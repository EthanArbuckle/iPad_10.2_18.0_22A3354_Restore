void sub_20D967904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D9687D8(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x212BAC9D8](v2, 0x1090C4018C15A78);

  _Unwind_Resume(a1);
}

void sub_20D968C58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9694CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  void *v59;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void voicetrigger::VTAudioCircularBufferImpl<unsigned short>::copySamples(uint64_t *a1, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  NSObject *v14;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  const void **v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint8_t buf[4];
  unint64_t v28;
  __int16 v29;
  unint64_t v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  unint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v7 = a2[3];
  v8 = a2[5];
  if (v8 >= v7)
    v9 = v8 - v7;
  else
    v9 = 0;
  if (v9 > a3 || a4 <= a3 || v8 < a4 || v8 <= a3 || v9 >= a4)
  {
    v14 = VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134349824;
      v28 = a3;
      v29 = 2050;
      v30 = a4;
      v31 = 2050;
      v32 = v9;
      v33 = 2050;
      v34 = v8;
      _os_log_error_impl(&dword_20D965000, v14, OS_LOG_TYPE_ERROR, "Invalid request: reqStartSample=%{public}ld, reqEndSample=%{public}ld, oldestSampleInBuffer: %{public}ld, latestSampleInBuffer=%{public}ld", buf, 0x2Au);
    }
    *a1 = 0;
  }
  else
  {
    v26 = a4 - a3;
    v16 = operator new[]();
    *a1 = v16;
    v17 = *a2;
    if (*a2)
    {
      v18 = (char *)v16;
      v19 = a3 % v7;
      v20 = (const void **)a2[7];
      v21 = 2 * v26;
      if (a3 % v7 >= a4 % v7)
      {
        v23 = 0;
        v24 = (char *)v16;
        do
        {
          v25 = (char *)*v20++;
          memcpy(v24, &v25[2 * v19], 2 * (v7 - v19));
          memcpy(&v18[2 * v23 * v26 + 2 * (v7 - v19)], v25, 2 * (v26 - (v7 - v19)));
          ++v23;
          v24 += v21;
          --v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v22 = (uint64_t)*v20++;
          memcpy(v18, (const void *)(v22 + 2 * v19), v21);
          v18 += v21;
          --v17;
        }
        while (v17);
      }
    }
  }
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x24BEDB7F0];
  v3 = *MEMORY[0x24BEDB7F0];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB7F0];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8](a1 + 128);
  return a1;
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24C7EFC48, MEMORY[0x24BEDAAF0]);
}

void sub_20D969880(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  size_t v16;
  std::locale::__imp *p_b;
  uint64_t v18;
  uint64_t v19;
  void *locale;
  uint64_t v21;
  uint64_t v22;
  _BYTE v24[16];
  std::locale __b;
  size_t v26;
  int64_t v27;

  MEMORY[0x212BAC918](v24, a1);
  if (v24[0])
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *((_QWORD *)v6 + 5);
    v8 = *((_DWORD *)v6 + 2);
    v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&__b, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20)
      v12 = a2 + a3;
    else
      v12 = a2;
    if (!v7)
      goto LABEL_30;
    v13 = *((_QWORD *)v6 + 3);
    v14 = v13 <= a3;
    v15 = v13 - a3;
    v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_30;
    }
    if ((uint64_t)v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      if (v16 >= 0x17)
      {
        v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17)
          v18 = v16 | 7;
        v19 = v18 + 1;
        p_b = (std::locale::__imp *)operator new(v18 + 1);
        v26 = v16;
        v27 = v19 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v27) = v16;
        p_b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v9, v16);
      *((_BYTE *)p_b + v16) = 0;
      if (v27 >= 0)
        locale = &__b;
      else
        locale = __b.__locale_;
      v21 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v7 + 96))(v7, locale, v16);
      v22 = v21;
      if (SHIBYTE(v27) < 0)
      {
        operator delete(__b.__locale_);
        if (v22 != v16)
        {
LABEL_30:
          std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
          goto LABEL_31;
        }
      }
      else if (v21 != v16)
      {
        goto LABEL_30;
      }
    }
    if (v11 - v12 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v12, v11 - v12) != v11 - v12)
    {
      goto LABEL_30;
    }
    *((_QWORD *)v6 + 3) = 0;
  }
LABEL_31:
  MEMORY[0x212BAC924](v24);
  return a1;
}

void sub_20D969AE4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _QWORD *v17;

  if (a17 < 0)
    operator delete(__p);
  MEMORY[0x212BAC924](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x20D969AB8);
}

void sub_20D969B44(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB800];
  v3 = *MEMORY[0x24BEDB800];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB800];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x212BAC9A8](a1 + 112);
  return a1;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

void sub_20D969DAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C80BDFB0063);
  _Unwind_Resume(a1);
}

void std::vector<unsigned short const*>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

const NString *NConfigSectionExt::sOpt(NConfigSectionExt *this, const NString *a2, const NString *a3)
{
  char *v6;
  const char *v7;

  v6 = (char *)this + 24;
  if (!NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return a3;
  if (!NMap<NString,NString>::contains((uint64_t)v6, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v7, *((_QWORD *)a2 + 2), *((_QWORD *)this + 2));
  return (const NString *)NMap<NString,NString>::operator[]((uint64_t)v6, (uint64_t)a2);
}

float NConfigSectionExt::fOpt(NConfigSectionExt *this, const NString *a2, const float *a3)
{
  if (NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return NConfigSection::fOpt(this, a2);
  else
    return *a3;
}

uint64_t NConfigSectionExt::iOpt(NConfigSectionExt *this, const NString *a2, const int *a3)
{
  if (NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return NConfigSection::iOpt(this, a2);
  else
    return *(unsigned int *)a3;
}

uint64_t NConfigSectionExt::bOpt(NConfigSectionExt *this, const NString *a2, const BOOL *a3)
{
  if (NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return NConfigSection::bOpt(this, a2);
  else
    return *(unsigned __int8 *)a3;
}

void sub_20D96A99C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D96AB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__111(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__112(uint64_t a1)
{

}

void sub_20D96B384(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;

  if (a2)
  {
    MEMORY[0x212BAC9D8](v2, 0x10F0C404F423172);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x20D96B1F0);
  }
  _Unwind_Resume(exception_object);
}

void sub_20D96BAF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__182(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__183(uint64_t a1)
{

}

void sub_20D96C7DC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int128 buf)
{
  uint64_t v17;
  void *v19;
  NSObject *v20;
  _BOOL4 v21;
  uint64_t (*v22)(void *);
  NSObject *v23;
  uint64_t v24;

  if (a2)
  {
    v19 = __cxa_begin_catch(a1);
    v20 = *(NSObject **)(v17 + 2744);
    v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (a2 == 2)
    {
      if (v21)
      {
        v22 = *(uint64_t (**)(void *))(*(_QWORD *)v19 + 16);
        v23 = v20;
        v24 = v22(v19);
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = v24;
        _os_log_impl(&dword_20D965000, v23, OS_LOG_TYPE_DEFAULT, "TDSR:: Exception creating VTTextDependentSpeakerRecognizer: %{public}s", (uint8_t *)&buf, 0xCu);

      }
    }
    else if (v21)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_20D965000, v20, OS_LOG_TYPE_DEFAULT, "TDSR:: Unknown exception creating VTTextDependentSpeakerRecognizer", (uint8_t *)&buf, 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x20D96C758);
  }
  _Unwind_Resume(a1);
}

void sub_20D96D210(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_20D96D284(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D96D310(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D96D62C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_20D96DB14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D96DD48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D96DEB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D96DEC0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf)
{
  uint64_t v11;
  uint64_t v12;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  id WeakRetained;
  NSObject *v21;
  void *v22;
  id v23;

  if (a2)
  {
    v14 = __cxa_begin_catch(a1);
    v15 = *(void **)(v11 + 32);
    if (a2 == 2)
    {
      objc_msgSend(v15, "setTdPsrCanProcessRequest:", 0);
      v16 = (void *)MEMORY[0x24BDD17C8];
      (*(void (**)(void *))(*(_QWORD *)v14 + 16))(v14);
      objc_msgSend(v16, "stringWithFormat:", CFSTR("Exception ending audio: %s"));
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = *(NSObject **)(v12 + 2744);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v17;
        _os_log_impl(&dword_20D965000, v18, OS_LOG_TYPE_DEFAULT, "TDSR:: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      +[VTTextDependentSpeakerRecognizer errorWithCode:message:](VTTextDependentSpeakerRecognizer, "errorWithCode:message:", 1003, v17);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(v11 + 32) + 40));
      objc_msgSend(WeakRetained, "textDependentSpeakerRecognizer:failedWithError:", *(_QWORD *)(v11 + 32), v19);

      __cxa_end_catch();
    }
    else
    {
      objc_msgSend(v15, "setTdPsrCanProcessRequest:", 0);
      v21 = *(NSObject **)(v12 + 2744);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_20D965000, v21, OS_LOG_TYPE_DEFAULT, "TDSR:: Unknown Exception adding audio:", (uint8_t *)&buf, 2u);
      }
      +[VTTextDependentSpeakerRecognizer errorWithCode:message:](VTTextDependentSpeakerRecognizer, "errorWithCode:message:", 1003, CFSTR("Unknown exception adding audio"));
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      v23 = objc_loadWeakRetained((id *)(*(_QWORD *)(v11 + 32) + 40));
      objc_msgSend(v23, "textDependentSpeakerRecognizer:failedWithError:", *(_QWORD *)(v11 + 32), v22);

      __cxa_end_catch();
    }
    JUMPOUT(0x20D96DE7CLL);
  }
  _Unwind_Resume(a1);
}

void sub_20D96E1A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D96E1B4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf)
{
  uint64_t v11;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  NSObject *v17;
  void *v18;
  id WeakRetained;
  NSObject *v20;
  void *v21;
  id v22;

  if (a2)
  {
    v13 = __cxa_begin_catch(a1);
    v14 = *(void **)(v11 + 32);
    if (a2 == 2)
    {
      objc_msgSend(v14, "setTdPsrCanProcessRequest:", 0);
      v15 = (void *)MEMORY[0x24BDD17C8];
      (*(void (**)(void *))(*(_QWORD *)v13 + 16))(v13);
      objc_msgSend(v15, "stringWithFormat:", CFSTR("Exception adding audio: %s"));
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      v17 = VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v16;
        _os_log_impl(&dword_20D965000, v17, OS_LOG_TYPE_DEFAULT, "TDSR:: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      +[VTTextDependentSpeakerRecognizer errorWithCode:message:](VTTextDependentSpeakerRecognizer, "errorWithCode:message:", 1002, v16);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(v11 + 32) + 40));
      objc_msgSend(WeakRetained, "textDependentSpeakerRecognizer:failedWithError:", *(_QWORD *)(v11 + 32), v18);

      __cxa_end_catch();
    }
    else
    {
      objc_msgSend(v14, "setTdPsrCanProcessRequest:", 0);
      v20 = VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_20D965000, v20, OS_LOG_TYPE_DEFAULT, "TDSR:: Unknown Exception adding audio:", (uint8_t *)&buf, 2u);
      }
      +[VTTextDependentSpeakerRecognizer errorWithCode:message:](VTTextDependentSpeakerRecognizer, "errorWithCode:message:", 1002, CFSTR("Unknown exception adding audio"));
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = objc_loadWeakRetained((id *)(*(_QWORD *)(v11 + 32) + 40));
      objc_msgSend(v22, "textDependentSpeakerRecognizer:failedWithError:", *(_QWORD *)(v11 + 32), v21);

      __cxa_end_catch();
    }
    JUMPOUT(0x20D96E170);
  }
  _Unwind_Resume(a1);
}

void sub_20D96E6C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v2;

  _Unwind_Resume(a1);
}

void sub_20D96EA78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_20D96EB7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_20D96ED74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::buildBlob(BlobBuilder *this, const NConfig *a2, N16ByteAlignedString *a3, int a4)
{
  int v5;
  const char *v13;
  uint64_t v14;
  _BYTE v16[64];
  __int128 v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t (**v23)();
  uint64_t v24;
  int v25;
  uint64_t (**v26)();
  uint64_t v27;
  int v28;
  uint64_t (**v29)();
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  __int128 v36;
  uint64_t v37;
  char v38;
  _BYTE v39[11];
  char v40;
  __int16 v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  void (**v46)(NPhoneHMMArray *__hidden);
  uint64_t v47;
  int v48;
  uint64_t (**v49)();
  uint64_t (**v50)();
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t (**v54)(N16ByteAlignedString *__hidden, const unsigned int *);
  int v55;
  void *v56;
  unsigned int v57;
  _BYTE v58[392];
  uint64_t (**v59)();
  uint64_t v60;
  int v61;
  uint64_t (**v62)();
  uint64_t v63;
  int v64;
  uint64_t (**v65)();
  uint64_t v66;
  int v67;
  char v68;
  char v69;
  uint64_t (**v70)();
  uint64_t v71;
  int v72;
  uint64_t v73;
  char v74;
  uint64_t (**v75)();
  uint64_t v76;
  int v77;
  char v78;
  char v79;
  uint64_t (**v80)();
  uint64_t v81;
  int v82;
  uint64_t (**v83)();
  uint64_t v84;
  int v85;
  uint64_t (**v86)();
  uint64_t v87;
  int v88;
  char v89;
  char v90;
  uint64_t (**v91)();
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t (**v95)();
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t (**v100)();
  uint64_t v101;
  int v102;
  uint64_t (**v103)();
  uint64_t v104;
  int v105;
  void (**v106)(NFrame *__hidden);
  uint64_t v107;
  int v108;
  char v109;
  int v110;
  uint64_t v111;
  int v112;
  int v113;
  __int128 v114;
  uint64_t v115;
  char v116;
  _BYTE v117[11];
  char v118;
  __int16 v119;
  char v120;
  uint64_t v121;
  void *memptr;

  v5 = (int)a3;
  v17 = xmmword_20DA24600;
  v18 = 0;
  v19 = 0;
  __asm { FMOV            V1.2S, #-1.0 }
  v20 = _D1;
  v21 = 1056964608;
  v22 = 1;
  v23 = &off_24C7F3090;
  v24 = 0;
  v25 = 0;
  v26 = &off_24C7F3090;
  v27 = 0;
  v28 = 0;
  v29 = &off_24C7F30C8;
  v30 = 0;
  v31 = 0;
  v32 = 0x4874240047C35000;
  v33 = 1064849900;
  v34 = 257;
  v35 = 26;
  v36 = xmmword_20DA24610;
  v37 = 0x160000000CLL;
  v38 = 1;
  *(_QWORD *)&v39[3] = 0x3F80000000000000;
  *(_DWORD *)v39 = 0;
  v40 = 0;
  v43 = 0x200000002;
  v42 = 0;
  v41 = 0;
  v44 = 51;
  v45 = 1065353216;
  v48 = 0;
  v46 = &off_24C7F18D0;
  v47 = 0;
  v52 = 0;
  v53 = 0;
  v50 = &off_24C7F2BF8;
  v51 = 0;
  v49 = &off_24C7F16B0;
  v54 = &off_24C7F2108;
  v57 = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v13, 1, v57);
  v55 = 0;
  v56 = memptr;
  v54 = &off_24C7F2108;
  *(_BYTE *)memptr = 0;
  NDeepnetDistribution::NDeepnetDistribution((NDeepnetDistribution *)v58);
  v58[384] = 0;
  v59 = &off_24C7F3090;
  v60 = 0;
  v61 = 0;
  v62 = &off_24C7F3090;
  v63 = 0;
  v64 = 0;
  v65 = &off_24C7F3090;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = &off_24C7F3090;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = &off_24C7F3090;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = &off_24C7F3100;
  v81 = 0;
  v82 = 0;
  v83 = &off_24C7F3020;
  v84 = 0;
  v85 = 0;
  v86 = &off_24C7F3090;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  v90 = 0;
  v92 = 0;
  v91 = &off_24C7F3388;
  v93 = 0;
  v94 = 0;
  v95 = &off_24C7F3090;
  v96 = 0;
  v97 = 0;
  v100 = &off_24C7F3090;
  v101 = 0;
  v102 = 0;
  v99 = 0;
  v98 = 0;
  v103 = &off_24C7F3090;
  v104 = 0;
  v105 = 0;
  v107 = 0;
  v108 = 0;
  v106 = &off_24C7F31A8;
  v109 = 0;
  v110 = 1203982336;
  v111 = 0x3F7851EC48742400;
  v112 = 257;
  v113 = 26;
  v114 = xmmword_20DA24610;
  v115 = 0x160000000CLL;
  v116 = 1;
  *(_DWORD *)v117 = 0;
  *(_QWORD *)&v117[3] = 0x3F80000000000000;
  v118 = 0;
  v121 = 0x200000002;
  v119 = 0;
  v120 = 0;
  v14 = BlobBuilder::build((BlobBuilder *)v16, this, a2, v5, a4);
  BlobBuilder::~BlobBuilder((BlobBuilder *)v16);
  return v14;
}

void sub_20D96F10C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  BlobBuilder::~BlobBuilder((BlobBuilder *)va);
  _Unwind_Resume(a1);
}

void sub_20D96F120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  void **v36;
  uint64_t v37;

  N16ByteAlignedString::~N16ByteAlignedString(v36);
  NPhoneHMMArray::~NPhoneHMMArray((NPhoneHMMArray *)(v37 + 272));
  if (a36)
    MEMORY[0x212BAC9C0](a36, 0x1000C8052888210);
  if (a33)
    MEMORY[0x212BAC9C0](a33, 0x1000C8052888210);
  if (a30)
    MEMORY[0x212BAC9C0](a30, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::build(BlobBuilder *this, const NConfig *a2, N16ByteAlignedString *a3, int a4, int a5)
{
  char *v10;
  uint64_t v11;
  char *v12;
  const char *v13;
  const NString *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  const char *v18;
  const NString *v19;
  char *v20;
  uint64_t v21;
  char *v22;
  const char *v23;
  const NString *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  const char *v28;
  const NString *v29;
  const char *v30;
  const NConfigSection *v31;
  const NConfigSection *v32;
  const NConfigSection *v33;
  const NConfigSection *v34;
  const char *v35;
  uint64_t v36;
  int v37;
  _DWORD *v38;
  uint64_t v39;
  _DWORD *v40;
  int v41;
  BlobBuilder *v42;
  const char *v43;
  uint64_t v44;
  int v45;
  size_t v46;
  void *v47;
  int v49;
  int v50;
  uint64_t (**v51)(NString *__hidden, const unsigned int *);
  int v52;
  char *v53;
  uint64_t (**v54)(NString *__hidden, const unsigned int *);
  int v55;
  char *v56;

  v54 = &off_24C7F32C0;
  v55 = 4;
  v10 = (char *)operator new[]();
  v56 = v10;
  strcpy(v10, "main");
  v11 = NConfig::section(a2, (const NString *)&v54);
  v51 = &off_24C7F32C0;
  v52 = 11;
  v12 = (char *)operator new[]();
  v53 = v12;
  strcpy(v12, "hmmdetector");
  if (!NMap<NString,NString>::contains(v11 + 24, (uint64_t)&v51))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v13, v12, *(_QWORD *)(v11 + 16));
  v14 = (const NString *)NMap<NString,NString>::operator[](v11 + 24, (uint64_t)&v51);
  MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  v54 = &off_24C7F32C0;
  v55 = 4;
  v15 = (char *)operator new[]();
  v56 = v15;
  strcpy(v15, "main");
  v16 = NConfig::section(a2, (const NString *)&v54);
  v50 = a5;
  v51 = &off_24C7F32C0;
  v52 = 15;
  v17 = (char *)operator new[]();
  v53 = v17;
  strcpy(v17, "rescoredetector");
  if (!NMap<NString,NString>::contains(v16 + 24, (uint64_t)&v51))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v18, v17, *(_QWORD *)(v16 + 16));
  v19 = (const NString *)NMap<NString,NString>::operator[](v16 + 24, (uint64_t)&v51);
  MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  v54 = &off_24C7F32C0;
  v55 = 4;
  v20 = (char *)operator new[]();
  v56 = v20;
  strcpy(v20, "main");
  v21 = NConfig::section(a2, (const NString *)&v54);
  v49 = a4;
  v51 = &off_24C7F32C0;
  v52 = 6;
  v22 = (char *)operator new[]();
  v53 = v22;
  strcpy(v22, "acanal");
  if (!NMap<NString,NString>::contains(v21 + 24, (uint64_t)&v51))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v23, v22, *(_QWORD *)(v21 + 16));
  v24 = (const NString *)NMap<NString,NString>::operator[](v21 + 24, (uint64_t)&v51);
  MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
  v54 = &off_24C7F32C0;
  v55 = 4;
  v25 = (char *)operator new[]();
  v56 = v25;
  strcpy(v25, "main");
  v26 = NConfig::section(a2, (const NString *)&v54);
  v51 = &off_24C7F32C0;
  v52 = 9;
  v27 = (char *)operator new[]();
  v53 = v27;
  strcpy(v27, "normalize");
  if (!NMap<NString,NString>::contains(v26 + 24, (uint64_t)&v51))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v28, v27, *(_QWORD *)(v26 + 16));
  v29 = (const NString *)NMap<NString,NString>::operator[](v26 + 24, (uint64_t)&v51);
  MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  if (!*((_DWORD *)v14 + 2))
    Error::chuck((Error *)"BlobBuilder: main.hmmdetector option compulsory", v30);
  if (!*((_DWORD *)v24 + 2))
    Error::chuck((Error *)"BlobBuilder: main.acanal option compulsory", v30);
  if (!*((_DWORD *)v19 + 2))
    Error::chuck((Error *)"BlobBuilder: main.rescoredetector option compulsory", v30);
  *((_BYTE *)this + 252) = 1;
  *((_BYTE *)this + 252) = *((_DWORD *)v29 + 2) != 0;
  v31 = (const NConfigSection *)NConfig::section(a2, v24);
  v32 = (const NConfigSection *)NConfig::section(a2, v14);
  v33 = (const NConfigSection *)NConfig::section(a2, v19);
  if (v50)
    *((_OWORD *)this + 3) = xmmword_20DA24620;
  BlobBuilder::buildDistBlob(this, v32);
  BlobBuilder::buildPhoneHmmArray(this, v32);
  BlobBuilder::buildAcAnalConfig(this, v31);
  if (*((_BYTE *)this + 252))
  {
    v34 = (const NConfigSection *)NConfig::section(a2, v29);
    BlobBuilder::buildNormConfig(this, v34);
  }
  BlobBuilder::buildDetectConfig(this, v31, v32, v33);
  BlobBuilder::buildConfgHeader((uint64_t)this, v50);
  v36 = *((unsigned int *)this + 97);
  if (*((_DWORD *)this + 342) * ((2 * *((unsigned __int8 *)this + 1388)) | 1) != (_DWORD)v36)
    Error::chuck((Error *)"BlobBuilder: feature and model dimension mismatch [%d != %d]", v35, *((_DWORD *)this + 342) * ((2 * *((unsigned __int8 *)this + 1388)) | 1u), v36);
  LODWORD(v54) = 48;
  (*(void (**)(N16ByteAlignedString *, BlobBuilder *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, this, &v54);
  if (v50)
  {
    LODWORD(v54) = 16;
    (*(void (**)(N16ByteAlignedString *, char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, (char *)this + 48, &v54);
    v37 = 192;
  }
  else
  {
    v37 = 176;
  }
  LODWORD(v54) = 44;
  (*(void (**)(N16ByteAlignedString *, char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, (char *)this + 64, &v54);
  v38 = (_DWORD *)operator new[]();
  *v38 = 0;
  LODWORD(v54) = 4;
  (*(void (**)(N16ByteAlignedString *, _DWORD *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, v38, &v54);
  MEMORY[0x212BAC9C0](v38, 0x1000C8077774924);
  LODWORD(v54) = 68;
  (*(void (**)(N16ByteAlignedString *, char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, (char *)this + 184, &v54);
  v39 = operator new[]();
  *(_QWORD *)v39 = 0;
  *(_DWORD *)(v39 + 8) = 0;
  LODWORD(v54) = 12;
  (*(void (**)(N16ByteAlignedString *, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, v39, &v54);
  MEMORY[0x212BAC9C0](v39, 0x1000C8077774924);
  if (*((_BYTE *)this + 252))
  {
    LODWORD(v54) = 12;
    (*(void (**)(N16ByteAlignedString *, char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, (char *)this + 256, &v54);
    v40 = (_DWORD *)operator new[]();
    *v40 = 0;
    LODWORD(v54) = 4;
    (*(void (**)(N16ByteAlignedString *, _DWORD *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, v40, &v54);
    MEMORY[0x212BAC9C0](v40, 0x1000C8077774924);
    v37 += 16;
  }
  v41 = BlobBuilder::serializeDistBlob(this, a3) + v37;
  v42 = (BlobBuilder *)BlobBuilder::serializeHmmArray(this, a3);
  v44 = (v41 + (_DWORD)v42);
  if (v49)
  {
    v45 = *((_DWORD *)a3 + 2);
    v46 = (40960 - v45);
    if (40960 - v45 <= 0)
      Error::chuck((Error *)"BlobBuilder: Cannot allocate heap", v43);
    v47 = (void *)operator new[]();
    bzero(v47, v46);
    LODWORD(v54) = v46;
    (*(void (**)(N16ByteAlignedString *, void *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 72))(a3, v47, &v54);
    v42 = (BlobBuilder *)MEMORY[0x212BAC9C0](v47, 0x1000C8077774924);
    v44 = (v46 + v44);
  }
  if (v50)
    BlobBuilder::insertChecksum(v42, a3);
  return v44;
}

void sub_20D96F99C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void BlobBuilder::~BlobBuilder(BlobBuilder *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *((_QWORD *)this + 163) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 164);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 160) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 161);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  AccelWin2MFCC::~AccelWin2MFCC((void **)this + 105);
  *((_QWORD *)this + 101) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 102);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 98) = &off_24C7F3090;
  v5 = *((_QWORD *)this + 99);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  *((_QWORD *)this + 95) = &off_24C7F3090;
  v6 = *((_QWORD *)this + 96);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  NDeepnetDistribution::~NDeepnetDistribution((BlobBuilder *)((char *)this + 368));
  *((_QWORD *)this + 42) = &off_24C7F2108;
  free(*((void **)this + 44));
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 42) = &off_24C7F32C0;
  NPhoneHMMArray::~NPhoneHMMArray((BlobBuilder *)((char *)this + 272));
  *((_QWORD *)this + 20) = &off_24C7F30C8;
  v7 = *((_QWORD *)this + 21);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  *((_QWORD *)this + 17) = &off_24C7F3090;
  v8 = *((_QWORD *)this + 18);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  *((_QWORD *)this + 14) = &off_24C7F3090;
  v9 = *((_QWORD *)this + 15);
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
}

_QWORD *NArray<int>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F30C8;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  return a1;
}

void NArray<int>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F30C8;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<int>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<int>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = 0;
    v10 = *(_QWORD *)(v4 + 8);
    do
    {
      *(_DWORD *)(v10 + 4 * v9) = *(_DWORD *)(a2 + 4 * v9);
      ++v9;
    }
    while (v9 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<int>::resize(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  int v17;

  v2 = *(_DWORD *)(result + 16);
  if (v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    LODWORD(v6) = *a2;
    if (v2 >= *a2)
      v6 = v6;
    else
      v6 = v2;
    if ((_DWORD)v6)
    {
      if (v6 >= 8 && (unint64_t)(result - v5) > 0x1F)
      {
        v8 = v6 & 0xFFFFFFF8;
        v9 = (_OWORD *)(result + 16);
        v10 = (__int128 *)(v5 + 16);
        v11 = v8;
        do
        {
          v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 8;
        }
        while (v11);
        if (v8 == v6)
LABEL_18:
          JUMPOUT(0x212BAC9C0);
      }
      else
      {
        v8 = 0;
      }
      v13 = v6 - v8;
      v14 = 4 * v8;
      v15 = (_DWORD *)(result + 4 * v8);
      v16 = (int *)(v5 + v14);
      do
      {
        v17 = *v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
      goto LABEL_18;
    }
    if (v5)
      goto LABEL_18;
  }
  return result;
}

_QWORD *NArray<float>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3090;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  return a1;
}

void NArray<float>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3090;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<float>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 8)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF8;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 4 * v7;
        v17 = (_DWORD *)(v9 + v16);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return a1;
}

float NArray<float>::fromArray(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int v5;
  int v6;
  uint64_t v7;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _OWORD *v14;
  __int128 *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int *v21;
  int v22;

  v5 = *(_DWORD *)(a1 + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(a1 + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
      v6 = *a3;
    }
    *(_DWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 8) = operator new[]();
    v5 = *(_DWORD *)(a1 + 16);
  }
  if (v5)
  {
    v10 = *(_QWORD *)(a1 + 8);
    v11 = v5;
    if (v5 < 8 || (unint64_t)(v10 - a2) <= 0x1F)
    {
      v13 = 0;
LABEL_14:
      v18 = v11 - v13;
      v19 = 4 * v13;
      v20 = (_DWORD *)(v10 + v19);
      v21 = (int *)(a2 + v19);
      do
      {
        v22 = *v21++;
        LODWORD(v9) = v22;
        *v20++ = v22;
        --v18;
      }
      while (v18);
      return *(float *)&v9;
    }
    v13 = v5 & 0xFFFFFFF8;
    v14 = (_OWORD *)(v10 + 16);
    v15 = (__int128 *)(a2 + 16);
    v16 = v11 & 0xFFFFFFF8;
    do
    {
      v9 = *(v15 - 1);
      v17 = *v15;
      *(v14 - 1) = v9;
      *v14 = v17;
      v14 += 2;
      v15 += 2;
      v16 -= 8;
    }
    while (v16);
    if (v13 != v11)
      goto LABEL_14;
  }
  return *(float *)&v9;
}

uint64_t NArray<float>::resize(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  int v17;

  v2 = *(_DWORD *)(result + 16);
  if (v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    LODWORD(v6) = *a2;
    if (v2 >= *a2)
      v6 = v6;
    else
      v6 = v2;
    if ((_DWORD)v6)
    {
      if (v6 >= 8 && (unint64_t)(result - v5) > 0x1F)
      {
        v8 = v6 & 0xFFFFFFF8;
        v9 = (_OWORD *)(result + 16);
        v10 = (__int128 *)(v5 + 16);
        v11 = v8;
        do
        {
          v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 8;
        }
        while (v11);
        if (v8 == v6)
LABEL_18:
          JUMPOUT(0x212BAC9C0);
      }
      else
      {
        v8 = 0;
      }
      v13 = v6 - v8;
      v14 = 4 * v8;
      v15 = (_DWORD *)(result + 4 * v8);
      v16 = (int *)(v5 + v14);
      do
      {
        v17 = *v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
      goto LABEL_18;
    }
    if (v5)
      goto LABEL_18;
  }
  return result;
}

void BlobBuilder::buildDistBlob(BlobBuilder *this, const NConfigSection *a2)
{
  const char *v4;
  char *v5;
  BOOL v6;
  const char *v7;
  char *v8;
  const char *v9;
  const NString *v10;
  const char *v11;
  unsigned int v12;
  _OWORD *v13;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  const char *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  void *v23;
  size_t v24;
  void *v25;
  const char *v26;
  _OWORD *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  const char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  unsigned int v35[2];
  unsigned int v36;
  uint64_t (**v37)(NString *__hidden, const unsigned int *);
  int v38;
  _BYTE *v39;
  uint64_t (**v40)(NString *__hidden, const unsigned int *);
  int v41;
  uint64_t v42;
  char v43[16];
  uint64_t (**v44)(NString *__hidden, const unsigned int *);
  int v45;
  char *v46;
  unsigned int v47[2];
  int v48;
  char *v49;
  unsigned int v50[2];
  unsigned int v51;
  void *v52;
  uint64_t (**v53)(N16ByteAlignedString *__hidden, const unsigned int *);
  unsigned int v54;
  void *v55;
  int v56;
  void *memptr;
  uint64_t v58;
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v53 = &off_24C7F2108;
  v56 = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v4, 1, 16);
  v54 = 0;
  v55 = memptr;
  v53 = &off_24C7F2108;
  *(_BYTE *)memptr = 0;
  memptr = &off_24C7F32C0;
  LODWORD(v58) = 16;
  v5 = (char *)operator new[]();
  v59 = v5;
  strcpy(v5, "output_dist_file");
  v6 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&memptr);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  if (!v6)
    Error::chuck((Error *)"BlobBuilder: hmmdetector:output_dist_file option compulsory", v7);
  *(_QWORD *)v47 = &off_24C7F32C0;
  v48 = 16;
  v8 = (char *)operator new[]();
  v49 = v8;
  strcpy(v8, "output_dist_file");
  if (!NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)v47))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v9, v8, *((_QWORD *)a2 + 2));
  v10 = (const NString *)NMap<NString,NString>::operator[]((uint64_t)a2 + 24, (uint64_t)v47);
  v44 = &off_24C7F32C0;
  v45 = 1;
  v46 = (char *)operator new[]();
  strcpy(v46, "r");
  NFile::NFile((NFile *)&memptr, v10, (const NString *)&v44);
  NFile::read((NFile *)&memptr, (uint64_t)v50);
  ((void (*)(uint64_t (***)(N16ByteAlignedString *__hidden, const unsigned int *), void *, unsigned int *))v53[8])(&v53, v52, &v51);
  *(_QWORD *)v50 = &off_24C7F32C0;
  if (v52)
    MEMORY[0x212BAC9C0](v52, 0x1000C8077774924);
  NFile::~NFile((NFile *)&memptr);
  v44 = &off_24C7F32C0;
  if (v46)
    MEMORY[0x212BAC9C0](v46, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  v12 = v54;
  if (v54 < 0x34)
  {
    v32 = "BlobBuilder: output_dist_file too small for valid DNNC";
LABEL_34:
    Error::chuck((Error *)v32, v11);
  }
  v13 = v55;
  if (*(_QWORD *)v55 != 0x20624C4E4E442023 || *((_QWORD *)v55 + 1) != 0xA0A0A30302E3176)
  {
    v32 = "BlobBuilder: output_dist_file missing DNNC cookie";
    goto LABEL_34;
  }
  memptr = &off_24C7F3100;
  v58 = 0;
  LODWORD(v59) = 0;
  if (!v55)
    Error::chuck((Error *)"Null pointer passed to string constructor", v11);
  v15 = operator new[]();
  v16 = v13[1];
  v17 = v13[2];
  *(_DWORD *)(v15 + 32) = *((_DWORD *)v13 + 12);
  *(_OWORD *)v15 = v16;
  *(_OWORD *)(v15 + 16) = v17;
  *(_BYTE *)(v15 + 36) = 0;
  v50[0] = 9;
  (*((void (**)(void **, uint64_t, unsigned int *))memptr + 3))(&memptr, v15, v50);
  MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  if ((*(_BYTE *)(v58 + 8) & 0x20) != 0)
    Error::chuck((Error *)"BlobBuilder: output_dist_file is 16bit fixedpoint", v18);
  v19 = (*(_DWORD *)(v58 + 32) + 55) & 0xFFFFFFFC;
  if (v12 < v19)
    Error::chuck((Error *)"BlobBuilder: output_dist_file too small for the comment", v18);
  v20 = (v19 + 15) & 0xFFFFFFF0;
  if (v20 != v19)
  {
    v21 = v54;
    if (v54 < 0x34)
    {
      v33 = 52;
      v34 = "Index %d outside of range [0,%d]";
    }
    else if (v19 > v54)
    {
      v34 = "Index %d outside of range [0,%d]";
      v33 = (*(_DWORD *)(v58 + 32) + 55) & 0xFFFFFFFC;
    }
    else
    {
      if (v19 > 0x33)
      {
        v22 = (char *)v55;
        *(_QWORD *)v50 = &off_24C7F32C0;
        if (v55)
        {
          v51 = v19 - 52;
          v23 = (void *)operator new[]();
          v24 = v20 - v19;
          v52 = v23;
          memcpy(v23, v22 + 52, v19 - 52);
          *((_BYTE *)v23 + v19 - 52) = 0;
          v25 = (void *)operator new[]();
          bzero(v25, v24);
          *((_BYTE *)v25 + v24) = 0;
          v47[0] = v24;
          (*(void (**)(NString *, const void *, const unsigned int *))(*(_QWORD *)v50 + 72))((NString *)v50, v25, v47);
          MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
          if (v54 > 0x2F)
          {
            v27 = v55;
            v40 = &off_24C7F32C0;
            if (v55)
            {
              v41 = 48;
              v28 = operator new[]();
              v42 = v28;
              v30 = v27[1];
              v29 = v27[2];
              *(_OWORD *)v28 = *v27;
              *(_OWORD *)(v28 + 16) = v30;
              *(_OWORD *)(v28 + 32) = v29;
              *(_BYTE *)(v28 + 48) = 0;
              v37 = &off_24C7F32C0;
              v38 = 0;
              v39 = (_BYTE *)operator new[]();
              *v39 = 0;
              v36 = v51;
              v35[0] = 4;
              ((void (*)(NString *, const void *, const unsigned int *))v37[9])((NString *)&v37, &v36, v35);
              NString::operator+((uint64_t)&v40, (uint64_t)&v37, (uint64_t)v43);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v26);
          }
          Error::chuck((Error *)"Index %d outside of range [0,%d]", v26, 48, v54);
        }
        Error::chuck((Error *)"Null pointer passed to string constructor", v18);
      }
      v33 = 52;
      v34 = "Start and end indices conflict, start [%d], end [%d]";
      v21 = (*(_DWORD *)(v58 + 32) + 55) & 0xFFFFFFFC;
    }
    Error::chuck((Error *)v34, v18, v33, v21);
  }
  if ((uint64_t (***)(N16ByteAlignedString *__hidden, const unsigned int *))((char *)this + 336) != &v53)
    (*(void (**)(char *, void *, unsigned int *))(*((_QWORD *)this + 42) + 64))((char *)this + 336, v55, &v54);
  *((_DWORD *)this + 90) = v56;
  v31 = (const char *)*((_QWORD *)this + 44);
  v50[0] = *((_DWORD *)this + 86);
  NDeepnetDistribution::init((BlobBuilder *)((char *)this + 368), v31, v50);
  memptr = &off_24C7F3100;
  if (v58)
    MEMORY[0x212BAC9C0](v58, 0x1000C8052888210);
  v53 = &off_24C7F2108;
  free(v55);
}

void sub_20D970A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  uint64_t v40;
  uint64_t v41;

  if (a31)
    MEMORY[0x212BAC9C0](a31, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v41, 0x1000C8077774924);
  if (a28)
    MEMORY[0x212BAC9C0](a28, 0x1000C8077774924);
  if (a25)
    MEMORY[0x212BAC9C0](a25, 0x1000C8077774924);
  if (a19)
    MEMORY[0x212BAC9C0](a19, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v40, 0x1000C8077774924);
  if (a34)
    MEMORY[0x212BAC9C0](a34, 0x1000C8077774924);
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8052888210);
  N16ByteAlignedString::~N16ByteAlignedString(&a35);
  _Unwind_Resume(a1);
}

void BlobBuilder::buildPhoneHmmArray(BlobBuilder *this, const NConfigSection *a2)
{
  char *v4;
  BOOL v5;
  const char *v6;
  char *v7;
  const char *v8;
  const NString *v9;
  unsigned int v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  int v12;
  char *v13;

  v11 = &off_24C7F32C0;
  v12 = 8;
  v4 = (char *)operator new[]();
  v13 = v4;
  strcpy(v4, "hmm_file");
  v5 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v11);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (v5)
  {
    v11 = &off_24C7F32C0;
    v12 = 8;
    v7 = (char *)operator new[]();
    v13 = v7;
    strcpy(v7, "hmm_file");
    if (NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v11))
    {
      v9 = (const NString *)NMap<NString,NString>::operator[]((uint64_t)a2 + 24, (uint64_t)&v11);
      v10 = *((_DWORD *)this + 94);
      NPhoneHMMArray::read((BlobBuilder *)((char *)this + 272), v9, &v10);
      JUMPOUT(0x212BAC9C0);
    }
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v8, v7, *((_QWORD *)a2 + 2));
  }
  Error::chuck((Error *)"BlobBuilder: hmmdetector:hmm_file option compulsory", v6);
}

void sub_20D970D68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::buildAcAnalConfig(BlobBuilder *this, const NConfigSection *a2)
{
  char *v4;
  char *v5;
  BOOL v6;
  uint64_t result;
  char *v8;
  int v9;
  char *v10;
  const char *v11;
  uint64_t (***v12)(NString *__hidden, const unsigned int *);
  _BYTE *v13;
  char *v14;
  uint64_t v15;
  const char *v16;
  const NString *v17;
  char *v18;
  const NConfigSection *v19;
  char *v20;
  NConfigSection *v21;
  BlobBuilder *v22;
  uint64_t v23;
  float *v24;
  char *v25;
  float v26;
  char *v27;
  float v28;
  char *v29;
  float v30;
  char *v31;
  char v32;
  char *v33;
  char v34;
  char *v35;
  char v36;
  char *v37;
  int v38;
  char *v39;
  float v40;
  char *v41;
  float v42;
  char *v43;
  float v44;
  char *v45;
  float v46;
  char *v47;
  int v48;
  char *v49;
  int v50;
  char *v51;
  char *v52;
  float v53;
  char *v54;
  float v55;
  char *v56;
  char v57;
  char *v58;
  char v59;
  char *v60;
  int v61;
  char *v62;
  uint64_t v63;
  char *v64;
  char *v65;
  uint64_t i;
  uint64_t (**v67)(NString *__hidden, const unsigned int *);
  int v68;
  _BYTE *v69;
  uint64_t (**v70)(NString *__hidden, const unsigned int *);
  int v71;
  void *v72;
  uint64_t (**v73)();
  uint64_t (**v74)();
  char *v75;
  BOOL v76[8];
  int v77;
  char *v78;

  v73 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v74) = 11;
  v4 = (char *)operator new[]();
  v75 = v4;
  strcpy(v4, "acanal_file");
  if (!NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v73))
  {
    v14 = v4;
    v15 = 0x1000C8077774924;
    return MEMORY[0x212BAC9C0](v14, v15);
  }
  *(_QWORD *)v76 = &off_24C7F32C0;
  v77 = 10;
  v5 = (char *)operator new[]();
  v78 = v5;
  strcpy(v5, "confstring");
  v6 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)v76);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  result = MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (v6)
  {
    v76[0] = 1;
    NConfig::NConfig((NConfig *)&v73, v76);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 10;
    v8 = (char *)operator new[]();
    v78 = v8;
    strcpy(v8, "confstring");
    v9 = NConfigSection::bOpt(a2, (const NString *)v76);
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
    if (v9)
    {
      *(_QWORD *)v76 = &off_24C7F32C0;
      v77 = 11;
      v10 = (char *)operator new[]();
      v78 = v10;
      strcpy(v10, "acanal_file");
      if (!NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)v76))
        Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v11, v10, *((_QWORD *)a2 + 2));
      v12 = (uint64_t (***)(NString *__hidden, const unsigned int *))NMap<NString,NString>::operator[]((uint64_t)a2 + 24, (uint64_t)v76);
      v70 = &off_24C7F32C0;
      v71 = 0;
      v72 = (void *)operator new[]();
      bzero(v72, 1uLL);
      v67 = &off_24C7F32C0;
      v68 = 0;
      v13 = (_BYTE *)operator new[]();
      v69 = v13;
      *v13 = 0;
      NConfig::loadString((NConfig *)&v73, v12, (const NString *)&v70, (const NString *)&v67);
      MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
    }
    else
    {
      *(_QWORD *)v76 = &off_24C7F32C0;
      v77 = 11;
      v10 = (char *)operator new[]();
      v78 = v10;
      strcpy(v10, "acanal_file");
      if (!NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)v76))
        Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v16, v10, *((_QWORD *)a2 + 2));
      v17 = (const NString *)NMap<NString,NString>::operator[]((uint64_t)a2 + 24, (uint64_t)v76);
      v70 = &off_24C7F32C0;
      v71 = 0;
      v72 = (void *)operator new[]();
      bzero(v72, 1uLL);
      NConfig::load((NConfig *)&v73, v17, (const NString *)&v70);
    }
    v70 = &off_24C7F32C0;
    if (v72)
      MEMORY[0x212BAC9C0](v72, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 0;
    v18 = (char *)operator new[]();
    v78 = v18;
    *v18 = 0;
    v19 = (const NConfigSection *)NConfig::section((NConfig *)&v73, (const NString *)v76);
    MEMORY[0x212BAC9C0](v18, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 0;
    v20 = (char *)operator new[]();
    v78 = v20;
    *v20 = 0;
    v21 = (NConfigSection *)NConfig::section((NConfig *)&v73, (const NString *)v76);
    v22 = (BlobBuilder *)MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
    v23 = BlobBuilder::sanityCheckAcAnalOption(v22, v19);
    v24 = (float *)((char *)this + 184);
    BlobBuilder::analysisTargetKind(v23, (uint64_t)v19, (_BYTE *)this + 184);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 10;
    v25 = (char *)operator new[]();
    v78 = v25;
    strcpy(v25, "TARGETRATE");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v26 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v26 = *v24;
    *v24 = v26;
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 10;
    v27 = (char *)operator new[]();
    v78 = v27;
    strcpy(v27, "WINDOWSIZE");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v28 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v28 = *((float *)this + 47);
    *((float *)this + 47) = v28;
    MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 9;
    v29 = (char *)operator new[]();
    v78 = v29;
    strcpy(v29, "PREEMCOEF");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v30 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v30 = *((float *)this + 48);
    *((float *)this + 48) = v30;
    MEMORY[0x212BAC9C0](v29, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 11;
    v31 = (char *)operator new[]();
    v78 = v31;
    strcpy(v31, "ZMEANSOURCE");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v32 = NConfigSection::bOpt(v21, (const NString *)v76);
    else
      v32 = *((_BYTE *)this + 196) != 0;
    *((_BYTE *)this + 196) = v32;
    MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 10;
    v33 = (char *)operator new[]();
    v78 = v33;
    strcpy(v33, "USEHAMMING");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v34 = NConfigSection::bOpt(v21, (const NString *)v76);
    else
      v34 = *((_BYTE *)this + 197) != 0;
    *((_BYTE *)this + 197) = v34;
    MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 8;
    v35 = (char *)operator new[]();
    v78 = v35;
    strcpy(v35, "USEPOWER");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v36 = NConfigSection::bOpt(v21, (const NString *)v76);
    else
      v36 = *((_BYTE *)this + 199) != 0;
    *((_BYTE *)this + 199) = v36;
    MEMORY[0x212BAC9C0](v35, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 8;
    v37 = (char *)operator new[]();
    v78 = v37;
    strcpy(v37, "NUMCHANS");
    v38 = *((_DWORD *)this + 50);
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v38 = NConfigSection::iOpt(v21, (const NString *)v76);
    *((_DWORD *)this + 50) = v38;
    MEMORY[0x212BAC9C0](v37, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 6;
    v39 = (char *)operator new[]();
    v78 = v39;
    strcpy(v39, "LOFREQ");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v40 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v40 = *((float *)this + 51);
    *((float *)this + 51) = v40;
    MEMORY[0x212BAC9C0](v39, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 6;
    v41 = (char *)operator new[]();
    v78 = v41;
    strcpy(v41, "HIFREQ");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v42 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v42 = *((float *)this + 52);
    *((float *)this + 52) = v42;
    MEMORY[0x212BAC9C0](v41, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 9;
    v43 = (char *)operator new[]();
    v78 = v43;
    strcpy(v43, "freqscale");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v44 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v44 = *((float *)this + 53);
    *((float *)this + 53) = v44;
    MEMORY[0x212BAC9C0](v43, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 5;
    v45 = (char *)operator new[]();
    v78 = v45;
    strcpy(v45, "MINBW");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v46 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v46 = *((float *)this + 54);
    *((float *)this + 54) = v46;
    MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 7;
    v47 = (char *)operator new[]();
    v78 = v47;
    *(_QWORD *)v47 = 0x535045434D554ELL;
    v48 = *((_DWORD *)this + 55);
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v48 = NConfigSection::iOpt(v21, (const NString *)v76);
    *((_DWORD *)this + 55) = v48;
    MEMORY[0x212BAC9C0](v47, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 9;
    v49 = (char *)operator new[]();
    v78 = v49;
    strcpy(v49, "CEPLIFTER");
    v50 = *((_DWORD *)this + 56);
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v50 = NConfigSection::iOpt(v21, (const NString *)v76);
    *((_DWORD *)this + 56) = v50;
    MEMORY[0x212BAC9C0](v49, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 13;
    v51 = (char *)operator new[]();
    v78 = v51;
    strcpy(v51, "logical_order");
    *((_BYTE *)this + 229) = NConfigSection::bOpt(a2, (const NString *)v76);
    MEMORY[0x212BAC9C0](v51, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 8;
    v52 = (char *)operator new[]();
    v78 = v52;
    strcpy(v52, "MELFLOOR");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v53 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v53 = *((float *)this + 58);
    *((float *)this + 58) = v53;
    MEMORY[0x212BAC9C0](v52, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 8;
    v54 = (char *)operator new[]();
    v78 = v54;
    strcpy(v54, "MELSCALE");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v55 = NConfigSection::fOpt(v21, (const NString *)v76);
    else
      v55 = *((float *)this + 59);
    *((float *)this + 59) = v55;
    MEMORY[0x212BAC9C0](v54, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 10;
    v56 = (char *)operator new[]();
    v78 = v56;
    strcpy(v56, "FRAMEINPUT");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v57 = NConfigSection::bOpt(v21, (const NString *)v76);
    else
      v57 = *((_BYTE *)this + 230) != 0;
    *((_BYTE *)this + 230) = v57;
    MEMORY[0x212BAC9C0](v56, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 9;
    v58 = (char *)operator new[]();
    v78 = v58;
    strcpy(v58, "FIPUSELOG");
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v59 = NConfigSection::bOpt(v21, (const NString *)v76);
    else
      v59 = *((_BYTE *)this + 231) != 0;
    *((_BYTE *)this + 231) = v59;
    MEMORY[0x212BAC9C0](v58, 0x1000C8077774924);
    *(_QWORD *)v76 = &off_24C7F32C0;
    v77 = 11;
    v60 = (char *)operator new[]();
    v78 = v60;
    strcpy(v60, "sample_rate");
    v61 = *((_DWORD *)this + 16);
    if (NMap<NString,NString>::contains((uint64_t)v21 + 24, (uint64_t)v76))
      v61 = NConfigSection::iOpt(v21, (const NString *)v76);
    LODWORD(v70) = v61;
    NDEAcAnal::init((uint64_t)this + 752, (uint64_t)this + 184, (unsigned int *)&v70);
    result = MEMORY[0x212BAC9C0](v60, 0x1000C8077774924);
    v73 = &off_24C7F2A90;
    v74 = &off_24C7F2C68;
    v62 = v75;
    if (v75)
    {
      v63 = *((_QWORD *)v75 - 1);
      if (v63)
      {
        v64 = &v75[32 * v63];
        v65 = v64;
        do
        {
          *((_QWORD *)v65 - 4) = off_24C7F1420;
          v65 -= 32;
          for (i = *((_QWORD *)v65 + 1); i; i = *((_QWORD *)v64 - 3))
          {
            *((_QWORD *)v64 - 3) = *(_QWORD *)(i + 8);
            (*(void (**)(char *))(*((_QWORD *)v64 - 4) + 72))(v65);
          }
          *((_QWORD *)v64 - 2) = 0;
          *((_DWORD *)v64 - 2) = 0;
          v64 = v65;
        }
        while (v65 != v62);
      }
      v14 = v62 - 16;
      v15 = 0x10A1C80F4A7E088;
      return MEMORY[0x212BAC9C0](v14, v15);
    }
  }
  return result;
}

void sub_20D971C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  uint64_t v11;
  va_list va;

  va_start(va, a10);
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  if (a10)
    MEMORY[0x212BAC9C0](a10, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  NConfig::~NConfig((NConfig *)va);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::buildNormConfig(BlobBuilder *this, const NConfigSection *a2)
{
  char *v4;
  int v5;
  char *v6;
  int v7;
  char *v8;
  float v9;
  char *v10;
  uint64_t v11;
  uint64_t result;
  const char *v13;
  uint64_t (**v14)(NString *__hidden, const unsigned int *);
  int v15;
  char *v16;

  v14 = &off_24C7F32C0;
  v15 = 11;
  v4 = (char *)operator new[]();
  v16 = v4;
  strcpy(v4, "window_size");
  v5 = *((_DWORD *)this + 64);
  if (NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v14))
    v5 = NConfigSection::iOpt(a2, (const NString *)&v14);
  *((_DWORD *)this + 64) = v5;
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v14 = &off_24C7F32C0;
  v15 = 13;
  v6 = (char *)operator new[]();
  v16 = v6;
  strcpy(v6, "window_offset");
  if (NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v14))
    v7 = NConfigSection::iOpt(a2, (const NString *)&v14);
  else
    v7 = *((_DWORD *)this + 65);
  *((_DWORD *)this + 65) = v7;
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  v14 = &off_24C7F32C0;
  v15 = 12;
  v8 = (char *)operator new[]();
  v16 = v8;
  strcpy(v8, "decay_factor");
  if (NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v14))
    v9 = NConfigSection::fOpt(a2, (const NString *)&v14);
  else
    v9 = *((float *)this + 66);
  *((float *)this + 66) = v9;
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  v14 = &off_24C7F32C0;
  v15 = 10;
  v10 = (char *)operator new[]();
  v16 = v10;
  strcpy(v10, "min_frames");
  if (!NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v14))
    return MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  v11 = NConfigSection::iOpt(a2, (const NString *)&v14);
  result = MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  if ((_DWORD)v11)
    Error::chuck((Error *)"BlobBuilder: non-zero min_frames %d option not supported", v13, v11);
  return result;
}

void sub_20D97211C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::buildDetectConfig(BlobBuilder *this, const NConfigSection *a2, const NConfigSection *a3, const NConfigSection *a4)
{
  char *v8;
  int v9;
  char *v10;
  int v11;
  char *v12;
  int v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  char *v18;
  float v19;
  char *v20;
  float v21;
  char *v22;
  const char *v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  int v27;
  char *v28;
  const char *v29;
  uint64_t v30;
  unsigned int v31;
  char *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  char *v36;
  char *v37;
  _BYTE *v38;
  const char *v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _OWORD *v50;
  __int128 *v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  int *v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  unint64_t v61;
  int v62;
  const char *v63;
  char *v64;
  _BOOL4 v65;
  char *v66;
  const char *v67;
  uint64_t v68;
  void *v69;
  const char *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  float v75;
  int v76;
  float v77;
  unint64_t v78;
  unsigned int v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int *v87;
  int *v88;
  _DWORD *v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _OWORD *v95;
  __int128 *v96;
  uint64_t v97;
  __int128 v98;
  uint64_t v99;
  uint64_t v100;
  _DWORD *v101;
  int *v102;
  int v103;
  char *v104;
  _BOOL4 v105;
  char *v106;
  const char *v107;
  uint64_t v108;
  char *v109;
  const char *v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  _OWORD *v122;
  __int128 *v123;
  uint64_t v124;
  __int128 v125;
  uint64_t v126;
  uint64_t v127;
  _DWORD *v128;
  int *v129;
  int v130;
  unsigned int v131;
  uint64_t v132;
  unsigned int v133;
  int v134;
  float v135;
  char *v136;
  float v137;
  uint64_t result;
  const char *v139;
  char v140;
  char *v141;
  char *v142;
  char v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  unint64_t v157;
  unint64_t v158;
  BOOL v160;
  float *v162;
  uint64_t v163;
  uint64_t v164;
  float *v165;
  uint64_t v166;
  const char *v167;
  uint64_t v168;
  const char *v169;
  _BYTE *v170;
  char *v171;
  __int128 v172;
  unsigned int v173;
  uint64_t (**v174)(NString *__hidden, const unsigned int *);
  int v175;
  char *v176;
  uint64_t (**v177)(NString *__hidden, const unsigned int *);
  int v178;
  void *v179;
  uint64_t (**v180)(NString *__hidden, const unsigned int *);
  int v181;
  void *v182;
  uint64_t (**v183)(NString *__hidden, const unsigned int *);
  int v184;
  char *v185;
  char *v186;
  int v187;
  char *v188;
  char *v189;
  uint64_t v190;
  _QWORD *v191;
  uint64_t (**v192)();
  uint64_t v193;
  char *v194;
  uint64_t (**v195)();
  uint64_t v196;
  char *v197;
  float32x4x2_t v198;
  float32x4x2_t v199;

  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 11;
  v8 = (char *)operator new[]();
  v197 = v8;
  strcpy(v8, "sample_rate");
  v9 = *((_DWORD *)this + 16);
  if (NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v195))
    v9 = NConfigSection::iOpt(a2, (const NString *)&v195);
  *((_DWORD *)this + 16) = v9;
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 22;
  v10 = (char *)operator new[]();
  v197 = v10;
  strcpy(v10, "expected_interval_secs");
  v11 = *((_DWORD *)this + 19);
  if (NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    v11 = NConfigSection::iOpt(a3, (const NString *)&v195);
  *((_DWORD *)this + 19) = v11;
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 10;
  v12 = (char *)operator new[]();
  v197 = v12;
  strcpy(v12, "frame_skip");
  v13 = *((_DWORD *)this + 21);
  if (NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    v13 = NConfigSection::iOpt(a3, (const NString *)&v195);
  *((_DWORD *)this + 21) = v13;
  MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 14;
  v14 = (char *)operator new[]();
  v197 = v14;
  strcpy(v14, "latency_offset");
  if (NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    v15 = NConfigSection::iOpt(a3, (const NString *)&v195);
  else
    v15 = *((_DWORD *)this + 20);
  *((_DWORD *)this + 20) = v15;
  MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 16;
  v16 = (char *)operator new[]();
  v197 = v16;
  strcpy(v16, "early_warn_state");
  v17 = *((_DWORD *)this + 22);
  if (NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    v17 = NConfigSection::iOpt(a3, (const NString *)&v195);
  *((_DWORD *)this + 22) = v17;
  MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 16;
  v18 = (char *)operator new[]();
  v197 = v18;
  strcpy(v18, "early_warn_thres");
  if (NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    v19 = NConfigSection::fOpt(a3, (const NString *)&v195);
  else
    v19 = *((float *)this + 24);
  *((float *)this + 24) = v19;
  MEMORY[0x212BAC9C0](v18, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 13;
  v20 = (char *)operator new[]();
  v197 = v20;
  strcpy(v20, "rescore_thres");
  if (NMap<NString,NString>::contains((uint64_t)a4 + 24, (uint64_t)&v195))
    v21 = NConfigSection::fOpt(a4, (const NString *)&v195);
  else
    v21 = *((float *)this + 23);
  *((float *)this + 23) = v21;
  MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 9;
  v22 = (char *)operator new[]();
  v197 = v22;
  strcpy(v22, "gsm_label");
  if (!NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v23, v22, *((_QWORD *)a3 + 2));
  v24 = NMap<NString,NString>::operator[]((uint64_t)a3 + 24, (uint64_t)&v195);
  if (*(_DWORD *)(v24 + 8) == 3)
  {
    v25 = **(unsigned __int16 **)(v24 + 16) ^ 0x4C41 | *(unsigned __int8 *)(*(_QWORD *)(v24 + 16) + 2) ^ 0x4C;
    v26 = v25 == 0;
    MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
    if (!v25)
    {
      v27 = 0;
      goto LABEL_27;
    }
  }
  else
  {
    MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
    v26 = 0;
  }
  v195 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v196) = 9;
  v28 = (char *)operator new[]();
  v197 = v28;
  strcpy(v28, "gsm_label");
  if (!NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v195))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v29, v28, *((_QWORD *)a3 + 2));
  v30 = NMap<NString,NString>::operator[]((uint64_t)a3 + 24, (uint64_t)&v195);
  *((_DWORD *)this + 18) = NPhoneHMMArray::operator()((uint64_t)this + 272, v30);
  MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
  v31 = *((_DWORD *)this + 18);
  if ((v31 & 0x80000000) != 0)
  {
    NString::NString((NString *)&v195, "gsm_label");
    v166 = NConfigSection::sOpt(a3, (const NString *)&v195);
    Error::chuck((Error *)"BlobBuilder: Cannot find gsm label %s in HMM", v167, *(_QWORD *)(v166 + 16));
  }
  if (*(_DWORD *)(*((_QWORD *)this + 35) + 48 * v31 + 16) != 1)
  {
    NString::NString((NString *)&v195, "gsm_label");
    v168 = NConfigSection::sOpt(a3, (const NString *)&v195);
    Error::chuck((Error *)"BlobBuilder: gsm hmm %s is not single-state", v169, *(_QWORD *)(v168 + 16));
  }
  v27 = 1;
LABEL_27:
  v195 = &off_24C7F2E28;
  v196 = 0;
  LODWORD(v197) = 0;
  v189 = (char *)&off_24C7F32C0;
  LODWORD(v190) = 13;
  v32 = (char *)operator new[]();
  v191 = v32;
  strcpy(v32, "keyword_label");
  if (!NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v189))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v33, v32, *((_QWORD *)a3 + 2));
  v34 = NMap<NString,NString>::operator[]((uint64_t)a3 + 24, (uint64_t)&v189);
  LODWORD(v172) = v27;
  v186 = (char *)&off_24C7F32C0;
  v187 = 1;
  v188 = (char *)operator new[]();
  strcpy(v188, ",");
  v183 = &off_24C7F32C0;
  v184 = 1;
  v185 = (char *)operator new[]();
  strcpy(v185, " ");
  (*(void (**)(uint64_t (***__return_ptr)(), uint64_t, char **, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v34 + 112))(&v192, v34, &v186, &v183);
  v180 = &off_24C7F32C0;
  v181 = 4;
  v35 = (void *)operator new[]();
  v182 = v35;
  strcpy((char *)v35, "\r\n\t ");
  LODWORD(v177) = -1;
  NString::split((uint64_t)&v192, &v195, (uint64_t)&v180, (unsigned int *)&v177);
  MEMORY[0x212BAC9C0](v35, 0x1000C8077774924);
  v192 = (uint64_t (**)())&off_24C7F32C0;
  if (v194)
    MEMORY[0x212BAC9C0](v194, 0x1000C8077774924);
  v183 = &off_24C7F32C0;
  if (v185)
    MEMORY[0x212BAC9C0](v185, 0x1000C8077774924);
  v186 = (char *)&off_24C7F32C0;
  if (v188)
    MEMORY[0x212BAC9C0](v188, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v32, 0x1000C8077774924);
  v192 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v193) = 14;
  v36 = (char *)operator new[]();
  v194 = v36;
  strcpy(v36, "direct_lengths");
  v171 = (char *)a3 + 24;
  if (NMap<NString,NString>::contains((uint64_t)a3 + 24, (uint64_t)&v192))
  {
    v189 = (char *)&off_24C7F32C0;
    LODWORD(v190) = 14;
    v37 = (char *)operator new[]();
    v191 = v37;
    strcpy(v37, "direct_lengths");
    *((_BYTE *)this + 106) = NConfigSection::bOpt(a3, (const NString *)&v189);
    v38 = (char *)this + 106;
    MEMORY[0x212BAC9C0](v37, 0x1000C8077774924);
  }
  else
  {
    *((_BYTE *)this + 106) = 0;
    v38 = (char *)this + 106;
  }
  MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
  v170 = v38;
  if (*v38)
  {
    v40 = (int)v197;
    LODWORD(v192) = 2 * (_DWORD)v197;
    NArray<NString>::resize((uint64_t)&v195, &v192);
    if (v40)
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v196 + 24 * (2 * v40 - 1)) + 32))(v196 + 24 * (2 * v40 - 1), v196 + 24 * (v40 - 1));
      v41 = v196;
      v189 = (char *)&off_24C7F32C0;
      LODWORD(v190) = 7;
      v191 = (_QWORD *)operator new[]();
      *v191 = 0x6874676E656C5FLL;
      NString::operator+(v41 + 24 * (v40 - 1), (uint64_t)&v189, (uint64_t)&v192);
    }
  }
  v42 = (int)v197;
  if (v197 >= 0x101)
    Error::chuck((Error *)"BlobBuilder: Cannot build blob more than 256 multiple phrases", v39);
  if (v197 > 1)
    v43 = -(int)v197;
  else
    v43 = 0;
  *((_DWORD *)this + 17) = v43;
  v44 = v42 + v172;
  v45 = *((_DWORD *)this + 44);
  if (v45 != v42 + (_DWORD)v172)
  {
    v46 = *((_QWORD *)this + 21);
    *((_DWORD *)this + 44) = v44;
    v47 = operator new[]();
    *((_QWORD *)this + 21) = v47;
    if (v45 >= v44)
      v48 = v44;
    else
      v48 = v45;
    if ((_DWORD)v48)
    {
      v49 = 0;
      if (v48 < 8)
        goto LABEL_54;
      if ((unint64_t)(v47 - v46) <= 0x1F)
        goto LABEL_54;
      v49 = v48 & 0xFFFFFFF8;
      v50 = (_OWORD *)(v47 + 16);
      v51 = (__int128 *)(v46 + 16);
      v52 = v49;
      do
      {
        v53 = *v51;
        *(v50 - 1) = *(v51 - 1);
        *v50 = v53;
        v50 += 2;
        v51 += 2;
        v52 -= 8;
      }
      while (v52);
      if (v49 != v48)
      {
LABEL_54:
        v54 = v48 - v49;
        v55 = 4 * v49;
        v56 = (_DWORD *)(v47 + 4 * v49);
        v57 = (int *)(v46 + v55);
        do
        {
          v58 = *v57++;
          *v56++ = v58;
          --v54;
        }
        while (v54);
      }
    }
    else if (!v46)
    {
      goto LABEL_59;
    }
    MEMORY[0x212BAC9C0](v46, 0x1000C8052888210);
  }
LABEL_59:
  v59 = v197;
  if ((_DWORD)v197)
  {
    v60 = 0;
    v61 = 0;
    do
    {
      v62 = NPhoneHMMArray::operator()((uint64_t)this + 272, v196 + v60);
      *(_DWORD *)(*((_QWORD *)this + 21) + 4 * v61) = v62;
      if (v62 < 0)
        Error::chuck((Error *)"BlobBuilder: Cannot find keyword %s in HMM", v63, *(_QWORD *)(v196 + 24 * v61 + 16));
      ++v61;
      v59 = v197;
      v60 += 24;
    }
    while (v61 < v197);
  }
  if (!v26)
  {
    *(_DWORD *)(*((_QWORD *)this + 21) + 4 * v59) = *((_DWORD *)this + 18);
    *((_DWORD *)this + 18) = (_DWORD)v197;
  }
  v192 = &off_24C7F2E28;
  v193 = 0;
  LODWORD(v194) = 0;
  v189 = (char *)&off_24C7F32C0;
  LODWORD(v190) = 16;
  v64 = (char *)operator new[]();
  v191 = v64;
  v172 = *(_OWORD *)"hmm_score_offset";
  strcpy(v64, "hmm_score_offset");
  v65 = NMap<NString,NString>::contains((uint64_t)v171, (uint64_t)&v189);
  MEMORY[0x212BAC9C0](v64, 0x1000C8077774924);
  if (v65)
  {
    v186 = (char *)&off_24C7F32C0;
    v187 = 16;
    v66 = (char *)operator new[]();
    v188 = v66;
    v66[16] = 0;
    *(_OWORD *)v66 = v172;
    if (!NMap<NString,NString>::contains((uint64_t)v171, (uint64_t)&v186))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v67, v66, *((_QWORD *)a3 + 2));
    v68 = NMap<NString,NString>::operator[]((uint64_t)v171, (uint64_t)&v186);
    v183 = &off_24C7F32C0;
    v184 = 1;
    v185 = (char *)operator new[]();
    memcpy(v185, ",", (v184 + 1));
    v180 = &off_24C7F32C0;
    v181 = 1;
    v182 = (void *)operator new[]();
    memcpy(v182, " ", (v181 + 1));
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v68 + 112))(&v189, v68, &v183, &v180);
    v177 = &off_24C7F32C0;
    v178 = 4;
    v69 = (void *)operator new[]();
    v179 = v69;
    strcpy((char *)v69, "\r\n\t ");
    LODWORD(v174) = -1;
    NString::split((uint64_t)&v189, &v192, (uint64_t)&v177, (unsigned int *)&v174);
    MEMORY[0x212BAC9C0](v69, 0x1000C8077774924);
    v189 = (char *)&off_24C7F32C0;
    if (v191)
      MEMORY[0x212BAC9C0](v191, 0x1000C8077774924);
    v180 = &off_24C7F32C0;
    if (v182)
      MEMORY[0x212BAC9C0](v182, 0x1000C8077774924);
    v183 = &off_24C7F32C0;
    if (v185)
      MEMORY[0x212BAC9C0](v185, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v66, 0x1000C8077774924);
    (*(void (**)(char *, char **))(*((_QWORD *)this + 14) + 32))((char *)this + 112, &v194);
    if ((_DWORD)v194)
    {
      v71 = 0;
      v72 = 0;
      v73 = v193;
      do
      {
        v74 = v73 + v71;
        if (!*(_DWORD *)(v73 + v71 + 8)
          || (v189 = 0,
              strtod(*(const char **)(v74 + 16), &v189),
              v73 = v193,
              v189 != (char *)(*(_QWORD *)(v74 + 16) + *(unsigned int *)(v74 + 8))))
        {
          Error::chuck((Error *)"BlobBuilder: unable to convert %s to float", v70, *(_QWORD *)(v73 + 24 * v72 + 16));
        }
        v75 = atof(*(const char **)(v193 + v71 + 16));
        *(float *)(*((_QWORD *)this + 15) + 4 * v72++) = v75;
        v71 += 24;
      }
      while (v72 < v194);
    }
    v76 = *((_DWORD *)this + 32);
    if (v76)
    {
      if (v76 != (_DWORD)v197)
      {
        if (v76 != (_DWORD)v197 + 1
          || (v77 = *(float *)(*((_QWORD *)this + 15) + 4 * v197), (float)(v77 * v77) > 0.0000001))
        {
          Error::chuck((Error *)"BlobBuilder: hmm_score_offset/keyword_label size mismatch (%d/%d)", v70, *((unsigned int *)this + 32), v197);
        }
      }
      if (*v170)
      {
        v78 = v197;
        v79 = v197 & 0xFFFFFFFE;
        v80 = operator new[]();
        v81 = v80;
        if (v78 >= 2)
        {
          v82 = v78 >> 1;
          v83 = *((_QWORD *)this + 15);
          if ((v78 >> 1) <= 1)
            v84 = 1;
          else
            v84 = v82;
          if (v84 > 0xB)
          {
            v85 = 0;
            v157 = v80 + 8 * v84;
            v158 = v83 + 4 * v82;
            v160 = v80 < v158 + 4 * v84 && v158 < v157;
            if ((v83 >= v157 || v80 >= v83 + 4 * v84) && !v160)
            {
              v85 = v84 & 0x7FFFFFF8;
              v162 = (float *)(v80 + 32);
              v163 = *((_QWORD *)this + 15);
              v164 = v85;
              do
              {
                v198.val[0] = *(float32x4_t *)(v163 + 4 * v82);
                v199.val[0] = *(float32x4_t *)(v163 + 4 * v82 + 16);
                v198.val[1] = *(float32x4_t *)v163;
                v199.val[1] = *(float32x4_t *)(v163 + 16);
                v163 += 32;
                v165 = v162 - 8;
                vst2q_f32(v165, v198);
                vst2q_f32(v162, v199);
                v162 += 16;
                v164 -= 8;
              }
              while (v164);
              if (v85 == v84)
                goto LABEL_91;
            }
          }
          else
          {
            v85 = 0;
          }
          v86 = v84 - v85;
          v87 = (int *)(v83 + 4 * v85);
          v88 = (int *)(v83 + 4 * (v85 + v82));
          v89 = (_DWORD *)(v80 + 8 * v85 + 4);
          do
          {
            v90 = *v88++;
            *(v89 - 1) = v90;
            v91 = *v87++;
            *v89 = v91;
            v89 += 2;
            --v86;
          }
          while (v86);
        }
LABEL_91:
        if (*((_DWORD *)this + 32) != v79)
        {
          v92 = *((_QWORD *)this + 15);
          if (v92)
            MEMORY[0x212BAC9C0](v92, 0x1000C8052888210);
          *((_DWORD *)this + 32) = v79;
          *((_QWORD *)this + 15) = operator new[]();
          v79 = *((_DWORD *)this + 32);
        }
        if (v79)
        {
          v93 = 0;
          v94 = *((_QWORD *)this + 15);
          if (v79 < 8)
            goto LABEL_101;
          if (v94 - v81 < 0x20)
            goto LABEL_101;
          v93 = v79 & 0xFFFFFFF8;
          v95 = (_OWORD *)(v94 + 16);
          v96 = (__int128 *)(v81 + 16);
          v97 = v93;
          do
          {
            v98 = *v96;
            *(v95 - 1) = *(v96 - 1);
            *v95 = v98;
            v95 += 2;
            v96 += 2;
            v97 -= 8;
          }
          while (v97);
          if (v93 != v79)
          {
LABEL_101:
            v99 = v79 - v93;
            v100 = 4 * v93;
            v101 = (_DWORD *)(v94 + v100);
            v102 = (int *)(v81 + v100);
            do
            {
              v103 = *v102++;
              *v101++ = v103;
              --v99;
            }
            while (v99);
          }
        }
        MEMORY[0x212BAC9C0](v81, 0x1000C8052888210);
      }
    }
  }
  v189 = (char *)&off_24C7F2E28;
  v190 = 0;
  LODWORD(v191) = 0;
  v186 = (char *)&off_24C7F32C0;
  v187 = 19;
  v104 = (char *)operator new[]();
  v188 = v104;
  v172 = *(_OWORD *)"phrase_score_offset";
  strcpy(v104, "phrase_score_offset");
  v105 = NMap<NString,NString>::contains((uint64_t)v171, (uint64_t)&v186);
  MEMORY[0x212BAC9C0](v104, 0x1000C8077774924);
  if (!v105)
    goto LABEL_142;
  v183 = &off_24C7F32C0;
  v184 = 19;
  v106 = (char *)operator new[]();
  v185 = v106;
  *((_DWORD *)v106 + 4) = 7628147;
  *(_OWORD *)v106 = v172;
  if (!NMap<NString,NString>::contains((uint64_t)v171, (uint64_t)&v183))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v107, v106, *((_QWORD *)a3 + 2));
  v108 = NMap<NString,NString>::operator[]((uint64_t)v171, (uint64_t)&v183);
  v180 = &off_24C7F32C0;
  v181 = 1;
  v182 = (void *)operator new[]();
  memcpy(v182, ",", (v181 + 1));
  v177 = &off_24C7F32C0;
  v178 = 1;
  v179 = (void *)operator new[]();
  memcpy(v179, " ", (v178 + 1));
  (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v108 + 112))(&v186, v108, &v180, &v177);
  v174 = &off_24C7F32C0;
  v175 = 4;
  v109 = (char *)operator new[]();
  v176 = v109;
  strcpy(v109, "\r\n\t ");
  v173 = -1;
  NString::split((uint64_t)&v186, &v189, (uint64_t)&v174, &v173);
  MEMORY[0x212BAC9C0](v109, 0x1000C8077774924);
  v186 = (char *)&off_24C7F32C0;
  if (v188)
    MEMORY[0x212BAC9C0](v188, 0x1000C8077774924);
  v177 = &off_24C7F32C0;
  if (v179)
    MEMORY[0x212BAC9C0](v179, 0x1000C8077774924);
  v180 = &off_24C7F32C0;
  if (v182)
    MEMORY[0x212BAC9C0](v182, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v106, 0x1000C8077774924);
  (*(void (**)(char *, _QWORD **))(*((_QWORD *)this + 17) + 32))((char *)this + 136, &v191);
  if ((_DWORD)v191)
  {
    v111 = 0;
    v112 = 0;
    v113 = v190;
    do
    {
      v114 = v113 + v111;
      if (!*(_DWORD *)(v113 + v111 + 8)
        || (v186 = 0,
            strtod(*(const char **)(v114 + 16), &v186),
            v113 = v190,
            v186 != (char *)(*(_QWORD *)(v114 + 16) + *(unsigned int *)(v114 + 8))))
      {
        Error::chuck((Error *)"BlobBuilder: unable to convert %s to float", v110, *(_QWORD *)(v113 + 24 * v112 + 16));
      }
      v115 = atof(*(const char **)(v190 + v111 + 16));
      *(float *)(*((_QWORD *)this + 18) + 4 * v112++) = v115;
      v111 += 24;
    }
    while (v112 < v191);
  }
  if (*v170)
  {
    v116 = *((_DWORD *)this + 38);
    if (v116)
    {
      v117 = 2 * v116;
      v118 = *((_QWORD *)this + 18);
      *((_DWORD *)this + 38) = 2 * v116;
      v119 = operator new[]();
      *((_QWORD *)this + 18) = v119;
      if (v116 >= 2 * v116)
        v120 = v117;
      else
        v120 = v116;
      if ((_DWORD)v120)
      {
        v121 = 0;
        if (v120 < 8)
          goto LABEL_128;
        if ((unint64_t)(v119 - v118) <= 0x1F)
          goto LABEL_128;
        v121 = v120 & 0xFFFFFFF8;
        v122 = (_OWORD *)(v119 + 16);
        v123 = (__int128 *)(v118 + 16);
        v124 = v121;
        do
        {
          v125 = *v123;
          *(v122 - 1) = *(v123 - 1);
          *v122 = v125;
          v122 += 2;
          v123 += 2;
          v124 -= 8;
        }
        while (v124);
        if (v121 != v120)
        {
LABEL_128:
          v126 = v120 - v121;
          v127 = 4 * v121;
          v128 = (_DWORD *)(v119 + 4 * v121);
          v129 = (int *)(v118 + v127);
          do
          {
            v130 = *v129++;
            *v128++ = v130;
            --v126;
          }
          while (v126);
        }
      }
      else if (!v118)
      {
LABEL_133:
        v131 = v116 - 1;
        if (v116 <= 1)
          v132 = 1;
        else
          v132 = v116;
        v133 = v117 - 2;
        do
        {
          *(_DWORD *)(v119 + 4 * (v133 + 1)) = *(_DWORD *)(v119 + 4 * v131);
          *(_DWORD *)(v119 + 4 * v133) = 0;
          --v131;
          v133 -= 2;
          --v132;
        }
        while (v132);
        goto LABEL_138;
      }
      MEMORY[0x212BAC9C0](v118, 0x1000C8052888210);
      v119 = *((_QWORD *)this + 18);
      goto LABEL_133;
    }
  }
LABEL_138:
  v134 = *((_DWORD *)this + 38);
  if (v134)
  {
    if (v134 != (_DWORD)v197)
    {
      if (v134 != (_DWORD)v197 + 1
        || (v135 = *(float *)(*((_QWORD *)this + 18) + 4 * v197), (float)(v135 * v135) > 0.0000001))
      {
        Error::chuck((Error *)"BlobBuilder: phrase_score_offset/keyword_label size mismatch (%d/%d)", v110, *((unsigned int *)this + 38), v197);
      }
    }
  }
LABEL_142:
  *((_BYTE *)this + 104) = *((_BYTE *)this + 252);
  v186 = (char *)&off_24C7F32C0;
  v187 = 16;
  v136 = (char *)operator new[]();
  v188 = v136;
  strcpy(v136, "lengthnorm_power");
  v137 = 1.0;
  if (NMap<NString,NString>::contains((uint64_t)v171, (uint64_t)&v186))
    v137 = NConfigSection::fOpt(a3, (const NString *)&v186);
  result = MEMORY[0x212BAC9C0](v136, 0x1000C8077774924);
  if ((v137 + -1.0) * (v137 + -1.0) <= 0.0001)
  {
    v140 = 0;
  }
  else
  {
    if (v137 * v137 > 0.0001)
      Error::chuck((Error *)"BlobBuilder: only lengthnorm_power=1.0 or 0.0 supported (not %f)", v139, v137);
    v140 = 1;
  }
  *((_BYTE *)this + 105) = v140;
  if (v197 >= 2)
  {
    v186 = (char *)&off_24C7F32C0;
    v187 = 15;
    v141 = (char *)operator new[]();
    v188 = v141;
    strcpy((char *)&v172, "best_after_norm");
    strcpy(v141, "best_after_norm");
    if (NMap<NString,NString>::contains((uint64_t)v171, (uint64_t)&v186))
    {
      v183 = &off_24C7F32C0;
      v184 = 15;
      v142 = (char *)operator new[]();
      v185 = v142;
      *(_OWORD *)v142 = v172;
      v143 = NConfigSection::bOpt(a3, (const NString *)&v183);
      MEMORY[0x212BAC9C0](v142, 0x1000C8077774924);
      result = MEMORY[0x212BAC9C0](v141, 0x1000C8077774924);
      if ((v143 & 1) == 0)
        Error::chuck((Error *)"BlobBuilder: best_after_norm=false not supported", v144);
    }
    else
    {
      result = MEMORY[0x212BAC9C0](v141, 0x1000C8077774924);
    }
  }
  v189 = (char *)&off_24C7F2E28;
  v145 = v190;
  if (v190)
  {
    v146 = *(_QWORD *)(v190 - 8);
    if (v146)
    {
      v147 = 24 * v146;
      do
      {
        *(_QWORD *)(v145 + v147 - 24) = &off_24C7F32C0;
        v148 = *(_QWORD *)(v145 + v147 - 8);
        if (v148)
          MEMORY[0x212BAC9C0](v148, 0x1000C8077774924);
        v147 -= 24;
      }
      while (v147);
    }
    result = MEMORY[0x212BAC9C0](v145 - 16, 0x1091C800F2A5985);
  }
  v192 = &off_24C7F2E28;
  v149 = v193;
  if (v193)
  {
    v150 = *(_QWORD *)(v193 - 8);
    if (v150)
    {
      v151 = 24 * v150;
      do
      {
        *(_QWORD *)(v149 + v151 - 24) = &off_24C7F32C0;
        v152 = *(_QWORD *)(v149 + v151 - 8);
        if (v152)
          MEMORY[0x212BAC9C0](v152, 0x1000C8077774924);
        v151 -= 24;
      }
      while (v151);
    }
    result = MEMORY[0x212BAC9C0](v149 - 16, 0x1091C800F2A5985);
  }
  v195 = &off_24C7F2E28;
  v153 = v196;
  if (v196)
  {
    v154 = *(_QWORD *)(v196 - 8);
    if (v154)
    {
      v155 = 24 * v154;
      do
      {
        *(_QWORD *)(v153 + v155 - 24) = &off_24C7F32C0;
        v156 = *(_QWORD *)(v153 + v155 - 8);
        if (v156)
          MEMORY[0x212BAC9C0](v156, 0x1000C8077774924);
        v155 -= 24;
      }
      while (v155);
    }
    return MEMORY[0x212BAC9C0](v153 - 16, 0x1091C800F2A5985);
  }
  return result;
}

void sub_20D9739D4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  NArray<NString>::~NArray((_QWORD *)(v2 - 152));
  NArray<NString>::~NArray((_QWORD *)(v2 - 128));
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::buildConfgHeader(uint64_t this, int a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  int v23;
  unsigned int *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned int *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int *v37;
  unsigned int v38;
  int v39;
  unsigned int *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;

  *(_QWORD *)this = 0xA3176424F4C4243;
  if (a2)
    v2 = 64;
  else
    v2 = 48;
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 12) = v2;
  v3 = v2 | 0x80;
  *(_DWORD *)(this + 16) = v2 + 48;
  *(_DWORD *)(this + 20) = v2 | 0x80;
  v4 = v2 + 144;
  if (*(_BYTE *)(this + 252))
    v5 = v4;
  else
    v5 = v3;
  v6 = *(_DWORD *)(this + 344);
  *(_DWORD *)(this + 24) = v5;
  *(_DWORD *)(this + 28) = v6;
  v7 = ((v6 + 15) & 0xFFFFFFF0) + v5;
  *(_DWORD *)(this + 32) = v7;
  v8 = *(unsigned int *)(this + 176);
  if (!(_DWORD)v8)
  {
    v14 = 4;
    *(_DWORD *)(this + 36) = 4;
    goto LABEL_41;
  }
  v9 = *(_DWORD *)(this + 68);
  v10 = *(_QWORD *)(this + 168);
  v11 = *(_QWORD *)(this + 280);
  if (v9 >= -1)
  {
    if ((_DWORD)v8 == 1)
    {
      v15 = 0;
      v13 = 4;
    }
    else
    {
      v23 = 0;
      v15 = v8 & 0xFFFFFFFE;
      v24 = (unsigned int *)(v10 + 4);
      v25 = 4;
      v26 = v15;
      do
      {
        v25 += 8 * *(_DWORD *)(v11 + 48 * *(v24 - 1) + 16) + 4;
        v23 += 8 * *(_DWORD *)(v11 + 48 * *v24 + 16) + 4;
        v24 += 2;
        v26 -= 2;
      }
      while (v26);
      v13 = v23 + v25;
      if (v15 == v8)
        goto LABEL_25;
    }
    v27 = v8 - v15;
    v28 = (unsigned int *)(v10 + 4 * v15);
    do
    {
      v29 = *v28++;
      v13 += 8 * *(_DWORD *)(v11 + 48 * v29 + 16) + 4;
      --v27;
    }
    while (v27);
    goto LABEL_25;
  }
  if ((_DWORD)v8 == 1)
  {
    v12 = 0;
    v13 = 4;
LABEL_17:
    v20 = v8 - v12;
    v21 = (unsigned int *)(v10 + 4 * v12);
    do
    {
      v22 = *v21++;
      v13 += 8 * *(_DWORD *)(v11 + 48 * v22 + 16) + 12;
      --v20;
    }
    while (v20);
    goto LABEL_25;
  }
  v16 = 0;
  v12 = v8 & 0xFFFFFFFE;
  v17 = (unsigned int *)(v10 + 4);
  v18 = 4;
  v19 = v12;
  do
  {
    v18 += 8 * *(_DWORD *)(v11 + 48 * *(v17 - 1) + 16) + 12;
    v16 += 8 * *(_DWORD *)(v11 + 48 * *v17 + 16) + 12;
    v17 += 2;
    v19 -= 2;
  }
  while (v19);
  v13 = v16 + v18;
  if (v12 != v8)
    goto LABEL_17;
LABEL_25:
  *(_DWORD *)(this + 36) = v13;
  if (v9 >= -1)
  {
    if ((_DWORD)v8 == 1)
    {
      v31 = 0;
      v14 = 4;
    }
    else
    {
      v39 = 0;
      v31 = v8 & 0xFFFFFFFE;
      v40 = (unsigned int *)(v10 + 4);
      v41 = 4;
      v42 = v31;
      do
      {
        v41 += 8 * *(_DWORD *)(v11 + 48 * *(v40 - 1) + 16) + 4;
        v39 += 8 * *(_DWORD *)(v11 + 48 * *v40 + 16) + 4;
        v40 += 2;
        v42 -= 2;
      }
      while (v42);
      v14 = v39 + v41;
      if (v31 == v8)
        goto LABEL_41;
    }
    v43 = v8 - v31;
    v44 = (unsigned int *)(v10 + 4 * v31);
    do
    {
      v45 = *v44++;
      v14 += 8 * *(_DWORD *)(v11 + 48 * v45 + 16) + 4;
      --v43;
    }
    while (v43);
    goto LABEL_41;
  }
  if ((_DWORD)v8 == 1)
  {
    v30 = 0;
    v14 = 4;
LABEL_33:
    v36 = v8 - v30;
    v37 = (unsigned int *)(v10 + 4 * v30);
    do
    {
      v38 = *v37++;
      v14 += 8 * *(_DWORD *)(v11 + 48 * v38 + 16) + 12;
      --v36;
    }
    while (v36);
    goto LABEL_41;
  }
  v32 = 0;
  v30 = v8 & 0xFFFFFFFE;
  v33 = (unsigned int *)(v10 + 4);
  v34 = 4;
  v35 = v30;
  do
  {
    v34 += 8 * *(_DWORD *)(v11 + 48 * *(v33 - 1) + 16) + 12;
    v32 += 8 * *(_DWORD *)(v11 + 48 * *v33 + 16) + 12;
    v33 += 2;
    v35 -= 2;
  }
  while (v35);
  v14 = v32 + v34;
  if (v30 != v8)
    goto LABEL_33;
LABEL_41:
  v46 = ((v14 + 15) & 0xFFFFFFF0) + v7;
  *(_DWORD *)(this + 40) = v46;
  *(_DWORD *)(this + 44) = 40960 - v46;
  return this;
}

uint64_t BlobBuilder::serializeDistBlob(BlobBuilder *this, N16ByteAlignedString *a2)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  size_t v7;
  void *v8;
  int v9;
  int v10;

  v4 = *((_QWORD *)this + 44);
  v9 = *((_DWORD *)this + 86);
  (*(void (**)(N16ByteAlignedString *, uint64_t, int *))(*(_QWORD *)a2 + 72))(a2, v4, &v9);
  v5 = *((_DWORD *)this + 86);
  result = (v5 + 15) & 0xFFFFFFF0;
  v7 = (result - v5);
  if ((_DWORD)result != v5)
  {
    v8 = (void *)operator new[]();
    bzero(v8, v7);
    v10 = v7;
    (*(void (**)(N16ByteAlignedString *, void *, int *))(*(_QWORD *)a2 + 72))(a2, v8, &v10);
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
    return (*((_DWORD *)this + 86) + 15) & 0xFFFFFFF0;
  }
  return result;
}

void sub_20D97418C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::serializeHmmArray(BlobBuilder *this, N16ByteAlignedString *a2)
{
  int v4;
  unint64_t i;
  uint64_t v6;
  uint64_t v7;
  unint64_t j;
  float *v9;
  float v10;
  float v11;
  int v12;
  uint64_t v13;
  size_t v14;
  void *v15;
  float v17;
  float v18;
  unsigned int v19;
  unsigned int v20;
  int v21;

  v4 = *((_DWORD *)a2 + 2);
  v20 = *((_DWORD *)this + 44);
  v21 = 4;
  (*(void (**)(N16ByteAlignedString *, unsigned int *, int *))(*(_QWORD *)a2 + 72))(a2, &v20, &v21);
  if (v20)
  {
    for (i = 0; i < v20; ++i)
    {
      if (*((int *)this + 17) <= -2)
      {
        v19 = 0;
        if (i < *((unsigned int *)this + 32))
          v19 = *(_DWORD *)(*((_QWORD *)this + 15) + 4 * i);
        v21 = 4;
        (*(void (**)(N16ByteAlignedString *, unsigned int *, int *))(*(_QWORD *)a2 + 72))(a2, &v19, &v21);
        v19 = 0;
        if (i < *((unsigned int *)this + 38))
          v19 = *(_DWORD *)(*((_QWORD *)this + 18) + 4 * i);
        v21 = 4;
        (*(void (**)(N16ByteAlignedString *, unsigned int *, int *))(*(_QWORD *)a2 + 72))(a2, &v19, &v21);
      }
      v6 = *((_QWORD *)this + 35) + 48 * *(unsigned int *)(*((_QWORD *)this + 21) + 4 * i);
      v19 = 0;
      v19 = *(_DWORD *)(v6 + 16);
      v21 = 4;
      (*(void (**)(N16ByteAlignedString *, unsigned int *, int *))(*(_QWORD *)a2 + 72))(a2, &v19, &v21);
      if (v19)
      {
        v7 = 0;
        for (j = 0; j < v19; ++j)
        {
          v18 = 0.0;
          v9 = (float *)(*(_QWORD *)(v6 + 8) + v7);
          v10 = *v9;
          v17 = 0.0;
          v18 = v10;
          v11 = 1.0 / (1.0 - v9[1]);
          v17 = v11;
          v21 = 4;
          (*(void (**)(N16ByteAlignedString *, float *, int *))(*(_QWORD *)a2 + 72))(a2, &v18, &v21);
          v21 = 4;
          (*(void (**)(N16ByteAlignedString *, float *, int *))(*(_QWORD *)a2 + 72))(a2, &v17, &v21);
          v7 += 8;
        }
      }
    }
  }
  v12 = *((_DWORD *)a2 + 2) - v4;
  v13 = (v12 + 15) & 0xFFFFFFF0;
  v14 = (v13 - v12);
  if ((_DWORD)v13 != v12)
  {
    v15 = (void *)operator new[]();
    bzero(v15, v14);
    v21 = v14;
    (*(void (**)(N16ByteAlignedString *, void *, int *))(*(_QWORD *)a2 + 72))(a2, v15, &v21);
    MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  }
  return v13;
}

void sub_20D974404(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void BlobBuilder::insertChecksum(BlobBuilder *this, N16ByteAlignedString *a2)
{
  unsigned int v2;
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *((_DWORD *)a2 + 2);
  if (v2 < 0x30)
    goto LABEL_31;
  v3 = (_DWORD *)*((_QWORD *)a2 + 2);
  v4 = v3[9] + v3[8];
  if (v4 > v2)
    goto LABEL_31;
  v5 = v3[3];
  if (v5 > v2)
    goto LABEL_31;
  if (v5 >= 0x40 && v3[12] == 1919706177)
  {
    v6 = 0;
    v7 = v3[13];
    v8 = 52;
    v9 = 52;
  }
  else
  {
    v7 = 0;
    v6 = -1;
    if (!v4)
    {
      v13 = 1;
      v9 = 0;
      v12 = 0;
      goto LABEL_16;
    }
    v8 = (v3[9] + v3[8]);
    v9 = v3[9] + v3[8];
  }
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 1;
  while (1)
  {
    while (1)
    {
      v13 += *((unsigned __int8 *)v3 + v11);
      v12 += v13;
      v14 = v11 + 1;
      if (v10 > 0xFFE || v14 >= v8)
        break;
      ++v10;
      ++v11;
    }
    v13 %= 0xFFF1u;
    v12 %= 0xFFF1u;
    if (v14 >= v8)
      break;
    v10 = 0;
    ++v11;
  }
LABEL_16:
  if (v9 < v4)
  {
    v12 = (v12 + 4 * v13) % 0xFFF1;
    v15 = v9 + 4;
    v16 = v4 - v15;
    if ((_DWORD)v16)
    {
      v21 = 0;
      v22 = 0;
      v23 = (char *)v3 + v15;
      while (1)
      {
        while (1)
        {
          v13 += v23[v22];
          v12 += v13;
          v24 = v22 + 1;
          if (v21 > 0xFFE || v24 >= v16)
            break;
          ++v21;
          ++v22;
        }
        v13 %= 0xFFF1u;
        v12 %= 0xFFF1u;
        if (v24 >= v16)
          break;
        v21 = 0;
        ++v22;
      }
    }
  }
  v17 = v13 | (v12 << 16);
  if (v6)
LABEL_31:
    Error::chuck((Error *)"BlobBuilder: failed to compute checksum", (const char *)a2);
  if (v7)
    Error::chuck((Error *)"BlobBuilder: checksum already set", (const char *)a2);
  if (v2 <= 0x34)
  {
    v25 = v2 - 1;
    v26 = 52;
    goto LABEL_37;
  }
  *((_BYTE *)v3 + 52) = v17;
  v18 = *((_DWORD *)a2 + 2);
  if (v18 <= 0x35)
  {
    v25 = v18 - 1;
    v26 = 53;
    goto LABEL_37;
  }
  *(_BYTE *)(*((_QWORD *)a2 + 2) + 53) = BYTE1(v17);
  v19 = *((_DWORD *)a2 + 2);
  if (v19 <= 0x36)
  {
    v25 = v19 - 1;
    v26 = 54;
    goto LABEL_37;
  }
  *(_BYTE *)(*((_QWORD *)a2 + 2) + 54) = BYTE2(v17);
  v20 = *((_DWORD *)a2 + 2);
  if (v20 <= 0x37)
  {
    v25 = v20 - 1;
    v26 = 55;
LABEL_37:
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, v26, v25);
  }
  *(_BYTE *)(*((_QWORD *)a2 + 2) + 55) = HIBYTE(v17);
}

uint64_t NArray<NString>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 24;
    *(_QWORD *)(result + 8) = v3;
    v16 = result + 16;
    if ((_DWORD)v3)
    {
      v7 = result;
      v8 = 0;
      v9 = 24 * v3;
      do
      {
        *(_QWORD *)(v7 + v8 + 16) = &off_24C7F32C0;
        *(_DWORD *)(v7 + v8 + 24) = 0;
        result = operator new[]();
        *(_QWORD *)(v7 + v8 + 32) = result;
        *(_BYTE *)result = 0;
        v8 += 24;
      }
      while (v9 != v8);
    }
    *(_QWORD *)(v5 + 8) = v16;
    if ((_DWORD)v2 && *a2)
    {
      v10 = 0;
      v11 = 1;
      do
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 8) + v10) + 32))(*(_QWORD *)(v5 + 8) + v10, v6 + v10);
        if (v11 >= v2)
          break;
        v10 += 24;
      }
      while (v11++ < *a2);
    }
    if (v6)
    {
      v13 = *(_QWORD *)(v6 - 8);
      if (v13)
      {
        v14 = 24 * v13;
        do
        {
          *(_QWORD *)(v6 + v14 - 24) = &off_24C7F32C0;
          v15 = *(_QWORD *)(v6 + v14 - 8);
          if (v15)
            MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
          v14 -= 24;
        }
        while (v14);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

void sub_20D974830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  if (a10 != v13)
  {
    do
    {
      *(_QWORD *)(v10 + v12 - 8) = v11;
      v15 = *(_QWORD *)(v10 + v12 + 8);
      if (v15)
        MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
      v12 -= 24;
    }
    while (v12);
  }
  MEMORY[0x212BAC9C0](v10, 0x1091C800F2A5985);
  _Unwind_Resume(a1);
}

_QWORD *NArray<NString>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2E28;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 24 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 24) = &off_24C7F32C0;
        v5 = *(_QWORD *)(v2 + v4 - 8);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x1091C800F2A5985);
  }
  return a1;
}

void NArray<NString>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F2E28;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F32C0;
        v4 = *(_QWORD *)(v1 + v3 - 8);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1091C800F2A5985);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NString>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  unint64_t v17;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 - 8);
        if (v7)
        {
          v8 = 24 * v7;
          do
          {
            *(_QWORD *)(v6 + v8 - 24) = &off_24C7F32C0;
            v9 = *(_QWORD *)(v6 + v8 - 8);
            if (v9)
              MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
            v8 -= 24;
          }
          while (v8);
        }
        MEMORY[0x212BAC9C0](v6 - 16, 0x1091C800F2A5985);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v10 = (_QWORD *)operator new[]();
      *v10 = 24;
      v10[1] = v5;
      v11 = v10 + 2;
      if (v5)
      {
        v12 = v10;
        v13 = 0;
        v14 = 24 * v5;
        do
        {
          v12[v13 / 8 + 2] = &off_24C7F32C0;
          LODWORD(v12[v13 / 8 + 3]) = 0;
          v15 = (_BYTE *)operator new[]();
          v12[v13 / 8 + 4] = v15;
          *v15 = 0;
          v13 += 24;
        }
        while (v14 != v13);
      }
      *(_QWORD *)(a1 + 8) = v11;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v16 = 0;
      v17 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v16) + 32))(*(_QWORD *)(a1 + 8) + v16, *(_QWORD *)(a2 + 8) + v16);
        ++v17;
        v16 += 24;
      }
      while (v17 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<NString>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = 24 * v9;
        do
        {
          *(_QWORD *)(v7 + v10 - 24) = &off_24C7F32C0;
          v11 = *(_QWORD *)(v7 + v10 - 8);
          if (v11)
            MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x1091C800F2A5985);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v12 = v6;
    result = operator new[]();
    *(_QWORD *)result = 24;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (v6)
    {
      v14 = result;
      v15 = 0;
      v16 = 24 * v12;
      do
      {
        *(_QWORD *)(v14 + v15 + 16) = &off_24C7F32C0;
        *(_DWORD *)(v14 + v15 + 24) = 0;
        result = operator new[]();
        *(_QWORD *)(v14 + v15 + 32) = result;
        *(_BYTE *)result = 0;
        v15 += 24;
      }
      while (v16 != v15);
    }
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + v17) + 32))(*(_QWORD *)(v4 + 8) + v17, a2 + v17);
      ++v18;
      v17 += 24;
    }
    while (v18 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t BlobBuilder::sanityCheckAcAnalOption(BlobBuilder *this, const NConfigSection *a2)
{
  char *v3;
  _BOOL4 v4;
  char *v5;
  float v6;
  char *v7;
  _BOOL4 v8;
  char *v9;
  float v10;
  char *v11;
  _BOOL4 v12;
  char *v13;
  int v14;
  char *v15;
  _BOOL4 v16;
  char *v17;
  int v18;
  char *v19;
  _BOOL4 v20;
  char *v21;
  int v22;
  char *v23;
  _BOOL4 v24;
  char *v25;
  char *v26;
  float v27;
  float v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  char *v32;
  char *v33;
  float v34;
  float v35;
  const char *v36;
  char *v37;
  _BOOL4 v38;
  char *v39;
  float v40;
  char *v41;
  _BOOL4 v42;
  char *v43;
  float v44;
  char *v45;
  _BOOL4 v46;
  uint64_t result;
  char *v48;
  float v49;
  float v50;
  const char *v51;
  float v52;
  const char *v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  const char *v59;
  float v60;
  const char *v61;
  float v62;
  const char *v63;
  float v64;
  const char *v65;
  uint64_t (**v66)(NString *__hidden, const unsigned int *);
  int v67;
  char *v68;
  uint64_t (**v69)(NString *__hidden, const unsigned int *);
  int v70;
  char *v71;

  v69 = &off_24C7F32C0;
  v70 = 10;
  v3 = (char *)operator new[]();
  v71 = v3;
  strcpy(v3, "WINDOWSIZE");
  v4 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  if (v4)
  {
    v69 = &off_24C7F32C0;
    v70 = 10;
    v5 = (char *)operator new[]();
    v71 = v5;
    strcpy(v5, "WINDOWSIZE");
    v6 = NConfigSection::fOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
    if (v6 < 0.0)
    {
      NString::NString((NString *)&v69, "WINDOWSIZE");
      v50 = NConfigSection::fOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - windowsize = %f can't be negative", v51, v50);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 9;
  v7 = (char *)operator new[]();
  v71 = v7;
  strcpy(v7, "PREEMCOEF");
  v8 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  if (v8)
  {
    v69 = &off_24C7F32C0;
    v70 = 9;
    v9 = (char *)operator new[]();
    v71 = v9;
    strcpy(v9, "PREEMCOEF");
    v10 = NConfigSection::fOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
    if (v10 < 0.0)
    {
      NString::NString((NString *)&v69, "PREEMCOEF");
      v52 = NConfigSection::fOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - preemcoef = %f can't be negative", v53, v52);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 8;
  v11 = (char *)operator new[]();
  v71 = v11;
  strcpy(v11, "NUMCHANS");
  v12 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  if (v12)
  {
    v69 = &off_24C7F32C0;
    v70 = 8;
    v13 = (char *)operator new[]();
    v71 = v13;
    strcpy(v13, "NUMCHANS");
    v14 = NConfigSection::iOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
    if (v14 < 0)
    {
      NString::NString((NString *)&v69, "NUMCHANS");
      v54 = NConfigSection::iOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - numchans = %d can't be negative", v55, v54);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 9;
  v15 = (char *)operator new[]();
  v71 = v15;
  strcpy(v15, "CEPLIFTER");
  v16 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  if (v16)
  {
    v69 = &off_24C7F32C0;
    v70 = 9;
    v17 = (char *)operator new[]();
    v71 = v17;
    strcpy(v17, "CEPLIFTER");
    v18 = NConfigSection::iOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
    if (v18 < 0)
    {
      NString::NString((NString *)&v69, "CEPLIFTER");
      v56 = NConfigSection::iOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - ceplifter = %d can't be negative", v57, v56);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 7;
  v19 = (char *)operator new[]();
  v71 = v19;
  *(_QWORD *)v19 = 0x535045434D554ELL;
  v20 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v19, 0x1000C8077774924);
  if (v20)
  {
    v69 = &off_24C7F32C0;
    v70 = 7;
    v21 = (char *)operator new[]();
    v71 = v21;
    *(_QWORD *)v21 = 0x535045434D554ELL;
    v22 = NConfigSection::iOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
    if (v22 < 0)
    {
      NString::NString((NString *)&v69, "NUMCEPS");
      v58 = NConfigSection::iOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - numceps = %d can't be negative", v59, v58);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 6;
  v23 = (char *)operator new[]();
  v71 = v23;
  strcpy(v23, "LOFREQ");
  v24 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
  if (v24)
  {
    v69 = &off_24C7F32C0;
    v70 = 6;
    v25 = (char *)operator new[]();
    v71 = v25;
    strcpy(v25, "LOFREQ");
    if (NConfigSection::fOpt(a2, (const NString *)&v69) >= 0.0)
    {
      MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
    }
    else
    {
      v66 = &off_24C7F32C0;
      v67 = 6;
      v26 = (char *)operator new[]();
      v68 = v26;
      strcpy(v26, "LOFREQ");
      v27 = NConfigSection::fOpt(a2, (const NString *)&v66);
      MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
      if (v27 != -1.0)
      {
        NString::NString((NString *)&v69, "LOFREQ");
        v28 = NConfigSection::fOpt(a2, (const NString *)&v69);
        Error::chuck((Error *)"BlobBuilder::buildBlob - lofreq = %f can only be positive or -1", v29, v28);
      }
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 6;
  v30 = (char *)operator new[]();
  v71 = v30;
  strcpy(v30, "HIFREQ");
  v31 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v30, 0x1000C8077774924);
  if (v31)
  {
    v69 = &off_24C7F32C0;
    v70 = 6;
    v32 = (char *)operator new[]();
    v71 = v32;
    strcpy(v32, "HIFREQ");
    if (NConfigSection::fOpt(a2, (const NString *)&v69) >= 0.0)
    {
      MEMORY[0x212BAC9C0](v32, 0x1000C8077774924);
    }
    else
    {
      v66 = &off_24C7F32C0;
      v67 = 6;
      v33 = (char *)operator new[]();
      v68 = v33;
      strcpy(v33, "HIFREQ");
      v34 = NConfigSection::fOpt(a2, (const NString *)&v66);
      MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v32, 0x1000C8077774924);
      if (v34 != -1.0)
      {
        NString::NString((NString *)&v69, "HIFREQ");
        v35 = NConfigSection::fOpt(a2, (const NString *)&v69);
        Error::chuck((Error *)"BlobBuilder::buildBlob - hifreq = %f can only be positive or -1", v36, v35);
      }
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 8;
  v37 = (char *)operator new[]();
  v71 = v37;
  strcpy(v37, "MELFLOOR");
  v38 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v37, 0x1000C8077774924);
  if (v38)
  {
    v69 = &off_24C7F32C0;
    v70 = 8;
    v39 = (char *)operator new[]();
    v71 = v39;
    strcpy(v39, "MELFLOOR");
    v40 = NConfigSection::fOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v39, 0x1000C8077774924);
    if (v40 < 0.0)
    {
      NString::NString((NString *)&v69, "MELFLOOR");
      v60 = NConfigSection::fOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - melfloor = %f can't be negative", v61, v60);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 8;
  v41 = (char *)operator new[]();
  v71 = v41;
  strcpy(v41, "MELSCALE");
  v42 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  MEMORY[0x212BAC9C0](v41, 0x1000C8077774924);
  if (v42)
  {
    v69 = &off_24C7F32C0;
    v70 = 8;
    v43 = (char *)operator new[]();
    v71 = v43;
    strcpy(v43, "MELSCALE");
    v44 = NConfigSection::fOpt(a2, (const NString *)&v69);
    MEMORY[0x212BAC9C0](v43, 0x1000C8077774924);
    if (v44 < 0.0)
    {
      NString::NString((NString *)&v69, "MELSCALE");
      v62 = NConfigSection::fOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - melscale = %f can't be negative", v63, v62);
    }
  }
  v69 = &off_24C7F32C0;
  v70 = 9;
  v45 = (char *)operator new[]();
  v71 = v45;
  strcpy(v45, "freqscale");
  v46 = NMap<NString,NString>::contains((uint64_t)a2 + 24, (uint64_t)&v69);
  result = MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
  if (v46)
  {
    v69 = &off_24C7F32C0;
    v70 = 9;
    v48 = (char *)operator new[]();
    v71 = v48;
    strcpy(v48, "freqscale");
    v49 = NConfigSection::fOpt(a2, (const NString *)&v69);
    result = MEMORY[0x212BAC9C0](v48, 0x1000C8077774924);
    if (v49 < 0.0)
    {
      NString::NString((NString *)&v69, "freqscale");
      v64 = NConfigSection::fOpt(a2, (const NString *)&v69);
      Error::chuck((Error *)"BlobBuilder::buildBlob - freqscale = %f can't be negative", v65, v64);
    }
  }
  return result;
}

void sub_20D975988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t BlobBuilder::analysisTargetKind(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  char *v5;
  const char *v6;
  uint64_t v7;
  _WORD *v8;
  const char *v9;
  uint64_t v10;
  int v11;
  char v12;
  int *v13;
  int v14;
  int v15;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _BYTE *v22;
  const char *v23;
  char v24;
  uint64_t v25;
  const char *v27;
  char *v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t (**v31)(NString *__hidden, const unsigned int *);
  int v32;
  _WORD *v33;
  uint64_t (**i)();
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t (**v38)(NString *__hidden, const unsigned int *);
  int v39;
  char *v40;

  v38 = &off_24C7F32C0;
  v39 = 10;
  v5 = (char *)operator new[]();
  v40 = v5;
  strcpy(v5, "TARGETKIND");
  if (!NMap<NString,NString>::contains(a2 + 24, (uint64_t)&v38))
    return MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  if (!NMap<NString,NString>::contains(a2 + 24, (uint64_t)&v38))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v6, v5, *(_QWORD *)(a2 + 16));
  v7 = NMap<NString,NString>::operator[](a2 + 24, (uint64_t)&v38);
  v31 = &off_24C7F32C0;
  v32 = 1;
  v8 = (_WORD *)operator new[]();
  *v8 = 95;
  v30 = -1;
  v35 = 0;
  v36 = 0;
  v33 = v8;
  i = off_24C7F13C0;
  v37 = 0;
  NString::split(v7, (uint64_t)&i, (uint64_t)&v31, &v30);
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  if (!v37)
    Error::chuck((Error *)"BlobBuilder::analysisTargetKind - no parameter type specified", v9);
  v10 = v35;
  v11 = *(_DWORD *)(v35 + 24);
  if (v11 == 5)
  {
    v13 = *(int **)(v35 + 32);
    v14 = *v13;
    v15 = *((unsigned __int8 *)v13 + 4);
    if (v14 == 1312899654 && v15 == 75)
    {
      v12 = 1;
      goto LABEL_14;
    }
LABEL_39:
    Error::chuck((Error *)"BlobBuilder::analysisTargetKind - we only do MFCC or FBANK here('%s' specified)", v9, *(_QWORD *)(v35 + 32));
  }
  if (v11 != 4 || **(_DWORD **)(v35 + 32) != 1128482381)
    goto LABEL_39;
  v12 = 0;
LABEL_14:
  a3[14] = v12;
  a3[44] = 0;
  a3[56] = 0;
  v17 = *(_QWORD *)(v10 + 8);
  if (v17)
  {
    v29 = v7;
    v18 = 0;
    v19 = 0;
    while (2)
    {
      v20 = v19;
      v31 = &off_24C7F32C0;
      v32 = *(_DWORD *)(v17 + 24);
      v21 = v32;
      v22 = (_BYTE *)operator new[]();
      v33 = v22;
      memcpy(v22, *(const void **)(v17 + 32), (*(_DWORD *)(v17 + 24) + 1));
      if (v21 != 1)
      {
LABEL_33:
        v28 = "BlobBuilder::analysisTargetKind - Qualifier '%s' not supported in target kind '%s'";
        if (!NString::operator==((uint64_t)&v31, "E") && !NString::operator==((uint64_t)&v31, "N"))
          v28 = "BlobBuilder::analysisTargetKind - Invalid qualifier '%s' in target kind '%s' (only accept ENDACZK0)";
        Error::chuck((Error *)v28, v27, v22, *(_QWORD *)(v29 + 16));
      }
      v19 = 1;
      switch(*v22)
      {
        case '0':
          if (a3[14])
          {
            if (!v37)
              Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", v23, 0, 0);
            Error::chuck((Error *)"BlobBuilder::analysisTargetKind - Qualifier '%s' not supported for target kind '%s'", v23, v22, *(_QWORD *)(v35 + 32));
          }
          a3[44] = 1;
          goto LABEL_17;
        case 'A':
          v18 = 1;
          goto LABEL_17;
        case 'C':
        case 'E':
        case 'K':
        case 'N':
        case 'Z':
LABEL_17:
          v19 = v20;
          goto LABEL_18;
        case 'D':
LABEL_18:
          MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
          v17 = *(_QWORD *)(v17 + 8);
          if (v17)
            continue;
          if ((v19 & v18 & 1) == 0)
            goto LABEL_26;
          v24 = 1;
          break;
        default:
          goto LABEL_33;
      }
      break;
    }
  }
  else
  {
    LOBYTE(v18) = 0;
    LOBYTE(v19) = 0;
LABEL_26:
    if ((v19 & 1) != 0 || (v18 & 1) != 0)
      Error::chuck((Error *)"BlobBuilder::analysisTargetKind - we do both dynamics or none(Check your .cfg file)", v9);
    v24 = 0;
  }
  a3[56] = v24;
  for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, v25))
  {
    v25 = v35;
    if (!v35)
      break;
    v35 = *(_QWORD *)(v35 + 8);
  }
  return MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
}

void sub_20D975E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  NLinkedList<NString>::~NLinkedList((uint64_t)va);
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NConfig::~NConfig(NConfig *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *(_QWORD *)this = &off_24C7F2A90;
  *((_QWORD *)this + 1) = &off_24C7F2C68;
  v1 = *((_QWORD *)this + 2);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1420;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::removeElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a2)
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(a1 + 8);
  if (v3 == v5)
  {
    *v4 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *v4 = *(_QWORD *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      v7 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(a2 + 8);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1420;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void NLinkedList<NMap<NString,NConfigSection>::HashItem>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1420;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    for (i = *(_QWORD *)(a2 + 8); i; i = *(_QWORD *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::prepend(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
    *(_QWORD *)(result + 8) = v3;
  else
    *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::append(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = (uint64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 16);
    v3 = (uint64_t *)(a1 + 8);
  }
  *v4 = result;
  *v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v8;
  int i;

  v3 = *(unsigned int *)a2;
  v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4)
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  if (!(_DWORD)v3)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32);
    return v6(a1, a3);
  }
  if ((_DWORD)v3 == v4)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40);
    return v6(a1, a3);
  }
  v8 = *(_QWORD *)(a1 + 8);
  for (i = v3 - 1; i; --i)
    v8 = *(_QWORD *)(v8 + 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::reset(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = *(_QWORD *)(result + 8); i; i = *(_QWORD *)(v1 + 8))
  {
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  }
  *(_QWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::newElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C7F35E0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = &off_24C7F32C0;
  *(_DWORD *)(v3 + 24) = *(_DWORD *)(a2 + 8);
  v4 = (void *)operator new[]();
  *(_QWORD *)(v3 + 32) = v4;
  memcpy(v4, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  *(_QWORD *)(v3 + 40) = &off_24C7F32C0;
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 32);
  v5 = (void *)operator new[]();
  *(_QWORD *)(v3 + 56) = v5;
  memcpy(v5, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 32) + 1));
  NMap<NString,NString>::NMap(v3 + 64, a2 + 48);
  return v3;
}

void sub_20D976404(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v1[5] = v2;
  v4 = v1[7];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v1[2] = v2;
  v5 = v1[4];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  MEMORY[0x212BAC9D8](v1, 0x10B1C402CAC5B7ELL);
  _Unwind_Resume(a1);
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::deleteElement(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

uint64_t NMap<NString,NString>::NMap(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_QWORD *)(a1 + 8) = &off_24C7F2BC0;
  v3 = a1 + 8;
  *(_QWORD *)a1 = &off_24C7F2AB0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  if (a1 != a2)
  {
    *(_QWORD *)(a1 + 28) = *(_QWORD *)(a2 + 28);
    NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=(v3, a2 + 8);
  }
  return a1;
}

void sub_20D9764FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;

  *(_QWORD *)(v1 + 8) = &off_24C7F2CA0;
  v3 = *(_QWORD *)(v1 + 16);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 - 8);
    if (v4)
    {
      v5 = v3 + 32 * v4;
      v6 = v5;
      do
      {
        *(_QWORD *)(v6 - 32) = off_24C7F1480;
        v6 -= 32;
        for (i = *(_QWORD *)(v6 + 8); i; i = *(_QWORD *)(v5 - 24))
        {
          *(_QWORD *)(v5 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v5 - 32) + 72))(v6);
        }
        *(_QWORD *)(v5 - 16) = 0;
        *(_DWORD *)(v5 - 8) = 0;
        v5 = v6;
      }
      while (v6 != v3);
    }
    MEMORY[0x212BAC9C0](v3 - 16, 0x10A1C80F4A7E088);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 - 8);
        if (v7)
        {
          v8 = v6 + 32 * v7;
          v9 = v8;
          do
          {
            *(_QWORD *)(v9 - 32) = off_24C7F1480;
            v9 -= 32;
            for (i = *(_QWORD *)(v9 + 8); i; i = *(_QWORD *)(v8 - 24))
            {
              *(_QWORD *)(v8 - 24) = *(_QWORD *)(i + 8);
              (*(void (**)(uint64_t))(*(_QWORD *)(v8 - 32) + 72))(v9);
            }
            *(_QWORD *)(v8 - 16) = 0;
            *(_DWORD *)(v8 - 8) = 0;
            v8 = v9;
          }
          while (v9 != v6);
        }
        MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80F4A7E088);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v11 = (_QWORD *)operator new[]();
      *v11 = 32;
      v11[1] = v5;
      v12 = v11 + 2;
      if (v5)
      {
        v13 = v11 + 2;
        do
        {
          v13[1] = 0;
          v13[2] = 0;
          *v13 = off_24C7F1480;
          *((_DWORD *)v13 + 6) = 0;
          v13 += 4;
        }
        while (v13 != &v12[4 * v5]);
      }
      *(_QWORD *)(a1 + 8) = v12;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v14 = 0;
      v15 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v14) + 24))(*(_QWORD *)(a1 + 8) + v14, *(_QWORD *)(a2 + 8) + v14);
        ++v15;
        v14 += 32;
      }
      while (v15 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::removeElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a2)
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(a1 + 8);
  if (v3 == v5)
  {
    *v4 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *v4 = *(_QWORD *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      v7 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(a2 + 8);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1480;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void NLinkedList<NMap<NString,NString>::HashItem>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1480;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    for (i = *(_QWORD *)(a2 + 8); i; i = *(_QWORD *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::prepend(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
    *(_QWORD *)(result + 8) = v3;
  else
    *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::append(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = (uint64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 16);
    v3 = (uint64_t *)(a1 + 8);
  }
  *v4 = result;
  *v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v8;
  int i;

  v3 = *(unsigned int *)a2;
  v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4)
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  if (!(_DWORD)v3)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32);
    return v6(a1, a3);
  }
  if ((_DWORD)v3 == v4)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40);
    return v6(a1, a3);
  }
  v8 = *(_QWORD *)(a1 + 8);
  for (i = v3 - 1; i; --i)
    v8 = *(_QWORD *)(v8 + 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::reset(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = *(_QWORD *)(result + 8); i; i = *(_QWORD *)(v1 + 8))
  {
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  }
  *(_QWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::newElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C7F3600;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = &off_24C7F32C0;
  *(_DWORD *)(v3 + 24) = *(_DWORD *)(a2 + 8);
  v4 = (void *)operator new[]();
  *(_QWORD *)(v3 + 32) = v4;
  memcpy(v4, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  *(_QWORD *)(v3 + 40) = &off_24C7F32C0;
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 32);
  v5 = (void *)operator new[]();
  *(_QWORD *)(v3 + 56) = v5;
  memcpy(v5, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 32) + 1));
  return v3;
}

void sub_20D976B68(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)(v1 + 16) = v3;
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9D8](v1, 0x10B1C40C03CEF6FLL);
  _Unwind_Resume(a1);
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::deleteElement(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

_QWORD *NLinkedList<NMap<NString,NString>::HashItem>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &off_24C7F3600;
  a1[5] = &off_24C7F32C0;
  v2 = a1[7];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[2] = &off_24C7F32C0;
  v3 = a1[4];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  return a1;
}

void NLinkedList<NMap<NString,NString>::HashItem>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &off_24C7F3600;
  a1[5] = &off_24C7F32C0;
  v2 = a1[7];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[2] = &off_24C7F32C0;
  v3 = a1[4];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<NLinkedList<NMap<NString,NString>::HashItem>>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2CA0;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NArray<NLinkedList<NMap<NString,NString>::HashItem>>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2CA0;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1480;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NLinkedList<NMap<NString,NString>::HashItem>>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = v7 + 32 * v9;
        v11 = v10;
        do
        {
          *(_QWORD *)(v11 - 32) = off_24C7F1480;
          v11 -= 32;
          for (i = *(_QWORD *)(v11 + 8); i; i = *(_QWORD *)(v10 - 24))
          {
            *(_QWORD *)(v10 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v10 - 32) + 72))(v11);
          }
          *(_QWORD *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          v10 = v11;
        }
        while (v11 != v7);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x10A1C80F4A7E088);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)result = 32;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (v6)
    {
      v14 = result + 16;
      do
      {
        *(_QWORD *)(v14 + 8) = 0;
        *(_QWORD *)(v14 + 16) = 0;
        *(_QWORD *)v14 = off_24C7F1480;
        *(_DWORD *)(v14 + 24) = 0;
        v14 += 32;
      }
      while (v14 != v13 + 32 * v6);
    }
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v15 = 0;
    v16 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + v15) + 24))(*(_QWORD *)(v4 + 8) + v15, a2 + v15);
      ++v16;
      v15 += 32;
    }
    while (v16 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NString>::HashItem>>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 32;
    *(_QWORD *)(result + 8) = v3;
    v7 = result + 16;
    if ((_DWORD)v3)
    {
      v8 = result + 16;
      do
      {
        *(_QWORD *)(v8 + 8) = 0;
        *(_QWORD *)(v8 + 16) = 0;
        *(_QWORD *)v8 = off_24C7F1480;
        *(_DWORD *)(v8 + 24) = 0;
        v8 += 32;
      }
      while (v8 != v7 + 32 * v3);
    }
    *(_QWORD *)(v5 + 8) = v7;
    if ((_DWORD)v2 && *a2)
    {
      v9 = 0;
      v10 = 1;
      do
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 8) + v9) + 24))(*(_QWORD *)(v5 + 8) + v9, v6 + v9);
        if (v10 >= v2)
          break;
        v9 += 32;
      }
      while (v10++ < *a2);
    }
    if (v6)
    {
      v12 = *(_QWORD *)(v6 - 8);
      if (v12)
      {
        v13 = v6 + 32 * v12;
        v14 = v13;
        do
        {
          *(_QWORD *)(v14 - 32) = off_24C7F1480;
          v14 -= 32;
          for (i = *(_QWORD *)(v14 + 8); i; i = *(_QWORD *)(v13 - 24))
          {
            *(_QWORD *)(v13 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v13 - 32) + 72))(v14);
          }
          *(_QWORD *)(v13 - 16) = 0;
          *(_DWORD *)(v13 - 8) = 0;
          v13 = v14;
        }
        while (v14 != v6);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

_QWORD *NHash<NMap<NString,NString>::HashItem>::~NHash(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2CA0;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NHash<NMap<NString,NString>::HashItem>::~NHash(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2CA0;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1480;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NMap<NString,NString>::~NMap(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2AB0;
  a1[1] = &off_24C7F2CA0;
  v2 = a1[2];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NMap<NString,NString>::~NMap(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2AB0;
  a1[1] = &off_24C7F2CA0;
  v1 = a1[2];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1480;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

void NLinkedList<NMap<NString,NConfigSection>::HashItem>::NElement::~NElement(_QWORD *a1)
{
  NLinkedList<NMap<NString,NConfigSection>::HashItem>::NElement::~NElement(a1);
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NLinkedList<NMap<NString,NConfigSection>::HashItem>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;

  *a1 = &off_24C7F35E0;
  a1[8] = &off_24C7F2AB0;
  a1[9] = &off_24C7F2CA0;
  v2 = a1[10];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  a1[5] = &off_24C7F32C0;
  v7 = a1[7];
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  a1[2] = &off_24C7F32C0;
  v8 = a1[4];
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  return a1;
}

_QWORD *NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2C68;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1420;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2C68;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1420;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 - 8);
        if (v7)
        {
          v8 = v6 + 32 * v7;
          v9 = v8;
          do
          {
            *(_QWORD *)(v9 - 32) = off_24C7F1420;
            v9 -= 32;
            for (i = *(_QWORD *)(v9 + 8); i; i = *(_QWORD *)(v8 - 24))
            {
              *(_QWORD *)(v8 - 24) = *(_QWORD *)(i + 8);
              (*(void (**)(uint64_t))(*(_QWORD *)(v8 - 32) + 72))(v9);
            }
            *(_QWORD *)(v8 - 16) = 0;
            *(_DWORD *)(v8 - 8) = 0;
            v8 = v9;
          }
          while (v9 != v6);
        }
        MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80F4A7E088);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v11 = (_QWORD *)operator new[]();
      *v11 = 32;
      v11[1] = v5;
      v12 = v11 + 2;
      if (v5)
      {
        v13 = v11 + 2;
        do
        {
          v13[1] = 0;
          v13[2] = 0;
          *v13 = off_24C7F1420;
          *((_DWORD *)v13 + 6) = 0;
          v13 += 4;
        }
        while (v13 != &v12[4 * v5]);
      }
      *(_QWORD *)(a1 + 8) = v12;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v14 = 0;
      v15 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v14) + 24))(*(_QWORD *)(a1 + 8) + v14, *(_QWORD *)(a2 + 8) + v14);
        ++v15;
        v14 += 32;
      }
      while (v15 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = v7 + 32 * v9;
        v11 = v10;
        do
        {
          *(_QWORD *)(v11 - 32) = off_24C7F1420;
          v11 -= 32;
          for (i = *(_QWORD *)(v11 + 8); i; i = *(_QWORD *)(v10 - 24))
          {
            *(_QWORD *)(v10 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v10 - 32) + 72))(v11);
          }
          *(_QWORD *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          v10 = v11;
        }
        while (v11 != v7);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x10A1C80F4A7E088);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)result = 32;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (v6)
    {
      v14 = result + 16;
      do
      {
        *(_QWORD *)(v14 + 8) = 0;
        *(_QWORD *)(v14 + 16) = 0;
        *(_QWORD *)v14 = off_24C7F1420;
        *(_DWORD *)(v14 + 24) = 0;
        v14 += 32;
      }
      while (v14 != v13 + 32 * v6);
    }
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v15 = 0;
    v16 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + v15) + 24))(*(_QWORD *)(v4 + 8) + v15, a2 + v15);
      ++v16;
      v15 += 32;
    }
    while (v16 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 32;
    *(_QWORD *)(result + 8) = v3;
    v7 = result + 16;
    if ((_DWORD)v3)
    {
      v8 = result + 16;
      do
      {
        *(_QWORD *)(v8 + 8) = 0;
        *(_QWORD *)(v8 + 16) = 0;
        *(_QWORD *)v8 = off_24C7F1420;
        *(_DWORD *)(v8 + 24) = 0;
        v8 += 32;
      }
      while (v8 != v7 + 32 * v3);
    }
    *(_QWORD *)(v5 + 8) = v7;
    if ((_DWORD)v2 && *a2)
    {
      v9 = 0;
      v10 = 1;
      do
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 8) + v9) + 24))(*(_QWORD *)(v5 + 8) + v9, v6 + v9);
        if (v10 >= v2)
          break;
        v9 += 32;
      }
      while (v10++ < *a2);
    }
    if (v6)
    {
      v12 = *(_QWORD *)(v6 - 8);
      if (v12)
      {
        v13 = v6 + 32 * v12;
        v14 = v13;
        do
        {
          *(_QWORD *)(v14 - 32) = off_24C7F1420;
          v14 -= 32;
          for (i = *(_QWORD *)(v14 + 8); i; i = *(_QWORD *)(v13 - 24))
          {
            *(_QWORD *)(v13 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v13 - 32) + 72))(v14);
          }
          *(_QWORD *)(v13 - 16) = 0;
          *(_DWORD *)(v13 - 8) = 0;
          v13 = v14;
        }
        while (v14 != v6);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

_QWORD *NMap<NString,NConfigSection>::~NMap(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2A90;
  a1[1] = &off_24C7F2C68;
  v2 = a1[2];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1420;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NMap<NString,NConfigSection>::~NMap(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2A90;
  a1[1] = &off_24C7F2C68;
  v1 = a1[2];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1420;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NString>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F13C0;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NString>::removeElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a2)
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(a1 + 8);
  if (v3 == v5)
  {
    *v4 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *v4 = *(_QWORD *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      v7 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(a2 + 8);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

void NLinkedList<NString>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F13C0;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NString>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    for (i = *(_QWORD *)(a2 + 8); i; i = *(_QWORD *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

uint64_t NLinkedList<NString>::prepend(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
    *(_QWORD *)(result + 8) = v3;
  else
    *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NString>::append(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = (uint64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 16);
    v3 = (uint64_t *)(a1 + 8);
  }
  *v4 = result;
  *v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NString>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v8;
  int i;

  v3 = *(unsigned int *)a2;
  v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4)
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  if (!(_DWORD)v3)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32);
    return v6(a1, a3);
  }
  if ((_DWORD)v3 == v4)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40);
    return v6(a1, a3);
  }
  v8 = *(_QWORD *)(a1 + 8);
  for (i = v3 - 1; i; --i)
    v8 = *(_QWORD *)(v8 + 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NString>::reset(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = *(_QWORD *)(result + 8); i; i = *(_QWORD *)(v1 + 8))
  {
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  }
  *(_QWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NString>::newElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C7F35C0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = &off_24C7F32C0;
  *(_DWORD *)(v3 + 24) = *(_DWORD *)(a2 + 8);
  v4 = (void *)operator new[]();
  *(_QWORD *)(v3 + 32) = v4;
  memcpy(v4, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  return v3;
}

void sub_20D978150(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10B1C403C52864DLL);
  _Unwind_Resume(a1);
}

uint64_t NLinkedList<NString>::deleteElement(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

_QWORD *NLinkedList<NString>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F35C0;
  a1[2] = &off_24C7F32C0;
  v2 = a1[4];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  return a1;
}

void NLinkedList<NString>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F35C0;
  a1[2] = &off_24C7F32C0;
  v1 = a1[4];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<unsigned int>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3100;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  return a1;
}

void NArray<unsigned int>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3100;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<unsigned int>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = 0;
    v10 = *(_QWORD *)(v4 + 8);
    do
    {
      *(_DWORD *)(v10 + 4 * v9) = *(_DWORD *)(a2 + 4 * v9);
      ++v9;
    }
    while (v9 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<unsigned int>::resize(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  int v17;

  v2 = *(_DWORD *)(result + 16);
  if (v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    LODWORD(v6) = *a2;
    if (v2 >= *a2)
      v6 = v6;
    else
      v6 = v2;
    if ((_DWORD)v6)
    {
      if (v6 >= 8 && (unint64_t)(result - v5) > 0x1F)
      {
        v8 = v6 & 0xFFFFFFF8;
        v9 = (_OWORD *)(result + 16);
        v10 = (__int128 *)(v5 + 16);
        v11 = v8;
        do
        {
          v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 8;
        }
        while (v11);
        if (v8 == v6)
LABEL_18:
          JUMPOUT(0x212BAC9C0);
      }
      else
      {
        v8 = 0;
      }
      v13 = v6 - v8;
      v14 = 4 * v8;
      v15 = (_DWORD *)(result + 4 * v8);
      v16 = (int *)(v5 + v14);
      do
      {
        v17 = *v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
      goto LABEL_18;
    }
    if (v5)
      goto LABEL_18;
  }
  return result;
}

void NFrame::~NFrame(NFrame *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F3090;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F3090;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

double BlobBuilder::buildChecksumHeader(BlobBuilder *this)
{
  double result;

  *(_QWORD *)&result = 1919706177;
  *((_OWORD *)this + 3) = xmmword_20DA24620;
  return result;
}

uint64_t BlobBuilder::serializeConfigHeader(uint64_t a1, uint64_t a2)
{
  int v3;

  v3 = 48;
  (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a2 + 72))(a2, a1, &v3);
  return 48;
}

uint64_t BlobBuilder::serializeChecksumHeader(uint64_t a1, uint64_t a2)
{
  int v3;

  v3 = 16;
  (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a2 + 72))(a2, a1 + 48, &v3);
  return 16;
}

uint64_t BlobBuilder::serializeDetectConfig(BlobBuilder *this, N16ByteAlignedString *a2)
{
  _DWORD *v3;
  int v5;
  int v6;

  v5 = 44;
  (*(void (**)(N16ByteAlignedString *, char *, int *))(*(_QWORD *)a2 + 72))(a2, (char *)this + 64, &v5);
  v3 = (_DWORD *)operator new[]();
  *v3 = 0;
  v6 = 4;
  (*(void (**)(N16ByteAlignedString *, _DWORD *, int *))(*(_QWORD *)a2 + 72))(a2, v3, &v6);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  return 48;
}

void sub_20D978710(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::serializeAcAnalConfig(BlobBuilder *this, N16ByteAlignedString *a2)
{
  uint64_t v3;
  int v5;
  int v6;

  v5 = 68;
  (*(void (**)(N16ByteAlignedString *, char *, int *))(*(_QWORD *)a2 + 72))(a2, (char *)this + 184, &v5);
  v3 = operator new[]();
  *(_QWORD *)v3 = 0;
  *(_DWORD *)(v3 + 8) = 0;
  v6 = 12;
  (*(void (**)(N16ByteAlignedString *, uint64_t, int *))(*(_QWORD *)a2 + 72))(a2, v3, &v6);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  return 80;
}

void sub_20D9787E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::serializeNormConfig(BlobBuilder *this, N16ByteAlignedString *a2)
{
  _DWORD *v3;
  int v5;
  int v6;

  v5 = 12;
  (*(void (**)(N16ByteAlignedString *, char *, int *))(*(_QWORD *)a2 + 72))(a2, (char *)this + 256, &v5);
  v3 = (_DWORD *)operator new[]();
  *v3 = 0;
  v6 = 4;
  (*(void (**)(N16ByteAlignedString *, _DWORD *, int *))(*(_QWORD *)a2 + 72))(a2, v3, &v6);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  return 16;
}

void sub_20D9788AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

size_t BlobBuilder::serializeHeap(BlobBuilder *this, N16ByteAlignedString *a2)
{
  int v2;
  size_t v3;
  void *v5;
  int v7;

  v2 = *((_DWORD *)a2 + 2);
  v3 = (40960 - v2);
  if (40960 - v2 <= 0)
    Error::chuck((Error *)"BlobBuilder: Cannot allocate heap", (const char *)a2);
  v5 = (void *)operator new[]();
  bzero(v5, v3);
  v7 = v3;
  (*(void (**)(N16ByteAlignedString *, void *, int *))(*(_QWORD *)a2 + 72))(a2, v5, &v7);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return v3;
}

void sub_20D978978(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::getConfigHeaderSize(BlobBuilder *this)
{
  return 48;
}

uint64_t BlobBuilder::getChecksumHeaderSize(BlobBuilder *this)
{
  return 16;
}

uint64_t BlobBuilder::getDetectorConfigSize(BlobBuilder *this)
{
  return 48;
}

uint64_t BlobBuilder::getAcAnalConfigSize(BlobBuilder *this)
{
  return 80;
}

uint64_t BlobBuilder::getNormConfigSize(BlobBuilder *this)
{
  return 16;
}

uint64_t BlobBuilder::getActualDistributionSize(BlobBuilder *this)
{
  return *((unsigned int *)this + 86);
}

uint64_t BlobBuilder::getDistributionSize(BlobBuilder *this)
{
  return (*((_DWORD *)this + 86) + 15) & 0xFFFFFFF0;
}

uint64_t BlobBuilder::getActualHmmArraySize(BlobBuilder *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  unsigned int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  int v14;
  unsigned int *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;

  v1 = *((unsigned int *)this + 44);
  if (!(_DWORD)v1)
    return 4;
  v2 = *((_QWORD *)this + 21);
  v3 = *((_QWORD *)this + 35);
  if (*((int *)this + 17) >= -1)
  {
    if ((_DWORD)v1 == 1)
    {
      v6 = 0;
      LODWORD(result) = 4;
    }
    else
    {
      v14 = 0;
      v6 = v1 & 0xFFFFFFFE;
      v15 = (unsigned int *)(v2 + 4);
      v16 = 4;
      v17 = v6;
      do
      {
        v16 += 8 * *(_DWORD *)(v3 + 48 * *(v15 - 1) + 16) + 4;
        v14 += 8 * *(_DWORD *)(v3 + 48 * *v15 + 16) + 4;
        v15 += 2;
        v17 -= 2;
      }
      while (v17);
      result = (v14 + v16);
      if (v6 == v1)
        return result;
    }
    v18 = v1 - v6;
    v19 = (unsigned int *)(v2 + 4 * v6);
    do
    {
      v20 = *v19++;
      result = (result + 8 * *(_DWORD *)(v3 + 48 * v20 + 16) + 4);
      --v18;
    }
    while (v18);
    return result;
  }
  if ((_DWORD)v1 == 1)
  {
    v4 = 0;
    LODWORD(result) = 4;
LABEL_11:
    v11 = v1 - v4;
    v12 = (unsigned int *)(v2 + 4 * v4);
    do
    {
      v13 = *v12++;
      result = (result + 8 * *(_DWORD *)(v3 + 48 * v13 + 16) + 12);
      --v11;
    }
    while (v11);
    return result;
  }
  v7 = 0;
  v4 = v1 & 0xFFFFFFFE;
  v8 = (unsigned int *)(v2 + 4);
  v9 = 4;
  v10 = v4;
  do
  {
    v9 += 8 * *(_DWORD *)(v3 + 48 * *(v8 - 1) + 16) + 12;
    v7 += 8 * *(_DWORD *)(v3 + 48 * *v8 + 16) + 12;
    v8 += 2;
    v10 -= 2;
  }
  while (v10);
  result = (v7 + v9);
  if (v4 != v1)
    goto LABEL_11;
  return result;
}

uint64_t BlobBuilder::getHmmArraySize(BlobBuilder *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  unsigned int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  int v14;
  unsigned int *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;

  v1 = *((unsigned int *)this + 44);
  if (!(_DWORD)v1)
  {
    v5 = 4;
    return (v5 + 15) & 0xFFFFFFF0;
  }
  v2 = *((_QWORD *)this + 21);
  v3 = *((_QWORD *)this + 35);
  if (*((int *)this + 17) >= -1)
  {
    if ((_DWORD)v1 == 1)
    {
      v6 = 0;
      v5 = 4;
    }
    else
    {
      v14 = 0;
      v6 = v1 & 0xFFFFFFFE;
      v15 = (unsigned int *)(v2 + 4);
      v16 = 4;
      v17 = v6;
      do
      {
        v16 += 8 * *(_DWORD *)(v3 + 48 * *(v15 - 1) + 16) + 4;
        v14 += 8 * *(_DWORD *)(v3 + 48 * *v15 + 16) + 4;
        v15 += 2;
        v17 -= 2;
      }
      while (v17);
      v5 = v14 + v16;
      if (v6 == v1)
        return (v5 + 15) & 0xFFFFFFF0;
    }
    v18 = v1 - v6;
    v19 = (unsigned int *)(v2 + 4 * v6);
    do
    {
      v20 = *v19++;
      v5 += 8 * *(_DWORD *)(v3 + 48 * v20 + 16) + 4;
      --v18;
    }
    while (v18);
    return (v5 + 15) & 0xFFFFFFF0;
  }
  if ((_DWORD)v1 == 1)
  {
    v4 = 0;
    v5 = 4;
LABEL_11:
    v11 = v1 - v4;
    v12 = (unsigned int *)(v2 + 4 * v4);
    do
    {
      v13 = *v12++;
      v5 += 8 * *(_DWORD *)(v3 + 48 * v13 + 16) + 12;
      --v11;
    }
    while (v11);
    return (v5 + 15) & 0xFFFFFFF0;
  }
  v7 = 0;
  v4 = v1 & 0xFFFFFFFE;
  v8 = (unsigned int *)(v2 + 4);
  v9 = 4;
  v10 = v4;
  do
  {
    v9 += 8 * *(_DWORD *)(v3 + 48 * *(v8 - 1) + 16) + 12;
    v7 += 8 * *(_DWORD *)(v3 + 48 * *v8 + 16) + 12;
    v8 += 2;
    v10 -= 2;
  }
  while (v10);
  v5 = v7 + v9;
  if (v4 != v1)
    goto LABEL_11;
  return (v5 + 15) & 0xFFFFFFF0;
}

float BlobBuilder::convertStrArrToFloatArr(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int *v5;
  const char *v6;
  float result;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;

  v5 = (unsigned int *)(a2 + 16);
  (*(void (**)(_QWORD *, uint64_t))(*a3 + 32))(a3, a2 + 16);
  if (*(_DWORD *)(a2 + 16))
  {
    v8 = 0;
    v9 = 0;
    v10 = *(_QWORD *)(a2 + 8);
    do
    {
      v11 = v10 + v8;
      if (!*(_DWORD *)(v10 + v8 + 8)
        || (v12 = 0,
            strtod(*(const char **)(v11 + 16), &v12),
            v10 = *(_QWORD *)(a2 + 8),
            v12 != (char *)(*(_QWORD *)(v11 + 16) + *(unsigned int *)(v11 + 8))))
      {
        Error::chuck((Error *)"BlobBuilder: unable to convert %s to float", v6, *(_QWORD *)(v10 + 24 * v9 + 16));
      }
      result = atof(*(const char **)(v10 + v8 + 16));
      *(float *)(a3[1] + 4 * v9++) = result;
      v8 += 24;
    }
    while (v9 < *v5);
  }
  return result;
}

void BlobBuilder::serializePadding(BlobBuilder *this, unsigned int a2, N16ByteAlignedString *a3)
{
  size_t v5;
  void *v6;
  unsigned int v7;

  if (a2)
  {
    v5 = a2;
    v6 = (void *)operator new[]();
    bzero(v6, v5);
    v7 = a2;
    (*(void (**)(N16ByteAlignedString *, void *, unsigned int *))(*(_QWORD *)a3 + 72))(a3, v6, &v7);
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  }
}

void sub_20D978DF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NMemPool::getAlignedSize(NMemPool *this)
{
  unsigned int v1;

  v1 = NMemPool::m_iAlignBytes - this % NMemPool::m_iAlignBytes;
  if (!(this % NMemPool::m_iAlignBytes))
    v1 = 0;
  return v1 + this;
}

void NMemPool::init(NMemPool *this, const char *a2, int a3)
{
  if (!this)
    Error::chuck((Error *)"NMemPool::init - no memory provided", a2);
  if (!a3)
    Error::chuck((Error *)"NMemPool::init - byte alignment should be >1", a2);
  if (!NMemPool::m_bLocked)
    Error::chuck((Error *)"NMemPool::init - second call to init() before lock()", a2);
  if (a2 >> 30)
    Error::chuck((Error *)"NMemPool::init - pool size too large", a2);
  NMemPool::m_pData = (uint64_t)this;
  NMemPool::m_iSize = (int)a2;
  NMemPool::m_iAlignBytes = a3;
  NMemPool::m_bLocked = 0;
  NMemPool::m_iPos = 0;
  bzero(this, a2);
}

uint64_t NMemPool::getMem(NMemPool *this, const char *a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;

  if (NMemPool::m_bLocked)
    Error::chuck((Error *)"NMemPool::getMem - memory locked", a2);
  if (this % NMemPool::m_iAlignBytes)
    v2 = NMemPool::m_iAlignBytes - this % NMemPool::m_iAlignBytes;
  else
    v2 = 0;
  if (this >> 30
    || (v3 = NMemPool::m_iPos, v4 = NMemPool::m_iPos + (_DWORD)this + v2, v4 > NMemPool::m_iSize))
  {
    Error::chuck((Error *)"NMemPool::getMem - memory bound violation", a2);
  }
  NMemPool::m_iPos = v4;
  return NMemPool::m_pData + v3;
}

uint64_t NMemPool::lock(uint64_t this)
{
  NMemPool::m_bLocked = this;
  return this;
}

uint64_t NMemPool::isLocked(NMemPool *this)
{
  return NMemPool::m_bLocked;
}

uint64_t NMemPool::report(NMemPool *this, const char *a2)
{
  return Error::warning((Error *)"MemPool::report - size: %d align: %d:  pos: %d  locked: %d", a2, NMemPool::m_iSize, NMemPool::m_iAlignBytes, NMemPool::m_iPos, NMemPool::m_bLocked);
}

uint64_t _AFLanguageDidChangeCallback(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_didReceiveLanguageCodeUpdate");
}

void sub_20D979C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21)
{
  id *v21;
  id *v22;
  id *v23;

  objc_destroyWeak(v23);
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  objc_destroyWeak(v21);
  objc_destroyWeak(&a21);
  _Unwind_Resume(a1);
}

void TSHMMDetector::~TSHMMDetector(TSHMMDetector *this)
{
  TSHMMDetector::~TSHMMDetector(this);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  *(_QWORD *)this = &off_24C7F1820;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    if (!*((_QWORD *)this + 3)
      || ((*(void (**)(uint64_t))(*(_QWORD *)v2 + 152))(v2), (v2 = *((_QWORD *)this + 1)) != 0))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  v3 = *((_QWORD *)this + 2);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)this + 40) = &off_24C7F3058;
  v4 = *((_QWORD *)this + 41);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  *((_QWORD *)this + 37) = &off_24C7F2D80;
  v5 = *((_QWORD *)this + 38);
  if (v5)
  {
    v6 = v5 - 16;
    v7 = *(_QWORD *)(v5 - 8);
    if (v7)
    {
      v8 = 48 * v7;
      v9 = v5 - 24;
      do
      {
        v10 = v9 + v8;
        *(_QWORD *)(v9 + v8) = &off_24C7F3100;
        v11 = *(_QWORD *)(v9 + v8 + 8);
        if (v11)
          MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
        *(_QWORD *)(v10 - 24) = &off_24C7F3090;
        v12 = *(_QWORD *)(v10 - 16);
        if (v12)
          MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
        v8 -= 48;
      }
      while (v8);
    }
    MEMORY[0x212BAC9C0](v6, 0x1090C80405A4B77);
  }
  *((_QWORD *)this + 34) = &off_24C7F3090;
  v13 = *((_QWORD *)this + 35);
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
  *((_QWORD *)this + 31) = &off_24C7F3090;
  v14 = *((_QWORD *)this + 32);
  if (v14)
    MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
  *((_QWORD *)this + 28) = &off_24C7F3090;
  v15 = *((_QWORD *)this + 29);
  if (v15)
    MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
  *((_QWORD *)this + 20) = &off_24C7F2C30;
  v16 = *((_QWORD *)this + 21);
  if (v16)
  {
    v17 = v16 - 16;
    v18 = *(_QWORD *)(v16 - 8);
    if (v18)
    {
      v19 = 88 * v18;
      v20 = v16 - 32;
      do
      {
        v21 = v20 + v19;
        *(_QWORD *)(v20 + v19) = &off_24C7F3100;
        v22 = *(_QWORD *)(v20 + v19 + 8);
        if (v22)
          MEMORY[0x212BAC9C0](v22, 0x1000C8052888210);
        *(_QWORD *)(v21 - 24) = &off_24C7F3090;
        v23 = *(_QWORD *)(v21 - 16);
        if (v23)
          MEMORY[0x212BAC9C0](v23, 0x1000C8052888210);
        *(_QWORD *)(v20 + v19 - 48) = &off_24C7F3090;
        v24 = *(_QWORD *)(v20 + v19 - 40);
        if (v24)
          MEMORY[0x212BAC9C0](v24, 0x1000C8052888210);
        v19 -= 88;
      }
      while (v19);
    }
    MEMORY[0x212BAC9C0](v17, 0x1090C806998C76BLL);
  }
  *((_QWORD *)this + 14) = &off_24C7F2FE8;
  v25 = *((_QWORD *)this + 15);
  if (v25)
  {
    v26 = *(_QWORD *)(v25 - 8);
    if (v26)
    {
      v27 = 24 * v26;
      do
      {
        *(_QWORD *)(v25 + v27 - 24) = &off_24C7F3058;
        v28 = *(_QWORD *)(v25 + v27 - 16);
        if (v28)
          MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
        v27 -= 24;
      }
      while (v27);
    }
    MEMORY[0x212BAC9C0](v25 - 16, 0x1091C80FBD4B0D6);
  }
  *((_QWORD *)this + 10) = &off_24C7F3090;
  v29 = *((_QWORD *)this + 11);
  if (v29)
    MEMORY[0x212BAC9C0](v29, 0x1000C8052888210);
}

_QWORD *NArray<NArray<BOOL>>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2FE8;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 24 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 24) = &off_24C7F3058;
        v5 = *(_QWORD *)(v2 + v4 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x1091C80FBD4B0D6);
  }
  return a1;
}

void NArray<NArray<BOOL>>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F2FE8;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F3058;
        v4 = *(_QWORD *)(v1 + v3 - 16);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1091C80FBD4B0D6);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NArray<BOOL>>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 - 8);
      if (v7)
      {
        v8 = 24 * v7;
        do
        {
          *(_QWORD *)(v6 + v8 - 24) = &off_24C7F3058;
          v9 = *(_QWORD *)(v6 + v8 - 16);
          if (v9)
            MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
          v8 -= 24;
        }
        while (v8);
      }
      MEMORY[0x212BAC9C0](v6 - 16, 0x1091C80FBD4B0D6);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v10 = 24 * v5;
    v11 = (_QWORD *)operator new[]();
    *v11 = 24;
    v11[1] = v5;
    v12 = v11 + 2;
    if (!v5)
      goto LABEL_17;
    v13 = v11 + 2;
    if ((unint64_t)(v10 - 24) >= 0x18)
    {
      v14 = (v10 - 24) / 0x18uLL + 1;
      v15 = v11 + 4;
      v16 = v14 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v15 - 2) = &off_24C7F3058;
        *(v15 - 1) = 0;
        v15[1] = &off_24C7F3058;
        v15[2] = 0;
        *(_DWORD *)v15 = 0;
        *((_DWORD *)v15 + 6) = 0;
        v15 += 6;
        v16 -= 2;
      }
      while (v16);
      if (v14 == (v14 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_17;
      v13 = &v12[3 * (v14 & 0x1FFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v13 = &off_24C7F3058;
      v13[1] = 0;
      *((_DWORD *)v13 + 4) = 0;
      v13 += 3;
    }
    while (v13 != &v12[3 * v5]);
LABEL_17:
    *(_QWORD *)(a1 + 8) = v12;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v17) + 16))(*(_QWORD *)(a1 + 8) + v17, *(_QWORD *)(a2 + 8) + v17);
      ++v18;
      v17 += 24;
    }
    while (v18 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NArray<NArray<BOOL>>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = 24 * v9;
        do
        {
          *(_QWORD *)(v7 + v10 - 24) = &off_24C7F3058;
          v11 = *(_QWORD *)(v7 + v10 - 16);
          if (v11)
            MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x1091C80FBD4B0D6);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v12 = 24 * v6;
    result = operator new[]();
    *(_QWORD *)result = 24;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (!v6)
      goto LABEL_16;
    v14 = result + 16;
    if ((unint64_t)(v12 - 24) >= 0x18)
    {
      v15 = (v12 - 24) / 0x18uLL + 1;
      v16 = result + 32;
      v17 = v15 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(_QWORD *)(v16 - 16) = &off_24C7F3058;
        *(_QWORD *)(v16 - 8) = 0;
        *(_QWORD *)(v16 + 8) = &off_24C7F3058;
        *(_QWORD *)(v16 + 16) = 0;
        *(_DWORD *)v16 = 0;
        *(_DWORD *)(v16 + 24) = 0;
        v16 += 48;
        v17 -= 2;
      }
      while (v17);
      if (v15 == (v15 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_16;
      v14 = v13 + 24 * (v15 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v14 = &off_24C7F3058;
      *(_QWORD *)(v14 + 8) = 0;
      *(_DWORD *)(v14 + 16) = 0;
      v14 += 24;
    }
    while (v14 != v13 + 24 * v6);
LABEL_16:
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + v18) + 16))(*(_QWORD *)(v4 + 8) + v18, a2 + v18);
      ++v19;
      v18 += 24;
    }
    while (v19 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NArray<BOOL>>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 24 * v3;
  result = operator new[]();
  *(_QWORD *)result = 24;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = result + 16;
    if ((unint64_t)(v7 - 24) >= 0x18)
    {
      v10 = (v7 - 24) / 0x18uLL + 1;
      v11 = result + 32;
      v12 = v10 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(_QWORD *)(v11 - 16) = &off_24C7F3058;
        *(_QWORD *)(v11 - 8) = 0;
        *(_QWORD *)(v11 + 8) = &off_24C7F3058;
        *(_QWORD *)(v11 + 16) = 0;
        *(_DWORD *)v11 = 0;
        *(_DWORD *)(v11 + 24) = 0;
        v11 += 48;
        v12 -= 2;
      }
      while (v12);
      if (v10 == (v10 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_9;
      v9 = v8 + 24 * (v10 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v9 = &off_24C7F3058;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      v9 += 24;
    }
    while (v9 != v8 + 24 * v3);
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v8;
  if ((_DWORD)v2 && *a2)
  {
    v13 = 0;
    v14 = 1;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 8) + v13) + 16))(*(_QWORD *)(v5 + 8) + v13, v6 + v13);
      if (v14 >= v2)
        break;
      v13 += 24;
    }
    while (v14++ < *a2);
  }
  if (v6)
  {
    v16 = *(_QWORD *)(v6 - 8);
    if (v16)
    {
      v17 = 24 * v16;
      do
      {
        *(_QWORD *)(v6 + v17 - 24) = &off_24C7F3058;
        v18 = *(_QWORD *)(v6 + v17 - 16);
        if (v18)
          MEMORY[0x212BAC9C0](v18, 0x1000C8077774924);
        v17 -= 24;
      }
      while (v17);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

_QWORD *NArray<NLRHMMModel>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a1 = &off_24C7F2C30;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 88 * v4;
      v6 = v2 - 32;
      do
      {
        v7 = v6 + v5;
        *(_QWORD *)(v6 + v5) = &off_24C7F3100;
        v8 = *(_QWORD *)(v6 + v5 + 8);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *(_QWORD *)(v7 - 24) = &off_24C7F3090;
        v9 = *(_QWORD *)(v7 - 16);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        *(_QWORD *)(v6 + v5 - 48) = &off_24C7F3090;
        v10 = *(_QWORD *)(v6 + v5 - 40);
        if (v10)
          MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
        v5 -= 88;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x1090C806998C76BLL);
  }
  return a1;
}

void NArray<NLRHMMModel>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2C30;
  v1 = a1[1];
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = 88 * v3;
      v5 = v1 - 32;
      do
      {
        v6 = v5 + v4;
        *(_QWORD *)(v5 + v4) = &off_24C7F3100;
        v7 = *(_QWORD *)(v5 + v4 + 8);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        *(_QWORD *)(v6 - 24) = &off_24C7F3090;
        v8 = *(_QWORD *)(v6 - 16);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *(_QWORD *)(v5 + v4 - 48) = &off_24C7F3090;
        v9 = *(_QWORD *)(v5 + v4 - 40);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v4 -= 88;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2, 0x1090C806998C76BLL);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NLRHMMModel>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = v6 - 16;
        v8 = *(_QWORD *)(v6 - 8);
        if (v8)
        {
          v9 = 88 * v8;
          v10 = v6 - 32;
          do
          {
            v11 = v10 + v9;
            *(_QWORD *)(v10 + v9) = &off_24C7F3100;
            v12 = *(_QWORD *)(v10 + v9 + 8);
            if (v12)
              MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
            *(_QWORD *)(v11 - 24) = &off_24C7F3090;
            v13 = *(_QWORD *)(v11 - 16);
            if (v13)
              MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
            *(_QWORD *)(v10 + v9 - 48) = &off_24C7F3090;
            v14 = *(_QWORD *)(v10 + v9 - 40);
            if (v14)
              MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
            v9 -= 88;
          }
          while (v9);
        }
        MEMORY[0x212BAC9C0](v7, 0x1090C806998C76BLL);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v15 = (_QWORD *)operator new[]();
      *v15 = 88;
      v15[1] = v5;
      v16 = v15 + 2;
      if (v5)
      {
        v17 = v15 + 2;
        do
        {
          *(_DWORD *)v17 = 0;
          v17[1] = &off_24C7F3090;
          v17[2] = 0;
          *((_DWORD *)v17 + 6) = 0;
          v17[4] = &off_24C7F3090;
          v17[5] = 0;
          *((_DWORD *)v17 + 12) = 0;
          v17[7] = &off_24C7F3100;
          v17[8] = 0;
          *((_DWORD *)v17 + 18) = 0;
          *((_BYTE *)v17 + 80) = 0;
          v17 += 11;
        }
        while (v17 != &v16[11 * v5]);
      }
      *(_QWORD *)(a1 + 8) = v16;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v18 = 0;
      v19 = 0;
      do
      {
        NLRHMMModel::operator=(*(_QWORD *)(a1 + 8) + v18, *(_QWORD *)(a2 + 8) + v18);
        ++v19;
        v18 += 88;
      }
      while (v19 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<NLRHMMModel>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = v7 - 16;
      v10 = *(_QWORD *)(v7 - 8);
      if (v10)
      {
        v11 = 88 * v10;
        v12 = v7 - 32;
        do
        {
          v13 = v12 + v11;
          *(_QWORD *)(v12 + v11) = &off_24C7F3100;
          v14 = *(_QWORD *)(v12 + v11 + 8);
          if (v14)
            MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
          *(_QWORD *)(v13 - 24) = &off_24C7F3090;
          v15 = *(_QWORD *)(v13 - 16);
          if (v15)
            MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
          *(_QWORD *)(v12 + v11 - 48) = &off_24C7F3090;
          v16 = *(_QWORD *)(v12 + v11 - 40);
          if (v16)
            MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
          v11 -= 88;
        }
        while (v11);
      }
      MEMORY[0x212BAC9C0](v9, 0x1090C806998C76BLL);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)result = 88;
    *(_QWORD *)(result + 8) = v6;
    v17 = result + 16;
    if (v6)
    {
      v18 = result + 16;
      do
      {
        *(_DWORD *)v18 = 0;
        *(_QWORD *)(v18 + 8) = &off_24C7F3090;
        *(_QWORD *)(v18 + 16) = 0;
        *(_DWORD *)(v18 + 24) = 0;
        *(_QWORD *)(v18 + 32) = &off_24C7F3090;
        *(_QWORD *)(v18 + 40) = 0;
        *(_DWORD *)(v18 + 48) = 0;
        *(_QWORD *)(v18 + 56) = &off_24C7F3100;
        *(_QWORD *)(v18 + 64) = 0;
        *(_DWORD *)(v18 + 72) = 0;
        *(_BYTE *)(v18 + 80) = 0;
        v18 += 88;
      }
      while (v18 != v17 + 88 * v6);
    }
    *(_QWORD *)(v4 + 8) = v17;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v19 = 0;
    v20 = 0;
    do
    {
      result = NLRHMMModel::operator=(*(_QWORD *)(v4 + 8) + v19, a2 + v19);
      ++v20;
      v19 += 88;
    }
    while (v20 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLRHMMModel>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 88;
    *(_QWORD *)(result + 8) = v3;
    v7 = result + 16;
    if ((_DWORD)v3)
    {
      v8 = result + 16;
      do
      {
        *(_DWORD *)v8 = 0;
        *(_QWORD *)(v8 + 8) = &off_24C7F3090;
        *(_QWORD *)(v8 + 16) = 0;
        *(_DWORD *)(v8 + 24) = 0;
        *(_QWORD *)(v8 + 32) = &off_24C7F3090;
        *(_QWORD *)(v8 + 40) = 0;
        *(_DWORD *)(v8 + 48) = 0;
        *(_QWORD *)(v8 + 56) = &off_24C7F3100;
        *(_QWORD *)(v8 + 64) = 0;
        *(_DWORD *)(v8 + 72) = 0;
        *(_BYTE *)(v8 + 80) = 0;
        v8 += 88;
      }
      while (v8 != v7 + 88 * v3);
    }
    *(_QWORD *)(v5 + 8) = v7;
    if ((_DWORD)v2 && *a2)
    {
      v9 = 0;
      v10 = 1;
      do
      {
        result = NLRHMMModel::operator=(*(_QWORD *)(v5 + 8) + v9, v6 + v9);
        if (v10 >= v2)
          break;
        v9 += 88;
      }
      while (v10++ < *a2);
    }
    if (v6)
    {
      v12 = *(_QWORD *)(v6 - 8);
      if (v12)
      {
        v13 = 88 * v12;
        v14 = v6 - 32;
        do
        {
          v15 = v14 + v13;
          *(_QWORD *)(v14 + v13) = &off_24C7F3100;
          v16 = *(_QWORD *)(v14 + v13 + 8);
          if (v16)
            MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
          *(_QWORD *)(v15 - 24) = &off_24C7F3090;
          v17 = *(_QWORD *)(v15 - 16);
          if (v17)
            MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
          *(_QWORD *)(v14 + v13 - 48) = &off_24C7F3090;
          v18 = *(_QWORD *)(v14 + v13 - 40);
          if (v18)
            MEMORY[0x212BAC9C0](v18, 0x1000C8052888210);
          v13 -= 88;
        }
        while (v13);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

uint64_t NLRHMMModel::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int *v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 24);
    v5 = *(_DWORD *)(a2 + 24);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 16);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 24);
      }
      *(_DWORD *)(a1 + 24) = v5;
      *(_QWORD *)(a1 + 16) = operator new[]();
      v4 = *(_DWORD *)(a1 + 24);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 16);
      v9 = *(_QWORD *)(a1 + 16);
      v10 = v4;
      if (v4 < 8)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF8;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 4 * v7;
        v17 = (_DWORD *)(v9 + v16);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    v20 = *(_DWORD *)(a1 + 48);
    v21 = *(_DWORD *)(a2 + 48);
    if (v20 != v21)
    {
      v22 = *(_QWORD *)(a1 + 40);
      if (v22)
      {
        MEMORY[0x212BAC9C0](v22, 0x1000C8052888210);
        v21 = *(_DWORD *)(a2 + 48);
      }
      *(_DWORD *)(a1 + 48) = v21;
      *(_QWORD *)(a1 + 40) = operator new[]();
      v20 = *(_DWORD *)(a1 + 48);
    }
    if (v20)
    {
      v23 = 0;
      v24 = *(_QWORD *)(a2 + 40);
      v25 = *(_QWORD *)(a1 + 40);
      v26 = v20;
      if (v20 < 8)
        goto LABEL_24;
      if ((unint64_t)(v25 - v24) < 0x20)
        goto LABEL_24;
      v23 = v20 & 0xFFFFFFF8;
      v27 = (_OWORD *)(v25 + 16);
      v28 = (__int128 *)(v24 + 16);
      v29 = v26 & 0xFFFFFFF8;
      do
      {
        v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v23 != v26)
      {
LABEL_24:
        v31 = v26 - v23;
        v32 = 4 * v23;
        v33 = (_DWORD *)(v25 + v32);
        v34 = (int *)(v24 + v32);
        do
        {
          v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
    }
    v36 = *(_DWORD *)(a1 + 72);
    v37 = *(_DWORD *)(a2 + 72);
    if (v36 != v37)
    {
      v38 = *(_QWORD *)(a1 + 64);
      if (v38)
      {
        MEMORY[0x212BAC9C0](v38, 0x1000C8052888210);
        v37 = *(_DWORD *)(a2 + 72);
      }
      *(_DWORD *)(a1 + 72) = v37;
      *(_QWORD *)(a1 + 64) = operator new[]();
      v36 = *(_DWORD *)(a1 + 72);
    }
    if (v36)
    {
      v39 = 0;
      v40 = *(_QWORD *)(a2 + 64);
      v41 = *(_QWORD *)(a1 + 64);
      do
      {
        *(_DWORD *)(v41 + 4 * v39) = *(_DWORD *)(v40 + 4 * v39);
        ++v39;
      }
      while (v39 < *(unsigned int *)(a1 + 72));
    }
  }
  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
  return a1;
}

_QWORD *NArray<NLRHMMStateTokens>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2D80;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 48 * v4;
      v6 = v2 - 24;
      do
      {
        v7 = v6 + v5;
        *(_QWORD *)(v6 + v5) = &off_24C7F3100;
        v8 = *(_QWORD *)(v6 + v5 + 8);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *(_QWORD *)(v7 - 24) = &off_24C7F3090;
        v9 = *(_QWORD *)(v7 - 16);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v5 -= 48;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x1090C80405A4B77);
  }
  return a1;
}

void NArray<NLRHMMStateTokens>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = &off_24C7F2D80;
  v1 = a1[1];
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = 48 * v3;
      v5 = v1 - 24;
      do
      {
        v6 = v5 + v4;
        *(_QWORD *)(v5 + v4) = &off_24C7F3100;
        v7 = *(_QWORD *)(v5 + v4 + 8);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        *(_QWORD *)(v6 - 24) = &off_24C7F3090;
        v8 = *(_QWORD *)(v6 - 16);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2, 0x1090C80405A4B77);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NLRHMMStateTokens>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = v6 - 16;
      v8 = *(_QWORD *)(v6 - 8);
      if (v8)
      {
        v9 = 48 * v8;
        v10 = v6 - 24;
        do
        {
          v11 = v10 + v9;
          *(_QWORD *)(v10 + v9) = &off_24C7F3100;
          v12 = *(_QWORD *)(v10 + v9 + 8);
          if (v12)
            MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
          *(_QWORD *)(v11 - 24) = &off_24C7F3090;
          v13 = *(_QWORD *)(v11 - 16);
          if (v13)
            MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
          v9 -= 48;
        }
        while (v9);
      }
      MEMORY[0x212BAC9C0](v7, 0x1090C80405A4B77);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v14 = 48 * v5;
    v15 = (_QWORD *)operator new[]();
    *v15 = 48;
    v15[1] = v5;
    v16 = v15 + 2;
    if (!v5)
      goto LABEL_19;
    v17 = v15 + 2;
    if ((unint64_t)(v14 - 48) >= 0x30)
    {
      v18 = (v14 - 48) / 0x30uLL + 1;
      v19 = v15 + 13;
      v20 = v18 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v19 - 11) = &off_24C7F3090;
        *((_QWORD *)v19 - 10) = 0;
        *((_QWORD *)v19 - 5) = &off_24C7F3090;
        *((_QWORD *)v19 - 4) = 0;
        *(v19 - 18) = 0;
        *(v19 - 6) = 0;
        *((_QWORD *)v19 - 8) = &off_24C7F3100;
        *((_QWORD *)v19 - 7) = 0;
        *((_QWORD *)v19 - 2) = &off_24C7F3100;
        *((_QWORD *)v19 - 1) = 0;
        *(v19 - 12) = 0;
        *v19 = 0;
        v19 += 24;
        v20 -= 2;
      }
      while (v20);
      if (v18 == (v18 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_19;
      v17 = &v16[6 * (v18 & 0xFFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v17 = &off_24C7F3090;
      v17[1] = 0;
      *((_DWORD *)v17 + 4) = 0;
      v17[3] = &off_24C7F3100;
      v17[4] = 0;
      *((_DWORD *)v17 + 10) = 0;
      v17 += 6;
    }
    while (v17 != &v16[6 * v5]);
LABEL_19:
    *(_QWORD *)(a1 + 8) = v16;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
  {
    v21 = 0;
    v22 = 0;
    do
    {
      NLRHMMStateTokens::operator=(*(_QWORD *)(a1 + 8) + v21, *(_QWORD *)(a2 + 8) + v21);
      ++v22;
      v21 += 48;
    }
    while (v22 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NArray<NLRHMMStateTokens>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = v7 - 16;
      v10 = *(_QWORD *)(v7 - 8);
      if (v10)
      {
        v11 = 48 * v10;
        v12 = v7 - 24;
        do
        {
          v13 = v12 + v11;
          *(_QWORD *)(v12 + v11) = &off_24C7F3100;
          v14 = *(_QWORD *)(v12 + v11 + 8);
          if (v14)
            MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
          *(_QWORD *)(v13 - 24) = &off_24C7F3090;
          v15 = *(_QWORD *)(v13 - 16);
          if (v15)
            MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
          v11 -= 48;
        }
        while (v11);
      }
      MEMORY[0x212BAC9C0](v9, 0x1090C80405A4B77);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v16 = 48 * v6;
    result = operator new[]();
    *(_QWORD *)result = 48;
    *(_QWORD *)(result + 8) = v6;
    v17 = result + 16;
    if (!v6)
      goto LABEL_18;
    v18 = result + 16;
    if ((unint64_t)(v16 - 48) >= 0x30)
    {
      v19 = (v16 - 48) / 0x30uLL + 1;
      v20 = (_DWORD *)(result + 104);
      v21 = v19 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v20 - 11) = &off_24C7F3090;
        *((_QWORD *)v20 - 10) = 0;
        *((_QWORD *)v20 - 5) = &off_24C7F3090;
        *((_QWORD *)v20 - 4) = 0;
        *(v20 - 18) = 0;
        *(v20 - 6) = 0;
        *((_QWORD *)v20 - 8) = &off_24C7F3100;
        *((_QWORD *)v20 - 7) = 0;
        *((_QWORD *)v20 - 2) = &off_24C7F3100;
        *((_QWORD *)v20 - 1) = 0;
        *(v20 - 12) = 0;
        *v20 = 0;
        v20 += 24;
        v21 -= 2;
      }
      while (v21);
      if (v19 == (v19 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_18;
      v18 = v17 + 48 * (v19 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v18 = &off_24C7F3090;
      *(_QWORD *)(v18 + 8) = 0;
      *(_DWORD *)(v18 + 16) = 0;
      *(_QWORD *)(v18 + 24) = &off_24C7F3100;
      *(_QWORD *)(v18 + 32) = 0;
      *(_DWORD *)(v18 + 40) = 0;
      v18 += 48;
    }
    while (v18 != v17 + 48 * v6);
LABEL_18:
    *(_QWORD *)(v4 + 8) = v17;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v22 = 0;
    v23 = 0;
    do
    {
      result = NLRHMMStateTokens::operator=(*(_QWORD *)(v4 + 8) + v22, a2 + v22);
      ++v23;
      v22 += 48;
    }
    while (v23 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLRHMMStateTokens>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 48 * v3;
  result = operator new[]();
  *(_QWORD *)result = 48;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = result + 16;
    if ((unint64_t)(v7 - 48) >= 0x30)
    {
      v10 = (v7 - 48) / 0x30uLL + 1;
      v11 = (_DWORD *)(result + 104);
      v12 = v10 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v11 - 11) = &off_24C7F3090;
        *((_QWORD *)v11 - 10) = 0;
        *((_QWORD *)v11 - 5) = &off_24C7F3090;
        *((_QWORD *)v11 - 4) = 0;
        *(v11 - 18) = 0;
        *(v11 - 6) = 0;
        *((_QWORD *)v11 - 8) = &off_24C7F3100;
        *((_QWORD *)v11 - 7) = 0;
        *((_QWORD *)v11 - 2) = &off_24C7F3100;
        *((_QWORD *)v11 - 1) = 0;
        *(v11 - 12) = 0;
        *v11 = 0;
        v11 += 24;
        v12 -= 2;
      }
      while (v12);
      if (v10 == (v10 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_9;
      v9 = v8 + 48 * (v10 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v9 = &off_24C7F3090;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      *(_QWORD *)(v9 + 24) = &off_24C7F3100;
      *(_QWORD *)(v9 + 32) = 0;
      *(_DWORD *)(v9 + 40) = 0;
      v9 += 48;
    }
    while (v9 != v8 + 48 * v3);
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v8;
  if ((_DWORD)v2 && *a2)
  {
    v13 = 0;
    v14 = 1;
    do
    {
      result = NLRHMMStateTokens::operator=(*(_QWORD *)(v5 + 8) + v13, v6 + v13);
      if (v14 >= v2)
        break;
      v13 += 48;
    }
    while (v14++ < *a2);
  }
  if (v6)
  {
    v16 = *(_QWORD *)(v6 - 8);
    if (v16)
    {
      v17 = 48 * v16;
      v18 = v6 - 24;
      do
      {
        v19 = v18 + v17;
        *(_QWORD *)(v18 + v17) = &off_24C7F3100;
        v20 = *(_QWORD *)(v18 + v17 + 8);
        if (v20)
          MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
        *(_QWORD *)(v19 - 24) = &off_24C7F3090;
        v21 = *(_QWORD *)(v19 - 16);
        if (v21)
          MEMORY[0x212BAC9C0](v21, 0x1000C8052888210);
        v17 -= 48;
      }
      while (v17);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

uint64_t NLRHMMStateTokens::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 8)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF8;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 4 * v7;
        v17 = (_DWORD *)(v9 + v16);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    v20 = *(_DWORD *)(a1 + 40);
    v21 = *(_DWORD *)(a2 + 40);
    if (v20 != v21)
    {
      v22 = *(_QWORD *)(a1 + 32);
      if (v22)
      {
        MEMORY[0x212BAC9C0](v22, 0x1000C8052888210);
        v21 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(a1 + 40) = v21;
      *(_QWORD *)(a1 + 32) = operator new[]();
      v20 = *(_DWORD *)(a1 + 40);
    }
    if (v20)
    {
      v23 = 0;
      v24 = *(_QWORD *)(a2 + 32);
      v25 = *(_QWORD *)(a1 + 32);
      do
      {
        *(_DWORD *)(v25 + 4 * v23) = *(_DWORD *)(v24 + 4 * v23);
        ++v23;
      }
      while (v23 < *(unsigned int *)(a1 + 40));
    }
  }
  return a1;
}

_QWORD *NArray<BOOL>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3058;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  return a1;
}

void NArray<BOOL>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3058;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<BOOL>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  char *v22;
  char v23;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 8 || (unint64_t)(v9 - v8) < 0x20)
        goto LABEL_18;
      if (v4 >= 0x20)
      {
        v7 = v4 & 0xFFFFFFE0;
        v11 = (_OWORD *)(v9 + 16);
        v12 = (__int128 *)(v8 + 16);
        v13 = v10 & 0xFFFFFFE0;
        do
        {
          v14 = *v12;
          *(v11 - 1) = *(v12 - 1);
          *v11 = v14;
          v11 += 2;
          v12 += 2;
          v13 -= 32;
        }
        while (v13);
        if (v7 == v10)
          return a1;
        if ((v10 & 0x18) == 0)
        {
LABEL_18:
          v20 = v10 - v7;
          v21 = (_BYTE *)(v9 + v7);
          v22 = (char *)(v8 + v7);
          do
          {
            v23 = *v22++;
            *v21++ = v23;
            --v20;
          }
          while (v20);
          return a1;
        }
      }
      else
      {
        v7 = 0;
      }
      v15 = v7;
      v7 = v10 & 0xFFFFFFF8;
      v16 = v15 - v7;
      v17 = (_QWORD *)(v9 + v15);
      v18 = (uint64_t *)(v8 + v15);
      do
      {
        v19 = *v18++;
        *v17++ = v19;
        v16 += 8;
      }
      while (v16);
      if (v7 != v10)
        goto LABEL_18;
    }
  }
  return a1;
}

uint64_t NArray<BOOL>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  char *v24;
  char v25;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = *(_QWORD *)(v4 + 8);
    v10 = v5;
    if (v5 < 8 || (unint64_t)(v9 - a2) <= 0x1F)
    {
      v12 = 0;
      goto LABEL_20;
    }
    if (v5 >= 0x20)
    {
      v12 = v5 & 0xFFFFFFE0;
      v13 = (_OWORD *)(v9 + 16);
      v14 = (__int128 *)(a2 + 16);
      v15 = v10 & 0xFFFFFFE0;
      do
      {
        v16 = *v14;
        *(v13 - 1) = *(v14 - 1);
        *v13 = v16;
        v13 += 2;
        v14 += 2;
        v15 -= 32;
      }
      while (v15);
      if (v12 == v10)
        return result;
      if ((v10 & 0x18) == 0)
      {
LABEL_20:
        v22 = v10 - v12;
        v23 = (_BYTE *)(v9 + v12);
        v24 = (char *)(a2 + v12);
        do
        {
          v25 = *v24++;
          *v23++ = v25;
          --v22;
        }
        while (v22);
        return result;
      }
    }
    else
    {
      v12 = 0;
    }
    v17 = v12;
    v12 = v10 & 0xFFFFFFF8;
    v18 = v17 - v12;
    v19 = (_QWORD *)(v9 + v17);
    v20 = (uint64_t *)(a2 + v17);
    do
    {
      v21 = *v20++;
      *v19++ = v21;
      v18 += 8;
    }
    while (v18);
    if (v12 != v10)
      goto LABEL_20;
  }
  return result;
}

uint64_t NArray<BOOL>::resize(uint64_t a1, unsigned int *a2)
{
  unsigned int v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  _OWORD *v10;
  __int128 *v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  char *v21;
  char v22;

  v3 = *(_DWORD *)(a1 + 16);
  result = *a2;
  if (v3 != (_DWORD)result)
  {
    v6 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 16) = result;
    result = operator new[]();
    *(_QWORD *)(a1 + 8) = result;
    LODWORD(v7) = *a2;
    if (v3 >= *a2)
      v7 = v7;
    else
      v7 = v3;
    if ((_DWORD)v7)
    {
      if (v7 < 8 || (unint64_t)(result - v6) <= 0x1F)
      {
        v9 = 0;
        goto LABEL_22;
      }
      if (v7 >= 0x20)
      {
        v9 = v7 & 0xFFFFFFE0;
        v10 = (_OWORD *)(result + 16);
        v11 = (__int128 *)(v6 + 16);
        v12 = v9;
        do
        {
          v13 = *v11;
          *(v10 - 1) = *(v11 - 1);
          *v10 = v13;
          v10 += 2;
          v11 += 2;
          v12 -= 32;
        }
        while (v12);
        if (v9 == v7)
          goto LABEL_24;
        if ((v7 & 0x18) == 0)
        {
LABEL_22:
          v19 = v7 - v9;
          v20 = (_BYTE *)(result + v9);
          v21 = (char *)(v6 + v9);
          do
          {
            v22 = *v21++;
            *v20++ = v22;
            --v19;
          }
          while (v19);
          goto LABEL_24;
        }
      }
      else
      {
        v9 = 0;
      }
      v14 = v9;
      v9 = v7 & 0xFFFFFFF8;
      v15 = v14 - v9;
      v16 = (_QWORD *)(result + v14);
      v17 = (uint64_t *)(v6 + v14);
      do
      {
        v18 = *v17++;
        *v16++ = v18;
        v15 += 8;
      }
      while (v15);
      if (v9 != v7)
        goto LABEL_22;
LABEL_24:
      JUMPOUT(0x212BAC9C0);
    }
    if (v6)
      goto LABEL_24;
  }
  return result;
}

void NLRHMMModel::init(NLRHMMModel *this, const NPhoneHMM *a2, const int *a3, const float *a4, const float *a5)
{
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  int *v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  _OWORD *v32;
  __int128 *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  int *v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  uint64_t v47;
  _DWORD *v48;
  unint64_t v49;
  int *v50;
  int v51;
  unint64_t v52;
  const int *v53;
  float *v54;
  float *v55;
  float *v56;
  uint64_t v57;
  float v58;
  _OWORD *v59;
  __int128 *v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  uint64_t v64;
  _DWORD *v65;
  int *v66;
  int v67;
  float v68;
  unsigned int v69;
  BOOL v70;
  uint64_t v71;
  BOOL v72;
  int *v73;
  int v74;
  int v75;
  const float *v77;

  v10 = *((_DWORD *)a2 + 4) + 1;
  *(_DWORD *)this = v10;
  v11 = *((_DWORD *)this + 6);
  if (v11 != v10)
  {
    v12 = *((_QWORD *)this + 2);
    *((_DWORD *)this + 6) = v10;
    v13 = operator new[]();
    *((_QWORD *)this + 2) = v13;
    v10 = *(_DWORD *)this;
    if (v11 >= *(_DWORD *)this)
      v14 = v10;
    else
      v14 = v11;
    if ((_DWORD)v14)
    {
      if (v14 >= 8 && (unint64_t)(v13 - v12) > 0x1F)
      {
        v16 = v14 & 0xFFFFFFF8;
        v17 = (_OWORD *)(v13 + 16);
        v18 = (__int128 *)(v12 + 16);
        v19 = v16;
        do
        {
          v20 = *v18;
          *(v17 - 1) = *(v18 - 1);
          *v17 = v20;
          v17 += 2;
          v18 += 2;
          v19 -= 8;
        }
        while (v19);
        if (v16 == v14)
          goto LABEL_18;
      }
      else
      {
        v16 = 0;
      }
      v21 = v14 - v16;
      v22 = 4 * v16;
      v23 = (_DWORD *)(v13 + 4 * v16);
      v24 = (int *)(v12 + v22);
      do
      {
        v25 = *v24++;
        *v23++ = v25;
        --v21;
      }
      while (v21);
LABEL_18:
      MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
      v10 = *(_DWORD *)this;
      goto LABEL_19;
    }
    if (v12)
      goto LABEL_18;
  }
LABEL_19:
  v26 = *((_DWORD *)this + 12);
  if (v26 == v10)
    goto LABEL_37;
  v27 = *((_QWORD *)this + 5);
  *((_DWORD *)this + 12) = v10;
  v28 = operator new[]();
  *((_QWORD *)this + 5) = v28;
  v10 = *(_DWORD *)this;
  if (v26 >= *(_DWORD *)this)
    v29 = v10;
  else
    v29 = v26;
  if ((_DWORD)v29)
  {
    if (v29 >= 8 && (unint64_t)(v28 - v27) > 0x1F)
    {
      v31 = v29 & 0xFFFFFFF8;
      v32 = (_OWORD *)(v28 + 16);
      v33 = (__int128 *)(v27 + 16);
      v34 = v31;
      do
      {
        v35 = *v33;
        *(v32 - 1) = *(v33 - 1);
        *v32 = v35;
        v32 += 2;
        v33 += 2;
        v34 -= 8;
      }
      while (v34);
      if (v31 == v29)
        goto LABEL_36;
    }
    else
    {
      v31 = 0;
    }
    v36 = v29 - v31;
    v37 = 4 * v31;
    v38 = (_DWORD *)(v28 + 4 * v31);
    v39 = (int *)(v27 + v37);
    do
    {
      v40 = *v39++;
      *v38++ = v40;
      --v36;
    }
    while (v36);
LABEL_36:
    MEMORY[0x212BAC9C0](v27, 0x1000C8052888210);
    v10 = *(_DWORD *)this;
    goto LABEL_37;
  }
  if (v27)
    goto LABEL_36;
LABEL_37:
  v41 = *((_DWORD *)this + 18);
  if (v41 != v10)
  {
    v42 = *((_QWORD *)this + 8);
    *((_DWORD *)this + 18) = v10;
    v43 = operator new[]();
    *((_QWORD *)this + 8) = v43;
    v10 = *(_DWORD *)this;
    if (v41 >= *(_DWORD *)this)
      v44 = v10;
    else
      v44 = v41;
    if ((_DWORD)v44)
    {
      if (v44 >= 8 && (unint64_t)(v43 - v42) > 0x1F)
      {
        v46 = v44 & 0xFFFFFFF8;
        v59 = (_OWORD *)(v43 + 16);
        v60 = (__int128 *)(v42 + 16);
        v61 = v46;
        do
        {
          v62 = *v60;
          *(v59 - 1) = *(v60 - 1);
          *v59 = v62;
          v59 += 2;
          v60 += 2;
          v61 -= 8;
        }
        while (v61);
        if (v46 == v44)
        {
LABEL_61:
          MEMORY[0x212BAC9C0](v42, 0x1000C8052888210);
          v10 = *(_DWORD *)this;
          if (*(_DWORD *)this <= 1u)
            goto LABEL_62;
          goto LABEL_49;
        }
      }
      else
      {
        v46 = 0;
      }
      v63 = v44 - v46;
      v64 = 4 * v46;
      v65 = (_DWORD *)(v43 + 4 * v46);
      v66 = (int *)(v42 + v64);
      do
      {
        v67 = *v66++;
        *v65++ = v67;
        --v63;
      }
      while (v63);
      goto LABEL_61;
    }
    if (v42)
      goto LABEL_61;
  }
  if (v10 <= 1)
  {
LABEL_62:
    v48 = (_DWORD *)*((_QWORD *)this + 8);
    goto LABEL_63;
  }
LABEL_49:
  v47 = *((_QWORD *)a2 + 1);
  v48 = (_DWORD *)*((_QWORD *)this + 8);
  v49 = 1;
  v50 = (int *)v47;
  do
  {
    v51 = *v50;
    v50 += 2;
    v48[v49++] = v51;
    v52 = *(unsigned int *)this;
  }
  while (v49 < v52);
  if (v52 <= 1)
  {
    v10 = *(_DWORD *)this;
LABEL_63:
    v55 = (float *)*((_QWORD *)this + 5);
    v54 = (float *)*((_QWORD *)this + 2);
    LODWORD(v52) = v10;
    goto LABEL_64;
  }
  v77 = a4;
  v53 = a3;
  v54 = (float *)*((_QWORD *)this + 2);
  v55 = (float *)*((_QWORD *)this + 5);
  v56 = (float *)(v47 + 4);
  v57 = 1;
  do
  {
    v58 = *v56;
    v56 += 2;
    v54[v57] = logf(v58);
    v55[v57++] = logf(1.0 - v58);
  }
  while (v52 != v57);
  a3 = v53;
  a4 = v77;
LABEL_64:
  v55[(v52 - 1)] = *a5 + v55[(v52 - 1)];
  v68 = 1.0 - 1.0 / *a4;
  *v54 = logf(v68);
  *v55 = logf(1.0 - v68);
  *v48 = *a3;
  v69 = *((_DWORD *)a2 + 8);
  v70 = v69 >= 7;
  v71 = v69 - 7;
  if (v70)
  {
    v73 = (int *)(*((_QWORD *)a2 + 5) + v71);
    v74 = *v73;
    v75 = *(int *)((char *)v73 + 3);
    v72 = v74 == 1935959151 && v75 == 1885956979;
  }
  else
  {
    v72 = 0;
  }
  *((_BYTE *)this + 80) = v72;
}

uint64_t NLRHMMStateTokens::init(uint64_t this, const unsigned int *a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  _OWORD *v10;
  __int128 *v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  int *v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  _OWORD *v25;
  __int128 *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  int *v32;
  int v33;

  v3 = this;
  v4 = *a2 + 1;
  v5 = *(_DWORD *)(this + 16);
  if (v5 != v4)
  {
    v6 = *(_QWORD *)(this + 8);
    *(_DWORD *)(this + 16) = v4;
    this = operator new[]();
    *(_QWORD *)(v3 + 8) = this;
    if (v5 >= v4)
      v7 = v4;
    else
      v7 = v5;
    if ((_DWORD)v7)
    {
      if (v7 >= 8 && (unint64_t)(this - v6) > 0x1F)
      {
        v9 = v7 & 0xFFFFFFF8;
        v10 = (_OWORD *)(this + 16);
        v11 = (__int128 *)(v6 + 16);
        v12 = v9;
        do
        {
          v13 = *v11;
          *(v10 - 1) = *(v11 - 1);
          *v10 = v13;
          v10 += 2;
          v11 += 2;
          v12 -= 8;
        }
        while (v12);
        if (v9 == v7)
          goto LABEL_18;
      }
      else
      {
        v9 = 0;
      }
      v14 = v7 - v9;
      v15 = 4 * v9;
      v16 = (_DWORD *)(this + 4 * v9);
      v17 = (int *)(v6 + v15);
      do
      {
        v18 = *v17++;
        *v16++ = v18;
        --v14;
      }
      while (v14);
LABEL_18:
      this = MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
      goto LABEL_19;
    }
    if (v6)
      goto LABEL_18;
  }
LABEL_19:
  v19 = *a2 + 1;
  v20 = *(_DWORD *)(v3 + 40);
  if (v20 != v19)
  {
    v21 = *(_QWORD *)(v3 + 32);
    *(_DWORD *)(v3 + 40) = v19;
    this = operator new[]();
    *(_QWORD *)(v3 + 32) = this;
    if (v20 >= v19)
      v22 = v19;
    else
      v22 = v20;
    if ((_DWORD)v22)
    {
      if (v22 >= 8 && (unint64_t)(this - v21) > 0x1F)
      {
        v24 = v22 & 0xFFFFFFF8;
        v25 = (_OWORD *)(this + 16);
        v26 = (__int128 *)(v21 + 16);
        v27 = v24;
        do
        {
          v28 = *v26;
          *(v25 - 1) = *(v26 - 1);
          *v25 = v28;
          v25 += 2;
          v26 += 2;
          v27 -= 8;
        }
        while (v27);
        if (v24 == v22)
LABEL_36:
          JUMPOUT(0x212BAC9C0);
      }
      else
      {
        v24 = 0;
      }
      v29 = v22 - v24;
      v30 = 4 * v24;
      v31 = (_DWORD *)(this + 4 * v24);
      v32 = (int *)(v21 + v30);
      do
      {
        v33 = *v32++;
        *v31++ = v33;
        --v29;
      }
      while (v29);
      goto LABEL_36;
    }
    if (v21)
      goto LABEL_36;
  }
  return this;
}

void NLRHMMStateTokens::reset(NLRHMMStateTokens *this)
{
  unint64_t v1;
  uint64_t v2;
  int v3;
  _DWORD *v4;

  if (*((_DWORD *)this + 10))
  {
    v1 = 0;
    v2 = *((_QWORD *)this + 4);
    do
      *(_DWORD *)(v2 + 4 * v1++) = 0;
    while (v1 < *((unsigned int *)this + 10));
  }
  v3 = *((_DWORD *)this + 4);
  if (v3)
  {
    v4 = (_DWORD *)*((_QWORD *)this + 1);
    *v4 = 0;
    if (v3 != 1)
      memset_pattern16(v4 + 1, &unk_20DA246C0, 4 * (v3 - 2) + 4);
  }
}

void TSHMMDetector::TSHMMDetector(TSHMMDetector *this)
{
  int v2;
  int v3;

  *(_QWORD *)this = &off_24C7F1820;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = &off_24C7F31A8;
  *((_WORD *)this + 52) = 1;
  v2 = 0;
  v3 = 1;
  N2DArray<BOOL>::N2DArray((uint64_t)this + 112, &v3, &v2);
  *((_QWORD *)this + 18) = 1;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = &off_24C7F2C30;
  *((_QWORD *)this + 21) = 0;
  *((_DWORD *)this + 44) = 0;
  *(_OWORD *)((char *)this + 184) = xmmword_20DA24630;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_BYTE *)this + 216) = 0;
  *((_QWORD *)this + 28) = &off_24C7F31A8;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_QWORD *)this + 31) = &off_24C7F3090;
  *((_QWORD *)this + 32) = 0;
  *((_DWORD *)this + 66) = 0;
  *((_QWORD *)this + 34) = &off_24C7F3090;
  *((_QWORD *)this + 35) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_QWORD *)this + 37) = &off_24C7F2D80;
  *((_QWORD *)this + 38) = 0;
  *((_DWORD *)this + 78) = 0;
  *((_QWORD *)this + 40) = &off_24C7F3058;
  *((_QWORD *)this + 41) = 0;
  *((_DWORD *)this + 84) = 0;
  *((_QWORD *)this + 43) = 4286578687;
  *((_DWORD *)this + 88) = -8388609;
  *(_OWORD *)((char *)this + 356) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *((_DWORD *)this + 97) = 1;
  *((_QWORD *)this + 49) = 0;
  *(_DWORD *)((char *)this + 399) = 0;
}

void sub_20D97C5DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  *(_QWORD *)(v1 + 80) = &off_24C7F3090;
  v3 = *(_QWORD *)(v1 + 88);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  _Unwind_Resume(exception_object);
}

void TSHMMDetector::init(TSHMMDetector *this, const NString *a2, const NString *a3, const NString *a4, const NString *a5, const NString *a6, const NString *a7, uint64_t (***a8)(NString *__hidden this, const unsigned int *), float a9, unsigned int a10, unsigned int a11, unsigned int a12, unsigned int a13, unsigned int a14, unsigned int a15, unsigned int a16, unsigned int a17, int a18)
{
  uint64_t v24;
  int v25;
  unsigned __int16 *v26;
  int v27;
  int v28;
  unsigned int v30;
  const char *v31;
  void *v32;
  const char *v33;
  char *v34;
  const char *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  const char *v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _OWORD *v58;
  __int128 *v59;
  uint64_t v60;
  __int128 v61;
  uint64_t v62;
  uint64_t v63;
  _DWORD *v64;
  int *v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _OWORD *v73;
  __int128 *v74;
  uint64_t v75;
  __int128 v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  _BYTE *v83;
  char *v84;
  char v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  unsigned int v92;
  const char *v93;
  uint64_t v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  _BOOL4 v98;
  int v99;
  int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int *v103;
  unsigned int *v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _OWORD *v110;
  __int128 *v111;
  uint64_t v112;
  __int128 v113;
  uint64_t v114;
  uint64_t v115;
  _DWORD *v116;
  int *v117;
  int v118;
  unsigned int v119;
  const char *v120;
  unsigned int v121;
  unsigned int v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v127;
  _OWORD *v128;
  __int128 *v129;
  uint64_t v130;
  __int128 v131;
  uint64_t v132;
  uint64_t v133;
  _DWORD *v134;
  int *v135;
  int v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t (**v147)(NString *__hidden, const unsigned int *);
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  const char *v153;
  const char *v154;
  uint64_t v155;
  char *v156;
  char *v157;
  uint64_t v158;
  unsigned int *v159;
  const char *v160;
  uint64_t (**v161)(NString *__hidden, const unsigned int *);
  uint64_t v162;
  const char *v163;
  const NString *v164;
  const NString *v165;
  unsigned int v166;
  unsigned int v168;
  unsigned int v169[2];
  int v170;
  char *v171;
  unsigned int v172[2];
  int v173;
  void *v174;
  unsigned int v175[2];
  uint64_t v176;
  char *v177;
  char *v178;
  int v179;
  char *v180;
  uint64_t (**v181)();
  uint64_t v182;
  uint64_t v183;
  unsigned int v184[2];
  uint64_t v185;
  _DWORD v186[3];
  int v187;
  void (**v188)(NPhoneHMMArray *__hidden);
  uint64_t v189;
  int v190;
  uint64_t (**v191)();
  uint64_t (**v192)();
  uint64_t v193;
  uint64_t v194;
  int v195;
  float v196[3];

  v166 = a10;
  v196[0] = a9;
  if (*((_BYTE *)this + 396))
    Error::chuck((Error *)"TSHMMDetector::init() - init() already called", (const char *)a2, a3, a4, a5, a6, a7);
  v188 = &off_24C7F1FD8;
  v189 = 0;
  v24 = NDistributionLoader::read((NDistributionLoader *)&v188, (uint64_t (***)(NString *__hidden, const unsigned int *))a2, a3);
  if (v189)
    (*(void (**)(uint64_t))(*(_QWORD *)v189 + 8))(v189);
  *((_QWORD *)this + 1) = v24;
  *((_QWORD *)this + 3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v24 + 144))(v24);
  v188 = &off_24C7F18D0;
  v189 = 0;
  v192 = &off_24C7F2BF8;
  v193 = 0;
  v190 = 0;
  v194 = 0;
  v195 = 0;
  v191 = &off_24C7F16B0;
  v184[0] = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  NPhoneHMMArray::read((NPhoneHMMArray *)&v188, a4, v184);
  v187 = -1;
  *(_WORD *)((char *)this + 399) = 1;
  v25 = *((_DWORD *)a5 + 2);
  if (v25 != 3)
  {
    if (v25 == 4 && **((_DWORD **)a5 + 2) == 1297303386)
    {
      *((_BYTE *)this + 400) = 1;
LABEL_15:
      *((_BYTE *)this + 399) = 0;
      goto LABEL_16;
    }
LABEL_12:
    v30 = NPhoneHMMArray::operator()((uint64_t)&v188, (uint64_t)a5);
    if ((v30 & 0x80000000) != 0)
    {
      v157 = "TSHMMDetector::init() - cannot find label %s in hmm file %s";
    }
    else
    {
      if (*(_DWORD *)(v189 + 48 * v30 + 16) == 1)
      {
        v187 = **(_DWORD **)(v189 + 48 * v30 + 8);
        goto LABEL_15;
      }
      v157 = "TSHMMDetector::init() - GSM HMM (label %s in hmm file %s) must be single state";
    }
    Error::chuck((Error *)v157, v31, *((_QWORD *)a5 + 2), *((_QWORD *)a4 + 2));
  }
  v26 = (unsigned __int16 *)*((_QWORD *)a5 + 2);
  v27 = *v26;
  v28 = *((unsigned __int8 *)v26 + 2);
  if (v27 != 19521 || v28 != 76)
    goto LABEL_12;
LABEL_16:
  *(_QWORD *)v184 = &off_24C7F2E28;
  v185 = 0;
  v186[0] = 0;
  v178 = (char *)&off_24C7F32C0;
  v179 = 1;
  v180 = (char *)operator new[]();
  strcpy(v180, ",");
  *(_QWORD *)v175 = &off_24C7F32C0;
  LODWORD(v176) = 1;
  v177 = (char *)operator new[]();
  strcpy(v177, " ");
  (*(void (**)(uint64_t (***__return_ptr)(), const NString *, char **, unsigned int *))(*(_QWORD *)a6 + 112))(&v181, a6, &v178, v175);
  *(_QWORD *)v172 = &off_24C7F32C0;
  v173 = 4;
  v32 = (void *)operator new[]();
  v174 = v32;
  strcpy((char *)v32, "\r\n\t ");
  v169[0] = -1;
  NString::split((uint64_t)&v181, v184, (uint64_t)v172, v169);
  MEMORY[0x212BAC9C0](v32, 0x1000C8077774924);
  v181 = (uint64_t (**)())&off_24C7F32C0;
  if (v183)
    MEMORY[0x212BAC9C0](v183, 0x1000C8077774924);
  *(_QWORD *)v175 = &off_24C7F32C0;
  if (v177)
    MEMORY[0x212BAC9C0](v177, 0x1000C8077774924);
  v178 = (char *)&off_24C7F32C0;
  if (v180)
    MEMORY[0x212BAC9C0](v180, 0x1000C8077774924);
  if (!v186[0])
    Error::chuck((Error *)"TSHMMDetector::init() - no labels in keywords specification", v33);
  v181 = &off_24C7F2E28;
  v182 = 0;
  LODWORD(v183) = 0;
  *(_QWORD *)v175 = &off_24C7F32C0;
  LODWORD(v176) = 1;
  v177 = (char *)operator new[]();
  memcpy(v177, ",", (v176 + 1));
  *(_QWORD *)v172 = &off_24C7F32C0;
  v173 = 1;
  v174 = (void *)operator new[]();
  memcpy(v174, " ", (v173 + 1));
  (*(void (**)(char **__return_ptr, const NString *, unsigned int *, unsigned int *))(*(_QWORD *)a7 + 112))(&v178, a7, v175, v172);
  *(_QWORD *)v169 = &off_24C7F32C0;
  v170 = 4;
  v34 = (char *)operator new[]();
  v171 = v34;
  strcpy(v34, "\r\n\t ");
  v168 = -1;
  NString::split((uint64_t)&v178, &v181, (uint64_t)v169, &v168);
  MEMORY[0x212BAC9C0](v34, 0x1000C8077774924);
  v178 = (char *)&off_24C7F32C0;
  if (v180)
    MEMORY[0x212BAC9C0](v180, 0x1000C8077774924);
  *(_QWORD *)v172 = &off_24C7F32C0;
  if (v174)
    MEMORY[0x212BAC9C0](v174, 0x1000C8077774924);
  *(_QWORD *)v175 = &off_24C7F32C0;
  if (v177)
    MEMORY[0x212BAC9C0](v177, 0x1000C8077774924);
  if ((_DWORD)v183 && (_DWORD)v183 != v186[0])
    Error::chuck((Error *)"TSHMMDetector::init() - hmm score offsets size (%d) doesn't match number of keywords (%d)", v35, v183, v186[0]);
  v164 = a2;
  v165 = a4;
  NArray<NLRHMMModel>::resize((uint64_t)this + 160, v186);
  NArray<NLRHMMStateTokens>::resize((uint64_t)this + 296, v186);
  if (v186[0])
  {
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    do
    {
      v41 = v185;
      v43 = NPhoneHMMArray::operator()((uint64_t)&v188, v185 + v39);
      if ((v43 & 0x80000000) != 0)
        Error::chuck((Error *)"TSHMMDetector::init() - cannot find label %s in hmm file %s", v42, *(_QWORD *)(v41 + 24 * v40 + 16), *((_QWORD *)v165 + 2));
      v175[0] = 0;
      if (v40 < v183)
      {
        v44 = v182;
        v45 = v182 + v39;
        if (!*(_DWORD *)(v182 + v39 + 8)
          || (v178 = 0,
              strtod(*(const char **)(v45 + 16), &v178),
              v44 = v182,
              v178 != (char *)(*(_QWORD *)(v45 + 16) + *(unsigned int *)(v45 + 8))))
        {
          Error::chuck((Error *)"TSHMMDetector::init() - hmm score offset \"%s\" not float", v42, *(_QWORD *)(v44 + 24 * v40 + 16));
        }
        v46 = atof(*(const char **)(v182 + v39 + 16));
        *(float *)v175 = v46;
      }
      NLRHMMModel::init((NLRHMMModel *)(*((_QWORD *)this + 21) + v38), (const NPhoneHMM *)(v189 + 48 * v43), &v187, v196, (const float *)v175);
      NLRHMMStateTokens::init(*((_QWORD *)this + 38) + v37, (const unsigned int *)(*((_QWORD *)this + 21) + v38));
      ++v40;
      v39 += 24;
      v38 += 88;
      v37 += 48;
    }
    while (v40 < v186[0]);
  }
  v47 = **((unsigned int **)this + 21);
  if (*((_DWORD *)a8 + 2))
  {
    v178 = (char *)&off_24C7F32C0;
    v179 = 0;
    v180 = (char *)operator new[]();
    bzero(v180, (v179 + 1));
    *(_QWORD *)v175 = &off_24C7F1FD8;
    v176 = 0;
    v48 = NDistributionLoader::read((NDistributionLoader *)v175, a8, (const NString *)&v178);
    if (v176)
      (*(void (**)(uint64_t))(*(_QWORD *)v176 + 8))(v176);
    *((_QWORD *)this + 2) = v48;
    v178 = (char *)&off_24C7F32C0;
    if (v180)
    {
      MEMORY[0x212BAC9C0](v180, 0x1000C8077774924);
      v48 = *((_QWORD *)this + 2);
    }
    v49 = *(_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v48 + 40))(v48);
    if (v49 != *(_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1))
      || (v50 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2)),
          v50 != (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1))))
    {
      v147 = a8[2];
      v148 = *(unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2));
      v149 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2));
      v150 = *((_QWORD *)v164 + 2);
      v151 = *(unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1));
      v152 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
      Error::chuck((Error *)"TSHMMDetector::init() - input format of %s (%d,%d) does not match that of %s (%d,%d)", v153, v147, v148, v149, v150, v151, v152);
    }
    v51 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2));
    v52 = v51;
    if (v51 != 2 * (_DWORD)v47 - 2)
    {
      v161 = a8[2];
      v162 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2));
      Error::chuck((Error *)"TSHMMDetector::init() - output size of %s (%d) does not match that of %s (%d*2-2)", v163, v161, v162, *((_QWORD *)v165 + 2), v47);
    }
    v53 = *((_DWORD *)this + 66);
    if (v53 != v51)
    {
      v54 = *((_QWORD *)this + 32);
      *((_DWORD *)this + 66) = v51;
      v55 = operator new[]();
      *((_QWORD *)this + 32) = v55;
      if (v53 >= v52)
        v56 = v52;
      else
        v56 = v53;
      if ((_DWORD)v56)
      {
        v57 = 0;
        if (v56 < 8)
          goto LABEL_57;
        if ((unint64_t)(v55 - v54) <= 0x1F)
          goto LABEL_57;
        v57 = v56 & 0xFFFFFFF8;
        v58 = (_OWORD *)(v55 + 16);
        v59 = (__int128 *)(v54 + 16);
        v60 = v57;
        do
        {
          v61 = *v59;
          *(v58 - 1) = *(v59 - 1);
          *v58 = v61;
          v58 += 2;
          v59 += 2;
          v60 -= 8;
        }
        while (v60);
        if (v57 != v56)
        {
LABEL_57:
          v62 = v56 - v57;
          v63 = 4 * v57;
          v64 = (_DWORD *)(v55 + 4 * v57);
          v65 = (int *)(v54 + v63);
          do
          {
            v66 = *v65++;
            *v64++ = v66;
            --v62;
          }
          while (v62);
        }
      }
      else if (!v54)
      {
        goto LABEL_62;
      }
      MEMORY[0x212BAC9C0](v54, 0x1000C8052888210);
    }
  }
LABEL_62:
  v67 = v47 - 1;
  v68 = *((_DWORD *)this + 84);
  if (v68 == (_DWORD)v47 - 1)
    goto LABEL_83;
  v69 = *((_QWORD *)this + 41);
  *((_DWORD *)this + 84) = v67;
  v70 = operator new[]();
  *((_QWORD *)this + 41) = v70;
  if (v68 >= v67)
    v71 = v67;
  else
    v71 = v68;
  if ((_DWORD)v71)
  {
    v72 = 0;
    if (v71 >= 8 && (unint64_t)(v70 - v69) > 0x1F)
    {
      if (v71 < 0x20)
      {
        v72 = 0;
        goto LABEL_77;
      }
      v72 = v71 & 0xFFFFFFE0;
      v73 = (_OWORD *)(v70 + 16);
      v74 = (__int128 *)(v69 + 16);
      v75 = v72;
      do
      {
        v76 = *v74;
        *(v73 - 1) = *(v74 - 1);
        *v73 = v76;
        v73 += 2;
        v74 += 2;
        v75 -= 32;
      }
      while (v75);
      if (v72 == v71)
        goto LABEL_82;
      if ((v71 & 0x18) != 0)
      {
LABEL_77:
        v77 = v72;
        v72 = v71 & 0xFFFFFFF8;
        v78 = v77 - v72;
        v79 = (_QWORD *)(v70 + v77);
        v80 = (uint64_t *)(v69 + v77);
        do
        {
          v81 = *v80++;
          *v79++ = v81;
          v78 += 8;
        }
        while (v78);
        if (v72 == v71)
          goto LABEL_82;
      }
    }
    v82 = v71 - v72;
    v83 = (_BYTE *)(v70 + v72);
    v84 = (char *)(v69 + v72);
    do
    {
      v85 = *v84++;
      *v83++ = v85;
      --v82;
    }
    while (v82);
    goto LABEL_82;
  }
  if (v69)
LABEL_82:
    MEMORY[0x212BAC9C0](v69, 0x1000C8077774924);
LABEL_83:
  v86 = a11;
  if (v47 < a11)
    Error::chuck((Error *)"TSHMMDetector::init() - partial state set to %d, must be between 0 (disabled) and %d", v36, a11, v47);
  v87 = a12;
  *((_DWORD *)this + 46) = a12;
  *((_DWORD *)this + 47) = v86;
  if (!v87)
    *((_DWORD *)this + 46) = *(_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1));
  v88 = a14;
  if (!a14)
    Error::chuck((Error *)"TSHMMDetector::initialize() - noutputscoreframes cannot be zero", v36);
  v89 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  v90 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  v91 = **((_QWORD **)this + 1);
  if (v89 / v88 * (_DWORD)v88 != v90)
  {
    v155 = (*(uint64_t (**)(void))(v91 + 16))();
    v156 = "TSHMMDetector::initialize() - noutputscoreframes %d doesn't go into %d";
    goto LABEL_164;
  }
  v92 = (*(uint64_t (**)(void))(v91 + 32))();
  v94 = a17;
  if (v92 < a17 + 1)
  {
    v88 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
    v156 = "TSHMMDetector::initialize() - Too few input frames %d when there are %d info frames";
    v155 = v94;
LABEL_164:
    Error::chuck((Error *)v156, v154, v88, v155);
  }
  if (a17 >= 2)
    Error::chuck((Error *)"TSHMMDetector::initialize() - Don't know what to do with info frames %d > 1", v93, a17);
  v95 = a13;
  v97 = a15;
  v96 = a16;
  *((_BYTE *)this + 216) = a17 != 0;
  *((_DWORD *)this + 51) = v88;
  *((_DWORD *)this + 52) = v97;
  *((_DWORD *)this + 53) = v96;
  if ((_DWORD)v94)
    v98 = 1;
  else
    v98 = v88 > 1;
  if (v98)
    v99 = 1;
  else
    v99 = v95 + 1;
  *((_DWORD *)this + 48) = v95;
  *((_DWORD *)this + 49) = v99;
  *((_BYTE *)this + 398) = 0;
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1)) > 1
    || (v100 = *((_DWORD *)this + 46),
        v100 != *(_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1))))
  {
    v101 = *((_DWORD *)this + 46);
    if (v101 < *(_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1)))
    {
      v158 = *((unsigned int *)this + 46);
      v159 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1));
      Error::chuck((Error *)"TSHMMDetector::init() - acanal frames smaller than those required for model (%d < %d)", v160, v158, *v159);
    }
    *((_BYTE *)this + 398) = 1;
    v102 = ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1))
          - v88) >> 1;
    if ((_DWORD)v94)
      v102 = 0;
    LODWORD(v178) = v102;
    v175[0] = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
    v172[0] = 0;
    v103 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1));
    v168 = 0;
    v169[0] = 0;
    NFrameWindow::configure((uint64_t)this + 32, (const char *)v175, (unsigned int *)this + 46, v172, v103, (unsigned int *)&v178, v169, &v168);
    v104 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
    v105 = *((_DWORD *)this + 60);
    if (v105 != *v104)
    {
      v106 = *((_QWORD *)this + 29);
      *((_DWORD *)this + 60) = *v104;
      v107 = operator new[]();
      *((_QWORD *)this + 29) = v107;
      LODWORD(v108) = *v104;
      if (v105 >= *v104)
        v108 = v108;
      else
        v108 = v105;
      if ((_DWORD)v108)
      {
        v109 = 0;
        if (v108 < 8)
          goto LABEL_111;
        if ((unint64_t)(v107 - v106) <= 0x1F)
          goto LABEL_111;
        v109 = v108 & 0xFFFFFFF8;
        v110 = (_OWORD *)(v107 + 16);
        v111 = (__int128 *)(v106 + 16);
        v112 = v109;
        do
        {
          v113 = *v111;
          *(v110 - 1) = *(v111 - 1);
          *v110 = v113;
          v110 += 2;
          v111 += 2;
          v112 -= 8;
        }
        while (v112);
        if (v109 != v108)
        {
LABEL_111:
          v114 = v108 - v109;
          v115 = 4 * v109;
          v116 = (_DWORD *)(v107 + 4 * v109);
          v117 = (int *)(v106 + v115);
          do
          {
            v118 = *v117++;
            *v116++ = v118;
            --v114;
          }
          while (v114);
        }
      }
      else if (!v106)
      {
        goto LABEL_116;
      }
      MEMORY[0x212BAC9C0](v106, 0x1000C8052888210);
    }
  }
LABEL_116:
  *((_DWORD *)this + 50) = a18;
  v119 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  v121 = v119;
  v122 = *((_DWORD *)this + 72);
  if (v122 == v119)
    goto LABEL_134;
  v123 = *((_QWORD *)this + 35);
  *((_DWORD *)this + 72) = v119;
  v124 = operator new[]();
  *((_QWORD *)this + 35) = v124;
  if (v122 >= v121)
    v125 = v121;
  else
    v125 = v122;
  if ((_DWORD)v125)
  {
    if (v125 >= 8 && (unint64_t)(v124 - v123) > 0x1F)
    {
      v127 = v125 & 0xFFFFFFF8;
      v128 = (_OWORD *)(v124 + 16);
      v129 = (__int128 *)(v123 + 16);
      v130 = v127;
      do
      {
        v131 = *v129;
        *(v128 - 1) = *(v129 - 1);
        *v128 = v131;
        v128 += 2;
        v129 += 2;
        v130 -= 8;
      }
      while (v130);
      if (v127 == v125)
        goto LABEL_133;
    }
    else
    {
      v127 = 0;
    }
    v132 = v125 - v127;
    v133 = 4 * v127;
    v134 = (_DWORD *)(v124 + 4 * v127);
    v135 = (int *)(v123 + v133);
    do
    {
      v136 = *v135++;
      *v134++ = v136;
      --v132;
    }
    while (v132);
LABEL_133:
    MEMORY[0x212BAC9C0](v123, 0x1000C8052888210);
    goto LABEL_134;
  }
  if (v123)
    goto LABEL_133;
LABEL_134:
  *((_BYTE *)this + 401) = 0;
  if (v166)
  {
    if (*((_DWORD *)this + 39))
      Error::chuck((Error *)"NLRHMMTraceback::resize() - cannot resize unless empty", v120);
    *((_DWORD *)this + 34) = v67;
    *((_DWORD *)this + 33) = v166;
    NArray<NArray<BOOL>>::resize((uint64_t)this + 112, &a10);
    if (*((_DWORD *)this + 33))
    {
      v137 = 0;
      v138 = 0;
      do
      {
        (*(void (**)(uint64_t, char *))(*(_QWORD *)(*((_QWORD *)this + 15) + v137) + 32))(*((_QWORD *)this + 15) + v137, (char *)this + 136);
        ++v138;
        v137 += 24;
      }
      while (v138 < *((unsigned int *)this + 33));
    }
    *((_DWORD *)this + 36) = v166;
    *((_DWORD *)this + 37) = v67;
    *((_QWORD *)this + 19) = 0;
    *((_BYTE *)this + 401) = 1;
  }
  TSHMMDetector::reset(this);
  *((_BYTE *)this + 396) = 1;
  v181 = &off_24C7F2E28;
  v139 = v182;
  if (v182)
  {
    v140 = *(_QWORD *)(v182 - 8);
    if (v140)
    {
      v141 = 24 * v140;
      do
      {
        *(_QWORD *)(v139 + v141 - 24) = &off_24C7F32C0;
        v142 = *(_QWORD *)(v139 + v141 - 8);
        if (v142)
          MEMORY[0x212BAC9C0](v142, 0x1000C8077774924);
        v141 -= 24;
      }
      while (v141);
    }
    MEMORY[0x212BAC9C0](v139 - 16, 0x1091C800F2A5985);
  }
  *(_QWORD *)v184 = &off_24C7F2E28;
  v143 = v185;
  if (v185)
  {
    v144 = *(_QWORD *)(v185 - 8);
    if (v144)
    {
      v145 = 24 * v144;
      do
      {
        *(_QWORD *)(v143 + v145 - 24) = &off_24C7F32C0;
        v146 = *(_QWORD *)(v143 + v145 - 8);
        if (v146)
          MEMORY[0x212BAC9C0](v146, 0x1000C8077774924);
        v145 -= 24;
      }
      while (v145);
    }
    MEMORY[0x212BAC9C0](v143 - 16, 0x1091C800F2A5985);
  }
  NPhoneHMMArray::~NPhoneHMMArray((NPhoneHMMArray *)&v188);
}

void sub_20D97D59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  uint64_t v32;

  NArray<NString>::~NArray(&a32);
  NArray<NString>::~NArray((_QWORD *)(v32 - 192));
  NPhoneHMMArray::~NPhoneHMMArray((NPhoneHMMArray *)(v32 - 160));
  _Unwind_Resume(a1);
}

uint64_t TSHMMDetector::reset(TSHMMDetector *this)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t result;

  *((_QWORD *)this + 43) = 4286578687;
  *((_DWORD *)this + 88) = -8388609;
  *((_BYTE *)this + 397) = 0;
  *((_BYTE *)this + 403) = 0;
  *(_OWORD *)((char *)this + 356) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  if (*((_DWORD *)this + 78))
  {
    v2 = 0;
    v3 = *((_QWORD *)this + 38);
    do
    {
      v4 = v3 + 48 * v2;
      if (*(_DWORD *)(v4 + 40))
      {
        v5 = 0;
        v6 = *(_QWORD *)(v3 + 48 * v2 + 32);
        do
          *(_DWORD *)(v6 + 4 * v5++) = 0;
        while (v5 < *(unsigned int *)(v4 + 40));
      }
      v7 = *(_DWORD *)(v4 + 16);
      if (v7)
      {
        v8 = *(_DWORD **)(v4 + 8);
        *v8 = 0;
        if (v7 != 1)
          memset_pattern16(v8 + 1, &unk_20DA246C0, 4 * (v7 - 2) + 4);
      }
      ++v2;
    }
    while (v2 < *((unsigned int *)this + 78));
  }
  *((_WORD *)this + 52) = 1;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 97) = 1;
  if (*((_BYTE *)this + 398))
  {
    v9 = *((_QWORD *)this + 1);
    if (v9)
      *((_DWORD *)this + 97) = ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 32))(v9) >> 1) + 1;
  }
  *((_DWORD *)this + 98) = 0;
  *((_BYTE *)this + 402) = 0;
  *((_QWORD *)this + 19) = 0;
  result = *((_QWORD *)this + 1);
  if (result)
  {
    if (*((_QWORD *)this + 3))
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 160))(result);
  }
  return result;
}

uint64_t TSHMMDetector::disablePriming(uint64_t this)
{
  *(_BYTE *)(this + 402) = 1;
  return this;
}

void TSHMMDetector::feedFrame(TSHMMDetector *this, const NFrame *a2, double a3)
{
  const NFrame *v4;
  int v5;
  uint64_t v6;
  __n128 v7;
  int v8;
  const char *v9;

  if (!*((_BYTE *)this + 396))
    Error::chuck((Error *)"TSHMMDetector::feedFrame() - init() not called", (const char *)a2);
  if (*((_BYTE *)this + 397))
    Error::chuck((Error *)"TSHMMDetector::feedFrame() - endFrame() was called", (const char *)a2);
  v4 = a2;
  while ((TSHMMDetector::updateResult(this, (const char *)a2, a3) & 1) != 0)
    ;
  if (!*((_BYTE *)this + 398))
    goto LABEL_13;
  v5 = *((_DWORD *)v4 + 4);
  if (!v5)
    Error::chuck((Error *)"NFrameWindow::pushFrame() - cannot feed zero-sized frames", (const char *)a2);
  v6 = *((unsigned int *)this + 10);
  if (v5 != (_DWORD)v6)
    Error::chuck((Error *)"NFrameWindow::pushFrame() - mismatched input frame size (%d != %d)", (const char *)a2, *((unsigned int *)v4 + 4), v6);
  v7.n128_u64[0] = (unint64_t)NFrameWindow::pushFrame((TSHMMDetector *)((char *)this + 32), *((const float **)v4 + 1));
  v8 = *((_DWORD *)this + 18);
  if (*((_BYTE *)this + 105) && v8 || v8 == *((_DWORD *)this + 9) + 1)
  {
    v9 = (char *)this + 52;
    if (!*((_DWORD *)this + 13))
      Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v9, v7.n128_f64[0]);
    v4 = (TSHMMDetector *)((char *)this + 224);
    (*(void (**)(char *, const char *, __n128))(*((_QWORD *)this + 28) + 32))((char *)this + 224, v9, v7);
    NFrameWindow::setOutputFrameWindow((uint64_t)this + 32, *((float **)this + 29));
LABEL_13:
    TSHMMDetector::stepFrame(this, v4);
  }
  ++*((_DWORD *)this + 91);
}

uint64_t TSHMMDetector::updateResult(TSHMMDetector *this, const char *a2, double a3)
{
  int v4;
  char *v5;
  unsigned int v6;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  _OWORD *v21;
  uint64_t v22;
  __int128 *v23;
  __int128 v24;
  _QWORD v25[2];
  int v26;

  if (!*((_BYTE *)this + 396))
    Error::chuck((Error *)"TSHMMDetector::updateResult() - init() not called", a2);
  v4 = *((_DWORD *)this + 96);
  if (!v4)
  {
    if (!*((_DWORD *)this + 94))
      return 0;
    v6 = *((_DWORD *)this + 51);
    if (v6 == 1)
    {
      TSHMMDetector::advanceHMMScores((uint64_t)this, (uint64_t)this + 272, a3);
LABEL_15:
      v5 = (char *)this + 376;
      v4 = *((_DWORD *)this + 94);
      goto LABEL_16;
    }
    v8 = *((_DWORD *)this + 72);
    v9 = v8 / v6;
    v25[0] = &off_24C7F3090;
    v10 = operator new[]();
    v12 = v10;
    v25[1] = v10;
    v26 = v8 / v6;
    v13 = *((_DWORD *)this + 93);
    *((_DWORD *)this + 93) = v13 + 1;
    if (v6 <= v8)
    {
      v14 = (v13 * v9);
      v15 = *((_QWORD *)this + 35);
      v16 = v15 + 4 * v14;
      if (v9 >= 8 && (unint64_t)(v10 - (v15 + 4 * v14)) >= 0x20)
      {
        v20 = 0;
        v17 = v9 & 0xFFFFFFF8;
        v21 = (_OWORD *)(v10 + 16);
        v22 = v17;
        do
        {
          v23 = (__int128 *)(v16 + 4 * v20);
          v11 = *v23;
          v24 = v23[1];
          *(v21 - 1) = *v23;
          *v21 = v24;
          v20 += 8;
          v21 += 2;
          v22 -= 8;
        }
        while (v22);
        if (v17 == v9)
          goto LABEL_14;
      }
      else
      {
        v17 = 0;
      }
      v18 = v9 - v17;
      v19 = (_DWORD *)(v10 + 4 * v17);
      do
      {
        LODWORD(v11) = *(_DWORD *)(v16 + 4 * v17);
        *v19++ = v11;
        ++v17;
        --v18;
      }
      while (v18);
    }
LABEL_14:
    TSHMMDetector::advanceHMMScores((uint64_t)this, (uint64_t)v25, *(double *)&v11);
    MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
    goto LABEL_15;
  }
  v5 = (char *)this + 384;
LABEL_16:
  *(_DWORD *)v5 = v4 - 1;
  return 1;
}

void sub_20D97DB9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t TSHMMDetector::stepFrame(TSHMMDetector *this, const NFrame *a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  int v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  float v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  unsigned int v33;

  result = *((_QWORD *)this + 2);
  if (!result)
    goto LABEL_6;
  v5 = *((_DWORD *)this + 97);
  if (!v5)
    goto LABEL_6;
  v6 = v5 - 1;
  *((_DWORD *)this + 97) = v6;
  if (v6)
  {
    ++*((_DWORD *)this + 92);
    return result;
  }
  if (!*((_BYTE *)this + 402))
  {
    result = (*(uint64_t (**)(uint64_t, const NFrame *, char *, _QWORD))(*(_QWORD *)result + 72))(result, a2, (char *)this + 248, 0);
    v16 = **((_DWORD **)this + 21);
    v17 = *((_QWORD *)this + 38);
    v18 = (v16 - 1);
    if (v16 == 1)
    {
      v21 = *(_DWORD **)(v17 + 32);
      v22 = *(_DWORD **)(v17 + 8);
    }
    else
    {
      v19 = 0;
      v20 = *((_QWORD *)this + 32);
      v21 = *(_DWORD **)(v17 + 32);
      v22 = *(_DWORD **)(v17 + 8);
      do
      {
        v23 = *(float *)(v20 + 4 * (v18 + v19));
        if (v23 < 0.0)
          v23 = 0.0;
        v21[v19 + 1] = *((_DWORD *)this + 92) - (uint64_t)rintf(v23);
        v22[v19 + 1] = *(_DWORD *)(v20 + 4 * v19);
        ++v19;
      }
      while (v18 != v19);
    }
    *v21 = *((_DWORD *)this + 92);
    *v22 = 0;
    v7 = *((_DWORD *)this + 95);
    if (v7)
      goto LABEL_7;
  }
  else
  {
LABEL_6:
    v7 = *((_DWORD *)this + 95);
    if (v7)
    {
LABEL_7:
      if (*((_BYTE *)this + 401))
      {
        v8 = **((_DWORD **)this + 21);
        v9 = (v8 - 1);
        if (v8 != 1)
          bzero(*((void **)this + 41), v9);
        v10 = *((unsigned int *)this + 37);
        if (*((_DWORD *)this + 84) != (_DWORD)v10)
          Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)v9, *((unsigned int *)this + 84), v10);
        v11 = *((_QWORD *)this + 15) + 24 * *((unsigned int *)this + 38);
        result = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v11 + 16))(v11, (char *)this + 320);
        v13 = *((_DWORD *)this + 38);
        v12 = *((_DWORD *)this + 39);
        v14 = *((_DWORD *)this + 36);
        if (v13 + 1 < v14)
          v15 = v13 + 1;
        else
          v15 = 0;
        *((_DWORD *)this + 38) = v15;
        if (v12 < v14)
          *((_DWORD *)this + 39) = v12 + 1;
        v7 = *((_DWORD *)this + 95);
      }
      ++*((_DWORD *)this + 96);
      *((_DWORD *)this + 95) = v7 - 1;
      return result;
    }
  }
  v24 = *((_DWORD *)this + 92);
  if (v24 && *((_DWORD *)this + 51) == 1)
    *((_DWORD *)this + 92) = *((_DWORD *)this + 48) + v24;
  *((_DWORD *)this + 95) = *((_DWORD *)this + 48);
  if (*((_BYTE *)this + 216))
  {
    v25 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1)) - 2;
    if (*((_DWORD *)this + 98) > v25)
      *((_DWORD *)this + 98) = v25;
    v26 = *((_DWORD *)this + 60);
    v27 = *(_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1));
    v28 = *((_QWORD *)this + 29);
    *(float *)(v28 + 4 * (v26 - v27)) = (float)*((unsigned int *)this + 98);
    v29 = *((_DWORD *)a2 + 4);
    v30 = v26 - v27 + 1;
    if (v30 < v29)
      bzero((void *)(v28 + 4 * v30), 4 * (v27 + v29 - v26 - 2) + 4);
    TSHMMDetector::quasarCMNBatch((unsigned int *)this);
  }
  result = (*(uint64_t (**)(_QWORD, const NFrame *, char *, _QWORD))(**((_QWORD **)this + 1) + 72))(*((_QWORD *)this + 1), a2, (char *)this + 272, *((_QWORD *)this + 3));
  v31 = 1;
  *((_BYTE *)this + 403) = 1;
  v32 = *((_DWORD *)this + 51);
  *((_DWORD *)this + 93) = 0;
  v33 = *((_DWORD *)this + 98);
  if (v32 + 1 > v33)
    v31 = v32 - v33;
  *((_DWORD *)this + 94) = v31;
  return result;
}

unsigned int *TSHMMDetector::quasarCMNBatch(unsigned int *this)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  const char *v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  float *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  float *v16;
  size_t v17;
  uint64_t v18;
  unsigned int v19;
  float v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  unsigned int v30;
  float32x4_t *v31;
  uint64_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  float v35;
  int v36;
  float *v37;
  uint64_t v38;
  float v39;
  uint64_t v40;
  unsigned int v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float *v46;
  unsigned int v47;
  uint64_t v48;
  float v49;
  float v50;
  unsigned int v51;
  float32x4_t *v52;
  uint64_t v53;
  uint64_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float *v62;
  float v63;
  unsigned int v64;
  float32x4_t *v65;
  uint64_t v66;
  float32x4_t *v67;
  float32x4_t v68;

  v1 = this[52];
  if ((_DWORD)v1)
  {
    v2 = this;
    v3 = this[53];
    v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1))
       - *((unsigned __int8 *)this + 216);
    this = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v2 + 1) + 40))(*((_QWORD *)v2 + 1));
    v6 = v2[98];
    v7 = v4 >= v6;
    v8 = v4 - v6;
    if (v7)
      v9 = v8;
    else
      v9 = 0;
    if (v9 > v1)
      Error::chuck((Error *)"TSHMMDetector::quasarCMNBatch() - small maxframes=%d not supported for batch=%d", v5, v1, v9);
    v10 = *this;
    if ((_DWORD)v10)
    {
      v11 = 4 * *this;
      v12 = (float *)operator new[]();
      bzero(v12, v11);
      if (v3 >= v9)
        v13 = v9;
      else
        v13 = v3;
      if (!v13)
      {
        if (v9 > v3)
        {
          v13 = 0;
          v23 = 0;
          v15 = *((_QWORD *)v2 + 29);
LABEL_43:
          v40 = v10 & 0xFFFFFFFC;
          v41 = v23;
          do
          {
            v42 = 1.0 / (float)++v13;
            if (v10 >= 8)
            {
              v43 = 0;
              if (__CFADD__(v41, v10 - 1) || (unint64_t)(v10 - 1) >> 32)
                goto LABEL_50;
              v44 = 4 * v41;
              if ((unint64_t)v12 >= v15 + v11 + v44 || v15 + v44 >= (unint64_t)&v12[v11 / 4])
              {
                v51 = v41;
                v52 = (float32x4_t *)v12;
                v53 = v10 & 0xFFFFFFFC;
                do
                {
                  v54 = 4 * v51;
                  v55 = *(float32x4_t *)(v15 + v54);
                  v56 = vaddq_f32(v55, *v52);
                  *v52++ = v56;
                  *(float32x4_t *)(v15 + v54) = vsubq_f32(v55, vmulq_n_f32(v56, v42));
                  v51 += 4;
                  v53 -= 4;
                }
                while (v53);
                v41 += v40;
                v43 = v10 & 0xFFFFFFFC;
                v47 = v41;
                if (v40 == v10)
                  goto LABEL_52;
                goto LABEL_50;
              }
            }
            v43 = 0;
LABEL_50:
            v45 = v10 - v43;
            v46 = &v12[v43];
            v47 = v41;
            do
            {
              v48 = 4 * v47;
              v49 = *(float *)(v15 + v48);
              v50 = v49 + *v46;
              *v46++ = v50;
              *(float *)(v15 + v48) = v49 - (float)(v42 * v50);
              ++v47;
              --v45;
            }
            while (v45);
LABEL_52:
            v41 = v47;
          }
          while (v13 < v9);
        }
LABEL_73:
        JUMPOUT(0x212BAC9C0);
      }
      v14 = v10 - 1;
      v15 = *((_QWORD *)v2 + 29);
      v16 = &v12[v11 / 4];
      v17 = v15 + v11;
      v18 = v10 & 0xFFFFFFF8;
      if (v10 < 8)
      {
        v19 = 0;
        v20 = *v12;
        v21 = v13;
        do
        {
          v20 = *(float *)(v15 + 4 * v19) + v20;
          *v12 = v20;
          v22 = v19 + 1;
          if ((_DWORD)v10 != 1)
          {
            v12[1] = *(float *)(v15 + 4 * v22) + v12[1];
            v22 = v19 + 2;
            if ((_DWORD)v10 != 2)
            {
              v12[2] = *(float *)(v15 + 4 * v22) + v12[2];
              v22 = v19 + 3;
              if ((_DWORD)v10 != 3)
              {
                v12[3] = *(float *)(v15 + 4 * v22) + v12[3];
                v22 = v19 + 4;
                if ((_DWORD)v10 != 4)
                {
                  v12[4] = *(float *)(v15 + 4 * v22) + v12[4];
                  v22 = v19 + 5;
                  if ((_DWORD)v10 != 5)
                  {
                    v12[5] = *(float *)(v15 + 4 * v22) + v12[5];
                    v22 = v19 + 6;
                    if ((_DWORD)v10 != 6)
                    {
                      v12[6] = *(float *)(v15 + 4 * v22) + v12[6];
                      v22 = v19 + 7;
                    }
                  }
                }
              }
            }
          }
          v19 = v22;
          --v21;
        }
        while (v21);
LABEL_37:
        v35 = 1.0 / (float)v13;
        if (v10 < 8)
        {
          v36 = 0;
          v23 = 0;
          do
          {
            v37 = v12;
            v38 = v10;
            do
            {
              v39 = *v37++;
              *(float *)(v15 + 4 * v23) = *(float *)(v15 + 4 * v23) - (float)(v35 * v39);
              ++v23;
              --v38;
            }
            while (v38);
            ++v36;
          }
          while (v36 != v13);
LABEL_42:
          if (v9 > v3)
            goto LABEL_43;
          goto LABEL_73;
        }
        v57 = 0;
        v58 = 0;
        while (1)
        {
          if (__CFADD__(v58, v14)
            || (v59 = 4 * v58, (unint64_t)v12 < v17 + v59) && v15 + v59 < (unint64_t)v16)
          {
            v60 = 0;
          }
          else
          {
            v64 = v58;
            v65 = (float32x4_t *)(v12 + 4);
            v66 = v10 & 0xFFFFFFF8;
            do
            {
              v67 = (float32x4_t *)(v15 + 4 * v64);
              v68 = vsubq_f32(v67[1], vmulq_n_f32(*v65, v35));
              *v67 = vsubq_f32(*v67, vmulq_n_f32(v65[-1], v35));
              v67[1] = v68;
              v65 += 2;
              v64 += 8;
              v66 -= 8;
            }
            while (v66);
            v58 += v18;
            v60 = v10 & 0xFFFFFFF8;
            v23 = v58;
            if (v18 == v10)
              goto LABEL_60;
          }
          v61 = v10 - v60;
          v62 = &v12[v60];
          v23 = v58;
          do
          {
            v63 = *v62++;
            *(float *)(v15 + 4 * v23) = *(float *)(v15 + 4 * v23) - (float)(v35 * v63);
            ++v23;
            --v61;
          }
          while (v61);
LABEL_60:
          ++v57;
          v58 = v23;
          if (v57 == v13)
            goto LABEL_42;
        }
      }
      v24 = 0;
      v25 = 0;
      while (1)
      {
        if (__CFADD__(v25, v14)
          || (v26 = 4 * v25, (unint64_t)v12 < v17 + v26) && v15 + v26 < (unint64_t)v16)
        {
          v27 = 0;
        }
        else
        {
          v30 = v25;
          v31 = (float32x4_t *)(v12 + 4);
          v32 = v10 & 0xFFFFFFF8;
          do
          {
            v33 = (float32x4_t *)(v15 + 4 * v30);
            v34 = vaddq_f32(v33[1], *v31);
            v31[-1] = vaddq_f32(*v33, v31[-1]);
            *v31 = v34;
            v31 += 2;
            v30 += 8;
            v32 -= 8;
          }
          while (v32);
          v25 += v18;
          v27 = v10 & 0xFFFFFFF8;
          if (v18 == v10)
            goto LABEL_25;
        }
        v28 = v10 - v27;
        v29 = &v12[v27];
        do
        {
          *v29 = *(float *)(v15 + 4 * v25) + *v29;
          ++v29;
          ++v25;
          --v28;
        }
        while (v28);
LABEL_25:
        if (++v24 == v13)
          goto LABEL_37;
      }
    }
  }
  return this;
}

uint64_t TSHMMDetector::advanceHMMScores(uint64_t result, uint64_t a2, double a3)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  float *v8;
  float v9;
  float v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  char v18;
  unsigned int *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  int v25;
  int v26;
  _QWORD *v27;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  float v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  int v37;

  v4 = result;
  if (*(_BYTE *)(result + 399))
  {
    v5 = *(unsigned int *)(a2 + 16);
    if ((_DWORD)v5)
    {
      v6 = *(_DWORD **)(a2 + 8);
      LODWORD(a3) = *v6;
      if ((_DWORD)v5 != 1)
      {
        v7 = v5 - 1;
        v8 = (float *)(v6 + 1);
        do
        {
          v9 = *v8++;
          v10 = v9;
          if (v9 > *(float *)&a3)
            *(float *)&a3 = v10;
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      LODWORD(a3) = 0;
    }
  }
  else
  {
    if (*(_BYTE *)(result + 400))
    {
      v37 = 0;
      if (*(_DWORD *)(result + 176))
        goto LABEL_15;
LABEL_11:
      LODWORD(v11) = 0;
      goto LABEL_23;
    }
    LODWORD(a3) = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4 * **(unsigned int **)(*(_QWORD *)(result + 168) + 64));
  }
  v37 = LODWORD(a3);
  if (!*(_DWORD *)(result + 176))
    goto LABEL_11;
LABEL_15:
  v12 = 0;
  v13 = 0;
  v14 = 0;
  do
  {
    v15 = *(_QWORD *)(v4 + 168) + v12;
    v16 = *(_QWORD *)(v4 + 304) + v13;
    if (v14)
      v17 = 1;
    else
      v17 = *(_BYTE *)(v4 + 401) == 0;
    v18 = !v17;
    v36 = v18;
    result = TSHMMDetector::updateStateProbs(v4, v15, v16, a2, (float *)&v37, &v36, a3);
    ++v14;
    v11 = *(unsigned int *)(v4 + 176);
    v13 += 48;
    v12 += 88;
  }
  while (v14 < v11);
LABEL_23:
  v19 = *(unsigned int **)(v4 + 168);
  v20 = *(_QWORD **)(v4 + 304);
  v21 = v20[1];
  v22 = 4 * *v19;
  v23 = *(float *)(v21 + v22);
  v24 = v20[4];
  v25 = *(_DWORD *)(v24 + v22);
  if (v11 < 2)
  {
    v26 = 0;
  }
  else
  {
    v26 = 0;
    v27 = v20 + 10;
    v28 = v19 + 22;
    v29 = 1;
    do
    {
      v31 = *v28;
      v28 += 22;
      v30 = v31;
      v32 = *(float *)(*(v27 - 3) + 4 * v31);
      if (v32 > v23)
      {
        v25 = *(_DWORD *)(*v27 + 4 * v30);
        v26 = v29;
        v23 = v32;
      }
      ++v29;
      v27 += 6;
    }
    while (v11 != v29);
  }
  v33 = (float)*(unsigned int *)(v4 + 196);
  *(float *)(v4 + 352) = v23 * v33;
  *(_DWORD *)(v4 + 356) = v25;
  *(_DWORD *)(v4 + 360) = v26;
  v34 = *(unsigned int *)(v4 + 188);
  if ((_DWORD)v34)
  {
    v35 = 4 * v34;
    *(float *)(v4 + 344) = *(float *)(v21 + v35) * v33;
    *(_DWORD *)(v4 + 348) = *(_DWORD *)(v24 + v35);
  }
  ++*(_DWORD *)(v4 + 368);
  return result;
}

uint64_t TSHMMDetector::updateStateProbs(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, float *a5, _BYTE *a6, double a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  char v43;
  float v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  float v52;
  float v53;
  float v54;
  _DWORD *v55;
  uint64_t v56;
  float *v57;
  uint64_t v58;
  uint64_t v59;
  float32x4_t v60;
  float32x4_t *v61;
  uint64_t v62;
  float32x4_t v63;
  uint64_t v64;
  float *v65;

  v10 = a2;
  v11 = result;
  v12 = *(unsigned int *)a2;
  if (*(_BYTE *)(a2 + 80))
  {
    v13 = (v12 - 1);
    if ((_DWORD)v12 != 1)
    {
      v14 = 0;
      v15 = *(_QWORD *)(a3 + 8);
      v16 = *(_QWORD *)(a3 + 32);
      v17 = 4 * (v12 - 1);
      v18 = v16 + v17;
      v19 = *(_QWORD *)(a2 + 40);
      v20 = v12 - 3;
      v21 = *(_QWORD *)(a2 + 16) + v17;
      v22 = v15 + v17;
      do
      {
        v23 = (v12 - 2 + v14);
        v24 = *(float *)(v22 + 4 * v14) + *(float *)(v21 + 4 * v14);
        v25 = *(float *)(v15 + 4 * v23) + *(float *)(v19 + 4 * v23);
        a2 = v25 >= v24;
        if (v25 >= v24)
        {
          *(_DWORD *)(v18 + 4 * v14) = *(_DWORD *)(v16 + 4 * v23);
          v24 = v25;
        }
        if ((unint64_t)(v13 + v14) >= 2 && (((_DWORD)v13 + (_DWORD)v14) & 1) != 0)
        {
          v26 = *(float *)(v15 + 4 * (v20 + v14)) + *(float *)(v19 + 4 * (v20 + v14));
          if (v26 >= v24)
          {
            *(_DWORD *)(v18 + 4 * v14) = *(_DWORD *)(v16 + 4 * (v20 + v14));
            a2 = 1;
            v24 = v26;
          }
        }
        *(float *)(v22 + 4 * v14) = v24;
        if (*a6)
          *(_BYTE *)(*(_QWORD *)(v11 + 328) + v23) = a2;
        result = (v13 + v14--);
      }
      while ((_DWORD)result != 1);
    }
    if (*a6)
    {
LABEL_14:
      v27 = *(unsigned int *)(v11 + 148);
      if (*(_DWORD *)(v11 + 336) != (_DWORD)v27)
        Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)a2, *(unsigned int *)(v11 + 336), v27);
      v28 = *(_QWORD *)(v11 + 120) + 24 * *(unsigned int *)(v11 + 152);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v28 + 16))(v28, v11 + 320);
      v30 = *(_DWORD *)(v11 + 152);
      v29 = *(_DWORD *)(v11 + 156);
      v31 = *(_DWORD *)(v11 + 144);
      if (v30 + 1 < v31)
        v32 = v30 + 1;
      else
        v32 = 0;
      *(_DWORD *)(v11 + 152) = v32;
      if (v29 < v31)
        *(_DWORD *)(v11 + 156) = v29 + 1;
    }
  }
  else
  {
    v37 = (v12 - 1);
    if (*a6)
    {
      if ((_DWORD)v12 != 1)
      {
        v38 = *(_QWORD *)(a3 + 8);
        v39 = *(_QWORD *)(a2 + 16);
        v40 = *(_QWORD *)(a2 + 40);
        v41 = v12 - 2;
        v42 = *(_QWORD *)(a3 + 32);
        do
        {
          v44 = *(float *)(v38 + 4 * v37) + *(float *)(v39 + 4 * v37);
          v45 = v41;
          v46 = *(float *)(v38 + 4 * v41) + *(float *)(v40 + 4 * v41);
          if (v44 <= v46)
          {
            *(_DWORD *)(v42 + 4 * v37) = *(_DWORD *)(v42 + 4 * v41);
            v43 = 1;
            v44 = v46;
          }
          else
          {
            v43 = 0;
          }
          *(_BYTE *)(*(_QWORD *)(result + 328) + v45) = v43;
          *(float *)(v38 + 4 * v37) = v44;
          v41 = v45 - 1;
          --v37;
        }
        while ((_DWORD)v37);
      }
      goto LABEL_14;
    }
    if ((_DWORD)v12 == 1)
      goto LABEL_36;
    v47 = *(_QWORD *)(a3 + 8);
    v48 = *(_QWORD *)(a2 + 16);
    v49 = *(_QWORD *)(a2 + 40);
    v50 = v12 - 2;
    v51 = *(_QWORD *)(a3 + 32);
    do
    {
      v52 = *(float *)(v47 + 4 * v37) + *(float *)(v48 + 4 * v37);
      v53 = *(float *)(v47 + 4 * v50) + *(float *)(v49 + 4 * v50);
      if (v52 <= v53)
      {
        *(_DWORD *)(v51 + 4 * v37) = *(_DWORD *)(v51 + 4 * v50);
        v52 = v53;
      }
      *(float *)(v47 + 4 * v37) = v52;
      --v50;
      --v37;
    }
    while ((_DWORD)v37);
  }
  if (v12 > 1)
  {
    v33 = *(_QWORD *)(v10 + 64);
    v34 = *(_QWORD *)(a4 + 8);
    v35 = 1;
    v36 = *(float **)(a3 + 8);
    do
    {
      v36[v35] = *(float *)(v34 + 4 * *(unsigned int *)(v33 + v35 * 4)) + v36[v35];
      ++v35;
    }
    while (v12 != v35);
    goto LABEL_37;
  }
LABEL_36:
  v36 = *(float **)(a3 + 8);
LABEL_37:
  v54 = *v36 + **(float **)(v10 + 16);
  *v36 = v54;
  *v36 = v54 + *a5;
  v55 = *(_DWORD **)(a3 + 32);
  *v55 = *(_DWORD *)(v11 + 368) + 1;
  v56 = (v12 - 1);
  v57 = *(float **)(v10 + 40);
  v36[v12] = v36[v56] + v57[v56];
  v55[v12] = v55[v56];
  *(float *)&a7 = *v36 + *v57;
  if ((v12 + 1) > 1)
    v58 = (v12 + 1);
  else
    v58 = 1;
  if (v58 <= 7)
  {
    v59 = 0;
LABEL_45:
    v64 = v58 - v59;
    v65 = &v36[v59];
    do
    {
      *v65 = *v65 - *(float *)&a7;
      ++v65;
      --v64;
    }
    while (v64);
    return result;
  }
  v59 = v58 & 0xFFFFFFF8;
  v60 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
  v61 = (float32x4_t *)(v36 + 4);
  v62 = v59;
  do
  {
    v63 = vsubq_f32(*v61, v60);
    v61[-1] = vsubq_f32(v61[-1], v60);
    *v61 = v63;
    v61 += 2;
    v62 -= 8;
  }
  while (v62);
  if (v59 != v58)
    goto LABEL_45;
  return result;
}

uint64_t TSHMMDetector::endFrame(TSHMMDetector *this, const char *a2, double a3)
{
  int v4;
  char *v5;
  int v6;
  const char *v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  if (!*((_BYTE *)this + 396))
    Error::chuck((Error *)"TSHMMDetector::endFrame() - init() not called", a2);
  v4 = *((unsigned __int8 *)this + 397);
  *((_BYTE *)this + 397) = 1;
  while ((TSHMMDetector::updateResult(this, a2, a3) & 1) != 0)
    ;
  if (!*((_BYTE *)this + 398))
    return 0;
  if (v4)
  {
    v5 = (char *)this + 32;
    v6 = *((_DWORD *)this + 18);
    if (*((_BYTE *)this + 105) && v6)
      goto LABEL_11;
LABEL_10:
    if (v6 == *((_DWORD *)this + 9) + 1)
      goto LABEL_11;
    return 0;
  }
  *((_BYTE *)this + 105) = 1;
  v5 = (char *)this + 32;
  v6 = *((_DWORD *)this + 18);
  if (!v6)
    goto LABEL_10;
LABEL_11:
  v7 = (char *)this + 52;
  if (!*((_DWORD *)this + 13))
    Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v7);
  (*(void (**)(char *, const char *))(*((_QWORD *)this + 28) + 32))((char *)this + 224, v7);
  NFrameWindow::setOutputFrameWindow((uint64_t)v5, *((float **)this + 29));
  TSHMMDetector::stepFrame(this, (TSHMMDetector *)((char *)this + 224));
  v8 = *((_DWORD *)this + 91);
  v9 = *((_DWORD *)this + 92);
  v10 = v8 >= v9;
  v11 = v8 - v9;
  if (v11 != 0 && v10)
  {
    if (*((_DWORD *)this + 94) > v11)
      *((_DWORD *)this + 94) = v11;
  }
  else
  {
    *((_DWORD *)this + 94) = 0;
  }
  return 1;
}

void TSHMMDetector::padToEndOfBatch(TSHMMDetector *this)
{
  unsigned int v2;
  const char *v3;
  double v4;
  unsigned int v5;
  size_t v6;
  void *v7;
  uint64_t (**v8)();
  void *v9;
  int v10;

  v2 = *((_DWORD *)this + 95);
  if (v2 < (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1)))
  {
    v10 = 0;
    v8 = (uint64_t (**)())&off_24C7F31A8;
    v9 = 0;
    if (!*((_BYTE *)this + 396))
      Error::chuck((Error *)"TSHMMDetector::frameSize() - init() not called", v3);
    v5 = *((_DWORD *)this + 46);
    if (v5)
    {
      v10 = *((_DWORD *)this + 46);
      v6 = 4 * v5;
      v7 = (void *)operator new[]();
      v9 = v7;
      bzero(v7, v6);
    }
    else
    {
      v7 = 0;
    }
    *((_DWORD *)this + 98) = 0;
    if (!*((_DWORD *)this + 94))
    {
      do
      {
        TSHMMDetector::feedFrame(this, (const NFrame *)&v8, v4);
        --*((_DWORD *)this + 91);
        ++*((_DWORD *)this + 98);
      }
      while (!*((_DWORD *)this + 94));
      v7 = v9;
    }
    v8 = &off_24C7F3090;
    if (v7)
      MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  }
}

void sub_20D97EAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8052888210);
  _Unwind_Resume(exception_object);
}

uint64_t TSHMMDetector::frameSize(TSHMMDetector *this, const char *a2)
{
  if (!*((_BYTE *)this + 396))
    Error::chuck((Error *)"TSHMMDetector::frameSize() - init() not called", a2);
  return *((unsigned int *)this + 46);
}

uint64_t TSHMMDetector::skipUntilInitialize(TSHMMDetector *this, const NFrame *a2)
{
  uint64_t result;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  float v13;

  result = *((_QWORD *)this + 2);
  if (result)
  {
    v4 = *((_DWORD *)this + 97);
    if (!v4)
      return 0;
    v5 = v4 - 1;
    *((_DWORD *)this + 97) = v5;
    if (v5)
    {
      ++*((_DWORD *)this + 92);
      return 1;
    }
    if (!*((_BYTE *)this + 402))
    {
      (*(void (**)(uint64_t, const NFrame *, char *, _QWORD))(*(_QWORD *)result + 72))(result, a2, (char *)this + 248, 0);
      v6 = **((_DWORD **)this + 21);
      v7 = *((_QWORD *)this + 38);
      v8 = (v6 - 1);
      if (v6 == 1)
      {
        v11 = *(_DWORD **)(v7 + 32);
        v12 = *(_DWORD **)(v7 + 8);
      }
      else
      {
        v9 = 0;
        v10 = *((_QWORD *)this + 32);
        v11 = *(_DWORD **)(v7 + 32);
        v12 = *(_DWORD **)(v7 + 8);
        do
        {
          v13 = *(float *)(v10 + 4 * (v8 + v9));
          if (v13 < 0.0)
            v13 = 0.0;
          v11[v9 + 1] = *((_DWORD *)this + 92) - (uint64_t)rintf(v13);
          v12[v9 + 1] = *(_DWORD *)(v10 + 4 * v9);
          ++v9;
        }
        while (v8 != v9);
      }
      result = 0;
      *v11 = *((_DWORD *)this + 92);
      *v12 = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL TSHMMDetector::skipUntilProcessedFrame(TSHMMDetector *this)
{
  int v2;
  int v3;
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  _BOOL8 result;

  v2 = *((_DWORD *)this + 95);
  if (v2)
  {
    if (*((_BYTE *)this + 401))
    {
      v3 = **((_DWORD **)this + 21);
      v4 = (v3 - 1);
      if (v3 != 1)
        bzero(*((void **)this + 41), v4);
      v5 = *((unsigned int *)this + 37);
      if (*((_DWORD *)this + 84) != (_DWORD)v5)
        Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)v4, *((unsigned int *)this + 84), v5);
      v6 = *((_QWORD *)this + 15) + 24 * *((unsigned int *)this + 38);
      (*(void (**)(uint64_t, char *))(*(_QWORD *)v6 + 16))(v6, (char *)this + 320);
      v8 = *((_DWORD *)this + 38);
      v7 = *((_DWORD *)this + 39);
      v9 = *((_DWORD *)this + 36);
      if (v8 + 1 < v9)
        v10 = v8 + 1;
      else
        v10 = 0;
      *((_DWORD *)this + 38) = v10;
      if (v7 < v9)
        *((_DWORD *)this + 39) = v7 + 1;
      v11 = *((_DWORD *)this + 95);
    }
    else
    {
      v11 = *((_DWORD *)this + 95);
    }
    ++*((_DWORD *)this + 96);
    v13 = v11 - 1;
  }
  else
  {
    v12 = *((_DWORD *)this + 92);
    if (v12 && *((_DWORD *)this + 51) == 1)
      *((_DWORD *)this + 92) = *((_DWORD *)this + 48) + v12;
    v13 = *((_DWORD *)this + 48);
  }
  result = v2 != 0;
  *((_DWORD *)this + 95) = v13;
  return result;
}

float TSHMMDetector::maxScore(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float result;
  uint64_t v5;
  float *v6;
  float v7;
  float v8;

  v2 = *(unsigned int *)(a2 + 16);
  if (!(_DWORD)v2)
    return 0.0;
  v3 = *(float **)(a2 + 8);
  result = *v3;
  if ((_DWORD)v2 != 1)
  {
    v5 = v2 - 1;
    v6 = v3 + 1;
    do
    {
      v7 = *v6++;
      v8 = v7;
      if (v7 > result)
        result = v8;
      --v5;
    }
    while (v5);
  }
  return result;
}

float TSHMMDetector::partialScore(TSHMMDetector *this)
{
  return *((float *)this + 86);
}

uint64_t TSHMMDetector::partialLength(TSHMMDetector *this)
{
  if (*((_DWORD *)this + 47))
    return (*((_DWORD *)this + 92) - *((_DWORD *)this + 87));
  else
    return 0;
}

float TSHMMDetector::score(TSHMMDetector *this)
{
  return *((float *)this + 88);
}

uint64_t TSHMMDetector::bestLength(TSHMMDetector *this)
{
  return (*((_DWORD *)this + 92) - *((_DWORD *)this + 89));
}

uint64_t TSHMMDetector::bestPhrase(TSHMMDetector *this)
{
  return *((unsigned int *)this + 90);
}

float TSHMMDetector::scorePhrase(TSHMMDetector *this, const char *a2)
{
  uint64_t v2;

  v2 = *((unsigned int *)this + 44);
  if (*(_DWORD *)a2 >= v2)
    Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", a2, *(unsigned int *)a2, v2);
  return *(float *)(*(_QWORD *)(*((_QWORD *)this + 38) + 48 * *(unsigned int *)a2 + 8)
                  + 4 * *(unsigned int *)(*((_QWORD *)this + 21) + 88 * *(unsigned int *)a2))
       * (float)*((unsigned int *)this + 49);
}

uint64_t TSHMMDetector::bestLengthPhrase(TSHMMDetector *this, const char *a2)
{
  uint64_t v2;

  v2 = *((unsigned int *)this + 44);
  if (*(_DWORD *)a2 >= v2)
    Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", a2, *(unsigned int *)a2, v2);
  return (*((_DWORD *)this + 92)
                      - *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 38) + 48 * *(unsigned int *)a2 + 32)
                                  + 4 * *(unsigned int *)(*((_QWORD *)this + 21) + 88 * *(unsigned int *)a2)));
}

uint64_t TSHMMDetector::numPhrases(TSHMMDetector *this)
{
  return *((unsigned int *)this + 44);
}

uint64_t TSHMMDetector::frameLatency(TSHMMDetector *this)
{
  int v1;

  v1 = *((_DWORD *)this + 91) - *((_DWORD *)this + 92) + *((_DWORD *)this + 50);
  return v1 & ~(v1 >> 31);
}

uint64_t TSHMMDetector::numStates(TSHMMDetector *this)
{
  if (*((_DWORD *)this + 44))
    return (**((_DWORD **)this + 21) - 1);
  else
    return 0;
}

uint64_t TSHMMDetector::stateAlignment(uint64_t a1, uint64_t a2, int a3)
{
  int v4;

  v4 = a3;
  return NLRHMMTraceback::stateAlignment(a1 + 112, a2, &v4);
}

uint64_t TSHMMDetector::lastOutputDistSize(TSHMMDetector *this)
{
  return *((unsigned int *)this + 72);
}

BOOL TSHMMDetector::lastOutputDist(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  v2 = *(unsigned int *)(a1 + 288);
  if (*(_DWORD *)(a2 + 16) != (_DWORD)v2)
    Error::chuck((Error *)"TSHMMDetector::lastModelOutput() - mismatched size in output array (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v2);
  v3 = *(unsigned __int8 *)(a1 + 403);
  if (*(_BYTE *)(a1 + 403))
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 272);
  return v3 != 0;
}

void sub_20D97F9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D97FBB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D97FE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D980004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__574(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__575(uint64_t a1)
{

}

void TSSATScorer::~TSSATScorer(TSSATScorer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24C7F16D0;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 30) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 31);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 27) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 28);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 11) = &off_24C7F1670;
  *((_QWORD *)this + 24) = &off_24C7F32C0;
  v5 = *((_QWORD *)this + 26);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *((_QWORD *)this + 21) = &off_24C7F32C0;
  v6 = *((_QWORD *)this + 23);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  *((_QWORD *)this + 12) = &off_24C7F32C0;
  v7 = *((_QWORD *)this + 14);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  *((_QWORD *)this + 2) = &off_24C7F1790;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  v8 = *((_QWORD *)this + 5);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24C7F16D0;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 30) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 31);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 27) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 28);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 11) = &off_24C7F1670;
  *((_QWORD *)this + 24) = &off_24C7F32C0;
  v5 = *((_QWORD *)this + 26);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *((_QWORD *)this + 21) = &off_24C7F32C0;
  v6 = *((_QWORD *)this + 23);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  *((_QWORD *)this + 12) = &off_24C7F32C0;
  v7 = *((_QWORD *)this + 14);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  *((_QWORD *)this + 2) = &off_24C7F1790;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  v8 = *((_QWORD *)this + 5);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24C7F16D0;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 30) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 31);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 27) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 28);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 11) = &off_24C7F1670;
  *((_QWORD *)this + 24) = &off_24C7F32C0;
  v5 = *((_QWORD *)this + 26);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *((_QWORD *)this + 21) = &off_24C7F32C0;
  v6 = *((_QWORD *)this + 23);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  *((_QWORD *)this + 12) = &off_24C7F32C0;
  v7 = *((_QWORD *)this + 14);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  *((_QWORD *)this + 2) = &off_24C7F1790;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  v8 = *((_QWORD *)this + 5);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
}

void TSSATScorer::TSSATScorer(TSSATScorer *this)
{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F16D0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &off_24C7F1790;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  *((_DWORD *)this + 8) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 5) = v2;
  *v2 = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_BYTE *)this + 80) = 0;
  NSATSpeaker::NSATSpeaker((TSSATScorer *)((char *)this + 88));
  *((_QWORD *)this + 27) = &off_24C7F31A8;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = &off_24C7F3090;
  *((_QWORD *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_BYTE *)this + 280) = 0;
  *(_QWORD *)((char *)this + 284) = 0;
  *(_QWORD *)((char *)this + 290) = 0;
}

{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F16D0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &off_24C7F1790;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  *((_DWORD *)this + 8) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 5) = v2;
  *v2 = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_BYTE *)this + 80) = 0;
  NSATSpeaker::NSATSpeaker((TSSATScorer *)((char *)this + 88));
  *((_QWORD *)this + 27) = &off_24C7F31A8;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = &off_24C7F3090;
  *((_QWORD *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_BYTE *)this + 280) = 0;
  *(_QWORD *)((char *)this + 284) = 0;
  *(_QWORD *)((char *)this + 290) = 0;
}

void sub_20D980D04(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v4 = v2;
  v1[2] = v4;
  v1[3] = v3;
  v6 = v1[5];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D980DE8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v4 = v2;
  v1[2] = v4;
  v1[3] = v3;
  v6 = v1[5];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

float TSSATScorer::init(TSSATScorer *this, const NString *a2, const NString *a3, const unsigned int *a4, const BOOL *a5, const BOOL *a6, const BOOL *a7, float *a8, const unsigned int *a9, unsigned int *a10, const unsigned int *a11)
{
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  const BOOL *v22;
  float *v23;
  const BOOL *v24;
  int v25;
  unsigned int v26;
  _DWORD *v27;
  int *v28;
  int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  _OWORD *v38;
  __int128 *v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int *v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v54;
  _OWORD *v55;
  __int128 *v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  int *v62;
  int v63;
  int v64;
  float result;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int *v76;
  const char *v77;
  const NString *v78;
  uint64_t (**v79)(NString *__hidden, const unsigned int *);
  int v80;
  _BYTE *v81;
  void (**v82)(NDistributionLoader *__hidden);
  uint64_t v83;

  if (*((_BYTE *)this + 295))
    Error::chuck((Error *)"TSSATScorer::init() - init() already called", (const char *)a2, a3, a4, a5, a6, a7, a8);
  v19 = *((_QWORD *)this + 1);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  v79 = &off_24C7F32C0;
  v80 = 0;
  v20 = (_BYTE *)operator new[]();
  *v20 = 0;
  v81 = v20;
  v82 = &off_24C7F1FD8;
  v83 = 0;
  v78 = a2;
  v21 = NDistributionLoader::read((NDistributionLoader *)&v82, (uint64_t (***)(NString *__hidden, const unsigned int *))a2, (const NString *)&v79);
  v22 = a6;
  if (v83)
    (*(void (**)(uint64_t))(*(_QWORD *)v83 + 8))(v83);
  v23 = a8;
  *((_QWORD *)this + 1) = v21;
  v79 = &off_24C7F32C0;
  if (v81)
  {
    MEMORY[0x212BAC9C0](v81, 0x1000C8077774924);
    v21 = *((_QWORD *)this + 1);
  }
  v24 = a7;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v21 + 32))(v21) != 1)
  {
    v66 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
    Error::chuck((Error *)"TSSATScorer::init() - Models must expect a single frame, not %d", v67, v66);
  }
  v25 = *a11;
  v26 = *a10 | *a11;
  if (v26)
  {
    v27 = (_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
    v26 = *a10;
    if (*v27 + v25 > *a10)
    {
      v74 = *((_QWORD *)this + 1);
      v75 = *a11;
      v76 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v74 + 24))(v74);
      Error::chuck((Error *)"TSSATScorer::init() - Subvector extraction out of range (%d + %d > %d)", v77, v75, *v76, *a10);
    }
  }
  *((_DWORD *)this + 66) = v26;
  *((_DWORD *)this + 67) = *a11;
  v28 = (int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
  v29 = *v28;
  *((_DWORD *)this + 68) = *v28;
  if (!*((_DWORD *)this + 66))
    *((_DWORD *)this + 66) = v29;
  v30 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
  v31 = *((_DWORD *)this + 58);
  if (v31 != *v30)
  {
    v32 = v30;
    v33 = *((_QWORD *)this + 28);
    *((_DWORD *)this + 58) = *v30;
    v34 = operator new[]();
    *((_QWORD *)this + 28) = v34;
    LODWORD(v35) = *v32;
    if (v31 >= *v32)
      v35 = v35;
    else
      v35 = v31;
    if ((_DWORD)v35)
    {
      if (v35 >= 8 && (unint64_t)(v34 - v33) > 0x1F)
      {
        v37 = v35 & 0xFFFFFFF8;
        v38 = (_OWORD *)(v34 + 16);
        v39 = (__int128 *)(v33 + 16);
        v40 = v37;
        do
        {
          v41 = *v39;
          *(v38 - 1) = *(v39 - 1);
          *v38 = v41;
          v38 += 2;
          v39 += 2;
          v40 -= 8;
        }
        while (v40);
        if (v37 == v35)
          goto LABEL_30;
      }
      else
      {
        v37 = 0;
      }
      v42 = v35 - v37;
      v43 = 4 * v37;
      v44 = (_DWORD *)(v34 + 4 * v37);
      v45 = (int *)(v33 + v43);
      do
      {
        v46 = *v45++;
        *v44++ = v46;
        --v42;
      }
      while (v42);
LABEL_30:
      MEMORY[0x212BAC9C0](v33, 0x1000C8052888210);
      goto LABEL_31;
    }
    if (v33)
      goto LABEL_30;
  }
LABEL_31:
  v47 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  v48 = *((_DWORD *)this + 64);
  if (v48 != v47)
  {
    v49 = v47;
    v50 = *((_QWORD *)this + 31);
    *((_DWORD *)this + 64) = v47;
    v51 = operator new[]();
    *((_QWORD *)this + 31) = v51;
    if (v48 >= v49)
      v52 = v49;
    else
      v52 = v48;
    if (!(_DWORD)v52)
    {
      if (!v50)
        goto LABEL_49;
      goto LABEL_48;
    }
    if (v52 >= 8 && (unint64_t)(v51 - v50) > 0x1F)
    {
      v54 = v52 & 0xFFFFFFF8;
      v55 = (_OWORD *)(v51 + 16);
      v56 = (__int128 *)(v50 + 16);
      v57 = v54;
      do
      {
        v58 = *v56;
        *(v55 - 1) = *(v56 - 1);
        *v55 = v58;
        v55 += 2;
        v56 += 2;
        v57 -= 8;
      }
      while (v57);
      if (v54 == v52)
        goto LABEL_48;
    }
    else
    {
      v54 = 0;
    }
    v59 = v52 - v54;
    v60 = 4 * v54;
    v61 = (_DWORD *)(v51 + 4 * v54);
    v62 = (int *)(v50 + v60);
    do
    {
      v63 = *v62++;
      *v61++ = v63;
      --v59;
    }
    while (v59);
LABEL_48:
    MEMORY[0x212BAC9C0](v50, 0x1000C8052888210);
  }
LABEL_49:
  *((_BYTE *)this + 292) = 0;
  if (*((_DWORD *)a3 + 2))
  {
    *((_BYTE *)this + 292) = 1;
    NSATImpostor::load((TSSATScorer *)((char *)this + 16), a3);
    v64 = *((_DWORD *)this + 12);
    if (v64 != (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1)))
    {
      v68 = *((_QWORD *)a3 + 2);
      v69 = *((_QWORD *)v78 + 2);
      v70 = *((_QWORD *)this + 1);
      v71 = *((unsigned int *)this + 12);
      v72 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v70 + 16))(v70);
      Error::chuck((Error *)"TSSATScorer::init() - Impostor model dimensionality in %s (%d)does not match transform in %s (%d)", v73, v68, v71, v69, v72);
    }
  }
  *((_DWORD *)this + 69) = *a4;
  *((_BYTE *)this + 293) = *a5;
  *((_BYTE *)this + 280) = *v22;
  result = *v23;
  *((float *)this + 71) = *v23;
  *((_DWORD *)this + 72) = *a9;
  *((_BYTE *)this + 294) = *v24;
  *((_BYTE *)this + 297) = 0;
  *(_WORD *)((char *)this + 295) = 1;
  return result;
}

void sub_20D9813A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18)
    (*(void (**)(uint64_t))(*(_QWORD *)a18 + 8))(a18);
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void TSSATScorer::setModelFile(TSSATScorer *this, const NString *a2)
{
  NSATSpeaker *v4;
  const char *v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t (**v8)(NString *__hidden, const unsigned int *);
  int v9;
  _BYTE *v10;
  BOOL v11;
  unsigned int v12;

  if (!*((_BYTE *)this + 295))
    Error::chuck((Error *)"TSSATScorer::setModelFile() - init() not called", (const char *)a2);
  *((_BYTE *)this + 296) = 0;
  v4 = (TSSATScorer *)((char *)this + 88);
  v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  v11 = 1;
  v8 = &off_24C7F32C0;
  v9 = 0;
  v10 = (_BYTE *)operator new[]();
  *v10 = 0;
  NSATSpeaker::configure(v4, &v12, (const unsigned int *)this + 69, &v11, (const BOOL *)this + 280, (const BOOL *)this + 294, (float *)this + 71, (const unsigned int *)this + 72, a2, (const NString *)&v8);
  v8 = &off_24C7F32C0;
  if (v10)
    MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  NSATSpeaker::loadOrInit(v4, v5, v6, v7);
  *((_BYTE *)this + 296) = 1;
}

void sub_20D981500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void TSSATScorer::score(TSSATScorer *this, const float *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  const float *v16;
  int v17;
  uint64_t v18;
  float32x4_t *v19;
  uint64_t v20;
  float v21;
  float *v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  float v26;
  float v27;
  uint64_t v28;
  _OWORD *v29;
  const float *v30;
  uint64_t v31;
  __int128 v32;
  float32x4_t *v33;
  uint64_t v34;
  float32x4_t v35;
  uint64_t v36;
  float *v37;
  __n128 v38;
  uint64_t v39;
  float32x4_t *v40;
  uint64_t v41;
  float *v42;
  uint64_t v43;
  uint64_t v44;
  float *v45;
  float v46;
  uint64_t v47;
  float32x4_t *v48;
  uint64_t v49;
  float32x4_t v50;
  uint64_t v51;
  float *v52;
  __int32 v53;
  unsigned __int32 v54;

  *((_BYTE *)this + 297) = 0;
  if (!*((_BYTE *)this + 296))
    Error::chuck((Error *)"TSSATScorer::score() - setModelFile() not called", (const char *)a2);
  v4 = *((unsigned int *)this + 66);
  if ((_DWORD)v4 != (_DWORD)a3)
    Error::chuck((Error *)"TSSATScorer::score() - supervector size (%d) does not match scorer input size (%d)", (const char *)a2, a3, v4);
  if (!a2)
    Error::chuck((Error *)"TSSATScorer::score() - NULL supervector pointer", 0);
  v6 = *((unsigned int *)this + 67);
  v7 = *((_DWORD *)this + 58);
  v8 = *((_DWORD *)this + 68);
  if (v7 != v8)
  {
    v9 = *((_QWORD *)this + 28);
    if (v9)
    {
      MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
      v8 = *((_DWORD *)this + 68);
    }
    *((_DWORD *)this + 58) = v8;
    *((_QWORD *)this + 28) = operator new[]();
    v7 = *((_DWORD *)this + 58);
  }
  if (v7)
  {
    v10 = *((_QWORD *)this + 28);
    v11 = v7;
    if (v7 < 8 || (unint64_t)(v10 - (_QWORD)a2 - 4 * v6) < 0x20)
    {
      v12 = 0;
LABEL_12:
      v13 = v11 - v12;
      v14 = v12;
      v15 = (_DWORD *)(v10 + v14 * 4);
      v16 = &a2[v6 + v14];
      do
      {
        v17 = *(_DWORD *)v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
      goto LABEL_14;
    }
    v12 = v7 & 0xFFFFFFF8;
    v29 = (_OWORD *)(v10 + 16);
    v30 = &a2[v6 + 4];
    v31 = v11 & 0xFFFFFFF8;
    do
    {
      v32 = *(_OWORD *)v30;
      *(v29 - 1) = *((_OWORD *)v30 - 1);
      *v29 = v32;
      v29 += 2;
      v30 += 8;
      v31 -= 8;
    }
    while (v31);
    if (v12 != v11)
      goto LABEL_12;
  }
LABEL_14:
  if (!*((_BYTE *)this + 293))
    goto LABEL_35;
  v18 = *((unsigned int *)this + 58);
  if (!(_DWORD)v18)
    goto LABEL_35;
  v19 = (float32x4_t *)*((_QWORD *)this + 28);
  if ((_DWORD)v18 == 1)
  {
    v20 = 0;
    v21 = 0.0;
  }
  else
  {
    v20 = v18 & 0xFFFFFFFE;
    v22 = &v19->f32[1];
    v21 = 0.0;
    v23 = v20;
    do
    {
      v21 = (float)(v21 + (float)(*(v22 - 1) * *(v22 - 1))) + (float)(*v22 * *v22);
      v22 += 2;
      v23 -= 2;
    }
    while (v23);
    if (v20 == v18)
      goto LABEL_23;
  }
  v24 = v18 - v20;
  v25 = &v19->f32[v20];
  do
  {
    v26 = *v25++;
    v21 = v21 + (float)(v26 * v26);
    --v24;
  }
  while (v24);
LABEL_23:
  if (v21 <= 0.0)
    goto LABEL_35;
  v27 = sqrtf((float)v18 / v21);
  if (v18 < 8)
  {
    v28 = 0;
LABEL_33:
    v36 = v18 - v28;
    v37 = &v19->f32[v28];
    do
    {
      *v37 = v27 * *v37;
      ++v37;
      --v36;
    }
    while (v36);
    goto LABEL_35;
  }
  v28 = v18 & 0xFFFFFFF8;
  v33 = v19 + 1;
  v34 = v28;
  do
  {
    v35 = vmulq_n_f32(*v33, v27);
    v33[-1] = vmulq_n_f32(v33[-1], v27);
    *v33 = v35;
    v33 += 2;
    v34 -= 8;
  }
  while (v34);
  if (v28 != v18)
    goto LABEL_33;
LABEL_35:
  (*(void (**)(_QWORD, char *, char *, _QWORD))(**((_QWORD **)this + 1) + 72))(*((_QWORD *)this + 1), (char *)this + 216, (char *)this + 240, 0);
  v39 = *((unsigned int *)this + 64);
  if (!(_DWORD)v39)
    goto LABEL_51;
  v40 = (float32x4_t *)*((_QWORD *)this + 31);
  if ((_DWORD)v39 == 1)
  {
    v41 = 0;
    v38.n128_u32[0] = 0;
LABEL_41:
    v44 = v39 - v41;
    v45 = &v40->f32[v41];
    do
    {
      v46 = *v45++;
      v38.n128_f32[0] = v38.n128_f32[0] + (float)(v46 * v46);
      --v44;
    }
    while (v44);
    goto LABEL_43;
  }
  v41 = v39 & 0xFFFFFFFE;
  v42 = &v40->f32[1];
  v38.n128_u32[0] = 0;
  v43 = v41;
  do
  {
    v38.n128_f32[0] = (float)(v38.n128_f32[0] + (float)(*(v42 - 1) * *(v42 - 1))) + (float)(*v42 * *v42);
    v42 += 2;
    v43 -= 2;
  }
  while (v43);
  if (v41 != v39)
    goto LABEL_41;
LABEL_43:
  if (v38.n128_f32[0] <= 0.0)
    goto LABEL_51;
  v38.n128_f32[0] = sqrtf((float)v39 / v38.n128_f32[0]);
  if (v39 < 8)
  {
    v47 = 0;
LABEL_49:
    v51 = v39 - v47;
    v52 = &v40->f32[v47];
    do
    {
      *v52 = v38.n128_f32[0] * *v52;
      ++v52;
      --v51;
    }
    while (v51);
    goto LABEL_51;
  }
  v47 = v39 & 0xFFFFFFF8;
  v48 = v40 + 1;
  v49 = v47;
  do
  {
    v50 = vmulq_n_f32(*v48, v38.n128_f32[0]);
    v48[-1] = vmulq_n_f32(v48[-1], v38.n128_f32[0]);
    *v48 = v50;
    v48 += 2;
    v49 -= 8;
  }
  while (v49);
  if (v47 != v39)
    goto LABEL_49;
LABEL_51:
  v53 = 1065353216;
  v54 = 0;
  if (*((_BYTE *)this + 292))
    NSATImpostor::score((uint64_t)this + 16, (uint64_t)this + 240, &v54, &v53, v38);
  NSATSpeaker::score((uint64_t)this + 88, (uint64_t)this + 240, &v54, &v53, v38);
  *((_BYTE *)this + 297) = 1;
}

void TSSATScorer::normaliseVector(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float32x4_t *v3;
  uint64_t v4;
  float v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  float v10;
  float v11;
  uint64_t v12;
  float32x4_t *v13;
  uint64_t v14;
  float32x4_t v15;
  uint64_t v16;
  float *v17;

  v2 = *(unsigned int *)(a2 + 16);
  if (!(_DWORD)v2)
    return;
  v3 = *(float32x4_t **)(a2 + 8);
  if ((_DWORD)v2 == 1)
  {
    v4 = 0;
    v5 = 0.0;
  }
  else
  {
    v4 = v2 & 0xFFFFFFFE;
    v6 = &v3->f32[1];
    v5 = 0.0;
    v7 = v4;
    do
    {
      v5 = (float)(v5 + (float)(*(v6 - 1) * *(v6 - 1))) + (float)(*v6 * *v6);
      v6 += 2;
      v7 -= 2;
    }
    while (v7);
    if (v4 == v2)
      goto LABEL_9;
  }
  v8 = v2 - v4;
  v9 = &v3->f32[v4];
  do
  {
    v10 = *v9++;
    v5 = v5 + (float)(v10 * v10);
    --v8;
  }
  while (v8);
LABEL_9:
  if (v5 <= 0.0)
    return;
  v11 = sqrtf((float)v2 / v5);
  if (v2 < 8)
  {
    v12 = 0;
LABEL_15:
    v16 = v2 - v12;
    v17 = &v3->f32[v12];
    do
    {
      *v17 = v11 * *v17;
      ++v17;
      --v16;
    }
    while (v16);
    return;
  }
  v12 = v2 & 0xFFFFFFF8;
  v13 = v3 + 1;
  v14 = v12;
  do
  {
    v15 = vmulq_n_f32(*v13, v11);
    v13[-1] = vmulq_n_f32(v13[-1], v11);
    *v13 = v15;
    v13 += 2;
    v14 -= 8;
  }
  while (v14);
  if (v12 != v2)
    goto LABEL_15;
}

uint64_t TSSATScorer::applyTransform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(a1 + 8) + 72))(*(_QWORD *)(a1 + 8), a2, a3, 0);
}

void TSSATScorer::scoreTransformed(TSSATScorer *this, __n128 a2)
{
  __int32 v3;
  unsigned __int32 v4;

  v3 = 1065353216;
  v4 = 0;
  if (*((_BYTE *)this + 292))
    NSATImpostor::score((uint64_t)this + 16, (uint64_t)this + 240, &v4, &v3, a2);
  NSATSpeaker::score((uint64_t)this + 88, (uint64_t)this + 240, &v4, &v3, a2);
  *((_BYTE *)this + 297) = 1;
}

void TSSATScorer::scoreSpeakerVector(TSSATScorer *this, const float *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v6;
  __n128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  const float *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int32 *v17;
  const float *v18;
  unsigned __int32 v19;
  uint64_t v20;
  const char *v21;
  __int32 v22;
  unsigned __int32 v23;

  *((_BYTE *)this + 297) = 0;
  if (!*((_BYTE *)this + 296))
    Error::chuck((Error *)"TSSATScorer::scorespeakervector() - setModelFile() not called", (const char *)a2);
  v3 = a3;
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1)) != (_DWORD)a3)
  {
    v20 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
    Error::chuck((Error *)"TSSATScorer::scorespeakervector() - speakervector size (%d) does not match scorer transform size (%d)", v21, v3, v20);
  }
  if (!a2)
    Error::chuck((Error *)"TSSATScorer::score() - NULL supervector pointer", v6);
  if (*((_DWORD *)this + 64) != (_DWORD)v3)
  {
    v8 = *((_QWORD *)this + 31);
    if (v8)
      MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
    *((_DWORD *)this + 64) = v3;
    *((_QWORD *)this + 31) = operator new[]();
    LODWORD(v3) = *((_DWORD *)this + 64);
  }
  if ((_DWORD)v3)
  {
    v9 = 0;
    v10 = *((_QWORD *)this + 31);
    if (v3 < 8)
      goto LABEL_14;
    if ((unint64_t)(v10 - (_QWORD)a2) < 0x20)
      goto LABEL_14;
    v9 = v3 & 0xFFFFFFF8;
    v11 = (_OWORD *)(v10 + 16);
    v12 = a2 + 4;
    v13 = v9;
    do
    {
      v7 = *(__n128 *)(v12 - 4);
      v14 = *(_OWORD *)v12;
      *(v11 - 1) = v7;
      *v11 = v14;
      v11 += 2;
      v12 += 8;
      v13 -= 8;
    }
    while (v13);
    if (v9 != v3)
    {
LABEL_14:
      v15 = v3 - v9;
      v16 = v9;
      v17 = (unsigned __int32 *)(v10 + v16 * 4);
      v18 = &a2[v16];
      do
      {
        v19 = *(_DWORD *)v18++;
        v7.n128_u32[0] = v19;
        *v17++ = v19;
        --v15;
      }
      while (v15);
    }
  }
  v22 = 1065353216;
  v23 = 0;
  if (*((_BYTE *)this + 292))
    NSATImpostor::score((uint64_t)this + 16, (uint64_t)this + 240, &v23, &v22, v7);
  NSATSpeaker::score((uint64_t)this + 88, (uint64_t)this + 240, &v23, &v22, v7);
  *((_BYTE *)this + 297) = 1;
}

void TSSATScorer::update(TSSATScorer *this, const char *a2)
{
  NSATSpeaker *v3;
  const char *v4;

  if (!*((_BYTE *)this + 297))
    Error::chuck((Error *)"TSSATScorer::update() - no valid vector prepared", a2);
  *((_BYTE *)this + 297) = 0;
  v3 = (TSSATScorer *)((char *)this + 88);
  NSATSpeaker::insert((_BYTE *)this + 88, (uint64_t)this + 240);
  if (*((_BYTE *)this + 166))
  {
    NSATSpeaker::write(v3, v4);
    *((_BYTE *)this + 166) = 0;
  }
}

void TSSATScorer::deleteVector(TSSATScorer *this, const char *a2)
{
  NSATSpeaker *v3;
  const char *v4;

  if (!*((_BYTE *)this + 296))
    Error::chuck((Error *)"TSSATScorer::deleteVector() - setModelFile() not called", a2);
  v3 = (TSSATScorer *)((char *)this + 88);
  NSATSpeaker::remove((TSSATScorer *)((char *)this + 88), a2);
  if (*((_BYTE *)this + 166))
  {
    NSATSpeaker::write(v3, v4);
    *((_BYTE *)this + 166) = 0;
  }
}

uint64_t TSSATScorer::getSpeakerVector(uint64_t a1, const char *a2, unsigned int *a3)
{
  if (!*(_BYTE *)(a1 + 296))
    Error::chuck((Error *)"TSSATScorer::getSuperVector() - setModelFile() not called", a2);
  return NSATSpeaker::getVector(a1 + 88, (uint64_t)a2, a3);
}

uint64_t TSSATScorer::getSpeakerVectorDimen(TSSATScorer *this, const char *a2)
{
  if (!*((_BYTE *)this + 295))
    Error::chuck((Error *)"TSSATScorer::setModelFile() - init() not called", a2);
  return *((unsigned int *)this + 64);
}

uint64_t TSSATScorer::vectorCount(TSSATScorer *this)
{
  return *((unsigned int *)this + 31);
}

void TSSATScorer::reset(TSSATScorer *this, const char *a2)
{
  NSATSpeaker *v3;
  const char *v4;

  *((_BYTE *)this + 297) = 0;
  v3 = (TSSATScorer *)((char *)this + 88);
  NSATSpeaker::reset((TSSATScorer *)((char *)this + 88), a2);
  if (*((_BYTE *)this + 166))
  {
    NSATSpeaker::write(v3, v4);
    *((_BYTE *)this + 166) = 0;
  }
}

void TSSupervectorScorer::~TSSupervectorScorer(TSSupervectorScorer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F20E8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 7);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 3) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 4);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F20E8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 7);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 3) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 4);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F20E8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 7);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 3) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 4);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
}

void TSSupervectorScorer::TSSupervectorScorer(TSSupervectorScorer *this)
{
  *(_QWORD *)this = &off_24C7F20E8;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = &off_24C7F31A8;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_BYTE *)this + 72) = 0;
}

{
  *(_QWORD *)this = &off_24C7F20E8;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = &off_24C7F31A8;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_BYTE *)this + 72) = 0;
}

uint64_t TSSupervectorScorer::init(TSSupervectorScorer *this, const NString *a2, uint64_t a3)
{
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _OWORD *v19;
  __int128 *v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  _DWORD *v25;
  int *v26;
  int v27;
  uint64_t result;
  const char *v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  _OWORD *v36;
  __int128 *v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  int *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  _BYTE *v50;
  void (**v51)(NDistributionLoader *__hidden);
  uint64_t v52;

  if (*((_BYTE *)this + 72))
    Error::chuck((Error *)"TSSupervectorScorer::init() - init() already called", (const char *)a2);
  v6 = *((_QWORD *)this + 1);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v48 = &off_24C7F32C0;
  v49 = 0;
  v7 = (_BYTE *)operator new[]();
  *v7 = 0;
  v50 = v7;
  v51 = &off_24C7F1FD8;
  v52 = 0;
  v8 = NDistributionLoader::read((NDistributionLoader *)&v51, (uint64_t (***)(NString *__hidden, const unsigned int *))a2, (const NString *)&v48);
  if (v52)
    (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  *((_QWORD *)this + 1) = v8;
  v48 = &off_24C7F32C0;
  if (v50)
  {
    MEMORY[0x212BAC9C0](v50, 0x1000C8077774924);
    v8 = *((_QWORD *)this + 1);
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
  v10 = **((_QWORD **)this + 1);
  if (v9 != 1)
  {
    v46 = (*(uint64_t (**)(void))(v10 + 32))();
    Error::chuck((Error *)"TSSupervectorScorer::init() - Models must expect a single frame, not %d", v47, v46);
  }
  v11 = (unsigned int *)(*(uint64_t (**)(void))(v10 + 24))();
  v12 = *((_DWORD *)this + 10);
  if (v12 != *v11)
  {
    v13 = v11;
    v14 = *((_QWORD *)this + 4);
    *((_DWORD *)this + 10) = *v11;
    v15 = operator new[]();
    *((_QWORD *)this + 4) = v15;
    LODWORD(v16) = *v13;
    if (v12 >= *v13)
      v16 = v16;
    else
      v16 = v12;
    if ((_DWORD)v16)
    {
      if (v16 >= 8 && (unint64_t)(v15 - v14) > 0x1F)
      {
        v18 = v16 & 0xFFFFFFF8;
        v19 = (_OWORD *)(v15 + 16);
        v20 = (__int128 *)(v14 + 16);
        v21 = v18;
        do
        {
          v22 = *v20;
          *(v19 - 1) = *(v20 - 1);
          *v19 = v22;
          v19 += 2;
          v20 += 2;
          v21 -= 8;
        }
        while (v21);
        if (v18 == v16)
          goto LABEL_26;
      }
      else
      {
        v18 = 0;
      }
      v23 = v16 - v18;
      v24 = 4 * v18;
      v25 = (_DWORD *)(v15 + 4 * v18);
      v26 = (int *)(v14 + v24);
      do
      {
        v27 = *v26++;
        *v25++ = v27;
        --v23;
      }
      while (v23);
LABEL_26:
      MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
      goto LABEL_27;
    }
    if (v14)
      goto LABEL_26;
  }
LABEL_27:
  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  v30 = *((_DWORD *)this + 16);
  if (v30 == (_DWORD)result)
    goto LABEL_45;
  v31 = result;
  v32 = *((_QWORD *)this + 7);
  *((_DWORD *)this + 16) = result;
  result = operator new[]();
  *((_QWORD *)this + 7) = result;
  if (v30 >= v31)
    v33 = v31;
  else
    v33 = v30;
  if ((_DWORD)v33)
  {
    if (v33 >= 8 && (unint64_t)(result - v32) > 0x1F)
    {
      v35 = v33 & 0xFFFFFFF8;
      v36 = (_OWORD *)(result + 16);
      v37 = (__int128 *)(v32 + 16);
      v38 = v35;
      do
      {
        v39 = *v37;
        *(v36 - 1) = *(v37 - 1);
        *v36 = v39;
        v36 += 2;
        v37 += 2;
        v38 -= 8;
      }
      while (v38);
      if (v35 == v33)
        goto LABEL_44;
    }
    else
    {
      v35 = 0;
    }
    v40 = v33 - v35;
    v41 = 4 * v35;
    v42 = (_DWORD *)(result + 4 * v35);
    v43 = (int *)(v32 + v41);
    do
    {
      v44 = *v43++;
      *v42++ = v44;
      --v40;
    }
    while (v40);
LABEL_44:
    result = MEMORY[0x212BAC9C0](v32, 0x1000C8052888210);
    goto LABEL_45;
  }
  if (v32)
    goto LABEL_44;
LABEL_45:
  v45 = *((unsigned int *)this + 16);
  if (v45 <= a3)
    Error::chuck((Error *)"TSSupervectorScorer::init() - selected output %d out of range (0-%d)", v29, a3, v45);
  *((_DWORD *)this + 4) = a3;
  *((_BYTE *)this + 72) = 1;
  return result;
}

void sub_20D982200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 8))(a16);
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

float TSSupervectorScorer::score(TSSupervectorScorer *this, const float *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD *v7;
  const float *v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  const float *v14;
  int v15;

  if (!*((_BYTE *)this + 72))
    Error::chuck((Error *)"TSSupervectorScorer::score() - init() not called", (const char *)a2);
  v4 = *((unsigned int *)this + 10);
  if ((_DWORD)v4 != (_DWORD)a3)
    Error::chuck((Error *)"TSSupervectorScorer::score() - supervector size (%d) does not match scorer input size (%d)", (const char *)a2, a3, v4);
  if (!a2)
    Error::chuck((Error *)"TSSupervectorScorer::score() - NULL supervector pointer", 0);
  if ((_DWORD)a3)
  {
    v5 = 0;
    v6 = *((_QWORD *)this + 4);
    if (a3 < 8)
      goto LABEL_10;
    if ((unint64_t)(v6 - (_QWORD)a2) < 0x20)
      goto LABEL_10;
    v5 = a3 & 0xFFFFFFF8;
    v7 = (_OWORD *)(v6 + 16);
    v8 = a2 + 4;
    v9 = v5;
    do
    {
      v10 = *(_OWORD *)v8;
      *(v7 - 1) = *((_OWORD *)v8 - 1);
      *v7 = v10;
      v7 += 2;
      v8 += 8;
      v9 -= 8;
    }
    while (v9);
    if (v5 != a3)
    {
LABEL_10:
      v11 = a3 - v5;
      v12 = v5;
      v13 = (_DWORD *)(v6 + v12 * 4);
      v14 = &a2[v12];
      do
      {
        v15 = *(_DWORD *)v14++;
        *v13++ = v15;
        --v11;
      }
      while (v11);
    }
  }
  (*(void (**)(_QWORD, char *, char *, _QWORD))(**((_QWORD **)this + 1) + 72))(*((_QWORD *)this + 1), (char *)this + 24, (char *)this + 48, 0);
  return *(float *)(*((_QWORD *)this + 7) + 4 * *((unsigned int *)this + 4));
}

void NSATImpostor::~NSATImpostor(NSATImpostor *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F1790;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F1790;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F1790;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
}

void NSATImpostor::NSATImpostor(NSATImpostor *this)
{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F1790;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_BYTE *)this + 64) = 0;
}

{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F1790;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_BYTE *)this + 64) = 0;
}

uint64_t NSATImpostor::load(NSATImpostor *this, const NString *a2)
{
  const char *v4;
  const char *v5;
  BOOL v6;
  const char *v7;
  const char *v8;
  const char *v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  const char *v15;
  unsigned int v16;
  int v17;
  const char *v18;
  BOOL v19;
  __int128 v20;
  uint64_t v21;
  uint64_t result;
  const char *v23;
  uint64_t v24;
  int v25;
  uint64_t (**v26)(NString *__hidden, const unsigned int *);
  unsigned int v27;
  _QWORD *v28;
  uint64_t (**v29)();
  uint64_t v30;
  int v31;
  uint64_t (**v32)(NString *__hidden, const unsigned int *);
  int v33;
  uint64_t v34;
  uint64_t (**v35)();
  uint64_t v36;
  unsigned int v37;

  *((_BYTE *)this + 64) = 0;
  v32 = &off_24C7F32C0;
  v33 = 1;
  v34 = operator new[]();
  *(_WORD *)v34 = 114;
  v35 = (uint64_t (**)())&off_24C7F33E0;
  v36 = 0;
  NFilePtr::open((NFilePtr *)&v35, a2, (const NString *)&v32);
  v32 = &off_24C7F32C0;
  if (v34)
    MEMORY[0x212BAC9C0](v34, 0x1000C8077774924);
  if (!v36)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v4);
  LODWORD(v29) = 16;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)()))(*(_QWORD *)v36 + 64))(&v32, v36, &v29);
  if (v33 != 16
    || (*(_QWORD *)v34 == 0x4F54534F504D4923 ? (v6 = *(_QWORD *)(v34 + 8) == 0xA0A313030762052) : (v6 = 0), !v6))
  {
    Error::chuck((Error *)"NSATImpostor::load() - %s %s", v5, "cannot read cookie from", *((_QWORD *)a2 + 2));
  }
  v29 = &off_24C7F3100;
  v30 = operator new[]();
  v31 = 16;
  if (!v36)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7);
  v25 = 64;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v36 + 64))(&v26, v36, &v25);
  if ((v27 & 3) != 0)
  {
    v26 = &off_24C7F32C0;
    if (v28)
      MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
    Error::chuck((Error *)"NSATImpostor::load() - %s %s", v8, "cannot read header from", *((_QWORD *)a2 + 2));
  }
  v37 = v27 >> 2;
  ((void (*)(uint64_t (***)(), _QWORD *, unsigned int *))v29[3])(&v29, v28, &v37);
  v26 = &off_24C7F32C0;
  if (v28)
    MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
  v10 = *(_DWORD *)(v30 + 4);
  v11 = *(_DWORD *)(v30 + 8);
  v37 = v11;
  if (v10 != 1)
  {
    v15 = "cannot read incompatible version";
    goto LABEL_51;
  }
  if (v11 > 0x989680)
  {
    v15 = "header specifies implausible filesize";
    goto LABEL_51;
  }
  v12 = *(_DWORD *)(v30 + 12);
  v13 = *(_QWORD *)(v30 + 20);
  v14 = v13;
  v15 = "stride is less than width";
  if (v13 < v12 || (v16 = *(_DWORD *)(v30 + 16), HIDWORD(v13) < v16))
LABEL_51:
    Error::chuck((Error *)"NSATImpostor::load() - %s %s", v9, v15, *((_QWORD *)a2 + 2));
  if (v12 != v16)
  {
    v15 = "covariance matrix is not square";
    goto LABEL_51;
  }
  if (*(_DWORD *)(v30 + 28))
  {
    v15 = "only float32 dataformat supported";
    goto LABEL_51;
  }
  if (v11 != 4 * ((_DWORD)v13 + (_DWORD)v13 * HIDWORD(v13)))
  {
    v23 = "unexpected file size";
    goto LABEL_55;
  }
  v24 = *(_QWORD *)(v30 + 20);
  if (!v36)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v9);
  v17 = (*(uint64_t (**)(uint64_t, unsigned int *, char *))(*(_QWORD *)v36 + 72))(v36, &v37, (char *)this + 8);
  if (v17 != v37)
  {
    v23 = "cannot read enough data from file:";
LABEL_55:
    Error::chuck((Error *)"NSATImpostor::load() - %s %s", v9, v23, *((_QWORD *)a2 + 2));
  }
  if (!v36)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v9);
  v25 = 16;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v36 + 64))(&v26, v36, &v25);
  if (v27 != 16 || (*v28 == 0x54534F504D49230ALL ? (v19 = v28[1] == 0xA0A444E4520524FLL) : (v19 = 0), !v19))
    Error::chuck((Error *)"NSATImpostor::load() - %s %s", v18, "cannot read endsig from", *((_QWORD *)a2 + 2));
  if (!v36)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v18);
  (*(void (**)(uint64_t))(*(_QWORD *)v36 + 24))(v36);
  LODWORD(v20) = v12;
  *((_QWORD *)&v20 + 1) = v24;
  DWORD1(v20) = v12;
  *((_OWORD *)this + 2) = v20;
  v21 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 6) = v21;
  *((_QWORD *)this + 7) = v21 + 4 * v14;
  *((_BYTE *)this + 64) = 1;
  v26 = &off_24C7F32C0;
  if (v28)
    MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
  v29 = &off_24C7F3100;
  if (v30)
    MEMORY[0x212BAC9C0](v30, 0x1000C8052888210);
  v32 = &off_24C7F32C0;
  if (v34)
    MEMORY[0x212BAC9C0](v34, 0x1000C8077774924);
  v35 = &off_24C7F17F8;
  result = v36;
  if (v36)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
  return result;
}

void sub_20D982B5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t v23;
  uint64_t v25;

  if (a19)
    MEMORY[0x212BAC9C0](a19, 0x1000C8052888210);
  if (a23)
    MEMORY[0x212BAC9C0](a23, 0x1000C8077774924);
  *(_QWORD *)(v23 - 72) = &off_24C7F17F8;
  v25 = *(_QWORD *)(v23 - 64);
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  _Unwind_Resume(exception_object);
}

_QWORD *NSmartPointer<NBaseFile>::~NSmartPointer(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F17F8;
  v2 = a1[1];
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void NSmartPointer<NBaseFile>::~NSmartPointer(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F17F8;
  v1 = a1[1];
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSmartPointer<NBaseFile>::setPointer(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

void NFilePtr::~NFilePtr(NFilePtr *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F17F8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F17F8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSATImpostor::score(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, __n128 a5)
{
  uint64_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t *v8;
  uint64_t v9;
  float32x4_t *v10;
  float32x4_t *v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  uint64_t result;
  uint64_t v23;
  _DWORD *v24;
  float *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  float32x4_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  uint64_t v34;
  float v35;
  float *v36;
  float *v37;
  float v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  float v42;
  float32x4_t v43;
  float32x4_t v44;
  uint64_t v45;
  float32x4_t *v46;
  uint64_t v47;
  float v48;
  float32x4_t *v49;
  float32x4_t *v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  uint64_t v54;
  uint64_t v55;
  float *v56;
  float *v57;
  float v58;
  float v59;
  float v60;
  _QWORD v61[2];

  v61[1] = *MEMORY[0x24BDAC8D0];
  *a3 = 0;
  *a4 = 0;
  if (!*(_BYTE *)(a1 + 64))
    Error::chuck((Error *)"NSATImpostor::score() - model not loaded", (const char *)a2);
  v5 = *(unsigned int *)(a2 + 16);
  v6 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v5 != (_DWORD)v6)
    Error::chuck((Error *)"NSATImpostor::score() - mismatched vector dimension (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v6);
  if (!(_DWORD)v5)
  {
    a5.n128_u32[0] = 0;
    goto LABEL_12;
  }
  v7 = *(float32x4_t **)(a1 + 48);
  v8 = *(float32x4_t **)(a2 + 8);
  if (v5 < 8)
  {
    v9 = 0;
    a5.n128_u32[0] = 0;
LABEL_10:
    v15 = v5 - v9;
    v16 = v9;
    v17 = &v7->f32[v16];
    v18 = &v8->f32[v16];
    do
    {
      v19 = *v18++;
      v20 = v19;
      v21 = *v17++;
      a5.n128_f32[0] = a5.n128_f32[0] + (float)(v20 * v21);
      --v15;
    }
    while (v15);
    goto LABEL_12;
  }
  v9 = v5 & 0xFFFFFFF8;
  v10 = v7 + 1;
  v11 = v8 + 1;
  a5.n128_u32[0] = 0;
  v12 = v9;
  do
  {
    v13 = vmulq_f32(v11[-1], v10[-1]);
    v14 = vmulq_f32(*v11, *v10);
    a5.n128_f32[0] = (float)((float)((float)((float)((float)((float)((float)(a5.n128_f32[0] + v13.f32[0]) + v13.f32[1])
                                                           + v13.f32[2])
                                                   + v13.f32[3])
                                           + v14.f32[0])
                                   + v14.f32[1])
                           + v14.f32[2])
                   + v14.f32[3];
    v10 += 2;
    v11 += 2;
    v12 -= 8;
  }
  while (v12);
  if (v9 != v5)
    goto LABEL_10;
LABEL_12:
  result = MEMORY[0x24BDAC7A8](a5);
  v29 = (float32x4_t *)((char *)v61 - ((v28 + 15) & 0x7FFFFFFF0));
  v30 = *(unsigned int *)(result + 36);
  if ((_DWORD)v30)
  {
    if (!(_DWORD)v26)
    {
LABEL_35:
      v48 = 0.0;
      goto LABEL_41;
    }
    v31 = *(_QWORD *)(result + 56);
    v32 = (*(_DWORD *)(result + 40) - v26);
    v33 = *(float **)(v23 + 8);
    v34 = 4 * (v26 - 1);
    if (v26 >= 8)
    {
      v39 = 0;
      v40 = v34 + 4 * v32 + 4;
      do
      {
        v41 = 0;
        v42 = 0.0;
        do
        {
          result = (uint64_t)&v33[v41 / 4];
          v43 = vmulq_f32(*(float32x4_t *)(v31 + v41), *(float32x4_t *)&v33[v41 / 4]);
          v44 = vmulq_f32(*(float32x4_t *)(v31 + v41 + 16), *(float32x4_t *)&v33[v41 / 4 + 4]);
          v42 = (float)((float)((float)((float)((float)((float)((float)(v42 + v43.f32[0]) + v43.f32[1]) + v43.f32[2])
                                              + v43.f32[3])
                                      + v44.f32[0])
                              + v44.f32[1])
                      + v44.f32[2])
              + v44.f32[3];
          v41 += 32;
        }
        while (((4 * v26) & 0x3FFFFFFE0) != v41);
        if ((v26 & 0xFFFFFFF8) != v26)
        {
          v45 = v26 & 0xFFFFFFF8;
          do
          {
            result = 4 * v45;
            v42 = v42 + (float)(*(float *)(v31 + 4 * v45) * v33[v45]);
            ++v45;
          }
          while (v26 != v45);
        }
        v29->f32[v39++] = v42;
        v31 += v40;
      }
      while (v39 != v30);
    }
    else
    {
      v35 = *v33;
      v36 = (float *)(v31 + 12);
      v37 = (float *)v29;
      do
      {
        v38 = (float)(*(v36 - 3) * v35) + 0.0;
        if ((_DWORD)v26 != 1)
        {
          v38 = v38 + (float)(*(v36 - 2) * v33[1]);
          if ((_DWORD)v26 != 2)
          {
            v38 = v38 + (float)(*(v36 - 1) * v33[2]);
            if ((_DWORD)v26 != 3)
            {
              v38 = v38 + (float)(*v36 * v33[3]);
              if ((_DWORD)v26 != 4)
              {
                v38 = v38 + (float)(v36[1] * v33[4]);
                if ((_DWORD)v26 != 5)
                {
                  v38 = v38 + (float)(v36[2] * v33[5]);
                  if ((_DWORD)v26 != 6)
                    v38 = v38 + (float)(v36[3] * v33[6]);
                }
              }
            }
          }
        }
        *v37++ = v38;
        v36 = (float *)((char *)v36 + 4 * v32 + v34 + 4);
        --v30;
      }
      while (v30);
    }
  }
  if (!(_DWORD)v26)
    goto LABEL_35;
  v46 = *(float32x4_t **)(v23 + 8);
  if (v26 < 8)
  {
    v47 = 0;
    v48 = 0.0;
LABEL_39:
    v54 = v26 - v47;
    v55 = v47;
    v56 = &v29->f32[v55];
    v57 = &v46->f32[v55];
    do
    {
      v58 = *v57++;
      v59 = v58;
      v60 = *v56++;
      v48 = v48 + (float)(v59 * v60);
      --v54;
    }
    while (v54);
    goto LABEL_41;
  }
  v47 = v26 & 0xFFFFFFF8;
  v49 = v29 + 1;
  v50 = v46 + 1;
  v48 = 0.0;
  v51 = v47;
  do
  {
    v52 = vmulq_f32(v50[-1], v49[-1]);
    v53 = vmulq_f32(*v50, *v49);
    v48 = (float)((float)((float)((float)((float)((float)((float)(v48 + v52.f32[0]) + v52.f32[1]) + v52.f32[2])
                                        + v52.f32[3])
                                + v53.f32[0])
                        + v53.f32[1])
                + v53.f32[2])
        + v53.f32[3];
    v49 += 2;
    v50 += 2;
    v51 -= 8;
  }
  while (v51);
  if (v47 != v26)
    goto LABEL_39;
LABEL_41:
  *v24 = v27;
  *v25 = sqrtf(v48);
  return result;
}

float NSATImpostor::dotproduct(uint64_t a1, uint64_t a2, float32x4_t *a3, unsigned int *a4)
{
  uint64_t v4;
  float32x4_t *v5;
  uint64_t v6;
  float result;
  float32x4_t *v8;
  float32x4_t *v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  float *v16;
  float v17;
  float v18;
  float v19;

  v4 = *a4;
  if (!(_DWORD)v4)
    return 0.0;
  v5 = *(float32x4_t **)(a2 + 8);
  if (v4 <= 7)
  {
    v6 = 0;
    result = 0.0;
LABEL_8:
    v13 = v4 - v6;
    v14 = v6;
    v15 = &a3->f32[v6];
    v16 = &v5->f32[v14];
    do
    {
      v17 = *v16++;
      v18 = v17;
      v19 = *v15++;
      result = result + (float)(v18 * v19);
      --v13;
    }
    while (v13);
    return result;
  }
  v6 = v4 & 0xFFFFFFF8;
  v8 = a3 + 1;
  v9 = v5 + 1;
  result = 0.0;
  v10 = v6;
  do
  {
    v11 = vmulq_f32(v9[-1], v8[-1]);
    v12 = vmulq_f32(*v9, *v8);
    result = (float)((float)((float)((float)((float)((float)((float)(result + v11.f32[0]) + v11.f32[1]) + v11.f32[2])
                                           + v11.f32[3])
                                   + v12.f32[0])
                           + v12.f32[1])
                   + v12.f32[2])
           + v12.f32[3];
    v8 += 2;
    v9 += 2;
    v10 -= 8;
  }
  while (v10);
  if (v6 != v4)
    goto LABEL_8;
  return result;
}

void NSATImpostor::matrixvector(int a1, uint64_t a2, uint64_t a3, float *a4, unsigned int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  float *v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  float v17;
  float32x4_t v18;
  float32x4_t v19;
  uint64_t v20;

  v7 = *a5;
  if ((_DWORD)v7)
  {
    v8 = *a6;
    if ((_DWORD)v8)
    {
      v9 = (*a7 - v8);
      v10 = *(float **)(a3 + 8);
      v11 = 4 * (v8 - 1);
      if (v8 >= 8)
      {
        v14 = 0;
        v15 = v11 + 4 * v9 + 4;
        do
        {
          v16 = 0;
          v17 = 0.0;
          do
          {
            v18 = vmulq_f32(*(float32x4_t *)(a2 + v16), *(float32x4_t *)&v10[v16 / 4]);
            v19 = vmulq_f32(*(float32x4_t *)(a2 + v16 + 16), *(float32x4_t *)&v10[v16 / 4 + 4]);
            v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v18.f32[0]) + v18.f32[1]) + v18.f32[2])
                                                + v18.f32[3])
                                        + v19.f32[0])
                                + v19.f32[1])
                        + v19.f32[2])
                + v19.f32[3];
            v16 += 32;
          }
          while (((4 * v8) & 0x3FFFFFFE0) != v16);
          if ((v8 & 0xFFFFFFF8) != v8)
          {
            v20 = v8 & 0xFFFFFFF8;
            do
            {
              v17 = v17 + (float)(*(float *)(a2 + 4 * v20) * v10[v20]);
              ++v20;
            }
            while (v8 != v20);
          }
          a4[v14++] = v17;
          a2 += v15;
        }
        while (v14 != v7);
      }
      else
      {
        v12 = (float *)(a2 + 12);
        do
        {
          v13 = (float)(*(v12 - 3) * *v10) + 0.0;
          if ((_DWORD)v8 != 1)
          {
            v13 = v13 + (float)(*(v12 - 2) * v10[1]);
            if ((_DWORD)v8 != 2)
            {
              v13 = v13 + (float)(*(v12 - 1) * v10[2]);
              if ((_DWORD)v8 != 3)
              {
                v13 = v13 + (float)(*v12 * v10[3]);
                if ((_DWORD)v8 != 4)
                {
                  v13 = v13 + (float)(v12[1] * v10[4]);
                  if ((_DWORD)v8 != 5)
                  {
                    v13 = v13 + (float)(v12[2] * v10[5]);
                    if ((_DWORD)v8 != 6)
                      v13 = v13 + (float)(v12[3] * v10[6]);
                  }
                }
              }
            }
          }
          *a4++ = v13;
          v12 = (float *)((char *)v12 + 4 * v9 + v11 + 4);
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      bzero(a4, 4 * v7);
    }
  }
}

uint64_t NSATImpostor::dimen(NSATImpostor *this)
{
  return (uint64_t)this + 32;
}

void NSATSpeaker::~NSATSpeaker(NSATSpeaker *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F1670;
  *((_QWORD *)this + 13) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *((_QWORD *)this + 10) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 12);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 3);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F1670;
  *((_QWORD *)this + 13) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *((_QWORD *)this + 10) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 12);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 3);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F1670;
  *((_QWORD *)this + 13) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *((_QWORD *)this + 10) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 12);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 3);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
}

void NSATSpeaker::NSATSpeaker(NSATSpeaker *this)
{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;

  *(_QWORD *)this = &off_24C7F1670;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *v2 = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = v2;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 1112014848;
  *((_DWORD *)this + 18) = 1;
  *(_WORD *)((char *)this + 77) = 0;
  *((_QWORD *)this + 10) = &off_24C7F32C0;
  *((_DWORD *)this + 22) = 0;
  v3 = (_BYTE *)operator new[]();
  *v3 = 0;
  *((_QWORD *)this + 12) = v3;
  *((_QWORD *)this + 13) = &off_24C7F32C0;
  *((_DWORD *)this + 28) = 0;
  v4 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 15) = v4;
  *v4 = 0;
}

{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;

  *(_QWORD *)this = &off_24C7F1670;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *v2 = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = v2;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 1112014848;
  *((_DWORD *)this + 18) = 1;
  *(_WORD *)((char *)this + 77) = 0;
  *((_QWORD *)this + 10) = &off_24C7F32C0;
  *((_DWORD *)this + 22) = 0;
  v3 = (_BYTE *)operator new[]();
  *v3 = 0;
  *((_QWORD *)this + 12) = v3;
  *((_QWORD *)this + 13) = &off_24C7F32C0;
  *((_DWORD *)this + 28) = 0;
  v4 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 15) = v4;
  *v4 = 0;
}

void sub_20D983618(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v1[10] = v2;
  v4 = v1[12];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v1[1] = v2;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D983734(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v1[10] = v2;
  v4 = v1[12];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v1[1] = v2;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NSATSpeaker::configure(NSATSpeaker *this, const unsigned int *a2, const unsigned int *a3, const BOOL *a4, const BOOL *a5, const BOOL *a6, float *a7, const unsigned int *a8, const NString *a9, const NString *a10)
{
  char *v18;
  uint64_t result;
  float v20;
  int v21;
  BOOL v22;
  int v23;
  int v24;
  int *v25;
  int v26;
  int v27;
  uint64_t (**v29)(NString *__hidden, const unsigned int *);
  int v30;
  char *v31;
  uint64_t v32;

  v18 = (char *)this + 80;
  if ((NSATSpeaker *)((char *)this + 80) != a9)
    (*(void (**)(char *, _QWORD, char *))(*(_QWORD *)v18 + 64))((char *)this + 80, *((_QWORD *)a9 + 2), (char *)a9 + 8);
  if (!*((_DWORD *)a10 + 2))
  {
    v29 = &off_24C7F32C0;
    v30 = 4;
    v31 = (char *)operator new[]();
    strcpy(v31, ".tmp");
    NString::operator+((uint64_t)v18, (uint64_t)&v29, (uint64_t)&v32);
  }
  result = (uint64_t)this + 104;
  if ((NSATSpeaker *)((char *)this + 104) != a10)
    result = (*(uint64_t (**)(uint64_t, _QWORD, char *))(*(_QWORD *)result + 64))(result, *((_QWORD *)a10 + 2), (char *)a10 + 8);
  *((_BYTE *)this + 73) = *a5;
  v20 = *a7;
  *((float *)this + 16) = *a7;
  *((_BYTE *)this + 74) = *a6;
  v21 = 0;
  if (v20 < 0.0 || (v21 = 1120403456, v20 > 100.0))
    *((_DWORD *)this + 16) = v21;
  v22 = 0;
  *((_DWORD *)this + 17) = *a8;
  v23 = *a2;
  *((_DWORD *)this + 8) = *a2;
  *((_DWORD *)this + 9) = 0;
  v24 = *a3;
  *((_DWORD *)this + 10) = *a3;
  *((_DWORD *)this + 11) = (v23 + 3) & 0xFFFFFFFC;
  *((_DWORD *)this + 12) = (v24 + 3) & 0xFFFFFFFC;
  *((_BYTE *)this + 72) = *a4;
  *((_BYTE *)this + 75) = 1;
  *(_WORD *)((char *)this + 77) = 256;
  if (*((_DWORD *)this + 22) >= 7u)
  {
    v25 = (int *)*((_QWORD *)this + 12);
    v26 = *v25;
    v27 = *(int *)((char *)v25 + 3);
    v22 = v26 == 1684957549 && v27 == 980968804;
  }
  *((_BYTE *)this + 76) = v22;
  return result;
}

void sub_20D983A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;

  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NSATSpeaker::loadOrInit(NSATSpeaker *this, const char *a2, uint64_t a3, unsigned int *a4)
{
  FILE *v5;
  const char *v6;

  if (!*((_BYTE *)this + 75))
    Error::chuck((Error *)"NSATSpeaker::loadOrInit() - not configured", a2);
  if (*((_BYTE *)this + 76))
  {
    NSATSpeaker::useModelFromMemory(this, (uint64_t)a2, a3, a4);
  }
  else
  {
    v5 = fopen(*((const char **)this + 12), "r");
    if (v5)
    {
      fclose(v5);
      NSATSpeaker::read(this);
    }
    else
    {
      NSATSpeaker::reset(this, v6);
    }
  }
}

uint64_t NSATSpeaker::useModelFromMemory(NSATSpeaker *this, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *((_BYTE *)this + 77) = 0;
  LODWORD(v11) = 0;
  v10 = 0;
  result = NMemoryFile::getMemoryBlockParams((NSATSpeaker *)((char *)this + 80), (const NString *)&v10, (const void **)&v11, a4);
  if ((result & 1) == 0)
    Error::chuck((Error *)"NSATSpeaker::useModelFromMemory() - %s does not define a memory block", v6, *((_QWORD *)this + 12));
  v7 = *((unsigned int *)this + 8);
  v8 = (v11 / v7) >> 2;
  if (v11 != 4 * (v8 * v7))
    Error::chuck((Error *)"NSATSpeaker::useModelFromMemory() - Speaker vector block size (%d) not a multiple of dimen (%d*4)", v6, v11, v7);
  v9 = *((unsigned int *)this + 10);
  if (v8 > v9)
    Error::chuck((Error *)"NSATSpeaker::useModelFromMemory() - Number of speaker vectors (%d) exceeds maximum (%d)", v6, v8, v9);
  *((_DWORD *)this + 9) = v8;
  *((_DWORD *)this + 11) = v7;
  *((_DWORD *)this + 12) = v8;
  *((_QWORD *)this + 7) = v10;
  *(_WORD *)((char *)this + 77) = 1;
  return result;
}

void NSATSpeaker::read(NSATSpeaker *this)
{
  const NString *v2;
  const char *v3;
  uint64_t v4;
  BOOL v5;
  const char *v6;
  _QWORD *v7;
  const char *v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  const char *v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  const char *v18;
  _QWORD *v19;
  BOOL v20;
  const char *v21;
  unsigned int v22;
  _BYTE v23[8];
  unsigned int v24;
  _QWORD *v25;
  unsigned int v26[2];
  _DWORD *v27;
  int v28;
  uint64_t (**v29)(NString *__hidden, const unsigned int *);
  int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  _QWORD v34[4];
  _QWORD v35[75];

  v35[74] = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 77) = 0;
  v2 = (NSATSpeaker *)((char *)this + 80);
  v29 = &off_24C7F32C0;
  v30 = 1;
  v31 = operator new[]();
  *(_WORD *)v31 = 114;
  NFile::NFile((NFile *)&v33, v2, (const NString *)&v29);
  v29 = &off_24C7F32C0;
  if (v31)
    MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
  v26[0] = 16;
  NFile::read((NFile *)&v33, v26, (uint64_t)&v29);
  if (v30 != 16
    || ((v4 = v31, *(_QWORD *)v31 == 0x544152454B505323)
      ? (v5 = *(_QWORD *)(v31 + 8) == 0xA0A0A3130307620)
      : (v5 = 0),
        !v5))
  {
    Error::chuck((Error *)"NSATSpeaker::read() - %s %s", v3, "cannot read cookie from", *((_QWORD *)this + 12));
  }
  *(_QWORD *)v26 = &off_24C7F3100;
  v27 = (_DWORD *)operator new[]();
  v28 = 16;
  v22 = 64;
  NFile::read((NFile *)&v33, &v22, (uint64_t)v23);
  if ((v24 & 3) != 0)
  {
    if (v25)
      MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
    Error::chuck((Error *)"NSATSpeaker::read() - %s %s", v6, "cannot read header from", *((_QWORD *)this + 12));
  }
  v32 = v24 >> 2;
  v7 = v25;
  (*(void (**)(unsigned int *, _QWORD *, unsigned int *))(*(_QWORD *)v26 + 24))(v26, v25, &v32);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  v9 = v27[1];
  v10 = v27[2];
  v22 = v10;
  if (v9 != 1)
  {
    v13 = "cannot read incompatible version";
    goto LABEL_47;
  }
  if (v10 > 0x989680)
  {
    v13 = "header specifies implausible filesize";
    goto LABEL_47;
  }
  v11 = v27[3];
  v12 = v27[6];
  v13 = "stride is less than width";
  if (v12 < v11 || (v14 = v27[4], v15 = v27[7], v15 < v14))
LABEL_47:
    Error::chuck((Error *)"NSATSpeaker::read() - %s %s", v8, v13, *((_QWORD *)this + 12));
  if (v27[8])
  {
    v13 = "only float32 dataformat supported";
    goto LABEL_47;
  }
  if (v10 != 4 * v12 * v15)
  {
    v21 = "unexpected file size";
    goto LABEL_52;
  }
  v16 = v27[5];
  if (*((_BYTE *)this + 72))
  {
    if (*((_DWORD *)this + 8) == v11)
    {
      if (*((_DWORD *)this + 10) == v16)
        goto LABEL_21;
      v21 = "size does not match configuration";
    }
    else
    {
      v21 = "dimensionality does not match configuration";
    }
LABEL_52:
    Error::chuck((Error *)"NSATSpeaker::read() - %s %s", v8, v21, *((_QWORD *)this + 12));
  }
LABEL_21:
  v17 = NFile::read((NFile *)&v33, &v22, (NSATSpeaker *)((char *)this + 8));
  if (v17 != v22)
  {
    v21 = "cannot read enough data from file:";
    goto LABEL_52;
  }
  v32 = 16;
  NFile::read((NFile *)&v33, &v32, (uint64_t)v23);
  if (v24 != 16
    || ((v19 = v25, *v25 == 0x4152454B5053230ALL) ? (v20 = v25[1] == 0xA0A0A444E452054) : (v20 = 0), !v20))
  {
    Error::chuck((Error *)"NSATSpeaker::read() - %s %s", v18, "cannot read endsig from", *((_QWORD *)this + 12));
  }
  if ((*(unsigned int (**)(uint64_t *))(v33 + 32))(&v33))
  {
    if (!std::filebuf::close())
      std::ios_base::clear((std::ios_base *)((char *)v35 + *(_QWORD *)(v35[0] - 24)), *(_DWORD *)((char *)&v35[4] + *(_QWORD *)(v35[0] - 24)) | 4);
    v32 = 0;
    (*(void (**)(_QWORD *, const char *, unsigned int *))(v34[0] + 64))(v34, "", &v32);
  }
  *((_DWORD *)this + 8) = v11;
  *((_DWORD *)this + 9) = v14;
  *((_DWORD *)this + 10) = v16;
  *((_DWORD *)this + 11) = v12;
  *((_DWORD *)this + 12) = v15;
  *((_QWORD *)this + 7) = *((_QWORD *)this + 3);
  *((_BYTE *)this + 78) = 0;
  *((_WORD *)this + 38) = 256;
  if (v19)
    MEMORY[0x212BAC9C0](v19, 0x1000C8077774924);
  *(_QWORD *)v26 = &off_24C7F3100;
  if (v27)
    MEMORY[0x212BAC9C0](v27, 0x1000C8052888210);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NFile::~NFile((NFile *)&v33);
}

void sub_20D984064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  if (a10)
    MEMORY[0x212BAC9C0](a10, 0x1000C8052888210);
  if (v15)
    MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  NFile::~NFile((NFile *)va);
  _Unwind_Resume(a1);
}

uint64_t NSATSpeaker::reset(NSATSpeaker *this, const char *a2)
{
  int v3;
  size_t v4;
  void *v5;
  uint64_t result;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  void *v9;

  if (!*((_BYTE *)this + 75))
    Error::chuck((Error *)"NSATSpeaker::reset() - not configured", a2);
  if (*((_BYTE *)this + 76))
    Error::chuck((Error *)"NSATSpeaker::reset() - model readonly", a2);
  *((_DWORD *)this + 9) = 0;
  v3 = *((_DWORD *)this + 11) * *((_DWORD *)this + 12);
  v4 = (4 * v3);
  v7 = &off_24C7F32C0;
  v8 = 4 * v3;
  v5 = (void *)operator new[]();
  v9 = v5;
  bzero(v5, v4);
  *((_BYTE *)v5 + v4) = 0;
  if ((uint64_t (***)(NString *__hidden, const unsigned int *))((char *)this + 8) == &v7)
  {
    v7 = &off_24C7F32C0;
  }
  else
  {
    result = (*(uint64_t (**)(char *, void *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, v5, &v8);
    v5 = v9;
    v7 = &off_24C7F32C0;
    if (!v9)
      goto LABEL_8;
  }
  result = MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
LABEL_8:
  *((_QWORD *)this + 7) = *((_QWORD *)this + 3);
  *(_WORD *)((char *)this + 77) = 257;
  return result;
}

void sub_20D98424C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

float NSATSpeaker::score(uint64_t a1, uint64_t a2, unsigned __int32 *a3, __int32 *a4, __n128 a5)
{
  uint64_t v7;
  uint64_t v9;
  const float *v10;
  NSATSpeaker *v11;
  const char *v12;
  __n128 v13;
  int32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t *v19;
  uint64_t v20;
  float32x4_t v21;
  uint64_t v22;
  float *v23;
  const BOOL *v24;
  float v25;
  uint64_t v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  float v31;
  _QWORD v33[2];

  v33[1] = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 77))
    Error::chuck((Error *)"NSATSpeaker::score() - model not loaded", (const char *)a2);
  v7 = *(unsigned int *)(a1 + 32);
  if (*(_DWORD *)(a2 + 16) != (_DWORD)v7)
    Error::chuck((Error *)"NSATSpeaker::score() - vector wrong size (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v7);
  MEMORY[0x24BDAC7A8](a5);
  v10 = (const float *)((char *)v33 - ((v9 + 15) & 0x7FFFFFFF0));
  v11 = (NSATSpeaker *)cblas_sgemv_NEWLAPACK_ILP64();
  v15 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v15)
  {
    v13.n128_u32[0] = *a3;
    v14.i32[0] = *a4;
    if (v15 <= 7)
    {
      v16 = 0;
LABEL_9:
      v22 = v15 - v16;
      v23 = (float *)&v10[v16];
      do
      {
        *v23 = (float)(*v23 - v13.n128_f32[0]) / *(float *)v14.i32;
        ++v23;
        --v22;
      }
      while (v22);
      goto LABEL_11;
    }
    v16 = v15 & 0xFFFFFFF8;
    v17 = (float32x4_t)vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 0);
    v18 = (float32x4_t)vdupq_lane_s32(v14, 0);
    v19 = (float32x4_t *)(v10 + 4);
    v20 = v16;
    do
    {
      v21 = vdivq_f32(vsubq_f32(*v19, v17), v18);
      v19[-1] = vdivq_f32(vsubq_f32(v19[-1], v17), v18);
      *v19 = v21;
      v19 += 2;
      v20 -= 8;
    }
    while (v20);
    if (v16 != v15)
      goto LABEL_9;
  }
LABEL_11:
  v24 = (const BOOL *)(a1 + 73);
  if (*(_DWORD *)(a1 + 68))
    return NSATSpeaker::findTopNAverage(v11, v10, (const unsigned int *)(a1 + 36), (const unsigned int *)(a1 + 68), v24, (const float *)(a1 + 64), v13);
  if (*v24)
    return NSATSpeaker::findPercentile(v11, v10, (const unsigned int *)(a1 + 36), (const float *)(a1 + 64), v13);
  if (!(_DWORD)v15)
  {
    v25 = 0.0;
    goto LABEL_25;
  }
  if ((_DWORD)v15 == 1)
  {
    v26 = 0;
    v13.n128_u32[0] = 0;
  }
  else
  {
    v26 = v15 & 0xFFFFFFFE;
    v27 = (float *)(v10 + 1);
    v13.n128_u32[0] = 0;
    v28 = v26;
    do
    {
      v13.n128_f32[0] = (float)(v13.n128_f32[0] + *(v27 - 1)) + *v27;
      v27 += 2;
      v28 -= 2;
    }
    while (v28);
    if (v26 == v15)
      goto LABEL_24;
  }
  v29 = v15 - v26;
  v30 = (float *)&v10[v26];
  do
  {
    v31 = *v30++;
    v13.n128_f32[0] = v13.n128_f32[0] + v31;
    --v29;
  }
  while (v29);
LABEL_24:
  v25 = v13.n128_f32[0] / (float)v15;
LABEL_25:
  if (*(_BYTE *)(a1 + 74))
    return v25 * NSATSpeaker::calcModelNormScale((NSATSpeaker *)a1, v12, v13);
  return v25;
}

float NSATSpeaker::findTopNAverage(NSATSpeaker *this, const float *a2, const unsigned int *a3, const unsigned int *a4, const BOOL *a5, const float *a6, __n128 a7)
{
  uint64_t v7;
  NSATSpeaker *v10;
  const void *v11;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int32 *v15;
  unsigned int *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  char v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  float v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  float v30;
  _BYTE v31[4];
  unsigned int v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (*a3 >= *a4)
    v7 = *a4;
  else
    v7 = *a3;
  v32 = v7;
  if (!(_DWORD)v7)
    return 0.0;
  v10 = (NSATSpeaker *)MEMORY[0x24BDAC7A8](a7);
  v14 = (v13 + 15) & 0x7FFFFFFF0;
  v15 = (unsigned __int32 *)&v31[-v14];
  v17 = *v16;
  if ((_DWORD)v17)
  {
    v10 = (NSATSpeaker *)memcpy(&v31[-v14], v11, 4 * v17);
    v18 = v17 - 1;
    if ((_DWORD)v17 == 1)
      goto LABEL_7;
  }
  else
  {
    v18 = -1;
  }
  do
  {
    v21 = 0;
    v12.n128_u32[0] = *v15;
    v22 = v18;
    v23 = v15 + 1;
    do
    {
      if (v12.n128_f32[0] > *(float *)v23)
      {
        *(v23 - 1) = *v23;
        *v23 = v12.n128_u32[0];
        v21 = 1;
      }
      else
      {
        v12.n128_u32[0] = *v23;
      }
      ++v23;
      --v22;
    }
    while (v22);
  }
  while ((v21 & 1) != 0);
LABEL_7:
  v19 = (v17 - v7);
  if (*a5)
    return NSATSpeaker::findPercentile(v10, (const float *)&v15[v19], &v32, a6, v12);
  if (v7 >= 2)
  {
    v24 = v7 & 0xFFFFFFFE;
    v26 = (float *)&v15[v19 + 1];
    v25 = 0.0;
    v27 = v24;
    do
    {
      v25 = (float)(v25 + *(v26 - 1)) + *v26;
      v26 += 2;
      v27 -= 2;
    }
    while (v27);
    if (v24 == v7)
      return v25 / (float)v7;
  }
  else
  {
    v24 = 0;
    v25 = 0.0;
  }
  v28 = v7 - v24;
  v29 = (float *)&v15[v24 + v19];
  do
  {
    v30 = *v29++;
    v25 = v25 + v30;
    --v28;
  }
  while (v28);
  return v25 / (float)v7;
}

float NSATSpeaker::findPercentile(NSATSpeaker *this, const float *a2, const unsigned int *a3, const float *a4, __n128 a5)
{
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  unsigned int *v10;
  uint64_t v11;
  unsigned int v12;
  char v14;
  float v15;
  uint64_t v16;
  _DWORD *v17;
  float v18;
  unsigned int v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x24BDAC8D0];
  if (!*a3)
    return 0.0;
  MEMORY[0x24BDAC7A8](a5);
  v8 = (v7 + 15) & 0x7FFFFFFF0;
  v9 = (float *)((char *)v20 - v8);
  v11 = *v10;
  if (!(_DWORD)v11)
  {
    v12 = -1;
    do
    {
LABEL_9:
      v14 = 0;
      v15 = *v9;
      v16 = v12;
      v17 = v9 + 1;
      do
      {
        if (v15 > *(float *)v17)
        {
          *(v17 - 1) = *v17;
          *(float *)v17 = v15;
          v14 = 1;
        }
        else
        {
          v15 = *(float *)v17;
        }
        ++v17;
        --v16;
      }
      while (v16);
    }
    while ((v14 & 1) != 0);
    v12 = v11 - 1;
    goto LABEL_15;
  }
  memcpy((char *)v20 - v8, v6, 4 * v11);
  v12 = v11 - 1;
  if ((_DWORD)v11 != 1)
    goto LABEL_9;
LABEL_15:
  v18 = *a4 * 0.01 * (float)v12;
  v19 = v18 + 1;
  if (v19 >= v11)
    return v9[v12];
  else
    return (float)((float)(v18 - (float)v18) * v9[v19])
         + (1.0 - (float)(v18 - (float)v18)) * v9[v18];
}

float NSATSpeaker::calcModelNormScale(NSATSpeaker *this, const char *a2, __n128 a3)
{
  uint64_t v4;
  float *v5;
  __n128 v6;
  uint64_t v7;
  const float *v8;
  vDSP_Length v9;
  float v10;
  float __A;
  float __C;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 75))
    Error::chuck((Error *)"NSATSpeaker::reset() - not configured", a2);
  if (!*((_DWORD *)this + 9))
    return 0.0;
  __C = 0.0;
  MEMORY[0x24BDAC7A8](a3);
  v5 = (float *)((char *)&__A - ((v4 + 15) & 0x7FFFFFFF0));
  MEMORY[0x24BDAC7A8](v6);
  v8 = (float *)((char *)&__A - ((v7 + 15) & 0x7FFFFFFF0));
  v9 = *((unsigned int *)this + 9);
  __A = 1.0 / (float)v9;
  vDSP_vfill(&__A, v5, 1, v9);
  v10 = 0.0;
  cblas_sgemv_NEWLAPACK_ILP64();
  vDSP_svesq(v8, 1, &__C, *((unsigned int *)this + 8));
  if (__C > 0.0)
    return sqrtf((float)*((unsigned int *)this + 8) / __C);
  return v10;
}

float NSATSpeaker::findMean(NSATSpeaker *this, const float *a2, const unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  float v11;

  v3 = *a3;
  if (!(_DWORD)v3)
    return 0.0;
  if ((_DWORD)v3 == 1)
  {
    v4 = 0;
    v5 = 0.0;
  }
  else
  {
    v4 = v3 & 0xFFFFFFFE;
    v7 = (float *)(a2 + 1);
    v5 = 0.0;
    v8 = v4;
    do
    {
      v5 = (float)(v5 + *(v7 - 1)) + *v7;
      v7 += 2;
      v8 -= 2;
    }
    while (v8);
    if (v4 == v3)
      return v5 / (float)v3;
  }
  v9 = v3 - v4;
  v10 = (float *)&a2[v4];
  do
  {
    v11 = *v10++;
    v5 = v5 + v11;
    --v9;
  }
  while (v9);
  return v5 / (float)v3;
}

uint64_t NSATSpeaker::numInserted(NSATSpeaker *this)
{
  return (uint64_t)this + 36;
}

_BYTE *NSATSpeaker::insert(_BYTE *result, uint64_t a2)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;

  if (!result[77])
    Error::chuck((Error *)"NSATSpeaker::insert() - model not initialized", (const char *)a2);
  v2 = result;
  if (result[76])
    Error::chuck((Error *)"NSATSpeaker::insert() - model readonly", (const char *)a2);
  v3 = *(unsigned int *)(a2 + 16);
  v4 = *((unsigned int *)result + 8);
  if ((_DWORD)v3 != (_DWORD)v4)
    Error::chuck((Error *)"NSATSpeaker::insert() - vector wrong size (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v4);
  v5 = *((_DWORD *)result + 9);
  if (v5 < *((_DWORD *)result + 10))
  {
    if (!*((_DWORD *)result + 4))
      Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, 0, 0xFFFFFFFFLL);
    result = memcpy((void *)(*((_QWORD *)result + 3) + 4 * v5 * *((_DWORD *)result + 11)), *(const void **)(a2 + 8), 4 * v3);
    ++*((_DWORD *)v2 + 9);
    v2[78] = 1;
  }
  return result;
}

void *NSATSpeaker::remove(NSATSpeaker *this, const char *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  void *result;

  if (!*((_BYTE *)this + 77))
    Error::chuck((Error *)"NSATSpeaker::deleteVector() - model not initialized", a2);
  if (*((_BYTE *)this + 76))
    Error::chuck((Error *)"NSATSpeaker::deleteVector() - model readonly", a2);
  v3 = *(_DWORD *)a2;
  v4 = *((unsigned int *)this + 9);
  if (*(_DWORD *)a2 >= v4)
    Error::chuck((Error *)"NSATSpeaker::deleteVector() - index out of range (%u >= %u)", a2, *(unsigned int *)a2, v4);
  if (!*((_DWORD *)this + 4))
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, 0, 0xFFFFFFFFLL);
  v5 = *((unsigned int *)this + 11);
  v6 = (char *)(*((_QWORD *)this + 3) + 4 * (v3 * v5));
  result = memmove(v6, &v6[4 * v5], 4 * ((v4 + ~v3) * v5));
  --*((_DWORD *)this + 9);
  *((_BYTE *)this + 78) = 1;
  return result;
}

uint64_t NSATSpeaker::getVector(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v5;
  uint64_t v7;
  int v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;

  if (!*(_BYTE *)(a1 + 77))
    Error::chuck((Error *)"NSATSpeaker::getVector() - model not initialized", (const char *)a2);
  if (*(_BYTE *)(a1 + 76))
    Error::chuck((Error *)"NSATSpeaker::getVector() - model readonly", (const char *)a2);
  v5 = *(unsigned int *)(a1 + 36);
  if (*a3 >= v5)
    Error::chuck((Error *)"NSATSpeaker::getVector() - index out of range (%u >= %u)", (const char *)a2, *a3, v5);
  v7 = operator new[]();
  v8 = *(_DWORD *)(a2 + 16);
  MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  if (!v8)
    Error::chuck((Error *)"NSATSpeaker::getVector() - a_vector is NULL", v9);
  v10 = a1 + 32;
  v11 = *(unsigned int *)(a1 + 32);
  if (*(_DWORD *)(a2 + 16) != (_DWORD)v11)
    Error::chuck((Error *)"NSATSpeaker::getVector() - a_vector size is incorrect (%u vs %u)", v9, v10, *(unsigned int *)(a2 + 16), v11);
  if (!*(_DWORD *)(a1 + 16))
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v10, 0, 0xFFFFFFFFLL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(a1 + 24) + 4 * *a3 * *(_DWORD *)(a1 + 44), v10);
}

void NSATSpeaker::write(NSATSpeaker *this, const char *a2)
{
  char *v3;
  const char *v4;
  int v5;
  int v6;
  char *v7;
  const char *v8;
  const char *v9;
  char *v10;
  const char *v11;
  std::error_code *v12;
  uint64_t v13;
  const char *v14;
  int v15;
  char *v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t (**v22)(NString *__hidden, const unsigned int *);
  int v23;
  _WORD *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];
  _QWORD v29[73];
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 76))
    Error::chuck((Error *)"NSATSpeaker::write() - model readonly", a2);
  if (!*((_BYTE *)this + 77))
    Error::chuck((Error *)"NSATSpeaker::write() - model not initialized", a2);
  v22 = &off_24C7F32C0;
  v23 = 1;
  v24 = (_WORD *)operator new[]();
  *v24 = 119;
  NFile::NFile((NFile *)&v26, (NSATSpeaker *)((char *)this + 104), (const NString *)&v22);
  v22 = &off_24C7F32C0;
  if (v24)
    MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  v3 = (char *)operator new[]();
  strcpy(v3, "#SPKERAT v001\n\n\n");
  if (!(*(unsigned int (**)(uint64_t *))(v26 + 32))(&v26))
  {
    v16 = "NFile::write() cannot write, file %s is not open";
    goto LABEL_27;
  }
  if (!v30)
  {
    v16 = "NFile::write() cannot write, file %s opened in read mode";
LABEL_27:
    Error::chuck((Error *)v16, v4, v28[0]);
  }
  std::ostream::write();
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  v5 = *((_DWORD *)this + 4);
  v21 = *((_OWORD *)this + 2);
  v6 = *((_DWORD *)this + 12);
  v22 = &off_24C7F32C0;
  v23 = 0;
  v24 = (_WORD *)operator new[]();
  *(_BYTE *)v24 = 0;
  v7 = (char *)operator new[]();
  *(_QWORD *)v7 = 0x100000001;
  *((_DWORD *)v7 + 2) = v5;
  *(_OWORD *)(v7 + 12) = v21;
  *((_DWORD *)v7 + 7) = v6;
  *((_OWORD *)v7 + 2) = 0u;
  *((_OWORD *)v7 + 3) = 0u;
  v25 = 64;
  ((void (*)(NString *, const void *, const unsigned int *))v22[9])((NString *)&v22, v7, &v25);
  if (!(*(unsigned int (**)(uint64_t *))(v26 + 32))(&v26))
  {
    v17 = "NFile::write() cannot write, file %s is not open";
    goto LABEL_30;
  }
  if (!v30)
  {
    v17 = "NFile::write() cannot write, file %s opened in read mode";
LABEL_30:
    Error::chuck((Error *)v17, v8, v28[0]);
  }
  std::ostream::write();
  MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  v22 = &off_24C7F32C0;
  if (v24)
    MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  if (((*(uint64_t (**)(uint64_t *))(v26 + 32))(&v26) & 1) == 0)
  {
    v18 = v28;
    v19 = "NFile::write() cannot write, file %s is not open";
LABEL_37:
    v13 = *v18;
    goto LABEL_39;
  }
  if (!v30)
  {
    v18 = v28;
    v19 = "NFile::write() cannot write, file %s opened in read mode";
    goto LABEL_37;
  }
  std::ostream::write();
  v10 = (char *)operator new[]();
  strcpy(v10, "\n#SPKERAT END\n\n\n");
  if (!(*(unsigned int (**)(uint64_t *))(v26 + 32))(&v26))
  {
    v20 = "NFile::write() cannot write, file %s is not open";
    goto LABEL_35;
  }
  if (!v30)
  {
    v20 = "NFile::write() cannot write, file %s opened in read mode";
LABEL_35:
    Error::chuck((Error *)v20, v11, v28[0]);
  }
  std::ostream::write();
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  if (*(_DWORD *)((char *)&v29[4] + *(_QWORD *)(v29[0] - 24)))
  {
    v18 = (uint64_t *)((char *)this + 120);
    v19 = "NSATSpeaker::write() - write error for %s";
    goto LABEL_37;
  }
  if ((*(unsigned int (**)(uint64_t *))(v26 + 32))(&v26))
  {
    if (!std::filebuf::close())
      std::ios_base::clear((std::ios_base *)((char *)v29 + *(_QWORD *)(v29[0] - 24)), *(_DWORD *)((char *)&v29[4] + *(_QWORD *)(v29[0] - 24)) | 4);
    LODWORD(v22) = 0;
    (*(void (**)(uint64_t *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(v27 + 64))(&v27, "", &v22);
  }
  v13 = *((_QWORD *)this + 15);
  if (*(_DWORD *)((char *)&v29[4] + *(_QWORD *)(v29[0] - 24)))
  {
    v19 = "NSATSpeaker::write() - write (on close) error for %s";
LABEL_39:
    Error::chuck((Error *)v19, v9, v13);
  }
  rename(*((const std::__fs::filesystem::path **)this + 15), *((const std::__fs::filesystem::path **)this + 12), v12);
  if (v15)
    Error::chuck((Error *)"NSATSpeaker::write() - error renaming %s to %s", v14, *((_QWORD *)this + 15), *((_QWORD *)this + 12));
  NFile::~NFile((NFile *)&v26);
}

void sub_20D985130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  NFile::~NFile((NFile *)va);
  _Unwind_Resume(a1);
}

void NSATSpeaker::writeIfModified(NSATSpeaker *this, const char *a2)
{
  if (*((_BYTE *)this + 78))
  {
    NSATSpeaker::write(this, a2);
    *((_BYTE *)this + 78) = 0;
  }
}

void NSATSpeaker::matrixvector(int a1, uint64_t a2, uint64_t a3, float *a4, unsigned int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  float *v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  float v17;
  float32x4_t v18;
  float32x4_t v19;
  uint64_t v20;

  v7 = *a5;
  if ((_DWORD)v7)
  {
    v8 = *a6;
    if ((_DWORD)v8)
    {
      v9 = (*a7 - v8);
      v10 = *(float **)(a3 + 8);
      v11 = 4 * (v8 - 1);
      if (v8 >= 8)
      {
        v14 = 0;
        v15 = v11 + 4 * v9 + 4;
        do
        {
          v16 = 0;
          v17 = 0.0;
          do
          {
            v18 = vmulq_f32(*(float32x4_t *)(a2 + v16), *(float32x4_t *)&v10[v16 / 4]);
            v19 = vmulq_f32(*(float32x4_t *)(a2 + v16 + 16), *(float32x4_t *)&v10[v16 / 4 + 4]);
            v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v18.f32[0]) + v18.f32[1]) + v18.f32[2])
                                                + v18.f32[3])
                                        + v19.f32[0])
                                + v19.f32[1])
                        + v19.f32[2])
                + v19.f32[3];
            v16 += 32;
          }
          while (((4 * v8) & 0x3FFFFFFE0) != v16);
          if ((v8 & 0xFFFFFFF8) != v8)
          {
            v20 = v8 & 0xFFFFFFF8;
            do
            {
              v17 = v17 + (float)(*(float *)(a2 + 4 * v20) * v10[v20]);
              ++v20;
            }
            while (v8 != v20);
          }
          a4[v14++] = v17;
          a2 += v15;
        }
        while (v14 != v7);
      }
      else
      {
        v12 = (float *)(a2 + 12);
        do
        {
          v13 = (float)(*(v12 - 3) * *v10) + 0.0;
          if ((_DWORD)v8 != 1)
          {
            v13 = v13 + (float)(*(v12 - 2) * v10[1]);
            if ((_DWORD)v8 != 2)
            {
              v13 = v13 + (float)(*(v12 - 1) * v10[2]);
              if ((_DWORD)v8 != 3)
              {
                v13 = v13 + (float)(*v12 * v10[3]);
                if ((_DWORD)v8 != 4)
                {
                  v13 = v13 + (float)(v12[1] * v10[4]);
                  if ((_DWORD)v8 != 5)
                  {
                    v13 = v13 + (float)(v12[2] * v10[5]);
                    if ((_DWORD)v8 != 6)
                      v13 = v13 + (float)(v12[3] * v10[6]);
                  }
                }
              }
            }
          }
          *a4++ = v13;
          v12 = (float *)((char *)v12 + 4 * v9 + v11 + 4);
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      bzero(a4, 4 * v7);
    }
  }
}

void NSATSpeaker::bubbleSort(NSATSpeaker *this, const float *a2, float *a3, const unsigned int *a4)
{
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  float *v8;
  const float *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  const float *v15;
  int v16;
  char v17;
  float v18;
  uint64_t v19;
  float *v20;

  v4 = *a4;
  if ((_DWORD)v4)
  {
    if (v4 >= 8 && (unint64_t)((char *)a3 - (char *)a2) > 0x1F)
    {
      v6 = v4 & 0xFFFFFFF8;
      v8 = a3 + 4;
      v9 = a2 + 4;
      v10 = v6;
      do
      {
        v11 = *(_OWORD *)v9;
        *((_OWORD *)v8 - 1) = *((_OWORD *)v9 - 1);
        *(_OWORD *)v8 = v11;
        v8 += 8;
        v9 += 8;
        v10 -= 8;
      }
      while (v10);
      if (v6 == v4)
      {
LABEL_13:
        v7 = v4 - 1;
        if (!v7)
          return;
        goto LABEL_16;
      }
    }
    else
    {
      v6 = 0;
    }
    v12 = v4 - v6;
    v13 = v6;
    v14 = &a3[v6];
    v15 = &a2[v13];
    do
    {
      v16 = *(_DWORD *)v15++;
      *(_DWORD *)v14++ = v16;
      --v12;
    }
    while (v12);
    goto LABEL_13;
  }
  v7 = -1;
  do
  {
LABEL_16:
    v17 = 0;
    v18 = *a3;
    v19 = v7;
    v20 = a3 + 1;
    do
    {
      if (v18 > *v20)
      {
        *(v20 - 1) = *v20;
        *v20 = v18;
        v17 = 1;
      }
      else
      {
        v18 = *v20;
      }
      ++v20;
      --v19;
    }
    while (v19);
  }
  while ((v17 & 1) != 0);
}

void *createFloatArray(int a1, void *a2)
{
  id v3;
  int v4;
  void *v5;
  void *v6;
  NSObject *v7;
  _DWORD v9[2];
  __int16 v10;
  id v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  v4 = 4 * a1;
  v5 = malloc_type_malloc(4 * a1, 0x94A3413DuLL);
  v6 = v5;
  if (v5)
  {
    bzero(v5, v4);
  }
  else
  {
    v7 = VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      v9[0] = 67240450;
      v9[1] = v4;
      v10 = 2114;
      v11 = v3;
      _os_log_error_impl(&dword_20D965000, v7, OS_LOG_TYPE_ERROR, "could not allocate %{public}d bytes for %{public}@", (uint8_t *)v9, 0x12u);
    }
  }

  return v6;
}

float *fftEnergies(OpaqueFFTSetup *a1, float *a2, int a3)
{
  float *FloatArray;
  long double v7;
  float *v8;
  vDSP_Length v9;
  float *v10;
  float *v11;
  DSPSplitComplex __C;
  int __B;

  FloatArray = (float *)createFloatArray(a3, CFSTR("complex part zero vec"));
  __C.realp = a2;
  __C.imagp = FloatArray;
  v7 = log2((double)a3);
  vDSP_fft_zip(a1, &__C, 1, (unint64_t)v7, 1);
  v8 = (float *)createFloatArray(a3, CFSTR("fft magnitudes array"));
  v9 = a3;
  vDSP_zvmags(&__C, 1, v8, 1, a3);
  __B = a3;
  v10 = (float *)createFloatArray(a3, CFSTR("sqrt"));
  vvsqrtf(v10, v8, &__B);
  v11 = (float *)createFloatArray(a3, CFSTR("normalized fft magnitudes"));
  __B = 0x40000000;
  vDSP_vsmul(v10, 1, (const float *)&__B, v11, 1, v9);
  free(FloatArray);
  free(v8);
  free(v10);
  return v11;
}

uint64_t zeroCrossingVAD(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  NSObject *v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  unsigned int v18;
  _BOOL4 v20;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v4 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240192;
    v23 = a2;
    _os_log_impl(&dword_20D965000, v4, OS_LOG_TYPE_INFO, "begin zerocross vad, lentotal = %{public}d", buf, 8u);
  }
  if (a2 >= 1)
  {
    v5 = 0;
    v6 = 0;
    LODWORD(v7) = 0;
    v8 = 0;
    v9 = VTLogContextFacilityVoiceTrigger;
    v10 = 0.0;
    v11 = a1;
    do
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67240448;
        v23 = v5;
        v24 = 2050;
        v25 = v10;
        _os_log_impl(&dword_20D965000, v9, OS_LOG_TYPE_INFO, "vad fr = %{public}d, delta=%{public}f", buf, 0x12u);
        v9 = VTLogContextFacilityVoiceTrigger;
      }
      v12 = 0;
      v13 = 0;
      v14 = *(float *)(a1 + 4 * v5 + 4);
      v15 = 3.4028e38;
      v16 = 1.1755e-38;
      do
      {
        v17 = v14;
        v14 = *(float *)(v11 + v12);
        if (v14 < v15)
          v15 = *(float *)(v11 + v12);
        if (v14 > v16)
          v16 = *(float *)(v11 + v12);
        if (v17 > 0.0 && v14 <= 0.0 || v17 < 0.0 && v14 >= 0.0)
          ++v13;
        v12 += 4;
      }
      while (v12 != 640);
      v10 = vabds_f32(v16, v15);
      v18 = v13 - 5;
      v20 = v10 > 200.0 && v18 < 0x1A;
      if (v20)
      {
        if (v8)
          v7 = v7;
        else
          v7 = v5;
        if (v6 > 3)
          return v7;
        ++v6;
      }
      else
      {
        LODWORD(v7) = 0;
        v6 = 0;
      }
      v5 += 160;
      v11 += 640;
      v8 = v20;
    }
    while ((int)v5 < a2);
  }
  return 0xFFFFFFFFLL;
}

float *vecsqrt(const float *a1, int a2)
{
  float *FloatArray;
  int v5;

  v5 = a2;
  FloatArray = (float *)createFloatArray(a2, CFSTR("sqrt"));
  vvsqrtf(FloatArray, a1, &v5);
  return FloatArray;
}

float countZeroCrossings(float *a1, int a2, float *a3)
{
  int v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float result;

  if (a2 < 1)
  {
    v10 = -3.4028e38;
  }
  else
  {
    v4 = 0;
    v5 = a2;
    v6 = a1[1];
    v7 = 3.4028e38;
    v8 = 1.1755e-38;
    do
    {
      v9 = v6;
      v6 = *a1;
      if (*a1 < v7)
        v7 = *a1;
      if (v6 > v8)
        v8 = *a1;
      if (v9 > 0.0 && v6 <= 0.0 || v9 < 0.0 && v6 >= 0.0)
        ++v4;
      ++a1;
      --v5;
    }
    while (v5);
    v10 = v8 - v7;
  }
  result = fabsf(v10);
  *a3 = result;
  return result;
}

float sumsegment(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  float result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  float v9;

  if (a3 < 1)
    return 0.0;
  if (a3 <= 7)
  {
    v3 = 0;
    result = 0.0;
LABEL_8:
    v7 = a3 - v3;
    v8 = (float *)(a1 + 4 * (v3 + a2));
    do
    {
      v9 = *v8++;
      result = result + v9;
      --v7;
    }
    while (v7);
    return result;
  }
  v3 = a3 & 0x7FFFFFF8;
  v5 = a1 + 4 * a2 + 16;
  result = 0.0;
  v6 = a3 & 0xFFFFFFF8;
  do
  {
    result = (float)((float)((float)((float)((float)((float)((float)(result + COERCE_FLOAT(*(_OWORD *)(v5 - 16)))
                                                           + COERCE_FLOAT(HIDWORD(*(_QWORD *)(v5 - 16))))
                                                   + COERCE_FLOAT(*(_QWORD *)(v5 - 8)))
                                           + COERCE_FLOAT(HIDWORD(*(_OWORD *)(v5 - 16))))
                                   + COERCE_FLOAT(*(_OWORD *)v5))
                           + COERCE_FLOAT(HIDWORD(*(_QWORD *)v5)))
                   + COERCE_FLOAT(*(_QWORD *)(v5 + 8)))
           + COERCE_FLOAT(HIDWORD(*(_OWORD *)v5));
    v5 += 32;
    v6 -= 8;
  }
  while (v6);
  if (v3 != a3)
    goto LABEL_8;
  return result;
}

void NBase64File::~NBase64File(NBase64File *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;

  *(_QWORD *)this = &off_24C7F1268;
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 5) + 64))((char *)this + 40, "", &v4);
  v5 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v5);
  *((_BYTE *)this + 72) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;

  *(_QWORD *)this = &off_24C7F1268;
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 5) + 64))((char *)this + 40, "", &v4);
  v5 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v5);
  *((_BYTE *)this + 72) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;

  *(_QWORD *)this = &off_24C7F1268;
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 5) + 64))((char *)this + 40, "", &v4);
  v5 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v5);
  *((_BYTE *)this + 72) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

char *NBase64File::open(NBase64File *this, const NString *a2, const NString *a3)
{
  char *result;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  char *v9;

  v7 = &off_24C7F32C0;
  v8 = 17;
  v9 = (char *)operator new[]();
  strcpy(v9, "anonymous b64file");
  (*(void (**)(NBase64File *, uint64_t (***)(NString *__hidden, const unsigned int *), const NString *, const NString *))(*(_QWORD *)this + 128))(this, &v7, a2, a3);
  v7 = &off_24C7F32C0;
  result = v9;
  if (v9)
    return (char *)MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  return result;
}

void sub_20D986378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NBase64File::close(NBase64File *this)
{
  NBase64File *v1;
  uint64_t v2;
  uint64_t result;
  int v4;
  int v5;

  v1 = this;
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 5) + 64))((char *)this + 40, "", &v4);
  v5 = 0;
  v2 = *((_QWORD *)v1 + 1);
  v1 = (NBase64File *)((char *)v1 + 8);
  result = (*(uint64_t (**)(NBase64File *, const char *, int *))(v2 + 64))(v1, "", &v5);
  *((_BYTE *)v1 + 64) = 0;
  *((_DWORD *)v1 + 14) = 0;
  return result;
}

uint64_t NBase64File::isOpen(NBase64File *this)
{
  return *((unsigned __int8 *)this + 72);
}

BOOL NBase64File::eof(NBase64File *this)
{
  return *((_DWORD *)this + 16) == -1;
}

uint64_t NBase64File::good(NBase64File *this)
{
  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 40))(this) & 1) != 0)
    return 0;
  else
    return (*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 32))(this);
}

char *NBase64File::read@<X0>(NBase64File *this@<X0>, uint64_t a2@<X8>)
{
  const char *v4;
  char *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  size_t v10;
  char *v11;

  if ((*(unsigned int (**)(NBase64File *))(*(_QWORD *)this + 40))(this))
  {
    *(_QWORD *)a2 = &off_24C7F32C0;
    *(_DWORD *)(a2 + 8) = 0;
    result = (char *)operator new[]();
    *(_QWORD *)(a2 + 16) = result;
  }
  else
  {
    v6 = *((unsigned int *)this + 16);
    *((_DWORD *)this + 16) = -1;
    v7 = *((unsigned int *)this + 12);
    if (v7 < v6)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v4, v6, v7);
    v8 = *((_QWORD *)this + 7);
    *(_QWORD *)a2 = &off_24C7F32C0;
    if (!v8)
      Error::chuck((Error *)"Null pointer passed to string constructor", v4);
    v9 = (const void *)(v8 + v6);
    v10 = (v7 - v6);
    *(_DWORD *)(a2 + 8) = v10;
    v11 = (char *)operator new[]();
    *(_QWORD *)(a2 + 16) = v11;
    memcpy(v11, v9, v10);
    result = &v11[v10];
  }
  *result = 0;
  return result;
}

_BYTE *NBase64File::read@<X0>(NBase64File *this@<X0>, const unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v6;
  _BYTE *result;
  unsigned int v8;
  _BOOL4 v9;
  unsigned int v10;
  unsigned int v11;

  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 17))
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" not opened in read mode", v6, *((_QWORD *)this + 3));
  if (*a2 == -1)
    Error::chuck((Error *)"NBase64File::read() - attempting impossibly long read in file \"%s\"", v6, *((_QWORD *)this + 3));
  if ((*(unsigned int (**)(NBase64File *))(*(_QWORD *)this + 40))(this))
  {
    *(_QWORD *)a3 = &off_24C7F32C0;
    *(_DWORD *)(a3 + 8) = 0;
    result = (_BYTE *)operator new[]();
    *(_QWORD *)(a3 + 16) = result;
    *result = 0;
  }
  else
  {
    v11 = *((_DWORD *)this + 16);
    v8 = *a2 + v11;
    v9 = __CFADD__(*a2, v11);
    v10 = *a2 + v11;
    *((_DWORD *)this + 16) = v8;
    if (v8 > *((_DWORD *)this + 12) || v9)
    {
      v10 = *((_DWORD *)this + 12);
      *((_DWORD *)this + 16) = -1;
    }
    return NString::slice((NBase64File *)((char *)this + 40), &v11, &v10, a3);
  }
  return result;
}

uint64_t NBase64File::read(NBase64File *this, const unsigned int *a2, NString *a3)
{
  const char *v6;
  uint64_t v8;
  unsigned int v9;
  _BOOL4 v10;
  unsigned int v11;
  BOOL v12;
  int v13;
  void *v14;
  unsigned int __n;
  int __n_4;

  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 17))
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" not opened in read mode", v6, *((_QWORD *)this + 3));
  if (*a2 == -1)
    Error::chuck((Error *)"NBase64File::read() - attempting impossibly long read in file \"%s\"", v6, *((_QWORD *)this + 3));
  if ((*(unsigned int (**)(NBase64File *))(*(_QWORD *)this + 40))(this))
  {
    __n_4 = 0;
    (*(void (**)(NString *, int *))(*(_QWORD *)a3 + 56))(a3, &__n_4);
    return 0;
  }
  else
  {
    v8 = *((unsigned int *)this + 16);
    v9 = *a2 + v8;
    v10 = __CFADD__(*a2, (_DWORD)v8);
    v11 = *((_DWORD *)this + 12);
    if (v9 > v11)
      v10 = 1;
    v12 = !v10;
    if (v10)
      v13 = -1;
    else
      v13 = *a2 + v8;
    *((_DWORD *)this + 16) = v13;
    if (!v12)
      v9 = v11;
    __n = v9 - v8;
    v14 = (void *)(*(uint64_t (**)(NString *, unsigned int *))(*(_QWORD *)a3 + 56))(a3, &__n);
    memcpy(v14, (const void *)(*((_QWORD *)this + 7) + v8), __n);
    return *((unsigned int *)a3 + 2);
  }
}

uint64_t NBase64File::readLine@<X0>(NBase64File *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v6;
  unsigned int *v7;
  const char *v8;
  _WORD *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  void *v14;
  int v15;
  unsigned __int8 *v16;
  unsigned int v17;
  _BYTE *v18;
  const char *v19;
  int v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  void *v26;
  size_t v27;
  const void *v28;
  void *v29;
  int v30;
  unsigned int v31;
  _BYTE *v32;
  uint64_t v33;
  unsigned int v34;
  unsigned __int8 *v35;
  int v36;
  unsigned int v38;
  uint64_t (**v39)(NString *__hidden, const unsigned int *);
  int v40;
  void *v41;

  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NBase64File::readLine() - file \"%s\" is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 17))
    Error::chuck((Error *)"NBase64File::readLine() - file \"%s\" not opened in read mode", v6, *((_QWORD *)this + 3));
  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 40))(this) & 1) != 0)
    goto LABEL_19;
  v7 = (unsigned int *)((char *)this + 64);
  if (*((_DWORD *)this + 16) >= *((_DWORD *)this + 12))
  {
    *v7 = -1;
LABEL_19:
    *(_QWORD *)a3 = &off_24C7F32C0;
    *(_DWORD *)(a3 + 8) = 0;
    result = operator new[]();
    *(_QWORD *)(a3 + 16) = result;
    *(_BYTE *)result = 0;
    return result;
  }
  v9 = (_WORD *)operator new[]();
  *v9 = 10;
  v10 = *((unsigned int *)this + 16);
  v11 = *((_DWORD *)this + 12);
  if (v11 <= v10)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v8, *((unsigned int *)this + 16), v11 - 1);
  v12 = v11 - v10;
  if ((int)(v11 - v10) >= 1)
  {
    v13 = *((_QWORD *)this + 7);
    v14 = (void *)(v13 + v10);
    v15 = *(unsigned __int8 *)v9;
    do
    {
      v16 = (unsigned __int8 *)memchr(v14, 10, v12);
      if (!v16)
        break;
      v17 = (_DWORD)v16 - v13;
      if (*v16 == v15)
        goto LABEL_12;
      v12 = v11 + ~v17;
      v14 = v16 + 1;
    }
    while (v12 > 0);
  }
  v17 = -1;
LABEL_12:
  MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  *(_QWORD *)a3 = &off_24C7F32C0;
  *(_DWORD *)(a3 + 8) = 0;
  v18 = (_BYTE *)operator new[]();
  *(_QWORD *)(a3 + 16) = v18;
  *v18 = 0;
  if ((v17 & 0x80000000) != 0)
  {
    v22 = *((unsigned int *)this + 16);
    v23 = *((unsigned int *)this + 12);
    if (v23 < v22)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v19, *((unsigned int *)this + 16), v23);
    v24 = *((_QWORD *)this + 7);
    v39 = &off_24C7F32C0;
    if (!v24)
      Error::chuck((Error *)"Null pointer passed to string constructor", v19);
    v25 = (v23 - v22);
    v40 = v23 - v22;
    v26 = (void *)operator new[]();
    v41 = v26;
    memcpy(v26, (const void *)(v24 + v22), v25);
    *((_BYTE *)v26 + v25) = 0;
    if (&v39 == (uint64_t (***)(NString *__hidden, const unsigned int *))a3)
    {
      v39 = &off_24C7F32C0;
    }
    else
    {
      (*(void (**)(uint64_t, void *, int *))(*(_QWORD *)a3 + 64))(a3, v26, &v40);
      v26 = v41;
      v39 = &off_24C7F32C0;
      if (!v41)
        goto LABEL_28;
    }
    MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
LABEL_28:
    v20 = -1;
    goto LABEL_29;
  }
  v38 = v17;
  NString::slice((NBase64File *)((char *)this + 40), v7, &v38, (uint64_t)&v39);
  if (&v39 != (uint64_t (***)(NString *__hidden, const unsigned int *))a3)
    (*(void (**)(uint64_t, void *, int *))(*(_QWORD *)a3 + 64))(a3, v41, &v40);
  v39 = &off_24C7F32C0;
  if (v41)
    MEMORY[0x212BAC9C0](v41, 0x1000C8077774924);
  v20 = v17 + 1;
LABEL_29:
  *v7 = v20;
  result = *(unsigned int *)(a3 + 8);
  if ((_DWORD)result)
  {
    v27 = (result - 1);
    v28 = *(const void **)(a3 + 16);
    if (*((_BYTE *)v28 + v27) == 13)
    {
      v39 = &off_24C7F32C0;
      v40 = result - 1;
      v29 = (void *)operator new[]();
      v41 = v29;
      memcpy(v29, v28, v27);
      *((_BYTE *)v29 + v27) = 0;
      if (&v39 == (uint64_t (***)(NString *__hidden, const unsigned int *))a3)
      {
        v39 = &off_24C7F32C0;
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t, void *, int *))(*(_QWORD *)a3 + 64))(a3, v29, &v40);
        v29 = v41;
        v39 = &off_24C7F32C0;
        if (!v41)
          goto LABEL_36;
      }
      result = MEMORY[0x212BAC9C0](v29, 0x1000C8077774924);
    }
  }
LABEL_36:
  v30 = *(unsigned __int8 *)a2;
  if (*a2)
  {
    v31 = *(_DWORD *)(a3 + 8);
    if (v31)
    {
      v32 = *(_BYTE **)(a3 + 16);
      if (*v32 == v30)
      {
        *v32 = 0;
        *(_DWORD *)(a3 + 8) = 0;
      }
      else if (v31 >= 2)
      {
        v33 = 0;
        v34 = v31 - 1;
        while (1)
        {
          v35 = &v32[v33++];
          if (v35[1] == v30)
          {
            v36 = *v35;
            if (v36 == 32 || v36 == 9)
              break;
          }
          if (v34 == (_DWORD)v33)
            return result;
        }
        *(_DWORD *)(a3 + 8) = v33;
        v32[v33] = 0;
      }
    }
  }
  return result;
}

void sub_20D986BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  _QWORD *v14;
  uint64_t v15;
  uint64_t v17;

  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  *v14 = v15;
  v17 = v14[2];
  if (v17)
    MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NBase64File::readString(NBase64File *this, const char *a2)
{
  Error::chuck((Error *)"NBase64File::readString() - not supported by NBase64File", a2);
}

void NBase64File::write(NBase64File *this, const NString *a2)
{
  Error::chuck((Error *)"NBase64File::write() - file \"%s\" does not support write mode", (const char *)a2, *((_QWORD *)this + 3));
}

void NBaseFile::writeLine(NBaseFile *this, const NString *a2)
{
  uint64_t (**v3)(NString *__hidden, const unsigned int *);
  int v4;
  _WORD *v5;
  _BYTE v6[24];

  v3 = &off_24C7F32C0;
  v4 = 1;
  v5 = (_WORD *)operator new[]();
  *v5 = 10;
  NString::operator+((uint64_t)a2, (uint64_t)&v3, (uint64_t)v6);
}

uint64_t sub_20D986CE0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v1 + 96))(v1, &v4);
  v4 = v2;
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return MEMORY[0x212BAC9C0](v0, 0x1000C8077774924);
}

void sub_20D986D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;

  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NBase64File::setPosition(NBase64File *this, const unsigned int *a2)
{
  const char *v4;
  int v5;

  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NBase64File::getPosition() - cannot set position, file %s is not open", v4, *((_QWORD *)this + 3));
  v5 = *a2;
  if (*a2 > *((_DWORD *)this + 12))
    v5 = -1;
  *((_DWORD *)this + 16) = v5;
  return (*(unsigned int (**)(NBase64File *))(*(_QWORD *)this + 40))(this) ^ 1;
}

uint64_t NBase64File::getPosition(NBase64File *this)
{
  const char *v2;

  if (((*(uint64_t (**)(NBase64File *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NBase64File::getPosition() - cannot get position, file %s is not open", v2, *((_QWORD *)this + 3));
  return *((unsigned int *)this + 16);
}

uint64_t NBase64File::openNamed(NBase64File *this, const NString *a2, const NString *a3, const NString *a4)
{
  uint64_t result;
  uint64_t v9;
  const char *v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  uint64_t v12;
  uint64_t v13;

  (*(void (**)(NBase64File *))(*(_QWORD *)this + 24))(this);
  if (*((_DWORD *)a4 + 2) != 1 || **((_BYTE **)a4 + 2) != 114)
  {
    v9 = *((_QWORD *)a4 + 2);
    if (NString::operator==((uint64_t)a4, "w"))
      Error::chuck((Error *)"NBase64File::open() - does not support write mode \"%s\"", v10, v9);
    Error::chuck((Error *)"NBase64File::open() - unrecognized file mode \"%s\"", v10, v9);
  }
  *((_DWORD *)this + 17) = 0;
  base64_decode(a3, 1, (uint64_t)&v11);
  if ((uint64_t (***)(NString *__hidden, const unsigned int *))((char *)this + 40) != &v11)
    (*(void (**)(char *, uint64_t, uint64_t *))(*((_QWORD *)this + 5) + 64))((char *)this + 40, v13, &v12);
  v11 = &off_24C7F32C0;
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  *((_DWORD *)this + 16) = 0;
  result = (uint64_t)this + 8;
  if ((NBase64File *)((char *)this + 8) != a2)
    result = (*(uint64_t (**)(uint64_t, _QWORD, char *))(*(_QWORD *)result + 64))(result, *((_QWORD *)a2 + 2), (char *)a2 + 8);
  *((_BYTE *)this + 72) = 1;
  return result;
}

void sub_20D986F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NBase64File::NBase64File(NBase64File *this)
{
  _BYTE *v2;
  _BYTE *v3;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1268;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  *((_DWORD *)this + 12) = 0;
  v3 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 7) = v3;
  *v3 = 0;
  *((_BYTE *)this + 72) = 0;
}

{
  _BYTE *v2;
  _BYTE *v3;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1268;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  *((_DWORD *)this + 12) = 0;
  v3 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 7) = v3;
  *v3 = 0;
  *((_BYTE *)this + 72) = 0;
}

void sub_20D98704C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v4 = v2;
  *v1 = v4;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D98711C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v4 = v2;
  *v1 = v4;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NBase64File::NBase64File(NBase64File *this, const NString *a2, const NString *a3)
{
  _BYTE *v6;
  _BYTE *v7;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1268;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  *((_DWORD *)this + 12) = 0;
  v7 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 7) = v7;
  *v7 = 0;
  *((_BYTE *)this + 72) = 0;
  (*(void (**)(NBase64File *, const NString *, const NString *))(*(_QWORD *)this + 16))(this, a2, a3);
}

{
  _BYTE *v6;
  _BYTE *v7;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1268;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  *((_DWORD *)this + 12) = 0;
  v7 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 7) = v7;
  *v7 = 0;
  *((_BYTE *)this + 72) = 0;
  (*(void (**)(NBase64File *, const NString *, const NString *))(*(_QWORD *)this + 16))(this, a2, a3);
}

void sub_20D987214(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v1[5] = v3;
  v5 = v1[7];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *v1 = v2;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D987330(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v1[5] = v3;
  v5 = v1[7];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *v1 = v2;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NBase64File::NBase64File(NBase64File *this, const NString *a2, const NString *a3, const NString *a4)
{
  _BYTE *v8;
  _BYTE *v9;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v8 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v8;
  *v8 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1268;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  *((_DWORD *)this + 12) = 0;
  v9 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 7) = v9;
  *v9 = 0;
  *((_BYTE *)this + 72) = 0;
  (*(void (**)(NBase64File *, const NString *, const NString *, const NString *))(*(_QWORD *)this + 128))(this, a2, a3, a4);
}

{
  _BYTE *v8;
  _BYTE *v9;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v8 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v8;
  *v8 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1268;
  *((_QWORD *)this + 5) = &off_24C7F32C0;
  *((_DWORD *)this + 12) = 0;
  v9 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 7) = v9;
  *v9 = 0;
  *((_BYTE *)this + 72) = 0;
  (*(void (**)(NBase64File *, const NString *, const NString *, const NString *))(*(_QWORD *)this + 128))(this, a2, a3, a4);
}

void sub_20D987454(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v1[5] = v3;
  v5 = v1[7];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *v1 = v2;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D987578(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v1[5] = v3;
  v5 = v1[7];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  *v1 = v2;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NLRHMMTraceback::NLRHMMTraceback(NLRHMMTraceback *this, unsigned int *a2, unsigned int *a3)
{
  uint64_t v5;
  int v6;

  v5 = N2DArray<BOOL>::N2DArray((uint64_t)this, a2, a3);
  *(_DWORD *)(v5 + 32) = *a2;
  v6 = *a3;
  *(_QWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 36) = v6;
}

{
  uint64_t v5;
  int v6;

  v5 = N2DArray<BOOL>::N2DArray((uint64_t)this, a2, a3);
  *(_DWORD *)(v5 + 32) = *a2;
  v6 = *a3;
  *(_QWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 36) = v6;
}

uint64_t N2DArray<BOOL>::N2DArray(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;

  *(_QWORD *)a1 = &off_24C7F2FE8;
  v6 = *a2;
  v7 = 24 * v6;
  v8 = (_QWORD *)operator new[]();
  *v8 = 24;
  v8[1] = v6;
  v9 = v8 + 2;
  if ((_DWORD)v6)
  {
    v10 = v8 + 2;
    if ((unint64_t)(v7 - 24) < 0x18)
      goto LABEL_7;
    v11 = (v7 - 24) / 0x18uLL + 1;
    v12 = v8 + 4;
    v13 = v11 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v12 - 2) = &off_24C7F3058;
      *(v12 - 1) = 0;
      v12[1] = &off_24C7F3058;
      v12[2] = 0;
      *(_DWORD *)v12 = 0;
      *((_DWORD *)v12 + 6) = 0;
      v12 += 6;
      v13 -= 2;
    }
    while (v13);
    if (v11 != (v11 & 0x1FFFFFFFFFFFFFFELL))
    {
      v10 = &v9[3 * (v11 & 0x1FFFFFFFFFFFFFFELL)];
      do
      {
LABEL_7:
        *v10 = &off_24C7F3058;
        v10[1] = 0;
        *((_DWORD *)v10 + 4) = 0;
        v10 += 3;
      }
      while (v10 != &v9[3 * v6]);
    }
  }
  *(_DWORD *)(a1 + 16) = *a2;
  *(_QWORD *)a1 = &off_24C7F3350;
  *(_QWORD *)(a1 + 8) = v9;
  v14 = *a2;
  *(_DWORD *)(a1 + 20) = *a2;
  *(_DWORD *)(a1 + 24) = *a3;
  if (v14)
  {
    v15 = 0;
    v16 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v15) + 32))(*(_QWORD *)(a1 + 8) + v15, a1 + 24);
      ++v16;
      v15 += 24;
    }
    while (v16 < *(unsigned int *)(a1 + 20));
  }
  return a1;
}

void sub_20D98782C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *v1 = v2;
  v4 = v1[1];
  if (v4)
  {
    v5 = *(_QWORD *)(v4 - 8);
    if (v5)
    {
      v6 = 24 * v5;
      do
      {
        *(_QWORD *)(v4 + v6 - 24) = &off_24C7F3058;
        v7 = *(_QWORD *)(v4 + v6 - 16);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
        v6 -= 24;
      }
      while (v6);
    }
    MEMORY[0x212BAC9C0](v4 - 16, 0x1091C80FBD4B0D6);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *N2DArray<BOOL>::~N2DArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2FE8;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 24 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 24) = &off_24C7F3058;
        v5 = *(_QWORD *)(v2 + v4 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x1091C80FBD4B0D6);
  }
  return a1;
}

void N2DArray<BOOL>::~N2DArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F2FE8;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F3058;
        v4 = *(_QWORD *)(v1 + v3 - 16);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1091C80FBD4B0D6);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLRHMMTraceback::resize(NLRHMMTraceback *this, char *a2, const unsigned int *a3)
{
  char *v6;
  uint64_t result;
  uint64_t v8;
  unint64_t v9;
  int v10;

  if (*((_DWORD *)this + 11))
    Error::chuck((Error *)"NLRHMMTraceback::resize() - cannot resize unless empty", a2, a3);
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NLRHMMTraceback::resize() - must be at least 1 frame in buffer", a2, a3);
  *((_DWORD *)this + 5) = *(_DWORD *)a2;
  *((_DWORD *)this + 6) = *a3;
  v6 = (char *)this + 24;
  result = NArray<NArray<BOOL>>::resize((uint64_t)this, a2);
  if (*((_DWORD *)this + 5))
  {
    v8 = 0;
    v9 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)(*((_QWORD *)this + 1) + v8) + 32))(*((_QWORD *)this + 1) + v8, v6);
      ++v9;
      v8 += 24;
    }
    while (v9 < *((unsigned int *)this + 5));
  }
  *((_DWORD *)this + 8) = *(_DWORD *)a2;
  v10 = *a3;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 9) = v10;
  return result;
}

uint64_t NLRHMMTraceback::reset(uint64_t this)
{
  *(_QWORD *)(this + 40) = 0;
  return this;
}

uint64_t NLRHMMTraceback::drop(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t result;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;

  v2 = *(unsigned int *)(a1 + 36);
  if (*(_DWORD *)(a2 + 16) != (_DWORD)v2)
    Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v2);
  v4 = *(_QWORD *)(a1 + 8) + 24 * *(unsigned int *)(a1 + 40);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  v7 = *(_DWORD *)(a1 + 40);
  v6 = *(_DWORD *)(a1 + 44);
  v8 = *(_DWORD *)(a1 + 32);
  if (v7 + 1 < v8)
    v9 = v7 + 1;
  else
    v9 = 0;
  *(_DWORD *)(a1 + 40) = v9;
  if (v6 < v8)
    *(_DWORD *)(a1 + 44) = v6 + 1;
  return result;
}

uint64_t NLRHMMTraceback::stateAlignment(uint64_t result, uint64_t a2, _DWORD *a3)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *(_DWORD *)(a2 + 16);
  v4 = *(unsigned int *)(result + 36);
  if (v3 != (_DWORD)v4)
    Error::chuck((Error *)"NLRHMMTraceback::stateAlignment() - mismatched number of states in duration array (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v4);
  v5 = *(_DWORD *)(result + 44);
  v6 = v5 - *a3;
  if (v5 <= *a3)
  {
    if (v3)
    {
      v15 = 0;
      v16 = *(_QWORD *)(a2 + 8);
      do
        *(_DWORD *)(v16 + 4 * v15++) = 0;
      while (v15 < *(unsigned int *)(result + 36));
    }
  }
  else if (v3)
  {
    v7 = 0;
    v8 = v3 - 1;
    v9 = *(_DWORD *)(result + 40) + ~*a3;
    v10 = *(_DWORD *)(result + 32);
    v11 = __CFADD__(v9, v10);
    v12 = v9 + v10;
    if (v11)
      v9 = v12;
    v13 = *(_QWORD *)(result + 8);
    v14 = *(_QWORD *)(a2 + 8);
    do
    {
      ++v7;
      if (*(_BYTE *)(*(_QWORD *)(v13 + 24 * v9 + 8) + v8))
      {
        *(_DWORD *)(v14 + 4 * v8--) = v7;
        v3 = *(_DWORD *)(result + 36);
        if (v8 >= v3)
          break;
        v7 = 0;
      }
      if (!v9)
        v9 = *(_DWORD *)(result + 32);
      --v9;
      --v6;
    }
    while (v6);
    if (v8 < v3)
    {
      v17 = *(_QWORD *)(a2 + 8);
      do
        *(_DWORD *)(v17 + 4 * v8--) = 0;
      while (v8 < *(_DWORD *)(result + 36));
    }
  }
  return result;
}

void NRingDropBuffer::NRingDropBuffer(NRingDropBuffer *this, char *a2)
{
  *(_QWORD *)this = &off_24C7F2DB8;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NRingDropBuffer::resize() - cannot set size < 1", a2);
  NArray<NFrame>::resize((uint64_t)this, a2);
  *((_QWORD *)this + 3) = 0;
}

{
  *(_QWORD *)this = &off_24C7F2DB8;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NRingDropBuffer::resize() - cannot set size < 1", a2);
  NArray<NFrame>::resize((uint64_t)this, a2);
  *((_QWORD *)this + 3) = 0;
}

void sub_20D9891B4(_Unwind_Exception *a1)
{
  _QWORD *v1;

  NArray<NFrame>::~NArray(v1);
  _Unwind_Resume(a1);
}

uint64_t NArray<NFrame>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD *v24;
  __int128 *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 24 * v3;
  result = operator new[]();
  *(_QWORD *)result = 24;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = result + 16;
    if ((unint64_t)(v7 - 24) < 0x18)
      goto LABEL_8;
    v10 = (v7 - 24) / 0x18uLL + 1;
    v11 = result + 32;
    v12 = v10 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(_DWORD *)v11 = 0;
      *(_DWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 - 16) = &off_24C7F31A8;
      *(_QWORD *)(v11 - 8) = 0;
      *(_QWORD *)(v11 + 8) = &off_24C7F31A8;
      *(_QWORD *)(v11 + 16) = 0;
      v11 += 48;
      v12 -= 2;
    }
    while (v12);
    if (v10 != (v10 & 0x1FFFFFFFFFFFFFFELL))
    {
      v9 = v8 + 24 * (v10 & 0x1FFFFFFFFFFFFFFELL);
      do
      {
LABEL_8:
        *(_DWORD *)(v9 + 16) = 0;
        *(_QWORD *)v9 = &off_24C7F31A8;
        *(_QWORD *)(v9 + 8) = 0;
        v9 += 24;
      }
      while (v9 != v8 + 24 * v3);
    }
  }
  *(_QWORD *)(v5 + 8) = v8;
  if ((_DWORD)v2)
  {
    if (*a2 && v8 != v6)
    {
      v14 = 0;
      do
      {
        v15 = *(_QWORD *)(v5 + 8);
        if (v15 != v6)
        {
          v16 = v6 + 24 * v14;
          v17 = v15 + 24 * v14;
          v18 = *(unsigned int *)(v17 + 16);
          v19 = *(unsigned int *)(v16 + 16);
          if (v18 != v19)
          {
            v20 = *(_QWORD *)(v17 + 8);
            if (v20)
            {
              MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
              LODWORD(v19) = *(_DWORD *)(v16 + 16);
            }
            *(_DWORD *)(v17 + 16) = v19;
            result = operator new[]();
            *(_QWORD *)(v17 + 8) = result;
            v18 = *(unsigned int *)(v17 + 16);
          }
          if (v18)
          {
            v21 = 0;
            v22 = *(_QWORD *)(v16 + 8);
            v23 = *(_QWORD *)(v17 + 8);
            if (v18 < 8)
              goto LABEL_26;
            if ((unint64_t)(v23 - v22) < 0x20)
              goto LABEL_26;
            v21 = v18 & 0xFFFFFFF8;
            v24 = (_OWORD *)(v23 + 16);
            v25 = (__int128 *)(v22 + 16);
            v26 = v21;
            do
            {
              v27 = *v25;
              *(v24 - 1) = *(v25 - 1);
              *v24 = v27;
              v24 += 2;
              v25 += 2;
              v26 -= 8;
            }
            while (v26);
            if (v21 != v18)
            {
LABEL_26:
              v28 = v18 - v21;
              v29 = 4 * v21;
              v30 = (_DWORD *)(v23 + v29);
              v31 = (int *)(v22 + v29);
              do
              {
                v32 = *v31++;
                *v30++ = v32;
                --v28;
              }
              while (v28);
            }
          }
        }
        ++v14;
      }
      while (v14 < v2 && v14 < *a2);
    }
  }
  if (v6)
  {
    v33 = *(_QWORD *)(v6 - 8);
    if (v33)
    {
      v34 = 24 * v33;
      do
      {
        *(_QWORD *)(v6 + v34 - 24) = &off_24C7F3090;
        v35 = *(_QWORD *)(v6 + v34 - 16);
        if (v35)
          MEMORY[0x212BAC9C0](v35, 0x1000C8052888210);
        v34 -= 24;
      }
      while (v34);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

_QWORD *NArray<NFrame>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2DB8;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 24 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 24) = &off_24C7F3090;
        v5 = *(_QWORD *)(v2 + v4 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x1081C80622C3295);
  }
  return a1;
}

void NArray<NFrame>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F2DB8;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F3090;
        v4 = *(_QWORD *)(v1 + v3 - 16);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1081C80622C3295);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NFrame>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  __int128 *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  int *v35;
  int v36;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 - 8);
      if (v7)
      {
        v8 = 24 * v7;
        do
        {
          *(_QWORD *)(v6 + v8 - 24) = &off_24C7F3090;
          v9 = *(_QWORD *)(v6 + v8 - 16);
          if (v9)
            MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
          v8 -= 24;
        }
        while (v8);
      }
      MEMORY[0x212BAC9C0](v6 - 16, 0x1081C80622C3295);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v10 = 24 * v5;
    v11 = (_QWORD *)operator new[]();
    *v11 = 24;
    v11[1] = v5;
    v12 = v11 + 2;
    if (!v5)
      goto LABEL_17;
    v13 = v11 + 2;
    if ((unint64_t)(v10 - 24) >= 0x18)
    {
      v14 = (v10 - 24) / 0x18uLL + 1;
      v15 = v11 + 4;
      v16 = v14 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(_DWORD *)v15 = 0;
        *((_DWORD *)v15 + 6) = 0;
        *(v15 - 2) = &off_24C7F31A8;
        *(v15 - 1) = 0;
        v15[1] = &off_24C7F31A8;
        v15[2] = 0;
        v15 += 6;
        v16 -= 2;
      }
      while (v16);
      if (v14 == (v14 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_17;
      v13 = &v12[3 * (v14 & 0x1FFFFFFFFFFFFFFELL)];
    }
    do
    {
      *((_DWORD *)v13 + 4) = 0;
      *v13 = &off_24C7F31A8;
      v13[1] = 0;
      v13 += 3;
    }
    while (v13 != &v12[3 * v5]);
LABEL_17:
    *(_QWORD *)(a1 + 8) = v12;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4 && *(_QWORD *)(a1 + 8) != *(_QWORD *)(a2 + 8))
  {
    v17 = 0;
    do
    {
      v18 = *(_QWORD *)(a2 + 8);
      v19 = *(_QWORD *)(a1 + 8);
      if (v19 != v18)
      {
        v20 = v18 + 24 * v17;
        v21 = v19 + 24 * v17;
        v22 = *(unsigned int *)(v21 + 16);
        v23 = *(unsigned int *)(v20 + 16);
        if (v22 != v23)
        {
          v24 = *(_QWORD *)(v21 + 8);
          if (v24)
          {
            MEMORY[0x212BAC9C0](v24, 0x1000C8052888210);
            LODWORD(v23) = *(_DWORD *)(v20 + 16);
          }
          *(_DWORD *)(v21 + 16) = v23;
          *(_QWORD *)(v21 + 8) = operator new[]();
          v22 = *(unsigned int *)(v21 + 16);
        }
        if (v22)
        {
          v25 = 0;
          v26 = *(_QWORD *)(v20 + 8);
          v27 = *(_QWORD *)(v21 + 8);
          if (v22 < 8)
            goto LABEL_33;
          if ((unint64_t)(v27 - v26) < 0x20)
            goto LABEL_33;
          v25 = v22 & 0xFFFFFFF8;
          v28 = (_OWORD *)(v27 + 16);
          v29 = (__int128 *)(v26 + 16);
          v30 = v25;
          do
          {
            v31 = *v29;
            *(v28 - 1) = *(v29 - 1);
            *v28 = v31;
            v28 += 2;
            v29 += 2;
            v30 -= 8;
          }
          while (v30);
          if (v25 != v22)
          {
LABEL_33:
            v32 = v22 - v25;
            v33 = 4 * v25;
            v34 = (_DWORD *)(v27 + v33);
            v35 = (int *)(v26 + v33);
            do
            {
              v36 = *v35++;
              *v34++ = v36;
              --v32;
            }
            while (v32);
          }
        }
      }
      ++v17;
    }
    while (v17 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NArray<NFrame>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  __int128 *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  int *v35;
  int v36;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = 24 * v9;
        do
        {
          *(_QWORD *)(v7 + v10 - 24) = &off_24C7F3090;
          v11 = *(_QWORD *)(v7 + v10 - 16);
          if (v11)
            MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x1081C80622C3295);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v12 = 24 * v6;
    result = operator new[]();
    *(_QWORD *)result = 24;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (!v6)
      goto LABEL_16;
    v14 = result + 16;
    if ((unint64_t)(v12 - 24) >= 0x18)
    {
      v15 = (v12 - 24) / 0x18uLL + 1;
      v16 = result + 32;
      v17 = v15 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(_DWORD *)v16 = 0;
        *(_DWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 - 16) = &off_24C7F31A8;
        *(_QWORD *)(v16 - 8) = 0;
        *(_QWORD *)(v16 + 8) = &off_24C7F31A8;
        *(_QWORD *)(v16 + 16) = 0;
        v16 += 48;
        v17 -= 2;
      }
      while (v17);
      if (v15 == (v15 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_16;
      v14 = v13 + 24 * (v15 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_DWORD *)(v14 + 16) = 0;
      *(_QWORD *)v14 = &off_24C7F31A8;
      *(_QWORD *)(v14 + 8) = 0;
      v14 += 24;
    }
    while (v14 != v13 + 24 * v6);
LABEL_16:
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5 && *(_QWORD *)(v4 + 8) != a2)
  {
    v18 = 0;
    do
    {
      v19 = *(_QWORD *)(v4 + 8);
      if (v19 != a2)
      {
        v20 = a2 + 24 * v18;
        v21 = v19 + 24 * v18;
        v22 = *(unsigned int *)(v21 + 16);
        v23 = *(unsigned int *)(v20 + 16);
        if (v22 != v23)
        {
          v24 = *(_QWORD *)(v21 + 8);
          if (v24)
          {
            MEMORY[0x212BAC9C0](v24, 0x1000C8052888210);
            LODWORD(v23) = *(_DWORD *)(v20 + 16);
          }
          *(_DWORD *)(v21 + 16) = v23;
          result = operator new[]();
          *(_QWORD *)(v21 + 8) = result;
          v22 = *(unsigned int *)(v21 + 16);
        }
        if (v22)
        {
          v25 = 0;
          v26 = *(_QWORD *)(v20 + 8);
          v27 = *(_QWORD *)(v21 + 8);
          if (v22 < 8)
            goto LABEL_32;
          if ((unint64_t)(v27 - v26) < 0x20)
            goto LABEL_32;
          v25 = v22 & 0xFFFFFFF8;
          v28 = (_OWORD *)(v27 + 16);
          v29 = (__int128 *)(v26 + 16);
          v30 = v25;
          do
          {
            v31 = *v29;
            *(v28 - 1) = *(v29 - 1);
            *v28 = v31;
            v28 += 2;
            v29 += 2;
            v30 -= 8;
          }
          while (v30);
          if (v25 != v22)
          {
LABEL_32:
            v32 = v22 - v25;
            v33 = 4 * v25;
            v34 = (_DWORD *)(v27 + v33);
            v35 = (int *)(v26 + v33);
            do
            {
              v36 = *v35++;
              *v34++ = v36;
              --v32;
            }
            while (v32);
          }
        }
      }
      ++v18;
    }
    while (v18 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NRingDropBuffer::resize(NRingDropBuffer *this, char *a2)
{
  uint64_t result;

  if (*((_DWORD *)this + 7))
    Error::chuck((Error *)"RingDropBuffer::resize() - cannot resize unless empty", a2);
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NRingDropBuffer::resize() - cannot set size < 1", a2);
  result = NArray<NFrame>::resize((uint64_t)this, a2);
  *((_QWORD *)this + 3) = 0;
  return result;
}

void sub_20D989BA4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v1;
  *v3 = v2;
  v5 = v3[1];
  if (v5)
  {
    v6 = *(_QWORD *)(v5 - 8);
    if (v6)
    {
      v7 = 24 * v6;
      do
      {
        *(_QWORD *)(v5 + v7 - 24) = &off_24C7F3090;
        v8 = *(_QWORD *)(v5 + v7 - 16);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        v7 -= 24;
      }
      while (v7);
    }
    MEMORY[0x212BAC9C0](v5 - 16, 0x1081C80622C3295);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NRingDropBuffer::size(NRingDropBuffer *this)
{
  return (uint64_t)this + 28;
}

uint64_t NRingDropBuffer::reset(uint64_t this)
{
  *(_QWORD *)(this + 24) = 0;
  return this;
}

uint64_t NRingDropBuffer::pushFrame(uint64_t this, const NFrame *a2)
{
  _DWORD *v2;
  uint64_t v3;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  int *v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;

  v2 = (_DWORD *)this;
  v3 = *(_QWORD *)(this + 8) + 24 * *(unsigned int *)(this + 24);
  if ((const NFrame *)v3 != a2)
  {
    v5 = *(_DWORD *)(v3 + 16);
    v6 = *((_DWORD *)a2 + 4);
    if (v5 != v6)
    {
      v7 = *(_QWORD *)(v3 + 8);
      if (v7)
      {
        MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        v6 = *((_DWORD *)a2 + 4);
      }
      *(_DWORD *)(v3 + 16) = v6;
      this = operator new[]();
      *(_QWORD *)(v3 + 8) = this;
      v5 = *(_DWORD *)(v3 + 16);
    }
    if (v5)
    {
      v8 = 0;
      v9 = *((_QWORD *)a2 + 1);
      v10 = *(_QWORD *)(v3 + 8);
      v11 = v5;
      if (v5 < 8)
        goto LABEL_12;
      if ((unint64_t)(v10 - v9) < 0x20)
        goto LABEL_12;
      v8 = v5 & 0xFFFFFFF8;
      v12 = (_OWORD *)(v10 + 16);
      v13 = (__int128 *)(v9 + 16);
      v14 = v11 & 0xFFFFFFF8;
      do
      {
        v15 = *v13;
        *(v12 - 1) = *(v13 - 1);
        *v12 = v15;
        v12 += 2;
        v13 += 2;
        v14 -= 8;
      }
      while (v14);
      if (v8 != v11)
      {
LABEL_12:
        v16 = v11 - v8;
        v17 = 4 * v8;
        v18 = (_DWORD *)(v10 + v17);
        v19 = (int *)(v9 + v17);
        do
        {
          v20 = *v19++;
          *v18++ = v20;
          --v16;
        }
        while (v16);
      }
    }
  }
  v22 = v2[6];
  v21 = v2[7];
  v23 = v2[4];
  if (v22 + 1 < v23)
    v24 = v22 + 1;
  else
    v24 = 0;
  v2[6] = v24;
  if (v21 < v23)
    v2[7] = v21 + 1;
  return this;
}

uint64_t NRingDropBuffer::operator[](uint64_t a1, const char *a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;

  v2 = *(unsigned int *)a2;
  v3 = *(_DWORD *)(a1 + 28);
  if (v2 >= v3)
    Error::chuck((Error *)"NRingDropBuffer[] - out-of-bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 28), v2);
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 24) + v2 + v4 - v3;
  if (v5 >= v4)
    v6 = *(_DWORD *)(a1 + 16);
  else
    v6 = 0;
  return *(_QWORD *)(a1 + 8) + 24 * (v5 - v6);
}

uint64_t NRingDropBuffer::maxSize(NRingDropBuffer *this)
{
  return (uint64_t)this + 16;
}

uint64_t NDelta::init(uint64_t this, const unsigned int *a2, const unsigned int *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  float v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;

  v3 = this;
  v4 = *a2;
  *(_DWORD *)(this + 4) = *a2;
  v5 = *a3;
  *(_DWORD *)(this + 8) = *a3;
  v6 = (double)((v4 + v4 * v4) * ((4 * v4) | 2u)) / 6.0;
  *(float *)(this + 12) = v6;
  v7 = *(_DWORD *)(this + 40);
  if (v7 != v5)
  {
    v8 = *(_QWORD *)(this + 32);
    *(_DWORD *)(this + 40) = v5;
    this = operator new[]();
    *(_QWORD *)(v3 + 32) = this;
    LODWORD(v9) = *(_DWORD *)(v3 + 8);
    if (v7 >= v9)
      v9 = v9;
    else
      v9 = v7;
    if ((_DWORD)v9)
    {
      v10 = 0;
      if (v9 < 8)
        goto LABEL_11;
      if ((unint64_t)(this - v8) <= 0x1F)
        goto LABEL_11;
      v10 = v9 & 0xFFFFFFF8;
      v11 = (_OWORD *)(this + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v10 != v9)
      {
LABEL_11:
        v15 = v9 - v10;
        v16 = 4 * v10;
        v17 = (_DWORD *)(this + 4 * v10);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
      goto LABEL_15;
    }
    if (v8)
LABEL_15:
      this = MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  }
  *(_BYTE *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 1;
  return this;
}

BOOL NDelta::isFrame(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t a4)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t i;
  unsigned __int32 *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float *v23;
  int32x4_t v25;
  int32x4_t *v26;
  uint64_t v27;

  if (!*(_BYTE *)a1)
    Error::chuck((Error *)"NDelta::isFrame - NDelta::init() has to be called before computing the first frame", (const char *)a2);
  v4 = *(unsigned int *)(a2 + 24);
  v5 = *(_DWORD *)(a1 + 4);
  v6 = v5 + 1;
  if (v4 >= v5 + 1)
  {
    if (!(_DWORD)v4)
      Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, a3, *(double *)a4.i64, 0, 0);
    v7 = *(_QWORD *)(a2 + 8);
    v8 = *(unsigned int *)(v7 + 32);
    if ((_DWORD)v8 != *(_DWORD *)(a1 + 8))
      Error::chuck((Error *)"NDelta::isFrame - head of the list should have %d elements, not %d", (const char *)a2, *(unsigned int *)(a1 + 8), v8);
    if (!(_DWORD)v8)
      goto LABEL_33;
    if (v5)
    {
      v9 = 0;
      v10 = *(_DWORD *)(a1 + 4);
      do
      {
        if (v10)
        {
          v11 = 0;
          v12 = *(unsigned int *)(a2 + 24);
          a4.i32[0] = 0;
          do
          {
            v13 = 2 * v10;
            v14 = (2 * v10 - v11);
            if ((int)v14 + 1 <= v4)
            {
              if (v14 >= v4)
                Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, v14, *(double *)a4.i64, v4, (v13 - v11));
              v15 = v7;
              if (v13 != v11)
              {
                v15 = v7;
                do
                {
                  v15 = *(_QWORD *)(v15 + 8);
                  --v13;
                }
                while (v11 != v13);
              }
            }
            else
            {
              v15 = v7;
              if ((_DWORD)v4 != 1)
              {
                v16 = v4 - 1;
                v15 = v7;
                do
                {
                  v15 = *(_QWORD *)(v15 + 8);
                  --v16;
                }
                while (v16);
              }
            }
            if (v11 == (_DWORD)v12)
              Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, v15, *(double *)a4.i64, *(unsigned int *)(a2 + 24), v12);
            v17 = v11;
            for (i = *(_QWORD *)(a2 + 8); v17; --v17)
              i = *(_QWORD *)(i + 8);
            a4.f32[0] = a4.f32[0]
                      + (float)((float)(v5 - v11++)
                              * (float)(*(float *)(*(_QWORD *)(i + 24) + 4 * v9)
                                      - *(float *)(*(_QWORD *)(v15 + 24) + 4 * v9)));
            v10 = v5;
          }
          while (v11 != v5);
          v10 = v5;
        }
        else
        {
          a4.i32[0] = 0;
        }
        *(float *)(*(_QWORD *)(a1 + 32) + 4 * v9++) = a4.f32[0] / *(float *)(a1 + 12);
      }
      while (v9 < v8);
      goto LABEL_33;
    }
    v19 = (unsigned __int32 *)(a1 + 12);
    v20 = *(_QWORD *)(a1 + 32);
    if (v8 >= 8 && (v20 >= a1 + 16 || (unint64_t)v19 >= v20 + 4 * v8))
    {
      v21 = v8 & 0xFFFFFFF8;
      a4.i32[0] = *v19;
      v25 = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vdivq_f32((float32x4_t)0, a4), 0);
      v26 = (int32x4_t *)(v20 + 16);
      v27 = v21;
      do
      {
        v26[-1] = v25;
        *v26 = v25;
        v26 += 2;
        v27 -= 8;
      }
      while (v27);
      if (v21 == v8)
        goto LABEL_33;
    }
    else
    {
      v21 = 0;
    }
    v22 = v8 - v21;
    v23 = (float *)(v20 + 4 * v21);
    do
    {
      *v23++ = 0.0 / *(float *)v19;
      --v22;
    }
    while (v22);
LABEL_33:
    *(_BYTE *)(a1 + 16) = 1;
  }
  return v4 >= v6;
}

uint64_t NDelta::getFrame(NDelta *this, const char *a2)
{
  if (!*((_BYTE *)this + 16))
    Error::chuck((Error *)"NDelta::getFrame - called NDelta::getFrame while no available frame", a2);
  return (uint64_t)this + 24;
}

uint64_t NDynamicMFCC::init(NDynamicMFCC *this, const unsigned int *a2, const unsigned int *a3, const unsigned int *a4)
{
  uint64_t result;

  *((_DWORD *)this + 30) = *a4;
  *((_DWORD *)this + 24) = *a2;
  *((_DWORD *)this + 25) = *a3;
  result = NDynamicMFCC::reset(this);
  *((_BYTE *)this + 25) = 1;
  return result;
}

uint64_t NDynamicMFCC::reset(NDynamicMFCC *this)
{
  int v2;
  const unsigned int *v3;
  int v4;
  const unsigned int *v5;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t i;
  uint64_t j;

  v3 = (const unsigned int *)((char *)this + 96);
  v2 = *((_DWORD *)this + 24);
  v5 = (const unsigned int *)((char *)this + 100);
  v4 = *((_DWORD *)this + 25);
  *((_DWORD *)this + 28) = v4 + v2;
  *((_DWORD *)this + 29) = v2;
  *((_DWORD *)this + 26) = v2;
  *((_DWORD *)this + 27) = v4;
  NDelta::init((uint64_t)this + 128, (const unsigned int *)this + 24, (const unsigned int *)this + 30);
  result = NDelta::init((uint64_t)(v3 + 20), v5, v3 + 6);
  v7 = 3 * v3[6];
  v8 = *(v3 - 20);
  if (v8 != v7)
  {
    v9 = *((_QWORD *)this + 1);
    *((_DWORD *)this + 4) = v7;
    result = operator new[]();
    *((_QWORD *)this + 1) = result;
    if (v8 >= v7)
      v10 = v7;
    else
      v10 = v8;
    if ((_DWORD)v10)
    {
      if (v10 >= 8 && (unint64_t)(result - v9) > 0x1F)
      {
        v12 = v10 & 0xFFFFFFF8;
        v13 = (_OWORD *)(result + 16);
        v14 = (__int128 *)(v9 + 16);
        v15 = v12;
        do
        {
          v16 = *v14;
          *(v13 - 1) = *(v14 - 1);
          *v13 = v16;
          v13 += 2;
          v14 += 2;
          v15 -= 8;
        }
        while (v15);
        if (v12 == v10)
          goto LABEL_18;
      }
      else
      {
        v12 = 0;
      }
      v17 = v10 - v12;
      v18 = 4 * v12;
      v19 = (_DWORD *)(result + 4 * v12);
      v20 = (int *)(v9 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
LABEL_18:
      result = MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
      goto LABEL_19;
    }
    if (v9)
      goto LABEL_18;
  }
LABEL_19:
  for (i = *((_QWORD *)this + 5); i; i = *((_QWORD *)this + 5))
  {
    *((_QWORD *)this + 5) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(char *))(*((_QWORD *)this + 4) + 72))((char *)this + 32);
  }
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  for (j = *((_QWORD *)this + 9); j; j = *((_QWORD *)this + 9))
  {
    *((_QWORD *)this + 9) = *(_QWORD *)(j + 8);
    result = (*(uint64_t (**)(char *))(*((_QWORD *)this + 8) + 72))((char *)this + 64);
  }
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_BYTE *)this + 24) = 0;
  return result;
}

BOOL NDynamicMFCC::isFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  float32x4_t v8;
  uint64_t v9;
  _BOOL8 result;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  unsigned int v16;

  if (!*(_BYTE *)(a1 + 25))
    Error::chuck((Error *)"NDynamicMFCC::isFrame() - NDynamicMFCC::init() has to be called before starting computing frames", (const char *)a2);
  v3 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v3 != *(_DWORD *)(a1 + 120))
    Error::chuck((Error *)"NDynamicMFCC::isFrame() - input length should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 120), v3);
  v5 = *(_DWORD *)(a1 + 96);
  v4 = *(_DWORD *)(a1 + 100);
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 64))(a1 + 32);
  v9 = *(_QWORD *)(a1 + 40);
  if (v9)
    *(_QWORD *)(v6 + 8) = v9;
  else
    *(_QWORD *)(a1 + 48) = v6;
  *(_QWORD *)(a1 + 40) = v6;
  ++*(_DWORD *)(a1 + 56);
  result = NDelta::isFrame(a1 + 128, a1 + 32, v7, v8);
  if (result)
  {
    if (!*(_BYTE *)(a1 + 144))
      goto LABEL_25;
    v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 64) + 64))(a1 + 64, a1 + 152);
    v15 = *(_QWORD *)(a1 + 72);
    if (v15)
      *(_QWORD *)(v12 + 8) = v15;
    else
      *(_QWORD *)(a1 + 80) = v12;
    *(_QWORD *)(a1 + 72) = v12;
    ++*(_DWORD *)(a1 + 88);
    result = NDelta::isFrame(a1 + 176, a1 + 64, v13, v14);
    if (result)
    {
      v16 = v4 + 2 * v5 + 1;
      while (*(_DWORD *)(a1 + 56) > v16)
      {
        if (!*(_QWORD *)(a1 + 40))
LABEL_22:
          Error::chuck((Error *)"NLinkedList::removeTail Attempted to remove tail of empty list", v11);
        (**(void (***)(uint64_t, _QWORD))(a1 + 32))(a1 + 32, *(_QWORD *)(a1 + 48));
      }
      while (*(_DWORD *)(a1 + 88) > ((2 * v4) | 1u))
      {
        if (!*(_QWORD *)(a1 + 72))
          goto LABEL_22;
        (**(void (***)(uint64_t, _QWORD))(a1 + 64))(a1 + 64, *(_QWORD *)(a1 + 80));
      }
      if (*(_BYTE *)(a1 + 192))
      {
        NDynamicMFCC::makeFrame(a1, a1 + 200);
        result = 1;
        *(_BYTE *)(a1 + 24) = 1;
        return result;
      }
LABEL_25:
      Error::chuck((Error *)"NDelta::getFrame - called NDelta::getFrame while no available frame", v11);
    }
  }
  return result;
}

float NDynamicMFCC::makeFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float result;
  uint64_t v8;
  int i;
  uint64_t v10;
  uint64_t v11;
  uint64_t j;

  v2 = *(unsigned int *)(a1 + 120);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = *(unsigned int *)(a1 + 112);
    v5 = *(unsigned int *)(a1 + 56);
    v6 = *(_QWORD *)(a2 + 8);
    do
    {
      if (v4 >= v5)
        Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, v5, v4);
      v8 = *(_QWORD *)(a1 + 40);
      for (i = v4; i; --i)
        v8 = *(_QWORD *)(v8 + 8);
      v10 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)(v10 + 4 * v3) = *(_DWORD *)(*(_QWORD *)(v8 + 24) + 4 * v3);
      v11 = *(unsigned int *)(a1 + 116);
      if (v11 >= *(_DWORD *)(a1 + 88))
        Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, *(unsigned int *)(a1 + 88), v11);
      for (j = *(_QWORD *)(a1 + 72); (_DWORD)v11; LODWORD(v11) = v11 - 1)
        j = *(_QWORD *)(j + 8);
      *(_DWORD *)(v10 + 4 * (v2 + v3)) = *(_DWORD *)(*(_QWORD *)(j + 24) + 4 * v3);
      result = *(float *)(v6 + 4 * v3);
      *(float *)(v10 + 4 * (2 * v2 + v3++)) = result;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t NDynamicMFCC::finish(NDynamicMFCC *this, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float32x4_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x4_t v20;
  uint64_t v21;

  if (!*((_BYTE *)this + 25))
    Error::chuck((Error *)"NDynamicMFCC::finish() - NDynamicMFCC::init() has to be called before finishing", a2);
  if (*((_DWORD *)this + 26) && *((_BYTE *)this + 24))
  {
    v3 = *((_QWORD *)this + 5);
    if (v3)
    {
      v4 = (*(uint64_t (**)(char *, uint64_t))(*((_QWORD *)this + 4) + 64))((char *)this + 32, v3 + 16);
      v7 = *((_QWORD *)this + 5);
      if (v7)
        *(_QWORD *)(v4 + 8) = v7;
      else
        *((_QWORD *)this + 6) = v4;
      *((_QWORD *)this + 5) = v4;
      ++*((_DWORD *)this + 14);
      NDelta::isFrame((uint64_t)this + 128, (uint64_t)this + 32, v5, v6);
      if (*((_BYTE *)this + 144))
      {
        v13 = (*(uint64_t (**)(char *, char *))(*((_QWORD *)this + 8) + 64))((char *)this + 64, (char *)this + 152);
        v16 = *((_QWORD *)this + 9);
        if (v16)
          *(_QWORD *)(v13 + 8) = v16;
        else
          *((_QWORD *)this + 10) = v13;
        *((_QWORD *)this + 9) = v13;
        ++*((_DWORD *)this + 22);
        NDelta::isFrame((uint64_t)this + 176, (uint64_t)this + 64, v14, v15);
        if (*((_BYTE *)this + 192))
        {
          NDynamicMFCC::makeFrame((uint64_t)this, (uint64_t)this + 200);
          result = 0;
          --*((_DWORD *)this + 26);
          return result;
        }
      }
LABEL_28:
      Error::chuck((Error *)"NDelta::getFrame - called NDelta::getFrame while no available frame", v12);
    }
LABEL_29:
    Error::chuck((Error *)"NLinkedList::head() - cannot access head of empty list", a2);
  }
  if (!*((_DWORD *)this + 27) || !*((_BYTE *)this + 24))
  {
    NDynamicMFCC::reset(this);
    return 1;
  }
  v8 = *((_QWORD *)this + 5);
  if (!v8)
    goto LABEL_29;
  v9 = (*(uint64_t (**)(char *, uint64_t))(*((_QWORD *)this + 4) + 64))((char *)this + 32, v8 + 16);
  v10 = *((_QWORD *)this + 5);
  if (v10)
    *(_QWORD *)(v9 + 8) = v10;
  else
    *((_QWORD *)this + 6) = v9;
  *((_QWORD *)this + 5) = v9;
  ++*((_DWORD *)this + 14);
  v17 = *((_QWORD *)this + 9);
  if (!v17)
    goto LABEL_29;
  v18 = (*(uint64_t (**)(char *, uint64_t))(*((_QWORD *)this + 8) + 64))((char *)this + 64, v17 + 16);
  v21 = *((_QWORD *)this + 9);
  if (v21)
    *(_QWORD *)(v18 + 8) = v21;
  else
    *((_QWORD *)this + 10) = v18;
  *((_QWORD *)this + 9) = v18;
  ++*((_DWORD *)this + 22);
  NDelta::isFrame((uint64_t)this + 176, (uint64_t)this + 64, v19, v20);
  if (!*((_BYTE *)this + 192))
    goto LABEL_28;
  NDynamicMFCC::makeFrame((uint64_t)this, (uint64_t)this + 200);
  result = 0;
  --*((_DWORD *)this + 27);
  return result;
}

uint64_t NDynamicMFCC::getFrame(uint64_t this, const char *a2)
{
  if (!*(_BYTE *)(this + 24))
    Error::chuck((Error *)"NDynamicMFCC::getFrame() - no frame available", a2);
  return this;
}

uint64_t nextPowerOf2(int *a1)
{
  int v1;
  uint64_t v2;
  uint64_t result;

  v1 = *a1;
  v2 = 1;
  do
  {
    result = v2;
    v2 = (2 * v2);
  }
  while ((int)result < v1);
  return result;
}

unsigned int *AccelMelFilter::init(AccelMelFilter *this, const char *a2, const unsigned int *a3, const unsigned int *a4, const float *a5, float *a6, float *a7, float *a8)
{
  int v8;
  uint64_t v9;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _OWORD *v21;
  __int128 *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  int *v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD *v40;
  __int128 *v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  int *v47;
  int v48;
  unsigned int *result;
  uint64_t (**v50)();
  uint64_t v51;
  int v52;
  uint64_t (**v53)();
  uint64_t v54;
  int v55;
  uint64_t (**v56)();
  uint64_t v57;
  int v58;

  v8 = *(_DWORD *)a2;
  v9 = *a3;
  if (*(_DWORD *)a2 > v9)
    Error::chuck((Error *)"AccelMelFilter::init - NUMCHANS %d > %d spectral samples", a2, *(unsigned int *)a2, v9);
  *(_DWORD *)this = v8;
  *((_DWORD *)this + 1) = *a3;
  *((_DWORD *)this + 2) = *a4;
  v15 = *((_DWORD *)this + 8);
  if (v15 != v8)
  {
    v16 = *((_QWORD *)this + 3);
    *((_DWORD *)this + 8) = v8;
    v17 = operator new[]();
    *((_QWORD *)this + 3) = v17;
    LODWORD(v18) = *(_DWORD *)this;
    if (v15 >= *(_DWORD *)this)
      v18 = v18;
    else
      v18 = v15;
    if ((_DWORD)v18)
    {
      if (v18 >= 8 && (unint64_t)(v17 - v16) > 0x1F)
      {
        v20 = v18 & 0xFFFFFFF8;
        v21 = (_OWORD *)(v17 + 16);
        v22 = (__int128 *)(v16 + 16);
        v23 = v20;
        do
        {
          v24 = *v22;
          *(v21 - 1) = *(v22 - 1);
          *v21 = v24;
          v21 += 2;
          v22 += 2;
          v23 -= 8;
        }
        while (v23);
        if (v20 == v18)
          goto LABEL_19;
      }
      else
      {
        v20 = 0;
      }
      v25 = v18 - v20;
      v26 = 4 * v20;
      v27 = (_DWORD *)(v17 + 4 * v20);
      v28 = (int *)(v16 + v26);
      do
      {
        v29 = *v28++;
        *v27++ = v29;
        --v25;
      }
      while (v25);
LABEL_19:
      MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
      goto LABEL_20;
    }
    if (v16)
      goto LABEL_19;
  }
LABEL_20:
  NArray<NArray<float>>::resize((uint64_t)this + 40, this);
  v56 = &off_24C7F3090;
  v57 = 0;
  v58 = 0;
  v53 = &off_24C7F3090;
  v54 = 0;
  v55 = 0;
  v50 = &off_24C7F3090;
  v51 = 0;
  v52 = 0;
  if (*(_DWORD *)this == -2)
  {
    v30 = 0;
    v31 = -1;
  }
  else
  {
    v55 = *(_DWORD *)this + 2;
    v30 = operator new[]();
    v54 = v30;
    v31 = *(_DWORD *)this + 1;
    if (*(_DWORD *)this == -1)
    {
      v32 = 0;
LABEL_25:
      v33 = 0;
      v34 = -1;
      goto LABEL_27;
    }
  }
  v52 = v31;
  v32 = operator new[]();
  v51 = v32;
  if (*(_DWORD *)this == -1)
    goto LABEL_25;
  v58 = *(_DWORD *)this + 1;
  v33 = operator new[]();
  v57 = v33;
  v34 = *(_DWORD *)this;
LABEL_27:
  v35 = *((_DWORD *)this + 20);
  if (v35 == v34)
    goto LABEL_42;
  v36 = *((_QWORD *)this + 9);
  *((_DWORD *)this + 20) = v34;
  v37 = operator new[]();
  *((_QWORD *)this + 9) = v37;
  LODWORD(v38) = *(_DWORD *)this;
  if (v35 >= *(_DWORD *)this)
    v38 = v38;
  else
    v38 = v35;
  if ((_DWORD)v38)
  {
    v39 = 0;
    if (v38 < 8)
      goto LABEL_37;
    if ((unint64_t)(v37 - v36) <= 0x1F)
      goto LABEL_37;
    v39 = v38 & 0xFFFFFFF8;
    v40 = (_OWORD *)(v37 + 16);
    v41 = (__int128 *)(v36 + 16);
    v42 = v39;
    do
    {
      v43 = *v41;
      *(v40 - 1) = *(v41 - 1);
      *v40 = v43;
      v40 += 2;
      v41 += 2;
      v42 -= 8;
    }
    while (v42);
    if (v39 != v38)
    {
LABEL_37:
      v44 = v38 - v39;
      v45 = 4 * v39;
      v46 = (_DWORD *)(v37 + 4 * v39);
      v47 = (int *)(v36 + v45);
      do
      {
        v48 = *v47++;
        *v46++ = v48;
        --v44;
      }
      while (v44);
    }
  }
  else if (!v36)
  {
    goto LABEL_42;
  }
  MEMORY[0x212BAC9C0](v36, 0x1000C8052888210);
LABEL_42:
  AccelMelFilter::setPoints((unsigned int *)this, (const char *)a5, a6, a7, a8, (uint64_t)&v56, (uint64_t)&v53, (uint64_t)&v50);
  result = AccelMelFilter::setFilters((unsigned int *)this, (uint64_t)&v56, (uint64_t)&v53, (uint64_t)&v50);
  *((_BYTE *)this + 12) = 1;
  if (v32)
    result = (unsigned int *)MEMORY[0x212BAC9C0](v32, 0x1000C8052888210);
  if (v30)
    result = (unsigned int *)MEMORY[0x212BAC9C0](v30, 0x1000C8052888210);
  if (v33)
    JUMPOUT(0x212BAC9C0);
  return result;
}

void sub_20D98AC68(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NArray<NArray<float>>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 24 * v3;
  result = operator new[]();
  *(_QWORD *)result = 24;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = result + 16;
    if ((unint64_t)(v7 - 24) >= 0x18)
    {
      v10 = (v7 - 24) / 0x18uLL + 1;
      v11 = result + 32;
      v12 = v10 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(_QWORD *)(v11 - 16) = &off_24C7F3090;
        *(_QWORD *)(v11 - 8) = 0;
        *(_QWORD *)(v11 + 8) = &off_24C7F3090;
        *(_QWORD *)(v11 + 16) = 0;
        *(_DWORD *)v11 = 0;
        *(_DWORD *)(v11 + 24) = 0;
        v11 += 48;
        v12 -= 2;
      }
      while (v12);
      if (v10 == (v10 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_9;
      v9 = v8 + 24 * (v10 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v9 = &off_24C7F3090;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      v9 += 24;
    }
    while (v9 != v8 + 24 * v3);
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v8;
  if ((_DWORD)v2 && *a2)
  {
    v13 = 0;
    v14 = 1;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 8) + v13) + 16))(*(_QWORD *)(v5 + 8) + v13, v6 + v13);
      if (v14 >= v2)
        break;
      v13 += 24;
    }
    while (v14++ < *a2);
  }
  if (v6)
  {
    v16 = *(_QWORD *)(v6 - 8);
    if (v16)
    {
      v17 = 24 * v16;
      do
      {
        *(_QWORD *)(v6 + v17 - 24) = &off_24C7F3090;
        v18 = *(_QWORD *)(v6 + v17 - 16);
        if (v18)
          MEMORY[0x212BAC9C0](v18, 0x1000C8052888210);
        v17 -= 24;
      }
      while (v17);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

void AccelMelFilter::setPoints(unsigned int *a1, const char *a2, float *a3, float *a4, float *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  double v21;
  float v22;
  const char *v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  float v28;
  unsigned int v29;
  float v30;
  uint64_t v31;
  unsigned int v32;
  unint64_t v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  float *v40;
  float *v41;
  uint64_t v42;
  float *v43;
  float v44;
  float v45;
  float v46;
  const char *v47;

  v15 = *(float *)a2;
  v16 = 0.0;
  if (*(float *)a2 >= 0.0)
  {
    v17 = v15 / 700.0 + 1.0;
    v16 = log10f(v17) * 2595.0;
  }
  v18 = *a3;
  if (*a3 >= 0.0)
  {
    v21 = v18;
    v19 = a1[2];
    v20 = (float)v19;
    if ((float)v19 + 1.0 < v18)
      Error::chuck((Error *)"NMelFilter::setPoints() - HIFREQ %f > NYQUIST %d", a2, v18, a1[2]);
    if (v18 <= v20)
    {
      if (v15 >= v18)
        Error::chuck((Error *)"NMelFilter::setPoints() - LOFREQ %f >= HIFREQ %f", a2, v15, *(_QWORD *)&v21);
    }
    else
    {
      v21 = (float)v19;
    }
  }
  else
  {
    v19 = a1[2];
    v20 = (float)v19;
    v21 = (float)v19;
  }
  v22 = v21 / 700.0 + 1.0;
  v24 = log10f(v22);
  if (*a5 > v20)
    Error::chuck((Error *)"NMelFilter::setPoints() - MINBW %f > nyquist %d", v23, *a5, v19);
  v25 = v24 * 2595.0;
  v26 = *a4;
  if (*a4 <= 0.0)
  {
LABEL_27:
    v46 = __exp10f(v25 / 2595.0);
    Error::chuck((Error *)"NMelFilter::setPoints() - freqscale %f -ve or > NYQUIST/HIFREQ (%f/%d)", v47, v26, (float)((float)(v46 + -1.0) * 700.0), a1[2]);
  }
  v27 = *a1;
  v28 = __exp10f(v25 / 2595.0);
  v29 = a1[2];
  if ((float)(v26 * (float)((float)(v28 + -1.0) * 700.0)) * 0.98 > (double)v29)
  {
    v26 = *a4;
    goto LABEL_27;
  }
  if (*a1 == -2)
  {
    v30 = (float)(*a5 / (float)v29) * (float)a1[1];
    v31 = *(_QWORD *)(a7 + 8);
    v32 = -1;
  }
  else
  {
    v33 = 0;
    do
    {
      v34 = (float)(v25 - v16) / ((float)v27 + 1.0);
      v35 = __exp10f((float)(v16 + (float)((float)v33 * v34)) / 2595.0);
      v36 = (float)a1[2];
      v37 = (float)(*a4 * (float)((float)(v35 + -1.0) * 700.0)) / v36;
      v38 = (float)a1[1];
      v31 = *(_QWORD *)(a7 + 8);
      *(float *)(v31 + 4 * v33++) = v37 * v38;
    }
    while (v33 < *a1 + 2);
    v32 = *a1 + 1;
    if (v32 < 2)
      return;
    v30 = (float)(*a5 / v36) * v38;
  }
  v39 = v32;
  v40 = (float *)(*(_QWORD *)(a6 + 8) + 4);
  v41 = (float *)(*(_QWORD *)(a8 + 8) + 4);
  v42 = v39 - 1;
  v43 = (float *)(v31 + 4);
  do
  {
    *v40 = *(v43 - 1);
    v44 = v43[1];
    *v41 = v44;
    v45 = *v43;
    if ((float)(*v43 - *v40) < v30)
    {
      *v40 = v45 - v30;
      v44 = *v41;
      v45 = *v43;
    }
    if ((float)(v44 - v45) < v30)
      *v41 = v30 + v45;
    ++v40;
    ++v41;
    ++v43;
    --v42;
  }
  while (v42);
}

unsigned int *AccelMelFilter::setFilters(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int *v7;
  uint64_t v8;
  unint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v24;
  int32x2_t v25;
  int32x2_t v26;
  float v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  int32x4_t v32;
  int32x4_t v33;
  int8x16_t *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t *v41;
  unint64_t v42;
  float32x4_t v43;
  float32x4_t v44;
  __int8 *v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v53;
  int v55;
  float v56;
  unint64_t v57;
  int32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  unsigned int v61;
  unint64_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t *v65;
  float32x4_t v66;
  int v67;

  if (*result)
  {
    v7 = result;
    v8 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v66 = _Q0;
    while (1)
    {
      v12 = v8 + 1;
      v13 = 4 * (v8 + 1);
      v14 = *(float *)(*(_QWORD *)(a2 + 8) + v13);
      v15 = *(float *)(*(_QWORD *)(a3 + 8) + v13);
      v16 = *(float *)(*(_QWORD *)(a4 + 8) + v13);
      v17 = (uint64_t)rintf(v14);
      v18 = (uint64_t)rintf(v15);
      v19 = (uint64_t)rintf(v16);
      v20 = v17 & ~((int)v17 >> 31);
      v21 = v7[1] - 1;
      if (v21 >= (int)v19)
        v22 = v19;
      else
        v22 = v21;
      if (v20 > (int)v18 || (int)v22 < (int)v18)
        Error::chuck((Error *)"AccelMelFilter::setFilters() - point locations out of order %d %d %d", (const char *)a2, v17 & ~((int)v17 >> 31), v18, v22);
      *(_DWORD *)(*((_QWORD *)v7 + 3) + 4 * v8) = v20;
      v24 = *((_QWORD *)v7 + 6) + 24 * v8;
      v67 = v22 - v20 + 1;
      result = (unsigned int *)(*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)v24 + 32))(v24, &v67);
      v27 = (float)(int)v18;
      v28 = *(_DWORD *)(*((_QWORD *)v7 + 3) + 4 * v8);
      LODWORD(v29) = v18 - v17;
      v30 = (v28 - v17);
      v31 = v15 > (float)(int)v18;
      if (v15 <= (float)(int)v18)
        v29 = v29;
      else
        v29 = (v29 + 1);
      v32.i64[0] = 0x400000004;
      v32.i64[1] = 0x400000004;
      v33.i64[0] = 0x800000008;
      v33.i64[1] = 0x800000008;
      if (v30 >= v29)
        goto LABEL_24;
      *(float *)v25.i32 = v15 - v14;
      *(float *)v26.i32 = (float)(int)v17 - v14;
      v34 = *(int8x16_t **)(*((_QWORD *)v7 + 6) + 24 * v8 + 8);
      v35 = v29 - v30;
      v36 = (v28 - v17);
      if ((unint64_t)(v29 - v30) < 8)
        goto LABEL_20;
      v37 = v35 & 0xFFFFFFFFFFFFFFF8;
      v38 = vaddq_s32(vdupq_n_s32(v30), (int32x4_t)xmmword_20DA24640);
      v39 = (float32x4_t)vdupq_lane_s32(v26, 0);
      v40 = (float32x4_t)vdupq_lane_s32(v25, 0);
      v41 = v34 + 1;
      v42 = v35 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v43 = vdivq_f32(vaddq_f32(v39, vcvtq_f32_u32((uint32x4_t)v38)), v40);
        v44 = vdivq_f32(vaddq_f32(v39, vcvtq_f32_u32((uint32x4_t)vaddq_s32(v38, v32))), v40);
        v41[-1] = vbicq_s8((int8x16_t)v43, (int8x16_t)vcltzq_f32(v43));
        *v41 = vbicq_s8((int8x16_t)v44, (int8x16_t)vcltzq_f32(v44));
        v38 = vaddq_s32(v38, v33);
        v41 += 2;
        v42 -= 8;
      }
      while (v42);
      if (v35 != v37)
        break;
LABEL_24:
      v47 = (v22 - v18 + 1);
      if (v47 > v31)
      {
        *(float *)v25.i32 = v16 - v15;
        *(float *)v26.i32 = v15 - v27;
        v48 = v15 > v27;
        v49 = *(_QWORD *)(*((_QWORD *)v7 + 6) + 24 * v8 + 8);
        v50 = v47 - v48;
        v51 = ~v48 + v47;
        _CF = (unint64_t)(v47 - v48) >= 8 && v28 + ~(v31 + v18) >= v51;
        v53 = HIDWORD(v51);
        if (!_CF || v53 != 0)
          goto LABEL_32;
        v57 = v50 & 0xFFFFFFFFFFFFFFF8;
        v58 = vaddq_s32(vdupq_n_s32(v31), (int32x4_t)xmmword_20DA24640);
        v59 = (float32x4_t)vdupq_lane_s32(v26, 0);
        v60 = (float32x4_t)vdupq_lane_s32(v25, 0);
        v61 = v31 + v18 - v28;
        v62 = v50 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v63 = vaddq_f32(vdivq_f32(vsubq_f32(v59, vcvtq_f32_u32((uint32x4_t)v58)), v60), v66);
          v64 = vaddq_f32(vdivq_f32(vsubq_f32(v59, vcvtq_f32_u32((uint32x4_t)vaddq_s32(v58, v32))), v60), v66);
          v65 = (int8x16_t *)(v49 + 4 * v61);
          *v65 = vbicq_s8((int8x16_t)v63, (int8x16_t)vcltzq_f32(v63));
          v65[1] = vbicq_s8((int8x16_t)v64, (int8x16_t)vcltzq_f32(v64));
          v58 = vaddq_s32(v58, v33);
          v61 += 8;
          v62 -= 8;
        }
        while (v62);
        if (v50 != v57)
        {
          v48 |= v57;
LABEL_32:
          v55 = v18 - v28;
          do
          {
            v56 = (float)((float)(*(float *)v26.i32 - (float)v48) / *(float *)v25.i32) + 1.0;
            if (v56 < 0.0)
              v56 = 0.0;
            *(float *)(v49 + 4 * (v55 + v48++)) = v56;
          }
          while (v47 != v48);
        }
      }
      ++v8;
      if (v12 >= *v7)
        return result;
    }
    v36 = v37 + v30;
LABEL_20:
    v45 = &v34->i8[-4 * v30];
    do
    {
      v46 = (float)(*(float *)v26.i32 + (float)v36) / *(float *)v25.i32;
      if (v46 < 0.0)
        v46 = 0.0;
      *(float *)&v45[4 * v36++] = v46;
    }
    while (v29 != v36);
    goto LABEL_24;
  }
  return result;
}

float AccelMelFilter::freq2mel(AccelMelFilter *this, const float *a2)
{
  float v2;

  v2 = *a2 / 700.0 + 1.0;
  return log10f(v2) * 2595.0;
}

float AccelMelFilter::mel2freq(AccelMelFilter *this, const float *a2)
{
  return (float)(__exp10f(*a2 / 2595.0) + -1.0) * 700.0;
}

void *AccelMelFilter::run(AccelMelFilter *this, float *a2)
{
  unint64_t v4;
  unint64_t v5;
  size_t v6;

  if (!*((_BYTE *)this + 12))
    Error::chuck((Error *)"AccelMelFilter::run - AccelMelFilter::init() must be called before running", (const char *)a2);
  if (*(_DWORD *)this)
  {
    v4 = 0;
    do
    {
      vDSP_dotpr(&a2[*(unsigned int *)(*((_QWORD *)this + 3) + 4 * v4)], 1, *(const float **)(*((_QWORD *)this + 6) + 24 * v4 + 8), 1, (float *)(*((_QWORD *)this + 9) + 4 * v4), *(unsigned int *)(*((_QWORD *)this + 6) + 24 * v4 + 16));
      ++v4;
      v5 = *(unsigned int *)this;
    }
    while (v4 < v5);
    v6 = 4 * v5;
  }
  else
  {
    v6 = 0;
  }
  return memcpy(a2, *((const void **)this + 9), v6);
}

float AccelMelFilter::getScalingFactor(AccelMelFilter *this)
{
  return 256.0;
}

void AccelCosine::init(AccelCosine *this, const char *a2, const unsigned int *a3, const unsigned int *a4)
{
  int v4;
  uint64_t v5;
  int v8;
  unsigned int *v9;
  int v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v22;
  _OWORD *v23;
  __int128 *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  int *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  uint64_t v41;
  uint64_t v42;
  float32x2_t *v43;
  uint64_t v44;
  int32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  float v48;
  float v49;
  unsigned int v50;
  _DWORD *v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  int32x2_t v58;
  float32x2_t *v59;
  unint64_t v61;
  uint64x2_t v62;
  float32x2_t v63;
  float32x2_t v64;
  float v65;
  float v66;
  float v67;
  float64x2_t v68;
  float64x2_t v69;
  unsigned int v70;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  float v74;
  double v75;
  float v76;
  uint64_t v77;
  float v78;
  float v79;
  __int128 v80;
  float v81;

  v4 = *(_DWORD *)a2;
  v5 = *a3;
  if (*(_DWORD *)a2)
    _ZF = (_DWORD)v5 == 0;
  else
    _ZF = 1;
  if (_ZF)
    Error::chuck((Error *)"AccelCosine::init() - those arguments must be strictly positive : a_iNumChans (=%d), a_iNumCep (=%d)", a2, *(unsigned int *)a2, v5);
  *(_DWORD *)this = v4;
  v8 = *a3;
  *((_DWORD *)this + 1) = *a3;
  v9 = (unsigned int *)((char *)this + 4);
  v10 = *a4;
  *((_DWORD *)this + 10) = v4;
  v11 = (char *)this + 40;
  *((_DWORD *)this + 2) = v10;
  *((_DWORD *)this + 9) = v8;
  NArray<NArray<float>>::resize((uint64_t)this + 16, (_DWORD *)this + 1);
  if (*((_DWORD *)v11 - 1))
  {
    v13 = 0;
    v14 = 0;
    do
    {
      (*(void (**)(uint64_t, char *))(*(_QWORD *)(*((_QWORD *)this + 3) + v13) + 32))(*((_QWORD *)this + 3) + v13, v11);
      ++v14;
      v13 += 24;
    }
    while (v14 < *((unsigned int *)this + 9));
  }
  v15 = *((_DWORD *)this + 16);
  v16 = *((_DWORD *)this + 1);
  if (v15 != v16)
  {
    v17 = *((_QWORD *)this + 7);
    *((_DWORD *)this + 16) = v16;
    v18 = operator new[]();
    *((_QWORD *)this + 7) = v18;
    v19 = *((_DWORD *)this + 1);
    if (v15 >= v19)
      v20 = v19;
    else
      v20 = v15;
    if ((_DWORD)v20)
    {
      if (v20 >= 8 && (unint64_t)(v18 - v17) > 0x1F)
      {
        v22 = v20 & 0xFFFFFFF8;
        v23 = (_OWORD *)(v18 + 16);
        v24 = (__int128 *)(v17 + 16);
        v25 = v22;
        do
        {
          v26 = *v24;
          *(v23 - 1) = *(v24 - 1);
          *v23 = v26;
          v23 += 2;
          v24 += 2;
          v25 -= 8;
        }
        while (v25);
        if (v22 == v20)
          goto LABEL_25;
      }
      else
      {
        v22 = 0;
      }
      v27 = v20 - v22;
      v28 = 4 * v22;
      v29 = (_DWORD *)(v18 + 4 * v22);
      v30 = (int *)(v17 + v28);
      do
      {
        v31 = *v30++;
        *v29++ = v31;
        --v27;
      }
      while (v27);
LABEL_25:
      MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
      v15 = *v9;
      goto LABEL_26;
    }
    if (v17)
      goto LABEL_25;
    v15 = *((_DWORD *)this + 1);
  }
LABEL_26:
  v70 = v15;
  if (v15)
  {
    v32 = *(unsigned int *)this;
    if ((_DWORD)v32)
    {
      v33 = 0;
      v78 = sqrtf(2.0 / (float)v32);
      v35 = *((_QWORD *)this + 3);
      __asm
      {
        FMOV            V13.2S, #1.0
        FMOV            V1.2D, #-0.5
      }
      v72 = _Q1;
      do
      {
        v34 = 3.14159 / (double)v32;
        *(double *)&v12 = (float)(v34 * (float)v33);
        v41 = *(_QWORD *)(v35 + 24 * v33 + 8);
        v80 = v12;
        if (v32 >= 2)
        {
          v43 = *(float32x2_t **)(v35 + 24 * v33 + 8);
          v44 = v32 & 0xFFFFFFFE;
          v45 = (int32x2_t)0x100000000;
          do
          {
            v46 = vcvt_f32_f64(vmulq_n_f64(vaddq_f64(vcvtq_f64_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v45), _D13)), v72), *(double *)&v12));
            v74 = v46.f32[0];
            v76 = cosf(v46.f32[1]);
            v47.f32[0] = cosf(v74);
            v47.f32[1] = v76;
            v12 = v80;
            *v43++ = vmul_n_f32(v47, v78);
            v45 = vadd_s32(v45, (int32x2_t)0x200000002);
            v44 -= 2;
          }
          while (v44);
          v42 = v32 & 0xFFFFFFFE;
          if (v42 == v32)
            goto LABEL_29;
        }
        else
        {
          v42 = 0;
        }
        do
        {
          v48 = ((float)((float)v42 + 1.0) + -0.5) * *(double *)&v12;
          v49 = cosf(v48);
          v12 = v80;
          *(float *)(v41 + 4 * v42++) = v78 * v49;
        }
        while (v32 != v42);
LABEL_29:
        ++v33;
      }
      while (v33 != v15);
    }
  }
  v50 = *((_DWORD *)this + 2);
  v51 = (_DWORD *)*((_QWORD *)this + 7);
  *v51 = 1065354483;
  if (v50)
  {
    v52 = v15;
    if (v15 < 2)
      goto LABEL_48;
    *(double *)&v53 = (float)v50;
    v54 = v15;
    v75 = *(double *)&v53 * 0.5;
    v77 = v53;
    if (v15 == 2)
    {
      v55 = 1;
      goto LABEL_47;
    }
    v56 = v15 - 1;
    v57 = (v70 - 1) & 0xFFFFFFFFFFFFFFFELL;
    v71 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)&v53 * 0.5), 0);
    v73 = (float64x2_t)vdupq_lane_s64(v53, 0);
    v58 = (int32x2_t)0x200000001;
    v59 = (float32x2_t *)(v51 + 1);
    __asm { FMOV            V0.2D, #1.0 }
    v68 = _Q0;
    v69 = (float64x2_t)vdupq_n_s64(0x400921F9F01B866EuLL);
    v61 = (v52 - 1) & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v62.i64[0] = v58.u32[0];
      v62.i64[1] = v58.u32[1];
      v63 = vcvt_f32_f64(vdivq_f64(vmulq_f64(vcvtq_f64_u64(v62), v69), v73));
      v79 = v63.f32[0];
      v81 = sinf(v63.f32[1]);
      v64.f32[0] = sinf(v79);
      v64.f32[1] = v81;
      *v59++ = vcvt_f32_f64(vmlaq_f64(v68, vcvtq_f64_f32(v64), v71));
      v58 = vadd_s32(v58, (int32x2_t)0x200000002);
      v61 -= 2;
    }
    while (v61);
    v53 = v77;
    if (v56 != v57)
    {
      v55 = v56 | 1;
      do
      {
LABEL_47:
        v65 = (double)v55 * 3.14159 / *(double *)&v53;
        v66 = sinf(v65);
        v53 = v77;
        v67 = v75 * v66 + 1.0;
        *(float *)&v51[v55++] = v67;
      }
      while (v54 != v55);
    }
  }
  else if (v15 >= 2)
  {
    memset_pattern16(v51 + 1, &unk_20DA246D0, 4 * (v15 - 2) + 4);
  }
LABEL_48:
  *((_BYTE *)this + 12) = 1;
}

void AccelCosine::dctCoef(AccelCosine *this, double a2, __n128 a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  float **v8;
  float *v9;
  uint64_t v10;
  float32x2_t *v17;
  float32x2_t *v18;
  uint64_t v19;
  int32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  uint64_t v23;
  float v24;
  float v25;
  float64x2_t v26;
  __n128 v27;
  float v28;
  float v29;
  float v30;

  v3 = *((unsigned int *)this + 1);
  if ((_DWORD)v3)
  {
    v4 = *(unsigned int *)this;
    if ((_DWORD)v4)
    {
      v28 = sqrtf(2.0 / (float)v4);
      v5 = 3.14159 / (double)v4;
      v6 = *((_QWORD *)this + 3);
      if (v4 >= 2)
      {
        v10 = 0;
        __asm
        {
          FMOV            V10.2S, #1.0
          FMOV            V0.2D, #-0.5
        }
        v26 = _Q0;
        do
        {
          a3.n128_f64[0] = (float)(v5 * (float)v10);
          v17 = *(float32x2_t **)(v6 + 24 * v10 + 8);
          v18 = v17;
          v19 = v4 & 0xFFFFFFFE;
          v20 = (int32x2_t)0x100000000;
          v27 = a3;
          do
          {
            v21 = vcvt_f32_f64(vmulq_n_f64(vaddq_f64(vcvtq_f64_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v20), _D10)), v26), a3.n128_f64[0]));
            v29 = v21.f32[0];
            v30 = cosf(v21.f32[1]);
            v22.f32[0] = cosf(v29);
            v22.f32[1] = v30;
            a3 = v27;
            *v18++ = vmul_n_f32(v22, v28);
            v20 = vadd_s32(v20, (int32x2_t)0x200000002);
            v19 -= 2;
          }
          while (v19);
          if ((v4 & 0xFFFFFFFE) != v4)
          {
            v23 = v4 & 0xFFFFFFFE;
            do
            {
              v24 = ((float)((float)v23 + 1.0) + -0.5) * a3.n128_f64[0];
              v25 = cosf(v24);
              a3 = v27;
              v17->f32[v23++] = v28 * v25;
            }
            while (v4 != v23);
          }
          ++v10;
        }
        while (v10 != v3);
      }
      else
      {
        v7 = 0;
        v8 = (float **)(v6 + 8);
        do
        {
          v9 = *v8;
          v8 += 3;
          *v9 = v28 * cosf((float)(v5 * (float)v7++) * 0.5);
        }
        while (v3 != v7);
      }
    }
  }
}

void AccelCosine::lifterCoef(AccelCosine *this)
{
  _DWORD *v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int32x2_t v7;
  float32x2_t *v8;
  unint64_t v14;
  uint64x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float v18;
  float v19;
  float v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  double v25;
  uint64_t v26;
  float v27;
  float v28;

  v1 = (_DWORD *)*((_QWORD *)this + 7);
  *v1 = 1065354483;
  v3 = *((unsigned int *)this + 1);
  v2 = *((_DWORD *)this + 2);
  if (v2)
  {
    if (v3 < 2)
      return;
    *(double *)&v4 = (float)v2;
    v25 = *(double *)&v4 * 0.5;
    v26 = v4;
    if ((_DWORD)v3 == 2)
    {
      v5 = 1;
      goto LABEL_11;
    }
    v6 = v3 - 1;
    v23 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)&v4 * 0.5), 0);
    v24 = (float64x2_t)vdupq_lane_s64(v4, 0);
    v7 = (int32x2_t)0x200000001;
    v8 = (float32x2_t *)(v1 + 1);
    __asm { FMOV            V0.2D, #1.0 }
    v21 = _Q0;
    v22 = (float64x2_t)vdupq_n_s64(0x400921F9F01B866EuLL);
    v14 = (v3 - 1) & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v15.i64[0] = v7.u32[0];
      v15.i64[1] = v7.u32[1];
      v16 = vcvt_f32_f64(vdivq_f64(vmulq_f64(vcvtq_f64_u64(v15), v22), v24));
      v27 = v16.f32[0];
      v28 = sinf(v16.f32[1]);
      v17.f32[0] = sinf(v27);
      v17.f32[1] = v28;
      *v8++ = vcvt_f32_f64(vmlaq_f64(v21, vcvtq_f64_f32(v17), v23));
      v7 = vadd_s32(v7, (int32x2_t)0x200000002);
      v14 -= 2;
    }
    while (v14);
    v4 = v26;
    if (v6 != ((v3 - 1) & 0xFFFFFFFFFFFFFFFELL))
    {
      v5 = v6 | 1;
      do
      {
LABEL_11:
        v18 = (double)v5 * 3.14159 / *(double *)&v4;
        v19 = sinf(v18);
        v4 = v26;
        v20 = v25 * v19 + 1.0;
        *(float *)&v1[v5++] = v20;
      }
      while (v3 != v5);
    }
  }
  else if (v3 >= 2)
  {
    memset_pattern16(v1 + 1, &unk_20DA246D0, 4 * (v3 - 2) + 4);
  }
}

float AccelCosine::run(unsigned int *a1, float *__A, uint64_t a3)
{
  uint64_t v5;
  unint64_t v7;
  uint64_t v8;
  float result;
  float __C;

  if (!*((_BYTE *)a1 + 12))
    Error::chuck((Error *)"AccelCosine::run() - AccelCosine::init() has to be called before running", (const char *)__A);
  v5 = *(unsigned int *)(a3 + 16);
  if ((_DWORD)v5 != a1[1])
    Error::chuck((Error *)"AccelCosine::run() - length of output should be %d, not %d", (const char *)__A, a1[1], v5);
  if ((_DWORD)v5)
  {
    v7 = 0;
    v8 = 8;
    do
    {
      __C = 0.0;
      vDSP_dotpr(__A, 1, *(const float **)(*((_QWORD *)a1 + 3) + v8), 1, &__C, *a1);
      result = *(float *)(*((_QWORD *)a1 + 7) + 4 * v7) * __C;
      *(float *)(*(_QWORD *)(a3 + 8) + 4 * v7++) = result;
      v8 += 24;
    }
    while (v7 < a1[1]);
  }
  return result;
}

uint64_t AccelPSD::init(uint64_t this, const unsigned int *a2, const BOOL *a3)
{
  *(_DWORD *)(this + 8) = *a2;
  *(_BYTE *)(this + 12) = *a3;
  *(_DWORD *)this = 0;
  *(_BYTE *)(this + 4) = 1;
  return this;
}

uint64_t AccelPSD::fixp_sqrt(AccelPSD *this, int a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  _BOOL4 v47;
  int v48;
  int v49;
  int v50;
  _BOOL4 v51;
  int v52;
  int v53;
  int v54;
  _BOOL4 v55;
  int v56;
  int v57;
  int v58;
  _BOOL4 v59;

  v2 = a2 > 0x40000000;
  if (a2 <= 0x40000000)
    v3 = 0;
  else
    v3 = -1073741824;
  v4 = v3 + a2;
  v5 = v2 << 16;
  v6 = (v2 << 30) | 0x10000000;
  v7 = v6 < v4;
  if (v6 >= v4)
    v6 = 0;
  v8 = v4 - v6;
  v9 = v5 | (v7 << 15);
  v10 = (((v9 >> 15) & 3) << 28) | 0x4000000;
  v11 = v10 < v8;
  if (v10 >= v8)
    v10 = 0;
  v12 = v8 - v10;
  v13 = v9 | (v11 << 14);
  v14 = (((v13 >> 14) & 7) << 26) | 0x1000000;
  v15 = v14 < v12;
  if (v14 >= v12)
    v14 = 0;
  v16 = v12 - v14;
  v17 = v13 | (v15 << 13);
  v18 = (((v17 >> 13) & 0xF) << 24) | 0x400000;
  v19 = v18 < v16;
  if (v18 >= v16)
    v18 = 0;
  v20 = v16 - v18;
  v21 = v17 | (v19 << 12);
  v22 = ((unsigned __int16)(v21 >> 12) << 22) | 0x100000;
  v23 = v22 < v20;
  if (v22 >= v20)
    v22 = 0;
  v24 = v20 - v22;
  v25 = v21 | (v23 << 11);
  v26 = (v25 << 9) | 0x40000;
  v27 = v26 < v24;
  if (v26 >= v24)
    v26 = 0;
  v28 = v24 - v26;
  v29 = v25 | (v27 << 10);
  v30 = (v29 << 8) + 0x10000;
  v31 = v30 < v28;
  if (v30 >= v28)
    v30 = 0;
  v32 = v28 - v30;
  v33 = v29 | (v31 << 9);
  v34 = (v33 << 7) + 0x4000;
  v35 = v34 < v32;
  if (v34 >= v32)
    v34 = 0;
  v36 = v32 - v34;
  v37 = v33 | (v35 << 8);
  v38 = (v37 << 6) + 4096;
  v39 = v38 < v36;
  if (v38 >= v36)
    v38 = 0;
  v40 = v36 - v38;
  v41 = v37 | (v39 << 7);
  v42 = 32 * v41 + 1024;
  v43 = v42 < v40;
  if (v42 >= v40)
    v42 = 0;
  v44 = v40 - v42;
  v45 = v41 | (v43 << 6);
  v46 = 16 * v45 + 256;
  v47 = v46 < v44;
  if (v46 >= v44)
    v46 = 0;
  v48 = v44 - v46;
  v49 = v45 | (32 * v47);
  v50 = 8 * v49 + 64;
  v51 = v50 < v48;
  if (v50 >= v48)
    v50 = 0;
  v52 = v48 - v50;
  v53 = v49 | (16 * v51);
  v54 = 4 * v53 + 16;
  v55 = v54 < v52;
  if (v54 >= v52)
    v54 = 0;
  v56 = v52 - v54;
  v57 = v53 | (8 * v55);
  v58 = 2 * v57 + 4;
  v59 = v58 < v56;
  if (v58 >= v56)
    v58 = 0;
  return (((v57 | (4 * v59)) + 1 < v56 - v58) << 16) | ((v57 | (4 * v59)) << 15);
}

uint64_t AccelPSD::fixp_sqrt_range(AccelPSD *this, const int *a2, const int *a3, int a4, char a5)
{
  int v5;
  int v6;
  unsigned int v7;
  char v8;
  char v9;
  BOOL v10;
  char v11;

  v5 = (*a2 >> 31) & -*a2 | *a2 & ~(*a2 >> 31);
  v6 = (*a3 >> 31) & -*a3 | *a3 & ~(*a3 >> 31);
  v7 = (v5 >> 14) * (v5 >> 14) + (v6 >> 14) * (v6 >> 14);
  if (v7)
  {
    v8 = -1;
    do
    {
      v9 = v8++;
      v10 = v7 > 3;
      v7 >>= 2;
    }
    while (v10);
    v11 = ~v8;
    v5 = ((v5 >> v8) + 1) >> 1;
    v6 = ((v6 >> v8) + 1) >> 1;
    a4 = ((a4 >> (2 * (v9 + 2) - 1)) + 1) >> 1;
  }
  else
  {
    v11 = 0;
  }
  return ((int)AccelPSD::fixp_sqrt(this, v6 * v6 + v5 * v5 + a4) >> (a5 + v11 + 16));
}

void AccelPSD::run(AccelPSD *this, DSPSplitComplex *__A)
{
  float *realp;
  float *imagp;
  float v6;
  float *v7;
  vDSP_Length v8;
  int v9;
  float __B;

  if (!*((_BYTE *)this + 4))
    Error::chuck((Error *)"AccelPSD::run() - AccelPSD::init() has to be called before runing", (const char *)__A);
  __B = 1.0;
  realp = __A->realp;
  imagp = __A->imagp;
  v6 = *imagp;
  *imagp = 0.0;
  vDSP_zvmags(__A, 1, realp, 1, (*((_DWORD *)this + 2) - 1));
  v7 = __A->realp;
  v8 = *((unsigned int *)this + 2);
  __A->realp[(v8 - 1)] = v6 * v6;
  vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
  if (!*((_BYTE *)this + 12))
  {
    v9 = *((_DWORD *)this + 2);
    vvsqrtf(__A->realp, __A->realp, &v9);
  }
}

float AccelPSD::getScalingFactor(AccelPSD *this)
{
  char v1;

  if (*((_BYTE *)this + 12))
    v1 = 2 * *(_BYTE *)this + 16;
  else
    v1 = *(_DWORD *)this;
  return 256.0 / (float)(1 << v1);
}

uint64_t NWavChunk2HTKFrames::init(NWavChunk2HTKFrames *this, const NString *a2, unsigned int *a3, const BOOL *a4, const BOOL *a5)
{
  char *v9;
  const NString *v10;
  const char *v11;
  double v12;
  unsigned int v13;
  const BOOL *v14;
  _DWORD *v15;
  unsigned int v16;
  uint64_t result;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  _OWORD *v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  _OWORD *v34;
  int v35;
  int v36;
  int v37;

  v9 = (char *)this + 936;
  v10 = (NWavChunk2HTKFrames *)((char *)this + 808);
  if ((NWavChunk2HTKFrames *)((char *)this + 808) != a2)
    (*(void (**)(char *, _QWORD, char *))(*(_QWORD *)v10 + 64))((char *)this + 808, *((_QWORD *)a2 + 2), (char *)a2 + 8);
  v35 = 10;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 104) + 64))((char *)this + 832, "MFCC_D_A_0", &v35);
  v36 = 8;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 107) + 64))((char *)this + 856, "WAVEFORM", &v36);
  v37 = 3;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 110) + 64))((char *)this + 880, "WAV", &v37);
  *((_QWORD *)this + 113) = 0x47C3500000000000;
  *((_WORD *)this + 456) = 0;
  *((_DWORD *)this + 229) = 1243365376;
  *((_BYTE *)this + 920) = 1;
  *((_DWORD *)this + 231) = 1064849900;
  *((_WORD *)this + 464) = 0;
  *((_BYTE *)this + 930) = 0;
  *((_DWORD *)this + 233) = 26;
  *((_DWORD *)this + 238) = 12;
  *((_DWORD *)this + 240) = 22;
  *(_QWORD *)(v9 + 28) = 0x3F80000000000000;
  *(_OWORD *)v9 = xmmword_20DA24650;
  *((_BYTE *)this + 984) = 1;
  *(_QWORD *)(v9 + 52) = 0x200000002;
  *((_BYTE *)this + 801) = 0;
  *((_BYTE *)this + 956) = 1;
  NWavChunk2HTKFrames::loadCfg(this, v10, a5);
  *((_BYTE *)this + 801) = *a4;
  v13 = *a3;
  if (!*a3)
    Error::chuck((Error *)"NWavChunk2HTKFrames::changeSamRate - a_iSampleRate = %d has to be strictly positive", v11, 0);
  v14 = (const BOOL *)this + 929;
  v15 = (_DWORD *)((char *)this + 952);
  *((_DWORD *)this + 243) = v13;
  *(float *)&v12 = (float)(*((float *)this + 227) * (float)v13) / 10000000.0;
  *((_DWORD *)this + 244) = (float)((float)(*((float *)this + 229) * (float)v13) / 10000000.0);
  if (*(float *)&v12 <= 1)
    v16 = 1;
  else
    v16 = *(float *)&v12;
  *((_DWORD *)this + 245) = v16;
  if (*((_BYTE *)this + 956))
    ++*v15;
  if (*v14)
    *v15 = *((_DWORD *)this + 233);
  AccelStaticMFCC::init((NWavChunk2HTKFrames *)((char *)this + 48), (const char *)this + 980, (unsigned int *)this + 243, (unsigned int *)this + 244, (const BOOL *)this + 920, (float *)this + 231, (const BOOL *)this + 928, v14, v12, (const BOOL *)this + 930, (const unsigned int *)this + 233, (const float *)v9, (const float *)this + 235, (const unsigned int *)this + 240, (const unsigned int *)this + 238, (const float *)v9 + 7, (const float *)this + 242, (const float *)this + 236, (const float *)this + 237);
  *((_DWORD *)this + 174) = *((_DWORD *)this + 238);
  *((_QWORD *)this + 84) = *(_QWORD *)(v9 + 52);
  result = NDynamicMFCC::reset((NWavChunk2HTKFrames *)((char *)this + 576));
  *((_BYTE *)this + 601) = 1;
  if (*((_BYTE *)this + 984))
  {
    v18 = 3 * *((_DWORD *)this + 238);
    v19 = *((_DWORD *)this + 10);
    if (v19 == v18)
      goto LABEL_38;
    v20 = *((_QWORD *)this + 4);
    *((_DWORD *)this + 10) = v18;
    result = operator new[]();
    *((_QWORD *)this + 4) = result;
    if (v19 >= v18)
      v21 = v18;
    else
      v21 = v19;
    if ((_DWORD)v21)
    {
      v22 = 0;
      if (v21 < 8)
        goto LABEL_42;
      if ((unint64_t)(result - v20) <= 0x1F)
        goto LABEL_42;
      v23 = 0;
      v22 = v21 & 0xFFFFFFF8;
      v24 = v22;
      do
      {
        v25 = *(_OWORD *)(v20 + v23 + 16);
        v26 = (_OWORD *)(result + v23);
        *v26 = *(_OWORD *)(v20 + v23);
        v26[1] = v25;
        v23 += 32;
        v24 -= 8;
      }
      while (v24);
      if (v22 != v21)
      {
LABEL_42:
        do
        {
          *(_DWORD *)(result + 4 * v22) = *(_DWORD *)(v20 + 4 * v22);
          ++v22;
        }
        while (v21 != v22);
      }
      goto LABEL_37;
    }
  }
  else
  {
    v27 = *((_DWORD *)this + 10);
    v28 = *((_DWORD *)this + 238);
    if (v27 == v28)
      goto LABEL_38;
    v20 = *((_QWORD *)this + 4);
    *((_DWORD *)this + 10) = v28;
    result = operator new[]();
    *((_QWORD *)this + 4) = result;
    LODWORD(v29) = *((_DWORD *)this + 238);
    if (v27 >= v29)
      v29 = v29;
    else
      v29 = v27;
    if ((_DWORD)v29)
    {
      v30 = 0;
      if (v29 < 8)
        goto LABEL_43;
      if ((unint64_t)(result - v20) <= 0x1F)
        goto LABEL_43;
      v31 = 0;
      v30 = v29 & 0xFFFFFFF8;
      v32 = v30;
      do
      {
        v33 = *(_OWORD *)(v20 + v31 + 16);
        v34 = (_OWORD *)(result + v31);
        *v34 = *(_OWORD *)(v20 + v31);
        v34[1] = v33;
        v31 += 32;
        v32 -= 8;
      }
      while (v32);
      if (v30 != v29)
      {
LABEL_43:
        do
        {
          *(_DWORD *)(result + 4 * v30) = *(_DWORD *)(v20 + 4 * v30);
          ++v30;
        }
        while (v29 != v30);
      }
      goto LABEL_37;
    }
  }
  if (v20)
LABEL_37:
    result = MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
LABEL_38:
  *((_BYTE *)this + 800) = 1;
  return result;
}

_BYTE *NWavChunk2HTKFrames::loadCfg(NWavChunk2HTKFrames *this, const NString *a2, const BOOL *a3)
{
  const char *v6;
  _BYTE *v7;
  _BYTE *v8;
  NConfigSection *v9;
  uint64_t v10;
  const char *v11;
  _QWORD *v12;
  _WORD *v13;
  const char *v14;
  uint64_t v15;
  int v16;
  char v17;
  int *v18;
  int v19;
  int v20;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  _BYTE *v27;
  const char *v28;
  char v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  const char *v33;
  float v34;
  uint64_t v35;
  _BYTE *result;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t i;
  _BOOL4 v42;
  const char *v43;
  uint64_t v44;
  const char *v45;
  char *v46;
  char *v47;
  char *v48;
  unsigned int v49;
  BOOL v50[8];
  uint64_t v51;
  void *v52;
  int v53;
  uint64_t (**v54)(NString *__hidden, const unsigned int *);
  int v55;
  _BYTE *v56;
  uint64_t (**v57)(NString *__hidden, const unsigned int *);
  int v58;
  _BYTE *v59;
  _QWORD v60[2];
  uint64_t v61;
  uint64_t (**v62)();
  uint64_t v63;
  uint64_t v64;
  int v65;

  v63 = 0;
  v64 = 0;
  v62 = off_24C7F13C0;
  v65 = 0;
  v50[0] = 1;
  NConfig::NConfig((NConfig *)v60, v50);
  v57 = &off_24C7F32C0;
  v58 = 0;
  v59 = (_BYTE *)operator new[]();
  *v59 = 0;
  if (!*((_DWORD *)a2 + 2))
    goto LABEL_86;
  if (*a3)
  {
    *(_QWORD *)v50 = &off_24C7F32C0;
    LODWORD(v51) = 0;
    v52 = (void *)operator new[]();
    bzero(v52, (v51 + 1));
    v54 = &off_24C7F32C0;
    v55 = 0;
    v7 = (_BYTE *)operator new[]();
    v56 = v7;
    *v7 = 0;
    NConfig::loadString((NConfig *)v60, (uint64_t (***)(NString *__hidden, const unsigned int *))a2, (const NString *)v50, (const NString *)&v54);
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  }
  else
  {
    *(_QWORD *)v50 = &off_24C7F32C0;
    LODWORD(v51) = 0;
    v52 = (void *)operator new[]();
    bzero(v52, (v51 + 1));
    NConfig::load((NConfig *)v60, a2, (const NString *)v50);
  }
  *(_QWORD *)v50 = &off_24C7F32C0;
  if (v52)
    MEMORY[0x212BAC9C0](v52, 0x1000C8077774924);
  *(_QWORD *)v50 = &off_24C7F32C0;
  LODWORD(v51) = 0;
  v8 = (_BYTE *)operator new[]();
  v52 = v8;
  *v8 = 0;
  v9 = (NConfigSection *)NConfig::section((NConfig *)v60, (const NString *)v50);
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  *(_DWORD *)v50 = 10;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "TARGETKIND", (const unsigned int *)v50);
  v10 = (uint64_t)v9 + 24;
  if (NMap<NString,NString>::contains((uint64_t)v9 + 24, (uint64_t)&v57))
  {
    if (!NMap<NString,NString>::contains((uint64_t)v9 + 24, (uint64_t)&v57))
      goto LABEL_107;
    v12 = (_QWORD *)NMap<NString,NString>::operator[]((uint64_t)v9 + 24, (uint64_t)&v57);
    if ((_QWORD *)((char *)this + 832) != v12)
      (*(void (**)(char *, _QWORD, _QWORD *))(*((_QWORD *)this + 104) + 64))((char *)this + 832, v12[2], v12 + 1);
    v54 = &off_24C7F32C0;
    v55 = 1;
    v13 = (_WORD *)operator new[]();
    v56 = v13;
    *v13 = 95;
    v49 = -1;
    v51 = 0;
    v52 = 0;
    *(_QWORD *)v50 = off_24C7F13C0;
    v53 = 0;
    NString::split((uint64_t)this + 832, (uint64_t)v50, (uint64_t)&v54, &v49);
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
    if (!v53)
      Error::chuck((Error *)"NWavChunk2HTKFrames::loadCfg - no parameter type specified", v14);
    v15 = v51;
    v16 = *(_DWORD *)(v51 + 24);
    if (v16 == 5)
    {
      v18 = *(int **)(v51 + 32);
      v19 = *v18;
      v20 = *((unsigned __int8 *)v18 + 4);
      if (v19 == 1312899654 && v20 == 75)
      {
        v17 = 1;
        goto LABEL_22;
      }
    }
    else if (v16 == 4 && **(_DWORD **)(v51 + 32) == 1128482381)
    {
      v17 = 0;
LABEL_22:
      *((_BYTE *)this + 929) = v17;
      *((_BYTE *)this + 956) = 0;
      *((_BYTE *)this + 984) = 0;
      v22 = *(_QWORD *)(v15 + 8);
      if (v22)
      {
        v23 = 0;
        v24 = 0;
        v48 = "NWavChunk2HTKFrames::loadCfg - Qualifier '%s' not supported for target kind '%s'";
        while (2)
        {
          v25 = v24;
          v54 = &off_24C7F32C0;
          v55 = *(_DWORD *)(v22 + 24);
          v26 = v55;
          v27 = (_BYTE *)operator new[]();
          v56 = v27;
          memcpy(v27, *(const void **)(v22 + 32), (*(_DWORD *)(v22 + 24) + 1));
          if (v26 != 1)
          {
LABEL_102:
            v48 = "NWavChunk2HTKFrames::loadCfg - Qualifier '%s' not supported in target kind '%s'";
            if (!NString::operator==((uint64_t)&v54, "E"))
            {
              v42 = NString::operator==((uint64_t)&v54, "N");
              v43 = "NWavChunk2HTKFrames::loadCfg - Invalid qualifier '%s' in target kind '%s' (only accept ENDACZK0)";
              if (v42)
                v43 = "NWavChunk2HTKFrames::loadCfg - Qualifier '%s' not supported in target kind '%s'";
              v48 = (char *)v43;
            }
LABEL_106:
            Error::chuck((Error *)v48, v28, v27, *((_QWORD *)this + 106));
          }
          v24 = 1;
          switch(*v27)
          {
            case '0':
              if (*((_BYTE *)this + 929))
                goto LABEL_106;
              *((_BYTE *)this + 956) = 1;
LABEL_25:
              v24 = v25;
LABEL_26:
              MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
              v22 = *(_QWORD *)(v22 + 8);
              if (v22)
                continue;
              if ((v24 & v23 & 1) == 0)
                goto LABEL_34;
              v29 = 1;
              break;
            case 'A':
              v23 = 1;
              goto LABEL_25;
            case 'C':
            case 'K':
            case 'Z':
              goto LABEL_25;
            case 'D':
              goto LABEL_26;
            default:
              goto LABEL_102;
          }
          break;
        }
      }
      else
      {
        LOBYTE(v23) = 0;
        LOBYTE(v24) = 0;
LABEL_34:
        if ((v24 & 1) != 0 || (v23 & 1) != 0)
          Error::chuck((Error *)"NWavChunk2HTKFrames::loadCfg - we do both dynamics or none(Check your .cfg file)", v14);
        v29 = 0;
      }
      *((_BYTE *)this + 984) = v29;
      for (*(_QWORD *)v50 = off_24C7F13C0;
            ;
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v50 + 72))((uint64_t)v50, v30))
      {
        v30 = v51;
        if (!v51)
          break;
        v51 = *(_QWORD *)(v51 + 8);
      }
      goto LABEL_40;
    }
    Error::chuck((Error *)"NWavChunk2HTKFrames::loadCfg - we only do MFCC or FBANK here('%s' specified)", v14, *(_QWORD *)(v51 + 32));
  }
LABEL_40:
  *(_DWORD *)v50 = 10;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "SOURCEKIND", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    if (!NMap<NString,NString>::contains(v10, (uint64_t)&v57))
      goto LABEL_107;
    v31 = (_QWORD *)NMap<NString,NString>::operator[](v10, (uint64_t)&v57);
    if ((_QWORD *)((char *)this + 856) != v31)
      (*(void (**)(char *, _QWORD, _QWORD *))(*((_QWORD *)this + 107) + 64))((char *)this + 856, v31[2], v31 + 1);
  }
  *(_DWORD *)v50 = 12;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "SOURCEFORMAT", (const unsigned int *)v50);
  if (!NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    goto LABEL_48;
  if (!NMap<NString,NString>::contains(v10, (uint64_t)&v57))
LABEL_107:
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v11, v59, *((_QWORD *)v9 + 2));
  v32 = (_QWORD *)NMap<NString,NString>::operator[](v10, (uint64_t)&v57);
  if ((_QWORD *)((char *)this + 880) != v32)
    (*(void (**)(char *, _QWORD, _QWORD *))(*((_QWORD *)this + 110) + 64))((char *)this + 880, v32[2], v32 + 1);
LABEL_48:
  *(_DWORD *)v50 = 10;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "SOURCERATE", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    *((_DWORD *)this + 226) = NConfigSection::iOpt(v9, (const NString *)&v57);
    if ((NConfigSection::iOpt(v9, (const NString *)&v57) & 0x80000000) != 0)
    {
      v44 = NConfigSection::iOpt(v9, (const NString *)&v57);
      v46 = "NWavChunk2HTKFrames::loadCfg() - m_iSourceRate = %d can't be negative";
      goto LABEL_118;
    }
  }
  *(_DWORD *)v50 = 10;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "TARGETRATE", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 227) = v34;
    if (v34 <= 0.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fTargetRate = %f can't be negative or zero";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 14;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "SAVECOMPRESSED", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    *((_BYTE *)this + 912) = NConfigSection::bOpt(v9, (const NString *)&v57);
  *(_DWORD *)v50 = 11;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "SAVEWITHCRC", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    *((_BYTE *)this + 913) = NConfigSection::bOpt(v9, (const NString *)&v57);
  *(_DWORD *)v50 = 10;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "WINDOWSIZE", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 229) = v34;
    if (v34 < 0.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fWindowSize = %f can't be negative";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 10;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "USEHAMMING", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    *((_BYTE *)this + 920) = NConfigSection::bOpt(v9, (const NString *)&v57);
  *(_DWORD *)v50 = 9;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "PREEMCOEF", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 231) = v34;
    if (v34 < 0.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fPreemCoef = %f can't be negative";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 8;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "NUMCHANS", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    *((_DWORD *)this + 233) = NConfigSection::iOpt(v9, (const NString *)&v57);
    if ((NConfigSection::iOpt(v9, (const NString *)&v57) & 0x80000000) != 0)
    {
      v44 = NConfigSection::iOpt(v9, (const NString *)&v57);
      v46 = "NWavChunk2HTKFrames::loadCfg() - m_iNumChans = %d can't be negative";
      goto LABEL_118;
    }
  }
  *(_DWORD *)v50 = 9;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "CEPLIFTER", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    *((_DWORD *)this + 240) = NConfigSection::iOpt(v9, (const NString *)&v57);
    if ((NConfigSection::iOpt(v9, (const NString *)&v57) & 0x80000000) != 0)
    {
      v44 = NConfigSection::iOpt(v9, (const NString *)&v57);
      v46 = "NWavChunk2HTKFrames::loadCfg() - m_iCepLifter = %d can't be negative";
      goto LABEL_118;
    }
  }
  *(_DWORD *)v50 = 7;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "NUMCEPS", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    *((_DWORD *)this + 238) = NConfigSection::iOpt(v9, (const NString *)&v57);
    if ((NConfigSection::iOpt(v9, (const NString *)&v57) & 0x80000000) != 0)
    {
      v44 = NConfigSection::iOpt(v9, (const NString *)&v57);
      v46 = "NWavChunk2HTKFrames::loadCfg() - m_iNumCep = %d can't be negative";
LABEL_118:
      Error::chuck((Error *)v46, v45, v44);
    }
  }
  *(_DWORD *)v50 = 6;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "LOFREQ", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 234) = v34;
    if (v34 < 0.0 && v34 != -1.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fLoFreq = %f can only be positive or -1";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 6;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "HIFREQ", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 235) = v34;
    if (v34 < 0.0 && *((float *)this + 234) != -1.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fHiFreq = %f can only be positive or -1";
LABEL_125:
      Error::chuck((Error *)v47, v33, v34);
    }
  }
  *(_DWORD *)v50 = 11;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "ZMEANSOURCE", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    *((_BYTE *)this + 928) = NConfigSection::bOpt(v9, (const NString *)&v57);
  *(_DWORD *)v50 = 8;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "USEPOWER", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    *((_BYTE *)this + 930) = NConfigSection::bOpt(v9, (const NString *)&v57);
  *(_DWORD *)v50 = 8;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "MELFLOOR", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 241) = v34;
    if (v34 < 0.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fMelFloor = %f can only be positive";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 8;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "MELSCALE", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 242) = v34;
    if (v34 < 0.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fMelScale = %f can only be positive";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 9;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "freqscale", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
  {
    v34 = NConfigSection::fOpt(v9, (const NString *)&v57);
    *((float *)this + 236) = v34;
    if (v34 <= 0.0)
    {
      v47 = "NWavChunk2HTKFrames::loadCfg() - m_fFreqScale = %f can only be positive";
      goto LABEL_125;
    }
  }
  *(_DWORD *)v50 = 5;
  ((void (*)(NString *, const void *, const unsigned int *))v57[8])((NString *)&v57, "MINBW", (const unsigned int *)v50);
  if (NMap<NString,NString>::contains(v10, (uint64_t)&v57))
    *((float *)this + 237) = NConfigSection::fOpt(v9, (const NString *)&v57);
LABEL_86:
  if (!*((_BYTE *)this + 929))
  {
    v35 = *((unsigned int *)this + 233);
    if (*((_DWORD *)this + 238) > (10 * v35))
      Error::chuck((Error *)"NWavChunk2HTKFrames::loadCfg() - ncep %d > nchan %d * 10 validation limit", v6, *((unsigned int *)this + 238), v35);
  }
  v57 = &off_24C7F32C0;
  result = v59;
  if (v59)
    result = (_BYTE *)MEMORY[0x212BAC9C0](v59, 0x1000C8077774924);
  v60[0] = &off_24C7F2A90;
  v60[1] = &off_24C7F2C68;
  v37 = v61;
  if (v61)
  {
    v38 = *(_QWORD *)(v61 - 8);
    if (v38)
    {
      v39 = v61 + 32 * v38;
      v40 = v39;
      do
      {
        *(_QWORD *)(v40 - 32) = off_24C7F1420;
        v40 -= 32;
        for (i = *(_QWORD *)(v40 + 8); i; i = *(_QWORD *)(v39 - 24))
        {
          *(_QWORD *)(v39 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v39 - 32) + 72))(v40);
        }
        *(_QWORD *)(v39 - 16) = 0;
        *(_DWORD *)(v39 - 8) = 0;
        v39 = v40;
      }
      while (v40 != v37);
    }
    result = (_BYTE *)MEMORY[0x212BAC9C0](v37 - 16, 0x10A1C80F4A7E088);
  }
  v62 = off_24C7F13C0;
  while (v63)
  {
    v63 = *(_QWORD *)(v63 + 8);
    result = (_BYTE *)((uint64_t (*)(uint64_t (***)()))v62[9])(&v62);
  }
  return result;
}

void sub_20D98DAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  NLinkedList<NString>::~NLinkedList((uint64_t)va);
  if (v18)
    MEMORY[0x212BAC9C0](v18, 0x1000C8077774924);
  NConfig::~NConfig((NConfig *)va1);
  NLinkedList<NString>::~NLinkedList(v6 - 120);
  _Unwind_Resume(a1);
}

double NWavChunk2HTKFrames::resetOpt(NWavChunk2HTKFrames *this)
{
  double result;
  int v3;
  int v4;
  int v5;

  v3 = 10;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 104) + 64))((char *)this + 832, "MFCC_D_A_0", &v3);
  v4 = 8;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 107) + 64))((char *)this + 856, "WAVEFORM", &v4);
  v5 = 3;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 110) + 64))((char *)this + 880, "WAV", &v5);
  *((_QWORD *)this + 113) = 0x47C3500000000000;
  *((_WORD *)this + 456) = 0;
  *((_DWORD *)this + 229) = 1243365376;
  *((_BYTE *)this + 920) = 1;
  *((_DWORD *)this + 231) = 1064849900;
  *((_WORD *)this + 464) = 0;
  *((_BYTE *)this + 930) = 0;
  *((_DWORD *)this + 233) = 26;
  *((_DWORD *)this + 238) = 12;
  *((_DWORD *)this + 240) = 22;
  *(_QWORD *)((char *)this + 964) = 0x3F80000000000000;
  result = -0.00781250557;
  *(_OWORD *)((char *)this + 936) = xmmword_20DA24650;
  *((_BYTE *)this + 984) = 1;
  *(_QWORD *)((char *)this + 988) = 0x200000002;
  *((_BYTE *)this + 801) = 0;
  *((_BYTE *)this + 956) = 1;
  return result;
}

uint64_t NWavChunk2HTKFrames::changeSamRate(uint64_t this, const char *a2)
{
  unsigned int v2;
  unsigned int v3;

  v2 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NWavChunk2HTKFrames::changeSamRate - a_iSampleRate = %d has to be strictly positive", a2, 0);
  *(_DWORD *)(this + 972) = v2;
  *(_DWORD *)(this + 976) = (float)((float)(*(float *)(this + 916) * (float)v2) / 10000000.0);
  v3 = (float)((float)(*(float *)(this + 908) * (float)v2) / 10000000.0);
  if (v3 <= 1)
    v3 = 1;
  *(_DWORD *)(this + 980) = v3;
  return this;
}

uint64_t NWavChunk2HTKFrames::initStatic(NWavChunk2HTKFrames *this, double a2)
{
  return AccelStaticMFCC::init((NWavChunk2HTKFrames *)((char *)this + 48), (const char *)this + 980, (unsigned int *)this + 243, (unsigned int *)this + 244, (const BOOL *)this + 920, (float *)this + 231, (const BOOL *)this + 928, (const BOOL *)this + 929, a2, (const BOOL *)this + 930, (const unsigned int *)this + 233, (const float *)this + 234, (const float *)this + 235, (const unsigned int *)this + 240, (const unsigned int *)this + 238, (const float *)this + 241, (const float *)this + 242, (const float *)this + 236, (const float *)this + 237);
}

uint64_t NWavChunk2HTKFrames::initDyn(NWavChunk2HTKFrames *this)
{
  uint64_t result;

  *((_DWORD *)this + 174) = *((_DWORD *)this + 238);
  *((_QWORD *)this + 84) = *(_QWORD *)((char *)this + 988);
  result = NDynamicMFCC::reset((NWavChunk2HTKFrames *)((char *)this + 576));
  *((_BYTE *)this + 601) = 1;
  return result;
}

uint64_t NWavChunk2HTKFrames::parmCode(NWavChunk2HTKFrames *this)
{
  __int16 v1;

  if (*((_BYTE *)this + 929))
    v1 = 0;
  else
    v1 = (3 * *((_BYTE *)this + 801));
  return (unsigned __int16)((v1 + (*((unsigned __int8 *)this + 929) | 6) + 768 * *((unsigned __int8 *)this + 984)) | (*((unsigned __int8 *)this + 956) << 13));
}

uint64_t NWavChunk2HTKFrames::frameSize(NWavChunk2HTKFrames *this)
{
  return *((_DWORD *)this + 238) * ((2 * *((unsigned __int8 *)this + 984)) | 1u);
}

uint64_t NWavChunk2HTKFrames::numStatic(NWavChunk2HTKFrames *this)
{
  return *((unsigned int *)this + 238);
}

uint64_t NWavChunk2HTKFrames::reset(NWavChunk2HTKFrames *this)
{
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 138) = *((_DWORD *)this + 134) + 1;
  *((_QWORD *)this + 70) = 0;
  *((_BYTE *)this + 556) = 0;
  return NDynamicMFCC::reset((NWavChunk2HTKFrames *)((char *)this + 576));
}

uint64_t NWavChunk2HTKFrames::run(uint64_t a1, const char *a2, int *a3, int *a4, uint64_t a5)
{
  AccelStaticMFCC *v6;
  int v8;
  int v9;
  uint64_t result;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  int *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _OWORD *v30;
  __int128 *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  int *v37;
  int v38;
  int *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _OWORD *v47;
  __int128 *v48;
  uint64_t v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  _DWORD *v53;
  int *v54;
  int v55;

  if (!*(_BYTE *)(a1 + 800))
    Error::chuck((Error *)"NWavChunk2HTKFrames::run - NWavChunk2HTKFrames::init() must be called before running", a2);
  v6 = (AccelStaticMFCC *)(a1 + 48);
  if (!*(_BYTE *)(a1 + 48))
    Error::chuck((Error *)"AccelStaticMFCC::start() - AccelStaticMFCC::init() has to be called before starting", a2);
  if (*(_QWORD *)(a1 + 560))
    Error::chuck((Error *)"AccelStaticMFCC::start() - frames undrained from previous chunk - call isFrame() or reset()", a2);
  v8 = *a3;
  if (!a2 && v8)
    Error::chuck((Error *)"AccelStaticMFCC::start() - pointer to chunk is NULL", 0);
  v9 = *a4;
  if (*a4 >= 2)
    Error::chuck((Error *)"NAccelStaticMFCC::start() - unsupported sample type", a2);
  *(_QWORD *)(a1 + 560) = a2;
  *(_DWORD *)(a1 + 568) = v8;
  *(_DWORD *)(a1 + 572) = v9;
  *(_BYTE *)(a1 + 556) = 0;
  while (1)
  {
    result = AccelStaticMFCC::isFrame(v6, a2);
    if (!(_DWORD)result)
      return result;
    v11 = *(unsigned int *)(a1 + 16);
    v12 = *(unsigned int *)(a1 + 72);
    if (v11 != v12)
    {
      v13 = *(_QWORD *)(a1 + 8);
      if (v13)
      {
        MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
        LODWORD(v12) = *(_DWORD *)(a1 + 72);
      }
      *(_DWORD *)(a1 + 16) = v12;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v11 = *(unsigned int *)(a1 + 16);
    }
    if (v11)
    {
      v14 = 0;
      v15 = *(_QWORD *)(a1 + 64);
      v16 = *(_QWORD *)(a1 + 8);
      if (v11 < 8)
        goto LABEL_20;
      if ((unint64_t)(v16 - v15) < 0x20)
        goto LABEL_20;
      v14 = v11 & 0xFFFFFFF8;
      v17 = (_OWORD *)(v16 + 16);
      v18 = (__int128 *)(v15 + 16);
      v19 = v14;
      do
      {
        v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v14 != v11)
      {
LABEL_20:
        v21 = v11 - v14;
        v22 = 4 * v14;
        v23 = (_DWORD *)(v16 + v22);
        v24 = (int *)(v15 + v22);
        do
        {
          v25 = *v24++;
          *v23++ = v25;
          --v21;
        }
        while (v21);
      }
    }
    if (*(_BYTE *)(a1 + 956) && !*(_BYTE *)(a1 + 801))
    {
      v39 = *(int **)(a1 + 8);
      v40 = *v39;
      v41 = *(_DWORD *)(a1 + 952);
      v42 = (v41 - 1);
      if (v41 == 1)
        v42 = 0;
      else
        memmove(*(void **)(a1 + 8), v39 + 1, 4 * (v41 - 1));
      v39[v42] = v40;
      if (*(_BYTE *)(a1 + 984))
        goto LABEL_25;
LABEL_40:
      v43 = *(unsigned int *)(a1 + 40);
      if ((_DWORD)v43)
      {
        v44 = 0;
        v45 = *(_QWORD *)(a1 + 8);
        v46 = *(_QWORD *)(a1 + 32);
        if (v43 < 8)
          goto LABEL_46;
        if ((unint64_t)(v46 - v45) < 0x20)
          goto LABEL_46;
        v44 = v43 & 0xFFFFFFF8;
        v47 = (_OWORD *)(v46 + 16);
        v48 = (__int128 *)(v45 + 16);
        v49 = v44;
        do
        {
          v50 = *v48;
          *(v47 - 1) = *(v48 - 1);
          *v47 = v50;
          v47 += 2;
          v48 += 2;
          v49 -= 8;
        }
        while (v49);
        if (v44 != v43)
        {
LABEL_46:
          v51 = v43 - v44;
          v52 = 4 * v44;
          v53 = (_DWORD *)(v46 + 4 * v44);
          v54 = (int *)(v45 + v52);
          do
          {
            v55 = *v54++;
            *v53++ = v55;
            --v51;
          }
          while (v51);
        }
      }
LABEL_8:
      NResizingQueue<NFrame>::push(a5, a1 + 24);
    }
    else
    {
      if (!*(_BYTE *)(a1 + 984))
        goto LABEL_40;
LABEL_25:
      if (NDynamicMFCC::isFrame(a1 + 576, a1))
      {
        if (!*(_BYTE *)(a1 + 600))
          Error::chuck((Error *)"NDynamicMFCC::getFrame() - no frame available", a2);
        v26 = *(unsigned int *)(a1 + 40);
        if ((_DWORD)v26)
        {
          v27 = 0;
          v28 = *(_QWORD *)(a1 + 584);
          v29 = *(_QWORD *)(a1 + 32);
          if (v26 < 8)
            goto LABEL_33;
          if ((unint64_t)(v29 - v28) < 0x20)
            goto LABEL_33;
          v27 = v26 & 0xFFFFFFF8;
          v30 = (_OWORD *)(v29 + 16);
          v31 = (__int128 *)(v28 + 16);
          v32 = v27;
          do
          {
            v33 = *v31;
            *(v30 - 1) = *(v31 - 1);
            *v30 = v33;
            v30 += 2;
            v31 += 2;
            v32 -= 8;
          }
          while (v32);
          if (v27 != v26)
          {
LABEL_33:
            v34 = v26 - v27;
            v35 = 4 * v27;
            v36 = (_DWORD *)(v29 + 4 * v27);
            v37 = (int *)(v28 + v35);
            do
            {
              v38 = *v37++;
              *v36++ = v38;
              --v34;
            }
            while (v34);
          }
        }
        goto LABEL_8;
      }
    }
  }
}

uint64_t NResizingQueue<NFrame>::push(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  __int128 *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int *v21;
  int v22;
  unsigned int v23;

  if (*(_BYTE *)(result + 68))
    Error::chuck((Error *)"NResizingQueue::push() - tried pushing a new element after NResizingQueue::finish() has been called", (const char *)a2);
  v3 = result;
  v4 = *(_DWORD *)(result + 64);
  if (*(_DWORD *)(result + 56) - *(_DWORD *)(result + 60) >= v4 - 2)
  {
    v5 = (float)(*(float *)(result + 76) * (float)v4);
    if (v5 <= 1)
      v5 = 1;
    v23 = v5;
    result = NResizingQueue<NFrame>::enlargeBy(result, (int *)&v23);
  }
  v6 = *(_QWORD *)(v3 + 40);
  if (v6 + 16 != a2)
  {
    v7 = *(_DWORD *)(v6 + 32);
    v8 = *(_DWORD *)(a2 + 16);
    if (v7 != v8)
    {
      v9 = *(_QWORD *)(v6 + 24);
      if (v9)
      {
        MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v8 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v6 + 32) = v8;
      result = operator new[]();
      *(_QWORD *)(v6 + 24) = result;
      v7 = *(_DWORD *)(v6 + 32);
    }
    if (v7)
    {
      v10 = 0;
      v11 = *(_QWORD *)(a2 + 8);
      v12 = *(_QWORD *)(v6 + 24);
      v13 = v7;
      if (v7 < 8)
        goto LABEL_17;
      if ((unint64_t)(v12 - v11) < 0x20)
        goto LABEL_17;
      v10 = v7 & 0xFFFFFFF8;
      v14 = (_OWORD *)(v12 + 16);
      v15 = (__int128 *)(v11 + 16);
      v16 = v13 & 0xFFFFFFF8;
      do
      {
        v17 = *v15;
        *(v14 - 1) = *(v15 - 1);
        *v14 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v10 != v13)
      {
LABEL_17:
        v18 = v13 - v10;
        v19 = 4 * v10;
        v20 = (_DWORD *)(v12 + v19);
        v21 = (int *)(v11 + v19);
        do
        {
          v22 = *v21++;
          *v20++ = v22;
          --v18;
        }
        while (v18);
      }
    }
  }
  *(_QWORD *)(v3 + 40) = *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8);
  ++*(_DWORD *)(v3 + 56);
  return result;
}

uint64_t NResizingQueue<NFrame>::enlargeBy(uint64_t a1, int *a2)
{
  uint64_t v4;
  const char *v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t (**v27)();
  uint64_t v28;
  int v29;

  v27 = &off_24C7F2F08;
  v28 = 0;
  v29 = 0;
  v4 = (*(uint64_t (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)(a1 + 8) + 64))(a1 + 8, &v27);
  v6 = (uint64_t *)(a1 + 16);
  v7 = (_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16))
  {
    v8 = (uint64_t *)(*v7 + 8);
    v6 = (uint64_t *)(a1 + 24);
  }
  else
  {
    v8 = (uint64_t *)(a1 + 24);
  }
  *v8 = v4;
  *v6 = v4;
  ++*(_DWORD *)(a1 + 32);
  v27 = &off_24C7F2F08;
  v9 = v28;
  if (v28)
  {
    v10 = *(_QWORD *)(v28 - 8);
    if (v10)
    {
      v11 = 40 * v10;
      do
      {
        v12 = v9 + v11;
        *(_QWORD *)(v12 - 40) = &off_24C7F3640;
        *(_QWORD *)(v12 - 24) = &off_24C7F3090;
        v13 = *(_QWORD *)(v9 + v11 - 16);
        if (v13)
          MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
        v11 -= 40;
      }
      while (v11);
    }
    MEMORY[0x212BAC9C0](v9 - 16, 0x10A1C80C9FAA55CLL);
  }
  v14 = *v7;
  if (!*v7)
    Error::chuck((Error *)"NLinkedList::tail() - cannot access tail of empty list", v5);
  result = (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)(v14 + 16) + 32))(v14 + 16, a2);
  v16 = *a2;
  v17 = (*a2 - 1);
  if (*a2 != 1)
  {
    v18 = *(_QWORD *)(v14 + 24);
    if (*a2 == 2)
    {
      v19 = 0;
    }
    else
    {
      v19 = v17 & 0xFFFFFFFE;
      v20 = v18 + 40;
      v21 = v19;
      do
      {
        *(_QWORD *)(v20 - 32) = v20;
        *(_QWORD *)(v20 + 8) = v20 + 40;
        v20 += 80;
        v21 -= 2;
      }
      while (v21);
      if (v19 == v17)
        goto LABEL_20;
    }
    v22 = v18 + 40 * v19 + 40;
    v23 = v17 - v19;
    do
    {
      *(_QWORD *)(v22 - 32) = v22;
      v22 += 40;
      --v23;
    }
    while (v23);
  }
LABEL_20:
  v24 = *(_QWORD *)(a1 + 40);
  if (v24)
  {
    v25 = *(_QWORD *)(v14 + 24);
    *(_QWORD *)(v25 + 40 * v17 + 8) = *(_QWORD *)(v24 + 8);
    *(_QWORD *)(v24 + 8) = v25;
  }
  else
  {
    v26 = *(_QWORD *)(v14 + 24);
    *(_QWORD *)(v26 + 40 * v17 + 8) = v26;
    *(_QWORD *)(a1 + 40) = v26;
    *(_QWORD *)(a1 + 48) = v26;
  }
  *(_DWORD *)(a1 + 64) += v16;
  return result;
}

void sub_20D98E570(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  NArray<NResizingQueue<NFrame>::NElement>::~NArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *NArray<NResizingQueue<NFrame>::NElement>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *a1 = &off_24C7F2F08;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 40 * v3;
      do
      {
        v5 = v2 + v4;
        *(_QWORD *)(v5 - 40) = &off_24C7F3640;
        *(_QWORD *)(v5 - 24) = &off_24C7F3090;
        v6 = *(_QWORD *)(v2 + v4 - 16);
        if (v6)
          MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v4 -= 40;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80C9FAA55CLL);
  }
  return a1;
}

_QWORD *NResizingQueue<NFrame>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3640;
  a1[2] = &off_24C7F3090;
  v2 = a1[3];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  return a1;
}

void NResizingQueue<NFrame>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3640;
  a1[2] = &off_24C7F3090;
  v1 = a1[3];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

void NArray<NResizingQueue<NFrame>::NElement>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2F08;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 40 * v2;
      do
      {
        v4 = v1 + v3;
        *(_QWORD *)(v4 - 40) = &off_24C7F3640;
        *(_QWORD *)(v4 - 24) = &off_24C7F3090;
        v5 = *(_QWORD *)(v1 + v3 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
        v3 -= 40;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80C9FAA55CLL);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NResizingQueue<NFrame>::NElement>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  _DWORD *v16;
  uint64_t v17;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 - 8);
      if (v7)
      {
        v8 = 40 * v7;
        do
        {
          v9 = v6 + v8;
          *(_QWORD *)(v9 - 40) = &off_24C7F3640;
          *(_QWORD *)(v9 - 24) = &off_24C7F3090;
          v10 = *(_QWORD *)(v6 + v8 - 16);
          if (v10)
            MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
          v8 -= 40;
        }
        while (v8);
      }
      MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80C9FAA55CLL);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v11 = 40 * v5;
    v12 = (_QWORD *)operator new[]();
    *v12 = 40;
    v12[1] = v5;
    v13 = v12 + 2;
    if (!v5)
      goto LABEL_17;
    v14 = v12 + 2;
    if ((unint64_t)(v11 - 40) >= 0x28)
    {
      v15 = (v11 - 40) / 0x28uLL + 1;
      v16 = v12 + 11;
      v17 = v15 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v16 - 9) = &off_24C7F3640;
        *((_QWORD *)v16 - 4) = &off_24C7F3640;
        *(v16 - 10) = 0;
        *v16 = 0;
        *((_QWORD *)v16 - 7) = &off_24C7F31A8;
        *((_QWORD *)v16 - 6) = 0;
        *((_QWORD *)v16 - 2) = &off_24C7F31A8;
        *((_QWORD *)v16 - 1) = 0;
        v16 += 20;
        v17 -= 2;
      }
      while (v17);
      if (v15 == (v15 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_17;
      v14 = &v13[5 * (v15 & 0xFFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v14 = &off_24C7F3640;
      *((_DWORD *)v14 + 8) = 0;
      v14[2] = &off_24C7F31A8;
      v14[3] = 0;
      v14 += 5;
    }
    while (v14 != &v13[5 * v5]);
LABEL_17:
    *(_QWORD *)(a1 + 8) = v13;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
    Error::chuck((Error *)"NLinkedList::NElement::operator=() -this method should never be called", (const char *)a2);
  return a1;
}

uint64_t NArray<NResizingQueue<NFrame>::NElement>::fromArray(uint64_t result, const char *a2, unsigned int *a3)
{
  int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _DWORD *v16;
  uint64_t v17;

  v3 = *(_DWORD *)(result + 16);
  v4 = *a3;
  if (v3 == *a3)
    goto LABEL_17;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  if (v6)
  {
    v8 = *(_QWORD *)(v6 - 8);
    if (v8)
    {
      v9 = 40 * v8;
      do
      {
        v10 = v6 + v9;
        *(_QWORD *)(v10 - 40) = &off_24C7F3640;
        *(_QWORD *)(v10 - 24) = &off_24C7F3090;
        v11 = *(_QWORD *)(v6 + v9 - 16);
        if (v11)
          MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
        v9 -= 40;
      }
      while (v9);
    }
    MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80C9FAA55CLL);
    v4 = *a3;
  }
  *(_DWORD *)(v5 + 16) = v4;
  v12 = 40 * v4;
  result = operator new[]();
  *(_QWORD *)result = 40;
  *(_QWORD *)(result + 8) = v4;
  v13 = result + 16;
  if (v4)
  {
    v14 = result + 16;
    if ((unint64_t)(v12 - 40) >= 0x28)
    {
      v15 = (v12 - 40) / 0x28uLL + 1;
      v16 = (_DWORD *)(result + 88);
      v17 = v15 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v16 - 9) = &off_24C7F3640;
        *((_QWORD *)v16 - 4) = &off_24C7F3640;
        *(v16 - 10) = 0;
        *v16 = 0;
        *((_QWORD *)v16 - 7) = &off_24C7F31A8;
        *((_QWORD *)v16 - 6) = 0;
        *((_QWORD *)v16 - 2) = &off_24C7F31A8;
        *((_QWORD *)v16 - 1) = 0;
        v16 += 20;
        v17 -= 2;
      }
      while (v17);
      if (v15 == (v15 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_16;
      v14 = v13 + 40 * (v15 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v14 = &off_24C7F3640;
      *(_DWORD *)(v14 + 32) = 0;
      *(_QWORD *)(v14 + 16) = &off_24C7F31A8;
      *(_QWORD *)(v14 + 24) = 0;
      v14 += 40;
    }
    while (v14 != v13 + 40 * v4);
  }
LABEL_16:
  *(_QWORD *)(v5 + 8) = v13;
  v3 = *(_DWORD *)(v5 + 16);
LABEL_17:
  if (v3)
    Error::chuck((Error *)"NLinkedList::NElement::operator=() -this method should never be called", a2);
  return result;
}

uint64_t NArray<NResizingQueue<NFrame>::NElement>::resize(uint64_t result, _DWORD *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = *(_DWORD *)(result + 16);
  v3 = *a2;
  if (v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 40 * v3;
  result = operator new[]();
  *(_QWORD *)result = 40;
  *(_QWORD *)(result + 8) = v3;
  v9 = result + 16;
  if ((_DWORD)v3)
  {
    v10 = result + 16;
    if ((unint64_t)(v7 - 40) >= 0x28)
    {
      v11 = (v7 - 40) / 0x28uLL + 1;
      v12 = (_DWORD *)(result + 88);
      v13 = v11 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v12 - 9) = &off_24C7F3640;
        *((_QWORD *)v12 - 4) = &off_24C7F3640;
        *(v12 - 10) = 0;
        *v12 = 0;
        *((_QWORD *)v12 - 7) = &off_24C7F31A8;
        *((_QWORD *)v12 - 6) = 0;
        *((_QWORD *)v12 - 2) = &off_24C7F31A8;
        *((_QWORD *)v12 - 1) = 0;
        v12 += 20;
        v13 -= 2;
      }
      while (v13);
      if (v11 == (v11 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_9;
      v10 = v9 + 40 * (v11 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v10 = &off_24C7F3640;
      *(_DWORD *)(v10 + 32) = 0;
      *(_QWORD *)(v10 + 16) = &off_24C7F31A8;
      *(_QWORD *)(v10 + 24) = 0;
      v10 += 40;
    }
    while (v10 != v9 + 40 * v3);
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v9;
  if (v2 && *a2)
    Error::chuck((Error *)"NLinkedList::NElement::operator=() -this method should never be called", v8);
  if (v6)
  {
    v14 = *(_QWORD *)(v6 - 8);
    if (v14)
    {
      v15 = 40 * v14;
      do
      {
        v16 = v6 + v15;
        *(_QWORD *)(v16 - 40) = &off_24C7F3640;
        *(_QWORD *)(v16 - 24) = &off_24C7F3090;
        v17 = *(_QWORD *)(v6 + v15 - 16);
        if (v17)
          MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
        v15 -= 40;
      }
      while (v15);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

void *NWavChunk2HTKFrames::c0Invert(void *this)
{
  int *v1;
  int v2;
  int v3;
  uint64_t v4;

  v1 = (int *)*((_QWORD *)this + 1);
  v2 = *v1;
  v3 = *((_DWORD *)this + 238);
  v4 = (v3 - 1);
  if (v3 == 1)
    v4 = 0;
  else
    this = memmove(*((void **)this + 1), v1 + 1, 4 * (v3 - 1));
  v1[v4] = v2;
  return this;
}

float NWavChunk2HTKFrames::toOutType(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;

  v2 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = *(_QWORD *)(a2 + 8);
    v5 = *(_QWORD *)(a1 + 32);
    if (v2 < 8)
      goto LABEL_7;
    if ((unint64_t)(v5 - v4) < 0x20)
      goto LABEL_7;
    v3 = v2 & 0xFFFFFFF8;
    v6 = (_OWORD *)(v5 + 16);
    v7 = (__int128 *)(v4 + 16);
    v8 = v3;
    do
    {
      v9 = *(v7 - 1);
      v10 = *v7;
      *(v6 - 1) = v9;
      *v6 = v10;
      v6 += 2;
      v7 += 2;
      v8 -= 8;
    }
    while (v8);
    if (v3 != v2)
    {
LABEL_7:
      v11 = v2 - v3;
      v12 = 4 * v3;
      v13 = (_DWORD *)(v5 + 4 * v3);
      v14 = (int *)(v4 + v12);
      do
      {
        v15 = *v14++;
        LODWORD(v9) = v15;
        *v13++ = v15;
        --v11;
      }
      while (v11);
    }
  }
  return *(float *)&v9;
}

uint64_t NWavChunk2HTKFrames::finish(uint64_t result, const char *a2)
{
  uint64_t v2;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  int v17;

  if (!*(_BYTE *)(result + 800))
    Error::chuck((Error *)"NWavChunk2HTKFrames::finish - NWavChunk2HTKFrames::init() must be called before finishing", a2);
  v2 = result;
  if (*(_BYTE *)(result + 984))
  {
    while (1)
    {
      result = NDynamicMFCC::finish((NDynamicMFCC *)(v2 + 576), a2);
      if ((result & 1) != 0)
        break;
      if (!*(_BYTE *)(v2 + 600))
        Error::chuck((Error *)"NDynamicMFCC::getFrame() - no frame available", v4);
      v5 = *(unsigned int *)(v2 + 40);
      if ((_DWORD)v5)
      {
        v6 = 0;
        v7 = *(_QWORD *)(v2 + 584);
        v8 = *(_QWORD *)(v2 + 32);
        if (v5 < 8)
          goto LABEL_13;
        if ((unint64_t)(v8 - v7) < 0x20)
          goto LABEL_13;
        v6 = v5 & 0xFFFFFFF8;
        v9 = (_OWORD *)(v8 + 16);
        v10 = (__int128 *)(v7 + 16);
        v11 = v6;
        do
        {
          v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 8;
        }
        while (v11);
        if (v6 != v5)
        {
LABEL_13:
          v13 = v5 - v6;
          v14 = 4 * v6;
          v15 = (_DWORD *)(v8 + 4 * v6);
          v16 = (int *)(v7 + v14);
          do
          {
            v17 = *v16++;
            *v15++ = v17;
            --v13;
          }
          while (v13);
        }
      }
      NResizingQueue<NFrame>::push((uint64_t)a2, v2 + 24);
    }
  }
  return result;
}

float NWavChunk2HTKFrames::getFrameRate(NWavChunk2HTKFrames *this)
{
  return (float)*((unsigned int *)this + 243) / (float)*((unsigned int *)this + 245);
}

uint64_t NWavChunk2HTKFrames::isTypeInt4(NWavChunk2HTKFrames *this)
{
  return 0;
}

uint64_t NDEAcAnal::init(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  unsigned int v7;
  float v8;
  float v9;
  float v10;
  double v11;
  unsigned int v12;
  uint64_t result;
  const char *v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *v21;
  __int128 *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  int *v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  _OWORD *v35;
  __int128 *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  int *v42;
  int v43;

  if (a2)
  {
    *(_OWORD *)(a1 + 580) = *(_OWORD *)a2;
    v4 = *(_OWORD *)(a2 + 16);
    v5 = *(_OWORD *)(a2 + 32);
    v6 = *(_OWORD *)(a2 + 48);
    *(_DWORD *)(a1 + 644) = *(_DWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 612) = v5;
    *(_OWORD *)(a1 + 628) = v6;
    *(_OWORD *)(a1 + 596) = v4;
  }
  v7 = *a3;
  if (!*a3)
    Error::chuck((Error *)"NDEAcAnal::setSamRate() - a_iSamRate (= %d) must be strictly positive\n", (const char *)a2, 0);
  *(_DWORD *)(a1 + 648) = v7;
  v8 = (float)(*(float *)(a1 + 584) * (float)v7) / 10000000.0;
  v9 = 2147500000.0;
  if (v8 <= 2147500000.0)
  {
    v9 = (float)(*(float *)(a1 + 584) * (float)v7) / 10000000.0;
    if (v8 < 0.0)
      v9 = 0.0;
  }
  *(_DWORD *)(a1 + 652) = v9;
  v10 = (float)(*(float *)(a1 + 580) * (float)v7) / 10000000.0;
  v11 = 3.53369517e72;
  if (v10 <= 2147500000.0)
  {
    *(float *)&v11 = (float)(*(float *)(a1 + 580) * (float)v7) / 10000000.0;
    if (v10 < 0.0)
      LODWORD(v11) = 0;
  }
  v12 = *(float *)&v11;
  if (*(float *)&v11 <= 1)
    v12 = 1;
  *(_DWORD *)(a1 + 656) = v12;
  if (*(_BYTE *)(a1 + 624))
    ++*(_DWORD *)(a1 + 616);
  if (*(_BYTE *)(a1 + 594))
    *(_DWORD *)(a1 + 616) = *(_DWORD *)(a1 + 596);
  result = AccelStaticMFCC::init((AccelStaticMFCC *)a1, (const char *)(a1 + 656), (unsigned int *)(a1 + 648), (unsigned int *)(a1 + 652), (const BOOL *)(a1 + 593), (float *)(a1 + 588), (const BOOL *)(a1 + 592), (const BOOL *)(a1 + 594), v11, (const BOOL *)(a1 + 595), (const unsigned int *)(a1 + 596), (const float *)(a1 + 600), (const float *)(a1 + 604), (const unsigned int *)(a1 + 620), (const unsigned int *)(a1 + 616), (const float *)(a1 + 628), (const float *)(a1 + 632), (const float *)(a1 + 608), (const float *)(a1 + 612));
  if (*(_BYTE *)(a1 + 636))
    Error::chuck((Error *)"NDEAcAnal::init() - deltas not supported", v14);
  v15 = *(_DWORD *)(a1 + 568);
  v16 = *(_DWORD *)(a1 + 616);
  if (v15 != v16)
  {
    v17 = *(_QWORD *)(a1 + 560);
    *(_DWORD *)(a1 + 568) = v16;
    result = operator new[]();
    *(_QWORD *)(a1 + 560) = result;
    v18 = *(_DWORD *)(a1 + 616);
    if (v15 >= v18)
      v19 = v18;
    else
      v19 = v15;
    if ((_DWORD)v19)
    {
      v20 = 0;
      if (v19 < 8)
        goto LABEL_27;
      if ((unint64_t)(result - v17) <= 0x1F)
        goto LABEL_27;
      v20 = v19 & 0xFFFFFFF8;
      v21 = (_OWORD *)(result + 16);
      v22 = (__int128 *)(v17 + 16);
      v23 = v20;
      do
      {
        v24 = *v22;
        *(v21 - 1) = *(v22 - 1);
        *v21 = v24;
        v21 += 2;
        v22 += 2;
        v23 -= 8;
      }
      while (v23);
      if (v20 != v19)
      {
LABEL_27:
        v25 = v19 - v20;
        v26 = 4 * v20;
        v27 = (_DWORD *)(result + 4 * v20);
        v28 = (int *)(v17 + v26);
        do
        {
          v29 = *v28++;
          *v27++ = v29;
          --v25;
        }
        while (v25);
      }
      goto LABEL_31;
    }
    if (v17)
    {
LABEL_31:
      result = MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
      v15 = *(_DWORD *)(a1 + 616);
      goto LABEL_32;
    }
    v15 = *(_DWORD *)(a1 + 616);
  }
LABEL_32:
  v30 = *(_DWORD *)(a1 + 544);
  if (v30 != v15)
  {
    v31 = *(_QWORD *)(a1 + 536);
    *(_DWORD *)(a1 + 544) = v15;
    result = operator new[]();
    *(_QWORD *)(a1 + 536) = result;
    LODWORD(v32) = *(_DWORD *)(a1 + 616);
    if (v30 >= v32)
      v32 = v32;
    else
      v32 = v30;
    if (!(_DWORD)v32)
    {
      if (!v31)
        goto LABEL_50;
      goto LABEL_49;
    }
    if (v32 >= 8 && (unint64_t)(result - v31) > 0x1F)
    {
      v34 = v32 & 0xFFFFFFF8;
      v35 = (_OWORD *)(result + 16);
      v36 = (__int128 *)(v31 + 16);
      v37 = v34;
      do
      {
        v38 = *v36;
        *(v35 - 1) = *(v36 - 1);
        *v35 = v38;
        v35 += 2;
        v36 += 2;
        v37 -= 8;
      }
      while (v37);
      if (v34 == v32)
        goto LABEL_49;
    }
    else
    {
      v34 = 0;
    }
    v39 = v32 - v34;
    v40 = 4 * v34;
    v41 = (_DWORD *)(result + 4 * v34);
    v42 = (int *)(v31 + v40);
    do
    {
      v43 = *v42++;
      *v41++ = v43;
      --v39;
    }
    while (v39);
LABEL_49:
    result = MEMORY[0x212BAC9C0](v31, 0x1000C8052888210);
  }
LABEL_50:
  *(_BYTE *)(a1 + 576) = 1;
  return result;
}

uint64_t NDEAcAnal::setSamRate(uint64_t this, const char *a2)
{
  unsigned int v2;
  float v3;
  float v4;
  float v5;
  float v6;
  unsigned int v7;

  v2 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NDEAcAnal::setSamRate() - a_iSamRate (= %d) must be strictly positive\n", a2, 0);
  *(_DWORD *)(this + 648) = v2;
  v3 = (float)(*(float *)(this + 584) * (float)v2) / 10000000.0;
  v4 = 2147500000.0;
  if (v3 <= 2147500000.0)
  {
    v4 = (float)(*(float *)(this + 584) * (float)v2) / 10000000.0;
    if (v3 < 0.0)
      v4 = 0.0;
  }
  *(_DWORD *)(this + 652) = v4;
  v5 = (float)(*(float *)(this + 580) * (float)v2) / 10000000.0;
  v6 = 2147500000.0;
  if (v5 <= 2147500000.0)
  {
    v6 = (float)(*(float *)(this + 580) * (float)v2) / 10000000.0;
    if (v5 < 0.0)
      v6 = 0.0;
  }
  v7 = v6;
  if (v6 <= 1)
    v7 = 1;
  *(_DWORD *)(this + 656) = v7;
  return this;
}

uint64_t NDEAcAnal::initStatic(NDEAcAnal *this, double a2)
{
  return AccelStaticMFCC::init(this, (const char *)this + 656, (unsigned int *)this + 162, (unsigned int *)this + 163, (const BOOL *)this + 593, (float *)this + 147, (const BOOL *)this + 592, (const BOOL *)this + 594, a2, (const BOOL *)this + 595, (const unsigned int *)this + 149, (const float *)this + 150, (const float *)this + 151, (const unsigned int *)this + 155, (const unsigned int *)this + 154, (const float *)this + 157, (const float *)this + 158, (const float *)this + 152, (const float *)this + 153);
}

uint64_t NDEAcAnal::feedFromInt(NDEAcAnal *this, const char *a2, const unsigned int *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  __int128 *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int *v21;
  int v22;
  int *v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD *v31;
  __int128 *v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  int *v38;
  int v39;

  if (!*((_BYTE *)this + 576))
    Error::chuck((Error *)"NDEAcAnal::feedFromInt() - you must call NDEAcAnal::init() before feeding the program", a2, a3);
  v4 = *a3;
  v5 = *((unsigned int *)this + 164);
  if (*a3 > v5)
    Error::chuck((Error *)"NDEAcAnal::feedFromInt() - we are supposed to get only one frame at a time feed size (%d) must be less than step size (%d) ", a2, *a3, v5);
  if (!*(_BYTE *)this)
    Error::chuck((Error *)"AccelStaticMFCC::start() - AccelStaticMFCC::init() has to be called before starting", a2);
  if (*((_QWORD *)this + 64))
    Error::chuck((Error *)"AccelStaticMFCC::start() - frames undrained from previous chunk - call isFrame() or reset()", a2);
  if (!a2 && v4)
    Error::chuck((Error *)"AccelStaticMFCC::start() - pointer to chunk is NULL", 0);
  v6 = 0;
  *((_QWORD *)this + 64) = a2;
  *((_DWORD *)this + 130) = v4;
  *((_DWORD *)this + 131) = 0;
  *((_BYTE *)this + 508) = 0;
  *((_BYTE *)this + 660) = 0;
  while (1)
  {
    result = AccelStaticMFCC::isFrame(this, a2);
    if (!(_DWORD)result)
      break;
    v8 = *((unsigned int *)this + 136);
    v9 = *((unsigned int *)this + 6);
    if (v8 != v9)
    {
      v10 = *((_QWORD *)this + 67);
      if (v10)
      {
        MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
        LODWORD(v9) = *((_DWORD *)this + 6);
      }
      *((_DWORD *)this + 136) = v9;
      *((_QWORD *)this + 67) = operator new[]();
      v8 = *((unsigned int *)this + 136);
    }
    if (v8)
    {
      v11 = 0;
      v12 = *((_QWORD *)this + 2);
      v13 = *((_QWORD *)this + 67);
      if (v8 < 8)
        goto LABEL_20;
      if ((unint64_t)(v13 - v12) < 0x20)
        goto LABEL_20;
      v11 = v8 & 0xFFFFFFF8;
      v14 = (_OWORD *)(v13 + 16);
      v15 = (__int128 *)(v12 + 16);
      v16 = v11;
      do
      {
        v17 = *v15;
        *(v14 - 1) = *(v15 - 1);
        *v14 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v11 != v8)
      {
LABEL_20:
        v18 = v8 - v11;
        v19 = 4 * v11;
        v20 = (_DWORD *)(v13 + v19);
        v21 = (int *)(v12 + v19);
        do
        {
          v22 = *v21++;
          *v20++ = v22;
          --v18;
        }
        while (v18);
      }
    }
    if (*((_BYTE *)this + 624) && !*((_BYTE *)this + 625))
    {
      v23 = (int *)*((_QWORD *)this + 67);
      v24 = *v23;
      v25 = *((_DWORD *)this + 154);
      v26 = (v25 - 1);
      if (v25 == 1)
        v26 = 0;
      else
        memmove(*((void **)this + 67), v23 + 1, 4 * (v25 - 1));
      v23[v26] = v24;
    }
    if (*((_BYTE *)this + 636))
      Error::chuck((Error *)"NDEAcAnal::feedFromInt() - deltas not supported", a2);
    v27 = *((unsigned int *)this + 142);
    if ((_DWORD)v27)
    {
      v28 = 0;
      v29 = *((_QWORD *)this + 67);
      v30 = *((_QWORD *)this + 70);
      if (v27 < 8)
        goto LABEL_35;
      if ((unint64_t)(v30 - v29) < 0x20)
        goto LABEL_35;
      v28 = v27 & 0xFFFFFFF8;
      v31 = (_OWORD *)(v30 + 16);
      v32 = (__int128 *)(v29 + 16);
      v33 = v28;
      do
      {
        v34 = *v32;
        *(v31 - 1) = *(v32 - 1);
        *v31 = v34;
        v31 += 2;
        v32 += 2;
        v33 -= 8;
      }
      while (v33);
      if (v28 != v27)
      {
LABEL_35:
        v35 = v27 - v28;
        v36 = 4 * v28;
        v37 = (_DWORD *)(v30 + 4 * v28);
        v38 = (int *)(v29 + v36);
        do
        {
          v39 = *v38++;
          *v37++ = v39;
          --v35;
        }
        while (v35);
      }
    }
    *((_BYTE *)this + 660) = 1;
    v6 = (v6 + 1);
  }
  if (v6 >= 2)
    Error::chuck((Error *)"NDEAcAnal::feedFromInt() - we are supposed to get *at most* one frame at a time (num frames = %d) ", a2, v6);
  return result;
}

void *NDEAcAnal::c0Invert(void *this)
{
  int *v1;
  int v2;
  int v3;
  uint64_t v4;

  v1 = (int *)*((_QWORD *)this + 67);
  v2 = *v1;
  v3 = *((_DWORD *)this + 154);
  v4 = (v3 - 1);
  if (v3 == 1)
    v4 = 0;
  else
    this = memmove(*((void **)this + 67), v1 + 1, 4 * (v3 - 1));
  v1[v4] = v2;
  return this;
}

float NDEAcAnal::toOutType(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  _OWORD *v7;
  __int128 *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  int *v15;
  int v16;

  v2 = *(unsigned int *)(a1 + 568);
  if ((_DWORD)v2)
  {
    v3 = *(_QWORD *)(a2 + 8);
    v4 = *(_QWORD *)(a1 + 560);
    if (v2 < 8 || (unint64_t)(v4 - v3) <= 0x1F)
    {
      v6 = 0;
LABEL_10:
      v12 = v2 - v6;
      v13 = 4 * v6;
      v14 = (_DWORD *)(v4 + v13);
      v15 = (int *)(v3 + v13);
      do
      {
        v16 = *v15++;
        LODWORD(v10) = v16;
        *v14++ = v16;
        --v12;
      }
      while (v12);
      return *(float *)&v10;
    }
    v6 = v2 & 0xFFFFFFF8;
    v7 = (_OWORD *)(v4 + 16);
    v8 = (__int128 *)(v3 + 16);
    v9 = v6;
    do
    {
      v10 = *(v8 - 1);
      v11 = *v8;
      *(v7 - 1) = v10;
      *v7 = v11;
      v7 += 2;
      v8 += 2;
      v9 -= 8;
    }
    while (v9);
    if (v6 != v2)
      goto LABEL_10;
  }
  return *(float *)&v10;
}

uint64_t NDEAcAnal::reset(uint64_t this)
{
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 504) = *(_DWORD *)(this + 488) + 1;
  *(_QWORD *)(this + 512) = 0;
  *(_BYTE *)(this + 508) = 0;
  return this;
}

float NDEAcAnal::get_framerate(NDEAcAnal *this)
{
  return (float)*((unsigned int *)this + 162) / (float)*((unsigned int *)this + 164);
}

uint64_t NDEAcAnal::frameAvailable(NDEAcAnal *this)
{
  return *((unsigned __int8 *)this + 660);
}

uint64_t NDEAcAnal::getFrameByRef(NDEAcAnal *this)
{
  return (uint64_t)this + 552;
}

uint64_t NDEAcAnal::frameSize(NDEAcAnal *this)
{
  return *((_DWORD *)this + 154) * ((2 * *((unsigned __int8 *)this + 636)) | 1u);
}

void AccelWin2MFCC::AccelWin2MFCC(AccelWin2MFCC *this)
{
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 12) = 0;
  *((_QWORD *)this + 2) = &off_24C7F3090;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_QWORD *)this + 9) = &off_24C7F3090;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_BYTE *)this + 100) = 0;
  *((_BYTE *)this + 124) = 0;
  *((_QWORD *)this + 16) = &off_24C7F3100;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = &off_24C7F3020;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 22) = &off_24C7F3090;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_BYTE *)this + 204) = 0;
  *((_BYTE *)this + 228) = 0;
  *((_QWORD *)this + 29) = &off_24C7F3388;
  *((_QWORD *)this + 30) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_QWORD *)this + 33) = &off_24C7F3090;
  *((_QWORD *)this + 34) = 0;
  *((_DWORD *)this + 70) = 0;
  *((_QWORD *)this + 38) = &off_24C7F3090;
  *((_QWORD *)this + 39) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 37) = 0;
}

{
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 12) = 0;
  *((_QWORD *)this + 2) = &off_24C7F3090;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_QWORD *)this + 9) = &off_24C7F3090;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_BYTE *)this + 100) = 0;
  *((_BYTE *)this + 124) = 0;
  *((_QWORD *)this + 16) = &off_24C7F3100;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = &off_24C7F3020;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 22) = &off_24C7F3090;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_BYTE *)this + 204) = 0;
  *((_BYTE *)this + 228) = 0;
  *((_QWORD *)this + 29) = &off_24C7F3388;
  *((_QWORD *)this + 30) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_QWORD *)this + 33) = &off_24C7F3090;
  *((_QWORD *)this + 34) = 0;
  *((_DWORD *)this + 70) = 0;
  *((_QWORD *)this + 38) = &off_24C7F3090;
  *((_QWORD *)this + 39) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 37) = 0;
}

_QWORD *N2DArray<float>::~N2DArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F3020;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 24 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 24) = &off_24C7F3090;
        v5 = *(_QWORD *)(v2 + v4 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x1081C80622C3295);
  }
  return a1;
}

void N2DArray<float>::~N2DArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F3020;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F3090;
        v4 = *(_QWORD *)(v1 + v3 - 16);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1081C80622C3295);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NArray<float>>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 - 8);
      if (v7)
      {
        v8 = 24 * v7;
        do
        {
          *(_QWORD *)(v6 + v8 - 24) = &off_24C7F3090;
          v9 = *(_QWORD *)(v6 + v8 - 16);
          if (v9)
            MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
          v8 -= 24;
        }
        while (v8);
      }
      MEMORY[0x212BAC9C0](v6 - 16, 0x1081C80622C3295);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v10 = 24 * v5;
    v11 = (_QWORD *)operator new[]();
    *v11 = 24;
    v11[1] = v5;
    v12 = v11 + 2;
    if (!v5)
      goto LABEL_17;
    v13 = v11 + 2;
    if ((unint64_t)(v10 - 24) >= 0x18)
    {
      v14 = (v10 - 24) / 0x18uLL + 1;
      v15 = v11 + 4;
      v16 = v14 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v15 - 2) = &off_24C7F3090;
        *(v15 - 1) = 0;
        v15[1] = &off_24C7F3090;
        v15[2] = 0;
        *(_DWORD *)v15 = 0;
        *((_DWORD *)v15 + 6) = 0;
        v15 += 6;
        v16 -= 2;
      }
      while (v16);
      if (v14 == (v14 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_17;
      v13 = &v12[3 * (v14 & 0x1FFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v13 = &off_24C7F3090;
      v13[1] = 0;
      *((_DWORD *)v13 + 4) = 0;
      v13 += 3;
    }
    while (v13 != &v12[3 * v5]);
LABEL_17:
    *(_QWORD *)(a1 + 8) = v12;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v17) + 16))(*(_QWORD *)(a1 + 8) + v17, *(_QWORD *)(a2 + 8) + v17);
      ++v18;
      v17 += 24;
    }
    while (v18 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NArray<NArray<float>>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = 24 * v9;
        do
        {
          *(_QWORD *)(v7 + v10 - 24) = &off_24C7F3090;
          v11 = *(_QWORD *)(v7 + v10 - 16);
          if (v11)
            MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x1081C80622C3295);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v12 = 24 * v6;
    result = operator new[]();
    *(_QWORD *)result = 24;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (!v6)
      goto LABEL_16;
    v14 = result + 16;
    if ((unint64_t)(v12 - 24) >= 0x18)
    {
      v15 = (v12 - 24) / 0x18uLL + 1;
      v16 = result + 32;
      v17 = v15 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(_QWORD *)(v16 - 16) = &off_24C7F3090;
        *(_QWORD *)(v16 - 8) = 0;
        *(_QWORD *)(v16 + 8) = &off_24C7F3090;
        *(_QWORD *)(v16 + 16) = 0;
        *(_DWORD *)v16 = 0;
        *(_DWORD *)(v16 + 24) = 0;
        v16 += 48;
        v17 -= 2;
      }
      while (v17);
      if (v15 == (v15 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_16;
      v14 = v13 + 24 * (v15 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v14 = &off_24C7F3090;
      *(_QWORD *)(v14 + 8) = 0;
      *(_DWORD *)(v14 + 16) = 0;
      v14 += 24;
    }
    while (v14 != v13 + 24 * v6);
LABEL_16:
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + v18) + 16))(*(_QWORD *)(v4 + 8) + v18, a2 + v18);
      ++v19;
      v18 += 24;
    }
    while (v19 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

_QWORD *NArray<NArray<float>>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F3020;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 24 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 24) = &off_24C7F3090;
        v5 = *(_QWORD *)(v2 + v4 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x1081C80622C3295);
  }
  return a1;
}

void NArray<NArray<float>>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F3020;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F3090;
        v4 = *(_QWORD *)(v1 + v3 - 16);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1081C80622C3295);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t AccelWin2MFCC::init(AccelWin2MFCC *this, unsigned int *a2, const unsigned int *a3, const BOOL *a4, const BOOL *a5, const BOOL *a6, const BOOL *a7, const unsigned int *a8, double a9, const float *a10, const float *a11, const unsigned int *a12, const unsigned int *a13, const float *a14, const float *a15, const float *a16, const float *a17)
{
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t result;

  *(_BYTE *)this = 0;
  v18 = *a2;
  *((_DWORD *)this + 83) = *a2;
  v19 = *a3;
  *((_DWORD *)this + 84) = *a3;
  *((_BYTE *)this + 340) = *a4;
  v20 = 1;
  do
  {
    v21 = v20;
    v20 *= 2;
  }
  while (v21 < v19);
  *((_DWORD *)this + 86) = v21;
  *((_DWORD *)this + 87) = (v21 >> 1) + 1;
  *((_BYTE *)this + 352) = *a7;
  *((float *)this + 89) = *a14 * *a15;
  *((_BYTE *)this + 360) = *a5;
  v22 = *a8;
  *((_DWORD *)this + 91) = *a8;
  *((_DWORD *)this + 92) = v18 >> 1;
  *((float *)this + 93) = *a10;
  *((float *)this + 94) = *a11;
  *((float *)this + 95) = *a16;
  *(float *)&a9 = *a17;
  *((float *)this + 96) = *a17;
  v23 = *(unsigned __int8 *)a6;
  *((_BYTE *)this + 361) = v23;
  *((_DWORD *)this + 97) = *a12;
  if (v23)
    v24 = v22;
  else
    v24 = *a13;
  *((_DWORD *)this + 98) = v24;
  AccelWin2MFCC::initProc(this, a9);
  result = AccelWin2MFCC::initData((void **)this);
  *((_DWORD *)this + 82) = 1065353216;
  *(_BYTE *)this = 1;
  return result;
}

void AccelWin2MFCC::initProc(AccelWin2MFCC *this, double a2)
{
  int v3;

  AccelWindow::init((AccelWin2MFCC *)((char *)this + 8), (const char *)this + 336, (const BOOL *)this + 340, (const BOOL *)this + 360, a2);
  AccelFFT::init((vDSP_DFT_SetupStruct **)this + 6, (const char *)this + 336, (unsigned int *)this + 86, (const unsigned int *)this + 87);
  *((_DWORD *)this + 26) = *((_DWORD *)this + 87);
  *((_BYTE *)this + 108) = *((_BYTE *)this + 352);
  *((_DWORD *)this + 24) = 0;
  *((_BYTE *)this + 100) = 1;
  AccelMelFilter::init((AccelWin2MFCC *)((char *)this + 112), (const char *)this + 364, (const unsigned int *)this + 87, (const unsigned int *)this + 92, (const float *)this + 93, (float *)this + 94, (float *)this + 95, (float *)this + 96);
  v3 = *((_DWORD *)this + 89);
  *((_DWORD *)this + 50) = *((_DWORD *)this + 91);
  *((_BYTE *)this + 204) = 1;
  *((_DWORD *)this + 52) = v3;
  if (!*((_BYTE *)this + 361))
    AccelCosine::init((AccelWin2MFCC *)((char *)this + 216), (const char *)this + 364, (const unsigned int *)this + 98, (const unsigned int *)this + 97);
}

uint64_t AccelWin2MFCC::initData(void **this)
{
  void **v2;
  uint64_t result;
  const char *v4;
  unsigned int v5;
  int v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  __int128 *v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  char *v17;
  int v18;

  v2 = this + 36;
  free(this[36]);
  this[36] = 0;
  this[37] = 0;
  result = malloc_type_posix_memalign(v2, 0x10uLL, 4 * *((unsigned int *)this + 86), 0x100004052888210uLL);
  if ((_DWORD)result)
    Error::chuck((Error *)"AccelWin2MFCC::initData - posix_memalign returned an error", v4);
  this[37] = (char *)this[36] + ((2 * *((unsigned int *)this + 86)) & 0x1FFFFFFFCLL);
  v5 = *((_DWORD *)this + 80);
  v6 = *((_DWORD *)this + 98);
  if (v5 != v6)
  {
    v7 = (char *)this[39];
    *((_DWORD *)this + 80) = v6;
    result = operator new[]();
    this[39] = (void *)result;
    LODWORD(v8) = *((_DWORD *)this + 98);
    if (v5 >= v8)
      v8 = v8;
    else
      v8 = v5;
    if ((_DWORD)v8)
    {
      v9 = 0;
      if (v8 < 8)
        goto LABEL_13;
      if ((unint64_t)(result - (_QWORD)v7) <= 0x1F)
        goto LABEL_13;
      v9 = v8 & 0xFFFFFFF8;
      v10 = (_OWORD *)(result + 16);
      v11 = (__int128 *)(v7 + 16);
      v12 = v9;
      do
      {
        v13 = *v11;
        *(v10 - 1) = *(v11 - 1);
        *v10 = v13;
        v10 += 2;
        v11 += 2;
        v12 -= 8;
      }
      while (v12);
      if (v9 != v8)
      {
LABEL_13:
        v14 = v8 - v9;
        v15 = 4 * v9;
        v16 = (_DWORD *)(result + 4 * v9);
        v17 = &v7[v15];
        do
        {
          v18 = *(_DWORD *)v17;
          v17 += 4;
          *v16++ = v18;
          --v14;
        }
        while (v14);
      }
    }
    else if (!v7)
    {
      return result;
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

void AccelWin2MFCC::~AccelWin2MFCC(void **this)
{
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  vDSP_DFT_SetupStruct *v14;
  void *v15;
  void *v16;

  free(this[36]);
  this[38] = &off_24C7F3090;
  v2 = this[39];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  this[33] = &off_24C7F3090;
  v3 = this[34];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  this[29] = &off_24C7F3020;
  v4 = this[30];
  if (v4)
  {
    v5 = *(v4 - 1);
    if (v5)
    {
      v6 = 3 * v5;
      do
      {
        v4[v6 - 3] = &off_24C7F3090;
        v7 = v4[v6 - 2];
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        v6 -= 3;
      }
      while (v6 * 8);
    }
    MEMORY[0x212BAC9C0](v4 - 2, 0x1081C80622C3295);
  }
  this[22] = &off_24C7F3090;
  v8 = this[23];
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  this[19] = &off_24C7F3020;
  v9 = this[20];
  if (v9)
  {
    v10 = *(v9 - 1);
    if (v10)
    {
      v11 = 3 * v10;
      do
      {
        v9[v11 - 3] = &off_24C7F3090;
        v12 = v9[v11 - 2];
        if (v12)
          MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
        v11 -= 3;
      }
      while (v11 * 8);
    }
    MEMORY[0x212BAC9C0](v9 - 2, 0x1081C80622C3295);
  }
  this[16] = &off_24C7F3100;
  v13 = this[17];
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
  v14 = (vDSP_DFT_SetupStruct *)this[6];
  if (v14)
    vDSP_DFT_DestroySetup(v14);
  this[9] = &off_24C7F3090;
  v15 = this[10];
  if (v15)
    MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
  this[2] = &off_24C7F3090;
  v16 = this[3];
  if (v16)
    MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
}

uint64_t AccelWin2MFCC::run(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  const char *v6;
  float *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  const char *v11;
  float *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  __int128 *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  int *v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  const float *v29;
  uint64_t v30;
  int v32;
  float __C;

  if (!*(_BYTE *)a1)
    Error::chuck((Error *)"AccelWin2MFCC::run - AccelWin2MFCC::init() has to be called before running", (const char *)a2);
  v4 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v4 != *(_DWORD *)(a1 + 336))
    Error::chuck((Error *)"AccelWin2MFCC::run - length of input should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 336), v4);
  if (!*(_BYTE *)(a1 + 12))
    Error::chuck((Error *)"AccelWindow::apply() - AccelWindow::init() has to be called before running", (const char *)a2);
  v5 = (unsigned int *)(a1 + 8);
  if ((_DWORD)v4 != *(_DWORD *)(a1 + 8))
    Error::chuck((Error *)"AccelWindow::apply() - length of input array should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 8), v4);
  AccelWindow::applyHamming(v5, a2);
  AccelFFT::run(a1 + 48, a2, (const DSPSplitComplex *)(a1 + 288));
  AccelPSD::run((AccelPSD *)(a1 + 96), (DSPSplitComplex *)(a1 + 288));
  if (!*(_BYTE *)(a1 + 124))
    Error::chuck((Error *)"AccelMelFilter::run - AccelMelFilter::init() must be called before running", v6);
  v7 = *(float **)(a1 + 288);
  if (*(_DWORD *)(a1 + 112))
  {
    v8 = 0;
    do
    {
      vDSP_dotpr(&v7[*(unsigned int *)(*(_QWORD *)(a1 + 136) + 4 * v8)], 1, *(const float **)(*(_QWORD *)(a1 + 160) + 24 * v8 + 8), 1, (float *)(*(_QWORD *)(a1 + 184) + 4 * v8), *(unsigned int *)(*(_QWORD *)(a1 + 160) + 24 * v8 + 16));
      ++v8;
      v9 = *(unsigned int *)(a1 + 112);
    }
    while (v8 < v9);
    v10 = 4 * v9;
  }
  else
  {
    v10 = 0;
  }
  memcpy(v7, *(const void **)(a1 + 184), v10);
  if (!*(_BYTE *)(a1 + 204))
    Error::chuck((Error *)"AccelLoga::run - AccelLoga::init() has to be called before running", v11);
  v12 = *(float **)(a1 + 288);
  vDSP_vsadd(v12, 1, (const float *)(a1 + 208), v12, 1, *(unsigned int *)(a1 + 200));
  v32 = *(_DWORD *)(a1 + 200);
  vvlogf(v12, v12, &v32);
  if (*(_BYTE *)(a1 + 361))
  {
    v14 = *(unsigned int *)(a1 + 392);
    if ((_DWORD)v14)
    {
      v15 = 0;
      v16 = *(_QWORD *)(a1 + 288);
      v17 = *(_QWORD *)(a1 + 312);
      if (v14 < 8)
        goto LABEL_19;
      if ((unint64_t)(v17 - v16) < 0x20)
        goto LABEL_19;
      v15 = v14 & 0xFFFFFFF8;
      v18 = (_OWORD *)(v17 + 16);
      v19 = (__int128 *)(v16 + 16);
      v20 = v15;
      do
      {
        v21 = *v19;
        *(v18 - 1) = *(v19 - 1);
        *v18 = v21;
        v18 += 2;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v15 != v14)
      {
LABEL_19:
        v22 = v14 - v15;
        v23 = 4 * v15;
        v24 = (_DWORD *)(v17 + 4 * v15);
        v25 = (int *)(v16 + v23);
        do
        {
          v26 = *v25++;
          *v24++ = v26;
          --v22;
        }
        while (v22);
      }
    }
  }
  else
  {
    if (!*(_BYTE *)(a1 + 228))
      Error::chuck((Error *)"AccelCosine::run() - AccelCosine::init() has to be called before running", v13);
    v27 = *(unsigned int *)(a1 + 320);
    if ((_DWORD)v27 != *(_DWORD *)(a1 + 220))
      Error::chuck((Error *)"AccelCosine::run() - length of output should be %d, not %d", v13, *(unsigned int *)(a1 + 220), v27);
    if ((_DWORD)v27)
    {
      v28 = 0;
      v29 = *(const float **)(a1 + 288);
      v30 = 8;
      do
      {
        __C = 0.0;
        vDSP_dotpr(v29, 1, *(const float **)(*(_QWORD *)(a1 + 240) + v30), 1, &__C, *(unsigned int *)(a1 + 216));
        *(float *)(*(_QWORD *)(a1 + 312) + 4 * v28) = *(float *)(*(_QWORD *)(a1 + 272) + 4 * v28) * __C;
        ++v28;
        v30 += 24;
      }
      while (v28 < *(unsigned int *)(a1 + 220));
    }
  }
  return a1 + 304;
}

uint64_t AccelWin2MFCC::getScalingFactor(AccelWin2MFCC *this)
{
  return (uint64_t)this + 328;
}

uint64_t TSAcAnal::init(TSAcAnal *this, const NString *a2, uint64_t a3, const NString *a4, char a5, BOOL a6)
{
  int v8;
  int *v9;
  int v10;
  int v11;
  BOOL v12;
  int v13;
  uint64_t i;
  uint64_t result;
  BOOL v16;

  v16 = a6;
  if (!(_DWORD)a3)
    Error::chuck((Error *)"TSAcAnal::init() - a_iSamRate (= %d) must be strictly positive\n", (const char *)a2, a3, a4, 0);
  v8 = *((_DWORD *)a4 + 2);
  if (v8 == 8)
  {
    if (**((_QWORD **)a4 + 2) != 0x454C5F54414F4C46)
      goto LABEL_17;
    v13 = 4;
  }
  else
  {
    if (v8 != 6
      || ((v9 = (int *)*((_QWORD *)a4 + 2), v10 = *v9, v11 = *((unsigned __int16 *)v9 + 2), v10 == 1597387091)
        ? (v12 = v11 == 17740)
        : (v12 = 0),
          !v12))
    {
LABEL_17:
      Error::chuck((Error *)"TSAcAnal::init() - sorry, format must be 'S16_LE' or 'FLOAT_LE'", (const char *)a2);
    }
    v13 = 2;
  }
  *((_DWORD *)this + 285) = v13;
  *((_DWORD *)this + 284) = a3;
  if ((TSAcAnal *)((char *)this + 1112) != a2)
    (*(void (**)(char *, _QWORD, char *))(*((_QWORD *)this + 139) + 64))((char *)this + 1112, *((_QWORD *)a2 + 2), (char *)a2 + 8);
  *((_BYTE *)this + 1104) = a5;
  NWavChunk2HTKFrames::init(this, (TSAcAnal *)((char *)this + 1112), (unsigned int *)this + 284, (const BOOL *)this + 1104, &v16);
  *((float *)this + 286) = (float)*((unsigned int *)this + 243) / (float)*((unsigned int *)this + 245);
  *((_BYTE *)this + 1148) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 138) = *((_DWORD *)this + 134) + 1;
  *((_QWORD *)this + 70) = 0;
  *((_BYTE *)this + 556) = 0;
  NDynamicMFCC::reset((TSAcAnal *)((char *)this + 576));
  *((_QWORD *)this + 131) = 0;
  *((_QWORD *)this + 130) = 0;
  for (i = *((_QWORD *)this + 127); i; i = *((_QWORD *)this + 127))
  {
    *((_QWORD *)this + 127) = *(_QWORD *)(i + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 126) + 72))((char *)this + 1008);
  }
  *((_QWORD *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;
  *((_QWORD *)this + 132) = 0;
  *(_QWORD *)((char *)this + 1061) = 0;
  result = NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1000, (int *)this + 268);
  *((_BYTE *)this + 1149) = 1;
  return result;
}

uint64_t TSAcAnal::reset(TSAcAnal *this)
{
  uint64_t i;

  *((_BYTE *)this + 1148) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 138) = *((_DWORD *)this + 134) + 1;
  *((_QWORD *)this + 70) = 0;
  *((_BYTE *)this + 556) = 0;
  NDynamicMFCC::reset((TSAcAnal *)((char *)this + 576));
  *((_QWORD *)this + 131) = 0;
  *((_QWORD *)this + 130) = 0;
  for (i = *((_QWORD *)this + 127); i; i = *((_QWORD *)this + 127))
  {
    *((_QWORD *)this + 127) = *(_QWORD *)(i + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 126) + 72))((char *)this + 1008);
  }
  *((_QWORD *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;
  *((_QWORD *)this + 132) = 0;
  *(_QWORD *)((char *)this + 1061) = 0;
  return NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1000, (int *)this + 268);
}

float TSAcAnal::get_framerate(TSAcAnal *this)
{
  return *((float *)this + 286);
}

uint64_t TSAcAnal::feedFromInt(TSAcAnal *this, const char *a2, unsigned int *a3)
{
  int v4;

  if (!*((_BYTE *)this + 1149))
    Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2, a3);
  if (*((_BYTE *)this + 1148))
    Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffer "
               "(m_queue) has been emptied (call reset())",
      a2,
      a3);
  v4 = 0;
  return NWavChunk2HTKFrames::run((uint64_t)this, a2, (int *)a3, &v4, (uint64_t)this + 1000);
}

uint64_t TSAcAnal::feedFromFloat(TSAcAnal *this, const float *a2, unsigned int *a3)
{
  int v4;

  if (!*((_BYTE *)this + 1149))
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - you must call TSAcAnal::init() before feedFromFloat()", (const char *)a2, a3);
  if (*((_BYTE *)this + 1148))
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
               "r (m_queue) has been emptied (call reset())",
      (const char *)a2,
      a3);
  v4 = 1;
  return NWavChunk2HTKFrames::run((uint64_t)this, (const char *)a2, (int *)a3, &v4, (uint64_t)this + 1000);
}

uint64_t TSAcAnal::feed(TSAcAnal *this, const NString *a2)
{
  unsigned int v2;
  const char *v3;
  unsigned int v5;
  _BOOL4 v6;

  if (!*((_BYTE *)this + 1149))
    Error::chuck((Error *)"TSAcAnal::feed() - you must call TSAcAnal::init() before feed()", (const char *)a2);
  if (*((_BYTE *)this + 1148))
    Error::chuck((Error *)"TSAcAnal::feed() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffer (m_queu"
               "e) has been emptied (call reset())",
      (const char *)a2);
  v2 = *((_DWORD *)this + 285);
  v6 = v2 == 4;
  v3 = (const char *)*((_QWORD *)a2 + 2);
  v5 = *((_DWORD *)a2 + 2) / v2;
  return NWavChunk2HTKFrames::run((uint64_t)this, v3, (int *)&v5, (int *)&v6, (uint64_t)this + 1000);
}

uint64_t TSAcAnal::endfeed(TSAcAnal *this, const char *a2)
{
  uint64_t result;

  if (!*((_BYTE *)this + 1149))
    Error::chuck((Error *)"TSAcAnal::endfeed() - you must call TSAcAnal::init() before endfeed()\n", a2);
  if (*((_BYTE *)this + 1148))
    Error::chuck((Error *)"TSAcAnal::endfeed() - TSAcAnal::endfeed() has been called before; is cannot be called againbefore the buf"
               "fer (m_queue) has been emptied\n",
      a2);
  result = NWavChunk2HTKFrames::finish((uint64_t)this, (const char *)this + 1000);
  *((_BYTE *)this + 1068) = 1;
  *((_BYTE *)this + 1148) = 1;
  return result;
}

BOOL TSAcAnal::eos(TSAcAnal *this)
{
  if (!*((_BYTE *)this + 1148))
    return 0;
  if (*((_BYTE *)this + 1068))
    return *((_DWORD *)this + 264) == *((_DWORD *)this + 265);
  return (*((_DWORD *)this + 264) - *((_DWORD *)this + 265)) < 2;
}

BOOL TSAcAnal::framesAvailable(TSAcAnal *this)
{
  if (*((_BYTE *)this + 1068))
    return *((_DWORD *)this + 264) != *((_DWORD *)this + 265);
  else
    return (*((_DWORD *)this + 264) - *((_DWORD *)this + 265)) > 1;
}

uint64_t TSAcAnal::getframe@<X0>(TSAcAnal *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  char *FrameByRef;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  int v17;

  FrameByRef = TSAcAnal::getFrameByRef(this, a2);
  *(_QWORD *)a3 = &off_24C7F3090;
  v5 = *((unsigned int *)FrameByRef + 4);
  *(_DWORD *)(a3 + 16) = v5;
  result = operator new[]();
  *(_QWORD *)(a3 + 8) = result;
  if ((_DWORD)v5)
  {
    v7 = 0;
    v8 = *((_QWORD *)FrameByRef + 1);
    if (v5 < 8)
      goto LABEL_7;
    if ((unint64_t)(result - v8) < 0x20)
      goto LABEL_7;
    v7 = v5 & 0xFFFFFFF8;
    v9 = (_OWORD *)(result + 16);
    v10 = (__int128 *)(v8 + 16);
    v11 = v7;
    do
    {
      v12 = *v10;
      *(v9 - 1) = *(v10 - 1);
      *v9 = v12;
      v9 += 2;
      v10 += 2;
      v11 -= 8;
    }
    while (v11);
    if (v7 != v5)
    {
LABEL_7:
      v13 = v5 - v7;
      v14 = 4 * v7;
      v15 = (_DWORD *)(result + 4 * v7);
      v16 = (int *)(v8 + v14);
      do
      {
        v17 = *v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
    }
  }
  *(_QWORD *)a3 = &off_24C7F31A8;
  return result;
}

char *TSAcAnal::getFrameByRef(TSAcAnal *this, const char *a2)
{
  int v2;
  BOOL v3;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  __int128 *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int *v21;
  int v22;

  v2 = *((_DWORD *)this + 265);
  if (*((_BYTE *)this + 1068))
    v3 = *((_DWORD *)this + 264) != v2;
  else
    v3 = (*((_DWORD *)this + 264) - v2) > 1;
  if (!v3)
    Error::chuck((Error *)"TSAcAnal::getframe() - no frame available", a2);
  v5 = *((_QWORD *)this + 131);
  *((_QWORD *)this + 131) = *(_QWORD *)(v5 + 8);
  *((_DWORD *)this + 265) = v2 + 1;
  v6 = (char *)this + 1080;
  if ((TSAcAnal *)((char *)this + 1080) != (TSAcAnal *)(v5 + 16))
  {
    v7 = *((_DWORD *)this + 274);
    v8 = *(_DWORD *)(v5 + 32);
    if (v7 != v8)
    {
      v9 = *((_QWORD *)this + 136);
      if (v9)
      {
        MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v8 = *(_DWORD *)(v5 + 32);
      }
      *((_DWORD *)this + 274) = v8;
      *((_QWORD *)this + 136) = operator new[]();
      v7 = *((_DWORD *)this + 274);
    }
    if (v7)
    {
      v10 = 0;
      v11 = *(_QWORD *)(v5 + 24);
      v12 = *((_QWORD *)this + 136);
      v13 = v7;
      if (v7 < 8)
        goto LABEL_16;
      if ((unint64_t)(v12 - v11) < 0x20)
        goto LABEL_16;
      v10 = v7 & 0xFFFFFFF8;
      v14 = (_OWORD *)(v12 + 16);
      v15 = (__int128 *)(v11 + 16);
      v16 = v13 & 0xFFFFFFF8;
      do
      {
        v17 = *v15;
        *(v14 - 1) = *(v15 - 1);
        *v14 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v10 != v13)
      {
LABEL_16:
        v18 = v13 - v10;
        v19 = 4 * v10;
        v20 = (_DWORD *)(v12 + v19);
        v21 = (int *)(v11 + v19);
        do
        {
          v22 = *v21++;
          *v20++ = v22;
          --v18;
        }
        while (v18);
      }
    }
  }
  return v6;
}

char *TSAcAnal::getStringFrame@<X0>(TSAcAnal *this@<X0>, uint64_t a2@<X8>)
{
  char *result;
  unint64_t v5;
  _WORD *v6;
  unsigned int v7[2];
  int v8;
  _BYTE *v9;
  int v10;

  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 5;
  result = (char *)operator new[]();
  *(_QWORD *)(a2 + 16) = result;
  strcpy(result, "empty");
  if (*((_DWORD *)this + 274))
  {
    v7[0] = 0;
    result = (char *)NString::assignTo((NString *)a2, "", v7);
    if (*((_DWORD *)this + 274))
    {
      v5 = 0;
      do
      {
        *(_QWORD *)v7 = &off_24C7F32C0;
        v8 = 0;
        v9 = (_BYTE *)operator new[]();
        *v9 = 0;
        NString::printf((NString *)v7, "%10.4f", *(float *)(*((_QWORD *)this + 136) + 4 * v5));
        if (v8)
        {
          v10 = v8;
          (*(void (**)(uint64_t, _BYTE *, int *))(*(_QWORD *)a2 + 72))(a2, v9, &v10);
        }
        *(_QWORD *)v7 = &off_24C7F32C0;
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
        v6 = (_WORD *)operator new[]();
        *v6 = 32;
        v7[0] = 1;
        (*(void (**)(uint64_t, _WORD *, unsigned int *))(*(_QWORD *)a2 + 72))(a2, v6, v7);
        result = (char *)MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
        ++v5;
      }
      while (v5 < *((unsigned int *)this + 274));
    }
  }
  return result;
}

void sub_20D992D3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _QWORD *v13;
  uint64_t v14;
  uint64_t v16;

  *v13 = v14;
  v16 = v13[2];
  if (v16)
    MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t TSAcAnal::framesQueued(TSAcAnal *this)
{
  return (*((_DWORD *)this + 264) - *((_DWORD *)this + 265));
}

uint64_t TSAcAnal::isTypeInt4(TSAcAnal *this)
{
  return 0;
}

uint64_t TSAcAnal::parmCode(TSAcAnal *this)
{
  int v1;

  if (*((_BYTE *)this + 929))
    v1 = 0;
  else
    v1 = 3 * *((unsigned __int8 *)this + 801);
  return (v1 + (*((unsigned __int8 *)this + 929) | 6) + 768 * *((unsigned __int8 *)this + 984)) | (*((unsigned __int8 *)this + 956) << 13);
}

uint64_t TSAcAnal::frameSize(TSAcAnal *this)
{
  return *((_DWORD *)this + 238) * ((2 * *((unsigned __int8 *)this + 984)) | 1u);
}

uint64_t TSAcAnal::numStatic(TSAcAnal *this)
{
  return *((unsigned int *)this + 238);
}

void sub_20D992FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 buf)
{
  NSObject *v11;

  if (a2)
  {
    __cxa_begin_catch(exception_object);
    v11 = VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
    {
      buf = 0;
      _os_log_impl(&dword_20D965000, v11, OS_LOG_TYPE_DEFAULT, "VTTranscriber failed : _EARSpeechRecognizer initWithConfiguration", (uint8_t *)&buf, 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x20D992F6CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_20D9930D0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  uint64_t v9;
  NSObject *v10;

  __cxa_begin_catch(a1);
  v10 = *(NSObject **)(v9 + 2744);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_20D965000, v10, OS_LOG_TYPE_DEFAULT, "VTTranscriber runRecognitionWithCallback failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20D9930B8);
}

void sub_20D993118(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D993154(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  NSObject *v9;

  __cxa_begin_catch(a1);
  v9 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_20D965000, v9, OS_LOG_TYPE_DEFAULT, "VTTranscriber recognizeWavData failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20D993144);
}

void sub_20D993214(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  uint64_t v9;
  NSObject *v10;

  __cxa_begin_catch(a1);
  v10 = *(NSObject **)(v9 + 2744);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_20D965000, v10, OS_LOG_TYPE_DEFAULT, "VTTranscriber endAudio failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20D993200);
}

void sub_20D9934F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_20D993700(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_20D9939AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D993A3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_20D993BE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

IntNovDetect *nd_create()
{
  IntNovDetect *v0;

  if ((initndlib(void)::bNDLibInitialized & 1) == 0)
    initndlib(void)::bNDLibInitialized = 1;
  v0 = (IntNovDetect *)operator new();
  IntNovDetect::IntNovDetect(v0);
  return v0;
}

void sub_20D993C8C(void *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10F0C404F423172);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x20D993C7CLL);
}

uint64_t nd_addresource(IntNovDetect *a1, const char *a2, const NString *a3, const void *a4)
{
  if (a1)
    IntNovDetect::addresource(a1, a2, a3, a4);
  return 0xFFFFFFFFLL;
}

void sub_20D993E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_initialize(IntNovDetect *a1, const char *a2, const char *a3)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::initialize(a1, a2, a3);
  return 0;
}

void sub_20D994068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_wavedata(IntNovDetect *a1, const char *a2, int a3)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::wavedata(a1, a2, a3);
  return 0;
}

void sub_20D994280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_wavedataf(IntNovDetect *a1, const float *a2, int a3)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::wavedataf(a1, a2, a3);
  return 0;
}

void sub_20D994498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

char *nd_getresults(char *result, const char *a2)
{
  if (result)
    return IntNovDetect::getresults((IntNovDetect *)result, a2);
  return result;
}

char *nd_getphraseresults(char *result, const char *a2)
{
  if (result)
    return IntNovDetect::getphraseresults((IntNovDetect *)result, a2);
  return result;
}

uint64_t nd_phrasecount(uint64_t a1, const char *a2)
{
  char *v4;
  int v5;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1838836561)
  {
    v4 = "Invalid NovDetect Object Signature";
    goto LABEL_9;
  }
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    v4 = "NovDetect: phrasecount() can only be called after initialize()";
LABEL_9:
    Error::chuck((Error *)v4, a2);
  }
  if (*(_BYTE *)(a1 + 40))
  {
    v5 = 6;
    (*(void (**)(uint64_t, const char *, int *))(*(_QWORD *)(a1 + 16) + 64))(a1 + 16, "all ok", &v5);
    *(_BYTE *)(a1 + 40) = 0;
  }
  return *(unsigned int *)(a1 + 3080);
}

void sub_20D994B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

IntNovDetect *nd_getresultsstr(IntNovDetect *result, const char *a2)
{
  if (result)
    return (IntNovDetect *)IntNovDetect::getresultsstr(result, a2);
  return result;
}

char *nd_getsupervector(char *result, const char *a2, double a3)
{
  if (result)
    return IntNovDetect::getsupervector((IntNovDetect *)result, a2, a3);
  return result;
}

char *nd_scoresupervector(char *result, const float *a2, uint64_t a3)
{
  if (result)
    return IntNovDetect::scoresupervector((IntNovDetect *)result, a2, a3);
  return result;
}

uint64_t nd_resetbest(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::resetbest(a1, a2);
  return 0;
}

void sub_20D995384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_reset(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::reset(a1, a2);
  return 0;
}

void sub_20D99559C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_endwavedata(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::endwavedata(a1, a2);
  return 0;
}

void sub_20D9957B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_close(IntNovDetect *a1)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::~IntNovDetect(a1);
  MEMORY[0x212BAC9D8]();
  return 0;
}

IntNovDetect *nd_getoption(IntNovDetect *result, const char *a2)
{
  if (result)
    return (IntNovDetect *)IntNovDetect::getoption(result, a2);
  return result;
}

uint64_t nd_sat_initialize(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::sat_initialize(a1, a2);
  return 0;
}

void sub_20D995C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_analyze(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4;
  int v5;
  char *v6;
  int v8;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1838836561)
  {
    v6 = "Invalid NovDetect Object Signature";
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 12) != 1)
  {
    v6 = "NovDetect: sat_analyze() can only be called after sat_initialize()";
LABEL_8:
    Error::chuck((Error *)v6, a2);
  }
  *(_DWORD *)(a1 + 2680) = 0;
  TSSATScorer::score((TSSATScorer *)(a1 + 2184), (const float *)a2, a3);
  v4 = a1 + 2680;
  *(_DWORD *)(a1 + 2680) = v5;
  if (*(_BYTE *)(a1 + 40))
  {
    v8 = 6;
    (*(void (**)(uint64_t, const char *, int *))(*(_QWORD *)(a1 + 16) + 64))(a1 + 16, "all ok", &v8);
    *(_BYTE *)(a1 + 40) = 0;
  }
  return v4;
}

void sub_20D995E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_analyzetransformed(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4;
  int v5;
  char *v6;
  int v8;

  if (!a1)
    return 0;
  if (*(_DWORD *)a1 != -1838836561)
  {
    v6 = "Invalid NovDetect Object Signature";
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 12) != 1)
  {
    v6 = "NovDetect: sat_analyzetransformed() can only be called after sat_initialize()";
LABEL_8:
    Error::chuck((Error *)v6, a2);
  }
  *(_DWORD *)(a1 + 2728) = 0;
  TSSATScorer::scoreSpeakerVector((TSSATScorer *)(a1 + 2184), (const float *)a2, a3);
  v4 = a1 + 2728;
  *(_DWORD *)(a1 + 2728) = v5;
  if (*(_BYTE *)(a1 + 40))
  {
    v8 = 6;
    (*(void (**)(uint64_t, const char *, int *))(*(_QWORD *)(a1 + 16) + 64))(a1 + 16, "all ok", &v8);
    *(_BYTE *)(a1 + 40) = 0;
  }
  return v4;
}

void sub_20D996120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_update(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::sat_update(a1, a2);
  return 0;
}

void sub_20D996338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_deletevector(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::sat_deletevector(a1, a2);
  return 0;
}

void sub_20D996550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_vectorcount(uint64_t a1, const char *a2)
{
  uint64_t v3;
  char *v4;
  int v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != -1838836561)
  {
    v4 = "Invalid NovDetect Object Signature";
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 12) != 1)
  {
    v4 = "NovDetect: sat_vectorcount() can only be called after sat_initialize()";
LABEL_8:
    Error::chuck((Error *)v4, a2);
  }
  v3 = *(unsigned int *)(a1 + 2308);
  if (*(_BYTE *)(a1 + 40))
  {
    v6 = 6;
    (*(void (**)(uint64_t, const char *, int *))(*(_QWORD *)(a1 + 16) + 64))(a1 + 16, "all ok", &v6);
    *(_BYTE *)(a1 + 40) = 0;
  }
  return v3;
}

void sub_20D9967C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_reset(IntNovDetect *a1, const char *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  IntNovDetect::sat_reset(a1, a2);
  return 0;
}

void sub_20D9969DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

char *nd_sat_getspeakervector(char *result, const char *a2)
{
  if (result)
    return IntNovDetect::sat_getspeakervector((IntNovDetect *)result, a2);
  return result;
}

const char *nd_error(uint64_t a1)
{
  if (!a1)
    return "Invalid NovDetect pointer (NULL)";
  if (*(_DWORD *)(a1 + 4) == 2 || *(_DWORD *)a1 != -1838836561)
    return "Invalid NovDetect object";
  return *(const char **)(a1 + 32);
}

uint64_t nd_initlog(void (*a1)(void))
{
  char *v2;

  if ((initndlib(void)::bNDLibInitialized & 1) == 0)
    initndlib(void)::bNDLibInitialized = 1;
  if (a1)
  {
    v2 = (char *)operator new[]();
    strcpy(v2, "Novalib gitrelno_unavailable Release Sat Aug  3 09:26:23 2024");
    a1();
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  }
  return 0;
}

void sub_20D996D60(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x20D996D50);
  }
  _Unwind_Resume(a1);
}

uint64_t nd_logcontrol(const char *a1, const char *a2)
{
  void *v3;
  char *v4;
  char *v5;
  char *v6;
  unsigned int v8;
  uint64_t (**v9)(NString *__hidden, const unsigned int *);
  int v10;
  char *v11;
  uint64_t (**v12)(NString *__hidden, const unsigned int *);
  int v13;
  void *v14;
  uint64_t (**v15)();
  char *v16;
  uint64_t v17;
  int v18;

  v12 = &off_24C7F32C0;
  if (!a1)
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  v13 = strlen(a1);
  v3 = (void *)operator new[]();
  v14 = v3;
  memcpy(v3, a1, (v13 + 1));
  v9 = &off_24C7F32C0;
  v10 = 5;
  v4 = (char *)operator new[]();
  v11 = v4;
  strcpy(v4, ", \t\r\n");
  v8 = -1;
  v16 = 0;
  v17 = 0;
  v15 = off_24C7F13C0;
  v18 = 0;
  NString::split((uint64_t)&v12, (uint64_t)&v15, (uint64_t)&v9, &v8);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  v5 = v16;
  if (v16)
  {
    v6 = v16;
    do
      v6 = (char *)*((_QWORD *)v6 + 1);
    while (v6);
    v15 = off_24C7F13C0;
    do
    {
      v16 = (char *)*((_QWORD *)v5 + 1);
      ((void (*)(uint64_t, uint64_t))v15[9])((uint64_t)&v15, (uint64_t)v5);
      v5 = v16;
    }
    while (v16);
  }
  return 0;
}

void sub_20D996F0C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  uint64_t v11;
  va_list va;

  va_start(va, a10);
  NLinkedList<NString>::~NLinkedList((uint64_t)va);
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x20D996EE8);
  }
  _Unwind_Resume(a1);
}

void IntNovDetect::IntNovDetect(IntNovDetect *this)
{
  char *v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  const char *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t i;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t j;
  uint64_t v23;
  unsigned int v24;
  char *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t m;
  unsigned int v33;
  uint64_t (**k)();
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38[2];
  uint64_t v39;
  uint64_t v40;

  *((_QWORD *)this + 2) = &off_24C7F32C0;
  v2 = (char *)this + 16;
  *((_DWORD *)this + 6) = 0;
  v3 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 4) = v3;
  *v3 = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 9) = &off_24C7F31A8;
  *((_QWORD *)this + 10) = 0;
  *((_BYTE *)this + 96) = 0;
  *((_QWORD *)this + 13) = &off_24C7F3090;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 16) = &off_24C7F3090;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = &off_24C7F3090;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_BYTE *)this + 184) = 0;
  *((_BYTE *)this + 196) = 0;
  *((_QWORD *)this + 25) = &off_24C7F3090;
  *((_QWORD *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_BYTE *)this + 240) = 0;
  *((_QWORD *)this + 32) = &off_24C7F3090;
  *((_QWORD *)this + 33) = 0;
  *((_DWORD *)this + 68) = 0;
  *((_BYTE *)this + 284) = 0;
  *((_BYTE *)this + 308) = 0;
  *((_QWORD *)this + 39) = &off_24C7F3100;
  *((_QWORD *)this + 40) = 0;
  *((_DWORD *)this + 82) = 0;
  *((_QWORD *)this + 42) = &off_24C7F3020;
  *((_QWORD *)this + 43) = 0;
  *((_DWORD *)this + 88) = 0;
  *((_QWORD *)this + 45) = &off_24C7F3090;
  *((_QWORD *)this + 46) = 0;
  *((_DWORD *)this + 94) = 0;
  *((_BYTE *)this + 388) = 0;
  *((_BYTE *)this + 412) = 0;
  *((_QWORD *)this + 52) = &off_24C7F3388;
  *((_QWORD *)this + 53) = 0;
  *((_QWORD *)this + 54) = 0;
  *((_DWORD *)this + 110) = 0;
  *((_QWORD *)this + 56) = &off_24C7F3090;
  *((_QWORD *)this + 57) = 0;
  *((_DWORD *)this + 116) = 0;
  *((_QWORD *)this + 61) = &off_24C7F3090;
  *((_QWORD *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
  *((_QWORD *)this + 78) = &off_24C7F3090;
  *((_QWORD *)this + 79) = 0;
  *((_DWORD *)this + 160) = 0;
  *((_BYTE *)this + 649) = 0;
  *((_QWORD *)this + 82) = off_24C7F1360;
  *((_QWORD *)this + 84) = 0;
  *((_QWORD *)this + 83) = 0;
  *((_DWORD *)this + 170) = 0;
  *((_QWORD *)this + 86) = off_24C7F1360;
  *((_QWORD *)this + 88) = 0;
  *((_QWORD *)this + 87) = 0;
  *((_DWORD *)this + 178) = 0;
  *((_BYTE *)this + 752) = 0;
  *((_QWORD *)this + 97) = &off_24C7F3090;
  *((_QWORD *)this + 98) = 0;
  *((_DWORD *)this + 198) = 0;
  *((_BYTE *)this + 800) = 0;
  *((_QWORD *)this + 103) = &off_24C7F3090;
  *((_QWORD *)this + 104) = 0;
  *((_DWORD *)this + 210) = 0;
  *((_BYTE *)this + 848) = 0;
  *((_QWORD *)this + 107) = &off_24C7F32C0;
  *((_DWORD *)this + 216) = 0;
  v4 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 109) = v4;
  *v4 = 0;
  *((_QWORD *)this + 110) = &off_24C7F32C0;
  *((_DWORD *)this + 222) = 0;
  v5 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 112) = v5;
  *v5 = 0;
  *((_QWORD *)this + 113) = &off_24C7F32C0;
  *((_DWORD *)this + 228) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 115) = v6;
  *v6 = 0;
  *((_QWORD *)this + 116) = &off_24C7F32C0;
  *((_DWORD *)this + 234) = 0;
  v7 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 118) = v7;
  *v7 = 0;
  *((_QWORD *)this + 131) = &off_24C7F1908;
  *((_QWORD *)this + 132) = off_24C7F1300;
  *((_QWORD *)this + 134) = 0;
  *((_QWORD *)this + 133) = 0;
  *((_DWORD *)this + 270) = 0;
  *((_QWORD *)this + 136) = 0;
  *((_QWORD *)this + 138) = 0;
  *((_QWORD *)this + 137) = 0;
  *(_QWORD *)((char *)this + 1109) = 0;
  *((_QWORD *)this + 140) = 10;
  *((_DWORD *)this + 281) = 1056964608;
  NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1048, (int *)this + 280);
  *((_QWORD *)this + 142) = 0;
  *((_DWORD *)this + 286) = 0;
  *((_QWORD *)this + 141) = &off_24C7F31A8;
  *((_QWORD *)this + 145) = &off_24C7F32C0;
  *((_DWORD *)this + 292) = 0;
  v8 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 147) = v8;
  *v8 = 0;
  *((_BYTE *)this + 1197) = 0;
  NLocalCepNorm::NLocalCepNorm((IntNovDetect *)((char *)this + 1200));
  TSHMMDetector::TSHMMDetector((IntNovDetect *)((char *)this + 1288));
  TSHMMDetector::TSHMMDetector((IntNovDetect *)((char *)this + 1696));
  *((_QWORD *)this + 263) = &off_24C7F20E8;
  *((_QWORD *)this + 264) = 0;
  *((_DWORD *)this + 530) = 0;
  *((_QWORD *)this + 268) = 0;
  *((_QWORD *)this + 267) = 0;
  *((_QWORD *)this + 266) = &off_24C7F31A8;
  *((_QWORD *)this + 269) = &off_24C7F3090;
  *((_QWORD *)this + 270) = 0;
  *((_DWORD *)this + 542) = 0;
  *((_BYTE *)this + 2176) = 0;
  *((_QWORD *)this + 273) = &off_24C7F16D0;
  *((_QWORD *)this + 274) = 0;
  *((_QWORD *)this + 275) = &off_24C7F1790;
  *((_QWORD *)this + 276) = &off_24C7F32C0;
  *((_DWORD *)this + 554) = 0;
  v9 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 278) = v9;
  *v9 = 0;
  *((_BYTE *)this + 2264) = 0;
  *(_OWORD *)((char *)this + 2232) = 0u;
  *(_OWORD *)((char *)this + 2248) = 0u;
  NSATSpeaker::NSATSpeaker((IntNovDetect *)((char *)this + 2272));
  *((_QWORD *)this + 302) = 0;
  *((_QWORD *)this + 301) = 0;
  *((_QWORD *)this + 300) = &off_24C7F31A8;
  *((_QWORD *)this + 303) = &off_24C7F3090;
  *((_QWORD *)this + 304) = 0;
  *((_DWORD *)this + 610) = 0;
  *((_QWORD *)this + 307) = 0;
  *((_QWORD *)this + 306) = 0;
  *((_BYTE *)this + 2464) = 0;
  *(_QWORD *)((char *)this + 2468) = 0;
  *(_QWORD *)((char *)this + 2474) = 0;
  v38[0] = 1;
  NRingDropBuffer::NRingDropBuffer((IntNovDetect *)((char *)this + 2488), (char *)v38);
  *((_QWORD *)this + 316) = 0;
  *((_DWORD *)this + 634) = 0;
  *((_QWORD *)this + 315) = &off_24C7F31A8;
  *((_QWORD *)this + 318) = &off_24C7F32C0;
  *((_DWORD *)this + 638) = 0;
  v10 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 320) = v10;
  *v10 = 0;
  *((_QWORD *)this + 332) = &off_24C7F3090;
  *((_QWORD *)this + 333) = 0;
  *((_DWORD *)this + 668) = 0;
  *((_QWORD *)this + 338) = &off_24C7F3090;
  *((_QWORD *)this + 339) = 0;
  *((_DWORD *)this + 680) = 0;
  *((_QWORD *)this + 342) = &off_24C7F3100;
  *((_QWORD *)this + 343) = 0;
  *((_DWORD *)this + 688) = 0;
  *((_QWORD *)this + 351) = &off_24C7F3090;
  *((_QWORD *)this + 352) = 0;
  *((_DWORD *)this + 706) = 0;
  *((_QWORD *)this + 354) = &off_24C7F3090;
  *((_QWORD *)this + 355) = 0;
  *((_DWORD *)this + 712) = 0;
  v11 = (_BYTE *)operator new[]();
  *v11 = 0;
  *((_QWORD *)this + 362) = &off_24C7F32C0;
  *((_DWORD *)this + 726) = 0;
  v12 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 364) = v12;
  *v12 = *v11;
  v38[0] = 10;
  *((_QWORD *)this + 365) = &off_24C7F2AB0;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)this + 2928, v38, 0);
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  *((_QWORD *)this + 373) = &off_24C7F3138;
  *((_QWORD *)this + 374) = 0;
  *((_DWORD *)this + 750) = 0;
  *((_QWORD *)this + 376) = &off_24C7F3100;
  *((_QWORD *)this + 377) = 0;
  *((_DWORD *)this + 756) = 0;
  *((_QWORD *)this + 379) = &off_24C7F3100;
  *((_QWORD *)this + 380) = 0;
  *((_DWORD *)this + 762) = 0;
  *((_QWORD *)this + 382) = &off_24C7F3090;
  *((_QWORD *)this + 383) = 0;
  *((_DWORD *)this + 768) = 0;
  *((_QWORD *)this + 388) = 0;
  *((_QWORD *)this + 387) = &off_24C7F2BC0;
  *((_QWORD *)this + 389) = 0;
  *((_DWORD *)this + 780) = 0;
  *((_QWORD *)this + 386) = &off_24C7F1690;
  *(_QWORD *)((char *)this + 4) = 0;
  *((_DWORD *)this + 3) = 0;
  v33 = 16;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)v38, &v33, 0);
  v14 = (_QWORD *)((char *)this + 3116);
  k = off_24C7F1480;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v15 = *((unsigned int *)this + 779);
  if ((_DWORD)v15)
  {
    for (i = 0; i < v15; ++i)
    {
      v17 = *((_QWORD *)this + 388);
      if (!v17)
        Error::chuck((Error *)"NLinkedList::NIterator::start List not set", v13);
      v18 = *(_QWORD *)(v17 + 32 * i + 8);
      if (v18)
      {
        do
        {
          v19 = ((uint64_t (*)(uint64_t, uint64_t))k[8])((uint64_t)&k, v18 + 16);
          if (v35)
            v20 = (uint64_t *)(v36 + 8);
          else
            v20 = &v36;
          if (v35)
            v21 = 2;
          else
            v21 = 1;
          *v20 = v19;
          (&k)[v21] = (uint64_t (**)())v19;
          ++v37;
          v18 = *(_QWORD *)(v18 + 8);
        }
        while (v18);
        v15 = *(unsigned int *)v14;
      }
    }
    for (j = v35; j; j = *(_QWORD *)(j + 8))
    {
      if (!(_DWORD)v40)
        Error::chuck((Error *)"NHash::insert() - zero length hash table", v13);
      v23 = *(unsigned int *)(j + 24);
      if ((_DWORD)v23)
      {
        v24 = 0;
        v25 = *(char **)(j + 32);
        do
        {
          v26 = *v25++;
          v24 = v26 + 65599 * v24;
          --v23;
        }
        while (v23);
      }
      else
      {
        v24 = 0;
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v39 + 32 * (v24 % v40)) + 32))(v39 + 32 * (v24 % v40), j + 16);
      ++HIDWORD(v40);
    }
  }
  if (v38 != (unsigned int *)((char *)this + 3096))
  {
    *v14 = v40;
    NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=((uint64_t)this + 3096, (uint64_t)v38);
  }
  for (k = off_24C7F1480; ; ((void (*)(uint64_t, uint64_t))k[9])((uint64_t)&k, v27))
  {
    v27 = v35;
    if (!v35)
      break;
    v35 = *(_QWORD *)(v35 + 8);
  }
  *(_QWORD *)v38 = &off_24C7F2CA0;
  v28 = v39;
  if (v39)
  {
    v29 = *(_QWORD *)(v39 - 8);
    if (v29)
    {
      v30 = v39 + 32 * v29;
      v31 = v30;
      do
      {
        *(_QWORD *)(v31 - 32) = off_24C7F1480;
        v31 -= 32;
        for (m = *(_QWORD *)(v31 + 8); m; m = *(_QWORD *)(v30 - 24))
        {
          *(_QWORD *)(v30 - 24) = *(_QWORD *)(m + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v30 - 32) + 72))(v31);
        }
        *(_QWORD *)(v30 - 16) = 0;
        *(_DWORD *)(v30 - 8) = 0;
        v30 = v31;
      }
      while (v31 != v28);
    }
    MEMORY[0x212BAC9C0](v28 - 16, 0x10A1C80F4A7E088);
  }
  *((_BYTE *)this + 40) = 1;
  v38[0] = 6;
  (*(void (**)(char *, const char *, unsigned int *))(*((_QWORD *)this + 2) + 64))(v2, "all ok", v38);
  *((_BYTE *)this + 40) = 0;
  *(_DWORD *)this = -1838836561;
}

void sub_20D99772C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, NRingDropBuffer *a10, TSSATScorer *a11, TSHMMDetector *a12, NLocalCepNorm *a13, TSHMMDetector *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  _QWORD *v21;
  TSAcAnal *v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  NLinkedList<NMap<NString,NString>::HashItem>::~NLinkedList((uint64_t)&a17);
  NHash<NMap<NString,NString>::HashItem>::~NHash(&a21);
  NStringHash<NString>::~NStringHash(v21 + 386);
  v21[382] = &off_24C7F3090;
  v24 = v21[383];
  if (v24)
    MEMORY[0x212BAC9C0](v24, 0x1000C8052888210);
  v21[379] = &off_24C7F3100;
  v25 = v21[380];
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8052888210);
  v21[376] = &off_24C7F3100;
  v26 = v21[377];
  if (v26)
    MEMORY[0x212BAC9C0](v26, 0x1000C8052888210);
  v21[373] = &off_24C7F3138;
  v27 = v21[374];
  if (v27)
    MEMORY[0x212BAC9C0](v27, 0x1000C80BDFB0063);
  NConfigSection::~NConfigSection((NConfigSection *)(v21 + 362));
  v21[354] = &off_24C7F3090;
  v28 = v21[355];
  if (v28)
    MEMORY[0x212BAC9C0](v28, 0x1000C8052888210);
  v21[351] = &off_24C7F3090;
  v29 = v21[352];
  if (v29)
    MEMORY[0x212BAC9C0](v29, 0x1000C8052888210);
  v21[342] = &off_24C7F3100;
  v30 = v21[343];
  if (v30)
    MEMORY[0x212BAC9C0](v30, 0x1000C8052888210);
  v21[338] = &off_24C7F3090;
  v31 = v21[339];
  if (v31)
    MEMORY[0x212BAC9C0](v31, 0x1000C8052888210);
  v21[332] = &off_24C7F3090;
  v32 = v21[333];
  if (v32)
    MEMORY[0x212BAC9C0](v32, 0x1000C8052888210);
  v21[318] = &off_24C7F32C0;
  v33 = v21[320];
  if (v33)
    MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
  v21[315] = &off_24C7F3090;
  v34 = v21[316];
  if (v34)
    MEMORY[0x212BAC9C0](v34, 0x1000C8052888210);
  NRingDropBuffer::~NRingDropBuffer(a10);
  TSSATScorer::~TSSATScorer(a11);
  TSSupervectorScorer::~TSSupervectorScorer((TSSupervectorScorer *)(v21 + 263));
  TSHMMDetector::~TSHMMDetector(a12);
  TSHMMDetector::~TSHMMDetector(a14);
  NLocalCepNorm::~NLocalCepNorm(a13);
  TSAcAnal::~TSAcAnal(v22);
  v21[2] = &off_24C7F32C0;
  v35 = v21[4];
  if (v35)
    MEMORY[0x212BAC9C0](v35, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_QWORD *NStringHash<NString>::~NStringHash(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2AB0;
  a1[1] = &off_24C7F2CA0;
  v2 = a1[2];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NConfigSection::~NConfigSection(NConfigSection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;

  *((_QWORD *)this + 3) = &off_24C7F2AB0;
  *((_QWORD *)this + 4) = &off_24C7F2CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  *(_QWORD *)this = &off_24C7F32C0;
  v7 = *((_QWORD *)this + 2);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
}

void NRingDropBuffer::~NRingDropBuffer(NRingDropBuffer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C7F2DB8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 24 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 24) = &off_24C7F3090;
        v4 = *(_QWORD *)(v1 + v3 - 16);
        if (v4)
          MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x1081C80622C3295);
  }
}

void NLocalCepNorm::~NLocalCepNorm(NLocalCepNorm *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *((_QWORD *)this + 7) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 4) = &off_24C7F2DB8;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 - 8);
    if (v4)
    {
      v5 = 24 * v4;
      do
      {
        *(_QWORD *)(v3 + v5 - 24) = &off_24C7F3090;
        v6 = *(_QWORD *)(v3 + v5 - 16);
        if (v6)
          MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 -= 24;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3 - 16, 0x1081C80622C3295);
  }
}

void TSAcAnal::~TSAcAnal(TSAcAnal *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;

  *((_QWORD *)this + 139) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 141);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *((_QWORD *)this + 135) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 136);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 125) = &off_24C7F1908;
  *((_QWORD *)this + 126) = off_24C7F1300;
  for (i = *((_QWORD *)this + 127); i; i = *((_QWORD *)this + 127))
  {
    *((_QWORD *)this + 127) = *(_QWORD *)(i + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 126) + 72))((char *)this + 1008);
  }
  *((_QWORD *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;
  NWavChunk2HTKFrames::~NWavChunk2HTKFrames(this);
}

void NWavChunk2HTKFrames::~NWavChunk2HTKFrames(NWavChunk2HTKFrames *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *((_QWORD *)this + 110) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 112);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *((_QWORD *)this + 107) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 109);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *((_QWORD *)this + 104) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 106);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  *((_QWORD *)this + 101) = &off_24C7F32C0;
  v5 = *((_QWORD *)this + 103);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  NDynamicMFCC::~NDynamicMFCC((NWavChunk2HTKFrames *)((char *)this + 576));
  AccelWin2MFCC::~AccelWin2MFCC((void **)this + 17);
  *((_QWORD *)this + 13) = &off_24C7F3090;
  v6 = *((_QWORD *)this + 14);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  *((_QWORD *)this + 10) = &off_24C7F3090;
  v7 = *((_QWORD *)this + 11);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  *((_QWORD *)this + 7) = &off_24C7F3090;
  v8 = *((_QWORD *)this + 8);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  *((_QWORD *)this + 3) = &off_24C7F3090;
  v9 = *((_QWORD *)this + 4);
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
  *(_QWORD *)this = &off_24C7F3090;
  v10 = *((_QWORD *)this + 1);
  if (v10)
    MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
}

void NDynamicMFCC::~NDynamicMFCC(NDynamicMFCC *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t j;
  uint64_t v6;

  *((_QWORD *)this + 25) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 26);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 19) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 20);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 8) = off_24C7F1360;
  for (i = *((_QWORD *)this + 9); i; i = *((_QWORD *)this + 9))
  {
    *((_QWORD *)this + 9) = *(_QWORD *)(i + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 8) + 72))((char *)this + 64);
  }
  *((_QWORD *)this + 4) = off_24C7F1360;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  for (j = *((_QWORD *)this + 5); j; j = *((_QWORD *)this + 5))
  {
    *((_QWORD *)this + 5) = *(_QWORD *)(j + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 4) + 72))((char *)this + 32);
  }
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_24C7F3090;
  v6 = *((_QWORD *)this + 1);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
}

uint64_t NLinkedList<NArray<float>>::removeElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a2)
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(a1 + 8);
  if (v3 == v5)
  {
    *v4 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *v4 = *(_QWORD *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      v7 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(a2 + 8);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1360;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void NLinkedList<NArray<float>>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1360;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NArray<float>>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    for (i = *(_QWORD *)(a2 + 8); i; i = *(_QWORD *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

uint64_t NLinkedList<NArray<float>>::prepend(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
    *(_QWORD *)(result + 8) = v3;
  else
    *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::append(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = (uint64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 16);
    v3 = (uint64_t *)(a1 + 8);
  }
  *v4 = result;
  *v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v8;
  int i;

  v3 = *(unsigned int *)a2;
  v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4)
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  if (!(_DWORD)v3)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32);
    return v6(a1, a3);
  }
  if ((_DWORD)v3 == v4)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40);
    return v6(a1, a3);
  }
  v8 = *(_QWORD *)(a1 + 8);
  for (i = v3 - 1; i; --i)
    v8 = *(_QWORD *)(v8 + 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::reset(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = *(_QWORD *)(result + 8); i; i = *(_QWORD *)(v1 + 8))
  {
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  }
  *(_QWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NArray<float>>::newElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  int *v15;
  int v16;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C7F35A0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = &off_24C7F3090;
  v4 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(v3 + 32) = v4;
  v5 = operator new[]();
  *(_QWORD *)(v3 + 24) = v5;
  if ((_DWORD)v4)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a2 + 8);
    if (v4 < 8)
      goto LABEL_7;
    if ((unint64_t)(v5 - v7) < 0x20)
      goto LABEL_7;
    v6 = v4 & 0xFFFFFFF8;
    v8 = (_OWORD *)(v5 + 16);
    v9 = (__int128 *)(v7 + 16);
    v10 = v6;
    do
    {
      v11 = *v9;
      *(v8 - 1) = *(v9 - 1);
      *v8 = v11;
      v8 += 2;
      v9 += 2;
      v10 -= 8;
    }
    while (v10);
    if (v6 != v4)
    {
LABEL_7:
      v12 = v4 - v6;
      v13 = 4 * v6;
      v14 = (_DWORD *)(v5 + 4 * v6);
      v15 = (int *)(v7 + v13);
      do
      {
        v16 = *v15++;
        *v14++ = v16;
        --v12;
      }
      while (v12);
    }
  }
  return v3;
}

void sub_20D9986A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10A1C40C9FAA55CLL);
  _Unwind_Resume(a1);
}

uint64_t NLinkedList<NArray<float>>::deleteElement(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

_QWORD *NLinkedList<NArray<float>>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F35A0;
  a1[2] = &off_24C7F3090;
  v2 = a1[3];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  return a1;
}

void NLinkedList<NArray<float>>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F35A0;
  a1[2] = &off_24C7F3090;
  v1 = a1[3];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::removeElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a2)
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(a1 + 8);
  if (v3 == v5)
  {
    *v4 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *v4 = *(_QWORD *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      v7 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(a2 + 8);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1300;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F1300;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    for (i = *(_QWORD *)(a2 + 8); i; i = *(_QWORD *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::prepend(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
    *(_QWORD *)(result + 8) = v3;
  else
    *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::append(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = (uint64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 16);
    v3 = (uint64_t *)(a1 + 8);
  }
  *v4 = result;
  *v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v8;
  int i;

  v3 = *(unsigned int *)a2;
  v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4)
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  if (!(_DWORD)v3)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32);
    return v6(a1, a3);
  }
  if ((_DWORD)v3 == v4)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40);
    return v6(a1, a3);
  }
  v8 = *(_QWORD *)(a1 + 8);
  for (i = v3 - 1; i; --i)
    v8 = *(_QWORD *)(v8 + 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::reset(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = *(_QWORD *)(result + 8); i; i = *(_QWORD *)(v1 + 8))
  {
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  }
  *(_QWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::newElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  const char *v7;
  _QWORD *v8;
  _QWORD *v10;
  unint64_t v11;
  _DWORD *v12;
  uint64_t v13;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C7F3580;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = &off_24C7F2F08;
  v4 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(v3 + 32) = v4;
  v5 = 40 * v4;
  v6 = (_QWORD *)operator new[]();
  *v6 = 40;
  v6[1] = v4;
  v8 = v6 + 2;
  if ((_DWORD)v4)
  {
    v10 = v6 + 2;
    if ((unint64_t)(v5 - 40) >= 0x28)
    {
      v11 = (v5 - 40) / 0x28uLL + 1;
      v12 = v6 + 11;
      v13 = v11 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v12 - 9) = &off_24C7F3640;
        *((_QWORD *)v12 - 4) = &off_24C7F3640;
        *(v12 - 10) = 0;
        *v12 = 0;
        *((_QWORD *)v12 - 7) = &off_24C7F31A8;
        *((_QWORD *)v12 - 6) = 0;
        *((_QWORD *)v12 - 2) = &off_24C7F31A8;
        *((_QWORD *)v12 - 1) = 0;
        v12 += 20;
        v13 -= 2;
      }
      while (v13);
      if (v11 == (v11 & 0xFFFFFFFFFFFFFFELL))
      {
LABEL_9:
        *(_QWORD *)(v3 + 24) = v8;
        Error::chuck((Error *)"NLinkedList::NElement::operator=() -this method should never be called", v7);
      }
      v10 = &v8[5 * (v11 & 0xFFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v10 = &off_24C7F3640;
      *((_DWORD *)v10 + 8) = 0;
      v10[2] = &off_24C7F31A8;
      v10[3] = 0;
      v10 += 5;
    }
    while (v10 != &v8[5 * v4]);
    goto LABEL_9;
  }
  *(_QWORD *)(v3 + 24) = v8;
  return v3;
}

void sub_20D998C78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10A1C40DF491954);
  _Unwind_Resume(a1);
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::deleteElement(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

_QWORD *NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *a1 = &off_24C7F3580;
  a1[2] = &off_24C7F2F08;
  v2 = a1[3];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 40 * v3;
      do
      {
        v5 = v2 + v4;
        *(_QWORD *)(v5 - 40) = &off_24C7F3640;
        *(_QWORD *)(v5 - 24) = &off_24C7F3090;
        v6 = *(_QWORD *)(v2 + v4 - 16);
        if (v6)
          MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v4 -= 40;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80C9FAA55CLL);
  }
  return a1;
}

void NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F3580;
  a1[2] = &off_24C7F2F08;
  v1 = a1[3];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 40 * v2;
      do
      {
        v4 = v1 + v3;
        *(_QWORD *)(v4 - 40) = &off_24C7F3640;
        *(_QWORD *)(v4 - 24) = &off_24C7F3090;
        v5 = *(_QWORD *)(v1 + v3 - 16);
        if (v5)
          MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
        v3 -= 40;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80C9FAA55CLL);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NResizingQueue<NFrame>::~NResizingQueue(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  *(_QWORD *)a1 = &off_24C7F1908;
  *(_QWORD *)(a1 + 8) = off_24C7F1300;
  v2 = a1 + 8;
  for (i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 8) + 72))(v2);
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return a1;
}

void NResizingQueue<NFrame>::~NResizingQueue(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  *(_QWORD *)a1 = &off_24C7F1908;
  *(_QWORD *)(a1 + 8) = off_24C7F1300;
  v2 = a1 + 8;
  for (i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 8) + 72))(v2);
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NHash<NMap<NString,NString>::HashItem>::NHash(uint64_t a1, unsigned int *a2, char a3)
{
  unsigned int v4;
  unsigned int v5;
  int v7;
  unsigned int v8;
  unsigned int v9;

  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_24C7F2BC0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = *a2;
  if (!a3 && v4 - 1 >= 2)
  {
    v5 = v4 | 1;
    if ((v4 & 0xFFFFFFFE) >= 3)
    {
      while (v5 >= 9)
      {
        v7 = 5;
        while (v5 % (v7 - 2))
        {
          v8 = v7 * v7;
          v7 += 2;
          if (v8 > v5)
            goto LABEL_4;
        }
        v4 = v5 + 2;
        v9 = v5 + 1;
        v5 += 2;
        if (v9 < 3)
          goto LABEL_5;
      }
    }
LABEL_4:
    v4 = v5;
  }
LABEL_5:
  *(_DWORD *)(a1 + 20) = v4;
  NArray<NLinkedList<NMap<NString,NString>::HashItem>>::resize(a1, (_DWORD *)(a1 + 20));
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void sub_20D999008(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;

  *v1 = &off_24C7F2CA0;
  v3 = v1[1];
  if (v3)
  {
    v4 = *(_QWORD *)(v3 - 8);
    if (v4)
    {
      v5 = v3 + 32 * v4;
      v6 = v5;
      do
      {
        *(_QWORD *)(v6 - 32) = off_24C7F1480;
        v6 -= 32;
        for (i = *(_QWORD *)(v6 + 8); i; i = *(_QWORD *)(v5 - 24))
        {
          *(_QWORD *)(v5 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v5 - 32) + 72))(v6);
        }
        *(_QWORD *)(v5 - 16) = 0;
        *(_DWORD *)(v5 - 8) = 0;
        v5 = v6;
      }
      while (v6 != v3);
    }
    MEMORY[0x212BAC9C0](v3 - 16, 0x10A1C80F4A7E088);
  }
  _Unwind_Resume(exception_object);
}

void NStringHash<NString>::~NStringHash(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2AB0;
  a1[1] = &off_24C7F2CA0;
  v1 = a1[2];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1480;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<short>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3138;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C80BDFB0063);
  return a1;
}

void NArray<short>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3138;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C80BDFB0063);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<short>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _WORD *v17;
  __int16 *v18;
  __int16 v19;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C80BDFB0063);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 0x10)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF0;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF0;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 16;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 2 * v7;
        v17 = (_WORD *)(v9 + v16);
        v18 = (__int16 *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return a1;
}

uint64_t NArray<short>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _WORD *v19;
  __int16 *v20;
  __int16 v21;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C80BDFB0063);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = *(_QWORD *)(v4 + 8);
    v10 = v5;
    if (v5 < 0x10 || (unint64_t)(v9 - a2) <= 0x1F)
    {
      v12 = 0;
LABEL_14:
      v17 = v10 - v12;
      v18 = 2 * v12;
      v19 = (_WORD *)(v9 + v18);
      v20 = (__int16 *)(a2 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
      return result;
    }
    v12 = v5 & 0xFFFFFFF0;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(a2 + 16);
    v15 = v10 & 0xFFFFFFF0;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 16;
    }
    while (v15);
    if (v12 != v10)
      goto LABEL_14;
  }
  return result;
}

uint64_t NArray<short>::resize(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;
  __int16 *v16;
  __int16 v17;

  v2 = *(_DWORD *)(result + 16);
  if (v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    LODWORD(v6) = *a2;
    if (v2 >= *a2)
      v6 = v6;
    else
      v6 = v2;
    if ((_DWORD)v6)
    {
      if (v6 >= 0x10 && (unint64_t)(result - v5) > 0x1F)
      {
        v8 = v6 & 0xFFFFFFF0;
        v9 = (_OWORD *)(result + 16);
        v10 = (__int128 *)(v5 + 16);
        v11 = v8;
        do
        {
          v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 16;
        }
        while (v11);
        if (v8 == v6)
LABEL_18:
          JUMPOUT(0x212BAC9C0);
      }
      else
      {
        v8 = 0;
      }
      v13 = v6 - v8;
      v14 = 2 * v8;
      v15 = (_WORD *)(result + 2 * v8);
      v16 = (__int16 *)(v5 + v14);
      do
      {
        v17 = *v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
      goto LABEL_18;
    }
    if (v5)
      goto LABEL_18;
  }
  return result;
}

void AccelStaticMFCC::~AccelStaticMFCC(void **this)
{
  void *v2;
  void *v3;
  void *v4;

  AccelWin2MFCC::~AccelWin2MFCC(this + 11);
  this[7] = &off_24C7F3090;
  v2 = this[8];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  this[4] = &off_24C7F3090;
  v3 = this[5];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  this[1] = &off_24C7F3090;
  v4 = this[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
}

uint64_t IntNovDetect::clearError(uint64_t this)
{
  uint64_t v1;
  int v2;

  if (*(_BYTE *)(this + 40))
  {
    v2 = 6;
    v1 = this + 16;
    this = (*(uint64_t (**)(uint64_t, const char *, int *))(*(_QWORD *)(this + 16) + 64))(this + 16, "all ok", &v2);
    *(_BYTE *)(v1 + 24) = 0;
  }
  return this;
}

void IntNovDetect::~IntNovDetect(IntNovDetect *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t j;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t k;
  uint64_t v39;

  *(_OWORD *)this = xmmword_20DA24660;
  *((_QWORD *)this + 386) = &off_24C7F2AB0;
  *((_QWORD *)this + 387) = &off_24C7F2CA0;
  v2 = *((_QWORD *)this + 388);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  *((_QWORD *)this + 382) = &off_24C7F3090;
  v7 = *((_QWORD *)this + 383);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  *((_QWORD *)this + 379) = &off_24C7F3100;
  v8 = *((_QWORD *)this + 380);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  *((_QWORD *)this + 376) = &off_24C7F3100;
  v9 = *((_QWORD *)this + 377);
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
  *((_QWORD *)this + 373) = &off_24C7F3138;
  v10 = *((_QWORD *)this + 374);
  if (v10)
    MEMORY[0x212BAC9C0](v10, 0x1000C80BDFB0063);
  *((_QWORD *)this + 365) = &off_24C7F2AB0;
  *((_QWORD *)this + 366) = &off_24C7F2CA0;
  v11 = *((_QWORD *)this + 367);
  if (v11)
  {
    v12 = *(_QWORD *)(v11 - 8);
    if (v12)
    {
      v13 = v11 + 32 * v12;
      v14 = v13;
      do
      {
        *(_QWORD *)(v14 - 32) = off_24C7F1480;
        v14 -= 32;
        for (j = *(_QWORD *)(v14 + 8); j; j = *(_QWORD *)(v13 - 24))
        {
          *(_QWORD *)(v13 - 24) = *(_QWORD *)(j + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v13 - 32) + 72))(v14);
        }
        *(_QWORD *)(v13 - 16) = 0;
        *(_DWORD *)(v13 - 8) = 0;
        v13 = v14;
      }
      while (v14 != v11);
    }
    MEMORY[0x212BAC9C0](v11 - 16, 0x10A1C80F4A7E088);
  }
  *((_QWORD *)this + 362) = &off_24C7F32C0;
  v16 = *((_QWORD *)this + 364);
  if (v16)
    MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
  *((_QWORD *)this + 354) = &off_24C7F3090;
  v17 = *((_QWORD *)this + 355);
  if (v17)
    MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
  *((_QWORD *)this + 351) = &off_24C7F3090;
  v18 = *((_QWORD *)this + 352);
  if (v18)
    MEMORY[0x212BAC9C0](v18, 0x1000C8052888210);
  *((_QWORD *)this + 342) = &off_24C7F3100;
  v19 = *((_QWORD *)this + 343);
  if (v19)
    MEMORY[0x212BAC9C0](v19, 0x1000C8052888210);
  *((_QWORD *)this + 338) = &off_24C7F3090;
  v20 = *((_QWORD *)this + 339);
  if (v20)
    MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
  *((_QWORD *)this + 332) = &off_24C7F3090;
  v21 = *((_QWORD *)this + 333);
  if (v21)
    MEMORY[0x212BAC9C0](v21, 0x1000C8052888210);
  *((_QWORD *)this + 318) = &off_24C7F32C0;
  v22 = *((_QWORD *)this + 320);
  if (v22)
    MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  *((_QWORD *)this + 315) = &off_24C7F3090;
  v23 = *((_QWORD *)this + 316);
  if (v23)
    MEMORY[0x212BAC9C0](v23, 0x1000C8052888210);
  *((_QWORD *)this + 311) = &off_24C7F2DB8;
  v24 = *((_QWORD *)this + 312);
  if (v24)
  {
    v25 = *(_QWORD *)(v24 - 8);
    if (v25)
    {
      v26 = 24 * v25;
      do
      {
        *(_QWORD *)(v24 + v26 - 24) = &off_24C7F3090;
        v27 = *(_QWORD *)(v24 + v26 - 16);
        if (v27)
          MEMORY[0x212BAC9C0](v27, 0x1000C8052888210);
        v26 -= 24;
      }
      while (v26);
    }
    MEMORY[0x212BAC9C0](v24 - 16, 0x1081C80622C3295);
  }
  TSSATScorer::~TSSATScorer((IntNovDetect *)((char *)this + 2184));
  *((_QWORD *)this + 263) = &off_24C7F20E8;
  v28 = *((_QWORD *)this + 264);
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
  *((_QWORD *)this + 264) = 0;
  *((_QWORD *)this + 269) = &off_24C7F3090;
  v29 = *((_QWORD *)this + 270);
  if (v29)
    MEMORY[0x212BAC9C0](v29, 0x1000C8052888210);
  *((_QWORD *)this + 266) = &off_24C7F3090;
  v30 = *((_QWORD *)this + 267);
  if (v30)
    MEMORY[0x212BAC9C0](v30, 0x1000C8052888210);
  TSHMMDetector::~TSHMMDetector((IntNovDetect *)((char *)this + 1696));
  TSHMMDetector::~TSHMMDetector((IntNovDetect *)((char *)this + 1288));
  *((_QWORD *)this + 157) = &off_24C7F3090;
  v31 = *((_QWORD *)this + 158);
  if (v31)
    MEMORY[0x212BAC9C0](v31, 0x1000C8052888210);
  *((_QWORD *)this + 154) = &off_24C7F2DB8;
  v32 = *((_QWORD *)this + 155);
  if (v32)
  {
    v33 = *(_QWORD *)(v32 - 8);
    if (v33)
    {
      v34 = 24 * v33;
      do
      {
        *(_QWORD *)(v32 + v34 - 24) = &off_24C7F3090;
        v35 = *(_QWORD *)(v32 + v34 - 16);
        if (v35)
          MEMORY[0x212BAC9C0](v35, 0x1000C8052888210);
        v34 -= 24;
      }
      while (v34);
    }
    MEMORY[0x212BAC9C0](v32 - 16, 0x1081C80622C3295);
  }
  *((_QWORD *)this + 145) = &off_24C7F32C0;
  v36 = *((_QWORD *)this + 147);
  if (v36)
    MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
  *((_QWORD *)this + 141) = &off_24C7F3090;
  v37 = *((_QWORD *)this + 142);
  if (v37)
    MEMORY[0x212BAC9C0](v37, 0x1000C8052888210);
  *((_QWORD *)this + 131) = &off_24C7F1908;
  *((_QWORD *)this + 132) = off_24C7F1300;
  for (k = *((_QWORD *)this + 133); k; k = *((_QWORD *)this + 133))
  {
    *((_QWORD *)this + 133) = *(_QWORD *)(k + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 132) + 72))((char *)this + 1056);
  }
  *((_QWORD *)this + 134) = 0;
  *((_DWORD *)this + 270) = 0;
  NWavChunk2HTKFrames::~NWavChunk2HTKFrames((IntNovDetect *)((char *)this + 48));
  *((_QWORD *)this + 2) = &off_24C7F32C0;
  v39 = *((_QWORD *)this + 4);
  if (v39)
    MEMORY[0x212BAC9C0](v39, 0x1000C8077774924);
}

void IntNovDetect::addresource(IntNovDetect *this, const char *__s, const NString *a3, const void *a4)
{
  _DWORD *v7;
  const char *v8;
  BOOL v9;
  char *v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  unsigned int v12;
  _DWORD *v13;

  if (*(_DWORD *)this == -1838836561)
  {
    if (!*((_DWORD *)this + 1))
    {
      v11 = &off_24C7F32C0;
      if (__s)
      {
        v12 = strlen(__s);
        v7 = (_DWORD *)operator new[]();
        v13 = v7;
        memcpy(v7, __s, v12 + 1);
        if (v12 >= 7 && (*v7 == 1684957549 ? (v9 = *(_DWORD *)((char *)v7 + 3) == 980968804) : (v9 = 0), v9))
        {
          if (a3)
          {
            if ((a4 & 0x80000000) == 0)
              NMemoryFile::newMemoryBlockDef((NMemoryFile *)&v11, a3, a4);
            v10 = "NovDetect: addresource() size must be positive";
          }
          else
          {
            v10 = "NovDetect: addresource() resourceptr is NULL pointer";
          }
        }
        else
        {
          v10 = "NovDetect: resource label must begin with \"mindex:\"";
        }
        Error::chuck((Error *)v10, v8);
      }
      Error::chuck((Error *)"Null pointer passed to string constructor", 0, a3);
    }
    Error::chuck((Error *)"NovDetect: addresource() can only be called after create()", __s, a3);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", __s, a3);
}

void sub_20D999D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v15;

  if (a15)
    MEMORY[0x212BAC9C0](a15, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NMap<NString,NString>::operator[](uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  size_t v5;
  char *v6;
  const char *v7;
  unsigned int v8;
  unsigned int v9;
  char *v10;
  size_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  size_t v17;
  unsigned int v18;
  char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  void *v23;
  char *v24;
  uint64_t (**v26)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**v29)(NString *__hidden, const unsigned int *);
  int v30;
  _BYTE *v31;

  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v26 = &off_24C7F32C0;
  v5 = *(unsigned int *)(a2 + 8);
  LODWORD(__n) = *(_DWORD *)(a2 + 8);
  v6 = (char *)operator new[]();
  __s2 = v6;
  memcpy(v6, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v29 = &off_24C7F32C0;
  v30 = 0;
  v31 = (_BYTE *)operator new[]();
  *v31 = *v4;
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v8 = *(_DWORD *)(a1 + 28);
  if (!v8)
  {
    v24 = "NHash::contains() - zero length hash table";
    goto LABEL_31;
  }
  v9 = 0;
  if ((_DWORD)v5)
  {
    v10 = v6;
    v11 = v5;
    do
    {
      v12 = *v10++;
      v9 = v12 + 65599 * v9;
      --v11;
    }
    while (v11);
  }
  v13 = *(_QWORD *)(a1 + 16);
  v14 = *(_QWORD *)(v13 + 32 * (v9 % v8) + 8);
  if (v14)
  {
    while ((_DWORD)v5 != *(_DWORD *)(v14 + 24) || memcmp(*(const void **)(v14 + 32), v6, v5))
    {
      v14 = *(_QWORD *)(v14 + 8);
      if (!v14)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v15 = 0;
    if ((_DWORD)v5)
    {
      do
      {
        v16 = *v6++;
        v15 = v16 + 65599 * v15;
        --v5;
      }
      while (v5);
    }
    (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)(v13 + 32 * (v15 % v8)) + 32))(v13 + 32 * (v15 % v8), &v26);
    v8 = *(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 32);
  }
  if (!v8)
  {
    v24 = "NHash::get() - zero length hash table";
    goto LABEL_31;
  }
  v17 = __n;
  if ((_DWORD)__n)
  {
    v18 = 0;
    v19 = (char *)__s2;
    v20 = __n;
    do
    {
      v21 = *v19++;
      v18 = v21 + 65599 * v18;
      --v20;
    }
    while (v20);
  }
  else
  {
    v18 = 0;
  }
  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v18 % v8) + 8);
  if (!v22)
  {
    v24 = "NLinkedList::get Attempted to get element that is not in list";
LABEL_31:
    Error::chuck((Error *)v24, v7, v26);
  }
  v23 = __s2;
  v24 = "NLinkedList::get Attempted to get element that is not in list";
  while ((_DWORD)v17 != *(_DWORD *)(v22 + 24) || memcmp(*(const void **)(v22 + 32), v23, v17))
  {
    v22 = *(_QWORD *)(v22 + 8);
    if (!v22)
      goto LABEL_31;
  }
  v29 = &off_24C7F32C0;
  if (v31)
  {
    MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
    v23 = __s2;
  }
  v26 = &off_24C7F32C0;
  if (v23)
    MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
  return v22 + 40;
}

{
  _BYTE *v4;
  size_t v5;
  char *v6;
  _BYTE *v7;
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  size_t v12;
  int v13;
  uint64_t v14;
  char *v15;

  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v5 = *(unsigned int *)(a2 + 8);
  v6 = (char *)operator new[]();
  memcpy(v6, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v7 = (_BYTE *)operator new[]();
  *v7 = *v4;
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v9 = *(_DWORD *)(a1 + 28);
  if (!v9)
  {
    v15 = "NHash::get() - zero length hash table";
    goto LABEL_13;
  }
  v10 = 0;
  if ((_DWORD)v5)
  {
    v11 = v6;
    v12 = v5;
    do
    {
      v13 = *v11++;
      v10 = v13 + 65599 * v10;
      --v12;
    }
    while (v12);
  }
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v10 % v9) + 8);
  if (!v14)
  {
    v15 = "NLinkedList::get Attempted to get element that is not in list";
LABEL_13:
    Error::chuck((Error *)v15, v8);
  }
  v15 = "NLinkedList::get Attempted to get element that is not in list";
  while ((_DWORD)v5 != *(_DWORD *)(v14 + 24) || memcmp(*(const void **)(v14 + 32), v6, v5))
  {
    v14 = *(_QWORD *)(v14 + 8);
    if (!v14)
      goto LABEL_13;
  }
  MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  return v14 + 40;
}

void sub_20D99A05C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

const NString *IntNovDetect::mapfile(IntNovDetect *this, int **a2)
{
  const NString *v2;
  int *v3;
  int v4;
  int v5;
  uint64_t v7;

  v2 = (const NString *)a2;
  if (*((_DWORD *)a2 + 2) >= 7u)
  {
    v3 = a2[2];
    v4 = *v3;
    v5 = *(int *)((char *)v3 + 3);
    if (v4 == 1684957549 && v5 == 980968804)
    {
      v7 = NMap<NString,NString>::find((uint64_t)this + 3088, (uint64_t)a2);
      if (v7)
        return (const NString *)v7;
    }
  }
  return v2;
}

uint64_t NMap<NString,NString>::find(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  size_t v5;
  char *v6;
  _BYTE *v7;
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  size_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v5 = *(unsigned int *)(a2 + 8);
  v6 = (char *)operator new[]();
  memcpy(v6, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v7 = (_BYTE *)operator new[]();
  *v7 = *v4;
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v9 = *(_DWORD *)(a1 + 28);
  if (!v9)
    Error::chuck((Error *)"NHash::get() - zero length hash table", v8);
  v10 = 0;
  if ((_DWORD)v5)
  {
    v11 = v6;
    v12 = v5;
    do
    {
      v13 = *v11++;
      v10 = v13 + 65599 * v10;
      --v12;
    }
    while (v12);
  }
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v10 % v9) + 8);
  if (v14)
  {
    while ((_DWORD)v5 != *(_DWORD *)(v14 + 24) || memcmp(*(const void **)(v14 + 32), v6, v5))
    {
      v14 = *(_QWORD *)(v14 + 8);
      if (!v14)
        goto LABEL_6;
    }
    v15 = v14 + 40;
  }
  else
  {
LABEL_6:
    v15 = 0;
  }
  MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  return v15;
}

void sub_20D99A2BC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t IntNovDetect::initialize(IntNovDetect *this, const char *a2, const char *a3)
{
  const char *v6;
  const char *v7;
  _BYTE *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  int v14;
  void *v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  int v25;
  void *v26;
  uint64_t v27;
  char *v28;
  const char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char *v33;
  const char *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  void *v38;
  char *v39;
  uint64_t v40;
  _WORD *v41;
  const char *v42;
  uint64_t (***v43)(NString *__hidden, const unsigned int *);
  void *v44;
  uint64_t v45;
  void *v46;
  const char *v47;
  void *v48;
  uint64_t v49;
  char *v50;
  const char *v51;
  uint64_t (***v52)(NString *__hidden, const unsigned int *);
  NConfigSection *v53;
  void *v54;
  uint64_t v55;
  void *v56;
  const char *v57;
  uint64_t v58;
  const NString *v59;
  int *v60;
  int v61;
  int v62;
  uint64_t v64;
  void *v65;
  char *v66;
  char v67;
  void *v68;
  char v69;
  NConfigSection *v70;
  void *v71;
  float v72;
  float v73;
  void *v74;
  unsigned int v75;
  void *v76;
  void *v77;
  unsigned int v78;
  const char *v79;
  void *v80;
  void *v81;
  uint64_t v82;
  int v83;
  void *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  void *v88;
  const char *v89;
  uint64_t v90;
  IntNovDetect *v91;
  void *v92;
  const char *v93;
  uint64_t v94;
  const NString *v95;
  int *v96;
  int v97;
  int v98;
  uint64_t v100;
  char *v101;
  const char *v102;
  uint64_t v103;
  int *v104;
  int v105;
  int v106;
  uint64_t v108;
  void *v109;
  const char *v110;
  uint64_t v111;
  unsigned int v112;
  int *v113;
  int v114;
  int v115;
  BOOL v116;
  void *v117;
  const char *v118;
  void *v119;
  const char *v120;
  NString *v121;
  void *v122;
  const char *v123;
  uint64_t v124;
  uint64_t (***v125)(NString *__hidden, const unsigned int *);
  unsigned int v126;
  int *v127;
  int v128;
  int v129;
  uint64_t v131;
  int v132;
  int v133;
  unsigned int v134;
  NConfigSection *v135;
  unsigned int v136;
  int v137;
  void *v138;
  float v139;
  const char *v140;
  void *v141;
  float v142;
  const char *v143;
  unsigned int v144;
  int v145;
  void *v146;
  int v147;
  uint64_t v148;
  void *v149;
  _BOOL4 v150;
  const char *v151;
  _DWORD *v152;
  const char *v153;
  uint64_t v154;
  void *v155;
  const char *v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  float v161;
  unsigned int v162;
  const NString *v163;
  uint64_t v164;
  const NString *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  NConfigSection *v169;
  _OWORD *v170;
  float v171;
  float v172;
  _BYTE *v173;
  unsigned int v174;
  _BYTE *v175;
  _QWORD *v176;
  int v177;
  const char *v178;
  void *v179;
  void *v180;
  void *v181;
  float v182;
  void *v183;
  float v184;
  void *v185;
  float v186;
  const char *v187;
  float v188;
  unsigned int v189;
  void *v190;
  const char *v191;
  uint64_t v192;
  int v193;
  unsigned int v194;
  _BYTE *v195;
  uint64_t v196;
  uint64_t v197;
  _OWORD *v198;
  int v199;
  _QWORD *v200;
  int v201;
  const char *v202;
  _QWORD *v203;
  const char *v204;
  uint64_t v205;
  IntNovDetect *v206;
  uint64_t v207;
  const char *v208;
  uint64_t v209;
  NString *v210;
  int *v211;
  int v212;
  int v213;
  uint64_t v215;
  _OWORD *v216;
  uint64_t v217;
  const char *v218;
  uint64_t (***v219)(NString *__hidden, const unsigned int *);
  uint64_t (**v220)(NString *__hidden, const unsigned int *);
  int v221;
  int v222;
  uint64_t v224;
  _BYTE *v225;
  const char *v226;
  uint64_t v227;
  int *v228;
  int v229;
  int v230;
  BOOL v231;
  _WORD *v232;
  const char *v233;
  _BYTE *v234;
  const char *v235;
  char *v236;
  const char *v237;
  uint64_t v238;
  uint64_t (***v239)(NString *__hidden, const unsigned int *);
  unsigned int v240;
  int *v241;
  int v242;
  int v243;
  uint64_t v245;
  uint64_t v246;
  unsigned int v247;
  unsigned int v248;
  unsigned int v249;
  uint64_t v250;
  unsigned int v251;
  _QWORD *v252;
  int v253;
  unsigned int v254;
  int v255;
  _QWORD *v256;
  int v257;
  uint64_t v258;
  uint64_t v259;
  _BOOL4 v260;
  const char *v261;
  _DWORD *v262;
  const char *v263;
  uint64_t v264;
  void *v265;
  const char *v266;
  uint64_t v267;
  uint64_t v268;
  unint64_t v269;
  uint64_t v270;
  float v271;
  NString *v272;
  uint64_t v273;
  NString *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  NConfigSection *v278;
  char *v279;
  int v280;
  char *v281;
  void *v282;
  void *v283;
  char v284;
  int v285;
  unsigned int v286;
  unsigned int v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  _OWORD *v292;
  __int128 *v293;
  uint64_t v294;
  __int128 v295;
  uint64_t v296;
  uint64_t v297;
  _DWORD *v298;
  int *v299;
  int v300;
  char *v301;
  int v302;
  int v303;
  char *v304;
  int v305;
  int v306;
  char *v307;
  char v308;
  unsigned int v309;
  unsigned int v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  _OWORD *v315;
  __int128 *v316;
  uint64_t v317;
  __int128 v318;
  uint64_t v319;
  uint64_t v320;
  _DWORD *v321;
  int *v322;
  int v323;
  char *v324;
  int v325;
  _QWORD *v326;
  int v327;
  NConfigSection *v328;
  void *v329;
  int v330;
  void *v331;
  int v332;
  void *v333;
  int v334;
  const char *v335;
  int v336;
  void *v337;
  NConfigSection *v338;
  void *v339;
  const char *v340;
  uint64_t v341;
  const NString *v342;
  int *v343;
  int v344;
  int v345;
  uint64_t v347;
  void *v348;
  uint64_t v349;
  NConfigSection *v350;
  void *v351;
  char v352;
  void *v353;
  const char *v354;
  uint64_t v355;
  NString *v356;
  int *v357;
  int v358;
  int v359;
  uint64_t v361;
  void *v362;
  const char *v363;
  uint64_t v364;
  const NString *v365;
  int *v366;
  int v367;
  int v368;
  uint64_t v370;
  char *v371;
  void *v372;
  void *v373;
  void *v374;
  void *v375;
  void *v376;
  void *v377;
  float v378;
  unsigned int v379;
  unsigned int v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  _OWORD *v385;
  __int128 *v386;
  uint64_t v387;
  __int128 v388;
  uint64_t v389;
  uint64_t v390;
  _DWORD *v391;
  int *v392;
  int v393;
  _QWORD *v394;
  unsigned int v395;
  int v396;
  uint64_t v397;
  uint64_t v398;
  unsigned int v399;
  uint64_t v400;
  uint64_t v401;
  _OWORD *v402;
  __int128 *v403;
  uint64_t v404;
  __int128 v405;
  uint64_t v406;
  uint64_t v407;
  _DWORD *v408;
  int *v409;
  int v410;
  unsigned int v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v416;
  _OWORD *v417;
  __int128 *v418;
  uint64_t v419;
  __int128 v420;
  uint64_t v421;
  uint64_t v422;
  _DWORD *v423;
  int *v424;
  int v425;
  unsigned int v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v431;
  _OWORD *v432;
  __int128 *v433;
  uint64_t v434;
  __int128 v435;
  uint64_t v436;
  uint64_t v437;
  _DWORD *v438;
  int *v439;
  int v440;
  unint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  int v446;
  int v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t i;
  char *v454;
  char *v455;
  char *v456;
  char *v457;
  char *v458;
  char *v459;
  char *v460;
  uint64_t v461;
  uint64_t v462;
  __int128 v463;
  __int128 v464;
  __int128 v465;
  __int128 v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  __int128 v471;
  __int128 v472;
  __int128 v473;
  uint64_t v474;
  uint64_t v475;
  __int128 v476;
  NString *v477[2];
  const NString *v478;
  _OWORD v479[2];
  NString *v480;
  unsigned int v481[4];
  NString *v482;
  unsigned int v483;
  NString *v484;
  const NString *v485;
  const NString *v486;
  const NString *v487;
  unsigned int v488[7];
  BOOL v489;
  BOOL v490[8];
  int v491;
  _QWORD *v492;
  unsigned int v493[2];
  int v494;
  uint64_t v495;
  uint64_t (**v496)(NString *__hidden, const unsigned int *);
  int v497;
  char *v498;
  BOOL v499[4];
  unsigned int v500[2];
  int v501;
  char *v502;
  uint64_t (**v503)(NString *__hidden, const unsigned int *);
  int v504;
  char *v505;
  uint64_t (**v506)(NString *__hidden, const unsigned int *);
  int v507;
  char *v508;
  uint64_t (**v509)(NString *__hidden, const unsigned int *);
  int v510;
  void *v511;
  uint64_t (**v512)(NString *__hidden, const unsigned int *);
  int v513;
  void *v514;
  uint64_t (**v515)(NString *__hidden, const unsigned int *);
  int v516;
  void *v517;
  uint64_t (**v518)(NString *__hidden, const unsigned int *);
  int v519;
  void *v520;
  uint64_t (**v521)(NString *__hidden, const unsigned int *);
  int v522;
  void *v523;
  char *v524;
  int v525;
  void *v526;
  char *v527;
  uint64_t v528;
  _QWORD *v529;
  uint64_t (**v530)();
  uint64_t v531;
  void *v532;
  uint64_t (**v533)(NString *__hidden, const unsigned int *);
  int v534;
  void *v535;
  uint64_t (**v536)(NString *__hidden, const unsigned int *);
  int v537;
  _BYTE *v538;
  uint64_t (**v539)(NString *__hidden, const unsigned int *);
  int v540;
  _BYTE *v541;
  uint64_t (**v542)(NString *__hidden, const unsigned int *);
  int v543;
  void *v544;
  uint64_t (**v545)(NString *__hidden, const unsigned int *);
  int v546;
  void *v547;
  uint64_t (**v548)(NString *__hidden, const unsigned int *);
  int v549;
  void *v550;
  uint64_t (**v551)(NString *__hidden, const unsigned int *);
  int v552;
  void *v553;
  uint64_t (**v554)(NString *__hidden, const unsigned int *);
  int v555;
  void *v556;
  _QWORD v557[2];
  uint64_t v558;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2, a3);
  if (*((_DWORD *)this + 1))
    Error::chuck((Error *)"NovDetect: initialize() can only be called after create()", a2, a3);
  LOBYTE(v554) = 0;
  NConfig::NConfig((NConfig *)v557, (const BOOL *)&v554);
  if (!a2)
  {
    v454 = "NovDetect: initialize() cannot be called with filename = NULL";
    goto LABEL_495;
  }
  if (!a3)
  {
    v454 = "NovDetect: initialize() cannot be called with rootpath = NULL";
LABEL_495:
    Error::chuck((Error *)v454, v6);
  }
  if (!strncmp(a2, "CONFIGSTR: ", 0xBuLL))
  {
    v7 = a2 + 11;
    v554 = &off_24C7F32C0;
    v555 = strlen(v7);
    v556 = (void *)operator new[]();
    memcpy(v556, v7, (v555 + 1));
    v551 = &off_24C7F32C0;
    v552 = strlen(a3);
    v553 = (void *)operator new[]();
    memcpy(v553, a3, (v552 + 1));
    v548 = &off_24C7F32C0;
    v549 = 0;
    v8 = (_BYTE *)operator new[]();
    v550 = v8;
    *v8 = 0;
    NConfig::loadString((NConfig *)v557, &v554, (const NString *)&v551, (const NString *)&v548);
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  }
  else
  {
    v554 = &off_24C7F32C0;
    v555 = strlen(a2);
    v556 = (void *)operator new[]();
    memcpy(v556, a2, (v555 + 1));
    v551 = &off_24C7F32C0;
    v552 = strlen(a3);
    v553 = (void *)operator new[]();
    memcpy(v553, a3, (v552 + 1));
    NConfig::load((NConfig *)v557, (const NString *)&v554, (const NString *)&v551);
  }
  v551 = &off_24C7F32C0;
  if (v553)
    MEMORY[0x212BAC9C0](v553, 0x1000C8077774924);
  v554 = &off_24C7F32C0;
  if (v556)
    MEMORY[0x212BAC9C0](v556, 0x1000C8077774924);
  v551 = &off_24C7F32C0;
  v552 = 4;
  v9 = (void *)operator new[]();
  v553 = v9;
  strcpy((char *)v9, "main");
  v10 = NConfig::section((NConfig *)v557, (const NString *)&v551);
  v548 = &off_24C7F32C0;
  v549 = 11;
  v11 = (void *)operator new[]();
  v550 = v11;
  strcpy((char *)v11, "hmmdetector");
  if (!NMap<NString,NString>::contains(v10 + 24, (uint64_t)&v548))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v12, v11, *(_QWORD *)(v10 + 16));
  v13 = NMap<NString,NString>::operator[](v10 + 24, (uint64_t)&v548);
  v554 = &off_24C7F32C0;
  v14 = *(_DWORD *)(v13 + 8);
  v555 = v14;
  v556 = (void *)operator new[]();
  memcpy(v556, *(const void **)(v13 + 16), (*(_DWORD *)(v13 + 8) + 1));
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  v548 = &off_24C7F32C0;
  v549 = 4;
  v15 = (void *)operator new[]();
  v550 = v15;
  strcpy((char *)v15, "main");
  v16 = NConfig::section((NConfig *)v557, (const NString *)&v548);
  v545 = &off_24C7F32C0;
  v546 = 15;
  v17 = (void *)operator new[]();
  v547 = v17;
  strcpy((char *)v17, "rescoredetector");
  if (!NMap<NString,NString>::contains(v16 + 24, (uint64_t)&v545))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v18, v17, *(_QWORD *)(v16 + 16));
  v19 = NMap<NString,NString>::operator[](v16 + 24, (uint64_t)&v545);
  v551 = &off_24C7F32C0;
  v552 = *(_DWORD *)(v19 + 8);
  v553 = (void *)operator new[]();
  memcpy(v553, *(const void **)(v19 + 16), (*(_DWORD *)(v19 + 8) + 1));
  MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  v545 = &off_24C7F32C0;
  v546 = 4;
  v20 = (void *)operator new[]();
  v547 = v20;
  strcpy((char *)v20, "main");
  v21 = NConfig::section((NConfig *)v557, (const NString *)&v545);
  v542 = &off_24C7F32C0;
  v543 = 6;
  v22 = (void *)operator new[]();
  v544 = v22;
  strcpy((char *)v22, "acanal");
  if (!NMap<NString,NString>::contains(v21 + 24, (uint64_t)&v542))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v23, v22, *(_QWORD *)(v21 + 16));
  v24 = NMap<NString,NString>::operator[](v21 + 24, (uint64_t)&v542);
  v548 = &off_24C7F32C0;
  v25 = *(_DWORD *)(v24 + 8);
  v549 = v25;
  v550 = (void *)operator new[]();
  memcpy(v550, *(const void **)(v24 + 16), (*(_DWORD *)(v24 + 8) + 1));
  MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
  v542 = &off_24C7F32C0;
  v543 = 4;
  v26 = (void *)operator new[]();
  v544 = v26;
  strcpy((char *)v26, "main");
  v27 = NConfig::section((NConfig *)v557, (const NString *)&v542);
  v539 = &off_24C7F32C0;
  v540 = 9;
  v28 = (char *)operator new[]();
  v541 = v28;
  strcpy(v28, "normalize");
  if (!NMap<NString,NString>::contains(v27 + 24, (uint64_t)&v539))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v29, v28, *(_QWORD *)(v27 + 16));
  v30 = NMap<NString,NString>::operator[](v27 + 24, (uint64_t)&v539);
  v545 = &off_24C7F32C0;
  v546 = *(_DWORD *)(v30 + 8);
  v547 = (void *)operator new[]();
  memcpy(v547, *(const void **)(v30 + 16), (*(_DWORD *)(v30 + 8) + 1));
  MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
  v539 = &off_24C7F32C0;
  v540 = 4;
  v31 = (char *)operator new[]();
  v541 = v31;
  strcpy(v31, "main");
  v32 = NConfig::section((NConfig *)v557, (const NString *)&v539);
  v536 = &off_24C7F32C0;
  v537 = 8;
  v33 = (char *)operator new[]();
  v538 = v33;
  strcpy(v33, "external");
  if (!NMap<NString,NString>::contains(v32 + 24, (uint64_t)&v536))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v34, v33, *(_QWORD *)(v32 + 16));
  v35 = NMap<NString,NString>::operator[](v32 + 24, (uint64_t)&v536);
  v542 = &off_24C7F32C0;
  v543 = *(_DWORD *)(v35 + 8);
  v544 = (void *)operator new[]();
  memcpy(v544, *(const void **)(v35 + 16), (*(_DWORD *)(v35 + 8) + 1));
  MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
  v539 = &off_24C7F32C0;
  v540 = 0;
  v541 = (_BYTE *)operator new[]();
  *v541 = 0;
  v536 = &off_24C7F32C0;
  v537 = 4;
  v36 = (char *)operator new[]();
  v538 = v36;
  strcpy(v36, "main");
  v37 = NConfig::section((NConfig *)v557, (const NString *)&v536);
  v533 = &off_24C7F32C0;
  v534 = 17;
  v38 = (void *)operator new[]();
  v535 = v38;
  *(_OWORD *)v488 = *(_OWORD *)"supervectorscorer";
  strcpy((char *)v38, "supervectorscorer");
  LODWORD(v37) = NMap<NString,NString>::contains(v37 + 24, (uint64_t)&v533);
  MEMORY[0x212BAC9C0](v38, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
  if ((_DWORD)v37)
  {
    v536 = &off_24C7F32C0;
    v537 = 4;
    v39 = (char *)operator new[]();
    v538 = v39;
    strcpy(v39, "main");
    v40 = NConfig::section((NConfig *)v557, (const NString *)&v536);
    v533 = &off_24C7F32C0;
    v534 = 17;
    v41 = (_WORD *)operator new[]();
    v535 = v41;
    v41[8] = 114;
    *(_OWORD *)v41 = *(_OWORD *)v488;
    if (!NMap<NString,NString>::contains(v40 + 24, (uint64_t)&v533))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v42, v41, *(_QWORD *)(v40 + 16));
    v43 = (uint64_t (***)(NString *__hidden, const unsigned int *))NMap<NString,NString>::operator[](v40 + 24, (uint64_t)&v533);
    if (&v539 != v43)
      ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (**)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))v539[8])(&v539, v43[2], v43 + 1);
    MEMORY[0x212BAC9C0](v41, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v39, 0x1000C8077774924);
  }
  v536 = &off_24C7F32C0;
  v537 = 0;
  v538 = (_BYTE *)operator new[]();
  *v538 = 0;
  v533 = &off_24C7F32C0;
  v534 = 4;
  v44 = (void *)operator new[]();
  v535 = v44;
  strcpy((char *)v44, "main");
  v45 = NConfig::section((NConfig *)v557, (const NString *)&v533);
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 20;
  v46 = (void *)operator new[]();
  v532 = v46;
  *(_OWORD *)v488 = *(_OWORD *)"supervectorsatscorer";
  strcpy((char *)v46, "supervectorsatscorer");
  LODWORD(v45) = NMap<NString,NString>::contains(v45 + 24, (uint64_t)&v530);
  MEMORY[0x212BAC9C0](v46, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v44, 0x1000C8077774924);
  if ((_DWORD)v45)
  {
    v533 = &off_24C7F32C0;
    v534 = 4;
    v48 = (void *)operator new[]();
    v535 = v48;
    strcpy((char *)v48, "main");
    v49 = NConfig::section((NConfig *)v557, (const NString *)&v533);
    v530 = (uint64_t (**)())&off_24C7F32C0;
    LODWORD(v531) = 20;
    v50 = (char *)operator new[]();
    v532 = v50;
    *(_OWORD *)v50 = *(_OWORD *)v488;
    strcpy(v50 + 13, "tscorer");
    if (!NMap<NString,NString>::contains(v49 + 24, (uint64_t)&v530))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v51, v50, *(_QWORD *)(v49 + 16));
    v52 = (uint64_t (***)(NString *__hidden, const unsigned int *))NMap<NString,NString>::operator[](v49 + 24, (uint64_t)&v530);
    if (&v536 != v52)
      ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (**)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))v536[8])(&v536, v52[2], v52 + 1);
    MEMORY[0x212BAC9C0](v50, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v48, 0x1000C8077774924);
  }
  if (!v14)
  {
    v455 = "NovDetect: main.hmmdetector option compulsory";
    goto LABEL_503;
  }
  if (!v25)
  {
    v455 = "NovDetect: main.acanal option compulsory";
LABEL_503:
    Error::chuck((Error *)v455, v47);
  }
  *((_OWORD *)this + 162) = 0u;
  *((_DWORD *)this + 654) = 0;
  *((_QWORD *)this + 326) = 0;
  *((_OWORD *)this + 164) = *((_OWORD *)this + 162);
  *((_OWORD *)this + 165) = *((_OWORD *)this + 163);
  *((_DWORD *)this + 670) = 0;
  *((_QWORD *)this + 336) = 0;
  *((_DWORD *)this + 674) = 0;
  *((_DWORD *)this + 682) = 0;
  *((_DWORD *)this + 770) = 0;
  v53 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v548);
  v533 = &off_24C7F32C0;
  v534 = 11;
  v54 = (void *)operator new[]();
  v535 = v54;
  strcpy((char *)v54, "sample_rate");
  v55 = NConfigSection::iOpt(v53, (const NString *)&v533);
  MEMORY[0x212BAC9C0](v54, 0x1000C8077774924);
  v533 = &off_24C7F32C0;
  v534 = 11;
  v56 = (void *)operator new[]();
  v535 = v56;
  strcpy((char *)v56, "acanal_file");
  if (!NMap<NString,NString>::contains((uint64_t)v53 + 24, (uint64_t)&v533))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v57, v56, *((_QWORD *)v53 + 2));
  v58 = NMap<NString,NString>::operator[]((uint64_t)v53 + 24, (uint64_t)&v533);
  v59 = (const NString *)v58;
  if (*(_DWORD *)(v58 + 8) >= 7u)
  {
    v60 = *(int **)(v58 + 16);
    v61 = *v60;
    v62 = *(int *)((char *)v60 + 3);
    if (v61 == 1684957549 && v62 == 980968804)
    {
      v64 = NMap<NString,NString>::find((uint64_t)this + 3088, v58);
      if (v64)
        v59 = (const NString *)v64;
    }
  }
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 6;
  v65 = (void *)operator new[]();
  v532 = v65;
  strcpy((char *)v65, "S16_LE");
  v527 = (char *)&off_24C7F32C0;
  LODWORD(v528) = 13;
  v66 = (char *)operator new[]();
  v529 = v66;
  strcpy(v66, "logical_order");
  v67 = NConfigSection::bOpt(v53, (const NString *)&v527);
  v524 = (char *)&off_24C7F32C0;
  v525 = 10;
  v68 = (void *)operator new[]();
  v526 = v68;
  strcpy((char *)v68, "confstring");
  v69 = NConfigSection::bOpt(v53, (const NString *)&v524);
  TSAcAnal::init((IntNovDetect *)((char *)this + 48), v59, v55, (const NString *)&v530, v67, v69);
  MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v66, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v65, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v56, 0x1000C8077774924);
  *((_QWORD *)this + 345) = ((float)((float)v55 / *((float *)this + 298)) + 0.5);
  v70 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v554);
  v533 = &off_24C7F32C0;
  v534 = 22;
  v71 = (void *)operator new[]();
  v535 = v71;
  *(_OWORD *)v481 = *(_OWORD *)"expected_interval_secs";
  strcpy((char *)v71, "expected_interval_secs");
  strcpy((char *)&v480, "al_secs");
  v72 = NConfigSection::fOpt(v70, (const NString *)&v533);
  v73 = *((float *)this + 298);
  MEMORY[0x212BAC9C0](v71, 0x1000C8077774924);
  v533 = &off_24C7F32C0;
  v534 = 16;
  v74 = (void *)operator new[]();
  v535 = v74;
  strcpy((char *)v74, "early_warn_state");
  v75 = NConfigSection::iOpt(v70, (const NString *)&v533);
  MEMORY[0x212BAC9C0](v74, 0x1000C8077774924);
  v533 = &off_24C7F32C0;
  v534 = 16;
  v76 = (void *)operator new[]();
  v535 = v76;
  qmemcpy(v479, "early_warn_thresearly_warn_state", sizeof(v479));
  strcpy((char *)v76, "early_warn_thres");
  *((float *)this + 716) = NConfigSection::fOpt(v70, (const NString *)&v533);
  MEMORY[0x212BAC9C0](v76, 0x1000C8077774924);
  v533 = &off_24C7F32C0;
  v534 = 10;
  v77 = (void *)operator new[]();
  v535 = v77;
  v478 = *(const NString **)"frame_skip";
  strcpy((char *)v77, "frame_skip");
  v78 = NConfigSection::iOpt(v70, (const NString *)&v533);
  MEMORY[0x212BAC9C0](v77, 0x1000C8077774924);
  if ((v78 & 0x80000000) != 0)
  {
    v456 = "NovDetect: detector.frame_skip must be +ve";
    goto LABEL_545;
  }
  v533 = &off_24C7F32C0;
  v534 = 16;
  v80 = (void *)operator new[]();
  v535 = v80;
  *(_OWORD *)v477 = *(_OWORD *)"lengthnorm_power";
  strcpy((char *)v80, "lengthnorm_power");
  *((float *)this + 718) = NConfigSection::fOpt(v70, (const NString *)&v533);
  MEMORY[0x212BAC9C0](v80, 0x1000C8077774924);
  v533 = &off_24C7F32C0;
  v534 = 15;
  v81 = (void *)operator new[]();
  v535 = v81;
  strcpy((char *)&v476, "best_after_norm");
  strcpy((char *)v81, "best_after_norm");
  v82 = (uint64_t)v70 + 24;
  v83 = NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v533);
  if (v83)
    LOBYTE(v83) = NConfigSection::bOpt(v70, (const NString *)&v533);
  v488[0] = v78;
  *((_BYTE *)this + 2882) = v83;
  MEMORY[0x212BAC9C0](v81, 0x1000C8077774924);
  v533 = &off_24C7F32C0;
  v534 = 14;
  v84 = (void *)operator new[]();
  v535 = v84;
  v85 = *(_QWORD *)"direct_lengths";
  strcpy((char *)v84, "direct_lengths");
  v86 = *(_QWORD *)"lengths";
  v87 = NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v533);
  if (v87)
    LOBYTE(v87) = NConfigSection::bOpt(v70, (const NString *)&v533);
  *((_BYTE *)this + 2880) = v87;
  MEMORY[0x212BAC9C0](v84, 0x1000C8077774924);
  if (!*((_BYTE *)this + 2882) && *((_BYTE *)this + 2880))
  {
    v456 = "NovDetect: best_after_norm=false not compatible with direct_lengths=true";
LABEL_545:
    Error::chuck((Error *)v456, v79);
  }
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 13;
  v88 = (void *)operator new[]();
  v532 = v88;
  strcpy((char *)v88, "keyword_label");
  strcpy((char *)&v474, "d_label");
  v475 = *(_QWORD *)"keyword_label";
  if (!NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v530))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v89, v88, *((_QWORD *)v70 + 2));
  v90 = NMap<NString,NString>::operator[]((uint64_t)v70 + 24, (uint64_t)&v530);
  v533 = &off_24C7F32C0;
  v534 = *(_DWORD *)(v90 + 8);
  v535 = (void *)operator new[]();
  memcpy(v535, *(const void **)(v90 + 16), (*(_DWORD *)(v90 + 8) + 1));
  v91 = (IntNovDetect *)MEMORY[0x212BAC9C0](v88, 0x1000C8077774924);
  if (*((_BYTE *)this + 2880))
    IntNovDetect::addLengthKeywords(v91, (const NString *)&v533);
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 16;
  v92 = (void *)operator new[]();
  v532 = v92;
  v473 = *(_OWORD *)"output_dist_file";
  strcpy((char *)v92, "output_dist_file");
  if (!NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v530))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v93, v92, *((_QWORD *)v70 + 2));
  v94 = NMap<NString,NString>::operator[]((uint64_t)v70 + 24, (uint64_t)&v530);
  v95 = (const NString *)v94;
  if (*(_DWORD *)(v94 + 8) >= 7u)
  {
    v96 = *(int **)(v94 + 16);
    v97 = *v96;
    v98 = *(int *)((char *)v96 + 3);
    if (v97 == 1684957549 && v98 == 980968804)
    {
      v100 = NMap<NString,NString>::find((uint64_t)this + 3088, v94);
      if (v100)
        v95 = (const NString *)v100;
    }
  }
  v527 = (char *)&off_24C7F32C0;
  LODWORD(v528) = 25;
  v101 = (char *)operator new[]();
  v529 = v101;
  v472 = *(_OWORD *)"output_dist_weights_ofile";
  strcpy(v101, "output_dist_weights_ofile");
  strcpy((char *)&v471, "t_weights_ofile");
  v524 = (char *)&off_24C7F32C0;
  v525 = 0;
  v526 = (void *)operator new[]();
  bzero(v526, (v525 + 1));
  if (NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v527))
  {
    if (!NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v527))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v102, v101, *((_QWORD *)v70 + 2));
    v103 = NMap<NString,NString>::operator[]((uint64_t)v70 + 24, (uint64_t)&v527);
  }
  else
  {
    v103 = (uint64_t)&v524;
  }
  if (*(_DWORD *)(v103 + 8) >= 7u)
  {
    v104 = *(int **)(v103 + 16);
    v105 = *v104;
    v106 = *(int *)((char *)v104 + 3);
    if (v105 == 1684957549 && v106 == 980968804)
    {
      v108 = NMap<NString,NString>::find((uint64_t)this + 3088, v103);
      if (v108)
        v103 = v108;
    }
  }
  v487 = (const NString *)v103;
  v521 = &off_24C7F32C0;
  v522 = 8;
  v109 = (void *)operator new[]();
  v523 = v109;
  strcpy((char *)v109, "hmm_file");
  if (!NMap<NString,NString>::contains((uint64_t)v70 + 24, (uint64_t)&v521))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v110, v109, *((_QWORD *)v70 + 2));
  v111 = NMap<NString,NString>::operator[]((uint64_t)v70 + 24, (uint64_t)&v521);
  v112 = *(_DWORD *)(v111 + 8);
  v486 = v95;
  if (v112 >= 7
    && ((v113 = *(int **)(v111 + 16), v114 = *v113, v115 = *(int *)((char *)v113 + 3), v114 == 1684957549)
      ? (v116 = v115 == 980968804)
      : (v116 = 0),
        v116))
  {
    v162 = v75;
    v163 = (const NString *)v111;
    v164 = NMap<NString,NString>::find((uint64_t)this + 3088, v111);
    v165 = v163;
    v75 = v162;
    v85 = *(_QWORD *)"direct_lengths";
    v86 = *(_QWORD *)"lengths";
    if (v164)
      v165 = (const NString *)v164;
    v485 = v165;
  }
  else
  {
    v485 = (const NString *)v111;
  }
  v518 = &off_24C7F32C0;
  v519 = 9;
  v117 = (void *)operator new[]();
  v520 = v117;
  v467 = *(_QWORD *)"gsm_label";
  strcpy((char *)v117, "gsm_label");
  if (!NMap<NString,NString>::contains(v82, (uint64_t)&v518))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v118, v117, *((_QWORD *)v70 + 2));
  v484 = (NString *)NMap<NString,NString>::operator[](v82, (uint64_t)&v518);
  v468 = *(_QWORD *)"hmm_file";
  v515 = &off_24C7F32C0;
  v516 = 16;
  v119 = (void *)operator new[]();
  v517 = v119;
  v466 = *(_OWORD *)"hmm_score_offset";
  strcpy((char *)v119, "hmm_score_offset");
  v512 = &off_24C7F32C0;
  v513 = 0;
  v514 = (void *)operator new[]();
  bzero(v514, 1uLL);
  if (NMap<NString,NString>::contains(v82, (uint64_t)&v515))
  {
    if (!NMap<NString,NString>::contains(v82, (uint64_t)&v515))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v120, v119, *((_QWORD *)v70 + 2));
    v121 = (NString *)NMap<NString,NString>::operator[](v82, (uint64_t)&v515);
  }
  else
  {
    v121 = (NString *)&v512;
  }
  v509 = &off_24C7F32C0;
  v510 = 15;
  v122 = (void *)operator new[]();
  v511 = v122;
  strcpy((char *)&v465, "state_init_file");
  strcpy((char *)v122, "state_init_file");
  if (!NMap<NString,NString>::contains(v82, (uint64_t)&v509))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v123, v122, *((_QWORD *)v70 + 2));
  v124 = NMap<NString,NString>::operator[](v82, (uint64_t)&v509);
  v125 = (uint64_t (***)(NString *__hidden, const unsigned int *))v124;
  v126 = *(_DWORD *)(v124 + 8);
  v469 = v86;
  v470 = v85;
  v483 = v75;
  v482 = v121;
  if (v126 >= 7)
  {
    v127 = *(int **)(v124 + 16);
    v128 = *v127;
    v129 = *(int *)((char *)v127 + 3);
    if (v128 == 1684957549 && v129 == 980968804)
    {
      v131 = NMap<NString,NString>::find((uint64_t)this + 3088, v124);
      if (v131)
        v125 = (uint64_t (***)(NString *__hidden, const unsigned int *))v131;
    }
  }
  v132 = *((_DWORD *)this + 250);
  v133 = *((unsigned __int8 *)this + 1032);
  v506 = &off_24C7F32C0;
  v507 = 18;
  v508 = (char *)operator new[]();
  v464 = *(_OWORD *)"output_dist_frames";
  strcpy(v508, "output_dist_frames");
  if (NMap<NString,NString>::contains(v82, (uint64_t)&v506))
    v134 = NConfigSection::iOpt(v70, (const NString *)&v506);
  else
    v134 = 1;
  v135 = v70;
  v503 = &off_24C7F32C0;
  v504 = 20;
  v505 = (char *)operator new[]();
  v463 = *(_OWORD *)"endpad_length_encode";
  strcpy(v505, "endpad_length_encode");
  strcpy((char *)&v462, "_encode");
  if (NMap<NString,NString>::contains(v82, (uint64_t)&v503))
    v136 = NConfigSection::bOpt(v70, (const NString *)&v503);
  else
    v136 = 0;
  *(_QWORD *)v500 = &off_24C7F32C0;
  v501 = 14;
  v502 = (char *)operator new[]();
  strcpy(v502, "latency_offset");
  strcpy((char *)&v461, "_offset");
  v137 = NConfigSection::iOpt(v135, (const NString *)v500);
  TSHMMDetector::init((IntNovDetect *)((char *)this + 1288), v486, v487, v485, v484, (const NString *)&v533, v482, v125, v72 * v73, 0, v483, v132 * ((2 * v133) | 1), v488[0], v134, 0, 0, v136, v137);
  if (v502)
    MEMORY[0x212BAC9C0](v502, 0x1000C8077774924);
  if (v505)
    MEMORY[0x212BAC9C0](v505, 0x1000C8077774924);
  if (v508)
    MEMORY[0x212BAC9C0](v508, 0x1000C8077774924);
  if (v511)
    MEMORY[0x212BAC9C0](v511, 0x1000C8077774924);
  v512 = &off_24C7F32C0;
  if (v514)
    MEMORY[0x212BAC9C0](v514, 0x1000C8077774924);
  if (v517)
    MEMORY[0x212BAC9C0](v517, 0x1000C8077774924);
  if (v520)
    MEMORY[0x212BAC9C0](v520, 0x1000C8077774924);
  if (v523)
    MEMORY[0x212BAC9C0](v523, 0x1000C8077774924);
  v524 = (char *)&off_24C7F32C0;
  if (v526)
    MEMORY[0x212BAC9C0](v526, 0x1000C8077774924);
  if (v529)
    MEMORY[0x212BAC9C0](v529, 0x1000C8077774924);
  if (v532)
    MEMORY[0x212BAC9C0](v532, 0x1000C8077774924);
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 20;
  v138 = (void *)operator new[]();
  v532 = v138;
  strcpy((char *)v138, "background_init_secs");
  v139 = NConfigSection::fOpt(v135, (const NString *)&v530);
  MEMORY[0x212BAC9C0](v138, 0x1000C8077774924);
  if (v139 < 0.0)
    Error::chuck((Error *)"NovDetect: detector.background_init_secs must be +ve", v140);
  *((_DWORD *)this + 742) = (float)(v139 * *((float *)this + 298));
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 20;
  v141 = (void *)operator new[]();
  v532 = v141;
  strcpy((char *)v141, "zerosample_init_secs");
  v142 = NConfigSection::fOpt(v135, (const NString *)&v530);
  MEMORY[0x212BAC9C0](v141, 0x1000C8077774924);
  if (v142 < 0.0)
  {
    v457 = "NovDetect: detector.zerosample_init_secs must be +ve";
    goto LABEL_515;
  }
  *((_DWORD *)this + 745) = (float)(v142 * *((float *)this + 298));
  if (!*((_BYTE *)this + 1684))
  {
    v457 = "TSHMMDetector::frameSize() - init() not called";
    goto LABEL_515;
  }
  v486 = *(const NString **)"latency_offset";
  if (*((_DWORD *)this + 368) != *((_DWORD *)this + 250) * ((2 * *((unsigned __int8 *)this + 1032)) | 1))
  {
    v457 = "NovDetect: incompatible framesize in acanal and detector sections";
LABEL_515:
    Error::chuck((Error *)v457, v143);
  }
  v144 = *((_DWORD *)this + 366);
  v145 = *((unsigned __int8 *)this + 2880);
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 13;
  v146 = (void *)operator new[]();
  v532 = v146;
  strcpy((char *)v146, "phrase_scores");
  strcpy((char *)&v484, "_scores");
  v485 = *(const NString **)"phrase_scores";
  v147 = NConfigSection::bOpt(v135, (const NString *)&v530);
  v148 = v144 / (v145 + 1);
  MEMORY[0x212BAC9C0](v146, 0x1000C8077774924);
  if (v147)
    *((_DWORD *)this + 770) = v148;
  v530 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v531) = 19;
  v149 = (void *)operator new[]();
  v532 = v149;
  *(_OWORD *)v488 = *(_OWORD *)"phrase_score_offset";
  strcpy((char *)v149, "phrase_score_offset");
  v150 = NMap<NString,NString>::contains(v82, (uint64_t)&v530);
  MEMORY[0x212BAC9C0](v149, 0x1000C8077774924);
  if (v150)
  {
    v530 = &off_24C7F2E28;
    v531 = 0;
    LODWORD(v532) = 0;
    v524 = (char *)&off_24C7F32C0;
    v525 = 19;
    v152 = (_DWORD *)operator new[]();
    v526 = v152;
    v152[4] = 7628147;
    *(_OWORD *)v152 = *(_OWORD *)v488;
    if (!NMap<NString,NString>::contains(v82, (uint64_t)&v524))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v153, v152, *((_QWORD *)v135 + 2));
    v154 = NMap<NString,NString>::operator[](v82, (uint64_t)&v524);
    v521 = &off_24C7F32C0;
    v522 = 1;
    v523 = (void *)operator new[]();
    memcpy(v523, ",", (v522 + 1));
    v518 = &off_24C7F32C0;
    v519 = 1;
    v520 = (void *)operator new[]();
    memcpy(v520, " ", (v519 + 1));
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v154 + 112))(&v527, v154, &v521, &v518);
    v515 = &off_24C7F32C0;
    v516 = 4;
    v155 = (void *)operator new[]();
    v517 = v155;
    strcpy((char *)v155, "\r\n\t ");
    LODWORD(v512) = -1;
    NString::split((uint64_t)&v527, &v530, (uint64_t)&v515, (unsigned int *)&v512);
    MEMORY[0x212BAC9C0](v155, 0x1000C8077774924);
    v527 = (char *)&off_24C7F32C0;
    if (v529)
      MEMORY[0x212BAC9C0](v529, 0x1000C8077774924);
    v518 = &off_24C7F32C0;
    if (v520)
      MEMORY[0x212BAC9C0](v520, 0x1000C8077774924);
    v521 = &off_24C7F32C0;
    if (v523)
      MEMORY[0x212BAC9C0](v523, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v152, 0x1000C8077774924);
    if ((_DWORD)v532 && (_DWORD)v532 != (_DWORD)v148)
      Error::chuck((Error *)"NovDetect: phrase_score_offset/keyword_label size mismatch (%d/%d)", v156, v532, v148);
    (*(void (**)(char *, void **))(*((_QWORD *)this + 351) + 32))((char *)this + 2808, &v532);
    v157 = v531;
    if ((_DWORD)v532)
    {
      v158 = 0;
      v159 = 0;
      do
      {
        v160 = v157 + v158;
        if (!*(_DWORD *)(v160 + 8)
          || (v527 = 0,
              strtod(*(const char **)(v160 + 16), &v527),
              v527 != (char *)(*(_QWORD *)(v160 + 16) + *(unsigned int *)(v160 + 8))))
        {
          Error::chuck((Error *)"NovDetect: cannot convert element to float", v151);
        }
        v157 = v531;
        v161 = atof(*(const char **)(v531 + v158 + 16));
        *(float *)(*((_QWORD *)this + 352) + 4 * v159++) = v161;
        v158 += 24;
      }
      while (v159 < v532);
      v530 = &off_24C7F2E28;
    }
    else
    {
      v530 = &off_24C7F2E28;
      if (!v531)
        goto LABEL_150;
    }
    v166 = *(_QWORD *)(v157 - 8);
    if (v166)
    {
      v167 = 24 * v166;
      do
      {
        *(_QWORD *)(v157 + v167 - 24) = &off_24C7F32C0;
        v168 = *(_QWORD *)(v157 + v167 - 8);
        if (v168)
          MEMORY[0x212BAC9C0](v168, 0x1000C8077774924);
        v167 -= 24;
      }
      while (v167);
    }
    MEMORY[0x212BAC9C0](v157 - 16, 0x1091C800F2A5985);
  }
LABEL_150:
  v533 = &off_24C7F32C0;
  if (v535)
    MEMORY[0x212BAC9C0](v535, 0x1000C8077774924);
  v487 = (IntNovDetect *)((char *)this + 2604);
  *((_BYTE *)this + 2891) = 0;
  *((_BYTE *)this + 2885) = 0;
  *((_DWORD *)this + 714) = 0;
  if (v552)
  {
    v169 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v551);
    v533 = &off_24C7F32C0;
    v534 = 22;
    v170 = (_OWORD *)operator new[]();
    v535 = v170;
    *v170 = *(_OWORD *)v481;
    *(_QWORD *)((char *)v170 + 15) = v480;
    v171 = NConfigSection::fOpt(v169, (const NString *)&v533);
    v172 = *((float *)this + 298);
    MEMORY[0x212BAC9C0](v170, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 16;
    v173 = (_BYTE *)operator new[]();
    v535 = v173;
    v173[16] = 0;
    *(_OWORD *)v173 = v479[1];
    v174 = NConfigSection::iOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v173, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 16;
    v175 = (_BYTE *)operator new[]();
    v535 = v175;
    v175[16] = 0;
    *(_OWORD *)v175 = v479[0];
    *((float *)this + 717) = NConfigSection::fOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v175, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 10;
    v176 = (_QWORD *)operator new[]();
    v535 = v176;
    *(_DWORD *)((char *)v176 + 7) = 7367019;
    *v176 = v478;
    v177 = NConfigSection::iOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v176, 0x1000C8077774924);
    if (v177 < 0)
      Error::chuck((Error *)"NovDetect: rescoredetector.frame_skip must be +ve", v178);
    *((_BYTE *)this + 2891) = 1;
    v533 = &off_24C7F32C0;
    v534 = 13;
    v179 = (void *)operator new[]();
    v535 = v179;
    strcpy((char *)v179, "rescore_thres");
    *((float *)this + 715) = NConfigSection::fOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v179, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 22;
    v180 = (void *)operator new[]();
    v535 = v180;
    strcpy((char *)v180, "firstpass_score_offset");
    *((float *)this + 714) = NConfigSection::fOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v180, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 18;
    v181 = (void *)operator new[]();
    v535 = v181;
    strcpy((char *)v181, "rescore_extra_time");
    v182 = NConfigSection::fOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v181, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 25;
    v183 = (void *)operator new[]();
    v535 = v183;
    strcpy((char *)v183, "rescore_max_windback_time");
    v184 = NConfigSection::fOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v183, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 27;
    v185 = (void *)operator new[]();
    v535 = v185;
    strcpy((char *)v185, "rescore_extra_windback_time");
    v186 = NConfigSection::fOpt(v169, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v185, 0x1000C8077774924);
    if (v182 < 0.0)
    {
      v458 = "NovDetect: rescoredetector.rescore_extra_time must be +ve";
    }
    else if (v184 < 0.0)
    {
      v458 = "NovDetect: rescoredetector.rescore_max_windback_time must be +ve";
    }
    else
    {
      if (v186 >= 0.0)
      {
        v188 = *((float *)this + 298);
        *((_DWORD *)this + 698) = (float)(v182 * v188);
        *((_DWORD *)this + 699) = (float)(v186 * v188);
        v189 = (float)(v184 * v188);
        *(_DWORD *)v499 = v189;
        if (*((_DWORD *)this + 629))
        {
          v459 = "RingDropBuffer::resize() - cannot resize unless empty";
        }
        else
        {
          if (v189)
          {
            NArray<NFrame>::resize((uint64_t)this + 2488, v499);
            LODWORD(v482) = v177;
            v483 = v174;
            *((_QWORD *)this + 314) = 0;
            v530 = (uint64_t (**)())&off_24C7F32C0;
            LODWORD(v531) = 11;
            v190 = (void *)operator new[]();
            v532 = v190;
            strcpy((char *)v190, "supervector");
            if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v530))
              Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v191, v190, *((_QWORD *)v169 + 2));
            v192 = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v530);
            v533 = &off_24C7F32C0;
            v534 = *(_DWORD *)(v192 + 8);
            v193 = v534;
            v535 = (void *)operator new[]();
            memcpy(v535, *(const void **)(v192 + 16), (*(_DWORD *)(v192 + 8) + 1));
            MEMORY[0x212BAC9C0](v190, 0x1000C8077774924);
            if (v193)
              v194 = v189;
            else
              v194 = 0;
            v481[0] = v194;
            v530 = (uint64_t (**)())&off_24C7F32C0;
            LODWORD(v531) = 16;
            v195 = (_BYTE *)operator new[]();
            v532 = v195;
            v195[16] = 0;
            *(_OWORD *)v195 = *(_OWORD *)v477;
            v197 = v469;
            v196 = v470;
            *((float *)this + 719) = NConfigSection::fOpt(v169, (const NString *)&v530);
            MEMORY[0x212BAC9C0](v195, 0x1000C8077774924);
            v530 = (uint64_t (**)())&off_24C7F32C0;
            LODWORD(v531) = 15;
            v198 = (_OWORD *)operator new[]();
            v532 = v198;
            *v198 = v476;
            v199 = NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v530);
            if (v199)
              LOBYTE(v199) = NConfigSection::bOpt(v169, (const NString *)&v530);
            *((_BYTE *)this + 2883) = v199;
            MEMORY[0x212BAC9C0](v198, 0x1000C8077774924);
            v530 = (uint64_t (**)())&off_24C7F32C0;
            LODWORD(v531) = 14;
            v200 = (_QWORD *)operator new[]();
            v532 = v200;
            *v200 = v196;
            *(_QWORD *)((char *)v200 + 7) = v197;
            v201 = NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v530);
            if (v201)
              LOBYTE(v201) = NConfigSection::bOpt(v169, (const NString *)&v530);
            *((_BYTE *)this + 2881) = v201;
            MEMORY[0x212BAC9C0](v200, 0x1000C8077774924);
            if (!*((_BYTE *)this + 2883) && *((_BYTE *)this + 2881))
              Error::chuck((Error *)"NovDetect: best_after_norm=false not compatible with direct_lengths=true", v202);
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 13;
            v203 = (_QWORD *)operator new[]();
            v529 = v203;
            *v203 = v475;
            *(_QWORD *)((char *)v203 + 6) = v474;
            if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v527))
              Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v204, v203, *((_QWORD *)v169 + 2));
            v205 = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v527);
            v530 = (uint64_t (**)())&off_24C7F32C0;
            LODWORD(v531) = *(_DWORD *)(v205 + 8);
            v532 = (void *)operator new[]();
            memcpy(v532, *(const void **)(v205 + 16), (*(_DWORD *)(v205 + 8) + 1));
            v206 = (IntNovDetect *)MEMORY[0x212BAC9C0](v203, 0x1000C8077774924);
            if (*((_BYTE *)this + 2881))
              IntNovDetect::addLengthKeywords(v206, (const NString *)&v530);
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 16;
            v207 = operator new[]();
            v529 = (_QWORD *)v207;
            *(_BYTE *)(v207 + 16) = 0;
            *(_OWORD *)v207 = v473;
            if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v527))
              Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v208, v207, *((_QWORD *)v169 + 2));
            v209 = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v527);
            v210 = (NString *)v209;
            if (*(_DWORD *)(v209 + 8) >= 7u)
            {
              v211 = *(int **)(v209 + 16);
              v212 = *v211;
              v213 = *(int *)((char *)v211 + 3);
              if (v212 == 1684957549 && v213 == 980968804)
              {
                v215 = NMap<NString,NString>::find((uint64_t)this + 3088, v209);
                if (v215)
                  v210 = (NString *)v215;
              }
            }
            v524 = (char *)&off_24C7F32C0;
            v525 = 25;
            v216 = (_OWORD *)operator new[]();
            v526 = v216;
            *v216 = v472;
            *(_OWORD *)((char *)v216 + 10) = v471;
            v521 = &off_24C7F32C0;
            v522 = 0;
            v523 = (void *)operator new[]();
            bzero(v523, (v522 + 1));
            v217 = v468;
            if (NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v524))
            {
              if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v524))
                Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v218, v216, *((_QWORD *)v169 + 2));
              v219 = (uint64_t (***)(NString *__hidden, const unsigned int *))NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v524);
            }
            else
            {
              v219 = &v521;
            }
            if (*((_DWORD *)v219 + 2) >= 7u)
            {
              v220 = v219[2];
              v221 = *(_DWORD *)v220;
              v222 = *(_DWORD *)((char *)v220 + 3);
              if (v221 == 1684957549 && v222 == 980968804)
              {
                v224 = NMap<NString,NString>::find((uint64_t)this + 3088, (uint64_t)v219);
                if (v224)
                  v219 = (uint64_t (***)(NString *__hidden, const unsigned int *))v224;
              }
            }
            v518 = &off_24C7F32C0;
            v519 = 8;
            v225 = (_BYTE *)operator new[]();
            v520 = v225;
            v225[8] = 0;
            *(_QWORD *)v225 = v217;
            if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v518))
              Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v226, v225, *((_QWORD *)v169 + 2));
            v227 = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v518);
            if (*(_DWORD *)(v227 + 8) >= 7u
              && ((v228 = *(int **)(v227 + 16), v229 = *v228, v230 = *(int *)((char *)v228 + 3), v229 == 1684957549)
                ? (v231 = v230 == 980968804)
                : (v231 = 0),
                  v231))
            {
              v272 = (NString *)v227;
              v273 = NMap<NString,NString>::find((uint64_t)this + 3088, v227);
              if (v273)
                v274 = (NString *)v273;
              else
                v274 = v272;
              v480 = v274;
            }
            else
            {
              v480 = (NString *)v227;
            }
            v515 = &off_24C7F32C0;
            v516 = 9;
            v232 = (_WORD *)operator new[]();
            v517 = v232;
            v232[4] = 108;
            *(_QWORD *)v232 = v467;
            if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v515))
              Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v233, v232, *((_QWORD *)v169 + 2));
            *(_QWORD *)&v479[1] = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v515);
            v512 = &off_24C7F32C0;
            v513 = 16;
            v234 = (_BYTE *)operator new[]();
            v514 = v234;
            v234[16] = 0;
            *(_OWORD *)v234 = v466;
            v509 = &off_24C7F32C0;
            v510 = 0;
            v511 = (void *)operator new[]();
            bzero(v511, (v510 + 1));
            *(_QWORD *)&v479[0] = v219;
            if (NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v512))
            {
              if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v512))
                Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v235, v234, *((_QWORD *)v169 + 2));
              v478 = (const NString *)NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v512);
            }
            else
            {
              v478 = (const NString *)&v509;
            }
            v506 = &off_24C7F32C0;
            v507 = 15;
            v236 = (char *)operator new[]();
            v508 = v236;
            *(_OWORD *)v236 = v465;
            if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v506))
              Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v237, v236, *((_QWORD *)v169 + 2));
            v238 = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v506);
            v239 = (uint64_t (***)(NString *__hidden, const unsigned int *))v238;
            v240 = *(_DWORD *)(v238 + 8);
            v477[0] = v210;
            if (v240 >= 7)
            {
              v241 = *(int **)(v238 + 16);
              v242 = *v241;
              v243 = *(int *)((char *)v241 + 3);
              if (v242 == 1684957549 && v243 == 980968804)
              {
                v245 = NMap<NString,NString>::find((uint64_t)this + 3088, v238);
                if (v245)
                  v239 = (uint64_t (***)(NString *__hidden, const unsigned int *))v245;
              }
            }
            LODWORD(v476) = *((_DWORD *)this + 250);
            LODWORD(v475) = *((unsigned __int8 *)this + 1032);
            v503 = &off_24C7F32C0;
            v504 = 18;
            v246 = operator new[]();
            v505 = (char *)v246;
            *(_DWORD *)(v246 + 15) = 7562605;
            *(_OWORD *)v246 = v464;
            if (NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v503))
              v247 = NConfigSection::iOpt(v169, (const NString *)&v503);
            else
              v247 = 1;
            *(_QWORD *)v500 = &off_24C7F32C0;
            v501 = 19;
            v502 = (char *)operator new[]();
            strcpy(v502, "batch_cmn_maxframes");
            if (NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)v500))
              v248 = NConfigSection::iOpt(v169, (const NString *)v500);
            else
              v248 = 0;
            v496 = &off_24C7F32C0;
            v497 = 19;
            v498 = (char *)operator new[]();
            strcpy(v498, "batch_cmn_minframes");
            if (NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v496))
              v249 = NConfigSection::iOpt(v169, (const NString *)&v496);
            else
              v249 = 0;
            *(_QWORD *)v493 = &off_24C7F32C0;
            v494 = 20;
            v250 = operator new[]();
            v495 = v250;
            *(_OWORD *)v250 = v463;
            *(_QWORD *)(v250 + 13) = v462;
            if (NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)v493))
              v251 = NConfigSection::bOpt(v169, (const NString *)v493);
            else
              v251 = 0;
            *(_QWORD *)v490 = &off_24C7F32C0;
            v491 = 14;
            v252 = (_QWORD *)operator new[]();
            v492 = v252;
            *v252 = v486;
            *(_QWORD *)((char *)v252 + 7) = v461;
            v253 = NConfigSection::iOpt(v169, (const NString *)v490);
            TSHMMDetector::init((IntNovDetect *)((char *)this + 1696), v477[0], *(const NString **)&v479[0], v480, *(const NString **)&v479[1], (const NString *)&v530, v478, v239, v171 * v172, v481[0], v483, v476 * ((2 * v475) | 1), v482, v247, v248, v249, v251, v253);
            if (v492)
              MEMORY[0x212BAC9C0](v492, 0x1000C8077774924);
            if (v495)
              MEMORY[0x212BAC9C0](v495, 0x1000C8077774924);
            if (v498)
              MEMORY[0x212BAC9C0](v498, 0x1000C8077774924);
            if (v502)
              MEMORY[0x212BAC9C0](v502, 0x1000C8077774924);
            if (v505)
              MEMORY[0x212BAC9C0](v505, 0x1000C8077774924);
            if (v508)
              MEMORY[0x212BAC9C0](v508, 0x1000C8077774924);
            v509 = &off_24C7F32C0;
            if (v511)
              MEMORY[0x212BAC9C0](v511, 0x1000C8077774924);
            if (v514)
              MEMORY[0x212BAC9C0](v514, 0x1000C8077774924);
            if (v517)
              MEMORY[0x212BAC9C0](v517, 0x1000C8077774924);
            if (v520)
              MEMORY[0x212BAC9C0](v520, 0x1000C8077774924);
            v521 = &off_24C7F32C0;
            if (v523)
              MEMORY[0x212BAC9C0](v523, 0x1000C8077774924);
            if (v526)
              MEMORY[0x212BAC9C0](v526, 0x1000C8077774924);
            if (v529)
              MEMORY[0x212BAC9C0](v529, 0x1000C8077774924);
            v254 = *((_DWORD *)this + 468);
            v255 = *((unsigned __int8 *)this + 2881);
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 13;
            v256 = (_QWORD *)operator new[]();
            v529 = v256;
            *v256 = v485;
            *(_QWORD *)((char *)v256 + 6) = v484;
            v257 = NConfigSection::bOpt(v169, (const NString *)&v527);
            v258 = v254 / (v255 + 1);
            MEMORY[0x212BAC9C0](v256, 0x1000C8077774924);
            if (v257 && v258 > *((_DWORD *)this + 770))
              *((_DWORD *)this + 770) = v258;
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 19;
            v259 = operator new[]();
            v529 = (_QWORD *)v259;
            *(_DWORD *)(v259 + 16) = 7628147;
            *(_OWORD *)v259 = *(_OWORD *)v488;
            v260 = NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v527);
            MEMORY[0x212BAC9C0](v259, 0x1000C8077774924);
            if (v260)
            {
              v527 = (char *)&off_24C7F2E28;
              v528 = 0;
              LODWORD(v529) = 0;
              v521 = &off_24C7F32C0;
              v522 = 19;
              v262 = (_DWORD *)operator new[]();
              v523 = v262;
              v262[4] = 7628147;
              *(_OWORD *)v262 = *(_OWORD *)v488;
              if (!NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v521))
                Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v263, v262, *((_QWORD *)v169 + 2));
              v264 = NMap<NString,NString>::operator[]((uint64_t)v169 + 24, (uint64_t)&v521);
              v518 = &off_24C7F32C0;
              v519 = 1;
              v520 = (void *)operator new[]();
              memcpy(v520, ",", (v519 + 1));
              v515 = &off_24C7F32C0;
              v516 = 1;
              v517 = (void *)operator new[]();
              memcpy(v517, " ", (v516 + 1));
              (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v264 + 112))(&v524, v264, &v518, &v515);
              v512 = &off_24C7F32C0;
              v513 = 4;
              v265 = (void *)operator new[]();
              v514 = v265;
              strcpy((char *)v265, "\r\n\t ");
              LODWORD(v509) = -1;
              NString::split((uint64_t)&v524, &v527, (uint64_t)&v512, (unsigned int *)&v509);
              MEMORY[0x212BAC9C0](v265, 0x1000C8077774924);
              v524 = (char *)&off_24C7F32C0;
              if (v526)
                MEMORY[0x212BAC9C0](v526, 0x1000C8077774924);
              v515 = &off_24C7F32C0;
              if (v517)
                MEMORY[0x212BAC9C0](v517, 0x1000C8077774924);
              v518 = &off_24C7F32C0;
              if (v520)
                MEMORY[0x212BAC9C0](v520, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v262, 0x1000C8077774924);
              if ((_DWORD)v529 && (_DWORD)v529 != (_DWORD)v258)
                Error::chuck((Error *)"NovDetect: phrase_score_offset/keyword_label size mismatch (%d/%d)", v266, v529, v258);
              (*(void (**)(char *, _QWORD **))(*((_QWORD *)this + 354) + 32))((char *)this + 2832, &v529);
              v267 = v528;
              if ((_DWORD)v529)
              {
                v268 = 0;
                v269 = 0;
                do
                {
                  v270 = v267 + v268;
                  if (!*(_DWORD *)(v270 + 8)
                    || (v524 = 0,
                        strtod(*(const char **)(v270 + 16), &v524),
                        v524 != (char *)(*(_QWORD *)(v270 + 16) + *(unsigned int *)(v270 + 8))))
                  {
                    Error::chuck((Error *)"NovDetect: cannot convert element to float", v261);
                  }
                  v267 = v528;
                  v271 = atof(*(const char **)(v528 + v268 + 16));
                  *(float *)(*((_QWORD *)this + 355) + 4 * v269++) = v271;
                  v268 += 24;
                }
                while (v269 < v529);
                v527 = (char *)&off_24C7F2E28;
              }
              else
              {
                v527 = (char *)&off_24C7F2E28;
                if (!v528)
                  goto LABEL_282;
              }
              v275 = *(_QWORD *)(v267 - 8);
              if (v275)
              {
                v276 = 24 * v275;
                do
                {
                  *(_QWORD *)(v267 + v276 - 24) = &off_24C7F32C0;
                  v277 = *(_QWORD *)(v267 + v276 - 8);
                  if (v277)
                    MEMORY[0x212BAC9C0](v277, 0x1000C8077774924);
                  v276 -= 24;
                }
                while (v276);
              }
              MEMORY[0x212BAC9C0](v267 - 16, 0x1091C800F2A5985);
            }
LABEL_282:
            if (!v534)
              goto LABEL_335;
            v278 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v533);
            *((_BYTE *)this + 2885) = 1;
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 9;
            v279 = (char *)operator new[]();
            v529 = v279;
            strcpy(v279, "embedding");
            if (NMap<NString,NString>::contains((uint64_t)v278 + 24, (uint64_t)&v527))
            {
              v280 = NConfigSection::bOpt(v278, (const NString *)&v527);
              MEMORY[0x212BAC9C0](v279, 0x1000C8077774924);
              if (v280)
              {
                *((_BYTE *)this + 2886) = 1;
                v527 = (char *)&off_24C7F32C0;
                LODWORD(v528) = 9;
                v281 = (char *)operator new[]();
                v529 = v281;
                strcpy(v281, "durations");
                if (!NConfigSection::bOpt(v278, (const NString *)&v527))
                {
                  v524 = (char *)&off_24C7F32C0;
                  v525 = 5;
                  v282 = (void *)operator new[]();
                  v526 = v282;
                  strcpy((char *)v282, "means");
                  if ((NConfigSection::bOpt(v278, (const NString *)&v524) & 1) == 0)
                  {
                    v521 = &off_24C7F32C0;
                    v522 = 5;
                    v283 = (void *)operator new[]();
                    v523 = v283;
                    strcpy((char *)v283, "score");
                    v284 = NConfigSection::bOpt(v278, (const NString *)&v521);
                    MEMORY[0x212BAC9C0](v283, 0x1000C8077774924);
                    MEMORY[0x212BAC9C0](v282, 0x1000C8077774924);
                    MEMORY[0x212BAC9C0](v281, 0x1000C8077774924);
                    if ((v284 & 1) == 0)
                    {
                      v285 = 0;
                      *(_QWORD *)v487 = 0x100000000;
                      *(_QWORD *)((char *)this + 2612) = *((unsigned int *)this + 496);
                      goto LABEL_319;
                    }
LABEL_553:
                    Error::chuck((Error *)"NovDetect: supervector.embedding option incompatible with durations/means/score", v261);
                  }
                  MEMORY[0x212BAC9C0](v282, 0x1000C8077774924);
                }
                MEMORY[0x212BAC9C0](v281, 0x1000C8077774924);
                goto LABEL_553;
              }
            }
            else
            {
              MEMORY[0x212BAC9C0](v279, 0x1000C8077774924);
            }
            *((_BYTE *)this + 2886) = 0;
            if (*((_DWORD *)this + 468))
              v286 = **((_DWORD **)this + 233) - 1;
            else
              v286 = 0;
            v287 = *((_DWORD *)this + 688);
            if (v287 != v286)
            {
              v288 = *((_QWORD *)this + 343);
              *((_DWORD *)this + 688) = v286;
              v289 = operator new[]();
              *((_QWORD *)this + 343) = v289;
              if (v287 >= v286)
                v290 = v286;
              else
                v290 = v287;
              if ((_DWORD)v290)
              {
                v291 = 0;
                if (v290 < 8)
                  goto LABEL_303;
                if ((unint64_t)(v289 - v288) <= 0x1F)
                  goto LABEL_303;
                v291 = v290 & 0xFFFFFFF8;
                v292 = (_OWORD *)(v289 + 16);
                v293 = (__int128 *)(v288 + 16);
                v294 = v291;
                do
                {
                  v295 = *v293;
                  *(v292 - 1) = *(v293 - 1);
                  *v292 = v295;
                  v292 += 2;
                  v293 += 2;
                  v294 -= 8;
                }
                while (v294);
                if (v291 != v290)
                {
LABEL_303:
                  v296 = v290 - v291;
                  v297 = 4 * v291;
                  v298 = (_DWORD *)(v289 + 4 * v291);
                  v299 = (int *)(v288 + v297);
                  do
                  {
                    v300 = *v299++;
                    *v298++ = v300;
                    --v296;
                  }
                  while (v296);
                }
                goto LABEL_307;
              }
              if (v288)
LABEL_307:
                MEMORY[0x212BAC9C0](v288, 0x1000C8052888210);
            }
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 9;
            v301 = (char *)operator new[]();
            v529 = v301;
            strcpy(v301, "durations");
            v302 = NConfigSection::bOpt(v278, (const NString *)&v527);
            MEMORY[0x212BAC9C0](v301, 0x1000C8077774924);
            if (v302)
            {
              v303 = *((_DWORD *)this + 468);
              if (v303)
                v303 = **((_DWORD **)this + 233) - 1;
              *(_DWORD *)v487 = v303;
            }
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 5;
            v304 = (char *)operator new[]();
            v529 = v304;
            strcpy(v304, "means");
            v305 = NConfigSection::bOpt(v278, (const NString *)&v527);
            MEMORY[0x212BAC9C0](v304, 0x1000C8077774924);
            if (v305)
            {
              v306 = *((_DWORD *)this + 468);
              if (v306)
                v306 = **((_DWORD **)this + 233) - 1;
              *((_DWORD *)this + 652) = v306;
              *((_DWORD *)this + 653) = *((_DWORD *)this + 250) * ((2 * *((unsigned __int8 *)this + 1032)) | 1);
            }
            v527 = (char *)&off_24C7F32C0;
            LODWORD(v528) = 5;
            v307 = (char *)operator new[]();
            v529 = v307;
            strcpy(v307, "score");
            v308 = NConfigSection::bOpt(v278, (const NString *)&v527);
            MEMORY[0x212BAC9C0](v307, 0x1000C8077774924);
            if ((v308 & 1) != 0)
            {
              v285 = 1;
              *((_DWORD *)this + 654) = 1;
            }
            else
            {
              v285 = *((_DWORD *)this + 654);
            }
LABEL_319:
            v309 = *((_DWORD *)this + 651) + *((_DWORD *)this + 653) * *((_DWORD *)this + 652) + v285;
            v310 = *((_DWORD *)this + 668);
            if (v310 != v309)
            {
              v311 = *((_QWORD *)this + 333);
              *((_DWORD *)this + 668) = v309;
              v312 = operator new[]();
              *((_QWORD *)this + 333) = v312;
              if (v310 >= v309)
                v313 = v309;
              else
                v313 = v310;
              if ((_DWORD)v313)
              {
                v314 = 0;
                if (v313 < 8)
                  goto LABEL_329;
                if ((unint64_t)(v312 - v311) <= 0x1F)
                  goto LABEL_329;
                v314 = v313 & 0xFFFFFFF8;
                v315 = (_OWORD *)(v312 + 16);
                v316 = (__int128 *)(v311 + 16);
                v317 = v314;
                do
                {
                  v318 = *v316;
                  *(v315 - 1) = *(v316 - 1);
                  *v315 = v318;
                  v315 += 2;
                  v316 += 2;
                  v317 -= 8;
                }
                while (v317);
                if (v314 != v313)
                {
LABEL_329:
                  v319 = v313 - v314;
                  v320 = 4 * v314;
                  v321 = (_DWORD *)(v312 + 4 * v314);
                  v322 = (int *)(v311 + v320);
                  do
                  {
                    v323 = *v322++;
                    *v321++ = v323;
                    --v319;
                  }
                  while (v319);
                }
                goto LABEL_333;
              }
              if (v311)
LABEL_333:
                MEMORY[0x212BAC9C0](v311, 0x1000C8052888210);
            }
            *((_DWORD *)this + 650) = *((_DWORD *)this + 668);
            *((_QWORD *)this + 324) = *((_QWORD *)this + 333);
LABEL_335:
            if (*((_BYTE *)this + 2092))
            {
              if (*((_DWORD *)this + 470) == *((_DWORD *)this + 250) * ((2 * *((unsigned __int8 *)this + 1032)) | 1))
              {
                v527 = (char *)&off_24C7F32C0;
                LODWORD(v528) = 9;
                v324 = (char *)operator new[]();
                v529 = v324;
                strcpy(v324, "batch_pad");
                v325 = NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v527);
                if (v325)
                  LOBYTE(v325) = NConfigSection::bOpt(v169, (const NString *)&v527);
                *((_BYTE *)this + 2887) = v325;
                MEMORY[0x212BAC9C0](v324, 0x1000C8077774924);
                v527 = (char *)&off_24C7F32C0;
                LODWORD(v528) = 7;
                v326 = (_QWORD *)operator new[]();
                v529 = v326;
                *v326 = 0x6461705F646E65;
                v327 = NMap<NString,NString>::contains((uint64_t)v169 + 24, (uint64_t)&v527);
                if (v327)
                  LOBYTE(v327) = NConfigSection::bOpt(v169, (const NString *)&v527);
                *((_BYTE *)this + 2888) = v327;
                MEMORY[0x212BAC9C0](v326, 0x1000C8077774924);
                v530 = (uint64_t (**)())&off_24C7F32C0;
                if (v532)
                  MEMORY[0x212BAC9C0](v532, 0x1000C8077774924);
                if (v535)
                  MEMORY[0x212BAC9C0](v535, 0x1000C8077774924);
                goto LABEL_345;
              }
              v460 = "NovDetect: incompatible framesize in acanal and rescoredetector sections";
            }
            else
            {
              v460 = "TSHMMDetector::frameSize() - init() not called";
            }
            Error::chuck((Error *)v460, v261);
          }
          v459 = "NRingDropBuffer::resize() - cannot set size < 1";
        }
        Error::chuck((Error *)v459, v187);
      }
      v458 = "NovDetect: rescoredetector.rescore_extra_windback_time must be +ve";
    }
    Error::chuck((Error *)v458, v187);
  }
LABEL_345:
  *((_BYTE *)this + 2884) = 0;
  if (v546)
  {
    v328 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v545);
    v533 = &off_24C7F32C0;
    v534 = 11;
    v329 = (void *)operator new[]();
    v535 = v329;
    strcpy((char *)v329, "window_size");
    v330 = NConfigSection::iOpt(v328, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v329, 0x1000C8077774924);
    LODWORD(v530) = 0;
    v533 = &off_24C7F32C0;
    v534 = 13;
    v331 = (void *)operator new[]();
    v535 = v331;
    strcpy((char *)v331, "window_offset");
    v332 = NConfigSection::iOpt(v328, (const NString *)&v533);
    MEMORY[0x212BAC9C0](v331, 0x1000C8077774924);
    v533 = &off_24C7F32C0;
    v534 = 10;
    v333 = (void *)operator new[]();
    v535 = v333;
    strcpy((char *)v333, "min_frames");
    if (NMap<NString,NString>::contains((uint64_t)v328 + 24, (uint64_t)&v533))
      v334 = NConfigSection::iOpt(v328, (const NString *)&v533);
    else
      v334 = 0;
    MEMORY[0x212BAC9C0](v333, 0x1000C8077774924);
    if (v330 >= 0)
      v336 = v330;
    else
      v336 = v330 + 1;
    LODWORD(v530) = v332 + (v336 >> 1);
    if (v330 <= 0)
      Error::chuck((Error *)"NovDetect: normalisation window_size must be positive-valued", v335);
    LODWORD(v527) = v330;
    LODWORD(v524) = *((_DWORD *)this + 250) * ((2 * *((unsigned __int8 *)this + 1032)) | 1);
    v533 = &off_24C7F32C0;
    v534 = 12;
    v337 = (void *)operator new[]();
    v535 = v337;
    strcpy((char *)v337, "decay_factor");
    LODWORD(v521) = NConfigSection::fOpt(v328, (const NString *)&v533);
    LODWORD(v518) = v334;
    NLocalCepNorm::configure((IntNovDetect *)((char *)this + 1200), (char *)&v527, (unsigned int *)&v524, (float *)&v521, (unsigned int *)&v530, (const unsigned int *)&v518);
    MEMORY[0x212BAC9C0](v337, 0x1000C8077774924);
    *((_BYTE *)this + 2884) = 1;
  }
  *((_BYTE *)this + 2889) = 0;
  if (v540)
  {
    v338 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v539);
    v533 = &off_24C7F32C0;
    v534 = 19;
    v339 = (void *)operator new[]();
    v535 = v339;
    strcpy((char *)v339, "scorer_network_file");
    if (!NMap<NString,NString>::contains((uint64_t)v338 + 24, (uint64_t)&v533))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v340, v339, *((_QWORD *)v338 + 2));
    v341 = NMap<NString,NString>::operator[]((uint64_t)v338 + 24, (uint64_t)&v533);
    v342 = (const NString *)v341;
    if (*(_DWORD *)(v341 + 8) >= 7u)
    {
      v343 = *(int **)(v341 + 16);
      v344 = *v343;
      v345 = *(int *)((char *)v343 + 3);
      if (v344 == 1684957549 && v345 == 980968804)
      {
        v347 = NMap<NString,NString>::find((uint64_t)this + 3088, v341);
        if (v347)
          v342 = (const NString *)v347;
      }
    }
    v530 = (uint64_t (**)())&off_24C7F32C0;
    LODWORD(v531) = 10;
    v348 = (void *)operator new[]();
    v532 = v348;
    strcpy((char *)v348, "use_output");
    v349 = NConfigSection::iOpt(v338, (const NString *)&v530);
    TSSupervectorScorer::init((IntNovDetect *)((char *)this + 2104), v342, v349);
    MEMORY[0x212BAC9C0](v348, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v339, 0x1000C8077774924);
    *((_BYTE *)this + 2889) = 1;
  }
  *((_BYTE *)this + 2890) = 0;
  if (v537)
  {
    v350 = (NConfigSection *)NConfig::section((NConfig *)v557, (const NString *)&v536);
    v533 = &off_24C7F32C0;
    v534 = 14;
    v351 = (void *)operator new[]();
    v535 = v351;
    strcpy((char *)v351, "norm_modelmean");
    if (NMap<NString,NString>::contains((uint64_t)v350 + 24, (uint64_t)&v533))
      v352 = NConfigSection::bOpt(v350, (const NString *)&v533);
    else
      v352 = 0;
    MEMORY[0x212BAC9C0](v351, 0x1000C8077774924);
    v490[0] = v352;
    v533 = &off_24C7F32C0;
    v534 = 14;
    v353 = (void *)operator new[]();
    v535 = v353;
    strcpy((char *)v353, "transform_file");
    *(_QWORD *)v488 = v353;
    if (!NMap<NString,NString>::contains((uint64_t)v350 + 24, (uint64_t)&v533))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v354, v353, *((_QWORD *)v350 + 2));
    v355 = NMap<NString,NString>::operator[]((uint64_t)v350 + 24, (uint64_t)&v533);
    v356 = (NString *)v355;
    if (*(_DWORD *)(v355 + 8) >= 7u)
    {
      v357 = *(int **)(v355 + 16);
      v358 = *v357;
      v359 = *(int *)((char *)v357 + 3);
      if (v358 == 1684957549 && v359 == 980968804)
      {
        v361 = NMap<NString,NString>::find((uint64_t)this + 3088, v355);
        if (v361)
          v356 = (NString *)v361;
      }
    }
    v530 = (uint64_t (**)())&off_24C7F32C0;
    LODWORD(v531) = 13;
    v362 = (void *)operator new[]();
    v532 = v362;
    strcpy((char *)v362, "impostor_file");
    v486 = (const NString *)v362;
    if (!NMap<NString,NString>::contains((uint64_t)v350 + 24, (uint64_t)&v530))
      Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v363, v362, *((_QWORD *)v350 + 2));
    v364 = NMap<NString,NString>::operator[]((uint64_t)v350 + 24, (uint64_t)&v530);
    v365 = (const NString *)v364;
    if (*(_DWORD *)(v364 + 8) >= 7u)
    {
      v366 = *(int **)(v364 + 16);
      v367 = *v366;
      v368 = *(int *)((char *)v366 + 3);
      if (v367 == 1684957549 && v368 == 980968804)
      {
        v370 = NMap<NString,NString>::find((uint64_t)this + 3088, v364);
        if (v370)
          v365 = (const NString *)v370;
      }
    }
    v527 = (char *)&off_24C7F32C0;
    LODWORD(v528) = 19;
    v371 = (char *)operator new[]();
    v529 = v371;
    strcpy(v371, "max_speaker_vectors");
    v485 = (const NString *)v371;
    LODWORD(v506) = NConfigSection::iOpt(v350, (const NString *)&v527);
    v524 = (char *)&off_24C7F32C0;
    v525 = 12;
    v372 = (void *)operator new[]();
    v484 = v356;
    v526 = v372;
    strcpy((char *)v372, "prenormalize");
    v499[0] = NConfigSection::bOpt(v350, (const NString *)&v524);
    v521 = &off_24C7F32C0;
    v522 = 20;
    v373 = (void *)operator new[]();
    v523 = v373;
    strcpy((char *)v373, "use_percentile_score");
    v489 = NConfigSection::bOpt(v350, (const NString *)&v521);
    v518 = &off_24C7F32C0;
    v519 = 10;
    v374 = (void *)operator new[]();
    v520 = v374;
    strcpy((char *)v374, "percentile");
    LODWORD(v503) = NConfigSection::fOpt(v350, (const NString *)&v518);
    v515 = &off_24C7F32C0;
    v516 = 8;
    v375 = (void *)operator new[]();
    v517 = v375;
    strcpy((char *)v375, "use_best");
    v500[0] = NConfigSection::iOpt(v350, (const NString *)&v515);
    v512 = &off_24C7F32C0;
    v513 = 11;
    v376 = (void *)operator new[]();
    v514 = v376;
    strcpy((char *)v376, "input_dimen");
    LODWORD(v496) = NConfigSection::iOpt(v350, (const NString *)&v512);
    v509 = &off_24C7F32C0;
    v510 = 14;
    v377 = (void *)operator new[]();
    v511 = v377;
    strcpy((char *)v377, "use_from_index");
    v493[0] = NConfigSection::iOpt(v350, (const NString *)&v509);
    v378 = TSSATScorer::init((IntNovDetect *)((char *)this + 2184), v484, v365, (const unsigned int *)&v506, v499, &v489, v490, (float *)&v503, v500, (unsigned int *)&v496, v493);
    MEMORY[0x212BAC9C0](v377, 0x1000C8077774924, v378);
    MEMORY[0x212BAC9C0](v376, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v375, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v374, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v373, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v372, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v485, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v486, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](*(_QWORD *)v488, 0x1000C8077774924);
    if (!*((_BYTE *)this + 2479))
      Error::chuck((Error *)"TSSATScorer::setModelFile() - init() not called", v151);
    v379 = *((_DWORD *)this + 610);
    v380 = *((_DWORD *)this + 680);
    if (v380 == v379)
      goto LABEL_403;
    v381 = *((_QWORD *)this + 339);
    *((_DWORD *)this + 680) = v379;
    v382 = operator new[]();
    *((_QWORD *)this + 339) = v382;
    if (v380 >= v379)
      v383 = v379;
    else
      v383 = v380;
    if ((_DWORD)v383)
    {
      v384 = 0;
      if (v383 < 8)
        goto LABEL_398;
      if ((unint64_t)(v382 - v381) <= 0x1F)
        goto LABEL_398;
      v384 = v383 & 0xFFFFFFF8;
      v385 = (_OWORD *)(v382 + 16);
      v386 = (__int128 *)(v381 + 16);
      v387 = v384;
      do
      {
        v388 = *v386;
        *(v385 - 1) = *(v386 - 1);
        *v385 = v388;
        v385 += 2;
        v386 += 2;
        v387 -= 8;
      }
      while (v387);
      if (v384 != v383)
      {
LABEL_398:
        v389 = v383 - v384;
        v390 = 4 * v384;
        v391 = (_DWORD *)(v382 + 4 * v384);
        v392 = (int *)(v381 + v390);
        do
        {
          v393 = *v392++;
          *v391++ = v393;
          --v389;
        }
        while (v389);
      }
    }
    else if (!v381)
    {
LABEL_403:
      *((_QWORD *)this + 336) = *((_QWORD *)this + 339);
      *((_DWORD *)this + 674) = *((_DWORD *)this + 680);
      *((_BYTE *)this + 2890) = 1;
      goto LABEL_404;
    }
    MEMORY[0x212BAC9C0](v381, 0x1000C8052888210);
    goto LABEL_403;
  }
LABEL_404:
  if (v543)
  {
    v394 = (_QWORD *)NConfig::section((NConfig *)v557, (const NString *)&v542);
    if ((_QWORD *)((char *)this + 2896) != v394)
    {
      (*(void (**)(char *, _QWORD, _QWORD *))(*((_QWORD *)this + 362) + 64))((char *)this + 2896, v394[2], v394 + 1);
      *((_QWORD *)v487 + 43) = *(_QWORD *)((char *)v394 + 52);
      NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=((uint64_t)this + 2928, (uint64_t)(v394 + 4));
    }
  }
  *((_DWORD *)this + 696) = 0;
  *((_OWORD *)this + 173) = 0u;
  *((_DWORD *)this + 700) = -915135488;
  v395 = *((_DWORD *)this + 756);
  v396 = *((_DWORD *)this + 770);
  if (v395 != v396)
  {
    v397 = *((_QWORD *)this + 377);
    *((_DWORD *)this + 756) = v396;
    v398 = operator new[]();
    *((_QWORD *)this + 377) = v398;
    v399 = *((_DWORD *)this + 770);
    if (v395 >= v399)
      v400 = v399;
    else
      v400 = v395;
    if ((_DWORD)v400)
    {
      v401 = 0;
      if (v400 < 8)
        goto LABEL_417;
      if ((unint64_t)(v398 - v397) <= 0x1F)
        goto LABEL_417;
      v401 = v400 & 0xFFFFFFF8;
      v402 = (_OWORD *)(v398 + 16);
      v403 = (__int128 *)(v397 + 16);
      v404 = v401;
      do
      {
        v405 = *v403;
        *(v402 - 1) = *(v403 - 1);
        *v402 = v405;
        v402 += 2;
        v403 += 2;
        v404 -= 8;
      }
      while (v404);
      if (v401 != v400)
      {
LABEL_417:
        v406 = v400 - v401;
        v407 = 4 * v401;
        v408 = (_DWORD *)(v398 + 4 * v401);
        v409 = (int *)(v397 + v407);
        do
        {
          v410 = *v409++;
          *v408++ = v410;
          --v406;
        }
        while (v406);
      }
      goto LABEL_421;
    }
    if (v397)
    {
LABEL_421:
      MEMORY[0x212BAC9C0](v397, 0x1000C8052888210);
      v395 = *((_DWORD *)this + 770);
      goto LABEL_422;
    }
    v395 = *((_DWORD *)this + 770);
  }
LABEL_422:
  v411 = *((_DWORD *)this + 762);
  if (v411 == v395)
    goto LABEL_440;
  v412 = *((_QWORD *)this + 380);
  *((_DWORD *)this + 762) = v395;
  v413 = operator new[]();
  *((_QWORD *)this + 380) = v413;
  v395 = *((_DWORD *)this + 770);
  if (v411 >= v395)
    v414 = v395;
  else
    v414 = v411;
  if ((_DWORD)v414)
  {
    if (v414 >= 8 && (unint64_t)(v413 - v412) > 0x1F)
    {
      v416 = v414 & 0xFFFFFFF8;
      v417 = (_OWORD *)(v413 + 16);
      v418 = (__int128 *)(v412 + 16);
      v419 = v416;
      do
      {
        v420 = *v418;
        *(v417 - 1) = *(v418 - 1);
        *v417 = v420;
        v417 += 2;
        v418 += 2;
        v419 -= 8;
      }
      while (v419);
      if (v416 == v414)
        goto LABEL_439;
    }
    else
    {
      v416 = 0;
    }
    v421 = v414 - v416;
    v422 = 4 * v416;
    v423 = (_DWORD *)(v413 + 4 * v416);
    v424 = (int *)(v412 + v422);
    do
    {
      v425 = *v424++;
      *v423++ = v425;
      --v421;
    }
    while (v421);
LABEL_439:
    MEMORY[0x212BAC9C0](v412, 0x1000C8052888210);
    v395 = *((_DWORD *)this + 770);
    goto LABEL_440;
  }
  if (v412)
    goto LABEL_439;
LABEL_440:
  v426 = *((_DWORD *)this + 768);
  if (v426 == v395)
    goto LABEL_458;
  v427 = *((_QWORD *)this + 383);
  *((_DWORD *)this + 768) = v395;
  v428 = operator new[]();
  *((_QWORD *)this + 383) = v428;
  v395 = *((_DWORD *)this + 770);
  if (v426 >= v395)
    v429 = v395;
  else
    v429 = v426;
  if ((_DWORD)v429)
  {
    if (v429 >= 8 && (unint64_t)(v428 - v427) > 0x1F)
    {
      v431 = v429 & 0xFFFFFFF8;
      v432 = (_OWORD *)(v428 + 16);
      v433 = (__int128 *)(v427 + 16);
      v434 = v431;
      do
      {
        v435 = *v433;
        *(v432 - 1) = *(v433 - 1);
        *v432 = v435;
        v432 += 2;
        v433 += 2;
        v434 -= 8;
      }
      while (v434);
      if (v431 == v429)
        goto LABEL_457;
    }
    else
    {
      v431 = 0;
    }
    v436 = v429 - v431;
    v437 = 4 * v431;
    v438 = (_DWORD *)(v428 + 4 * v431);
    v439 = (int *)(v427 + v437);
    do
    {
      v440 = *v439++;
      *v438++ = v440;
      --v436;
    }
    while (v436);
LABEL_457:
    MEMORY[0x212BAC9C0](v427, 0x1000C8052888210);
    v395 = *((_DWORD *)this + 770);
    goto LABEL_458;
  }
  if (v427)
    goto LABEL_457;
LABEL_458:
  if (v395)
  {
    v441 = 0;
    v442 = *((_QWORD *)this + 377);
    v443 = *((_QWORD *)this + 380);
    v444 = *((_QWORD *)this + 383);
    do
    {
      v445 = 4 * v441;
      *(_DWORD *)(v442 + v445) = 0;
      *(_DWORD *)(v443 + v445) = 0;
      *(_DWORD *)(v444 + v445) = -915135488;
      ++v441;
    }
    while (v441 < *((unsigned int *)this + 770));
  }
  *((_DWORD *)this + 697) = 0;
  *((_WORD *)this + 1446) = 0;
  *((_QWORD *)this + 314) = 0;
  *((_QWORD *)this + 370) = 0;
  v446 = *((_DWORD *)this + 742);
  *((_DWORD *)this + 743) = v446;
  v447 = *((_DWORD *)this + 745);
  *((_DWORD *)this + 744) = v447 + v446;
  if (v447)
    IntNovDetect::zeroWavePrime(this, v151);
  *(_QWORD *)((char *)this + 4) = 0x100000001;
  if (*((_BYTE *)this + 40))
  {
    LODWORD(v533) = 6;
    (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v533);
    *((_BYTE *)this + 40) = 0;
  }
  v536 = &off_24C7F32C0;
  if (v538)
    MEMORY[0x212BAC9C0](v538, 0x1000C8077774924);
  v539 = &off_24C7F32C0;
  if (v541)
    MEMORY[0x212BAC9C0](v541, 0x1000C8077774924);
  if (v544)
    MEMORY[0x212BAC9C0](v544, 0x1000C8077774924);
  if (v547)
    MEMORY[0x212BAC9C0](v547, 0x1000C8077774924);
  if (v550)
    MEMORY[0x212BAC9C0](v550, 0x1000C8077774924);
  if (v553)
    MEMORY[0x212BAC9C0](v553, 0x1000C8077774924);
  if (v556)
    MEMORY[0x212BAC9C0](v556, 0x1000C8077774924);
  v557[0] = &off_24C7F2A90;
  v557[1] = &off_24C7F2C68;
  v448 = v558;
  if (v558)
  {
    v449 = *(_QWORD *)(v558 - 8);
    if (v449)
    {
      v450 = v558 + 32 * v449;
      v451 = v450;
      do
      {
        *(_QWORD *)(v451 - 32) = off_24C7F1420;
        v451 -= 32;
        for (i = *(_QWORD *)(v451 + 8); i; i = *(_QWORD *)(v450 - 24))
        {
          *(_QWORD *)(v450 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v450 - 32) + 72))(v451);
        }
        *(_QWORD *)(v450 - 16) = 0;
        *(_DWORD *)(v450 - 8) = 0;
        v450 = v451;
      }
      while (v451 != v448);
    }
    MEMORY[0x212BAC9C0](v448 - 16, 0x10A1C80F4A7E088);
  }
  return 0;
}

void sub_20D99F3F0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  v4[24] = &off_24C7F32C0;
  v7 = v4[26];
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  if (v4[29])
    MEMORY[0x212BAC9C0](v4[29], 0x1000C8077774924);
  v4[30] = &off_24C7F32C0;
  v8 = v4[32];
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  v4[33] = &off_24C7F32C0;
  v9 = v4[35];
  if (v9)
  {
    MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
    v10 = v4[38];
    if (!v10)
    {
LABEL_9:
      v11 = v4[41];
      if (!v11)
        goto LABEL_10;
      goto LABEL_17;
    }
  }
  else
  {
    v10 = v4[38];
    if (!v10)
      goto LABEL_9;
  }
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  v11 = v4[41];
  if (!v11)
  {
LABEL_10:
    v12 = v4[44];
    if (!v12)
      goto LABEL_11;
    goto LABEL_18;
  }
LABEL_17:
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  v12 = v4[44];
  if (!v12)
  {
LABEL_11:
    v13 = v4[47];
    if (!v13)
      goto LABEL_12;
    goto LABEL_19;
  }
LABEL_18:
  MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  v13 = v4[47];
  if (!v13)
  {
LABEL_12:
    v14 = v4[50];
    if (!v14)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_19:
  MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  v14 = v4[50];
  if (!v14)
  {
LABEL_14:
    NConfig::~NConfig((NConfig *)(v5 - 184));
    _Unwind_Resume(a1);
  }
LABEL_13:
  MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  goto LABEL_14;
}

void IntNovDetect::addLengthKeywords(IntNovDetect *this, const NString *a2)
{
  char *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  int v7;
  char *v8;
  uint64_t (**v9)(NString *__hidden, const unsigned int *);
  int v10;
  char *v11;
  uint64_t (**v12)(NString *__hidden, const unsigned int *);
  int v13;
  _WORD *v14;
  _QWORD v15[2];
  uint64_t v16;
  uint64_t (**v17)();
  uint64_t v18;
  int v19;

  v17 = &off_24C7F2E28;
  v18 = 0;
  v19 = 0;
  v12 = &off_24C7F32C0;
  v13 = 1;
  v14 = (_WORD *)operator new[]();
  *v14 = 44;
  v9 = &off_24C7F32C0;
  v10 = 1;
  v11 = (char *)operator new[]();
  strcpy(v11, " ");
  (*(void (**)(_QWORD *__return_ptr, const NString *, uint64_t (***)(NString *__hidden, const unsigned int *), uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a2 + 112))(v15, a2, &v12, &v9);
  v6 = &off_24C7F32C0;
  v7 = 4;
  v3 = (char *)operator new[]();
  v8 = v3;
  strcpy(v3, "\r\n\t ");
  v5 = -1;
  NString::split((uint64_t)v15, &v17, (uint64_t)&v6, &v5);
  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  v15[0] = &off_24C7F32C0;
  if (v16)
    MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
  v9 = &off_24C7F32C0;
  if (v11)
    MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  v12 = &off_24C7F32C0;
  if (v14)
    MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  if (v19)
  {
    v4 = v18;
    v12 = &off_24C7F32C0;
    v13 = 7;
    v14 = (_WORD *)operator new[]();
    *(_QWORD *)v14 = 0x6874676E656C5FLL;
    NString::operator+(v4, (uint64_t)&v12, (uint64_t)v15);
  }
  v12 = &off_24C7F32C0;
  v13 = 1;
  v14 = (_WORD *)operator new[]();
  *v14 = 32;
  NString::operator+((uint64_t)a2, (uint64_t)&v12, (uint64_t)v15);
}

void sub_20D9A08A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  uint64_t v14;
  uint64_t v15;
  va_list va;

  va_start(va, a14);
  if (a8)
    MEMORY[0x212BAC9C0](a8, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  NArray<NString>::~NArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void IntNovDetect::zeroWavePrime(IntNovDetect *this, const char *a2)
{
  int *v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  const char *v13;
  const char *v14;
  double v15;
  _OWORD *v16;
  __int128 *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  __int16 *v23;
  __int16 v24;
  int v25;

  v3 = (int *)((char *)this + 3000);
  v4 = *((_DWORD *)this + 750);
  v5 = *((_DWORD *)this + 690);
  if (v4 != v5)
  {
    v6 = *((_QWORD *)this + 374);
    *((_DWORD *)this + 750) = v5;
    v7 = operator new[]();
    *((_QWORD *)this + 374) = v7;
    LODWORD(v8) = *((_DWORD *)this + 690);
    if (v4 >= v8)
      v8 = v8;
    else
      v8 = v4;
    if ((_DWORD)v8)
    {
      if (v8 < 0x10 || (unint64_t)(v7 - v6) <= 0x1F)
      {
        v10 = 0;
LABEL_23:
        v20 = v8 - v10;
        v21 = 2 * v10;
        v22 = (_WORD *)(v7 + 2 * v10);
        v23 = (__int16 *)(v6 + v21);
        do
        {
          v24 = *v23++;
          *v22++ = v24;
          --v20;
        }
        while (v20);
        goto LABEL_25;
      }
      v10 = v8 & 0xFFFFFFF0;
      v16 = (_OWORD *)(v7 + 16);
      v17 = (__int128 *)(v6 + 16);
      v18 = v10;
      do
      {
        v19 = *v17;
        *(v16 - 1) = *(v17 - 1);
        *v16 = v19;
        v16 += 2;
        v17 += 2;
        v18 -= 16;
      }
      while (v18);
      if (v10 != v8)
        goto LABEL_23;
    }
    else if (!v6)
    {
      v11 = *v3;
      if (!(_DWORD)v11)
        goto LABEL_14;
      goto LABEL_13;
    }
LABEL_25:
    MEMORY[0x212BAC9C0](v6, 0x1000C80BDFB0063);
    v11 = *v3;
    if (!(_DWORD)v11)
      goto LABEL_14;
LABEL_13:
    bzero(*((void **)this + 374), 2 * v11);
  }
LABEL_14:
  if (*((_DWORD *)this + 745))
  {
    v12 = 0;
    do
    {
      if (!*((_BYTE *)this + 1197))
        Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2);
      if (*((_BYTE *)this + 1196))
        Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buf"
                   "fer (m_queue) has been emptied (call reset())",
          a2);
      v13 = (const char *)*((_QWORD *)this + 374);
      v25 = 0;
      NWavChunk2HTKFrames::run((uint64_t)this + 48, v13, v3, &v25, (uint64_t)this + 1048);
      IntNovDetect::advanceDetection(this, v14, v15);
      ++v12;
    }
    while (v12 < *((_DWORD *)this + 745));
  }
}

void IntNovDetect::advanceDetection(IntNovDetect *this, const char *a2, double a3)
{
  TSAcAnal *v4;
  int32x2_t *v5;
  NFrame *v6;
  TSHMMDetector *v7;
  char *v8;
  TSHMMDetector *v9;
  const NFrame *v10;
  int v11;
  _BOOL4 v12;
  char *FrameByRef;
  const char *v14;
  int v16;
  double v17;
  TSHMMDetector *v18;
  const NFrame *v19;
  int v20;
  int v21;
  double v22;

  v4 = (IntNovDetect *)((char *)this + 48);
  v5 = (int32x2_t *)((char *)this + 1200);
  v6 = (IntNovDetect *)((char *)this + 2520);
  v7 = (IntNovDetect *)((char *)this + 1288);
  v8 = (char *)this + 2488;
  v9 = (IntNovDetect *)((char *)this + 1696);
LABEL_2:
  while (1)
  {
    v10 = (const NFrame *)*((_QWORD *)this + 370);
    if (!v10)
      break;
    v11 = *((_DWORD *)this + 743);
    if (!v11)
    {
      *((_QWORD *)this + 370) = 0;
      break;
    }
    *((_DWORD *)this + 743) = v11 - 1;
LABEL_18:
    if (*((_BYTE *)this + 2884))
    {
      *(int32x2_t *)&a3 = NLocalCepNorm::pushFrame(v5, v10);
      v16 = *((_DWORD *)this + 304);
      if (*((_BYTE *)this + 1284) && v16 || v16 == *((_DWORD *)this + 307) + 1)
      {
        NLocalCepNorm::setOutputFrame((NLocalCepNorm *)v5, v6);
        TSHMMDetector::feedFrame(v7, v6, v17);
        if (!*((_BYTE *)this + 2891))
          goto LABEL_29;
        NRingDropBuffer::pushFrame((uint64_t)v8, v6);
        v10 = v6;
        if (!*((_BYTE *)this + 2892))
          goto LABEL_29;
LABEL_27:
        v18 = v9;
        v19 = v10;
        goto LABEL_28;
      }
    }
    else
    {
      TSHMMDetector::feedFrame(v7, v10, a3);
      if (*((_BYTE *)this + 2891))
      {
        NRingDropBuffer::pushFrame((uint64_t)v8, v10);
        if (*((_BYTE *)this + 2892))
          goto LABEL_27;
      }
      while (1)
      {
LABEL_29:
        v20 = *((_DWORD *)this + 744);
        if (v20)
        {
          *((_DWORD *)this + 744) = v20 - 1;
          if (!*((_BYTE *)this + 2884))
            goto LABEL_2;
        }
        else
        {
          ++*((_DWORD *)this + 693);
          IntNovDetect::innerAdvanceDetection(this, a2, a3);
          if (!*((_BYTE *)this + 2884))
            goto LABEL_2;
        }
        v21 = *((_DWORD *)this + 304);
        if ((!*((_BYTE *)this + 1284) || !v21) && v21 != *((_DWORD *)this + 307) + 1)
          break;
        NLocalCepNorm::setOutputFrame((NLocalCepNorm *)v5, v6);
        TSHMMDetector::feedFrame(v7, v6, v22);
        if (*((_BYTE *)this + 2891))
        {
          NRingDropBuffer::pushFrame((uint64_t)v8, v6);
          if (*((_BYTE *)this + 2892))
          {
            v18 = v9;
            v19 = v6;
LABEL_28:
            TSHMMDetector::feedFrame(v18, v19, a3);
          }
        }
      }
    }
  }
  if (*((_BYTE *)this + 1116))
    v12 = *((_DWORD *)this + 276) != *((_DWORD *)this + 277);
  else
    v12 = (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) > 1;
  if (v12)
  {
    FrameByRef = TSAcAnal::getFrameByRef(v4, a2);
    v10 = (const NFrame *)FrameByRef;
    if (*((_DWORD *)this + 2) != 2
      && *((_BYTE *)this + 1196)
      && (*((_BYTE *)this + 1116)
        ? *((_DWORD *)this + 276) == *((_DWORD *)this + 277)
        : (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) < 2))
    {
      Error::chuck((Error *)"NovDetect: advanceDetection() - acanal has shut down!", v14);
    }
    if (*((_DWORD *)this + 743))
      *((_QWORD *)this + 370) = FrameByRef;
    goto LABEL_18;
  }
}

void IntNovDetect::innerAdvanceDetection(IntNovDetect *this, const char *a2, double a3)
{
  TSHMMDetector *v4;
  float *v5;
  float *v6;
  _BYTE *v7;
  char *v8;
  unsigned __int8 *v9;
  unsigned int *v10;
  int v11;
  int v12;
  float v13;
  float v14;
  float v15;
  int v16;
  int v17;
  float v18;
  int v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v22;
  int v23;
  int v24;
  float v25;
  float v26;
  float BestLengthNormalizedPhraseScore;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;

  v4 = (IntNovDetect *)((char *)this + 1288);
  v5 = (float *)((char *)this + 2872);
  v6 = (float *)((char *)this + 2856);
  v7 = (char *)this + 2882;
  v8 = (char *)this + 2808;
  v9 = (unsigned __int8 *)this + 2880;
  v10 = (unsigned int *)((char *)this + 2772);
  while ((TSHMMDetector::updateResult(v4, a2, a3) & 1) != 0)
  {
    v11 = *((_DWORD *)this + 414);
    if (*((_DWORD *)this + 369))
    {
      v12 = v11 - *((_DWORD *)this + 409);
      if (v12)
      {
        v13 = *((float *)this + 408);
        v14 = *((float *)this + 718);
        if (v14 == 1.0)
        {
          *(float *)&a3 = (float)v12;
          goto LABEL_8;
        }
        if (v14 != 0.0)
        {
          *(float *)&a3 = powf((float)v12, v14);
LABEL_8:
          v13 = v13 / *(float *)&a3;
        }
        *(float *)&a3 = v13 + *((float *)this + 714);
        if (*(float *)&a3 > *((float *)this + 716))
          *((_BYTE *)this + 2893) = 1;
      }
    }
    v33 = v11 - *((_DWORD *)this + 411);
    if (v33)
    {
      v32 = 0;
      *(float *)&a3 = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)v4, v5, v7, (uint64_t)v8, &v33, &v32, v9);
      v15 = *(float *)&a3;
      if (!*((_BYTE *)this + 2891))
        goto LABEL_20;
      LODWORD(a3) = *((_DWORD *)this + 715);
      if (v15 > *(float *)&a3)
      {
        if (!*((_BYTE *)this + 2892))
        {
          IntNovDetect::rescoreInit(this);
          *((_BYTE *)this + 2892) = 1;
        }
        *((_DWORD *)this + 697) = *((_DWORD *)this + 698);
        goto LABEL_20;
      }
      v16 = *((_DWORD *)this + 697);
      if (v16 && (v17 = v16 - 1, (*((_DWORD *)this + 697) = v17) == 0))
      {
        IntNovDetect::rescoreComplete(this, a2, a3);
        *((_BYTE *)this + 2892) = 0;
LABEL_21:
        v18 = v15 + *((float *)this + 714);
        if (v18 > *((float *)this + 700))
        {
          v19 = *((_DWORD *)this + 413) - *((_DWORD *)this + 414) + *((_DWORD *)this + 372);
          v20 = v19 & ~(v19 >> 31);
          v21 = *v10 >= v20;
          v22 = *v10 - v20;
          if (v22 != 0 && v21)
          {
            *((_DWORD *)this + 694) = v22;
            *((_DWORD *)this + 695) = v33;
            *((_DWORD *)this + 696) = v32;
            *((float *)this + 700) = v18;
          }
        }
        IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)v4, v5, v6, (uint64_t)v8, v10, v9);
      }
      else
      {
LABEL_20:
        if (!*((_BYTE *)this + 2892))
          goto LABEL_21;
      }
    }
  }
  if (*((_BYTE *)this + 2892))
  {
    while (1)
    {
      if (!TSHMMDetector::updateResult((IntNovDetect *)((char *)this + 1696), a2, a3))
        return;
      v23 = *((_DWORD *)this + 516);
      if (*((_DWORD *)this + 471))
      {
        v24 = v23 - *((_DWORD *)this + 511);
        if (v24)
          break;
      }
LABEL_40:
      v33 = v23 - *((_DWORD *)this + 513);
      if (v33)
      {
        v32 = 0;
        BestLengthNormalizedPhraseScore = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (_BYTE *)this + 2883, (uint64_t)this + 2832, &v33, &v32, (unsigned __int8 *)this + 2881);
        if (BestLengthNormalizedPhraseScore > *((float *)this + 700))
        {
          v28 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
          v29 = v28 & ~(v28 >> 31);
          v21 = *v10 >= v29;
          v30 = *v10 - v29;
          if (v30 != 0 && v21)
          {
            *((_DWORD *)this + 694) = v30;
            *((_DWORD *)this + 695) = v33;
            *((_DWORD *)this + 696) = v32;
            *((float *)this + 700) = BestLengthNormalizedPhraseScore;
          }
        }
        v31 = 0;
        IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (float *)&v31, (uint64_t)this + 2832, v10, (unsigned __int8 *)this + 2881);
      }
      if (!*((_BYTE *)this + 2892))
        return;
    }
    v25 = *((float *)this + 510);
    v26 = *((float *)this + 719);
    if (v26 == 1.0)
    {
      *(float *)&a3 = (float)v24;
    }
    else
    {
      if (v26 == 0.0)
      {
LABEL_38:
        LODWORD(a3) = *((_DWORD *)this + 717);
        if (v25 > *(float *)&a3)
          *((_BYTE *)this + 2893) = 1;
        goto LABEL_40;
      }
      *(float *)&a3 = powf((float)v24, v26);
    }
    v25 = v25 / *(float *)&a3;
    goto LABEL_38;
  }
}

float IntNovDetect::getBestLengthNormalizedPhraseScore(uint64_t a1, uint64_t a2, float *a3, _BYTE *a4, uint64_t a5, _DWORD *a6, _DWORD *a7, unsigned __int8 *a8)
{
  unsigned int v12;
  float v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  float v21;
  float v22;
  unint64_t v23;
  unsigned int v24;
  unsigned int *v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  int v44;

  if (!*a4)
  {
    *a7 = *(_DWORD *)(a2 + 360);
    v20 = *(_DWORD *)(a2 + 368) - *(_DWORD *)(a2 + 356);
    *a6 = v20;
    v13 = *(float *)(a2 + 352);
    v21 = *a3;
    if (*a3 == 1.0)
    {
      v22 = (float)v20;
    }
    else
    {
      if (v21 == 0.0)
      {
LABEL_31:
        v40 = *a7;
        if (v40 < *(_DWORD *)(a5 + 16))
          return v13 + *(float *)(*(_QWORD *)(a5 + 8) + 4 * v40);
        return v13;
      }
      v22 = powf((float)v20, v21);
    }
    v13 = v13 / v22;
    goto LABEL_31;
  }
  v12 = *(_DWORD *)(a2 + 176);
  v44 = *a8;
  if (v12 >= v44 + 1)
  {
    v23 = 0;
    v24 = v12 / (v44 + 1);
    v25 = *(unsigned int **)(a2 + 168);
    v26 = *a3;
    v27 = *(_QWORD *)(a5 + 8);
    if (v24 <= 1)
      v28 = 1;
    else
      v28 = v24;
    v29 = (_QWORD *)(*(_QWORD *)(a2 + 304) + 32);
    v13 = -1000000.0;
    while (1)
    {
      v30 = *(unsigned int *)(a2 + 176);
      if (v23 >= v30)
        Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, v23, v30);
      v31 = *v25;
      v32 = *(_DWORD *)(*v29 + 4 * v31);
      v33 = *(_DWORD *)(a2 + 368);
      v34 = v33 - v32;
      if (v33 == v32)
        goto LABEL_15;
      v35 = *(float *)(*(v29 - 3) + 4 * v31) * (float)*(unsigned int *)(a2 + 196);
      if (v26 == 1.0)
      {
        v36 = (float)v34;
      }
      else
      {
        if (v26 == 0.0)
          goto LABEL_22;
        v36 = powf((float)v34, v26);
      }
      v35 = v35 / v36;
LABEL_22:
      if (v23 < *(unsigned int *)(a5 + 16))
        v35 = v35 + *(float *)(v27 + 4 * v23);
      if (v35 > v13)
      {
        *a6 = v34;
        *a7 = v23;
        v13 = v35;
      }
LABEL_15:
      ++v23;
      v25 += 22;
      v29 += 6;
      if (v28 == v23)
        goto LABEL_4;
    }
  }
  v13 = -1000000.0;
LABEL_4:
  if (v44)
  {
    v14 = *(unsigned int *)(a2 + 176);
    v15 = *a7 + (v14 >> 1);
    if (v15 >= v14)
      Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, *a7 + (v14 >> 1), v14);
    v16 = *(unsigned int *)(*(_QWORD *)(a2 + 168) + 88 * v15);
    v17 = *(_QWORD *)(a2 + 304);
    v18 = *(_DWORD *)(a2 + 368) - *(_DWORD *)(*(_QWORD *)(v17 + 48 * v15 + 32) + 4 * v16);
    if (!v18)
    {
      v19 = 0;
LABEL_35:
      *a6 = v19;
      return v13;
    }
    v37 = *(float *)(*(_QWORD *)(v17 + 48 * v15 + 8) + 4 * v16) * (float)*(unsigned int *)(a2 + 196);
    v38 = *a3;
    if (*a3 == 1.0)
    {
      v39 = (float)v18;
    }
    else
    {
      if (v38 == 0.0)
        goto LABEL_34;
      v39 = powf((float)v18, v38);
    }
    v37 = v37 / v39;
LABEL_34:
    v19 = ((float)(fmaxf(v37, 0.0) * *(float *)(a1 + 1192)) + 0.5);
    goto LABEL_35;
  }
  return v13;
}

void IntNovDetect::rescoreInit(IntNovDetect *this)
{
  int v2;
  int v3;
  int v4;
  int v5;
  TSHMMDetector *v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  TSHMMDetector *v10;
  unsigned int v11;
  double v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  const char *v21;
  float BestLengthNormalizedPhraseScore;
  int v23;
  unsigned int v24;
  int v26;
  int v27;
  int v28;
  int v29;

  v2 = *((_DWORD *)this + 414);
  v3 = v2 - *((_DWORD *)this + 411);
  v4 = *((_DWORD *)this + 413) - v2 + *((_DWORD *)this + 372);
  v5 = (v4 & ~(v4 >> 31)) + v3;
  v6 = (IntNovDetect *)((char *)this + 1696);
  v7 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
  v8 = v5 + (v7 & ~(v7 >> 31)) + *((_DWORD *)this + 699) - (v7 > 0);
  v9 = *((_DWORD *)this + 629);
  v10 = (IntNovDetect *)((char *)this + 1696);
  v11 = v9 - v8;
  if (v9 <= v8)
  {
    TSHMMDetector::reset(v10);
LABEL_5:
    v11 = 0;
    v14 = 0;
    v13 = *((_DWORD *)this + 629);
    if (v13 != *((_DWORD *)this + 626))
      goto LABEL_7;
    goto LABEL_6;
  }
  TSHMMDetector::reset(v10);
  if (!v11)
    goto LABEL_5;
  v13 = *((_DWORD *)this + 629);
LABEL_6:
  *((_BYTE *)this + 2098) = 1;
  v14 = v11;
LABEL_7:
  v15 = *((_DWORD *)this + 693);
  v16 = v15 + v14 - v13;
  if (v15 >= v13 - v14)
    v17 = 0;
  else
    v17 = v13 - (v15 + v14);
  while (v14 < v13)
  {
    v18 = *((_DWORD *)this + 626);
    v19 = *((_DWORD *)this + 628) + v14 + v18 - v13;
    if (v19 >= v18)
      v20 = *((_DWORD *)this + 626);
    else
      v20 = 0;
    TSHMMDetector::feedFrame(v6, (const NFrame *)(*((_QWORD *)this + 312) + 24 * (v19 - v20)), v12);
    v29 = ++v16;
    if (v17)
    {
      --v17;
    }
    else
    {
      while (TSHMMDetector::updateResult(v6, v21, v12))
      {
        v28 = *((_DWORD *)this + 516) - *((_DWORD *)this + 513);
        if (v28)
        {
          v27 = 0;
          BestLengthNormalizedPhraseScore = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)v6, (float *)this + 719, (_BYTE *)this + 2883, (uint64_t)this + 2832, &v28, &v27, (unsigned __int8 *)this + 2881);
          v23 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
          v24 = v23 & ~(v23 >> 31);
          if (BestLengthNormalizedPhraseScore > *((float *)this + 700) && v16 > v24)
          {
            *((_DWORD *)this + 694) = v16 - v24;
            *((_DWORD *)this + 695) = v28;
            *((_DWORD *)this + 696) = v27;
            *((float *)this + 700) = BestLengthNormalizedPhraseScore;
          }
          v26 = 0;
          IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)v6, (float *)this + 719, (float *)&v26, (uint64_t)this + 2832, &v29, (unsigned __int8 *)this + 2881);
        }
      }
      v17 = 0;
    }
    ++v14;
    v13 = *((_DWORD *)this + 629);
  }
}

uint64_t IntNovDetect::rescoreComplete(IntNovDetect *this, const char *a2, double a3)
{
  unsigned int v4;
  uint64_t result;
  float BestLengthNormalizedPhraseScore;
  int v7;
  unsigned int v8;
  int v10;
  int v11;
  int v12;
  unsigned int v13;

  if (*((_BYTE *)this + 2887))
    TSHMMDetector::padToEndOfBatch((IntNovDetect *)((char *)this + 1696));
  v4 = *((_DWORD *)this + 693);
  v13 = v4;
  while (1)
  {
    result = TSHMMDetector::updateResult((IntNovDetect *)((char *)this + 1696), a2, a3);
    if ((result & 1) == 0)
    {
      if (!*((_BYTE *)this + 2888))
        break;
      result = TSHMMDetector::endFrame((IntNovDetect *)((char *)this + 1696), a2, a3);
      if (!(_DWORD)result)
        break;
    }
    v12 = *((_DWORD *)this + 516) - *((_DWORD *)this + 513);
    if (v12)
    {
      v11 = 0;
      BestLengthNormalizedPhraseScore = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (_BYTE *)this + 2883, (uint64_t)this + 2832, &v12, &v11, (unsigned __int8 *)this + 2881);
      v7 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
      v8 = v7 & ~(v7 >> 31);
      if (BestLengthNormalizedPhraseScore > *((float *)this + 700) && v4 > v8)
      {
        *((_DWORD *)this + 694) = v4 - v8;
        *((_DWORD *)this + 695) = v12;
        *((_DWORD *)this + 696) = v11;
        *((float *)this + 700) = BestLengthNormalizedPhraseScore;
      }
      v10 = 0;
      IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (float *)&v10, (uint64_t)this + 2832, &v13, (unsigned __int8 *)this + 2881);
    }
  }
  *((_BYTE *)this + 2892) = 0;
  return result;
}

void IntNovDetect::updateMultiphraseResults(uint64_t a1, uint64_t a2, float *a3, float *a4, uint64_t a5, _DWORD *a6, unsigned __int8 *a7)
{
  unsigned int v7;
  unsigned int v9;
  uint64_t v10;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int *v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  float v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  float *v42;
  unsigned int v43;
  _DWORD *v44;

  v7 = *(_DWORD *)(a1 + 3080);
  if (!v7)
    return;
  v9 = *(_DWORD *)(a2 + 176) / (*a7 + 1);
  v10 = v7 >= v9 ? v9 : v7;
  if (!(_DWORD)v10)
    return;
  v41 = *a7;
  v13 = 0;
  v14 = *(_DWORD *)(a2 + 364) - *(_DWORD *)(a2 + 368) + *(_DWORD *)(a2 + 200);
  v15 = v14 & ~(v14 >> 31);
  v16 = *(unsigned int **)(a2 + 168);
  v17 = *(_QWORD *)(a5 + 8);
  v18 = (_QWORD *)(*(_QWORD *)(a2 + 304) + 32);
  v44 = a6;
  v43 = v15;
  v42 = a4;
  do
  {
    v19 = *(unsigned int *)(a2 + 176);
    if (v13 >= v19)
      Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, v13, v19);
    v20 = *v16;
    v21 = *(_DWORD *)(*v18 + 4 * v20);
    v22 = *(_DWORD *)(a2 + 368);
    v23 = v22 - v21;
    if (v22 != v21)
    {
      v24 = *(float *)(*(v18 - 3) + 4 * v20) * (float)*(unsigned int *)(a2 + 196);
      v25 = *a3;
      if (*a3 == 1.0)
      {
        v26 = (float)v23;
      }
      else
      {
        if (v25 == 0.0)
          goto LABEL_14;
        v30 = a3;
        v26 = powf((float)v23, v25);
        v15 = v43;
        a4 = v42;
        a3 = v30;
        a6 = v44;
      }
      v24 = v24 / v26;
LABEL_14:
      v27 = v24 + *a4;
      if (v13 < *(unsigned int *)(a5 + 16))
        v27 = v27 + *(float *)(v17 + 4 * v13);
      v28 = *(_QWORD *)(a1 + 3064);
      if (v27 > *(float *)(v28 + 4 * v13) && *a6 > v15)
      {
        v29 = 4 * v13;
        *(_DWORD *)(*(_QWORD *)(a1 + 3016) + v29) = *a6 - v15;
        *(_DWORD *)(*(_QWORD *)(a1 + 3040) + v29) = v23;
        *(float *)(v28 + v29) = v27;
      }
    }
    ++v13;
    v16 += 22;
    v18 += 6;
  }
  while (v10 != v13);
  if (v41)
  {
    v31 = 0;
    v32 = *(_QWORD *)(a2 + 168);
    v33 = *(_QWORD *)(a2 + 304);
    v34 = *a3;
    while (2)
    {
      v38 = *(unsigned int *)(a2 + 176);
      v39 = v31 + (v38 >> 1);
      if (v39 >= v38)
        Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, v31 + (v38 >> 1), v38);
      v40 = *(unsigned int *)(v32 + 88 * v39);
      v37 = *(_DWORD *)(a2 + 368) - *(_DWORD *)(*(_QWORD *)(v33 + 48 * v39 + 32) + 4 * v40);
      if (!v37)
        goto LABEL_25;
      v36 = *(float *)(*(_QWORD *)(v33 + 48 * v39 + 8) + 4 * v40) * (float)*(unsigned int *)(a2 + 196);
      if (v34 != 1.0)
      {
        if (v34 != 0.0)
        {
          v35 = powf((float)v37, v34);
LABEL_23:
          v36 = v36 / v35;
        }
        v37 = ((float)(fmaxf(v36, 0.0) * *(float *)(a1 + 1192)) + 0.5);
LABEL_25:
        *(_DWORD *)(*(_QWORD *)(a1 + 3040) + 4 * v31++) = v37;
        if (v10 == v31)
          return;
        continue;
      }
      break;
    }
    v35 = (float)v37;
    goto LABEL_23;
  }
}

float IntNovDetect::convertStrArrToFloatArr(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const char *v5;
  float result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;

  (*(void (**)(_QWORD *, uint64_t))(*a3 + 32))(a3, a2 + 16);
  if (*(_DWORD *)(a2 + 16))
  {
    v7 = 0;
    v8 = 0;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v10 = v9 + v7;
      if (!*(_DWORD *)(v10 + 8)
        || (v11 = 0,
            strtod(*(const char **)(v10 + 16), &v11),
            v11 != (char *)(*(_QWORD *)(v10 + 16) + *(unsigned int *)(v10 + 8))))
      {
        Error::chuck((Error *)"NovDetect: cannot convert element to float", v5);
      }
      v9 = *(_QWORD *)(a2 + 8);
      result = atof(*(const char **)(v9 + v7 + 16));
      *(float *)(a3[1] + 4 * v8++) = result;
      v7 += 24;
    }
    while (v8 < *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t IntNovDetect::resetMultiphraseResults(uint64_t this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_DWORD *)(this + 3080))
  {
    v1 = 0;
    v2 = *(_QWORD *)(this + 3016);
    v3 = *(_QWORD *)(this + 3040);
    v4 = *(_QWORD *)(this + 3064);
    do
    {
      v5 = 4 * v1;
      *(_DWORD *)(v2 + v5) = 0;
      *(_DWORD *)(v3 + v5) = 0;
      *(_DWORD *)(v4 + v5) = -915135488;
      ++v1;
    }
    while (v1 < *(unsigned int *)(this + 3080));
  }
  return this;
}

uint64_t IntNovDetect::handleWavedataOverflow(IntNovDetect *this, const char *a2, int *a3, const BOOL *a4)
{
  int v7;
  uint64_t v8;
  char *v9;
  uint64_t i;
  const char *v11;
  uint64_t result;
  int v13;
  int v14;
  int v15;

  v7 = *((_DWORD *)this + 692);
  v8 = (*a3 - v7);
  v13 = *a3 - v7;
  v14 = v7;
  v9 = (char *)this + 48;
  if (*a4)
  {
    if (!*((_BYTE *)this + 1197))
      goto LABEL_20;
    if (*((_BYTE *)this + 1196))
      goto LABEL_21;
    v15 = 1;
  }
  else
  {
    if (!*((_BYTE *)this + 1197))
      goto LABEL_22;
    if (*((_BYTE *)this + 1196))
      goto LABEL_23;
    v15 = 0;
  }
  NWavChunk2HTKFrames::run((uint64_t)this + 48, a2, &v13, &v15, (uint64_t)this + 1048);
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1288));
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1696));
  *((_BYTE *)this + 1196) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_DWORD *)this + 150) = *((_DWORD *)this + 146) + 1;
  *((_QWORD *)this + 76) = 0;
  *((_BYTE *)this + 604) = 0;
  NDynamicMFCC::reset((IntNovDetect *)((char *)this + 624));
  *((_QWORD *)this + 137) = 0;
  *((_QWORD *)this + 136) = 0;
  for (i = *((_QWORD *)this + 133); i; i = *((_QWORD *)this + 133))
  {
    *((_QWORD *)this + 133) = *(_QWORD *)(i + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 132) + 72))((char *)this + 1056);
  }
  *((_QWORD *)this + 134) = 0;
  *((_DWORD *)this + 270) = 0;
  *((_QWORD *)this + 138) = 0;
  *(_QWORD *)((char *)this + 1109) = 0;
  NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1048, (int *)this + 280);
  if (*((_BYTE *)this + 2884))
    NLocalCepNorm::resync((void **)this + 150);
  *((_QWORD *)this + 346) = 0;
  if (!*a4)
  {
    if (*((_BYTE *)this + 1197))
    {
      if (!*((_BYTE *)this + 1196))
      {
        v11 = &a2[2 * v8];
        v15 = 0;
        goto LABEL_19;
      }
LABEL_23:
      Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
                 "r (m_queue) has been emptied (call reset())",
        a2);
    }
LABEL_22:
    Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2);
  }
  if (!*((_BYTE *)this + 1197))
LABEL_20:
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - you must call TSAcAnal::init() before feedFromFloat()", a2);
  if (*((_BYTE *)this + 1196))
LABEL_21:
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
               "r (m_queue) has been emptied (call reset())",
      a2);
  v11 = &a2[4 * v8];
  v15 = 1;
LABEL_19:
  result = NWavChunk2HTKFrames::run((uint64_t)v9, v11, &v14, &v15, (uint64_t)this + 1048);
  *((_DWORD *)this + 692) += v7;
  return result;
}

uint64_t IntNovDetect::wavedata(IntNovDetect *this, const char *a2, int a3)
{
  int v4;
  const char *v5;
  double v6;
  char *v7;
  uint64_t v8;
  int v10;
  int v11;
  BOOL v12[4];

  v11 = a3;
  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: wavedata() can only be called after initialize()", a2);
  if (*((_DWORD *)this + 2) != 1)
    Error::chuck((Error *)"NovDetect: wavedata() cannot be called after endwavedata()", a2);
  if (!a2)
    Error::chuck((Error *)"NovDetect: wavedata() data is NULL pointer", 0);
  if (a3 < 0)
    Error::chuck((Error *)"NovDetect: wavedata() length must be positive", a2);
  v4 = *((_DWORD *)this + 692);
  *((_DWORD *)this + 692) = v4 + a3;
  if (__CFADD__(v4, a3))
  {
    v12[0] = 0;
    IntNovDetect::handleWavedataOverflow(this, a2, &v11, v12);
  }
  else
  {
    v10 = a3;
    if (!*((_BYTE *)this + 1197))
      Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2);
    if (*((_BYTE *)this + 1196))
      Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
                 "r (m_queue) has been emptied (call reset())",
        a2);
    *(_DWORD *)v12 = 0;
    NWavChunk2HTKFrames::run((uint64_t)this + 48, a2, &v10, (int *)v12, (uint64_t)this + 1048);
  }
  IntNovDetect::advanceDetection(this, v5, v6);
  if (*((_BYTE *)this + 40))
  {
    *(_DWORD *)v12 = 6;
    v8 = *((_QWORD *)this + 2);
    v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, BOOL *))(v8 + 64))(v7, "all ok", v12);
    v7[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::wavedataf(IntNovDetect *this, const float *a2, int a3)
{
  int v4;
  const char *v5;
  double v6;
  char *v7;
  uint64_t v8;
  int v10;
  int v11;
  BOOL v12[4];

  v11 = a3;
  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: wavedataf() can only be called after initialize()", (const char *)a2);
  if (*((_DWORD *)this + 2) != 1)
    Error::chuck((Error *)"NovDetect: wavedata() cannot be called after endwavedata()", (const char *)a2);
  if (!a2)
    Error::chuck((Error *)"NovDetect: wavedataf() data is NULL pointer", 0);
  if (a3 < 0)
    Error::chuck((Error *)"NovDetect: wavedataf() length must be positive", (const char *)a2);
  v4 = *((_DWORD *)this + 692);
  *((_DWORD *)this + 692) = v4 + a3;
  if (__CFADD__(v4, a3))
  {
    v12[0] = 1;
    IntNovDetect::handleWavedataOverflow(this, (const char *)a2, &v11, v12);
  }
  else
  {
    v10 = a3;
    if (!*((_BYTE *)this + 1197))
      Error::chuck((Error *)"TSAcAnal::feedFromFloat() - you must call TSAcAnal::init() before feedFromFloat()", (const char *)a2);
    if (*((_BYTE *)this + 1196))
      Error::chuck((Error *)"TSAcAnal::feedFromFloat() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buf"
                 "fer (m_queue) has been emptied (call reset())",
        (const char *)a2);
    *(_DWORD *)v12 = 1;
    NWavChunk2HTKFrames::run((uint64_t)this + 48, (const char *)a2, &v10, (int *)v12, (uint64_t)this + 1048);
  }
  IntNovDetect::advanceDetection(this, v5, v6);
  if (*((_BYTE *)this + 40))
  {
    *(_DWORD *)v12 = 6;
    v8 = *((_QWORD *)this + 2);
    v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, BOOL *))(v8 + 64))(v7, "all ok", v12);
    v7[24] = 0;
  }
  return 0;
}

char *IntNovDetect::getresults(IntNovDetect *this, const char *a2)
{
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  unsigned int v8;
  int v9;
  char *v10;
  char *v11;
  int v13;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: getresults() can only be called after initialize()", a2);
  v2 = *((_DWORD *)this + 694);
  v3 = *((_DWORD *)this + 690);
  v4 = *((_DWORD *)this + 691);
  v5 = *((_DWORD *)this + 695);
  v6 = v2 >= v5;
  v8 = v2 - v5;
  v7 = v8 != 0 && v6;
  v9 = v8 * v3;
  if (!v7)
    v9 = 0;
  v10 = (char *)this + 2568;
  *((_DWORD *)this + 642) = *((_DWORD *)this + 692);
  *((_DWORD *)this + 643) = v9;
  *((_DWORD *)this + 644) = v4 + v3 * v2;
  *((_DWORD *)this + 645) = *((_DWORD *)this + 696);
  *((_DWORD *)this + 646) = *((_DWORD *)this + 700);
  *((_BYTE *)this + 2588) = *((_BYTE *)this + 2893);
  *((_BYTE *)this + 2589) = *((_BYTE *)this + 2892);
  if (*((_BYTE *)this + 40))
  {
    v13 = 6;
    v11 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v13);
    v11[24] = 0;
  }
  return v10;
}

char *IntNovDetect::getphraseresults(IntNovDetect *this, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  BOOL v9;
  unsigned int v10;
  int v11;
  char *v12;
  char *v13;
  int v15;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: getphraseresults() can only be called after initialize()", a2);
  v2 = *((unsigned int *)this + 770);
  if (v2 <= a2)
  {
    if (!(_DWORD)v2)
      Error::chuck((Error *)"NovDetect: getphraseresults() phrase results not set up", a2);
    Error::chuck((Error *)"NovDetect: getphraseresults() phrase %d out of range (0-%d)", a2, a2, v2);
  }
  v3 = 4 * a2;
  v4 = *(_DWORD *)(*((_QWORD *)this + 377) + v3);
  v5 = *((_DWORD *)this + 690);
  v6 = *((_DWORD *)this + 691);
  v7 = *(_DWORD *)(*((_QWORD *)this + 380) + v3);
  v8 = v4 >= v7;
  v10 = v4 - v7;
  v9 = v10 != 0 && v8;
  v11 = v10 * v5;
  if (!v9)
    v11 = 0;
  v12 = (char *)this + 2568;
  *((_DWORD *)this + 642) = *((_DWORD *)this + 692);
  *((_DWORD *)this + 643) = v11;
  *((_DWORD *)this + 644) = v6 + v5 * v4;
  *((_DWORD *)this + 645) = *((_DWORD *)this + 696);
  *((_DWORD *)this + 646) = *(_DWORD *)(*((_QWORD *)this + 383) + 4 * a2);
  *((_BYTE *)this + 2588) = *((_BYTE *)this + 2893);
  *((_BYTE *)this + 2589) = *((_BYTE *)this + 2892);
  if (*((_BYTE *)this + 40))
  {
    v15 = 6;
    v13 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v15);
    v13[24] = 0;
  }
  return v12;
}

uint64_t IntNovDetect::phrasecount(IntNovDetect *this, const char *a2)
{
  int v4;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: phrasecount() can only be called after initialize()", a2);
  if (*((_BYTE *)this + 40))
  {
    v4 = 6;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v4);
    *((_BYTE *)this + 40) = 0;
  }
  return *((unsigned int *)this + 770);
}

uint64_t IntNovDetect::getresultsstr(IntNovDetect *this, const char *a2)
{
  unsigned int v3;
  int v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  unsigned int v8;
  int v9;
  int v11;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: getresultsstr() can only be called after initialize()", a2);
  v3 = *((_DWORD *)this + 694);
  v4 = *((_DWORD *)this + 690);
  v5 = *((_DWORD *)this + 695);
  v6 = v3 >= v5;
  v8 = v3 - v5;
  v7 = v8 != 0 && v6;
  v9 = v8 * v4;
  if (!v7)
    v9 = 0;
  NString::printf((IntNovDetect *)((char *)this + 2544), "samples_fed: %u\nbest_start: %u\nbest_end: %u\nbest_score: %.3f\n", *((_DWORD *)this + 692), v9, *((_DWORD *)this + 691) + v4 * v3, *((float *)this + 700));
  if (*((_BYTE *)this + 40))
  {
    v11 = 6;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v11);
    *((_BYTE *)this + 40) = 0;
  }
  return *((_QWORD *)this + 320);
}

char *IntNovDetect::getsupervector(IntNovDetect *this, const char *a2, double a3)
{
  unsigned int v3;
  uint64_t v5;
  int v6;
  char *v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  float32x4_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  unsigned int v27;
  int v28;
  int v29;
  uint32x4_t *v30;
  float32x4_t *v31;
  uint64_t v32;
  float32x4_t *v33;
  uint32x4_t *v34;
  uint64_t v35;
  float32x4_t v36;
  uint64_t v37;
  uint64_t v38;
  float *v39;
  unsigned int *v40;
  unsigned int v41;
  BOOL v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  const char *v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  float v59;
  unsigned int v60;
  uint64_t v61;
  _OWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  float32x4_t *v66;
  float32x4_t v67;
  int v68;
  unsigned int v69;
  int v70;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  v3 = a2;
  if (*((_BYTE *)this + 40))
  {
    v68 = 6;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v68);
    *((_BYTE *)this + 40) = 0;
  }
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: getsupervector() can only be called after initialize()", a2);
  if (!*((_BYTE *)this + 2885))
    Error::chuck((Error *)"NovDetect: supervector not enabled in config", a2);
  if (*((_BYTE *)this + 2886))
  {
    v5 = *((unsigned int *)this + 496);
    if (*((_DWORD *)this + 668) != (_DWORD)v5)
      Error::chuck((Error *)"TSHMMDetector::lastModelOutput() - mismatched size in output array (%d != %d)", a2, *((unsigned int *)this + 668), v5);
    v6 = *((unsigned __int8 *)this + 2099);
    if (*((_BYTE *)this + 2099))
      (*(void (**)(char *, char *))(*((_QWORD *)this + 332) + 16))((char *)this + 2656, (char *)this + 1968);
    if (v6)
      return (char *)this + 2592;
    else
      return (char *)this + 2624;
  }
  if (!*((_BYTE *)this + 2891) || !*((_BYTE *)this + 2892))
    return (char *)this + 2624;
  while ((TSHMMDetector::updateResult((IntNovDetect *)((char *)this + 1696), a2, a3) & 1) != 0)
    ;
  v8 = *((_DWORD *)this + 516);
  if (v8 == *((_DWORD *)this + 513))
    return (char *)this + 2624;
  v9 = *((_DWORD *)this + 691);
  v10 = v3 >= v9;
  v11 = (v3 - v9 + (*((_DWORD *)this + 690) >> 1)) / *((_DWORD *)this + 690);
  if (!v10)
    v11 = 0;
  v12 = *((_DWORD *)this + 515) - v8 + *((_DWORD *)this + 474);
  v13 = v12 & ~(v12 >> 31);
  v14 = *((_DWORD *)this + 693);
  if (v14 < v11 + v13)
    return (char *)this + 2624;
  v15 = v14 - v11;
  v69 = v14 - v11 - v13;
  NLRHMMTraceback::stateAlignment((uint64_t)this + 1808, (uint64_t)this + 2736, &v69);
  v17 = *((unsigned int *)this + 688);
  if ((_DWORD)v17)
  {
    v18 = 0;
    v19 = (int *)*((_QWORD *)this + 343);
    v20 = *((unsigned int *)this + 688);
    while (1)
    {
      v22 = *v19++;
      v21 = v22;
      if (!v22)
        return (char *)this + 2624;
      v18 += v21;
      if (!--v20)
        goto LABEL_26;
    }
  }
  v18 = 0;
LABEL_26:
  v23 = *((unsigned int *)this + 629);
  v24 = v18 + v15;
  v10 = v23 >= v24;
  v25 = v23 - v24;
  if (!v10)
    return (char *)this + 2624;
  v27 = 0;
  v28 = *((_DWORD *)this + 250);
  v29 = *((unsigned __int8 *)this + 1032);
  if (*((_DWORD *)this + 651) && (_DWORD)v17)
  {
    v30 = (uint32x4_t *)*((_QWORD *)this + 343);
    v31 = (float32x4_t *)*((_QWORD *)this + 333);
    if (v17 >= 8)
    {
      v32 = v17 & 0xFFFFFFF8;
      v33 = v31 + 1;
      v34 = v30 + 1;
      v35 = v32;
      do
      {
        v16 = vcvtq_f32_u32(v34[-1]);
        v36 = vcvtq_f32_u32(*v34);
        v33[-1] = v16;
        *v33 = v36;
        v33 += 2;
        v34 += 2;
        v35 -= 8;
      }
      while (v35);
      if (v32 == v17)
        goto LABEL_38;
    }
    else
    {
      v32 = 0;
    }
    v37 = v17 - v32;
    v38 = v32;
    v39 = &v31->f32[v38];
    v40 = &v30->u32[v38];
    do
    {
      v41 = *v40++;
      *v39++ = (float)v41;
      --v37;
    }
    while (v37);
LABEL_38:
    v27 = v17;
  }
  if (*((_DWORD *)this + 653))
    v42 = (_DWORD)v17 == 0;
  else
    v42 = 1;
  if (!v42)
  {
    v45 = 0;
    v46 = v28 * ((2 * v29) | 1u);
    v47 = v46 - 1;
    v48 = v46 & 0xFFFFFFF8;
    v16.i32[0] = 1.0;
    while (1)
    {
      if (!v28)
      {
        LODWORD(v53) = *(_DWORD *)(*((_QWORD *)this + 343) + 4 * v45);
        if (!(_DWORD)v53)
          goto LABEL_48;
        goto LABEL_65;
      }
      v49 = *((_QWORD *)this + 333);
      if (v46 <= 7)
        break;
      v50 = 0;
      if (__CFADD__(v27, (_DWORD)v47))
        goto LABEL_52;
      if (HIDWORD(v47))
        goto LABEL_52;
      v60 = v27;
      v61 = v46 & 0xFFFFFFF8;
      do
      {
        v62 = (_OWORD *)(v49 + 4 * v60);
        *v62 = 0uLL;
        v62[1] = 0uLL;
        v60 += 8;
        v61 -= 8;
      }
      while (v61);
      v50 = v46 & 0xFFFFFFF8;
      if (v48 != v46)
        goto LABEL_52;
LABEL_55:
      v53 = (const char *)*(unsigned int *)(*((_QWORD *)this + 343) + 4 * v45);
      if ((_DWORD)v53)
      {
        v54 = 0;
        do
        {
          v55 = 0;
          v56 = v54 + v25;
          do
          {
            if (v56 >= v23)
              Error::chuck((Error *)"NRingDropBuffer[] - out-of-bounds (size = %d, [] = %d)", v53, *(double *)v16.i64, 0.0, v23, (v54 + v25));
            v57 = *((_DWORD *)this + 626);
            v58 = *((_DWORD *)this + 628) + v56 + v57 - v23;
            if (v58 < v57)
              v57 = 0;
            *(float *)(v49 + 4 * (v27 + v55)) = *(float *)(*(_QWORD *)(*((_QWORD *)this + 312)
                                                                                     + 24 * (v58 - v57)
                                                                                     + 8)
                                                                         + 4 * v55)
                                                              + *(float *)(v49 + 4 * (v27 + v55));
            ++v55;
          }
          while (v46 != v55);
          ++v54;
        }
        while (v54 != (_DWORD)v53);
LABEL_65:
        v59 = 1.0 / (float)v53;
        if (!v28)
          goto LABEL_48;
        goto LABEL_74;
      }
      v59 = 0.0;
LABEL_74:
      v63 = *((_QWORD *)this + 333);
      if (v46 > 7)
      {
        v64 = 0;
        if (!__CFADD__(v27, (_DWORD)v47) && !HIDWORD(v47))
        {
          v65 = 0;
          do
          {
            v66 = (float32x4_t *)(v63 + 4 * (v27 + v65));
            v67 = vmulq_n_f32(v66[1], v59);
            *v66 = vmulq_n_f32(*v66, v59);
            v66[1] = v67;
            v65 += 8;
          }
          while (v48 != v65);
          v64 = v46 & 0xFFFFFFF8;
          if (v48 == v46)
            goto LABEL_48;
        }
      }
      else
      {
        v64 = 0;
      }
      do
      {
        *(float *)(v63 + 4 * (v27 + v64)) = v59 * *(float *)(v63 + 4 * (v27 + v64));
        ++v64;
      }
      while (v46 != v64);
LABEL_48:
      v25 += (int)v53;
      v27 += v46;
      if (++v45 == v17)
        goto LABEL_44;
    }
    v50 = 0;
LABEL_52:
    v51 = v50 - v46;
    v52 = v27 + v50;
    do
    {
      *(_DWORD *)(v49 + 4 * v52++) = 0;
      v10 = __CFADD__(v51++, 1);
    }
    while (!v10);
    goto LABEL_55;
  }
LABEL_44:
  v7 = (char *)this + 2592;
  if (*((_DWORD *)this + 654))
    *(_DWORD *)(*((_QWORD *)this + 333) + 4 * v27) = *((_DWORD *)this + 700);
  if (*((_BYTE *)this + 40))
  {
    v70 = 6;
    v44 = *((_QWORD *)this + 2);
    v43 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v44 + 64))(v43, "all ok", &v70);
    v43[24] = 0;
  }
  return v7;
}

char *IntNovDetect::scoresupervector(IntNovDetect *this, const float *a2, uint64_t a3)
{
  char *v4;
  char *v5;
  uint64_t v6;
  int v8;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: scoresupervector() can only be called after initialize()", (const char *)a2);
  if (!*((_BYTE *)this + 2889))
    Error::chuck((Error *)"NovDetect: supervector scorer not initialized in config", (const char *)a2);
  v4 = (char *)this + 2680;
  *((_DWORD *)this + 670) = 0;
  *((float *)this + 670) = TSSupervectorScorer::score((IntNovDetect *)((char *)this + 2104), a2, a3);
  if (*((_BYTE *)this + 40))
  {
    v8 = 6;
    v6 = *((_QWORD *)this + 2);
    v5 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v6 + 64))(v5, "all ok", &v8);
    v5[24] = 0;
  }
  return v4;
}

uint64_t IntNovDetect::resetbest(IntNovDetect *this, const char *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int v9;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: resetbest() can only be called after initialize()", a2);
  *((_QWORD *)this + 347) = 0;
  *((_DWORD *)this + 696) = 0;
  *((_DWORD *)this + 700) = -915135488;
  *((_BYTE *)this + 2893) = 0;
  if (*((_DWORD *)this + 770))
  {
    v2 = 0;
    v3 = *((_QWORD *)this + 377);
    v4 = *((_QWORD *)this + 380);
    v5 = *((_QWORD *)this + 383);
    do
    {
      v6 = 4 * v2;
      *(_DWORD *)(v3 + v6) = 0;
      *(_DWORD *)(v4 + v6) = 0;
      *(_DWORD *)(v5 + v6) = -915135488;
      ++v2;
    }
    while (v2 < *((unsigned int *)this + 770));
  }
  if (*((_BYTE *)this + 40))
  {
    v9 = 6;
    v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v9);
    v7[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::reset(IntNovDetect *this, const char *a2)
{
  int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t i;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  char *v14;
  uint64_t v15;
  int v17;
  int v18;

  if (*(_DWORD *)this != -1838836561)
    goto LABEL_22;
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: reset() can only be called after initialize()", a2);
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1288));
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1696));
  if (*((_BYTE *)this + 2884))
  {
    *((_BYTE *)this + 1284) = 0;
    *(_QWORD *)((char *)this + 1220) = 0;
    *(_QWORD *)((char *)this + 1212) = 0;
    v3 = *((_DWORD *)this + 300);
    *((_DWORD *)this + 307) = v3;
    v4 = *((_DWORD *)this + 302);
    if (v4 > v3 + 1)
      *((_DWORD *)this + 307) = v4 - 1;
    v5 = *((unsigned int *)this + 301);
    if ((_DWORD)v5)
      bzero(*((void **)this + 158), 4 * v5);
  }
  *((_BYTE *)this + 1196) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_DWORD *)this + 150) = *((_DWORD *)this + 146) + 1;
  *((_QWORD *)this + 76) = 0;
  *((_BYTE *)this + 604) = 0;
  NDynamicMFCC::reset((IntNovDetect *)((char *)this + 624));
  *((_QWORD *)this + 137) = 0;
  *((_QWORD *)this + 136) = 0;
  for (i = *((_QWORD *)this + 133); i; i = *((_QWORD *)this + 133))
  {
    *((_QWORD *)this + 133) = *(_QWORD *)(i + 8);
    (*(void (**)(char *))(*((_QWORD *)this + 132) + 72))((char *)this + 1056);
  }
  *((_QWORD *)this + 134) = 0;
  *((_DWORD *)this + 270) = 0;
  *((_QWORD *)this + 138) = 0;
  *(_QWORD *)((char *)this + 1109) = 0;
  NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1048, (int *)this + 280);
  *((_QWORD *)this + 314) = 0;
  *((_QWORD *)this + 370) = 0;
  v7 = *((_DWORD *)this + 742);
  *((_DWORD *)this + 743) = v7;
  *((_DWORD *)this + 744) = *((_DWORD *)this + 745) + v7;
  *((_QWORD *)this + 346) = 0;
  *((_DWORD *)this + 697) = 0;
  *((_WORD *)this + 1446) = 0;
  if (*(_DWORD *)this != -1838836561)
LABEL_22:
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: resetbest() can only be called after initialize()", a2);
  *((_QWORD *)this + 347) = 0;
  *((_DWORD *)this + 696) = 0;
  *((_DWORD *)this + 700) = -915135488;
  *((_BYTE *)this + 2893) = 0;
  if (*((_DWORD *)this + 770))
  {
    v8 = 0;
    v9 = *((_QWORD *)this + 377);
    v10 = *((_QWORD *)this + 380);
    v11 = *((_QWORD *)this + 383);
    do
    {
      v12 = 4 * v8;
      *(_DWORD *)(v9 + v12) = 0;
      *(_DWORD *)(v10 + v12) = 0;
      *(_DWORD *)(v11 + v12) = -915135488;
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 770));
  }
  if (*((_BYTE *)this + 40))
  {
    v17 = 6;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v17);
    *((_BYTE *)this + 40) = 0;
  }
  if (*((_DWORD *)this + 745))
  {
    IntNovDetect::zeroWavePrime(this, a2);
    v13 = *((unsigned __int8 *)this + 40);
    *((_DWORD *)this + 2) = 1;
    if (v13)
    {
      v18 = 6;
      v15 = *((_QWORD *)this + 2);
      v14 = (char *)this + 16;
      (*(void (**)(char *, const char *, int *))(v15 + 64))(v14, "all ok", &v18);
      v14[24] = 0;
    }
  }
  else
  {
    *((_DWORD *)this + 2) = 1;
  }
  return 0;
}

uint64_t IntNovDetect::endwavedata(IntNovDetect *this, const char *a2)
{
  const char *v3;
  double v4;
  const char *v5;
  double v6;
  int v7;
  double v8;
  const char *v9;
  double v10;
  const char *v11;
  double v12;
  char *v13;
  uint64_t v14;
  int v16;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: endwavedata() can only be called after initialize()", a2);
  if (*((_DWORD *)this + 2) != 1)
    Error::chuck((Error *)"NovDetect: endwavedata() cannot be called twice in a row", a2);
  *((_DWORD *)this + 2) = 2;
  if (!*((_BYTE *)this + 1197))
    Error::chuck((Error *)"TSAcAnal::endfeed() - you must call TSAcAnal::init() before endfeed()\n", a2);
  if (*((_BYTE *)this + 1196))
    Error::chuck((Error *)"TSAcAnal::endfeed() - TSAcAnal::endfeed() has been called before; is cannot be called againbefore the buf"
               "fer (m_queue) has been emptied\n",
      a2);
  NWavChunk2HTKFrames::finish((uint64_t)this + 48, (const char *)this + 1048);
  *((_BYTE *)this + 1116) = 1;
  *((_BYTE *)this + 1196) = 1;
  IntNovDetect::advanceDetection(this, v3, v4);
  if (*((_BYTE *)this + 2884))
  {
    NLocalCepNorm::endFrames((unsigned int *)this + 300, v5);
    while (1)
    {
      v7 = *((_DWORD *)this + 304);
      if ((!*((_BYTE *)this + 1284) || !v7) && v7 != *((_DWORD *)this + 307) + 1)
        break;
      NLocalCepNorm::setOutputFrame((IntNovDetect *)((char *)this + 1200), (IntNovDetect *)((char *)this + 2520));
      TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1288), (IntNovDetect *)((char *)this + 2520), v8);
      if (*((_BYTE *)this + 2891))
      {
        NRingDropBuffer::pushFrame((uint64_t)this + 2488, (IntNovDetect *)((char *)this + 2520));
        if (*((_BYTE *)this + 2892))
          TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1696), (IntNovDetect *)((char *)this + 2520), v10);
      }
      ++*((_DWORD *)this + 693);
      IntNovDetect::innerAdvanceDetection(this, v9, v10);
    }
  }
  while (TSHMMDetector::endFrame((IntNovDetect *)((char *)this + 1288), v5, v6))
    IntNovDetect::innerAdvanceDetection(this, v11, v12);
  if (*((_BYTE *)this + 2892))
  {
    IntNovDetect::rescoreComplete(this, v11, v12);
    *((_BYTE *)this + 2892) = 0;
  }
  if (*((_BYTE *)this + 40))
  {
    v16 = 6;
    v14 = *((_QWORD *)this + 2);
    v13 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v14 + 64))(v13, "all ok", &v16);
    v13[24] = 0;
  }
  return 0;
}

void IntNovDetect::feedFrameToDetector(IntNovDetect *this, const NFrame *a2, double a3)
{
  double v5;

  TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1288), a2, a3);
  if (*((_BYTE *)this + 2891))
  {
    NRingDropBuffer::pushFrame((uint64_t)this + 2488, a2);
    if (*((_BYTE *)this + 2892))
      TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1696), a2, v5);
  }
}

uint64_t IntNovDetect::getoption(IntNovDetect *this, const char *__s)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t (**v8)(NString *__hidden, const unsigned int *);
  int v9;
  void *v10;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", __s);
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: getoption() can only be called after initialize()", __s);
  if (!__s)
    Error::chuck((Error *)"NovDetect: getoption() cannot be called with NULL", 0);
  v8 = &off_24C7F32C0;
  v9 = strlen(__s);
  v4 = (void *)operator new[]();
  v10 = v4;
  memcpy(v4, __s, (v9 + 1));
  if (!NMap<NString,NString>::contains((uint64_t)this + 2920, (uint64_t)&v8))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v5, v4, *((_QWORD *)this + 364));
  v6 = *(_QWORD *)(NMap<NString,NString>::operator[]((uint64_t)this + 2920, (uint64_t)&v8) + 16);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  return v6;
}

void sub_20D9A2E54(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t IntNovDetect::sat_initialize(IntNovDetect *this, const char *__s)
{
  _DWORD *v4;
  BOOL v5;
  const NString *v6;
  char *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  unsigned int v12;
  _DWORD *v13;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", __s);
  *((_DWORD *)this + 3) = 0;
  if (*((_DWORD *)this + 1) != 1)
    Error::chuck((Error *)"NovDetect: sat_initialize() can only be called after initialize()", __s);
  if (!*((_BYTE *)this + 2890))
    Error::chuck((Error *)"NovDetect: SAT scoring not initialized in config", __s);
  v11 = &off_24C7F32C0;
  if (!__s)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  v12 = strlen(__s);
  v4 = (_DWORD *)operator new[]();
  v13 = v4;
  memcpy(v4, __s, v12 + 1);
  if (v12 >= 7 && (*v4 == 1684957549 ? (v5 = *(_DWORD *)((char *)v4 + 3) == 980968804) : (v5 = 0), v5))
  {
    v10 = NMap<NString,NString>::find((uint64_t)this + 3088, (uint64_t)&v11);
    if (v10)
      v6 = (const NString *)v10;
    else
      v6 = (const NString *)&v11;
  }
  else
  {
    v6 = (const NString *)&v11;
  }
  TSSATScorer::setModelFile((IntNovDetect *)((char *)this + 2184), v6);
  v11 = &off_24C7F32C0;
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  *((_DWORD *)this + 3) = 1;
  if (*((_BYTE *)this + 40))
  {
    LODWORD(v11) = 6;
    v8 = *((_QWORD *)this + 2);
    v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(v8 + 64))(v7, "all ok", &v11);
    v7[24] = 0;
  }
  return 0;
}

void sub_20D9A300C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

char *IntNovDetect::sat_analyze(IntNovDetect *this, const float *a2, uint64_t a3)
{
  char *v4;
  int v5;
  char *v6;
  uint64_t v7;
  int v9;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_analyze() can only be called after sat_initialize()", (const char *)a2);
  v4 = (char *)this + 2680;
  *((_DWORD *)this + 670) = 0;
  TSSATScorer::score((IntNovDetect *)((char *)this + 2184), a2, a3);
  *((_DWORD *)this + 670) = v5;
  if (*((_BYTE *)this + 40))
  {
    v9 = 6;
    v7 = *((_QWORD *)this + 2);
    v6 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v7 + 64))(v6, "all ok", &v9);
    v6[24] = 0;
  }
  return v4;
}

char *IntNovDetect::sat_analyzetransformed(IntNovDetect *this, const float *a2, uint64_t a3)
{
  char *v4;
  int v5;
  char *v6;
  uint64_t v7;
  int v9;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_analyzetransformed() can only be called after sat_initialize()", (const char *)a2);
  v4 = (char *)this + 2728;
  *((_DWORD *)this + 682) = 0;
  TSSATScorer::scoreSpeakerVector((IntNovDetect *)((char *)this + 2184), a2, a3);
  *((_DWORD *)this + 682) = v5;
  if (*((_BYTE *)this + 40))
  {
    v9 = 6;
    v7 = *((_QWORD *)this + 2);
    v6 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v7 + 64))(v6, "all ok", &v9);
    v6[24] = 0;
  }
  return v4;
}

uint64_t IntNovDetect::sat_update(IntNovDetect *this, const char *a2)
{
  const char *v3;
  char *v4;
  uint64_t v5;
  int v7;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_update() can only be called after sat_initialize()", a2);
  if (!*((_BYTE *)this + 2481))
    Error::chuck((Error *)"TSSATScorer::update() - no valid vector prepared", a2);
  *((_BYTE *)this + 2481) = 0;
  NSATSpeaker::insert((_BYTE *)this + 2272, (uint64_t)this + 2424);
  if (*((_BYTE *)this + 2350))
  {
    NSATSpeaker::write((IntNovDetect *)((char *)this + 2272), v3);
    *((_BYTE *)this + 2350) = 0;
  }
  if (*((_BYTE *)this + 40))
  {
    v7 = 6;
    v5 = *((_QWORD *)this + 2);
    v4 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v5 + 64))(v4, "all ok", &v7);
    v4[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::sat_deletevector(IntNovDetect *this, const char *a2)
{
  NSATSpeaker *v3;
  unsigned int *v4;
  int v5;
  BOOL v6;
  signed int v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  int v12;
  unsigned int v13;
  int v14;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_deletevector() can only be called after sat_initialize()", a2);
  if ((_DWORD)a2 != -1)
  {
    v12 = (int)a2;
    if (*((_BYTE *)this + 2480))
    {
      v3 = (IntNovDetect *)((char *)this + 2272);
      v4 = (unsigned int *)&v12;
      goto LABEL_9;
    }
LABEL_16:
    Error::chuck((Error *)"TSSATScorer::deleteVector() - setModelFile() not called", a2);
  }
  v5 = *((_DWORD *)this + 577);
  v6 = __OFSUB__(v5, 1);
  v7 = v5 - 1;
  if (v7 < 0 != v6)
    goto LABEL_11;
  v13 = v7;
  if (!*((_BYTE *)this + 2480))
    goto LABEL_16;
  v3 = (IntNovDetect *)((char *)this + 2272);
  v4 = &v13;
LABEL_9:
  NSATSpeaker::remove(v3, (const char *)v4);
  if (*((_BYTE *)this + 2350))
  {
    NSATSpeaker::write(v3, v8);
    *((_BYTE *)this + 2350) = 0;
  }
LABEL_11:
  if (*((_BYTE *)this + 40))
  {
    v14 = 6;
    v10 = *((_QWORD *)this + 2);
    v9 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v10 + 64))(v9, "all ok", &v14);
    v9[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::sat_vectorcount(IntNovDetect *this, const char *a2)
{
  uint64_t v2;
  char *v3;
  int v5;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_vectorcount() can only be called after sat_initialize()", a2);
  v2 = *((unsigned int *)this + 577);
  if (*((_BYTE *)this + 40))
  {
    v5 = 6;
    v3 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "all ok", &v5);
    v3[24] = 0;
  }
  return v2;
}

char *IntNovDetect::sat_getspeakervector(IntNovDetect *this, const char *a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  unsigned int v7;
  int v8;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_getspeakervector() can only be called after sat_initialize()", a2);
  if ((_DWORD)a2 == -1)
    a2 = (const char *)(*((_DWORD *)this + 577) - 1);
  v7 = a2;
  if (!*((_BYTE *)this + 2480))
    Error::chuck((Error *)"TSSATScorer::getSuperVector() - setModelFile() not called", a2);
  NSATSpeaker::getVector((uint64_t)this + 2272, (uint64_t)this + 2704, &v7);
  v3 = (char *)this + 2688;
  *((_QWORD *)this + 336) = *((_QWORD *)this + 339);
  *((_DWORD *)this + 674) = *((_DWORD *)this + 680);
  if (*((_BYTE *)this + 40))
  {
    v8 = 6;
    v5 = *((_QWORD *)this + 2);
    v4 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v5 + 64))(v4, "all ok", &v8);
    v4[24] = 0;
  }
  return v3;
}

uint64_t IntNovDetect::sat_reset(IntNovDetect *this, const char *a2)
{
  const char *v3;
  char *v4;
  uint64_t v5;
  int v7;

  if (*(_DWORD *)this != -1838836561)
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 3) != 1)
    Error::chuck((Error *)"NovDetect: sat_reset() can only be called after sat_initialize()", a2);
  *((_BYTE *)this + 2481) = 0;
  NSATSpeaker::reset((IntNovDetect *)((char *)this + 2272), a2);
  if (*((_BYTE *)this + 2350))
  {
    NSATSpeaker::write((IntNovDetect *)((char *)this + 2272), v3);
    *((_BYTE *)this + 2350) = 0;
  }
  if (*((_BYTE *)this + 40))
  {
    v7 = 6;
    v5 = *((_QWORD *)this + 2);
    v4 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v5 + 64))(v4, "all ok", &v7);
    v4[24] = 0;
  }
  return 0;
}

const char *IntNovDetect::error(IntNovDetect *this)
{
  if (*((_DWORD *)this + 1) == 2 || *(_DWORD *)this != -1838836561)
    return "Invalid NovDetect object";
  else
    return (const char *)*((_QWORD *)this + 4);
}

_DWORD *IntNovDetect::setError(_DWORD *result, uint64_t a2)
{
  _DWORD *v2;

  if (result[1] != 2)
  {
    v2 = result;
    if (*result == -1838836561)
    {
      result += 4;
      if (v2 + 4 != (_DWORD *)a2)
        result = (_DWORD *)(*(uint64_t (**)(_DWORD *, _QWORD, uint64_t))(*(_QWORD *)result + 64))(result, *(_QWORD *)(a2 + 16), a2 + 8);
      *((_BYTE *)v2 + 40) = 1;
    }
  }
  return result;
}

char *IntNovDetect::nextFrameFromAcanal(IntNovDetect *this, const char *a2)
{
  char *result;
  int v4;
  _BOOL4 v5;
  const char *v6;
  _BOOL4 v7;

  result = (char *)*((_QWORD *)this + 370);
  if (result)
  {
    v4 = *((_DWORD *)this + 743);
    if (v4)
    {
      *((_DWORD *)this + 743) = v4 - 1;
      return result;
    }
    *((_QWORD *)this + 370) = 0;
  }
  if (*((_BYTE *)this + 1116))
    v5 = *((_DWORD *)this + 276) != *((_DWORD *)this + 277);
  else
    v5 = (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) > 1;
  if (!v5)
    return 0;
  result = TSAcAnal::getFrameByRef((IntNovDetect *)((char *)this + 48), a2);
  if (*((_DWORD *)this + 2) != 2 && *((_BYTE *)this + 1196))
  {
    if (*((_BYTE *)this + 1116))
      v7 = *((_DWORD *)this + 276) == *((_DWORD *)this + 277);
    else
      v7 = (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) < 2;
    if (v7)
      Error::chuck((Error *)"NovDetect: advanceDetection() - acanal has shut down!", v6);
  }
  if (*((_DWORD *)this + 743))
    *((_QWORD *)this + 370) = result;
  return result;
}

uint64_t IntNovDetect::directlyComputedLength(IntNovDetect *this, const TSHMMDetector *a2, float *a3, const unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v11;
  float v12;
  float v13;

  v4 = *((unsigned int *)a2 + 44);
  v5 = *a4 + (v4 >> 1);
  if (v5 >= v4)
    Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, a3, *a4 + (v4 >> 1), v4);
  v6 = *(unsigned int *)(*((_QWORD *)a2 + 21) + 88 * v5);
  v7 = *((_QWORD *)a2 + 38);
  v8 = *((_DWORD *)a2 + 92) - *(_DWORD *)(*(_QWORD *)(v7 + 48 * v5 + 32) + 4 * v6);
  if (!v8)
    return 0;
  v11 = *(float *)(*(_QWORD *)(v7 + 48 * v5 + 8) + 4 * v6) * (float)*((unsigned int *)a2 + 49);
  v12 = *a3;
  if (*a3 == 1.0)
  {
    v13 = (float)v8;
  }
  else
  {
    if (v12 == 0.0)
      return ((float)(fmaxf(v11, 0.0) * *((float *)this + 298)) + 0.5);
    v13 = powf((float)v8, v12);
  }
  v11 = v11 / v13;
  return ((float)(fmaxf(v11, 0.0) * *((float *)this + 298)) + 0.5);
}

uint64_t IntNovDetect::feedFrameToNorm(int32x2_t *this, const NFrame *a2, double a3)
{
  const NFrame *v3;
  __int32 v5;
  double v6;

  v3 = a2;
  if (!this[360].i8[4])
  {
    if (a2)
      goto LABEL_9;
    return 0;
  }
  if (a2)
    NLocalCepNorm::pushFrame(this + 150, a2);
  v5 = this[152].i32[0];
  if ((!this[160].i8[4] || !v5) && v5 != this[153].i32[1] + 1)
    return 0;
  v3 = (const NFrame *)&this[315];
  NLocalCepNorm::setOutputFrame((NLocalCepNorm *)&this[150], (NFrame *)&this[315]);
LABEL_9:
  TSHMMDetector::feedFrame((TSHMMDetector *)&this[161], v3, a3);
  if (this[361].i8[3])
  {
    NRingDropBuffer::pushFrame((uint64_t)&this[311], v3);
    if (this[361].i8[4])
      TSHMMDetector::feedFrame((TSHMMDetector *)&this[212], v3, v6);
  }
  return 1;
}

float *IntNovDetect::updateBestScore(float *this, const float *a2, float *a3, float *a4, const unsigned int *a5, const unsigned int *a6)
{
  int v6;

  v6 = *(_DWORD *)a2;
  if (*a2 > this[700] && *a6 > *a5)
  {
    *((_DWORD *)this + 694) = *a6 - *a5;
    this[695] = *a3;
    this[696] = *a4;
    *((_DWORD *)this + 700) = v6;
  }
  return this;
}

void initndlib(void)
{
  if ((initndlib(void)::bNDLibInitialized & 1) == 0)
    initndlib(void)::bNDLibInitialized = 1;
}

void IntNovDetectE::IntNovDetectE(IntNovDetectE *this)
{
  *(_DWORD *)this = 2;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 2) = &off_24C7F3090;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = &off_24C7F3090;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = &off_24C7F3090;
  *((_QWORD *)this + 9) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_BYTE *)this + 96) = 0;
  *((_BYTE *)this + 108) = 0;
  *((_QWORD *)this + 14) = &off_24C7F3090;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_BYTE *)this + 152) = 0;
  *((_QWORD *)this + 21) = &off_24C7F3090;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_BYTE *)this + 196) = 0;
  *((_BYTE *)this + 220) = 0;
  *((_QWORD *)this + 28) = &off_24C7F3100;
  *((_QWORD *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_QWORD *)this + 31) = &off_24C7F3020;
  *((_QWORD *)this + 32) = 0;
  *((_DWORD *)this + 66) = 0;
  *((_QWORD *)this + 34) = &off_24C7F3090;
  *((_QWORD *)this + 35) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_BYTE *)this + 300) = 0;
  *((_BYTE *)this + 324) = 0;
  *((_QWORD *)this + 41) = &off_24C7F3388;
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = 0;
  *((_DWORD *)this + 88) = 0;
  *((_QWORD *)this + 45) = &off_24C7F3090;
  *((_QWORD *)this + 46) = 0;
  *((_DWORD *)this + 94) = 0;
  *((_QWORD *)this + 50) = &off_24C7F3090;
  *((_QWORD *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *((_QWORD *)this + 48) = 0;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 67) = &off_24C7F3090;
  *((_QWORD *)this + 68) = 0;
  *((_DWORD *)this + 138) = 0;
  *((_QWORD *)this + 71) = 0;
  *((_DWORD *)this + 144) = 0;
  *((_QWORD *)this + 70) = &off_24C7F31A8;
  *((_BYTE *)this + 584) = 0;
  *((_DWORD *)this + 147) = 1203982336;
  *((_QWORD *)this + 74) = 0x3F7851EC48742400;
  *((_DWORD *)this + 150) = 257;
  *((_DWORD *)this + 151) = 26;
  *((_OWORD *)this + 38) = xmmword_20DA24610;
  *((_QWORD *)this + 78) = 0x160000000CLL;
  *((_BYTE *)this + 632) = 1;
  *(_DWORD *)((char *)this + 633) = 0;
  *(_QWORD *)((char *)this + 636) = 0x3F80000000000000;
  *((_BYTE *)this + 644) = 0;
  *((_QWORD *)this + 81) = 0x200000002;
  *((_BYTE *)this + 647) = 0;
  *(_WORD *)((char *)this + 645) = 0;
  *((_QWORD *)this + 85) = 0;
  *((_QWORD *)this + 86) = 0;
  *((_QWORD *)this + 84) = &off_24C7F31A8;
  *((_BYTE *)this + 696) = 0;
  *((_BYTE *)this + 708) = 0;
  *(_QWORD *)((char *)this + 700) = 0;
  NLocalCepNorm::NLocalCepNorm((IntNovDetectE *)((char *)this + 712));
  *((_QWORD *)this + 100) = &off_24C7F18B0;
  *((_QWORD *)this + 102) = 0;
  *((_QWORD *)this + 101) = 0;
  *((_QWORD *)this + 103) = &off_24C7F2D10;
  *((_QWORD *)this + 104) = 0;
  *((_DWORD *)this + 210) = 0;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *(_OWORD *)((char *)this + 876) = 0u;
  *((_QWORD *)this + 114) = 0;
  *((_QWORD *)this + 113) = 0;
  *((_QWORD *)this + 112) = &off_24C7F31A8;
  *((_WORD *)this + 460) = 1;
  *((_OWORD *)this + 58) = 0u;
  *((_OWORD *)this + 59) = 0u;
  *((_QWORD *)this + 120) = 0;
  *((_QWORD *)this + 118) = &off_24C7F31A8;
  *((_QWORD *)this + 121) = &off_24C7F3090;
  *((_QWORD *)this + 122) = 0;
  *((_DWORD *)this + 246) = 0;
  *((_DWORD *)this + 248) = -8388609;
  *(_QWORD *)((char *)this + 1004) = 0;
  *(_QWORD *)((char *)this + 996) = 0;
  *(_DWORD *)((char *)this + 1011) = 0;
  *((_QWORD *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;
  *((_QWORD *)this + 127) = &off_24C7F31A8;
  *((_OWORD *)this + 65) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_DWORD *)this + 268) = 0x10000;
  *(_QWORD *)((char *)this + 1076) = 0x4974240049742400;
  *((_DWORD *)this + 271) = 0;
  *((_QWORD *)this + 136) = 0;
  *(_DWORD *)this = 0;
}

void sub_20D9A47EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  NDEAcAnal *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v4 = v3;
  *(_QWORD *)(v1 + 672) = v4;
  v6 = *(_QWORD *)(v1 + 680);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  NDEAcAnal::~NDEAcAnal(v2);
  _Unwind_Resume(a1);
}

void NDEAcAnal::~NDEAcAnal(NDEAcAnal *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *((_QWORD *)this + 69) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 70);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 66) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 67);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  AccelWin2MFCC::~AccelWin2MFCC((void **)this + 11);
  *((_QWORD *)this + 7) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 8);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 4) = &off_24C7F3090;
  v5 = *((_QWORD *)this + 5);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  *((_QWORD *)this + 1) = &off_24C7F3090;
  v6 = *((_QWORD *)this + 2);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
}

void IntNovDetectE::~IntNovDetectE(IntNovDetectE *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *(_DWORD *)this = 2;
  *((_QWORD *)this + 127) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 128);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  NDEHMMDetector::~NDEHMMDetector((IntNovDetectE *)((char *)this + 800));
  *((_QWORD *)this + 96) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 97);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 93) = &off_24C7F2DB8;
  v4 = *((_QWORD *)this + 94);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 - 8);
    if (v5)
    {
      v6 = 24 * v5;
      do
      {
        *(_QWORD *)(v4 + v6 - 24) = &off_24C7F3090;
        v7 = *(_QWORD *)(v4 + v6 - 16);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        v6 -= 24;
      }
      while (v6);
    }
    MEMORY[0x212BAC9C0](v4 - 16, 0x1081C80622C3295);
  }
  *((_QWORD *)this + 84) = &off_24C7F3090;
  v8 = *((_QWORD *)this + 85);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  *((_QWORD *)this + 70) = &off_24C7F3090;
  v9 = *((_QWORD *)this + 71);
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
  *((_QWORD *)this + 67) = &off_24C7F3090;
  v10 = *((_QWORD *)this + 68);
  if (v10)
    MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  AccelWin2MFCC::~AccelWin2MFCC((void **)this + 12);
  *((_QWORD *)this + 8) = &off_24C7F3090;
  v11 = *((_QWORD *)this + 9);
  if (v11)
    MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
  *((_QWORD *)this + 5) = &off_24C7F3090;
  v12 = *((_QWORD *)this + 6);
  if (v12)
    MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
  *((_QWORD *)this + 2) = &off_24C7F3090;
  v13 = *((_QWORD *)this + 3);
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
}

uint64_t IntNovDetectE::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const unsigned int *a6, const char *a7, const unsigned int *a8)
{
  float v16;
  unsigned int v17;
  int v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD *v24;
  __int128 *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int *v31;
  int v32;
  char v33;
  unsigned int v34;
  double v35;
  BOOL v36;
  char v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _OWORD *v45;
  __int128 *v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  int *v52;
  int v53;
  uint64_t result;
  const char *v55;
  float v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int *v63;
  int v64;
  uint64_t v65;
  _DWORD *v66;
  _DWORD *v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  int v72;
  unsigned int v73;

  if (*(_BYTE *)(a3 + 46))
  {
    v16 = *(float *)(a3 + 52) * *(float *)(a3 + 48);
    v17 = *(_DWORD *)(a1 + 688);
    v18 = *(_DWORD *)(a3 + 16);
    v19 = 10000000.0 / *(float *)a3;
    if (v17 != v18)
    {
      v20 = *(_QWORD *)(a1 + 680);
      *(_DWORD *)(a1 + 688) = v18;
      v21 = operator new[]();
      *(_QWORD *)(a1 + 680) = v21;
      LODWORD(v22) = *(_DWORD *)(a3 + 16);
      if (v17 >= v22)
        v22 = v22;
      else
        v22 = v17;
      if ((_DWORD)v22)
      {
        v23 = 0;
        if (v22 < 8)
          goto LABEL_12;
        if ((unint64_t)(v21 - v20) <= 0x1F)
          goto LABEL_12;
        v23 = v22 & 0xFFFFFFF8;
        v24 = (_OWORD *)(v21 + 16);
        v25 = (__int128 *)(v20 + 16);
        v26 = v23;
        do
        {
          v27 = *v25;
          *(v24 - 1) = *(v25 - 1);
          *v24 = v27;
          v24 += 2;
          v25 += 2;
          v26 -= 8;
        }
        while (v26);
        if (v23 != v22)
        {
LABEL_12:
          v28 = v22 - v23;
          v29 = 4 * v23;
          v30 = (_DWORD *)(v21 + 4 * v23);
          v31 = (int *)(v20 + v29);
          do
          {
            v32 = *v31++;
            *v30++ = v32;
            --v28;
          }
          while (v28);
        }
        goto LABEL_17;
      }
      if (v20)
LABEL_17:
        MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
    }
    *(float *)(a1 + 700) = v16;
    *(_BYTE *)(a1 + 708) = *(_BYTE *)(a3 + 47);
    *(float *)(a1 + 704) = v19;
    v33 = 1;
    *(_BYTE *)(a1 + 696) = 1;
    v34 = *(_DWORD *)(a1 + 688);
    goto LABEL_19;
  }
  NDEAcAnal::init(a1 + 8, a3, (unsigned int *)a2);
  v33 = 0;
  v34 = *(_DWORD *)(a1 + 624) * ((2 * *(unsigned __int8 *)(a1 + 644)) | 1);
  v19 = (float)*(unsigned int *)(a1 + 656) / (float)*(unsigned int *)(a1 + 664);
LABEL_19:
  v73 = v34;
  *(_BYTE *)(a1 + 1073) = v33;
  v35 = (float)((float)*(unsigned int *)a2 / v19) + 0.5;
  *(_QWORD *)(a1 + 1040) = v35;
  if ((v35 & 0x80000000) != 0)
    Error::chuck((Error *)"NovDetectE: unsupportable frame advance %u", (const char *)a2, v35);
  if (!v35)
    *(_DWORD *)(a1 + 1040) = 1;
  if (a4)
    v36 = *(_BYTE *)(a2 + 40) == 0;
  else
    v36 = 1;
  v37 = !v36;
  *(_BYTE *)(a1 + 1072) = v37;
  if (!v36)
  {
    v38 = *(_DWORD *)(a4 + 4) + (*(_DWORD *)a4 >> 1);
    if (v38 >= *(_DWORD *)a4)
      return 0xFFFFFFFFLL;
    v71 = 0;
    v72 = v38;
    NLocalCepNorm::configure((NLocalCepNorm *)(a1 + 712), (char *)a4, &v73, (float *)(a4 + 8), (unsigned int *)&v72, &v71);
    v39 = *(_DWORD *)(a1 + 624) * ((2 * *(unsigned __int8 *)(a1 + 644)) | 1);
    v40 = *(_DWORD *)(a1 + 1032);
    if (v40 != v39)
    {
      v41 = *(_QWORD *)(a1 + 1024);
      *(_DWORD *)(a1 + 1032) = v39;
      v42 = operator new[]();
      *(_QWORD *)(a1 + 1024) = v42;
      if (v40 >= v39)
        v43 = v39;
      else
        v43 = v40;
      if ((_DWORD)v43)
      {
        v44 = 0;
        if (v43 < 8)
          goto LABEL_40;
        if ((unint64_t)(v42 - v41) <= 0x1F)
          goto LABEL_40;
        v44 = v43 & 0xFFFFFFF8;
        v45 = (_OWORD *)(v42 + 16);
        v46 = (__int128 *)(v41 + 16);
        v47 = v44;
        do
        {
          v48 = *v46;
          *(v45 - 1) = *(v46 - 1);
          *v45 = v48;
          v45 += 2;
          v46 += 2;
          v47 -= 8;
        }
        while (v47);
        if (v44 != v43)
        {
LABEL_40:
          v49 = v43 - v44;
          v50 = 4 * v44;
          v51 = (_DWORD *)(v42 + 4 * v44);
          v52 = (int *)(v41 + v50);
          do
          {
            v53 = *v52++;
            *v51++ = v53;
            --v49;
          }
          while (v49);
        }
        goto LABEL_45;
      }
      if (v41)
LABEL_45:
        MEMORY[0x212BAC9C0](v41, 0x1000C8052888210);
    }
  }
  NDEHMMDetector::init(a1 + 800, (int32x2_t *)a2, a5, a6, a7, a8, v73, v19 * (float)*(unsigned int *)(a2 + 12));
  *(_DWORD *)(a1 + 1076) = *(_DWORD *)(a2 + 28);
  *(_BYTE *)(a1 + 1074) = *(_BYTE *)(a2 + 41) ^ 1;
  *(_BYTE *)(a1 + 1075) = *(_BYTE *)(a2 + 42);
  if (*(_DWORD *)(a2 + 24))
    *(_DWORD *)(a1 + 1080) = *(_DWORD *)(a2 + 32);
  v56 = *(float *)(a2 + 36);
  if (v56 < 0.0)
    Error::chuck((Error *)"NovDetectE: extra wait time (%.3f) should be positive", v55, v56);
  *(_DWORD *)(a1 + 1084) = (float)(v19 * v56);
  if (*(_BYTE *)(a1 + 1072))
  {
    *(_BYTE *)(a1 + 796) = 0;
    *(_QWORD *)(a1 + 732) = 0;
    *(_QWORD *)(a1 + 724) = 0;
    v57 = *(_DWORD *)(a1 + 712);
    *(_DWORD *)(a1 + 740) = v57;
    v58 = *(_DWORD *)(a1 + 720);
    if (v58 > v57 + 1)
      *(_DWORD *)(a1 + 740) = v58 - 1;
    v59 = *(unsigned int *)(a1 + 716);
    if ((_DWORD)v59)
      bzero(*(void **)(a1 + 776), 4 * v59);
  }
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 512) = *(_DWORD *)(a1 + 496) + 1;
  *(_QWORD *)(a1 + 520) = 0;
  *(_BYTE *)(a1 + 516) = 0;
  *(_DWORD *)(a1 + 992) = -8388609;
  *(_QWORD *)(a1 + 1004) = 0;
  *(_QWORD *)(a1 + 996) = 0;
  if (*(_DWORD *)(a1 + 840))
  {
    v60 = 0;
    v61 = *(_QWORD *)(a1 + 832);
    do
    {
      v62 = v61 + 136 * v60;
      v64 = *(_DWORD *)(v62 + 72);
      v63 = (unsigned int *)(v62 + 72);
      if (v64)
      {
        v65 = v61 + 136 * v60;
        v66 = *(_DWORD **)(v65 + 88);
        *v66 = 0;
        v67 = *(_DWORD **)(v65 + 112);
        *v67 = 0;
        if (*v63)
        {
          v68 = 1;
          do
          {
            v69 = v68;
            v66[v69] = -8388609;
            v67[v69] = 0;
            ++v68;
          }
          while (v68 <= *v63);
        }
      }
      ++v60;
    }
    while (v60 < *(unsigned int *)(a1 + 840));
  }
  *(_WORD *)(a1 + 920) = 1;
  *(_DWORD *)(a1 + 888) = 0;
  *(_DWORD *)(a1 + 884) = 0;
  v70 = *(_QWORD *)(a1 + 808);
  if (v70)
  {
    if (*(_QWORD *)(a1 + 816))
      (*(void (**)(uint64_t))(*(_QWORD *)v70 + 160))(v70);
  }
  result = 0;
  *(_QWORD *)(a1 + 1088) = 0;
  *(_OWORD *)(a1 + 1048) = 0u;
  *(int32x2_t *)(a1 + 1064) = vdup_n_s32(0xC9742400);
  *(_DWORD *)a1 = 1;
  return result;
}

uint64_t IntNovDetectE::reset(IntNovDetectE *this)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  int v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;

  if (*((_BYTE *)this + 1072))
  {
    *((_BYTE *)this + 796) = 0;
    *(_QWORD *)((char *)this + 732) = 0;
    *(_QWORD *)((char *)this + 724) = 0;
    v2 = *((_DWORD *)this + 178);
    *((_DWORD *)this + 185) = v2;
    v3 = *((_DWORD *)this + 180);
    if (v3 > v2 + 1)
      *((_DWORD *)this + 185) = v3 - 1;
    v4 = *((unsigned int *)this + 179);
    if ((_DWORD)v4)
      bzero(*((void **)this + 97), 4 * v4);
  }
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
  *((_QWORD *)this + 65) = 0;
  *((_BYTE *)this + 516) = 0;
  *((_DWORD *)this + 248) = -8388609;
  *(_QWORD *)((char *)this + 1004) = 0;
  *(_QWORD *)((char *)this + 996) = 0;
  if (*((_DWORD *)this + 210))
  {
    v5 = 0;
    v6 = *((_QWORD *)this + 104);
    do
    {
      v7 = v6 + 136 * v5;
      v9 = *(_DWORD *)(v7 + 72);
      v8 = (unsigned int *)(v7 + 72);
      if (v9)
      {
        v10 = v6 + 136 * v5;
        v11 = *(_DWORD **)(v10 + 88);
        *v11 = 0;
        v12 = *(_DWORD **)(v10 + 112);
        *v12 = 0;
        if (*v8)
        {
          v13 = 1;
          do
          {
            v14 = v13;
            v11[v14] = -8388609;
            v12[v14] = 0;
            ++v13;
          }
          while (v13 <= *v8);
        }
      }
      ++v5;
    }
    while (v5 < *((unsigned int *)this + 210));
  }
  *((_WORD *)this + 460) = 1;
  *((_DWORD *)this + 222) = 0;
  *((_DWORD *)this + 221) = 0;
  v15 = *((_QWORD *)this + 101);
  if (v15 && *((_QWORD *)this + 102))
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 160))(v15);
  *((_QWORD *)this + 136) = 0;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *((int32x2_t *)this + 133) = vdup_n_s32(0xC9742400);
  return 0;
}

uint64_t IntNovDetectE::process(uint64_t a1, const char *a2, signed int a3, _BYTE *a4, _BYTE *a5, uint64_t a6)
{
  uint64_t result;
  int v11;
  int v12;
  const char *v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  BOOL v19;
  unsigned int v20;
  int v21;
  int v22;
  float v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;

  if (*(_DWORD *)a1 != 1)
    Error::chuck((Error *)"NovDetectE: process() can only be called after initialize()", a2);
  if (*(_BYTE *)(a1 + 1073))
    return 0xFFFFFFFFLL;
  v11 = *(_DWORD *)(a1 + 1052);
  v12 = *(_DWORD *)(a1 + 1040);
  if (a3 < 1)
  {
    v15 = *(_DWORD *)(a1 + 1052);
  }
  else
  {
    v13 = a2;
    do
    {
      v14 = a3 - v12;
      if (a3 >= v12)
        a3 = v12;
      IntNovDetectE::wavedata((IntNovDetectE *)a1, v13, a3);
      v13 += 2 * v12;
      a3 = v14;
    }
    while (v14 > 0);
    v15 = *(_DWORD *)(a1 + 1052);
    v12 = *(_DWORD *)(a1 + 1040);
  }
  result = 0;
  v16 = *(_DWORD *)(a1 + 1056);
  v17 = *(_DWORD *)(a1 + 1060);
  v18 = v16 >= v17;
  v20 = v16 - v17;
  v19 = v20 != 0 && v18;
  v21 = *(_DWORD *)(a1 + 1044) + v12 * v16;
  v22 = v20 * v12;
  if (!v19)
    v22 = 0;
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 1048);
  *(_DWORD *)(a6 + 4) = v22;
  *(_DWORD *)(a6 + 8) = v21;
  v23 = *(float *)(a1 + 1064);
  *(float *)(a6 + 12) = v23;
  *(_BYTE *)(a6 + 16) = 0;
  *a4 = 0;
  *a5 = 0;
  v24 = v15 - v11;
  if (v24)
  {
    v25 = *(_DWORD *)(a1 + 1088);
    if (v23 <= *(float *)(a1 + 1076))
    {
      if (v25 < 1)
        goto LABEL_21;
      v27 = v25 - v24;
      *(_DWORD *)(a1 + 1088) = v27;
      if (v27 <= 0)
        goto LABEL_21;
    }
    else
    {
      if (v25 <= 0)
        *a4 = 1;
      v26 = *(_DWORD *)(a1 + 1084);
      *(_DWORD *)(a1 + 1088) = v26;
      *(_QWORD *)(a1 + 1056) = 0;
      *(int32x2_t *)(a1 + 1064) = vdup_n_s32(0xC9742400);
      if (v26 <= 0)
      {
LABEL_21:
        if (*(float *)(a1 + 1068) > *(float *)(a1 + 1080))
        {
          if (*(int *)(a1 + 1092) <= 0)
            *a5 = 1;
          result = 0;
          *(_DWORD *)(a1 + 1092) = *(_DWORD *)(a1 + 1084);
          *(_DWORD *)(a1 + 1068) = -915135488;
          return result;
        }
      }
    }
    v28 = *(_DWORD *)(a1 + 1092);
    result = 0;
    if (v28 >= 1)
      *(_DWORD *)(a1 + 1092) = v28 - v24;
  }
  return result;
}

uint64_t IntNovDetectE::wavedata(IntNovDetectE *this, const char *a2, unsigned int a3)
{
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;

  v5 = *((_DWORD *)this + 262);
  v6 = v5 + a3;
  *((_DWORD *)this + 262) = v5 + a3;
  if (!__CFADD__(v5, a3))
  {
    v20 = a3;
    NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), a2, &v20);
    if (!*((_BYTE *)this + 668))
      return 0;
LABEL_19:
    IntNovDetectE::feedFrameToNorm((int32x2_t *)this, (IntNovDetectE *)((char *)this + 560));
    return 0;
  }
  v7 = -v5;
  v21 = -v5;
  v22 = v5 + a3;
  NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), a2, &v21);
  *((_DWORD *)this + 248) = -8388609;
  *(_QWORD *)((char *)this + 1004) = 0;
  *(_QWORD *)((char *)this + 996) = 0;
  if (*((_DWORD *)this + 210))
  {
    v8 = 0;
    v9 = *((_QWORD *)this + 104);
    do
    {
      v10 = v9 + 136 * v8;
      v12 = *(_DWORD *)(v10 + 72);
      v11 = (unsigned int *)(v10 + 72);
      if (v12)
      {
        v13 = v9 + 136 * v8;
        v14 = *(_DWORD **)(v13 + 88);
        *v14 = 0;
        v15 = *(_DWORD **)(v13 + 112);
        *v15 = 0;
        if (*v11)
        {
          v16 = 1;
          do
          {
            v17 = v16;
            v14[v17] = -8388609;
            v15[v17] = 0;
            ++v16;
          }
          while (v16 <= *v11);
        }
      }
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 210));
  }
  *((_WORD *)this + 460) = 1;
  *((_DWORD *)this + 222) = 0;
  *((_DWORD *)this + 221) = 0;
  v18 = *((_QWORD *)this + 101);
  if (v18 && *((_QWORD *)this + 102))
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 160))(v18);
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
  *((_QWORD *)this + 65) = 0;
  *((_BYTE *)this + 516) = 0;
  if (*((_BYTE *)this + 1072))
    NLocalCepNorm::resync((void **)this + 89);
  *((_QWORD *)this + 131) = 0;
  NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), &a2[2 * v7], &v22);
  *((_DWORD *)this + 262) += v6;
  if (*((_BYTE *)this + 668))
    goto LABEL_19;
  return 0;
}

uint64_t IntNovDetectE::feedFrameToNorm(int32x2_t *this, const NFrame *a2)
{
  int v3;
  __int32 v4;
  __int32 v5;

  if (!this[134].i8[0])
  {
    NDEHMMDetector::feedFrame((NDEHMMDetector *)&this[100], a2);
    IntNovDetectE::advanceDetectionAfterFeed((uint64_t)this);
    return 1;
  }
  NLocalCepNorm::pushFrame(this + 89, a2);
  v3 = this[99].u8[4];
  v4 = this[91].i32[0];
  v5 = v4;
  if (this[99].i8[4])
  {
    if (v4)
      goto LABEL_9;
    v5 = 0;
  }
  if (v5 == this[92].i32[1] + 1)
  {
LABEL_9:
    while (v3 && v4 || v4 == this[92].i32[1] + 1)
    {
      NLocalCepNorm::setOutputFrame((NLocalCepNorm *)&this[89], (NFrame *)&this[127]);
      NDEHMMDetector::feedFrame((NDEHMMDetector *)&this[100], (const NFrame *)&this[127]);
      IntNovDetectE::advanceDetectionAfterFeed((uint64_t)this);
      v3 = this[99].u8[4];
      v4 = this[91].i32[0];
    }
    return 1;
  }
  return 0;
}

uint64_t IntNovDetectE::advanceDetectionAfterFeed(uint64_t this)
{
  int v1;
  int v2;
  float v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  float v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v12;
  float v13;
  unsigned int v14;
  float v15;

  v1 = *(_DWORD *)(this + 1052) + 1;
  *(_DWORD *)(this + 1052) = v1;
  v2 = *(unsigned __int8 *)(this + 1075);
  if (*(_BYTE *)(this + 1075))
    v3 = (float)*(unsigned int *)(this + 656) / (float)*(unsigned int *)(this + 664);
  else
    v3 = 100.0;
  v4 = 0;
  v5 = 0;
  v6 = *(unsigned int *)(this + 840);
  v7 = 0.0;
  while (v6 != v5)
  {
    if (v5 < v6)
    {
      v8 = *(_DWORD *)(this + 1004);
      v9 = *(_QWORD *)(this + 832);
      v10 = *(unsigned int *)(v9 + v4 + 72);
      v11 = v8 - *(_DWORD *)(*(_QWORD *)(v9 + v4 + 112) + 4 * v10);
      if (v11)
      {
        v12 = *(float *)(*(_QWORD *)(v9 + v4 + 88) + 4 * v10) * (float)(*(_DWORD *)(this + 936) + 1);
        if (*(_BYTE *)(this + 1074))
          v12 = v12 / (float)v11;
        v13 = v12 + *(float *)(v9 + v4 + 128);
        if (v2 && (v5 & 1) == 0)
        {
          v7 = v13;
        }
        else if (v13 > *(float *)(this + 1064))
        {
          if (v2)
          {
            v11 = ((float)(v3 * fmaxf(v7, 0.0)) + 0.5);
            v7 = 0.0;
          }
          *(_DWORD *)(this + 1056) = v1
                                   - ((*(_DWORD *)(this + 1000) - v8 + *(_DWORD *)(this + 940)) & ~((*(_DWORD *)(this + 1000) - v8 + *(_DWORD *)(this + 940)) >> 31));
          *(_DWORD *)(this + 1060) = v11;
          *(float *)(this + 1064) = v13;
        }
      }
    }
    ++v5;
    v4 += 136;
  }
  if (*(_DWORD *)(this + 932))
  {
    v14 = *(_DWORD *)(this + 1004) - *(_DWORD *)(this + 996);
    if (v14)
    {
      v15 = *(float *)(this + 992);
      if (*(_BYTE *)(this + 1074))
        v15 = v15 / (float)v14;
      if (v15 > *(float *)(this + 1068))
        *(float *)(this + 1068) = v15;
    }
  }
  return this;
}

float IntNovDetectE::getResult(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  unsigned int v8;
  int v9;
  float result;

  v2 = *(_DWORD *)(a1 + 1056);
  v3 = *(_DWORD *)(a1 + 1040);
  v4 = *(_DWORD *)(a1 + 1044);
  v5 = *(_DWORD *)(a1 + 1060);
  v6 = v2 >= v5;
  v8 = v2 - v5;
  v7 = v8 != 0 && v6;
  v9 = v8 * v3;
  if (!v7)
    v9 = 0;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 1048);
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)(a2 + 8) = v4 + v3 * v2;
  result = *(float *)(a1 + 1064);
  *(float *)(a2 + 12) = result;
  *(_BYTE *)(a2 + 16) = 0;
  return result;
}

uint64_t IntNovDetectE::setTriggerSignal(uint64_t this, BOOL *a2, BOOL *a3, const unsigned int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  *a2 = 0;
  *a3 = 0;
  if (!*a4)
    return this;
  v4 = *(_DWORD *)(this + 1088);
  if (*(float *)(this + 1064) <= *(float *)(this + 1076))
  {
    if (v4 >= 1)
    {
      v6 = v4 - *a4;
      *(_DWORD *)(this + 1088) = v6;
      if (v6 > 0)
        goto LABEL_13;
    }
  }
  else
  {
    if (v4 <= 0)
      *a2 = 1;
    v5 = *(_DWORD *)(this + 1084);
    *(_DWORD *)(this + 1088) = v5;
    *(_QWORD *)(this + 1056) = 0;
    *(int32x2_t *)(this + 1064) = vdup_n_s32(0xC9742400);
    if (v5 > 0)
      goto LABEL_13;
  }
  if (*(float *)(this + 1068) > *(float *)(this + 1080))
  {
    if (*(int *)(this + 1092) <= 0)
      *a3 = 1;
    *(_DWORD *)(this + 1092) = *(_DWORD *)(this + 1084);
    *(_DWORD *)(this + 1068) = -915135488;
    return this;
  }
LABEL_13:
  v7 = *(_DWORD *)(this + 1092);
  if (v7 >= 1)
    *(_DWORD *)(this + 1092) = v7 - *a4;
  return this;
}

uint64_t IntNovDetectE::processframe(uint64_t a1, float32x4_t *a2, unsigned int a3, _BYTE *a4, _BYTE *a5, uint64_t a6)
{
  int v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  int v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  BOOL v28;
  BOOL v29;
  unsigned int v30;
  int v31;
  float v32;
  int v33;
  int v34;
  BOOL v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;

  if (*(_DWORD *)a1 != 1)
    Error::chuck((Error *)"NovDetectE: process() can only be called after initialize()", (const char *)a2);
  if (!*(_BYTE *)(a1 + 1073))
    return 0xFFFFFFFFLL;
  v10 = *(_DWORD *)(a1 + 1048);
  v11 = *(_DWORD *)(a1 + 1040);
  *(_DWORD *)(a1 + 1048) = v11 + v10;
  if (__CFADD__(v11, v10))
  {
    *(_DWORD *)(a1 + 992) = -8388609;
    *(_QWORD *)(a1 + 1004) = 0;
    *(_QWORD *)(a1 + 996) = 0;
    if (*(_DWORD *)(a1 + 840))
    {
      v12 = 0;
      v13 = *(_QWORD *)(a1 + 832);
      do
      {
        v14 = v13 + 136 * v12;
        v16 = *(_DWORD *)(v14 + 72);
        v15 = (unsigned int *)(v14 + 72);
        if (v16)
        {
          v17 = v13 + 136 * v12;
          v18 = *(_DWORD **)(v17 + 88);
          *v18 = 0;
          v19 = *(_DWORD **)(v17 + 112);
          *v19 = 0;
          if (*v15)
          {
            v20 = 1;
            do
            {
              v21 = v20;
              v18[v21] = -8388609;
              v19[v21] = 0;
              ++v20;
            }
            while (v20 <= *v15);
          }
        }
        ++v12;
      }
      while (v12 < *(unsigned int *)(a1 + 840));
    }
    *(_WORD *)(a1 + 920) = 1;
    *(_DWORD *)(a1 + 888) = 0;
    *(_DWORD *)(a1 + 884) = 0;
    v23 = *(_QWORD *)(a1 + 808);
    if (v23 && *(_QWORD *)(a1 + 816))
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 160))(v23);
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 512) = *(_DWORD *)(a1 + 496) + 1;
    *(_QWORD *)(a1 + 520) = 0;
    *(_BYTE *)(a1 + 516) = 0;
    if (*(_BYTE *)(a1 + 1072))
      NLocalCepNorm::resync((void **)(a1 + 712));
    *(_DWORD *)(a1 + 1052) = 0;
  }
  else
  {
    v39 = a3;
    NDEFrameProc::apply((NDEFrameProc *)(a1 + 672), a2, &v39);
    IntNovDetectE::feedFrameToNorm((int32x2_t *)a1, (const NFrame *)(a1 + 672));
  }
  v24 = *(_DWORD *)(a1 + 1056);
  v25 = *(_DWORD *)(a1 + 1040);
  v26 = *(_DWORD *)(a1 + 1044);
  v27 = *(_DWORD *)(a1 + 1060);
  v28 = v24 >= v27;
  v30 = v24 - v27;
  v29 = v30 != 0 && v28;
  v31 = v30 * v25;
  if (!v29)
    v31 = 0;
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 1048);
  *(_DWORD *)(a6 + 4) = v31;
  *(_DWORD *)(a6 + 8) = v26 + v25 * v24;
  v32 = *(float *)(a1 + 1064);
  *(float *)(a6 + 12) = v32;
  *(_BYTE *)(a6 + 16) = 0;
  *a4 = 0;
  *a5 = 0;
  v33 = *(_DWORD *)(a1 + 1088);
  if (v32 <= *(float *)(a1 + 1076))
  {
    v35 = __OFSUB__(v33, 1);
    v36 = v33 - 1;
    if (v36 < 0 == v35)
    {
      *(_DWORD *)(a1 + 1088) = v36;
      if (v36 > 0)
        goto LABEL_33;
    }
  }
  else
  {
    if (v33 <= 0)
      *a4 = 1;
    v34 = *(_DWORD *)(a1 + 1084);
    *(_DWORD *)(a1 + 1088) = v34;
    *(_QWORD *)(a1 + 1056) = 0;
    *(int32x2_t *)(a1 + 1064) = vdup_n_s32(0xC9742400);
    if (v34 > 0)
      goto LABEL_33;
  }
  if (*(float *)(a1 + 1068) > *(float *)(a1 + 1080))
  {
    if (*(int *)(a1 + 1092) <= 0)
      *a5 = 1;
    result = 0;
    *(_DWORD *)(a1 + 1092) = *(_DWORD *)(a1 + 1084);
    *(_DWORD *)(a1 + 1068) = -915135488;
    return result;
  }
LABEL_33:
  v37 = *(_DWORD *)(a1 + 1092);
  result = 0;
  v35 = __OFSUB__(v37, 1);
  v38 = v37 - 1;
  if (v38 < 0 == v35)
    *(_DWORD *)(a1 + 1092) = v38;
  return result;
}

uint64_t IntNovDetectE::framedata(IntNovDetectE *this, float32x4_t *a2, unsigned int a3)
{
  int v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v18;

  v4 = *((_DWORD *)this + 262);
  v5 = *((_DWORD *)this + 260);
  *((_DWORD *)this + 262) = v5 + v4;
  if (__CFADD__(v5, v4))
  {
    *((_DWORD *)this + 248) = -8388609;
    *(_QWORD *)((char *)this + 1004) = 0;
    *(_QWORD *)((char *)this + 996) = 0;
    if (*((_DWORD *)this + 210))
    {
      v6 = 0;
      v7 = *((_QWORD *)this + 104);
      do
      {
        v8 = v7 + 136 * v6;
        v10 = *(_DWORD *)(v8 + 72);
        v9 = (unsigned int *)(v8 + 72);
        if (v10)
        {
          v11 = v7 + 136 * v6;
          v12 = *(_DWORD **)(v11 + 88);
          *v12 = 0;
          v13 = *(_DWORD **)(v11 + 112);
          *v13 = 0;
          if (*v9)
          {
            v14 = 1;
            do
            {
              v15 = v14;
              v12[v15] = -8388609;
              v13[v15] = 0;
              ++v14;
            }
            while (v14 <= *v9);
          }
        }
        ++v6;
      }
      while (v6 < *((unsigned int *)this + 210));
    }
    *((_WORD *)this + 460) = 1;
    *((_DWORD *)this + 222) = 0;
    *((_DWORD *)this + 221) = 0;
    v16 = *((_QWORD *)this + 101);
    if (v16 && *((_QWORD *)this + 102))
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 160))(v16);
    *((_DWORD *)this + 22) = 0;
    *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
    *((_QWORD *)this + 65) = 0;
    *((_BYTE *)this + 516) = 0;
    if (*((_BYTE *)this + 1072))
      NLocalCepNorm::resync((void **)this + 89);
    *((_DWORD *)this + 263) = 0;
  }
  else
  {
    v18 = a3;
    NDEFrameProc::apply((IntNovDetectE *)((char *)this + 672), a2, &v18);
    IntNovDetectE::feedFrameToNorm((int32x2_t *)this, (IntNovDetectE *)((char *)this + 672));
  }
  return 0;
}

uint64_t IntNovDetectE::resetbest(int32x2_t *this)
{
  this[132] = 0;
  this[133] = vdup_n_s32(0xC9742400);
  return 0;
}

uint64_t IntNovDetectE::handleWavedataOverflow(IntNovDetectE *this, const char *a2, const int *a3)
{
  unsigned int v5;
  unsigned int v6;
  NDEAcAnal *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  unsigned int v20;
  unsigned int v21;

  v5 = *((_DWORD *)this + 262);
  v6 = *a3 - v5;
  v20 = v6;
  v21 = v5;
  v7 = (IntNovDetectE *)((char *)this + 8);
  NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), a2, &v20);
  *((_DWORD *)this + 248) = -8388609;
  *(_QWORD *)((char *)this + 1004) = 0;
  *(_QWORD *)((char *)this + 996) = 0;
  if (*((_DWORD *)this + 210))
  {
    v8 = 0;
    v9 = *((_QWORD *)this + 104);
    do
    {
      v10 = v9 + 136 * v8;
      v12 = *(_DWORD *)(v10 + 72);
      v11 = (unsigned int *)(v10 + 72);
      if (v12)
      {
        v13 = v9 + 136 * v8;
        v14 = *(_DWORD **)(v13 + 88);
        *v14 = 0;
        v15 = *(_DWORD **)(v13 + 112);
        *v15 = 0;
        if (*v11)
        {
          v16 = 1;
          do
          {
            v17 = v16;
            v14[v17] = -8388609;
            v15[v17] = 0;
            ++v16;
          }
          while (v16 <= *v11);
        }
      }
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 210));
  }
  *((_WORD *)this + 460) = 1;
  *((_DWORD *)this + 222) = 0;
  *((_DWORD *)this + 221) = 0;
  v18 = *((_QWORD *)this + 101);
  if (v18 && *((_QWORD *)this + 102))
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 160))(v18);
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
  *((_QWORD *)this + 65) = 0;
  *((_BYTE *)this + 516) = 0;
  if (*((_BYTE *)this + 1072))
    NLocalCepNorm::resync((void **)this + 89);
  *((_QWORD *)this + 131) = 0;
  result = NDEAcAnal::feedFromInt(v7, &a2[2 * v6], &v21);
  *((_DWORD *)this + 262) += v5;
  return result;
}

void IntNovDetectE::feedFrameToDetector(IntNovDetectE *this, const NFrame *a2)
{
  NDEHMMDetector::feedFrame((IntNovDetectE *)((char *)this + 800), a2);
}

uint64_t __Block_byref_object_copy__1931(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1932(uint64_t a1)
{

}

uint64_t _AssistantPrefsChangedNotification(uint64_t a1, void *a2)
{
  int v3;
  NSObject *v4;
  const __CFString *v5;
  int v7;
  const __CFString *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v3 = AFPreferencesAssistantEnabled();
  v4 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    v5 = CFSTR("Disabled");
    if (v3)
      v5 = CFSTR("Enabled");
    v7 = 138543362;
    v8 = v5;
    _os_log_impl(&dword_20D965000, v4, OS_LOG_TYPE_DEFAULT, "Siri Enabled = %{public}@", (uint8_t *)&v7, 0xCu);
  }
  return objc_msgSend(a2, "_didReceiveSiriSettingChanged:", v3 != 0);
}

void NLocalCepNorm::NLocalCepNorm(NLocalCepNorm *this)
{
  int v1;

  *((_QWORD *)this + 4) = &off_24C7F2DB8;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = &off_24C7F31A8;
  *((_DWORD *)this + 20) = 1065353048;
  *((_BYTE *)this + 84) = 0;
  v1 = 1;
  NArray<NFrame>::resize((uint64_t)this + 32, &v1);
}

{
  int v1;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = &off_24C7F2DB8;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = &off_24C7F31A8;
  *((_DWORD *)this + 20) = 1065353048;
  *((_BYTE *)this + 84) = 0;
  v1 = 1;
  NArray<NFrame>::resize((uint64_t)this + 32, &v1);
}

void sub_20D9A7B58(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *(_QWORD *)(v2 + 56) = &off_24C7F3090;
  v4 = *(_QWORD *)(v2 + 64);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  NArray<NFrame>::~NArray(v1);
  _Unwind_Resume(a1);
}

void sub_20D9A7C18(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = v1;
  *(_QWORD *)(v3 + 56) = &off_24C7F3090;
  v5 = v3;
  v6 = *(_QWORD *)(v3 + 64);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  *(_QWORD *)(v5 + 32) = v2;
  v7 = *(_QWORD *)(v5 + 40);
  if (v7)
  {
    v8 = *(_QWORD *)(v7 - 8);
    if (v8)
    {
      v9 = 24 * v8;
      do
      {
        *(_QWORD *)(v7 + v9 - 24) = &off_24C7F3090;
        v10 = *(_QWORD *)(v7 + v9 - 16);
        if (v10)
          MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
        v9 -= 24;
      }
      while (v9);
    }
    MEMORY[0x212BAC9C0](v7 - 16, 0x1081C80622C3295);
  }
  _Unwind_Resume(exception_object);
}

void NLocalCepNorm::configure(NLocalCepNorm *this, char *a2, unsigned int *a3, float *a4, unsigned int *a5, const unsigned int *a6)
{
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  __int128 *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  int *v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;

  v9 = *a5;
  if (*a5 == -1)
  {
    v10 = 0;
  }
  else if (v9 == -2)
  {
    if ((*(_DWORD *)a2 & 1) == 0)
      Error::chuck((Error *)"NLocalCepNorm::configure() - only an odd number of frames supported", a2, a3, a4);
    v10 = *(_DWORD *)a2 >> 1;
  }
  else
  {
    v11 = *(unsigned int *)a2;
    if (v9 >= v11)
      Error::chuck((Error *)"NLocalCepNorm::configure() - offset %d lies outside window %d", a2, a3, a4, *a5, v11);
    v10 = v11 + ~v9;
  }
  *(_DWORD *)this = v10;
  v12 = *(unsigned int *)a2;
  if (*((_DWORD *)this + 2) > v12)
    Error::chuck((Error *)"NLocalCepNorm::configure() - minframes %d cannot exceed total buffer size %d", a2, a3, a4, *((unsigned int *)this + 2), v12);
  *((_DWORD *)this + 2) = *a6;
  *((_DWORD *)this + 1) = *a3;
  *((float *)this + 20) = *a4;
  NArray<NFrame>::resize((uint64_t)this + 32, a2);
  v13 = *((_DWORD *)this + 18);
  if (v13 != *a3)
  {
    v14 = *((_QWORD *)this + 8);
    *((_DWORD *)this + 18) = *a3;
    v15 = operator new[]();
    *((_QWORD *)this + 8) = v15;
    LODWORD(v16) = *a3;
    if (v13 >= *a3)
      v16 = v16;
    else
      v16 = v13;
    if ((_DWORD)v16)
    {
      v17 = 0;
      if (v16 < 8)
        goto LABEL_19;
      if ((unint64_t)(v15 - v14) <= 0x1F)
        goto LABEL_19;
      v17 = v16 & 0xFFFFFFF8;
      v18 = (_OWORD *)(v15 + 16);
      v19 = (__int128 *)(v14 + 16);
      v20 = v17;
      do
      {
        v21 = *v19;
        *(v18 - 1) = *(v19 - 1);
        *v18 = v21;
        v18 += 2;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v17 != v16)
      {
LABEL_19:
        v22 = v16 - v17;
        v23 = 4 * v17;
        v24 = (_DWORD *)(v15 + 4 * v17);
        v25 = (int *)(v14 + v23);
        do
        {
          v26 = *v25++;
          *v24++ = v26;
          --v22;
        }
        while (v22);
      }
    }
    else if (!v14)
    {
      goto LABEL_24;
    }
    MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
  }
LABEL_24:
  if (*(_DWORD *)a2)
  {
    v27 = 0;
    v28 = 0;
    do
    {
      (*(void (**)(uint64_t, unsigned int *))(*(_QWORD *)(*((_QWORD *)this + 5) + v27) + 32))(*((_QWORD *)this + 5) + v27, a3);
      ++v28;
      v27 += 24;
    }
    while (v28 < *(unsigned int *)a2);
  }
  *((_BYTE *)this + 84) = 0;
  *(_QWORD *)((char *)this + 20) = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  v29 = *(_DWORD *)this;
  *((_DWORD *)this + 7) = *(_DWORD *)this;
  v30 = *((_DWORD *)this + 2);
  if (v30 > v29 + 1)
    *((_DWORD *)this + 7) = v30 - 1;
  v31 = *((unsigned int *)this + 1);
  if ((_DWORD)v31)
    bzero(*((void **)this + 8), 4 * v31);
}

void NLocalCepNorm::reset(NLocalCepNorm *this)
{
  int v1;
  unsigned int v2;
  uint64_t v3;

  *((_BYTE *)this + 84) = 0;
  *(_QWORD *)((char *)this + 20) = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  v1 = *(_DWORD *)this;
  *((_DWORD *)this + 7) = *(_DWORD *)this;
  v2 = *((_DWORD *)this + 2);
  if (v2 > v1 + 1)
    *((_DWORD *)this + 7) = v2 - 1;
  v3 = *((unsigned int *)this + 1);
  if ((_DWORD)v3)
    bzero(*((void **)this + 8), 4 * v3);
}

void NLocalCepNorm::resync(void **this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD *v7;
  float *v8;
  float v9;
  float *v10;
  uint64_t v11;
  float *v12;
  int v13;
  float *v14;
  float32x4_t *v16;
  float32x4_t *v17;
  uint64_t v18;
  float32x4_t v19;
  float *v20;
  uint64_t v21;
  float v22;
  int v23;
  float32x4_t *v24;
  float32x4_t *v26;
  float32x4_t *v27;
  uint64_t v28;
  float32x4_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  float *v34;
  float v35;

  if (!*((_BYTE *)this + 84))
  {
    v2 = *((unsigned int *)this + 1);
    if ((_DWORD)v2)
      bzero(this[8], 4 * v2);
    v3 = *((_DWORD *)this + 5);
    v4 = *((_DWORD *)this + 3);
    if (v3 <= v4)
    {
      if (!v3)
        return;
      v5 = *((_DWORD *)this + 12);
      if (!(_DWORD)v2)
        return;
    }
    else
    {
      v5 = *((_DWORD *)this + 12);
      v4 += v5;
      if (!(_DWORD)v2)
        return;
    }
    v6 = v4 - v3;
    v7 = this[5];
    v8 = (float *)this[8];
    if (v2 > 7)
    {
      v11 = v2;
      v12 = &v8[v2];
      if ((v2 & 0xFFFFFFF8) == v2)
      {
        v13 = 0;
        do
        {
          v14 = (float *)v7[3 * v6 + 1];
          if (v8 >= &v14[v11] || v14 >= v12)
          {
            v16 = (float32x4_t *)(v14 + 4);
            v17 = (float32x4_t *)(v8 + 4);
            v18 = v2 & 0xFFFFFFF8;
            do
            {
              v19 = vaddq_f32(*v16, *v17);
              v17[-1] = vaddq_f32(v16[-1], v17[-1]);
              *v17 = v19;
              v17 += 2;
              v16 += 2;
              v18 -= 8;
            }
            while (v18);
          }
          else
          {
            v20 = v8;
            v21 = v2;
            do
            {
              v22 = *v14++;
              *v20 = v22 + *v20;
              ++v20;
              --v21;
            }
            while (v21);
          }
          if (v6 + 1 < v5)
            ++v6;
          else
            v6 = 0;
          ++v13;
        }
        while (v13 != v3);
      }
      else
      {
        v23 = 0;
        do
        {
          v24 = (float32x4_t *)v7[3 * v6 + 1];
          if (v8 >= &v24->f32[v11] || v24 >= (float32x4_t *)v12)
          {
            v26 = v24 + 1;
            v27 = (float32x4_t *)(v8 + 4);
            v28 = v2 & 0xFFFFFFF8;
            do
            {
              v29 = vaddq_f32(*v26, *v27);
              v27[-1] = vaddq_f32(v26[-1], v27[-1]);
              *v27 = v29;
              v27 += 2;
              v26 += 2;
              v28 -= 8;
            }
            while (v28);
            v30 = v2 & 0xFFFFFFF8;
          }
          else
          {
            v30 = 0;
          }
          v31 = v2 - v30;
          v32 = v30;
          v33 = &v8[v30];
          v34 = &v24->f32[v32];
          do
          {
            v35 = *v34++;
            *v33 = v35 + *v33;
            ++v33;
            --v31;
          }
          while (v31);
          if (v6 + 1 < v5)
            ++v6;
          else
            v6 = 0;
          ++v23;
        }
        while (v23 != v3);
      }
    }
    else
    {
      v9 = *v8;
      do
      {
        v10 = (float *)v7[3 * v6 + 1];
        v9 = *v10 + v9;
        *v8 = v9;
        if ((_DWORD)v2 != 1)
        {
          v8[1] = v10[1] + v8[1];
          if ((_DWORD)v2 != 2)
          {
            v8[2] = v10[2] + v8[2];
            if ((_DWORD)v2 != 3)
            {
              v8[3] = v10[3] + v8[3];
              if ((_DWORD)v2 != 4)
              {
                v8[4] = v10[4] + v8[4];
                if ((_DWORD)v2 != 5)
                {
                  v8[5] = v10[5] + v8[5];
                  if ((_DWORD)v2 != 6)
                    v8[6] = v10[6] + v8[6];
                }
              }
            }
          }
        }
        if (v6 + 1 < v5)
          ++v6;
        else
          v6 = 0;
        --v3;
      }
      while (v3);
    }
  }
}

unsigned int *NLocalCepNorm::endFrames(unsigned int *this, const char *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  if (*((_BYTE *)this + 84))
    Error::chuck((Error *)"NLocalCepNorm::endFrames() - endFrames() already called", a2);
  v2 = this[7];
  if (this[4] > v2)
    Error::chuck((Error *)"NLocalCepNorm::endFrames() - buffer full", a2);
  v3 = this[5];
  v4 = this[12];
  if (v3 >= v4)
    Error::chuck((Error *)"NLocalCepNorm::endFrames() - buffer full - redundant test", a2);
  v5 = v4 + ~v3;
  this[6] = v5;
  v6 = v4 + ~v2;
  if (v5 <= v6)
  {
    v6 = v5;
  }
  else
  {
    v7 = this[3];
    do
    {
      if (v7 + 1 < v4)
        ++v7;
      else
        v7 = 0;
      --v5;
    }
    while (v5 > v6);
    this[3] = v7;
    this[6] = v6;
  }
  v8 = *this;
  if (v2 > *this)
  {
    v9 = this[3];
    v10 = v2;
    do
    {
      if (--v9 >= v4)
        v9 = v4 - 1;
      --v10;
    }
    while (v10 > v8);
    this[3] = v9;
    this[6] = v2 + v6 - v8;
    this[7] = v8;
  }
  *((_BYTE *)this + 84) = 1;
  return this;
}

int32x2_t NLocalCepNorm::pushFrame(int32x2_t *this, const NFrame *a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;
  __int32 v20;
  __int32 v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  BOOL v25;
  uint64_t v26;
  float32x4_t *v27;
  float32x4_t *v28;
  uint64_t v29;
  float32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  float *v34;
  float v35;
  int32x2_t result;

  v2 = *((_DWORD *)a2 + 4);
  if (v2 != this->i32[1])
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - mismatched input frame size", (const char *)a2);
  if (this[10].i8[4])
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - endFrames() already called", (const char *)a2);
  if (this[2].i32[0] > (unsigned __int32)this[3].i32[1])
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - buffer full", (const char *)a2);
  if (this[2].i32[1] >= (unsigned __int32)this[6].i32[0])
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - buffer full - redundant test", (const char *)a2);
  v5 = *(_QWORD *)&this[5] + 24 * this[1].u32[1];
  if ((const NFrame *)v5 != a2)
  {
    if (*(_DWORD *)(v5 + 16) != v2)
    {
      v6 = *(_QWORD *)(v5 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v2 = *((_DWORD *)a2 + 4);
      }
      *(_DWORD *)(v5 + 16) = v2;
      *(_QWORD *)(v5 + 8) = operator new[]();
      v2 = *(_DWORD *)(v5 + 16);
    }
    if (v2)
    {
      v7 = 0;
      v8 = *((_QWORD *)a2 + 1);
      v9 = *(_QWORD *)(v5 + 8);
      v10 = v2;
      if (v2 < 8)
        goto LABEL_16;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_16;
      v7 = v2 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF8;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_16:
        v15 = v10 - v7;
        v16 = 4 * v7;
        v17 = (_DWORD *)(v9 + v16);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  v20 = this[1].i32[1];
  if ((v20 + 1) < this[6].i32[0])
    v21 = v20 + 1;
  else
    v21 = 0;
  this[1].i32[1] = v21;
  v22 = this->u32[1];
  if ((_DWORD)v22)
  {
    v23 = *((_QWORD *)a2 + 1);
    v24 = (unint64_t)this[8];
    if (v22 <= 7 || (v24 < v23 + 4 * v22 ? (v25 = v23 >= v24 + 4 * v22) : (v25 = 1), !v25))
    {
      v26 = 0;
LABEL_33:
      v31 = v22 - v26;
      v32 = 4 * v26;
      v33 = (float *)(v24 + v32);
      v34 = (float *)(v23 + v32);
      do
      {
        v35 = *v34++;
        *v33 = v35 + *v33;
        ++v33;
        --v31;
      }
      while (v31);
      goto LABEL_35;
    }
    v26 = v22 & 0xFFFFFFF8;
    v27 = (float32x4_t *)(v24 + 16);
    v28 = (float32x4_t *)(v23 + 16);
    v29 = v26;
    do
    {
      v30 = vaddq_f32(*v28, *v27);
      v27[-1] = vaddq_f32(v28[-1], v27[-1]);
      *v27 = v30;
      v27 += 2;
      v28 += 2;
      v29 -= 8;
    }
    while (v29);
    if (v26 != v22)
      goto LABEL_33;
  }
LABEL_35:
  result = vadd_s32(this[2], (int32x2_t)0x100000001);
  this[2] = result;
  return result;
}

BOOL NLocalCepNorm::frameReady(NLocalCepNorm *this)
{
  int v1;

  v1 = *((_DWORD *)this + 4);
  return *((_BYTE *)this + 84) && v1 || v1 == *((_DWORD *)this + 7) + 1;
}

uint64_t NLocalCepNorm::setOutputFrame(NLocalCepNorm *this, NFrame *a2)
{
  unint64_t v2;
  _BYTE *v5;
  int v6;
  int v7;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t result;
  float32x4_t v14;
  uint64_t v15;
  double v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t *v19;
  uint64_t v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  uint64_t v24;
  float32x4_t v25;
  uint64_t v26;
  uint64_t v27;
  float *v28;
  float *v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  int v34;
  unsigned int v35;
  float *v36;
  double v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float *v44;
  float *v45;
  float v46;
  float v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v51;
  float32x4_t *v52;
  float32x4_t *v53;
  uint64_t v54;
  float32x4_t v55;
  uint64_t v56;
  uint64_t v57;
  float *v58;
  float *v59;
  float v60;
  int v61;
  unsigned int v62;
  unint64_t v63;
  BOOL v65;
  float64x2_t v70;
  float32x4_t *v71;
  float32x2_t *v72;
  uint64_t v73;
  float32x4_t v74;

  v5 = (char *)this + 84;
  v6 = *((_DWORD *)this + 4);
  if (*((_BYTE *)this + 84))
  {
    v7 = *((_DWORD *)this + 7);
    if (v6)
      _ZF = 1;
    else
      _ZF = v7 == -1;
    if (!_ZF)
LABEL_71:
      Error::chuck((Error *)"NLocalCepNorm::setOutputFrame() - buffer empty", (const char *)a2);
    v9 = *((_DWORD *)this + 3);
    v10 = *((_DWORD *)this + 12);
    if (v9 + 1 < v10)
      v11 = v9 + 1;
    else
      v11 = 0;
    *((_DWORD *)this + 3) = v11;
  }
  else
  {
    v7 = *((_DWORD *)this + 7);
    if (v6 != v7 + 1)
      goto LABEL_71;
    v10 = *((_DWORD *)this + 12);
    v11 = *((_DWORD *)this + 3);
  }
  LODWORD(v2) = *((_DWORD *)this + 5);
  v12 = *((_QWORD *)this + 5);
  result = (*(uint64_t (**)(NFrame *, char *))(*(_QWORD *)a2 + 32))(a2, (char *)this + 4);
  v15 = *((unsigned int *)this + 1);
  if ((_DWORD)v15)
  {
    v14.i64[0] = 1.0;
    v16 = 1.0 / (double)v2;
    *(float *)&v16 = v16;
    v17 = *(float32x4_t **)(v12 + 24 * ((v10 + ~v7 + v11) % v10) + 8);
    v18 = (float32x4_t *)*((_QWORD *)this + 8);
    v19 = (float32x4_t *)*((_QWORD *)a2 + 1);
    if (v15 <= 7)
    {
      v20 = 0;
LABEL_21:
      v26 = v15 - v20;
      v27 = v20;
      v28 = &v19->f32[v27];
      v29 = &v18->f32[v27];
      v30 = &v17->f32[v27];
      do
      {
        v31 = *v30++;
        v32 = v31;
        v33 = *v29++;
        *v28++ = v32 - (float)(v33 * *(float *)&v16);
        --v26;
      }
      while (v26);
      goto LABEL_23;
    }
    v20 = 0;
    if ((unint64_t)((char *)v19 - (char *)v17) < 0x20)
      goto LABEL_21;
    if ((unint64_t)((char *)v19 - (char *)v18) < 0x20)
      goto LABEL_21;
    v20 = v15 & 0xFFFFFFF8;
    v14 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 0);
    v21 = v19 + 1;
    v22 = v18 + 1;
    v23 = v17 + 1;
    v24 = v20;
    do
    {
      v25 = vmlsq_f32(*v23, v14, *v22);
      v21[-1] = vmlsq_f32(v23[-1], v14, v22[-1]);
      *v21 = v25;
      v21 += 2;
      v22 += 2;
      v23 += 2;
      v24 -= 8;
    }
    while (v24);
    if (v20 != v15)
      goto LABEL_21;
  }
LABEL_23:
  v34 = *((_DWORD *)this + 6);
  if (v34)
  {
    *((_DWORD *)this + 6) = v34 - 1;
    goto LABEL_50;
  }
  v35 = *((_DWORD *)this + 5);
  if (v35 == *((_DWORD *)this + 12) || *v5)
  {
    v36 = (float *)((char *)this + 80);
    v14.i32[0] = *((_DWORD *)this + 20);
    if (v14.f32[0] < 1.0 && (_DWORD)v15 != 0)
    {
      v38 = (double)v35;
      v39 = *((_QWORD *)a2 + 1);
      v40 = *((_QWORD *)this + 8);
      if (v15 < 8)
      {
        v41 = 0;
LABEL_33:
        v42 = v15 - v41;
        v43 = 4 * v41;
        v44 = (float *)(v40 + v43);
        v45 = (float *)(v39 + v43);
        do
        {
          v46 = *v45++;
          v47 = *v44 + (1.0 - *v36) * v38 * v46;
          *v44++ = v47;
          --v42;
        }
        while (v42);
        goto LABEL_35;
      }
      v41 = 0;
      v63 = v40 + 4 * v15;
      v65 = v40 < v39 + 4 * v15 && v39 < v63;
      if ((unint64_t)v36 < v63 && v40 < (unint64_t)v5)
        goto LABEL_33;
      if (v65)
        goto LABEL_33;
      v41 = v15 & 0xFFFFFFFC;
      __asm { FMOV            V2.2D, #1.0 }
      v70 = vmulq_n_f64(vsubq_f64(_Q2, vcvtq_f64_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v14.f32, 0))), v38);
      v71 = (float32x4_t *)*((_QWORD *)a2 + 1);
      v72 = (float32x2_t *)*((_QWORD *)this + 8);
      v73 = v41;
      do
      {
        v74 = *v71++;
        *(float32x4_t *)v72->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(*v72), vcvtq_f64_f32(*(float32x2_t *)v74.f32), v70)), vmlaq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v72->f32), vcvt_hight_f64_f32(v74), v70));
        v72 += 2;
        v73 -= 4;
      }
      while (v73);
      if (v41 != v15)
        goto LABEL_33;
    }
LABEL_35:
    if ((_DWORD)v15)
    {
      v48 = *(_QWORD *)(*((_QWORD *)this + 5) + 24 * *((unsigned int *)this + 3) + 8);
      v49 = *((_QWORD *)this + 8);
      if (v15 > 7 && (v49 < v48 + 4 * v15 ? (_CF = v48 >= v49 + 4 * v15) : (_CF = 1), _CF))
      {
        v51 = v15 & 0xFFFFFFF8;
        v52 = (float32x4_t *)(v49 + 16);
        v53 = (float32x4_t *)(v48 + 16);
        v54 = v51;
        do
        {
          v55 = vsubq_f32(*v52, *v53);
          v52[-1] = vsubq_f32(v52[-1], v53[-1]);
          *v52 = v55;
          v52 += 2;
          v53 += 2;
          v54 -= 8;
        }
        while (v54);
        if (v51 == v15)
          goto LABEL_49;
      }
      else
      {
        v51 = 0;
      }
      v56 = v15 - v51;
      v57 = 4 * v51;
      v58 = (float *)(v49 + v57);
      v59 = (float *)(v48 + v57);
      do
      {
        v60 = *v59++;
        *v58 = *v58 - v60;
        ++v58;
        --v56;
      }
      while (v56);
    }
LABEL_49:
    *((_DWORD *)this + 5) = v35 - 1;
LABEL_50:
    v61 = *((unsigned __int8 *)this + 84);
    --*((_DWORD *)this + 4);
    if (v61)
      return result;
    goto LABEL_51;
  }
  --*((_DWORD *)this + 4);
LABEL_51:
  v62 = *((_DWORD *)this + 7);
  if (v62 > *(_DWORD *)this)
    *((_DWORD *)this + 7) = v62 - 1;
  return result;
}

uint64_t NLocalCepNorm::getFrame@<X0>(NLocalCepNorm *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = &off_24C7F31A8;
  *(_QWORD *)(a2 + 8) = 0;
  return NLocalCepNorm::setOutputFrame(this, (NFrame *)a2);
}

void sub_20D9A890C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &off_24C7F3090;
  v3 = v1[1];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::NChunkGaussianMixtureModelsHeader(NChunkGaussianMixtureModelsHeader *this)
{
  _BYTE *v2;

  *(_DWORD *)this = 0;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 0;
  *((_WORD *)this + 18) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = &off_24C7F30C8;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = &off_24C7F3090;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 14) = &off_24C7F3090;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_QWORD *)this + 17) = &off_24C7F3090;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_BYTE *)this + 160) = 0;
  *((_QWORD *)this + 5) = &off_24C7F2A18;
  *(_QWORD *)((char *)this + 164) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_QWORD *)this + 22) = &off_24C7F30C8;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = &off_24C7F30C8;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
}

{
  _BYTE *v2;

  *(_DWORD *)this = 0;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 0;
  *((_WORD *)this + 18) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = &off_24C7F30C8;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = &off_24C7F3090;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 14) = &off_24C7F3090;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_QWORD *)this + 17) = &off_24C7F3090;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_BYTE *)this + 160) = 0;
  *((_QWORD *)this + 5) = &off_24C7F2A18;
  *(_QWORD *)((char *)this + 164) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_QWORD *)this + 22) = &off_24C7F30C8;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = &off_24C7F30C8;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
}

void NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader(NChunkGaussianMixtureModelsHeader *this)
{
  uint64_t v2;

  NGaussianFixedPointScales::~NGaussianFixedPointScales((NChunkGaussianMixtureModelsHeader *)((char *)this + 40));
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
}

{
  uint64_t v2;

  NGaussianFixedPointScales::~NGaussianFixedPointScales((NChunkGaussianMixtureModelsHeader *)((char *)this + 40));
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
}

char *NChunkGaussianMixtureModelsHeader::read(NChunkGaussianMixtureModelsHeader *this, const NString *a2, NFilePtr *a3, const NString *a4, const BOOL *a5)
{
  int v10;
  const char *v11;
  uint64_t v12;
  char v17;
  char v18;
  _BYTE *v19;
  char *v20;
  _DWORD *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  const char *v30;
  _BYTE *v31;
  BOOL v32;
  char *v33;
  BOOL v34;
  BOOL v35;
  char *v36;
  char *v37;
  char *v38;
  char *result;
  uint64_t (**v40)(NString *__hidden, const unsigned int *);
  int v41;
  char *v42;
  uint64_t (**v43)(NString *__hidden, const unsigned int *);
  int v44;
  _BYTE *v45;
  uint64_t (**v46)(NString *__hidden, const unsigned int *);
  int v47;
  _BYTE *v48;
  uint64_t (**v49)(NString *__hidden, const unsigned int *);
  int v50;
  char *v51;

  v10 = *((_DWORD *)a4 + 2);
  v49 = &off_24C7F32C0;
  v50 = v10;
  v51 = (char *)operator new[]();
  memcpy(v51, *((const void **)a4 + 2), (*((_DWORD *)a4 + 2) + 1));
  if (!v10)
  {
    v12 = *((_QWORD *)a3 + 1);
    if (!v12)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v11);
    LODWORD(v43) = 13;
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v12 + 64))(&v46, v12, &v43);
    ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _BYTE *, int *))v49[8])(&v49, v48, &v47);
    v46 = &off_24C7F32C0;
    if (v48)
      MEMORY[0x212BAC9C0](v48, 0x1000C8077774924);
    v10 = v50;
  }
  if (v10 != 13)
LABEL_62:
    Error::chuck((Error *)"NChunkGaussianMixtureModelsHeader::read() - invalid cookie", v11);
  if (*(_QWORD *)v51 == 0x206152494D472023 && *(_QWORD *)(v51 + 5) == 0x30302E3276206152)
  {
    v17 = 0;
    v18 = 0;
  }
  else if (*(_QWORD *)v51 == 0x206252494D472023 && *(_QWORD *)(v51 + 5) == 0x30302E3176206252)
  {
    v18 = 0;
    v17 = 1;
  }
  else
  {
    if (*(_QWORD *)v51 == 0x206153494D472023 && *(_QWORD *)(v51 + 5) == 0x30302E3276206153)
    {
      v17 = 0;
    }
    else
    {
      if (*(_QWORD *)v51 != 0x206253494D472023 || *(_QWORD *)(v51 + 5) != 0x30302E3176206253)
        goto LABEL_62;
      v17 = 1;
    }
    v18 = 1;
  }
  *((_BYTE *)this + 252) = v17;
  v19 = (char *)this + 252;
  *((_BYTE *)this + 253) = v18;
  v46 = &off_24C7F32C0;
  v47 = 5;
  v20 = (char *)operator new[]();
  v48 = v20;
  strcpy(v20, "IDENT");
  NChunkGaussianMixtureModelsHeader::readField(this, a2, a3, (const NString *)&v46, (NChunkGaussianMixtureModelsHeader *)((char *)this + 8));
  MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
  v46 = &off_24C7F32C0;
  v47 = 3;
  v21 = (_DWORD *)operator new[]();
  v48 = v21;
  *v21 = 5065028;
  NChunkGaussianMixtureModelsHeader::readField<unsigned int>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, this);
  MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
  v46 = &off_24C7F32C0;
  v47 = 8;
  v22 = (char *)operator new[]();
  v48 = v22;
  strcpy(v22, "MEANBITS");
  NChunkGaussianMixtureModelsHeader::readField<unsigned char>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_BYTE *)this + 32);
  MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  if (*((_BYTE *)this + 253))
  {
    v46 = &off_24C7F32C0;
    v47 = 9;
    v23 = (char *)operator new[]();
    v48 = v23;
    strcpy(v23, "INVSDBITS");
  }
  else
  {
    v46 = &off_24C7F32C0;
    v47 = 9;
    v23 = (char *)operator new[]();
    v48 = v23;
    strcpy(v23, "INVARBITS");
  }
  NChunkGaussianMixtureModelsHeader::readField<unsigned char>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_BYTE *)this + 33);
  MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
  v46 = &off_24C7F32C0;
  v47 = 10;
  v24 = (char *)operator new[]();
  v48 = v24;
  strcpy(v24, "GCONSTBITS");
  NChunkGaussianMixtureModelsHeader::readField<unsigned char>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_BYTE *)this + 34);
  MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  v46 = &off_24C7F32C0;
  v47 = 9;
  v25 = (char *)operator new[]();
  v48 = v25;
  strcpy(v25, "NCOMPBITS");
  NChunkGaussianMixtureModelsHeader::readField<unsigned char>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_BYTE *)this + 35);
  MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  v46 = &off_24C7F32C0;
  v47 = 8;
  v26 = (char *)operator new[]();
  v48 = v26;
  strcpy(v26, "COMPBITS");
  NChunkGaussianMixtureModelsHeader::readField<unsigned char>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_BYTE *)this + 36);
  MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
  v46 = &off_24C7F32C0;
  v47 = 10;
  v27 = (char *)operator new[]();
  v48 = v27;
  strcpy(v27, "WEIGHTBITS");
  NChunkGaussianMixtureModelsHeader::readField<unsigned char>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_BYTE *)this + 37);
  MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
  if (!*a5)
  {
    NGaussianFixedPointScales::read((NChunkGaussianMixtureModelsHeader *)((char *)this + 40), a3, (unsigned int *)this, (BOOL *)this + 252);
    if (!*v19)
    {
      v46 = &off_24C7F32C0;
      v47 = 0;
      v48 = (_BYTE *)operator new[]();
      *v48 = 0;
      v43 = &off_24C7F32C0;
      v44 = 0;
      v45 = (_BYTE *)operator new[]();
      *v45 = 0;
      v40 = &off_24C7F32C0;
      v41 = 7;
      v28 = (char *)operator new[]();
      v42 = v28;
      *(_QWORD *)v28 = 0x45505954524156;
      NChunkGaussianMixtureModelsHeader::readField(this, a2, a3, (const NString *)&v40, (NString *)&v46);
      MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
      v40 = &off_24C7F32C0;
      v41 = 5;
      v29 = (char *)operator new[]();
      v42 = v29;
      strcpy(v29, "WTYPE");
      NChunkGaussianMixtureModelsHeader::readField(this, a2, a3, (const NString *)&v40, (NString *)&v43);
      MEMORY[0x212BAC9C0](v29, 0x1000C8077774924);
      if (*((_BYTE *)this + 253))
      {
        if (v47 != 5 || ((v31 = v48, *(_DWORD *)v48 == 1398165065) ? (v32 = v48[4] == 68) : (v32 = 0), !v32))
        {
          v33 = "NChunkGaussianMixtureModelsHeader::readAscii()  - only INVSD type supported for variances in GMIS (file %s)";
          goto LABEL_66;
        }
      }
      else if (v47 != 5 || ((v31 = v48, *(_DWORD *)v48 == 1096175177) ? (v34 = v48[4] == 82) : (v34 = 0), !v34))
      {
        v33 = "NChunkGaussianMixtureModelsHeader::readAscii()  - only INVAR type supported for variances in GMIR (file %s)";
LABEL_66:
        Error::chuck((Error *)v33, v30, *((_QWORD *)a2 + 2));
      }
      if (v44 != 3 || (*(_WORD *)v45 == 20300 ? (v35 = v45[2] == 71) : (v35 = 0), !v35))
      {
        v33 = "NChunkGaussianMixtureModelsHeader::readAscii()  - only LOG type supported for weights (file %s)";
        goto LABEL_66;
      }
      v43 = &off_24C7F32C0;
      if (v45)
      {
        MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
        v31 = v48;
      }
      v46 = &off_24C7F32C0;
      if (v31)
        MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
    }
    v46 = &off_24C7F32C0;
    v47 = 10;
    v36 = (char *)operator new[]();
    v48 = v36;
    strcpy(v36, "NGAUSSIANS");
    NChunkGaussianMixtureModelsHeader::readField<unsigned int>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_DWORD *)this + 60);
    MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
    v46 = &off_24C7F32C0;
    v47 = 9;
    v37 = (char *)operator new[]();
    v48 = v37;
    strcpy(v37, "NMIXTURES");
    NChunkGaussianMixtureModelsHeader::readField<unsigned int>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_DWORD *)this + 61);
    MEMORY[0x212BAC9C0](v37, 0x1000C8077774924);
    if (*v19)
    {
      v46 = &off_24C7F32C0;
      v47 = 12;
      v38 = (char *)operator new[]();
      v48 = v38;
      strcpy(v38, "MIXBLOCKSIZE");
      NChunkGaussianMixtureModelsHeader::readField<unsigned int>(*((_BYTE *)this + 252), (uint64_t)a2, (uint64_t)a3, (uint64_t)&v46, (_DWORD *)this + 62);
      MEMORY[0x212BAC9C0](v38, 0x1000C8077774924);
    }
  }
  v49 = &off_24C7F32C0;
  result = v51;
  if (v51)
    return (char *)MEMORY[0x212BAC9C0](v51, 0x1000C8077774924);
  return result;
}

void sub_20D9A9550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  uint64_t v22;

  MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  if (a19)
    MEMORY[0x212BAC9C0](a19, 0x1000C8077774924);
  if (a22)
    MEMORY[0x212BAC9C0](a22, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void *NChunkGaussianMixtureModelsHeader::readField(NChunkGaussianMixtureModelsHeader *this, const NString *a2, NFilePtr *a3, const NString *a4, NString *a5)
{
  uint64_t v7;
  void *result;
  _BYTE *v9;
  const char *v10;
  int v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  _WORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  void *v25;
  char *v27;
  char v29;
  uint64_t (**v30)(NString *__hidden, const unsigned int *);
  unsigned int v31;
  _WORD *v32;
  uint64_t (**v33)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**v36)(NString *__hidden, const unsigned int *);
  int v37;
  void *__s1;

  if (!*((_BYTE *)this + 252))
  {
    v36 = &off_24C7F32C0;
    v37 = 0;
    v9 = (_BYTE *)operator new[]();
    v11 = 0;
    __s1 = v9;
    *v9 = 0;
    v27 = "Index %d outside of range [0,%d]";
    while (1)
    {
      if (v11)
        goto LABEL_33;
      v12 = *((_QWORD *)a3 + 1);
      if (!v12)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v10);
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 48))(v12))
      {
LABEL_33:
        v30 = &off_24C7F32C0;
        v31 = 1;
        v32 = (_WORD *)operator new[]();
        *v32 = 61;
        NString::operator+((uint64_t)a4, (uint64_t)&v30, (uint64_t)&v33);
      }
      v14 = *((_QWORD *)a3 + 1);
      if (!v14)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v13);
      v29 = 35;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char *))(*(_QWORD *)v14 + 80))(&v30, v14, &v29);
      v16 = (char *)operator new[]();
      strcpy(v16, "\r\n\t ");
      v17 = v31;
      v18 = v32;
      if (v31)
      {
        v19 = 0;
        while (strchr(v16, *((char *)v18 + v19)))
        {
          if (v17 == ++v19)
          {
            v20 = v17;
            v21 = v17;
            v19 = v17;
            goto LABEL_19;
          }
        }
        v20 = v19;
        v21 = v17;
      }
      else
      {
        v20 = 0;
        v21 = 0;
        v19 = 0;
      }
LABEL_19:
      if (v19 >= v17)
        v22 = v17;
      else
        v22 = v19;
      do
      {
        if (v21 <= v20)
          goto LABEL_25;
        v23 = v21--;
      }
      while (strchr(v16, *((char *)v18 + v23 - 1)));
      v22 = v23;
LABEL_25:
      if (v19 > v17)
        goto LABEL_39;
      if (v22 > v17)
        break;
      v24 = (v22 - v19);
      if (v22 < v19)
      {
        v27 = "Start and end indices conflict, start [%d], end [%d]";
        v17 = v22;
LABEL_39:
        Error::chuck((Error *)v27, v15, v19, v17, a2);
      }
      v33 = &off_24C7F32C0;
      if (!v18)
        Error::chuck((Error *)"Null pointer passed to string constructor", v15);
      LODWORD(__n) = v22 - v19;
      v25 = (void *)operator new[]();
      __s2 = v25;
      memcpy(v25, (char *)v18 + v19, v24);
      *((_BYTE *)v25 + v24) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v36[8])((NString *)&v36, v25, (const unsigned int *)&__n);
      v33 = &off_24C7F32C0;
      if (__s2)
        MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
      v30 = &off_24C7F32C0;
      if (v32)
        MEMORY[0x212BAC9C0](v32, 0x1000C8077774924);
      v11 = v37;
    }
    v19 = v22;
    goto LABEL_39;
  }
  v7 = *((_QWORD *)a3 + 1);
  if (!v7)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v7 + 88))(&v36);
  (*(void (**)(NString *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a5 + 32))(a5, &v36);
  v36 = &off_24C7F32C0;
  result = __s1;
  if (__s1)
    return (void *)MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
  return result;
}

void sub_20D9A9B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (a21)
    MEMORY[0x212BAC9C0](a21, 0x1000C8077774924);
  if (a24)
    MEMORY[0x212BAC9C0](a24, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NChunkGaussianMixtureModelsHeader::readField<unsigned int>(char a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  _BYTE *v10;
  const char *v11;
  int v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  uint64_t v18;
  _WORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  void *v26;
  const char *v28;
  char *v29;
  char v31;
  uint64_t (**v32)(NString *__hidden, const unsigned int *);
  unsigned int v33;
  _WORD *v34;
  char *__endptr;
  size_t __n;
  void *__s2;
  uint64_t (**v38)(NString *__hidden, const unsigned int *);
  int v39;
  _DWORD *v40;

  if (!a1)
  {
    v38 = &off_24C7F32C0;
    v39 = 0;
    v10 = (_BYTE *)operator new[]();
    v12 = 0;
    v40 = v10;
    *v10 = 0;
    v29 = "Index %d outside of range [0,%d]";
    while (1)
    {
      if (v12)
        goto LABEL_32;
      v13 = *(_QWORD *)(a3 + 8);
      if (!v13)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v11);
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13))
      {
LABEL_32:
        v32 = &off_24C7F32C0;
        v33 = 1;
        v34 = (_WORD *)operator new[]();
        *v34 = 61;
        NString::operator+(a4, (uint64_t)&v32, (uint64_t)&__endptr);
      }
      v15 = *(_QWORD *)(a3 + 8);
      if (!v15)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v14);
      v31 = 35;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char *))(*(_QWORD *)v15 + 80))(&v32, v15, &v31);
      v17 = (char *)operator new[]();
      strcpy(v17, "\r\n\t ");
      v18 = v33;
      v19 = v34;
      if (v33)
      {
        v20 = 0;
        while (strchr(v17, *((char *)v19 + v20)))
        {
          if (v18 == ++v20)
          {
            v21 = v18;
            v22 = v18;
            v20 = v18;
            goto LABEL_18;
          }
        }
        v21 = v20;
        v22 = v18;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        v20 = 0;
      }
LABEL_18:
      if (v20 >= v18)
        v23 = v18;
      else
        v23 = v20;
      do
      {
        if (v22 <= v21)
          goto LABEL_24;
        v24 = v22--;
      }
      while (strchr(v17, *((char *)v19 + v24 - 1)));
      v23 = v24;
LABEL_24:
      if (v20 > v18)
        goto LABEL_38;
      if (v23 > v18)
        break;
      v25 = (v23 - v20);
      if (v23 < v20)
      {
        v29 = "Start and end indices conflict, start [%d], end [%d]";
        v18 = v23;
LABEL_38:
        Error::chuck((Error *)v29, v16, v20, v18);
      }
      __endptr = (char *)&off_24C7F32C0;
      if (!v19)
        Error::chuck((Error *)"Null pointer passed to string constructor", v16);
      LODWORD(__n) = v23 - v20;
      v26 = (void *)operator new[]();
      __s2 = v26;
      memcpy(v26, (char *)v19 + v20, v25);
      *((_BYTE *)v26 + v25) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v38[8])((NString *)&v38, v26, (const unsigned int *)&__n);
      __endptr = (char *)&off_24C7F32C0;
      if (__s2)
        MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
      v32 = &off_24C7F32C0;
      if (v34)
        MEMORY[0x212BAC9C0](v34, 0x1000C8077774924);
      v12 = v39;
    }
    v20 = v23;
    goto LABEL_38;
  }
  v9 = *(_QWORD *)(a3 + 8);
  if (!v9)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  LODWORD(__endptr) = 4;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char **))(*(_QWORD *)v9 + 64))(&v38, v9, &__endptr);
  if (v39 != 4)
  {
    *a5 = 0;
    NString::~NString((NString *)&v38);
    Error::chuck((Error *)"NChunkGaussianMixtureModelsHeader::readBinary() - failed to read %s from file %s", v28, *(_QWORD *)(a4 + 16), *(_QWORD *)(a2 + 16));
  }
  *a5 = *v40;
  v38 = &off_24C7F32C0;
  return MEMORY[0x212BAC9C0]();
}

void sub_20D9AA15C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t v23;
  uint64_t v25;

  *(_QWORD *)(v23 - 104) = &off_24C7F32C0;
  v25 = *(_QWORD *)(v23 - 88);
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NChunkGaussianMixtureModelsHeader::readField<unsigned char>(char a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v9;
  _BYTE *v10;
  const char *v11;
  int v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  uint64_t v18;
  _WORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  void *v26;
  const char *v28;
  char *v29;
  char v31;
  uint64_t (**v32)(NString *__hidden, const unsigned int *);
  unsigned int v33;
  _WORD *v34;
  char *__endptr;
  size_t __n;
  void *__s2;
  uint64_t (**v38)(NString *__hidden, const unsigned int *);
  int v39;
  _BYTE *v40;

  if (!a1)
  {
    v38 = &off_24C7F32C0;
    v39 = 0;
    v10 = (_BYTE *)operator new[]();
    v12 = 0;
    v40 = v10;
    *v10 = 0;
    v29 = "Index %d outside of range [0,%d]";
    while (1)
    {
      if (v12)
        goto LABEL_32;
      v13 = *(_QWORD *)(a3 + 8);
      if (!v13)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v11);
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13))
      {
LABEL_32:
        v32 = &off_24C7F32C0;
        v33 = 1;
        v34 = (_WORD *)operator new[]();
        *v34 = 61;
        NString::operator+(a4, (uint64_t)&v32, (uint64_t)&__endptr);
      }
      v15 = *(_QWORD *)(a3 + 8);
      if (!v15)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v14);
      v31 = 35;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char *))(*(_QWORD *)v15 + 80))(&v32, v15, &v31);
      v17 = (char *)operator new[]();
      strcpy(v17, "\r\n\t ");
      v18 = v33;
      v19 = v34;
      if (v33)
      {
        v20 = 0;
        while (strchr(v17, *((char *)v19 + v20)))
        {
          if (v18 == ++v20)
          {
            v21 = v18;
            v22 = v18;
            v20 = v18;
            goto LABEL_18;
          }
        }
        v21 = v20;
        v22 = v18;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        v20 = 0;
      }
LABEL_18:
      if (v20 >= v18)
        v23 = v18;
      else
        v23 = v20;
      do
      {
        if (v22 <= v21)
          goto LABEL_24;
        v24 = v22--;
      }
      while (strchr(v17, *((char *)v19 + v24 - 1)));
      v23 = v24;
LABEL_24:
      if (v20 > v18)
        goto LABEL_38;
      if (v23 > v18)
        break;
      v25 = (v23 - v20);
      if (v23 < v20)
      {
        v29 = "Start and end indices conflict, start [%d], end [%d]";
        v18 = v23;
LABEL_38:
        Error::chuck((Error *)v29, v16, v20, v18);
      }
      __endptr = (char *)&off_24C7F32C0;
      if (!v19)
        Error::chuck((Error *)"Null pointer passed to string constructor", v16);
      LODWORD(__n) = v23 - v20;
      v26 = (void *)operator new[]();
      __s2 = v26;
      memcpy(v26, (char *)v19 + v20, v25);
      *((_BYTE *)v26 + v25) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v38[8])((NString *)&v38, v26, (const unsigned int *)&__n);
      __endptr = (char *)&off_24C7F32C0;
      if (__s2)
        MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
      v32 = &off_24C7F32C0;
      if (v34)
        MEMORY[0x212BAC9C0](v34, 0x1000C8077774924);
      v12 = v39;
    }
    v20 = v23;
    goto LABEL_38;
  }
  v9 = *(_QWORD *)(a3 + 8);
  if (!v9)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  LODWORD(__endptr) = 1;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char **))(*(_QWORD *)v9 + 64))(&v38, v9, &__endptr);
  if (v39 != 1)
  {
    *a5 = 0;
    NString::~NString((NString *)&v38);
    Error::chuck((Error *)"NChunkGaussianMixtureModelsHeader::readBinary() - failed to read %s from file %s", v28, *(_QWORD *)(a4 + 16), *(_QWORD *)(a2 + 16));
  }
  *a5 = *v40;
  v38 = &off_24C7F32C0;
  return MEMORY[0x212BAC9C0]();
}

void sub_20D9AA770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t v23;
  uint64_t v25;

  *(_QWORD *)(v23 - 104) = &off_24C7F32C0;
  v25 = *(_QWORD *)(v23 - 88);
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::write(NChunkGaussianMixtureModelsHeader *this, NFilePtr *a2)
{
  uint64_t v4;
  const char *v5;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  int v7;
  char *v8;
  char __str[8];
  int v10;
  char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)a2 + 1);
  if (*((_BYTE *)this + 253))
  {
    if (v4)
    {
      *(_QWORD *)__str = &off_24C7F32C0;
      v10 = 13;
      v11 = (char *)operator new[]();
      strcpy(v11, "# GMISa v2.00");
      (*(void (**)(uint64_t, char *))(*(_QWORD *)v4 + 104))(v4, __str);
      goto LABEL_6;
    }
  }
  else if (v4)
  {
    *(_QWORD *)__str = &off_24C7F32C0;
    v10 = 13;
    v11 = (char *)operator new[]();
    strcpy(v11, "# GMIRa v2.00");
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v4 + 104))(v4, __str);
LABEL_6:
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v11)
      MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
    if (*((_QWORD *)a2 + 1))
    {
      v6 = &off_24C7F32C0;
      v7 = 6;
      v8 = (char *)operator new[]();
      strcpy(v8, "IDENT=");
      NString::operator+((uint64_t)&v6, (uint64_t)this + 8, (uint64_t)__str);
    }
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v5);
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
}

void sub_20D9AB8CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22)
  {
    MEMORY[0x212BAC9C0](a22, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::writeBinary(NChunkGaussianMixtureModelsHeader *this, NFilePtr *a2)
{
  uint64_t v4;
  NBaseFile *v5;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  uint64_t v7;
  char *v8;

  v4 = *((_QWORD *)a2 + 1);
  if (*((_BYTE *)this + 253))
  {
    if (!v4)
      goto LABEL_10;
    v6 = &off_24C7F32C0;
    LODWORD(v7) = 13;
    v8 = (char *)operator new[]();
    strcpy(v8, "# GMISb v1.00");
    (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v4 + 96))(v4, &v6);
  }
  else
  {
    if (!v4)
      goto LABEL_10;
    v6 = &off_24C7F32C0;
    LODWORD(v7) = 13;
    v8 = (char *)operator new[]();
    strcpy(v8, "# GMIRb v1.00");
    (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v4 + 96))(v4, &v6);
  }
  v6 = &off_24C7F32C0;
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  v5 = (NBaseFile *)*((_QWORD *)a2 + 1);
  if (v5)
    NBaseFile::writeString(v5, (NChunkGaussianMixtureModelsHeader *)((char *)this + 8));
LABEL_10:
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2, v6, v7);
}

void sub_20D9AC0FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *NChunkGaussianMixtureModelsHeader::encodingString@<X0>(NChunkGaussianMixtureModelsHeader *this@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  void *v5;
  void *result;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  void *__src;

  v7 = &off_24C7F32C0;
  v8 = 0;
  __src = (void *)operator new[]();
  *(_BYTE *)__src = 0;
  NString::printf((NString *)&v7, "%d-%d-%d-%d-%d-%d", *((unsigned __int8 *)this + 32), *((unsigned __int8 *)this + 33), *((unsigned __int8 *)this + 34), *((unsigned __int8 *)this + 35), *((unsigned __int8 *)this + 36), *((unsigned __int8 *)this + 37));
  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = v8;
  v4 = (void *)operator new[]();
  *(_QWORD *)(a2 + 16) = v4;
  v5 = __src;
  result = memcpy(v4, __src, (v8 + 1));
  v7 = &off_24C7F32C0;
  if (v5)
    return (void *)MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return result;
}

void sub_20D9AC244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18)
    MEMORY[0x212BAC9C0](a18, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NFastFixedGaussians<signed char,int,unsigned char>::score(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int32x4_t a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char *v15;
  int16x8_t *v16;
  int32x4_t *v17;
  uint64_t v18;
  int32x4_t v19;
  int32x4_t v20;
  const char *v21;
  int32x4_t *v22;
  int16x8_t *v23;
  uint64_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  const char *v30;
  int16x8_t v31;
  int16x8_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int16x8_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  uint32x4_t v56;
  uint32x4_t v57;
  uint32x4_t v58;
  uint32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int32x4_t v67;
  uint64_t v68;
  int32x4_t v69;
  int32x4_t v70;
  uint64_t v71;
  int32x4_t *v72;
  uint64_t v73;
  int16x8_t *v74;
  const char *v75;
  int16x8_t v76;
  int8x8_t v77;
  int16x8_t v78;
  int32x4_t v79;
  int32x4_t v80;
  uint32x4_t v81;
  uint32x4_t v82;
  int32x4_t v83;
  int32x4_t v84;
  uint64_t v85;
  __int32 *v86;
  __int16 *v87;
  int v88;
  unsigned int v89;
  int v90;
  int8x16x2_t v92;
  int8x16x2_t v93;

  v11 = *(_QWORD *)(a1 + 24);
  v12 = (*(_DWORD *)(a1 + 232) * *a2);
  v13 = *(unsigned int *)(a1 + 216);
  v14 = *(_DWORD *)(v11 + v12);
  if ((_DWORD)v13)
  {
    v15 = (char *)(v11 + v12 + 4);
    v16 = *(int16x8_t **)(a3 + 8);
    v17 = *(int32x4_t **)(a1 + 208);
    if (v13 < 8)
    {
      v18 = 0;
      goto LABEL_15;
    }
    if (v13 >= 0x20)
    {
      v18 = v13 & 0xFFFFFFE0;
      v19 = (int32x4_t)*(unsigned int *)(v11 + v12);
      v20 = 0uLL;
      v21 = (const char *)(v12 + v11 + 36);
      v22 = v17 + 4;
      v23 = v16 + 2;
      v24 = v18;
      v25 = 0uLL;
      a11 = 0uLL;
      v26 = 0uLL;
      v27 = 0uLL;
      v28 = 0uLL;
      v29 = 0uLL;
      do
      {
        v30 = v21 - 32;
        v92 = vld2q_s8(v30);
        v93 = vld2q_s8(v21);
        v31 = v23[-2];
        v32 = v23[-1];
        v33 = vmovl_high_s16(v32);
        v34 = vmovl_high_s16(v31);
        v35 = *v23;
        v36 = v23[1];
        v23 += 4;
        v37 = vmovl_high_s16(v36);
        v38 = vmovl_high_s16(v35);
        v39 = vmovl_s8(*(int8x8_t *)v92.val[0].i8);
        v40 = vmovl_high_s8(v92.val[0]);
        v41 = vmovl_s8(*(int8x8_t *)v93.val[0].i8);
        v42 = vmovl_high_s8(v93.val[0]);
        v43 = vsubq_s32(vmovl_s16(*(int16x4_t *)v31.i8), vshll_n_s16(*(int16x4_t *)v39.i8, 8uLL));
        v44 = vsubq_s32(v34, vshll_high_n_s16(v39, 8uLL));
        v45 = vsubq_s32(vmovl_s16(*(int16x4_t *)v32.i8), vshll_n_s16(*(int16x4_t *)v40.i8, 8uLL));
        v46 = vsubq_s32(v33, vshll_high_n_s16(v40, 8uLL));
        v47 = vsubq_s32(vmovl_s16(*(int16x4_t *)v35.i8), vshll_n_s16(*(int16x4_t *)v41.i8, 8uLL));
        v48 = vsubq_s32(v38, vshll_high_n_s16(v41, 8uLL));
        v49 = vsubq_s32(vmovl_s16(*(int16x4_t *)v36.i8), vshll_n_s16(*(int16x4_t *)v42.i8, 8uLL));
        v50 = vsubq_s32(v37, vshll_high_n_s16(v42, 8uLL));
        v51 = (int32x4_t)vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_20DA24670);
        v52 = (int32x4_t)vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_20DA24680);
        v53 = (int32x4_t)vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_20DA24690);
        v92.val[0] = vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_20DA246A0);
        v92.val[1] = vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_20DA24670);
        v54 = (int32x4_t)vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_20DA24680);
        v55 = (int32x4_t)vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_20DA24690);
        v93.val[0] = vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_20DA246A0);
        v92.val[0] = (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v92.val[0], (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v46, v46), 0xFuLL)), 8uLL);
        v93.val[1] = (int8x16_t)vshlq_n_s32(vmulq_s32(v53, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v45, v45), 0xFuLL)), 8uLL);
        v56 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v52, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v44, v44), 0xFuLL)), 8uLL);
        v57 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v51, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v43, v43), 0xFuLL)), 8uLL);
        v93.val[0] = (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v93.val[0], (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v50, v50), 0xFuLL)), 8uLL);
        v58 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v55, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v49, v49), 0xFuLL)), 8uLL);
        v59 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v54, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v48, v48), 0xFuLL)), 8uLL);
        v92.val[1] = (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v92.val[1], (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v47, v47), 0xFuLL)), 8uLL);
        v61 = v22[-2];
        v60 = v22[-1];
        v63 = v22[-4];
        v62 = v22[-3];
        v65 = v22[2];
        v64 = v22[3];
        v67 = *v22;
        v66 = v22[1];
        v22 += 8;
        a11 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v92.val[0], (uint32x4_t)vnegq_s32(v60)), a11);
        v25 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v93.val[1], (uint32x4_t)vnegq_s32(v61)), v25);
        v20 = vaddq_s32((int32x4_t)vshlq_u32(v56, (uint32x4_t)vnegq_s32(v62)), v20);
        v19 = vaddq_s32((int32x4_t)vshlq_u32(v57, (uint32x4_t)vnegq_s32(v63)), v19);
        v29 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v93.val[0], (uint32x4_t)vnegq_s32(v64)), v29);
        v21 += 64;
        v28 = vaddq_s32((int32x4_t)vshlq_u32(v58, (uint32x4_t)vnegq_s32(v65)), v28);
        v27 = vaddq_s32((int32x4_t)vshlq_u32(v59, (uint32x4_t)vnegq_s32(v66)), v27);
        v26 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v92.val[1], (uint32x4_t)vnegq_s32(v67)), v26);
        v24 -= 32;
      }
      while (v24);
      v14 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v26, v19), vaddq_s32(v28, v25)), vaddq_s32(vaddq_s32(v27, v20), vaddq_s32(v29, a11))));
      if (v18 == v13)
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      if ((v13 & 0x18) == 0)
      {
        v15 += 2 * v18;
LABEL_15:
        v85 = v13 - v18;
        v86 = &v17->i32[v18];
        v87 = &v16->i16[v18];
        do
        {
          v88 = *v87++;
          v89 = (v15[1] * (((v88 - (*v15 << 8)) * (v88 - (*v15 << 8))) >> 15)) << 8;
          v90 = *v86++;
          v14 += v89 >> v90;
          v15 += 2;
          --v85;
        }
        while (v85);
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      }
    }
    else
    {
      v18 = 0;
    }
    v68 = v18;
    v18 = v13 & 0xFFFFFFF8;
    v69 = 0uLL;
    v70 = (int32x4_t)v14;
    v71 = v68 - v18;
    v72 = (int32x4_t *)((char *)v17 + 4 * v68);
    v73 = 2 * v68;
    v74 = (int16x8_t *)((char *)v16 + 2 * v68);
    v75 = (const char *)(v73 + v11 + v12 + 4);
    do
    {
      v76 = *v74++;
      *(int8x8x2_t *)((char *)&a11 - 8) = vld2_s8(v75);
      v75 += 16;
      v78 = vmovl_s8(v77);
      v79 = vsubq_s32(vmovl_s16(*(int16x4_t *)v76.i8), vshll_n_s16(*(int16x4_t *)v78.i8, 8uLL));
      v80 = vsubq_s32(vmovl_high_s16(v76), vshll_high_n_s16(v78, 8uLL));
      v81 = (uint32x4_t)vshlq_n_s32(vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_20DA24680), (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v80, v80), 0xFuLL)), 8uLL);
      v82 = (uint32x4_t)vshlq_n_s32(vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_20DA24670), (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v79, v79), 0xFuLL)), 8uLL);
      v84 = *v72;
      v83 = v72[1];
      v72 += 2;
      a11 = vnegq_s32(v84);
      v69 = vaddq_s32((int32x4_t)vshlq_u32(v81, (uint32x4_t)vnegq_s32(v83)), v69);
      v70 = vaddq_s32((int32x4_t)vshlq_u32(v82, (uint32x4_t)a11), v70);
      v71 += 8;
    }
    while (v71);
    v14 = vaddvq_s32(vaddq_s32(v70, v69));
    if (v18 != v13)
    {
      v15 += 2 * (v13 & 0xFFFFFFF8);
      goto LABEL_15;
    }
  }
  return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
}

uint64_t NFastFixedGaussians<short,int,unsigned char>::score(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  __int16 *v7;
  int16x8_t *v8;
  int32x4_t *v9;
  uint64_t v10;
  int16x8_t v11;
  int32x4_t v12;
  const __int16 *v13;
  int32x4_t *v14;
  int16x8_t *v15;
  uint64_t v16;
  int32x4_t v17;
  int32x4_t v18;
  const __int16 *v19;
  int16x8_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  uint32x4_t v25;
  uint32x4_t v26;
  uint32x4_t v27;
  int32x4_t v28;
  uint64_t v29;
  __int32 *v30;
  __int16 *v31;
  int v32;
  unsigned int v33;
  int v34;
  int16x8x2_t v36;
  int16x8x2_t v37;

  v3 = *(_QWORD *)(a1 + 24);
  v4 = (*(_DWORD *)(a1 + 232) * *a2);
  v5 = *(unsigned int *)(a1 + 216);
  v6 = *(_DWORD *)(v3 + v4);
  if ((_DWORD)v5)
  {
    v7 = (__int16 *)(v3 + v4 + 4);
    v8 = *(int16x8_t **)(a3 + 8);
    v9 = *(int32x4_t **)(a1 + 208);
    if (v5 < 0x10)
    {
      v10 = 0;
      goto LABEL_8;
    }
    v10 = v5 & 0xFFFFFFF0;
    v11 = 0uLL;
    v12 = (int32x4_t)*(unsigned int *)(v3 + v4);
    v13 = (const __int16 *)(v4 + v3 + 36);
    v14 = v9 + 2;
    v15 = v8 + 1;
    v16 = v10;
    v17 = 0uLL;
    v18 = 0uLL;
    do
    {
      v19 = v13 - 16;
      v20 = v15[-1];
      v36 = vld2q_s16(v19);
      v37 = vld2q_s16(v13);
      v21 = vsubl_high_s16(v20, v36.val[0]);
      v22 = vsubl_s16(*(int16x4_t *)v20.i8, *(int16x4_t *)v36.val[0].i8);
      v23 = vsubl_high_s16(*v15, v37.val[0]);
      v24 = vsubl_s16(*(int16x4_t *)v15->i8, *(int16x4_t *)v37.val[0].i8);
      v25 = vmull_high_u16((uint16x8_t)vuzp1q_s16(v11, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v21, v21), 0xFuLL)), (uint16x8_t)v36.val[1]);
      v26 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v22, v22), 0xFuLL), *(uint16x4_t *)v36.val[1].i8);
      v36.val[0] = (int16x8_t)vmull_high_u16((uint16x8_t)vuzp1q_s16(v11, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v23, v23), 0xFuLL)), (uint16x8_t)v37.val[1]);
      v27 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v24, v24), 0xFuLL), *(uint16x4_t *)v37.val[1].i8);
      v37.val[0] = (int16x8_t)v14[-2];
      v36.val[1] = (int16x8_t)v14[-1];
      v28 = *v14;
      v37.val[1] = (int16x8_t)v14[1];
      v14 += 4;
      v11 = (int16x8_t)vaddq_s32((int32x4_t)vshlq_u32(v25, (uint32x4_t)vnegq_s32((int32x4_t)v36.val[1])), (int32x4_t)v11);
      v12 = vaddq_s32((int32x4_t)vshlq_u32(v26, (uint32x4_t)vnegq_s32((int32x4_t)v37.val[0])), v12);
      v18 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v36.val[0], (uint32x4_t)vnegq_s32((int32x4_t)v37.val[1])), v18);
      v17 = vaddq_s32((int32x4_t)vshlq_u32(v27, (uint32x4_t)vnegq_s32(v28)), v17);
      v13 += 32;
      v15 += 2;
      v16 -= 16;
    }
    while (v16);
    v6 = vaddvq_s32(vaddq_s32(vaddq_s32(v17, v12), vaddq_s32(v18, (int32x4_t)v11)));
    if (v10 != v5)
    {
      v7 += 2 * (v5 & 0xFFFFFFF0);
LABEL_8:
      v29 = v5 - v10;
      v30 = &v9->i32[v10];
      v31 = &v8->i16[v10];
      do
      {
        v32 = *v31++;
        v33 = (((v32 - *v7) * (v32 - *v7)) >> 15) * (unsigned __int16)v7[1];
        v34 = *v30++;
        v6 += v33 >> v34;
        v7 += 2;
        --v29;
      }
      while (v29);
    }
  }
  return ((1 - (v6 >> *(_DWORD *)(a1 + 164))) >> 1);
}

uint64_t NFastFixedGaussians<signed char,int,unsigned short>::score(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int32x4_t a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char *v15;
  int16x8_t *v16;
  int32x4_t *v17;
  uint64_t v18;
  int32x4_t v19;
  int32x4_t v20;
  const char *v21;
  int32x4_t *v22;
  int16x8_t *v23;
  uint64_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  const char *v30;
  int16x8_t v31;
  int16x8_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int16x8_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int32x4_t v67;
  uint64_t v68;
  int32x4_t v69;
  int32x4_t v70;
  uint64_t v71;
  int32x4_t *v72;
  uint64_t v73;
  int16x8_t *v74;
  const char *v75;
  int16x8_t v76;
  int8x8_t v77;
  int16x8_t v78;
  int32x4_t v79;
  int32x4_t v80;
  int32x4_t v81;
  int32x4_t v82;
  uint64_t v83;
  __int32 *v84;
  __int16 *v85;
  int v86;
  int v87;
  int v88;
  int8x16x2_t v90;
  int8x16x2_t v91;

  v11 = *(_QWORD *)(a1 + 24);
  v12 = (*(_DWORD *)(a1 + 232) * *a2);
  v13 = *(unsigned int *)(a1 + 216);
  v14 = *(_DWORD *)(v11 + v12);
  if ((_DWORD)v13)
  {
    v15 = (char *)(v11 + v12 + 4);
    v16 = *(int16x8_t **)(a3 + 8);
    v17 = *(int32x4_t **)(a1 + 208);
    if (v13 < 8)
    {
      v18 = 0;
      goto LABEL_15;
    }
    if (v13 >= 0x20)
    {
      v18 = v13 & 0xFFFFFFE0;
      v19 = (int32x4_t)*(unsigned int *)(v11 + v12);
      v20 = 0uLL;
      v21 = (const char *)(v12 + v11 + 36);
      v22 = v17 + 4;
      v23 = v16 + 2;
      v24 = v18;
      v25 = 0uLL;
      a11 = 0uLL;
      v26 = 0uLL;
      v27 = 0uLL;
      v28 = 0uLL;
      v29 = 0uLL;
      do
      {
        v30 = v21 - 32;
        v90 = vld2q_s8(v30);
        v91 = vld2q_s8(v21);
        v31 = v23[-2];
        v32 = v23[-1];
        v33 = vmovl_high_s16(v32);
        v34 = vmovl_high_s16(v31);
        v35 = *v23;
        v36 = v23[1];
        v23 += 4;
        v37 = vmovl_high_s16(v36);
        v38 = vmovl_high_s16(v35);
        v39 = vmovl_s8(*(int8x8_t *)v90.val[0].i8);
        v40 = vmovl_high_s8(v90.val[0]);
        v41 = vmovl_s8(*(int8x8_t *)v91.val[0].i8);
        v42 = vmovl_high_s8(v91.val[0]);
        v43 = vshll_high_n_s16(v39, 7uLL);
        v44 = vshll_high_n_s16(v42, 7uLL);
        v45 = vshll_high_n_s16(v41, 7uLL);
        v46 = vsubq_s32(vmovl_s16(*(int16x4_t *)v31.i8), vshll_n_s16(*(int16x4_t *)v39.i8, 7uLL));
        v47 = vsubq_s32(vmovl_s16(*(int16x4_t *)v32.i8), vshll_n_s16(*(int16x4_t *)v40.i8, 7uLL));
        v48 = vsubq_s32(v33, vshll_high_n_s16(v40, 7uLL));
        v49 = vsubq_s32(vmovl_s16(*(int16x4_t *)v35.i8), vshll_n_s16(*(int16x4_t *)v41.i8, 7uLL));
        v50 = vsubq_s32(vmovl_s16(*(int16x4_t *)v36.i8), vshll_n_s16(*(int16x4_t *)v42.i8, 7uLL));
        v51 = (int32x4_t)vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_20DA24670);
        v52 = (int32x4_t)vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_20DA24680);
        v53 = (int32x4_t)vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_20DA24690);
        v90.val[0] = vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_20DA246A0);
        v90.val[1] = vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_20DA24670);
        v54 = (int32x4_t)vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_20DA24680);
        v55 = (int32x4_t)vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_20DA24690);
        v91.val[0] = vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_20DA246A0);
        v91.val[1] = (int8x16_t)vmulq_s32(v47, v53);
        v56 = vshrq_n_s32(vmulq_s32(v46, v51), 7uLL);
        v57 = vshrq_n_s32(vmulq_s32(vsubq_s32(v34, v43), v52), 7uLL);
        v91.val[1] = (int8x16_t)vshrq_n_s32((int32x4_t)v91.val[1], 7uLL);
        v90.val[0] = (int8x16_t)vshrq_n_s32(vmulq_s32(v48, (int32x4_t)v90.val[0]), 7uLL);
        v90.val[1] = (int8x16_t)vshrq_n_s32(vmulq_s32(v49, (int32x4_t)v90.val[1]), 7uLL);
        v58 = vshrq_n_s32(vmulq_s32(vsubq_s32(v38, v45), v54), 7uLL);
        v59 = vshrq_n_s32(vmulq_s32(v50, v55), 7uLL);
        v91.val[0] = (int8x16_t)vshrq_n_s32(vmulq_s32(vsubq_s32(v37, v44), (int32x4_t)v91.val[0]), 7uLL);
        v61 = v22[-2];
        v60 = v22[-1];
        v63 = v22[-4];
        v62 = v22[-3];
        v65 = v22[2];
        v64 = v22[3];
        v67 = *v22;
        v66 = v22[1];
        v22 += 8;
        a11 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v90.val[0], (int32x4_t)v90.val[0]), (uint32x4_t)vnegq_s32(v60)), a11);
        v25 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v91.val[1], (int32x4_t)v91.val[1]), (uint32x4_t)vnegq_s32(v61)), v25);
        v20 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v57, v57), (uint32x4_t)vnegq_s32(v62)), v20);
        v19 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v56, v56), (uint32x4_t)vnegq_s32(v63)), v19);
        v29 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v91.val[0], (int32x4_t)v91.val[0]), (uint32x4_t)vnegq_s32(v64)), v29);
        v21 += 64;
        v28 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v59, v59), (uint32x4_t)vnegq_s32(v65)), v28);
        v27 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v58, v58), (uint32x4_t)vnegq_s32(v66)), v27);
        v26 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v90.val[1], (int32x4_t)v90.val[1]), (uint32x4_t)vnegq_s32(v67)), v26);
        v24 -= 32;
      }
      while (v24);
      v14 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v26, v19), vaddq_s32(v28, v25)), vaddq_s32(vaddq_s32(v27, v20), vaddq_s32(v29, a11))));
      if (v18 == v13)
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      if ((v13 & 0x18) == 0)
      {
        v15 += 2 * v18;
LABEL_15:
        v83 = v13 - v18;
        v84 = &v17->i32[v18];
        v85 = &v16->i16[v18];
        do
        {
          v86 = *v85++;
          v87 = ((v86 - (*v15 << 7)) * v15[1]) >> 7;
          v88 = *v84++;
          v14 += (v87 * v87) >> v88;
          v15 += 2;
          --v83;
        }
        while (v83);
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      }
    }
    else
    {
      v18 = 0;
    }
    v68 = v18;
    v18 = v13 & 0xFFFFFFF8;
    v69 = 0uLL;
    v70 = (int32x4_t)v14;
    v71 = v68 - v18;
    v72 = (int32x4_t *)((char *)v17 + 4 * v68);
    v73 = 2 * v68;
    v74 = (int16x8_t *)((char *)v16 + 2 * v68);
    v75 = (const char *)(v73 + v11 + v12 + 4);
    do
    {
      v76 = *v74++;
      *(int8x8x2_t *)((char *)&a11 - 8) = vld2_s8(v75);
      v75 += 16;
      v78 = vmovl_s8(v77);
      v79 = vshrq_n_s32(vmulq_s32(vsubq_s32(vmovl_s16(*(int16x4_t *)v76.i8), vshll_n_s16(*(int16x4_t *)v78.i8, 7uLL)), (int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_20DA24670)), 7uLL);
      v80 = vshrq_n_s32(vmulq_s32(vsubq_s32(vmovl_high_s16(v76), vshll_high_n_s16(v78, 7uLL)), (int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_20DA24680)), 7uLL);
      v82 = *v72;
      v81 = v72[1];
      v72 += 2;
      a11 = vnegq_s32(v82);
      v69 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v80, v80), (uint32x4_t)vnegq_s32(v81)), v69);
      v70 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v79, v79), (uint32x4_t)a11), v70);
      v71 += 8;
    }
    while (v71);
    v14 = vaddvq_s32(vaddq_s32(v70, v69));
    if (v18 != v13)
    {
      v15 += 2 * (v13 & 0xFFFFFFF8);
      goto LABEL_15;
    }
  }
  return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
}

void sub_20D9AD3F0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

uint64_t __deviceCallback(uint64_t a1)
{
  NSObject *v2;
  const __CFString *v3;
  int v5;
  const __CFString *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = CFSTR("Connected");
    if (!a1)
      v3 = CFSTR("Disconnected");
    v5 = 138543362;
    v6 = v3;
    _os_log_impl(&dword_20D965000, v2, OS_LOG_TYPE_DEFAULT, "Posting HID device connection changed : %{public}@", (uint8_t *)&v5, 0xCu);
  }
  return notify_post("com.apple.voicetrigger.RemoteDarwin.ConnectionChanged");
}

uint64_t __deviceReportCallback()
{
  NSObject *v0;
  uint8_t v2[16];

  v0 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl(&dword_20D965000, v0, OS_LOG_TYPE_DEFAULT, "Posting HID device report received (Indicating VT first pass triggered in remote darwin)", v2, 2u);
  }
  return notify_post("com.apple.voicetrigger.RemoteDarwin.EarlyDetect");
}

void NBaseFile::writeString(NBaseFile *this, const NString *a2)
{
  int v3;
  uint64_t (**v4)(NString *__hidden, const unsigned int *);
  int v5;
  _BYTE *v6;
  _BYTE v7[28];
  unsigned int v8;

  v4 = &off_24C7F32C0;
  v5 = 0;
  v6 = (_BYTE *)operator new[]();
  *v6 = 0;
  v3 = *((_DWORD *)a2 + 2);
  v8 = 4;
  NString::appendTo((NString *)&v4, &v3, &v8);
  NString::operator+((uint64_t)&v4, (uint64_t)a2, (uint64_t)v7);
}

uint64_t sub_20D9ADB54()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v0 + 96))(v0, &v4);
  v4 = v1;
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  result = v3;
  if (v3)
    return MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  return result;
}

void sub_20D9ADBBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15)
    MEMORY[0x212BAC9C0](a15, 0x1000C8077774924);
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NBaseFile::print(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
}

_BYTE *NBaseFile::printf(NBaseFile *this, const char *a2, ...)
{
  _BYTE *result;
  uint64_t (**v5)(NString *__hidden, const unsigned int *);
  int v6;
  _BYTE *v7;
  va_list va;

  va_start(va, a2);
  v5 = &off_24C7F32C0;
  v6 = 0;
  v7 = (_BYTE *)operator new[]();
  *v7 = 0;
  NString::vprintf((NString *)&v5, a2, va);
  (*(void (**)(NBaseFile *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)this + 96))(this, &v5);
  v5 = &off_24C7F32C0;
  result = v7;
  if (v7)
    return (_BYTE *)MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  return result;
}

void sub_20D9ADCC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NDeepnetDistribution::~NDeepnetDistribution(NDeepnetDistribution *this)
{
  NDeepnetDistribution::~NDeepnetDistribution(this);
  JUMPOUT(0x212BAC9D8);
}

{
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F21F0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 6) = 0;
  v13 = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v13);
  v14 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 7) + 64))((char *)this + 56, "", &v14);
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  v2 = *((unsigned int *)this + 36);
  if ((_DWORD)v2)
    munmap(*((void **)this + 19), v2);
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = 0;
  v15 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 14) + 64))((char *)this + 112, "", &v15);
  *((_QWORD *)this + 43) = &off_24C7F3138;
  v3 = *((_QWORD *)this + 44);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C80BDFB0063);
  *((_QWORD *)this + 38) = &off_24C7F3138;
  v4 = *((_QWORD *)this + 39);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C80BDFB0063);
  *((_QWORD *)this + 20) = &off_24C7F1BF8;
  *((_QWORD *)this + 32) = &off_24C7F3090;
  v5 = *((_QWORD *)this + 33);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  *((_QWORD *)this + 29) = &off_24C7F3090;
  v6 = *((_QWORD *)this + 30);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  *((_QWORD *)this + 26) = &off_24C7F3090;
  v7 = *((_QWORD *)this + 27);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  *((_QWORD *)this + 22) = &off_24C7F30C8;
  v8 = *((_QWORD *)this + 23);
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
  NLoadedMemory::~NLoadedMemory((NDeepnetDistribution *)((char *)this + 88));
  *((_QWORD *)this + 7) = &off_24C7F2108;
  free(*((void **)this + 9));
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = &off_24C7F32C0;
  *((_QWORD *)this + 4) = &off_24C7F2DF0;
  v9 = *((_QWORD *)this + 5);
  if (v9)
  {
    v10 = *(_QWORD *)(v9 - 8);
    if (v10)
    {
      v11 = 16 * v10;
      do
      {
        *(_QWORD *)(v9 + v11 - 16) = &off_24C7F17D0;
        v12 = *(_QWORD *)(v9 + v11 - 8);
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        v11 -= 16;
      }
      while (v11);
    }
    MEMORY[0x212BAC9C0](v9 - 16, 0xA1C80BD48D6D6);
  }
}

uint64_t NDeepnetDistribution::size(NDeepnetDistribution *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t NDeepnetDistribution::dimen(NDeepnetDistribution *this)
{
  return (uint64_t)this + 12;
}

uint64_t NDeepnetDistribution::numFrames(NDeepnetDistribution *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t NDeepnetDistribution::frameSize(NDeepnetDistribution *this)
{
  return (uint64_t)this + 20;
}

uint64_t NDeepnetDistribution::scoreCacheTypes(NDeepnetDistribution *this)
{
  return 4;
}

uint64_t NDeepnetDistribution::read(NDeepnetDistribution *this, const NString *a2)
{
  char *v4;
  uint64_t v5;
  size_t v6;
  unsigned int v7;
  int *v8;
  int v9;
  int v10;
  const char *v12;
  const char *v13;
  BOOL v14;
  const char *v15;
  const char *v16;
  const char *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  uint64_t v26;
  uint64_t result;
  const char *v28;
  const void *v29;
  void *v30;
  const char *v31;
  const char *v32;
  const char *v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD *v40;
  __int128 *v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  int *v47;
  int v48;
  _DWORD *v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  __int128 *v57;
  uint64_t v58;
  __int128 v59;
  _OWORD *v60;
  uint64_t v61;
  int v62;
  int *v63;
  int v64;
  const float *v65;
  const float *v66;
  const char *v67;
  const char *v68;
  int v69;
  int v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  _BOOL4 v80;
  const char *v82;
  const char *v83;
  const char *v84;
  const NString *v85;
  int v86;
  uint64_t v87;
  unsigned int v88;
  int v89;
  uint64_t (**v90)(NString *__hidden, const unsigned int *);
  unsigned int v91;
  unsigned int *v92;
  unsigned int v93;
  uint64_t (**v94)();
  uint64_t v95;
  void *v96;
  int v97;
  int v98;
  int v99;
  uint64_t (**v100)(NString *__hidden, const unsigned int *);
  unsigned int v101;
  const void *v102;
  uint64_t (**v103)();
  int *v104;
  int v105;
  uint64_t (**v106)(NString *__hidden, const unsigned int *);
  int v107;
  _QWORD *v108;
  uint64_t (**v109)();
  uint64_t v110;
  int v111[3];

  v4 = (char *)this + 32;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  LODWORD(v106) = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v106);
  v5 = *((_QWORD *)this + 7);
  LODWORD(v106) = 0;
  (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(v5 + 64))((char *)this + 56, "", &v106);
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  v6 = *((unsigned int *)this + 36);
  if ((_DWORD)v6)
    munmap(*((void **)this + 19), v6);
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = 0;
  LODWORD(v106) = 0;
  (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*((_QWORD *)this + 14) + 64))((char *)this + 112, "", &v106);
  v7 = *((_DWORD *)a2 + 2);
  if (v7 >= 7)
  {
    v8 = (int *)*((_QWORD *)a2 + 2);
    v9 = *v8;
    v10 = *(int *)((char *)v8 + 3);
    if (v9 == 1684957549 && v10 == 980968804)
      goto LABEL_26;
    goto LABEL_10;
  }
  if (v7 >= 4)
  {
LABEL_10:
    if (**((_DWORD **)a2 + 2) != 980443501)
      goto LABEL_11;
LABEL_26:
    NLoadedMemory::load((NDeepnetDistribution *)((char *)this + 88), a2);
    return NDeepnetDistribution::mapFromMemory(this, *((const char **)this + 13), (const unsigned int *)this + 24, *((const char **)a2 + 2));
  }
LABEL_11:
  v106 = &off_24C7F32C0;
  v107 = 1;
  v108 = (_QWORD *)operator new[]();
  memcpy(v108, "r", (v107 + 1));
  v109 = (uint64_t (**)())&off_24C7F33E0;
  v110 = 0;
  NFilePtr::open((NFilePtr *)&v109, a2, (const NString *)&v106);
  v106 = &off_24C7F32C0;
  if (v108)
    MEMORY[0x212BAC9C0](v108, 0x1000C8077774924);
  if (!v110)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
  LODWORD(v103) = 16;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)()))(*(_QWORD *)v110 + 64))(&v106, v110, &v103);
  if (v107 != 16 || (*v108 == 0x20624C4E4E442023 ? (v14 = v108[1] == 0xA0A0A30302E3176) : (v14 = 0), !v14))
    Error::chuck((Error *)"NDeepnetDistribution::read() - cannot read cookie from file %s", v13, *((_QWORD *)a2 + 2));
  v103 = &off_24C7F3100;
  v104 = (int *)operator new[]();
  v105 = 9;
  if (!v110)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v15);
  LODWORD(v90) = 36;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v110 + 64))(&v100, v110, &v90);
  if ((v101 & 3) != 0)
  {
    v100 = &off_24C7F32C0;
    if (v102)
      MEMORY[0x212BAC9C0](v102, 0x1000C8077774924);
    Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v16, "cannot read header from", *((_QWORD *)a2 + 2));
  }
  LODWORD(v94) = v101 >> 2;
  ((void (*)(uint64_t, uint64_t, int *))v103[3])((uint64_t)&v103, (uint64_t)v102, (int *)&v94);
  v87 = (uint64_t)v4;
  v100 = &off_24C7F32C0;
  if (v102)
    MEMORY[0x212BAC9C0](v102, 0x1000C8077774924);
  v18 = *v104;
  v99 = v104[1];
  v20 = v104[2];
  v19 = v104[3];
  v21 = v104[4];
  v22 = v104[5];
  v98 = v104[5];
  v23 = v104[6];
  v24 = v104[7];
  v25 = v104[8];
  if ((v18 & 0xF) == 2)
  {
    v26 = BYTE1(v18);
  }
  else
  {
    if (v18 != 1)
      Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v17, "only version 1 or 2 of DNN file supported:", *((_QWORD *)a2 + 2));
    v26 = 0;
  }
  if ((v20 & 1) != 0 || v26 >= 2)
    Error::chuck((Error *)"NDeepnetDistribution::read() - DNN file %s contains unsupported feature (required set = 0x%.6X%.8X, available = 0x%.6X%.8X)", v17, *((_QWORD *)a2 + 2), v26, v20, 1, 4294967294);
  if (!(_DWORD)v22)
    Error::chuck((Error *)"NDeepnetDistribution::read() - DNN file %s contains no layers (must be at least 1)", v17, *((_QWORD *)a2 + 2));
  if (v22 >= 0x4000001)
    Error::chuck((Error *)"NDeepnetDistribution::read() - DNN image %s implies %u layers (too many)", v17, *((_QWORD *)a2 + 2), v22);
  v86 = v21;
  v88 = v19;
  v97 = v25 + (-(int)v25 & 3);
  if (!v110)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v17);
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v110 + 64))(&v100, v110, &v97);
  if (v101 != v97)
    Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v28, "cannot read comment from", *((_QWORD *)a2 + 2));
  if (v25 > v101)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v28, v25, v101);
  v29 = v102;
  v94 = (uint64_t (**)())&off_24C7F32C0;
  if (!v102)
    Error::chuck((Error *)"Null pointer passed to string constructor", v28);
  v85 = a2;
  LODWORD(v95) = v25;
  v30 = (void *)operator new[]();
  v96 = v30;
  memcpy(v30, v29, v25);
  *((_BYTE *)v30 + v25) = 0;
  ((void (*)(NString *, const void *, const unsigned int *))v100[8])((NString *)&v100, v30, (const unsigned int *)&v95);
  v94 = (uint64_t (**)())&off_24C7F32C0;
  if (v96)
    MEMORY[0x212BAC9C0](v96, 0x1000C8077774924);
  *((_BYTE *)this + 376) = 0;
  if ((v20 & 0x20) != 0)
  {
    v94 = &off_24C7F30C8;
    v95 = 0;
    LODWORD(v96) = 0;
    if (!v110)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v31);
    v111[0] = 4;
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v110 + 64))(&v90, v110, v111);
    if (v91 == 4)
    {
      v93 = *v92;
      v90 = &off_24C7F32C0;
      MEMORY[0x212BAC9C0]();
      if (!v110)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v33);
      v89 = 4 * v24;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v110 + 64))(&v90, v110, &v89);
      if ((v91 & 3) == 0)
      {
        v111[0] = v91 >> 2;
        ((void (*)(uint64_t (***)(), unsigned int *, int *))v94[3])(&v94, v92, v111);
        v90 = &off_24C7F32C0;
        if (v92)
          MEMORY[0x212BAC9C0](v92, 0x1000C8077774924);
        v34 = v24 * v23;
        v35 = v96;
        if ((_DWORD)v96 == (_DWORD)v24 * (_DWORD)v23)
          goto LABEL_61;
        v36 = v95;
        LODWORD(v96) = v24 * v23;
        v37 = operator new[]();
        v95 = v37;
        if (v35 >= v34)
          v38 = v34;
        else
          v38 = v35;
        if ((_DWORD)v38)
        {
          v39 = 0;
          if (v38 < 8)
            goto LABEL_56;
          if ((unint64_t)(v37 - v36) <= 0x1F)
            goto LABEL_56;
          v39 = v38 & 0xFFFFFFF8;
          v40 = (_OWORD *)(v37 + 16);
          v41 = (__int128 *)(v36 + 16);
          v42 = v39;
          do
          {
            v43 = *v41;
            *(v40 - 1) = *(v41 - 1);
            *v40 = v43;
            v40 += 2;
            v41 += 2;
            v42 -= 8;
          }
          while (v42);
          if (v39 != v38)
          {
LABEL_56:
            v44 = v38 - v39;
            v45 = 4 * v39;
            v46 = (_DWORD *)(v37 + 4 * v39);
            v47 = (int *)(v36 + v45);
            do
            {
              v48 = *v47++;
              *v46++ = v48;
              --v44;
            }
            while (v44);
          }
        }
        else if (!v36)
        {
          goto LABEL_61;
        }
        MEMORY[0x212BAC9C0](v36, 0x1000C8052888210);
LABEL_61:
        if (v23 >= 2 && (_DWORD)v24)
        {
          v49 = (_DWORD *)v95;
          if (v24 >= 8)
          {
            v52 = 0;
            v53 = 1;
            v54 = v24;
            do
            {
              v55 = 0;
              ++v52;
              if (__CFADD__(v24 * v52, v24 - 1))
                goto LABEL_80;
              if ((v24 * v52) < 8)
                goto LABEL_80;
              v56 = v54;
              v57 = (__int128 *)(v49 + 4);
              v58 = v24 & 0xFFFFFFF8;
              do
              {
                v59 = *v57;
                v60 = &v49[v56];
                *v60 = *(v57 - 1);
                v60[1] = v59;
                v57 += 2;
                v56 += 8;
                v58 -= 8;
              }
              while (v58);
              v55 = v24 & 0xFFFFFFF8;
              if (v55 != v24)
              {
LABEL_80:
                v61 = v24 - v55;
                v62 = v54 + v55;
                v63 = &v49[v55];
                do
                {
                  v64 = *v63++;
                  v49[v62++] = v64;
                  --v61;
                }
                while (v61);
              }
              ++v53;
              v54 += v24;
            }
            while (v53 != (_DWORD)v23);
          }
          else
          {
            v50 = v24 + 6;
            v51 = v23 - 1;
            do
            {
              v49[v50 - 6] = *v49;
              if ((_DWORD)v24 != 1)
              {
                v49[v50 - 5] = v49[1];
                if ((_DWORD)v24 != 2)
                {
                  v49[v50 - 4] = v49[2];
                  if ((_DWORD)v24 != 3)
                  {
                    v49[v50 - 3] = v49[3];
                    if ((_DWORD)v24 != 4)
                    {
                      v49[v50 - 2] = v49[4];
                      if ((_DWORD)v24 != 5)
                      {
                        v49[v50 - 1] = v49[5];
                        if ((_DWORD)v24 != 6)
                          v49[v50] = v49[6];
                      }
                    }
                  }
                }
              }
              v50 += v24;
              --v51;
            }
            while (v51);
          }
        }
        NFixedPointScales::initialize((uint64_t)this + 160, &v93, (uint64_t)&v94);
        NFixedPointSigmoidTable::initialize((NDeepnetDistribution *)((char *)this + 288), (const unsigned int *)0x100, v65, 8.0);
        *((_BYTE *)this + 368) = 1;
        NFixedPointLogaddTable::initialize((NDeepnetDistribution *)((char *)this + 328), (const unsigned int *)0x100, v66, 8.0);
        *((_BYTE *)this + 369) = 1;
        *((_BYTE *)this + 376) = 1;
        v94 = &off_24C7F30C8;
        if (v95)
          MEMORY[0x212BAC9C0](v95, 0x1000C8052888210);
        goto LABEL_85;
      }
      v90 = &off_24C7F32C0;
      if (v92)
        MEMORY[0x212BAC9C0](v92, 0x1000C8077774924);
      v84 = "cannot read fixpoint scalings from";
    }
    else
    {
      v90 = &off_24C7F32C0;
      if (v92)
        MEMORY[0x212BAC9C0](v92, 0x1000C8077774924);
      v84 = "cannot read fixpoint scaling from";
    }
    Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v32, v84, *((_QWORD *)a2 + 2));
  }
LABEL_85:
  v94 = &off_24C7F3100;
  v95 = operator new[]();
  LODWORD(v96) = 4 * v22;
  if (!v110)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v67);
  v93 = 16 * v22;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, unsigned int *))(*(_QWORD *)v110 + 64))(&v90, v110, &v93);
  if ((v91 & 3) != 0)
  {
    v90 = &off_24C7F32C0;
    if (v92)
      MEMORY[0x212BAC9C0](v92, 0x1000C8077774924);
    goto LABEL_140;
  }
  v111[0] = v91 >> 2;
  ((void (*)(uint64_t, uint64_t, int *))v94[3])((uint64_t)&v94, (uint64_t)v92, v111);
  v69 = (int)v96;
  v90 = &off_24C7F32C0;
  if (v92)
    MEMORY[0x212BAC9C0](v92, 0x1000C8077774924);
  if (v69 != 4 * (_DWORD)v22)
  {
LABEL_140:
    v82 = "cannot read layer definitions from";
    goto LABEL_145;
  }
  if (!v110)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v68);
  v70 = (*(uint64_t (**)(uint64_t, int *, char *))(*(_QWORD *)v110 + 72))(v110, &v99, (char *)this + 56);
  if (v70 != v99)
  {
    v82 = "cannot read enough data from file:";
    goto LABEL_145;
  }
  if (!v110)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v68);
  v111[0] = 1;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v110 + 64))(&v90, v110, v111);
  v71 = v91;
  v90 = &off_24C7F32C0;
  if (v92)
    MEMORY[0x212BAC9C0](v92, 0x1000C8077774924);
  if (v71)
  {
    v82 = "extra junk at end of file:";
LABEL_145:
    Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v68, v82, *((_QWORD *)a2 + 2));
  }
  v72 = v23;
  v73 = v88;
  LODWORD(v90) = v88;
  NArray<NLayer>::resize(v87, &v98);
  v75 = 0;
  v76 = 0;
  if (v22 <= 1)
    v77 = 1;
  else
    v77 = v22;
  v78 = 4 * v77;
  do
  {
    v111[0] = *(_DWORD *)(v95 + 4 * v76);
    v93 = 0;
    v93 = *(_DWORD *)(v95 + 4 * (v76 + 1));
    v79 = *(unsigned int *)(v95 + 4 * (v76 + 2));
    v89 = 0;
    v89 = *(_DWORD *)(v95 + 4 * (v76 + 3));
    v80 = __CFADD__((_DWORD)v79, v89);
    if ((v89 + v79) > *((_DWORD *)this + 16) || v80)
      Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v74, "layer incorrectly defined in", *((_QWORD *)v85 + 2));
    NLayer::initialize((_QWORD *)(*((_QWORD *)this + 5) + v75), (unsigned int *)v111, (uint64_t)&v90, (uint64_t)&v93, *((_QWORD *)this + 9) + v79, (uint64_t)&v89, (uint64_t)this + 288);
    LODWORD(v90) = v93;
    if (v73 <= v93)
      v73 = v93;
    v76 += 4;
    v75 += 16;
  }
  while (v78 != v76);
  if (v93 != v86)
  {
    v83 = "last layer output width doesn't match spec in file";
    goto LABEL_148;
  }
  if ((_DWORD)v24 * v72 != v88)
  {
    v83 = "number of frames x framesize doesn't equal input dimen";
LABEL_148:
    Error::chuck((Error *)"NDeepnetDistribution::read() - %s %s", v74, v83, *((_QWORD *)v85 + 2));
  }
  *((_DWORD *)this + 2) = v86;
  *((_DWORD *)this + 3) = v88;
  *((_DWORD *)this + 4) = v72;
  *((_DWORD *)this + 5) = v24;
  *((_DWORD *)this + 6) = v73;
  v94 = &off_24C7F3100;
  if (v95)
    MEMORY[0x212BAC9C0](v95, 0x1000C8052888210);
  v100 = &off_24C7F32C0;
  if (v102)
    MEMORY[0x212BAC9C0](v102, 0x1000C8077774924);
  v103 = &off_24C7F3100;
  if (v104)
    MEMORY[0x212BAC9C0](v104, 0x1000C8052888210);
  v106 = &off_24C7F32C0;
  if (v108)
    MEMORY[0x212BAC9C0](v108, 0x1000C8077774924);
  v109 = &off_24C7F17F8;
  result = v110;
  if (v110)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v110 + 8))(v110);
  return result;
}

void sub_20D9AEB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if (a24)
    MEMORY[0x212BAC9C0](a24, 0x1000C8052888210);
  if (a30)
    MEMORY[0x212BAC9C0](a30, 0x1000C8077774924);
  *(_QWORD *)(v30 - 160) = &off_24C7F3100;
  v32 = *(_QWORD *)(v30 - 152);
  if (v32)
    MEMORY[0x212BAC9C0](v32, 0x1000C8052888210);
  *(_QWORD *)(v30 - 136) = &off_24C7F32C0;
  v33 = *(_QWORD *)(v30 - 120);
  if (v33)
    MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
  *(_QWORD *)(v30 - 112) = &off_24C7F17F8;
  v34 = *(_QWORD *)(v30 - 104);
  if (v34)
    (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
  _Unwind_Resume(exception_object);
}

void NDeepnetDistribution::score(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::score not implemented yet() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::scoreAll(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *(unsigned int *)(a1 + 12);
  if (*(_DWORD *)(a2 + 16) != (_DWORD)v5)
    Error::chuck((Error *)"NDeepnetDistribution::scoreAll() - input vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v5);
  v6 = *(unsigned int *)(a1 + 8);
  if (*(_DWORD *)(a3 + 16) != (_DWORD)v6)
    Error::chuck((Error *)"NDeepnetDistribution::scoreAll() - output (dist) vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a3 + 16), v6);
  if (*(_BYTE *)(a1 + 376))
    NDeepnetDistribution::forwardComputeFixed(a1, a5, a2, a3);
  else
    NDeepnetDistribution::forwardComputeFloat(a1, a2, a3, a4, a5);
}

void NDeepnetDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::scoreUsingCache() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::componentScore(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::componentScore() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::numComponents(NDeepnetDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::numComponents() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::setComponentMask(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::setComponentMask() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::firstComponentId(NDeepnetDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::firstComponentId() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::posteriorWeightedMean() - not supported for this distribution type", a2);
}

void NDeepnetDistribution::baseGMM(NDeepnetDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDeepnetDistribution::baseGMM() - not supported for this distribution type", a2);
}

uint64_t NDeepnetDistribution::fixedPointScalesP(NDeepnetDistribution *this)
{
  return (uint64_t)this + 160;
}

uint64_t NDeepnetDistribution::allocateStateP(NDeepnetDistribution *this, __n128 a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  size_t v6;
  const char *v7;
  uint64_t v8;
  char v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  __int128 *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;
  uint64_t v24;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x24BDAC8D0];
  v3 = *((unsigned int *)this + 12);
  MEMORY[0x24BDAC7A8](a2);
  v5 = (char *)v26 - v4;
  if (!(_DWORD)v3)
    return 0;
  v6 = (unint64_t)(8 * v3) >= 0x200 ? 512 : 8 * v3;
  bzero(v5, v6);
  v8 = 0;
  v9 = 0;
  v10 = (uint64_t *)v5;
  do
  {
    v11 = *(_QWORD *)(*((_QWORD *)this + 5) + v8 + 8);
    if (!v11)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
    *v10++ = v12;
    v9 |= v12 != 0;
    v8 += 16;
  }
  while (16 * v3 != v8);
  if ((v9 & 1) == 0)
    return 0;
  v13 = operator new();
  *(_QWORD *)v13 = &off_24C7F2FB0;
  v14 = operator new[]();
  *(_QWORD *)(v13 + 8) = v14;
  *(_DWORD *)(v13 + 16) = v3;
  if (v3 <= 3)
  {
    v15 = 0;
LABEL_15:
    v20 = v3 - v15;
    v21 = 8 * v15;
    v22 = (_QWORD *)(v14 + 8 * v15);
    v23 = &v5[v21];
    do
    {
      v24 = *(_QWORD *)v23;
      v23 += 8;
      *v22++ = v24;
      --v20;
    }
    while (v20);
    return v13;
  }
  v15 = v3 & 0xFFFFFFFC;
  v16 = (_OWORD *)(v14 + 16);
  v17 = (__int128 *)(v5 + 16);
  v18 = v15;
  do
  {
    v19 = *v17;
    *(v16 - 1) = *(v17 - 1);
    *v16 = v19;
    v16 += 2;
    v17 += 2;
    v18 -= 4;
  }
  while (v18);
  if (v15 != v3)
    goto LABEL_15;
  return v13;
}

void sub_20D9AF094(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x1081C40622C3295);
  _Unwind_Resume(a1);
}

uint64_t NDeepnetDistribution::deallocateState(uint64_t this, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  if (a2)
  {
    v3 = this;
    v4 = *(unsigned int *)(this + 48);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 8 * v4;
      v7 = 8;
      do
      {
        v8 = *(const char **)(a2[1] + v5);
        if (v8)
        {
          v9 = *(_QWORD *)(*(_QWORD *)(v3 + 40) + v7);
          if (!v9)
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
        }
        v5 += 8;
        v7 += 16;
      }
      while (v6 != v5);
    }
    return (*(uint64_t (**)(_QWORD *))(*a2 + 8))(a2);
  }
  return this;
}

uint64_t NDeepnetDistribution::resetState(uint64_t this, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  if (a2)
  {
    v2 = this;
    v3 = *(unsigned int *)(this + 48);
    if ((_DWORD)v3)
    {
      v5 = 0;
      v6 = 8 * v3;
      v7 = 8;
      do
      {
        v8 = *(const char **)(a2[1] + v5);
        if (v8)
        {
          v9 = *(_QWORD *)(*(_QWORD *)(v2 + 40) + v7);
          if (!v9)
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
          this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9);
        }
        v5 += 8;
        v7 += 16;
      }
      while (v6 != v5);
    }
  }
  return this;
}

_QWORD *NArray<void *>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F2FB0;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x80C80B8603338);
  return a1;
}

void NArray<void *>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F2FB0;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x80C80B8603338);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<void *>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x80C80B8603338);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = 8 * v4;
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + v7) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + v7);
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  return a1;
}

uint64_t NArray<void *>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x80C80B8603338);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = 0;
    v10 = 8 * v5;
    do
    {
      *(_QWORD *)(*(_QWORD *)(v4 + 8) + v9) = *(_QWORD *)(a2 + v9);
      v9 += 8;
    }
    while (v10 != v9);
  }
  return result;
}

uint64_t NArray<void *>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = *(unsigned int *)(result + 16);
  if ((_DWORD)v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    if ((_DWORD)v2)
      v6 = *a2 == 0;
    else
      v6 = 1;
    if (!v6)
    {
      v7 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * v7) = *(_QWORD *)(v5 + 8 * v7);
        ++v7;
      }
      while (v7 < v2 && v7 < *a2);
LABEL_11:
      JUMPOUT(0x212BAC9C0);
    }
    if (v5)
      goto LABEL_11;
  }
  return result;
}

void NDeepnetDistribution::forwardComputeFixed(uint64_t a1, __n128 a2, uint64_t a3, uint64_t a4)
{
  __n128 v6;
  uint64_t v7;
  int32x4_t *v8;
  uint64_t v9;
  __n128 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  _DWORD *v16;
  float v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int32x4_t *v25;
  uint64_t v26;
  float32x4_t *v27;
  uint64_t v28;
  float32x4_t *v29;
  int32x4_t *v30;
  float32x4_t v31;
  uint64_t v32;
  float32x4_t v33;
  uint64_t v34;
  uint64_t v35;
  float *v36;
  int *v37;
  int v38;
  _QWORD v39[2];

  v39[1] = *MEMORY[0x24BDAC8D0];
  v6 = MEMORY[0x24BDAC7A8](a2);
  v10 = MEMORY[0x24BDAC7A8](v6);
  v11 = (char *)v39 - v9;
  v13 = *(unsigned int *)(v12 + 12);
  if ((_DWORD)v13)
  {
    v14 = *(float **)(v7 + 8);
    v15 = *(float **)(a1 + 216);
    v10.n128_u64[0] = 0xC7000000C7000000;
    v16 = (_DWORD *)((char *)v39 - v9);
    do
    {
      v17 = *v14++;
      v18 = v17;
      v19 = *v15++;
      v20 = v18 * v19;
      if (v20 > 32767.0)
        v20 = 32767.0;
      if (v20 < -32768.0)
        v20 = -32768.0;
      *v16++ = (uint64_t)rintf(v20);
      --v13;
    }
    while (v13);
  }
  v21 = *(unsigned int *)(a1 + 48);
  if (!(_DWORD)v21)
  {
    v25 = (int32x4_t *)v11;
    v26 = *(unsigned int *)(a1 + 8);
    if (!(_DWORD)v26)
      return;
LABEL_15:
    v27 = *(float32x4_t **)(a4 + 8);
    if (v26 >= 8)
    {
      v28 = v26 & 0xFFFFFFF8;
      v29 = v27 + 1;
      v30 = v25 + 1;
      v31.i64[0] = 0x3800000038000000;
      v31.i64[1] = 0x3800000038000000;
      v32 = v28;
      do
      {
        v33 = vmulq_f32(vcvtq_f32_s32(*v30), v31);
        v29[-1] = vmulq_f32(vcvtq_f32_s32(v30[-1]), v31);
        *v29 = v33;
        v29 += 2;
        v30 += 2;
        v32 -= 8;
      }
      while (v32);
      if (v28 == v26)
        return;
    }
    else
    {
      v28 = 0;
    }
    v34 = v26 - v28;
    v35 = v28;
    v36 = &v27->f32[v35];
    v37 = &v25->i32[v35];
    do
    {
      v38 = *v37++;
      *v36++ = (float)v38 * 0.000030518;
      --v34;
    }
    while (v34);
    return;
  }
  v22 = 0;
  v23 = 16 * v21;
  do
  {
    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + v22 + 8);
    if (!v24)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)v7, v10.n128_f64[0]);
    v25 = v8;
    (*(void (**)(uint64_t, char *, int32x4_t *, __n128))(*(_QWORD *)v24 + 32))(v24, v11, v8, v10);
    v22 += 16;
    v8 = (int32x4_t *)v11;
    v11 = (char *)v25;
  }
  while (v23 != v22);
  v26 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v26)
    goto LABEL_15;
}

uint64_t NDeepnetDistribution::forwardComputeFloat(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  const char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __n128 v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t (*v28)(void);
  uint64_t v29;
  _QWORD v30[2];

  v30[1] = *MEMORY[0x24BDAC8D0];
  v7 = *(const char **)(a2 + 8);
  v8 = *(_DWORD *)(a1 + 48);
  v9 = (v8 - 1);
  if (v8 == 1)
  {
    if (a4)
      v10 = **(_QWORD **)(a4 + 8);
    else
      v10 = 0;
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    if (v21)
      return (*(uint64_t (**)(uint64_t, const char *, _QWORD, uint64_t))(*(_QWORD *)v21 + 24))(v21, v7, *(_QWORD *)(a3 + 8), v10);
    goto LABEL_27;
  }
  v11 = MEMORY[0x24BDAC7A8](a5);
  v13 = (char *)v30 - ((v12 + 15) & 0x7FFFFFFF0);
  a5 = MEMORY[0x24BDAC7A8](v11);
  v15 = (char *)v30 - ((v14 + 15) & 0x7FFFFFFF0);
  v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (!a4)
  {
    if (!v16)
      goto LABEL_27;
    (*(void (**)(uint64_t, __n128))(*(_QWORD *)v16 + 24))(v16, a5);
    if (v9 >= 2)
    {
      v23 = v9 - 1;
      v24 = 24;
      while (1)
      {
        v25 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + v24);
        if (!v25)
          goto LABEL_27;
        v26 = v13;
        v13 = v15;
        (*(void (**)(uint64_t, char *, char *, _QWORD))(*(_QWORD *)v25 + 24))(v25, v15, v26, 0);
        v24 += 16;
        v15 = v26;
        if (!--v23)
          goto LABEL_24;
      }
    }
    v9 = 1;
LABEL_24:
    v29 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16 * v9 + 8);
    if (v29)
    {
      v28 = *(uint64_t (**)(void))(*(_QWORD *)v29 + 24);
      return v28();
    }
LABEL_27:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7, a5.n128_f64[0]);
  }
  if (!v16)
    goto LABEL_27;
  (*(void (**)(uint64_t, __n128))(*(_QWORD *)v16 + 24))(v16, a5);
  if (v9 >= 2)
  {
    v17 = 1;
    v18 = 24;
    while (1)
    {
      v19 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + v18);
      if (!v19)
        goto LABEL_27;
      v20 = v13;
      v13 = v15;
      (*(void (**)(uint64_t, char *, char *, _QWORD))(*(_QWORD *)v19 + 24))(v19, v15, v20, *(_QWORD *)(*(_QWORD *)(a4 + 8) + 8 * v17++));
      v18 += 16;
      v15 = v20;
      if (v9 == v17)
        goto LABEL_21;
    }
  }
  v9 = 1;
LABEL_21:
  v27 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16 * v9 + 8);
  if (!v27)
    goto LABEL_27;
  v28 = *(uint64_t (**)(void))(*(_QWORD *)v27 + 24);
  return v28();
}

uint64_t NArray<NLayer>::resize(uint64_t result, _DWORD *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = *(_DWORD *)(result + 16);
  v3 = *a2;
  if (v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  result = operator new[]();
  *(_QWORD *)result = 16;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = (v3 - 1) & 0xFFFFFFFFFFFFFFFLL;
    v10 = (_QWORD *)(result + 16);
    if (v9 >= 3)
    {
      v11 = (v9 + 1) & 0x1FFFFFFFFFFFFFFCLL;
      v12 = (_OWORD *)(result + 48);
      *((_QWORD *)&v13 + 1) = 0;
      *(_QWORD *)&v13 = &off_24C7F31E0;
      v14 = v11;
      do
      {
        *(v12 - 2) = v13;
        *(v12 - 1) = v13;
        *v12 = v13;
        v12[1] = v13;
        v12 += 4;
        v14 -= 4;
      }
      while (v14);
      if (v9 + 1 == v11)
        goto LABEL_9;
      v10 = (_QWORD *)(v8 + 16 * v11);
    }
    do
    {
      *v10 = &off_24C7F31E0;
      v10[1] = 0;
      v10 += 2;
    }
    while (v10 != (_QWORD *)(v8 + 16 * v3));
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v8;
  if (v2 && *a2)
    Error::chuck((Error *)"NLayer::operator=() - attempting to copy layer prohibited", v7);
  if (v6)
  {
    v15 = *(_QWORD *)(v6 - 8);
    if (v15)
    {
      v16 = 16 * v15;
      do
      {
        *(_QWORD *)(v6 + v16 - 16) = &off_24C7F17D0;
        v17 = *(_QWORD *)(v6 + v16 - 8);
        if (v17)
          (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
        v16 -= 16;
      }
      while (v16);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

uint64_t NDeepnetDistribution::mapFromMemory(NDeepnetDistribution *this, const char *a2, const unsigned int *a3, const char *a4)
{
  uint64_t v5;
  const char *v6;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  const char *v23;
  unsigned int v24;
  int i;
  uint64_t v26;
  unsigned int v27;
  const char *v28;
  uint64_t v29;
  __int128 v30;
  _OWORD *v31;
  uint64_t v32;
  unsigned int v33;
  const char *v34;
  int v35;
  const float *v36;
  const float *v37;
  char *v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  _BOOL4 v45;
  uint64_t result;
  const char *v48;
  const char *v49;
  const char *v50;
  int v51;
  const char *v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t (**v56)();
  uint64_t v57;
  int v58;
  unsigned int v59;
  unsigned int v60;

  if (!a2)
  {
    v48 = "null pointer";
    goto LABEL_78;
  }
  v5 = *a3;
  if (v5 <= 0x33)
  {
    v48 = "DNN image smaller than minimum";
    goto LABEL_78;
  }
  v6 = a2;
  if (*(_QWORD *)a2 != 0x20624C4E4E442023 || *((_QWORD *)a2 + 1) != 0xA0A0A30302E3176)
  {
    v48 = "cannot read cookie from";
    goto LABEL_78;
  }
  v9 = *((_DWORD *)a2 + 4);
  v10 = *((unsigned int *)a2 + 5);
  v11 = *((unsigned int *)a2 + 6);
  v12 = *((_DWORD *)a2 + 7);
  v13 = *((_DWORD *)a2 + 8);
  v14 = *((unsigned int *)a2 + 9);
  v60 = *((_DWORD *)a2 + 9);
  a2 = (const char *)*((unsigned int *)a2 + 10);
  v15 = *((unsigned int *)v6 + 11);
  if ((v9 & 0xF) == 2)
  {
    v16 = BYTE1(v9);
  }
  else
  {
    if (v9 != 1)
    {
      v48 = "only version 1 or 2 of DNN file supported:";
LABEL_78:
      Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - %s %s", a2, v48, a4);
    }
    v16 = 0;
  }
  if ((v11 & 1) != 0 || v16 >= 2)
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - DNN image %s contains unsupported feature (required set = 0x%.6X%.8X, available = 0x%.6X%.8X)", a2, a4, v16, v11, 1, 4294967294);
  if (!(_DWORD)v14)
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - DNN image %s contains no layers (must be at least 1)", a2, a4);
  if (v14 >= 0x4000001)
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - DNN image %s implies %u layers (too many)", a2, a4, v14);
  v51 = v13;
  v53 = v12;
  v17 = (unint64_t)&v6[v5];
  v18 = *((_DWORD *)v6 + 12) + (-*((_DWORD *)v6 + 12) & 3u);
  v19 = (unsigned int *)&v6[v18 + 52];
  if (v19 > (unsigned int *)&v6[v5])
  {
    v48 = "cannot read comment from";
    goto LABEL_78;
  }
  *((_BYTE *)this + 376) = 0;
  v52 = a2;
  if ((v11 & 0x20) != 0)
  {
    v56 = &off_24C7F30C8;
    v57 = 0;
    v58 = 0;
    v59 = *v19;
    if ((unint64_t)v19 + (4 * v15) + 4 > v17)
      Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - %s %s", a2, "cannot read fixpoint scaling from", a4);
    if ((_DWORD)v15 * (_DWORD)a2)
    {
      v58 = v15 * (_DWORD)a2;
      v20 = operator new[]();
      v57 = v20;
      a2 = v52;
      if (!(_DWORD)v52)
        goto LABEL_44;
    }
    else
    {
      v20 = 0;
      if (!(_DWORD)a2)
        goto LABEL_44;
    }
    if ((_DWORD)v15)
    {
      if (v15 < 8)
      {
        v21 = v19[1];
        v22 = 6;
        v23 = a2;
        do
        {
          *(_DWORD *)(v20 + 4 * (v22 - 6)) = v21;
          if ((_DWORD)v15 != 1)
          {
            *(_DWORD *)(v20 + 4 * (v22 - 5)) = v19[2];
            if ((_DWORD)v15 != 2)
            {
              *(_DWORD *)(v20 + 4 * (v22 - 4)) = v19[3];
              if ((_DWORD)v15 != 3)
              {
                *(_DWORD *)(v20 + 4 * (v22 - 3)) = v19[4];
                if ((_DWORD)v15 != 4)
                {
                  *(_DWORD *)(v20 + 4 * (v22 - 2)) = v19[5];
                  if ((_DWORD)v15 != 5)
                  {
                    *(_DWORD *)(v20 + 4 * (v22 - 1)) = v19[6];
                    if ((_DWORD)v15 != 6)
                      *(_DWORD *)(v20 + 4 * v22) = v19[7];
                  }
                }
              }
            }
          }
          v22 += v15;
          --v23;
        }
        while (v23);
        goto LABEL_44;
      }
      v24 = 0;
      for (i = 0; i != (_DWORD)a2; ++i)
      {
        if (__CFADD__(i * v15, v15 - 1))
        {
          v26 = 0;
        }
        else
        {
          v27 = v24;
          v28 = &v6[v18 + 72];
          v29 = v15 & 0xFFFFFFF8;
          do
          {
            v30 = *(_OWORD *)v28;
            v31 = (_OWORD *)(v20 + 4 * v27);
            *v31 = *((_OWORD *)v28 - 1);
            v31[1] = v30;
            v28 += 32;
            v27 += 8;
            v29 -= 8;
          }
          while (v29);
          v26 = v15 & 0xFFFFFFF8;
          if (v26 == v15)
            goto LABEL_35;
        }
        v32 = v15 - v26;
        v33 = v24 + v26;
        v34 = &v6[4 * v26 + 56 + v18];
        do
        {
          v35 = *(_DWORD *)v34;
          v34 += 4;
          *(_DWORD *)(v20 + 4 * v33++) = v35;
          --v32;
        }
        while (v32);
LABEL_35:
        v24 += v15;
      }
    }
LABEL_44:
    NFixedPointScales::initialize((uint64_t)this + 160, &v59, (uint64_t)&v56);
    NFixedPointSigmoidTable::initialize((NDeepnetDistribution *)((char *)this + 288), (const unsigned int *)0x100, v36, 8.0);
    *((_BYTE *)this + 368) = 1;
    NFixedPointLogaddTable::initialize((NDeepnetDistribution *)((char *)this + 328), (const unsigned int *)0x100, v37, 8.0);
    *((_BYTE *)this + 369) = 1;
    *((_BYTE *)this + 376) = 1;
    v56 = &off_24C7F30C8;
    if (v57)
      MEMORY[0x212BAC9C0](v57, 0x1000C8052888210);
    v19 = (unsigned int *)((char *)v19 + (4 * v15) + 4);
  }
  v38 = (char *)v19 + (16 * v14);
  if ((unint64_t)v38 > v17)
  {
    v48 = "cannot read layer definitions from";
    goto LABEL_78;
  }
  if ((unint64_t)&v38[v10] > v17)
  {
    v48 = "cannot read enough data from image:";
    goto LABEL_78;
  }
  v50 = a4;
  if (&v38[v10] != (char *)v17)
  {
    v49 = "extra junk at end of image:";
    goto LABEL_66;
  }
  v39 = v53;
  LODWORD(v56) = v53;
  NArray<NLayer>::resize((uint64_t)this + 32, &v60);
  v40 = 0;
  v41 = 0;
  v42 = 3;
  do
  {
    v43 = v19[v42 - 2];
    v59 = v19[v42 - 3];
    v44 = v19[v42 - 1];
    v54 = v19[v42];
    v55 = v43;
    v45 = __CFADD__(v54, (_DWORD)v44);
    if (v54 + v44 > v10 || v45)
    {
      v49 = "layer incorrectly defined in";
      goto LABEL_66;
    }
    result = NLayer::initialize((_QWORD *)(*((_QWORD *)this + 5) + v40), &v59, (uint64_t)&v56, (uint64_t)&v55, (uint64_t)&v38[v44], (uint64_t)&v54, (uint64_t)this + 288);
    LODWORD(v56) = v55;
    if (v39 <= v55)
      v39 = v55;
    ++v41;
    v40 += 16;
    v42 += 4;
  }
  while (v41 < v60);
  if (v55 != v51)
  {
    v49 = "last layer output width doesn't match spec in file";
    goto LABEL_66;
  }
  if ((_DWORD)v15 * (_DWORD)v52 != v53)
  {
    v49 = "number of frames x framesize doesn't equal input dimen";
LABEL_66:
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - %s %s", a2, v49, v50);
  }
  *((_DWORD *)this + 2) = v51;
  *((_DWORD *)this + 3) = v53;
  *((_DWORD *)this + 4) = (_DWORD)v52;
  *((_DWORD *)this + 5) = v15;
  *((_DWORD *)this + 6) = v39;
  return result;
}

void sub_20D9AFFC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a20)
    MEMORY[0x212BAC9C0](a20, 0x1000C8052888210);
  _Unwind_Resume(exception_object);
}

void NFixedPointSigmoidTable::initialize(NFixedPointSigmoidTable *this, const unsigned int *a2, const float *a3, float a4)
{
  unsigned int v4;
  float v6;
  const char *v7;
  float v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _WORD *v21;
  __int16 *v22;
  __int16 v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  float v27;

  v4 = a2;
  *(float *)this = a4;
  *((_DWORD *)this + 1) = (_DWORD)a2;
  v6 = a4 / (float)a2;
  *((float *)this + 2) = v6;
  v8 = logf(v6) / -0.69315;
  v9 = (int)(v8 + 0.5);
  *((_DWORD *)this + 3) = v9;
  if (vabds_f32(v8, (float)v9) > 0.0001)
    Error::chuck((Error *)"NFixedPointSigmoidTable::initialize() - scale is not a power of 2", v7);
  v10 = *((_DWORD *)this + 8);
  if (v10 != v4)
  {
    v11 = *((_QWORD *)this + 3);
    *((_DWORD *)this + 8) = v4;
    v12 = operator new[]();
    *((_QWORD *)this + 3) = v12;
    v4 = *((_DWORD *)this + 1);
    if (v10 >= v4)
      v13 = v4;
    else
      v13 = v10;
    if ((_DWORD)v13)
    {
      v14 = 0;
      if (v13 < 0x10)
        goto LABEL_12;
      if ((unint64_t)(v12 - v11) <= 0x1F)
        goto LABEL_12;
      v14 = v13 & 0xFFFFFFF0;
      v15 = (_OWORD *)(v12 + 16);
      v16 = (__int128 *)(v11 + 16);
      v17 = v14;
      do
      {
        v18 = *v16;
        *(v15 - 1) = *(v16 - 1);
        *v15 = v18;
        v15 += 2;
        v16 += 2;
        v17 -= 16;
      }
      while (v17);
      if (v14 != v13)
      {
LABEL_12:
        v19 = v13 - v14;
        v20 = 2 * v14;
        v21 = (_WORD *)(v12 + 2 * v14);
        v22 = (__int16 *)(v11 + v20);
        do
        {
          v23 = *v22++;
          *v21++ = v23;
          --v19;
        }
        while (v19);
      }
    }
    else if (!v11)
    {
      goto LABEL_17;
    }
    MEMORY[0x212BAC9C0](v11, 0x1000C80BDFB0063);
    v4 = *((_DWORD *)this + 1);
  }
LABEL_17:
  if (v4)
  {
    v24 = 0;
    v25 = -*((float *)this + 2);
    v26 = *((_QWORD *)this + 3);
    do
    {
      v27 = 1.0 / (expf((float)v24 * v25) + 1.0);
      *(_WORD *)(v26 + 2 * v24++) = (uint64_t)rintf(v27 * 32767.0);
    }
    while (v4 != v24);
  }
}

void NFixedPointLogaddTable::initialize(NFixedPointLogaddTable *this, const unsigned int *a2, const float *a3, float a4)
{
  unsigned int v4;
  float v6;
  const char *v7;
  float v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _WORD *v21;
  __int16 *v22;
  __int16 v23;
  uint64_t v24;
  float v25;
  float v26;
  uint64_t v27;
  float v28;

  v4 = a2;
  *(float *)this = a4;
  *((_DWORD *)this + 1) = (_DWORD)a2;
  v6 = a4 / (float)a2;
  v8 = logf(v6) / -0.69315;
  v9 = (int)(v8 + 0.5);
  if (vabds_f32(v8, (float)v9) > 0.0001)
    Error::chuck((Error *)"NFixedPointLogaddTable::initialize() - scale is not a power of 2", v7);
  *((float *)this + 2) = 2.0 / v6;
  *((_DWORD *)this + 3) = v9 + 1;
  v10 = *((_DWORD *)this + 8);
  if (v10 != v4)
  {
    v11 = *((_QWORD *)this + 3);
    *((_DWORD *)this + 8) = v4;
    v12 = operator new[]();
    *((_QWORD *)this + 3) = v12;
    v4 = *((_DWORD *)this + 1);
    if (v10 >= v4)
      v13 = v4;
    else
      v13 = v10;
    if ((_DWORD)v13)
    {
      v14 = 0;
      if (v13 < 0x10)
        goto LABEL_12;
      if ((unint64_t)(v12 - v11) <= 0x1F)
        goto LABEL_12;
      v14 = v13 & 0xFFFFFFF0;
      v15 = (_OWORD *)(v12 + 16);
      v16 = (__int128 *)(v11 + 16);
      v17 = v14;
      do
      {
        v18 = *v16;
        *(v15 - 1) = *(v16 - 1);
        *v15 = v18;
        v15 += 2;
        v16 += 2;
        v17 -= 16;
      }
      while (v17);
      if (v14 != v13)
      {
LABEL_12:
        v19 = v13 - v14;
        v20 = 2 * v14;
        v21 = (_WORD *)(v12 + 2 * v14);
        v22 = (__int16 *)(v11 + v20);
        do
        {
          v23 = *v22++;
          *v21++ = v23;
          --v19;
        }
        while (v19);
      }
    }
    else if (!v11)
    {
      goto LABEL_17;
    }
    MEMORY[0x212BAC9C0](v11, 0x1000C80BDFB0063);
    v4 = *((_DWORD *)this + 1);
  }
LABEL_17:
  if (v4)
  {
    v24 = 0;
    v25 = -v6;
    v26 = *((float *)this + 2);
    v27 = *((_QWORD *)this + 3);
    do
    {
      v28 = expf(v25 * (float)v24);
      *(_WORD *)(v27 + 2 * v24++) = (int)((float)(logf(v28 + 1.0) * v26) + 0.5);
    }
    while (v4 != v24);
  }
}

uint64_t NLayer::initialize(_QWORD *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  void (**v16)(N8BitLogSoftmaxLayer *__hidden);
  _QWORD *v17;
  void (**v18)(Nfp16SigmoidOnlyLayer *__hidden);
  _QWORD *v19;
  void (**v20)(Nfp16AMPalettizedLayer *__hidden);
  _QWORD *v21;
  const char *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  const char *v26;
  int v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  const char *v32;

  switch(*a2)
  {
    case 1u:
      v14 = operator new();
      v15 = v14;
      *(_QWORD *)(v14 + 16) = 0;
      v16 = &off_24C7F1928;
      goto LABEL_32;
    case 2u:
      v14 = operator new();
      v15 = v14;
      *(_QWORD *)(v14 + 16) = 0;
      v16 = &off_24C7F1A68;
LABEL_32:
      *(_QWORD *)(v14 + 8) = 0;
      goto LABEL_36;
    case 3u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F2048;
      goto LABEL_43;
    case 4u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1740;
      goto LABEL_43;
    case 6u:
      v21 = (_QWORD *)operator new();
      v23 = v21;
      if (*(_BYTE *)(a7 + 80))
        v24 = a7;
      else
        v24 = 0;
      v21[2] = 0;
      v21[3] = 0;
      *v21 = &off_24C7F1D78;
      v21[1] = 0;
      v21[4] = v24;
      if (!v24)
        Error::chuck((Error *)"NFixSigmoidalLayer::NFixSigmoidalLayer() - sigmoid table not defined", v22);
      goto LABEL_27;
    case 7u:
      v25 = (_QWORD *)operator new();
      v23 = v25;
      v27 = *(unsigned __int8 *)(a7 + 81);
      v28 = a7 + 40;
      if (!*(_BYTE *)(a7 + 81))
        v28 = 0;
      v25[2] = 0;
      v25[3] = 0;
      *v25 = &off_24C7F1FF8;
      v25[1] = 0;
      v25[4] = v28;
      if (!v27)
        Error::chuck((Error *)"NFixLogSoftmaxLayer::NFixLogSoftmaxLayer() - logadd table not defined", v26);
LABEL_27:
      (*(void (**)(_QWORD *, _QWORD *))(*a1 + 16))(a1, v23);
      goto LABEL_46;
    case 8u:
      v14 = operator new();
      v15 = v14;
      *(_OWORD *)v14 = 0u;
      *(_OWORD *)(v14 + 16) = 0u;
      *(_QWORD *)(v14 + 32) = 0;
      v16 = &off_24C7F1E80;
      goto LABEL_36;
    case 9u:
      v14 = operator new();
      v15 = v14;
      *(_OWORD *)v14 = 0u;
      *(_OWORD *)(v14 + 16) = 0u;
      *(_QWORD *)(v14 + 32) = 0;
      v16 = &off_24C7F21A0;
LABEL_36:
      *(_QWORD *)v14 = v16;
      goto LABEL_45;
    case 0xAu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F16F0;
      goto LABEL_43;
    case 0xBu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1120;
      goto LABEL_43;
    case 0xCu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      *v17 = &off_24C7F1A18;
      v17[1] = 0;
      v17[3] = 0;
      v17[4] = 0;
      goto LABEL_44;
    case 0xDu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1C20;
      goto LABEL_43;
    case 0xEu:
      v19 = (_QWORD *)operator new();
      v15 = (uint64_t)v19;
      v20 = &off_24C7F2098;
      goto LABEL_41;
    case 0xFu:
      v15 = operator new();
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 76) = 0u;
      *(_QWORD *)(v15 + 8) = 0;
      *(_QWORD *)(v15 + 16) = 0;
      *(_QWORD *)v15 = &off_24C7F1170;
      *(_DWORD *)(v15 + 24) = 0;
      goto LABEL_45;
    case 0x10u:
      v15 = operator new();
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 76) = 0u;
      *(_QWORD *)(v15 + 8) = 0;
      *(_QWORD *)(v15 + 16) = 0;
      *(_DWORD *)(v15 + 24) = 0;
      *(_QWORD *)v15 = &off_24C7F1840;
      *(_QWORD *)(v15 + 96) = 0;
      *(_DWORD *)(v15 + 92) = 0;
      goto LABEL_45;
    case 0x11u:
      v15 = operator new();
      *(_QWORD *)v15 = &off_24C7F1F88;
      *(_QWORD *)(v15 + 8) = 0;
      *(_QWORD *)(v15 + 16) = 0;
      *(_QWORD *)(v15 + 24) = 0;
      *(_DWORD *)(v15 + 32) = 0;
      goto LABEL_45;
    case 0x12u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F2348;
      goto LABEL_43;
    case 0x13u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1C70;
      goto LABEL_43;
    case 0x14u:
      v15 = operator new();
      *(_OWORD *)(v15 + 8) = 0u;
      *(_OWORD *)(v15 + 24) = 0u;
      *(_QWORD *)v15 = &off_24C7F2870;
      *(_QWORD *)(v15 + 40) = 0;
      goto LABEL_45;
    case 0x15u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F22A8;
      goto LABEL_43;
    case 0x16u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F29C8;
      goto LABEL_43;
    case 0x17u:
      v15 = operator new();
      *(_QWORD *)v15 = &off_24C7F2A40;
      *(_QWORD *)(v15 + 8) = 0;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      *(_QWORD *)(v15 + 48) = 0;
      goto LABEL_45;
    case 0x18u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1BA8;
      goto LABEL_43;
    case 0x19u:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1B58;
      goto LABEL_43;
    case 0x1Au:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1978;
      goto LABEL_43;
    case 0x1Bu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1B08;
      goto LABEL_43;
    case 0x1Cu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F1AB8;
      goto LABEL_43;
    case 0x1Du:
      v19 = (_QWORD *)operator new();
      v15 = (uint64_t)v19;
      v20 = &off_24C7F22F8;
      goto LABEL_41;
    case 0x1Eu:
      v17 = (_QWORD *)operator new();
      v15 = (uint64_t)v17;
      v17[1] = 0;
      v18 = &off_24C7F2398;
LABEL_43:
      *v17 = v18;
LABEL_44:
      v17[2] = 0;
      goto LABEL_45;
    case 0x1Fu:
      v19 = (_QWORD *)operator new();
      v15 = (uint64_t)v19;
      v20 = &off_24C7F28C0;
      goto LABEL_41;
    case 0x20u:
      v19 = (_QWORD *)operator new();
      v15 = (uint64_t)v19;
      v20 = &off_24C7F19C8;
LABEL_41:
      *v19 = v20;
      v19[1] = 0;
      v19[2] = 0;
      v19[3] = 0;
LABEL_45:
      (*(void (**)(_QWORD *, uint64_t))(*a1 + 16))(a1, v15);
LABEL_46:
      v30 = a1[1];
      if (!v30)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v29);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v30 + 16))(v30, a3, a4, a5, a6);
    default:
      (*(void (**)(_QWORD *, _QWORD))(*a1 + 16))(a1, 0);
      Error::chuck((Error *)"NLayer::initialize() - unsupported layer type %d", v32, *a2);
  }
}

void sub_20D9B0A98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10F1C4069C8BB13);
  _Unwind_Resume(a1);
}

void Nfp16AMPalettizedLayer::~Nfp16AMPalettizedLayer(Nfp16AMPalettizedLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16AMPalettizedLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*a5 != ((2 * ((*(_DWORD *)a2 * *a3) & 0x3FFFFFFF) + 16 * ((*a3 & 3) != 0) + 15) & 0xFFFFFFF0) + 32)
    Error::chuck((Error *)"Nfp16AMPalettizedLayer::initialize() - Incorrect data size", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  *(_QWORD *)(this + 24) = a4;
  return this;
}

void Nfp16AMPalettizedLayer::compute(Nfp16AMPalettizedLayer *this, const float *a2, float *a3, void *a4)
{
  _BYTE *v4;
  int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  float *v12;
  unsigned int v13;
  char v14;
  char v16;
  unsigned int v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  float *v23;
  unint64_t v24;
  unint64_t v76;
  unsigned int v77;
  float *v78;
  unint64_t i;
  unint64_t v104;
  unsigned int v107;
  float *v108;
  _BYTE v135[32];
  uint64_t v136;

  v136 = *MEMORY[0x24BDAC8D0];
  v4 = (_BYTE *)*((_QWORD *)this + 3);
  if (!v4)
    Error::chuck((Error *)"Nfp16AMPalettizedLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v7 = *((_DWORD *)this + 2);
  v8 = (2 * *((_DWORD *)this + 3));
  bzero(a3, 2 * v8);
  v135[0] = *v4;
  v135[1] = v4[16];
  v135[2] = v4[1];
  v135[3] = v4[17];
  v135[4] = v4[2];
  v135[5] = v4[18];
  v135[6] = v4[3];
  v135[7] = v4[19];
  v135[8] = v4[4];
  v135[9] = v4[20];
  v135[10] = v4[5];
  v135[11] = v4[21];
  v135[12] = v4[6];
  v135[13] = v4[22];
  v135[14] = v4[7];
  v135[15] = v4[23];
  v135[16] = v4[8];
  v135[17] = v4[24];
  v135[18] = v4[9];
  v135[19] = v4[25];
  v135[20] = v4[10];
  v135[21] = v4[26];
  v135[22] = v4[11];
  v135[23] = v4[27];
  v135[24] = v4[12];
  v135[25] = v4[28];
  v135[26] = v4[13];
  v135[27] = v4[29];
  v135[28] = v4[14];
  v135[29] = v4[30];
  v135[30] = v4[15];
  v135[31] = v4[31];
  if ((_DWORD)v8)
  {
    v9 = (2 * v7);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = v4 + 32;
      v12 = a3;
      v13 = v8;
      do
      {
        v14 = v13;
        _CF = v13 >= 0x40;
        v13 -= 64;
        if (_CF)
          v16 = 64;
        else
          v16 = v14;
        v17 = v8 - v10;
        if ((v8 - v10) >= 0x40)
          v17 = 64;
        if ((v17 & 0x7C) != 0)
        {
          v18 = 0;
          v19 = (((v16 & 0x7C) - 1) & 0xFFFFFFFC) + 4;
          do
          {
            v20 = 0;
            _H2 = LOWORD(a2[v18 / 2]);
            _H3 = *(_WORD *)((char *)a2 + ((2 * v18) | 2));
            v23 = &a3[v10 / 2];
            do
            {
              v24 = *(unsigned int *)&v11[v20];
              _H1 = *(_WORD *)&v135[2 * (v24 & 0xF)];
              _H4 = *(_WORD *)&v135[2 * (v24 >> 4)];
              __asm
              {
                FCVT            S0, H3
                FCVT            S4, H4
              }
              _S4 = _S0 * _S4;
              __asm
              {
                FCVT            S5, H1
                FCVT            S1, H2
              }
              _S5 = _S5 * _S1;
              __asm { FCVT            H4, S4 }
              _H6 = *(_WORD *)&v135[2 * ((v24 >> 8) & 0xF)];
              _H7 = *(_WORD *)&v135[2 * ((unsigned __int16)v24 >> 12)];
              __asm
              {
                FCVT            S4, H4
                FCVT            H5, S5
                FCVT            S7, H7
              }
              _S7 = _S0 * _S7;
              __asm
              {
                FCVT            H7, S7
                FCVT            S6, H6
                FCVT            S5, H5
              }
              _S6 = _S6 * _S1;
              __asm { FCVT            H6, S6 }
              _H16 = *(_WORD *)&v135[2 * ((v24 >> 16) & 0xF)];
              __asm
              {
                FCVT            S7, H7
                FCVT            S6, H6
              }
              _H17 = *(_WORD *)&v135[2 * ((v24 >> 20) & 0xF)];
              __asm { FCVT            S17, H17 }
              _S17 = _S0 * _S17;
              _S4 = _S5 + _S4;
              __asm
              {
                FCVT            H5, S17
                FCVT            S5, H5
                FCVT            S16, H16
              }
              _S16 = _S16 * _S1;
              __asm { FCVT            H16, S16 }
              _S6 = _S6 + _S7;
              __asm { FCVT            S7, H16 }
              _S5 = _S7 + _S5;
              LOWORD(_S7) = *(_WORD *)&v135[2 * ((v24 >> 24) & 0xF)];
              __asm { FCVT            H4, S4 }
              LOWORD(_S16) = *(_WORD *)&v135[(v24 >> 27) & 0x1E];
              __asm { FCVT            S16, H16 }
              _S16 = _S0 * _S16;
              __asm
              {
                FCVT            H6, S6
                FCVT            H16, S16
                FCVT            S7, H7
              }
              _S7 = _S7 * _S1;
              __asm
              {
                FCVT            H7, S7
                FCVT            S7, H7
                FCVT            H5, S5
                FCVT            S16, H16
              }
              _S7 = _S7 + _S16;
              __asm { FCVT            H7, S7 }
              LOWORD(_S16) = *(_WORD *)v23;
              __asm
              {
                FCVT            S16, H16
                FCVT            S4, H4
              }
              _S4 = _S4 + _S16;
              __asm { FCVT            H4, S4 }
              LOWORD(_S16) = *((_WORD *)v23 + 1);
              __asm
              {
                FCVT            S6, H6
                FCVT            S16, H16
              }
              *(_WORD *)v23 = LOWORD(_S4);
              _S4 = _S6 + _S16;
              __asm { FCVT            H4, S4 }
              LOWORD(_S6) = *((_WORD *)v23 + 2);
              __asm
              {
                FCVT            S5, H5
                FCVT            S6, H6
              }
              *((_WORD *)v23 + 1) = LOWORD(_S4);
              _S4 = _S5 + _S6;
              __asm { FCVT            H4, S4 }
              LOWORD(_S5) = *((_WORD *)v23 + 3);
              __asm
              {
                FCVT            S6, H7
                FCVT            S5, H5
              }
              *((_WORD *)v23 + 2) = LOWORD(_S4);
              _S4 = _S6 + _S5;
              __asm { FCVT            H4, S4 }
              *((_WORD *)v23 + 3) = LOWORD(_S4);
              v20 += 4;
              v23 += 2;
            }
            while (v20 < (v17 & 0x7C));
            if (v19 >= v17)
            {
              v11 += v20;
            }
            else
            {
              v76 = 0;
              do
              {
                v77 = *(unsigned __int16 *)&v11[v20 + v76];
                v78 = &v23[v76 / 2];
                _H2 = *(_WORD *)&v135[2 * (v77 & 0xF)];
                _H3 = *(_WORD *)&v135[2 * (v77 >> 4)];
                __asm { FCVT            S3, H3 }
                _S3 = _S0 * _S3;
                __asm
                {
                  FCVT            H3, S3
                  FCVT            S2, H2
                }
                _S2 = _S2 * _S1;
                __asm { FCVT            H2, S2 }
                _H4 = *(_WORD *)&v135[2 * ((v77 >> 8) & 0xF)];
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _H5 = *(_WORD *)&v135[2 * (v77 >> 12)];
                __asm { FCVT            S5, H5 }
                _S5 = _S0 * _S5;
                _S2 = _S2 + _S3;
                __asm
                {
                  FCVT            H3, S5
                  FCVT            S3, H3
                  FCVT            S4, H4
                }
                _S4 = _S4 * _S1;
                __asm
                {
                  FCVT            H4, S4
                  FCVT            H2, S2
                  FCVT            S4, H4
                }
                _S3 = _S4 + _S3;
                __asm { FCVT            H3, S3 }
                LOWORD(_S4) = *(_WORD *)v78;
                __asm
                {
                  FCVT            S4, H4
                  FCVT            S2, H2
                }
                _S2 = _S2 + _S4;
                __asm { FCVT            H2, S2 }
                LOWORD(_S4) = *((_WORD *)v78 + 1);
                __asm
                {
                  FCVT            S3, H3
                  FCVT            S4, H4
                }
                *(_WORD *)v78 = LOWORD(_S2);
                _S2 = _S3 + _S4;
                __asm { FCVT            H2, S2 }
                *((_WORD *)v78 + 1) = LOWORD(_S2);
                v76 += 2;
              }
              while (v19 + v76 < v17);
              v11 += v20 + v76;
            }
            v18 += 2;
          }
          while (v18 < v9);
        }
        else if (v17)
        {
          for (i = 0; i < v9; i += 2)
          {
            v104 = 0;
            _H0 = LOWORD(a2[i / 2]);
            _H1 = *(_WORD *)((char *)a2 + ((2 * i) | 2));
            do
            {
              v107 = *(unsigned __int16 *)&v11[v104];
              v108 = &v12[v104 / 2];
              _H2 = *(_WORD *)&v135[2 * (v107 & 0xF)];
              _H3 = *(_WORD *)&v135[2 * (v107 >> 4)];
              __asm
              {
                FCVT            S3, H3
                FCVT            S4, H1
              }
              _S3 = _S4 * _S3;
              __asm
              {
                FCVT            H3, S3
                FCVT            S2, H2
                FCVT            S5, H0
              }
              _S2 = _S2 * _S5;
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
                FCVT            S3, H3
              }
              _H6 = *(_WORD *)&v135[2 * ((v107 >> 8) & 0xF)];
              _H7 = *(_WORD *)&v135[2 * (v107 >> 12)];
              __asm { FCVT            S7, H7 }
              _S2 = _S2 + _S3;
              _S3 = _S4 * _S7;
              __asm
              {
                FCVT            H3, S3
                FCVT            S3, H3
                FCVT            S4, H6
              }
              _S4 = _S4 * _S5;
              __asm
              {
                FCVT            H2, S2
                FCVT            H4, S4
                FCVT            S4, H4
              }
              _S3 = _S4 + _S3;
              __asm { FCVT            H3, S3 }
              LOWORD(_S4) = *(_WORD *)v108;
              __asm
              {
                FCVT            S2, H2
                FCVT            S4, H4
              }
              _S2 = _S2 + _S4;
              __asm { FCVT            H2, S2 }
              LOWORD(_S4) = *((_WORD *)v108 + 1);
              __asm { FCVT            S3, H3 }
              *(_WORD *)v108 = LOWORD(_S2);
              __asm { FCVT            S2, H4 }
              _S2 = _S3 + _S2;
              __asm { FCVT            H2, S2 }
              *((_WORD *)v108 + 1) = LOWORD(_S2);
              v104 += 2;
            }
            while (v104 < v17);
            v11 += v104;
          }
        }
        v10 += 64;
        v12 += 32;
      }
      while (v10 < v8);
    }
  }
}

void NBaseLayer::compute(NBaseLayer *this, const char *a2, int *a3)
{
  Error::chuck((Error *)"NBaseLayer::compute() - fixed-point compute not supported", a2, a3);
}

uint64_t NBaseLayer::allocateStateP(NBaseLayer *this)
{
  return 0;
}

void Nfp16SigmoidOnlyLayer::~Nfp16SigmoidOnlyLayer(Nfp16SigmoidOnlyLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16SigmoidOnlyLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3)
    Error::chuck((Error *)"Nfp16SigmoidOnlyLayer::initialize() - input and output size must be the same", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

__int16 Nfp16SigmoidOnlyLayer::compute@<H0>(Nfp16SigmoidOnlyLayer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>, __n128 a5@<Q0>)
{
  vDSP_Length v6;
  float16x4_t *v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  float32x4_t *v12;
  float16x4_t *v13;
  uint64_t v14;
  float16x8_t v15;
  float32x4_t v16;
  float32x4_t v17;
  vDSP_Length v18;
  float *v19;
  __int16 *v20;
  __int16 v21;
  uint64_t v28;
  float *v29;
  float32x4_t *v30;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float16x8_t v36;
  vDSP_Length v37;
  _WORD *v38;
  float *v39;
  __int32 v40;
  float __B;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"Nfp16SigmoidOnlyLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v6 = (2 * *((_DWORD *)this + 3));
  MEMORY[0x24BDAC7A8](a5);
  v9 = (float *)((char *)&__B - v8);
  if (!(_DWORD)v6)
  {
    vDSP_vneg((float *)((char *)&__B - v8), 1, (float *)((char *)&__B - v8), 1, v6);
    v43 = 0;
    vvexpf(v9, v9, &v43);
    __B = 1.0;
    vDSP_vsadd(v9, 1, &__B, v9, 1, v6);
    vvrecf(v9, v9, &v43);
    return _Q0.i16[0];
  }
  if (v6 <= 0xF)
  {
    v10 = 0;
LABEL_9:
    v18 = v6 - v10;
    v19 = &v9[v10];
    v20 = (__int16 *)v7 + v10;
    do
    {
      v21 = *v20++;
      _H0 = v21;
      __asm { FCVT            S0, H0 }
      *(_DWORD *)v19++ = _S0;
      --v18;
    }
    while (v18);
    goto LABEL_11;
  }
  v10 = v6 & 0xFFFFFFF0;
  v12 = (float32x4_t *)(v9 + 8);
  v13 = v7 + 2;
  v14 = v10;
  do
  {
    v15 = *(float16x8_t *)v13[-2].i8;
    v16 = vcvtq_f32_f16(*v13);
    v17 = vcvt_hight_f32_f16(*(float16x8_t *)v13->i8);
    v12[-2] = vcvtq_f32_f16(*(float16x4_t *)v15.i8);
    v12[-1] = vcvt_hight_f32_f16(v15);
    *v12 = v16;
    v12[1] = v17;
    v12 += 4;
    v13 += 4;
    v14 -= 16;
  }
  while (v14);
  if (v10 != v6)
    goto LABEL_9;
LABEL_11:
  vDSP_vneg(v9, 1, v9, 1, v6);
  v43 = v6;
  vvexpf(v9, v9, &v43);
  __B = 1.0;
  vDSP_vsadd(v9, 1, &__B, v9, 1, v6);
  vvrecf(v9, v9, &v43);
  if (v6 <= 0xF)
  {
    v28 = 0;
LABEL_16:
    v37 = v6 - v28;
    v38 = (_WORD *)a3 + v28;
    v39 = &v9[v28];
    do
    {
      v40 = *(_DWORD *)v39++;
      _Q0.i32[0] = v40;
      __asm { FCVT            H0, S0 }
      *v38++ = _Q0.i16[0];
      --v37;
    }
    while (v37);
    return _Q0.i16[0];
  }
  v28 = v6 & 0xFFFFFFF0;
  v29 = a3 + 4;
  v30 = (float32x4_t *)(v9 + 8);
  v31 = v28;
  do
  {
    v33 = v30[-2];
    v32 = v30[-1];
    v35 = *v30;
    v34 = v30[1];
    v30 += 4;
    v36 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v33), v32);
    _Q0 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v35), v34);
    *((float16x8_t *)v29 - 1) = v36;
    *(float16x8_t *)v29 = _Q0;
    v29 += 8;
    v31 -= 16;
  }
  while (v31);
  if (v28 != v6)
    goto LABEL_16;
  return _Q0.i16[0];
}

void Nfp16PalettizedLayer::~Nfp16PalettizedLayer(Nfp16PalettizedLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16PalettizedLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*a5 != ((2 * ((*(_DWORD *)a2 * *a3) & 0x3FFFFFFF) + 15) & 0xFFFFFFF0) + 32)
    Error::chuck((Error *)"Nfp16PalettizedLayer::initialize() - Incorrect data size", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  *(_QWORD *)(this + 24) = a4 + 32;
  return this;
}

void Nfp16PalettizedLayer::compute(Nfp16PalettizedLayer *this, const float *a2, float *a3, void *a4)
{
  unsigned __int8 *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 *v11;
  unsigned int v12;
  const float *v14;

  v4 = (unsigned __int8 *)*((_QWORD *)this + 3);
  if (!v4)
    Error::chuck((Error *)"Nfp16PalettizedLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v5 = (2 * *((_DWORD *)this + 3));
  if ((_DWORD)v5)
  {
    v6 = (2 * *((_DWORD *)this + 2));
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = *((_QWORD *)this + 2);
      do
      {
        v9 = 0;
        _S0 = 0.0;
        v11 = v4;
        do
        {
          v12 = *v11++;
          _H1 = *(_WORD *)(v8 + 2 * (v12 & 0xF));
          v14 = &a2[v9 / 2];
          _H2 = *(_WORD *)(v8 + 2 * (v12 >> 4));
          _H3 = *(_WORD *)v14;
          _H4 = *((_WORD *)v14 + 1);
          __asm
          {
            FCVT            S4, H4
            FCVT            S2, H2
          }
          _S2 = _S2 * _S4;
          __asm
          {
            FCVT            H2, S2
            FCVT            S3, H3
            FCVT            S1, H1
          }
          _S1 = _S1 * _S3;
          __asm
          {
            FCVT            H1, S1
            FCVT            S1, H1
            FCVT            S2, H2
          }
          _S1 = _S1 + _S2;
          __asm
          {
            FCVT            H1, S1
            FCVT            S1, H1
          }
          _S0 = _S0 + _S1;
          v9 += 2;
        }
        while (v9 < v6);
        v4 += ((v6 - 1) >> 1) + 1;
        __asm { FCVT            H0, S0 }
        *((_WORD *)a3 + v7++) = _H0;
      }
      while (v7 != v5);
    }
    else
    {
      bzero(a3, 2 * (2 * *((_DWORD *)this + 3)));
    }
  }
}

void Nfp16MatrixLayer::~Nfp16MatrixLayer(Nfp16MatrixLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16MatrixLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;
  int v6;

  v5 = *(_DWORD *)a2;
  v6 = *a3;
  if (((2 * v6 + 7) & 0xFFFFFFF8) + ((2 * *(_DWORD *)a2 + 7) & 0xFFFFFFF8) * 2 * v6 != *a5 >> 1)
    Error::chuck((Error *)"Nfp16MatrixLayer::initialize() - Incorrect data size", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!v6)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

__n128 Nfp16MatrixLayer::compute(Nfp16MatrixLayer *this, const float *a2, float *a3, void *a4, __n128 result)
{
  __int16 *v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v27;
  float *v28;
  _WORD *v29;
  uint64_t v30;
  uint64_t v64;
  __int16 *v65;
  __int16 v66;
  uint64_t v72;
  uint64_t v73;
  unint64_t v75;
  uint64_t v77;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  uint64_t v137;

  v5 = (__int16 *)*((_QWORD *)this + 2);
  if (!v5)
    Error::chuck((Error *)"Nfp16MatrixLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v6 = (2 * *((_DWORD *)this + 3));
  if ((_DWORD)v6)
  {
    v8 = *((_DWORD *)this + 2);
    v9 = (2 * v8);
    if ((_DWORD)v9)
    {
      v10 = 2 * (v9 - 2);
      if (v9 >= 0x10)
      {
        v72 = 0;
        v73 = v10 + 4 * (-v8 & 3) + 4;
        do
        {
          v75 = 0;
          _S0 = 0.0;
          v77 = v9 & 0xFFFFFFF0;
          do
          {
            _Q2 = *(_OWORD *)&v5[v75 / 2];
            _Q7 = *(_OWORD *)&v5[v75 / 2 + 8];
            _Q3 = *(_OWORD *)&a2[v75 / 4];
            _Q17 = *(_OWORD *)&a2[v75 / 4 + 4];
            _H1 = HIWORD(*(_QWORD *)&a2[v75 / 4]);
            __asm { FCVT            S1, H1 }
            _H4 = HIWORD(*(_QWORD *)&v5[v75 / 2]);
            __asm { FCVT            S4, H4 }
            _H5 = WORD2(*(_QWORD *)&a2[v75 / 4]);
            _S4 = _S4 * _S1;
            __asm { FCVT            S1, H5 }
            _H5 = WORD2(*(_QWORD *)&v5[v75 / 2]);
            __asm
            {
              FCVT            S5, H5
              FCVT            S6, H3
              FCVT            S16, H2
            }
            _S5 = _S5 * _S1;
            *(float *)_D1.i32 = _S16 * _S6;
            LOWORD(_S6) = WORD1(_Q3);
            __asm { FCVT            S6, H6 }
            LOWORD(_S16) = WORD1(_Q2);
            __asm
            {
              FCVT            S16, H16
              FCVT            H1, S1
            }
            _S6 = _S16 * _S6;
            __asm { FCVT            H6, S6 }
            LOWORD(_S16) = HIWORD(_Q3);
            __asm { FCVT            S16, H16 }
            _H18 = HIWORD(_Q2);
            __asm
            {
              FCVT            H4, S4
              FCVT            S18, H18
            }
            _S18 = _S18 * _S16;
            LOWORD(_S16) = WORD6(_Q3);
            __asm { FCVT            S19, H16 }
            _H20 = WORD6(_Q2);
            __asm
            {
              FCVT            H16, S5
              FCVT            S5, H20
            }
            _S5 = _S5 * _S19;
            LOWORD(_S19) = *(_QWORD *)&a2[v75 / 4 + 2];
            __asm { FCVT            S20, H19 }
            _H21 = *(_QWORD *)&v5[v75 / 2 + 4];
            __asm
            {
              FCVT            H19, S18
              FCVT            S18, H21
            }
            _S18 = _S18 * _S20;
            LOWORD(_Q3) = WORD1(*(_QWORD *)&a2[v75 / 4 + 2]);
            __asm { FCVT            S3, H3 }
            LOWORD(_Q2) = WORD1(*(_QWORD *)&v5[v75 / 2 + 4]);
            __asm
            {
              FCVT            H21, S5
              FCVT            S2, H2
            }
            *(float *)&_Q2 = *(float *)&_Q2 * *(float *)&_Q3;
            LOWORD(_Q3) = HIWORD(*(_QWORD *)&a2[v75 / 4 + 4]);
            __asm { FCVT            S3, H3 }
            LOWORD(_S5) = HIWORD(*(_QWORD *)&v5[v75 / 2 + 8]);
            __asm
            {
              FCVT            H22, S18
              FCVT            S5, H5
            }
            *(float *)&_Q3 = _S5 * *(float *)&_Q3;
            LOWORD(_S5) = WORD2(*(_QWORD *)&a2[v75 / 4 + 4]);
            __asm { FCVT            S5, H5 }
            LOWORD(_S18) = WORD2(*(_QWORD *)&v5[v75 / 2 + 8]);
            __asm
            {
              FCVT            H23, S2
              FCVT            S2, H18
            }
            _S5 = *(float *)&_Q2 * _S5;
            __asm
            {
              FCVT            S2, H17
              FCVT            S18, H7
            }
            *(float *)&_Q2 = _S18 * *(float *)&_Q2;
            __asm
            {
              FCVT            H3, S3
              FCVT            H2, S2
            }
            LOWORD(_S18) = WORD1(_Q17);
            __asm { FCVT            S18, H18 }
            LOWORD(_S20) = WORD1(_Q7);
            __asm
            {
              FCVT            S20, H20
              FCVT            H5, S5
            }
            _S18 = _S20 * _S18;
            LOWORD(_S20) = HIWORD(_Q17);
            __asm { FCVT            S20, H20 }
            _H24 = HIWORD(_Q7);
            __asm
            {
              FCVT            S24, H24
              FCVT            H18, S18
            }
            _S20 = _S24 * _S20;
            LOWORD(_S24) = WORD6(_Q17);
            __asm { FCVT            S24, H24 }
            _H25 = WORD6(_Q7);
            __asm
            {
              FCVT            S25, H25
              FCVT            H20, S20
            }
            _S24 = _S25 * _S24;
            LOWORD(_S25) = *(_QWORD *)&a2[v75 / 4 + 6];
            __asm { FCVT            S25, H25 }
            _H26 = *(_QWORD *)&v5[v75 / 2 + 12];
            __asm
            {
              FCVT            S26, H26
              FCVT            H24, S24
            }
            _S25 = _S26 * _S25;
            LOWORD(_Q17) = WORD1(*(_QWORD *)&a2[v75 / 4 + 6]);
            __asm { FCVT            S26, H17 }
            LOWORD(_Q7) = WORD1(*(_QWORD *)&v5[v75 / 2 + 12]);
            __asm
            {
              FCVT            S7, H7
              FCVT            H17, S25
            }
            *(float *)&_Q7 = *(float *)&_Q7 * _S26;
            __asm { FCVT            H25, S7 }
            _D22.i16[1] = _H23;
            _D22.i16[2] = _H21;
            _D22.i16[3] = LOWORD(_S19);
            v133 = vcvtq_f32_f16(_D22);
            _D1.i16[1] = LOWORD(_S6);
            _D1.i16[2] = LOWORD(_S16);
            _D1.i16[3] = LOWORD(_S4);
            v134 = vcvtq_f32_f16(_D1);
            WORD1(_Q17) = LOWORD(_S25);
            WORD2(_Q17) = LOWORD(_S24);
            WORD3(_Q17) = LOWORD(_S20);
            WORD1(_Q2) = LOWORD(_S18);
            v135 = vcvtq_f32_f16(*(float16x4_t *)&_Q17);
            WORD2(_Q2) = LOWORD(_S5);
            WORD3(_Q2) = _Q3;
            v136 = vcvtq_f32_f16(*(float16x4_t *)&_Q2);
            _S0 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(_S0 + v134.f32[0]) + v134.f32[1]) + v134.f32[2]) + v134.f32[3]) + v133.f32[0])
                                                                                                + v133.f32[1])
                                                                                        + v133.f32[2])
                                                                                + v133.f32[3])
                                                                        + v136.f32[0])
                                                                + v136.f32[1])
                                                        + v136.f32[2])
                                                + v136.f32[3])
                                        + v135.f32[0])
                                + v135.f32[1])
                        + v135.f32[2])
                + v135.f32[3];
            v75 += 32;
            v77 -= 16;
          }
          while (v77);
          if ((v9 & 0xFFFFFFF0) != v9)
          {
            v137 = v9 & 0xFFFFFFF0;
            do
            {
              _H1 = v5[v137];
              _H2 = *((_WORD *)a2 + v137);
              __asm
              {
                FCVT            S2, H2
                FCVT            S1, H1
              }
              _S1 = _S1 * _S2;
              __asm
              {
                FCVT            H1, S1
                FCVT            S1, H1
              }
              _S0 = _S0 + _S1;
              ++v137;
            }
            while (v9 != v137);
          }
          __asm { FCVT            H0, S0 }
          *((_WORD *)a3 + v72) = _H0;
          v5 = (__int16 *)((char *)v5 + v73);
          ++v72;
        }
        while (v72 != v6);
      }
      else
      {
        v11 = 0;
        v12 = 2 * v9;
        v13 = v10 + 4 * (-v8 & 3) + 4;
        do
        {
          v14 = 0;
          _S0 = 0.0;
          do
          {
            _H1 = v5[v14 / 2];
            _H2 = *(_WORD *)((char *)a2 + v14);
            __asm
            {
              FCVT            S2, H2
              FCVT            S1, H1
            }
            _S1 = _S1 * _S2;
            __asm
            {
              FCVT            H1, S1
              FCVT            S1, H1
            }
            _S0 = _S0 + _S1;
            v14 += 2;
          }
          while (v12 != v14);
          __asm { FCVT            H0, S0 }
          *((_WORD *)a3 + v11) = _H0;
          v5 = (__int16 *)((char *)v5 + v13);
          ++v11;
        }
        while (v11 != v6);
      }
    }
    else
    {
      bzero(a3, 2 * (2 * *((_DWORD *)this + 3)));
      v5 = (__int16 *)((char *)v5 + (4 * (v6 - 2) + 8) * (-v8 & 3));
    }
    if (v6 < 0x10 || (&v5[v6] > (__int16 *)a3 ? (_CF = v5 >= (__int16 *)a3 + v6) : (_CF = 1), !_CF))
    {
      v27 = 0;
LABEL_22:
      v64 = v6 - v27;
      v65 = (__int16 *)a3 + v27;
      do
      {
        v66 = *v5++;
        _H0 = v66;
        _H1 = *v65;
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        _S0 = _S0 + _S1;
        __asm { FCVT            H0, S0 }
        *v65++ = result.n128_u16[0];
        --v64;
      }
      while (v64);
      return result;
    }
    v27 = v6 & 0xFFFFFFF0;
    v28 = a3 + 4;
    v29 = v5 + 8;
    v30 = v27;
    do
    {
      _Q3 = *((_OWORD *)v29 - 1);
      _Q0 = *(_OWORD *)v29;
      _Q4 = *((_OWORD *)v28 - 1);
      _Q1 = *(_OWORD *)v28;
      _H2 = WORD1(_Q4);
      __asm { FCVT            S2, H2 }
      _H5 = WORD1(_Q3);
      __asm { FCVT            S5, H5 }
      _S2 = _S5 + _S2;
      __asm
      {
        FCVT            H5, S2
        FCVT            S2, H4
        FCVT            S6, H3
      }
      *(float *)&_Q2 = _S6 + _S2;
      __asm { FCVT            H2, S2 }
      WORD1(_Q2) = LOWORD(_S5);
      LOWORD(_S5) = WORD2(*((_QWORD *)v28 - 2));
      __asm { FCVT            S5, H5 }
      LOWORD(_S6) = WORD2(*((_QWORD *)v29 - 2));
      __asm { FCVT            S6, H6 }
      _S5 = _S6 + _S5;
      __asm { FCVT            H5, S5 }
      WORD2(_Q2) = LOWORD(_S5);
      LOWORD(_S5) = HIWORD(*((_QWORD *)v28 - 2));
      __asm { FCVT            S5, H5 }
      LOWORD(_S6) = HIWORD(*((_QWORD *)v29 - 2));
      __asm { FCVT            S6, H6 }
      _S5 = _S6 + _S5;
      __asm { FCVT            H5, S5 }
      WORD3(_Q2) = LOWORD(_S5);
      LOWORD(_S5) = *((_QWORD *)v28 - 1);
      __asm { FCVT            S5, H5 }
      LOWORD(_S6) = *((_QWORD *)v29 - 1);
      __asm { FCVT            S6, H6 }
      _S5 = _S6 + _S5;
      __asm { FCVT            H5, S5 }
      WORD4(_Q2) = LOWORD(_S5);
      LOWORD(_S5) = WORD1(*((_QWORD *)v28 - 1));
      __asm { FCVT            S5, H5 }
      LOWORD(_S6) = WORD1(*((_QWORD *)v29 - 1));
      __asm { FCVT            S6, H6 }
      _S5 = _S6 + _S5;
      __asm { FCVT            H5, S5 }
      WORD5(_Q2) = LOWORD(_S5);
      LOWORD(_S5) = WORD6(_Q4);
      __asm { FCVT            S5, H5 }
      LOWORD(_S6) = WORD6(_Q3);
      __asm { FCVT            S6, H6 }
      _S5 = _S6 + _S5;
      __asm { FCVT            H5, S5 }
      WORD6(_Q2) = LOWORD(_S5);
      LOWORD(_Q4) = HIWORD(_Q4);
      __asm { FCVT            S4, H4 }
      LOWORD(_Q3) = HIWORD(_Q3);
      __asm { FCVT            S3, H3 }
      *(float *)&_Q3 = *(float *)&_Q3 + *(float *)&_Q4;
      __asm { FCVT            H3, S3 }
      HIWORD(_Q2) = _Q3;
      LOWORD(_Q3) = WORD1(*(_OWORD *)v28);
      __asm { FCVT            S3, H3 }
      LOWORD(_Q4) = WORD1(*(_OWORD *)v29);
      __asm { FCVT            S4, H4 }
      *(float *)&_Q3 = *(float *)&_Q4 + *(float *)&_Q3;
      __asm
      {
        FCVT            H3, S3
        FCVT            S4, H1
        FCVT            S5, H0
      }
      *(float *)&_Q4 = _S5 + *(float *)&_Q4;
      __asm { FCVT            H4, S4 }
      WORD1(_Q4) = _Q3;
      LOWORD(_Q3) = WORD2(*(_QWORD *)v28);
      __asm { FCVT            S3, H3 }
      LOWORD(_S5) = WORD2(*(_QWORD *)v29);
      __asm { FCVT            S5, H5 }
      *(float *)&_Q3 = _S5 + *(float *)&_Q3;
      __asm { FCVT            H3, S3 }
      WORD2(_Q4) = _Q3;
      LOWORD(_Q3) = HIWORD(*(_QWORD *)v28);
      __asm { FCVT            S3, H3 }
      LOWORD(_S5) = HIWORD(*(_QWORD *)v29);
      __asm { FCVT            S5, H5 }
      *(float *)&_Q3 = _S5 + *(float *)&_Q3;
      __asm { FCVT            H3, S3 }
      WORD3(_Q4) = _Q3;
      LOWORD(_Q3) = *((_QWORD *)v28 + 1);
      __asm { FCVT            S3, H3 }
      LOWORD(_S5) = *((_QWORD *)v29 + 1);
      __asm { FCVT            S5, H5 }
      *(float *)&_Q3 = _S5 + *(float *)&_Q3;
      __asm { FCVT            H3, S3 }
      WORD4(_Q4) = _Q3;
      LOWORD(_Q3) = WORD1(*((_QWORD *)v28 + 1));
      __asm { FCVT            S3, H3 }
      LOWORD(_S5) = WORD1(*((_QWORD *)v29 + 1));
      __asm { FCVT            S5, H5 }
      *(float *)&_Q3 = _S5 + *(float *)&_Q3;
      __asm { FCVT            H3, S3 }
      WORD5(_Q4) = _Q3;
      LOWORD(_Q3) = WORD6(*(_OWORD *)v28);
      __asm { FCVT            S3, H3 }
      LOWORD(_S5) = WORD6(*(_OWORD *)v29);
      __asm { FCVT            S5, H5 }
      *(float *)&_Q3 = _S5 + *(float *)&_Q3;
      __asm { FCVT            H3, S3 }
      WORD6(_Q4) = _Q3;
      LOWORD(_Q1) = HIWORD(*(_OWORD *)v28);
      __asm { FCVT            S1, H1 }
      LOWORD(_Q0) = HIWORD(*(_OWORD *)v29);
      __asm { FCVT            S0, H0 }
      *(float *)&_Q0 = *(float *)&_Q0 + *(float *)&_Q1;
      __asm { FCVT            H0, S0 }
      HIWORD(_Q4) = result.n128_u16[0];
      *((_OWORD *)v28 - 1) = _Q2;
      *(_OWORD *)v28 = _Q4;
      v28 += 8;
      v29 += 16;
      v30 -= 16;
    }
    while (v30);
    if (v27 != v6)
    {
      v5 += v6 & 0xFFFFFFF0;
      goto LABEL_22;
    }
  }
  return result;
}

void Nfp16OffsetLayer::~Nfp16OffsetLayer(Nfp16OffsetLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16OffsetLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;

  v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2)
    Error::chuck((Error *)"Nfp16OffsetLayer::initialize() - Incorrect data size", a2, a3, a4);
  if (v5 != *a3)
    Error::chuck((Error *)"Nfp16OffsetLayer::initialize() - Input and output not same", a2);
  if (*a5 <= 3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

__int16 Nfp16OffsetLayer::compute@<H0>(Nfp16OffsetLayer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  __int128 *v8;
  const float *v9;
  uint64_t v10;
  __int16 result;
  uint64_t v69;
  uint64_t v70;
  _WORD *v71;
  __int16 *v72;
  __int16 *v73;
  __int16 v74;
  __int16 v76;

  v4 = *((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"Nfp16OffsetLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v5 = (2 * *((_DWORD *)this + 2));
  if ((_DWORD)v5)
  {
    if (v5 <= 0xF)
    {
      v6 = 0;
LABEL_10:
      v69 = v5 - v6;
      v70 = 2 * v6;
      v71 = (_WORD *)a3 + v6;
      v72 = (__int16 *)(v4 + v70);
      v73 = (__int16 *)((char *)a2 + v70);
      do
      {
        v74 = *v73++;
        _H0 = v74;
        v76 = *v72++;
        _H1 = v76;
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        _S0 = _S0 + _S1;
        __asm { FCVT            H0, S0 }
        *v71++ = result;
        --v69;
      }
      while (v69);
      return result;
    }
    v6 = 0;
    if ((unint64_t)((char *)a3 - (char *)a2) < 0x20)
      goto LABEL_10;
    if ((unint64_t)a3 - v4 < 0x20)
      goto LABEL_10;
    v6 = v5 & 0xFFFFFFF0;
    v7 = a3 + 4;
    v8 = (__int128 *)(v4 + 16);
    v9 = a2 + 4;
    v10 = v6;
    do
    {
      _Q5 = *((_OWORD *)v9 - 1);
      _Q0 = *(_OWORD *)v9;
      _Q2 = *(v8 - 1);
      _Q1 = *v8;
      _H3 = WORD1(_Q2);
      __asm { FCVT            S3, H3 }
      _H4 = WORD1(_Q5);
      __asm
      {
        FCVT            S6, H2
        FCVT            S7, H5
        FCVT            S4, H4
      }
      _S6 = _S7 + _S6;
      LOWORD(_S7) = WORD2(*((_QWORD *)v8 - 2));
      __asm { FCVT            S7, H7 }
      _H16 = WORD2(*((_QWORD *)v9 - 2));
      __asm { FCVT            S16, H16 }
      _S17 = _S4 + _S3;
      _S3 = _S16 + _S7;
      LOWORD(_S4) = HIWORD(*((_QWORD *)v8 - 2));
      __asm { FCVT            S4, H4 }
      LOWORD(_S7) = HIWORD(*((_QWORD *)v9 - 2));
      __asm { FCVT            S7, H7 }
      _S7 = _S7 + _S4;
      LOWORD(_S4) = *((_QWORD *)v8 - 1);
      __asm { FCVT            S4, H4 }
      LOWORD(_S16) = *((_QWORD *)v9 - 1);
      __asm { FCVT            S16, H16 }
      _H18 = WORD1(*((_QWORD *)v8 - 1));
      _S16 = _S16 + _S4;
      __asm { FCVT            S4, H18 }
      _H18 = WORD1(*((_QWORD *)v9 - 1));
      __asm { FCVT            S18, H18 }
      _H19 = WORD6(_Q2);
      __asm { FCVT            S19, H19 }
      _S18 = _S18 + _S4;
      LOWORD(_S4) = WORD6(_Q5);
      __asm { FCVT            S4, H4 }
      _S4 = _S4 + _S19;
      LOWORD(_Q2) = HIWORD(_Q2);
      __asm
      {
        FCVT            S19, H2
        FCVT            H2, S6
      }
      LOWORD(_Q5) = HIWORD(_Q5);
      __asm { FCVT            S5, H5 }
      *(float *)&_Q5 = *(float *)&_Q5 + _S19;
      LOWORD(_S6) = WORD1(*v8);
      __asm
      {
        FCVT            S6, H6
        FCVT            H17, S17
      }
      LOWORD(_S19) = WORD1(*(_OWORD *)v9);
      __asm { FCVT            S19, H19 }
      _S6 = _S19 + _S6;
      __asm { FCVT            H6, S6 }
      WORD1(_Q2) = LOWORD(_S17);
      __asm
      {
        FCVT            S17, H1
        FCVT            S19, H0
      }
      *(float *)&_Q17 = _S19 + _S17;
      __asm { FCVT            H17, S17 }
      WORD1(_Q17) = LOWORD(_S6);
      LOWORD(_S6) = WORD2(*(_QWORD *)v8);
      __asm { FCVT            S6, H6 }
      LOWORD(_S19) = WORD2(*(_QWORD *)v9);
      __asm { FCVT            S19, H19 }
      _S6 = _S19 + _S6;
      __asm
      {
        FCVT            H3, S3
        FCVT            H7, S7
        FCVT            H16, S16
        FCVT            H18, S18
        FCVT            H6, S6
      }
      WORD2(_Q2) = LOWORD(_S3);
      WORD2(_Q17) = LOWORD(_S6);
      LOWORD(_S3) = HIWORD(*(_QWORD *)v8);
      __asm { FCVT            S3, H3 }
      WORD3(_Q2) = LOWORD(_S7);
      LOWORD(_S6) = HIWORD(*(_QWORD *)v9);
      __asm { FCVT            S6, H6 }
      _S3 = _S6 + _S3;
      __asm { FCVT            H3, S3 }
      WORD3(_Q17) = LOWORD(_S3);
      LOWORD(_S3) = *((_QWORD *)v8 + 1);
      __asm { FCVT            S3, H3 }
      LOWORD(_S6) = *((_QWORD *)v9 + 1);
      __asm { FCVT            S6, H6 }
      WORD4(_Q2) = LOWORD(_S16);
      _S3 = _S6 + _S3;
      __asm { FCVT            H3, S3 }
      LOWORD(_S6) = WORD1(*((_QWORD *)v8 + 1));
      __asm { FCVT            S6, H6 }
      WORD4(_Q17) = LOWORD(_S3);
      LOWORD(_S3) = WORD1(*((_QWORD *)v9 + 1));
      __asm { FCVT            S3, H3 }
      _S3 = _S3 + _S6;
      __asm { FCVT            H3, S3 }
      WORD5(_Q2) = LOWORD(_S18);
      LOWORD(_S6) = WORD6(*v8);
      __asm { FCVT            S6, H6 }
      LOWORD(_S7) = WORD6(*(_OWORD *)v9);
      __asm { FCVT            S7, H7 }
      WORD5(_Q17) = LOWORD(_S3);
      _S3 = _S7 + _S6;
      __asm
      {
        FCVT            H4, S4
        FCVT            H5, S5
        FCVT            H3, S3
      }
      WORD6(_Q2) = LOWORD(_S4);
      WORD6(_Q17) = LOWORD(_S3);
      LOWORD(_Q1) = HIWORD(*v8);
      __asm { FCVT            S1, H1 }
      HIWORD(_Q2) = _Q5;
      LOWORD(_Q0) = HIWORD(*(_OWORD *)v9);
      __asm { FCVT            S0, H0 }
      *(float *)&_Q0 = *(float *)&_Q0 + *(float *)&_Q1;
      __asm { FCVT            H0, S0 }
      HIWORD(_Q17) = result;
      *((_OWORD *)v7 - 1) = _Q2;
      *(_OWORD *)v7 = _Q17;
      v7 += 8;
      v8 += 2;
      v9 += 8;
      v10 -= 16;
    }
    while (v10);
    if (v6 != v5)
      goto LABEL_10;
  }
  return result;
}

void Nfp16ScaleLayer::~Nfp16ScaleLayer(Nfp16ScaleLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16ScaleLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;

  v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2)
    Error::chuck((Error *)"Nfp16ScaleLayer::initialize() - Incorrect data size", a2, a3, a4);
  if (v5 != *a3)
    Error::chuck((Error *)"Nfp16ScaleLayer::initialize() - Input and output not same", a2);
  if (*a5 <= 3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

__int16 Nfp16ScaleLayer::compute@<H0>(Nfp16ScaleLayer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  __int128 *v8;
  const float *v9;
  uint64_t v10;
  __int16 result;
  uint64_t v69;
  uint64_t v70;
  _WORD *v71;
  __int16 *v72;
  __int16 *v73;
  __int16 v74;
  __int16 v76;

  v4 = *((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"Nfp16ScaleLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v5 = (2 * *((_DWORD *)this + 2));
  if ((_DWORD)v5)
  {
    if (v5 <= 0xF)
    {
      v6 = 0;
LABEL_10:
      v69 = v5 - v6;
      v70 = 2 * v6;
      v71 = (_WORD *)a3 + v6;
      v72 = (__int16 *)(v4 + v70);
      v73 = (__int16 *)((char *)a2 + v70);
      do
      {
        v74 = *v73++;
        _H0 = v74;
        v76 = *v72++;
        _H1 = v76;
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        _S0 = _S0 * _S1;
        __asm { FCVT            H0, S0 }
        *v71++ = result;
        --v69;
      }
      while (v69);
      return result;
    }
    v6 = 0;
    if ((unint64_t)((char *)a3 - (char *)a2) < 0x20)
      goto LABEL_10;
    if ((unint64_t)a3 - v4 < 0x20)
      goto LABEL_10;
    v6 = v5 & 0xFFFFFFF0;
    v7 = a3 + 4;
    v8 = (__int128 *)(v4 + 16);
    v9 = a2 + 4;
    v10 = v6;
    do
    {
      _Q5 = *((_OWORD *)v9 - 1);
      _Q0 = *(_OWORD *)v9;
      _Q2 = *(v8 - 1);
      _Q1 = *v8;
      _H3 = WORD1(_Q2);
      __asm { FCVT            S3, H3 }
      _H4 = WORD1(_Q5);
      __asm
      {
        FCVT            S6, H2
        FCVT            S7, H5
        FCVT            S4, H4
      }
      _S6 = _S7 * _S6;
      LOWORD(_S7) = WORD2(*((_QWORD *)v8 - 2));
      __asm { FCVT            S7, H7 }
      _H16 = WORD2(*((_QWORD *)v9 - 2));
      __asm { FCVT            S16, H16 }
      _S17 = _S4 * _S3;
      _S3 = _S16 * _S7;
      LOWORD(_S4) = HIWORD(*((_QWORD *)v8 - 2));
      __asm { FCVT            S4, H4 }
      LOWORD(_S7) = HIWORD(*((_QWORD *)v9 - 2));
      __asm { FCVT            S7, H7 }
      _S7 = _S7 * _S4;
      LOWORD(_S4) = *((_QWORD *)v8 - 1);
      __asm { FCVT            S4, H4 }
      LOWORD(_S16) = *((_QWORD *)v9 - 1);
      __asm { FCVT            S16, H16 }
      _H18 = WORD1(*((_QWORD *)v8 - 1));
      _S16 = _S16 * _S4;
      __asm { FCVT            S4, H18 }
      _H18 = WORD1(*((_QWORD *)v9 - 1));
      __asm { FCVT            S18, H18 }
      _H19 = WORD6(_Q2);
      __asm { FCVT            S19, H19 }
      _S18 = _S18 * _S4;
      LOWORD(_S4) = WORD6(_Q5);
      __asm { FCVT            S4, H4 }
      _S4 = _S4 * _S19;
      LOWORD(_Q2) = HIWORD(_Q2);
      __asm
      {
        FCVT            S19, H2
        FCVT            H2, S6
      }
      LOWORD(_Q5) = HIWORD(_Q5);
      __asm { FCVT            S5, H5 }
      *(float *)&_Q5 = *(float *)&_Q5 * _S19;
      LOWORD(_S6) = WORD1(*v8);
      __asm
      {
        FCVT            S6, H6
        FCVT            H17, S17
      }
      LOWORD(_S19) = WORD1(*(_OWORD *)v9);
      __asm { FCVT            S19, H19 }
      _S6 = _S19 * _S6;
      __asm { FCVT            H6, S6 }
      WORD1(_Q2) = LOWORD(_S17);
      __asm
      {
        FCVT            S17, H1
        FCVT            S19, H0
      }
      *(float *)&_Q17 = _S19 * _S17;
      __asm { FCVT            H17, S17 }
      WORD1(_Q17) = LOWORD(_S6);
      LOWORD(_S6) = WORD2(*(_QWORD *)v8);
      __asm { FCVT            S6, H6 }
      LOWORD(_S19) = WORD2(*(_QWORD *)v9);
      __asm { FCVT            S19, H19 }
      _S6 = _S19 * _S6;
      __asm
      {
        FCVT            H3, S3
        FCVT            H7, S7
        FCVT            H16, S16
        FCVT            H18, S18
        FCVT            H6, S6
      }
      WORD2(_Q2) = LOWORD(_S3);
      WORD2(_Q17) = LOWORD(_S6);
      LOWORD(_S3) = HIWORD(*(_QWORD *)v8);
      __asm { FCVT            S3, H3 }
      WORD3(_Q2) = LOWORD(_S7);
      LOWORD(_S6) = HIWORD(*(_QWORD *)v9);
      __asm { FCVT            S6, H6 }
      _S3 = _S6 * _S3;
      __asm { FCVT            H3, S3 }
      WORD3(_Q17) = LOWORD(_S3);
      LOWORD(_S3) = *((_QWORD *)v8 + 1);
      __asm { FCVT            S3, H3 }
      LOWORD(_S6) = *((_QWORD *)v9 + 1);
      __asm { FCVT            S6, H6 }
      WORD4(_Q2) = LOWORD(_S16);
      _S3 = _S6 * _S3;
      __asm { FCVT            H3, S3 }
      LOWORD(_S6) = WORD1(*((_QWORD *)v8 + 1));
      __asm { FCVT            S6, H6 }
      WORD4(_Q17) = LOWORD(_S3);
      LOWORD(_S3) = WORD1(*((_QWORD *)v9 + 1));
      __asm { FCVT            S3, H3 }
      _S3 = _S3 * _S6;
      __asm { FCVT            H3, S3 }
      WORD5(_Q2) = LOWORD(_S18);
      LOWORD(_S6) = WORD6(*v8);
      __asm { FCVT            S6, H6 }
      LOWORD(_S7) = WORD6(*(_OWORD *)v9);
      __asm { FCVT            S7, H7 }
      WORD5(_Q17) = LOWORD(_S3);
      _S3 = _S7 * _S6;
      __asm
      {
        FCVT            H4, S4
        FCVT            H5, S5
        FCVT            H3, S3
      }
      WORD6(_Q2) = LOWORD(_S4);
      WORD6(_Q17) = LOWORD(_S3);
      LOWORD(_Q1) = HIWORD(*v8);
      __asm { FCVT            S1, H1 }
      HIWORD(_Q2) = _Q5;
      LOWORD(_Q0) = HIWORD(*(_OWORD *)v9);
      __asm { FCVT            S0, H0 }
      *(float *)&_Q0 = *(float *)&_Q0 * *(float *)&_Q1;
      __asm { FCVT            H0, S0 }
      HIWORD(_Q17) = result;
      *((_OWORD *)v7 - 1) = _Q2;
      *(_OWORD *)v7 = _Q17;
      v7 += 8;
      v8 += 2;
      v9 += 8;
      v10 -= 16;
    }
    while (v10);
    if (v6 != v5)
      goto LABEL_10;
  }
  return result;
}

void Nfp16tofp32Layer::~Nfp16tofp32Layer(Nfp16tofp32Layer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp16tofp32Layer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;

  v5 = *a3 + 1;
  if (v5 >> 1 != *(_DWORD *)a2)
    Error::chuck((Error *)"Nfp16tofp32Layer::initialize() - input and output size must be in ratio 1:2", a2);
  if (v5 <= 1)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5 >> 1;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

float32_t Nfp16tofp32Layer::compute(Nfp16tofp32Layer *this, float16x4_t *a2, float *a3, void *a4)
{
  uint64_t v4;
  uint64_t v5;
  float *v6;
  float16x4_t *v7;
  uint64_t v8;
  float16x8_t v9;
  float32x4_t v10;
  float32x4_t v12;
  float32x4_t v13;
  uint64_t v14;
  float *v15;
  __int16 *v16;
  __int16 v17;

  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"Nfp16tofp32Layer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v4 = *((unsigned int *)this + 3);
  if ((_DWORD)v4)
  {
    if (v4 <= 0xF)
    {
      v5 = 0;
LABEL_8:
      v14 = v4 - v5;
      v15 = &a3[v5];
      v16 = (__int16 *)a2 + v5;
      do
      {
        v17 = *v16++;
        _H0 = v17;
        __asm { FCVT            S0, H0 }
        *v15++ = _Q0.f32[0];
        --v14;
      }
      while (v14);
      return _Q0.f32[0];
    }
    v5 = v4 & 0xFFFFFFF0;
    v6 = a3 + 8;
    v7 = a2 + 2;
    v8 = v5;
    do
    {
      v9 = *(float16x8_t *)v7[-2].i8;
      v10 = vcvtq_f32_f16(*(float16x4_t *)v9.i8);
      _Q0 = vcvt_hight_f32_f16(v9);
      v12 = vcvtq_f32_f16(*v7);
      v13 = vcvt_hight_f32_f16(*(float16x8_t *)v7->i8);
      *((float32x4_t *)v6 - 2) = v10;
      *((float32x4_t *)v6 - 1) = _Q0;
      *(float32x4_t *)v6 = v12;
      *((float32x4_t *)v6 + 1) = v13;
      v6 += 16;
      v7 += 4;
      v8 -= 16;
    }
    while (v8);
    if (v5 != v4)
      goto LABEL_8;
  }
  return _Q0.f32[0];
}

void Nfp32tofp16Layer::~Nfp32tofp16Layer(Nfp32tofp16Layer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t Nfp32tofp16Layer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*a3 != (*(_DWORD *)a2 + 1) >> 1)
    Error::chuck((Error *)"Nfp32tofp16Layer::initialize() - input and output size must be in ratio 2:1", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if ((v5 + 1) <= 1)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

__int16 Nfp32tofp16Layer::compute@<H0>(Nfp32tofp16Layer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>)
{
  uint64_t v4;
  uint64_t v5;
  float *v6;
  const float *v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float16x8_t v13;
  uint64_t v15;
  _WORD *v16;
  const float *v17;
  __int32 v18;

  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"Nfp32tofp16Layer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v4 = *((unsigned int *)this + 2);
  a3[*((_DWORD *)this + 3) - 1] = 0.0;
  if ((_DWORD)v4)
  {
    if (v4 <= 0xF)
    {
      v5 = 0;
LABEL_8:
      v15 = v4 - v5;
      v16 = (_WORD *)a3 + v5;
      v17 = &a2[v5];
      do
      {
        v18 = *(_DWORD *)v17++;
        _Q0.i32[0] = v18;
        __asm { FCVT            H0, S0 }
        *v16++ = _Q0.i16[0];
        --v15;
      }
      while (v15);
      return _Q0.i16[0];
    }
    v5 = v4 & 0xFFFFFFF0;
    v6 = a3 + 4;
    v7 = a2 + 8;
    v8 = v5;
    do
    {
      v10 = *(float32x4_t *)(v7 - 8);
      v9 = *(float32x4_t *)(v7 - 4);
      v12 = *(float32x4_t *)v7;
      v11 = *(float32x4_t *)(v7 + 4);
      v7 += 16;
      v13 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v10), v9);
      _Q0 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v12), v11);
      *((float16x8_t *)v6 - 1) = v13;
      *(float16x8_t *)v6 = _Q0;
      v6 += 8;
      v8 -= 16;
    }
    while (v8);
    if (v5 != v4)
      goto LABEL_8;
  }
  return _Q0.i16[0];
}

void NSigned8BitMatrixLayer::~NSigned8BitMatrixLayer(NSigned8BitMatrixLayer *this)
{
  void *v1;

  *(_QWORD *)this = &off_24C7F2870;
  v1 = (void *)*((_QWORD *)this + 5);
  if (v1)
    BNNSFilterDestroy(v1);
}

{
  void *v1;

  *(_QWORD *)this = &off_24C7F2870;
  v1 = (void *)*((_QWORD *)this + 5);
  if (v1)
    BNNSFilterDestroy(v1);
  JUMPOUT(0x212BAC9D8);
}

void *NSigned8BitMatrixLayer::initialize(NSigned8BitMatrixLayer *this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  size_t v6;
  size_t v7;
  void *v8;
  void *result;
  const char *v10;
  BNNSFilterParameters v11;
  BNNSLayerParametersFullyConnected layer_params;

  N8BitMatrixLayer::initialize(this, a2, a3, a4, a5);
  v6 = *((unsigned int *)this + 3);
  v7 = (*((_DWORD *)this + 8) + *((_DWORD *)this + 2));
  v8 = (void *)*((_QWORD *)this + 2);
  *(_QWORD *)&layer_params.i_desc.flags = 0x1000000000000;
  layer_params.i_desc.size[0] = v7;
  memset(&layer_params.i_desc.size[1], 0, 128);
  *(_QWORD *)(&layer_params.i_desc.data_type + 1) = 0;
  layer_params.i_desc.data_type = BNNSDataTypeInt8;
  HIDWORD(layer_params.i_desc.table_data) = 0;
  *(_QWORD *)&layer_params.i_desc.table_data_type = 0x3F80000000020008;
  *(_QWORD *)&layer_params.i_desc.data_bias = 0;
  *(_QWORD *)&layer_params.w_desc.flags = 0x2000000000000;
  layer_params.w_desc.size[0] = v7;
  layer_params.w_desc.size[1] = v6;
  memset(&layer_params.w_desc.size[2], 0, 112);
  layer_params.w_desc.data = v8;
  *(_QWORD *)&layer_params.w_desc.data_type = 131080;
  layer_params.w_desc.table_data = 0;
  *(_QWORD *)&layer_params.w_desc.table_data_type = 0x3F80000000020008;
  *(_QWORD *)&layer_params.w_desc.data_bias = 0;
  *(_QWORD *)&layer_params.o_desc.flags = 0x1000000000000;
  layer_params.o_desc.size[0] = v6;
  memset(&layer_params.o_desc.size[1], 0, 128);
  layer_params.o_desc.data_type = BNNSDataTypeFloat32;
  *(_QWORD *)(&layer_params.o_desc.data_type + 1) = 0;
  HIDWORD(layer_params.o_desc.table_data) = 0;
  *(_QWORD *)&layer_params.o_desc.table_data_type = 0x3F80000000010020;
  memset(&layer_params.o_desc.data_bias, 0, 232);
  *(_OWORD *)&v11.alloc_memory = 0u;
  *(_QWORD *)&v11.flags = 1;
  v11.n_threads = 1;
  result = BNNSFilterCreateLayerFullyConnected(&layer_params, &v11);
  *((_QWORD *)this + 5) = result;
  if (!result)
    Error::chuck((Error *)"NSigned8BitMatrixLayer::compute() - BNNSFilter has not been successfully created at initialization", v10);
  return result;
}

uint64_t NSigned8BitMatrixLayer::compute(void **this, const float *a2, float *a3, void *a4, __n128 a5)
{
  float32x4_t *v7;
  unsigned int v8;
  unint64_t v9;
  int v10;
  __n128 v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  float32x4_t *v15;
  int8x8_t *v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  float *v24;
  float v25;
  uint64_t v26;
  int8x16_t *v27;
  uint64_t v28;
  int8x16_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x8_t *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  float32x4_t *v36;
  uint64_t result;
  const char *v38;
  uint64_t v39;
  int32x4_t *v40;
  uint64_t v41;
  float32x4_t *v42;
  int32x4_t *v43;
  uint64_t v44;
  float32x4_t v45;
  uint64_t v46;
  float *v47;
  int v48;
  const float *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float *v54;
  float v55;
  float32x4_t v56;
  float *v57;
  float32x4_t *v58;
  uint64_t v59;
  float32x4_t v60;
  _QWORD v61[2];

  v61[1] = *MEMORY[0x24BDAC8D0];
  v11 = MEMORY[0x24BDAC7A8](a5);
  v13 = (char *)v61 - v12;
  if (v9 >= 0x10)
  {
    v14 = v9 >> 4;
    v15 = v7 + 2;
    v16 = (int8x8_t *)(v13 + 8);
    v11 = (__n128)vdupq_n_s32(0x437F0000u);
    do
    {
      v17 = vmulq_f32(v15[-2], (float32x4_t)v11);
      v18 = vmulq_f32(v15[-1], (float32x4_t)v11);
      v19 = *v15;
      v20 = v15[1];
      v15 += 4;
      v16[-1] = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(v17), (int16x8_t)vcvtnq_s32_f32(v18)));
      *v16 = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(vmulq_f32(v19, (float32x4_t)v11)), (int16x8_t)vcvtnq_s32_f32(vmulq_f32(v20, (float32x4_t)v11))));
      v16 += 2;
      --v14;
    }
    while (v14);
  }
  v21 = v9 & 0xFFFFFFF0;
  if ((v9 & 0xFFFFFFF0) < v9)
  {
    v22 = v9 - v21;
    v23 = &v13[v21];
    v24 = (float *)((char *)v7->f32 + ((4 * v9) & 0x3FFFFFFC0));
    do
    {
      v25 = *v24++;
      v11.n128_f32[0] = rintf(v25 * 255.0);
      *v23++ = (uint64_t)v11.n128_f32[0];
      --v22;
    }
    while (v22);
  }
  if ((_DWORD)v9)
  {
    if (v9 < 8)
    {
      v26 = 0;
      goto LABEL_19;
    }
    if (v9 >= 0x20)
    {
      v26 = v9 & 0xFFFFFFE0;
      v27 = (int8x16_t *)(v13 + 16);
      v11.n128_u64[0] = 0x8080808080808080;
      v11.n128_u64[1] = 0x8080808080808080;
      v28 = v26;
      do
      {
        v29 = veorq_s8(*v27, (int8x16_t)v11);
        v27[-1] = veorq_s8(v27[-1], (int8x16_t)v11);
        *v27 = v29;
        v27 += 2;
        v28 -= 32;
      }
      while (v28);
      if (v26 == v9)
        goto LABEL_21;
      if ((v9 & 0x18) == 0)
      {
LABEL_19:
        v33 = v9 - v26;
        v34 = &v13[v26];
        do
        {
          *v34++ ^= 0x80u;
          --v33;
        }
        while (v33);
        goto LABEL_21;
      }
    }
    else
    {
      v26 = 0;
    }
    v30 = v26;
    v26 = v9 & 0xFFFFFFF8;
    v31 = v30 - v26;
    v32 = (int8x8_t *)&v13[v30];
    v11.n128_u64[0] = 0x8080808080808080;
    do
    {
      *v32 = veor_s8(*v32, (int8x8_t)0x8080808080808080);
      ++v32;
      v31 += 8;
    }
    while (v31);
    if (v26 != v9)
      goto LABEL_19;
  }
LABEL_21:
  if (v9 < v8)
    bzero(&v13[v9], (v10 - 1) + 1);
  MEMORY[0x24BDAC7A8](v11);
  v36 = (float32x4_t *)((char *)v61 - ((v35 + 15) & 0x7FFFFFFF0));
  result = BNNSFilterApply(this[5], v13, v36);
  if ((_DWORD)result == -1)
    Error::chuck((Error *)"NSigned8BitMatrixLayer::compute() - BNNSFilterApply failed", v38);
  v39 = *((unsigned int *)this + 3);
  if (!(_DWORD)v39)
    return result;
  v40 = (int32x4_t *)this[3];
  if (v39 > 7)
  {
    v41 = v39 & 0xFFFFFFF8;
    v42 = v36 + 1;
    v43 = v40 + 1;
    v44 = v41;
    do
    {
      v45 = vaddq_f32(*v42, vcvtq_f32_s32(*v43));
      v42[-1] = vaddq_f32(v42[-1], vcvtq_f32_s32(v43[-1]));
      *v42 = v45;
      v42 += 2;
      v43 += 2;
      v44 -= 8;
    }
    while (v44);
    if (v41 == v39)
      goto LABEL_33;
    v40 = (int32x4_t *)((char *)v40 + 4 * (v39 & 0xFFFFFFF8));
  }
  else
  {
    v41 = 0;
  }
  v46 = v39 - v41;
  v47 = &v36->f32[v41];
  do
  {
    v48 = v40->i32[0];
    v40 = (int32x4_t *)((char *)v40 + 4);
    *v47 = *v47 + (float)v48;
    ++v47;
    --v46;
  }
  while (v46);
LABEL_33:
  v49 = (const float *)this + 9;
  if (v39 <= 7 || this + 5 > (void **)a3 && v49 < &a3[v39])
  {
    v50 = 0;
LABEL_37:
    v51 = v39 - v50;
    v52 = v50;
    v53 = &a3[v50];
    v54 = &v36->f32[v52];
    do
    {
      v55 = *v54++;
      *v53++ = v55 * *v49;
      --v51;
    }
    while (v51);
    return result;
  }
  v50 = v39 & 0xFFFFFFF8;
  v56 = vld1q_dup_f32(v49);
  v57 = a3 + 4;
  v58 = v36 + 1;
  v59 = v50;
  do
  {
    v60 = vmulq_f32(*v58, v56);
    *((float32x4_t *)v57 - 1) = vmulq_f32(v58[-1], v56);
    *(float32x4_t *)v57 = v60;
    v57 += 8;
    v58 += 2;
    v59 -= 8;
  }
  while (v59);
  if (v50 != v39)
    goto LABEL_37;
  return result;
}

float N8BitMatrixLayer::initialize(N8BitMatrixLayer *this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;
  unsigned int v6;
  unsigned int v7;
  float result;

  if ((a4 & 0xF) != 0)
    Error::chuck((Error *)"N8BitMatrixLayer::initialize() - Unaligned data block", a2, a3);
  v5 = *(_DWORD *)a2;
  v6 = (*(_DWORD *)a2 + 15) & 0xFFFFFFF0;
  v7 = v6 * *a3;
  if (*a5 != ((((4 * *a3 + 15) & 0xFFFFFFF0) + v7) | 4))
    Error::chuck((Error *)"N8BitMatrixLayer::initialize() - Incorrect data size", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *((_DWORD *)this + 2) = v5;
  *((_DWORD *)this + 3) = *a3;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = &a4[v7];
  *((_DWORD *)this + 8) = v6 - *(_DWORD *)a2;
  result = *(float *)&a4[*a5 - 4] * 0.00392156863;
  *((float *)this + 9) = result;
  return result;
}

void N8BitLSTMLayer::~N8BitLSTMLayer(N8BitLSTMLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLSTMLayer::initialize(NLSTMLayer *this, const char *a2, unsigned int *a3, const char *a4, const unsigned int *a5)
{
  uint64_t result;
  const char *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  __int16 v27;
  unsigned int v28;
  const char *v29;

  if ((a4 & 0xF) != 0)
    Error::chuck((Error *)"NLSTMLayer::initialize() - Unaligned data block", a2, a3);
  v29 = a4;
  v28 = 0;
  v27 = 0;
  v26 = *a5;
  result = (*(uint64_t (**)(NLSTMLayer *, int *, const char **, unsigned int *, char *, __int16 *))(*(_QWORD *)this + 64))(this, &v26, &v29, &v28, (char *)&v27 + 1, &v27);
  v12 = v27;
  v13 = v28;
  v14 = *a3;
  if ((_BYTE)v27)
  {
    if (v28 <= v14)
      Error::chuck((Error *)"NLSTMLayer::initialize() - must be fewer outputs than cells when projecting", v11);
  }
  else if (v28 != v14)
  {
  }
  v15 = *(_DWORD *)a2;
  v16 = 4 * v28;
  v17 = v16 * ((*(_DWORD *)a2 * (_DWORD)result + 15) & 0x3FFFFFF0);
  v18 = v29;
  v19 = -(int)v29;
  v20 = (const char *)(v16 * ((v14 * (_DWORD)result + 15) & 0x3FFFFFF0));
  v21 = &v29[((_DWORD)v16 * ((*(_DWORD *)a2 * (_DWORD)result + 15) & 0x3FFFFFF0)) & 0xFFFFFFF0 | -(int)v29 & 0xFLL];
  *((_QWORD *)this + 4) = v29;
  *((_QWORD *)this + 5) = v21;
  *((_QWORD *)this + 6) = &v20[(_QWORD)v21];
  v22 = 16 * v13;
  v23 = (uint64_t)&v20[(_QWORD)v21 + v22];
  v29 = (const char *)v23;
  if (HIBYTE(v27))
  {
    *((_QWORD *)this + 7) = v23;
    *((_QWORD *)this + 8) = v23 + v16;
    *((_QWORD *)this + 9) = v23 + v16 + v16;
    v23 = (uint64_t)&v18[(v19 & 0xF) + (_QWORD)&v20[12 * v13 + (v16 & 0xC) + v17 + v22]];
    v29 = (const char *)v23;
  }
  if (v12)
  {
    *((_QWORD *)this + 10) = v23;
    v23 += (((v13 * (_DWORD)result + 15) & 0xFFFFFFF0) * v14) & 0xFFFFFFF0 | -(int)v23 & 0xFLL;
    v29 = (const char *)v23;
  }
  v24 = *a5;
  if (v23 - (_QWORD)a4 != v24)
    Error::chuck((Error *)"NLSTMLayer::initialize() - data block wrong size (%d != %d)", v20, v23 - (_QWORD)a4, v24);
  if ((v18 & 0xF) != 0 || (v21 & 0xF) != 0 || (*((_BYTE *)this + 80) & 0xF) != 0)
    Error::chuck((Error *)"NLSTMLayer::initialize() - Unaligned matrix", v20);
  if (!v15)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", v20);
  if (!v14)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", v20);
  *((_DWORD *)this + 2) = v15;
  *((_DWORD *)this + 3) = *a3;
  *((_DWORD *)this + 4) = v13;
  v25 = v13 + (-v13 & 0xF);
  *((_DWORD *)this + 5) = 2 * v25;
  *((_DWORD *)this + 6) = v25;
  return result;
}

float32_t NLSTMLayer::compute(NLSTMLayer *this, const float *a2, float *a3, _QWORD *a4, __n128 a5)
{
  uint64_t v5;
  int *v6;
  float *v9;
  uint64_t v10;
  __n128 v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  float32x4_t *v22;
  float32x4_t *v23;
  uint64_t v24;
  float32x4_t v25;
  uint64_t v26;
  uint64_t v27;
  float *v28;
  float *v29;
  float v30;
  float *v31;
  unint64_t v32;
  unint64_t v33;
  float32x4_t *v34;
  BOOL v35;
  uint64_t v36;
  float *v37;
  BOOL v39;
  float32x4_t *v41;
  float32x4_t *v42;
  float32x4_t *v43;
  uint64_t v44;
  float32x4_t v45;
  uint64_t v46;
  uint64_t v47;
  float *v48;
  float *v49;
  float *v50;
  float v51;
  float v52;
  float v53;
  float32x4_t *v54;
  uint64_t v55;
  float *v56;
  BOOL v58;
  float32x4_t *v60;
  float32x4_t *v61;
  float32x4_t *v62;
  uint64_t v63;
  float32x4_t v64;
  uint64_t v65;
  uint64_t v66;
  float *v67;
  float *v68;
  float *v69;
  float v70;
  float v71;
  float v72;
  vDSP_Length v73;
  int *v74;
  vDSP_Length v75;
  uint64_t v76;
  unint64_t v77;
  int *v78;
  vDSP_Length v79;
  float *v80;
  uint64_t v81;
  vDSP_Length v82;
  uint64_t v83;
  float *v84;
  float *v85;
  float v86;
  uint64_t v87;
  vDSP_Length v88;
  uint64_t v89;
  float *v90;
  float *v91;
  float v92;
  float v93;
  float *v94;
  vDSP_Length v95;
  float v96;
  float v97;
  float v98;
  float32x4_t *v99;
  uint64_t v100;
  vDSP_Length v101;
  uint64_t v102;
  float *v103;
  float *v104;
  float *v105;
  float v106;
  float v107;
  float v108;
  uint64_t v109;
  uint64_t v110;
  float *v111;
  uint64_t v112;
  __int128 v113;
  float *v114;
  float32x4_t *v115;
  float32x4_t *v116;
  uint64_t v117;
  float32x4_t v118;
  float *v119;
  BOOL v121;
  float32x4_t *v123;
  float32x4_t *v124;
  float32x4_t *v125;
  uint64_t v126;
  float32x4_t v127;
  float32x4_t *v128;
  uint64_t v129;
  float32x4_t v130;
  float32x4_t *v131;
  float32x4_t *v132;
  uint64_t v133;
  float32x4_t v134;
  uint64_t v135;
  float *v136;
  float32x4_t v137;
  uint64_t v138;
  BOOL v139;
  uint64_t v140;
  float32x4_t *v141;
  float32x4_t *v142;
  uint64_t v143;
  float32x4_t v144;
  uint64_t v145;
  uint64_t v146;
  float *v147;
  float *v148;
  float v149;
  uint64_t v150;
  float *v151;
  uint64_t v152;
  uint64_t v153;
  float32x4_t *v154;
  float32x4_t *v155;
  uint64_t v156;
  float32x4_t v157;
  uint64_t v158;
  uint64_t v159;
  float *v160;
  __int32 *v161;
  __int32 v162;
  uint64_t v163;
  float *v164;
  uint64_t v166;
  float32x4_t *v167;
  float32x4_t *v168;
  uint64_t v169;
  float32x4_t v170;
  uint64_t v171;
  uint64_t v172;
  __int32 *v173;
  float *v174;
  __int32 v175;
  unint64_t v177;
  float *v178;
  float *v179;
  int *v180;
  float __B;
  int v182;
  uint64_t v183;

  v183 = *MEMORY[0x24BDAC8D0];
  v6 = (int *)((char *)this + 16);
  v5 = *((unsigned int *)this + 4);
  if (!(_DWORD)v5)
    Error::chuck((Error *)"NLSTMLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  if (!a4)
    Error::chuck((Error *)"NLSTMLayer::compute() - State uninitialized", (const char *)a2, a3);
  v9 = (float *)a4[1];
  v10 = *((unsigned int *)this + 6);
  v11 = MEMORY[0x24BDAC7A8](a5);
  v13 = (float *)((char *)&v177 - v12);
  v14 = (2 * v5);
  v15 = (3 * v5);
  v179 = (float *)((char *)&v177 + 4 * v15 - v12);
  (*(void (**)(_QWORD *, int *, _QWORD, _QWORD, __n128))(*v16 + 72))(v16, v6, v16[4], v16[5], v11);
  v17 = *((unsigned int *)this + 4);
  v18 = (4 * v17);
  if ((_DWORD)v18)
  {
    v19 = *((_QWORD *)this + 6);
    if (v18 > 7
      && ((unint64_t)v13 < v19 + 4 * v18 ? (v20 = v19 >= (unint64_t)&v13[v18]) : (v20 = 1), v20))
    {
      v21 = v18 & 0xFFFFFFF8;
      v22 = (float32x4_t *)(v13 + 4);
      v23 = (float32x4_t *)(v19 + 16);
      v24 = v21;
      do
      {
        v25 = vaddq_f32(*v23, *v22);
        v22[-1] = vaddq_f32(v23[-1], v22[-1]);
        *v22 = v25;
        v22 += 2;
        v23 += 2;
        v24 -= 8;
      }
      while (v24);
      if (v21 == v18)
        goto LABEL_17;
    }
    else
    {
      v21 = 0;
    }
    v26 = v18 - v21;
    v27 = 4 * v21;
    v28 = &v13[v21];
    v29 = (float *)(v19 + v27);
    do
    {
      v30 = *v29++;
      *v28 = v30 + *v28;
      ++v28;
      --v26;
    }
    while (v26);
  }
LABEL_17:
  v180 = v6;
  v178 = a3;
  v31 = &v9[v10];
  v32 = (unint64_t)&v13[v14];
  v33 = (unint64_t)&v13[v5];
  v34 = (float32x4_t *)*((_QWORD *)this + 7);
  if (v34)
    v35 = (_DWORD)v17 == 0;
  else
    v35 = 1;
  if (v35)
    goto LABEL_59;
  if (v17 > 0xB)
  {
    v36 = 0;
    v37 = &v13[v17];
    v39 = v13 < &v9[v17 + v10] && v31 < v37;
    if ((v34 >= (float32x4_t *)v37 || v13 >= &v34->f32[v17]) && !v39)
    {
      v36 = v17 & 0xFFFFFFF8;
      v41 = (float32x4_t *)(v13 + 4);
      v42 = (float32x4_t *)&v9[v10 + 4];
      v43 = v34 + 1;
      v44 = v36;
      do
      {
        v45 = vmlaq_f32(*v41, *v42, *v43);
        v41[-1] = vmlaq_f32(v41[-1], v42[-1], v43[-1]);
        *v41 = v45;
        v41 += 2;
        v42 += 2;
        v43 += 2;
        v44 -= 8;
      }
      while (v44);
      if (v36 == v17)
        goto LABEL_40;
    }
  }
  else
  {
    v36 = 0;
  }
  v46 = v17 - v36;
  v47 = v36;
  v48 = &v13[v36];
  v49 = &v9[v10 + v47];
  v50 = &v34->f32[v47];
  do
  {
    v51 = *v50++;
    v52 = v51;
    v53 = *v49++;
    *v48 = *v48 + (float)(v52 * v53);
    ++v48;
    --v46;
  }
  while (v46);
LABEL_40:
  v54 = (float32x4_t *)*((_QWORD *)this + 8);
  if (v17 <= 0xB)
  {
    v55 = 0;
LABEL_57:
    v65 = v17 - v55;
    v66 = v55;
    v67 = &v13[v55 + v5];
    v68 = &v9[v10 + v66];
    v69 = &v54->f32[v66];
    do
    {
      v70 = *v69++;
      v71 = v70;
      v72 = *v68++;
      *v67 = *v67 + (float)(v71 * v72);
      ++v67;
      --v65;
    }
    while (v65);
    goto LABEL_59;
  }
  v55 = 0;
  v56 = &v13[v17 + v5];
  v58 = v33 < (unint64_t)&v9[v17 + v10] && v31 < v56;
  if (v54 < (float32x4_t *)v56 && v33 < (unint64_t)v54->u64 + 4 * v17)
    goto LABEL_57;
  if (v58)
    goto LABEL_57;
  v55 = v17 & 0xFFFFFFF8;
  v60 = v54 + 1;
  v61 = (float32x4_t *)&v13[v5 + 4];
  v62 = (float32x4_t *)&v9[v10 + 4];
  v63 = v55;
  do
  {
    v64 = vmlaq_f32(*v61, *v62, *v60);
    v61[-1] = vmlaq_f32(v61[-1], v62[-1], v60[-1]);
    *v61 = v64;
    v60 += 2;
    v61 += 2;
    v62 += 2;
    v63 -= 8;
  }
  while (v63);
  if (v55 != v17)
    goto LABEL_57;
LABEL_59:
  v177 = (unint64_t)&v13[v5];
  v73 = (2 * v17);
  vDSP_vneg(v13, 1, v13, 1, v73);
  v182 = v73;
  vvexpf(v13, v13, &v182);
  __B = 1.0;
  vDSP_vsadd(v13, 1, &__B, v13, 1, v73);
  vvrecf(v13, v13, &v182);
  v74 = v180;
  v182 = *v180;
  vvtanhf(v179, v179, &v182);
  v75 = *v74;
  if (!(_DWORD)v75)
  {
    v75 = 0;
    v78 = v180;
    goto LABEL_92;
  }
  if (v75 <= 7)
  {
    v76 = 0;
    v77 = (unint64_t)&v9[v10];
LABEL_66:
    v78 = v180;
LABEL_67:
    v79 = v75 - v76;
    v80 = &v13[v76];
    do
    {
      *v80 = v80[v15] * *v80;
      ++v80;
      --v79;
    }
    while (v79);
    goto LABEL_69;
  }
  v77 = (unint64_t)&v9[v10];
  if (v13 < &v13[v75 + v15] && v179 < &v13[v75])
  {
    v76 = 0;
    goto LABEL_66;
  }
  v76 = v75 & 0xFFFFFFF8;
  v128 = (float32x4_t *)v13;
  v129 = v76;
  v78 = v180;
  do
  {
    v130 = vmulq_f32(*(float32x4_t *)((char *)v128 + 4 * v15 + 16), v128[1]);
    *v128 = vmulq_f32(*(float32x4_t *)((char *)v128 + 4 * v15), *v128);
    v128[1] = v130;
    v128 += 2;
    v129 -= 8;
  }
  while (v129);
  if (v76 != v75)
    goto LABEL_67;
LABEL_69:
  if (v75 <= 7 || v177 < (unint64_t)&v9[v75 + v10] && v77 < (unint64_t)&v13[v75 + v5])
  {
    v81 = 0;
LABEL_73:
    v82 = v75 - v81;
    v83 = v81;
    v84 = &v13[v81 + v5];
    v85 = &v9[v10 + v83];
    do
    {
      v86 = *v85++;
      *v84 = v86 * *v84;
      ++v84;
      --v82;
    }
    while (v82);
    goto LABEL_75;
  }
  v81 = v75 & 0xFFFFFFF8;
  v131 = (float32x4_t *)&v13[v5 + 4];
  v132 = (float32x4_t *)&v9[v10 + 4];
  v133 = v81;
  do
  {
    v134 = vmulq_f32(*v132, *v131);
    v131[-1] = vmulq_f32(v132[-1], v131[-1]);
    *v131 = v134;
    v131 += 2;
    v132 += 2;
    v133 -= 8;
  }
  while (v133);
  if (v81 != v75)
    goto LABEL_73;
LABEL_75:
  if (v75 <= 0xB)
  {
    v87 = 0;
LABEL_77:
    v88 = v75 - v87;
    v89 = v87;
    v90 = &v9[v87 + v10];
    v91 = &v13[v89];
    do
    {
      v92 = v91[v5];
      v93 = *v91++;
      *v90++ = v93 + v92;
      --v88;
    }
    while (v88);
    goto LABEL_79;
  }
  v87 = 0;
  v114 = &v9[v10];
  if ((unint64_t)((char *)v114 - (char *)&v13[v5]) < 0x20)
    goto LABEL_77;
  if ((unint64_t)((char *)v114 - (char *)v13) < 0x20)
    goto LABEL_77;
  v87 = v75 & 0xFFFFFFF8;
  v115 = (float32x4_t *)&v9[v10 + 4];
  v116 = (float32x4_t *)v13;
  v117 = v87;
  do
  {
    v118 = vaddq_f32(v116[1], *(float32x4_t *)((char *)v116 + 4 * v5 + 16));
    v115[-1] = vaddq_f32(*v116, *(float32x4_t *)((char *)v116 + 4 * v5));
    *v115 = v118;
    v116 += 2;
    v115 += 2;
    v117 -= 8;
  }
  while (v117);
  if (v87 != v75)
    goto LABEL_77;
LABEL_79:
  if (*((float *)this + 22) != 0.0)
  {
    v94 = (float *)v77;
    v95 = v75;
    do
    {
      v96 = *((float *)this + 22);
      if (*v94 <= v96)
      {
        v97 = *((float *)this + 22);
        v96 = *v94;
      }
      else
      {
        *v94 = v96;
        v97 = *((float *)this + 22);
      }
      v98 = -v97;
      if (v96 < v98)
        *v94 = v98;
      ++v94;
      --v95;
    }
    while (v95);
  }
  v99 = (float32x4_t *)*((_QWORD *)this + 9);
  if (v99)
  {
    if (v75 < 0xC)
    {
      v100 = 0;
LABEL_90:
      v101 = v75 - v100;
      v102 = v100;
      v103 = &v13[v100 + v14];
      v104 = &v9[v10 + v102];
      v105 = &v99->f32[v102];
      do
      {
        v106 = *v105++;
        v107 = v106;
        v108 = *v104++;
        *v103 = *v103 + (float)(v107 * v108);
        ++v103;
        --v101;
      }
      while (v101);
      goto LABEL_92;
    }
    v100 = 0;
    v119 = &v13[v75 + v14];
    v121 = v32 < (unint64_t)&v9[v75 + v10] && v77 < (unint64_t)v119;
    if (v99 < (float32x4_t *)v119 && v32 < (unint64_t)v99->u64 + 4 * v75)
      goto LABEL_90;
    if (v121)
      goto LABEL_90;
    v100 = v75 & 0xFFFFFFF8;
    v123 = v99 + 1;
    v124 = (float32x4_t *)&v13[v14 + 4];
    v125 = (float32x4_t *)&v9[v10 + 4];
    v126 = v100;
    do
    {
      v127 = vmlaq_f32(*v124, *v125, *v123);
      v124[-1] = vmlaq_f32(v124[-1], v125[-1], v123[-1]);
      *v124 = v127;
      v123 += 2;
      v124 += 2;
      v125 += 2;
      v126 -= 8;
    }
    while (v126);
    if (v100 != v75)
      goto LABEL_90;
  }
LABEL_92:
  vDSP_vneg(&v13[v14], 1, &v13[v14], 1, v75);
  v182 = *v78;
  vvexpf(&v13[v14], &v13[v14], &v182);
  __B = 1.0;
  vDSP_vsadd(&v13[v14], 1, &__B, &v13[v14], 1, *v78);
  vvrecf(&v13[v14], &v13[v14], &v182);
  v109 = *v78;
  if (!(_DWORD)v109)
    goto LABEL_132;
  if (v109 < 8)
  {
    v110 = 0;
LABEL_130:
    v135 = v109 - v110;
    v136 = &v9[v110];
    do
    {
      *v136 = v136[v10];
      ++v136;
      --v135;
    }
    while (v135);
    goto LABEL_132;
  }
  v110 = 0;
  if ((unint64_t)(-4 * v10) <= 0x1F)
    goto LABEL_130;
  v110 = v109 & 0xFFFFFFF8;
  v111 = v9;
  v112 = v110;
  do
  {
    v113 = *(_OWORD *)&v111[v10 + 4];
    *(_OWORD *)v111 = *(_OWORD *)&v111[v10];
    *((_OWORD *)v111 + 1) = v113;
    v111 += 8;
    v112 -= 8;
  }
  while (v112);
  if (v110 != v109)
    goto LABEL_130;
LABEL_132:
  v182 = v109;
  vvtanhf(v9, v9, &v182);
  v138 = *v78;
  if (!(_DWORD)v138)
    goto LABEL_146;
  if (v138 <= 7
    || (v9 < &v13[v138 + v14] ? (v139 = v32 >= (unint64_t)&v9[v138]) : (v139 = 1), !v139))
  {
    v140 = 0;
LABEL_144:
    v145 = v138 - v140;
    v146 = v140;
    v147 = &v9[v140];
    v148 = &v13[v14 + v146];
    do
    {
      v149 = *v148++;
      v137.f32[0] = v149 * *v147;
      *v147++ = v137.f32[0];
      --v145;
    }
    while (v145);
    goto LABEL_146;
  }
  v140 = v138 & 0xFFFFFFF8;
  v141 = (float32x4_t *)(v9 + 4);
  v142 = (float32x4_t *)&v13[v14 + 4];
  v143 = v140;
  do
  {
    v137 = vmulq_f32(v142[-1], v141[-1]);
    v144 = vmulq_f32(*v142, *v141);
    v141[-1] = v137;
    *v141 = v144;
    v141 += 2;
    v142 += 2;
    v143 -= 8;
  }
  while (v143);
  if (v140 != v138)
    goto LABEL_144;
LABEL_146:
  v150 = *((_QWORD *)this + 10);
  if (!v150)
  {
    v163 = *((unsigned int *)this + 3);
    v164 = v178;
    if (!(_DWORD)v163)
      return v137.f32[0];
    if (v163 >= 8 && (unint64_t)((char *)v178 - (char *)v9) > 0x1F)
    {
      v166 = v163 & 0xFFFFFFF8;
      v167 = (float32x4_t *)(v178 + 4);
      v168 = (float32x4_t *)(v9 + 4);
      v169 = v166;
      do
      {
        v137 = v168[-1];
        v170 = *v168;
        v167[-1] = v137;
        *v167 = v170;
        v167 += 2;
        v168 += 2;
        v169 -= 8;
      }
      while (v169);
      if (v166 == v163)
        return v137.f32[0];
    }
    else
    {
      v166 = 0;
    }
    v171 = v163 - v166;
    v172 = v166;
    v173 = (__int32 *)&v164[v166];
    v174 = &v9[v172];
    do
    {
      v175 = *(_DWORD *)v174++;
      v137.i32[0] = v175;
      *v173++ = v175;
      --v171;
    }
    while (v171);
    return v137.f32[0];
  }
  v151 = v178;
  (*(void (**)(NLSTMLayer *, int *, uint64_t, float *, float *))(*(_QWORD *)this + 80))(this, v78, v150, v9, v178);
  v152 = *((unsigned int *)this + 3);
  if ((_DWORD)v152)
  {
    v153 = 0;
    if (v152 < 8)
      goto LABEL_153;
    if ((unint64_t)((char *)v9 - (char *)v151) < 0x20)
      goto LABEL_153;
    v153 = v152 & 0xFFFFFFF8;
    v154 = (float32x4_t *)(v9 + 4);
    v155 = (float32x4_t *)(v151 + 4);
    v156 = v153;
    do
    {
      v137 = v155[-1];
      v157 = *v155;
      v154[-1] = v137;
      *v154 = v157;
      v154 += 2;
      v155 += 2;
      v156 -= 8;
    }
    while (v156);
    if (v153 != v152)
    {
LABEL_153:
      v158 = v152 - v153;
      v159 = v153;
      v160 = &v9[v153];
      v161 = (__int32 *)&v151[v159];
      do
      {
        v162 = *v161++;
        v137.i32[0] = v162;
        *(_DWORD *)v160++ = v162;
        --v158;
      }
      while (v158);
    }
  }
  return v137.f32[0];
}

uint64_t NLSTMLayer::allocateStateP(NLSTMLayer *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;

  v2 = operator new();
  *(_QWORD *)v2 = &off_24C7F3090;
  v3 = (void *)operator new[]();
  *(_QWORD *)(v2 + 8) = v3;
  v4 = *((unsigned int *)this + 5);
  *(_DWORD *)(v2 + 16) = v4;
  if ((_DWORD)v4)
    bzero(v3, 4 * v4);
  return v2;
}

void sub_20D9B35C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x1081C40622C3295);
  _Unwind_Resume(a1);
}

uint64_t NLSTMLayer::deallocateState(NLSTMLayer *this, void *a2)
{
  if (!a2)
    Error::chuck((Error *)"NLSTMLayer::compute() - State uninitialized", 0);
  return (*(uint64_t (**)(void *))(*(_QWORD *)a2 + 8))(a2);
}

void NLSTMLayer::resetState(NLSTMLayer *this, void **a2)
{
  uint64_t v2;

  if (!a2)
    Error::chuck((Error *)"NLSTMLayer::compute() - State uninitialized", 0);
  v2 = *((unsigned int *)this + 5);
  if ((_DWORD)v2)
    bzero(a2[1], 4 * v2);
}

uint64_t N8BitLSTMLayer::loadHeader(N8BitLSTMLayer *this, const char *a2, const char **a3, unsigned int *a4, BOOL *a5, BOOL *a6)
{
  unsigned int *v6;
  char *v7;

  if (*(int *)a2 <= 31)
    Error::chuck((Error *)"N8BitLSTMLayer::initialize() - data block too small for header", a2, a3, a4, a5, a6);
  v6 = (unsigned int *)*a3;
  *a4 = *(_DWORD *)*a3;
  *((_DWORD *)this + 22) = v6[1];
  *a5 = *((_BYTE *)v6 + 8);
  *a6 = *((_BYTE *)v6 + 9);
  v7 = (char *)v6 + ((6 - (_BYTE)v6) & 0xF);
  *((_DWORD *)this + 23) = *(_DWORD *)(v7 + 10);
  *((_DWORD *)this + 24) = *(_DWORD *)(v7 + 14);
  *((_DWORD *)this + 25) = *(_DWORD *)(v7 + 18);
  *a3 = v7 + 26;
  return 1;
}

uint64_t N8BitLSTMLayer::computeIFOC(N8BitLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, const float *a5, const float *a6, float *a7)
{
  char *v12;
  char v14;
  unsigned int v15;
  char v16;
  unsigned int v17;

  v17 = 4 * *a2;
  v16 = 0;
  v12 = (char *)this + 12;
  (*(void (**)(N8BitLSTMLayer *, unsigned int *, char *, const float *, const float *, float *, char *, char *))(*(_QWORD *)this + 88))(this, &v17, (char *)this + 8, a3, a5, a7, (char *)this + 92, &v16);
  v15 = 4 * *a2;
  v14 = 1;
  return (*(uint64_t (**)(N8BitLSTMLayer *, unsigned int *, char *, const float *, const float *, float *, char *, char *))(*(_QWORD *)this + 88))(this, &v15, v12, a4, a6, a7, (char *)this + 96, &v14);
}

uint64_t N8BitLSTMLayer::computeProjection(N8BitLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, float *a5)
{
  char v6;

  v6 = 0;
  return (*(uint64_t (**)(N8BitLSTMLayer *, char *, const unsigned int *, const float *, const float *, float *, char *, char *))(*(_QWORD *)this + 88))(this, (char *)this + 12, a2, a3, a4, a5, (char *)this + 100, &v6);
}

void N8BitLSTMLayer::MatrixMultiply8Bit(N8BitLSTMLayer *this, const unsigned int *a2, const unsigned int *a3, const signed __int8 *a4, float *a5, float32x4_t *a6, const float *a7, const BOOL *a8, __n128 a9)
{
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  __n128 v21;
  char *v22;
  unsigned int *v23;
  uint64_t v24;
  float *v25;
  uint64_t v26;
  int32x4_t v27;
  uint64_t v28;
  int32x4_t *v29;
  char *v30;
  uint64_t v31;
  float v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  const signed __int8 *v36;
  const signed __int8 *v37;
  const signed __int8 *v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int64x2_t v45;
  int32x4_t v46;
  int64x2_t v47;
  uint64_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int16x8_t v68;
  int16x8_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  uint64_t v78;
  int32x4_t v79;
  int32x4_t v80;
  int16x8_t v81;
  int16x8_t v82;
  uint64_t v83;
  uint64_t v84;
  float32x4_t v85;
  float32x4_t *v86;
  int32x4_t *v87;
  uint64_t v88;
  float32x4_t v89;
  uint64_t v90;
  uint64_t v91;
  float *v92;
  int *v93;
  int v94;
  float *f32;
  int32x4_t *v96;
  uint64_t v97;
  float32x4_t v98;
  uint64_t v99;
  uint64_t v100;
  float *v101;
  int *v102;
  int v103;
  _QWORD v104[2];

  v104[1] = *MEMORY[0x24BDAC8D0];
  if (*a3)
  {
    a9.n128_u32[0] = 0;
    v15 = *a3;
    do
    {
      v16 = *a5++;
      v17 = v16;
      if (v16 > a9.n128_f32[0])
        a9.n128_f32[0] = v17;
      v18 = -v17;
      if (a9.n128_f32[0] < v18)
        a9.n128_f32[0] = v18;
      --v15;
    }
    while (v15);
  }
  else
  {
    a9.n128_u32[0] = 0;
  }
  if (a9.n128_f32[0] == 0.0)
    v19 = 127.0;
  else
    v19 = 127.0 / a9.n128_f32[0];
  v20 = (*a3 + 15) & 0xFFFFFFF0;
  v21 = MEMORY[0x24BDAC7A8](a9);
  v22 = (char *)v104 - v20;
  v24 = *v23;
  v27 = (int32x4_t)MEMORY[0x24BDAC7A8](v21);
  v29 = (int32x4_t *)((char *)v104 - ((v28 + 15) & 0x7FFFFFFF0));
  if ((_DWORD)v26)
  {
    v30 = (char *)v104 - v20;
    v31 = v26;
    do
    {
      v32 = *v25++;
      *v30++ = (uint64_t)rintf(v19 * v32);
      --v31;
    }
    while (v31);
  }
  if (v26 < v20)
    bzero(&v22[v26], (v20 + ~(_DWORD)v26) + 1);
  v33 = *((_DWORD *)this + 3) & 0xFFFFFFFC;
  if ((_DWORD)v33)
  {
    v34 = 0;
    v35 = (4 * v20);
    v36 = &a4[(3 * v20)];
    v37 = &a4[(2 * v20)];
    v38 = &a4[v20];
    do
    {
      if ((_DWORD)v20)
      {
        v48 = 0;
        v42 = 0uLL;
        v41 = 0uLL;
        v40 = 0uLL;
        v39 = 0uLL;
        do
        {
          v49 = vmovl_s8(*(int8x8_t *)&v22[v48]);
          v50 = vmovl_s8(*(int8x8_t *)&a4[v48]);
          v51 = vmovl_s8(*(int8x8_t *)&v38[v48]);
          v52 = vmovl_s8(*(int8x8_t *)&v37[v48]);
          v53 = vmovl_s8(*(int8x8_t *)&v36[v48]);
          v42 = vmlal_s16(vmlal_high_s16(v42, v49, v50), *(int16x4_t *)v49.i8, *(int16x4_t *)v50.i8);
          v39 = vmlal_s16(vmlal_high_s16(v39, v49, v51), *(int16x4_t *)v49.i8, *(int16x4_t *)v51.i8);
          v40 = vmlal_s16(vmlal_high_s16(v40, v49, v52), *(int16x4_t *)v49.i8, *(int16x4_t *)v52.i8);
          v41 = vmlal_s16(vmlal_high_s16(v41, v49, v53), *(int16x4_t *)v49.i8, *(int16x4_t *)v53.i8);
          v48 += 8;
        }
        while (v48 < v20);
      }
      else
      {
        v39 = 0uLL;
        v40 = 0uLL;
        v41 = 0uLL;
        v42 = 0uLL;
      }
      v43 = (int32x4_t)vpaddlq_s32(v42);
      v44 = (int32x4_t)vpaddlq_s32(v39);
      v45 = vpaddlq_s32(v40);
      v46.i64[0] = vzip1q_s32(v43, v44).u64[0];
      v46.i32[2] = v45.i32[0];
      v47 = vpaddlq_s32(v41);
      v46.i32[3] = v47.i32[0];
      v43.i64[0] = vzip2q_s32(v43, v44).u64[0];
      v43.i64[1] = __PAIR64__(v47.u32[2], v45.u32[2]);
      v27 = vaddq_s32(v46, v43);
      *(int32x4_t *)((char *)v29 + 4 * v34) = v27;
      a4 += v35;
      v34 += 4;
      v36 += v35;
      v37 += v35;
      v38 += v35;
    }
    while (v34 < v33);
  }
  else
  {
    LODWORD(v34) = 0;
  }
  if (v34 < v24)
  {
    if ((_DWORD)v20)
    {
      v34 = v34;
      v54 = v20 & 0xFFFFFFE0;
      while (1)
      {
        if (v20 >= 0x20)
        {
          v57 = 0;
          v58 = 0uLL;
          v59 = 0uLL;
          v60 = 0uLL;
          v61 = 0uLL;
          v62 = 0uLL;
          v63 = 0uLL;
          v64 = 0uLL;
          v65 = 0uLL;
          do
          {
            v66 = *(int8x16_t *)&a4[v57];
            v67 = *(int8x16_t *)&a4[v57 + 16];
            v68 = vmovl_s8(*(int8x8_t *)v66.i8);
            v69 = vmovl_high_s8(v66);
            v70 = vmovl_s8(*(int8x8_t *)v67.i8);
            v71 = vmovl_high_s8(v67);
            v72 = *(int8x16_t *)&v22[v57];
            v73 = *(int8x16_t *)&v22[v57 + 16];
            v74 = vmovl_s8(*(int8x8_t *)v72.i8);
            v75 = vmovl_high_s8(v72);
            v76 = vmovl_s8(*(int8x8_t *)v73.i8);
            v77 = vmovl_high_s8(v73);
            v61 = vmlal_high_s16(v61, v75, v69);
            v60 = vmlal_s16(v60, *(int16x4_t *)v75.i8, *(int16x4_t *)v69.i8);
            v59 = vmlal_high_s16(v59, v74, v68);
            v58 = vmlal_s16(v58, *(int16x4_t *)v74.i8, *(int16x4_t *)v68.i8);
            v65 = vmlal_high_s16(v65, v77, v71);
            v64 = vmlal_s16(v64, *(int16x4_t *)v77.i8, *(int16x4_t *)v71.i8);
            v63 = vmlal_high_s16(v63, v76, v70);
            v62 = vmlal_s16(v62, *(int16x4_t *)v76.i8, *(int16x4_t *)v70.i8);
            v57 += 32;
          }
          while (v54 != v57);
          v27 = vaddq_s32(vaddq_s32(vaddq_s32(v62, v58), vaddq_s32(v64, v60)), vaddq_s32(vaddq_s32(v63, v59), vaddq_s32(v65, v61)));
          v55 = vaddvq_s32(v27);
          if (v54 == v20)
            goto LABEL_30;
          v56 = v20 & 0xFFFFFFE0;
          v78 = v56;
          if ((v20 & 0x10) == 0)
          {
            do
            {
              v55 += v22[v78] * a4[v78];
              ++v78;
            }
            while (v20 != v78);
            goto LABEL_30;
          }
        }
        else
        {
          v55 = 0;
          v56 = 0;
        }
        v79 = 0uLL;
        v80 = (int32x4_t)v55;
        do
        {
          v81 = vmovl_s8(*(int8x8_t *)&a4[v56]);
          v82 = vmovl_s8(*(int8x8_t *)&v22[v56]);
          v79 = vmlal_high_s16(v79, v82, v81);
          v80 = vmlal_s16(v80, *(int16x4_t *)v82.i8, *(int16x4_t *)v81.i8);
          v56 += 8;
        }
        while (v20 != v56);
        v27 = vaddq_s32(v80, v79);
        v55 = vaddvq_s32(v27);
LABEL_30:
        a4 += (v20 - 16) + 16;
        v29->i32[v34++] = v55;
        if (v34 == v24)
          goto LABEL_43;
      }
    }
    bzero((char *)v29 + 4 * v34, 4 * (v24 + ~(_DWORD)v34) + 4);
  }
LABEL_43:
  *(float *)v27.i32 = *a7 / v19;
  if (!*a8)
  {
    if (!(_DWORD)v24)
      return;
    if (v24 > 7)
    {
      v84 = v24 & 0xFFFFFFF8;
      f32 = a6[1].f32;
      v96 = v29 + 1;
      v97 = v84;
      do
      {
        v98 = vmulq_n_f32(vcvtq_f32_s32(*v96), *(float *)v27.i32);
        *((float32x4_t *)f32 - 1) = vmulq_n_f32(vcvtq_f32_s32(v96[-1]), *(float *)v27.i32);
        *(float32x4_t *)f32 = v98;
        f32 += 8;
        v96 += 2;
        v97 -= 8;
      }
      while (v97);
      if (v84 == v24)
        return;
    }
    else
    {
      v84 = 0;
    }
    v99 = v24 - v84;
    v100 = v84;
    v101 = &a6->f32[v84];
    v102 = &v29->i32[v100];
    do
    {
      v103 = *v102++;
      *v101++ = *(float *)v27.i32 * (float)v103;
      --v99;
    }
    while (v99);
    return;
  }
  if (!(_DWORD)v24)
    return;
  if (v24 <= 7)
  {
    v83 = 0;
LABEL_53:
    v90 = v24 - v83;
    v91 = v83;
    v92 = &a6->f32[v83];
    v93 = &v29->i32[v91];
    do
    {
      v94 = *v93++;
      *v92 = *v92 + (float)((float)v94 * *(float *)v27.i32);
      ++v92;
      --v90;
    }
    while (v90);
    return;
  }
  v83 = v24 & 0xFFFFFFF8;
  v85 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 0);
  v86 = a6 + 1;
  v87 = v29 + 1;
  v88 = v83;
  do
  {
    v89 = vmlaq_f32(*v86, v85, vcvtq_f32_s32(*v87));
    v86[-1] = vmlaq_f32(v86[-1], v85, vcvtq_f32_s32(v87[-1]));
    *v86 = v89;
    v86 += 2;
    v87 += 2;
    v88 -= 8;
  }
  while (v88);
  if (v83 != v24)
    goto LABEL_53;
}

void NLSTMLayer::~NLSTMLayer(NLSTMLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLSTMLayer::loadHeader(NLSTMLayer *this, const char *a2, const char **a3, unsigned int *a4, BOOL *a5, BOOL *a6)
{
  unsigned int *v6;

  if (*(int *)a2 <= 15)
    Error::chuck((Error *)"NLSTMLayer::initialize() - data block too small for header", a2, a3, a4, a5, a6);
  v6 = (unsigned int *)*a3;
  *a4 = *(_DWORD *)*a3;
  *((_DWORD *)this + 22) = v6[1];
  *a5 = *((_BYTE *)v6 + 8);
  *a6 = *((_BYTE *)v6 + 9);
  *a3 = (char *)v6 + ((6 - v6) & 0xF) + 10;
  return 4;
}

void NLSTMLayer::computeIFOC(NLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, const float *a5, const float *a6, float *a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  const float *v18;
  unint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  const float *v28;
  unint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  uint64_t v37;
  const float *v38;
  float v39;
  const float *v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  float v45;
  float32x4_t v46;
  float32x4_t v47;
  uint64_t v48;
  uint64_t i;
  unint64_t v50;
  float v51;
  float32x4_t v52;
  float32x4_t v53;
  uint64_t v54;

  v7 = 4 * *a2;
  if ((_DWORD)v7)
  {
    v9 = *((unsigned int *)this + 2);
    v8 = *((unsigned int *)this + 3);
    v10 = -(int)v8 & 3;
    if ((_DWORD)v9)
    {
      v11 = -(int)v9 & 3;
      v12 = 4 * (v9 - 1);
      if ((_DWORD)v8)
      {
        v13 = 0;
        v14 = v12 + 4 * v11 + 4;
        v15 = 4 * v10 + 4 * (v8 - 1) + 4;
        while (v9 >= 8)
        {
          v19 = 0;
          v17 = 0.0;
          do
          {
            v20 = vmulq_f32(*(float32x4_t *)&a3[v19 / 4], *(float32x4_t *)&a5[v19 / 4]);
            v21 = vmulq_f32(*(float32x4_t *)&a3[v19 / 4 + 4], *(float32x4_t *)&a5[v19 / 4 + 4]);
            v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v20.f32[0]) + v20.f32[1]) + v20.f32[2])
                                                + v20.f32[3])
                                        + v21.f32[0])
                                + v21.f32[1])
                        + v21.f32[2])
                + v21.f32[3];
            v19 += 32;
          }
          while (((4 * v9) & 0x3FFFFFFE0) != v19);
          if ((v9 & 0xFFFFFFF8) != v9)
          {
            v18 = &a3[v9 & 0xFFFFFFF8];
            v16 = v9 & 0xFFFFFFF8;
LABEL_12:
            v22 = v9 - v16;
            v23 = (float *)&a5[v16];
            do
            {
              v24 = *v18++;
              v25 = v24;
              v26 = *v23++;
              v17 = v17 + (float)(v25 * v26);
              --v22;
            }
            while (v22);
          }
          if (v8 >= 8)
          {
            v29 = 0;
            do
            {
              v30 = vmulq_f32(*(float32x4_t *)&a4[v29 / 4], *(float32x4_t *)&a6[v29 / 4]);
              v31 = vmulq_f32(*(float32x4_t *)&a4[v29 / 4 + 4], *(float32x4_t *)&a6[v29 / 4 + 4]);
              v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v30.f32[0]) + v30.f32[1]) + v30.f32[2])
                                                  + v30.f32[3])
                                          + v31.f32[0])
                                  + v31.f32[1])
                          + v31.f32[2])
                  + v31.f32[3];
              v29 += 32;
            }
            while (((4 * v8) & 0x3FFFFFFE0) != v29);
            if ((v8 & 0xFFFFFFF8) == v8)
              goto LABEL_5;
            v28 = &a4[v8 & 0xFFFFFFF8];
            v27 = v8 & 0xFFFFFFF8;
          }
          else
          {
            v27 = 0;
            v28 = a4;
          }
          v32 = v8 - v27;
          v33 = (float *)&a6[v27];
          do
          {
            v34 = *v28++;
            v35 = v34;
            v36 = *v33++;
            v17 = v17 + (float)(v35 * v36);
            --v32;
          }
          while (v32);
LABEL_5:
          a3 = (const float *)((char *)a3 + v14);
          a4 = (const float *)((char *)a4 + v15);
          a7[v13++] = v17;
          if (v13 == v7)
            return;
        }
        v16 = 0;
        v17 = 0.0;
        v18 = a3;
        goto LABEL_12;
      }
      if (v9 >= 8)
      {
        for (i = 0; i != v7; ++i)
        {
          v50 = 0;
          v51 = 0.0;
          do
          {
            v52 = vmulq_f32(*(float32x4_t *)&a3[v50 / 4], *(float32x4_t *)&a5[v50 / 4]);
            v53 = vmulq_f32(*(float32x4_t *)&a3[v50 / 4 + 4], *(float32x4_t *)&a5[v50 / 4 + 4]);
            v51 = (float)((float)((float)((float)((float)((float)((float)(v51 + v52.f32[0]) + v52.f32[1]) + v52.f32[2])
                                                + v52.f32[3])
                                        + v53.f32[0])
                                + v53.f32[1])
                        + v53.f32[2])
                + v53.f32[3];
            v50 += 32;
          }
          while (((4 * v9) & 0x3FFFFFFE0) != v50);
          if ((v9 & 0xFFFFFFF8) != v9)
          {
            v54 = v9 & 0xFFFFFFF8;
            do
            {
              v51 = v51 + (float)(a3[v54] * a5[v54]);
              ++v54;
            }
            while (v9 != v54);
          }
          a7[i] = v51;
          a3 = (const float *)((char *)a3 + 4 * v11 + v12 + 4);
        }
      }
      else
      {
        v40 = a3 + 3;
        do
        {
          v41 = (float)(*(v40 - 3) * *a5) + 0.0;
          if ((_DWORD)v9 != 1)
          {
            v41 = v41 + (float)(*(v40 - 2) * a5[1]);
            if ((_DWORD)v9 != 2)
            {
              v41 = v41 + (float)(*(v40 - 1) * a5[2]);
              if ((_DWORD)v9 != 3)
              {
                v41 = v41 + (float)(*v40 * a5[3]);
                if ((_DWORD)v9 != 4)
                {
                  v41 = v41 + (float)(v40[1] * a5[4]);
                  if ((_DWORD)v9 != 5)
                  {
                    v41 = v41 + (float)(v40[2] * a5[5]);
                    if ((_DWORD)v9 != 6)
                      v41 = v41 + (float)(v40[3] * a5[6]);
                  }
                }
              }
            }
          }
          *a7++ = v41;
          v40 = (const float *)((char *)v40 + 4 * v11 + v12 + 4);
          --v7;
        }
        while (v7);
      }
    }
    else if ((_DWORD)v8)
    {
      v37 = 4 * (v8 - 1);
      if (v8 >= 8)
      {
        v42 = 0;
        v43 = v37 + 4 * v10 + 4;
        do
        {
          v44 = 0;
          v45 = 0.0;
          do
          {
            v46 = vmulq_f32(*(float32x4_t *)&a4[v44 / 4], *(float32x4_t *)&a6[v44 / 4]);
            v47 = vmulq_f32(*(float32x4_t *)&a4[v44 / 4 + 4], *(float32x4_t *)&a6[v44 / 4 + 4]);
            v45 = (float)((float)((float)((float)((float)((float)((float)(v45 + v46.f32[0]) + v46.f32[1]) + v46.f32[2])
                                                + v46.f32[3])
                                        + v47.f32[0])
                                + v47.f32[1])
                        + v47.f32[2])
                + v47.f32[3];
            v44 += 32;
          }
          while (((4 * v8) & 0x3FFFFFFE0) != v44);
          if ((v8 & 0xFFFFFFF8) != v8)
          {
            v48 = v8 & 0xFFFFFFF8;
            do
            {
              v45 = v45 + (float)(a4[v48] * a6[v48]);
              ++v48;
            }
            while (v8 != v48);
          }
          a7[v42++] = v45;
          a4 = (const float *)((char *)a4 + v43);
        }
        while (v42 != v7);
      }
      else
      {
        v38 = a4 + 3;
        do
        {
          v39 = (float)(*(v38 - 3) * *a6) + 0.0;
          if ((_DWORD)v8 != 1)
          {
            v39 = v39 + (float)(*(v38 - 2) * a6[1]);
            if ((_DWORD)v8 != 2)
            {
              v39 = v39 + (float)(*(v38 - 1) * a6[2]);
              if ((_DWORD)v8 != 3)
              {
                v39 = v39 + (float)(*v38 * a6[3]);
                if ((_DWORD)v8 != 4)
                {
                  v39 = v39 + (float)(v38[1] * a6[4]);
                  if ((_DWORD)v8 != 5)
                  {
                    v39 = v39 + (float)(v38[2] * a6[5]);
                    if ((_DWORD)v8 != 6)
                      v39 = v39 + (float)(v38[3] * a6[6]);
                  }
                }
              }
            }
          }
          *a7++ = v39;
          v38 = (const float *)((char *)v38 + 4 * v10 + v37 + 4);
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      bzero(a7, 16 * *a2);
    }
  }
}

void NLSTMLayer::computeProjection(NLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, float *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const float *v8;
  float v9;
  uint64_t i;
  unint64_t v11;
  float v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;

  v5 = *((unsigned int *)this + 3);
  if ((_DWORD)v5)
  {
    v6 = *a2;
    if ((_DWORD)v6)
    {
      v7 = 4 * (v6 - 1) + 4;
      if (v6 >= 8)
      {
        for (i = 0; i != v5; ++i)
        {
          v11 = 0;
          v12 = 0.0;
          do
          {
            v13 = vmulq_f32(*(float32x4_t *)&a3[v11 / 4], *(float32x4_t *)&a4[v11 / 4]);
            v14 = vmulq_f32(*(float32x4_t *)&a3[v11 / 4 + 4], *(float32x4_t *)&a4[v11 / 4 + 4]);
            v12 = (float)((float)((float)((float)((float)((float)((float)(v12 + v13.f32[0]) + v13.f32[1]) + v13.f32[2])
                                                + v13.f32[3])
                                        + v14.f32[0])
                                + v14.f32[1])
                        + v14.f32[2])
                + v14.f32[3];
            v11 += 32;
          }
          while (((4 * v6) & 0x3FFFFFFE0) != v11);
          if ((v6 & 0xFFFFFFF8) != v6)
          {
            v15 = v6 & 0xFFFFFFF8;
            do
            {
              v12 = v12 + (float)(a3[v15] * a4[v15]);
              ++v15;
            }
            while (v6 != v15);
          }
          a3 = (const float *)((char *)a3 + v7);
          a5[i] = v12;
        }
      }
      else
      {
        v8 = a3 + 3;
        do
        {
          v9 = (float)(*(v8 - 3) * *a4) + 0.0;
          if ((_DWORD)v6 != 1)
          {
            v9 = v9 + (float)(*(v8 - 2) * a4[1]);
            if ((_DWORD)v6 != 2)
            {
              v9 = v9 + (float)(*(v8 - 1) * a4[2]);
              if ((_DWORD)v6 != 3)
              {
                v9 = v9 + (float)(*v8 * a4[3]);
                if ((_DWORD)v6 != 4)
                {
                  v9 = v9 + (float)(v8[1] * a4[4]);
                  if ((_DWORD)v6 != 5)
                  {
                    v9 = v9 + (float)(v8[2] * a4[5]);
                    if ((_DWORD)v6 != 6)
                      v9 = v9 + (float)(v8[3] * a4[6]);
                  }
                }
              }
            }
          }
          *a5++ = v9;
          v8 = (const float *)((char *)v8 + v7);
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      bzero(a5, 4 * v5);
    }
  }
}

void N4BitMatrixLayer::~N4BitMatrixLayer(N4BitMatrixLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

float N4BitMatrixLayer::initialize(N4BitMatrixLayer *this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;
  unsigned int v6;
  float result;

  if ((a4 & 0xF) != 0)
    Error::chuck((Error *)"N4BitMatrixLayer::initialize() - Unaligned data block", a2, a3);
  v5 = *(_DWORD *)a2;
  v6 = (((*(_DWORD *)a2 + 1) >> 1) + 15) & 0xFFFFFFF0;
  if (*a5 != ((v6 * *a3) | 4))
    Error::chuck((Error *)"N4BitMatrixLayer::initialize() - Incorrect data size", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *((_DWORD *)this + 2) = v5;
  *((_DWORD *)this + 3) = *a3;
  *((_QWORD *)this + 2) = a4;
  *((_DWORD *)this + 6) = 2 * v6 - *(_DWORD *)a2;
  result = *(float *)&a4[*a5 - 4] * 0.00392156863;
  *((float *)this + 7) = result;
  return result;
}

void N4BitMatrixLayer::compute(N4BitMatrixLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  int8x16_t *v5;
  unint64_t v8;
  float *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __n128 v13;
  char *v14;
  char *v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  size_t v19;
  int32x4_t *v20;
  unint64_t v21;
  uint64_t i;
  unint64_t v23;
  __int32 v24;
  int8x16_t *v25;
  int v26;
  const float *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  int *v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  int32x4_t v36;
  int8x16_t *v37;
  int32x4_t v38;
  const char *v39;
  unint64_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  const char *v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int16x8_t v67;
  int16x8_t v68;
  int16x8_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int v72;
  unint64_t v73;
  int v74;
  float32x4_t v75;
  float *v76;
  int32x4_t *v77;
  uint64_t v78;
  float32x4_t v79;
  _QWORD v80[2];
  int8x16x2_t v81;
  int8x16x2_t v82;

  v80[1] = *MEMORY[0x24BDAC8D0];
  v5 = (int8x16_t *)*((_QWORD *)this + 2);
  if (!v5)
    Error::chuck((Error *)"N4BitMatrixLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v8 = (*((_DWORD *)this + 6) + *((_DWORD *)this + 2));
  v13 = MEMORY[0x24BDAC7A8](a5);
  v14 = (char *)v80 - v12;
  if ((_DWORD)v10)
  {
    v15 = (char *)v80 - v12;
    v16 = v10;
    do
    {
      v17 = *v9++;
      v13.n128_f32[0] = rintf(v17 * 255.0);
      *v15++ = (uint64_t)v13.n128_f32[0] ^ 0x80;
      --v16;
    }
    while (v16);
  }
  if (v10 < v8)
    bzero(&v14[v10], (v11 - 1) + 1);
  v18 = *((unsigned int *)this + 3);
  MEMORY[0x24BDAC7A8](v13);
  v20 = (int32x4_t *)((char *)v80 - ((v19 + 15) & 0x7FFFFFFF0));
  if ((_DWORD)v18)
  {
    if ((_DWORD)v8)
    {
      v21 = ((v8 - 1) >> 1) + 1;
      if (v8 >= 0x3F)
      {
        v34 = 0;
        v35 = v21 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v36 = 0uLL;
          v37 = v5 + 1;
          v38 = 0uLL;
          v39 = v14 + 32;
          v40 = v21 & 0xFFFFFFFFFFFFFFE0;
          v41 = 0uLL;
          v42 = 0uLL;
          v43 = 0uLL;
          v44 = 0uLL;
          v45 = 0uLL;
          v46 = 0uLL;
          do
          {
            v47 = v39 - 32;
            v81 = vld2q_s8(v47);
            v48 = v37[-1];
            v82 = vld2q_s8(v39);
            v49 = vshrq_n_s8(vshlq_n_s8(v48, 4uLL), 4uLL);
            v50 = vshrq_n_s8(vshlq_n_s8(*v37, 4uLL), 4uLL);
            v51 = vmovl_high_s8(v49);
            v52 = vmovl_s8(*(int8x8_t *)v49.i8);
            v53 = vmovl_high_s8(v50);
            v54 = vmovl_s8(*(int8x8_t *)v50.i8);
            v55 = vmovl_high_s8(v81.val[0]);
            v56 = vmovl_s8(*(int8x8_t *)v81.val[0].i8);
            v57 = vmovl_high_s8(v82.val[0]);
            v58 = vmovl_s8(*(int8x8_t *)v82.val[0].i8);
            v59 = vmlal_s16(v36, *(int16x4_t *)v52.i8, *(int16x4_t *)v56.i8);
            v60 = vmlal_high_s16(v38, v52, v56);
            v61 = vmlal_s16(v41, *(int16x4_t *)v51.i8, *(int16x4_t *)v55.i8);
            v62 = vmlal_high_s16(v42, v51, v55);
            v63 = vmlal_s16(v43, *(int16x4_t *)v54.i8, *(int16x4_t *)v58.i8);
            v64 = vmlal_high_s16(v44, v54, v58);
            v65 = vshrq_n_s8(v48, 4uLL);
            v66 = vshrq_n_s8(*v37, 4uLL);
            v67 = vmovl_s8(*(int8x8_t *)v65.i8);
            v68 = vmovl_high_s8(v65);
            v69 = vmovl_s8(*(int8x8_t *)v66.i8);
            v70 = vmovl_high_s8(v66);
            v71 = vmovl_s8(*(int8x8_t *)v81.val[1].i8);
            v81.val[0] = (int8x16_t)vmovl_high_s8(v81.val[1]);
            v81.val[1] = (int8x16_t)vmovl_s8(*(int8x8_t *)v82.val[1].i8);
            v82.val[0] = (int8x16_t)vmovl_high_s8(v82.val[1]);
            v42 = vmlal_high_s16(v62, (int16x8_t)v81.val[0], v68);
            v41 = vmlal_s16(v61, *(int16x4_t *)v81.val[0].i8, *(int16x4_t *)v68.i8);
            v38 = vmlal_high_s16(v60, v71, v67);
            v36 = vmlal_s16(v59, *(int16x4_t *)v71.i8, *(int16x4_t *)v67.i8);
            v46 = vmlal_high_s16(vmlal_high_s16(v46, v53, v57), (int16x8_t)v82.val[0], v70);
            v45 = vmlal_s16(vmlal_s16(v45, *(int16x4_t *)v53.i8, *(int16x4_t *)v57.i8), *(int16x4_t *)v82.val[0].i8, *(int16x4_t *)v70.i8);
            v44 = vmlal_high_s16(v64, (int16x8_t)v81.val[1], v69);
            v43 = vmlal_s16(v63, *(int16x4_t *)v81.val[1].i8, *(int16x4_t *)v69.i8);
            v39 += 64;
            v37 += 2;
            v40 -= 32;
          }
          while (v40);
          v5 = (int8x16_t *)((char *)v5 + v35);
          v72 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v43, v36), vaddq_s32(v45, v41)), vaddq_s32(vaddq_s32(v44, v38), vaddq_s32(v46, v42))));
          if (v21 != v35)
          {
            v73 = 2 * (v21 & 0xFFFFFFFFFFFFFFE0);
            do
            {
              v74 = v5->i8[0];
              v5 = (int8x16_t *)((char *)v5 + 1);
              v72 += (v74 << 28 >> 28) * v14[v73] + v14[v73 + 1] * (v74 >> 4);
              v73 += 2;
            }
            while (v73 < v8);
          }
          v20->i32[v34++] = v72;
        }
        while (v34 != v18);
      }
      else
      {
        for (i = 0; i != v18; ++i)
        {
          v23 = 0;
          v24 = 0;
          v25 = v5;
          do
          {
            v26 = v25->i8[0];
            v25 = (int8x16_t *)((char *)v25 + 1);
            v24 += (v26 << 28 >> 28) * v14[v23] + v14[v23 + 1] * (v26 >> 4);
            v23 += 2;
          }
          while (v23 < v8);
          v5 = (int8x16_t *)((char *)v5 + v21);
          v20->i32[i] = v24;
        }
      }
    }
    else
    {
      bzero((char *)v80 - ((v19 + 15) & 0x7FFFFFFF0), v19);
    }
    v27 = (const float *)((char *)this + 28);
    if (v18 <= 7 || (char *)this + 32 > (char *)a3 && v27 < &a3[v18])
    {
      v28 = 0;
LABEL_20:
      v29 = v18 - v28;
      v30 = v28;
      v31 = &a3[v28];
      v32 = &v20->i32[v30];
      do
      {
        v33 = *v32++;
        *v31++ = *v27 * (float)v33;
        --v29;
      }
      while (v29);
      return;
    }
    v28 = v18 & 0xFFFFFFF8;
    v75 = vld1q_dup_f32(v27);
    v76 = a3 + 4;
    v77 = v20 + 1;
    v78 = v28;
    do
    {
      v79 = vmulq_f32(v75, vcvtq_f32_s32(*v77));
      *((float32x4_t *)v76 - 1) = vmulq_f32(v75, vcvtq_f32_s32(v77[-1]));
      *(float32x4_t *)v76 = v79;
      v76 += 8;
      v77 += 2;
      v78 -= 8;
    }
    while (v78);
    if (v28 != v18)
      goto LABEL_20;
  }
}

void NSigned8BitInput1DConvLayer::~NSigned8BitInput1DConvLayer(NSigned8BitInput1DConvLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSigned8BitInput1DConvLayer::initialize(uint64_t this, const char *a2, unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  float v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;

  v5 = 4 * *(_DWORD *)a2;
  v6 = *(_DWORD *)a4;
  *(_DWORD *)(this + 36) = *(_DWORD *)a4;
  v7 = *((_DWORD *)a4 + 1);
  *(_DWORD *)(this + 40) = v7;
  v8 = *((_DWORD *)a4 + 2);
  v9 = *((float *)a4 + 3) * 0.00392156863;
  *(float *)(this + 52) = v9;
  *(_DWORD *)(this + 32) = v5 / v6;
  v10 = *a3;
  *(_DWORD *)(this + 44) = v6 / v7;
  if (v5 / v6 * v6 != v5)
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - inputsize not divisible by rowsize", a2);
  v11 = v10 / v7;
  v12 = v7 * (v10 / v7);
  if (v12 != *a3)
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - outputsize not divisible by numgroups", a2);
  if (v7 * (v6 / v7) != v6)
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - inputsize not divisible by numgroups", a2);
  if (v8 != 1)
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - numties not equal to 1 not supported", a2);
  v13 = (v5 + 15) & 0xFFFFFFF0;
  if (*a5 != v11 * v13 + ((4 * v12 + 15) & 0xFFFFFFF0) + 16)
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - Incorrect data size", a2);
  if (!*(_DWORD *)a2)
    goto LABEL_11;
  if (!v12)
    goto LABEL_12;
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4 + 16;
  *(_QWORD *)(this + 24) = &a4[v11 * v13 + 16];
  *(_DWORD *)(this + 48) = v13 - v6;
  if (!*(_DWORD *)a2)
LABEL_11:
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
LABEL_12:
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  return this;
}

void NSigned8BitInput1DConvLayer::compute(NSigned8BitInput1DConvLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  uint64_t v5;
  uint64_t v7;
  __n128 v8;
  uint64_t v9;
  int32x4_t *v10;
  uint64_t v11;
  unint64_t v12;
  float32x4_t *v13;
  size_t v14;
  char *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  __int128 v21;
  int v22;
  uint64_t v23;
  const float *v24;
  uint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  int v35;
  int32x4_t v36;
  uint64_t v37;
  int v38;
  int32x4_t v39;
  int32x4_t *v40;
  unsigned int v41;
  BOOL v42;
  uint64_t v43;
  unsigned int v44;
  char *v45;
  unsigned int v46;
  unsigned int v47;
  __int128 v48;
  int v49;
  unint64_t v50;
  const float *v51;
  uint64_t v52;
  int32x4_t v53;
  int v54;
  int32x4_t v55;
  int16x8_t v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  BOOL v62;
  int v63;
  int v64;
  int32x4_t v65;
  uint64_t v66;
  int v67;
  int32x4_t v68;
  int32x4_t *v69;
  unsigned int v70;
  BOOL v71;
  uint64_t v72;
  unsigned int v73;
  char *v74;
  int32x4_t *v75;
  uint64_t v76;
  float32x4_t *v77;
  int32x4_t *v78;
  int32x4_t *v79;
  uint64_t v80;
  int32x4_t v81;
  uint64_t v82;
  char *v83;
  __int32 v84;
  const float *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  float *v89;
  int *v90;
  int v91;
  float32x4_t v92;
  float32x4_t *v93;
  int32x4_t *v94;
  uint64_t v95;
  float32x4_t v96;
  uint64_t v97;
  float32x4_t *v98;
  unsigned int v99;
  uint64_t v100;
  size_t v101;
  const float *v102;
  size_t v103;
  uint64_t v104;

  v102 = a2;
  v104 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 2);
  if (!v5)
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v7 = *((unsigned int *)this + 3);
  v8 = MEMORY[0x24BDAC7A8](a5);
  v10 = (int32x4_t *)((char *)&v97 - ((v9 + 15) & 0x7FFFFFFF0));
  v12 = *(unsigned int *)(v11 + 36);
  MEMORY[0x24BDAC7A8](v8);
  v103 = v14;
  v15 = (char *)&v97 - ((v14 + 15) & 0x7FFFFFFF0);
  if (!(_DWORD)v7)
    return;
  v98 = v13;
  v16 = *((unsigned int *)this + 12);
  v17 = *((_DWORD *)this + 10);
  v18 = (v12 - 1);
  v19 = 0;
  if ((v12 & 7) != 0)
  {
    v100 = v18 + 1;
    LODWORD(v101) = v17 - 1;
    v20 = v17 & 0xFFFFFFF8;
    v21 = 0uLL;
    while (1)
    {
      if ((_DWORD)v12)
      {
        bzero(v15, v103);
        v22 = *((_DWORD *)this + 8);
        if (!v22)
        {
          v5 += v100;
          v21 = 0uLL;
          if (!v17)
            goto LABEL_6;
          goto LABEL_14;
        }
        v23 = 0;
        v24 = v102;
        v21 = 0uLL;
        do
        {
          v25 = 0;
          v26 = 0;
          v27 = v22;
          do
          {
            v26 += *((char *)v24 + v25) * *(char *)(v5 + v25);
            v25 += v12;
            --v27;
          }
          while (v27);
          *(_DWORD *)&v15[4 * v23] = v26;
          ++v5;
          v24 = (const float *)((char *)v24 + 1);
          ++v23;
        }
        while (v23 != v12);
      }
      if (!v17)
        goto LABEL_6;
LABEL_14:
      v28 = *((_DWORD *)this + 11);
      v29 = v17 + v19;
      if (v28)
      {
        v30 = 0;
        v31 = v28 & 0xFFFFFFF8;
        while (1)
        {
          v32 = 0;
          v33 = __CFADD__(v30, v28 - 1);
          v34 = 0;
          v35 = v30;
          if (v28 >= 8 && !v33)
          {
            v36 = 0uLL;
            v37 = v28 & 0xFFFFFFF8;
            v38 = v30;
            v39 = 0uLL;
            do
            {
              v40 = (int32x4_t *)&v15[4 * v38];
              v36 = vaddq_s32(*v40, v36);
              v39 = vaddq_s32(v40[1], v39);
              v38 += 8;
              v37 -= 8;
            }
            while (v37);
            v34 = vaddvq_s32(vaddq_s32(v39, v36));
            if (v28 == v31)
              goto LABEL_16;
            v35 = v30 + v31;
            v32 = v28 & 0xFFFFFFF8;
          }
          v41 = v28 - v32;
          do
          {
            v34 += *(_DWORD *)&v15[4 * v35++];
            --v41;
          }
          while (v41);
LABEL_16:
          v30 += v28;
          v10->i32[v19++] = v34;
          if (v19 == v29)
            goto LABEL_5;
        }
      }
      v42 = __CFADD__(v19, (_DWORD)v101);
      if (v17 >= 8)
      {
        v43 = v17 & 0xFFFFFFF8;
        v44 = v19;
        if (!v42)
        {
          do
          {
            v45 = &v10->i8[4 * v44];
            *(_OWORD *)v45 = v21;
            *((_OWORD *)v45 + 1) = v21;
            v44 += 8;
            v43 -= 8;
          }
          while (v43);
          if (v17 == v20)
            goto LABEL_5;
          v19 += v20;
        }
      }
      do
        v10->i32[v19++] = 0;
      while (v29 != v19);
LABEL_5:
      v19 = v29;
LABEL_6:
      v5 += v16;
      if (v19 >= v7)
        goto LABEL_78;
    }
  }
  v46 = v18 >> 3;
  v100 = 8 * v46 + 8;
  v101 = 32 * v46 + 32;
  v99 = v17 - 1;
  v47 = v17 & 0xFFFFFFF8;
  v48 = 0uLL;
  do
  {
    if (!(_DWORD)v12)
      goto LABEL_50;
    bzero(v15, v103);
    v49 = *((_DWORD *)this + 8);
    if (v49)
    {
      v50 = 0;
      v51 = v102;
      v48 = 0uLL;
      do
      {
        v52 = 0;
        v53 = 0uLL;
        v54 = v49;
        v55 = 0uLL;
        do
        {
          v56 = vmull_s8(*(int8x8_t *)((char *)v51 + v52), *(int8x8_t *)(v5 + v52));
          v55 = vaddw_s16(v55, *(int16x4_t *)v56.i8);
          v53 = vaddw_high_s16(v53, v56);
          v52 += v12;
          --v54;
        }
        while (v54);
        *(int32x4_t *)&v15[4 * v50] = v55;
        *(int32x4_t *)&v15[(4 * v50) | 0x10] = v53;
        v5 += 8;
        v51 += 2;
        v50 += 8;
      }
      while (v50 < v12);
LABEL_50:
      if (v17)
        goto LABEL_51;
      goto LABEL_43;
    }
    bzero(v15, v101);
    v5 += v100;
    v48 = 0uLL;
    if (v17)
    {
LABEL_51:
      v57 = *((_DWORD *)this + 11);
      v58 = v17 + v19;
      if (v57)
      {
        v59 = 0;
        v60 = v57 & 0xFFFFFFF8;
        while (1)
        {
          v61 = 0;
          v62 = __CFADD__(v59, v57 - 1);
          v63 = 0;
          v64 = v59;
          if (v57 >= 8 && !v62)
          {
            v65 = 0uLL;
            v66 = v57 & 0xFFFFFFF8;
            v67 = v59;
            v68 = 0uLL;
            do
            {
              v69 = (int32x4_t *)&v15[4 * v67];
              v65 = vaddq_s32(*v69, v65);
              v68 = vaddq_s32(v69[1], v68);
              v67 += 8;
              v66 -= 8;
            }
            while (v66);
            v63 = vaddvq_s32(vaddq_s32(v68, v65));
            if (v57 == v60)
              goto LABEL_53;
            v64 = v59 + v60;
            v61 = v57 & 0xFFFFFFF8;
          }
          v70 = v57 - v61;
          do
          {
            v63 += *(_DWORD *)&v15[4 * v64++];
            --v70;
          }
          while (v70);
LABEL_53:
          v59 += v57;
          v10->i32[v19++] = v63;
          if (v19 == v58)
            goto LABEL_42;
        }
      }
      v71 = __CFADD__(v19, v99);
      if (v17 < 8 || (v72 = v17 & 0xFFFFFFF8, v73 = v19, v71))
      {
        do
LABEL_76:
          v10->i32[v19++] = 0;
        while (v58 != v19);
      }
      else
      {
        do
        {
          v74 = &v10->i8[4 * v73];
          *(_OWORD *)v74 = v48;
          *((_OWORD *)v74 + 1) = v48;
          v73 += 8;
          v72 -= 8;
        }
        while (v72);
        if (v17 != v47)
        {
          v19 += v47;
          goto LABEL_76;
        }
      }
LABEL_42:
      v19 = v58;
    }
LABEL_43:
    v5 += v16;
  }
  while (v19 < v7);
LABEL_78:
  v75 = (int32x4_t *)*((_QWORD *)this + 3);
  if (v7 > 7)
  {
    v76 = v7 & 0xFFFFFFF8;
    v78 = v10 + 1;
    v79 = v75 + 1;
    v80 = v76;
    v77 = v98;
    do
    {
      v81 = vaddq_s32(*v78, *v79);
      v78[-1] = vaddq_s32(v78[-1], v79[-1]);
      *v78 = v81;
      v78 += 2;
      v79 += 2;
      v80 -= 8;
    }
    while (v80);
    if (v76 != v7)
    {
      v75 = (int32x4_t *)((char *)v75 + 4 * (v7 & 0xFFFFFFF8));
      goto LABEL_84;
    }
  }
  else
  {
    v76 = 0;
    v77 = v98;
LABEL_84:
    v82 = v7 - v76;
    v83 = &v10->i8[4 * v76];
    do
    {
      v84 = v75->i32[0];
      v75 = (int32x4_t *)((char *)v75 + 4);
      *(_DWORD *)v83 += v84;
      v83 += 4;
      --v82;
    }
    while (v82);
  }
  v85 = (const float *)((char *)this + 52);
  if (v7 <= 7 || (char *)this + 56 > (char *)v77 && v85 < &v77->f32[v7])
  {
    v86 = 0;
    goto LABEL_90;
  }
  v86 = v7 & 0xFFFFFFF8;
  v92 = vld1q_dup_f32(v85);
  v93 = v77 + 1;
  v94 = v10 + 1;
  v95 = v86;
  do
  {
    v96 = vmulq_f32(v92, vcvtq_f32_s32(*v94));
    v93[-1] = vmulq_f32(v92, vcvtq_f32_s32(v94[-1]));
    *v93 = v96;
    v93 += 2;
    v94 += 2;
    v95 -= 8;
  }
  while (v95);
  if (v86 != v7)
  {
LABEL_90:
    v87 = v7 - v86;
    v88 = v86;
    v89 = &v77->f32[v86];
    v90 = &v10->i32[v88];
    do
    {
      v91 = *v90++;
      *v89++ = *v85 * (float)v91;
      --v87;
    }
    while (v87);
  }
}

void NSigned8BitQuantizeLayer::~NSigned8BitQuantizeLayer(NSigned8BitQuantizeLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSigned8BitQuantizeLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != 4 * *a3)
    Error::chuck((Error *)"NSigned8BitQuantizeLayer::initialize() - input and output size must be in ratio 4:1", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

uint64_t NSigned8BitQuantizeLayer::compute(uint64_t this, const float *a2, int8x8_t *a3, void *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  const float *v7;
  int8x8_t *v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  unint64_t v14;
  unint64_t v15;

  if (!*(_QWORD *)(this + 16))
    Error::chuck((Error *)"NSigned8BitQuantizeLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v4 = *(unsigned int *)(this + 8);
  LODWORD(v5) = v4;
  if (v4 >= 0x10)
  {
    v6 = v4 >> 4;
    v7 = a2 + 8;
    v8 = a3 + 1;
    v9 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v10 = vmulq_f32(*(float32x4_t *)(v7 - 8), v9);
      v11 = vmulq_f32(*(float32x4_t *)(v7 - 4), v9);
      v12 = *(float32x4_t *)v7;
      v13 = *(float32x4_t *)(v7 + 4);
      v7 += 16;
      v8[-1] = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(v10), (int16x8_t)vcvtnq_s32_f32(v11)));
      *v8 = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(vmulq_f32(v12, v9)), (int16x8_t)vcvtnq_s32_f32(vmulq_f32(v13, v9))));
      v8 += 2;
      --v6;
    }
    while (v6);
    LODWORD(v5) = *(_DWORD *)(this + 8);
  }
  v14 = v4 & 0xFFFFFFF0;
  if (v14 < v5)
  {
    do
    {
      a3->i8[v14] = (uint64_t)rintf(a2[v14] * 255.0);
      ++v14;
      v5 = *(unsigned int *)(this + 8);
    }
    while (v14 < v5);
  }
  if ((_DWORD)v5)
  {
    v15 = 0;
    do
      a3->i8[v15++] ^= 0x80u;
    while (v15 < *(unsigned int *)(this + 8));
  }
  return this;
}

void NLogSoftmaxOnlyLayer::~NLogSoftmaxOnlyLayer(NLogSoftmaxOnlyLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLogSoftmaxOnlyLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3)
    Error::chuck((Error *)"NLogSoftmaxOnlyLayer::initialize() - input and output size must be the same", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

void NLogSoftmaxOnlyLayer::compute(NLogSoftmaxOnlyLayer *this, const float *a2, float32x4_t *__dst, void *a4)
{
  uint64_t v6;
  float v7;
  uint64_t v8;
  float *v9;
  float v10;
  float v11;
  uint64_t v12;
  float v13;
  float *v14;
  uint64_t v15;
  float v16;
  float v17;
  uint64_t v18;
  float *v19;
  float v20;
  int32x2_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t *v24;
  uint64_t v25;
  float32x4_t v26;
  uint64_t v27;
  float *v28;

  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"NLogSoftmaxOnlyLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  memcpy(__dst, a2, 4 * *((unsigned int *)this + 3));
  v6 = *((unsigned int *)this + 3);
  v7 = __dst->f32[0];
  if (v6 >= 2)
  {
    v8 = v6 - 1;
    v9 = &__dst->f32[1];
    do
    {
      v10 = *v9++;
      v11 = v10;
      if (v10 > v7)
        v7 = v11;
      --v8;
    }
    while (v8);
  }
  if (!(_DWORD)v6)
    return;
  if ((_DWORD)v6 == 1)
  {
    v12 = 0;
    v13 = 0.0;
  }
  else
  {
    v12 = v6 & 0xFFFFFFFE;
    v14 = &__dst->f32[1];
    v13 = 0.0;
    v15 = v12;
    do
    {
      v16 = *v14 - v7;
      v17 = expf(*(v14 - 1) - v7);
      v13 = (float)(v13 + v17) + expf(v16);
      v14 += 2;
      v15 -= 2;
    }
    while (v15);
    if (v12 == v6)
      goto LABEL_15;
  }
  v18 = v6 - v12;
  v19 = &__dst->f32[v12];
  do
  {
    v20 = *v19++;
    v13 = v13 + expf(v20 - v7);
    --v18;
  }
  while (v18);
LABEL_15:
  *(float *)v21.i32 = v7 + logf(v13);
  if (v6 < 8)
  {
    v22 = 0;
LABEL_20:
    v27 = v6 - v22;
    v28 = &__dst->f32[v22];
    do
    {
      *v28 = *v28 - *(float *)v21.i32;
      ++v28;
      --v27;
    }
    while (v27);
    return;
  }
  v22 = v6 & 0xFFFFFFF8;
  v23 = (float32x4_t)vdupq_lane_s32(v21, 0);
  v24 = __dst + 1;
  v25 = v22;
  do
  {
    v26 = vsubq_f32(*v24, v23);
    v24[-1] = vsubq_f32(v24[-1], v23);
    *v24 = v26;
    v24 += 2;
    v25 -= 8;
  }
  while (v25);
  if (v22 != v6)
    goto LABEL_20;
}

void NVectorScaleLayer::~NVectorScaleLayer(NVectorScaleLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NVectorScaleLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;

  v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2)
    Error::chuck((Error *)"NVectorScaleLayer::initialize() - Incorrect data size", a2, a3, a4);
  if (v5 != *a3)
    Error::chuck((Error *)"NVectorScaleLayer::initialize() - Input and output not same", a2);
  if (*a5 <= 3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

void NVectorScaleLayer::compute(NVectorScaleLayer *this, const float *__A, float *__C, void *a4)
{
  const float *v5;

  v5 = (const float *)*((_QWORD *)this + 2);
  if (!v5)
    Error::chuck((Error *)"NVectorScaleLayer::compute() - Layer uninitialized", (const char *)__A, 0, a4, __C);
  vDSP_vmul(__A, 1, v5, 1, __C, 1, *((unsigned int *)this + 2));
}

void NSubVectorSelectLayer::~NSubVectorSelectLayer(NSubVectorSelectLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSubVectorSelectLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, unsigned int *a5)
{
  unsigned int v5;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;

  v5 = *a5;
  if (*a5 < 0x10 || (*a5 & 4) != 0)
    Error::chuck((Error *)"NSubVectorSelectLayer::initialize() - invalid layer size", a2, a3, a4);
  v7 = v5 >> 2;
  v8 = (v5 >> 2) - 2;
  if (v5 >> 2 == 2)
  {
    v10 = 0;
    if (*(_DWORD *)&a4[4 * v8])
      goto LABEL_20;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = *(_DWORD *)a2;
    do
    {
      v12 = *(_DWORD *)&a4[4 * v9];
      if (v12 >= v11)
        goto LABEL_19;
      v13 = *(_DWORD *)&a4[4 * v9 + 4];
      if (v12 + v13 - 1 >= v11)
        goto LABEL_19;
      v10 += v13;
      v9 += 2;
    }
    while (v9 < v8);
    if (*(_DWORD *)&a4[4 * v8])
LABEL_20:
      Error::chuck((Error *)"NSubVectorSelectLayer::initialize() - missing subvector list termination", a2, a3);
  }
  if (*(_DWORD *)&a4[4 * v7 - 4])
    goto LABEL_20;
  if (v10 != *a3)
LABEL_19:
    Error::chuck((Error *)"NSubVectorSelectLayer::initialize() - invalid subvector specification", a2, a3);
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!v10)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

_QWORD *NSubVectorSelectLayer::compute(_QWORD *this, const float *a2, float *a3, void *a4)
{
  uint64_t v4;
  unsigned int v5;
  _QWORD *v8;
  int v9;
  unsigned int v10;

  v4 = this[2];
  if (!v4)
    Error::chuck((Error *)"NSubVectorSelectLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v5 = *(_DWORD *)(v4 + 4);
  if (v5)
  {
    v8 = this;
    v9 = 0;
    v10 = 3;
    do
    {
      this = memcpy(&a3[v9], &a2[*(unsigned int *)(v4 + 4 * (v10 - 3))], 4 * v5);
      v9 += v5;
      v4 = v8[2];
      v5 = *(_DWORD *)(v4 + 4 * v10);
      v10 += 2;
    }
    while (v5);
  }
  return this;
}

void NBlockDiagonalLayer::~NBlockDiagonalLayer(NBlockDiagonalLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NBlockDiagonalLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  uint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;

  v5 = *a5;
  v6 = *(_DWORD *)&a4[v5 - 4];
  v7 = *(_DWORD *)a2;
  v8 = *(_DWORD *)a2 / v6;
  v9 = *a3 / v6;
  if (*a3 != v9 * v6 || v7 != v8 * v6)
    Error::chuck((Error *)"NBlockDiagonalLayer::initialize() - dimen not divisible", a2);
  if (v9 + v9 * v8 + 1 != v5 >> 2)
    Error::chuck((Error *)"NBlockDiagonalLayer::initialize() - Incorrect data size", a2);
  if ((a4 & 0xF) != 0)
    Error::chuck((Error *)"NMatrixLayer::initialize() - Unaligned data block", a2);
  if (!v7)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v7;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  *(_DWORD *)(this + 28) = v9;
  *(_DWORD *)(this + 32) = v6;
  *(_DWORD *)(this + 24) = v8;
  return this;
}

uint64_t NBlockDiagonalLayer::compute(NBlockDiagonalLayer *this, const float *a2, float *a3, void *a4)
{
  uint64_t v4;
  unsigned int v7;
  const void *v8;

  v4 = *((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"NBlockDiagonalLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  if (*((_DWORD *)this + 8))
  {
    v7 = 0;
    v8 = (const void *)(v4 + 4 * (*((_DWORD *)this + 6) * *((_DWORD *)this + 7)));
    do
      memcpy(&a3[*((_DWORD *)this + 7) * v7++], v8, 4 * *((unsigned int *)this + 7));
    while (v7 < *((_DWORD *)this + 8));
  }
  return cblas_sgemm_NEWLAPACK_ILP64();
}

void NShiftRegisterLayer::~NShiftRegisterLayer(NShiftRegisterLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NShiftRegisterLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;
  int v6;
  int v7;

  v5 = *a3 / *(_DWORD *)a2;
  if (v5 * *(_DWORD *)a2 != *a3)
    Error::chuck((Error *)"NShiftRegisterLayer::initialize() - output size must integer-multiple of input", a2);
  if (*a5 != 8)
    Error::chuck((Error *)"NShiftRegisterLayer::initialize() - Incorrect data size", a2);
  v6 = *(_DWORD *)a4;
  v7 = *((_DWORD *)a4 + 1);
  if (*(_DWORD *)a4 + v5 + (v5 - 1) * v7 >= 0x7A121)
    Error::chuck((Error *)"NShiftRegisterLayer::initialize() - settings result in unreasonable storage requirement", a2);
  if (!*a3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  *(_DWORD *)(this + 24) = v6;
  *(_DWORD *)(this + 28) = v7;
  return this;
}

uint64_t NShiftRegisterLayer::compute(NShiftRegisterLayer *this, const float *a2, float *a3, NFrameWindow *a4)
{
  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"NShiftRegisterLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  if (!a4)
    Error::chuck((Error *)"NShiftRegisterLayer::compute() - State uninitialized", (const char *)a2, a3);
  NFrameWindow::pushFrame(a4, a2);
  return NFrameWindow::setOutputFrameWindow((uint64_t)a4, a3);
}

uint64_t NShiftRegisterLayer::allocateStateP(NShiftRegisterLayer *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;

  v2 = operator new();
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 28) = 0u;
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 48) = &off_24C7F31A8;
  *(_WORD *)(v2 + 72) = 1;
  v3 = *((_DWORD *)this + 2);
  v4 = *((_DWORD *)this + 3);
  v8 = 0;
  v9 = v4 / v3;
  v6 = -1;
  v7 = 0;
  NFrameWindow::configure(v2, (const char *)&v9, (unsigned int *)this + 2, &v8, &v7, &v6, (const unsigned int *)this + 7, (const unsigned int *)this + 6);
  return v2;
}

void NShiftRegisterLayer::deallocateState(NShiftRegisterLayer *this, _QWORD *a2)
{
  uint64_t v2;

  if (a2)
  {
    a2[6] = &off_24C7F3090;
    v2 = a2[7];
    if (v2)
      MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
    JUMPOUT(0x212BAC9D8);
  }
  Error::chuck((Error *)"NShiftRegisterLayer::compute() - State uninitialized", 0);
}

void NShiftRegisterLayer::resetState(NShiftRegisterLayer *this, _WORD *a2)
{
  if (!a2)
    Error::chuck((Error *)"NShiftRegisterLayer::compute() - State uninitialized", 0);
  a2[36] = 1;
  *((_DWORD *)a2 + 9) = 0;
  *((_DWORD *)a2 + 10) = 0;
}

void NSigmoidOnlyLayer::~NSigmoidOnlyLayer(NSigmoidOnlyLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSigmoidOnlyLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3)
    Error::chuck((Error *)"NSigmoidOnlyLayer::initialize() - input and output size must be the same", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

void NSigmoidOnlyLayer::compute(NSigmoidOnlyLayer *this, const float *a2, float *__dst, void *a4)
{
  float __B;
  int v7;

  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"NSigmoidOnlyLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  memcpy(__dst, a2, 4 * *((unsigned int *)this + 3));
  vDSP_vneg(__dst, 1, __dst, 1, *((unsigned int *)this + 3));
  v7 = *((_DWORD *)this + 3);
  vvexpf(__dst, __dst, &v7);
  __B = 1.0;
  vDSP_vsadd(__dst, 1, &__B, __dst, 1, *((unsigned int *)this + 3));
  vvrecf(__dst, __dst, &v7);
}

void N8BitMatrixLayer::~N8BitMatrixLayer(N8BitMatrixLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

void N8BitMatrixLayer::compute(N8BitMatrixLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  char *v5;
  uint64_t v8;
  __n128 v9;
  uint64_t v10;
  int8x8_t *v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  unint64_t v15;
  int v16;
  int16x8_t v17;
  uint64_t v18;
  int32x4_t *v19;
  unint64_t v20;
  float32x4_t *v21;
  int8x8_t *v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  float *v31;
  float v32;
  unint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int64x2_t v44;
  int32x4_t v45;
  int64x2_t v46;
  unint64_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int16x8_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int32x4_t v75;
  int32x4_t v76;
  int16x8_t v77;
  int32x4_t v78;
  uint64_t v79;
  char *v80;
  int v81;
  int v82;
  int v83;
  int32x4_t *v84;
  uint64_t v85;
  int32x4_t *v86;
  int32x4_t *v87;
  uint64_t v88;
  int32x4_t v89;
  uint64_t v90;
  char *v91;
  __int32 v92;
  const float *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  float *v97;
  int *v98;
  int v99;
  float32x4_t v100;
  float *v101;
  int32x4_t *v102;
  uint64_t v103;
  float32x4_t v104;
  _QWORD v105[2];

  v105[1] = *MEMORY[0x24BDAC8D0];
  v5 = (char *)*((_QWORD *)this + 2);
  if (!v5)
    Error::chuck((Error *)"N8BitMatrixLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v8 = (*((_DWORD *)this + 8) + *((_DWORD *)this + 2));
  v9 = MEMORY[0x24BDAC7A8](a5);
  v11 = (int8x8_t *)((char *)v105 - v10);
  v13 = *(unsigned int *)(v12 + 12);
  MEMORY[0x24BDAC7A8](v9);
  v19 = (int32x4_t *)((char *)v105 - ((v18 + 15) & 0x7FFFFFFF0));
  if (v15 >= 0x10)
  {
    v20 = v15 >> 4;
    v21 = v14 + 2;
    v22 = v11 + 1;
    v23 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      v24 = vmulq_f32(v21[-2], v23);
      v25 = vmulq_f32(v21[-1], v23);
      v26 = *v21;
      v27 = v21[1];
      v21 += 4;
      v22[-1] = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(v24), (int16x8_t)vcvtnq_s32_f32(v25)));
      *v22 = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(vmulq_f32(v26, v23)), (int16x8_t)vcvtnq_s32_f32(vmulq_f32(v27, v23))));
      v22 += 2;
      --v20;
    }
    while (v20);
  }
  v28 = v15 & 0xFFFFFFF0;
  if ((v15 & 0xFFFFFFF0) < v15)
  {
    v29 = v15 - v28;
    v30 = (char *)v11 + v28;
    v31 = (float *)((char *)v14->f32 + ((4 * v15) & 0x3FFFFFFC0));
    do
    {
      v32 = *v31++;
      *v30++ = (uint64_t)rintf(v32 * 255.0);
      --v29;
    }
    while (v29);
  }
  if (v15 < v8)
    bzero((char *)v11 + v15, (v16 - 1) + 1);
  if ((v13 & 0xFFFFFFFC) != 0)
  {
    v33 = 0;
    v34 = (4 * v8);
    v35 = &v5[(3 * v8)];
    v36 = &v5[(2 * v8)];
    v37 = &v5[v8];
    do
    {
      if ((_DWORD)v8)
      {
        v47 = 0;
        v41 = 0uLL;
        v40 = 0uLL;
        v39 = 0uLL;
        v38 = 0uLL;
        do
        {
          v48 = (int16x8_t)vmovl_u8((uint8x8_t)v11[v47 / 8]);
          v49 = vmovl_s8(*(int8x8_t *)&v5[v47]);
          v50 = vmovl_s8(*(int8x8_t *)&v37[v47]);
          v51 = vmovl_s8(*(int8x8_t *)&v36[v47]);
          v17 = vmovl_s8(*(int8x8_t *)&v35[v47]);
          v41 = vmlal_s16(vmlal_high_s16(v41, v48, v49), *(int16x4_t *)v48.i8, *(int16x4_t *)v49.i8);
          v40 = vmlal_s16(vmlal_high_s16(v40, v48, v50), *(int16x4_t *)v48.i8, *(int16x4_t *)v50.i8);
          v39 = vmlal_s16(vmlal_high_s16(v39, v48, v51), *(int16x4_t *)v48.i8, *(int16x4_t *)v51.i8);
          v38 = vmlal_s16(vmlal_high_s16(v38, v48, v17), *(int16x4_t *)v48.i8, *(int16x4_t *)v17.i8);
          v47 += 8;
        }
        while (v47 < v8);
      }
      else
      {
        v38 = 0uLL;
        v39 = 0uLL;
        v40 = 0uLL;
        v41 = 0uLL;
      }
      v42 = (int32x4_t)vpaddlq_s32(v41);
      v43 = (int32x4_t)vpaddlq_s32(v40);
      v44 = vpaddlq_s32(v39);
      v45.i64[0] = vzip1q_s32(v42, v43).u64[0];
      v45.i32[2] = v44.i32[0];
      v46 = vpaddlq_s32(v38);
      v45.i32[3] = v46.i32[0];
      v42.i64[0] = vzip2q_s32(v42, v43).u64[0];
      v42.i64[1] = __PAIR64__(v46.u32[2], v44.u32[2]);
      *(int32x4_t *)((char *)v19 + 4 * v33) = vaddq_s32(v45, v42);
      v5 += v34;
      v33 += 4;
      v35 += v34;
      v36 += v34;
      v37 += v34;
    }
    while (v33 < (v13 & 0xFFFFFFFC));
  }
  else
  {
    LODWORD(v33) = 0;
  }
  if (v33 >= v13)
  {
LABEL_40:
    if (!(_DWORD)v13)
      return;
  }
  else
  {
    v52 = v33;
    if ((_DWORD)v8)
    {
      v53 = v8 & 0xFFFFFFE0;
      v54 = v8 & 0xFFFFFFF8;
      while (1)
      {
        if (v8 < 8)
        {
          v55 = 0;
          v56 = 0;
          v57 = v5;
          goto LABEL_37;
        }
        if (v8 >= 0x20)
        {
          v59 = 0;
          v60 = 0uLL;
          v61 = 0uLL;
          v62 = 0uLL;
          v63 = 0uLL;
          v17 = 0uLL;
          v64 = 0uLL;
          v65 = 0uLL;
          v66 = 0uLL;
          do
          {
            v67 = *(int8x16_t *)&v5[v59];
            v68 = *(int8x16_t *)&v5[v59 + 16];
            v69 = vmovl_high_s8(v67);
            v70 = vmovl_s8(*(int8x8_t *)v67.i8);
            v71 = vmovl_high_s8(v68);
            v72 = vmovl_s8(*(int8x8_t *)v68.i8);
            v73 = *(int8x16_t *)v11[v59 / 8].i8;
            v74 = *(int8x16_t *)v11[v59 / 8 + 2].i8;
            v63 = vmlaq_s32(v63, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_20DA246A0), vmovl_high_s16(v69));
            v62 = vmlaq_s32(v62, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_20DA24690), vmovl_s16(*(int16x4_t *)v69.i8));
            v61 = vmlaq_s32(v61, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_20DA24680), vmovl_high_s16(v70));
            v60 = vmlaq_s32(v60, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_20DA24670), vmovl_s16(*(int16x4_t *)v70.i8));
            v66 = vmlaq_s32(v66, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_20DA246A0), vmovl_high_s16(v71));
            v65 = vmlaq_s32(v65, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_20DA24690), vmovl_s16(*(int16x4_t *)v71.i8));
            v64 = vmlaq_s32(v64, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_20DA24680), vmovl_high_s16(v72));
            v17 = (int16x8_t)vmlaq_s32((int32x4_t)v17, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_20DA24670), vmovl_s16(*(int16x4_t *)v72.i8));
            v59 += 32;
          }
          while (v53 != v59);
          v56 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v17, v60), vaddq_s32(v65, v62)), vaddq_s32(vaddq_s32(v64, v61), vaddq_s32(v66, v63))));
          if (v53 == v8)
            goto LABEL_22;
          if ((v8 & 0x18) == 0)
          {
            v57 = &v5[v53];
            v55 = v8 & 0xFFFFFFE0;
            goto LABEL_37;
          }
          v58 = v8 & 0xFFFFFFE0;
        }
        else
        {
          v56 = 0;
          v58 = 0;
        }
        v75 = 0uLL;
        v76 = (int32x4_t)v56;
        do
        {
          v77 = vmovl_s8(*(int8x8_t *)&v5[v58]);
          *(int8x8_t *)v17.i8 = *(int8x8_t *)((char *)v11 + v58);
          v78 = (int32x4_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_20DA24680);
          v17 = (int16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_20DA24670);
          v75 = vmlaq_s32(v75, v78, vmovl_high_s16(v77));
          v76 = vmlaq_s32(v76, (int32x4_t)v17, vmovl_s16(*(int16x4_t *)v77.i8));
          v58 += 8;
        }
        while (v54 != v58);
        v56 = vaddvq_s32(vaddq_s32(v76, v75));
        if (v54 == v8)
          goto LABEL_22;
        v57 = &v5[v54];
        v55 = v8 & 0xFFFFFFF8;
LABEL_37:
        v79 = v8 - v55;
        v80 = (char *)v11 + v55;
        do
        {
          v82 = *v57++;
          v81 = v82;
          v83 = *v80++;
          v56 += v83 * v81;
          --v79;
        }
        while (v79);
LABEL_22:
        v5 += v8;
        v19->i32[v52++] = v56;
        if (v52 == v13)
          goto LABEL_40;
      }
    }
    bzero((char *)v19 + 4 * v33, 4 * (v13 + ~(_DWORD)v33) + 4);
  }
  v84 = (int32x4_t *)*((_QWORD *)this + 3);
  if (v13 <= 7)
  {
    v85 = 0;
    goto LABEL_49;
  }
  v85 = v13 & 0xFFFFFFF8;
  v86 = v19 + 1;
  v87 = v84 + 1;
  v88 = v85;
  do
  {
    v89 = vaddq_s32(*v86, *v87);
    v86[-1] = vaddq_s32(v86[-1], v87[-1]);
    *v86 = v89;
    v86 += 2;
    v87 += 2;
    v88 -= 8;
  }
  while (v88);
  if (v85 != v13)
  {
    v84 = (int32x4_t *)((char *)v84 + 4 * (v13 & 0xFFFFFFF8));
LABEL_49:
    v90 = v13 - v85;
    v91 = &v19->i8[4 * v85];
    do
    {
      v92 = v84->i32[0];
      v84 = (int32x4_t *)((char *)v84 + 4);
      *(_DWORD *)v91 += v92;
      v91 += 4;
      --v90;
    }
    while (v90);
  }
  v93 = (const float *)((char *)this + 36);
  if (v13 <= 7 || (char *)this + 40 > (char *)a3 && v93 < &a3[v13])
  {
    v94 = 0;
LABEL_55:
    v95 = v13 - v94;
    v96 = v94;
    v97 = &a3[v94];
    v98 = &v19->i32[v96];
    do
    {
      v99 = *v98++;
      *v97++ = *v93 * (float)v99;
      --v95;
    }
    while (v95);
    return;
  }
  v94 = v13 & 0xFFFFFFF8;
  v100 = vld1q_dup_f32(v93);
  v101 = a3 + 4;
  v102 = v19 + 1;
  v103 = v94;
  do
  {
    v104 = vmulq_f32(v100, vcvtq_f32_s32(*v102));
    *((float32x4_t *)v101 - 1) = vmulq_f32(v100, vcvtq_f32_s32(v102[-1]));
    *(float32x4_t *)v101 = v104;
    v101 += 8;
    v102 += 2;
    v103 -= 8;
  }
  while (v103);
  if (v94 != v13)
    goto LABEL_55;
}

void NClipLayer::~NClipLayer(NClipLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NClipLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3)
    Error::chuck((Error *)"NClipLayer::initialize() - input and output size must be the same", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

void NClipLayer::compute(NClipLayer *this, const float *__A, float *__D, void *a4)
{
  float __C;
  float __B;

  if (!*((_QWORD *)this + 2))
    Error::chuck((Error *)"NClipLayer::compute() - Layer uninitialized", (const char *)__A, __D, a4);
  __B = 0.0;
  __C = 1.0;
  vDSP_vclip(__A, 1, &__B, &__C, __D, 1, *((unsigned int *)this + 2));
}

void NMatrixLayer::~NMatrixLayer(NMatrixLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NMatrixLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;
  int v6;

  v5 = *(_DWORD *)a2;
  v6 = *a3;
  if (v6 + v6 * *(_DWORD *)a2 != *a5 >> 2)
    Error::chuck((Error *)"NMatrixLayer::initialize() - Incorrect data size", a2);
  if ((a4 & 0xF) != 0)
    Error::chuck((Error *)"NMatrixLayer::initialize() - Unaligned data block", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!v6)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

uint64_t NMatrixLayer::compute(NMatrixLayer *this, const float *a2, float *__dst, void *a4)
{
  uint64_t v4;

  v4 = *((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"NMatrixLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  memcpy(__dst, (const void *)(v4 + 4 * (*((_DWORD *)this + 2) * *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  return cblas_sgemv_NEWLAPACK_ILP64();
}

void N8BitLogSoftmaxLayer::~N8BitLogSoftmaxLayer(N8BitLogSoftmaxLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

void N8BitLogSoftmaxLayer::compute(N8BitLogSoftmaxLayer *this, const float *a2, float32x4_t *a3, void *a4, __n128 a5)
{
  uint64_t v7;
  float v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;
  uint64_t v13;
  float v14;
  float *v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  float *v20;
  float v21;
  int32x2_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t *v25;
  uint64_t v26;
  float32x4_t v27;
  uint64_t v28;
  float *v29;

  N8BitMatrixLayer::compute(this, a2, a3->f32, a4, a5);
  v7 = *((unsigned int *)this + 3);
  v8 = a3->f32[0];
  if (v7 >= 2)
  {
    v9 = v7 - 1;
    v10 = &a3->f32[1];
    do
    {
      v11 = *v10++;
      v12 = v11;
      if (v11 > v8)
        v8 = v12;
      --v9;
    }
    while (v9);
  }
  if (!(_DWORD)v7)
    return;
  if ((_DWORD)v7 == 1)
  {
    v13 = 0;
    v14 = 0.0;
  }
  else
  {
    v13 = v7 & 0xFFFFFFFE;
    v15 = &a3->f32[1];
    v14 = 0.0;
    v16 = v13;
    do
    {
      v17 = *v15 - v8;
      v18 = expf(*(v15 - 1) - v8);
      v14 = (float)(v14 + v18) + expf(v17);
      v15 += 2;
      v16 -= 2;
    }
    while (v16);
    if (v13 == v7)
      goto LABEL_14;
  }
  v19 = v7 - v13;
  v20 = &a3->f32[v13];
  do
  {
    v21 = *v20++;
    v14 = v14 + expf(v21 - v8);
    --v19;
  }
  while (v19);
LABEL_14:
  *(float *)v22.i32 = v8 + logf(v14);
  if (v7 < 8)
  {
    v23 = 0;
LABEL_19:
    v28 = v7 - v23;
    v29 = &a3->f32[v23];
    do
    {
      *v29 = *v29 - *(float *)v22.i32;
      ++v29;
      --v28;
    }
    while (v28);
    return;
  }
  v23 = v7 & 0xFFFFFFF8;
  v24 = (float32x4_t)vdupq_lane_s32(v22, 0);
  v25 = a3 + 1;
  v26 = v23;
  do
  {
    v27 = vsubq_f32(*v25, v24);
    v25[-1] = vsubq_f32(v25[-1], v24);
    *v25 = v27;
    v25 += 2;
    v26 -= 8;
  }
  while (v26);
  if (v23 != v7)
    goto LABEL_19;
}

void N8BitSigmoidalLayer::~N8BitSigmoidalLayer(N8BitSigmoidalLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

void N8BitSigmoidalLayer::compute(N8BitSigmoidalLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  float __B;
  int v8;

  N8BitMatrixLayer::compute(this, a2, a3, a4, a5);
  vDSP_vneg(a3, 1, a3, 1, *((unsigned int *)this + 3));
  v8 = *((_DWORD *)this + 3);
  vvexpf(a3, a3, &v8);
  __B = 1.0;
  vDSP_vsadd(a3, 1, &__B, a3, 1, *((unsigned int *)this + 3));
  vvrecf(a3, a3, &v8);
}

void NFixLogSoftmaxLayer::~NFixLogSoftmaxLayer(NFixLogSoftmaxLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFixMatrixBaseLayer::initialize(uint64_t this, const char *a2, unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  BOOL v10;
  int v11;

  v5 = *a5 >> 1;
  v6 = *(_DWORD *)a2;
  v7 = *a3;
  if (v5 != v7 + v7 * *(_DWORD *)a2 + 1)
    Error::chuck((Error *)"NFixMatrixBaseLayer::initialize() - Incorrect data size", a2);
  if (!v6)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!v7)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = v6;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  v8 = *a3;
  if (*a3)
  {
    v9 = 0;
    do
    {
      ++v9;
      v10 = v8 > 1;
      v8 >>= 1;
    }
    while (v10);
  }
  else
  {
    v9 = 0;
  }
  v11 = *(__int16 *)&a4[2 * v5 - 2];
  *(_DWORD *)(this + 24) = v9;
  *(_DWORD *)(this + 28) = v11;
  return this;
}

void NBaseLayer::compute(NBaseLayer *this, const float *a2, float *a3, void *a4)
{
  Error::chuck((Error *)"NBaseLayer::compute() - floating-point compute not supported", (const char *)a2, a3, a4);
}

uint64_t NFixLogSoftmaxLayer::compute(uint64_t this, const char *a2, int *a3)
{
  int16x8_t *v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int16x8_t *v11;
  int32x4_t v12;
  int16x8_t *v13;
  int32x4_t v14;
  const int *v15;
  uint64_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  int16x8_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  uint64_t v27;
  const int *v28;
  int v29;
  int v30;
  int v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  int *v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  int v46;

  v3 = *(int16x8_t **)(this + 16);
  if (!v3)
    Error::chuck((Error *)"NFixMatrixBaseLayer::compute() - Layer uninitialized", a2, a3);
  LODWORD(v4) = *(_DWORD *)(this + 12);
  if ((_DWORD)v4)
  {
    v5 = 0;
    while (1)
    {
      v8 = *(unsigned int *)(this + 8);
      if ((_DWORD)v8)
        break;
      v6 = 0;
LABEL_5:
      a3[v5++] = v6;
      v7 = *(unsigned int *)(this + 12);
      if (v5 >= v7)
      {
        if ((_DWORD)v7)
        {
          v32 = 0;
          do
          {
            a3[v32] += (0x7FFF * v3->i16[v32]) >> *(_DWORD *)(this + 24);
            ++v32;
            v4 = *(unsigned int *)(this + 12);
          }
          while (v32 < v4);
        }
        else
        {
          LODWORD(v4) = 0;
        }
        goto LABEL_21;
      }
    }
    v9 = *(_DWORD *)(this + 24);
    if (v8 > 0xF)
    {
      v10 = v8 & 0xFFFFFFF0;
      v12 = vdupq_n_s32(v9);
      v13 = v3 + 1;
      v14 = 0uLL;
      v15 = (const int *)(a2 + 32);
      v16 = v10;
      v17 = 0uLL;
      v18 = 0uLL;
      v19 = 0uLL;
      do
      {
        v20 = v13[-1];
        v21 = *((int32x4_t *)v15 - 2);
        v22 = *((int32x4_t *)v15 - 1);
        v23 = *(int32x4_t *)v15;
        v24 = *((int32x4_t *)v15 + 1);
        v15 += 16;
        v25 = vmulq_s32(v21, vmovl_s16(*(int16x4_t *)v20.i8));
        v26 = vnegq_s32(v12);
        v17 = vaddq_s32(vshlq_s32(vmulq_s32(v22, vmovl_high_s16(v20)), v26), v17);
        v14 = vaddq_s32(vshlq_s32(v25, v26), v14);
        v19 = vaddq_s32(vshlq_s32(vmulq_s32(v24, vmovl_high_s16(*v13)), v26), v19);
        v18 = vaddq_s32(vshlq_s32(vmulq_s32(v23, vmovl_s16(*(int16x4_t *)v13->i8)), v26), v18);
        v13 += 2;
        v16 -= 16;
      }
      while (v16);
      v6 = vaddvq_s32(vaddq_s32(vaddq_s32(v18, v14), vaddq_s32(v19, v17)));
      if (v10 == v8)
        goto LABEL_15;
      v11 = (int16x8_t *)((char *)v3 + 2 * (v8 & 0xFFFFFFF0));
    }
    else
    {
      v10 = 0;
      v6 = 0;
      v11 = v3;
    }
    v27 = v8 - v10;
    v28 = (const int *)&a2[4 * v10];
    do
    {
      v30 = v11->i16[0];
      v11 = (int16x8_t *)((char *)v11 + 2);
      v29 = v30;
      v31 = *v28++;
      v6 += (v31 * v29) >> v9;
      --v27;
    }
    while (v27);
LABEL_15:
    v3 = (int16x8_t *)((char *)v3 + 2 * (v8 - 1) + 2);
    goto LABEL_5;
  }
LABEL_21:
  v33 = *(_DWORD *)(this + 28) - *(_DWORD *)(this + 24);
  v34 = *(_QWORD *)(this + 32);
  v35 = v33 - *(_DWORD *)(v34 + 12) + 15;
  v36 = *a3 >> (*(_BYTE *)(this + 28) - *(_BYTE *)(this + 24) - *(_BYTE *)(v34 + 12) + 15);
  if (v4 >= 2)
  {
    v37 = *(_DWORD *)(v34 + 4);
    v38 = v4 - 1;
    v39 = a3 + 1;
    do
    {
      v41 = *v39++;
      v42 = v41 >> v35;
      v43 = v36 - (v41 >> v35);
      if (v36 <= v41 >> v35)
      {
        v44 = (v42 - v36) >> 1;
        if (v44 < v37)
          v40 = *(__int16 *)(*(_QWORD *)(v34 + 24) + 2 * v44);
        else
          v40 = 0;
        v36 = v40 + v42;
      }
      else if (v43 >> 1 < v37)
      {
        v36 += *(__int16 *)(*(_QWORD *)(v34 + 24) + 2 * (v43 >> 1));
      }
      --v38;
    }
    while (v38);
  }
  if ((_DWORD)v4)
  {
    v45 = 0;
    v46 = v36 << (15 - *(_BYTE *)(v34 + 12));
    do
    {
      a3[v45] = (a3[v45] >> v33) - v46;
      ++v45;
    }
    while (v45 < *(unsigned int *)(this + 12));
  }
  return this;
}

void NFixSigmoidalLayer::~NFixSigmoidalLayer(NFixSigmoidalLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFixSigmoidalLayer::compute(uint64_t this, const char *a2, int *a3)
{
  int16x8_t *v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int16x8_t *v10;
  int32x4_t v11;
  int16x8_t *v12;
  int32x4_t v13;
  const int *v14;
  uint64_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int16x8_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  uint64_t v26;
  const int *v27;
  int v28;
  int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;

  v3 = *(int16x8_t **)(this + 16);
  if (!v3)
    Error::chuck((Error *)"NFixMatrixBaseLayer::compute() - Layer uninitialized", a2, a3);
  if (*(_DWORD *)(this + 12))
  {
    v4 = 0;
    while (1)
    {
      v7 = *(unsigned int *)(this + 8);
      if ((_DWORD)v7)
        break;
      v5 = 0;
LABEL_5:
      a3[v4++] = v5;
      v6 = *(unsigned int *)(this + 12);
      if (v4 >= v6)
      {
        if ((_DWORD)v6)
        {
          v31 = 0;
          do
          {
            a3[v31] += (0x7FFF * v3->i16[v31]) >> *(_DWORD *)(this + 24);
            ++v31;
            v32 = *(unsigned int *)(this + 12);
          }
          while (v31 < v32);
          if ((_DWORD)v32)
          {
            v33 = 0;
            v34 = *(_QWORD *)(this + 32);
            v35 = *(_DWORD *)(this + 28) - *(_DWORD *)(this + 24) - *(_DWORD *)(v34 + 12) + 15;
            do
            {
              v37 = a3[v33] >> v35;
              if ((v37 & 0x80000000) != 0)
              {
                v36 = 0;
                v38 = -v37;
                if (*(_DWORD *)(v34 + 4) > v38)
                  v36 = 0x7FFF - *(__int16 *)(*(_QWORD *)(v34 + 24) + 2 * v38);
              }
              else if (v37 < *(_DWORD *)(v34 + 4))
              {
                v36 = *(__int16 *)(*(_QWORD *)(v34 + 24) + 2 * v37);
              }
              else
              {
                v36 = 0x7FFF;
              }
              a3[v33++] = v36;
            }
            while (v33 < *(unsigned int *)(this + 12));
          }
        }
        return this;
      }
    }
    v8 = *(_DWORD *)(this + 24);
    if (v7 > 0xF)
    {
      v9 = v7 & 0xFFFFFFF0;
      v11 = vdupq_n_s32(v8);
      v12 = v3 + 1;
      v13 = 0uLL;
      v14 = (const int *)(a2 + 32);
      v15 = v9;
      v16 = 0uLL;
      v17 = 0uLL;
      v18 = 0uLL;
      do
      {
        v19 = v12[-1];
        v20 = *((int32x4_t *)v14 - 2);
        v21 = *((int32x4_t *)v14 - 1);
        v22 = *(int32x4_t *)v14;
        v23 = *((int32x4_t *)v14 + 1);
        v14 += 16;
        v24 = vmulq_s32(v20, vmovl_s16(*(int16x4_t *)v19.i8));
        v25 = vnegq_s32(v11);
        v16 = vaddq_s32(vshlq_s32(vmulq_s32(v21, vmovl_high_s16(v19)), v25), v16);
        v13 = vaddq_s32(vshlq_s32(v24, v25), v13);
        v18 = vaddq_s32(vshlq_s32(vmulq_s32(v23, vmovl_high_s16(*v12)), v25), v18);
        v17 = vaddq_s32(vshlq_s32(vmulq_s32(v22, vmovl_s16(*(int16x4_t *)v12->i8)), v25), v17);
        v12 += 2;
        v15 -= 16;
      }
      while (v15);
      v5 = vaddvq_s32(vaddq_s32(vaddq_s32(v17, v13), vaddq_s32(v18, v16)));
      if (v9 == v7)
        goto LABEL_15;
      v10 = (int16x8_t *)((char *)v3 + 2 * (v7 & 0xFFFFFFF0));
    }
    else
    {
      v9 = 0;
      v5 = 0;
      v10 = v3;
    }
    v26 = v7 - v9;
    v27 = (const int *)&a2[4 * v9];
    do
    {
      v29 = v10->i16[0];
      v10 = (int16x8_t *)((char *)v10 + 2);
      v28 = v29;
      v30 = *v27++;
      v5 += (v30 * v28) >> v8;
      --v26;
    }
    while (v26);
LABEL_15:
    v3 = (int16x8_t *)((char *)v3 + 2 * (v7 - 1) + 2);
    goto LABEL_5;
  }
  return this;
}

void NOffsetLayer::~NOffsetLayer(NOffsetLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NOffsetLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5;

  v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2)
    Error::chuck((Error *)"NOffsetLayer::initialize() - Incorrect data size", a2, a3, a4);
  if (v5 != *a3)
    Error::chuck((Error *)"NOffsetLayer::initialize() - Input and output not same", a2);
  if (*a5 <= 3)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

void NOffsetLayer::compute(NOffsetLayer *this, const float *__A, float *__C, void *a4)
{
  const float *v5;

  v5 = (const float *)*((_QWORD *)this + 2);
  if (!v5)
    Error::chuck((Error *)"NOffsetLayer::compute() - Layer uninitialized", (const char *)__A, 0, a4, __C);
  vDSP_vadd(__A, 1, v5, 1, __C, 1, *((unsigned int *)this + 2));
}

void NNormalizationLayer::~NNormalizationLayer(NNormalizationLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NNormalizationLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5;

  v5 = *(_DWORD *)a2;
  if (*a5 >> 2 != 2 * *(_DWORD *)a2)
    Error::chuck((Error *)"NNormalizationLayer::initialize() - Incorrect data size", a2, a3, a4);
  if (v5 != *a3)
    Error::chuck((Error *)"NNormalizationLayer::initialize() - Input and output not same size", a2);
  if (!v5)
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(_QWORD *)(this + 16) = a4;
  return this;
}

float32_t NNormalizationLayer::compute(NNormalizationLayer *this, float32x4_t *a2, const float *a3, void *a4)
{
  float *v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  BOOL v9;
  BOOL v10;
  float32x4_t *v11;
  float32x4_t *v12;
  const float *v13;
  uint64_t v14;
  const float *v15;
  float32x4_t v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float32x4x2_t v25;
  float32x4x2_t v26;

  v4 = (float *)*((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"NNormalizationLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  v5 = *((unsigned int *)this + 2);
  if ((_DWORD)v5)
  {
    if (v5 <= 7)
    {
      v6 = 0;
      goto LABEL_20;
    }
    v6 = 0;
    v7 = (float *)&a3[v5];
    v9 = &v4[2 * v5] > a3 && v4 < v7;
    v10 = v7 > (float *)a2 && &a2->f32[v5] > a3;
    if (v10 || v9)
      goto LABEL_20;
    v6 = v5 & 0xFFFFFFF8;
    v11 = (float32x4_t *)(a3 + 4);
    v12 = a2 + 1;
    v13 = v4 + 8;
    v14 = v6;
    do
    {
      v15 = v13 - 8;
      v25 = vld2q_f32(v15);
      v26 = vld2q_f32(v13);
      v16 = vmulq_f32(vaddq_f32(v12[-1], v25.val[0]), v25.val[1]);
      v25.val[1] = vmulq_f32(vaddq_f32(*v12, v26.val[0]), v26.val[1]);
      v11[-1] = v16;
      *v11 = v25.val[1];
      v11 += 2;
      v12 += 2;
      v13 += 16;
      v14 -= 8;
    }
    while (v14);
    if (v6 != v5)
    {
      v4 += 2 * (v5 & 0xFFFFFFF8);
LABEL_20:
      v17 = v5 - v6;
      v18 = v6;
      v19 = (float *)&a3[v6];
      v20 = &a2->f32[v18];
      do
      {
        v21 = *v20++;
        v22 = *v4;
        v23 = v4[1];
        v4 += 2;
        v16.f32[0] = (float)(v21 + v22) * v23;
        *v19++ = v16.f32[0];
        --v17;
      }
      while (v17);
    }
  }
  return v16.f32[0];
}

void NLogSoftmaxLayer::~NLogSoftmaxLayer(NLogSoftmaxLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

void NLogSoftmaxLayer::compute(NLogSoftmaxLayer *this, const float *a2, float32x4_t *__dst, void *a4)
{
  uint64_t v4;
  uint64_t v7;
  float v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;
  uint64_t v13;
  float v14;
  float *v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  float *v20;
  float v21;
  int32x2_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t *v25;
  uint64_t v26;
  float32x4_t v27;
  uint64_t v28;
  float *v29;

  v4 = *((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"NMatrixLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  memcpy(__dst, (const void *)(v4 + 4 * (*((_DWORD *)this + 2) * *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  cblas_sgemv_NEWLAPACK_ILP64();
  v7 = *((unsigned int *)this + 3);
  v8 = __dst->f32[0];
  if (v7 >= 2)
  {
    v9 = v7 - 1;
    v10 = &__dst->f32[1];
    do
    {
      v11 = *v10++;
      v12 = v11;
      if (v11 > v8)
        v8 = v12;
      --v9;
    }
    while (v9);
  }
  if (!(_DWORD)v7)
    return;
  if ((_DWORD)v7 == 1)
  {
    v13 = 0;
    v14 = 0.0;
  }
  else
  {
    v13 = v7 & 0xFFFFFFFE;
    v15 = &__dst->f32[1];
    v14 = 0.0;
    v16 = v13;
    do
    {
      v17 = *v15 - v8;
      v18 = expf(*(v15 - 1) - v8);
      v14 = (float)(v14 + v18) + expf(v17);
      v15 += 2;
      v16 -= 2;
    }
    while (v16);
    if (v13 == v7)
      goto LABEL_15;
  }
  v19 = v7 - v13;
  v20 = &__dst->f32[v13];
  do
  {
    v21 = *v20++;
    v14 = v14 + expf(v21 - v8);
    --v19;
  }
  while (v19);
LABEL_15:
  *(float *)v22.i32 = v8 + logf(v14);
  if (v7 < 8)
  {
    v23 = 0;
LABEL_20:
    v28 = v7 - v23;
    v29 = &__dst->f32[v23];
    do
    {
      *v29 = *v29 - *(float *)v22.i32;
      ++v29;
      --v28;
    }
    while (v28);
    return;
  }
  v23 = v7 & 0xFFFFFFF8;
  v24 = (float32x4_t)vdupq_lane_s32(v22, 0);
  v25 = __dst + 1;
  v26 = v23;
  do
  {
    v27 = vsubq_f32(*v25, v24);
    v25[-1] = vsubq_f32(v25[-1], v24);
    *v25 = v27;
    v25 += 2;
    v26 -= 8;
  }
  while (v26);
  if (v23 != v7)
    goto LABEL_20;
}

void NSigmoidalLayer::~NSigmoidalLayer(NSigmoidalLayer *this)
{
  JUMPOUT(0x212BAC9D8);
}

void NSigmoidalLayer::compute(NSigmoidalLayer *this, const float *a2, float *__dst, void *a4)
{
  uint64_t v4;
  float __B;
  int v8;

  v4 = *((_QWORD *)this + 2);
  if (!v4)
    Error::chuck((Error *)"NMatrixLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  memcpy(__dst, (const void *)(v4 + 4 * (*((_DWORD *)this + 2) * *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  cblas_sgemv_NEWLAPACK_ILP64();
  vDSP_vneg(__dst, 1, __dst, 1, *((unsigned int *)this + 3));
  v8 = *((_DWORD *)this + 3);
  vvexpf(__dst, __dst, &v8);
  __B = 1.0;
  vDSP_vsadd(__dst, 1, &__B, __dst, 1, *((unsigned int *)this + 3));
  vvrecf(__dst, __dst, &v8);
}

_QWORD *NSmartPointer<NBaseLayer>::~NSmartPointer(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F17D0;
  v2 = a1[1];
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void NSmartPointer<NBaseLayer>::~NSmartPointer(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F17D0;
  v1 = a1[1];
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NSmartPointer<NBaseLayer>::setPointer(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

void NLayer::~NLayer(NLayer *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F17D0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F17D0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<NLayer>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2DF0;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = 16 * v3;
      do
      {
        *(_QWORD *)(v2 + v4 - 16) = &off_24C7F17D0;
        v5 = *(_QWORD *)(v2 + v4 - 8);
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        v4 -= 16;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0xA1C80BD48D6D6);
  }
  return a1;
}

void NArray<NLayer>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *a1 = &off_24C7F2DF0;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = 16 * v2;
      do
      {
        *(_QWORD *)(v1 + v3 - 16) = &off_24C7F17D0;
        v4 = *(_QWORD *)(v1 + v3 - 8);
        if (v4)
          (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
        v3 -= 16;
      }
      while (v3);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0xA1C80BD48D6D6);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NLayer>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 v16;
  uint64_t v17;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 - 8);
      if (v7)
      {
        v8 = 16 * v7;
        do
        {
          *(_QWORD *)(v6 + v8 - 16) = &off_24C7F17D0;
          v9 = *(_QWORD *)(v6 + v8 - 8);
          if (v9)
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
          v8 -= 16;
        }
        while (v8);
      }
      MEMORY[0x212BAC9C0](v6 - 16, 0xA1C80BD48D6D6);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v10 = (_QWORD *)operator new[]();
    *v10 = 16;
    v10[1] = v5;
    v11 = v10 + 2;
    if (!v5)
      goto LABEL_17;
    v12 = (v5 - 1) & 0xFFFFFFFFFFFFFFFLL;
    v13 = v10 + 2;
    if (v12 >= 3)
    {
      v14 = (v12 + 1) & 0x1FFFFFFFFFFFFFFCLL;
      v15 = v10 + 6;
      *((_QWORD *)&v16 + 1) = 0;
      *(_QWORD *)&v16 = &off_24C7F31E0;
      v17 = v14;
      do
      {
        *(v15 - 2) = v16;
        *(v15 - 1) = v16;
        *v15 = v16;
        v15[1] = v16;
        v15 += 4;
        v17 -= 4;
      }
      while (v17);
      if (v12 + 1 == v14)
        goto LABEL_17;
      v13 = &v11[2 * v14];
    }
    do
    {
      *v13 = &off_24C7F31E0;
      v13[1] = 0;
      v13 += 2;
    }
    while (v13 != &v11[2 * v5]);
LABEL_17:
    *(_QWORD *)(a1 + 8) = v11;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
    Error::chuck((Error *)"NLayer::operator=() - attempting to copy layer prohibited", (const char *)a2);
  return a1;
}

uint64_t NArray<NLayer>::fromArray(uint64_t result, const char *a2, unsigned int *a3)
{
  int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 v16;
  uint64_t v17;

  v3 = *(_DWORD *)(result + 16);
  v4 = *a3;
  if (v3 == *a3)
    goto LABEL_17;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  if (v6)
  {
    v8 = *(_QWORD *)(v6 - 8);
    if (v8)
    {
      v9 = 16 * v8;
      do
      {
        *(_QWORD *)(v6 + v9 - 16) = &off_24C7F17D0;
        v10 = *(_QWORD *)(v6 + v9 - 8);
        if (v10)
          (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
        v9 -= 16;
      }
      while (v9);
    }
    MEMORY[0x212BAC9C0](v6 - 16, 0xA1C80BD48D6D6);
    v4 = *a3;
  }
  *(_DWORD *)(v5 + 16) = v4;
  result = operator new[]();
  *(_QWORD *)result = 16;
  *(_QWORD *)(result + 8) = v4;
  v11 = result + 16;
  if (v4)
  {
    v12 = (v4 - 1) & 0xFFFFFFFFFFFFFFFLL;
    v13 = (_QWORD *)(result + 16);
    if (v12 >= 3)
    {
      v14 = (v12 + 1) & 0x1FFFFFFFFFFFFFFCLL;
      v15 = (_OWORD *)(result + 48);
      *((_QWORD *)&v16 + 1) = 0;
      *(_QWORD *)&v16 = &off_24C7F31E0;
      v17 = v14;
      do
      {
        *(v15 - 2) = v16;
        *(v15 - 1) = v16;
        *v15 = v16;
        v15[1] = v16;
        v15 += 4;
        v17 -= 4;
      }
      while (v17);
      if (v12 + 1 == v14)
        goto LABEL_16;
      v13 = (_QWORD *)(v11 + 16 * v14);
    }
    do
    {
      *v13 = &off_24C7F31E0;
      v13[1] = 0;
      v13 += 2;
    }
    while (v13 != (_QWORD *)(v11 + 16 * v4));
  }
LABEL_16:
  *(_QWORD *)(v5 + 8) = v11;
  v3 = *(_DWORD *)(v5 + 16);
LABEL_17:
  if (v3)
    Error::chuck((Error *)"NLayer::operator=() - attempting to copy layer prohibited", a2);
  return result;
}

void NDeepnetDistribution::NDeepnetDistribution(NDeepnetDistribution *this)
{
  const char *v2;
  _BYTE *v3;
  const char *v4;
  _BYTE *v5;
  void *memptr;

  *((_QWORD *)this + 4) = &off_24C7F2DF0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F21F0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = &off_24C7F2108;
  *((_DWORD *)this + 20) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 20));
  v3 = memptr;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = v3;
  *((_QWORD *)this + 7) = &off_24C7F2108;
  *v3 = 0;
  *((_QWORD *)this + 11) = &off_24C7F17B0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = &off_24C7F2108;
  *((_DWORD *)this + 34) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v4, 1, *((unsigned int *)this + 34));
  v5 = memptr;
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 16) = v5;
  *((_QWORD *)this + 14) = &off_24C7F2108;
  *v5 = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = &off_24C7F1BF8;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 22) = &off_24C7F30C8;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = &off_24C7F3090;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *((_QWORD *)this + 29) = &off_24C7F3090;
  *((_QWORD *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
  *((_QWORD *)this + 32) = &off_24C7F3090;
  *((_QWORD *)this + 33) = 0;
  *((_DWORD *)this + 68) = 0;
  *((_BYTE *)this + 280) = 0;
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = &off_24C7F3138;
  *((_QWORD *)this + 39) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_QWORD *)this + 41) = 0;
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = &off_24C7F3138;
  *((_QWORD *)this + 44) = 0;
  *((_DWORD *)this + 90) = 0;
  *((_WORD *)this + 184) = 0;
  *((_BYTE *)this + 376) = 0;
}

void sub_20D9B7790(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;

  N16ByteAlignedString::~N16ByteAlignedString(v2);
  NArray<NLayer>::~NArray(v1);
  _Unwind_Resume(a1);
}

uint64_t NDeepnetDistribution::reset(NDeepnetDistribution *this)
{
  size_t v2;
  int v4;
  int v5;
  int v6;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  v4 = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v4);
  v5 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 7) + 64))((char *)this + 56, "", &v5);
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  v2 = *((unsigned int *)this + 36);
  if ((_DWORD)v2)
    munmap(*((void **)this + 19), v2);
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = 0;
  v6 = 0;
  return (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 14) + 64))((char *)this + 112, "", &v6);
}

uint64_t NDeepnetDistribution::verifyMemoryImage(NDeepnetDistribution *this, const char *a2, const unsigned int *a3)
{
  uint64_t v3;
  uint64_t v5;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  _BOOL4 v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  int v20;
  _DWORD *v21;
  unsigned int v22;
  unsigned int v23;
  int v25;
  unsigned int v26;

  if (!this)
    return 0xFFFFFFFFLL;
  v3 = *(unsigned int *)a2;
  if (v3 < 0x34)
    return 4294967294;
  if (*(_QWORD *)this != 0x20624C4E4E442023 || *((_QWORD *)this + 1) != 0xA0A0A30302E3176)
    return 4294967293;
  v7 = *((_DWORD *)this + 4);
  v8 = *((unsigned int *)this + 5);
  v10 = *((_DWORD *)this + 6);
  v9 = *((_DWORD *)this + 7);
  v11 = *((_DWORD *)this + 8);
  v12 = *((unsigned int *)this + 9);
  v13 = *((_DWORD *)this + 10);
  v14 = *((_DWORD *)this + 11);
  if ((v7 & 0xF) == 2)
  {
    v15 = (v7 & 0xFE00) == 0;
    v5 = 4294967291;
    if ((v10 & 1) != 0)
      return v5;
    goto LABEL_16;
  }
  if (v7 != 1)
    return 4294967292;
  v15 = 1;
  v5 = 4294967291;
  if ((v10 & 1) != 0)
    return v5;
LABEL_16:
  if (!v15)
    return v5;
  if (!(_DWORD)v12)
    return 4294967290;
  if (v12 > 0x4000000)
    return 4294967289;
  v16 = (char *)this + v3;
  v17 = (char *)this + *((_DWORD *)this + 12) + (-*((_DWORD *)this + 12) & 3u) + 52;
  if (v17 > v16)
    return 4294967288;
  if ((v10 & 0x20) != 0)
  {
    v17 += (4 * v14) + 4;
    if (v17 > v16)
      return 4294967287;
  }
  v18 = &v17[16 * v12];
  if (v18 > v16)
    return 4294967286;
  v19 = &v18[v8];
  if (v19 > v16)
    return 4294967285;
  if (v19 != v16)
    return 4294967284;
  v20 = 4 * v12;
  v21 = v17 + 12;
  do
  {
    v22 = *(v21 - 1);
    v23 = *v21 + v22;
    if (v23 > v8 || v23 < v22)
      return 4294967283;
    v21 += 4;
    --v12;
  }
  while (v12);
  v25 = *(_DWORD *)&v17[4 * (v20 - 3)];
  if (v14 * v13 == v9)
    v26 = 0;
  else
    v26 = -15;
  if (v25 == v11)
    return v26;
  else
    return 4294967282;
}

uint64_t NDeepnetDistribution::init(NDeepnetDistribution *this, const char *a2, const unsigned int *a3)
{
  size_t v6;
  int v8;
  int v9;
  int v10;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  v8 = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v8);
  v9 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 7) + 64))((char *)this + 56, "", &v9);
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  v6 = *((unsigned int *)this + 36);
  if ((_DWORD)v6)
    munmap(*((void **)this + 19), v6);
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 19) = 0;
  v10 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 14) + 64))((char *)this + 112, "", &v10);
  return NDeepnetDistribution::mapFromMemory(this, a2, a3, "Blob");
}

uint64_t NDeepnetDistribution::loadFixedInputLayer(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;

  if (*(_DWORD *)(result + 12))
  {
    v3 = 0;
    v4 = *(_QWORD *)(a2 + 8);
    v5 = *(_QWORD *)(result + 216);
    do
    {
      v6 = *(float *)(v4 + 4 * v3) * *(float *)(v5 + 4 * v3);
      if (v6 > 32767.0)
        v6 = 32767.0;
      if (v6 < -32768.0)
        v6 = -32768.0;
      *(_DWORD *)(a3 + 4 * v3++) = (uint64_t)rintf(v6);
    }
    while (v3 < *(unsigned int *)(result + 12));
  }
  return result;
}

uint64_t NDeepnetDistribution::extractFixedOutputLayer(uint64_t result, int32x4_t *a2, uint64_t a3)
{
  uint64_t v3;
  float32x4_t *v4;
  uint64_t v5;
  float32x4_t *v6;
  int32x4_t *v7;
  float32x4_t v8;
  uint64_t v9;
  float32x4_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  int *v14;
  int v15;

  v3 = *(unsigned int *)(result + 8);
  if ((_DWORD)v3)
  {
    v4 = *(float32x4_t **)(a3 + 8);
    if (v3 < 8)
    {
      v5 = 0;
LABEL_7:
      v11 = v3 - v5;
      v12 = v5;
      v13 = &v4->f32[v12];
      v14 = &a2->i32[v12];
      do
      {
        v15 = *v14++;
        *v13++ = (float)v15 * 0.000030518;
        --v11;
      }
      while (v11);
      return result;
    }
    v5 = v3 & 0xFFFFFFF8;
    v6 = v4 + 1;
    v7 = a2 + 1;
    v8.i64[0] = 0x3800000038000000;
    v8.i64[1] = 0x3800000038000000;
    v9 = v5;
    do
    {
      v10 = vmulq_f32(vcvtq_f32_s32(*v7), v8);
      v6[-1] = vmulq_f32(vcvtq_f32_s32(v7[-1]), v8);
      *v6 = v10;
      v6 += 2;
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    if (v5 != v3)
      goto LABEL_7;
  }
  return result;
}

void NMemoryFile::~NMemoryFile(NMemoryFile *this)
{
  uint64_t v2;
  int v3;

  *(_QWORD *)this = &off_24C7F1540;
  v3 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v3);
  *((_BYTE *)this + 68) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
}

{
  uint64_t v2;
  int v3;

  *(_QWORD *)this = &off_24C7F1540;
  v3 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v3);
  *((_BYTE *)this + 68) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  int v3;

  *(_QWORD *)this = &off_24C7F1540;
  v3 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v3);
  *((_BYTE *)this + 68) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
}

uint64_t NMemoryFile::open(NMemoryFile *this, const NString *a2, const NString *a3)
{
  const char *v6;
  _BYTE *v7;
  int v8;
  uint64_t v9;
  char *v10;
  _BYTE *v11;
  int64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  const void *v19;
  void *v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t (**v24)(NString *__hidden, const unsigned int *);
  int v25;
  void *v26;

  (*(void (**)(NMemoryFile *))(*(_QWORD *)this + 24))(this);
  v7 = (_BYTE *)*((_QWORD *)a3 + 2);
  if (*((_DWORD *)a3 + 2) != 1)
    goto LABEL_21;
  if (*v7 != 114)
  {
    v7 = (_BYTE *)*((_QWORD *)a3 + 2);
    if (*v7 == 119)
    {
      v8 = 1;
      goto LABEL_6;
    }
LABEL_21:
    Error::chuck((Error *)"NMemoryFile::open() - unrecognized file mode %s", v6, v7);
  }
  v8 = 0;
LABEL_6:
  *((_DWORD *)this + 16) = v8;
  v9 = *((unsigned int *)a2 + 2);
  if (!(_DWORD)v9
    || (v10 = (char *)*((_QWORD *)a2 + 2), (v11 = memchr(v10, 0, *((unsigned int *)a2 + 2))) == 0)
    || (v12 = v11 - v10, (_DWORD)v11 - (_DWORD)v10 < 0)
    || (v13 = ((_DWORD)v11 - (_DWORD)v10), v13 + 17 != v9))
  {
    Error::chuck((Error *)"NMemoryFile::open() - mindex: filespec has no memory pointer", v6);
  }
  v14 = (v12 + 1);
  if (v14 >= v9)
  {
    v22 = (v9 - 1);
    v23 = v14;
    goto LABEL_24;
  }
  v15 = *(_QWORD *)&v10[v14];
  *((_QWORD *)this + 5) = v15;
  v16 = (v12 + 9);
  v17 = *((_DWORD *)a2 + 2);
  if (v16 >= v17)
  {
    v22 = v17 - 1;
    v23 = v16;
LABEL_24:
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, v23, v22);
  }
  *((_QWORD *)this + 6) = *(_QWORD *)(*((_QWORD *)a2 + 2) + v16);
  *((_QWORD *)this + 7) = v15;
  v18 = *((unsigned int *)a2 + 2);
  if (v18 < v12)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, v12, v18);
  v19 = (const void *)*((_QWORD *)a2 + 2);
  v24 = &off_24C7F32C0;
  if (!v19)
    Error::chuck((Error *)"Null pointer passed to string constructor", v6);
  v25 = v12;
  v20 = (void *)operator new[]();
  v26 = v20;
  memcpy(v20, v19, v13);
  *((_BYTE *)v20 + v13) = 0;
  if ((uint64_t (***)(NString *__hidden, const unsigned int *))((char *)this + 8) == &v24)
  {
    v24 = &off_24C7F32C0;
  }
  else
  {
    result = (*(uint64_t (**)(char *, void *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, v20, &v25);
    v20 = v26;
    v24 = &off_24C7F32C0;
    if (!v26)
      goto LABEL_19;
  }
  result = MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
LABEL_19:
  *((_BYTE *)this + 68) = 1;
  return result;
}

void sub_20D9B7ED0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NMemoryFile::close(NMemoryFile *this)
{
  char *v1;
  uint64_t result;
  int v3;

  v3 = 0;
  v1 = (char *)this + 8;
  result = (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v3);
  v1[60] = 0;
  *((_QWORD *)v1 + 5) = 0;
  *((_QWORD *)v1 + 6) = 0;
  *((_QWORD *)v1 + 4) = 0;
  return result;
}

uint64_t NMemoryFile::isOpen(NMemoryFile *this)
{
  return *((unsigned __int8 *)this + 68);
}

BOOL NMemoryFile::eof(NMemoryFile *this)
{
  return *((_QWORD *)this + 7) >= *((_QWORD *)this + 6);
}

uint64_t NMemoryFile::good(NMemoryFile *this)
{
  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 40))(this) & 1) != 0)
    return 0;
  else
    return (*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this);
}

void *NMemoryFile::read@<X0>(NMemoryFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  const void *v5;
  unsigned int v6;
  void *v7;
  void *result;

  v4 = *((_QWORD *)this + 6);
  v5 = (const void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = v4;
  *(_QWORD *)a3 = &off_24C7F32C0;
  if (!v5)
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  v6 = v4 - (_DWORD)v5;
  *(_DWORD *)(a3 + 8) = v4 - (_DWORD)v5;
  v7 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v7;
  result = memcpy(v7, v5, v6);
  *((_BYTE *)v7 + v6) = 0;
  return result;
}

void *NMemoryFile::read@<X0>(NMemoryFile *this@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v6;
  unsigned int v7;
  char *v8;
  unsigned int v9;
  size_t v10;
  void *v11;
  void *result;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::read() - file %s is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 16))
    Error::chuck((Error *)"NMemoryFile::read() - file %s not opened in read mode", v6, *((_QWORD *)this + 3));
  v7 = *a2;
  if (*a2 == -1)
    Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((_QWORD *)this + 3));
  v8 = (char *)*((_QWORD *)this + 7);
  v9 = *((_DWORD *)this + 12) - (_DWORD)v8;
  if (v7 >= v9)
    v10 = v9;
  else
    v10 = v7;
  *((_QWORD *)this + 7) = &v8[v10];
  *(_QWORD *)a3 = &off_24C7F32C0;
  if (!v8)
    Error::chuck((Error *)"Null pointer passed to string constructor", v6);
  *(_DWORD *)(a3 + 8) = v10;
  v11 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v11;
  result = memcpy(v11, v8, v10);
  *((_BYTE *)v11 + v10) = 0;
  return result;
}

uint64_t NMemoryFile::read(NMemoryFile *this, unsigned int *a2, NString *a3)
{
  const char *v6;
  unsigned int v8;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::read() - file %s is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 16))
    Error::chuck((Error *)"NMemoryFile::read() - file %s not opened in read mode", v6, *((_QWORD *)this + 3));
  if (*a2 == -1)
    Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((_QWORD *)this + 3));
  v8 = *a2;
  if (*a2 > *((_DWORD *)this + 12) - *((_QWORD *)this + 7))
    v8 = *((_DWORD *)this + 12) - *((_QWORD *)this + 7);
  (*(void (**)(NString *))(*(_QWORD *)a3 + 64))(a3);
  *((_QWORD *)this + 7) += v8;
  return *((unsigned int *)a3 + 2);
}

void *NMemoryFile::readLine@<X0>(NMemoryFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  _BOOL8 v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unint64_t v15;
  int v17;
  int v18;
  unsigned int v19;
  void *v20;
  void *result;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::readLine() - file %s is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 16))
    Error::chuck((Error *)"NMemoryFile::readLine() - file %s not opened in read mode", v6, *((_QWORD *)this + 3));
  v7 = *((_QWORD *)this + 6);
  v8 = (unsigned __int8 *)*((_QWORD *)this + 7);
  if ((unint64_t)v8 >= v7)
  {
    v9 = 0;
    v10 = 0;
  }
  else if (*v8 == 10)
  {
    v9 = 0;
    v10 = 1;
  }
  else
  {
    v9 = 0;
    v11 = (unsigned __int8 *)*((_QWORD *)this + 6);
    while (~(unint64_t)v8 + v7 != v9)
    {
      v12 = v8[++v9];
      if (v12 == 10)
      {
        v11 = &v8[v9];
        goto LABEL_12;
      }
    }
    v9 = v7 - (_QWORD)v8;
LABEL_12:
    v10 = (unint64_t)v11 < v7;
  }
  v13 = &v8[v9 & (v9 >> 63)];
  v14 = v9;
  do
  {
    v15 = v14;
    if (v14-- < 1)
      goto LABEL_28;
  }
  while (v8[v15 - 1] == 13);
  v17 = *(unsigned __int8 *)a2;
  if (!*a2)
  {
    LODWORD(v13) = (_DWORD)v8 + v15;
LABEL_26:
    *((_QWORD *)this + 7) = &v8[v9 + v10];
    *(_QWORD *)a3 = &off_24C7F32C0;
    goto LABEL_29;
  }
  v18 = *v8;
  v13 = (unsigned __int8 *)*((_QWORD *)this + 7);
  if (v18 == v17)
    goto LABEL_26;
  v13 = v8 + 1;
  if (v15 < 2)
    goto LABEL_26;
  if (v18 != 32)
    goto LABEL_20;
LABEL_21:
  if (*v13 != v17)
  {
    while (v13 + 1 < &v8[v15])
    {
      v18 = *v13++;
      if (v18 == 32)
        goto LABEL_21;
LABEL_20:
      if (v18 == 9)
        goto LABEL_21;
    }
    LODWORD(v13) = (_DWORD)v13 + 1;
  }
LABEL_28:
  *((_QWORD *)this + 7) = &v8[v9 + v10];
  *(_QWORD *)a3 = &off_24C7F32C0;
  if (!v8)
    Error::chuck((Error *)"Null pointer passed to string constructor", v6);
LABEL_29:
  v19 = (_DWORD)v13 - (_DWORD)v8;
  *(_DWORD *)(a3 + 8) = (_DWORD)v13 - (_DWORD)v8;
  v20 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v20;
  result = memcpy(v20, v8, v19);
  *((_BYTE *)v20 + v19) = 0;
  return result;
}

void *NMemoryFile::readString@<X0>(NMemoryFile *this@<X0>, uint64_t a2@<X8>)
{
  const char *v4;
  uint64_t v5;
  _DWORD *v6;
  char *v7;
  size_t v8;
  unsigned int v9;
  void *v10;
  void *result;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::readString() - file %s is not open", v4, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 16))
    Error::chuck((Error *)"NMemoryFile::readString() - file %s not opened in read mode", v4, *((_QWORD *)this + 3));
  v5 = *((_QWORD *)this + 6);
  v6 = (_DWORD *)*((_QWORD *)this + 7);
  if (v5 - (uint64_t)v6 <= 3)
  {
    *((_QWORD *)this + 6) = v6;
    Error::chuck((Error *)"NMemoryFile::readString() - failed to read length for embedded binary string in %s", v4, *((_QWORD *)this + 3));
  }
  v9 = *v6;
  v7 = (char *)(v6 + 1);
  v8 = v9;
  *((_QWORD *)this + 7) = v7;
  if (v5 - (uint64_t)v7 < v9)
  {
    *((_QWORD *)this + 6) = v7;
    Error::chuck((Error *)"NMemoryFile::readString() - failed to read embedded binary string in %s", v4, *((_QWORD *)this + 3));
  }
  *((_QWORD *)this + 7) = &v7[v8];
  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = v8;
  v10 = (void *)operator new[]();
  *(_QWORD *)(a2 + 16) = v10;
  result = memcpy(v10, v7, v8);
  *((_BYTE *)v10 + v8) = 0;
  return result;
}

void *NMemoryFile::write(NMemoryFile *this, const NString *a2)
{
  const char *v4;
  unsigned int v5;
  void *v6;
  unsigned int v7;
  size_t v8;
  void *result;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::write() - file %s is not open", v4, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 16) != 1)
    Error::chuck((Error *)"NMemoryFile::write() - file %s not opened in write mode", v4, *((_QWORD *)this + 3));
  v5 = *((_DWORD *)a2 + 2);
  v6 = (void *)*((_QWORD *)this + 7);
  v7 = *((_DWORD *)this + 12) - (_DWORD)v6;
  if (v5 >= v7)
    v8 = v7;
  else
    v8 = v5;
  result = memcpy(v6, *((const void **)a2 + 2), v8);
  *((_QWORD *)this + 7) += v8;
  return result;
}

uint64_t NMemoryFile::setPosition(NMemoryFile *this, const unsigned int *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::setPosition() - cannot get position, file %s is not open", v4, *((_QWORD *)this + 3));
  v5 = *a2;
  if ((_DWORD)v5 == -1)
  {
    v8 = *((_QWORD *)this + 6);
  }
  else
  {
    v6 = *((_QWORD *)this + 5);
    if (*((_QWORD *)this + 6) - v6 < v5)
      return 0;
    v8 = v6 + v5;
  }
  *((_QWORD *)this + 7) = v8;
  return 1;
}

uint64_t NMemoryFile::getPosition(NMemoryFile *this)
{
  const char *v2;

  if (((*(uint64_t (**)(NMemoryFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NMemoryFile::getPosition() - cannot get position, file %s is not open", v2, *((_QWORD *)this + 3));
  return (*((_DWORD *)this + 14) - *((_DWORD *)this + 10));
}

void NMemoryFile::NMemoryFile(NMemoryFile *this)
{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1540;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)((char *)this + 61) = 0;
}

{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1540;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)((char *)this + 61) = 0;
}

void NMemoryFile::NMemoryFile(NMemoryFile *this, const NString *a2, const NString *a3)
{
  _BYTE *v6;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1540;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)((char *)this + 61) = 0;
  NMemoryFile::open(this, a2, a3);
}

{
  _BYTE *v6;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F1540;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)((char *)this + 61) = 0;
  NMemoryFile::open(this, a2, a3);
}

void sub_20D9B8818(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  *v1 = v2;
  v1[1] = v3;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9B88E4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  *v1 = v2;
  v1[1] = v3;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NMemoryFile::newMemoryBlockDef(NMemoryFile *this, const NString *a2, const void *a3)
{
  uint64_t (**v4)(NString *__hidden, const unsigned int *);
  int v5;
  _WORD *v6;
  _BYTE v7[48];
  const NString *v8;

  v8 = a2;
  v4 = &off_24C7F32C0;
  v5 = 1;
  v6 = (_WORD *)operator new[]();
  *v6 = 0;
  NString::operator+((uint64_t)this, (uint64_t)&v4, (uint64_t)v7);
}

void sub_20D9B8A10(uint64_t a1, ...)
{
  uint64_t v1;
  uint64_t v2;
  va_list va;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  va_list va1;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va2;

  va_start(va2, a1);
  va_start(va1, a1);
  va_start(va, a1);
  v2 = va_arg(va1, _QWORD);
  v4 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _BYTE *);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  LODWORD(v8) = 0;
  v9 = (_BYTE *)operator new[]();
  *v9 = 0;
  LODWORD(v2) = 8;
  NString::appendTo((NString *)va1, (const void *)(v1 - 64), (const unsigned int *)va);
  NString::operator+((uint64_t)va2, (uint64_t)va1, v1 - 88);
}

void sub_20D9B8A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, _BYTE *a12)
{
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  a11 = 0;
  a12 = (_BYTE *)operator new[]();
  *a12 = 0;
  a9 = *(_QWORD *)(v14 - 64) + v13;
  *(_DWORD *)(v14 - 52) = 8;
  NString::appendTo((NString *)&a10, &a9, (const unsigned int *)(v14 - 52));
  NString::operator+(v14 - 88, (uint64_t)&a10, v12);
}

uint64_t sub_20D9B8ABC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v2 = *(_QWORD *)(v1 - 72);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  return MEMORY[0x212BAC9C0](v0, 0x1000C8077774924);
}

void sub_20D9B8B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;

  v24 = *(_QWORD *)(v22 - 72);
  if (v24)
    MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  if (a15)
    MEMORY[0x212BAC9C0](a15, 0x1000C8077774924);
  if (a21)
    MEMORY[0x212BAC9C0](a21, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NMemoryFile::getMemoryBlockParams(NMemoryFile *this, const NString *a2, const void **a3, unsigned int *a4)
{
  size_t v4;
  char *v7;
  uint64_t result;
  const char *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v4 = *((unsigned int *)this + 2);
  if (!(_DWORD)v4)
    return 0;
  v7 = (char *)*((_QWORD *)this + 2);
  result = (uint64_t)memchr(v7, 0, v4);
  if (!result)
    return result;
  v10 = result - (_DWORD)v7;
  if ((_DWORD)result - (_DWORD)v7 < 0 || (result - (_DWORD)v7) + 17 != v4)
    return 0;
  v11 = v10;
  v12 = v10 + 1;
  if (v12 >= v4)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v12, (v4 - 1));
  v13 = v11 + 9;
  if (v13 >= v4)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v13, (v4 - 1));
  v14 = *(_QWORD *)&v7[v12];
  v15 = *(_DWORD *)&v7[v13];
  *(_QWORD *)a2 = v14;
  *(_DWORD *)a3 = v15 - v14;
  return 1;
}

void NFixedPointScales::~NFixedPointScales(NFixedPointScales *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C7F1BF8;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 13);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 9) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 10);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 7);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  v5 = *((_QWORD *)this + 3);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C7F1BF8;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 13);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 9) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 10);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 7);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  v5 = *((_QWORD *)this + 3);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C7F1BF8;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 13);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 9) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 10);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 7);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  v5 = *((_QWORD *)this + 3);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
}

uint64_t NFixedPointScales::paramLimit(NFixedPointScales *this)
{
  return 0x7FFFLL;
}

void NGaussianFixedPointScales::~NGaussianFixedPointScales(NGaussianFixedPointScales *this)
{
  NGaussianFixedPointScales::~NGaussianFixedPointScales(this);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24C7F2A18;
  *((_QWORD *)this + 21) = &off_24C7F30C8;
  v2 = *((_QWORD *)this + 22);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 17) = &off_24C7F30C8;
  v3 = *((_QWORD *)this + 18);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *(_QWORD *)this = &off_24C7F1BF8;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 13);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 9) = &off_24C7F3090;
  v5 = *((_QWORD *)this + 10);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  *((_QWORD *)this + 6) = &off_24C7F3090;
  v6 = *((_QWORD *)this + 7);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  v7 = *((_QWORD *)this + 3);
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
}

uint64_t NGaussianFixedPointScales::paramLimit(NGaussianFixedPointScales *this)
{
  return 23170;
}

void NFixedPointScales::NFixedPointScales(NFixedPointScales *this)
{
  *(_QWORD *)this = &off_24C7F1BF8;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = &off_24C7F3090;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_BYTE *)this + 120) = 0;
}

{
  *(_QWORD *)this = &off_24C7F1BF8;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = &off_24C7F3090;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_BYTE *)this + 120) = 0;
}

void NFixedPointScales::initialize(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;

  *(_DWORD *)(a1 + 8) = *a2;
  if (a1 + 16 != a3)
  {
    v5 = *(_DWORD *)(a1 + 32);
    v6 = *(_DWORD *)(a3 + 16);
    if (v5 != v6)
    {
      v7 = *(_QWORD *)(a1 + 24);
      if (v7)
      {
        MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        v6 = *(_DWORD *)(a3 + 16);
      }
      *(_DWORD *)(a1 + 32) = v6;
      *(_QWORD *)(a1 + 24) = operator new[]();
      v5 = *(_DWORD *)(a1 + 32);
    }
    if (v5)
    {
      v8 = 0;
      v9 = *(_QWORD *)(a3 + 8);
      v10 = *(_QWORD *)(a1 + 24);
      do
      {
        *(_DWORD *)(v10 + 4 * v8) = *(_DWORD *)(v9 + 4 * v8);
        ++v8;
      }
      while (v8 < *(unsigned int *)(a1 + 32));
    }
  }
  v11 = ldexp(1.0, *(_DWORD *)(a1 + 8));
  *(float *)(a1 + 40) = v11;
  *(float *)(a1 + 44) = 1.0 / v11;
  NFixedPointScales::makeParamScales((NFixedPointScales *)a1);
  *(_BYTE *)(a1 + 120) = 1;
}

void NFixedPointScales::makeParamScales(NFixedPointScales *this)
{
  int v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  _OWORD *v26;
  __int128 *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int *v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  _OWORD *v41;
  __int128 *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  int *v48;
  int v49;
  unint64_t v50;
  float v51;
  float v52;

  v2 = (*(uint64_t (**)(NFixedPointScales *))(*(_QWORD *)this + 16))(this);
  v3 = *((_DWORD *)this + 16);
  v4 = *((_DWORD *)this + 8);
  if (v3 != v4)
  {
    v5 = *((_QWORD *)this + 7);
    *((_DWORD *)this + 16) = v4;
    v6 = operator new[]();
    *((_QWORD *)this + 7) = v6;
    v7 = *((_DWORD *)this + 8);
    if (v3 >= v7)
      v8 = v7;
    else
      v8 = v3;
    if (!(_DWORD)v8)
    {
      if (!v5)
      {
        v3 = *((_DWORD *)this + 8);
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    if (v8 >= 8 && (unint64_t)(v6 - v5) > 0x1F)
    {
      v10 = v8 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v6 + 16);
      v12 = (__int128 *)(v5 + 16);
      v13 = v10;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v10 == v8)
        goto LABEL_18;
    }
    else
    {
      v10 = 0;
    }
    v15 = v8 - v10;
    v16 = 4 * v10;
    v17 = (_DWORD *)(v6 + 4 * v10);
    v18 = (int *)(v5 + v16);
    do
    {
      v19 = *v18++;
      *v17++ = v19;
      --v15;
    }
    while (v15);
LABEL_18:
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
    v3 = *((_DWORD *)this + 8);
  }
LABEL_19:
  v20 = *((_DWORD *)this + 22);
  if (v20 == v3)
    goto LABEL_37;
  v21 = *((_QWORD *)this + 10);
  *((_DWORD *)this + 22) = v3;
  v22 = operator new[]();
  *((_QWORD *)this + 10) = v22;
  v3 = *((_DWORD *)this + 8);
  if (v20 >= v3)
    v23 = v3;
  else
    v23 = v20;
  if ((_DWORD)v23)
  {
    if (v23 >= 8 && (unint64_t)(v22 - v21) > 0x1F)
    {
      v25 = v23 & 0xFFFFFFF8;
      v26 = (_OWORD *)(v22 + 16);
      v27 = (__int128 *)(v21 + 16);
      v28 = v25;
      do
      {
        v29 = *v27;
        *(v26 - 1) = *(v27 - 1);
        *v26 = v29;
        v26 += 2;
        v27 += 2;
        v28 -= 8;
      }
      while (v28);
      if (v25 == v23)
        goto LABEL_36;
    }
    else
    {
      v25 = 0;
    }
    v30 = v23 - v25;
    v31 = 4 * v25;
    v32 = (_DWORD *)(v22 + 4 * v25);
    v33 = (int *)(v21 + v31);
    do
    {
      v34 = *v33++;
      *v32++ = v34;
      --v30;
    }
    while (v30);
LABEL_36:
    MEMORY[0x212BAC9C0](v21, 0x1000C8052888210);
    v3 = *((_DWORD *)this + 8);
    goto LABEL_37;
  }
  if (v21)
    goto LABEL_36;
LABEL_37:
  v35 = *((_DWORD *)this + 28);
  if (v35 == v3)
    goto LABEL_55;
  v36 = *((_QWORD *)this + 13);
  *((_DWORD *)this + 28) = v3;
  v37 = operator new[]();
  *((_QWORD *)this + 13) = v37;
  v3 = *((_DWORD *)this + 8);
  if (v35 >= v3)
    v38 = v3;
  else
    v38 = v35;
  if ((_DWORD)v38)
  {
    if (v38 >= 8 && (unint64_t)(v37 - v36) > 0x1F)
    {
      v40 = v38 & 0xFFFFFFF8;
      v41 = (_OWORD *)(v37 + 16);
      v42 = (__int128 *)(v36 + 16);
      v43 = v40;
      do
      {
        v44 = *v42;
        *(v41 - 1) = *(v42 - 1);
        *v41 = v44;
        v41 += 2;
        v42 += 2;
        v43 -= 8;
      }
      while (v43);
      if (v40 == v38)
        goto LABEL_54;
    }
    else
    {
      v40 = 0;
    }
    v45 = v38 - v40;
    v46 = 4 * v40;
    v47 = (_DWORD *)(v37 + 4 * v40);
    v48 = (int *)(v36 + v46);
    do
    {
      v49 = *v48++;
      *v47++ = v49;
      --v45;
    }
    while (v45);
LABEL_54:
    MEMORY[0x212BAC9C0](v36, 0x1000C8052888210);
    v3 = *((_DWORD *)this + 8);
    goto LABEL_55;
  }
  if (v36)
    goto LABEL_54;
LABEL_55:
  if (v3)
  {
    v50 = 0;
    do
    {
      v51 = ldexp(1.0, *(_DWORD *)(*((_QWORD *)this + 3) + 4 * v50));
      *(float *)(*((_QWORD *)this + 7) + 4 * v50) = v51;
      v52 = 1.0 / v51;
      *(float *)(*((_QWORD *)this + 10) + 4 * v50) = v52;
      *(float *)(*((_QWORD *)this + 13) + 4 * v50++) = v52 * (float)v2;
    }
    while (v50 < *((unsigned int *)this + 8));
  }
}

void NFixedPointScales::setUp(NFixedPointScales *this)
{
  float v2;

  v2 = ldexp(1.0, *((_DWORD *)this + 2));
  *((float *)this + 10) = v2;
  *((float *)this + 11) = 1.0 / v2;
  NFixedPointScales::makeParamScales(this);
  *((_BYTE *)this + 120) = 1;
}

float32_t NFixedPointScales::toFloatVec@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  float32x4_t v7;
  uint64_t v8;
  uint64_t v9;
  int16x4_t *v10;
  float32x4_t *v11;
  float32x4_t *v12;
  float32x4_t *v13;
  int16x4_t *v14;
  uint64_t v15;
  int16x8_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;
  _DWORD *v25;
  float *v26;
  __int16 *v27;
  int v28;
  float v29;
  float v30;

  *(_QWORD *)a3 = &off_24C7F3090;
  v6 = operator new[]();
  *(_QWORD *)(a3 + 8) = v6;
  v8 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(a3 + 16) = v8;
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = *(int16x4_t **)(a2 + 8);
    v11 = *(float32x4_t **)(a1 + 80);
    if (v8 < 0x10)
      goto LABEL_7;
    if ((unint64_t)(v6 - (_QWORD)v11) < 0x40)
      goto LABEL_7;
    v9 = v8 & 0xFFFFFFF0;
    v12 = (float32x4_t *)(v6 + 32);
    v13 = v11 + 2;
    v14 = v10 + 2;
    v15 = v9;
    do
    {
      v16 = *(int16x8_t *)v14[-2].i8;
      v17 = vcvtq_f32_s32(vmovl_high_s16(v16));
      v19 = v13[-2];
      v18 = v13[-1];
      v21 = *v13;
      v20 = v13[1];
      v13 += 4;
      v7 = vmulq_f32(v19, vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v16.i8)));
      v22 = vmulq_f32(v21, vcvtq_f32_s32(vmovl_s16(*v14)));
      v23 = vmulq_f32(v20, vcvtq_f32_s32(vmovl_high_s16(*(int16x8_t *)v14->i8)));
      v12[-2] = v7;
      v12[-1] = vmulq_f32(v18, v17);
      *v12 = v22;
      v12[1] = v23;
      v12 += 4;
      v14 += 4;
      v15 -= 16;
    }
    while (v15);
    if (v9 != v8)
    {
LABEL_7:
      v24 = v8 - v9;
      v25 = (_DWORD *)(v6 + 4 * v9);
      v26 = &v11->f32[v9];
      v27 = (__int16 *)v10 + v9;
      do
      {
        v28 = *v27++;
        v29 = (float)v28;
        v30 = *v26++;
        v7.f32[0] = v30 * v29;
        *v25++ = v7.i32[0];
        --v24;
      }
      while (v24);
    }
  }
  return v7.f32[0];
}

float NFixedPointScales::toFixVec@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  float result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;

  *(_QWORD *)a3 = &off_24C7F3138;
  v6 = operator new[]();
  *(_QWORD *)(a3 + 8) = v6;
  v8 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(a3 + 16) = v8;
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = *(_QWORD *)(a2 + 8);
    v11 = *(_QWORD *)(a1 + 104);
    do
    {
      v13 = *(float *)(v10 + 4 * v9);
      v14 = *(float *)(v11 + 4 * v9);
      if (v13 > v14)
      {
        v12 = v14 * *(float *)(*(_QWORD *)(a1 + 56) + 4 * v9);
      }
      else
      {
        v15 = -v14;
        v16 = *(float *)(*(_QWORD *)(a1 + 56) + 4 * v9);
        if (v13 >= v15)
          v12 = v13 * v16;
        else
          v12 = v16 * v15;
      }
      result = rintf(v12);
      *(_WORD *)(v6 + 2 * v9++) = (uint64_t)result;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t NFixedPointScales::readInt(NFixedPointScales *this, NFilePtr *a2, const BOOL *a3, const NString *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  int v12;
  _WORD *v13;
  int v14;
  uint64_t (**v15)(NString *__hidden, const unsigned int *);
  int v16;
  void *__s1;

  if (!*a3)
  {
    v8 = *((_QWORD *)a2 + 1);
    if (v8)
    {
      LOBYTE(v14) = 0;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v8 + 80))(&v15, v8, &v14);
      v11 = &off_24C7F32C0;
      v12 = 1;
      v13 = (_WORD *)operator new[]();
      *v13 = 61;
      NString::operator+((uint64_t)a4, (uint64_t)&v11, (uint64_t)&v14);
    }
LABEL_10:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  v6 = *((_QWORD *)a2 + 1);
  if (!v6)
    goto LABEL_10;
  v14 = 4;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, int *))(*(_QWORD *)v6 + 64))(&v15, v6, &v14);
  if (v16 != 4)
  {
    v15 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    v10 = *((_QWORD *)a2 + 1);
    if (v10)
      Error::chuck((Error *)"NGaussianFixedPointScales::read() - failed to read %s from file %s", (const char *)a2, *((_QWORD *)a4 + 2), *(_QWORD *)(v10 + 24));
    goto LABEL_10;
  }
  v7 = *(unsigned int *)__s1;
  v15 = &off_24C7F32C0;
  MEMORY[0x212BAC9C0]();
  return v7;
}

void sub_20D9B9D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  uint64_t v21;

  MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
  if (a21)
    MEMORY[0x212BAC9C0](a21, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFixedPointScales::readIntVec(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *__endptr;
  uint64_t v26;
  uint64_t v27;
  uint64_t (**v28)(NString *__hidden, const unsigned int *);
  uint64_t v29;
  _WORD *v30;
  uint64_t v31;

  if (!*a3)
  {
    v11 = *(_QWORD *)(a2 + 8);
    if (v11)
    {
      LOBYTE(v24) = 0;
      (*(void (**)(char **__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v11 + 80))(&__endptr, v11, &v24);
      v13 = (char *)operator new[]();
      strcpy(v13, "\r\n\t ");
      v14 = v26;
      v15 = v27;
      if ((_DWORD)v26)
      {
        v16 = 0;
        while (strchr(v13, *(char *)(v15 + v16)))
        {
          if (v14 == ++v16)
          {
            v17 = v14;
            v18 = v14;
            v16 = v14;
            goto LABEL_14;
          }
        }
        v17 = v16;
        v18 = v14;
      }
      else
      {
        v17 = 0;
        v18 = 0;
        v16 = 0;
      }
LABEL_14:
      if (v16 >= v14)
        v19 = v14;
      else
        v19 = v16;
      do
      {
        if (v18 <= v17)
          goto LABEL_20;
        v20 = v18--;
      }
      while (strchr(v13, *(char *)(v15 + v20 - 1)));
      v19 = v20;
LABEL_20:
      if (v16 > v14)
      {
        v23 = "Index %d outside of range [0,%d]";
      }
      else if (v19 > v14)
      {
        v23 = "Index %d outside of range [0,%d]";
        v16 = v19;
      }
      else
      {
        if (v19 >= v16)
        {
          if (v15)
          {
            v21 = (void *)operator new[]();
            memcpy(v21, (const void *)(v15 + v16), (v19 - v16));
            *((_BYTE *)v21 + (v19 - v16)) = 0;
            v28 = &off_24C7F32C0;
            LODWORD(v29) = 1;
            v30 = (_WORD *)operator new[]();
            *v30 = 61;
            NString::operator+(a4, (uint64_t)&v28, (uint64_t)&v31);
          }
          Error::chuck((Error *)"Null pointer passed to string constructor", v12);
        }
        v23 = "Start and end indices conflict, start [%d], end [%d]";
        v14 = v19;
      }
      Error::chuck((Error *)v23, v12, v16, v14);
    }
LABEL_29:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  v9 = *(_QWORD *)(a2 + 8);
  if (!v9)
    goto LABEL_29;
  LODWORD(v28) = 4 * *a5;
  (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v9 + 64))(&__endptr, v9, &v28);
  if ((v26 & 3) != 0)
  {
    __endptr = (char *)&off_24C7F32C0;
    if (v27)
      MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
    v22 = *(_QWORD *)(a2 + 8);
    if (v22)
      Error::chuck((Error *)"NGaussianFixedPointScales::read() - failed to read %s from file %s", (const char *)a2, *(_QWORD *)(a4 + 16), *(_QWORD *)(v22 + 24));
    goto LABEL_29;
  }
  LODWORD(v31) = v26 >> 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a6 + 24))(a6, v27, &v31);
  __endptr = (char *)&off_24C7F32C0;
  result = v27;
  if (v27)
    return MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
  return result;
}

void sub_20D9BA674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  uint64_t v14;
  uint64_t v16;
  va_list va;

  va_start(va, a14);
  NArray<NString>::~NArray((uint64_t *)va);
  v16 = *(_QWORD *)(v14 - 96);
  if (v16)
    MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NFixedPointScales::read(NFixedPointScales *this, NFilePtr *a2, unsigned int *a3, BOOL *a4)
{
  char *v8;
  char *v9;
  float v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  int v12;
  char *v13;

  v11 = &off_24C7F32C0;
  v12 = 8;
  v8 = (char *)operator new[]();
  v13 = v8;
  strcpy(v8, "LOGPROBQ");
  *((_DWORD *)this + 2) = NFixedPointScales::readInt((NFixedPointScales *)v8, a2, a4, (const NString *)&v11);
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  v11 = &off_24C7F32C0;
  v12 = 6;
  v9 = (char *)operator new[]();
  v13 = v9;
  strcpy(v9, "PARAMQ");
  NFixedPointScales::readIntVec((uint64_t)v9, (uint64_t)a2, a4, (uint64_t)&v11, a3, (uint64_t)this + 16);
  MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  v10 = ldexp(1.0, *((_DWORD *)this + 2));
  *((float *)this + 10) = v10;
  *((float *)this + 11) = 1.0 / v10;
  NFixedPointScales::makeParamScales(this);
  *((_BYTE *)this + 120) = 1;
}

void sub_20D9BA958(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_BYTE *NFixedPointScales::write(NFixedPointScales *this, NFilePtr *a2, const BOOL *a3)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  _BYTE *result;
  const char *v9;
  uint64_t (**v10)(NString *, const unsigned int *);
  unsigned int v11;
  void *v12;
  uint64_t (**v13)(NString *__hidden, const unsigned int *);
  int v14;
  char *v15;
  unsigned int v16[2];
  char __str[8];
  int v18;
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)a2 + 1);
  if (!*a3)
  {
    if (v5)
    {
      v13 = &off_24C7F32C0;
      v14 = 9;
      v15 = (char *)operator new[]();
      strcpy(v15, "LOGPROBQ=");
      v10 = &off_24C7F32C0;
      if ((snprintf(__str, 0x80uLL, "%d", *((_DWORD *)this + 2)) - 129) > 0xFFFFFF7F)
      {
        v11 = strlen(__str);
        v12 = (void *)(*v10)((NString *)&v10, &v11);
        memcpy(v12, __str, v11 + 1);
        NString::operator+((uint64_t)&v13, (uint64_t)&v10, (uint64_t)v16);
      }
      Error::chuck((Error *)"NString::NString: cannot convert int to string", v9);
    }
LABEL_14:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  if (!v5)
    goto LABEL_14;
  *(_QWORD *)__str = &off_24C7F32C0;
  v18 = 0;
  v19 = (_BYTE *)operator new[]();
  *v19 = 0;
  v16[0] = 4;
  NString::appendTo((NString *)__str, (char *)this + 8, v16);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v5 + 96))(v5, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v19)
    MEMORY[0x212BAC9C0](v19, 0x1000C8077774924);
  v7 = *((_QWORD *)a2 + 1);
  if (!v7)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
  *(_QWORD *)__str = &off_24C7F32C0;
  v18 = 0;
  v19 = (_BYTE *)operator new[]();
  *v19 = 0;
  v16[0] = 4 * *((_DWORD *)this + 8);
  if (v16[0])
    NString::appendTo((NString *)__str, *((const void **)this + 3), v16);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v7 + 96))(v7, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  result = v19;
  if (v19)
    return (_BYTE *)MEMORY[0x212BAC9C0](v19, 0x1000C8077774924);
  return result;
}

void sub_20D9BADD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22)
  {
    MEMORY[0x212BAC9C0](a22, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t operator<<<int>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  char *v9;
  uint64_t (**v10)(NString *__hidden, const unsigned int *);
  int v11;
  _WORD *v12;

  v10 = &off_24C7F32C0;
  v11 = 1;
  v12 = (_WORD *)operator new[]();
  *v12 = 91;
  if (*(_DWORD *)(a2 + 16))
  {
    v7 = &off_24C7F32C0;
    v8 = 1;
    v9 = (char *)operator new[]();
    strcpy(v9, " ");
    v10[6]((NString *)&v10, (const unsigned int *)&v7);
    operator<<((uint64_t)&v10, *(_DWORD **)(a2 + 8));
    v7 = &off_24C7F32C0;
    if (v9)
      MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
    if (*(_DWORD *)(a2 + 16) >= 2u)
    {
      v4 = 1;
      v5 = 4;
      do
      {
        v7 = &off_24C7F32C0;
        v8 = 2;
        v9 = (char *)operator new[]();
        memcpy(v9, ", ", (v8 + 1));
        v10[6]((NString *)&v10, (const unsigned int *)&v7);
        operator<<((uint64_t)&v10, (_DWORD *)(*(_QWORD *)(a2 + 8) + v5));
        v7 = &off_24C7F32C0;
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
        ++v4;
        v5 += 4;
      }
      while (v4 < *(unsigned int *)(a2 + 16));
    }
  }
  v7 = &off_24C7F32C0;
  v8 = 2;
  v9 = (char *)operator new[]();
  strcpy(v9, " ]");
  v10[6]((NString *)&v10, (const unsigned int *)&v7);
  v7 = &off_24C7F32C0;
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a1 + 48))(a1, &v10);
  v10 = &off_24C7F32C0;
  if (v12)
    MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  return a1;
}

void sub_20D9BB108(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NGaussianFixedPointScales::NGaussianFixedPointScales(NGaussianFixedPointScales *this)
{
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = &off_24C7F3090;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_BYTE *)this + 120) = 0;
  *(_QWORD *)this = &off_24C7F2A18;
  *(_QWORD *)((char *)this + 124) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_QWORD *)this + 17) = &off_24C7F30C8;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = &off_24C7F30C8;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
}

{
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = &off_24C7F30C8;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3090;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = &off_24C7F3090;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = &off_24C7F3090;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_BYTE *)this + 120) = 0;
  *(_QWORD *)this = &off_24C7F2A18;
  *(_QWORD *)((char *)this + 124) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_QWORD *)this + 17) = &off_24C7F30C8;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = &off_24C7F30C8;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
}

void NGaussianFixedPointScales::initialize(uint64_t a1, const char *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  unsigned int v21;

  v6 = *(unsigned int *)(a5 + 16);
  v7 = *(unsigned int *)(a6 + 16);
  if ((_DWORD)v6 != (_DWORD)v7)
    Error::chuck((Error *)"NGaussianFixedPointScales::initialize() - inconsistent dimensionality (paramQ=%d, dimenShift=%d)", a2, *(unsigned int *)(a5 + 16), v7);
  if (*a4 > *(_DWORD *)a2)
    Error::chuck((Error *)"NGaussianFixedPointScales::initialize() - logprobQ > gaussianQ", a2);
  if ((_DWORD)v6)
  {
    for (i = 0; i != v6; ++i)
    {
      v13 = *(unsigned int *)(*(_QWORD *)(a6 + 8) + 4 * i);
      if ((v13 & 0x80000000) != 0)
        Error::chuck((Error *)"NGaussianFixedPointScales::initialize() - dimenShift[%d] -ve (%d)", a2, i, v13);
    }
  }
  NFixedPointScales::initialize(a1, a4, a5);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 124) = *a3;
  if (a1 + 168 != a6)
  {
    v14 = *(_DWORD *)(a1 + 184);
    v15 = *(_DWORD *)(a6 + 16);
    if (v14 != v15)
    {
      v16 = *(_QWORD *)(a1 + 176);
      if (v16)
      {
        MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
        v15 = *(_DWORD *)(a6 + 16);
      }
      *(_DWORD *)(a1 + 184) = v15;
      *(_QWORD *)(a1 + 176) = operator new[]();
      v14 = *(_DWORD *)(a1 + 184);
    }
    if (v14)
    {
      v17 = 0;
      v18 = *(_QWORD *)(a6 + 8);
      v19 = *(_QWORD *)(a1 + 176);
      do
      {
        *(_DWORD *)(v19 + 4 * v17) = *(_DWORD *)(v18 + 4 * v17);
        ++v17;
      }
      while (v17 < *(unsigned int *)(a1 + 184));
    }
  }
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 128) - *(_DWORD *)(a1 + 8);
  v21 = 0x2000;
  NGaussianFixedPointScales::makeLogAddTable((NGaussianFixedPointScales *)a1, (const char *)&v21);
  v20 = ldexp(1.0, *(_DWORD *)(a1 + 8));
  *(float *)(a1 + 40) = v20;
  *(float *)(a1 + 44) = 1.0 / v20;
  NFixedPointScales::makeParamScales((NFixedPointScales *)a1);
  *(_BYTE *)(a1 + 120) = 1;
}

void NGaussianFixedPointScales::makeLogAddTable(NGaussianFixedPointScales *this, const char *a2)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  double v6;
  long double v7;
  float v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  _OWORD *v18;
  __int128 *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  int *v25;
  int v26;
  int v27;
  double v28;
  double v29;
  float v30;
  float v31;
  float v32;
  uint64_t v33;
  uint64_t i;
  int32x2_t v35;
  int32x2_t *v42;
  uint64_t v43;
  float32x2_t v44;
  float32x2_t v45;
  float64x2_t v46;
  float v47;
  long double v48;
  float64x2_t v49;
  float64x2_t v50;
  float __x;
  float64x2_t __xa;
  float v53;
  long double v54;
  double v55;
  float v56;
  int v57;

  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NGaussianFixedPointScales::makeLogAddTable() - table size must be >0", a2);
  v3 = 0;
  v4 = *(_DWORD *)a2 - 1;
  if (*(_DWORD *)a2 != 1)
  {
    do
    {
      ++v3;
      v16 = v4 > 1;
      v4 >>= 1;
    }
    while (v16);
  }
  v5 = *((_DWORD *)this + 2);
  v6 = ldexp(1.0, v5);
  v7 = exp(0.5 / v6);
  v8 = -(v6 * log(v7 + -1.0));
  frexpf(v8, &v57);
  v9 = v57;
  if (v57 >= (*((_DWORD *)this + 31) + v5))
    v9 = *((_DWORD *)this + 31) + v5;
  if (v3 >= v9)
    v10 = v9;
  else
    v10 = v3;
  v11 = (1 << v10);
  *((_DWORD *)this + 40) = v9 - v10;
  *((_DWORD *)this + 41) = ~(-1 << v9);
  v12 = *((_DWORD *)this + 38);
  if (v12 != (_DWORD)v11)
  {
    v13 = *((_QWORD *)this + 18);
    *((_DWORD *)this + 38) = v11;
    v14 = operator new[]();
    *((_QWORD *)this + 18) = v14;
    if (v12 >= v11)
      v15 = v11;
    else
      v15 = v12;
    if ((_DWORD)v15)
    {
      v16 = v15 >= 8 && (unint64_t)(v14 - v13) > 0x1F;
      if (v16)
      {
        v17 = v15 & 0xFFFFFFF8;
        v18 = (_OWORD *)(v14 + 16);
        v19 = (__int128 *)(v13 + 16);
        v20 = v17;
        do
        {
          v21 = *v19;
          *(v18 - 1) = *(v19 - 1);
          *v18 = v21;
          v18 += 2;
          v19 += 2;
          v20 -= 8;
        }
        while (v20);
        if (v17 == v15)
          goto LABEL_26;
      }
      else
      {
        v17 = 0;
      }
      v22 = v15 - v17;
      v23 = 4 * v17;
      v24 = (_DWORD *)(v14 + 4 * v17);
      v25 = (int *)(v13 + v23);
      do
      {
        v26 = *v25++;
        *v24++ = v26;
        --v22;
      }
      while (v22);
LABEL_26:
      MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
      goto LABEL_27;
    }
    if (v13)
      goto LABEL_26;
  }
LABEL_27:
  v27 = *((_DWORD *)this + 2);
  v28 = ldexp(1.0, *((_DWORD *)this + 40) - v27);
  v29 = ldexp(1.0, v27);
  if (!(_DWORD)v11)
    goto LABEL_34;
  v30 = v28;
  v31 = -v30;
  v32 = v29;
  v55 = v32;
  v56 = v31;
  v33 = *((_QWORD *)this + 18);
  if ((_DWORD)v11 == 1)
  {
    for (i = 0; i != v11; ++i)
    {
LABEL_33:
      v47 = expf(v31 * (float)i);
      v48 = log(v47 + 1.0);
      v31 = v56;
      *(float *)&v48 = v48 * v55;
      *(_DWORD *)(v33 + 4 * i) = (int)(*(float *)&v48 + 0.5);
    }
    goto LABEL_34;
  }
  i = v11 & 0xFFFFFFFE;
  v35 = (int32x2_t)0x100000000;
  __asm
  {
    FMOV            V2.2D, #1.0
    FMOV            V0.2D, #0.5
  }
  v49 = _Q0;
  v50 = _Q2;
  v42 = (int32x2_t *)*((_QWORD *)this + 18);
  v43 = i;
  do
  {
    v44 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)v35), v31);
    __x = v44.f32[0];
    v53 = expf(v44.f32[1]);
    v45.f32[0] = expf(__x);
    v45.f32[1] = v53;
    __xa = vaddq_f64(vcvtq_f64_f32(v45), v50);
    v54 = log(__xa.f64[1]);
    v46.f64[0] = log(__xa.f64[0]);
    v46.f64[1] = v54;
    v31 = v56;
    *v42++ = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_f32(vcvt_f32_f64(vmulq_n_f64(v46, v55))), v49)));
    v35 = vadd_s32(v35, (int32x2_t)0x200000002);
    v43 -= 2;
  }
  while (v43);
  if (i != v11)
    goto LABEL_33;
LABEL_34:
  *((_BYTE *)this + 192) = 1;
}

void NGaussianFixedPointScales::setUp(NGaussianFixedPointScales *this)
{
  float v2;
  unsigned int v3;

  *((_DWORD *)this + 33) = *((_DWORD *)this + 32) - *((_DWORD *)this + 2);
  v3 = 0x2000;
  NGaussianFixedPointScales::makeLogAddTable(this, (const char *)&v3);
  v2 = ldexp(1.0, *((_DWORD *)this + 2));
  *((float *)this + 10) = v2;
  *((float *)this + 11) = 1.0 / v2;
  NFixedPointScales::makeParamScales(this);
  *((_BYTE *)this + 120) = 1;
}

void NGaussianFixedPointScales::read(NGaussianFixedPointScales *this, NFilePtr *a2, unsigned int *a3, BOOL *a4)
{
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  float v13;
  unsigned int v14[2];
  int v15;
  char *v16;

  *(_QWORD *)v14 = &off_24C7F32C0;
  v15 = 9;
  v8 = (char *)operator new[]();
  v16 = v8;
  strcpy(v8, "GAUSSIANQ");
  *((_DWORD *)this + 32) = NFixedPointScales::readInt((NFixedPointScales *)v8, a2, a4, (const NString *)v14);
  MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  *(_QWORD *)v14 = &off_24C7F32C0;
  v15 = 8;
  v9 = (char *)operator new[]();
  v16 = v9;
  strcpy(v9, "LOGPROBI");
  *((_DWORD *)this + 31) = NFixedPointScales::readInt((NFixedPointScales *)v9, a2, a4, (const NString *)v14);
  MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  *(_QWORD *)v14 = &off_24C7F32C0;
  v15 = 8;
  v10 = (char *)operator new[]();
  v16 = v10;
  strcpy(v10, "LOGPROBQ");
  *((_DWORD *)this + 2) = NFixedPointScales::readInt((NFixedPointScales *)v10, a2, a4, (const NString *)v14);
  MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  *(_QWORD *)v14 = &off_24C7F32C0;
  v15 = 6;
  v11 = (char *)operator new[]();
  v16 = v11;
  strcpy(v11, "PARAMQ");
  NFixedPointScales::readIntVec((uint64_t)v11, (uint64_t)a2, a4, (uint64_t)v14, a3, (uint64_t)this + 16);
  MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  *(_QWORD *)v14 = &off_24C7F32C0;
  v15 = 10;
  v12 = (char *)operator new[]();
  v16 = v12;
  strcpy(v12, "DIMENSHIFT");
  NFixedPointScales::readIntVec((uint64_t)v12, (uint64_t)a2, a4, (uint64_t)v14, a3, (uint64_t)this + 168);
  MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  *((_DWORD *)this + 33) = *((_DWORD *)this + 32) - *((_DWORD *)this + 2);
  v14[0] = 0x2000;
  NGaussianFixedPointScales::makeLogAddTable(this, (const char *)v14);
  v13 = ldexp(1.0, *((_DWORD *)this + 2));
  *((float *)this + 10) = v13;
  *((float *)this + 11) = 1.0 / v13;
  NFixedPointScales::makeParamScales(this);
  *((_BYTE *)this + 120) = 1;
}

void sub_20D9BBA24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_BYTE *NGaussianFixedPointScales::write(NGaussianFixedPointScales *this, NFilePtr *a2, const BOOL *a3)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  _BYTE *result;
  uint64_t (**v16)(NString *, const unsigned int *);
  unsigned int v17;
  void *v18;
  uint64_t (**v19)(NString *__hidden, const unsigned int *);
  int v20;
  char *v21;
  unsigned int v22[2];
  char __str[8];
  int v24;
  _BYTE *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)a2 + 1);
  if (!*a3)
  {
    if (v5)
    {
      v19 = &off_24C7F32C0;
      v20 = 10;
      v21 = (char *)operator new[]();
      strcpy(v21, "GAUSSIANQ=");
      v16 = &off_24C7F32C0;
      if ((snprintf(__str, 0x80uLL, "%d", *((_DWORD *)this + 32)) - 129) > 0xFFFFFF7F)
      {
        v17 = strlen(__str);
        v18 = (void *)(*v16)((NString *)&v16, &v17);
        memcpy(v18, __str, v17 + 1);
        NString::operator+((uint64_t)&v19, (uint64_t)&v16, (uint64_t)v22);
      }
      Error::chuck((Error *)"NString::NString: cannot convert int to string", v14);
    }
LABEL_26:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  if (!v5)
    goto LABEL_26;
  *(_QWORD *)__str = &off_24C7F32C0;
  v24 = 0;
  v25 = (_BYTE *)operator new[]();
  *v25 = 0;
  v22[0] = 4;
  NString::appendTo((NString *)__str, (char *)this + 128, v22);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v5 + 96))(v5, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  v7 = *((_QWORD *)a2 + 1);
  if (!v7)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
  *(_QWORD *)__str = &off_24C7F32C0;
  v24 = 0;
  v25 = (_BYTE *)operator new[]();
  *v25 = 0;
  v22[0] = 4;
  (*(void (**)(NString *, const void *, const unsigned int *))(*(_QWORD *)__str + 72))((NString *)__str, (char *)this + 124, v22);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v7 + 96))(v7, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  v9 = *((_QWORD *)a2 + 1);
  if (!v9)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
  *(_QWORD *)__str = &off_24C7F32C0;
  v24 = 0;
  v25 = (_BYTE *)operator new[]();
  *v25 = 0;
  v22[0] = 4;
  NString::appendTo((NString *)__str, (char *)this + 8, v22);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v9 + 96))(v9, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  v11 = *((_QWORD *)a2 + 1);
  if (!v11)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v10);
  *(_QWORD *)__str = &off_24C7F32C0;
  v24 = 0;
  v25 = (_BYTE *)operator new[]();
  *v25 = 0;
  v22[0] = 4 * *((_DWORD *)this + 8);
  if (v22[0])
    NString::appendTo((NString *)__str, *((const void **)this + 3), v22);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v11 + 96))(v11, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  v13 = *((_QWORD *)a2 + 1);
  if (!v13)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
  *(_QWORD *)__str = &off_24C7F32C0;
  v24 = 0;
  v25 = (_BYTE *)operator new[]();
  *v25 = 0;
  v22[0] = 4 * *((_DWORD *)this + 46);
  if (v22[0])
    NString::appendTo((NString *)__str, *((const void **)this + 22), v22);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v13 + 96))(v13, __str);
  *(_QWORD *)__str = &off_24C7F32C0;
  result = v25;
  if (v25)
    return (_BYTE *)MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  return result;
}

void sub_20D9BC410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22)
  {
    MEMORY[0x212BAC9C0](a22, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianFixedPointScales::logadd(NGaussianFixedPointScales *this, signed int a2, signed int a3)
{
  uint64_t result;
  int v5;
  int v6;

  if (a3 <= a2)
    result = a2;
  else
    result = a3;
  if (a3 >= a2)
    v5 = a2;
  else
    v5 = a3;
  if (v5 != -1073741823)
  {
    v6 = result - v5;
    if (v6 <= *((_DWORD *)this + 41))
      return (*(_DWORD *)(*((_QWORD *)this + 18) + 4 * (v6 >> *((_DWORD *)this + 40)))
                          + result);
  }
  return result;
}

uint64_t NGaussianFixedPointScales::setDimenShift(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result + 168 != a2)
  {
    v3 = result;
    v4 = *(_DWORD *)(result + 184);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(result + 176);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v3 + 184) = v5;
      result = operator new[]();
      *(_QWORD *)(v3 + 176) = result;
      v4 = *(_DWORD *)(v3 + 184);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(v3 + 176);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(v3 + 184));
    }
  }
  return result;
}

void NFrameWindow::NFrameWindow(NFrameWindow *this)
{
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = &off_24C7F31A8;
  *((_WORD *)this + 36) = 1;
}

{
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = &off_24C7F31A8;
  *((_WORD *)this + 36) = 1;
}

uint64_t NFrameWindow::configure(uint64_t this, const char *a2, unsigned int *a3, const unsigned int *a4, unsigned int *a5, unsigned int *a6, const unsigned int *a7, const unsigned int *a8)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int *v34;
  int v35;

  v8 = *a5;
  v9 = *a4;
  v10 = *a3;
  if (*a5 - 1 < v9 || v9 > v8 || v8 > v10)
    Error::chuck((Error *)"NFrameWindow::configure() - Invalid frame subset %d-%d from 0-%d", a2, v9, *a5, v10);
  v13 = this;
  *(_DWORD *)(this + 12) = v9;
  v14 = *a5;
  *(_DWORD *)(this + 16) = *a5;
  if (!v14)
  {
    v14 = *a3;
    *(_DWORD *)(this + 16) = *a3;
  }
  v15 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
    Error::chuck((Error *)"NFrameWindow::configure() - must be at least one frame in window", a2);
  v16 = v15 - 1 + (v15 - 1) * *a7 + *a8;
  v17 = v15 + (v15 - 1) * *a7 + *a8;
  v18 = *a6;
  if (*a6 == -1)
  {
    v19 = 0;
    *(_DWORD *)this = v16;
  }
  else if (v18 == -2)
  {
    if ((v17 & 1) == 0)
      Error::chuck((Error *)"NFrameWindow::configure() - only an odd number of frames supported for centered window (%d)", a2, v17);
    v19 = v17 >> 1;
    *(_DWORD *)this = v17 >> 1;
  }
  else
  {
    if (v18 >= v17)
      Error::chuck((Error *)"NFrameWindow::configure() - frame window offset %d located outside window (%d)", a2, *a6, v17);
    *(_DWORD *)this = v18;
    v19 = v16 - v18;
  }
  *(_DWORD *)(this + 4) = v19;
  if (*a8 >= v17)
    Error::chuck((Error *)"NFrameWindow::configure() - start frame %d located outside window (%d)", a2, *a8, v17);
  *(_DWORD *)(this + 28) = *a8;
  *(_DWORD *)(this + 32) = *a7;
  v20 = v14 - v9;
  *(_DWORD *)(this + 8) = *a3;
  v21 = *(_DWORD *)a2 * v20;
  v22 = v20 * v17;
  *(_DWORD *)(this + 20) = v21;
  *(_DWORD *)(this + 24) = v22;
  v23 = *(_DWORD *)(this + 64);
  if (v23 != v22)
  {
    v24 = *(_QWORD *)(this + 56);
    *(_DWORD *)(this + 64) = v22;
    this = operator new[]();
    *(_QWORD *)(v13 + 56) = this;
    LODWORD(v25) = *(_DWORD *)(v13 + 24);
    if (v23 >= v25)
      v25 = v25;
    else
      v25 = v23;
    if ((_DWORD)v25)
    {
      v26 = 0;
      if (v25 < 8)
        goto LABEL_29;
      if ((unint64_t)(this - v24) <= 0x1F)
        goto LABEL_29;
      v26 = v25 & 0xFFFFFFF8;
      v27 = (_OWORD *)(this + 16);
      v28 = (__int128 *)(v24 + 16);
      v29 = v26;
      do
      {
        v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v26 != v25)
      {
LABEL_29:
        v31 = v25 - v26;
        v32 = 4 * v26;
        v33 = (_DWORD *)(this + 4 * v26);
        v34 = (int *)(v24 + v32);
        do
        {
          v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
      goto LABEL_33;
    }
    if (v24)
LABEL_33:
      this = MEMORY[0x212BAC9C0](v24, 0x1000C8052888210);
  }
  *(_WORD *)(v13 + 72) = 1;
  *(_DWORD *)(v13 + 36) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  return this;
}

uint64_t NFrameWindow::reset(uint64_t this)
{
  *(_WORD *)(this + 72) = 1;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t NFrameWindow::endFrames(uint64_t this)
{
  *(_BYTE *)(this + 73) = 1;
  return this;
}

int32x2_t NFrameWindow::pushFrame(NFrameWindow *this, const NFrame *a2)
{
  int v2;
  uint64_t v3;

  v2 = *((_DWORD *)a2 + 4);
  if (!v2)
    Error::chuck((Error *)"NFrameWindow::pushFrame() - cannot feed zero-sized frames", (const char *)a2);
  v3 = *((unsigned int *)this + 2);
  if (v2 != (_DWORD)v3)
    Error::chuck((Error *)"NFrameWindow::pushFrame() - mismatched input frame size (%d != %d)", (const char *)a2, *((unsigned int *)a2 + 4), v3);
  return NFrameWindow::pushFrame(this, *((const float **)a2 + 1));
}

int32x2_t NFrameWindow::pushFrame(NFrameWindow *this, const float *a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int32x2_t result;

  if (*((_BYTE *)this + 73))
    Error::chuck((Error *)"NFrameWindow::pushFrame() - endFrames() already called", (const char *)a2);
  if (*((_DWORD *)this + 10) > *((_DWORD *)this + 1))
    Error::chuck((Error *)"NFrameWindow::pushFrame() - buffer full", (const char *)a2);
  if (*((_BYTE *)this + 72))
  {
    if (*(_DWORD *)this)
    {
      v4 = 0;
      v5 = *((_DWORD *)this + 9);
      do
      {
        if (v5 >= *((_DWORD *)this + 6))
        {
          v5 = 0;
          *((_DWORD *)this + 9) = 0;
        }
        v6 = *((unsigned int *)this + 3);
        v7 = *((_DWORD *)this + 4) - v6;
        memcpy((void *)(*((_QWORD *)this + 7) + 4 * v5), &a2[v6], 4 * v7);
        v5 = *((_DWORD *)this + 9) + v7;
        *((_DWORD *)this + 9) = v5;
        ++v4;
      }
      while (v4 < *(_DWORD *)this);
    }
    *((_BYTE *)this + 72) = 0;
  }
  v8 = *((_DWORD *)this + 9);
  if (v8 >= *((_DWORD *)this + 6))
  {
    v8 = 0;
    *((_DWORD *)this + 9) = 0;
  }
  v9 = *((unsigned int *)this + 3);
  v10 = *((_DWORD *)this + 4) - v9;
  memcpy((void *)(*((_QWORD *)this + 7) + 4 * v8), &a2[v9], 4 * v10);
  result = vadd_s32(*(int32x2_t *)((char *)this + 36), (int32x2_t)(v10 | 0x100000000));
  *(int32x2_t *)((char *)this + 36) = result;
  return result;
}

void *NFrameWindow::copyInFrame(NFrameWindow *this, const float *a2)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  void *result;

  v3 = *((_DWORD *)this + 9);
  if (v3 >= *((_DWORD *)this + 6))
  {
    v3 = 0;
    *((_DWORD *)this + 9) = 0;
  }
  v4 = *((unsigned int *)this + 3);
  v5 = *((_DWORD *)this + 4) - v4;
  result = memcpy((void *)(*((_QWORD *)this + 7) + 4 * v3), &a2[v4], 4 * v5);
  *((_DWORD *)this + 9) += v5;
  return result;
}

BOOL NFrameWindow::frameReady(NFrameWindow *this)
{
  int v1;

  v1 = *((_DWORD *)this + 10);
  return *((_BYTE *)this + 73) && v1 || v1 == *((_DWORD *)this + 1) + 1;
}

uint64_t NFrameWindow::setOutputFrameWindow(NFrameWindow *this, float **a2)
{
  const char *v3;

  v3 = (char *)this + 20;
  if (!*((_DWORD *)this + 5))
    Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v3);
  (*((void (**)(float **, const char *))*a2 + 4))(a2, v3);
  return NFrameWindow::setOutputFrameWindow((uint64_t)this, a2[1]);
}

uint64_t NFrameWindow::setOutputFrameWindow(uint64_t this, float *__dst)
{
  uint64_t v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  BOOL v15;
  int v16;
  unsigned int v17;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  __int128 *v29;
  __int128 v30;
  __int128 v31;
  _OWORD *v32;

  v3 = this;
  v4 = *(_DWORD *)(this + 40);
  if (*(_BYTE *)(this + 73))
  {
    if (!v4)
      Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - buffer empty after endFrames()", (const char *)__dst);
    if (v4 != *(_DWORD *)(this + 4) + 1)
    {
      v5 = *(_DWORD *)(this + 36);
      v6 = *(_DWORD *)(this + 24);
      if (v5 >= v6)
      {
        v5 = 0;
        *(_DWORD *)(this + 36) = 0;
      }
      v8 = *(_DWORD *)(this + 12);
      v7 = *(_DWORD *)(this + 16);
      v9 = v7 - v8;
      if (v7 != v8)
      {
        if (v5 >= v9)
          v10 = 0;
        else
          v10 = v6;
        v11 = v5 - v9 + v10;
        v12 = *(_QWORD *)(this + 56);
        if (v9 < 0x14)
          goto LABEL_20;
        v13 = 0;
        v14 = v7 + ~v8;
        this = __CFADD__(v5, v14);
        v15 = __CFADD__(v11, v14);
        if ((this & 1) != 0 || v15)
          goto LABEL_21;
        if (4 * v5 - 4 * (unint64_t)v11 >= 0x20)
        {
          v13 = v9 & 0xFFFFFFF8;
          v17 = v5 + (v9 & 0xFFFFFFF8);
          v28 = v10 + v8 - v7;
          this = v9 & 0xFFFFFFF8;
          do
          {
            v29 = (__int128 *)(v12 + 4 * (v28 + v5));
            v30 = *v29;
            v31 = v29[1];
            v32 = (_OWORD *)(v12 + 4 * v5);
            *v32 = v30;
            v32[1] = v31;
            v5 += 8;
            this -= 8;
          }
          while (this);
          if (v9 == v13)
            goto LABEL_24;
          v11 += v13;
          v5 = v17;
        }
        else
        {
LABEL_20:
          v13 = 0;
        }
LABEL_21:
        v16 = v13 + v8 - v7;
        v17 = v5;
        do
          *(_DWORD *)(v12 + 4 * v17++) = *(_DWORD *)(v12 + 4 * v11++);
        while (!__CFADD__(v16++, 1));
LABEL_24:
        *(_DWORD *)(v3 + 36) = v17;
      }
    }
  }
  else if (v4 != *(_DWORD *)(this + 4) + 1)
  {
    Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - buffer empty", (const char *)__dst);
  }
  *(_DWORD *)(v3 + 40) = v4 - 1;
  if (*(_DWORD *)(v3 + 28) || *(_DWORD *)(v3 + 32))
  {
    if (*(_DWORD *)(v3 + 20))
    {
      v19 = 0;
      v20 = *(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 12);
      v21 = *(_DWORD *)(v3 + 36);
      v22 = v20 + v20 * *(_DWORD *)(v3 + 32);
      do
      {
        v23 = *(_DWORD *)(v3 + 24);
        if (v21 < v23)
          v23 = 0;
        v24 = v21 - v23;
        this = (uint64_t)memcpy(&__dst[v19], (const void *)(*(_QWORD *)(v3 + 56) + 4 * (v21 - v23)), 4 * v20);
        v19 += v20;
        v21 = v22 + v24;
      }
      while (v19 < *(_DWORD *)(v3 + 20));
    }
  }
  else
  {
    v25 = *(_DWORD *)(v3 + 20);
    v26 = *(unsigned int *)(v3 + 36);
    v27 = v25 - v26;
    if (v25 != (_DWORD)v26)
    {
      memcpy(__dst, (const void *)(*(_QWORD *)(v3 + 56) + 4 * v26), 4 * (v25 - v26));
      v25 = *(_DWORD *)(v3 + 36);
    }
    return (uint64_t)memcpy(&__dst[v27], *(const void **)(v3 + 56), 4 * v25);
  }
  return this;
}

uint64_t NFrameWindow::endPadOneFrame(uint64_t this)
{
  unsigned int v1;
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  BOOL v12;
  int v13;
  unsigned int v14;
  int v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  __int128 v20;
  _OWORD *v21;

  v1 = *(_DWORD *)(this + 36);
  v2 = *(_DWORD *)(this + 24);
  if (v1 >= v2)
  {
    v1 = 0;
    *(_DWORD *)(this + 36) = 0;
  }
  v4 = *(_DWORD *)(this + 12);
  v3 = *(_DWORD *)(this + 16);
  v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v1 >= v5)
      v6 = 0;
    else
      v6 = v2;
    v7 = v1 - v5 + v6;
    v8 = *(_QWORD *)(this + 56);
    if (v5 < 0x14)
      goto LABEL_17;
    v9 = 0;
    v10 = v3 + ~v4;
    v11 = __CFADD__(v1, v10);
    v12 = __CFADD__(v7, v10);
    if (v11 || v12)
      goto LABEL_18;
    if (4 * v1 - 4 * (unint64_t)v7 >= 0x20)
    {
      v9 = v5 & 0xFFFFFFF8;
      v14 = v1 + (v5 & 0xFFFFFFF8);
      v16 = v6 + v4 - v3;
      v17 = v5 & 0xFFFFFFF8;
      do
      {
        v18 = (__int128 *)(v8 + 4 * (v16 + v1));
        v19 = *v18;
        v20 = v18[1];
        v21 = (_OWORD *)(v8 + 4 * v1);
        *v21 = v19;
        v21[1] = v20;
        v1 += 8;
        v17 -= 8;
      }
      while (v17);
      if (v5 == v9)
        goto LABEL_21;
      v7 += v9;
      v1 = v14;
    }
    else
    {
LABEL_17:
      v9 = 0;
    }
LABEL_18:
    v13 = v9 + v4 - v3;
    v14 = v1;
    do
      *(_DWORD *)(v8 + 4 * v14++) = *(_DWORD *)(v8 + 4 * v7++);
    while (!__CFADD__(v13++, 1));
LABEL_21:
    *(_DWORD *)(this + 36) = v14;
  }
  return this;
}

void NDEHMMDetector::~NDEHMMDetector(NDEHMMDetector *this)
{
  NDEHMMDetector::~NDEHMMDetector(this);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C7F18B0;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    if (!*((_QWORD *)this + 2)
      || ((*(void (**)(uint64_t))(*(_QWORD *)v2 + 152))(v2), (v2 = *((_QWORD *)this + 1)) != 0))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  *((_QWORD *)this + 21) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 22);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 18) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 19);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 12) = &off_24C7F3090;
  v5 = *((_QWORD *)this + 13);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  NArray<NDELRHMMModel>::~NArray((_QWORD *)this + 3);
}

_QWORD *NArray<NDELRHMMModel>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *a1 = &off_24C7F2D10;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 136 * v4;
      v6 = v2 - 56;
      do
      {
        v7 = (_QWORD *)(v6 + v5);
        *(_QWORD *)(v6 + v5 + 24) = &off_24C7F3100;
        v8 = *(_QWORD *)(v6 + v5 + 32);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *v7 = &off_24C7F3090;
        v9 = v7[1];
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v10 = v6 + v5;
        *(_QWORD *)(v6 + v5 - 32) = &off_24C7F3100;
        v11 = *(_QWORD *)(v6 + v5 - 24);
        if (v11)
          MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
        *(_QWORD *)(v10 - 56) = &off_24C7F3090;
        v12 = *(_QWORD *)(v10 - 48);
        if (v12)
          MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
        *(v7 - 10) = &off_24C7F3090;
        v13 = *(_QWORD *)(v6 + v5 - 72);
        if (v13)
          MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
        v5 -= 136;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x1090C80C1CE278ELL);
  }
  return a1;
}

void NArray<NDELRHMMModel>::~NArray(_QWORD *a1)
{
  NArray<NDELRHMMModel>::~NArray(a1);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NDELRHMMModel>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = v6 - 16;
        v8 = *(_QWORD *)(v6 - 8);
        if (v8)
        {
          v9 = 136 * v8;
          v10 = v6 - 56;
          do
          {
            v11 = (_QWORD *)(v10 + v9);
            *(_QWORD *)(v10 + v9 + 24) = &off_24C7F3100;
            v12 = *(_QWORD *)(v10 + v9 + 32);
            if (v12)
              MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
            *v11 = &off_24C7F3090;
            v13 = v11[1];
            if (v13)
              MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
            v14 = v10 + v9;
            *(_QWORD *)(v10 + v9 - 32) = &off_24C7F3100;
            v15 = *(_QWORD *)(v10 + v9 - 24);
            if (v15)
              MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
            *(_QWORD *)(v14 - 56) = &off_24C7F3090;
            v16 = *(_QWORD *)(v14 - 48);
            if (v16)
              MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
            *(v11 - 10) = &off_24C7F3090;
            v17 = *(_QWORD *)(v10 + v9 - 72);
            if (v17)
              MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
            v9 -= 136;
          }
          while (v9);
        }
        MEMORY[0x212BAC9C0](v7, 0x1090C80C1CE278ELL);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v18 = (_QWORD *)operator new[]();
      *v18 = 136;
      v18[1] = v5;
      v19 = v18 + 2;
      if (v5)
      {
        v20 = v18 + 2;
        do
        {
          *v20 = &off_24C7F3090;
          v20[1] = 0;
          *((_DWORD *)v20 + 4) = 0;
          v20[3] = &off_24C7F3090;
          v20[4] = 0;
          *((_DWORD *)v20 + 10) = 0;
          v20[6] = &off_24C7F3100;
          v20[7] = 0;
          *((_DWORD *)v20 + 16) = 0;
          *((_DWORD *)v20 + 18) = 0;
          v20[10] = &off_24C7F3090;
          v20[11] = 0;
          *((_DWORD *)v20 + 24) = 0;
          v20[13] = &off_24C7F3100;
          v20[14] = 0;
          *((_DWORD *)v20 + 30) = 0;
          *((_DWORD *)v20 + 32) = 0;
          v20 += 17;
        }
        while (v20 != &v19[17 * v5]);
      }
      *(_QWORD *)(a1 + 8) = v19;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v21 = 0;
      v22 = 0;
      do
      {
        NDELRHMMModel::operator=(*(_QWORD *)(a1 + 8) + v21, *(_QWORD *)(a2 + 8) + v21);
        ++v22;
        v21 += 136;
      }
      while (v22 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<NDELRHMMModel>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = v7 - 16;
      v10 = *(_QWORD *)(v7 - 8);
      if (v10)
      {
        v11 = 136 * v10;
        v12 = v7 - 56;
        do
        {
          v13 = (_QWORD *)(v12 + v11);
          *(_QWORD *)(v12 + v11 + 24) = &off_24C7F3100;
          v14 = *(_QWORD *)(v12 + v11 + 32);
          if (v14)
            MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
          *v13 = &off_24C7F3090;
          v15 = v13[1];
          if (v15)
            MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
          v16 = v12 + v11;
          *(_QWORD *)(v12 + v11 - 32) = &off_24C7F3100;
          v17 = *(_QWORD *)(v12 + v11 - 24);
          if (v17)
            MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
          *(_QWORD *)(v16 - 56) = &off_24C7F3090;
          v18 = *(_QWORD *)(v16 - 48);
          if (v18)
            MEMORY[0x212BAC9C0](v18, 0x1000C8052888210);
          *(v13 - 10) = &off_24C7F3090;
          v19 = *(_QWORD *)(v12 + v11 - 72);
          if (v19)
            MEMORY[0x212BAC9C0](v19, 0x1000C8052888210);
          v11 -= 136;
        }
        while (v11);
      }
      MEMORY[0x212BAC9C0](v9, 0x1090C80C1CE278ELL);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)result = 136;
    *(_QWORD *)(result + 8) = v6;
    v20 = result + 16;
    if (v6)
    {
      v21 = result + 16;
      do
      {
        *(_QWORD *)v21 = &off_24C7F3090;
        *(_QWORD *)(v21 + 8) = 0;
        *(_DWORD *)(v21 + 16) = 0;
        *(_QWORD *)(v21 + 24) = &off_24C7F3090;
        *(_QWORD *)(v21 + 32) = 0;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = &off_24C7F3100;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        *(_DWORD *)(v21 + 72) = 0;
        *(_QWORD *)(v21 + 80) = &off_24C7F3090;
        *(_QWORD *)(v21 + 88) = 0;
        *(_DWORD *)(v21 + 96) = 0;
        *(_QWORD *)(v21 + 104) = &off_24C7F3100;
        *(_QWORD *)(v21 + 112) = 0;
        *(_DWORD *)(v21 + 120) = 0;
        *(_DWORD *)(v21 + 128) = 0;
        v21 += 136;
      }
      while (v21 != v20 + 136 * v6);
    }
    *(_QWORD *)(v4 + 8) = v20;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v22 = 0;
    v23 = 0;
    do
    {
      result = NDELRHMMModel::operator=(*(_QWORD *)(v4 + 8) + v22, a2 + v22);
      ++v23;
      v22 += 136;
    }
    while (v23 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NDELRHMMModel>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 136;
    *(_QWORD *)(result + 8) = v3;
    v7 = result + 16;
    if ((_DWORD)v3)
    {
      v8 = result + 16;
      do
      {
        *(_QWORD *)v8 = &off_24C7F3090;
        *(_QWORD *)(v8 + 8) = 0;
        *(_DWORD *)(v8 + 16) = 0;
        *(_QWORD *)(v8 + 24) = &off_24C7F3090;
        *(_QWORD *)(v8 + 32) = 0;
        *(_DWORD *)(v8 + 40) = 0;
        *(_QWORD *)(v8 + 48) = &off_24C7F3100;
        *(_QWORD *)(v8 + 56) = 0;
        *(_DWORD *)(v8 + 64) = 0;
        *(_DWORD *)(v8 + 72) = 0;
        *(_QWORD *)(v8 + 80) = &off_24C7F3090;
        *(_QWORD *)(v8 + 88) = 0;
        *(_DWORD *)(v8 + 96) = 0;
        *(_QWORD *)(v8 + 104) = &off_24C7F3100;
        *(_QWORD *)(v8 + 112) = 0;
        *(_DWORD *)(v8 + 120) = 0;
        *(_DWORD *)(v8 + 128) = 0;
        v8 += 136;
      }
      while (v8 != v7 + 136 * v3);
    }
    *(_QWORD *)(v5 + 8) = v7;
    if ((_DWORD)v2 && *a2)
    {
      v9 = 0;
      v10 = 1;
      do
      {
        result = NDELRHMMModel::operator=(*(_QWORD *)(v5 + 8) + v9, v6 + v9);
        if (v10 >= v2)
          break;
        v9 += 136;
      }
      while (v10++ < *a2);
    }
    if (v6)
    {
      v12 = *(_QWORD *)(v6 - 8);
      if (v12)
      {
        v13 = 136 * v12;
        v14 = v6 - 56;
        do
        {
          v15 = (_QWORD *)(v14 + v13);
          *(_QWORD *)(v14 + v13 + 24) = &off_24C7F3100;
          v16 = *(_QWORD *)(v14 + v13 + 32);
          if (v16)
            MEMORY[0x212BAC9C0](v16, 0x1000C8052888210);
          *v15 = &off_24C7F3090;
          v17 = v15[1];
          if (v17)
            MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
          v18 = v14 + v13;
          *(_QWORD *)(v14 + v13 - 32) = &off_24C7F3100;
          v19 = *(_QWORD *)(v14 + v13 - 24);
          if (v19)
            MEMORY[0x212BAC9C0](v19, 0x1000C8052888210);
          *(_QWORD *)(v18 - 56) = &off_24C7F3090;
          v20 = *(_QWORD *)(v18 - 48);
          if (v20)
            MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
          *(v15 - 10) = &off_24C7F3090;
          v21 = *(_QWORD *)(v14 + v13 - 72);
          if (v21)
            MEMORY[0x212BAC9C0](v21, 0x1000C8052888210);
          v13 -= 136;
        }
        while (v13);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

uint64_t NDELRHMMModel::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int *v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _OWORD *v49;
  __int128 *v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  int *v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 8)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF8;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 4 * v7;
        v17 = (_DWORD *)(v9 + v16);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    v20 = *(_DWORD *)(a1 + 40);
    v21 = *(_DWORD *)(a2 + 40);
    if (v20 != v21)
    {
      v22 = *(_QWORD *)(a1 + 32);
      if (v22)
      {
        MEMORY[0x212BAC9C0](v22, 0x1000C8052888210);
        v21 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(a1 + 40) = v21;
      *(_QWORD *)(a1 + 32) = operator new[]();
      v20 = *(_DWORD *)(a1 + 40);
    }
    if (v20)
    {
      v23 = 0;
      v24 = *(_QWORD *)(a2 + 32);
      v25 = *(_QWORD *)(a1 + 32);
      v26 = v20;
      if (v20 < 8)
        goto LABEL_24;
      if ((unint64_t)(v25 - v24) < 0x20)
        goto LABEL_24;
      v23 = v20 & 0xFFFFFFF8;
      v27 = (_OWORD *)(v25 + 16);
      v28 = (__int128 *)(v24 + 16);
      v29 = v26 & 0xFFFFFFF8;
      do
      {
        v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v23 != v26)
      {
LABEL_24:
        v31 = v26 - v23;
        v32 = 4 * v23;
        v33 = (_DWORD *)(v25 + v32);
        v34 = (int *)(v24 + v32);
        do
        {
          v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
    }
    v36 = *(_DWORD *)(a1 + 64);
    v37 = *(_DWORD *)(a2 + 64);
    if (v36 != v37)
    {
      v38 = *(_QWORD *)(a1 + 56);
      if (v38)
      {
        MEMORY[0x212BAC9C0](v38, 0x1000C8052888210);
        v37 = *(_DWORD *)(a2 + 64);
      }
      *(_DWORD *)(a1 + 64) = v37;
      *(_QWORD *)(a1 + 56) = operator new[]();
      v36 = *(_DWORD *)(a1 + 64);
    }
    if (v36)
    {
      v39 = 0;
      v40 = *(_QWORD *)(a2 + 56);
      v41 = *(_QWORD *)(a1 + 56);
      do
      {
        *(_DWORD *)(v41 + 4 * v39) = *(_DWORD *)(v40 + 4 * v39);
        ++v39;
      }
      while (v39 < *(unsigned int *)(a1 + 64));
    }
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    v42 = *(_DWORD *)(a1 + 96);
    v43 = *(_DWORD *)(a2 + 96);
    if (v42 != v43)
    {
      v44 = *(_QWORD *)(a1 + 88);
      if (v44)
      {
        MEMORY[0x212BAC9C0](v44, 0x1000C8052888210);
        v43 = *(_DWORD *)(a2 + 96);
      }
      *(_DWORD *)(a1 + 96) = v43;
      *(_QWORD *)(a1 + 88) = operator new[]();
      v42 = *(_DWORD *)(a1 + 96);
    }
    if (v42)
    {
      v45 = 0;
      v46 = *(_QWORD *)(a2 + 88);
      v47 = *(_QWORD *)(a1 + 88);
      v48 = v42;
      if (v42 < 8)
        goto LABEL_43;
      if ((unint64_t)(v47 - v46) < 0x20)
        goto LABEL_43;
      v45 = v42 & 0xFFFFFFF8;
      v49 = (_OWORD *)(v47 + 16);
      v50 = (__int128 *)(v46 + 16);
      v51 = v48 & 0xFFFFFFF8;
      do
      {
        v52 = *v50;
        *(v49 - 1) = *(v50 - 1);
        *v49 = v52;
        v49 += 2;
        v50 += 2;
        v51 -= 8;
      }
      while (v51);
      if (v45 != v48)
      {
LABEL_43:
        v53 = v48 - v45;
        v54 = 4 * v45;
        v55 = (_DWORD *)(v47 + v54);
        v56 = (int *)(v46 + v54);
        do
        {
          v57 = *v56++;
          *v55++ = v57;
          --v53;
        }
        while (v53);
      }
    }
    v58 = *(_DWORD *)(a1 + 120);
    v59 = *(_DWORD *)(a2 + 120);
    if (v58 != v59)
    {
      v60 = *(_QWORD *)(a1 + 112);
      if (v60)
      {
        MEMORY[0x212BAC9C0](v60, 0x1000C8052888210);
        v59 = *(_DWORD *)(a2 + 120);
      }
      *(_DWORD *)(a1 + 120) = v59;
      *(_QWORD *)(a1 + 112) = operator new[]();
      v58 = *(_DWORD *)(a1 + 120);
    }
    if (v58)
    {
      v61 = 0;
      v62 = *(_QWORD *)(a2 + 112);
      v63 = *(_QWORD *)(a1 + 112);
      do
      {
        *(_DWORD *)(v63 + 4 * v61) = *(_DWORD *)(v62 + 4 * v61);
        ++v61;
      }
      while (v61 < *(unsigned int *)(a1 + 120));
    }
  }
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 128);
  return a1;
}

void NDELRHMMModel::NDELRHMMModel(NDELRHMMModel *this)
{
  *(_QWORD *)this = &off_24C7F3090;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = &off_24C7F3090;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3100;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = &off_24C7F3090;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = &off_24C7F3100;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 32) = 0;
}

{
  *(_QWORD *)this = &off_24C7F3090;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = &off_24C7F3090;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = &off_24C7F3100;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = &off_24C7F3090;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = &off_24C7F3100;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 32) = 0;
}

void NDELRHMMModel::init(uint64_t a1, const char *a2, _DWORD *a3, unsigned int *a4, float *a5, _DWORD *a6, float *a7)
{
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _OWORD *v20;
  __int128 *v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  int *v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  _OWORD *v35;
  __int128 *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  int *v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v49;
  _OWORD *v50;
  __int128 *v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  int *v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v65;
  _OWORD *v66;
  __int128 *v67;
  uint64_t v68;
  __int128 v69;
  uint64_t v70;
  uint64_t v71;
  _DWORD *v72;
  int *v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  _OWORD *v82;
  __int128 *v83;
  uint64_t v84;
  __int128 v85;
  uint64_t v86;
  uint64_t v87;
  _DWORD *v88;
  int *v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  unsigned int *v93;
  uint64_t v94;
  unsigned int v95;
  uint64_t v96;
  _DWORD *v97;
  float *v98;
  uint64_t i;
  double v100;
  float v101;
  float v102;
  float *v103;
  float v104;
  float *v105;
  float v106;

  v13 = *a3 + 1;
  *(_DWORD *)(a1 + 72) = v13;
  v14 = *(_DWORD *)(a1 + 16);
  if (v14 != v13)
  {
    v15 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 16) = v13;
    v16 = operator new[]();
    *(_QWORD *)(a1 + 8) = v16;
    v13 = *(_DWORD *)(a1 + 72);
    if (v14 >= v13)
      v17 = v13;
    else
      v17 = v14;
    if ((_DWORD)v17)
    {
      if (v17 >= 8 && (unint64_t)(v16 - v15) > 0x1F)
      {
        v19 = v17 & 0xFFFFFFF8;
        v20 = (_OWORD *)(v16 + 16);
        v21 = (__int128 *)(v15 + 16);
        v22 = v19;
        do
        {
          v23 = *v21;
          *(v20 - 1) = *(v21 - 1);
          *v20 = v23;
          v20 += 2;
          v21 += 2;
          v22 -= 8;
        }
        while (v22);
        if (v19 == v17)
          goto LABEL_18;
      }
      else
      {
        v19 = 0;
      }
      v24 = v17 - v19;
      v25 = 4 * v19;
      v26 = (_DWORD *)(v16 + 4 * v19);
      v27 = (int *)(v15 + v25);
      do
      {
        v28 = *v27++;
        *v26++ = v28;
        --v24;
      }
      while (v24);
LABEL_18:
      MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
      v13 = *(_DWORD *)(a1 + 72);
      goto LABEL_19;
    }
    if (v15)
      goto LABEL_18;
  }
LABEL_19:
  v29 = *(_DWORD *)(a1 + 40);
  if (v29 == v13)
    goto LABEL_37;
  v30 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 40) = v13;
  v31 = operator new[]();
  *(_QWORD *)(a1 + 32) = v31;
  v13 = *(_DWORD *)(a1 + 72);
  if (v29 >= v13)
    v32 = v13;
  else
    v32 = v29;
  if ((_DWORD)v32)
  {
    if (v32 >= 8 && (unint64_t)(v31 - v30) > 0x1F)
    {
      v34 = v32 & 0xFFFFFFF8;
      v35 = (_OWORD *)(v31 + 16);
      v36 = (__int128 *)(v30 + 16);
      v37 = v34;
      do
      {
        v38 = *v36;
        *(v35 - 1) = *(v36 - 1);
        *v35 = v38;
        v35 += 2;
        v36 += 2;
        v37 -= 8;
      }
      while (v37);
      if (v34 == v32)
        goto LABEL_36;
    }
    else
    {
      v34 = 0;
    }
    v39 = v32 - v34;
    v40 = 4 * v34;
    v41 = (_DWORD *)(v31 + 4 * v34);
    v42 = (int *)(v30 + v40);
    do
    {
      v43 = *v42++;
      *v41++ = v43;
      --v39;
    }
    while (v39);
LABEL_36:
    MEMORY[0x212BAC9C0](v30, 0x1000C8052888210);
    v13 = *(_DWORD *)(a1 + 72);
    goto LABEL_37;
  }
  if (v30)
    goto LABEL_36;
LABEL_37:
  v44 = *(_DWORD *)(a1 + 64);
  if (v44 == v13)
    goto LABEL_55;
  v45 = *(_QWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 64) = v13;
  v46 = operator new[]();
  *(_QWORD *)(a1 + 56) = v46;
  v13 = *(_DWORD *)(a1 + 72);
  if (v44 >= v13)
    v47 = v13;
  else
    v47 = v44;
  if ((_DWORD)v47)
  {
    if (v47 >= 8 && (unint64_t)(v46 - v45) > 0x1F)
    {
      v49 = v47 & 0xFFFFFFF8;
      v50 = (_OWORD *)(v46 + 16);
      v51 = (__int128 *)(v45 + 16);
      v52 = v49;
      do
      {
        v53 = *v51;
        *(v50 - 1) = *(v51 - 1);
        *v50 = v53;
        v50 += 2;
        v51 += 2;
        v52 -= 8;
      }
      while (v52);
      if (v49 == v47)
        goto LABEL_54;
    }
    else
    {
      v49 = 0;
    }
    v54 = v47 - v49;
    v55 = 4 * v49;
    v56 = (_DWORD *)(v46 + 4 * v49);
    v57 = (int *)(v45 + v55);
    do
    {
      v58 = *v57++;
      *v56++ = v58;
      --v54;
    }
    while (v54);
LABEL_54:
    MEMORY[0x212BAC9C0](v45, 0x1000C8052888210);
    v13 = *(_DWORD *)(a1 + 72);
    goto LABEL_55;
  }
  if (v45)
    goto LABEL_54;
LABEL_55:
  v59 = v13 + 1;
  v60 = *(_DWORD *)(a1 + 96);
  if (v60 == v13 + 1)
    goto LABEL_73;
  v61 = *(_QWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 96) = v59;
  v62 = operator new[]();
  *(_QWORD *)(a1 + 88) = v62;
  if (v60 >= v59)
    v63 = v59;
  else
    v63 = v60;
  if ((_DWORD)v63)
  {
    if (v63 >= 8 && (unint64_t)(v62 - v61) > 0x1F)
    {
      v65 = v63 & 0xFFFFFFF8;
      v66 = (_OWORD *)(v62 + 16);
      v67 = (__int128 *)(v61 + 16);
      v68 = v65;
      do
      {
        v69 = *v67;
        *(v66 - 1) = *(v67 - 1);
        *v66 = v69;
        v66 += 2;
        v67 += 2;
        v68 -= 8;
      }
      while (v68);
      if (v65 == v63)
        goto LABEL_72;
    }
    else
    {
      v65 = 0;
    }
    v70 = v63 - v65;
    v71 = 4 * v65;
    v72 = (_DWORD *)(v62 + 4 * v65);
    v73 = (int *)(v61 + v71);
    do
    {
      v74 = *v73++;
      *v72++ = v74;
      --v70;
    }
    while (v70);
LABEL_72:
    MEMORY[0x212BAC9C0](v61, 0x1000C8052888210);
    goto LABEL_73;
  }
  if (v61)
    goto LABEL_72;
LABEL_73:
  v75 = *(_DWORD *)(a1 + 72) + 1;
  v76 = *(_DWORD *)(a1 + 120);
  if (v76 == v75)
    goto LABEL_91;
  v77 = *(_QWORD *)(a1 + 112);
  *(_DWORD *)(a1 + 120) = v75;
  v78 = operator new[]();
  *(_QWORD *)(a1 + 112) = v78;
  if (v76 >= v75)
    v79 = v75;
  else
    v79 = v76;
  if ((_DWORD)v79)
  {
    if (v79 >= 8 && (unint64_t)(v78 - v77) > 0x1F)
    {
      v81 = v79 & 0xFFFFFFF8;
      v82 = (_OWORD *)(v78 + 16);
      v83 = (__int128 *)(v77 + 16);
      v84 = v81;
      do
      {
        v85 = *v83;
        *(v82 - 1) = *(v83 - 1);
        *v82 = v85;
        v82 += 2;
        v83 += 2;
        v84 -= 8;
      }
      while (v84);
      if (v81 == v79)
        goto LABEL_90;
    }
    else
    {
      v81 = 0;
    }
    v86 = v79 - v81;
    v87 = 4 * v81;
    v88 = (_DWORD *)(v78 + 4 * v81);
    v89 = (int *)(v77 + v87);
    do
    {
      v90 = *v89++;
      *v88++ = v90;
      --v86;
    }
    while (v86);
LABEL_90:
    MEMORY[0x212BAC9C0](v77, 0x1000C8052888210);
    goto LABEL_91;
  }
  if (v77)
    goto LABEL_90;
LABEL_91:
  *(_DWORD *)(a1 + 128) = *a6;
  LODWORD(v91) = *(_DWORD *)(a1 + 72);
  if (v91 < 2)
  {
    v97 = *(_DWORD **)(a1 + 56);
LABEL_101:
    v105 = *(float **)(a1 + 32);
    v103 = *(float **)(a1 + 8);
    goto LABEL_102;
  }
  v92 = 1;
  v93 = (unsigned int *)a2;
  do
  {
    v95 = *v93;
    v93 += 2;
    v94 = v95;
    v96 = *a4;
    if (v95 >= v96)
      Error::chuck((Error *)"NDELRHMMModel::init() - HMM includes invalid index %d (>=%d)", a2, v94, v96);
    v97 = *(_DWORD **)(a1 + 56);
    v97[v92++] = v94;
    v91 = *(unsigned int *)(a1 + 72);
  }
  while (v92 < v91);
  if (v91 <= 1)
    goto LABEL_101;
  v98 = (float *)(a2 + 4);
  for (i = 1; i != v91; ++i)
  {
    v100 = *v98;
    if (*v98 <= 1.0)
      Error::chuck((Error *)"NDELRHMMModel::init() - Duration %f less than or equal to 1.0 on hmmstate: %d", a2, *(_QWORD *)&v100, i);
    v101 = 1.0 - 1.0 / v100;
    v102 = logf(v101);
    v103 = *(float **)(a1 + 8);
    v103[i] = v102;
    v104 = logf(1.0 - v101);
    v105 = *(float **)(a1 + 32);
    v105[i] = v104;
    v98 += 2;
  }
LABEL_102:
  v105[(v91 - 1)] = *a5 + v105[(v91 - 1)];
  v106 = 1.0 - 1.0 / *a7;
  *v103 = logf(v106);
  *v105 = logf(1.0 - v106);
  *v97 = -1;
}

uint64_t NDELRHMMModel::updateFirstStateOutputID(uint64_t this, const unsigned int *a2)
{
  if (*(_DWORD *)(this + 64))
    **(_DWORD **)(this + 56) = *a2;
  return this;
}

uint64_t NDELRHMMModel::reset(uint64_t this)
{
  _DWORD *v1;
  _DWORD *v2;
  unsigned int v3;
  uint64_t v4;

  if (*(_DWORD *)(this + 72))
  {
    v1 = *(_DWORD **)(this + 88);
    *v1 = 0;
    v2 = *(_DWORD **)(this + 112);
    *v2 = 0;
    if (*(_DWORD *)(this + 72))
    {
      v3 = 1;
      do
      {
        v4 = v3;
        v1[v4] = -8388609;
        v2[v4] = 0;
        ++v3;
      }
      while (v3 <= *(_DWORD *)(this + 72));
    }
  }
  return this;
}

uint64_t NDELRHMMModel::stepFrame(uint64_t result, uint64_t a2, float *a3, _DWORD *a4, double a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  float v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  float *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t v27;
  float32x4_t *v28;
  uint64_t v29;
  float32x4_t v30;
  uint64_t v31;
  float *v32;

  v5 = *(_DWORD *)(result + 72);
  v6 = (v5 - 1);
  if (v5 == 1)
    goto LABEL_10;
  v7 = *(_QWORD *)(result + 88);
  v8 = *(_QWORD *)(result + 8);
  v9 = v5 - 2;
  v10 = *(_QWORD *)(result + 32);
  do
  {
    v11 = *(float *)(v7 + 4 * v6) + *(float *)(v8 + 4 * v6);
    v12 = *(float *)(v7 + 4 * v9) + *(float *)(v10 + 4 * v9);
    if (v11 <= v12)
    {
      *(_DWORD *)(*(_QWORD *)(result + 112) + 4 * v6) = *(_DWORD *)(*(_QWORD *)(result + 112) + 4 * v9);
      v11 = v12;
    }
    *(float *)(v7 + 4 * v6) = v11;
    --v9;
    --v6;
  }
  while ((_DWORD)v6);
  v13 = *(unsigned int *)(result + 72);
  if (v13 <= 1)
  {
LABEL_10:
    v18 = *(float **)(result + 88);
  }
  else
  {
    v14 = *(_QWORD *)(result + 56);
    v15 = *(_QWORD *)(a2 + 8);
    v16 = 4 * v13;
    v17 = 4;
    v18 = *(float **)(result + 88);
    do
    {
      v18[(unint64_t)v17 / 4] = *(float *)(v15 + 4 * *(unsigned int *)(v14 + v17))
                                     + v18[(unint64_t)v17 / 4];
      v17 += 4;
    }
    while (v16 != v17);
  }
  v19 = *v18 + **(float **)(result + 8);
  *v18 = v19;
  *v18 = v19 + *a3;
  v20 = *(_DWORD **)(result + 112);
  *v20 = *a4 + 1;
  v21 = *(unsigned int *)(result + 72);
  v22 = (v21 - 1);
  v23 = *(float **)(result + 32);
  v21 *= 4;
  *(float *)((char *)v18 + v21) = v18[v22] + v23[v22];
  *(_DWORD *)((char *)v20 + v21) = v20[v22];
  *(float *)&a5 = *v18 + *v23;
  v24 = *(_DWORD *)(result + 72);
  if ((v24 + 1) > 1)
    v25 = (v24 + 1);
  else
    v25 = 1;
  if (v25 < 8)
  {
    v26 = 0;
LABEL_19:
    v31 = v25 - v26;
    v32 = &v18[v26];
    do
    {
      *v32 = *v32 - *(float *)&a5;
      ++v32;
      --v31;
    }
    while (v31);
    return result;
  }
  v26 = v25 & 0xFFFFFFF8;
  v27 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
  v28 = (float32x4_t *)(v18 + 4);
  v29 = v26;
  do
  {
    v30 = vsubq_f32(*v28, v27);
    v28[-1] = vsubq_f32(v28[-1], v27);
    *v28 = v30;
    v28 += 2;
    v29 -= 8;
  }
  while (v29);
  if (v26 != v25)
    goto LABEL_19;
  return result;
}

void NDEHMMDetector::NDEHMMDetector(NDEHMMDetector *this)
{
  *(_QWORD *)this = &off_24C7F18B0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = &off_24C7F2D10;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = &off_24C7F31A8;
  *((_WORD *)this + 60) = 1;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 18) = &off_24C7F31A8;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = &off_24C7F3090;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 48) = -8388609;
  *(_QWORD *)((char *)this + 204) = 0;
  *(_QWORD *)((char *)this + 196) = 0;
  *(_DWORD *)((char *)this + 211) = 0;
}

{
  *(_QWORD *)this = &off_24C7F18B0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = &off_24C7F2D10;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = &off_24C7F31A8;
  *((_WORD *)this + 60) = 1;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 18) = &off_24C7F31A8;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = &off_24C7F3090;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 48) = -8388609;
  *(_QWORD *)((char *)this + 204) = 0;
  *(_QWORD *)((char *)this + 196) = 0;
  *(_DWORD *)((char *)this + 211) = 0;
}

uint64_t NDEHMMDetector::init(uint64_t a1, int32x2_t *a2, const char *a3, const unsigned int *a4, const char *a5, const unsigned int *a6, int a7, float a8)
{
  NDeepnetDistribution *v15;
  const char *v16;
  unsigned int v17;
  uint64_t v18;
  int32x2_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  __int128 *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  int *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int *v43;
  const char *v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v52;
  _OWORD *v53;
  __int128 *v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  int *v60;
  int v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int *v65;
  int v66;
  uint64_t v67;
  _DWORD *v68;
  _DWORD *v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t result;
  uint64_t v73;
  uint64_t v74;
  unsigned int *v75;
  const char *v76;
  unsigned int v77[2];
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  float v81;

  v81 = a8;
  if (*(_BYTE *)(a1 + 212))
    Error::chuck((Error *)"NDEHMMDetector::init() - init() already called", (const char *)a2);
  v15 = (NDeepnetDistribution *)operator new();
  NDeepnetDistribution::NDeepnetDistribution(v15);
  *(_QWORD *)(a1 + 8) = v15;
  NDeepnetDistribution::init(v15, a3, a4);
  *(_QWORD *)(a1 + 16) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 144))(*(_QWORD *)(a1 + 8));
  v80 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  NDEHMMDetector::initHMM((NDEHMMDetector *)a1, a5, a6, &v80, (const int *)a2 + 1, (int *)&a2[1], &v81);
  v17 = a2[3].u32[0];
  v18 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 72);
  if (v17 > v18)
    Error::chuck((Error *)"NDEHMMDetector::init() - partial state set to %d, must be between 0 (disabled) and %d", v16, a2[3].u32[0], v18);
  *(_DWORD *)(a1 + 132) = v17;
  v19 = vrev64_s32(a2[2]);
  *(_DWORD *)(a1 + 128) = a7;
  *(int32x2_t *)(a1 + 136) = v19;
  if (!a7)
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8));
  *(_BYTE *)(a1 + 213) = 0;
  v20 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8));
  v21 = *(_DWORD *)(a1 + 128);
  v22 = *(_DWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8));
  if (v20 < 2)
  {
    if (v21 != v22)
    {
      v41 = *(_QWORD *)(a1 + 8);
      v42 = *(unsigned int *)(a1 + 128);
      v43 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 40))(v41);
      Error::chuck((Error *)"NDEHMMDetector::init() - frame sizes of models and acanal must match for non-windowed frames (%d != %d)", v44, v42, *v43);
    }
  }
  else
  {
    if (v21 < v22)
    {
      v73 = *(_QWORD *)(a1 + 8);
      v74 = *(unsigned int *)(a1 + 128);
      v75 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v73 + 40))(v73);
      Error::chuck((Error *)"NDEHMMDetector::init() - acanal frames smaller than those required for model (%d < %d)", v76, v74, *v75);
    }
    *(_BYTE *)(a1 + 213) = 1;
    v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8));
    v79 = 0;
    v80 = v23;
    v24 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8));
    v78 = -2;
    *(_QWORD *)v77 = 0;
    NFrameWindow::configure(a1 + 48, (const char *)&v80, (unsigned int *)(a1 + 128), &v79, v24, &v78, &v77[1], v77);
    v25 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8));
    v26 = *(_DWORD *)(a1 + 160);
    if (v26 != *v25)
    {
      v27 = v25;
      v28 = *(_QWORD *)(a1 + 152);
      *(_DWORD *)(a1 + 160) = *v25;
      v29 = operator new[]();
      *(_QWORD *)(a1 + 152) = v29;
      LODWORD(v30) = *v27;
      if (v26 >= *v27)
        v30 = v30;
      else
        v30 = v26;
      if ((_DWORD)v30)
      {
        v31 = 0;
        if (v30 < 8)
          goto LABEL_17;
        if ((unint64_t)(v29 - v28) <= 0x1F)
          goto LABEL_17;
        v31 = v30 & 0xFFFFFFF8;
        v32 = (_OWORD *)(v29 + 16);
        v33 = (__int128 *)(v28 + 16);
        v34 = v31;
        do
        {
          v35 = *v33;
          *(v32 - 1) = *(v33 - 1);
          *v32 = v35;
          v32 += 2;
          v33 += 2;
          v34 -= 8;
        }
        while (v34);
        if (v31 != v30)
        {
LABEL_17:
          v36 = v30 - v31;
          v37 = 4 * v31;
          v38 = (_DWORD *)(v29 + 4 * v31);
          v39 = (int *)(v28 + v37);
          do
          {
            v40 = *v39++;
            *v38++ = v40;
            --v36;
          }
          while (v36);
        }
      }
      else if (!v28)
      {
        goto LABEL_24;
      }
      MEMORY[0x212BAC9C0](v28, 0x1000C8052888210);
    }
  }
LABEL_24:
  v45 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  v46 = *(_DWORD *)(a1 + 184);
  if (v46 == v45)
    goto LABEL_42;
  v47 = v45;
  v48 = *(_QWORD *)(a1 + 176);
  *(_DWORD *)(a1 + 184) = v45;
  v49 = operator new[]();
  *(_QWORD *)(a1 + 176) = v49;
  if (v46 >= v47)
    v50 = v47;
  else
    v50 = v46;
  if ((_DWORD)v50)
  {
    if (v50 >= 8 && (unint64_t)(v49 - v48) > 0x1F)
    {
      v52 = v50 & 0xFFFFFFF8;
      v53 = (_OWORD *)(v49 + 16);
      v54 = (__int128 *)(v48 + 16);
      v55 = v52;
      do
      {
        v56 = *v54;
        *(v53 - 1) = *(v54 - 1);
        *v53 = v56;
        v53 += 2;
        v54 += 2;
        v55 -= 8;
      }
      while (v55);
      if (v52 == v50)
        goto LABEL_41;
    }
    else
    {
      v52 = 0;
    }
    v57 = v50 - v52;
    v58 = 4 * v52;
    v59 = (_DWORD *)(v49 + 4 * v52);
    v60 = (int *)(v48 + v58);
    do
    {
      v61 = *v60++;
      *v59++ = v61;
      --v57;
    }
    while (v57);
LABEL_41:
    MEMORY[0x212BAC9C0](v48, 0x1000C8052888210);
    goto LABEL_42;
  }
  if (v48)
    goto LABEL_41;
LABEL_42:
  *(_DWORD *)(a1 + 192) = -8388609;
  *(_QWORD *)(a1 + 204) = 0;
  *(_QWORD *)(a1 + 196) = 0;
  if (*(_DWORD *)(a1 + 40))
  {
    v62 = 0;
    v63 = *(_QWORD *)(a1 + 32);
    do
    {
      v64 = v63 + 136 * v62;
      v66 = *(_DWORD *)(v64 + 72);
      v65 = (unsigned int *)(v64 + 72);
      if (v66)
      {
        v67 = v63 + 136 * v62;
        v68 = *(_DWORD **)(v67 + 88);
        *v68 = 0;
        v69 = *(_DWORD **)(v67 + 112);
        *v69 = 0;
        if (*v65)
        {
          v70 = 1;
          do
          {
            v71 = v70;
            v68[v71] = -8388609;
            v69[v71] = 0;
            ++v70;
          }
          while (v70 <= *v65);
        }
      }
      ++v62;
    }
    while (v62 < *(unsigned int *)(a1 + 40));
  }
  *(_WORD *)(a1 + 120) = 1;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  result = *(_QWORD *)(a1 + 8);
  if (result && *(_QWORD *)(a1 + 16))
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 160))(result);
  *(_BYTE *)(a1 + 212) = 1;
  return result;
}

void sub_20D9BE7F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10F1C40D53CD75ELL);
  _Unwind_Resume(a1);
}

void NDEHMMDetector::initHMM(NDEHMMDetector *this, const char *a2, const unsigned int *a3, unsigned int *a4, const int *a5, int *a6, float *a7)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const char *v17;
  unsigned int *v18;
  int v19;
  const int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  BOOL v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _DWORD *v30;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;

  if (!a2)
    Error::chuck((Error *)"NDEHMMDetector::initHMM() - NULL blob provided", 0, a3, a4, a5, a6);
  v9 = *(unsigned int *)a5;
  v10 = *a6;
  *((_BYTE *)this + 214) = *a6 < 0;
  if ((int)v9 >= -1)
    v11 = 1;
  else
    v11 = 3;
  v12 = *a3;
  if (v12 <= 3)
    goto LABEL_39;
  v13 = a2;
  v14 = *(unsigned int *)a2;
  if ((_DWORD)v9 == -1 || (int)v9 < -256 || (int)v9 >= (int)v14)
    Error::chuck((Error *)"NDEHMMDetector::initHMM() - wrong keyword_id %d (%d)", a2, v9, v14);
  v37 = 1;
  if ((int)v9 <= -2)
  {
    v37 = v14 + (~v10 >> 31);
    if (!v37)
      Error::chuck((Error *)"NDEHMMDetector::initHMM() - wrong num_keywords", a2);
  }
  NArray<NDELRHMMModel>::resize((uint64_t)this + 24, &v37);
  if ((_DWORD)v14)
  {
    v15 = 0;
    v16 = 0;
    v17 = &v13[v12];
    v18 = (unsigned int *)(v13 + 4);
    v19 = -1;
    v20 = a6;
    while (&v18[v11] <= (unsigned int *)v17)
    {
      v35 = 0;
      v36 = 0;
      if ((int)v9 <= -2)
      {
        v21 = *v18;
        v22 = v18[1];
        v18 += 2;
        v35 = v22;
        v36 = v21;
      }
      a2 = (const char *)(v18 + 1);
      v23 = *v18;
      v18 += 2 * v23 + 1;
      if (v18 > (unsigned int *)v17)
        break;
      v24 = *v20;
      if ((*v20 & 0x80000000) == 0 && (_DWORD)v15 == v24)
      {
        if ((_DWORD)v23 != 1)
          Error::chuck((Error *)"NDEHMMDetector::initHMM() - GSM HMM (id %d) must be single state", a2, v15);
        v19 = *(_DWORD *)a2;
      }
      v26 = *a5 >= 0 || (_DWORD)v15 == v24;
      if (((_DWORD)v15 == *a5 || !v26) && v16 < *((unsigned int *)this + 10))
      {
        v27 = *((_QWORD *)this + 4) + 136 * v16;
        v34 = v23;
        NDELRHMMModel::init(v27, a2, &v34, a4, (float *)&v36, &v35, a7);
        v20 = a6;
        ++v16;
      }
      v15 = (v15 + 1);
      if ((_DWORD)v14 == (_DWORD)v15)
        goto LABEL_33;
    }
LABEL_39:
    Error::chuck((Error *)"NDEHMMDetector::initHMM() - blobsize too small", a2);
  }
  v19 = -1;
LABEL_33:
  v28 = *((unsigned int *)this + 10);
  if ((_DWORD)v28)
  {
    v29 = 0;
    v30 = (_DWORD *)(*((_QWORD *)this + 4) + 64);
    do
    {
      if (*v30)
      {
        **((_DWORD **)v30 - 1) = v19;
        v28 = *((unsigned int *)this + 10);
      }
      ++v29;
      v30 += 34;
    }
    while (v29 < v28);
  }
}

uint64_t NDEHMMDetector::reset(uint64_t this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  int v5;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  *(_DWORD *)(this + 192) = -8388609;
  *(_QWORD *)(this + 204) = 0;
  *(_QWORD *)(this + 196) = 0;
  if (*(_DWORD *)(this + 40))
  {
    v1 = 0;
    v2 = *(_QWORD *)(this + 32);
    do
    {
      v3 = v2 + 136 * v1;
      v5 = *(_DWORD *)(v3 + 72);
      v4 = (unsigned int *)(v3 + 72);
      if (v5)
      {
        v6 = v2 + 136 * v1;
        v7 = *(_DWORD **)(v6 + 88);
        *v7 = 0;
        v8 = *(_DWORD **)(v6 + 112);
        *v8 = 0;
        if (*v4)
        {
          v9 = 1;
          do
          {
            v10 = v9;
            v7[v10] = -8388609;
            v8[v10] = 0;
            ++v9;
          }
          while (v9 <= *v4);
        }
      }
      ++v1;
    }
    while (v1 < *(unsigned int *)(this + 40));
  }
  *(_WORD *)(this + 120) = 1;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
  v11 = *(_QWORD *)(this + 8);
  if (v11)
  {
    if (*(_QWORD *)(this + 16))
      return (*(uint64_t (**)(_QWORD))(*(_QWORD *)v11 + 160))(*(_QWORD *)(this + 8));
  }
  return this;
}

void NDEHMMDetector::feedFrame(NDEHMMDetector *this, const NFrame *a2)
{
  const NFrame *v2;
  int v4;
  uint64_t v5;
  __n128 v6;
  int v7;
  const char *v8;

  if (!*((_BYTE *)this + 212))
    Error::chuck((Error *)"NDEHMMDetector::feedFrame() - init() not called", (const char *)a2);
  v2 = a2;
  if (!*((_BYTE *)this + 213))
    goto LABEL_10;
  v4 = *((_DWORD *)a2 + 4);
  if (!v4)
    Error::chuck((Error *)"NFrameWindow::pushFrame() - cannot feed zero-sized frames", (const char *)a2);
  v5 = *((unsigned int *)this + 14);
  if (v4 != (_DWORD)v5)
    Error::chuck((Error *)"NFrameWindow::pushFrame() - mismatched input frame size (%d != %d)", (const char *)a2, *((unsigned int *)a2 + 4), v5);
  v6.n128_u64[0] = (unint64_t)NFrameWindow::pushFrame((NDEHMMDetector *)((char *)this + 48), *((const float **)a2 + 1));
  v7 = *((_DWORD *)this + 22);
  if (*((_BYTE *)this + 121) && v7 || v7 == *((_DWORD *)this + 13) + 1)
  {
    v8 = (char *)this + 68;
    if (!*((_DWORD *)this + 17))
      Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v8, v6.n128_f64[0]);
    v2 = (NDEHMMDetector *)((char *)this + 144);
    (*(void (**)(char *, const char *, __n128))(*((_QWORD *)this + 18) + 32))((char *)this + 144, v8, v6);
    NFrameWindow::setOutputFrameWindow((uint64_t)this + 48, *((float **)this + 19));
LABEL_10:
    NDEHMMDetector::stepFrame((uint64_t)this, v2);
  }
  ++*((_DWORD *)this + 50);
}

uint64_t NDEHMMDetector::stepFrame(uint64_t this, const NFrame *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  _DWORD *v5;
  int v6;
  double v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  float *v11;
  float v12;
  float v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;

  v2 = this;
  v3 = *(_DWORD *)(this + 208);
  if (v3)
  {
    *(_DWORD *)(this + 208) = v3 - 1;
  }
  else
  {
    v5 = (_DWORD *)(this + 204);
    v4 = *(_DWORD *)(this + 204);
    v6 = *(_DWORD *)(this + 136);
    if (v4)
      *v5 = v6 + v4;
    *(_DWORD *)(this + 208) = v6;
    this = (*(uint64_t (**)(_QWORD, const NFrame *, uint64_t, _QWORD))(**(_QWORD **)(this + 8) + 72))(*(_QWORD *)(this + 8), a2, this + 168, *(_QWORD *)(this + 16));
    if (*(_BYTE *)(v2 + 214))
    {
      v8 = *(unsigned int *)(v2 + 184);
      if ((_DWORD)v8)
      {
        v9 = *(_DWORD **)(v2 + 176);
        LODWORD(v7) = *v9;
        if ((_DWORD)v8 != 1)
        {
          v10 = v8 - 1;
          v11 = (float *)(v9 + 1);
          do
          {
            v12 = *v11++;
            v13 = v12;
            if (v12 > *(float *)&v7)
              *(float *)&v7 = v13;
            --v10;
          }
          while (v10);
        }
      }
      else
      {
        LODWORD(v7) = 0;
      }
    }
    else
    {
      LODWORD(v7) = *(_DWORD *)(*(_QWORD *)(v2 + 176) + 4 * **(unsigned int **)(*(_QWORD *)(v2 + 32) + 56));
    }
    v19 = LODWORD(v7);
    if (*(_DWORD *)(v2 + 40))
    {
      v14 = 0;
      v15 = 0;
      do
      {
        this = NDELRHMMModel::stepFrame(*(_QWORD *)(v2 + 32) + v14, v2 + 168, (float *)&v19, (_DWORD *)(v2 + 204), v7);
        ++v15;
        v14 += 136;
      }
      while (v15 < *(unsigned int *)(v2 + 40));
    }
    v16 = *(unsigned int *)(v2 + 132);
    if ((_DWORD)v16)
    {
      v17 = *(_QWORD *)(v2 + 32);
      v18 = 4 * v16;
      *(float *)(v2 + 192) = *(float *)(*(_QWORD *)(v17 + 88) + v18) * (float)(*(_DWORD *)(v2 + 136) + 1);
      *(_DWORD *)(v2 + 196) = *(_DWORD *)(*(_QWORD *)(v17 + 112) + v18);
    }
    ++*v5;
  }
  return this;
}

uint64_t NDEHMMDetector::numKeywords(NDEHMMDetector *this)
{
  return *((unsigned int *)this + 10);
}

BOOL NDEHMMDetector::skipUntilProcessedFrame(NDEHMMDetector *this)
{
  int v1;
  int v2;
  int v3;

  v1 = *((_DWORD *)this + 52);
  if (v1)
  {
    v2 = v1 - 1;
  }
  else
  {
    v3 = *((_DWORD *)this + 51);
    v2 = *((_DWORD *)this + 34);
    if (v3)
      *((_DWORD *)this + 51) = v2 + v3;
  }
  *((_DWORD *)this + 52) = v2;
  return v1 != 0;
}

float NDEHMMDetector::maxScore(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float result;
  uint64_t v5;
  float *v6;
  float v7;
  float v8;

  v2 = *(unsigned int *)(a2 + 16);
  if (!(_DWORD)v2)
    return 0.0;
  v3 = *(float **)(a2 + 8);
  result = *v3;
  if ((_DWORD)v2 != 1)
  {
    v5 = v2 - 1;
    v6 = v3 + 1;
    do
    {
      v7 = *v6++;
      v8 = v7;
      if (v7 > result)
        result = v8;
      --v5;
    }
    while (v5);
  }
  return result;
}

float NDEHMMDetector::partialScore(NDEHMMDetector *this)
{
  return *((float *)this + 48);
}

uint64_t NDEHMMDetector::partialLength(NDEHMMDetector *this)
{
  if (*((_DWORD *)this + 33))
    return (*((_DWORD *)this + 51) - *((_DWORD *)this + 49));
  else
    return 0;
}

float NDEHMMDetector::scorePhrase(NDEHMMDetector *this, unsigned int a2)
{
  uint64_t v2;

  if (*((_DWORD *)this + 10) <= a2)
    return -3.4028e38;
  v2 = *((_QWORD *)this + 4) + 136 * a2;
  return *(float *)(*(_QWORD *)(v2 + 88) + 4 * *(unsigned int *)(v2 + 72))
       * (float)(*((_DWORD *)this + 34) + 1);
}

float NDEHMMDetector::phraseScoreOffset(NDEHMMDetector *this, unsigned int a2)
{
  float result;

  result = 0.0;
  if (*((_DWORD *)this + 10) > a2)
    return *(float *)(*((_QWORD *)this + 4) + 136 * a2 + 128);
  return result;
}

uint64_t NDEHMMDetector::bestLengthPhrase(NDEHMMDetector *this, unsigned int a2)
{
  uint64_t v2;

  if (*((_DWORD *)this + 10) <= a2)
    return 0;
  v2 = *((_QWORD *)this + 4) + 136 * a2;
  return (*((_DWORD *)this + 51) - *(_DWORD *)(*(_QWORD *)(v2 + 112) + 4 * *(unsigned int *)(v2 + 72)));
}

uint64_t NDEHMMDetector::frameLatency(NDEHMMDetector *this)
{
  int v1;

  v1 = *((_DWORD *)this + 50) - *((_DWORD *)this + 51) + *((_DWORD *)this + 35);
  return v1 & ~(v1 >> 31);
}

void NGaussianMixtureModels::~NGaussianMixtureModels(NGaussianMixtureModels *this)
{
  NGaussianMixtureModels::~NGaussianMixtureModels(this);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)this = &off_24C7F2838;
  *((_QWORD *)this + 7) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *((_QWORD *)this + 3) = &off_24C7F2E60;
  v3 = *((_QWORD *)this + 4);
  if (v3)
  {
    v4 = v3 - 16;
    v5 = *(_QWORD *)(v3 - 8);
    if (v5)
    {
      v6 = 56 * v5;
      v7 = v3 - 24;
      do
      {
        v8 = v7 + v6;
        *(_QWORD *)(v7 + v6 - 8) = &off_24C7F3090;
        v9 = *(_QWORD *)(v7 + v6);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        *(_QWORD *)(v8 - 32) = &off_24C7F3090;
        v10 = *(_QWORD *)(v8 - 24);
        if (v10)
          MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
        v6 -= 56;
      }
      while (v6);
    }
    MEMORY[0x212BAC9C0](v4, 0x1080C80D133DD60);
  }
  *(_QWORD *)this = &off_24C7F2D48;
  v11 = *((_QWORD *)this + 1);
  if (v11)
  {
    v12 = v11 - 16;
    v13 = *(_QWORD *)(v11 - 8);
    if (v13)
    {
      v14 = 48 * v13;
      v15 = v11 - 24;
      do
      {
        v16 = v15 + v14;
        *(_QWORD *)(v15 + v14) = &off_24C7F3090;
        v17 = *(_QWORD *)(v15 + v14 + 8);
        if (v17)
          MEMORY[0x212BAC9C0](v17, 0x1000C8052888210);
        *(_QWORD *)(v16 - 24) = &off_24C7F3100;
        v18 = *(_QWORD *)(v16 - 16);
        if (v18)
          MEMORY[0x212BAC9C0](v18, 0x1000C8052888210);
        v14 -= 48;
      }
      while (v14);
    }
    MEMORY[0x212BAC9C0](v12, 0x1090C806BD41B22);
  }
}

uint64_t NArray<NGaussianMixture>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = v6 - 16;
      v8 = *(_QWORD *)(v6 - 8);
      if (v8)
      {
        v9 = 48 * v8;
        v10 = v6 - 24;
        do
        {
          v11 = v10 + v9;
          *(_QWORD *)(v10 + v9) = &off_24C7F3090;
          v12 = *(_QWORD *)(v10 + v9 + 8);
          if (v12)
            MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
          *(_QWORD *)(v11 - 24) = &off_24C7F3100;
          v13 = *(_QWORD *)(v11 - 16);
          if (v13)
            MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
          v9 -= 48;
        }
        while (v9);
      }
      MEMORY[0x212BAC9C0](v7, 0x1090C806BD41B22);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v14 = 48 * v5;
    v15 = (_QWORD *)operator new[]();
    *v15 = 48;
    v15[1] = v5;
    v16 = v15 + 2;
    if (!v5)
      goto LABEL_19;
    v17 = v15 + 2;
    if ((unint64_t)(v14 - 48) >= 0x30)
    {
      v18 = (v14 - 48) / 0x30uLL + 1;
      v19 = v15 + 13;
      v20 = v18 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v19 - 11) = &off_24C7F3100;
        *((_QWORD *)v19 - 10) = 0;
        *((_QWORD *)v19 - 5) = &off_24C7F3100;
        *((_QWORD *)v19 - 4) = 0;
        *(v19 - 18) = 0;
        *(v19 - 6) = 0;
        *((_QWORD *)v19 - 8) = &off_24C7F3090;
        *((_QWORD *)v19 - 7) = 0;
        *((_QWORD *)v19 - 2) = &off_24C7F3090;
        *((_QWORD *)v19 - 1) = 0;
        *(v19 - 12) = 0;
        *v19 = 0;
        v19 += 24;
        v20 -= 2;
      }
      while (v20);
      if (v18 == (v18 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_19;
      v17 = &v16[6 * (v18 & 0xFFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v17 = &off_24C7F3100;
      v17[1] = 0;
      *((_DWORD *)v17 + 4) = 0;
      v17[3] = &off_24C7F3090;
      v17[4] = 0;
      *((_DWORD *)v17 + 10) = 0;
      v17 += 6;
    }
    while (v17 != &v16[6 * v5]);
LABEL_19:
    *(_QWORD *)(a1 + 8) = v16;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
  {
    v21 = 0;
    v22 = 0;
    do
    {
      NGaussianMixture::operator=(*(_QWORD *)(a1 + 8) + v21, *(_QWORD *)(a2 + 8) + v21);
      ++v22;
      v21 += 48;
    }
    while (v22 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NArray<NGaussianMixture>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = v7 - 16;
      v10 = *(_QWORD *)(v7 - 8);
      if (v10)
      {
        v11 = 48 * v10;
        v12 = v7 - 24;
        do
        {
          v13 = v12 + v11;
          *(_QWORD *)(v12 + v11) = &off_24C7F3090;
          v14 = *(_QWORD *)(v12 + v11 + 8);
          if (v14)
            MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
          *(_QWORD *)(v13 - 24) = &off_24C7F3100;
          v15 = *(_QWORD *)(v13 - 16);
          if (v15)
            MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
          v11 -= 48;
        }
        while (v11);
      }
      MEMORY[0x212BAC9C0](v9, 0x1090C806BD41B22);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v16 = 48 * v6;
    result = operator new[]();
    *(_QWORD *)result = 48;
    *(_QWORD *)(result + 8) = v6;
    v17 = result + 16;
    if (!v6)
      goto LABEL_18;
    v18 = result + 16;
    if ((unint64_t)(v16 - 48) >= 0x30)
    {
      v19 = (v16 - 48) / 0x30uLL + 1;
      v20 = (_DWORD *)(result + 104);
      v21 = v19 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v20 - 11) = &off_24C7F3100;
        *((_QWORD *)v20 - 10) = 0;
        *((_QWORD *)v20 - 5) = &off_24C7F3100;
        *((_QWORD *)v20 - 4) = 0;
        *(v20 - 18) = 0;
        *(v20 - 6) = 0;
        *((_QWORD *)v20 - 8) = &off_24C7F3090;
        *((_QWORD *)v20 - 7) = 0;
        *((_QWORD *)v20 - 2) = &off_24C7F3090;
        *((_QWORD *)v20 - 1) = 0;
        *(v20 - 12) = 0;
        *v20 = 0;
        v20 += 24;
        v21 -= 2;
      }
      while (v21);
      if (v19 == (v19 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_18;
      v18 = v17 + 48 * (v19 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v18 = &off_24C7F3100;
      *(_QWORD *)(v18 + 8) = 0;
      *(_DWORD *)(v18 + 16) = 0;
      *(_QWORD *)(v18 + 24) = &off_24C7F3090;
      *(_QWORD *)(v18 + 32) = 0;
      *(_DWORD *)(v18 + 40) = 0;
      v18 += 48;
    }
    while (v18 != v17 + 48 * v6);
LABEL_18:
    *(_QWORD *)(v4 + 8) = v17;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v22 = 0;
    v23 = 0;
    do
    {
      result = NGaussianMixture::operator=(*(_QWORD *)(v4 + 8) + v22, a2 + v22);
      ++v23;
      v22 += 48;
    }
    while (v23 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NGaussianMixture>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 48 * v3;
  result = operator new[]();
  *(_QWORD *)result = 48;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = result + 16;
    if ((unint64_t)(v7 - 48) >= 0x30)
    {
      v10 = (v7 - 48) / 0x30uLL + 1;
      v11 = (_DWORD *)(result + 104);
      v12 = v10 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v11 - 11) = &off_24C7F3100;
        *((_QWORD *)v11 - 10) = 0;
        *((_QWORD *)v11 - 5) = &off_24C7F3100;
        *((_QWORD *)v11 - 4) = 0;
        *(v11 - 18) = 0;
        *(v11 - 6) = 0;
        *((_QWORD *)v11 - 8) = &off_24C7F3090;
        *((_QWORD *)v11 - 7) = 0;
        *((_QWORD *)v11 - 2) = &off_24C7F3090;
        *((_QWORD *)v11 - 1) = 0;
        *(v11 - 12) = 0;
        *v11 = 0;
        v11 += 24;
        v12 -= 2;
      }
      while (v12);
      if (v10 == (v10 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_9;
      v9 = v8 + 48 * (v10 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v9 = &off_24C7F3100;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      *(_QWORD *)(v9 + 24) = &off_24C7F3090;
      *(_QWORD *)(v9 + 32) = 0;
      *(_DWORD *)(v9 + 40) = 0;
      v9 += 48;
    }
    while (v9 != v8 + 48 * v3);
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v8;
  if ((_DWORD)v2 && *a2)
  {
    v13 = 0;
    v14 = 1;
    do
    {
      result = NGaussianMixture::operator=(*(_QWORD *)(v5 + 8) + v13, v6 + v13);
      if (v14 >= v2)
        break;
      v13 += 48;
    }
    while (v14++ < *a2);
  }
  if (v6)
  {
    v16 = *(_QWORD *)(v6 - 8);
    if (v16)
    {
      v17 = 48 * v16;
      v18 = v6 - 24;
      do
      {
        v19 = v18 + v17;
        *(_QWORD *)(v18 + v17) = &off_24C7F3090;
        v20 = *(_QWORD *)(v18 + v17 + 8);
        if (v20)
          MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
        *(_QWORD *)(v19 - 24) = &off_24C7F3100;
        v21 = *(_QWORD *)(v19 - 16);
        if (v21)
          MEMORY[0x212BAC9C0](v21, 0x1000C8052888210);
        v17 -= 48;
      }
      while (v17);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

uint64_t NGaussianMixture::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  int *v24;
  int v25;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 16));
    }
    v10 = *(_DWORD *)(a1 + 40);
    v11 = *(_DWORD *)(a2 + 40);
    if (v10 != v11)
    {
      v12 = *(_QWORD *)(a1 + 32);
      if (v12)
      {
        MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
        v11 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(a1 + 40) = v11;
      *(_QWORD *)(a1 + 32) = operator new[]();
      v10 = *(_DWORD *)(a1 + 40);
    }
    if (v10)
    {
      v13 = 0;
      v14 = *(_QWORD *)(a2 + 32);
      v15 = *(_QWORD *)(a1 + 32);
      v16 = v10;
      if (v10 < 8)
        goto LABEL_19;
      if ((unint64_t)(v15 - v14) < 0x20)
        goto LABEL_19;
      v13 = v10 & 0xFFFFFFF8;
      v17 = (_OWORD *)(v15 + 16);
      v18 = (__int128 *)(v14 + 16);
      v19 = v16 & 0xFFFFFFF8;
      do
      {
        v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v13 != v16)
      {
LABEL_19:
        v21 = v16 - v13;
        v22 = 4 * v13;
        v23 = (_DWORD *)(v15 + v22);
        v24 = (int *)(v14 + v22);
        do
        {
          v25 = *v24++;
          *v23++ = v25;
          --v21;
        }
        while (v21);
      }
    }
  }
  return a1;
}

_QWORD *NArray<NGaussianMixture>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2D48;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 48 * v4;
      v6 = v2 - 24;
      do
      {
        v7 = v6 + v5;
        *(_QWORD *)(v6 + v5) = &off_24C7F3090;
        v8 = *(_QWORD *)(v6 + v5 + 8);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *(_QWORD *)(v7 - 24) = &off_24C7F3100;
        v9 = *(_QWORD *)(v7 - 16);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v5 -= 48;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x1090C806BD41B22);
  }
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2D48;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 48 * v4;
      v6 = v2 - 24;
      do
      {
        v7 = v6 + v5;
        *(_QWORD *)(v6 + v5) = &off_24C7F3090;
        v8 = *(_QWORD *)(v6 + v5 + 8);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *(_QWORD *)(v7 - 24) = &off_24C7F3100;
        v9 = *(_QWORD *)(v7 - 16);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v5 -= 48;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x1090C806BD41B22);
  }
  return a1;
}

void NArray<NGaussianMixture>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = &off_24C7F2D48;
  v1 = a1[1];
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = 48 * v3;
      v5 = v1 - 24;
      do
      {
        v6 = v5 + v4;
        *(_QWORD *)(v5 + v4) = &off_24C7F3090;
        v7 = *(_QWORD *)(v5 + v4 + 8);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        *(_QWORD *)(v6 - 24) = &off_24C7F3100;
        v8 = *(_QWORD *)(v6 - 16);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2, 0x1090C806BD41B22);
  }
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<NGaussian>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2E60;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 56 * v4;
      v6 = v2 - 24;
      do
      {
        v7 = v6 + v5;
        *(_QWORD *)(v6 + v5 - 8) = &off_24C7F3090;
        v8 = *(_QWORD *)(v6 + v5);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        *(_QWORD *)(v7 - 32) = &off_24C7F3090;
        v9 = *(_QWORD *)(v7 - 24);
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8052888210);
        v5 -= 56;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x1080C80D133DD60);
  }
  return a1;
}

void NArray<NGaussian>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = &off_24C7F2E60;
  v1 = a1[1];
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = 56 * v3;
      v5 = v1 - 24;
      do
      {
        v6 = v5 + v4;
        *(_QWORD *)(v5 + v4 - 8) = &off_24C7F3090;
        v7 = *(_QWORD *)(v5 + v4);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
        *(_QWORD *)(v6 - 32) = &off_24C7F3090;
        v8 = *(_QWORD *)(v6 - 24);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8052888210);
        v4 -= 56;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2, 0x1080C80D133DD60);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NGaussian>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;

  if (a1 == a2)
    return a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if (v4 != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      v7 = v6 - 16;
      v8 = *(_QWORD *)(v6 - 8);
      if (v8)
      {
        v9 = 56 * v8;
        v10 = v6 - 24;
        do
        {
          v11 = v10 + v9;
          *(_QWORD *)(v10 + v9 - 8) = &off_24C7F3090;
          v12 = *(_QWORD *)(v10 + v9);
          if (v12)
            MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
          *(_QWORD *)(v11 - 32) = &off_24C7F3090;
          v13 = *(_QWORD *)(v11 - 24);
          if (v13)
            MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
          v9 -= 56;
        }
        while (v9);
      }
      MEMORY[0x212BAC9C0](v7, 0x1080C80D133DD60);
      v5 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a1 + 16) = v5;
    v14 = 56 * v5;
    v15 = (_QWORD *)operator new[]();
    *v15 = 56;
    v15[1] = v5;
    v16 = v15 + 2;
    if (!v5)
      goto LABEL_19;
    v17 = v15 + 2;
    if ((unint64_t)(v14 - 56) >= 0x38)
    {
      v18 = (v14 - 56) / 0x38uLL + 1;
      v19 = v15 + 14;
      v20 = v18 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v19 - 12) = &off_24C7F3090;
        *((_QWORD *)v19 - 11) = 0;
        *((_QWORD *)v19 - 5) = &off_24C7F3090;
        *((_QWORD *)v19 - 4) = 0;
        *(v19 - 20) = 0;
        *(v19 - 6) = 0;
        *((_QWORD *)v19 - 9) = &off_24C7F3090;
        *((_QWORD *)v19 - 8) = 0;
        *((_QWORD *)v19 - 2) = &off_24C7F3090;
        *((_QWORD *)v19 - 1) = 0;
        *(v19 - 14) = 0;
        *v19 = 0;
        v19 += 28;
        v20 -= 2;
      }
      while (v20);
      if (v18 == (v18 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_19;
      v17 = &v16[7 * (v18 & 0xFFFFFFFFFFFFFFELL)];
    }
    do
    {
      *v17 = &off_24C7F3090;
      v17[1] = 0;
      *((_DWORD *)v17 + 4) = 0;
      v17[3] = &off_24C7F3090;
      v17[4] = 0;
      *((_DWORD *)v17 + 10) = 0;
      v17 += 7;
    }
    while (v17 != &v16[7 * v5]);
LABEL_19:
    *(_QWORD *)(a1 + 8) = v16;
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4)
  {
    v21 = 0;
    v22 = 0;
    do
    {
      NGaussian::operator=(*(_QWORD *)(a1 + 8) + v21, *(_QWORD *)(a2 + 8) + v21);
      ++v22;
      v21 += 56;
    }
    while (v22 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NArray<NGaussian>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = v7 - 16;
      v10 = *(_QWORD *)(v7 - 8);
      if (v10)
      {
        v11 = 56 * v10;
        v12 = v7 - 24;
        do
        {
          v13 = v12 + v11;
          *(_QWORD *)(v12 + v11 - 8) = &off_24C7F3090;
          v14 = *(_QWORD *)(v12 + v11);
          if (v14)
            MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
          *(_QWORD *)(v13 - 32) = &off_24C7F3090;
          v15 = *(_QWORD *)(v13 - 24);
          if (v15)
            MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
          v11 -= 56;
        }
        while (v11);
      }
      MEMORY[0x212BAC9C0](v9, 0x1080C80D133DD60);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v16 = 56 * v6;
    result = operator new[]();
    *(_QWORD *)result = 56;
    *(_QWORD *)(result + 8) = v6;
    v17 = result + 16;
    if (!v6)
      goto LABEL_18;
    v18 = result + 16;
    if ((unint64_t)(v16 - 56) >= 0x38)
    {
      v19 = (v16 - 56) / 0x38uLL + 1;
      v20 = (_DWORD *)(result + 112);
      v21 = v19 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v20 - 12) = &off_24C7F3090;
        *((_QWORD *)v20 - 11) = 0;
        *((_QWORD *)v20 - 5) = &off_24C7F3090;
        *((_QWORD *)v20 - 4) = 0;
        *(v20 - 20) = 0;
        *(v20 - 6) = 0;
        *((_QWORD *)v20 - 9) = &off_24C7F3090;
        *((_QWORD *)v20 - 8) = 0;
        *((_QWORD *)v20 - 2) = &off_24C7F3090;
        *((_QWORD *)v20 - 1) = 0;
        *(v20 - 14) = 0;
        *v20 = 0;
        v20 += 28;
        v21 -= 2;
      }
      while (v21);
      if (v19 == (v19 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_18;
      v18 = v17 + 56 * (v19 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v18 = &off_24C7F3090;
      *(_QWORD *)(v18 + 8) = 0;
      *(_DWORD *)(v18 + 16) = 0;
      *(_QWORD *)(v18 + 24) = &off_24C7F3090;
      *(_QWORD *)(v18 + 32) = 0;
      *(_DWORD *)(v18 + 40) = 0;
      v18 += 56;
    }
    while (v18 != v17 + 56 * v6);
LABEL_18:
    *(_QWORD *)(v4 + 8) = v17;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v22 = 0;
    v23 = 0;
    do
    {
      result = NGaussian::operator=(*(_QWORD *)(v4 + 8) + v22, a2 + v22);
      ++v23;
      v22 += 56;
    }
    while (v23 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NGaussian>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 == (_DWORD)v3)
    return result;
  v5 = result;
  v6 = *(_QWORD *)(result + 8);
  *(_DWORD *)(result + 16) = v3;
  v7 = 56 * v3;
  result = operator new[]();
  *(_QWORD *)result = 56;
  *(_QWORD *)(result + 8) = v3;
  v8 = result + 16;
  if ((_DWORD)v3)
  {
    v9 = result + 16;
    if ((unint64_t)(v7 - 56) >= 0x38)
    {
      v10 = (v7 - 56) / 0x38uLL + 1;
      v11 = (_DWORD *)(result + 112);
      v12 = v10 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *((_QWORD *)v11 - 12) = &off_24C7F3090;
        *((_QWORD *)v11 - 11) = 0;
        *((_QWORD *)v11 - 5) = &off_24C7F3090;
        *((_QWORD *)v11 - 4) = 0;
        *(v11 - 20) = 0;
        *(v11 - 6) = 0;
        *((_QWORD *)v11 - 9) = &off_24C7F3090;
        *((_QWORD *)v11 - 8) = 0;
        *((_QWORD *)v11 - 2) = &off_24C7F3090;
        *((_QWORD *)v11 - 1) = 0;
        *(v11 - 14) = 0;
        *v11 = 0;
        v11 += 28;
        v12 -= 2;
      }
      while (v12);
      if (v10 == (v10 & 0xFFFFFFFFFFFFFFELL))
        goto LABEL_9;
      v9 = v8 + 56 * (v10 & 0xFFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_QWORD *)v9 = &off_24C7F3090;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      *(_QWORD *)(v9 + 24) = &off_24C7F3090;
      *(_QWORD *)(v9 + 32) = 0;
      *(_DWORD *)(v9 + 40) = 0;
      v9 += 56;
    }
    while (v9 != v8 + 56 * v3);
  }
LABEL_9:
  *(_QWORD *)(v5 + 8) = v8;
  if ((_DWORD)v2 && *a2)
  {
    v13 = 0;
    v14 = 1;
    do
    {
      result = NGaussian::operator=(*(_QWORD *)(v5 + 8) + v13, v6 + v13);
      if (v14 >= v2)
        break;
      v13 += 56;
    }
    while (v14++ < *a2);
  }
  if (v6)
  {
    v16 = *(_QWORD *)(v6 - 8);
    if (v16)
    {
      v17 = 56 * v16;
      v18 = v6 - 24;
      do
      {
        v19 = v18 + v17;
        *(_QWORD *)(v18 + v17 - 8) = &off_24C7F3090;
        v20 = *(_QWORD *)(v18 + v17);
        if (v20)
          MEMORY[0x212BAC9C0](v20, 0x1000C8052888210);
        *(_QWORD *)(v19 - 32) = &off_24C7F3090;
        v21 = *(_QWORD *)(v19 - 24);
        if (v21)
          MEMORY[0x212BAC9C0](v21, 0x1000C8052888210);
        v17 -= 56;
      }
      while (v17);
    }
    JUMPOUT(0x212BAC9C0);
  }
  return result;
}

uint64_t NGaussian::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int *v34;
  int v35;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 8)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF8;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF8;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 4 * v7;
        v17 = (_DWORD *)(v9 + v16);
        v18 = (int *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    v20 = *(_DWORD *)(a1 + 40);
    v21 = *(_DWORD *)(a2 + 40);
    if (v20 != v21)
    {
      v22 = *(_QWORD *)(a1 + 32);
      if (v22)
      {
        MEMORY[0x212BAC9C0](v22, 0x1000C8052888210);
        v21 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(a1 + 40) = v21;
      *(_QWORD *)(a1 + 32) = operator new[]();
      v20 = *(_DWORD *)(a1 + 40);
    }
    if (v20)
    {
      v23 = 0;
      v24 = *(_QWORD *)(a2 + 32);
      v25 = *(_QWORD *)(a1 + 32);
      v26 = v20;
      if (v20 < 8)
        goto LABEL_24;
      if ((unint64_t)(v25 - v24) < 0x20)
        goto LABEL_24;
      v23 = v20 & 0xFFFFFFF8;
      v27 = (_OWORD *)(v25 + 16);
      v28 = (__int128 *)(v24 + 16);
      v29 = v26 & 0xFFFFFFF8;
      do
      {
        v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v23 != v26)
      {
LABEL_24:
        v31 = v26 - v23;
        v32 = 4 * v23;
        v33 = (_DWORD *)(v25 + v32);
        v34 = (int *)(v24 + v32);
        do
        {
          v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
    }
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  return a1;
}

float NGaussian::score(uint64_t a1, uint64_t a2)
{
  float v2;
  uint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;

  v2 = *(float *)(a1 + 48);
  v3 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v3)
  {
    v4 = *(float32x4_t **)(a2 + 8);
    v5 = *(float32x4_t **)(a1 + 8);
    v6 = *(float32x4_t **)(a1 + 32);
    if (v3 < 8)
    {
      v7 = 0;
LABEL_7:
      v16 = v3 - v7;
      v17 = v7;
      v18 = &v6->f32[v17];
      v19 = &v5->f32[v17];
      v20 = &v4->f32[v17];
      do
      {
        v21 = *v20++;
        v22 = v21;
        v23 = *v19++;
        v24 = (float)(v22 - v23) * (float)(v22 - v23);
        v25 = *v18++;
        v2 = v2 + (float)(v24 * v25);
        --v16;
      }
      while (v16);
      return v2 * -0.5;
    }
    v7 = v3 & 0xFFFFFFF8;
    v8 = v6 + 1;
    v9 = v5 + 1;
    v10 = v4 + 1;
    v11 = v7;
    do
    {
      v12 = vsubq_f32(v10[-1], v9[-1]);
      v13 = vsubq_f32(*v10, *v9);
      v14 = vmulq_f32(vmulq_f32(v12, v12), v8[-1]);
      v15 = vmulq_f32(vmulq_f32(v13, v13), *v8);
      v2 = (float)((float)((float)((float)((float)((float)((float)(v2 + v14.f32[0]) + v14.f32[1]) + v14.f32[2])
                                         + v14.f32[3])
                                 + v15.f32[0])
                         + v15.f32[1])
                 + v15.f32[2])
         + v15.f32[3];
      v8 += 2;
      v9 += 2;
      v10 += 2;
      v11 -= 8;
    }
    while (v11);
    if (v7 != v3)
      goto LABEL_7;
  }
  return v2 * -0.5;
}

void NGaussian::refreshOffset(NGaussian *this)
{
  uint64_t v1;
  float v2;
  float *v4;
  float v5;

  v1 = *((unsigned int *)this + 10);
  v2 = (double)v1 * 1.83787707;
  *((float *)this + 12) = v2;
  if ((_DWORD)v1)
  {
    v4 = (float *)*((_QWORD *)this + 4);
    do
    {
      v5 = *v4++;
      v2 = v2 - logf(v5);
      *((float *)this + 12) = v2;
      --v1;
    }
    while (v1);
  }
}

void NGaussianMixtureModels::NGaussianMixtureModels(NGaussianMixtureModels *this)
{
  _BYTE *v2;

  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_24C7F2838;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 3) = &off_24C7F2E60;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = &off_24C7F32C0;
  *((_DWORD *)this + 16) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 9) = v2;
  *v2 = 0;
}

{
  _BYTE *v2;

  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_24C7F2838;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 3) = &off_24C7F2E60;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = &off_24C7F32C0;
  *((_DWORD *)this + 16) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 9) = v2;
  *v2 = 0;
}

void sub_20D9C0568(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  NArray<NGaussian>::~NArray(v2);
  NArray<NGaussianMixture>::~NArray(v1);
  _Unwind_Resume(a1);
}

void sub_20D9C06F0(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v1[3] = v2;
  v4 = v1[4];
  if (v4)
  {
    v5 = v4 - 16;
    v6 = *(_QWORD *)(v4 - 8);
    if (v6)
    {
      v10 = 56 * v6;
      v11 = v4 - 24;
      do
      {
        v12 = v11 + v10;
        *(_QWORD *)(v11 + v10 - 8) = &off_24C7F3090;
        v13 = *(_QWORD *)(v11 + v10);
        if (v13)
          MEMORY[0x212BAC9C0](v13, 0x1000C8052888210);
        *(_QWORD *)(v12 - 32) = &off_24C7F3090;
        v14 = *(_QWORD *)(v12 - 24);
        if (v14)
          MEMORY[0x212BAC9C0](v14, 0x1000C8052888210);
        v10 -= 56;
      }
      while (v10);
    }
    MEMORY[0x212BAC9C0](v5, 0x1080C80D133DD60);
  }
  *v1 = &off_24C7F2D48;
  v7 = v1[1];
  if (v7)
  {
    v8 = v7 - 16;
    v9 = *(_QWORD *)(v7 - 8);
    if (v9)
    {
      v15 = 48 * v9;
      v16 = v7 - 24;
      do
      {
        v17 = v16 + v15;
        *(_QWORD *)(v16 + v15) = &off_24C7F3090;
        v18 = *(_QWORD *)(v16 + v15 + 8);
        if (v18)
          MEMORY[0x212BAC9C0](v18, 0x1000C8052888210);
        *(_QWORD *)(v17 - 24) = &off_24C7F3100;
        v19 = *(_QWORD *)(v17 - 16);
        if (v19)
          MEMORY[0x212BAC9C0](v19, 0x1000C8052888210);
        v15 -= 48;
      }
      while (v15);
    }
    MEMORY[0x212BAC9C0](v8, 0x1090C806BD41B22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianMixtureModels::read(NGaussianMixtureModels *this, const NString *a2)
{
  uint64_t v4;
  char **v5;
  const char *v6;
  _DWORD *v7;
  const char *v8;
  char *i;
  int v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  char *v20;
  unsigned int v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  uint64_t v27;
  BOOL v28;
  _WORD *v29;
  size_t v30;
  uint64_t v31;
  int *v33;
  char *v34;
  unsigned int v35;
  uint64_t v36;
  void *v37;
  int v38;
  uint64_t v39;
  const char *v40;
  size_t v41;
  uint64_t v42;
  void *v43;
  int v44;
  char *v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t v49;
  _BYTE *v50;
  char *v51;
  unsigned int v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  unsigned int v58;
  const char *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float v64;
  char *v65;
  uint64_t v66;
  _QWORD *v67;
  unint64_t v68;
  uint64_t v69;
  _BYTE *v70;
  char *v71;
  unsigned int v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  const char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  float v83;
  uint64_t v84;
  const char *v85;
  uint64_t v86;
  char *v87;
  float *v88;
  float v89;
  uint64_t v90;
  const char *v91;
  uint64_t v92;
  char *v93;
  float *v94;
  float v95;
  uint64_t v96;
  const char *v97;
  uint64_t v98;
  char *v99;
  size_t v100;
  uint64_t v101;
  char *v102;
  unsigned int v103;
  uint64_t v104;
  void *v105;
  size_t v106;
  uint64_t v107;
  _BYTE *v108;
  _BOOL4 v110;
  size_t v111;
  uint64_t v112;
  char *v114;
  unsigned int v115;
  uint64_t v116;
  void *v117;
  int v118;
  uint64_t v119;
  const char *v120;
  size_t v121;
  uint64_t v122;
  void *v123;
  int v124;
  const char *v125;
  size_t v126;
  uint64_t v127;
  char *v129;
  char *v130;
  unsigned int v131;
  uint64_t v132;
  void *v133;
  unsigned int v134;
  const char *v135;
  uint64_t v136;
  _QWORD *v137;
  unint64_t v138;
  uint64_t v139;
  _BYTE *v140;
  unsigned int v141;
  char *v142;
  unsigned int v143;
  unsigned int v144;
  _QWORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _QWORD *v149;
  uint64_t v150;
  _BYTE *v151;
  _QWORD *v152;
  _QWORD *v153;
  uint64_t v154;
  _QWORD *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  char *v159;
  _QWORD *v160;
  const char *v161;
  unint64_t v162;
  const char **v163;
  const char *v164;
  uint64_t v165;
  _QWORD *v166;
  unint64_t v167;
  uint64_t v168;
  _BYTE *v169;
  unsigned int v170;
  char *v171;
  unsigned int v172;
  unsigned int v173;
  _QWORD *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  _QWORD *v178;
  uint64_t v179;
  _BYTE *v180;
  _QWORD *v181;
  _QWORD *v182;
  uint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  _QWORD *v188;
  const char *v189;
  char *v190;
  unint64_t v191;
  const char **v192;
  const char *v193;
  float v194;
  uint64_t v195;
  float v196;
  float v197;
  double v198;
  uint64_t v199;
  const char *v200;
  uint64_t v201;
  float v202;
  char *v203;
  float *v204;
  float v205;
  double v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  size_t v210;
  uint64_t v211;
  BOOL v212;
  _BYTE *v213;
  _BOOL4 v215;
  unsigned int v216;
  uint64_t v217;
  unsigned __int16 *v218;
  int v219;
  unsigned int v220;
  uint64_t v221;
  int v222;
  BOOL v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  const char *v228;
  const char *v229;
  const char *v230;
  const char *v231;
  uint64_t v232;
  unint64_t v233;
  const char *v234;
  uint64_t v235;
  const char *v236;
  uint64_t v237;
  const char *v238;
  const NString *v239;
  const char *v240;
  uint64_t v241;
  unint64_t v242;
  const char *v243;
  int v244;
  const char *v245;
  int v246;
  uint64_t v247;
  const char *v248;
  uint64_t v249;
  int v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  float v256;
  float *v257;
  float *v258;
  float v259;
  uint64_t result;
  unint64_t v261;
  const char *v262;
  char *v263;
  char *v264;
  char *v265;
  char *v266;
  const char *v267;
  Error *v268;
  char *v269;
  char *v270;
  const NString *v271;
  char **v272;
  int v273;
  int v274;
  unsigned int v275;
  unsigned int v276;
  int *v277;
  uint64_t v278;
  unsigned int v279;
  uint64_t (**v280)(NString *__hidden, const unsigned int *);
  int v281;
  char *v282;
  unsigned int v283;
  char *v284;
  _QWORD *v285;
  char *v286;
  char *__endptr;
  char *v288;
  _WORD *v289;
  unsigned int v290;
  char *v291;
  _QWORD *v292;
  unsigned int v293;
  uint64_t (**v294)();
  uint64_t v295;
  int v296;
  uint64_t (**v297)(NString *__hidden, const unsigned int *);
  unsigned int v298;
  uint64_t v299;
  uint64_t (**v300)(NString *__hidden, const unsigned int *);
  int v301;
  _QWORD *v302;
  uint64_t (**v303)();
  uint64_t v304;

  __endptr = (char *)&off_24C7F32C0;
  LODWORD(v288) = 1;
  v289 = (_WORD *)operator new[]();
  *v289 = 114;
  v303 = (uint64_t (**)())&off_24C7F33E0;
  v304 = 0;
  NFilePtr::open((NFilePtr *)&v303, a2, (const NString *)&__endptr);
  __endptr = (char *)&off_24C7F32C0;
  if (v289)
    MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
  LODWORD(__endptr) = 0;
  (*(void (**)(NGaussianMixtureModels *, char **))(*(_QWORD *)this + 32))(this, &__endptr);
  LODWORD(__endptr) = 0;
  NArray<NGaussian>::resize((uint64_t)this + 24, &__endptr);
  v5 = (char **)((char *)this + 56);
  v4 = *((_QWORD *)this + 7);
  LODWORD(__endptr) = 0;
  (*(void (**)(char *, const char *, char **))(v4 + 64))((char *)this + 56, "", &__endptr);
  *((_DWORD *)this + 12) = 0;
  v7 = (_DWORD *)((char *)this + 48);
  if (!v304)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
  LODWORD(__endptr) = 13;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char **))(*(_QWORD *)v304 + 64))(&v300, v304, &__endptr);
  if (v301 != 13)
    goto LABEL_486;
  if (*v302 == 0x206258494D472023 && *(_QWORD *)((char *)v302 + 5) == 0x30302E3176206258)
  {
    if (!v304)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    (*(void (**)(char **__return_ptr))(*(_QWORD *)v304 + 88))(&__endptr);
    if (v5 != &__endptr)
      (*((void (**)(char *, _WORD *, char **))*v5 + 8))((char *)this + 56, v289, &v288);
    __endptr = (char *)&off_24C7F32C0;
    if (v289)
      MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
    if (!v304)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v228);
    LODWORD(v297) = 4;
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v297);
    if ((_DWORD)v288 != 4)
    {
      *v7 = 0;
      __endptr = (char *)&off_24C7F32C0;
      if (v289)
        MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
      v265 = "NGaussianMixtureModels::read() - failed to read dim from file %s";
LABEL_487:
      Error::chuck((Error *)v265, v8, *((_QWORD *)a2 + 2));
    }
    *v7 = *(_DWORD *)v289;
    __endptr = (char *)&off_24C7F32C0;
    MEMORY[0x212BAC9C0]();
    if (!v304)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v229);
    LODWORD(v297) = 4;
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v297);
    if ((_DWORD)v288 != 4)
    {
      __endptr = (char *)&off_24C7F32C0;
      if (v289)
        MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
      Error::chuck((Error *)"NGaussianMixtureModels::read() - failed to read number of gaussians from file %s", v230, *((_QWORD *)a2 + 2));
    }
    LODWORD(v294) = *(_DWORD *)v289;
    __endptr = (char *)&off_24C7F32C0;
    MEMORY[0x212BAC9C0]();
    NArray<NGaussian>::resize((uint64_t)this + 24, &v294);
    if (*((_DWORD *)this + 10))
    {
      v232 = 0;
      v233 = 0;
      while (1)
      {
        if (!v304)
          Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v231);
        LODWORD(v291) = 4 * *v7;
        (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v291);
        if ((v288 & 3) != 0)
          break;
        v235 = *((_QWORD *)this + 4) + v232;
        LODWORD(v297) = v288 >> 2;
        (*(void (**)(uint64_t, _WORD *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v235 + 24))(v235, v289, &v297);
        __endptr = (char *)&off_24C7F32C0;
        if (v289)
          MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
        if (!v304)
          Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v236);
        LODWORD(v291) = 4 * *v7;
        (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v291);
        if ((v288 & 3) != 0)
        {
          __endptr = (char *)&off_24C7F32C0;
          if (v289)
            MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
          v263 = "NGaussianMixtureModels::read() - failed to read gaussian invar %d from file %s";
          goto LABEL_457;
        }
        v237 = *((_QWORD *)this + 4);
        LODWORD(v297) = v288 >> 2;
        (*(void (**)(uint64_t, _WORD *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)(v237 + v232 + 24) + 24))(v237 + v232 + 24, v289, &v297);
        __endptr = (char *)&off_24C7F32C0;
        if (v289)
          MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
        ++v233;
        v232 += 56;
        if (v233 >= *((unsigned int *)this + 10))
          goto LABEL_401;
      }
      __endptr = (char *)&off_24C7F32C0;
      if (v289)
        MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
      v263 = "NGaussianMixtureModels::read() - failed to read gaussian mean %d from file %s";
LABEL_457:
      Error::chuck((Error *)v263, v234, v233, *((_QWORD *)a2 + 2));
    }
LABEL_401:
    LODWORD(v291) = 0;
    if (!v304)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v231);
    LODWORD(v297) = 4;
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v297);
    v239 = a2;
    if ((_DWORD)v288 == 4)
    {
      LODWORD(v291) = *(_DWORD *)v289;
      __endptr = (char *)&off_24C7F32C0;
      MEMORY[0x212BAC9C0]();
      (*(void (**)(NGaussianMixtureModels *, char **))(*(_QWORD *)this + 32))(this, &v291);
      if (*((_DWORD *)this + 4))
      {
        v241 = 0;
        v242 = 0;
        while (1)
        {
          if (!v304)
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v240);
          LODWORD(v297) = 4;
          (*(void (**)(char **__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v297);
          if ((_DWORD)v288 != 4)
            break;
          v244 = *(_DWORD *)v289;
          __endptr = (char *)&off_24C7F32C0;
          MEMORY[0x212BAC9C0]();
          if (!v304)
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v245);
          v246 = 4 * v244;
          LODWORD(v284) = v246;
          (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v284);
          if ((v288 & 3) != 0)
          {
            __endptr = (char *)&off_24C7F32C0;
            if (v289)
              MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
            v264 = "NGaussianMixtureModels::read() - failed to read gaussian indexes of mix %d from file %s";
            goto LABEL_470;
          }
          v247 = *((_QWORD *)this + 1) + v241;
          LODWORD(v297) = v288 >> 2;
          (*(void (**)(uint64_t, _WORD *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v247 + 24))(v247, v289, &v297);
          __endptr = (char *)&off_24C7F32C0;
          if (v289)
            MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
          if (!v304)
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v248);
          LODWORD(v284) = v246;
          (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 64))(&__endptr, v304, &v284);
          if ((v288 & 3) != 0)
          {
            __endptr = (char *)&off_24C7F32C0;
            if (v289)
              MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
            v264 = "NGaussianMixtureModels::read() - failed to read mixture weights of mix %d from file %s";
            goto LABEL_470;
          }
          v249 = *((_QWORD *)this + 1);
          LODWORD(v297) = v288 >> 2;
          (*(void (**)(uint64_t, _WORD *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)(v249 + v241 + 24) + 24))(v249 + v241 + 24, v289, &v297);
          __endptr = (char *)&off_24C7F32C0;
          if (v289)
            MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
          ++v242;
          v241 += 48;
          if (v242 >= *((unsigned int *)this + 4))
            goto LABEL_416;
        }
        __endptr = (char *)&off_24C7F32C0;
        if (v289)
          MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
        v264 = "NGaussianMixtureModels::read() - failed to read number of components of mix %d from file %s";
LABEL_470:
        Error::chuck((Error *)v264, v243, v242, *((_QWORD *)v239 + 2));
      }
LABEL_416:
      if (!v304)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v240);
      (*(void (**)(char **__return_ptr))(*(_QWORD *)v304 + 56))(&__endptr);
      v250 = (int)v288;
      __endptr = (char *)&off_24C7F32C0;
      if (v289)
        MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
      if (!v250)
        goto LABEL_420;
      v266 = "NGaussianMixtureModels::read() - extra junk at end of file %s";
    }
    else
    {
      LODWORD(v291) = 0;
      __endptr = (char *)&off_24C7F32C0;
      if (v289)
        MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
      v266 = "NGaussianMixtureModels::read() - failed to read number of mixtures from file %s";
    }
    Error::chuck((Error *)v266, v238, *((_QWORD *)v239 + 2));
  }
  if (*v302 != 0x206158494D472023 || *(_QWORD *)((char *)v302 + 5) != 0x30302E3176206158)
  {
LABEL_486:
    v265 = "NGaussianMixtureModels::read() - Could not read gmix cookie from %s";
    goto LABEL_487;
  }
  v272 = (char **)((char *)this + 56);
  v271 = a2;
  v297 = &off_24C7F32C0;
  v298 = 0;
  LODWORD(v278) = 0;
  v299 = operator new[]();
  *(_BYTE *)v299 = 0;
  v12 = 1;
  v294 = &off_24C7F2E28;
  v295 = 0;
  v296 = 0;
  v268 = (Error *)"NGaussianMixtureModels::read() - extra junk at end of file %s on line %d";
  v273 = 1;
  v274 = 2;
  v269 = "NGaussianMixtureModels::read() - mixture weight vector parse failed in file %s on line %d";
  v270 = "NGaussianMixtureModels::read() - variance vector parse failed in file %s on line %d";
  v277 = (int *)((char *)this + 48);
  while (1)
  {
LABEL_17:
    if (!v304)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", i);
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v304 + 48))(v304))
      break;
    if (!v304)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v13);
    LOBYTE(v291) = 35;
    (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v291);
    ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
    __endptr = (char *)&off_24C7F32C0;
    if (v289)
      MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
    v284 = (char *)&off_24C7F32C0;
    LODWORD(v285) = 4;
    v14 = (char *)operator new[]();
    strcpy(v14, "\r\n\t ");
    LODWORD(v280) = -1;
    v286 = v14;
    __endptr = (char *)off_24C7F13C0;
    v288 = 0;
    v289 = 0;
    v290 = 0;
    NString::split((uint64_t)&v297, (uint64_t)&__endptr, (uint64_t)&v284, (unsigned int *)&v280);
    v291 = (char *)&off_24C7F2E28;
    v15 = v290;
    v16 = (_QWORD *)operator new[]();
    *v16 = 24;
    v16[1] = v15;
    if ((_DWORD)v15)
    {
      v17 = 0;
      v18 = 24 * v15;
      do
      {
        v16[v17 / 8 + 2] = &off_24C7F32C0;
        LODWORD(v16[v17 / 8 + 3]) = 0;
        v19 = (_BYTE *)operator new[]();
        v16[v17 / 8 + 4] = v19;
        *v19 = 0;
        v17 += 24;
      }
      while (v18 != v17);
    }
    v292 = v16 + 2;
    v293 = v290;
    v20 = v288;
    if (v288)
    {
      v21 = 0;
      do
      {
        (*(void (**)(_QWORD *, char *))(v292[3 * v21] + 32))(&v292[3 * v21], v20 + 16);
        ++v21;
        v20 = (char *)*((_QWORD *)v20 + 1);
      }
      while (v20);
    }
    NArray<NString>::operator=((uint64_t)&v294, (uint64_t)&v291);
    v291 = (char *)&off_24C7F2E28;
    v22 = v292;
    if (v292)
    {
      v23 = *(v292 - 1);
      if (v23)
      {
        v24 = 3 * v23;
        do
        {
          v22[v24 - 3] = &off_24C7F32C0;
          v25 = v22[v24 - 1];
          if (v25)
            MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
          v24 -= 3;
        }
        while (v24 * 8);
      }
      MEMORY[0x212BAC9C0](v22 - 2, 0x1091C800F2A5985);
    }
    __endptr = (char *)off_24C7F13C0;
    for (i = v288; v288; i = v288)
    {
      v288 = (char *)*((_QWORD *)i + 1);
      (*((void (**)(uint64_t, uint64_t))__endptr + 9))((uint64_t)&__endptr, (uint64_t)i);
    }
    v289 = 0;
    v290 = 0;
    if (v286)
      MEMORY[0x212BAC9C0](v286, 0x1000C8077774924);
    v278 = (v278 + 1);
    if (v296)
    {
      switch(v12)
      {
        case 1:
          v26 = v298 - 6;
          if (v298 < 6
            || ((v27 = v299, *(_DWORD *)v299 == 1313162313)
              ? (v28 = *(unsigned __int16 *)(v299 + 4) == 15700)
              : (v28 = 0),
                !v28))
          {
            Error::chuck((Error *)"NGaussianMixtureModels::read() - no IDENT= field in file %s on line %d", i, *((_QWORD *)v271 + 2), v278);
          }
          __endptr = (char *)&off_24C7F32C0;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          LODWORD(v288) = v298 - 6;
          v29 = (_WORD *)operator new[]();
          v289 = v29;
          memcpy(v29, (const void *)(v27 + 6), v26);
          *((_BYTE *)v29 + v26) = 0;
          if (v272 == &__endptr)
          {
            __endptr = (char *)&off_24C7F32C0;
          }
          else
          {
            (*((void (**)(char **, _WORD *, char **))*v272 + 8))(v272, v29, &v288);
            v29 = v289;
            __endptr = (char *)&off_24C7F32C0;
            if (!v289)
              goto LABEL_370;
          }
          MEMORY[0x212BAC9C0](v29, 0x1000C8077774924);
LABEL_370:
          v12 = 2;
          continue;
        case 2:
          v100 = v298 - 4;
          if (v298 < 4)
            goto LABEL_507;
          v101 = v299;
          if (*(_DWORD *)v299 != 1028475204)
            goto LABEL_507;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v33 = (int *)operator new[]();
          memcpy(v33, (const void *)(v101 + 4), v100);
          *((_BYTE *)v33 + v100) = 0;
          if (!(_DWORD)v100)
          {
            v267 = "NGaussianMixtureModels::read() - no valid DIM= field in file %s on line %d";
            goto LABEL_530;
          }
          __endptr = 0;
          strtoul((const char *)v33, &__endptr, 10);
          v102 = __endptr;
          MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
          if (v102 != (char *)v33 + v100)
LABEL_507:
            Error::chuck((Error *)"NGaussianMixtureModels::read() - no valid DIM= field in file %s on line %d", i, *((_QWORD *)v271 + 2), v278);
          v103 = v298;
          if (v298 <= 3)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", i, 4, v298);
          v104 = v299;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v105 = (void *)operator new[]();
          memcpy(v105, (const void *)(v104 + 4), v103 - 4);
          *((_BYTE *)v105 + v103 - 4) = 0;
          *v277 = strtoul((const char *)v105, 0, 10);
          MEMORY[0x212BAC9C0](v105, 0x1000C8077774924);
          v12 = 3;
          continue;
        case 3:
          v106 = v298 - 8;
          if (v298 < 8 || (v107 = v299, *(_QWORD *)v299 != 0x3D45505954524156))
            Error::chuck((Error *)"NGaussianMixtureModels::read() - no VARTYPE= field in file %s on line %d", i, *((_QWORD *)v271 + 2), v278);
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v108 = (_BYTE *)operator new[]();
          memcpy(v108, (const void *)(v107 + 8), v106);
          v108[v106] = 0;
          if ((_DWORD)v106 == 5)
          {
            v110 = *(_DWORD *)v108 != 1096175177 || v108[4] != 82;
            MEMORY[0x212BAC9C0](v108, 0x1000C8077774924);
            v274 = 2;
            v12 = 4;
            if (!v110)
              continue;
          }
          else
          {
            MEMORY[0x212BAC9C0](v108, 0x1000C8077774924);
          }
          v216 = v298;
          if (v298 <= 7)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", i, 8, v298);
          v217 = v299;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v218 = (unsigned __int16 *)operator new[]();
          memcpy(v218, (const void *)(v217 + 8), v216 - 8);
          *((_BYTE *)v218 + v216 - 8) = 0;
          if (v216 == 10)
          {
            v219 = *v218;
            MEMORY[0x212BAC9C0](v218, 0x1000C8077774924);
            v274 = 1;
            v12 = 4;
            if (v219 == 17491)
              continue;
          }
          else
          {
            MEMORY[0x212BAC9C0](v218, 0x1000C8077774924);
          }
          LODWORD(v291) = 8;
          NString::tail((NString *)&v297, (const char *)&v291, (uint64_t)&__endptr);
          v223 = NString::operator==((uint64_t)&__endptr, "VAR");
          if (v289)
            MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
          v274 = 0;
          v12 = 4;
          if (!v223)
            Error::chuck((Error *)"NGaussianMixtureModels::read() - invalid VARTYPE= field in file %s on line %d (INVAR, SD or VAR)", i, *((_QWORD *)v271 + 2), v278);
          continue;
        case 4:
          v30 = v298 - 11;
          if (v298 < 0xB)
            goto LABEL_509;
          v31 = v299;
          if (*(_QWORD *)v299 != 0x414953535541474ELL || *(_QWORD *)(v299 + 3) != 0x3D534E4149535355)
            goto LABEL_509;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v33 = (int *)operator new[]();
          memcpy(v33, (const void *)(v31 + 11), v30);
          *((_BYTE *)v33 + v30) = 0;
          if (!(_DWORD)v30)
          {
            v267 = "NGaussianMixtureModels::read() - no valid NGAUSSIANS= field in file %s on line %d";
            goto LABEL_530;
          }
          __endptr = 0;
          strtoul((const char *)v33, &__endptr, 10);
          v34 = __endptr;
          MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
          if (v34 != (char *)v33 + v30)
LABEL_509:
            Error::chuck((Error *)"NGaussianMixtureModels::read() - no valid NGAUSSIANS= field in file %s on line %d", i, *((_QWORD *)v271 + 2), v278);
          v35 = v298;
          if (v298 <= 0xA)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", i, 11, v298);
          v36 = v299;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v37 = (void *)operator new[]();
          memcpy(v37, (const void *)(v36 + 11), v35 - 11);
          *((_BYTE *)v37 + v35 - 11) = 0;
          v38 = strtoul((const char *)v37, 0, 10);
          MEMORY[0x212BAC9C0](v37, 0x1000C8077774924);
          LODWORD(__endptr) = v38;
          NArray<NGaussian>::resize((uint64_t)this + 24, &__endptr);
LABEL_62:
          v12 = 6;
          if (*((_DWORD *)this + 10))
          {
            v39 = 0;
            while (1)
            {
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", i);
              LOBYTE(v291) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v291);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v41 = v298 - 2;
              if (v298 < 2)
                goto LABEL_447;
              v42 = v299;
              if (*(_WORD *)v299 != 15687)
                goto LABEL_447;
              if (!v299)
                Error::chuck((Error *)"Null pointer passed to string constructor", v40);
              v43 = (void *)operator new[]();
              memcpy(v43, (const void *)(v42 + 2), v41);
              *((_BYTE *)v43 + v41) = 0;
              v44 = strtoul((const char *)v43, 0, 10);
              MEMORY[0x212BAC9C0](v43, 0x1000C8077774924);
              if (v39 != v44)
LABEL_447:
                Error::chuck((Error *)"NGaussianMixtureModels::read() - no or incorrect G=%d field in file %s on line %d", v40, v39, *((_QWORD *)v271 + 2), (v278 + 1));
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v40);
              LOBYTE(v291) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v291);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v284 = (char *)&off_24C7F32C0;
              LODWORD(v285) = 2;
              v45 = (char *)operator new[]();
              strcpy(v45, " ,");
              LODWORD(v280) = -1;
              v286 = v45;
              __endptr = (char *)off_24C7F13C0;
              v288 = 0;
              v289 = 0;
              v290 = 0;
              NString::split((uint64_t)&v297, (uint64_t)&__endptr, (uint64_t)&v284, (unsigned int *)&v280);
              v291 = (char *)&off_24C7F2E28;
              v46 = v290;
              v47 = (_QWORD *)operator new[]();
              *v47 = 24;
              v47[1] = v46;
              if ((_DWORD)v46)
              {
                v48 = 0;
                v49 = 24 * v46;
                do
                {
                  v47[v48 / 8 + 2] = &off_24C7F32C0;
                  LODWORD(v47[v48 / 8 + 3]) = 0;
                  v50 = (_BYTE *)operator new[]();
                  v47[v48 / 8 + 4] = v50;
                  *v50 = 0;
                  v48 += 24;
                }
                while (v49 != v48);
              }
              v292 = v47 + 2;
              v293 = v290;
              v51 = v288;
              if (v288)
              {
                v52 = 0;
                do
                {
                  (*(void (**)(_QWORD *, char *))(v292[3 * v52] + 32))(&v292[3 * v52], v51 + 16);
                  ++v52;
                  v51 = (char *)*((_QWORD *)v51 + 1);
                }
                while (v51);
              }
              NArray<NString>::operator=((uint64_t)&v294, (uint64_t)&v291);
              v291 = (char *)&off_24C7F2E28;
              v53 = v292;
              if (v292)
              {
                v54 = *(v292 - 1);
                if (v54)
                {
                  v55 = 3 * v54;
                  do
                  {
                    v53[v55 - 3] = &off_24C7F32C0;
                    v56 = v53[v55 - 1];
                    if (v56)
                      MEMORY[0x212BAC9C0](v56, 0x1000C8077774924);
                    v55 -= 3;
                  }
                  while (v55 * 8);
                }
                MEMORY[0x212BAC9C0](v53 - 2, 0x1091C800F2A5985);
              }
              for (__endptr = (char *)off_24C7F13C0;
                    ;
                    (*((void (**)(uint64_t, uint64_t))__endptr + 9))((uint64_t)&__endptr, (uint64_t)v57))
              {
                v57 = v288;
                if (!v288)
                  break;
                v288 = (char *)*((_QWORD *)v288 + 1);
              }
              v289 = 0;
              v290 = 0;
              if (v286)
                MEMORY[0x212BAC9C0](v286, 0x1000C8077774924);
              if (v296 != *v277 + 2
                || *(_DWORD *)(v295 + 8) != 1
                || **(_BYTE **)(v295 + 16) != 91
                || (v58 = *v277 + 1, *(_DWORD *)(v295 + 24 * v58 + 8) != 1)
                || **(_BYTE **)(v295 + 24 * v58 + 16) != 93)
              {
                v278 = (v278 + 2);
                v270 = "NGaussianMixtureModels::read() - mean vector parse failed in file %s on line %d";
LABEL_444:
                Error::chuck((Error *)v270, v57, *((_QWORD *)v271 + 2), v278);
              }
              (*(void (**)(uint64_t, int *))(*(_QWORD *)(*((_QWORD *)this + 4) + 56 * v39) + 32))(*((_QWORD *)this + 4) + 56 * v39, v277);
              if (*v277)
              {
                v60 = 0;
                v61 = 0;
                v62 = v295;
                do
                {
                  v63 = v62 + v60;
                  if (!*(_DWORD *)(v62 + v60 + 32)
                    || (__endptr = 0,
                        strtod(*(const char **)(v63 + 40), &__endptr),
                        __endptr != (char *)(*(_QWORD *)(v63 + 40) + *(unsigned int *)(v63 + 32))))
                  {
                    Error::chuck((Error *)"NGaussianMixtureModels::read() - mean vector parse failed in file %s on line %d (item %d is invalid float)", v59, *((_QWORD *)v271 + 2), (v278 + 2), v61);
                  }
                  v62 = v295;
                  v64 = atof(*(const char **)(v295 + v60 + 40));
                  *(float *)(*(_QWORD *)(*((_QWORD *)this + 4) + 56 * v39 + 8) + 4 * v61) = v64;
                  v60 += 24;
                  ++v61;
                }
                while (v61 < *((unsigned int *)this + 12));
              }
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v59);
              LOBYTE(v291) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v291);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v284 = (char *)&off_24C7F32C0;
              LODWORD(v285) = 2;
              v65 = (char *)operator new[]();
              strcpy(v65, " ,");
              LODWORD(v280) = -1;
              v286 = v65;
              __endptr = (char *)off_24C7F13C0;
              v288 = 0;
              v289 = 0;
              v290 = 0;
              NString::split((uint64_t)&v297, (uint64_t)&__endptr, (uint64_t)&v284, (unsigned int *)&v280);
              v291 = (char *)&off_24C7F2E28;
              v66 = v290;
              v67 = (_QWORD *)operator new[]();
              *v67 = 24;
              v67[1] = v66;
              if ((_DWORD)v66)
              {
                v68 = 0;
                v69 = 24 * v66;
                do
                {
                  v67[v68 / 8 + 2] = &off_24C7F32C0;
                  LODWORD(v67[v68 / 8 + 3]) = 0;
                  v70 = (_BYTE *)operator new[]();
                  v67[v68 / 8 + 4] = v70;
                  *v70 = 0;
                  v68 += 24;
                }
                while (v69 != v68);
              }
              v292 = v67 + 2;
              v293 = v290;
              v71 = v288;
              if (v288)
              {
                v72 = 0;
                do
                {
                  (*(void (**)(_QWORD *, char *))(v292[3 * v72] + 32))(&v292[3 * v72], v71 + 16);
                  ++v72;
                  v71 = (char *)*((_QWORD *)v71 + 1);
                }
                while (v71);
              }
              NArray<NString>::operator=((uint64_t)&v294, (uint64_t)&v291);
              v291 = (char *)&off_24C7F2E28;
              v73 = v292;
              if (v292)
              {
                v74 = *(v292 - 1);
                if (v74)
                {
                  v75 = 3 * v74;
                  do
                  {
                    v73[v75 - 3] = &off_24C7F32C0;
                    v76 = v73[v75 - 1];
                    if (v76)
                      MEMORY[0x212BAC9C0](v76, 0x1000C8077774924);
                    v75 -= 3;
                  }
                  while (v75 * 8);
                }
                MEMORY[0x212BAC9C0](v73 - 2, 0x1091C800F2A5985);
              }
              for (__endptr = (char *)off_24C7F13C0;
                    ;
                    (*((void (**)(uint64_t, uint64_t))__endptr + 9))((uint64_t)&__endptr, (uint64_t)v57))
              {
                v57 = v288;
                if (!v288)
                  break;
                v288 = (char *)*((_QWORD *)v288 + 1);
              }
              v289 = 0;
              v290 = 0;
              if (v286)
                MEMORY[0x212BAC9C0](v286, 0x1000C8077774924);
              v77 = *v277;
              v278 = (v278 + 3);
              if (v296 != *v277 + 2
                || *(_DWORD *)(v295 + 8) != 1
                || **(_BYTE **)(v295 + 16) != 91
                || *(_DWORD *)(v295 + 24 * (v77 + 1) + 8) != 1
                || **(_BYTE **)(v295 + 24 * (v77 + 1) + 16) != 93)
              {
                goto LABEL_444;
              }
              __endptr = (char *)&off_24C7F3090;
              v288 = (char *)operator new[]();
              LODWORD(v289) = *v277;
              if ((_DWORD)v289)
              {
                v79 = 0;
                v80 = 0;
                v81 = v295;
                do
                {
                  v82 = v81 + v79;
                  if (!*(_DWORD *)(v82 + 32)
                    || (v291 = 0,
                        strtod(*(const char **)(v82 + 40), &v291),
                        v291 != (char *)(*(_QWORD *)(v82 + 40) + *(unsigned int *)(v82 + 32))))
                  {
                    Error::chuck((Error *)"NGaussianMixtureModels::read() - var vector parse failed in file %s on line %d (item %d is invalid float)", v78, *((_QWORD *)v271 + 2), v278, v80);
                  }
                  v81 = v295;
                  v83 = atof(*(const char **)(v295 + v79 + 40));
                  *(float *)&v288[4 * v80] = v83;
                  v79 += 24;
                  ++v80;
                }
                while (v80 < *v277);
              }
              if (v274 == 1)
              {
                v291 = (char *)&off_24C7F3090;
                v90 = operator new[]();
                v292 = (_QWORD *)v90;
                v92 = v289;
                v293 = v289;
                if ((_DWORD)v289)
                {
                  v93 = v288;
                  v94 = (float *)v90;
                  do
                  {
                    v95 = *(float *)v93;
                    if (*(float *)v93 <= 0.0)
                      Error::chuck((Error *)"NGaussianMixtureModels::invertSquareVars() - bad value %f in variance vector", v91, v95);
                    *v94++ = 1.0 / (float)(v95 * v95);
                    v93 += 4;
                    --v92;
                  }
                  while (v92);
                }
              }
              else
              {
                if (v274)
                {
                  v96 = operator new[]();
                  v98 = v289;
                  if ((_DWORD)v289)
                  {
                    v99 = v288;
                    do
                    {
                      if (*(float *)v99 <= 0.0)
                        Error::chuck((Error *)"NGaussianMixtureModels::validateVars() - bad value %f in variance vector", v97, *(float *)v99);
                      v99 += 4;
                      --v98;
                    }
                    while (v98);
                  }
                  MEMORY[0x212BAC9C0](v96, 0x1000C8052888210);
                  (*(void (**)(uint64_t, char **))(*(_QWORD *)(*((_QWORD *)this + 4) + 56 * v39 + 24) + 16))(*((_QWORD *)this + 4) + 56 * v39 + 24, &__endptr);
                  goto LABEL_152;
                }
                v291 = (char *)&off_24C7F3090;
                v84 = operator new[]();
                v292 = (_QWORD *)v84;
                v86 = v289;
                v293 = v289;
                if ((_DWORD)v289)
                {
                  v87 = v288;
                  v88 = (float *)v84;
                  do
                  {
                    v89 = *(float *)v87;
                    if (*(float *)v87 <= 0.0)
                      Error::chuck((Error *)"NGaussianMixtureModels::invertVars() - bad value %f in variance vector", v85, v89);
                    *v88++ = 1.0 / v89;
                    v87 += 4;
                    --v86;
                  }
                  while (v86);
                }
              }
              (*(void (**)(uint64_t, char **))(*(_QWORD *)(*((_QWORD *)this + 4) + 56 * v39 + 24) + 16))(*((_QWORD *)this + 4) + 56 * v39 + 24, &v291);
              v291 = (char *)&off_24C7F3090;
              if (v292)
                MEMORY[0x212BAC9C0](v292, 0x1000C8052888210);
LABEL_152:
              __endptr = (char *)&off_24C7F3090;
              if (v288)
                MEMORY[0x212BAC9C0](v288, 0x1000C8052888210);
              if (++v39 >= (unint64_t)*((unsigned int *)this + 10))
              {
                v12 = 6;
                goto LABEL_17;
              }
            }
          }
          continue;
        case 5:
          goto LABEL_62;
        case 6:
          v210 = v298 - 6;
          if (v298 < 6
            || ((v211 = v299, *(_DWORD *)v299 == 1348031575)
              ? (v212 = *(unsigned __int16 *)(v299 + 4) == 15685)
              : (v212 = 0),
                !v212))
          {
            Error::chuck((Error *)"NGaussianMixtureModels::read() - no WTYPE= field in file %s on line %d", i, *((_QWORD *)v271 + 2), v278);
          }
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v213 = (_BYTE *)operator new[]();
          memcpy(v213, (const void *)(v211 + 6), v210);
          v213[v210] = 0;
          if ((_DWORD)v210 == 3)
          {
            v215 = *(_WORD *)v213 != 20300 || v213[2] != 71;
            MEMORY[0x212BAC9C0](v213, 0x1000C8077774924);
            v273 = 1;
            v12 = 7;
            if (!v215)
              continue;
          }
          else
          {
            MEMORY[0x212BAC9C0](v213, 0x1000C8077774924);
          }
          v220 = v298;
          if (v298 <= 5)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", i, 6, v298);
          v221 = v299;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v33 = (int *)operator new[]();
          memcpy(v33, (const void *)(v221 + 6), v220 - 6);
          *((_BYTE *)v33 + v220 - 6) = 0;
          if (v220 != 10)
          {
            v267 = "NGaussianMixtureModels::read() - invalid WTYPE= field in file %s on line %d (LOG or PROB)";
            goto LABEL_530;
          }
          v222 = *v33;
          MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
          v273 = 0;
          v12 = 7;
          if (v222 != 1112494672)
            Error::chuck((Error *)"NGaussianMixtureModels::read() - invalid WTYPE= field in file %s on line %d (LOG or PROB)", i, *((_QWORD *)v271 + 2), v278);
          continue;
        case 7:
          v111 = v298 - 10;
          if (v298 < 0xA)
            goto LABEL_508;
          v112 = v299;
          if (*(_QWORD *)v299 != 0x4552555458494D4ELL || *(_WORD *)(v299 + 8) != 15699)
            goto LABEL_508;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v33 = (int *)operator new[]();
          memcpy(v33, (const void *)(v112 + 10), v111);
          *((_BYTE *)v33 + v111) = 0;
          if (!(_DWORD)v111)
          {
            v267 = "NGaussianMixtureModels::read() - no valid NMIXTURES= field in file %s on line %d";
LABEL_530:
            v268 = (Error *)v267;
            MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
LABEL_531:
            Error::chuck(v268, i, *((_QWORD *)v271 + 2), v278);
          }
          __endptr = 0;
          strtoul((const char *)v33, &__endptr, 10);
          v114 = __endptr;
          MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
          if (v114 != (char *)v33 + v111)
LABEL_508:
            Error::chuck((Error *)"NGaussianMixtureModels::read() - no valid NMIXTURES= field in file %s on line %d", i, *((_QWORD *)v271 + 2), v278);
          LODWORD(__endptr) = 0;
          v115 = v298;
          if (v298 <= 9)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", i, 10, v298);
          v116 = v299;
          if (!v299)
            Error::chuck((Error *)"Null pointer passed to string constructor", i);
          v117 = (void *)operator new[]();
          memcpy(v117, (const void *)(v116 + 10), v115 - 10);
          *((_BYTE *)v117 + v115 - 10) = 0;
          v118 = strtoul((const char *)v117, 0, 10);
          MEMORY[0x212BAC9C0](v117, 0x1000C8077774924);
          LODWORD(__endptr) = v118;
          (*(void (**)(NGaussianMixtureModels *, char **))(*(_QWORD *)this + 32))(this, &__endptr);
LABEL_187:
          v291 = (char *)&off_24C7F2E28;
          v292 = 0;
          v293 = 0;
          if (*((_DWORD *)this + 4))
          {
            v275 = 0;
            v119 = 0;
            while (1)
            {
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", i);
              LOBYTE(v284) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v284);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v121 = v298 - 2;
              if (v298 < 2)
                goto LABEL_448;
              v122 = v299;
              if (*(_WORD *)v299 != 15693)
                goto LABEL_448;
              if (!v299)
                Error::chuck((Error *)"Null pointer passed to string constructor", v120);
              v123 = (void *)operator new[]();
              memcpy(v123, (const void *)(v122 + 2), v121);
              *((_BYTE *)v123 + v121) = 0;
              v124 = strtoul((const char *)v123, 0, 10);
              MEMORY[0x212BAC9C0](v123, 0x1000C8077774924);
              if (v119 != v124)
LABEL_448:
                Error::chuck((Error *)"NGaussianMixtureModels::read() - no or incorrect M=%d field in file %s on line %d", v120, v119, *((_QWORD *)v271 + 2), (v278 + 1));
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v120);
              LOBYTE(v284) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v284);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v126 = v298 - 7;
              if (v298 < 7)
                goto LABEL_479;
              v127 = v299;
              if (*(_DWORD *)v299 != 1297040206 || *(_DWORD *)(v299 + 3) != 1028870221)
                goto LABEL_479;
              if (!v299)
                Error::chuck((Error *)"Null pointer passed to string constructor", v125);
              v129 = (char *)operator new[]();
              memcpy(v129, (const void *)(v127 + 7), v126);
              v129[v126] = 0;
              if (!(_DWORD)v126)
              {
                MEMORY[0x212BAC9C0](v129, 0x1000C8077774924);
LABEL_479:
                Error::chuck((Error *)"NGaussianMixtureModels::read() - no or invalid NCOMPS= field in file %s on line %d", v125, *((_QWORD *)v271 + 2), (v278 + 2));
              }
              __endptr = 0;
              strtoul(v129, &__endptr, 10);
              v130 = __endptr;
              MEMORY[0x212BAC9C0](v129, 0x1000C8077774924);
              if (v130 != &v129[v126])
                goto LABEL_479;
              v283 = 0;
              v131 = v298;
              if (v298 <= 6)
                Error::chuck((Error *)"Index %d outside of range [0,%d]", v125, 7, v298);
              v132 = v299;
              if (!v299)
                Error::chuck((Error *)"Null pointer passed to string constructor", v125);
              v133 = (void *)operator new[]();
              memcpy(v133, (const void *)(v132 + 7), v131 - 7);
              *((_BYTE *)v133 + v131 - 7) = 0;
              v134 = strtoul((const char *)v133, 0, 10);
              MEMORY[0x212BAC9C0](v133, 0x1000C8077774924);
              v283 = v134;
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v135);
              LOBYTE(v284) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v284);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v280 = &off_24C7F32C0;
              v281 = 2;
              v282 = (char *)operator new[]();
              strcpy(v282, " ,");
              v279 = -1;
              __endptr = (char *)off_24C7F13C0;
              v288 = 0;
              v289 = 0;
              v290 = 0;
              NString::split((uint64_t)&v297, (uint64_t)&__endptr, (uint64_t)&v280, &v279);
              v284 = (char *)&off_24C7F2E28;
              v136 = v290;
              v137 = (_QWORD *)operator new[]();
              *v137 = 24;
              v137[1] = v136;
              if ((_DWORD)v136)
              {
                v138 = 0;
                v139 = 24 * v136;
                do
                {
                  v137[v138 / 8 + 2] = &off_24C7F32C0;
                  LODWORD(v137[v138 / 8 + 3]) = 0;
                  v140 = (_BYTE *)operator new[]();
                  v137[v138 / 8 + 4] = v140;
                  *v140 = 0;
                  v138 += 24;
                }
                while (v139 != v138);
              }
              v285 = v137 + 2;
              v141 = v290;
              LODWORD(v286) = v290;
              v142 = v288;
              if (v288)
              {
                v143 = 0;
                do
                {
                  (*(void (**)(_QWORD *, char *))(v285[3 * v143] + 32))(&v285[3 * v143], v142 + 16);
                  ++v143;
                  v142 = (char *)*((_QWORD *)v142 + 1);
                }
                while (v142);
                v144 = v293;
                v141 = v286;
                if (v293 == (_DWORD)v286)
                  goto LABEL_234;
              }
              else
              {
                v144 = v275;
                if (v275 == v290)
                  goto LABEL_234;
              }
              v145 = v292;
              if (v292)
              {
                v146 = *(v292 - 1);
                if (v146)
                {
                  v147 = 3 * v146;
                  do
                  {
                    v145[v147 - 3] = &off_24C7F32C0;
                    v148 = v145[v147 - 1];
                    if (v148)
                      MEMORY[0x212BAC9C0](v148, 0x1000C8077774924);
                    v147 -= 3;
                  }
                  while (v147 * 8);
                }
                MEMORY[0x212BAC9C0](v145 - 2, 0x1091C800F2A5985);
              }
              v293 = v141;
              v149 = (_QWORD *)operator new[]();
              *v149 = 24;
              v149[1] = v141;
              if (v141)
              {
                v150 = 0;
                do
                {
                  v149[v150 + 2] = &off_24C7F32C0;
                  LODWORD(v149[v150 + 3]) = 0;
                  v151 = (_BYTE *)operator new[]();
                  v149[v150 + 4] = v151;
                  *v151 = 0;
                  v150 += 3;
                }
                while (3 * v141 != v150);
              }
              v292 = v149 + 2;
              v144 = v141;
LABEL_234:
              v276 = v144;
              v152 = v285;
              if (v141)
              {
                v153 = v292;
                v154 = v141;
                v155 = v285;
                do
                {
                  (*(void (**)(_QWORD *, _QWORD *))(*v153 + 32))(v153, v155);
                  v153 += 3;
                  v155 += 3;
                  --v154;
                }
                while (v154);
              }
              v284 = (char *)&off_24C7F2E28;
              if (v152)
              {
                v156 = *(v152 - 1);
                if (v156)
                {
                  v157 = 3 * v156;
                  do
                  {
                    v152[v157 - 3] = &off_24C7F32C0;
                    v158 = v152[v157 - 1];
                    if (v158)
                      MEMORY[0x212BAC9C0](v158, 0x1000C8077774924);
                    v157 -= 3;
                  }
                  while (v157 * 8);
                }
                MEMORY[0x212BAC9C0](v152 - 2, 0x1091C800F2A5985);
              }
              for (__endptr = (char *)off_24C7F13C0;
                    ;
                    (*((void (**)(uint64_t, uint64_t))__endptr + 9))((uint64_t)&__endptr, (uint64_t)v159))
              {
                v159 = v288;
                if (!v288)
                  break;
                v288 = (char *)*((_QWORD *)v288 + 1);
              }
              v289 = 0;
              v290 = 0;
              if (v282)
                MEMORY[0x212BAC9C0](v282, 0x1000C8077774924);
              if (v276 != v283 + 2
                || (v160 = v292, *((_DWORD *)v292 + 2) != 1)
                || *(_BYTE *)v292[2] != 91
                || LODWORD(v292[3 * v283 + 4]) != 1
                || *(_BYTE *)v292[3 * v283 + 5] != 93)
              {
                v278 = (v278 + 3);
                v269 = "NGaussianMixtureModels::read() - gaussian vector parse failed in file %s on line %d";
LABEL_446:
                Error::chuck((Error *)v269, v159, *((_QWORD *)v271 + 2), v278);
              }
              (*(void (**)(uint64_t, unsigned int *))(*(_QWORD *)(*((_QWORD *)this + 1) + 48 * v119) + 32))(*((_QWORD *)this + 1) + 48 * v119, &v283);
              if (v283)
              {
                v162 = 0;
                v163 = (const char **)(v160 + 5);
                do
                {
                  if (!*((_DWORD *)v163 - 2)
                    || (__endptr = 0, strtoul(*v163, &__endptr, 10), __endptr != &(*v163)[*((unsigned int *)v163 - 2)]))
                  {
                    Error::chuck((Error *)"NGaussianMixtureModels::read() - gaussian reference invalid in file %s on line %d (item %d)", v161, *((_QWORD *)v271 + 2), (v278 + 3), v162);
                  }
                  if (*((_DWORD *)this + 10) < strtoul(*v163, 0, 10))
                  {
                    v261 = strtoul((const char *)v160[3 * v162 + 2], 0, 10);
                    Error::chuck((Error *)"NGaussianMixtureModels::read() - gaussian reference %d out of range %d in file %s on line %d (item %d)", v262, v261, *((unsigned int *)this + 10), *((_QWORD *)v271 + 2), (v278 + 3), v162);
                  }
                  v164 = *v163;
                  v163 += 3;
                  *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 48 * v119 + 8) + 4 * v162++) = strtoul(v164, 0, 10);
                }
                while (v162 < v283);
              }
              if (!v304)
                Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v161);
              LOBYTE(v284) = 35;
              (*(void (**)(char **__return_ptr, uint64_t, char **))(*(_QWORD *)v304 + 80))(&__endptr, v304, &v284);
              ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _WORD *, char **))v297[8])(&v297, v289, &v288);
              __endptr = (char *)&off_24C7F32C0;
              if (v289)
                MEMORY[0x212BAC9C0](v289, 0x1000C8077774924);
              v280 = &off_24C7F32C0;
              v281 = 2;
              v282 = (char *)operator new[]();
              strcpy(v282, " ,");
              v279 = -1;
              __endptr = (char *)off_24C7F13C0;
              v288 = 0;
              v289 = 0;
              v290 = 0;
              NString::split((uint64_t)&v297, (uint64_t)&__endptr, (uint64_t)&v280, &v279);
              v284 = (char *)&off_24C7F2E28;
              v165 = v290;
              v166 = (_QWORD *)operator new[]();
              *v166 = 24;
              v166[1] = v165;
              if ((_DWORD)v165)
              {
                v167 = 0;
                v168 = 24 * v165;
                do
                {
                  v166[v167 / 8 + 2] = &off_24C7F32C0;
                  LODWORD(v166[v167 / 8 + 3]) = 0;
                  v169 = (_BYTE *)operator new[]();
                  v166[v167 / 8 + 4] = v169;
                  *v169 = 0;
                  v167 += 24;
                }
                while (v168 != v167);
              }
              v285 = v166 + 2;
              v170 = v290;
              LODWORD(v286) = v290;
              v171 = v288;
              if (v288)
              {
                v172 = 0;
                do
                {
                  (*(void (**)(_QWORD *, char *))(v285[3 * v172] + 32))(&v285[3 * v172], v171 + 16);
                  ++v172;
                  v171 = (char *)*((_QWORD *)v171 + 1);
                }
                while (v171);
                v170 = v286;
                v173 = v293;
                if (v293 != (_DWORD)v286)
                {
LABEL_272:
                  v174 = v292;
                  if (v292)
                  {
                    v175 = *(v292 - 1);
                    if (v175)
                    {
                      v176 = 3 * v175;
                      do
                      {
                        v174[v176 - 3] = &off_24C7F32C0;
                        v177 = v174[v176 - 1];
                        if (v177)
                          MEMORY[0x212BAC9C0](v177, 0x1000C8077774924);
                        v176 -= 3;
                      }
                      while (v176 * 8);
                    }
                    MEMORY[0x212BAC9C0](v174 - 2, 0x1091C800F2A5985);
                  }
                  v293 = v170;
                  v178 = (_QWORD *)operator new[]();
                  *v178 = 24;
                  v178[1] = v170;
                  if (v170)
                  {
                    v179 = 0;
                    do
                    {
                      v178[v179 + 2] = &off_24C7F32C0;
                      LODWORD(v178[v179 + 3]) = 0;
                      v180 = (_BYTE *)operator new[]();
                      v178[v179 + 4] = v180;
                      *v180 = 0;
                      v179 += 3;
                    }
                    while (3 * v170 != v179);
                  }
                  v292 = v178 + 2;
                  v173 = v170;
                }
              }
              else
              {
                v173 = v276;
                if (v276 != v290)
                  goto LABEL_272;
              }
              v275 = v173;
              v181 = v285;
              if (v170)
              {
                v182 = v292;
                v183 = v170;
                v184 = v285;
                do
                {
                  (*(void (**)(_QWORD *, _QWORD *))(*v182 + 32))(v182, v184);
                  v182 += 3;
                  v184 += 3;
                  --v183;
                }
                while (v183);
              }
              v284 = (char *)&off_24C7F2E28;
              if (v181)
              {
                v185 = *(v181 - 1);
                if (v185)
                {
                  v186 = 3 * v185;
                  do
                  {
                    v181[v186 - 3] = &off_24C7F32C0;
                    v187 = v181[v186 - 1];
                    if (v187)
                      MEMORY[0x212BAC9C0](v187, 0x1000C8077774924);
                    v186 -= 3;
                  }
                  while (v186 * 8);
                }
                MEMORY[0x212BAC9C0](v181 - 2, 0x1091C800F2A5985);
              }
              for (__endptr = (char *)off_24C7F13C0;
                    ;
                    (*((void (**)(uint64_t, uint64_t))__endptr + 9))((uint64_t)&__endptr, (uint64_t)v159))
              {
                v159 = v288;
                if (!v288)
                  break;
                v288 = (char *)*((_QWORD *)v288 + 1);
              }
              v289 = 0;
              v290 = 0;
              if (v282)
                MEMORY[0x212BAC9C0](v282, 0x1000C8077774924);
              v278 = (v278 + 4);
              if (v275 != v283 + 2)
                goto LABEL_446;
              v188 = v292;
              if (*((_DWORD *)v292 + 2) != 1
                || *(_BYTE *)v292[2] != 91
                || LODWORD(v292[3 * v283 + 4]) != 1
                || *(_BYTE *)v292[3 * v283 + 5] != 93)
              {
                goto LABEL_446;
              }
              __endptr = (char *)&off_24C7F3090;
              v190 = (char *)operator new[]();
              v288 = v190;
              LODWORD(v289) = v283;
              if (v283)
              {
                v191 = 0;
                v192 = (const char **)(v188 + 5);
                do
                {
                  if (!*((_DWORD *)v192 - 2)
                    || (v284 = 0, strtod(*v192, &v284), v284 != &(*v192)[*((unsigned int *)v192 - 2)]))
                  {
                    Error::chuck((Error *)"NGaussianMixtureModels::read() - weight vector parse failed in file %s on line %d (item %d is invalid float)", v189, *((_QWORD *)v271 + 2), v278, v191);
                  }
                  v193 = *v192;
                  v192 += 3;
                  v194 = atof(v193);
                  v190 = v288;
                  *(float *)&v288[4 * v191++] = v194;
                }
                while (v191 < v283);
              }
              if (v273)
              {
                v195 = v289;
                if ((_DWORD)v289)
                {
                  v196 = 0.0;
                  do
                  {
                    v197 = *(float *)v190;
                    v190 += 4;
                    v196 = v196 + expf(v197);
                    --v195;
                  }
                  while (v195);
                  v198 = v196 + -1.0;
                }
                else
                {
                  v198 = -1.0;
                }
                if (fabs(v198) > 0.1)
                  Error::chuck((Error *)"NGaussianMixtureModels::validateWeights() - mixture weights do not sum to one (tol=+-0.1)", v189);
                (*(void (**)(uint64_t, char **))(*(_QWORD *)(*((_QWORD *)this + 1) + 48 * v119 + 24) + 16))(*((_QWORD *)this + 1) + 48 * v119 + 24, &__endptr);
              }
              else
              {
                v284 = (char *)&off_24C7F3090;
                v199 = operator new[]();
                v285 = (_QWORD *)v199;
                v201 = v289;
                LODWORD(v286) = (_DWORD)v289;
                if ((_DWORD)v289)
                {
                  v202 = 0.0;
                  v203 = v288;
                  v204 = (float *)v199;
                  do
                  {
                    v205 = *(float *)v203;
                    if (*(float *)v203 <= 0.0)
                      Error::chuck((Error *)"NGaussianMixtureModels::logWeights() - bad value %f in variance vector", v200, v205);
                    v202 = v202 + v205;
                    *v204++ = logf(v205);
                    v203 += 4;
                    --v201;
                  }
                  while (v201);
                  v206 = v202 + -1.0;
                }
                else
                {
                  v206 = -1.0;
                }
                if (fabs(v206) > 0.1)
                  Error::chuck((Error *)"NGaussianMixtureModels::logWeights() - mixture weights do not sum to one (tol=+-0.1)", v200);
                (*(void (**)(uint64_t, char **))(*(_QWORD *)(*((_QWORD *)this + 1) + 48 * v119 + 24) + 16))(*((_QWORD *)this + 1) + 48 * v119 + 24, &v284);
                v284 = (char *)&off_24C7F3090;
                if (v285)
                  MEMORY[0x212BAC9C0](v285, 0x1000C8052888210);
              }
              __endptr = (char *)&off_24C7F3090;
              if (v288)
                MEMORY[0x212BAC9C0](v288, 0x1000C8052888210);
              if (++v119 >= (unint64_t)*((unsigned int *)this + 4))
              {
                if (v188)
                {
                  v207 = *(v188 - 1);
                  if (v207)
                  {
                    v208 = 3 * v207;
                    do
                    {
                      v188[v208 - 3] = &off_24C7F32C0;
                      v209 = v188[v208 - 1];
                      if (v209)
                        MEMORY[0x212BAC9C0](v209, 0x1000C8077774924);
                      v208 -= 3;
                    }
                    while (v208 * 8);
                  }
                  MEMORY[0x212BAC9C0](v188 - 2, 0x1091C800F2A5985);
                }
                break;
              }
            }
          }
          v12 = 9;
          break;
        case 8:
          goto LABEL_187;
        case 9:
          goto LABEL_531;
        default:
          continue;
      }
    }
  }
  if (v12 != 9)
    Error::chuck((Error *)"NGaussianMixtureModels::read() - premature end of gmix file %s", v13, *((_QWORD *)v271 + 2));
  v294 = &off_24C7F2E28;
  v224 = v295;
  if (v295)
  {
    v225 = *(_QWORD *)(v295 - 8);
    if (v225)
    {
      v226 = 24 * v225;
      do
      {
        *(_QWORD *)(v224 + v226 - 24) = &off_24C7F32C0;
        v227 = *(_QWORD *)(v224 + v226 - 8);
        if (v227)
          MEMORY[0x212BAC9C0](v227, 0x1000C8077774924);
        v226 -= 24;
      }
      while (v226);
    }
    MEMORY[0x212BAC9C0](v224 - 16, 0x1091C800F2A5985);
  }
  v297 = &off_24C7F32C0;
  if (v299)
    MEMORY[0x212BAC9C0](v299, 0x1000C8077774924);
LABEL_420:
  v251 = *((unsigned int *)this + 10);
  if ((_DWORD)v251)
  {
    v252 = 0;
    v253 = *((_QWORD *)this + 4);
    do
    {
      v254 = v253 + 56 * v252;
      v255 = *(unsigned int *)(v254 + 40);
      v256 = (double)v255 * 1.83787707;
      *(float *)(v254 + 48) = v256;
      v257 = (float *)(v254 + 48);
      if ((_DWORD)v255)
      {
        v258 = *(float **)(v253 + 56 * v252 + 32);
        do
        {
          v259 = *v258++;
          v256 = v256 - logf(v259);
          *v257 = v256;
          --v255;
        }
        while (v255);
      }
      ++v252;
    }
    while (v252 != v251);
  }
  v300 = &off_24C7F32C0;
  if (v302)
    MEMORY[0x212BAC9C0](v302, 0x1000C8077774924);
  v303 = &off_24C7F17F8;
  result = v304;
  if (v304)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v304 + 8))(v304);
  return result;
}

void sub_20D9C395C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  if (a36)
    MEMORY[0x212BAC9C0](a36, 0x1000C8077774924);
  *(_QWORD *)(v40 - 208) = &off_24C7F2E28;
  v42 = *(_QWORD *)(v40 - 200);
  if (v42)
  {
    v43 = *(_QWORD *)(v42 - 8);
    if (v43)
    {
      v47 = 24 * v43;
      do
      {
        *(_QWORD *)(v42 + v47 - 24) = v39;
        v48 = *(_QWORD *)(v42 + v47 - 8);
        if (v48)
          MEMORY[0x212BAC9C0](v48, 0x1000C8077774924);
        v47 -= 24;
      }
      while (v47);
    }
    MEMORY[0x212BAC9C0](v42 - 16, 0x1091C800F2A5985);
  }
  *(_QWORD *)(v40 - 184) = v39;
  v44 = *(_QWORD *)(v40 - 168);
  if (v44)
    MEMORY[0x212BAC9C0](v44, 0x1000C8077774924);
  *(_QWORD *)(v40 - 160) = v39;
  v45 = *(_QWORD *)(v40 - 144);
  if (v45)
    MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
  *(_QWORD *)(v40 - 136) = &off_24C7F17F8;
  v46 = *(_QWORD *)(v40 - 128);
  if (v46)
    (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianMixtureModels::invertVars@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t result;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;

  *(_QWORD *)a2 = &off_24C7F3090;
  result = operator new[]();
  *(_QWORD *)(a2 + 8) = result;
  v6 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = v6;
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 8);
    v9 = 4 * v6;
    do
    {
      v10 = *(float *)(v8 + v7);
      if (v10 <= 0.0)
        Error::chuck((Error *)"NGaussianMixtureModels::invertVars() - bad value %f in variance vector", v5, v10);
      *(float *)(result + v7) = 1.0 / v10;
      v7 += 4;
    }
    while (v9 != v7);
  }
  return result;
}

void sub_20D9C41A4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = &off_24C7F3090;
  MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NGaussianMixtureModels::invertSquareVars@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t result;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;

  *(_QWORD *)a2 = &off_24C7F3090;
  result = operator new[]();
  *(_QWORD *)(a2 + 8) = result;
  v6 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = v6;
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 8);
    v9 = 4 * v6;
    do
    {
      v10 = *(float *)(v8 + v7);
      if (v10 <= 0.0)
        Error::chuck((Error *)"NGaussianMixtureModels::invertSquareVars() - bad value %f in variance vector", v5, v10);
      *(float *)(result + v7) = 1.0 / (float)(v10 * v10);
      v7 += 4;
    }
    while (v9 != v7);
  }
  return result;
}

void sub_20D9C428C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = &off_24C7F3090;
  MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NGaussianMixtureModels::validateVars(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  float *v6;

  v3 = operator new[]();
  v5 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v5)
  {
    v6 = *(float **)(a2 + 8);
    do
    {
      if (*v6 <= 0.0)
        Error::chuck((Error *)"NGaussianMixtureModels::validateVars() - bad value %f in variance vector", v4, *v6);
      ++v6;
      --v5;
    }
    while (v5);
  }
  MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  return a2;
}

void sub_20D9C4354(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

void NGaussianMixtureModels::logWeights(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  float *v7;
  float v8;
  float *v9;
  float v10;
  double v11;

  *(_QWORD *)a2 = &off_24C7F3090;
  v4 = operator new[]();
  *(_QWORD *)(a2 + 8) = v4;
  v6 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = v6;
  if ((_DWORD)v6)
  {
    v7 = *(float **)(a1 + 8);
    v8 = 0.0;
    v9 = (float *)v4;
    do
    {
      v10 = *v7;
      if (*v7 <= 0.0)
        Error::chuck((Error *)"NGaussianMixtureModels::logWeights() - bad value %f in variance vector", v5, v10);
      v8 = v8 + v10;
      *v9++ = logf(v10);
      ++v7;
      --v6;
    }
    while (v6);
    v11 = v8 + -1.0;
  }
  else
  {
    v11 = -1.0;
  }
  if (fabs(v11) > 0.1)
    Error::chuck((Error *)"NGaussianMixtureModels::logWeights() - mixture weights do not sum to one (tol=+-0.1)", v5);
}

void sub_20D9C4474(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *v1 = v3;
  MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NGaussianMixtureModels::validateWeights(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  double v7;
  float *v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  float *v13;
  float v14;

  v3 = *(unsigned int *)(a2 + 16);
  if (!(_DWORD)v3)
  {
    v7 = -1.0;
    goto LABEL_11;
  }
  v4 = *(_QWORD *)(a2 + 8);
  if ((_DWORD)v3 == 1)
  {
    v5 = 0;
    v6 = 0.0;
  }
  else
  {
    v5 = v3 & 0xFFFFFFFE;
    v8 = (float *)(v4 + 4);
    v6 = 0.0;
    v9 = v5;
    do
    {
      v10 = *v8;
      v11 = expf(*(v8 - 1));
      v6 = (float)(v6 + v11) + expf(v10);
      v8 += 2;
      v9 -= 2;
    }
    while (v9);
    if (v5 == v3)
      goto LABEL_10;
  }
  v12 = v3 - v5;
  v13 = (float *)(v4 + 4 * v5);
  do
  {
    v14 = *v13++;
    v6 = v6 + expf(v14);
    --v12;
  }
  while (v12);
LABEL_10:
  v7 = v6 + -1.0;
LABEL_11:
  if (fabs(v7) > 0.1)
    Error::chuck((Error *)"NGaussianMixtureModels::validateWeights() - mixture weights do not sum to one (tol=+-0.1)", (const char *)a2);
  return a2;
}

void NGaussianMixtureModels::refreshOffsets(NGaussianMixtureModels *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  float *v7;
  float *v8;
  float v9;

  v1 = *((unsigned int *)this + 10);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = *((_QWORD *)this + 4);
    do
    {
      v4 = v3 + 56 * v2;
      v5 = *(unsigned int *)(v4 + 40);
      v6 = (double)v5 * 1.83787707;
      *(float *)(v4 + 48) = v6;
      v7 = (float *)(v4 + 48);
      if ((_DWORD)v5)
      {
        v8 = *(float **)(v3 + 56 * v2 + 32);
        do
        {
          v9 = *v8++;
          v6 = v6 - logf(v9);
          *v7 = v6;
          --v5;
        }
        while (v5);
      }
      ++v2;
    }
    while (v2 != v1);
  }
}

void NGaussianMixtureModels::write(uint64_t a1, const NString *a2)
{
  const char *v4;
  uint64_t v5;
  void (**v6)(NFilePtr *__hidden);
  uint64_t v7;
  uint64_t (**v8)(NString *__hidden, const unsigned int *);
  int v9;
  char *v10;
  char __str[8];
  uint64_t v12;
  _WORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v12) = 1;
  v13 = (_WORD *)operator new[]();
  *v13 = 119;
  v6 = &off_24C7F33E0;
  v7 = 0;
  NFilePtr::open((NFilePtr *)&v6, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  *(_BYTE *)operator new[]() = 0;
  v5 = v7;
  if (v7)
  {
    *(_QWORD *)__str = &off_24C7F32C0;
    LODWORD(v12) = 13;
    v13 = (_WORD *)operator new[]();
    memcpy(v13, "# GMIXa v1.00", (v12 + 1));
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v5 + 104))(v5, __str);
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v13)
      MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
    if (v7)
    {
      v8 = &off_24C7F32C0;
      v9 = 6;
      v10 = (char *)operator new[]();
      strcpy(v10, "IDENT=");
      NString::operator+((uint64_t)&v8, a1 + 56, (uint64_t)__str);
    }
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v4);
}

void sub_20D9C5810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  if (a35)
    MEMORY[0x212BAC9C0](a35, 0x1000C8077774924);
  if (a26)
    MEMORY[0x212BAC9C0](a26, 0x1000C8077774924);
  if (a29)
    (*(void (**)(uint64_t))(*(_QWORD *)a29 + 8))(a29);
  _Unwind_Resume(exception_object);
}

uint64_t operator<<<float>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  char *v9;
  uint64_t (**v10)(NString *__hidden, const unsigned int *);
  int v11;
  _WORD *v12;

  v10 = &off_24C7F32C0;
  v11 = 1;
  v12 = (_WORD *)operator new[]();
  *v12 = 91;
  if (*(_DWORD *)(a2 + 16))
  {
    v7 = &off_24C7F32C0;
    v8 = 1;
    v9 = (char *)operator new[]();
    strcpy(v9, " ");
    v10[6]((NString *)&v10, (const unsigned int *)&v7);
    operator<<((uint64_t)&v10, *(float **)(a2 + 8));
    v7 = &off_24C7F32C0;
    if (v9)
      MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
    if (*(_DWORD *)(a2 + 16) >= 2u)
    {
      v4 = 1;
      v5 = 4;
      do
      {
        v7 = &off_24C7F32C0;
        v8 = 2;
        v9 = (char *)operator new[]();
        memcpy(v9, ", ", (v8 + 1));
        v10[6]((NString *)&v10, (const unsigned int *)&v7);
        operator<<((uint64_t)&v10, (float *)(*(_QWORD *)(a2 + 8) + v5));
        v7 = &off_24C7F32C0;
        if (v9)
          MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
        ++v4;
        v5 += 4;
      }
      while (v4 < *(unsigned int *)(a2 + 16));
    }
  }
  v7 = &off_24C7F32C0;
  v8 = 2;
  v9 = (char *)operator new[]();
  strcpy(v9, " ]");
  v10[6]((NString *)&v10, (const unsigned int *)&v7);
  v7 = &off_24C7F32C0;
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a1 + 48))(a1, &v10);
  v10 = &off_24C7F32C0;
  if (v12)
    MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  return a1;
}

void sub_20D9C5DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianMixtureModels::invertSqrtVars@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t result;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;

  *(_QWORD *)a2 = &off_24C7F3090;
  result = operator new[]();
  *(_QWORD *)(a2 + 8) = result;
  v6 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = v6;
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 8);
    v9 = 4 * v6;
    do
    {
      v10 = *(float *)(v8 + v7);
      if (v10 <= 0.0)
        Error::chuck((Error *)"NGaussianMixtureModels::invertSqrtVars() - bad value %f in variance vector", v5, v10);
      *(float *)(result + v7) = 1.0 / sqrtf(v10);
      v7 += 4;
    }
    while (v9 != v7);
  }
  return result;
}

void sub_20D9C5ED0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = &off_24C7F3090;
  MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

void NGaussianMixtureModels::expWeights(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  double v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float *v20;
  float v21;
  uint64_t v22;
  float v23;
  float *v24;
  uint64_t v25;
  float v26;
  float v27;
  uint64_t v28;
  float *v29;
  float v30;
  float v31;

  *(_QWORD *)a2 = &off_24C7F3090;
  v4 = operator new[]();
  v6 = v4;
  *(_QWORD *)(a2 + 8) = v4;
  v7 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = v7;
  if (!(_DWORD)v7)
  {
    v11 = -1.0;
    goto LABEL_21;
  }
  v8 = *(_QWORD *)(a1 + 8);
  if ((_DWORD)v7 == 1 || (unint64_t)(v4 - v8) <= 7)
  {
    v10 = 0;
LABEL_11:
    v17 = v7 - v10;
    v18 = 4 * v10;
    v19 = (float *)(v6 + 4 * v10);
    v20 = (float *)(v8 + v18);
    do
    {
      v21 = *v20++;
      *v19++ = expf(v21);
      --v17;
    }
    while (v17);
    goto LABEL_13;
  }
  v10 = v7 & 0xFFFFFFFE;
  v12 = (uint64_t *)v8;
  v13 = (_QWORD *)v4;
  v14 = v10;
  do
  {
    v15 = *v12++;
    v31 = expf(*((float *)&v15 + 1));
    *(float *)&v16 = expf(*(float *)&v15);
    *((float *)&v16 + 1) = v31;
    *v13++ = v16;
    v14 -= 2;
  }
  while (v14);
  if (v10 != v7)
    goto LABEL_11;
LABEL_13:
  if (v7 > 1)
  {
    v22 = v7 & 0xFFFFFFFE;
    v24 = (float *)(v8 + 4);
    v23 = 0.0;
    v25 = v22;
    do
    {
      v26 = *v24;
      v27 = expf(*(v24 - 1));
      v23 = (float)(v23 + v27) + expf(v26);
      v24 += 2;
      v25 -= 2;
    }
    while (v25);
    if (v22 == v7)
      goto LABEL_20;
  }
  else
  {
    v22 = 0;
    v23 = 0.0;
  }
  v28 = v7 - v22;
  v29 = (float *)(v8 + 4 * v22);
  do
  {
    v30 = *v29++;
    v23 = v23 + expf(v30);
    --v28;
  }
  while (v28);
LABEL_20:
  v11 = v23 + -1.0;
LABEL_21:
  if (fabs(v11) > 0.1)
    Error::chuck((Error *)"NGaussianMixtureModels::expWeights() - mixture weights do not sum to one (tol=+-0.1)", v5);
}

void sub_20D9C60C4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *v1 = v3;
  MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

void NGaussianMixtureModels::writeBinary(NGaussianMixtureModels *this, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  NBaseFile *v6;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  char *v9;
  uint64_t (**v10)(NString *__hidden, const unsigned int *);
  int v11;
  _WORD *v12;
  uint64_t v13;
  void (**v14)(NFilePtr *__hidden);
  NBaseFile *v15;

  v10 = &off_24C7F32C0;
  v11 = 1;
  v12 = (_WORD *)operator new[]();
  *v12 = 119;
  v14 = &off_24C7F33E0;
  v15 = 0;
  NFilePtr::open((NFilePtr *)&v14, a2, (const NString *)&v10);
  v10 = &off_24C7F32C0;
  if (v12)
    MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
  v10 = &off_24C7F32C0;
  v11 = 0;
  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v12 = v4;
  v13 = 0;
  v10 = &off_24C7F11D8;
  v6 = v15;
  if (v15)
  {
    v7 = &off_24C7F32C0;
    v8 = 13;
    v9 = (char *)operator new[]();
    strcpy(v9, "# GMIXb v1.00");
    (*(void (**)(NBaseFile *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v6 + 96))(v6, &v7);
    v7 = &off_24C7F32C0;
    if (v9)
      MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
    if (v15)
      NBaseFile::writeString(v15, (NGaussianMixtureModels *)((char *)this + 56));
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v5, v7);
}

void sub_20D9C6610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  if (a17)
    (*(void (**)(uint64_t))(*(_QWORD *)a17 + 8))(a17);
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianMixtureModels::dimen(NGaussianMixtureModels *this)
{
  return (uint64_t)this + 48;
}

uint64_t NGaussianMixtureModels::id(NGaussianMixtureModels *this)
{
  return (uint64_t)this + 56;
}

{
  return (uint64_t)this + 56;
}

uint64_t NGaussianMixtureModels::gaussians(NGaussianMixtureModels *this)
{
  return (uint64_t)this + 24;
}

uint64_t NGaussianMixtureModels::gaussian(NGaussianMixtureModels *this, const unsigned int *a2, const unsigned int *a3)
{
  return *((_QWORD *)this + 4)
       + 56 * *(unsigned int *)(*(_QWORD *)(*((_QWORD *)this + 1) + 48 * *a2 + 8) + 4 * *a3);
}

uint64_t NGaussianMixtureModels::weight(NGaussianMixtureModels *this, const unsigned int *a2, const unsigned int *a3)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 48 * *a2 + 32) + 4 * *a3;
}

float NGaussianMixtureModels::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float *v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  float v11;
  long double v12;
  float v13;
  unsigned int v14;
  uint64_t v15;
  float *v16;
  float *v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  uint64_t v29;
  float32x4_t *v30;
  uint64_t v31;
  float *v32;
  uint64_t v33;
  float v34;
  float32x4_t *v35;
  float32x4_t *v36;
  float32x4_t *v37;
  float32x4_t *v38;
  float32x4_t *v39;
  uint64_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float *v45;
  float *v46;
  float *v47;
  uint64_t v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(unsigned int *)(v3 + 48 * *a2 + 16);
  if ((_DWORD)v4)
  {
    v5 = v3 + 48 * *a2;
    v6 = *(float **)(v5 + 32);
    v7 = *(unsigned int **)(v5 + 8);
    v8 = *(_QWORD *)(a1 + 32);
    v9 = *(unsigned int *)(a3 + 16);
    if ((_DWORD)v9)
    {
      v10 = *(float **)(a3 + 8);
      if (v9 >= 8)
      {
        v29 = 0;
        v30 = (float32x4_t *)(v10 + 4);
        v31 = (4 * v9) & 0x3FFFFFFE0;
        v32 = (float *)((char *)v10 + v31);
        v12 = 0.0;
        do
        {
          v33 = v8 + 56 * v7[v29];
          v34 = *(float *)(v33 + 48);
          v35 = *(float32x4_t **)(v33 + 8);
          v36 = *(float32x4_t **)(v33 + 32);
          v37 = v36 + 1;
          v38 = v35 + 1;
          v39 = v30;
          v40 = v9 & 0xFFFFFFF8;
          do
          {
            v41 = vsubq_f32(v39[-1], v38[-1]);
            v42 = vsubq_f32(*v39, *v38);
            v43 = vmulq_f32(vmulq_f32(v41, v41), v37[-1]);
            v44 = vmulq_f32(vmulq_f32(v42, v42), *v37);
            v34 = (float)((float)((float)((float)((float)((float)((float)(v34 + v43.f32[0]) + v43.f32[1]) + v43.f32[2])
                                                + v43.f32[3])
                                        + v44.f32[0])
                                + v44.f32[1])
                        + v44.f32[2])
                + v44.f32[3];
            v37 += 2;
            v38 += 2;
            v39 += 2;
            v40 -= 8;
          }
          while (v40);
          if (v9 != (v9 & 0xFFFFFFF8))
          {
            v45 = (float *)((char *)v36->f32 + v31);
            v46 = (float *)((char *)v35->f32 + v31);
            v47 = v32;
            v48 = v9 - (v9 & 0xFFFFFFF8);
            do
            {
              v49 = *v47++;
              v50 = v49;
              v51 = *v46++;
              v52 = (float)(v50 - v51) * (float)(v50 - v51);
              v53 = *v45++;
              v34 = v34 + (float)(v52 * v53);
              --v48;
            }
            while (v48);
          }
          v12 = v12 + exp((float)(v6[v29++] + (float)(v34 * -0.5)));
        }
        while (v29 != v4);
      }
      else
      {
        v11 = *v10;
        v12 = 0.0;
        do
        {
          v14 = *v7++;
          v15 = v8 + 56 * v14;
          v16 = *(float **)(v15 + 8);
          v17 = *(float **)(v15 + 32);
          v18 = *(float *)(v15 + 48) + (float)((float)((float)(v11 - *v16) * (float)(v11 - *v16)) * *v17);
          if ((_DWORD)v9 != 1)
          {
            v19 = v10[1] - v16[1];
            v18 = v18 + (float)((float)(v19 * v19) * v17[1]);
            if ((_DWORD)v9 != 2)
            {
              v20 = v10[2] - v16[2];
              v18 = v18 + (float)((float)(v20 * v20) * v17[2]);
              if ((_DWORD)v9 != 3)
              {
                v21 = v10[3] - v16[3];
                v18 = v18 + (float)((float)(v21 * v21) * v17[3]);
                if ((_DWORD)v9 != 4)
                {
                  v22 = v10[4] - v16[4];
                  v18 = v18 + (float)((float)(v22 * v22) * v17[4]);
                  if ((_DWORD)v9 != 5)
                  {
                    v23 = v10[5] - v16[5];
                    v18 = v18 + (float)((float)(v23 * v23) * v17[5]);
                    if ((_DWORD)v9 != 6)
                    {
                      v24 = v10[6] - v16[6];
                      v18 = v18 + (float)((float)(v24 * v24) * v17[6]);
                    }
                  }
                }
              }
            }
          }
          v13 = *v6++;
          v12 = v12 + exp((float)(v13 + (float)(v18 * -0.5)));
          --v4;
        }
        while (v4);
      }
    }
    else
    {
      v12 = 0.0;
      do
      {
        v25 = *v6++;
        v26 = v25;
        v27 = *v7++;
        v12 = v12 + exp((float)(v26 + (float)(*(float *)(v8 + 56 * v27 + 48) * -0.5)));
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    v12 = 0.0;
  }
  return log(v12);
}

float NGaussianMixtureModels::score2(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  float *v6;
  float *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t *v17;
  float v18;
  float v19;
  uint64_t v21;
  float v22;
  float32x4_t *v23;
  float32x4_t *v24;
  uint64_t v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  uint64_t v35;
  float *v36;
  float *v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  double v44;
  uint64_t v45;
  float *v46;
  unsigned int *v47;
  float *v48;
  float v49;
  float v50;
  unsigned int v51;
  float v52;
  uint64_t v53;
  float *v54;
  uint64_t v55;
  float v56;
  float v57;
  uint64_t v58;
  float *v59;
  float v60;
  float v61;

  v6 = (float *)operator new[]();
  v7 = v6;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  v10 = *(unsigned int *)(v8 + 48 * *a2 + 16);
  if (!(_DWORD)v10)
  {
    v44 = 0.0;
    v18 = 0.0;
    goto LABEL_31;
  }
  v11 = v8 + 48 * v9;
  v12 = *(float **)(v11 + 32);
  v13 = *(unsigned int **)(v11 + 8);
  v14 = *(_QWORD *)(a1 + 32);
  v15 = *(unsigned int *)(a3 + 16);
  if ((_DWORD)v15)
  {
    v16 = 0;
    v17 = *(float32x4_t **)(a3 + 8);
    v18 = 0.0;
    while (1)
    {
      v21 = v14 + 56 * v13[v16];
      v22 = *(float *)(v21 + 48);
      v23 = *(float32x4_t **)(v21 + 8);
      v24 = *(float32x4_t **)(v21 + 32);
      if (v15 < 8)
        break;
      v26 = v24 + 1;
      v27 = v23 + 1;
      v28 = v17 + 1;
      v29 = v15 & 0xFFFFFFF8;
      do
      {
        v30 = vsubq_f32(v28[-1], v27[-1]);
        v31 = vsubq_f32(*v28, *v27);
        v32 = vmulq_f32(vmulq_f32(v30, v30), v26[-1]);
        v33 = vmulq_f32(vmulq_f32(v31, v31), *v26);
        v22 = (float)((float)((float)((float)((float)((float)((float)(v22 + v32.f32[0]) + v32.f32[1]) + v32.f32[2])
                                            + v32.f32[3])
                                    + v33.f32[0])
                            + v33.f32[1])
                    + v33.f32[2])
            + v33.f32[3];
        v26 += 2;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      v25 = v15 & 0xFFFFFFF8;
      if (v25 != v15)
        goto LABEL_15;
LABEL_4:
      v19 = v12[v16] + (float)(v22 * -0.5);
      v7[v16] = v19;
      if (v19 > v18 || v16 == 0)
        v18 = v19;
      if (++v16 == v10)
        goto LABEL_24;
    }
    v25 = 0;
LABEL_15:
    v34 = v15 - v25;
    v35 = v25;
    v36 = &v24->f32[v35];
    v37 = &v23->f32[v35];
    v38 = &v17->f32[v35];
    do
    {
      v39 = *v38++;
      v40 = v39;
      v41 = *v37++;
      v42 = (float)(v40 - v41) * (float)(v40 - v41);
      v43 = *v36++;
      v22 = v22 + (float)(v42 * v43);
      --v34;
    }
    while (v34);
    goto LABEL_4;
  }
  v18 = *v12 + (float)(*(float *)(v14 + 56 * *v13 + 48) * -0.5);
  *v6 = v18;
  if ((_DWORD)v10 == 1)
    goto LABEL_25;
  v45 = v10 - 1;
  v46 = v6 + 1;
  v47 = v13 + 1;
  v48 = v12 + 1;
  do
  {
    v49 = *v48++;
    v50 = v49;
    v51 = *v47++;
    v52 = v50 + (float)(*(float *)(v14 + 56 * v51 + 48) * -0.5);
    *v46++ = v52;
    if (v52 > v18)
      v18 = v52;
    --v45;
  }
  while (v45);
LABEL_24:
  if (v10 < 2)
  {
LABEL_25:
    v53 = 0;
    v44 = 0.0;
LABEL_29:
    v58 = v10 - v53;
    v59 = &v7[v53];
    do
    {
      v60 = *v59++;
      v44 = v44 + expf(v60 - v18);
      --v58;
    }
    while (v58);
    goto LABEL_31;
  }
  v53 = v10 & 0xFFFFFFFE;
  v54 = v7 + 1;
  v44 = 0.0;
  v55 = v53;
  do
  {
    v56 = *v54 - v18;
    v57 = expf(*(v54 - 1) - v18);
    v44 = v44 + v57 + expf(v56);
    v54 += 2;
    v55 -= 2;
  }
  while (v55);
  if (v53 != v10)
    goto LABEL_29;
LABEL_31:
  v61 = log(v44) + v18;
  MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  return v61;
}

void NGaussianMixtureModels::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = v4 + 48 * *a2;
  v6 = *(unsigned int *)(v5 + 16);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(v5 + 8);
    v9 = *(_QWORD *)(a3 + 8);
    v10 = (_QWORD *)(v4 + 48 * *a2 + 32);
    v11 = *(_QWORD *)(a4 + 8);
    v12 = 4 * v6;
    v13 = 0.0;
    do
    {
      v14 = *(unsigned int *)(v8 + v7);
      if (*(_BYTE *)(v9 + v14))
        v13 = v13 + expf(*(float *)(*v10 + v7) + *(float *)(v11 + 4 * v14));
      v7 += 4;
    }
    while (v12 != v7);
    if (v13 != 0.0)
      log(v13);
  }
}

void NGaussianMixtureModels::posteriorWeightedMean(uint64_t a1, unsigned int *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  float *v11;
  unsigned int *v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  float32x4_t *v18;
  double v19;
  long double v20;
  uint64_t v21;
  float v22;
  float32x4_t *v23;
  float32x4_t *v24;
  uint64_t v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  uint64_t v35;
  float *v36;
  float *v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  double *v44;
  uint64_t v45;
  float v46;
  float v47;
  unsigned int v48;
  long double v49;
  double v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  float64x2_t *v54;
  uint64_t v55;
  float64x2_t v56;
  uint64_t v57;
  double *v58;
  uint64_t v59;
  uint64_t v60;
  double v61;
  uint64_t v62;
  uint64_t v63;
  float32x2_t *v64;
  float32x4_t *v65;
  float32x4_t *v66;
  float32x2_t *v67;
  uint64_t v68;
  float32x4_t v69;
  uint64_t v70;
  uint64_t v71;
  float *v72;
  float *v73;
  float v74;
  float v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  BOOL v81;
  float64x2_t v82;
  float32x2_t *v83;
  float32x2_t *v84;
  uint64_t v85;
  float32x2_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  float *v90;
  float *v91;
  float v92;
  float v93;
  uint64_t v94;
  _QWORD *v95;
  double *v96;

  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 48 * *a2 + 16);
  v96 = (double *)operator new[]();
  if (!(_DWORD)v8)
    Error::chuck((Error *)"NGaussianMixtureModels::posteriorWeightedMean() - mixture %d has no components", v9, *a2);
  v95 = a4;
  v10 = *(_QWORD *)(a1 + 8) + 48 * *a2;
  v11 = *(float **)(v10 + 32);
  v12 = *(unsigned int **)(v10 + 8);
  v13 = *(_QWORD *)(a1 + 32);
  v16 = *(_DWORD *)(a3 + 16);
  v14 = (unsigned int *)(a3 + 16);
  v15 = v16;
  v94 = a1;
  if (v16)
  {
    v17 = 0;
    v18 = (float32x4_t *)*((_QWORD *)v14 - 1);
    v19 = 0.0;
    while (1)
    {
      v21 = v13 + 56 * v12[v17];
      v22 = *(float *)(v21 + 48);
      v23 = *(float32x4_t **)(v21 + 8);
      v24 = *(float32x4_t **)(v21 + 32);
      if (v15 >= 8)
      {
        v26 = v24 + 1;
        v27 = v23 + 1;
        v28 = v18 + 1;
        v29 = v15 & 0xFFFFFFF8;
        do
        {
          v30 = vsubq_f32(v28[-1], v27[-1]);
          v31 = vsubq_f32(*v28, *v27);
          v32 = vmulq_f32(vmulq_f32(v30, v30), v26[-1]);
          v33 = vmulq_f32(vmulq_f32(v31, v31), *v26);
          v22 = (float)((float)((float)((float)((float)((float)((float)(v22 + v32.f32[0]) + v32.f32[1]) + v32.f32[2])
                                              + v32.f32[3])
                                      + v33.f32[0])
                              + v33.f32[1])
                      + v33.f32[2])
              + v33.f32[3];
          v26 += 2;
          v27 += 2;
          v28 += 2;
          v29 -= 8;
        }
        while (v29);
        v25 = v15 & 0xFFFFFFF8;
        if (v25 == v15)
          goto LABEL_4;
      }
      else
      {
        v25 = 0;
      }
      v34 = v15 - v25;
      v35 = v25;
      v36 = &v24->f32[v35];
      v37 = &v23->f32[v35];
      v38 = &v18->f32[v35];
      do
      {
        v39 = *v38++;
        v40 = v39;
        v41 = *v37++;
        v42 = (float)(v40 - v41) * (float)(v40 - v41);
        v43 = *v36++;
        v22 = v22 + (float)(v42 * v43);
        --v34;
      }
      while (v34);
LABEL_4:
      v20 = exp((float)(v11[v17] + (float)(v22 * -0.5)));
      v96[v17] = v20;
      v19 = v19 + v20;
      if (++v17 == v8)
        goto LABEL_15;
    }
  }
  v19 = 0.0;
  v44 = v96;
  v45 = v8;
  do
  {
    v46 = *v11++;
    v47 = v46;
    v48 = *v12++;
    v49 = exp((float)(v47 + (float)(*(float *)(v13 + 56 * v48 + 48) * -0.5)));
    *v44++ = v49;
    v19 = v19 + v49;
    --v45;
  }
  while (v45);
LABEL_15:
  v50 = 1.0 / v19;
  if (v8 >= 4)
  {
    v51 = v8 & 0xFFFFFFFC;
    v54 = (float64x2_t *)(v96 + 2);
    v55 = v51;
    v53 = v94;
    v52 = v95;
    do
    {
      v56 = vmulq_n_f64(*v54, v50);
      v54[-1] = vmulq_n_f64(v54[-1], v50);
      *v54 = v56;
      v54 += 2;
      v55 -= 4;
    }
    while (v55);
    if (v51 == v8)
    {
LABEL_22:
      (*(void (**)(_QWORD *, unsigned int *))(*v52 + 32))(v52, v14);
      v59 = *v14;
      if (!(_DWORD)v59)
        goto LABEL_49;
      v60 = 0;
      v61 = *v96;
      v62 = *(_QWORD *)(v53 + 8);
      v63 = *(_QWORD *)(v53 + 32);
      v64 = *(float32x2_t **)(v63 + 56 * **(unsigned int **)(v62 + 48 * *a2 + 8) + 8);
      v65 = (float32x4_t *)v52[1];
      if (v59 < 8)
        goto LABEL_28;
      if ((unint64_t)((char *)v65 - (char *)v64) <= 0x1F)
        goto LABEL_28;
      v60 = v59 & 0xFFFFFFF8;
      v66 = v65 + 1;
      v67 = v64 + 2;
      v68 = v60;
      do
      {
        v69 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(*v67), v61)), vmulq_n_f64(vcvt_hight_f64_f32(*(float32x4_t *)v67->f32), v61));
        v66[-1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v67[-2]), v61)), vmulq_n_f64(vcvt_hight_f64_f32(*(float32x4_t *)v67[-2].f32), v61));
        *v66 = v69;
        v66 += 2;
        v67 += 4;
        v68 -= 8;
      }
      while (v68);
      if (v60 != v59)
      {
LABEL_28:
        v70 = v59 - v60;
        v71 = 4 * v60;
        v72 = &v65->f32[v60];
        v73 = (float *)((char *)v64 + v71);
        do
        {
          v74 = *v73++;
          v75 = v61 * v74;
          *v72++ = v75;
          --v70;
        }
        while (v70);
      }
      if (v8 < 2)
LABEL_49:
        JUMPOUT(0x212BAC9C0);
      v76 = v52[1];
      v77 = *(_QWORD *)(v62 + 48 * *a2 + 8);
      v78 = 1;
      while (1)
      {
        v79 = *(uint64_t *)&v96[v78];
        v80 = *(_QWORD *)(v63 + 56 * *(unsigned int *)(v77 + 4 * v78) + 8);
        if (v59 >= 4 && (v76 < v80 + 4 * v59 ? (v81 = v80 >= v76 + 4 * v59) : (v81 = 1), v81))
        {
          v82 = (float64x2_t)vdupq_lane_s64(v79, 0);
          v83 = (float32x2_t *)(v80 + 8);
          v84 = (float32x2_t *)(v76 + 8);
          v85 = v59 & 0xFFFFFFFC;
          do
          {
            v86 = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(*v84), vcvtq_f64_f32(*v83), v82));
            v84[-1] = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(v84[-1]), vcvtq_f64_f32(v83[-1]), v82));
            *v84 = v86;
            v84 += 2;
            v83 += 2;
            v85 -= 4;
          }
          while (v85);
          v87 = v59 & 0xFFFFFFFC;
          if (v87 == v59)
            goto LABEL_32;
        }
        else
        {
          v87 = 0;
        }
        v88 = v59 - v87;
        v89 = 4 * v87;
        v90 = (float *)(v76 + 4 * v87);
        v91 = (float *)(v80 + v89);
        do
        {
          v92 = *v91++;
          v93 = *v90 + *(double *)&v79 * v92;
          *v90++ = v93;
          --v88;
        }
        while (v88);
LABEL_32:
        if (++v78 == v8)
          goto LABEL_49;
      }
    }
  }
  else
  {
    v51 = 0;
    v52 = v95;
    v53 = v94;
  }
  v57 = v8 - v51;
  v58 = &v96[v51];
  do
  {
    *v58 = v50 * *v58;
    ++v58;
    --v57;
  }
  while (v57);
  goto LABEL_22;
}

void sub_20D9C7340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  MEMORY[0x212BAC9C0](a14, 0x1000C8000313F17);
  _Unwind_Resume(a1);
}

uint64_t NGaussianMixtureModels::posteriors(uint64_t a1, unsigned int *a2, uint64_t a3, _QWORD *a4)
{
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  long double v19;
  float32_t v20;
  uint64_t v21;
  float v22;
  float32x4_t *v23;
  float32x4_t *v24;
  uint64_t v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  uint64_t v35;
  float *v36;
  float *v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float *v44;
  uint64_t v45;
  float v46;
  float v47;
  unsigned int v48;
  float v49;
  long double v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t *v53;
  uint64_t v54;
  float32x4_t v55;
  uint64_t v56;
  float *v57;
  uint64_t v59;
  unsigned int v60;

  v60 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 48 * *a2 + 16);
  v9 = operator new[]();
  if (!v60)
    Error::chuck((Error *)"NGaussianMixtureModels::posteriorWeightedMean() - mixture %d has no components", v8, *a2);
  (*(void (**)(_QWORD *, unsigned int *))(*a4 + 32))(a4, &v60);
  v10 = v60;
  if (v60)
  {
    v59 = v9;
    v11 = *(_QWORD *)(a1 + 8) + 48 * *a2;
    v12 = *(float **)(v11 + 32);
    v13 = *(unsigned int **)(v11 + 8);
    v14 = *(_QWORD *)(a1 + 32);
    v15 = *(unsigned int *)(a3 + 16);
    v16 = (float32x4_t *)a4[1];
    if ((_DWORD)v15)
    {
      v17 = 0;
      v18 = *(float32x4_t **)(a3 + 8);
      v19 = 0.0;
      while (1)
      {
        v21 = v14 + 56 * v13[v17];
        v22 = *(float *)(v21 + 48);
        v23 = *(float32x4_t **)(v21 + 8);
        v24 = *(float32x4_t **)(v21 + 32);
        if (v15 >= 8)
        {
          v26 = v24 + 1;
          v27 = v23 + 1;
          v28 = v18 + 1;
          v29 = v15 & 0xFFFFFFF8;
          do
          {
            v30 = vsubq_f32(v28[-1], v27[-1]);
            v31 = vsubq_f32(*v28, *v27);
            v32 = vmulq_f32(vmulq_f32(v30, v30), v26[-1]);
            v33 = vmulq_f32(vmulq_f32(v31, v31), *v26);
            v22 = (float)((float)((float)((float)((float)((float)((float)(v22 + v32.f32[0]) + v32.f32[1]) + v32.f32[2])
                                                + v32.f32[3])
                                        + v33.f32[0])
                                + v33.f32[1])
                        + v33.f32[2])
                + v33.f32[3];
            v26 += 2;
            v27 += 2;
            v28 += 2;
            v29 -= 8;
          }
          while (v29);
          v25 = v15 & 0xFFFFFFF8;
          if (v25 == v15)
            goto LABEL_5;
        }
        else
        {
          v25 = 0;
        }
        v34 = v15 - v25;
        v35 = v25;
        v36 = &v24->f32[v35];
        v37 = &v23->f32[v35];
        v38 = &v18->f32[v35];
        do
        {
          v39 = *v38++;
          v40 = v39;
          v41 = *v37++;
          v42 = (float)(v40 - v41) * (float)(v40 - v41);
          v43 = *v36++;
          v22 = v22 + (float)(v42 * v43);
          --v34;
        }
        while (v34);
LABEL_5:
        v20 = v12[v17] + (float)(v22 * -0.5);
        v16->f32[v17] = v20;
        v19 = v19 + exp(v20);
        if (++v17 == v10)
          goto LABEL_16;
      }
    }
    v19 = 0.0;
    v44 = (float *)v16;
    v45 = v60;
    do
    {
      v46 = *v12++;
      v47 = v46;
      v48 = *v13++;
      v49 = v47 + (float)(*(float *)(v14 + 56 * v48 + 48) * -0.5);
      *v44++ = v49;
      v19 = v19 + exp(v49);
      --v45;
    }
    while (v45);
LABEL_16:
    v50 = log(v19);
    *(float *)&v50 = v50;
    if (v10 < 8)
    {
      v51 = 0;
      v9 = v59;
LABEL_21:
      v56 = v10 - v51;
      v57 = &v16->f32[v51];
      do
      {
        *v57 = *v57 - *(float *)&v50;
        ++v57;
        --v56;
      }
      while (v56);
      return MEMORY[0x212BAC9C0](v9, 0x1000C8000313F17);
    }
    v51 = v10 & 0xFFFFFFF8;
    v52 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v50, 0);
    v53 = v16 + 1;
    v54 = v51;
    v9 = v59;
    do
    {
      v55 = vsubq_f32(*v53, v52);
      v53[-1] = vsubq_f32(v53[-1], v52);
      *v53 = v55;
      v53 += 2;
      v54 -= 8;
    }
    while (v54);
    if (v51 != v10)
      goto LABEL_21;
  }
  return MEMORY[0x212BAC9C0](v9, 0x1000C8000313F17);
}

void sub_20D9C7658(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8000313F17);
  _Unwind_Resume(a1);
}

uint64_t AccelLoga::init(uint64_t this, const unsigned int *a2, float a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = 1;
  *(float *)(this + 8) = a3;
  return this;
}

void AccelLoga::run(AccelLoga *this, float *__A)
{
  int v4;

  if (!*((_BYTE *)this + 4))
    Error::chuck((Error *)"AccelLoga::run - AccelLoga::init() has to be called before running", (const char *)__A);
  vDSP_vsadd(__A, 1, (const float *)this + 2, __A, 1, *(unsigned int *)this);
  v4 = *(_DWORD *)this;
  vvlogf(__A, __A, &v4);
}

float AccelLoga::getScalingFactor(AccelLoga *this)
{
  return *((float *)this + 3);
}

float AccelLoga::findMax(uint64_t a1, uint64_t a2)
{
  float *v2;
  float result;
  uint64_t v4;
  float v5;
  float v6;

  v2 = *(float **)(a2 + 8);
  result = *v2;
  v4 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v4)
  {
    do
    {
      v5 = *v2++;
      v6 = v5;
      if (v5 > result)
        result = v6;
      --v4;
    }
    while (v4);
  }
  if (result <= 0.0)
    return 1.0;
  return result;
}

void NPhoneHMMArray::~NPhoneHMMArray(NPhoneHMMArray *this)
{
  NPhoneHMMArray::~NPhoneHMMArray(this);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)this = &off_24C7F18D0;
  *((_QWORD *)this + 3) = &off_24C7F2AD0;
  *((_QWORD *)this + 4) = &off_24C7F2CD8;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F14E0;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  *(_QWORD *)this = &off_24C7F2ED0;
  v7 = *((_QWORD *)this + 1);
  if (v7)
  {
    v8 = v7 - 16;
    v9 = *(_QWORD *)(v7 - 8);
    if (v9)
    {
      v10 = 48 * v9;
      v11 = v7 - 24;
      do
      {
        v12 = (_QWORD *)(v11 + v10);
        *(v12 - 3) = &off_24C7F34B8;
        *v12 = &off_24C7F32C0;
        v13 = *(_QWORD *)(v11 + v10 + 16);
        if (v13)
          MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
        *(v12 - 3) = &off_24C7F2E98;
        v14 = *(v12 - 2);
        if (v14)
          MEMORY[0x212BAC9C0](v14 - 16, 0x1000C8000313F17);
        v10 -= 48;
      }
      while (v10);
    }
    MEMORY[0x212BAC9C0](v8, 0x10B1C80FD921951);
  }
}

uint64_t NArray<NPhoneHMM>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _BYTE *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = v6 - 16;
        v8 = *(_QWORD *)(v6 - 8);
        if (v8)
        {
          v9 = 48 * v8;
          v10 = v6 - 24;
          do
          {
            v11 = (_QWORD *)(v10 + v9);
            *(v11 - 3) = &off_24C7F34B8;
            *v11 = &off_24C7F32C0;
            v12 = *(_QWORD *)(v10 + v9 + 16);
            if (v12)
              MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
            *(v11 - 3) = &off_24C7F2E98;
            v13 = *(v11 - 2);
            if (v13)
              MEMORY[0x212BAC9C0](v13 - 16, 0x1000C8000313F17);
            v9 -= 48;
          }
          while (v9);
        }
        MEMORY[0x212BAC9C0](v7, 0x10B1C80FD921951);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v14 = v5;
      v15 = (_QWORD *)operator new[]();
      *v15 = 48;
      v15[1] = v5;
      v16 = v15 + 2;
      if (v5)
      {
        v17 = v15;
        v18 = 0;
        v19 = 48 * v14;
        do
        {
          v20 = &v17[v18 / 8];
          v20[2] = &off_24C7F34B8;
          v20[3] = 0;
          v21 = (uint64_t)&v17[v18 / 8 + 2];
          *(_DWORD *)(v21 + 16) = 0;
          *(_QWORD *)(v21 + 24) = &off_24C7F32C0;
          *(_DWORD *)(v21 + 32) = 0;
          v22 = (_BYTE *)operator new[]();
          v17[v18 / 8 + 7] = v22;
          *v22 = 0;
          v18 += 48;
        }
        while (v19 != v18);
      }
      *(_QWORD *)(a1 + 8) = v16;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v23 = 0;
      do
      {
        v24 = *(_QWORD *)(a2 + 8);
        v25 = *(_QWORD *)(a1 + 8);
        if (v25 != v24)
        {
          v26 = v24 + 48 * v23;
          v27 = v25 + 48 * v23;
          v28 = *(unsigned int *)(v27 + 16);
          v29 = *(unsigned int *)(v26 + 16);
          if (v28 != v29)
          {
            v30 = *(_QWORD *)(v27 + 8);
            if (v30)
            {
              MEMORY[0x212BAC9C0](v30 - 16, 0x1000C8000313F17);
              v29 = *(unsigned int *)(v26 + 16);
            }
            *(_DWORD *)(v27 + 16) = v29;
            v31 = (_QWORD *)operator new[]();
            *v31 = 8;
            v31[1] = v29;
            *(_QWORD *)(v27 + 8) = v31 + 2;
            v28 = *(unsigned int *)(v27 + 16);
          }
          if (v28)
          {
            v32 = 0;
            do
            {
              *(_QWORD *)(*(_QWORD *)(v27 + 8) + 8 * v32) = *(_QWORD *)(*(_QWORD *)(v26 + 8) + 8 * v32);
              ++v32;
            }
            while (v32 < *(unsigned int *)(v27 + 16));
          }
          (*(void (**)(unint64_t, _QWORD, unint64_t))(*(_QWORD *)(v25 + 48 * v23 + 24) + 64))(v25 + 48 * v23 + 24, *(_QWORD *)(v24 + 48 * v23 + 40), v24 + 48 * v23 + 32);
        }
        ++v23;
      }
      while (v23 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void sub_20D9C814C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v6;

  *v4 = &off_24C7F2E98;
  v6 = v4[1];
  if (v6)
    MEMORY[0x212BAC9C0](v6 - 16, 0x1000C8000313F17);
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x212BAC9C0](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NArray<NPhoneHMM>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = v7 - 16;
      v10 = *(_QWORD *)(v7 - 8);
      if (v10)
      {
        v11 = 48 * v10;
        v12 = v7 - 24;
        do
        {
          v13 = (_QWORD *)(v12 + v11);
          *(v13 - 3) = &off_24C7F34B8;
          *v13 = &off_24C7F32C0;
          v14 = *(_QWORD *)(v12 + v11 + 16);
          if (v14)
            MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
          *(v13 - 3) = &off_24C7F2E98;
          v15 = *(v13 - 2);
          if (v15)
            MEMORY[0x212BAC9C0](v15 - 16, 0x1000C8000313F17);
          v11 -= 48;
        }
        while (v11);
      }
      MEMORY[0x212BAC9C0](v9, 0x10B1C80FD921951);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v16 = v6;
    result = operator new[]();
    *(_QWORD *)result = 48;
    *(_QWORD *)(result + 8) = v6;
    v17 = result + 16;
    if (v6)
    {
      v18 = result;
      v19 = 0;
      v20 = 48 * v16;
      do
      {
        v21 = v18 + v19;
        *(_QWORD *)(v21 + 16) = &off_24C7F34B8;
        *(_QWORD *)(v21 + 24) = 0;
        v22 = v18 + v19 + 16;
        *(_DWORD *)(v22 + 16) = 0;
        *(_QWORD *)(v22 + 24) = &off_24C7F32C0;
        *(_DWORD *)(v22 + 32) = 0;
        result = operator new[]();
        *(_QWORD *)(v18 + v19 + 56) = result;
        *(_BYTE *)result = 0;
        v19 += 48;
      }
      while (v20 != v19);
    }
    *(_QWORD *)(v4 + 8) = v17;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v23 = 0;
    do
    {
      v24 = *(_QWORD *)(v4 + 8);
      if (v24 != a2)
      {
        v25 = a2 + 48 * v23;
        v26 = v24 + 48 * v23;
        v27 = *(unsigned int *)(v26 + 16);
        v28 = *(unsigned int *)(v25 + 16);
        if (v27 != v28)
        {
          v29 = *(_QWORD *)(v26 + 8);
          if (v29)
          {
            MEMORY[0x212BAC9C0](v29 - 16, 0x1000C8000313F17);
            v28 = *(unsigned int *)(v25 + 16);
          }
          *(_DWORD *)(v26 + 16) = v28;
          v30 = (_QWORD *)operator new[]();
          *v30 = 8;
          v30[1] = v28;
          *(_QWORD *)(v26 + 8) = v30 + 2;
          v27 = *(unsigned int *)(v26 + 16);
        }
        if (v27)
        {
          v31 = 0;
          do
          {
            *(_QWORD *)(*(_QWORD *)(v26 + 8) + 8 * v31) = *(_QWORD *)(*(_QWORD *)(v25 + 8) + 8 * v31);
            ++v31;
          }
          while (v31 < *(unsigned int *)(v26 + 16));
        }
        result = (*(uint64_t (**)(unint64_t, _QWORD, unint64_t))(*(_QWORD *)(v24 + 48 * v23 + 24)
                                                                                       + 64))(v24 + 48 * v23 + 24, *(_QWORD *)(a2 + 48 * v23 + 40), a2 + 48 * v23 + 32);
      }
      ++v23;
    }
    while (v23 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

void sub_20D9C8440(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v6;

  *v4 = &off_24C7F2E98;
  v6 = v4[1];
  if (v6)
    MEMORY[0x212BAC9C0](v6 - 16, 0x1000C8000313F17);
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x212BAC9C0](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NArray<NPhoneHMM>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 48;
    *(_QWORD *)(result + 8) = v3;
    v27 = result + 16;
    if ((_DWORD)v3)
    {
      v7 = result;
      v8 = 0;
      v9 = 48 * v3;
      do
      {
        v10 = v7 + v8;
        *(_QWORD *)(v10 + 16) = &off_24C7F34B8;
        *(_QWORD *)(v10 + 24) = 0;
        v11 = v7 + v8 + 16;
        *(_DWORD *)(v11 + 16) = 0;
        *(_QWORD *)(v11 + 24) = &off_24C7F32C0;
        *(_DWORD *)(v11 + 32) = 0;
        result = operator new[]();
        *(_QWORD *)(v7 + v8 + 56) = result;
        *(_BYTE *)result = 0;
        v8 += 48;
      }
      while (v9 != v8);
    }
    *(_QWORD *)(v5 + 8) = v27;
    if ((_DWORD)v2 && *a2)
    {
      v12 = 0;
      do
      {
        v13 = *(_QWORD *)(v5 + 8);
        if (v13 != v6)
        {
          v14 = v6 + 48 * v12;
          v15 = v13 + 48 * v12;
          v16 = *(unsigned int *)(v15 + 16);
          v17 = *(unsigned int *)(v14 + 16);
          if (v16 != v17)
          {
            v18 = *(_QWORD *)(v15 + 8);
            if (v18)
            {
              MEMORY[0x212BAC9C0](v18 - 16, 0x1000C8000313F17);
              v17 = *(unsigned int *)(v14 + 16);
            }
            *(_DWORD *)(v15 + 16) = v17;
            v19 = (_QWORD *)operator new[]();
            *v19 = 8;
            v19[1] = v17;
            *(_QWORD *)(v15 + 8) = v19 + 2;
            v16 = *(unsigned int *)(v15 + 16);
          }
          if (v16)
          {
            v20 = 0;
            do
            {
              *(_QWORD *)(*(_QWORD *)(v15 + 8) + 8 * v20) = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 8 * v20);
              ++v20;
            }
            while (v20 < *(unsigned int *)(v15 + 16));
          }
          result = (*(uint64_t (**)(unint64_t, _QWORD, unint64_t))(*(_QWORD *)(v13 + 48 * v12 + 24)
                                                                                         + 64))(v13 + 48 * v12 + 24, *(_QWORD *)(v6 + 48 * v12 + 40), v6 + 48 * v12 + 32);
        }
        ++v12;
      }
      while (v12 < v2 && v12 < *a2);
    }
    if (v6)
    {
      v21 = *(_QWORD *)(v6 - 8);
      if (v21)
      {
        v22 = 48 * v21;
        v23 = v6 - 24;
        do
        {
          v24 = (_QWORD *)(v23 + v22);
          *(v24 - 3) = &off_24C7F34B8;
          *v24 = &off_24C7F32C0;
          v25 = *(_QWORD *)(v23 + v22 + 16);
          if (v25)
            MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
          *(v24 - 3) = &off_24C7F2E98;
          v26 = *(v24 - 2);
          if (v26)
            MEMORY[0x212BAC9C0](v26 - 16, 0x1000C8000313F17);
          v22 -= 48;
        }
        while (v22);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

void sub_20D9C8760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v14;

  *v12 = &off_24C7F2E98;
  v14 = v12[1];
  if (v14)
    MEMORY[0x212BAC9C0](v14 - 16, 0x1000C8000313F17);
  if (a10 != v12)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v10 - 32 + v11));
      v11 -= 48;
    }
    while (v11);
  }
  MEMORY[0x212BAC9C0](v10, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

void NPhoneHMM::~NPhoneHMM(NPhoneHMM *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C7F34B8;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *(_QWORD *)this = &off_24C7F2E98;
  v3 = *((_QWORD *)this + 1);
  if (v3)
    MEMORY[0x212BAC9C0](v3 - 16, 0x1000C8000313F17);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C7F34B8;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *(_QWORD *)this = &off_24C7F2E98;
  v3 = *((_QWORD *)this + 1);
  if (v3)
    MEMORY[0x212BAC9C0](v3 - 16, 0x1000C8000313F17);
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<NHMMState>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F2E98;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2 - 16, 0x1000C8000313F17);
  return a1;
}

void NArray<NHMMState>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F2E98;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1 - 16, 0x1000C8000313F17);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NHMMState>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6 - 16, 0x1000C8000313F17);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v7 = v5;
      v8 = (_QWORD *)operator new[]();
      *v8 = 8;
      v8[1] = v7;
      *(_QWORD *)(a1 + 8) = v8 + 2;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v9 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v9) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v9);
        ++v9;
      }
      while (v9 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<NHMMState>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  unint64_t v10;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7 - 16, 0x1000C8000313F17);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    v9 = v6;
    result = operator new[]();
    *(_QWORD *)result = 8;
    *(_QWORD *)(result + 8) = v9;
    *(_QWORD *)(v4 + 8) = result + 16;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v10 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * v10) = *(_QWORD *)(a2 + 8 * v10);
      ++v10;
    }
    while (v10 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NHMMState>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unint64_t v8;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 8;
    *(_QWORD *)(result + 8) = v3;
    *(_QWORD *)(v5 + 8) = result + 16;
    if ((_DWORD)v2)
      v7 = *a2 == 0;
    else
      v7 = 1;
    if (!v7)
    {
      v8 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8 * v8) = *(_QWORD *)(v6 + 8 * v8);
        ++v8;
      }
      while (v8 < v2 && v8 < *a2);
LABEL_11:
      JUMPOUT(0x212BAC9C0);
    }
    if (v6)
      goto LABEL_11;
  }
  return result;
}

_QWORD *NArray<NPhoneHMM>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2ED0;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 48 * v4;
      v6 = v2 - 24;
      do
      {
        v7 = (_QWORD *)(v6 + v5);
        *(v7 - 3) = &off_24C7F34B8;
        *v7 = &off_24C7F32C0;
        v8 = *(_QWORD *)(v6 + v5 + 16);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
        *(v7 - 3) = &off_24C7F2E98;
        v9 = *(v7 - 2);
        if (v9)
          MEMORY[0x212BAC9C0](v9 - 16, 0x1000C8000313F17);
        v5 -= 48;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x10B1C80FD921951);
  }
  return a1;
}

void NArray<NPhoneHMM>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = &off_24C7F2ED0;
  v1 = a1[1];
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = 48 * v3;
      v5 = v1 - 24;
      do
      {
        v6 = (_QWORD *)(v5 + v4);
        *(v6 - 3) = &off_24C7F34B8;
        *v6 = &off_24C7F32C0;
        v7 = *(_QWORD *)(v5 + v4 + 16);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
        *(v6 - 3) = &off_24C7F2E98;
        v8 = *(v6 - 2);
        if (v8)
          MEMORY[0x212BAC9C0](v8 - 16, 0x1000C8000313F17);
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2, 0x10B1C80FD921951);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::removeElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a2)
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(a1 + 8);
  if (v3 == v5)
  {
    *v4 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *v4 = *(_QWORD *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      v7 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != a2);
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(a2 + 8);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F14E0;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void NLinkedList<NMap<NString,unsigned int>::HashItem>::~NLinkedList(uint64_t a1)
{
  uint64_t i;

  *(_QWORD *)a1 = off_24C7F14E0;
  for (i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 8);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  JUMPOUT(0x212BAC9D8);
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    for (i = *(_QWORD *)(a2 + 8); i; i = *(_QWORD *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::prepend(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
    *(_QWORD *)(result + 8) = v3;
  else
    *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::append(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v3 = (uint64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 16);
    v3 = (uint64_t *)(a1 + 8);
  }
  *v4 = result;
  *v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v8;
  int i;

  v3 = *(unsigned int *)a2;
  v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4)
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  if (!(_DWORD)v3)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32);
    return v6(a1, a3);
  }
  if ((_DWORD)v3 == v4)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40);
    return v6(a1, a3);
  }
  v8 = *(_QWORD *)(a1 + 8);
  for (i = v3 - 1; i; --i)
    v8 = *(_QWORD *)(v8 + 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::reset(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = *(_QWORD *)(result + 8); i; i = *(_QWORD *)(v1 + 8))
  {
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(i + 8);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
  }
  *(_QWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::newElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C7F3620;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = &off_24C7F32C0;
  *(_DWORD *)(v3 + 24) = *(_DWORD *)(a2 + 8);
  v4 = (void *)operator new[]();
  *(_QWORD *)(v3 + 32) = v4;
  memcpy(v4, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 24);
  return v3;
}

void sub_20D9C93A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10B1C4036FAF639);
  _Unwind_Resume(a1);
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::deleteElement(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

_QWORD *NLinkedList<NMap<NString,unsigned int>::HashItem>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3620;
  a1[2] = &off_24C7F32C0;
  v2 = a1[4];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  return a1;
}

void NLinkedList<NMap<NString,unsigned int>::HashItem>::NElement::~NElement(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3620;
  a1[2] = &off_24C7F32C0;
  v1 = a1[4];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::~NArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2CD8;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F14E0;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::~NArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2CD8;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F14E0;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 - 8);
        if (v7)
        {
          v8 = v6 + 32 * v7;
          v9 = v8;
          do
          {
            *(_QWORD *)(v9 - 32) = off_24C7F14E0;
            v9 -= 32;
            for (i = *(_QWORD *)(v9 + 8); i; i = *(_QWORD *)(v8 - 24))
            {
              *(_QWORD *)(v8 - 24) = *(_QWORD *)(i + 8);
              (*(void (**)(uint64_t))(*(_QWORD *)(v8 - 32) + 72))(v9);
            }
            *(_QWORD *)(v8 - 16) = 0;
            *(_DWORD *)(v8 - 8) = 0;
            v8 = v9;
          }
          while (v9 != v6);
        }
        MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80F4A7E088);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      v11 = (_QWORD *)operator new[]();
      *v11 = 32;
      v11[1] = v5;
      v12 = v11 + 2;
      if (v5)
      {
        v13 = v11 + 2;
        do
        {
          v13[1] = 0;
          v13[2] = 0;
          *v13 = off_24C7F14E0;
          *((_DWORD *)v13 + 6) = 0;
          v13 += 4;
        }
        while (v13 != &v12[4 * v5]);
      }
      *(_QWORD *)(a1 + 8) = v12;
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v14 = 0;
      v15 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v14) + 24))(*(_QWORD *)(a1 + 8) + v14, *(_QWORD *)(a2 + 8) + v14);
        ++v15;
        v14 += 32;
      }
      while (v15 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = v7 + 32 * v9;
        v11 = v10;
        do
        {
          *(_QWORD *)(v11 - 32) = off_24C7F14E0;
          v11 -= 32;
          for (i = *(_QWORD *)(v11 + 8); i; i = *(_QWORD *)(v10 - 24))
          {
            *(_QWORD *)(v10 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v10 - 32) + 72))(v11);
          }
          *(_QWORD *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          v10 = v11;
        }
        while (v11 != v7);
      }
      MEMORY[0x212BAC9C0](v7 - 16, 0x10A1C80F4A7E088);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)result = 32;
    *(_QWORD *)(result + 8) = v6;
    v13 = result + 16;
    if (v6)
    {
      v14 = result + 16;
      do
      {
        *(_QWORD *)(v14 + 8) = 0;
        *(_QWORD *)(v14 + 16) = 0;
        *(_QWORD *)v14 = off_24C7F14E0;
        *(_DWORD *)(v14 + 24) = 0;
        v14 += 32;
      }
      while (v14 != v13 + 32 * v6);
    }
    *(_QWORD *)(v4 + 8) = v13;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v15 = 0;
    v16 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + v15) + 24))(*(_QWORD *)(v4 + 8) + v15, a2 + v15);
      ++v16;
      v15 += 32;
    }
    while (v16 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;

  v2 = *(unsigned int *)(result + 16);
  v3 = *a2;
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = v3;
    result = operator new[]();
    *(_QWORD *)result = 32;
    *(_QWORD *)(result + 8) = v3;
    v7 = result + 16;
    if ((_DWORD)v3)
    {
      v8 = result + 16;
      do
      {
        *(_QWORD *)(v8 + 8) = 0;
        *(_QWORD *)(v8 + 16) = 0;
        *(_QWORD *)v8 = off_24C7F14E0;
        *(_DWORD *)(v8 + 24) = 0;
        v8 += 32;
      }
      while (v8 != v7 + 32 * v3);
    }
    *(_QWORD *)(v5 + 8) = v7;
    if ((_DWORD)v2 && *a2)
    {
      v9 = 0;
      v10 = 1;
      do
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v5 + 8) + v9) + 24))(*(_QWORD *)(v5 + 8) + v9, v6 + v9);
        if (v10 >= v2)
          break;
        v9 += 32;
      }
      while (v10++ < *a2);
    }
    if (v6)
    {
      v12 = *(_QWORD *)(v6 - 8);
      if (v12)
      {
        v13 = v6 + 32 * v12;
        v14 = v13;
        do
        {
          *(_QWORD *)(v14 - 32) = off_24C7F14E0;
          v14 -= 32;
          for (i = *(_QWORD *)(v14 + 8); i; i = *(_QWORD *)(v13 - 24))
          {
            *(_QWORD *)(v13 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v13 - 32) + 72))(v14);
          }
          *(_QWORD *)(v13 - 16) = 0;
          *(_DWORD *)(v13 - 8) = 0;
          v13 = v14;
        }
        while (v14 != v6);
      }
      JUMPOUT(0x212BAC9C0);
    }
  }
  return result;
}

_QWORD *NMap<NString,unsigned int>::~NMap(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2AD0;
  a1[1] = &off_24C7F2CD8;
  v2 = a1[2];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F14E0;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NMap<NString,unsigned int>::~NMap(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2AD0;
  a1[1] = &off_24C7F2CD8;
  v1 = a1[2];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F14E0;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

void NPhoneHMMArray::NPhoneHMMArray(NPhoneHMMArray *this)
{
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_24C7F18D0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 3) = &off_24C7F16B0;
  *((_QWORD *)this + 4) = &off_24C7F2BF8;
}

{
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_24C7F18D0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 3) = &off_24C7F16B0;
  *((_QWORD *)this + 4) = &off_24C7F2BF8;
}

_QWORD *NStringHash<unsigned int>::~NStringHash(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2AD0;
  a1[1] = &off_24C7F2CD8;
  v2 = a1[2];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F14E0;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NStringHash<unsigned int>::~NStringHash(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2AD0;
  a1[1] = &off_24C7F2CD8;
  v1 = a1[2];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F14E0;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

_QWORD *NHash<NMap<NString,unsigned int>::HashItem>::~NHash(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2CD8;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F14E0;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NHash<NMap<NString,unsigned int>::HashItem>::~NHash(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2CD8;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F14E0;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NPhoneHMMArray::read(NPhoneHMMArray *this, const NString *a2, const unsigned int *a3)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  const char *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  float v29;
  float v30;
  unint64_t v31;
  const char *v32;
  int v33;
  uint64_t v34;
  float v35;
  double v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t result;
  const NString *v52;
  uint64_t v54;
  unsigned int v55;
  uint64_t (**v56)(NString *__hidden, const unsigned int *);
  int v57;
  char *v58;
  char v59;
  _QWORD v60[2];
  uint64_t v61;
  uint64_t (**i)();
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t (**v66)();
  _QWORD *v67;
  unsigned int v68;
  uint64_t (**v69)();
  uint64_t v70;
  _WORD *v71;
  float v72;
  __int16 v73;
  uint64_t (**v74)();
  uint64_t v75;
  int v76;
  uint64_t (**v77)();
  uint64_t v78;

  v69 = (uint64_t (**)())&off_24C7F32C0;
  LODWORD(v70) = 1;
  v71 = (_WORD *)operator new[]();
  *v71 = 114;
  v77 = (uint64_t (**)())&off_24C7F33E0;
  v78 = 0;
  NFilePtr::open((NFilePtr *)&v77, a2, (const NString *)&v69);
  v52 = a2;
  v69 = (uint64_t (**)())&off_24C7F32C0;
  if (v71)
    MEMORY[0x212BAC9C0](v71, 0x1000C8077774924);
  v54 = 0;
  LODWORD(v6) = 0;
  v74 = &off_24C7F2E28;
  v75 = 0;
  v76 = 0;
  v69 = &off_24C7F1048;
  v70 = 0;
  v71 = 0;
  v72 = 2.0;
  v73 = 257;
  v7 = v78;
  if (!v78)
LABEL_58:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v5);
  while ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7))
  {
    if (!v78)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    v59 = 35;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, char *))(*(_QWORD *)v78 + 80))(v60, v78, &v59);
    v56 = &off_24C7F32C0;
    v57 = 4;
    v58 = (char *)operator new[]();
    strcpy(v58, "\r\n\t ");
    v55 = -1;
    i = off_24C7F13C0;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    NString::split((uint64_t)v60, (uint64_t)&i, (uint64_t)&v56, &v55);
    v66 = &off_24C7F2E28;
    v9 = v65;
    v10 = (_QWORD *)operator new[]();
    *v10 = 24;
    v10[1] = v9;
    if ((_DWORD)v9)
    {
      v11 = 0;
      v12 = 24 * v9;
      do
      {
        v10[v11 / 8 + 2] = &off_24C7F32C0;
        LODWORD(v10[v11 / 8 + 3]) = 0;
        v13 = (_BYTE *)operator new[]();
        v10[v11 / 8 + 4] = v13;
        *v13 = 0;
        v11 += 24;
      }
      while (v12 != v11);
    }
    v67 = v10 + 2;
    v68 = v65;
    v14 = v63;
    if (v63)
    {
      v15 = 0;
      do
      {
        (*(void (**)(_QWORD *, uint64_t))(v67[3 * v15] + 32))(&v67[3 * v15], v14 + 16);
        ++v15;
        v14 = *(_QWORD *)(v14 + 8);
      }
      while (v14);
    }
    NArray<NString>::operator=((uint64_t)&v74, (uint64_t)&v66);
    v66 = &off_24C7F2E28;
    v16 = v67;
    if (v67)
    {
      v17 = *(v67 - 1);
      if (v17)
      {
        v18 = 3 * v17;
        do
        {
          v16[v18 - 3] = &off_24C7F32C0;
          v19 = v16[v18 - 1];
          if (v19)
            MEMORY[0x212BAC9C0](v19, 0x1000C8077774924);
          v18 -= 3;
        }
        while (v18 * 8);
      }
      MEMORY[0x212BAC9C0](v16 - 2, 0x1091C800F2A5985);
    }
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v5))
    {
      v5 = (const char *)v63;
      if (!v63)
        break;
      v63 = *(_QWORD *)(v63 + 8);
    }
    v64 = 0;
    v65 = 0;
    if (v58)
      MEMORY[0x212BAC9C0](v58, 0x1000C8077774924);
    v60[0] = &off_24C7F32C0;
    if (v61)
      MEMORY[0x212BAC9C0](v61, 0x1000C8077774924);
    v6 = (v6 + 1);
    if (v76)
    {
      if (v76 == 1)
        Error::chuck((Error *)"NPhoneHMMArray::read() - bad file format on line %d of file %s", v5, v6, *((_QWORD *)v52 + 2));
      v20 = v75;
      v21 = v54;
      if (v54 >= v71)
      {
        if (!HIBYTE(v73))
          Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v5, v71, v54);
        if (v54 >= HIDWORD(v71))
        {
          if ((_DWORD)v54 == -1)
            Error::chuck((Error *)"NAutoArray::operator[] - access out of integer bound", v5);
          LODWORD(i) = v54 + 1;
          ((void (*)(uint64_t (***)(), uint64_t (***)(), _QWORD))v69[6])(&v69, &i, (float)(v72 * (float)(v54 + 1)));
          v21 = v54;
        }
        else
        {
          LODWORD(v71) = v54 + 1;
        }
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v70 + 48 * v21 + 24) + 32))(v70 + 48 * v21 + 24, v20);
      LODWORD(v66) = 0;
      LODWORD(v66) = strtoul(*(const char **)(v75 + 40), 0, 10);
      if (v76 != 2 * (_DWORD)v66 + 2)
        Error::chuck((Error *)"NPhoneHMMArray::read() - bad file format on line %d of file %s", v22, v6, *((_QWORD *)v52 + 2));
      v23 = v54;
      if (v54 >= v71)
      {
        if (!HIBYTE(v73))
          Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v22, v71, v54);
        if (v54 >= HIDWORD(v71))
        {
          LODWORD(i) = v54 + 1;
          ((void (*)(uint64_t (***)(), uint64_t (***)(), _QWORD))v69[6])(&v69, &i, (float)(v72 * (float)(v54 + 1)));
          v23 = v54;
        }
        else
        {
          LODWORD(v71) = v54 + 1;
        }
      }
      v24 = v23;
      v25 = v23;
      (*(void (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)(v70 + 48 * v23) + 32))(v70 + 48 * v23, &v66);
      v26 = v25 + 1;
      if ((_DWORD)v66)
      {
        v27 = 0;
        v28 = 0;
        v29 = (float)v26;
        do
        {
          v31 = strtoul(*(const char **)(v75 + 24 * (v27 + 2) + 16), 0, 10);
          v33 = v31;
          v34 = *a3 - 1;
          if (v34 < v31)
            Error::chuck((Error *)"NPhoneHMMArray::read() - Index %d out of range 0-%d on line %d of file %s", v32, v31, v34, v6, *((_QWORD *)v52 + 2));
          v35 = atof(*(const char **)(v75 + 24 * (v27 + 3) + 16));
          v36 = v35;
          if (v35 <= 1.0)
            Error::chuck((Error *)"NPhoneHMMArray::read() - Duration %f less than or equal to 1.0 on line %d of file %s", v5, v35, v6, *((_QWORD *)v52 + 2));
          v37 = v71;
          v38 = v54;
          if (v54 >= v71)
          {
            if (!HIBYTE(v73))
              goto LABEL_80;
            if (v54 >= HIDWORD(v71))
            {
              LODWORD(i) = v26;
              ((void (*)(uint64_t (***)(), uint64_t (***)(), _QWORD))v69[6])(&v69, &i, (float)(v72 * v29));
              v38 = v54;
            }
            else
            {
              LODWORD(v71) = v26;
            }
          }
          v39 = *(_QWORD *)(v70 + 48 * v24 + 8);
          *(_DWORD *)(v39 + 4 * v27) = v33;
          v37 = v71;
          if (v38 >= v71)
          {
            if (!HIBYTE(v73))
LABEL_80:
              Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v5, v37, v54);
            if (v38 < HIDWORD(v71))
            {
              LODWORD(v71) = v26;
            }
            else
            {
              LODWORD(i) = v26;
              ((void (*)(uint64_t (***)(), uint64_t (***)(), _QWORD))v69[6])(&v69, &i, (float)(v72 * v29));
              v39 = *(_QWORD *)(v70 + 48 * v24 + 8);
            }
          }
          v30 = 1.0 - 1.0 / v36;
          *(float *)(v39 + 4 * v27 + 4) = v30;
          ++v28;
          v27 += 2;
        }
        while (v28 < v66);
      }
      v54 = v26;
      v7 = v78;
      if (!v78)
        goto LABEL_58;
    }
    else
    {
      v7 = v78;
      if (!v78)
        goto LABEL_58;
    }
  }
  NArray<NPhoneHMM>::operator=((uint64_t)this, (uint64_t)&v69);
  v69 = &off_24C7F2ED0;
  if (v70)
  {
    v40 = v70 - 16;
    v41 = *(_QWORD *)(v70 - 8);
    if (v41)
    {
      v42 = 48 * v41;
      v43 = v70 - 24;
      do
      {
        v44 = (_QWORD *)(v43 + v42);
        *(v44 - 3) = &off_24C7F34B8;
        *v44 = &off_24C7F32C0;
        v45 = *(_QWORD *)(v43 + v42 + 16);
        if (v45)
          MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
        *(v44 - 3) = &off_24C7F2E98;
        v46 = *(v44 - 2);
        if (v46)
          MEMORY[0x212BAC9C0](v46 - 16, 0x1000C8000313F17);
        v42 -= 48;
      }
      while (v42);
    }
    MEMORY[0x212BAC9C0](v40, 0x10B1C80FD921951);
  }
  v74 = &off_24C7F2E28;
  v47 = v75;
  if (v75)
  {
    v48 = *(_QWORD *)(v75 - 8);
    if (v48)
    {
      v49 = 24 * v48;
      do
      {
        *(_QWORD *)(v47 + v49 - 24) = &off_24C7F32C0;
        v50 = *(_QWORD *)(v47 + v49 - 8);
        if (v50)
          MEMORY[0x212BAC9C0](v50, 0x1000C8077774924);
        v49 -= 24;
      }
      while (v49);
    }
    MEMORY[0x212BAC9C0](v47 - 16, 0x1091C800F2A5985);
  }
  v77 = &off_24C7F17F8;
  result = v78;
  if (v78)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
  return result;
}

void sub_20D9CA83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t (**a40)(),uint64_t a41)
{
  uint64_t v41;

  NAutoArray<NPhoneHMM>::~NAutoArray(&a33);
  NArray<NString>::~NArray((_QWORD *)(v41 - 160));
  a40 = &off_24C7F17F8;
  if (a41)
    (*(void (**)(uint64_t))(*(_QWORD *)a41 + 8))(a41);
  _Unwind_Resume(a1);
}

_QWORD *NAutoArray<NPhoneHMM>::~NAutoArray(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  *a1 = &off_24C7F2ED0;
  v2 = a1[1];
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = 48 * v4;
      v6 = v2 - 24;
      do
      {
        v7 = (_QWORD *)(v6 + v5);
        *(v7 - 3) = &off_24C7F34B8;
        *v7 = &off_24C7F32C0;
        v8 = *(_QWORD *)(v6 + v5 + 16);
        if (v8)
          MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
        *(v7 - 3) = &off_24C7F2E98;
        v9 = *(v7 - 2);
        if (v9)
          MEMORY[0x212BAC9C0](v9 - 16, 0x1000C8000313F17);
        v5 -= 48;
      }
      while (v5);
    }
    MEMORY[0x212BAC9C0](v3, 0x10B1C80FD921951);
  }
  return a1;
}

void NAutoArray<NPhoneHMM>::~NAutoArray(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = &off_24C7F2ED0;
  v1 = a1[1];
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = 48 * v3;
      v5 = v1 - 24;
      do
      {
        v6 = (_QWORD *)(v5 + v4);
        *(v6 - 3) = &off_24C7F34B8;
        *v6 = &off_24C7F32C0;
        v7 = *(_QWORD *)(v5 + v4 + 16);
        if (v7)
          MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
        *(v6 - 3) = &off_24C7F2E98;
        v8 = *(v6 - 2);
        if (v8)
          MEMORY[0x212BAC9C0](v8 - 16, 0x1000C8000313F17);
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x212BAC9C0](v2, 0x10B1C80FD921951);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NAutoArray<NPhoneHMM>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  __int128 *v16;
  _BYTE *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t (**v29)();
  __int128 v30;
  __int128 v31;
  _BYTE *v32;

  v6 = *(_DWORD *)(a2 + 16);
  v4 = a2 + 16;
  v5 = v6;
  v7 = *(_DWORD *)(a1 + 20);
  v8 = v6 >= v7;
  if (v6 <= v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    if (!v8)
    {
      do
      {
        v32 = 0;
        v30 = 0u;
        v31 = 0u;
        v29 = (uint64_t (**)())&off_24C7F34B8;
        *(_QWORD *)&v31 = &off_24C7F32C0;
        v32 = (_BYTE *)operator new[]();
        *v32 = 0;
        v9 = *(_QWORD *)(a1 + 8);
        v10 = v9 + 48 * v5;
        if ((uint64_t (***)())v10 != &v29)
        {
          v11 = *(unsigned int *)(v10 + 16);
          v12 = DWORD2(v30);
          if (v11 != DWORD2(v30))
          {
            v13 = *(_QWORD *)(v10 + 8);
            if (v13)
            {
              MEMORY[0x212BAC9C0](v13 - 16, 0x1000C8000313F17);
              v12 = DWORD2(v30);
            }
            *(_DWORD *)(v10 + 16) = v12;
            v14 = (_QWORD *)operator new[]();
            *v14 = 8;
            v14[1] = v12;
            *(_QWORD *)(v10 + 8) = v14 + 2;
            v11 = *(unsigned int *)(v10 + 16);
          }
          if (v11)
          {
            v15 = 0;
            do
            {
              *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8 * v15) = *(_QWORD *)(v30 + 8 * v15);
              ++v15;
            }
            while (v15 < *(unsigned int *)(v10 + 16));
          }
        }
        v16 = (__int128 *)(v9 + 48 * v5 + 24);
        v17 = v32;
        if (v16 != &v31)
        {
          (*(void (**)(__int128 *, _BYTE *, char *))(*(_QWORD *)v16 + 64))(v16, v32, (char *)&v31 + 8);
          v17 = v32;
        }
        v29 = (uint64_t (**)())&off_24C7F34B8;
        *(_QWORD *)&v31 = &off_24C7F32C0;
        if (v17)
          MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
        v29 = &off_24C7F2E98;
        if ((_QWORD)v30)
          MEMORY[0x212BAC9C0](v30 - 16, 0x1000C8000313F17);
        ++v5;
      }
      while (v5 < *(unsigned int *)(a1 + 20));
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, v4, (float)(*(float *)(a1 + 24) * (float)v5));
  }
  if (*(_DWORD *)(a1 + 16))
  {
    v18 = 0;
    do
    {
      v19 = *(_QWORD *)(a2 + 8);
      v20 = *(_QWORD *)(a1 + 8);
      if (v20 != v19)
      {
        v21 = v19 + 48 * v18;
        v22 = v20 + 48 * v18;
        v23 = *(unsigned int *)(v22 + 16);
        v24 = *(unsigned int *)(v21 + 16);
        if (v23 != v24)
        {
          v25 = *(_QWORD *)(v22 + 8);
          if (v25)
          {
            MEMORY[0x212BAC9C0](v25 - 16, 0x1000C8000313F17);
            v24 = *(unsigned int *)(v21 + 16);
          }
          *(_DWORD *)(v22 + 16) = v24;
          v26 = (_QWORD *)operator new[]();
          *v26 = 8;
          v26[1] = v24;
          *(_QWORD *)(v22 + 8) = v26 + 2;
          v23 = *(unsigned int *)(v22 + 16);
        }
        if (v23)
        {
          v27 = 0;
          do
          {
            *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8 * v27) = *(_QWORD *)(*(_QWORD *)(v21 + 8) + 8 * v27);
            ++v27;
          }
          while (v27 < *(unsigned int *)(v22 + 16));
        }
        (*(void (**)(unint64_t, _QWORD, unint64_t))(*(_QWORD *)(v20 + 48 * v18 + 24) + 64))(v20 + 48 * v18 + 24, *(_QWORD *)(v19 + 48 * v18 + 40), v19 + 48 * v18 + 32);
      }
      ++v18;
    }
    while (v18 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

void sub_20D9CAEEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  NPhoneHMM::~NPhoneHMM((NPhoneHMM *)va);
  _Unwind_Resume(a1);
}

void sub_20D9CAF00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12 - 16, 0x1000C8000313F17);
  _Unwind_Resume(exception_object);
}

uint64_t NAutoArray<NPhoneHMM>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;

  v4 = result;
  v5 = *a3;
  if (*(_DWORD *)(result + 20) < *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      v8 = v7 - 16;
      v9 = *(_QWORD *)(v7 - 8);
      if (v9)
      {
        v10 = 48 * v9;
        v11 = v7 - 24;
        do
        {
          v12 = (_QWORD *)(v11 + v10);
          *(v12 - 3) = &off_24C7F34B8;
          *v12 = &off_24C7F32C0;
          v13 = *(_QWORD *)(v11 + v10 + 16);
          if (v13)
            MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
          *(v12 - 3) = &off_24C7F2E98;
          v14 = *(v12 - 2);
          if (v14)
            MEMORY[0x212BAC9C0](v14 - 16, 0x1000C8000313F17);
          v10 -= 48;
        }
        while (v10);
      }
      MEMORY[0x212BAC9C0](v8, 0x10B1C80FD921951);
      v5 = *a3;
    }
    *(_DWORD *)(v4 + 20) = v5;
    v15 = v5;
    result = operator new[]();
    *(_QWORD *)result = 48;
    *(_QWORD *)(result + 8) = v5;
    v29 = result + 16;
    if (v5)
    {
      v16 = result;
      v17 = 0;
      do
      {
        v18 = v16 + v17;
        *(_QWORD *)(v18 + 16) = &off_24C7F34B8;
        *(_QWORD *)(v18 + 24) = 0;
        v19 = v16 + v17 + 16;
        *(_DWORD *)(v19 + 16) = 0;
        *(_QWORD *)(v19 + 24) = &off_24C7F32C0;
        *(_DWORD *)(v19 + 32) = 0;
        result = operator new[]();
        *(_QWORD *)(v16 + v17 + 56) = result;
        *(_BYTE *)result = 0;
        v17 += 48;
      }
      while (48 * v15 != v17);
    }
    *(_QWORD *)(v4 + 8) = v29;
    v5 = *a3;
  }
  *(_DWORD *)(v4 + 16) = v5;
  if (v5)
  {
    v20 = 0;
    do
    {
      v21 = *(_QWORD *)(v4 + 8);
      if (v21 != a2)
      {
        v22 = a2 + 48 * v20;
        v23 = v21 + 48 * v20;
        v24 = *(unsigned int *)(v23 + 16);
        v25 = *(unsigned int *)(v22 + 16);
        if (v24 != v25)
        {
          v26 = *(_QWORD *)(v23 + 8);
          if (v26)
          {
            MEMORY[0x212BAC9C0](v26 - 16, 0x1000C8000313F17);
            v25 = *(unsigned int *)(v22 + 16);
          }
          *(_DWORD *)(v23 + 16) = v25;
          v27 = (_QWORD *)operator new[]();
          *v27 = 8;
          v27[1] = v25;
          *(_QWORD *)(v23 + 8) = v27 + 2;
          v24 = *(unsigned int *)(v23 + 16);
        }
        if (v24)
        {
          v28 = 0;
          do
          {
            *(_QWORD *)(*(_QWORD *)(v23 + 8) + 8 * v28) = *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8 * v28);
            ++v28;
          }
          while (v28 < *(unsigned int *)(v23 + 16));
        }
        result = (*(uint64_t (**)(unint64_t, _QWORD, unint64_t))(*(_QWORD *)(v21 + 48 * v20 + 24)
                                                                                       + 64))(v21 + 48 * v20 + 24, *(_QWORD *)(a2 + 48 * v20 + 40), a2 + 48 * v20 + 32);
      }
      ++v20;
    }
    while (v20 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

void sub_20D9CB1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v14;

  *v12 = &off_24C7F2E98;
  v14 = v12[1];
  if (v14)
    MEMORY[0x212BAC9C0](v14 - 16, 0x1000C8000313F17);
  if (a10 != v12)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v10 - 32 + v11));
      v11 -= 48;
    }
    while (v11);
  }
  MEMORY[0x212BAC9C0](v10, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NAutoArray<NPhoneHMM>::operator=(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

_BYTE *NAutoArray<NPhoneHMM>::resize(_BYTE *result, unsigned int *a2, unsigned int a3)
{
  _BYTE *v3;
  unsigned int v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;

  v3 = result;
  v4 = *a2;
  if (*a2 <= a3)
    v5 = a3;
  else
    v5 = v4;
  v29 = v5;
  if ((_DWORD)v5)
  {
    v6 = (_QWORD *)operator new[]();
    v7 = 0;
    *v6 = 48;
    v6[1] = v5;
    v8 = v6 + 2;
    do
    {
      v9 = &v6[v7];
      v9[2] = &off_24C7F34B8;
      v9[3] = 0;
      v10 = (uint64_t)&v6[v7 + 2];
      *(_DWORD *)(v10 + 16) = 0;
      *(_QWORD *)(v10 + 24) = &off_24C7F32C0;
      *(_DWORD *)(v10 + 32) = 0;
      result = (_BYTE *)operator new[]();
      v6[v7 + 7] = result;
      *result = 0;
      v7 += 6;
    }
    while (2 * (v5 + 2 * v5) != v7);
    v4 = *a2;
  }
  else
  {
    v8 = 0;
  }
  v11 = *((_DWORD *)v3 + 4);
  if (v4 < v11)
  {
    *((_DWORD *)v3 + 4) = v4;
    v11 = v4;
  }
  if (v11)
  {
    v12 = 0;
    do
    {
      v13 = (_QWORD *)*((_QWORD *)v3 + 1);
      if (v8 != v13)
      {
        v14 = &v13[6 * v12];
        v15 = &v8[6 * v12];
        v16 = *((unsigned int *)v15 + 4);
        v17 = *((unsigned int *)v14 + 4);
        if (v16 != v17)
        {
          v18 = v15[1];
          if (v18)
          {
            MEMORY[0x212BAC9C0](v18 - 16, 0x1000C8000313F17);
            v17 = *((unsigned int *)v14 + 4);
          }
          *((_DWORD *)v15 + 4) = v17;
          v19 = (_QWORD *)operator new[]();
          *v19 = 8;
          v19[1] = v17;
          v15[1] = v19 + 2;
          v16 = *((unsigned int *)v15 + 4);
        }
        if (v16)
        {
          v20 = 0;
          do
          {
            *(_QWORD *)(v15[1] + 8 * v20) = *(_QWORD *)(v14[1] + 8 * v20);
            ++v20;
          }
          while (v20 < *((unsigned int *)v15 + 4));
        }
        result = (_BYTE *)(*(uint64_t (**)(_QWORD *, _QWORD, _QWORD *))(v8[6 * v12 + 3] + 64))(&v8[6 * v12 + 3], v13[6 * v12 + 5], &v13[6 * v12 + 4]);
      }
      ++v12;
    }
    while (v12 < *((unsigned int *)v3 + 4));
  }
  v21 = *((_QWORD *)v3 + 1);
  if (v21)
  {
    v22 = v21 - 16;
    v23 = *(_QWORD *)(v21 - 8);
    if (v23)
    {
      v24 = 48 * v23;
      v25 = v21 - 24;
      do
      {
        v26 = (_QWORD *)(v25 + v24);
        *(v26 - 3) = &off_24C7F34B8;
        *v26 = &off_24C7F32C0;
        v27 = *(_QWORD *)(v25 + v24 + 16);
        if (v27)
          MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
        *(v26 - 3) = &off_24C7F2E98;
        v28 = *(v26 - 2);
        if (v28)
          MEMORY[0x212BAC9C0](v28 - 16, 0x1000C8000313F17);
        v24 -= 48;
      }
      while (v24);
    }
    result = (_BYTE *)MEMORY[0x212BAC9C0](v22, 0x10B1C80FD921951);
  }
  *((_QWORD *)v3 + 1) = v8;
  *((_DWORD *)v3 + 4) = *a2;
  *((_DWORD *)v3 + 5) = v29;
  return result;
}

void sub_20D9CB4F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v6;

  *v4 = &off_24C7F2E98;
  v6 = v4[1];
  if (v6)
    MEMORY[0x212BAC9C0](v6 - 16, 0x1000C8000313F17);
  if (v2 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v3));
      v3 -= 48;
    }
    while (v3);
  }
  MEMORY[0x212BAC9C0](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NPhoneHMMArray::write(NPhoneHMMArray *this, const NString *a2)
{
  const char *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  uint64_t (**v24)(NString *, const unsigned int *);
  unsigned int v25;
  void *v26;
  uint64_t (**v27)();
  uint64_t v28;
  char __str[8];
  int v30;
  _WORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  v30 = 1;
  v31 = (_WORD *)operator new[]();
  *v31 = 119;
  v27 = (uint64_t (**)())&off_24C7F33E0;
  v28 = 0;
  NFilePtr::open((NFilePtr *)&v27, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v31)
    MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
  if (*((_DWORD *)this + 4))
  {
    v5 = 0;
    do
    {
      if (!v28)
        goto LABEL_43;
      (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v28 + 96))(v28, *((_QWORD *)this + 1) + 48 * v5 + 24);
      v6 = v28;
      if (!v28)
        goto LABEL_43;
      *(_QWORD *)__str = &off_24C7F32C0;
      v30 = 1;
      v31 = (_WORD *)operator new[]();
      memcpy(v31, "\t", (v30 + 1));
      (*(void (**)(uint64_t, char *))(*(_QWORD *)v6 + 96))(v6, __str);
      *(_QWORD *)__str = &off_24C7F32C0;
      if (v31)
        MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
      v7 = v28;
      if (!v28)
        goto LABEL_43;
      v8 = *((_QWORD *)this + 1) + 48 * v5;
      v24 = &off_24C7F32C0;
      if ((snprintf(__str, 0x80uLL, "%d", *(_DWORD *)(v8 + 16)) - 129) <= 0xFFFFFF7F)
        Error::chuck((Error *)"NString::NString: cannot convert int to string", v9);
      v25 = strlen(__str);
      v26 = (void *)(*v24)((NString *)&v24, &v25);
      memcpy(v26, __str, v25 + 1);
      (*(void (**)(uint64_t, uint64_t (***)(NString *, const unsigned int *)))(*(_QWORD *)v7 + 96))(v7, &v24);
      v24 = &off_24C7F32C0;
      if (v26)
        MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
      v10 = v28;
      if (!v28)
        goto LABEL_43;
      *(_QWORD *)__str = &off_24C7F32C0;
      v30 = 1;
      v31 = (_WORD *)operator new[]();
      memcpy(v31, "\t", (v30 + 1));
      (*(void (**)(uint64_t, char *))(*(_QWORD *)v10 + 96))(v10, __str);
      *(_QWORD *)__str = &off_24C7F32C0;
      if (v31)
        MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
      v11 = *((_QWORD *)this + 1);
      if (*(_DWORD *)(v11 + 48 * v5 + 16))
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v14 = v28;
          if (!v28)
            goto LABEL_40;
          v15 = *(_QWORD *)(v11 + 48 * v5 + 8);
          v24 = &off_24C7F32C0;
          if ((snprintf(__str, 0x80uLL, "%d", *(_DWORD *)(v15 + v12)) - 129) <= 0xFFFFFF7F)
            Error::chuck((Error *)"NString::NString: cannot convert int to string", v16);
          v25 = strlen(__str);
          v26 = (void *)(*v24)((NString *)&v24, &v25);
          memcpy(v26, __str, v25 + 1);
          (*(void (**)(uint64_t, uint64_t (***)(NString *, const unsigned int *)))(*(_QWORD *)v14 + 96))(v14, &v24);
          v24 = &off_24C7F32C0;
          if (v26)
            MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
          v17 = v28;
          if (!v28)
            goto LABEL_40;
          *(_QWORD *)__str = &off_24C7F32C0;
          v30 = 1;
          v31 = (_WORD *)operator new[]();
          memcpy(v31, "\t", (v30 + 1));
          (*(void (**)(uint64_t, char *))(*(_QWORD *)v17 + 96))(v17, __str);
          *(_QWORD *)__str = &off_24C7F32C0;
          if (v31)
            MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
          v18 = v28;
          if (!v28)
            goto LABEL_40;
          v19 = 1.0 / (1.0 - *(float *)(*(_QWORD *)(*((_QWORD *)this + 1) + 48 * v5 + 8) + v12 + 4));
          v24 = &off_24C7F32C0;
          if ((snprintf(__str, 0x200uLL, "%f", v19) - 513) <= 0xFFFFFDFF)
            Error::chuck((Error *)"NString::NString: cannot convert double to string", v20);
          v25 = strlen(__str);
          v26 = (void *)(*v24)((NString *)&v24, &v25);
          memcpy(v26, __str, v25 + 1);
          (*(void (**)(uint64_t, uint64_t (***)(NString *, const unsigned int *)))(*(_QWORD *)v18 + 96))(v18, &v24);
          v24 = &off_24C7F32C0;
          if (v26)
            MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
          v21 = v28;
          if (!v28)
LABEL_40:
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v4);
          *(_QWORD *)__str = &off_24C7F32C0;
          v30 = 1;
          v31 = (_WORD *)operator new[]();
          memcpy(v31, "\t", (v30 + 1));
          (*(void (**)(uint64_t, char *))(*(_QWORD *)v21 + 96))(v21, __str);
          *(_QWORD *)__str = &off_24C7F32C0;
          if (v31)
            MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
          ++v13;
          v11 = *((_QWORD *)this + 1);
          v12 += 8;
        }
        while (v13 < *(unsigned int *)(v11 + 48 * v5 + 16));
      }
      v22 = v28;
      if (!v28)
LABEL_43:
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v4);
      *(_QWORD *)__str = &off_24C7F32C0;
      v30 = 1;
      v31 = (_WORD *)operator new[]();
      memcpy(v31, "\n", (v30 + 1));
      (*(void (**)(uint64_t, char *))(*(_QWORD *)v22 + 96))(v22, __str);
      *(_QWORD *)__str = &off_24C7F32C0;
      if (v31)
        MEMORY[0x212BAC9C0](v31, 0x1000C8077774924);
      ++v5;
    }
    while (v5 < *((unsigned int *)this + 4));
  }
  v27 = &off_24C7F17F8;
  result = v28;
  if (v28)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
  return result;
}

void sub_20D9CBB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 8))(a14);
  if (a17)
  {
    MEMORY[0x212BAC9C0](a17, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *NPhoneHMMArray::initReverseLookup(_DWORD *this)
{
  _DWORD *v1;
  unint64_t v2;
  uint64_t v3;

  if (!this[13])
  {
    v1 = this;
    this = (_DWORD *)NHash<NMap<NString,unsigned int>::HashItem>::resize((uint64_t)(this + 8), this[4], 0);
    if (v1[4])
    {
      v2 = 0;
      v3 = 24;
      do
      {
        this = (_DWORD *)NMap<NString,unsigned int>::operator[]((uint64_t)(v1 + 6), *((_QWORD *)v1 + 1) + v3);
        *this = v2++;
        v3 += 48;
      }
      while (v2 < v1[4]);
    }
  }
  return this;
}

uint64_t NHash<NMap<NString,unsigned int>::HashItem>::resize(uint64_t result, unsigned int a2, char a3)
{
  uint64_t v3;
  unsigned int v4;
  const char *v5;
  unint64_t v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t j;
  uint64_t v13;
  unsigned int v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t m;
  int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t (**k)();
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t (**v30)();
  uint64_t v31;
  int v32;
  uint64_t v33;

  if (*(_DWORD *)(result + 20) != a2)
  {
    v3 = result;
    v32 = 0;
    v30 = &off_24C7F2BF8;
    v31 = 0;
    if (!a3 && a2 - 1 >= 2)
    {
      v4 = a2 | 1;
      if ((a2 & 0xFFFFFFFE) >= 3)
      {
        while (v4 >= 9)
        {
          v23 = 5;
          while (v4 % (v23 - 2))
          {
            v24 = v23 * v23;
            v23 += 2;
            if (v24 > v4)
              goto LABEL_5;
          }
          a2 = v4 + 2;
          v25 = v4 + 1;
          v4 += 2;
          if (v25 < 3)
            goto LABEL_6;
        }
      }
LABEL_5:
      a2 = v4;
    }
LABEL_6:
    LODWORD(v33) = a2;
    result = NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::resize((uint64_t)&v30, &v33);
    HIDWORD(v33) = 0;
    k = off_24C7F14E0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v6 = *(unsigned int *)(v3 + 20);
    if ((_DWORD)v6)
    {
      for (i = 0; i < v6; ++i)
      {
        v8 = *(_QWORD *)(v3 + 8);
        if (!v8)
          Error::chuck((Error *)"NLinkedList::NIterator::start List not set", v5);
        v9 = *(_QWORD *)(v8 + 32 * i + 8);
        if (v9)
        {
          do
          {
            result = ((uint64_t (*)(uint64_t, uint64_t))k[8])((uint64_t)&k, v9 + 16);
            if (v27)
              v10 = (uint64_t *)(v28 + 8);
            else
              v10 = &v28;
            if (v27)
              v11 = 2;
            else
              v11 = 1;
            *v10 = result;
            (&k)[v11] = (uint64_t (**)())result;
            ++v29;
            v9 = *(_QWORD *)(v9 + 8);
          }
          while (v9);
          v6 = *(unsigned int *)(v3 + 20);
        }
      }
      for (j = v27; j; j = *(_QWORD *)(j + 8))
      {
        if (!(_DWORD)v33)
          Error::chuck((Error *)"NHash::insert() - zero length hash table", v5);
        v13 = *(unsigned int *)(j + 24);
        if ((_DWORD)v13)
        {
          v14 = 0;
          v15 = *(char **)(j + 32);
          do
          {
            v16 = *v15++;
            v14 = v16 + 65599 * v14;
            --v13;
          }
          while (v13);
        }
        else
        {
          v14 = 0;
        }
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v31 + 32 * (v14 % v33)) + 32))(v31 + 32 * (v14 % v33), j + 16);
        ++HIDWORD(v33);
      }
    }
    if (&v30 != (uint64_t (***)())v3)
    {
      *(_QWORD *)(v3 + 20) = v33;
      result = NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::operator=(v3, (uint64_t)&v30);
    }
    for (k = off_24C7F14E0; ; result = ((uint64_t (*)(uint64_t, uint64_t))k[9])((uint64_t)&k, v17))
    {
      v17 = v27;
      if (!v27)
        break;
      v27 = *(_QWORD *)(v27 + 8);
    }
    v30 = &off_24C7F2CD8;
    v18 = v31;
    if (v31)
    {
      v19 = *(_QWORD *)(v31 - 8);
      if (v19)
      {
        v20 = v31 + 32 * v19;
        v21 = v20;
        do
        {
          *(_QWORD *)(v21 - 32) = off_24C7F14E0;
          v21 -= 32;
          for (m = *(_QWORD *)(v21 + 8); m; m = *(_QWORD *)(v20 - 24))
          {
            *(_QWORD *)(v20 - 24) = *(_QWORD *)(m + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v20 - 32) + 72))(v21);
          }
          *(_QWORD *)(v20 - 16) = 0;
          *(_DWORD *)(v20 - 8) = 0;
          v20 = v21;
        }
        while (v21 != v18);
      }
      return MEMORY[0x212BAC9C0](v18 - 16, 0x10A1C80F4A7E088);
    }
  }
  return result;
}

void sub_20D9CBFF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  NLinkedList<NMap<NString,unsigned int>::HashItem>::~NLinkedList((uint64_t)&a9);
  NHash<NMap<NString,unsigned int>::HashItem>::~NHash(&a13);
  _Unwind_Resume(a1);
}

uint64_t NMap<NString,unsigned int>::operator[](uint64_t a1, uint64_t a2)
{
  size_t v4;
  char *v5;
  const char *v6;
  unsigned int v7;
  unsigned int v8;
  char *v9;
  size_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  size_t v16;
  unsigned int v17;
  char *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  void *v22;
  char *v23;
  uint64_t (**v25)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  int v28;

  v25 = &off_24C7F32C0;
  v4 = *(unsigned int *)(a2 + 8);
  LODWORD(__n) = *(_DWORD *)(a2 + 8);
  v5 = (char *)operator new[]();
  __s2 = v5;
  memcpy(v5, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v28 = 0;
  v7 = *(_DWORD *)(a1 + 28);
  if (!v7)
  {
    v23 = "NHash::contains() - zero length hash table";
    goto LABEL_29;
  }
  v8 = 0;
  if ((_DWORD)v4)
  {
    v9 = v5;
    v10 = v4;
    do
    {
      v11 = *v9++;
      v8 = v11 + 65599 * v8;
      --v10;
    }
    while (v10);
  }
  v12 = *(_QWORD *)(a1 + 16);
  v13 = *(_QWORD *)(v12 + 32 * (v8 % v7) + 8);
  if (v13)
  {
    while ((_DWORD)v4 != *(_DWORD *)(v13 + 24) || memcmp(*(const void **)(v13 + 32), v5, v4))
    {
      v13 = *(_QWORD *)(v13 + 8);
      if (!v13)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v14 = 0;
    if ((_DWORD)v4)
    {
      do
      {
        v15 = *v5++;
        v14 = v15 + 65599 * v14;
        --v4;
      }
      while (v4);
    }
    (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)(v12 + 32 * (v14 % v7)) + 32))(v12 + 32 * (v14 % v7), &v25);
    v7 = *(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 32);
  }
  if (!v7)
  {
    v23 = "NHash::get() - zero length hash table";
    goto LABEL_29;
  }
  v16 = __n;
  if ((_DWORD)__n)
  {
    v17 = 0;
    v18 = (char *)__s2;
    v19 = __n;
    do
    {
      v20 = *v18++;
      v17 = v20 + 65599 * v17;
      --v19;
    }
    while (v19);
  }
  else
  {
    v17 = 0;
  }
  v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v17 % v7) + 8);
  if (!v21)
  {
    v23 = "NLinkedList::get Attempted to get element that is not in list";
LABEL_29:
    Error::chuck((Error *)v23, v6, v25);
  }
  v22 = __s2;
  v23 = "NLinkedList::get Attempted to get element that is not in list";
  while ((_DWORD)v16 != *(_DWORD *)(v21 + 24) || memcmp(*(const void **)(v21 + 32), v22, v16))
  {
    v21 = *(_QWORD *)(v21 + 8);
    if (!v21)
      goto LABEL_29;
  }
  v25 = &off_24C7F32C0;
  if (v22)
    MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  return v21 + 40;
}

void sub_20D9CC2D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NPhoneHMMArray::endReverseLookup(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;

  if (*(_DWORD *)(this + 52))
  {
    v1 = this;
    v2 = 0;
    v3 = 0;
    do
    {
      (*(void (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(v1 + 40) + v2) + 56))(*(_QWORD *)(v1 + 40) + v2);
      ++v3;
      v2 += 32;
    }
    while (v3 < *(unsigned int *)(v1 + 52));
    *(_DWORD *)(v1 + 56) = 0;
    return NHash<NMap<NString,unsigned int>::HashItem>::resize(v1 + 32, 0, 1);
  }
  return this;
}

uint64_t NPhoneHMMArray::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  size_t v6;
  char *v7;
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  size_t v12;
  int v13;
  uint64_t v14;
  size_t v16;
  char *v17;
  const char *v18;
  unsigned int v19;
  unsigned int v20;
  char *v21;
  size_t v22;
  int v23;
  uint64_t v24;
  char *v25;

  if (!*(_DWORD *)(a1 + 52))
  {
    NHash<NMap<NString,unsigned int>::HashItem>::resize(a1 + 32, *(_DWORD *)(a1 + 16), 0);
    if (*(_DWORD *)(a1 + 16))
    {
      v4 = 0;
      v5 = 24;
      do
      {
        *(_DWORD *)NMap<NString,unsigned int>::operator[](a1 + 24, *(_QWORD *)(a1 + 8) + v5) = v4++;
        v5 += 48;
      }
      while (v4 < *(unsigned int *)(a1 + 16));
    }
  }
  v6 = *(unsigned int *)(a2 + 8);
  v7 = (char *)operator new[]();
  memcpy(v7, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v9 = *(_DWORD *)(a1 + 52);
  if (!v9)
    Error::chuck((Error *)"NHash::contains() - zero length hash table", v8);
  v10 = 0;
  if ((_DWORD)v6)
  {
    v11 = v7;
    v12 = v6;
    do
    {
      v13 = *v11++;
      v10 = v13 + 65599 * v10;
      --v12;
    }
    while (v12);
  }
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32 * (v10 % v9) + 8);
  if (!v14)
  {
LABEL_10:
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
    return 0xFFFFFFFFLL;
  }
  while ((_DWORD)v6 != *(_DWORD *)(v14 + 24) || memcmp(*(const void **)(v14 + 32), v7, v6))
  {
    v14 = *(_QWORD *)(v14 + 8);
    if (!v14)
      goto LABEL_10;
  }
  MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  v16 = *(unsigned int *)(a2 + 8);
  v17 = (char *)operator new[]();
  memcpy(v17, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v19 = *(_DWORD *)(a1 + 52);
  if (!v19)
  {
    v25 = "NHash::get() - zero length hash table";
    goto LABEL_27;
  }
  v20 = 0;
  if ((_DWORD)v16)
  {
    v21 = v17;
    v22 = v16;
    do
    {
      v23 = *v21++;
      v20 = v23 + 65599 * v20;
      --v22;
    }
    while (v22);
  }
  v24 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32 * (v20 % v19) + 8);
  if (!v24)
  {
    v25 = "NLinkedList::get Attempted to get element that is not in list";
LABEL_27:
    Error::chuck((Error *)v25, v18);
  }
  v25 = "NLinkedList::get Attempted to get element that is not in list";
  while ((_DWORD)v16 != *(_DWORD *)(v24 + 24) || memcmp(*(const void **)(v24 + 32), v17, v16))
  {
    v24 = *(_QWORD *)(v24 + 8);
    if (!v24)
      goto LABEL_27;
  }
  MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  return *(unsigned int *)(v24 + 40);
}

void sub_20D9CC5CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NPipeFile::~NPipeFile(NPipeFile *this, const char *a2)
{
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F34F0;
  if (*((_BYTE *)this + 52))
    Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  *((_BYTE *)this + 52) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

{
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F34F0;
  if (!*((_BYTE *)this + 52))
  {
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
    *((_BYTE *)this + 52) = 0;
    *(_QWORD *)this = off_24C7F3428;
    *((_QWORD *)this + 1) = &off_24C7F32C0;
    v3 = *((_QWORD *)this + 3);
    if (v3)
      MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
    JUMPOUT(0x212BAC9D8);
  }
  Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
}

{
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F34F0;
  if (*((_BYTE *)this + 52))
    Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  *((_BYTE *)this + 52) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

void NPipeFile::open(NPipeFile *this, const NString *a2, const NString *a3)
{
  const char *v6;
  _BYTE *v7;
  int v8;

  (*(void (**)(NPipeFile *))(*(_QWORD *)this + 24))(this);
  v7 = (_BYTE *)*((_QWORD *)a3 + 2);
  if (*((_DWORD *)a3 + 2) == 1)
  {
    if (*v7 == 114)
    {
      v8 = 0;
      goto LABEL_6;
    }
    v7 = (_BYTE *)*((_QWORD *)a3 + 2);
    if (*v7 == 119)
    {
      v8 = 1;
LABEL_6:
      *((_DWORD *)this + 12) = v8;
      *((_QWORD *)this + 5) = 0;
      Error::chuck((Error *)"NPipeFile::open() - Can't open pipe '\"%s\"' because compiled without support", v6, *((_QWORD *)a2 + 2));
    }
  }
  Error::chuck((Error *)"NPipeFile::open() - unrecognized file mode \"%s\"", v6, v7);
}

uint64_t NPipeFile::close(NPipeFile *this, const char *a2)
{
  char *v2;
  uint64_t result;
  int v4;

  if (*((_BYTE *)this + 52))
    Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
  v4 = 0;
  v2 = (char *)this + 8;
  result = (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  v2[44] = 0;
  return result;
}

uint64_t NPipeFile::isOpen(NPipeFile *this)
{
  return *((unsigned __int8 *)this + 52);
}

void NPipeFile::eof(NPipeFile *this, const char *a2)
{
  Error::chuck((Error *)"NPipeFile::eof() - Not available because compiled without support", a2);
}

uint64_t NPipeFile::good(NPipeFile *this)
{
  if (((*(uint64_t (**)(NPipeFile *))(*(_QWORD *)this + 40))(this) & 1) != 0)
    return 0;
  else
    return (*(uint64_t (**)(NPipeFile *))(*(_QWORD *)this + 32))(this);
}

uint64_t NPipeFile::read@<X0>(NPipeFile *this@<X0>, uint64_t a2@<X8>)
{
  _BYTE *v4;
  uint64_t result;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  int v7;
  uint64_t v8;
  int v9;

  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 0;
  v4 = (_BYTE *)operator new[]();
  *(_QWORD *)(a2 + 16) = v4;
  *v4 = 0;
  while (1)
  {
    result = (*(uint64_t (**)(NPipeFile *))(*(_QWORD *)this + 40))(this);
    if ((result & 1) != 0)
      break;
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), NPipeFile *, void *))(*(_QWORD *)this + 64))(&v6, this, &PFILE_READ_LENGTH);
    if (v7)
    {
      v9 = v7;
      (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a2 + 72))(a2, v8, &v9);
    }
    v6 = &off_24C7F32C0;
    if (v8)
      MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  }
  return result;
}

void sub_20D9CC970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;

  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  *v11 = v12;
  v14 = v11[2];
  if (v14)
    MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NPipeFile::read(NPipeFile *this, const unsigned int *a2)
{
  const char *v4;
  const char *v5;

  if (((*(uint64_t (**)(NPipeFile *))(*(_QWORD *)this + 32))(this) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1)
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in pipe \"%s\"", v4, *((_QWORD *)this + 3));
      *(_BYTE *)operator new[]() = 0;
      Error::chuck((Error *)"NPipeFile::read() - Can't read from pipe because compiled without support", v5);
    }
    Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" not opened in read mode", v4, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" is not open", v4, *((_QWORD *)this + 3));
}

void sub_20D9CCA70(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NPipeFile::read(NPipeFile *this, const unsigned int *a2, NString *a3)
{
  const char *v5;

  if (((*(uint64_t (**)(NPipeFile *, const unsigned int *, NString *))(*(_QWORD *)this + 32))(this, a2, a3) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1)
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in pipe \"%s\"", v5, *((_QWORD *)this + 3));
      Error::chuck((Error *)"NPipeFile::read() - Not available because compiled without support", v5);
    }
    Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" not opened in read mode", v5, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" is not open", v5, *((_QWORD *)this + 3));
}

void NPipeFile::readLine(NPipeFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v5;
  _BYTE *v6;
  const char *v7;

  if (((*(uint64_t (**)(NPipeFile *, const char *))(*(_QWORD *)this + 32))(this, a2) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
    {
      *(_QWORD *)a3 = &off_24C7F32C0;
      *(_DWORD *)(a3 + 8) = 0;
      v6 = (_BYTE *)operator new[]();
      *(_QWORD *)(a3 + 16) = v6;
      *v6 = 0;
      *(_BYTE *)operator new[]() = 0;
      Error::chuck((Error *)"NPipeFile::readLine() - Not available because compiled without support", v7);
    }
    Error::chuck((Error *)"NPipeFile::readLine() - pipe \"%s\" not opened in read mode", v5, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::readLine() - pipe \"%s\" is not open", v5, *((_QWORD *)this + 3));
}

void sub_20D9CCBDC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *v1 = v4;
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NPipeFile::readString(NPipeFile *this)
{
  const char *v2;

  if (((*(uint64_t (**)(NPipeFile *))(*(_QWORD *)this + 32))(this) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
      Error::chuck((Error *)"NPipeFile::readString() - Not available because compiled without support", v2);
    Error::chuck((Error *)"NPipeFile::readString() - pipe \"%s\" not opened in read mode", v2, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::readString() - pipe \"%s\" is not open", v2, *((_QWORD *)this + 3));
}

void NPipeFile::write(NPipeFile *this, const NString *a2)
{
  const char *v3;

  if (((*(uint64_t (**)(NPipeFile *, const NString *))(*(_QWORD *)this + 32))(this, a2) & 1) != 0)
  {
    if (*((_DWORD *)this + 12) == 1)
      Error::chuck((Error *)"NPipeFile::write() - Not available because compiled without support", v3);
    Error::chuck((Error *)"NPipeFile::write() - pipe \"%s\" not opened in write mode", v3, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::write() - pipe \"%s\" is not open", v3, *((_QWORD *)this + 3));
}

void NPipeFile::setPosition(NPipeFile *this, const char *a2)
{
  Error::chuck((Error *)"NPipeFile::setPosition() - not supported by NPipeFile", a2);
}

void NPipeFile::getPosition(NPipeFile *this, const char *a2)
{
  Error::chuck((Error *)"NPipeFile::getPosition() - not supported by NPipeFile", a2);
}

void NPipeFile::NPipeFile(NPipeFile *this)
{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F34F0;
  *((_BYTE *)this + 52) = 0;
}

{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F34F0;
  *((_BYTE *)this + 52) = 0;
}

void NPipeFile::NPipeFile(NPipeFile *this, const NString *a2, const NString *a3)
{
  _BYTE *v6;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F34F0;
  *((_BYTE *)this + 52) = 0;
  NPipeFile::open(this, a2, a3);
}

{
  _BYTE *v6;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F34F0;
  *((_BYTE *)this + 52) = 0;
  NPipeFile::open(this, a2, a3);
}

void sub_20D9CCE74(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  *v1 = v2;
  v1[1] = v3;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9CCF24(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  *v1 = v2;
  v1[1] = v3;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NFloatDistribution::~NFloatDistribution(NFloatDistribution *this)
{
  *(_QWORD *)this = &off_24C7F1DC8;
  NGaussianMixtureModels::~NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_24C7F1DC8;
  NGaussianMixtureModels::~NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
  JUMPOUT(0x212BAC9D8);
}

{
  *(_QWORD *)this = &off_24C7F1DC8;
  NGaussianMixtureModels::~NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

uint64_t NFloatDistribution::size(NFloatDistribution *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t NFloatDistribution::dimen(NFloatDistribution *this)
{
  return (uint64_t)this + 56;
}

uint64_t NDistribution::numFrames(NDistribution *this)
{
  return 1;
}

uint64_t NDistribution::frameSize(NDistribution *this)
{
  return (*(uint64_t (**)(NDistribution *))(*(_QWORD *)this + 24))(this);
}

uint64_t NDistribution::scoreCacheTypes(NDistribution *this)
{
  return 7;
}

uint64_t NFloatDistribution::read(NFloatDistribution *this, const NString *a2)
{
  return NGaussianMixtureModels::read((NFloatDistribution *)((char *)this + 8), a2);
}

float NFloatDistribution::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return NGaussianMixtureModels::score(a1 + 8, a2, a3);
}

uint64_t NDistribution::scoreAll(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  float v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v10 = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result)
  {
    do
    {
      v7 = (*(float (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)a1 + 64))(a1, &v10, a2);
      v8 = v10;
      *(float *)(*(_QWORD *)(a3 + 8) + 4 * v10) = v7;
      v9 = v8 + 1;
      v10 = v8 + 1;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    }
    while (v9 < result);
  }
  return result;
}

void NFloatDistribution::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = v4 + 48 * *a2;
  v6 = *(unsigned int *)(v5 + 16);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(v5 + 8);
    v9 = *(_QWORD *)(a3 + 8);
    v10 = (_QWORD *)(v4 + 48 * *a2 + 32);
    v11 = *(_QWORD *)(a4 + 8);
    v12 = 4 * v6;
    v13 = 0.0;
    do
    {
      v14 = *(unsigned int *)(v8 + v7);
      if (*(_BYTE *)(v9 + v14))
        v13 = v13 + expf(*(float *)(*v10 + v7) + *(float *)(v11 + 4 * v14));
      v7 += 4;
    }
    while (v12 != v7);
    if (v13 != 0.0)
      log(v13);
  }
}

float NFloatDistribution::componentScore(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  float v4;
  uint64_t v5;
  float32x4_t *v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t *v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  float32x4_t *v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  float *v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;

  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(float *)(v3 + 56 * *a2 + 48);
  v5 = *(unsigned int *)(a3 + 16);
  if ((_DWORD)v5)
  {
    v6 = *(float32x4_t **)(a3 + 8);
    v7 = v3 + 56 * *a2;
    v8 = *(float32x4_t **)(v7 + 8);
    v9 = *(float32x4_t **)(v7 + 32);
    if (v5 < 8)
    {
      v10 = 0;
LABEL_7:
      v19 = v5 - v10;
      v20 = v10;
      v21 = &v9->f32[v20];
      v22 = &v8->f32[v20];
      v23 = &v6->f32[v20];
      do
      {
        v24 = *v23++;
        v25 = v24;
        v26 = *v22++;
        v27 = (float)(v25 - v26) * (float)(v25 - v26);
        v28 = *v21++;
        v4 = v4 + (float)(v27 * v28);
        --v19;
      }
      while (v19);
      return v4 * -0.5;
    }
    v10 = v5 & 0xFFFFFFF8;
    v11 = v9 + 1;
    v12 = v8 + 1;
    v13 = v6 + 1;
    v14 = v10;
    do
    {
      v15 = vsubq_f32(v13[-1], v12[-1]);
      v16 = vsubq_f32(*v13, *v12);
      v17 = vmulq_f32(vmulq_f32(v15, v15), v11[-1]);
      v18 = vmulq_f32(vmulq_f32(v16, v16), *v11);
      v4 = (float)((float)((float)((float)((float)((float)((float)(v4 + v17.f32[0]) + v17.f32[1]) + v17.f32[2])
                                         + v17.f32[3])
                                 + v18.f32[0])
                         + v18.f32[1])
                 + v18.f32[2])
         + v18.f32[3];
      v11 += 2;
      v12 += 2;
      v13 += 2;
      v14 -= 8;
    }
    while (v14);
    if (v10 != v5)
      goto LABEL_7;
  }
  return v4 * -0.5;
}

uint64_t NFloatDistribution::numComponents(NFloatDistribution *this)
{
  return (uint64_t)this + 48;
}

uint64_t NFloatDistribution::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;

  v3 = *(_QWORD *)(result + 16) + 48 * *a2;
  v4 = *(unsigned int *)(v3 + 16);
  if ((_DWORD)v4)
  {
    v5 = *(_QWORD *)(v3 + 8);
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      v7 = 0;
LABEL_7:
      v11 = v4 - v7;
      v12 = (unsigned int *)(v5 + 4 * v7);
      do
      {
        v13 = *v12++;
        *(_BYTE *)(v6 + v13) = 1;
        --v11;
      }
      while (v11);
      return result;
    }
    v7 = v4 & 0xFFFFFFFE;
    v8 = (unsigned int *)(v5 + 4);
    v9 = v7;
    do
    {
      v10 = *v8;
      *(_BYTE *)(v6 + *(v8 - 1)) = 1;
      *(_BYTE *)(v6 + v10) = 1;
      v8 += 2;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFloatDistribution::firstComponentId(NFloatDistribution *this, const unsigned int *a2)
{
  return **(unsigned int **)(*((_QWORD *)this + 2) + 48 * *a2 + 8);
}

void NFloatDistribution::posteriorWeightedMean(uint64_t a1, unsigned int *a2, uint64_t a3, _QWORD *a4)
{
  NGaussianMixtureModels::posteriorWeightedMean(a1 + 8, a2, a3, a4);
}

uint64_t NFloatDistribution::baseGMM(NFloatDistribution *this)
{
  return (uint64_t)this + 8;
}

void NFloatDistribution::fixedPointScalesP(NFloatDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NFloatDistribution::fixedPointScalesP() - not supported for floating-point models", a2);
}

uint64_t NDistribution::allocateStateP(NDistribution *this)
{
  return 0;
}

void NDistributionLoader::~NDistributionLoader(NDistributionLoader *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F1FD8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F1FD8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F1FD8;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

void NFloatDistribution::NFloatDistribution(NFloatDistribution *this)
{
  *(_QWORD *)this = &off_24C7F1DC8;
  NGaussianMixtureModels::NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_24C7F1DC8;
  NGaussianMixtureModels::NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

void NDistributionLoader::NDistributionLoader(NDistributionLoader *this)
{
  *(_QWORD *)this = &off_24C7F1FD8;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_24C7F1FD8;
  *((_QWORD *)this + 1) = 0;
}

uint64_t NDistributionLoader::read(NDistributionLoader *this, uint64_t (***a2)(NString *__hidden this, const unsigned int *), const NString *a3)
{
  uint64_t v6;
  const char *v7;
  const unsigned int *v8;
  unsigned int v9;
  size_t v10;
  uint64_t (**v11)(NString *__hidden, const unsigned int *);
  const char *v12;
  const char *v13;
  BOOL v14;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  NBNNSIRDistribution *v26;
  void *v27;
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v33;
  _BYTE *v34;
  _BYTE *v35;
  _BYTE *v36;
  _BYTE *v41;
  _BYTE *v42;
  const char *v43;
  _BYTE *v46;
  _BYTE *v47;
  _BYTE *v48;
  _BYTE *v49;
  _BYTE *v50;
  _BYTE *v51;
  _BYTE *v52;
  _BYTE *v53;
  char *v54;
  BOOL v55[8];
  int v56;
  uint64_t v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  uint64_t (**v59)(NString *__hidden, const unsigned int *);
  void *v60;
  _BYTE *v61;
  int v62;
  __int16 v63;
  void (**v64)(NGaussianFixedPointScales *__hidden);
  int v65;
  uint64_t (**v66)();
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t (**v70)();
  uint64_t v71;
  int v72;
  uint64_t (**v73)();
  uint64_t v74;
  int v75;
  uint64_t (**v76)();
  uint64_t v77;
  int v78;
  char v79;
  uint64_t v80;
  int v81;
  uint64_t (**v82)();
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint64_t (**v86)();
  uint64_t v87;
  int v88;
  uint64_t v89;
  int v90;
  uint64_t (**v91)(NString *__hidden, const unsigned int *);
  int v92;
  uint64_t v93;
  uint64_t (**v94)();
  uint64_t v95;
  uint64_t (**v96)(NString *__hidden, const unsigned int *);
  int v97;
  _BYTE *v98;

  v6 = *((_QWORD *)this + 1);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *((_QWORD *)this + 1) = 0;
  v96 = &off_24C7F32C0;
  v97 = 0;
  v98 = (_BYTE *)operator new[]();
  *v98 = 0;
  v8 = (const unsigned int *)(a2 + 1);
  v9 = *((_DWORD *)a2 + 2);
  v10 = v9 - 4;
  if (v9 >= 4 && (v11 = a2[2], *(_DWORD *)v11 == 980443501))
  {
    v58 = &off_24C7F32C0;
    if (!v11)
      Error::chuck((Error *)"Null pointer passed to string constructor", v7, v8);
    LODWORD(v59) = v9 - 4;
    v27 = (void *)operator new[]();
    v60 = v27;
    memcpy(v27, (char *)v11 + 4, v10);
    *((_BYTE *)v27 + v10) = 0;
    ((void (*)(NString *, const void *, const unsigned int *))v96[8])((NString *)&v96, v27, (const unsigned int *)&v59);
    v58 = &off_24C7F32C0;
    if (v60)
      MEMORY[0x212BAC9C0](v60, 0x1000C8077774924);
  }
  else if (&v96 != a2)
  {
    NString::assignTo((NString *)&v96, a2[2], v8);
  }
  v58 = &off_24C7F32C0;
  LODWORD(v59) = 1;
  v60 = (void *)operator new[]();
  memcpy(v60, "r", ((_DWORD)v59 + 1));
  v94 = (uint64_t (**)())&off_24C7F33E0;
  v95 = 0;
  NFilePtr::open((NFilePtr *)&v94, (const NString *)&v96, (const NString *)&v58);
  v58 = &off_24C7F32C0;
  if (v60)
    MEMORY[0x212BAC9C0](v60, 0x1000C8077774924);
  if (!v95)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
  LODWORD(v58) = 13;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v95 + 64))(&v91, v95, &v58);
  if (v92 != 13)
  {
LABEL_43:
    if (NString::operator==((uint64_t)&v91, "# GMISa v1.00") || NString::operator==((uint64_t)&v91, "# GMIRa v1.00"))
    {
      v54 = "read_gaussian_models() - old GMI[RS]a v1.00 format in %s not supported";
    }
    else
    {
      if (NString::operator==((uint64_t)&v91, "# DNNLb v1.00"))
      {
        v22 = operator new();
        NDeepnetDistribution::NDeepnetDistribution((NDeepnetDistribution *)v22);
LABEL_48:
        *((_QWORD *)this + 1) = v22;
        goto LABEL_49;
      }
      if (*(_DWORD *)v93 == -673472473)
      {
        v26 = (NBNNSIRDistribution *)operator new();
        NBNNSIRDistribution::NBNNSIRDistribution(v26);
        *((_QWORD *)this + 1) = v26;
        NBNNSIRDistribution::setWeightsFile(v26, a3);
        goto LABEL_49;
      }
      if (NString::operator==((uint64_t)&v91, "# DMIXa v1.00"))
      {
        v28 = (_QWORD *)operator new();
        *v28 = &off_24C7F1CC0;
        v28[1] = 0;
        *((_QWORD *)this + 1) = v28;
        goto LABEL_49;
      }
      if (NString::operator==((uint64_t)&v91, "# DMIFa v1.00"))
      {
        v22 = operator new();
        *(_QWORD *)v22 = &off_24C7F2910;
        *(_QWORD *)(v22 + 8) = 0;
        NFixedPointScales::NFixedPointScales((NFixedPointScales *)(v22 + 16));
        goto LABEL_48;
      }
      v54 = "read_gaussian_models() - invalid acoustic model \"%s\"";
    }
LABEL_116:
    Error::chuck((Error *)v54, v13, a2[2]);
  }
  v14 = *(_QWORD *)v93 == 0x206158494D472023 && *(_QWORD *)(v93 + 5) == 0x30302E3176206158;
  if (v14
    || (*(_QWORD *)v93 == 0x206258494D472023 ? (v15 = *(_QWORD *)(v93 + 5) == 0x30302E3176206258) : (v15 = 0), v15))
  {
    v22 = operator new();
    *(_QWORD *)v22 = &off_24C7F1DC8;
    NGaussianMixtureModels::NGaussianMixtureModels((NGaussianMixtureModels *)(v22 + 8));
    goto LABEL_48;
  }
  v16 = *(_QWORD *)v93 == 0x206146494D472023 && *(_QWORD *)(v93 + 5) == 0x30302E3176206146;
  if (v16
    || (*(_QWORD *)v93 == 0x206246494D472023 ? (v17 = *(_QWORD *)(v93 + 5) == 0x30302E3176206246) : (v17 = 0), v17))
  {
    v54 = "read_gaussian_models() - GMIF model format in %s not supported";
    goto LABEL_116;
  }
  v18 = *(_QWORD *)v93 == 0x206152494D472023 && *(_QWORD *)(v93 + 5) == 0x30302E3276206152;
  if (v18
    || (*(_QWORD *)v93 == 0x206252494D472023 ? (v19 = *(_QWORD *)(v93 + 5) == 0x30302E3176206252) : (v19 = 0), v19))
  {
    LODWORD(v58) = 0;
    v59 = &off_24C7F32C0;
    LODWORD(v60) = 0;
    v61 = (_BYTE *)operator new[]();
    *v61 = 0;
    v62 = 0;
    v63 = 0;
    v65 = 0;
    v66 = &off_24C7F30C8;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = &off_24C7F3090;
    v71 = 0;
    v72 = 0;
    v73 = &off_24C7F3090;
    v74 = 0;
    v75 = 0;
    v76 = &off_24C7F3090;
    v77 = 0;
    v78 = 0;
    v79 = 0;
    v64 = &off_24C7F2A18;
    v80 = 0;
    v81 = 0;
    v82 = &off_24C7F30C8;
    v83 = 0;
    v84 = 0;
    v85 = 0;
    v86 = &off_24C7F30C8;
    v87 = 0;
    v88 = 0;
    v89 = 0;
    v90 = 0;
    v55[0] = 1;
    NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)&v58, (const NString *)a2, (NFilePtr *)&v94, (const NString *)&v91, v55);
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)&v58, (uint64_t)v55);
    if (v56 == 17)
    {
      v30 = v57;
      if (*(_QWORD *)v57 == 0x32332D36312D3631
        && *(_QWORD *)(v57 + 8) == 0x312D36312D36312DLL
        && *(_BYTE *)(v57 + 16) == 54)
      {
        v33 = operator new();
        *(_QWORD *)v33 = &off_24C7F2780;
        *(_QWORD *)(v33 + 8) = &off_24C7F32C0;
        *(_DWORD *)(v33 + 16) = 0;
        v48 = (_BYTE *)operator new[]();
        *(_QWORD *)(v33 + 40) = &off_24C7F2A18;
        *v48 = 0;
        *(_QWORD *)(v33 + 24) = v48;
        *(_QWORD *)(v33 + 32) = 0;
        *(_DWORD *)(v33 + 48) = 0;
        *(_QWORD *)(v33 + 56) = &off_24C7F30C8;
        *(_QWORD *)(v33 + 64) = 0;
        *(_DWORD *)(v33 + 72) = 0;
        *(_QWORD *)(v33 + 80) = 0;
        *(_QWORD *)(v33 + 88) = &off_24C7F3090;
        *(_QWORD *)(v33 + 96) = 0;
        *(_DWORD *)(v33 + 104) = 0;
        *(_QWORD *)(v33 + 112) = &off_24C7F3090;
        *(_QWORD *)(v33 + 120) = 0;
        *(_DWORD *)(v33 + 128) = 0;
        *(_QWORD *)(v33 + 136) = &off_24C7F3090;
        *(_QWORD *)(v33 + 144) = 0;
        *(_DWORD *)(v33 + 152) = 0;
        *(_BYTE *)(v33 + 160) = 0;
        *(_QWORD *)(v33 + 164) = 0;
        *(_DWORD *)(v33 + 172) = 0;
        *(_QWORD *)(v33 + 176) = &off_24C7F30C8;
        *(_QWORD *)(v33 + 184) = 0;
        *(_DWORD *)(v33 + 192) = 0;
        *(_QWORD *)(v33 + 200) = 0;
        *(_QWORD *)(v33 + 208) = &off_24C7F30C8;
        *(_QWORD *)(v33 + 216) = 0;
        *(_DWORD *)(v33 + 224) = 0;
        *(_QWORD *)(v33 + 240) = 0;
        *(_QWORD *)(v33 + 248) = &off_24C7F32C0;
        *(_DWORD *)(v33 + 256) = 0;
        v49 = (_BYTE *)operator new[]();
        *v49 = 0;
        *(_QWORD *)(v33 + 264) = v49;
        *(_QWORD *)(v33 + 272) = &off_24C7F2F78;
        *(_QWORD *)(v33 + 280) = 0;
        *(_DWORD *)(v33 + 288) = 0;
        *(_DWORD *)(v33 + 296) = 0;
        *(_QWORD *)(v33 + 304) = &off_24C7F32C0;
        *(_DWORD *)(v33 + 312) = 0;
        v36 = (_BYTE *)operator new[]();
        goto LABEL_108;
      }
      v30 = v57;
      if (*(_QWORD *)v57 == 0x32332D36312D3631
        && *(_QWORD *)(v57 + 8) == 0x332D32332D32332DLL
        && *(_BYTE *)(v57 + 16) == 50)
      {
        v33 = operator new();
        *(_QWORD *)v33 = &off_24C7F26C8;
        *(_QWORD *)(v33 + 8) = &off_24C7F32C0;
        *(_DWORD *)(v33 + 16) = 0;
        v41 = (_BYTE *)operator new[]();
        *(_QWORD *)(v33 + 40) = &off_24C7F2A18;
        *v41 = 0;
        *(_QWORD *)(v33 + 24) = v41;
        *(_QWORD *)(v33 + 32) = 0;
        *(_DWORD *)(v33 + 48) = 0;
        *(_QWORD *)(v33 + 56) = &off_24C7F30C8;
        *(_QWORD *)(v33 + 64) = 0;
        *(_DWORD *)(v33 + 72) = 0;
        *(_QWORD *)(v33 + 80) = 0;
        *(_QWORD *)(v33 + 88) = &off_24C7F3090;
        *(_QWORD *)(v33 + 96) = 0;
        *(_DWORD *)(v33 + 104) = 0;
        *(_QWORD *)(v33 + 112) = &off_24C7F3090;
        *(_QWORD *)(v33 + 120) = 0;
        *(_DWORD *)(v33 + 128) = 0;
        *(_QWORD *)(v33 + 136) = &off_24C7F3090;
        *(_QWORD *)(v33 + 144) = 0;
        *(_DWORD *)(v33 + 152) = 0;
        *(_BYTE *)(v33 + 160) = 0;
        *(_QWORD *)(v33 + 164) = 0;
        *(_DWORD *)(v33 + 172) = 0;
        *(_QWORD *)(v33 + 176) = &off_24C7F30C8;
        *(_QWORD *)(v33 + 184) = 0;
        *(_DWORD *)(v33 + 192) = 0;
        *(_QWORD *)(v33 + 200) = 0;
        *(_QWORD *)(v33 + 208) = &off_24C7F30C8;
        *(_QWORD *)(v33 + 216) = 0;
        *(_DWORD *)(v33 + 224) = 0;
        *(_QWORD *)(v33 + 240) = 0;
        *(_QWORD *)(v33 + 248) = &off_24C7F32C0;
        *(_DWORD *)(v33 + 256) = 0;
        v42 = (_BYTE *)operator new[]();
        *v42 = 0;
        *(_QWORD *)(v33 + 264) = v42;
        *(_QWORD *)(v33 + 272) = &off_24C7F2F40;
        *(_QWORD *)(v33 + 280) = 0;
        *(_DWORD *)(v33 + 288) = 0;
        *(_DWORD *)(v33 + 296) = 0;
        *(_QWORD *)(v33 + 304) = &off_24C7F32C0;
        *(_DWORD *)(v33 + 312) = 0;
        v36 = (_BYTE *)operator new[]();
        goto LABEL_108;
      }
    }
    else
    {
      if (v56 == 15)
      {
        v30 = v57;
        if (*(_QWORD *)v57 == 0x312D32332D382D38 && *(_QWORD *)(v57 + 7) == 0x36312D36312D3631)
        {
          v33 = operator new();
          *(_QWORD *)v33 = &off_24C7F2558;
          *(_QWORD *)(v33 + 8) = &off_24C7F32C0;
          *(_DWORD *)(v33 + 16) = 0;
          v50 = (_BYTE *)operator new[]();
          *(_QWORD *)(v33 + 40) = &off_24C7F2A18;
          *v50 = 0;
          *(_QWORD *)(v33 + 24) = v50;
          *(_QWORD *)(v33 + 32) = 0;
          *(_DWORD *)(v33 + 48) = 0;
          *(_QWORD *)(v33 + 56) = &off_24C7F30C8;
          *(_QWORD *)(v33 + 64) = 0;
          *(_DWORD *)(v33 + 72) = 0;
          *(_QWORD *)(v33 + 80) = 0;
          *(_QWORD *)(v33 + 88) = &off_24C7F3090;
          *(_QWORD *)(v33 + 96) = 0;
          *(_DWORD *)(v33 + 104) = 0;
          *(_QWORD *)(v33 + 112) = &off_24C7F3090;
          *(_QWORD *)(v33 + 120) = 0;
          *(_DWORD *)(v33 + 128) = 0;
          *(_QWORD *)(v33 + 136) = &off_24C7F3090;
          *(_QWORD *)(v33 + 144) = 0;
          *(_DWORD *)(v33 + 152) = 0;
          *(_BYTE *)(v33 + 160) = 0;
          *(_QWORD *)(v33 + 164) = 0;
          *(_DWORD *)(v33 + 172) = 0;
          *(_QWORD *)(v33 + 176) = &off_24C7F30C8;
          *(_QWORD *)(v33 + 184) = 0;
          *(_DWORD *)(v33 + 192) = 0;
          *(_QWORD *)(v33 + 200) = 0;
          *(_QWORD *)(v33 + 208) = &off_24C7F30C8;
          *(_QWORD *)(v33 + 216) = 0;
          *(_DWORD *)(v33 + 224) = 0;
          *(_QWORD *)(v33 + 240) = 0;
          *(_QWORD *)(v33 + 248) = &off_24C7F32C0;
          *(_DWORD *)(v33 + 256) = 0;
          v51 = (_BYTE *)operator new[]();
          *v51 = 0;
          *(_QWORD *)(v33 + 264) = v51;
          *(_QWORD *)(v33 + 272) = &off_24C7F2F78;
          *(_QWORD *)(v33 + 280) = 0;
          *(_DWORD *)(v33 + 288) = 0;
          *(_DWORD *)(v33 + 296) = 0;
          *(_QWORD *)(v33 + 304) = &off_24C7F32C0;
          *(_DWORD *)(v33 + 312) = 0;
          v36 = (_BYTE *)operator new[]();
          goto LABEL_108;
        }
        if (*(_QWORD *)v57 == 0x332D32332D382D38 && *(_QWORD *)(v57 + 7) == 0x32332D32332D3233)
        {
          v33 = operator new();
          *(_QWORD *)v33 = &off_24C7F23E8;
          *(_QWORD *)(v33 + 8) = &off_24C7F32C0;
          *(_DWORD *)(v33 + 16) = 0;
          v34 = (_BYTE *)operator new[]();
          *(_QWORD *)(v33 + 40) = &off_24C7F2A18;
          *v34 = 0;
          *(_QWORD *)(v33 + 24) = v34;
          *(_QWORD *)(v33 + 32) = 0;
          *(_DWORD *)(v33 + 48) = 0;
          *(_QWORD *)(v33 + 56) = &off_24C7F30C8;
          *(_QWORD *)(v33 + 64) = 0;
          *(_DWORD *)(v33 + 72) = 0;
          *(_QWORD *)(v33 + 80) = 0;
          *(_QWORD *)(v33 + 88) = &off_24C7F3090;
          *(_QWORD *)(v33 + 96) = 0;
          *(_DWORD *)(v33 + 104) = 0;
          *(_QWORD *)(v33 + 112) = &off_24C7F3090;
          *(_QWORD *)(v33 + 120) = 0;
          *(_DWORD *)(v33 + 128) = 0;
          *(_QWORD *)(v33 + 136) = &off_24C7F3090;
          *(_QWORD *)(v33 + 144) = 0;
          *(_DWORD *)(v33 + 152) = 0;
          *(_BYTE *)(v33 + 160) = 0;
          *(_QWORD *)(v33 + 164) = 0;
          *(_DWORD *)(v33 + 172) = 0;
          *(_QWORD *)(v33 + 176) = &off_24C7F30C8;
          *(_QWORD *)(v33 + 184) = 0;
          *(_DWORD *)(v33 + 192) = 0;
          *(_QWORD *)(v33 + 200) = 0;
          *(_QWORD *)(v33 + 208) = &off_24C7F30C8;
          *(_QWORD *)(v33 + 216) = 0;
          *(_DWORD *)(v33 + 224) = 0;
          *(_QWORD *)(v33 + 240) = 0;
          *(_QWORD *)(v33 + 248) = &off_24C7F32C0;
          *(_DWORD *)(v33 + 256) = 0;
          v35 = (_BYTE *)operator new[]();
          *v35 = 0;
          *(_QWORD *)(v33 + 264) = v35;
          *(_QWORD *)(v33 + 272) = &off_24C7F2F40;
          *(_QWORD *)(v33 + 280) = 0;
          *(_DWORD *)(v33 + 288) = 0;
          *(_DWORD *)(v33 + 296) = 0;
          *(_QWORD *)(v33 + 304) = &off_24C7F32C0;
          *(_DWORD *)(v33 + 312) = 0;
          v36 = (_BYTE *)operator new[]();
          goto LABEL_108;
        }
      }
      v30 = v57;
    }
    Error::chuck((Error *)"read_gaussian_models() - GMIR mixture encoding %s in %s not supported", v29, v30, a2[2]);
  }
  if ((*(_QWORD *)v93 != 0x206153494D472023 || *(_QWORD *)(v93 + 5) != 0x30302E3276206153)
    && (*(_QWORD *)v93 != 0x206253494D472023 || *(_QWORD *)(v93 + 5) != 0x30302E3176206253))
  {
    goto LABEL_43;
  }
  LODWORD(v58) = 0;
  v59 = &off_24C7F32C0;
  LODWORD(v60) = 0;
  v61 = (_BYTE *)operator new[]();
  *v61 = 0;
  v62 = 0;
  v63 = 0;
  v65 = 0;
  v66 = &off_24C7F30C8;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = &off_24C7F3090;
  v71 = 0;
  v72 = 0;
  v73 = &off_24C7F3090;
  v74 = 0;
  v75 = 0;
  v76 = &off_24C7F3090;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v64 = &off_24C7F2A18;
  v80 = 0;
  v81 = 0;
  v82 = &off_24C7F30C8;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = &off_24C7F30C8;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  v90 = 0;
  v55[0] = 1;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)&v58, (const NString *)a2, (NFilePtr *)&v94, (const NString *)&v91, v55);
  NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)&v58, (uint64_t)v55);
  v30 = v57;
  if (v56 != 15)
LABEL_120:
    Error::chuck((Error *)"read_gaussian_models() - GMIS mixture encoding %s in %s not supported", v43, v30, a2[2]);
  if (*(_QWORD *)v57 == 0x312D32332D382D38 && *(_QWORD *)(v57 + 7) == 0x36312D36312D3631)
  {
    v33 = operator new();
    *(_QWORD *)v33 = &off_24C7F2610;
    *(_QWORD *)(v33 + 8) = &off_24C7F32C0;
    *(_DWORD *)(v33 + 16) = 0;
    v52 = (_BYTE *)operator new[]();
    *(_QWORD *)(v33 + 40) = &off_24C7F2A18;
    *v52 = 0;
    *(_QWORD *)(v33 + 24) = v52;
    *(_QWORD *)(v33 + 32) = 0;
    *(_DWORD *)(v33 + 48) = 0;
    *(_QWORD *)(v33 + 56) = &off_24C7F30C8;
    *(_QWORD *)(v33 + 64) = 0;
    *(_DWORD *)(v33 + 72) = 0;
    *(_QWORD *)(v33 + 80) = 0;
    *(_QWORD *)(v33 + 88) = &off_24C7F3090;
    *(_QWORD *)(v33 + 96) = 0;
    *(_DWORD *)(v33 + 104) = 0;
    *(_QWORD *)(v33 + 112) = &off_24C7F3090;
    *(_QWORD *)(v33 + 120) = 0;
    *(_DWORD *)(v33 + 128) = 0;
    *(_QWORD *)(v33 + 136) = &off_24C7F3090;
    *(_QWORD *)(v33 + 144) = 0;
    *(_DWORD *)(v33 + 152) = 0;
    *(_BYTE *)(v33 + 160) = 0;
    *(_QWORD *)(v33 + 164) = 0;
    *(_DWORD *)(v33 + 172) = 0;
    *(_QWORD *)(v33 + 176) = &off_24C7F30C8;
    *(_QWORD *)(v33 + 184) = 0;
    *(_DWORD *)(v33 + 192) = 0;
    *(_QWORD *)(v33 + 200) = 0;
    *(_QWORD *)(v33 + 208) = &off_24C7F30C8;
    *(_QWORD *)(v33 + 216) = 0;
    *(_DWORD *)(v33 + 224) = 0;
    *(_QWORD *)(v33 + 240) = 0;
    *(_QWORD *)(v33 + 248) = &off_24C7F32C0;
    *(_DWORD *)(v33 + 256) = 0;
    v53 = (_BYTE *)operator new[]();
    *v53 = 0;
    *(_QWORD *)(v33 + 264) = v53;
    *(_QWORD *)(v33 + 272) = &off_24C7F2F78;
    *(_QWORD *)(v33 + 280) = 0;
    *(_DWORD *)(v33 + 288) = 0;
    *(_DWORD *)(v33 + 296) = 0;
    *(_QWORD *)(v33 + 304) = &off_24C7F32C0;
    *(_DWORD *)(v33 + 312) = 0;
    v36 = (_BYTE *)operator new[]();
  }
  else
  {
    v30 = v57;
    if (*(_QWORD *)v57 != 0x332D32332D382D38 || *(_QWORD *)(v57 + 7) != 0x32332D32332D3233)
      goto LABEL_120;
    v33 = operator new();
    *(_QWORD *)v33 = &off_24C7F24A0;
    *(_QWORD *)(v33 + 8) = &off_24C7F32C0;
    *(_DWORD *)(v33 + 16) = 0;
    v46 = (_BYTE *)operator new[]();
    *(_QWORD *)(v33 + 40) = &off_24C7F2A18;
    *v46 = 0;
    *(_QWORD *)(v33 + 24) = v46;
    *(_QWORD *)(v33 + 32) = 0;
    *(_DWORD *)(v33 + 48) = 0;
    *(_QWORD *)(v33 + 56) = &off_24C7F30C8;
    *(_QWORD *)(v33 + 64) = 0;
    *(_DWORD *)(v33 + 72) = 0;
    *(_QWORD *)(v33 + 80) = 0;
    *(_QWORD *)(v33 + 88) = &off_24C7F3090;
    *(_QWORD *)(v33 + 96) = 0;
    *(_DWORD *)(v33 + 104) = 0;
    *(_QWORD *)(v33 + 112) = &off_24C7F3090;
    *(_QWORD *)(v33 + 120) = 0;
    *(_DWORD *)(v33 + 128) = 0;
    *(_QWORD *)(v33 + 136) = &off_24C7F3090;
    *(_QWORD *)(v33 + 144) = 0;
    *(_DWORD *)(v33 + 152) = 0;
    *(_BYTE *)(v33 + 160) = 0;
    *(_QWORD *)(v33 + 164) = 0;
    *(_DWORD *)(v33 + 172) = 0;
    *(_QWORD *)(v33 + 176) = &off_24C7F30C8;
    *(_QWORD *)(v33 + 184) = 0;
    *(_DWORD *)(v33 + 192) = 0;
    *(_QWORD *)(v33 + 200) = 0;
    *(_QWORD *)(v33 + 208) = &off_24C7F30C8;
    *(_QWORD *)(v33 + 216) = 0;
    *(_DWORD *)(v33 + 224) = 0;
    *(_QWORD *)(v33 + 240) = 0;
    *(_QWORD *)(v33 + 248) = &off_24C7F32C0;
    *(_DWORD *)(v33 + 256) = 0;
    v47 = (_BYTE *)operator new[]();
    *v47 = 0;
    *(_QWORD *)(v33 + 264) = v47;
    *(_QWORD *)(v33 + 272) = &off_24C7F2F40;
    *(_QWORD *)(v33 + 280) = 0;
    *(_DWORD *)(v33 + 288) = 0;
    *(_DWORD *)(v33 + 296) = 0;
    *(_QWORD *)(v33 + 304) = &off_24C7F32C0;
    *(_DWORD *)(v33 + 312) = 0;
    v36 = (_BYTE *)operator new[]();
  }
LABEL_108:
  *(_QWORD *)(v33 + 320) = v36;
  *v36 = 0;
  *(_DWORD *)(v33 + 328) = 0;
  *(_WORD *)(v33 + 332) = 0;
  *(_DWORD *)(v33 + 344) = 0;
  *(_QWORD *)(v33 + 352) = &off_24C7F30C8;
  *(_QWORD *)(v33 + 360) = 0;
  *(_DWORD *)(v33 + 368) = 0;
  *(_QWORD *)(v33 + 376) = 0;
  *(_QWORD *)(v33 + 384) = &off_24C7F3090;
  *(_QWORD *)(v33 + 392) = 0;
  *(_DWORD *)(v33 + 400) = 0;
  *(_QWORD *)(v33 + 408) = &off_24C7F3090;
  *(_QWORD *)(v33 + 416) = 0;
  *(_DWORD *)(v33 + 424) = 0;
  *(_QWORD *)(v33 + 432) = &off_24C7F3090;
  *(_QWORD *)(v33 + 440) = 0;
  *(_DWORD *)(v33 + 448) = 0;
  *(_BYTE *)(v33 + 456) = 0;
  *(_QWORD *)(v33 + 336) = &off_24C7F2A18;
  *(_QWORD *)(v33 + 460) = 0;
  *(_DWORD *)(v33 + 468) = 0;
  *(_QWORD *)(v33 + 472) = &off_24C7F30C8;
  *(_QWORD *)(v33 + 480) = 0;
  *(_DWORD *)(v33 + 488) = 0;
  *(_QWORD *)(v33 + 496) = 0;
  *(_QWORD *)(v33 + 504) = &off_24C7F30C8;
  *(_QWORD *)(v33 + 512) = 0;
  *(_DWORD *)(v33 + 520) = 0;
  *(_QWORD *)(v33 + 536) = 0;
  *(_DWORD *)(v33 + 544) = 0;
  *((_QWORD *)this + 1) = v33;
  if (v30)
    MEMORY[0x212BAC9C0](v30, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)&v64);
  v59 = &off_24C7F32C0;
  if (v61)
    MEMORY[0x212BAC9C0](v61, 0x1000C8077774924);
LABEL_49:
  if (!v95)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v23);
  (*(void (**)(uint64_t))(*(_QWORD *)v95 + 24))(v95);
  (*(void (**)(_QWORD, uint64_t (***)(NString *__hidden, const unsigned int *)))(**((_QWORD **)this + 1) + 56))(*((_QWORD *)this + 1), a2);
  v24 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  v91 = &off_24C7F32C0;
  if (v93)
    MEMORY[0x212BAC9C0](v93, 0x1000C8077774924);
  v94 = &off_24C7F17F8;
  if (v95)
    (*(void (**)(uint64_t))(*(_QWORD *)v95 + 8))(v95);
  v96 = &off_24C7F32C0;
  if (v98)
    MEMORY[0x212BAC9C0](v98, 0x1000C8077774924);
  return v24;
}

void sub_20D9CE534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  _QWORD *v17;
  NGaussianFixedPointScales *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v17[34] = v20;
  v23 = v17[35];
  if (v23)
    MEMORY[0x212BAC9C0](v23, 0x50C80EE9192B6);
  v17[31] = v19;
  v24 = v17[33];
  if (v24)
    MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales(v18);
  v17[1] = v19;
  v25 = v17[3];
  if (v25)
    MEMORY[0x212BAC9C0](v25, 0x1000C8077774924);
  MEMORY[0x212BAC9D8](v17, 0x10D1C4027B8FD50);
  if (v16)
    MEMORY[0x212BAC9C0](v16, 0x1000C8077774924);
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)&a14);
  *(_QWORD *)(v21 - 152) = v19;
  v26 = *(_QWORD *)(v21 - 136);
  if (v26)
    MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
  *(_QWORD *)(v21 - 128) = &off_24C7F17F8;
  v27 = *(_QWORD *)(v21 - 120);
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  *(_QWORD *)(v21 - 112) = v19;
  v28 = *(_QWORD *)(v21 - 96);
  if (v28)
    MEMORY[0x212BAC9C0](v28, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NFixedDummyDistribution::~NFixedDummyDistribution(NFixedDummyDistribution *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C7F2910;
  *((_QWORD *)this + 2) = &off_24C7F1BF8;
  *((_QWORD *)this + 14) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 11) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 12);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 8) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 9);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 4) = &off_24C7F30C8;
  v5 = *((_QWORD *)this + 5);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C7F2910;
  *((_QWORD *)this + 2) = &off_24C7F1BF8;
  *((_QWORD *)this + 14) = &off_24C7F3090;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  *((_QWORD *)this + 11) = &off_24C7F3090;
  v3 = *((_QWORD *)this + 12);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
  *((_QWORD *)this + 8) = &off_24C7F3090;
  v4 = *((_QWORD *)this + 9);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 4) = &off_24C7F30C8;
  v5 = *((_QWORD *)this + 5);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFixedDummyDistribution::size(NFixedDummyDistribution *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t NFixedDummyDistribution::dimen(NFixedDummyDistribution *this)
{
  return (uint64_t)this + 12;
}

uint64_t NFixedDummyDistribution::read(NFixedDummyDistribution *this, const NString *a2)
{
  const char *v3;
  const char *v4;
  BOOL v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  size_t v20;
  _BYTE *v21;
  char *v22;
  const char *v23;
  unsigned int v24;
  _BYTE *v25;
  void *v26;
  size_t v27;
  _BYTE *v28;
  BOOL v29;
  const char *v30;
  unsigned int v31;
  _BYTE *v32;
  void *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int32x4_t v38;
  int32x4_t *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int *v42;
  uint64_t result;
  char *v44;
  const NString *v45;
  char *v46;
  unsigned int v47;
  char v49;
  uint64_t (**v50)(NString *__hidden, const unsigned int *);
  unsigned int v51;
  uint64_t v52;
  char *__endptr;
  uint64_t v54;
  void *v55;
  uint64_t (**v56)(NString *__hidden, const unsigned int *);
  unsigned int v57;
  _BYTE *v58;
  uint64_t (**v59)(NString *__hidden, const unsigned int *);
  int v60;
  uint64_t v61;
  uint64_t (**v62)();
  uint64_t v63;
  int v64[3];

  *((_QWORD *)this + 1) = 0;
  v64[0] = -1;
  v59 = &off_24C7F32C0;
  v60 = 1;
  v61 = operator new[]();
  *(_WORD *)v61 = 114;
  v62 = (uint64_t (**)())&off_24C7F33E0;
  v63 = 0;
  NFilePtr::open((NFilePtr *)&v62, a2, (const NString *)&v59);
  v59 = &off_24C7F32C0;
  if (v61)
    MEMORY[0x212BAC9C0](v61, 0x1000C8077774924);
  if (!v63)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v3);
  LODWORD(v56) = 13;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v63 + 64))(&v59, v63, &v56);
  if (v60 != 13
    || (*(_QWORD *)v61 == 0x206146494D442023 ? (v5 = *(_QWORD *)(v61 + 5) == 0x30302E3176206146) : (v5 = 0), !v5))
  {
    Error::chuck((Error *)"NFixedDummyDistribution::read() - cannot read cookie from file %s", v4, *((_QWORD *)a2 + 2));
  }
  v45 = a2;
  v56 = &off_24C7F32C0;
  v57 = 0;
  LODWORD(v6) = 0;
  v58 = (_BYTE *)operator new[]();
  v47 = -1;
  *v58 = 0;
  v46 = "Index %d outside of range [0,%d]";
  while (1)
  {
    if (!v63)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7);
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v63 + 48))(v63))
      break;
    if (!v63)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    v49 = 35;
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char *))(*(_QWORD *)v63 + 80))(&v50, v63, &v49);
    v10 = (char *)operator new[]();
    strcpy(v10, "\r\n\t ");
    v11 = v51;
    v12 = v52;
    if (v51)
    {
      v13 = 0;
      while (strchr(v10, *(char *)(v12 + v13)))
      {
        if (v11 == ++v13)
        {
          v14 = v11;
          v15 = v11;
          v13 = v11;
          goto LABEL_21;
        }
      }
      v14 = v13;
      v15 = v11;
    }
    else
    {
      v14 = 0;
      v15 = 0;
      v13 = 0;
    }
LABEL_21:
    if (v13 >= v11)
      v16 = v11;
    else
      v16 = v13;
    while (v15 > v14)
    {
      v17 = v15--;
      if (!strchr(v10, *(char *)(v12 + v17 - 1)))
      {
        v16 = v17;
        break;
      }
    }
    if (v13 > v11)
      goto LABEL_83;
    if (v16 > v11)
    {
      v13 = v16;
      goto LABEL_83;
    }
    v18 = (v16 - v13);
    if (v16 < v13)
    {
      v46 = "Start and end indices conflict, start [%d], end [%d]";
      v11 = v16;
LABEL_83:
      Error::chuck((Error *)v46, v9, v13, v11);
    }
    __endptr = (char *)&off_24C7F32C0;
    if (!v12)
      Error::chuck((Error *)"Null pointer passed to string constructor", v9);
    LODWORD(v54) = v16 - v13;
    v19 = (void *)operator new[]();
    v55 = v19;
    memcpy(v19, (const void *)(v12 + v13), v18);
    *((_BYTE *)v19 + v18) = 0;
    ((void (*)(NString *, const void *, const unsigned int *))v56[8])((NString *)&v56, v19, (const unsigned int *)&v54);
    __endptr = (char *)&off_24C7F32C0;
    if (v55)
      MEMORY[0x212BAC9C0](v55, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
    v50 = &off_24C7F32C0;
    if (v52)
      MEMORY[0x212BAC9C0](v52, 0x1000C8077774924);
    v6 = (v6 + 1);
    if (v57)
    {
      v20 = v57 - 4;
      if (v57 < 4)
        goto LABEL_84;
      v21 = v58;
      if (*(_DWORD *)v58 == 1028475204)
      {
        if (!v58)
          Error::chuck((Error *)"Null pointer passed to string constructor", v7);
        v22 = (char *)operator new[]();
        memcpy(v22, v21 + 4, v20);
        v22[v20] = 0;
        if (!(_DWORD)v20 || (__endptr = 0, strtoul(v22, &__endptr, 10), __endptr != &v22[v20]))
          Error::chuck((Error *)"NFixedDummyDistribution::read() - DIM= field invalid in file %s on line %d", v23, *((_QWORD *)v45 + 2), v6);
        v24 = v57;
        if (v57 <= 3)
          Error::chuck((Error *)"Index %d outside of range [0,%d]", v23, 4, v57);
        v25 = v58;
        if (!v58)
          Error::chuck((Error *)"Null pointer passed to string constructor", v23);
        v26 = (void *)operator new[]();
        memcpy(v26, v25 + 4, v24 - 4);
        *((_BYTE *)v26 + v24 - 4) = 0;
        *((_DWORD *)this + 3) = strtoul((const char *)v26, 0, 10);
        MEMORY[0x212BAC9C0](v26, 0x1000C8077774924);
      }
      else
      {
        v27 = v57 - 9;
        if (v57 < 9 || ((v28 = v58, *(_QWORD *)v58 == 0x51424F5250474F4CLL) ? (v29 = v58[8] == 61) : (v29 = 0), !v29))
LABEL_84:
          Error::chuck((Error *)"NFixedDummyDistribution::read() - invalid line in file %s on line %d", v7, *((_QWORD *)v45 + 2), v6);
        if (!v58)
          Error::chuck((Error *)"Null pointer passed to string constructor", v7);
        v22 = (char *)operator new[]();
        memcpy(v22, v28 + 9, v27);
        v22[v27] = 0;
        if (!(_DWORD)v27)
          goto LABEL_57;
        __endptr = 0;
        strtoul(v22, &__endptr, 10);
        if (__endptr != &v22[v27])
          goto LABEL_57;
        v31 = v57;
        if (v57 <= 8)
          Error::chuck((Error *)"Index %d outside of range [0,%d]", v30, 9, v57);
        v32 = v58;
        if (!v58)
          Error::chuck((Error *)"Null pointer passed to string constructor", v30);
        v33 = (void *)operator new[]();
        memcpy(v33, v32 + 9, v31 - 9);
        *((_BYTE *)v33 + v31 - 9) = 0;
        v34 = strtol((const char *)v33, 0, 10);
        MEMORY[0x212BAC9C0](v33, 0x1000C8077774924);
        v47 = v34;
        if (v34 >= 0x21)
LABEL_57:
          Error::chuck((Error *)"NFixedDummyDistribution::read() - LOGPROBQ= field invalid in file %s on line %d", v30, *((_QWORD *)v45 + 2), v6);
      }
      MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
    }
  }
  v64[0] = v47;
  if (!*((_DWORD *)this + 3))
  {
    v44 = "NFixedDummyDistribution::read() - DIM= unset in file %s";
    goto LABEL_92;
  }
  if (v47 == -1)
  {
    v44 = "NFixedDummyDistribution::read() - LOGPROBQ= unset in file %s";
LABEL_92:
    Error::chuck((Error *)v44, v8, *((_QWORD *)v45 + 2));
  }
  __endptr = (char *)&off_24C7F30C8;
  v35 = operator new[]();
  v54 = v35;
  v36 = *((unsigned int *)this + 3);
  LODWORD(v55) = v36;
  if (!(_DWORD)v36)
    goto LABEL_68;
  if (v36 < 8)
  {
    v37 = 0;
LABEL_66:
    v41 = v36 - v37;
    v42 = (unsigned int *)(v35 + 4 * v37);
    do
    {
      *v42++ = v47;
      --v41;
    }
    while (v41);
    goto LABEL_68;
  }
  v37 = v36 & 0xFFFFFFF8;
  v38 = vdupq_n_s32(v47);
  v39 = (int32x4_t *)(v35 + 16);
  v40 = v37;
  do
  {
    v39[-1] = v38;
    *v39 = v38;
    v39 += 2;
    v40 -= 8;
  }
  while (v40);
  if (v37 != v36)
    goto LABEL_66;
LABEL_68:
  *((_DWORD *)this + 2) = v36;
  NFixedPointScales::initialize((uint64_t)this + 16, v64, (uint64_t)&__endptr);
  __endptr = (char *)&off_24C7F30C8;
  if (v54)
    MEMORY[0x212BAC9C0](v54, 0x1000C8052888210);
  v56 = &off_24C7F32C0;
  if (v58)
    MEMORY[0x212BAC9C0](v58, 0x1000C8077774924);
  v59 = &off_24C7F32C0;
  if (v61)
    MEMORY[0x212BAC9C0](v61, 0x1000C8077774924);
  v62 = &off_24C7F17F8;
  result = v63;
  if (v63)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v63 + 8))(v63);
  return result;
}

void sub_20D9CF144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  uint64_t v28;
  uint64_t v30;

  if (a25)
    MEMORY[0x212BAC9C0](a25, 0x1000C8077774924);
  if (a28)
    MEMORY[0x212BAC9C0](a28, 0x1000C8077774924);
  *(_QWORD *)(v28 - 112) = &off_24C7F17F8;
  v30 = *(_QWORD *)(v28 - 104);
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  _Unwind_Resume(exception_object);
}

float NFixedDummyDistribution::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return *(float *)(*(_QWORD *)(a3 + 8) + 4 * *a2);
}

void NFixedDummyDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "scoreUsingCache");
}

void NFixedDummyDistribution::componentScore(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "componentScore");
}

void NFixedDummyDistribution::numComponents(NFixedDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "numComponents");
}

void NFixedDummyDistribution::setComponentMask(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "setComponentMask");
}

void NFixedDummyDistribution::firstComponentId(NFixedDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "firstComponentId");
}

void NFixedDummyDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "posteriorWeightedMean");
}

void NFixedDummyDistribution::baseGMM(NFixedDummyDistribution *this, const char *a2)
{
  NFixedDummyDistribution::notSupported(this, a2);
}

uint64_t NFixedDummyDistribution::fixedPointScalesP(NFixedDummyDistribution *this)
{
  return (uint64_t)this + 16;
}

void NFixedDummyDistribution::notSupported(NFixedDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NFixedDummyDistribution::%s() - not supported for this distribution type", a2, "baseGMM");
}

void NDummyDistribution::~NDummyDistribution(NDummyDistribution *this)
{
  JUMPOUT(0x212BAC9D8);
}

uint64_t NDummyDistribution::size(NDummyDistribution *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t NDummyDistribution::dimen(NDummyDistribution *this)
{
  return (uint64_t)this + 12;
}

uint64_t NDummyDistribution::read(NDummyDistribution *this, const NString *a2)
{
  const char *v4;
  const char *v5;
  BOOL v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  const char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  void *v20;
  size_t v21;
  _BYTE *v22;
  char *v23;
  const char *v24;
  unsigned int v25;
  _BYTE *v26;
  void *v27;
  int v28;
  uint64_t result;
  const NString *v30;
  char *v31;
  NDummyDistribution *v32;
  char v33;
  uint64_t (**v34)(NString *__hidden, const unsigned int *);
  unsigned int v35;
  uint64_t v36;
  char *__endptr;
  unsigned int v38;
  void *v39;
  uint64_t (**v40)(NString *__hidden, const unsigned int *);
  unsigned int v41;
  _BYTE *v42;
  uint64_t (**v43)(NString *__hidden, const unsigned int *);
  int v44;
  uint64_t v45;
  uint64_t (**v46)();
  uint64_t v47;

  *((_QWORD *)this + 1) = 0;
  v43 = &off_24C7F32C0;
  v44 = 1;
  v45 = operator new[]();
  *(_WORD *)v45 = 114;
  v46 = (uint64_t (**)())&off_24C7F33E0;
  v47 = 0;
  NFilePtr::open((NFilePtr *)&v46, a2, (const NString *)&v43);
  v43 = &off_24C7F32C0;
  if (v45)
    MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
  if (!v47)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v4);
  LODWORD(v40) = 13;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v47 + 64))(&v43, v47, &v40);
  if (v44 != 13
    || (*(_QWORD *)v45 == 0x206158494D442023 ? (v6 = *(_QWORD *)(v45 + 5) == 0x30302E3176206158) : (v6 = 0), !v6))
  {
    Error::chuck((Error *)"NDummyDistribution::read() - cannot read cookie from file %s", v5, *((_QWORD *)a2 + 2));
  }
  v32 = this;
  v30 = a2;
  v40 = &off_24C7F32C0;
  v41 = 0;
  LODWORD(v7) = 0;
  v42 = (_BYTE *)operator new[]();
  *v42 = 0;
  v31 = "Index %d outside of range [0,%d]";
  while (1)
  {
    if (!v47)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v47 + 48))(v47))
      break;
    if (!v47)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v9);
    v33 = 35;
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, char *))(*(_QWORD *)v47 + 80))(&v34, v47, &v33);
    v11 = (char *)operator new[]();
    strcpy(v11, "\r\n\t ");
    v12 = v35;
    v13 = v36;
    if (v35)
    {
      v14 = 0;
      while (strchr(v11, *(char *)(v13 + v14)))
      {
        if (v12 == ++v14)
        {
          v15 = v12;
          v16 = v12;
          v14 = v12;
          goto LABEL_21;
        }
      }
      v15 = v14;
      v16 = v12;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      v14 = 0;
    }
LABEL_21:
    if (v14 >= v12)
      v17 = v12;
    else
      v17 = v14;
    while (v16 > v15)
    {
      v18 = v16--;
      if (!strchr(v11, *(char *)(v13 + v18 - 1)))
      {
        v17 = v18;
        break;
      }
    }
    if (v14 > v12)
      goto LABEL_59;
    if (v17 > v12)
    {
      v14 = v17;
      goto LABEL_59;
    }
    v19 = (v17 - v14);
    if (v17 < v14)
    {
      v31 = "Start and end indices conflict, start [%d], end [%d]";
      v12 = v17;
LABEL_59:
      Error::chuck((Error *)v31, v10, v14, v12);
    }
    __endptr = (char *)&off_24C7F32C0;
    if (!v13)
      Error::chuck((Error *)"Null pointer passed to string constructor", v10);
    v38 = v17 - v14;
    v20 = (void *)operator new[]();
    v39 = v20;
    memcpy(v20, (const void *)(v13 + v14), v19);
    *((_BYTE *)v20 + v19) = 0;
    ((void (*)(NString *, const void *, const unsigned int *))v40[8])((NString *)&v40, v20, &v38);
    __endptr = (char *)&off_24C7F32C0;
    if (v39)
      MEMORY[0x212BAC9C0](v39, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
    v34 = &off_24C7F32C0;
    if (v36)
      MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
    v7 = (v7 + 1);
    if (v41)
    {
      v21 = v41 - 4;
      if (v41 < 4 || (v22 = v42, *(_DWORD *)v42 != 1028475204))
        Error::chuck((Error *)"NDummyDistribution::read() - invalid line in file %s on line %d", v8, *((_QWORD *)v30 + 2), v7);
      if (!v42)
        Error::chuck((Error *)"Null pointer passed to string constructor", v8);
      v23 = (char *)operator new[]();
      memcpy(v23, v22 + 4, v21);
      v23[v21] = 0;
      if (!(_DWORD)v21 || (__endptr = 0, strtoul(v23, &__endptr, 10), __endptr != &v23[v21]))
        Error::chuck((Error *)"NDummyDistribution::read() - DIM= field invalid in file %s on line %d", v24, *((_QWORD *)v30 + 2), v7);
      v25 = v41;
      if (v41 <= 3)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v24, 4, v41);
      v26 = v42;
      if (!v42)
        Error::chuck((Error *)"Null pointer passed to string constructor", v24);
      v27 = (void *)operator new[]();
      memcpy(v27, v26 + 4, v25 - 4);
      *((_BYTE *)v27 + v25 - 4) = 0;
      *((_DWORD *)v32 + 3) = strtoul((const char *)v27, 0, 10);
      MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
    }
  }
  v28 = *((_DWORD *)v32 + 3);
  if (!v28)
    Error::chuck((Error *)"NDummyDistribution::read() - DIM= unset in file %s", v9, *((_QWORD *)v30 + 2));
  *((_DWORD *)v32 + 2) = v28;
  v40 = &off_24C7F32C0;
  if (v42)
    MEMORY[0x212BAC9C0](v42, 0x1000C8077774924);
  v43 = &off_24C7F32C0;
  if (v45)
    MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
  v46 = &off_24C7F17F8;
  result = v47;
  if (v47)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
  return result;
}

void sub_20D9CFA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  uint64_t v27;
  uint64_t v29;

  if (a24)
    MEMORY[0x212BAC9C0](a24, 0x1000C8077774924);
  if (a27)
    MEMORY[0x212BAC9C0](a27, 0x1000C8077774924);
  *(_QWORD *)(v27 - 104) = &off_24C7F17F8;
  v29 = *(_QWORD *)(v27 - 96);
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  _Unwind_Resume(exception_object);
}

float NDummyDistribution::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return *(float *)(*(_QWORD *)(a3 + 8) + 4 * *a2);
}

void NDummyDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "scoreUsingCache");
}

void NDummyDistribution::componentScore(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "componentScore");
}

void NDummyDistribution::numComponents(NDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "numComponents");
}

void NDummyDistribution::setComponentMask(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "setComponentMask");
}

void NDummyDistribution::firstComponentId(NDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "firstComponentId");
}

void NDummyDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "posteriorWeightedMean");
}

void NDummyDistribution::baseGMM(NDummyDistribution *this, const char *a2)
{
  NDummyDistribution::notSupported(this, a2);
}

void NDummyDistribution::fixedPointScalesP(NDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "fixedPointScalesP");
}

void NDummyDistribution::notSupported(NDummyDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NDummyDistribution::%s() - not supported for this distribution type", a2, "baseGMM");
}

_QWORD *NArray<unsigned int const*>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F2F40;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x50C80EE9192B6);
  return a1;
}

void NArray<unsigned int const*>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F2F40;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x50C80EE9192B6);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<unsigned int const*>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x50C80EE9192B6);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = 8 * v4;
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + v7) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + v7);
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  return a1;
}

uint64_t NArray<unsigned int const*>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x50C80EE9192B6);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = 0;
    v10 = 8 * v5;
    do
    {
      *(_QWORD *)(*(_QWORD *)(v4 + 8) + v9) = *(_QWORD *)(a2 + v9);
      v9 += 8;
    }
    while (v10 != v9);
  }
  return result;
}

uint64_t NArray<unsigned int const*>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = *(unsigned int *)(result + 16);
  if ((_DWORD)v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    if ((_DWORD)v2)
      v6 = *a2 == 0;
    else
      v6 = 1;
    if (!v6)
    {
      v7 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * v7) = *(_QWORD *)(v5 + 8 * v7);
        ++v7;
      }
      while (v7 < v2 && v7 < *a2);
LABEL_11:
      JUMPOUT(0x212BAC9C0);
    }
    if (v5)
      goto LABEL_11;
  }
  return result;
}

_QWORD *NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F24A0;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F40;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return a1;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F24A0;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F40;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::read(uint64_t a1, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  int v11;
  const char *v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  _DWORD *v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _DWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t result;
  const char *v41;
  char *v42;
  uint64_t (**v43)();
  uint64_t v44;
  uint64_t (**v45)(NString *, const unsigned int *);
  unsigned int v46;
  void *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  char *v50;
  size_t __n;
  size_t v52;
  void *__s2;
  uint64_t (**i)();
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  int v59;
  void *__s1;
  BOOL v61[8];
  void *__src;
  uint64_t v63;
  float v64;
  __int16 v65;
  char __str[8];
  uint64_t v67;
  _WORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 1;
  v68 = (_WORD *)operator new[]();
  *v68 = 114;
  v43 = (uint64_t (**)())&off_24C7F33E0;
  v44 = 0;
  NFilePtr::open((NFilePtr *)&v43, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v68)
    MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 0;
  v4 = (_BYTE *)operator new[]();
  v68 = v4;
  *v4 = 0;
  v61[0] = 0;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)(a1 + 296), a2, (NFilePtr *)&v43, (const NString *)__str, v61);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (*(_BYTE *)(a1 + 328) != 8
    || *(_BYTE *)(a1 + 329) != 8
    || *(_BYTE *)(a1 + 330) != 32
    || *(_BYTE *)(a1 + 331) != 32
    || *(_BYTE *)(a1 + 332) != 32
    || *(_BYTE *)(a1 + 333) != 32)
  {
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)(a1 + 296), (uint64_t)__str);
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header encoding (%s) does not match class  encoding (%d-%d-%d).", v41, v68, 8, 32, 32);
  }
  if (!*(_BYTE *)(a1 + 549))
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header usesd spec (%d) does not match class  encoding (%d).", v5, 0, 0);
  NFastFixedGaussians<signed char,int,unsigned short>::read(a1 + 8, (uint64_t)a2, (uint64_t)&v43, a1 + 336, (int *)(a1 + 536), (_BYTE *)(a1 + 548));
  if (*(_BYTE *)(a1 + 548))
  {
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, a1 + 544, a1 + 248);
    v9 = *(unsigned int *)(a1 + 544);
    if ((_DWORD)v7 != (_DWORD)v9)
      Error::chuck((Error *)"NFastFixedDistribution::read() - not enough weight data in file %s (%d out of %d bytes)", v8, *((_QWORD *)a2 + 2), v7, v9);
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    *(_DWORD *)v61 = 2;
    (*(void (**)(char *__return_ptr, uint64_t, BOOL *))(*(_QWORD *)v44 + 64))(__str, v44, v61);
    v11 = v67;
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v68)
      MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
    if (v11)
      Error::chuck((Error *)"NFastFixedDistribution::read() - extraneous data at end of file %s", v10, *((_QWORD *)a2 + 2));
  }
  else
  {
    *(_QWORD *)v61 = &off_24C7F1090;
    __src = 0;
    v63 = 0;
    v64 = 2.0;
    v65 = 257;
    v58 = &off_24C7F32C0;
    v59 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v55 = 0;
    v56 = 0;
    i = off_24C7F13C0;
    v57 = 0;
    if (*(_DWORD *)(a1 + 540))
    {
      v42 = "Index %d outside of range [0,%d]";
      if (!v44)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
      LOBYTE(v48) = 35;
      (*(void (**)(size_t *__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v44 + 80))(&__n, v44, &v48);
      v14 = (char *)operator new[]();
      strcpy(v14, "\r\n\t ");
      v15 = v52;
      v16 = (char *)__s2;
      if ((_DWORD)v52)
      {
        v17 = 0;
        while (strchr(v14, v16[v17]))
        {
          if (v15 == ++v17)
          {
            v18 = v15;
            v19 = v15;
            v17 = v15;
            goto LABEL_27;
          }
        }
        v18 = v17;
        v19 = v15;
      }
      else
      {
        v18 = 0;
        v19 = 0;
        v17 = 0;
      }
LABEL_27:
      if (v17 >= v15)
        v20 = v15;
      else
        v20 = v17;
      do
      {
        if (v19 <= v18)
          goto LABEL_33;
        v21 = v19--;
      }
      while (strchr(v14, v16[v21 - 1]));
      v20 = v21;
LABEL_33:
      if (v17 <= v15)
      {
        if (v20 > v15)
        {
          v17 = v20;
        }
        else
        {
          if (v20 >= v17)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v16)
            {
              LODWORD(v67) = v20 - v17;
              v22 = (_WORD *)operator new[]();
              v68 = v22;
              memcpy(v22, &v16[v17], (v20 - v17));
              *((_BYTE *)v22 + (v20 - v17)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v58[8])((NString *)&v58, v22, (const unsigned int *)&v67);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v68)
                MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
              __n = (size_t)&off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v48 = &off_24C7F32C0;
              v49 = 2;
              v50 = (char *)operator new[]();
              strcpy(v50, "M=");
              v45 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v46 = strlen(__str);
                v47 = (void *)(*v45)((NString *)&v45, &v46);
                memcpy(v47, __str, v46 + 1);
                NString::operator+((uint64_t)&v48, (uint64_t)&v45, (uint64_t)&__n);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v23);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v13);
          }
          v42 = "Start and end indices conflict, start [%d], end [%d]";
          v15 = v20;
        }
      }
      Error::chuck((Error *)v42, v13, v17, v15);
    }
    LODWORD(__n) = 0;
    if (*(_DWORD *)(a1 + 256))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 8))(a1 + 248, *(_QWORD *)(a1 + 264));
      v24 = (**(uint64_t (***)(uint64_t, size_t *))(a1 + 248))(a1 + 248, &__n);
      *(_QWORD *)(a1 + 264) = v24;
      v25 = __n;
      *(_DWORD *)(a1 + 256) = __n;
      *(_BYTE *)(v24 + v25) = 0;
    }
    v26 = *(void **)(a1 + 264);
    if (!(_DWORD)v63)
    {
      if (!HIBYTE(v65))
        Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v12, 0, 0);
      if (HIDWORD(v63))
      {
        LODWORD(v63) = 1;
      }
      else
      {
        *(_DWORD *)__str = 1;
        (*(void (**)(BOOL *, char *, _QWORD))(*(_QWORD *)v61 + 48))(v61, __str, v64);
      }
    }
    memcpy(v26, __src, __n);
    *(_DWORD *)(a1 + 544) = __n;
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v10))
    {
      v10 = (const char *)v55;
      if (!v55)
        break;
      v55 = *(_QWORD *)(v55 + 8);
    }
    v58 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    *(_QWORD *)v61 = &off_24C7F3100;
    if (__src)
      MEMORY[0x212BAC9C0](__src, 0x1000C8052888210);
  }
  if (!v44)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v10);
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v28 = *(_DWORD **)(a1 + 264);
  v29 = *(unsigned int *)(a1 + 256);
  v30 = *(unsigned int *)(a1 + 288);
  v31 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v30 == v31)
  {
    v32 = *(_DWORD *)(a1 + 288);
    goto LABEL_68;
  }
  v33 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 288) = v31;
  *(_QWORD *)(a1 + 280) = operator new[]();
  v32 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v30 && v32)
  {
    v34 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v34) = *(_QWORD *)(v33 + 8 * v34);
      ++v34;
    }
    while (v34 < v30 && v34 < *(unsigned int *)(a1 + 540));
  }
  else if (!v33)
  {
    goto LABEL_68;
  }
  MEMORY[0x212BAC9C0](v33, 0x50C80EE9192B6);
  v32 = *(_DWORD *)(a1 + 540);
LABEL_68:
  v35 = (unint64_t)v28 + v29;
  if (v32)
  {
    v36 = 0;
    do
    {
      if ((unint64_t)v28 >= v35)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v27, *((_QWORD *)a2 + 2));
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v36) = v28;
      v37 = v28 + 1;
      v38 = *v28;
      if ((unint64_t)&v28[2 * *v28 + 1] > v35)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v27, *((_QWORD *)a2 + 2));
      if (v38)
      {
        v39 = 0;
        do
        {
          if (*v37 >= *(_DWORD *)(a1 + 536))
            Error::chuck((Error *)"NFastFixedDistribution::read() - invalid gaussian index in M=%d, comp %d, in file %s", v27, v36, v39, *((_QWORD *)a2 + 2));
          v37 += 2;
          v39 = (v39 + 1);
        }
        while (v38 != (_DWORD)v39);
        v37 = &v28[2 * (v38 - 1) + 3];
      }
      ++v36;
      v28 = v37;
    }
    while (v36 < *(unsigned int *)(a1 + 540));
  }
  else
  {
    v37 = v28;
  }
  if (v37 != (_DWORD *)v35)
    Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector under/overflows block in file %s", v27, *((_QWORD *)a2 + 2));
  v43 = &off_24C7F17F8;
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void sub_20D9D1574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t (**a38)(NString *__hidden this, const unsigned int *),uint64_t a39,uint64_t a40,uint64_t (**a41)(),uint64_t a42)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a34);
  a38 = &off_24C7F32C0;
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  a41 = &off_24C7F3100;
  if (a42)
    MEMORY[0x212BAC9C0](a42, 0x1000C8052888210);
  if (a24)
    (*(void (**)(uint64_t))(*(_QWORD *)a24 + 8))(a24);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  int *v36;
  int v37;
  int *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  float v43;
  float v44;
  _QWORD v46[2];
  int v47;
  int v48;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v46[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v46[1] = v22;
  v47 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = *(int **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v37 = *v36;
  if (*v36)
  {
    v38 = v36 + 1;
    v39 = -1073741823;
    do
    {
      v40 = v39;
      v48 = *v38;
      v41 = NFastFixedGaussians<signed char,int,unsigned short>::score(a1 + 8, &v48, (uint64_t)v46, v23, v24, v25, v26, v27, v28, v29, v30)- v38[1];
      if (v41 <= v40)
        v39 = v40;
      else
        v39 = v41;
      if (v41 >= v40)
        v41 = v40;
      if (v41 != -1073741823)
      {
        v42 = v39 - v41;
        if (v42 <= *(_DWORD *)(a1 + 500))
          v39 += *(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v42 >> *(_DWORD *)(a1 + 496)));
      }
      v38 += 2;
      --v37;
    }
    while (v37);
    v43 = (float)v39;
  }
  else
  {
    v43 = -1073700000.0;
  }
  v44 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v44 * v43;
}

void sub_20D9D1B0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int *v5;
  int v6;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v5 = *(int **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v6 = *v5;
  if (*v5)
  {
    v9 = v5 + 2;
    v10 = 3221225473;
    do
    {
      v12 = *(v9 - 1);
      if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + v12))
      {
        v13 = (uint64_t)rintf(*(float *)(*(_QWORD *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10)
          v11 = v10;
        else
          v11 = v13;
        if (v13 >= (int)v10)
          v13 = v10;
        if (v13 != -1073741823)
        {
          v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500))
            v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
                               + v11);
        }
      }
      else
      {
        v11 = v10;
      }
      v9 += 2;
      v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::componentScore(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  int v36;
  float v37;
  _QWORD v39[2];
  int v40;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v39[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v39[1] = v22;
  v40 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = NFastFixedGaussians<signed char,int,unsigned short>::score(a1 + 8, a2, (uint64_t)v39, v23, v24, v25, v26, v27, v28, v29, v30);
  v37 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v37 * (float)v36;
}

void sub_20D9D1E34(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v3 = *(unsigned int **)(*(_QWORD *)(result + 280) + 8 * *a2);
  v4 = *v3;
  if ((_DWORD)v4)
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      v12 = v4 - v7;
      do
      {
        v13 = *v5;
        v5 += 2;
        *(_BYTE *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    v7 = v4 & 0xFFFFFFFE;
    v5 += 2 * v7;
    v8 = v3 + 3;
    v9 = v7;
    do
    {
      v10 = *(v8 - 2);
      v11 = *v8;
      v8 += 4;
      *(_BYTE *)(v6 + v10) = 1;
      *(_BYTE *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * *a2) + 4);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::posteriorWeightedMean() - not implemented", a2);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::baseGMM(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::baseGMM() - not implemented for fixed-point models", a2);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void *NFastFixedGaussians<signed char,int,unsigned short>::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _BYTE *a6)
{
  const char *v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  void *result;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  uint64_t (**v36)(NString *, const unsigned int *);
  unsigned int v37;
  void *v38;
  uint64_t (**v39)(NString *__hidden, const unsigned int *);
  int v40;
  char *v41;
  uint64_t (**v42)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**i)();
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t (**v49)(NString *__hidden, const unsigned int *);
  int v50;
  void *__s1;
  unsigned int v52;
  char __str[8];
  uint64_t v54;
  void *v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  NGaussianFixedPointScales::operator=(a1 + 32, a4);
  v13 = *a5;
  v14 = 2 * *(_DWORD *)(a4 + 184) + ((-2 * *(_DWORD *)(a4 + 184)) & 2) + 8;
  *(_DWORD *)(a1 + 232) = v14;
  *(_DWORD *)(a1 + 236) = v13;
  v15 = *a5 * v14;
  v52 = v15;
  if (*a6)
  {
    v16 = *(_QWORD *)(a3 + 8);
    if (!v16)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
    result = (void *)(*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)v16 + 72))(v16, &v52, a1);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16);
    if ((_DWORD)result != v52)
      Error::chuck((Error *)"NFastFixedGaussians::read() - not enough gaussian data in file %s (%d out of %d bytes)", v18, *(_QWORD *)(a2 + 16), result, v52);
  }
  else
  {
    v49 = &off_24C7F32C0;
    v50 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v46 = 0;
    v47 = 0;
    i = off_24C7F13C0;
    v48 = 0;
    if (v15 != *(_DWORD *)(a1 + 8))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 8))(a1, *(_QWORD *)(a1 + 16));
      v19 = (**(uint64_t (***)(uint64_t, unsigned int *))a1)(a1, &v52);
      *(_QWORD *)(a1 + 16) = v19;
      v20 = v52;
      *(_DWORD *)(a1 + 8) = v52;
      *(_BYTE *)(v19 + v20) = 0;
      v15 = v52;
    }
    v35 = *(void **)(a1 + 16);
    *(_QWORD *)(a1 + 24) = v35;
    bzero(v35, v15);
    if (*a5)
    {
      v22 = *(_QWORD *)(a3 + 8);
      if (!v22)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v21);
      LOBYTE(v39) = 35;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v22 + 80))(&v42, v22, &v39);
      v24 = (char *)operator new[]();
      strcpy(v24, "\r\n\t ");
      v25 = __n;
      v26 = (char *)__s2;
      if ((_DWORD)__n)
      {
        v27 = 0;
        while (strchr(v24, v26[v27]))
        {
          if (v25 == ++v27)
          {
            v28 = v25;
            v29 = v25;
            v27 = v25;
            goto LABEL_16;
          }
        }
        v28 = v27;
        v29 = v25;
      }
      else
      {
        v28 = 0;
        v29 = 0;
        v27 = 0;
      }
LABEL_16:
      if (v27 >= v25)
        v30 = v25;
      else
        v30 = v27;
      do
      {
        if (v29 <= v28)
          goto LABEL_22;
        v31 = v29--;
      }
      while (strchr(v24, v26[v31 - 1]));
      v30 = v31;
LABEL_22:
      if (v27 <= v25)
      {
        if (v30 <= v25)
        {
          if (v30 >= v27)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v26)
            {
              LODWORD(v54) = v30 - v27;
              v32 = (void *)operator new[]();
              v55 = v32;
              memcpy(v32, &v26[v27], (v30 - v27));
              *((_BYTE *)v32 + (v30 - v27)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v49[8])((NString *)&v49, v32, (const unsigned int *)&v54);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v55)
                MEMORY[0x212BAC9C0](v55, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
              v42 = &off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v39 = &off_24C7F32C0;
              v40 = 2;
              v41 = (char *)operator new[]();
              strcpy(v41, "G=");
              v36 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v37 = strlen(__str);
                v38 = (void *)(*v36)((NString *)&v36, &v37);
                memcpy(v38, __str, v37 + 1);
                NString::operator+((uint64_t)&v39, (uint64_t)&v36, (uint64_t)&v42);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v33);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v23);
          }
          Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v23, v27, v30);
        }
        v27 = v30;
      }
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v23, v27, v25);
    }
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, v34))
    {
      v34 = v46;
      if (!v46)
        break;
      v46 = *(_QWORD *)(v46 + 8);
    }
    v49 = &off_24C7F32C0;
    result = __s1;
    if (__s1)
      return (void *)MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
  }
  return result;
}

void sub_20D9D2BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a33);
  if (!a39)
    _Unwind_Resume(a1);
  MEMORY[0x212BAC9C0](a39, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_QWORD *NAutoArray<unsigned int>::~NAutoArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3100;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
  return a1;
}

void NAutoArray<unsigned int>::~NAutoArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3100;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NAutoArray<unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v6 = *(_DWORD *)(a2 + 16);
  v4 = a2 + 16;
  v5 = v6;
  v7 = *(_DWORD *)(a1 + 20);
  v8 = v6 >= v7;
  if (v6 <= v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    if (!v8)
    {
      v9 = *(_QWORD *)(a1 + 8);
      do
        *(_DWORD *)(v9 + 4 * v5++) = 0;
      while (v5 < *(unsigned int *)(a1 + 20));
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, v4, (float)(*(float *)(a1 + 24) * (float)v5));
  }
  if (*(_DWORD *)(a1 + 16))
  {
    v10 = 0;
    v11 = *(_QWORD *)(a2 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    do
    {
      *(_DWORD *)(v12 + 4 * v10) = *(_DWORD *)(v11 + 4 * v10);
      ++v10;
    }
    while (v10 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

uint64_t NAutoArray<unsigned int>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v4 = result;
  v5 = *a3;
  if (*(_DWORD *)(result + 20) < *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
      v5 = *a3;
    }
    *(_DWORD *)(v4 + 20) = v5;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *a3;
  }
  *(_DWORD *)(v4 + 16) = v5;
  if (v5)
  {
    v8 = 0;
    v9 = *(_QWORD *)(v4 + 8);
    do
    {
      *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(a2 + 4 * v8);
      ++v8;
    }
    while (v8 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NAutoArray<unsigned int>::operator=(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

uint64_t NAutoArray<unsigned int>::resize(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  int *v19;
  int v20;

  v5 = *a2;
  if (*a2 <= a3)
    v6 = a3;
  else
    v6 = *a2;
  if (v6)
  {
    v7 = operator new[]();
    v5 = *a2;
  }
  else
  {
    v7 = 0;
  }
  v8 = *(_DWORD *)(a1 + 16);
  if (v5 < v8)
  {
    *(_DWORD *)(a1 + 16) = v5;
    v8 = v5;
  }
  result = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v10 = 0;
    v11 = v8;
    if (v8 < 8)
      goto LABEL_15;
    if ((unint64_t)(v7 - result) < 0x20)
      goto LABEL_15;
    v10 = v8 & 0xFFFFFFF8;
    v12 = (_OWORD *)(v7 + 16);
    v13 = (__int128 *)(result + 16);
    v14 = v11 & 0xFFFFFFF8;
    do
    {
      v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 8;
    }
    while (v14);
    if (v10 != v11)
    {
LABEL_15:
      v16 = v11 - v10;
      v17 = 4 * v10;
      v18 = (_DWORD *)(v7 + 4 * v10);
      v19 = (int *)(result + v17);
      do
      {
        v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
    }
    goto LABEL_19;
  }
  if (result)
LABEL_19:
    result = MEMORY[0x212BAC9C0]();
  *(_QWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = v6;
  return result;
}

uint64_t NGaussianFixedPointScales::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  int *v24;
  int v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _OWORD *v33;
  __int128 *v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  _DWORD *v39;
  int *v40;
  int v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _OWORD *v49;
  __int128 *v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  int *v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  if (a1 == a2)
  {
    *(_BYTE *)(a1 + 120) = *(_BYTE *)(a2 + 120);
    v71 = *(_QWORD *)(a2 + 124);
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a2 + 132);
    *(_QWORD *)(a1 + 124) = v71;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 32);
    v5 = *(_DWORD *)(a2 + 32);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 24);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
        v5 = *(_DWORD *)(a2 + 32);
      }
      *(_DWORD *)(a1 + 32) = v5;
      *(_QWORD *)(a1 + 24) = operator new[]();
      v4 = *(_DWORD *)(a1 + 32);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 24);
      v9 = *(_QWORD *)(a1 + 24);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 32));
    }
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
    v10 = *(_DWORD *)(a1 + 64);
    v11 = *(_DWORD *)(a2 + 64);
    if (v10 != v11)
    {
      v12 = *(_QWORD *)(a1 + 56);
      if (v12)
      {
        MEMORY[0x212BAC9C0](v12, 0x1000C8052888210);
        v11 = *(_DWORD *)(a2 + 64);
      }
      *(_DWORD *)(a1 + 64) = v11;
      *(_QWORD *)(a1 + 56) = operator new[]();
      v10 = *(_DWORD *)(a1 + 64);
    }
    if (v10)
    {
      v13 = 0;
      v14 = *(_QWORD *)(a2 + 56);
      v15 = *(_QWORD *)(a1 + 56);
      v16 = v10;
      if (v10 < 8)
        goto LABEL_19;
      if ((unint64_t)(v15 - v14) < 0x20)
        goto LABEL_19;
      v13 = v10 & 0xFFFFFFF8;
      v17 = (_OWORD *)(v15 + 16);
      v18 = (__int128 *)(v14 + 16);
      v19 = v16 & 0xFFFFFFF8;
      do
      {
        v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v13 != v16)
      {
LABEL_19:
        v21 = v16 - v13;
        v22 = 4 * v13;
        v23 = (_DWORD *)(v15 + v22);
        v24 = (int *)(v14 + v22);
        do
        {
          v25 = *v24++;
          *v23++ = v25;
          --v21;
        }
        while (v21);
      }
    }
    v26 = *(_DWORD *)(a1 + 88);
    v27 = *(_DWORD *)(a2 + 88);
    if (v26 != v27)
    {
      v28 = *(_QWORD *)(a1 + 80);
      if (v28)
      {
        MEMORY[0x212BAC9C0](v28, 0x1000C8052888210);
        v27 = *(_DWORD *)(a2 + 88);
      }
      *(_DWORD *)(a1 + 88) = v27;
      *(_QWORD *)(a1 + 80) = operator new[]();
      v26 = *(_DWORD *)(a1 + 88);
    }
    if (v26)
    {
      v29 = 0;
      v30 = *(_QWORD *)(a2 + 80);
      v31 = *(_QWORD *)(a1 + 80);
      v32 = v26;
      if (v26 < 8)
        goto LABEL_31;
      if ((unint64_t)(v31 - v30) < 0x20)
        goto LABEL_31;
      v29 = v26 & 0xFFFFFFF8;
      v33 = (_OWORD *)(v31 + 16);
      v34 = (__int128 *)(v30 + 16);
      v35 = v32 & 0xFFFFFFF8;
      do
      {
        v36 = *v34;
        *(v33 - 1) = *(v34 - 1);
        *v33 = v36;
        v33 += 2;
        v34 += 2;
        v35 -= 8;
      }
      while (v35);
      if (v29 != v32)
      {
LABEL_31:
        v37 = v32 - v29;
        v38 = 4 * v29;
        v39 = (_DWORD *)(v31 + v38);
        v40 = (int *)(v30 + v38);
        do
        {
          v41 = *v40++;
          *v39++ = v41;
          --v37;
        }
        while (v37);
      }
    }
    v42 = *(_DWORD *)(a1 + 112);
    v43 = *(_DWORD *)(a2 + 112);
    if (v42 != v43)
    {
      v44 = *(_QWORD *)(a1 + 104);
      if (v44)
      {
        MEMORY[0x212BAC9C0](v44, 0x1000C8052888210);
        v43 = *(_DWORD *)(a2 + 112);
      }
      *(_DWORD *)(a1 + 112) = v43;
      *(_QWORD *)(a1 + 104) = operator new[]();
      v42 = *(_DWORD *)(a1 + 112);
    }
    if (v42)
    {
      v45 = 0;
      v46 = *(_QWORD *)(a2 + 104);
      v47 = *(_QWORD *)(a1 + 104);
      v48 = v42;
      if (v42 < 8)
        goto LABEL_43;
      if ((unint64_t)(v47 - v46) < 0x20)
        goto LABEL_43;
      v45 = v42 & 0xFFFFFFF8;
      v49 = (_OWORD *)(v47 + 16);
      v50 = (__int128 *)(v46 + 16);
      v51 = v48 & 0xFFFFFFF8;
      do
      {
        v52 = *v50;
        *(v49 - 1) = *(v50 - 1);
        *v49 = v52;
        v49 += 2;
        v50 += 2;
        v51 -= 8;
      }
      while (v51);
      if (v45 != v48)
      {
LABEL_43:
        v53 = v48 - v45;
        v54 = 4 * v45;
        v55 = (_DWORD *)(v47 + v54);
        v56 = (int *)(v46 + v54);
        do
        {
          v57 = *v56++;
          *v55++ = v57;
          --v53;
        }
        while (v53);
      }
    }
    *(_BYTE *)(a1 + 120) = *(_BYTE *)(a2 + 120);
    v58 = *(_QWORD *)(a2 + 124);
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a2 + 132);
    *(_QWORD *)(a1 + 124) = v58;
    v59 = *(_DWORD *)(a1 + 152);
    v60 = *(_DWORD *)(a2 + 152);
    if (v59 != v60)
    {
      v61 = *(_QWORD *)(a1 + 144);
      if (v61)
      {
        MEMORY[0x212BAC9C0](v61, 0x1000C8052888210);
        v60 = *(_DWORD *)(a2 + 152);
      }
      *(_DWORD *)(a1 + 152) = v60;
      *(_QWORD *)(a1 + 144) = operator new[]();
      v59 = *(_DWORD *)(a1 + 152);
    }
    if (v59)
    {
      v62 = 0;
      v63 = *(_QWORD *)(a2 + 144);
      v64 = *(_QWORD *)(a1 + 144);
      do
      {
        *(_DWORD *)(v64 + 4 * v62) = *(_DWORD *)(v63 + 4 * v62);
        ++v62;
      }
      while (v62 < *(unsigned int *)(a1 + 152));
    }
    *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
    v65 = *(_DWORD *)(a1 + 184);
    v66 = *(_DWORD *)(a2 + 184);
    if (v65 != v66)
    {
      v67 = *(_QWORD *)(a1 + 176);
      if (v67)
      {
        MEMORY[0x212BAC9C0](v67, 0x1000C8052888210);
        v66 = *(_DWORD *)(a2 + 184);
      }
      *(_DWORD *)(a1 + 184) = v66;
      *(_QWORD *)(a1 + 176) = operator new[]();
      v65 = *(_DWORD *)(a1 + 184);
    }
    if (v65)
    {
      v68 = 0;
      v69 = *(_QWORD *)(a2 + 176);
      v70 = *(_QWORD *)(a1 + 176);
      do
      {
        *(_DWORD *)(v70 + 4 * v68) = *(_DWORD *)(v69 + 4 * v68);
        ++v68;
      }
      while (v68 < *(unsigned int *)(a1 + 184));
    }
  }
  *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
  return a1;
}

_QWORD *NArray<unsigned short const*>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F2F78;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x50C80EE9192B6);
  return a1;
}

void NArray<unsigned short const*>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F2F78;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x50C80EE9192B6);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<unsigned short const*>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x50C80EE9192B6);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = 8 * v4;
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + v7) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + v7);
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  return a1;
}

uint64_t NArray<unsigned short const*>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x50C80EE9192B6);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = 0;
    v10 = 8 * v5;
    do
    {
      *(_QWORD *)(*(_QWORD *)(v4 + 8) + v9) = *(_QWORD *)(a2 + v9);
      v9 += 8;
    }
    while (v10 != v9);
  }
  return result;
}

uint64_t NArray<unsigned short const*>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = *(unsigned int *)(result + 16);
  if ((_DWORD)v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    if ((_DWORD)v2)
      v6 = *a2 == 0;
    else
      v6 = 1;
    if (!v6)
    {
      v7 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * v7) = *(_QWORD *)(v5 + 8 * v7);
        ++v7;
      }
      while (v7 < v2 && v7 < *a2);
LABEL_11:
      JUMPOUT(0x212BAC9C0);
    }
    if (v5)
      goto LABEL_11;
  }
  return result;
}

_QWORD *NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2610;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F78;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return a1;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2610;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F78;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::read(uint64_t a1, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _WORD *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  const char *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned __int16 *v36;
  int v37;
  uint64_t v38;
  uint64_t result;
  const char *v40;
  char *v41;
  char *v42;
  uint64_t (**v43)();
  uint64_t v44;
  uint64_t (**v45)(NString *, const unsigned int *);
  unsigned int v46;
  void *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  char *v50;
  size_t __n;
  size_t v52;
  void *__s2;
  uint64_t (**i)();
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  int v59;
  void *__s1;
  BOOL v61[8];
  void *__src;
  uint64_t v63;
  float v64;
  __int16 v65;
  char __str[8];
  uint64_t v67;
  _WORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 1;
  v68 = (_WORD *)operator new[]();
  *v68 = 114;
  v43 = (uint64_t (**)())&off_24C7F33E0;
  v44 = 0;
  NFilePtr::open((NFilePtr *)&v43, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v68)
    MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 0;
  v4 = (_BYTE *)operator new[]();
  v68 = v4;
  *v4 = 0;
  v61[0] = 0;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)(a1 + 296), a2, (NFilePtr *)&v43, (const NString *)__str, v61);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (*(_BYTE *)(a1 + 328) != 8
    || *(_BYTE *)(a1 + 329) != 8
    || *(_BYTE *)(a1 + 330) != 32
    || *(_BYTE *)(a1 + 331) != 16
    || *(_BYTE *)(a1 + 332) != 16
    || *(_BYTE *)(a1 + 333) != 16)
  {
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)(a1 + 296), (uint64_t)__str);
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header encoding (%s) does not match class  encoding (%d-%d-%d).", v40, v68, 8, 32, 16);
  }
  if (!*(_BYTE *)(a1 + 549))
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header usesd spec (%d) does not match class  encoding (%d).", v5, 0, 0);
  if (*(_DWORD *)(a1 + 536) > 0x10000u)
  {
    v41 = "NFastFixedDistribution::read() - more gaussians that index range provided by this format";
    goto LABEL_97;
  }
  NFastFixedGaussians<signed char,int,unsigned short>::read(a1 + 8, (uint64_t)a2, (uint64_t)&v43, a1 + 336, (int *)(a1 + 536), (_BYTE *)(a1 + 548));
  if (*(_BYTE *)(a1 + 548))
  {
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, a1 + 544, a1 + 248);
    v9 = *(unsigned int *)(a1 + 544);
    if ((_DWORD)v7 != (_DWORD)v9)
      Error::chuck((Error *)"NFastFixedDistribution::read() - not enough weight data in file %s (%d out of %d bytes)", v8, *((_QWORD *)a2 + 2), v7, v9);
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    *(_DWORD *)v61 = 2;
    (*(void (**)(char *__return_ptr, uint64_t, BOOL *))(*(_QWORD *)v44 + 64))(__str, v44, v61);
    v10 = v67;
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v68)
      MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
    if (v10)
      Error::chuck((Error *)"NFastFixedDistribution::read() - extraneous data at end of file %s", v5, *((_QWORD *)a2 + 2));
  }
  else
  {
    *(_QWORD *)v61 = &off_24C7F10D8;
    __src = 0;
    v63 = 0;
    v64 = 2.0;
    v65 = 257;
    v58 = &off_24C7F32C0;
    v59 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v55 = 0;
    v56 = 0;
    i = off_24C7F13C0;
    v57 = 0;
    if (*(_DWORD *)(a1 + 540))
    {
      v42 = "Index %d outside of range [0,%d]";
      if (!v44)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v11);
      LOBYTE(v48) = 35;
      (*(void (**)(size_t *__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v44 + 80))(&__n, v44, &v48);
      v13 = (char *)operator new[]();
      strcpy(v13, "\r\n\t ");
      v14 = v52;
      v15 = (char *)__s2;
      if ((_DWORD)v52)
      {
        v16 = 0;
        while (strchr(v13, v15[v16]))
        {
          if (v14 == ++v16)
          {
            v17 = v14;
            v18 = v14;
            v16 = v14;
            goto LABEL_28;
          }
        }
        v17 = v16;
        v18 = v14;
      }
      else
      {
        v17 = 0;
        v18 = 0;
        v16 = 0;
      }
LABEL_28:
      if (v16 >= v14)
        v19 = v14;
      else
        v19 = v16;
      do
      {
        if (v18 <= v17)
          goto LABEL_34;
        v20 = v18--;
      }
      while (strchr(v13, v15[v20 - 1]));
      v19 = v20;
LABEL_34:
      if (v16 <= v14)
      {
        if (v19 > v14)
        {
          v16 = v19;
        }
        else
        {
          if (v19 >= v16)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v15)
            {
              LODWORD(v67) = v19 - v16;
              v21 = (_WORD *)operator new[]();
              v68 = v21;
              memcpy(v21, &v15[v16], (v19 - v16));
              *((_BYTE *)v21 + (v19 - v16)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v58[8])((NString *)&v58, v21, (const unsigned int *)&v67);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v68)
                MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
              __n = (size_t)&off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v48 = &off_24C7F32C0;
              v49 = 2;
              v50 = (char *)operator new[]();
              strcpy(v50, "M=");
              v45 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v46 = strlen(__str);
                v47 = (void *)(*v45)((NString *)&v45, &v46);
                memcpy(v47, __str, v46 + 1);
                NString::operator+((uint64_t)&v48, (uint64_t)&v45, (uint64_t)&__n);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v22);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v12);
          }
          v42 = "Start and end indices conflict, start [%d], end [%d]";
          v14 = v19;
        }
      }
      Error::chuck((Error *)v42, v12, v16, v14);
    }
    LODWORD(__n) = 0;
    if (*(_DWORD *)(a1 + 256))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 8))(a1 + 248, *(_QWORD *)(a1 + 264));
      v23 = (**(uint64_t (***)(uint64_t, size_t *))(a1 + 248))(a1 + 248, &__n);
      *(_QWORD *)(a1 + 264) = v23;
      v24 = __n;
      *(_DWORD *)(a1 + 256) = __n;
      *(_BYTE *)(v23 + v24) = 0;
    }
    v25 = *(void **)(a1 + 264);
    if (!(_DWORD)v63)
    {
      if (!HIBYTE(v65))
        Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v11, 0, 0);
      if (HIDWORD(v63))
      {
        LODWORD(v63) = 1;
      }
      else
      {
        *(_DWORD *)__str = 1;
        (*(void (**)(BOOL *, char *, _QWORD))(*(_QWORD *)v61 + 48))(v61, __str, v64);
      }
    }
    memcpy(v25, __src, __n);
    *(_DWORD *)(a1 + 544) = __n;
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v5))
    {
      v5 = (const char *)v55;
      if (!v55)
        break;
      v55 = *(_QWORD *)(v55 + 8);
    }
    v58 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    *(_QWORD *)v61 = &off_24C7F3170;
    if (__src)
      MEMORY[0x212BAC9C0](__src, 0x1000C80BDFB0063);
  }
  if (!v44)
  {
    v41 = "NSmartPointer::checkptr() - pointer unset";
LABEL_97:
    Error::chuck((Error *)v41, v5);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v27 = *(unsigned __int16 **)(a1 + 264);
  v28 = *(unsigned int *)(a1 + 256);
  v29 = *(unsigned int *)(a1 + 288);
  v30 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v29 == v30)
  {
    v31 = *(_DWORD *)(a1 + 288);
    goto LABEL_69;
  }
  v32 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 288) = v30;
  *(_QWORD *)(a1 + 280) = operator new[]();
  v31 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v29 && v31)
  {
    v33 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v33) = *(_QWORD *)(v32 + 8 * v33);
      ++v33;
    }
    while (v33 < v29 && v33 < *(unsigned int *)(a1 + 540));
  }
  else if (!v32)
  {
    goto LABEL_69;
  }
  MEMORY[0x212BAC9C0](v32, 0x50C80EE9192B6);
  v31 = *(_DWORD *)(a1 + 540);
LABEL_69:
  v34 = (unint64_t)v27 + v28;
  if (v31)
  {
    v35 = 0;
    do
    {
      if ((unint64_t)v27 >= v34)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v26, *((_QWORD *)a2 + 2));
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v35) = v27;
      v36 = v27 + 1;
      v37 = *v27;
      if ((unint64_t)&v27[2 * *v27 + 1] > v34)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v26, *((_QWORD *)a2 + 2));
      if (*v27)
      {
        v38 = 0;
        do
        {
          if (*(_DWORD *)(a1 + 536) <= *v36)
            Error::chuck((Error *)"NFastFixedDistribution::read() - invalid gaussian index in M=%d, comp %d, in file %s", v26, v35, v38, *((_QWORD *)a2 + 2));
          v36 += 2;
          v38 = (v38 + 1);
        }
        while (v37 != (_DWORD)v38);
        v36 = &v27[2 * (v37 - 1) + 3];
      }
      ++v35;
      v27 = v36;
    }
    while (v35 < *(unsigned int *)(a1 + 540));
  }
  else
  {
    v36 = v27;
  }
  if (v36 != (unsigned __int16 *)v34)
    Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector under/overflows block in file %s", v26, *((_QWORD *)a2 + 2));
  v43 = &off_24C7F17F8;
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void sub_20D9D4D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t (**a38)(NString *__hidden this, const unsigned int *),uint64_t a39,uint64_t a40,uint64_t (**a41)(),uint64_t a42)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a34);
  a38 = &off_24C7F32C0;
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  a41 = &off_24C7F3170;
  if (a42)
    MEMORY[0x212BAC9C0](a42, 0x1000C80BDFB0063);
  if (a24)
    (*(void (**)(uint64_t))(*(_QWORD *)a24 + 8))(a24);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  _WORD *v36;
  int v37;
  unsigned __int16 *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  float v43;
  float v44;
  _QWORD v46[2];
  int v47;
  int v48;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v46[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v46[1] = v22;
  v47 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = *(_WORD **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v37 = (unsigned __int16)*v36;
  if (*v36)
  {
    v38 = v36 + 1;
    v39 = -1073741823;
    do
    {
      v40 = v39;
      v48 = *v38;
      v41 = NFastFixedGaussians<signed char,int,unsigned short>::score(a1 + 8, &v48, (uint64_t)v46, v23, v24, v25, v26, v27, v28, v29, v30)- v38[1];
      if (v41 <= v40)
        v39 = v40;
      else
        v39 = v41;
      if (v41 >= v40)
        v41 = v40;
      if (v41 != -1073741823)
      {
        v42 = v39 - v41;
        if (v42 <= *(_DWORD *)(a1 + 500))
          v39 += *(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v42 >> *(_DWORD *)(a1 + 496)));
      }
      v38 += 2;
      --v37;
    }
    while (v37);
    v43 = (float)v39;
  }
  else
  {
    v43 = -1073700000.0;
  }
  v44 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v44 * v43;
}

void sub_20D9D52F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _WORD *v5;
  int v6;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v5 = *(_WORD **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v6 = (unsigned __int16)*v5;
  if (*v5)
  {
    v9 = v5 + 2;
    v10 = 3221225473;
    do
    {
      v12 = *(v9 - 1);
      if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + v12))
      {
        v13 = (uint64_t)rintf(*(float *)(*(_QWORD *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10)
          v11 = v10;
        else
          v11 = v13;
        if (v13 >= (int)v10)
          v13 = v10;
        if (v13 != -1073741823)
        {
          v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500))
            v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
                               + v11);
        }
      }
      else
      {
        v11 = v10;
      }
      v9 += 2;
      v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::componentScore(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  int v36;
  float v37;
  _QWORD v39[2];
  int v40;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v39[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v39[1] = v22;
  v40 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = NFastFixedGaussians<signed char,int,unsigned short>::score(a1 + 8, a2, (uint64_t)v39, v23, v24, v25, v26, v27, v28, v29, v30);
  v37 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v37 * (float)v36;
}

void sub_20D9D5620(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  _WORD *v3;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v3 = *(_WORD **)(*(_QWORD *)(result + 280) + 8 * *a2);
  v4 = (unsigned __int16)*v3;
  if (*v3)
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      v12 = v4 - v7;
      do
      {
        v13 = *v5;
        v5 += 2;
        *(_BYTE *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    v7 = (unsigned __int16)v4 & 0xFFFE;
    v5 += 2 * v7;
    v8 = v3 + 3;
    v9 = v7;
    do
    {
      v10 = *(v8 - 2);
      v11 = *v8;
      v8 += 4;
      *(_BYTE *)(v6 + v10) = 1;
      *(_BYTE *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * *a2) + 2);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::posteriorWeightedMean() - not implemented", a2);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::baseGMM(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::baseGMM() - not implemented for fixed-point models", a2);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

_QWORD *NArray<unsigned short>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3170;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C80BDFB0063);
  return a1;
}

void NArray<unsigned short>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3170;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C80BDFB0063);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<unsigned short>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _WORD *v17;
  __int16 *v18;
  __int16 v19;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x1000C80BDFB0063);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v4;
      if (v4 < 0x10)
        goto LABEL_12;
      if ((unint64_t)(v9 - v8) < 0x20)
        goto LABEL_12;
      v7 = v4 & 0xFFFFFFF0;
      v11 = (_OWORD *)(v9 + 16);
      v12 = (__int128 *)(v8 + 16);
      v13 = v10 & 0xFFFFFFF0;
      do
      {
        v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 16;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        v15 = v10 - v7;
        v16 = 2 * v7;
        v17 = (_WORD *)(v9 + v16);
        v18 = (__int16 *)(v8 + v16);
        do
        {
          v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return a1;
}

uint64_t NArray<unsigned short>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _WORD *v19;
  __int16 *v20;
  __int16 v21;

  v4 = result;
  v5 = *(_DWORD *)(result + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C80BDFB0063);
      v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *(_DWORD *)(v4 + 16);
  }
  if (v5)
  {
    v9 = *(_QWORD *)(v4 + 8);
    v10 = v5;
    if (v5 < 0x10 || (unint64_t)(v9 - a2) <= 0x1F)
    {
      v12 = 0;
LABEL_14:
      v17 = v10 - v12;
      v18 = 2 * v12;
      v19 = (_WORD *)(v9 + v18);
      v20 = (__int16 *)(a2 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
      return result;
    }
    v12 = v5 & 0xFFFFFFF0;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(a2 + 16);
    v15 = v10 & 0xFFFFFFF0;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 16;
    }
    while (v15);
    if (v12 != v10)
      goto LABEL_14;
  }
  return result;
}

uint64_t NArray<unsigned short>::resize(uint64_t result, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;
  __int16 *v16;
  __int16 v17;

  v2 = *(_DWORD *)(result + 16);
  if (v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    LODWORD(v6) = *a2;
    if (v2 >= *a2)
      v6 = v6;
    else
      v6 = v2;
    if ((_DWORD)v6)
    {
      if (v6 >= 0x10 && (unint64_t)(result - v5) > 0x1F)
      {
        v8 = v6 & 0xFFFFFFF0;
        v9 = (_OWORD *)(result + 16);
        v10 = (__int128 *)(v5 + 16);
        v11 = v8;
        do
        {
          v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 16;
        }
        while (v11);
        if (v8 == v6)
LABEL_18:
          JUMPOUT(0x212BAC9C0);
      }
      else
      {
        v8 = 0;
      }
      v13 = v6 - v8;
      v14 = 2 * v8;
      v15 = (_WORD *)(result + 2 * v8);
      v16 = (__int16 *)(v5 + v14);
      do
      {
        v17 = *v16++;
        *v15++ = v17;
        --v13;
      }
      while (v13);
      goto LABEL_18;
    }
    if (v5)
      goto LABEL_18;
  }
  return result;
}

_QWORD *NAutoArray<unsigned short>::~NAutoArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F3170;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C80BDFB0063);
  return a1;
}

void NAutoArray<unsigned short>::~NAutoArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F3170;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C80BDFB0063);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NAutoArray<unsigned short>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _WORD *v18;
  __int16 *v19;
  __int16 v20;

  v6 = *(_DWORD *)(a2 + 16);
  v4 = a2 + 16;
  v5 = v6;
  v7 = *(_DWORD *)(a1 + 20);
  v8 = v6 >= v7;
  if (v6 <= v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    if (!v8)
      bzero((void *)(*(_QWORD *)(a1 + 8) + 2 * v5), 2 * (v7 + ~(_DWORD)v5) + 2);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, v4, (float)(*(float *)(a1 + 24) * (float)v5));
    LODWORD(v5) = *(_DWORD *)(a1 + 16);
  }
  if ((_DWORD)v5)
  {
    v9 = 0;
    v10 = *(_QWORD *)(a2 + 8);
    v11 = *(_QWORD *)(a1 + 8);
    if (v5 < 0x10)
      goto LABEL_11;
    if ((unint64_t)(v11 - v10) < 0x20)
      goto LABEL_11;
    v9 = v5 & 0xFFFFFFF0;
    v12 = (_OWORD *)(v11 + 16);
    v13 = (__int128 *)(v10 + 16);
    v14 = v9;
    do
    {
      v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 16;
    }
    while (v14);
    if (v9 != v5)
    {
LABEL_11:
      v16 = v5 - v9;
      v17 = 2 * v9;
      v18 = (_WORD *)(v11 + v17);
      v19 = (__int16 *)(v10 + v17);
      do
      {
        v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
    }
  }
  return a1;
}

uint64_t NAutoArray<unsigned short>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  _OWORD *v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _WORD *v18;
  __int16 *v19;
  __int16 v20;

  v4 = result;
  v5 = *a3;
  if (*(_DWORD *)(result + 20) < *a3)
  {
    v7 = *(_QWORD *)(result + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x1000C80BDFB0063);
      v5 = *a3;
    }
    *(_DWORD *)(v4 + 20) = v5;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    v5 = *a3;
  }
  *(_DWORD *)(v4 + 16) = v5;
  if (v5)
  {
    v8 = *(_QWORD *)(v4 + 8);
    v9 = v5;
    if (v5 < 0x10 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      v11 = 0;
LABEL_14:
      v16 = v9 - v11;
      v17 = 2 * v11;
      v18 = (_WORD *)(v8 + v17);
      v19 = (__int16 *)(a2 + v17);
      do
      {
        v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
      return result;
    }
    v11 = v5 & 0xFFFFFFF0;
    v12 = (_OWORD *)(v8 + 16);
    v13 = (__int128 *)(a2 + 16);
    v14 = v9 & 0xFFFFFFF0;
    do
    {
      v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 16;
    }
    while (v14);
    if (v11 != v9)
      goto LABEL_14;
  }
  return result;
}

uint64_t NAutoArray<unsigned short>::operator=(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

uint64_t NAutoArray<unsigned short>::resize(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _WORD *v18;
  __int16 *v19;
  __int16 v20;

  v5 = *a2;
  if (*a2 <= a3)
    v6 = a3;
  else
    v6 = *a2;
  if (v6)
  {
    v7 = operator new[]();
    v5 = *a2;
  }
  else
  {
    v7 = 0;
  }
  v8 = *(_DWORD *)(a1 + 16);
  if (v5 < v8)
  {
    *(_DWORD *)(a1 + 16) = v5;
    v8 = v5;
  }
  result = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v10 = 0;
    v11 = v8;
    if (v8 < 0x10)
      goto LABEL_15;
    if ((unint64_t)(v7 - result) < 0x20)
      goto LABEL_15;
    v10 = v8 & 0xFFFFFFF0;
    v12 = (_OWORD *)(v7 + 16);
    v13 = (__int128 *)(result + 16);
    v14 = v11 & 0xFFFFFFF0;
    do
    {
      v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 16;
    }
    while (v14);
    if (v10 != v11)
    {
LABEL_15:
      v16 = v11 - v10;
      v17 = 2 * v10;
      v18 = (_WORD *)(v7 + 2 * v10);
      v19 = (__int16 *)(result + v17);
      do
      {
        v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
    }
    goto LABEL_19;
  }
  if (result)
LABEL_19:
    result = MEMORY[0x212BAC9C0]();
  *(_QWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = v6;
  return result;
}

_QWORD *NFastFixedDistribution<short,int,unsigned int,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F26C8;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F40;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return a1;
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F26C8;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F40;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::read(uint64_t a1, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  int v11;
  const char *v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  _DWORD *v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _DWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t result;
  const char *v41;
  char *v42;
  uint64_t (**v43)();
  uint64_t v44;
  uint64_t (**v45)(NString *, const unsigned int *);
  unsigned int v46;
  void *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  char *v50;
  size_t __n;
  size_t v52;
  void *__s2;
  uint64_t (**i)();
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  int v59;
  void *__s1;
  BOOL v61[8];
  void *__src;
  uint64_t v63;
  float v64;
  __int16 v65;
  char __str[8];
  uint64_t v67;
  _WORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 1;
  v68 = (_WORD *)operator new[]();
  *v68 = 114;
  v43 = (uint64_t (**)())&off_24C7F33E0;
  v44 = 0;
  NFilePtr::open((NFilePtr *)&v43, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v68)
    MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 0;
  v4 = (_BYTE *)operator new[]();
  v68 = v4;
  *v4 = 0;
  v61[0] = 0;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)(a1 + 296), a2, (NFilePtr *)&v43, (const NString *)__str, v61);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (*(_BYTE *)(a1 + 328) != 16
    || *(_BYTE *)(a1 + 329) != 16
    || *(_BYTE *)(a1 + 330) != 32
    || *(_BYTE *)(a1 + 331) != 32
    || *(_BYTE *)(a1 + 332) != 32
    || *(_BYTE *)(a1 + 333) != 32)
  {
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)(a1 + 296), (uint64_t)__str);
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header encoding (%s) does not match class  encoding (%d-%d-%d).", v41, v68, 16, 32, 32);
  }
  if (*(_BYTE *)(a1 + 549))
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header usesd spec (%d) does not match class  encoding (%d).", v5, 1, 1);
  NFastFixedGaussians<short,int,unsigned char>::read(a1 + 8, (uint64_t)a2, (uint64_t)&v43, a1 + 336, (int *)(a1 + 536), (_BYTE *)(a1 + 548));
  if (*(_BYTE *)(a1 + 548))
  {
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, a1 + 544, a1 + 248);
    v9 = *(unsigned int *)(a1 + 544);
    if ((_DWORD)v7 != (_DWORD)v9)
      Error::chuck((Error *)"NFastFixedDistribution::read() - not enough weight data in file %s (%d out of %d bytes)", v8, *((_QWORD *)a2 + 2), v7, v9);
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    *(_DWORD *)v61 = 2;
    (*(void (**)(char *__return_ptr, uint64_t, BOOL *))(*(_QWORD *)v44 + 64))(__str, v44, v61);
    v11 = v67;
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v68)
      MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
    if (v11)
      Error::chuck((Error *)"NFastFixedDistribution::read() - extraneous data at end of file %s", v10, *((_QWORD *)a2 + 2));
  }
  else
  {
    *(_QWORD *)v61 = &off_24C7F1090;
    __src = 0;
    v63 = 0;
    v64 = 2.0;
    v65 = 257;
    v58 = &off_24C7F32C0;
    v59 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v55 = 0;
    v56 = 0;
    i = off_24C7F13C0;
    v57 = 0;
    if (*(_DWORD *)(a1 + 540))
    {
      v42 = "Index %d outside of range [0,%d]";
      if (!v44)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
      LOBYTE(v48) = 35;
      (*(void (**)(size_t *__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v44 + 80))(&__n, v44, &v48);
      v14 = (char *)operator new[]();
      strcpy(v14, "\r\n\t ");
      v15 = v52;
      v16 = (char *)__s2;
      if ((_DWORD)v52)
      {
        v17 = 0;
        while (strchr(v14, v16[v17]))
        {
          if (v15 == ++v17)
          {
            v18 = v15;
            v19 = v15;
            v17 = v15;
            goto LABEL_27;
          }
        }
        v18 = v17;
        v19 = v15;
      }
      else
      {
        v18 = 0;
        v19 = 0;
        v17 = 0;
      }
LABEL_27:
      if (v17 >= v15)
        v20 = v15;
      else
        v20 = v17;
      do
      {
        if (v19 <= v18)
          goto LABEL_33;
        v21 = v19--;
      }
      while (strchr(v14, v16[v21 - 1]));
      v20 = v21;
LABEL_33:
      if (v17 <= v15)
      {
        if (v20 > v15)
        {
          v17 = v20;
        }
        else
        {
          if (v20 >= v17)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v16)
            {
              LODWORD(v67) = v20 - v17;
              v22 = (_WORD *)operator new[]();
              v68 = v22;
              memcpy(v22, &v16[v17], (v20 - v17));
              *((_BYTE *)v22 + (v20 - v17)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v58[8])((NString *)&v58, v22, (const unsigned int *)&v67);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v68)
                MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
              __n = (size_t)&off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v48 = &off_24C7F32C0;
              v49 = 2;
              v50 = (char *)operator new[]();
              strcpy(v50, "M=");
              v45 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v46 = strlen(__str);
                v47 = (void *)(*v45)((NString *)&v45, &v46);
                memcpy(v47, __str, v46 + 1);
                NString::operator+((uint64_t)&v48, (uint64_t)&v45, (uint64_t)&__n);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v23);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v13);
          }
          v42 = "Start and end indices conflict, start [%d], end [%d]";
          v15 = v20;
        }
      }
      Error::chuck((Error *)v42, v13, v17, v15);
    }
    LODWORD(__n) = 0;
    if (*(_DWORD *)(a1 + 256))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 8))(a1 + 248, *(_QWORD *)(a1 + 264));
      v24 = (**(uint64_t (***)(uint64_t, size_t *))(a1 + 248))(a1 + 248, &__n);
      *(_QWORD *)(a1 + 264) = v24;
      v25 = __n;
      *(_DWORD *)(a1 + 256) = __n;
      *(_BYTE *)(v24 + v25) = 0;
    }
    v26 = *(void **)(a1 + 264);
    if (!(_DWORD)v63)
    {
      if (!HIBYTE(v65))
        Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v12, 0, 0);
      if (HIDWORD(v63))
      {
        LODWORD(v63) = 1;
      }
      else
      {
        *(_DWORD *)__str = 1;
        (*(void (**)(BOOL *, char *, _QWORD))(*(_QWORD *)v61 + 48))(v61, __str, v64);
      }
    }
    memcpy(v26, __src, __n);
    *(_DWORD *)(a1 + 544) = __n;
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v10))
    {
      v10 = (const char *)v55;
      if (!v55)
        break;
      v55 = *(_QWORD *)(v55 + 8);
    }
    v58 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    *(_QWORD *)v61 = &off_24C7F3100;
    if (__src)
      MEMORY[0x212BAC9C0](__src, 0x1000C8052888210);
  }
  if (!v44)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v10);
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v28 = *(_DWORD **)(a1 + 264);
  v29 = *(unsigned int *)(a1 + 256);
  v30 = *(unsigned int *)(a1 + 288);
  v31 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v30 == v31)
  {
    v32 = *(_DWORD *)(a1 + 288);
    goto LABEL_68;
  }
  v33 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 288) = v31;
  *(_QWORD *)(a1 + 280) = operator new[]();
  v32 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v30 && v32)
  {
    v34 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v34) = *(_QWORD *)(v33 + 8 * v34);
      ++v34;
    }
    while (v34 < v30 && v34 < *(unsigned int *)(a1 + 540));
  }
  else if (!v33)
  {
    goto LABEL_68;
  }
  MEMORY[0x212BAC9C0](v33, 0x50C80EE9192B6);
  v32 = *(_DWORD *)(a1 + 540);
LABEL_68:
  v35 = (unint64_t)v28 + v29;
  if (v32)
  {
    v36 = 0;
    do
    {
      if ((unint64_t)v28 >= v35)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v27, *((_QWORD *)a2 + 2));
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v36) = v28;
      v37 = v28 + 1;
      v38 = *v28;
      if ((unint64_t)&v28[2 * *v28 + 1] > v35)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v27, *((_QWORD *)a2 + 2));
      if (v38)
      {
        v39 = 0;
        do
        {
          if (*v37 >= *(_DWORD *)(a1 + 536))
            Error::chuck((Error *)"NFastFixedDistribution::read() - invalid gaussian index in M=%d, comp %d, in file %s", v27, v36, v39, *((_QWORD *)a2 + 2));
          v37 += 2;
          v39 = (v39 + 1);
        }
        while (v38 != (_DWORD)v39);
        v37 = &v28[2 * (v38 - 1) + 3];
      }
      ++v36;
      v28 = v37;
    }
    while (v36 < *(unsigned int *)(a1 + 540));
  }
  else
  {
    v37 = v28;
  }
  if (v37 != (_DWORD *)v35)
    Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector under/overflows block in file %s", v27, *((_QWORD *)a2 + 2));
  v43 = &off_24C7F17F8;
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void sub_20D9D73F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t (**a38)(NString *__hidden this, const unsigned int *),uint64_t a39,uint64_t a40,uint64_t (**a41)(),uint64_t a42)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a34);
  a38 = &off_24C7F32C0;
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  a41 = &off_24C7F3100;
  if (a42)
    MEMORY[0x212BAC9C0](a42, 0x1000C8052888210);
  if (a24)
    (*(void (**)(uint64_t))(*(_QWORD *)a24 + 8))(a24);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<short,int,unsigned int,unsigned char>::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  int *v32;
  int v33;
  int v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  __int16 *v42;
  int32x4_t *v43;
  uint64_t v44;
  int16x8_t v45;
  int32x4_t v46;
  const __int16 *v47;
  int32x4_t *v48;
  int16x8_t *v49;
  uint64_t v50;
  int32x4_t v51;
  int32x4_t v52;
  const __int16 *v53;
  int16x8_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  uint32x4_t v59;
  uint32x4_t v60;
  uint32x4_t v61;
  int32x4_t v62;
  uint64_t v63;
  __int32 *v64;
  __int16 *v65;
  int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  float v72;
  float v73;
  int16x8x2_t v75;
  int16x8x2_t v76;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v22 = operator new[]();
  if ((_DWORD)v8)
  {
    v25 = 0;
    v26 = *(_QWORD *)(v7 + 104);
    do
    {
      v28 = *(float *)(v10 + 4 * v25);
      v29 = *(float *)(v26 + 4 * v25);
      if (v28 > v29)
      {
        v27 = v29 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v25);
      }
      else
      {
        v30 = -v29;
        v31 = *(float *)(*(_QWORD *)(v7 + 56) + 4 * v25);
        if (v28 >= v30)
          v27 = v28 * v31;
        else
          v27 = v31 * v30;
      }
      *(_WORD *)(v22 + 2 * v25++) = (uint64_t)rintf(v27);
    }
    while (v8 != v25);
  }
  v32 = *(int **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v33 = *v32;
  if (!*v32)
  {
    v72 = -1073700000.0;
    goto LABEL_40;
  }
  v34 = 0;
  v35 = v32 + 1;
  v36 = *(_QWORD *)(a1 + 32);
  v37 = *(unsigned int *)(a1 + 224);
  v38 = *(_DWORD *)(a1 + 172);
  v23 = 3221225473;
  v24 = 1;
  v39 = -1073741823;
  do
  {
    v40 = (*(_DWORD *)(a1 + 240) * *v35);
    v41 = *(_DWORD *)(v36 + v40);
    if ((_DWORD)v37)
    {
      v42 = (__int16 *)(v36 + v40 + 4);
      v43 = *(int32x4_t **)(a1 + 216);
      if (v37 >= 0x10)
      {
        v45 = 0uLL;
        v46 = (int32x4_t)*(unsigned int *)(v36 + v40);
        v47 = (const __int16 *)(v36 + 36 + v40);
        v48 = v43 + 2;
        v49 = (int16x8_t *)(v22 + 16);
        v50 = v37 & 0xFFFFFFF0;
        v51 = 0uLL;
        v52 = 0uLL;
        do
        {
          v53 = v47 - 16;
          v54 = v49[-1];
          v75 = vld2q_s16(v53);
          v76 = vld2q_s16(v47);
          v55 = vsubl_high_s16(v54, v75.val[0]);
          v56 = vsubl_s16(*(int16x4_t *)v54.i8, *(int16x4_t *)v75.val[0].i8);
          v57 = vsubl_high_s16(*v49, v76.val[0]);
          v58 = vsubl_s16(*(int16x4_t *)v49->i8, *(int16x4_t *)v76.val[0].i8);
          v59 = vmull_high_u16((uint16x8_t)vuzp1q_s16(v45, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v55, v55), 0xFuLL)), (uint16x8_t)v75.val[1]);
          v60 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v56, v56), 0xFuLL), *(uint16x4_t *)v75.val[1].i8);
          v75.val[0] = (int16x8_t)vmull_high_u16((uint16x8_t)vuzp1q_s16(v45, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v57, v57), 0xFuLL)), (uint16x8_t)v76.val[1]);
          v61 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v58, v58), 0xFuLL), *(uint16x4_t *)v76.val[1].i8);
          v76.val[0] = (int16x8_t)v48[-2];
          v75.val[1] = (int16x8_t)v48[-1];
          v62 = *v48;
          v76.val[1] = (int16x8_t)v48[1];
          v48 += 4;
          v45 = (int16x8_t)vaddq_s32((int32x4_t)vshlq_u32(v59, (uint32x4_t)vnegq_s32((int32x4_t)v75.val[1])), (int32x4_t)v45);
          v46 = vaddq_s32((int32x4_t)vshlq_u32(v60, (uint32x4_t)vnegq_s32((int32x4_t)v76.val[0])), v46);
          v52 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v75.val[0], (uint32x4_t)vnegq_s32((int32x4_t)v76.val[1])), v52);
          v51 = vaddq_s32((int32x4_t)vshlq_u32(v61, (uint32x4_t)vnegq_s32(v62)), v51);
          v47 += 32;
          v49 += 2;
          v50 -= 16;
        }
        while (v50);
        v41 = vaddvq_s32(vaddq_s32(vaddq_s32(v51, v46), vaddq_s32(v52, (int32x4_t)v45)));
        if ((v37 & 0xFFFFFFF0) == v37)
          goto LABEL_30;
        v42 += 2 * (v37 & 0xFFFFFFF0);
        v44 = v37 & 0xFFFFFFF0;
      }
      else
      {
        v44 = 0;
      }
      v63 = v37 - v44;
      v64 = &v43->i32[v44];
      v65 = (__int16 *)(v22 + 2 * v44);
      do
      {
        v66 = *v65++;
        v67 = (((v66 - *v42) * (v66 - *v42)) >> 15) * (unsigned __int16)v42[1];
        v68 = *v64++;
        v41 += v67 >> v68;
        v42 += 2;
        --v63;
      }
      while (v63);
    }
LABEL_30:
    v69 = ((1 - (v41 >> v38)) >> 1) - v35[1];
    if (v69 <= v39)
      v70 = v39;
    else
      v70 = ((1 - (v41 >> v38)) >> 1) - v35[1];
    if (v69 < v39)
      v39 = ((1 - (v41 >> v38)) >> 1) - v35[1];
    if (v39 == -1073741823)
    {
      v39 = v70;
    }
    else
    {
      v71 = v70 - v39;
      v39 = v70;
      if (v71 <= *(_DWORD *)(a1 + 500))
        v39 = *(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v71 >> *(_DWORD *)(a1 + 496))) + v70;
    }
    v35 += 2;
    ++v34;
  }
  while (v34 != v33);
  v72 = (float)v39;
LABEL_40:
  v73 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v22, 0x1000C80BDFB0063, v23, v24);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v73 * v72;
}

void sub_20D9D7AD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<short,int,unsigned int,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int *v5;
  int v6;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v5 = *(int **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v6 = *v5;
  if (*v5)
  {
    v9 = v5 + 2;
    v10 = 3221225473;
    do
    {
      v12 = *(v9 - 1);
      if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + v12))
      {
        v13 = (uint64_t)rintf(*(float *)(*(_QWORD *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10)
          v11 = v10;
        else
          v11 = v13;
        if (v13 >= (int)v10)
          v13 = v10;
        if (v13 != -1073741823)
        {
          v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500))
            v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
                               + v11);
        }
      }
      else
      {
        v11 = v10;
      }
      v9 += 2;
      v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

float NFastFixedDistribution<short,int,unsigned int,unsigned char>::componentScore(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  __int16 *v34;
  int32x4_t *v35;
  uint64_t v36;
  int16x8_t v37;
  int32x4_t v38;
  const __int16 *v39;
  int32x4_t *v40;
  int16x8_t *v41;
  uint64_t v42;
  int32x4_t v43;
  int32x4_t v44;
  const __int16 *v45;
  int16x8_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  uint32x4_t v51;
  uint32x4_t v52;
  uint32x4_t v53;
  int32x4_t v54;
  uint64_t v55;
  __int32 *v56;
  __int16 *v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  float v62;
  int16x8x2_t v64;
  int16x8x2_t v65;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v22 = operator new[]();
  if ((_DWORD)v8)
  {
    v23 = 0;
    v24 = *(_QWORD *)(v7 + 104);
    do
    {
      v26 = *(float *)(v10 + 4 * v23);
      v27 = *(float *)(v24 + 4 * v23);
      if (v26 > v27)
      {
        v25 = v27 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v23);
      }
      else
      {
        v28 = -v27;
        v29 = *(float *)(*(_QWORD *)(v7 + 56) + 4 * v23);
        if (v26 >= v28)
          v25 = v26 * v29;
        else
          v25 = v29 * v28;
      }
      *(_WORD *)(v22 + 2 * v23++) = (uint64_t)rintf(v25);
    }
    while (v8 != v23);
  }
  v30 = *(_QWORD *)(a1 + 32);
  v31 = (*(_DWORD *)(a1 + 240) * *a2);
  v32 = *(unsigned int *)(a1 + 224);
  v33 = *(_DWORD *)(v30 + v31);
  if ((_DWORD)v32)
  {
    v34 = (__int16 *)(v30 + v31 + 4);
    v35 = *(int32x4_t **)(a1 + 216);
    if (v32 < 0x10)
    {
      v36 = 0;
      goto LABEL_24;
    }
    v36 = v32 & 0xFFFFFFF0;
    v37 = 0uLL;
    v38 = (int32x4_t)*(unsigned int *)(v30 + v31);
    v39 = (const __int16 *)(v31 + v30 + 36);
    v40 = v35 + 2;
    v41 = (int16x8_t *)(v22 + 16);
    v42 = v36;
    v43 = 0uLL;
    v44 = 0uLL;
    do
    {
      v45 = v39 - 16;
      v46 = v41[-1];
      v64 = vld2q_s16(v45);
      v65 = vld2q_s16(v39);
      v47 = vsubl_high_s16(v46, v64.val[0]);
      v48 = vsubl_s16(*(int16x4_t *)v46.i8, *(int16x4_t *)v64.val[0].i8);
      v49 = vsubl_high_s16(*v41, v65.val[0]);
      v50 = vsubl_s16(*(int16x4_t *)v41->i8, *(int16x4_t *)v65.val[0].i8);
      v51 = vmull_high_u16((uint16x8_t)vuzp1q_s16(v37, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v47, v47), 0xFuLL)), (uint16x8_t)v64.val[1]);
      v52 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v48, v48), 0xFuLL), *(uint16x4_t *)v64.val[1].i8);
      v64.val[0] = (int16x8_t)vmull_high_u16((uint16x8_t)vuzp1q_s16(v37, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v49, v49), 0xFuLL)), (uint16x8_t)v65.val[1]);
      v53 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v50, v50), 0xFuLL), *(uint16x4_t *)v65.val[1].i8);
      v65.val[0] = (int16x8_t)v40[-2];
      v64.val[1] = (int16x8_t)v40[-1];
      v54 = *v40;
      v65.val[1] = (int16x8_t)v40[1];
      v40 += 4;
      v37 = (int16x8_t)vaddq_s32((int32x4_t)vshlq_u32(v51, (uint32x4_t)vnegq_s32((int32x4_t)v64.val[1])), (int32x4_t)v37);
      v38 = vaddq_s32((int32x4_t)vshlq_u32(v52, (uint32x4_t)vnegq_s32((int32x4_t)v65.val[0])), v38);
      v44 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v64.val[0], (uint32x4_t)vnegq_s32((int32x4_t)v65.val[1])), v44);
      v43 = vaddq_s32((int32x4_t)vshlq_u32(v53, (uint32x4_t)vnegq_s32(v54)), v43);
      v39 += 32;
      v41 += 2;
      v42 -= 16;
    }
    while (v42);
    v33 = vaddvq_s32(vaddq_s32(vaddq_s32(v43, v38), vaddq_s32(v44, (int32x4_t)v37)));
    if (v36 != v32)
    {
      v34 += 2 * (v32 & 0xFFFFFFF0);
LABEL_24:
      v55 = v32 - v36;
      v56 = &v35->i32[v36];
      v57 = (__int16 *)(v22 + 2 * v36);
      do
      {
        v58 = *v57++;
        v59 = (((v58 - *v34) * (v58 - *v34)) >> 15) * (unsigned __int16)v34[1];
        v60 = *v56++;
        v33 += v59 >> v60;
        v34 += 2;
        --v55;
      }
      while (v55);
    }
  }
  v61 = *(_DWORD *)(a1 + 172);
  v62 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v22, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v62 * (float)((1 - (v33 >> v61)) >> 1);
}

void sub_20D9D7F44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v3 = *(unsigned int **)(*(_QWORD *)(result + 280) + 8 * *a2);
  v4 = *v3;
  if ((_DWORD)v4)
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      v12 = v4 - v7;
      do
      {
        v13 = *v5;
        v5 += 2;
        *(_BYTE *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    v7 = v4 & 0xFFFFFFFE;
    v5 += 2 * v7;
    v8 = v3 + 3;
    v9 = v7;
    do
    {
      v10 = *(v8 - 2);
      v11 = *v8;
      v8 += 4;
      *(_BYTE *)(v6 + v10) = 1;
      *(_BYTE *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * *a2) + 4);
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::posteriorWeightedMean() - not implemented", a2);
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::baseGMM() - not implemented for fixed-point models", a2);
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void *NFastFixedGaussians<short,int,unsigned char>::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _BYTE *a6)
{
  const char *v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  void *result;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  uint64_t (**v36)(NString *, const unsigned int *);
  unsigned int v37;
  void *v38;
  uint64_t (**v39)(NString *__hidden, const unsigned int *);
  int v40;
  char *v41;
  uint64_t (**v42)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**i)();
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t (**v49)(NString *__hidden, const unsigned int *);
  int v50;
  void *__s1;
  unsigned int v52;
  char __str[8];
  uint64_t v54;
  void *v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  NGaussianFixedPointScales::operator=(a1 + 32, a4);
  v13 = *a5;
  v14 = 4 * *(_DWORD *)(a4 + 184) + 8;
  *(_DWORD *)(a1 + 232) = v14;
  *(_DWORD *)(a1 + 236) = v13;
  v15 = *a5 * v14;
  v52 = v15;
  if (*a6)
  {
    v16 = *(_QWORD *)(a3 + 8);
    if (!v16)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
    result = (void *)(*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)v16 + 72))(v16, &v52, a1);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16);
    if ((_DWORD)result != v52)
      Error::chuck((Error *)"NFastFixedGaussians::read() - not enough gaussian data in file %s (%d out of %d bytes)", v18, *(_QWORD *)(a2 + 16), result, v52);
  }
  else
  {
    v49 = &off_24C7F32C0;
    v50 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v46 = 0;
    v47 = 0;
    i = off_24C7F13C0;
    v48 = 0;
    if (v15 != *(_DWORD *)(a1 + 8))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 8))(a1, *(_QWORD *)(a1 + 16));
      v19 = (**(uint64_t (***)(uint64_t, unsigned int *))a1)(a1, &v52);
      *(_QWORD *)(a1 + 16) = v19;
      v20 = v52;
      *(_DWORD *)(a1 + 8) = v52;
      *(_BYTE *)(v19 + v20) = 0;
      v15 = v52;
    }
    v35 = *(void **)(a1 + 16);
    *(_QWORD *)(a1 + 24) = v35;
    bzero(v35, v15);
    if (*a5)
    {
      v22 = *(_QWORD *)(a3 + 8);
      if (!v22)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v21);
      LOBYTE(v39) = 35;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v22 + 80))(&v42, v22, &v39);
      v24 = (char *)operator new[]();
      strcpy(v24, "\r\n\t ");
      v25 = __n;
      v26 = (char *)__s2;
      if ((_DWORD)__n)
      {
        v27 = 0;
        while (strchr(v24, v26[v27]))
        {
          if (v25 == ++v27)
          {
            v28 = v25;
            v29 = v25;
            v27 = v25;
            goto LABEL_16;
          }
        }
        v28 = v27;
        v29 = v25;
      }
      else
      {
        v28 = 0;
        v29 = 0;
        v27 = 0;
      }
LABEL_16:
      if (v27 >= v25)
        v30 = v25;
      else
        v30 = v27;
      do
      {
        if (v29 <= v28)
          goto LABEL_22;
        v31 = v29--;
      }
      while (strchr(v24, v26[v31 - 1]));
      v30 = v31;
LABEL_22:
      if (v27 <= v25)
      {
        if (v30 <= v25)
        {
          if (v30 >= v27)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v26)
            {
              LODWORD(v54) = v30 - v27;
              v32 = (void *)operator new[]();
              v55 = v32;
              memcpy(v32, &v26[v27], (v30 - v27));
              *((_BYTE *)v32 + (v30 - v27)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v49[8])((NString *)&v49, v32, (const unsigned int *)&v54);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v55)
                MEMORY[0x212BAC9C0](v55, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
              v42 = &off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v39 = &off_24C7F32C0;
              v40 = 2;
              v41 = (char *)operator new[]();
              strcpy(v41, "G=");
              v36 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v37 = strlen(__str);
                v38 = (void *)(*v36)((NString *)&v36, &v37);
                memcpy(v38, __str, v37 + 1);
                NString::operator+((uint64_t)&v39, (uint64_t)&v36, (uint64_t)&v42);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v33);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v23);
          }
          Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v23, v27, v30);
        }
        v27 = v30;
      }
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v23, v27, v25);
    }
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, v34))
    {
      v34 = v46;
      if (!v46)
        break;
      v46 = *(_QWORD *)(v46 + 8);
    }
    v49 = &off_24C7F32C0;
    result = __s1;
    if (__s1)
      return (void *)MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
  }
  return result;
}

void sub_20D9D8D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a33);
  if (!a39)
    _Unwind_Resume(a1);
  MEMORY[0x212BAC9C0](a39, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_QWORD *NFastFixedDistribution<short,int,unsigned short,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2780;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F78;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return a1;
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2780;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F78;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::read(uint64_t a1, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _WORD *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  const char *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned __int16 *v36;
  int v37;
  uint64_t v38;
  uint64_t result;
  const char *v40;
  char *v41;
  char *v42;
  uint64_t (**v43)();
  uint64_t v44;
  uint64_t (**v45)(NString *, const unsigned int *);
  unsigned int v46;
  void *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  char *v50;
  size_t __n;
  size_t v52;
  void *__s2;
  uint64_t (**i)();
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  int v59;
  void *__s1;
  BOOL v61[8];
  void *__src;
  uint64_t v63;
  float v64;
  __int16 v65;
  char __str[8];
  uint64_t v67;
  _WORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 1;
  v68 = (_WORD *)operator new[]();
  *v68 = 114;
  v43 = (uint64_t (**)())&off_24C7F33E0;
  v44 = 0;
  NFilePtr::open((NFilePtr *)&v43, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v68)
    MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 0;
  v4 = (_BYTE *)operator new[]();
  v68 = v4;
  *v4 = 0;
  v61[0] = 0;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)(a1 + 296), a2, (NFilePtr *)&v43, (const NString *)__str, v61);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (*(_BYTE *)(a1 + 328) != 16
    || *(_BYTE *)(a1 + 329) != 16
    || *(_BYTE *)(a1 + 330) != 32
    || *(_BYTE *)(a1 + 331) != 16
    || *(_BYTE *)(a1 + 332) != 16
    || *(_BYTE *)(a1 + 333) != 16)
  {
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)(a1 + 296), (uint64_t)__str);
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header encoding (%s) does not match class  encoding (%d-%d-%d).", v40, v68, 16, 32, 16);
  }
  if (*(_BYTE *)(a1 + 549))
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header usesd spec (%d) does not match class  encoding (%d).", v5, 1, 1);
  if (*(_DWORD *)(a1 + 536) > 0x10000u)
  {
    v41 = "NFastFixedDistribution::read() - more gaussians that index range provided by this format";
    goto LABEL_97;
  }
  NFastFixedGaussians<short,int,unsigned char>::read(a1 + 8, (uint64_t)a2, (uint64_t)&v43, a1 + 336, (int *)(a1 + 536), (_BYTE *)(a1 + 548));
  if (*(_BYTE *)(a1 + 548))
  {
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, a1 + 544, a1 + 248);
    v9 = *(unsigned int *)(a1 + 544);
    if ((_DWORD)v7 != (_DWORD)v9)
      Error::chuck((Error *)"NFastFixedDistribution::read() - not enough weight data in file %s (%d out of %d bytes)", v8, *((_QWORD *)a2 + 2), v7, v9);
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    *(_DWORD *)v61 = 2;
    (*(void (**)(char *__return_ptr, uint64_t, BOOL *))(*(_QWORD *)v44 + 64))(__str, v44, v61);
    v10 = v67;
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v68)
      MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
    if (v10)
      Error::chuck((Error *)"NFastFixedDistribution::read() - extraneous data at end of file %s", v5, *((_QWORD *)a2 + 2));
  }
  else
  {
    *(_QWORD *)v61 = &off_24C7F10D8;
    __src = 0;
    v63 = 0;
    v64 = 2.0;
    v65 = 257;
    v58 = &off_24C7F32C0;
    v59 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v55 = 0;
    v56 = 0;
    i = off_24C7F13C0;
    v57 = 0;
    if (*(_DWORD *)(a1 + 540))
    {
      v42 = "Index %d outside of range [0,%d]";
      if (!v44)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v11);
      LOBYTE(v48) = 35;
      (*(void (**)(size_t *__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v44 + 80))(&__n, v44, &v48);
      v13 = (char *)operator new[]();
      strcpy(v13, "\r\n\t ");
      v14 = v52;
      v15 = (char *)__s2;
      if ((_DWORD)v52)
      {
        v16 = 0;
        while (strchr(v13, v15[v16]))
        {
          if (v14 == ++v16)
          {
            v17 = v14;
            v18 = v14;
            v16 = v14;
            goto LABEL_28;
          }
        }
        v17 = v16;
        v18 = v14;
      }
      else
      {
        v17 = 0;
        v18 = 0;
        v16 = 0;
      }
LABEL_28:
      if (v16 >= v14)
        v19 = v14;
      else
        v19 = v16;
      do
      {
        if (v18 <= v17)
          goto LABEL_34;
        v20 = v18--;
      }
      while (strchr(v13, v15[v20 - 1]));
      v19 = v20;
LABEL_34:
      if (v16 <= v14)
      {
        if (v19 > v14)
        {
          v16 = v19;
        }
        else
        {
          if (v19 >= v16)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v15)
            {
              LODWORD(v67) = v19 - v16;
              v21 = (_WORD *)operator new[]();
              v68 = v21;
              memcpy(v21, &v15[v16], (v19 - v16));
              *((_BYTE *)v21 + (v19 - v16)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v58[8])((NString *)&v58, v21, (const unsigned int *)&v67);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v68)
                MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
              __n = (size_t)&off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v48 = &off_24C7F32C0;
              v49 = 2;
              v50 = (char *)operator new[]();
              strcpy(v50, "M=");
              v45 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v46 = strlen(__str);
                v47 = (void *)(*v45)((NString *)&v45, &v46);
                memcpy(v47, __str, v46 + 1);
                NString::operator+((uint64_t)&v48, (uint64_t)&v45, (uint64_t)&__n);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v22);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v12);
          }
          v42 = "Start and end indices conflict, start [%d], end [%d]";
          v14 = v19;
        }
      }
      Error::chuck((Error *)v42, v12, v16, v14);
    }
    LODWORD(__n) = 0;
    if (*(_DWORD *)(a1 + 256))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 8))(a1 + 248, *(_QWORD *)(a1 + 264));
      v23 = (**(uint64_t (***)(uint64_t, size_t *))(a1 + 248))(a1 + 248, &__n);
      *(_QWORD *)(a1 + 264) = v23;
      v24 = __n;
      *(_DWORD *)(a1 + 256) = __n;
      *(_BYTE *)(v23 + v24) = 0;
    }
    v25 = *(void **)(a1 + 264);
    if (!(_DWORD)v63)
    {
      if (!HIBYTE(v65))
        Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v11, 0, 0);
      if (HIDWORD(v63))
      {
        LODWORD(v63) = 1;
      }
      else
      {
        *(_DWORD *)__str = 1;
        (*(void (**)(BOOL *, char *, _QWORD))(*(_QWORD *)v61 + 48))(v61, __str, v64);
      }
    }
    memcpy(v25, __src, __n);
    *(_DWORD *)(a1 + 544) = __n;
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v5))
    {
      v5 = (const char *)v55;
      if (!v55)
        break;
      v55 = *(_QWORD *)(v55 + 8);
    }
    v58 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    *(_QWORD *)v61 = &off_24C7F3170;
    if (__src)
      MEMORY[0x212BAC9C0](__src, 0x1000C80BDFB0063);
  }
  if (!v44)
  {
    v41 = "NSmartPointer::checkptr() - pointer unset";
LABEL_97:
    Error::chuck((Error *)v41, v5);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v27 = *(unsigned __int16 **)(a1 + 264);
  v28 = *(unsigned int *)(a1 + 256);
  v29 = *(unsigned int *)(a1 + 288);
  v30 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v29 == v30)
  {
    v31 = *(_DWORD *)(a1 + 288);
    goto LABEL_69;
  }
  v32 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 288) = v30;
  *(_QWORD *)(a1 + 280) = operator new[]();
  v31 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v29 && v31)
  {
    v33 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v33) = *(_QWORD *)(v32 + 8 * v33);
      ++v33;
    }
    while (v33 < v29 && v33 < *(unsigned int *)(a1 + 540));
  }
  else if (!v32)
  {
    goto LABEL_69;
  }
  MEMORY[0x212BAC9C0](v32, 0x50C80EE9192B6);
  v31 = *(_DWORD *)(a1 + 540);
LABEL_69:
  v34 = (unint64_t)v27 + v28;
  if (v31)
  {
    v35 = 0;
    do
    {
      if ((unint64_t)v27 >= v34)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v26, *((_QWORD *)a2 + 2));
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v35) = v27;
      v36 = v27 + 1;
      v37 = *v27;
      if ((unint64_t)&v27[2 * *v27 + 1] > v34)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v26, *((_QWORD *)a2 + 2));
      if (*v27)
      {
        v38 = 0;
        do
        {
          if (*(_DWORD *)(a1 + 536) <= *v36)
            Error::chuck((Error *)"NFastFixedDistribution::read() - invalid gaussian index in M=%d, comp %d, in file %s", v26, v35, v38, *((_QWORD *)a2 + 2));
          v36 += 2;
          v38 = (v38 + 1);
        }
        while (v37 != (_DWORD)v38);
        v36 = &v27[2 * (v37 - 1) + 3];
      }
      ++v35;
      v27 = v36;
    }
    while (v35 < *(unsigned int *)(a1 + 540));
  }
  else
  {
    v36 = v27;
  }
  if (v36 != (unsigned __int16 *)v34)
    Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector under/overflows block in file %s", v26, *((_QWORD *)a2 + 2));
  v43 = &off_24C7F17F8;
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void sub_20D9DA494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t (**a38)(NString *__hidden this, const unsigned int *),uint64_t a39,uint64_t a40,uint64_t (**a41)(),uint64_t a42)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a34);
  a38 = &off_24C7F32C0;
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  a41 = &off_24C7F3170;
  if (a42)
    MEMORY[0x212BAC9C0](a42, 0x1000C80BDFB0063);
  if (a24)
    (*(void (**)(uint64_t))(*(_QWORD *)a24 + 8))(a24);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<short,int,unsigned short,unsigned char>::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  _WORD *v32;
  int v33;
  int v34;
  unsigned __int16 *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  __int16 *v42;
  int32x4_t *v43;
  uint64_t v44;
  int16x8_t v45;
  int32x4_t v46;
  const __int16 *v47;
  int32x4_t *v48;
  int16x8_t *v49;
  uint64_t v50;
  int32x4_t v51;
  int32x4_t v52;
  const __int16 *v53;
  int16x8_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  uint32x4_t v59;
  uint32x4_t v60;
  uint32x4_t v61;
  int32x4_t v62;
  uint64_t v63;
  __int32 *v64;
  __int16 *v65;
  int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  float v72;
  float v73;
  int16x8x2_t v75;
  int16x8x2_t v76;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v22 = operator new[]();
  if ((_DWORD)v8)
  {
    v25 = 0;
    v26 = *(_QWORD *)(v7 + 104);
    do
    {
      v28 = *(float *)(v10 + 4 * v25);
      v29 = *(float *)(v26 + 4 * v25);
      if (v28 > v29)
      {
        v27 = v29 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v25);
      }
      else
      {
        v30 = -v29;
        v31 = *(float *)(*(_QWORD *)(v7 + 56) + 4 * v25);
        if (v28 >= v30)
          v27 = v28 * v31;
        else
          v27 = v31 * v30;
      }
      *(_WORD *)(v22 + 2 * v25++) = (uint64_t)rintf(v27);
    }
    while (v8 != v25);
  }
  v32 = *(_WORD **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v33 = (unsigned __int16)*v32;
  if (!*v32)
  {
    v72 = -1073700000.0;
    goto LABEL_40;
  }
  v34 = 0;
  v35 = v32 + 1;
  v36 = *(_QWORD *)(a1 + 32);
  v37 = *(unsigned int *)(a1 + 224);
  v38 = *(_DWORD *)(a1 + 172);
  v23 = 3221225473;
  v24 = 1;
  v39 = -1073741823;
  do
  {
    v40 = *(_DWORD *)(a1 + 240) * *v35;
    v41 = *(_DWORD *)(v36 + v40);
    if ((_DWORD)v37)
    {
      v42 = (__int16 *)(v36 + v40 + 4);
      v43 = *(int32x4_t **)(a1 + 216);
      if (v37 >= 0x10)
      {
        v45 = 0uLL;
        v46 = (int32x4_t)*(unsigned int *)(v36 + v40);
        v47 = (const __int16 *)(v36 + 36 + v40);
        v48 = v43 + 2;
        v49 = (int16x8_t *)(v22 + 16);
        v50 = v37 & 0xFFFFFFF0;
        v51 = 0uLL;
        v52 = 0uLL;
        do
        {
          v53 = v47 - 16;
          v54 = v49[-1];
          v75 = vld2q_s16(v53);
          v76 = vld2q_s16(v47);
          v55 = vsubl_high_s16(v54, v75.val[0]);
          v56 = vsubl_s16(*(int16x4_t *)v54.i8, *(int16x4_t *)v75.val[0].i8);
          v57 = vsubl_high_s16(*v49, v76.val[0]);
          v58 = vsubl_s16(*(int16x4_t *)v49->i8, *(int16x4_t *)v76.val[0].i8);
          v59 = vmull_high_u16((uint16x8_t)vuzp1q_s16(v45, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v55, v55), 0xFuLL)), (uint16x8_t)v75.val[1]);
          v60 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v56, v56), 0xFuLL), *(uint16x4_t *)v75.val[1].i8);
          v75.val[0] = (int16x8_t)vmull_high_u16((uint16x8_t)vuzp1q_s16(v45, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v57, v57), 0xFuLL)), (uint16x8_t)v76.val[1]);
          v61 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v58, v58), 0xFuLL), *(uint16x4_t *)v76.val[1].i8);
          v76.val[0] = (int16x8_t)v48[-2];
          v75.val[1] = (int16x8_t)v48[-1];
          v62 = *v48;
          v76.val[1] = (int16x8_t)v48[1];
          v48 += 4;
          v45 = (int16x8_t)vaddq_s32((int32x4_t)vshlq_u32(v59, (uint32x4_t)vnegq_s32((int32x4_t)v75.val[1])), (int32x4_t)v45);
          v46 = vaddq_s32((int32x4_t)vshlq_u32(v60, (uint32x4_t)vnegq_s32((int32x4_t)v76.val[0])), v46);
          v52 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v75.val[0], (uint32x4_t)vnegq_s32((int32x4_t)v76.val[1])), v52);
          v51 = vaddq_s32((int32x4_t)vshlq_u32(v61, (uint32x4_t)vnegq_s32(v62)), v51);
          v47 += 32;
          v49 += 2;
          v50 -= 16;
        }
        while (v50);
        v41 = vaddvq_s32(vaddq_s32(vaddq_s32(v51, v46), vaddq_s32(v52, (int32x4_t)v45)));
        if ((v37 & 0xFFFFFFF0) == v37)
          goto LABEL_30;
        v42 += 2 * (v37 & 0xFFFFFFF0);
        v44 = v37 & 0xFFFFFFF0;
      }
      else
      {
        v44 = 0;
      }
      v63 = v37 - v44;
      v64 = &v43->i32[v44];
      v65 = (__int16 *)(v22 + 2 * v44);
      do
      {
        v66 = *v65++;
        v67 = (((v66 - *v42) * (v66 - *v42)) >> 15) * (unsigned __int16)v42[1];
        v68 = *v64++;
        v41 += v67 >> v68;
        v42 += 2;
        --v63;
      }
      while (v63);
    }
LABEL_30:
    v69 = ((1 - (v41 >> v38)) >> 1) - v35[1];
    if (v69 <= v39)
      v70 = v39;
    else
      v70 = ((1 - (v41 >> v38)) >> 1) - v35[1];
    if (v69 < v39)
      v39 = ((1 - (v41 >> v38)) >> 1) - v35[1];
    if (v39 == -1073741823)
    {
      v39 = v70;
    }
    else
    {
      v71 = v70 - v39;
      v39 = v70;
      if (v71 <= *(_DWORD *)(a1 + 500))
        v39 = *(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v71 >> *(_DWORD *)(a1 + 496))) + v70;
    }
    v35 += 2;
    ++v34;
  }
  while (v34 != v33);
  v72 = (float)v39;
LABEL_40:
  v73 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v22, 0x1000C80BDFB0063, v23, v24);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v73 * v72;
}

void sub_20D9DAB44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<short,int,unsigned short,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _WORD *v5;
  int v6;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v5 = *(_WORD **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v6 = (unsigned __int16)*v5;
  if (*v5)
  {
    v9 = v5 + 2;
    v10 = 3221225473;
    do
    {
      v12 = *(v9 - 1);
      if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + v12))
      {
        v13 = (uint64_t)rintf(*(float *)(*(_QWORD *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10)
          v11 = v10;
        else
          v11 = v13;
        if (v13 >= (int)v10)
          v13 = v10;
        if (v13 != -1073741823)
        {
          v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500))
            v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
                               + v11);
        }
      }
      else
      {
        v11 = v10;
      }
      v9 += 2;
      v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

float NFastFixedDistribution<short,int,unsigned short,unsigned char>::componentScore(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  __int16 *v34;
  int32x4_t *v35;
  uint64_t v36;
  int16x8_t v37;
  int32x4_t v38;
  const __int16 *v39;
  int32x4_t *v40;
  int16x8_t *v41;
  uint64_t v42;
  int32x4_t v43;
  int32x4_t v44;
  const __int16 *v45;
  int16x8_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  uint32x4_t v51;
  uint32x4_t v52;
  uint32x4_t v53;
  int32x4_t v54;
  uint64_t v55;
  __int32 *v56;
  __int16 *v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  float v62;
  int16x8x2_t v64;
  int16x8x2_t v65;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v22 = operator new[]();
  if ((_DWORD)v8)
  {
    v23 = 0;
    v24 = *(_QWORD *)(v7 + 104);
    do
    {
      v26 = *(float *)(v10 + 4 * v23);
      v27 = *(float *)(v24 + 4 * v23);
      if (v26 > v27)
      {
        v25 = v27 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v23);
      }
      else
      {
        v28 = -v27;
        v29 = *(float *)(*(_QWORD *)(v7 + 56) + 4 * v23);
        if (v26 >= v28)
          v25 = v26 * v29;
        else
          v25 = v29 * v28;
      }
      *(_WORD *)(v22 + 2 * v23++) = (uint64_t)rintf(v25);
    }
    while (v8 != v23);
  }
  v30 = *(_QWORD *)(a1 + 32);
  v31 = (*(_DWORD *)(a1 + 240) * *a2);
  v32 = *(unsigned int *)(a1 + 224);
  v33 = *(_DWORD *)(v30 + v31);
  if ((_DWORD)v32)
  {
    v34 = (__int16 *)(v30 + v31 + 4);
    v35 = *(int32x4_t **)(a1 + 216);
    if (v32 < 0x10)
    {
      v36 = 0;
      goto LABEL_24;
    }
    v36 = v32 & 0xFFFFFFF0;
    v37 = 0uLL;
    v38 = (int32x4_t)*(unsigned int *)(v30 + v31);
    v39 = (const __int16 *)(v31 + v30 + 36);
    v40 = v35 + 2;
    v41 = (int16x8_t *)(v22 + 16);
    v42 = v36;
    v43 = 0uLL;
    v44 = 0uLL;
    do
    {
      v45 = v39 - 16;
      v46 = v41[-1];
      v64 = vld2q_s16(v45);
      v65 = vld2q_s16(v39);
      v47 = vsubl_high_s16(v46, v64.val[0]);
      v48 = vsubl_s16(*(int16x4_t *)v46.i8, *(int16x4_t *)v64.val[0].i8);
      v49 = vsubl_high_s16(*v41, v65.val[0]);
      v50 = vsubl_s16(*(int16x4_t *)v41->i8, *(int16x4_t *)v65.val[0].i8);
      v51 = vmull_high_u16((uint16x8_t)vuzp1q_s16(v37, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v47, v47), 0xFuLL)), (uint16x8_t)v64.val[1]);
      v52 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v48, v48), 0xFuLL), *(uint16x4_t *)v64.val[1].i8);
      v64.val[0] = (int16x8_t)vmull_high_u16((uint16x8_t)vuzp1q_s16(v37, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v49, v49), 0xFuLL)), (uint16x8_t)v65.val[1]);
      v53 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v50, v50), 0xFuLL), *(uint16x4_t *)v65.val[1].i8);
      v65.val[0] = (int16x8_t)v40[-2];
      v64.val[1] = (int16x8_t)v40[-1];
      v54 = *v40;
      v65.val[1] = (int16x8_t)v40[1];
      v40 += 4;
      v37 = (int16x8_t)vaddq_s32((int32x4_t)vshlq_u32(v51, (uint32x4_t)vnegq_s32((int32x4_t)v64.val[1])), (int32x4_t)v37);
      v38 = vaddq_s32((int32x4_t)vshlq_u32(v52, (uint32x4_t)vnegq_s32((int32x4_t)v65.val[0])), v38);
      v44 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v64.val[0], (uint32x4_t)vnegq_s32((int32x4_t)v65.val[1])), v44);
      v43 = vaddq_s32((int32x4_t)vshlq_u32(v53, (uint32x4_t)vnegq_s32(v54)), v43);
      v39 += 32;
      v41 += 2;
      v42 -= 16;
    }
    while (v42);
    v33 = vaddvq_s32(vaddq_s32(vaddq_s32(v43, v38), vaddq_s32(v44, (int32x4_t)v37)));
    if (v36 != v32)
    {
      v34 += 2 * (v32 & 0xFFFFFFF0);
LABEL_24:
      v55 = v32 - v36;
      v56 = &v35->i32[v36];
      v57 = (__int16 *)(v22 + 2 * v36);
      do
      {
        v58 = *v57++;
        v59 = (((v58 - *v34) * (v58 - *v34)) >> 15) * (unsigned __int16)v34[1];
        v60 = *v56++;
        v33 += v59 >> v60;
        v34 += 2;
        --v55;
      }
      while (v55);
    }
  }
  v61 = *(_DWORD *)(a1 + 172);
  v62 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v22, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v62 * (float)((1 - (v33 >> v61)) >> 1);
}

void sub_20D9DAFB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  _WORD *v3;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v3 = *(_WORD **)(*(_QWORD *)(result + 280) + 8 * *a2);
  v4 = (unsigned __int16)*v3;
  if (*v3)
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      v12 = v4 - v7;
      do
      {
        v13 = *v5;
        v5 += 2;
        *(_BYTE *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    v7 = (unsigned __int16)v4 & 0xFFFE;
    v5 += 2 * v7;
    v8 = v3 + 3;
    v9 = v7;
    do
    {
      v10 = *(v8 - 2);
      v11 = *v8;
      v8 += 4;
      *(_BYTE *)(v6 + v10) = 1;
      *(_BYTE *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * *a2) + 2);
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::posteriorWeightedMean() - not implemented", a2);
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::baseGMM() - not implemented for fixed-point models", a2);
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

_QWORD *NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F23E8;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F40;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return a1;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F23E8;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F40;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::read(uint64_t a1, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  int v11;
  const char *v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  _DWORD *v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _DWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t result;
  const char *v41;
  char *v42;
  uint64_t (**v43)();
  uint64_t v44;
  uint64_t (**v45)(NString *, const unsigned int *);
  unsigned int v46;
  void *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  char *v50;
  size_t __n;
  size_t v52;
  void *__s2;
  uint64_t (**i)();
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  int v59;
  void *__s1;
  BOOL v61[8];
  void *__src;
  uint64_t v63;
  float v64;
  __int16 v65;
  char __str[8];
  uint64_t v67;
  _WORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 1;
  v68 = (_WORD *)operator new[]();
  *v68 = 114;
  v43 = (uint64_t (**)())&off_24C7F33E0;
  v44 = 0;
  NFilePtr::open((NFilePtr *)&v43, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v68)
    MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 0;
  v4 = (_BYTE *)operator new[]();
  v68 = v4;
  *v4 = 0;
  v61[0] = 0;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)(a1 + 296), a2, (NFilePtr *)&v43, (const NString *)__str, v61);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (*(_BYTE *)(a1 + 328) != 8
    || *(_BYTE *)(a1 + 329) != 8
    || *(_BYTE *)(a1 + 330) != 32
    || *(_BYTE *)(a1 + 331) != 32
    || *(_BYTE *)(a1 + 332) != 32
    || *(_BYTE *)(a1 + 333) != 32)
  {
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)(a1 + 296), (uint64_t)__str);
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header encoding (%s) does not match class  encoding (%d-%d-%d).", v41, v68, 8, 32, 32);
  }
  if (*(_BYTE *)(a1 + 549))
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header usesd spec (%d) does not match class  encoding (%d).", v5, 1, 1);
  NFastFixedGaussians<signed char,int,unsigned char>::read(a1 + 8, (uint64_t)a2, (uint64_t)&v43, a1 + 336, (int *)(a1 + 536), (_BYTE *)(a1 + 548));
  if (*(_BYTE *)(a1 + 548))
  {
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, a1 + 544, a1 + 248);
    v9 = *(unsigned int *)(a1 + 544);
    if ((_DWORD)v7 != (_DWORD)v9)
      Error::chuck((Error *)"NFastFixedDistribution::read() - not enough weight data in file %s (%d out of %d bytes)", v8, *((_QWORD *)a2 + 2), v7, v9);
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    *(_DWORD *)v61 = 2;
    (*(void (**)(char *__return_ptr, uint64_t, BOOL *))(*(_QWORD *)v44 + 64))(__str, v44, v61);
    v11 = v67;
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v68)
      MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
    if (v11)
      Error::chuck((Error *)"NFastFixedDistribution::read() - extraneous data at end of file %s", v10, *((_QWORD *)a2 + 2));
  }
  else
  {
    *(_QWORD *)v61 = &off_24C7F1090;
    __src = 0;
    v63 = 0;
    v64 = 2.0;
    v65 = 257;
    v58 = &off_24C7F32C0;
    v59 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v55 = 0;
    v56 = 0;
    i = off_24C7F13C0;
    v57 = 0;
    if (*(_DWORD *)(a1 + 540))
    {
      v42 = "Index %d outside of range [0,%d]";
      if (!v44)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
      LOBYTE(v48) = 35;
      (*(void (**)(size_t *__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v44 + 80))(&__n, v44, &v48);
      v14 = (char *)operator new[]();
      strcpy(v14, "\r\n\t ");
      v15 = v52;
      v16 = (char *)__s2;
      if ((_DWORD)v52)
      {
        v17 = 0;
        while (strchr(v14, v16[v17]))
        {
          if (v15 == ++v17)
          {
            v18 = v15;
            v19 = v15;
            v17 = v15;
            goto LABEL_27;
          }
        }
        v18 = v17;
        v19 = v15;
      }
      else
      {
        v18 = 0;
        v19 = 0;
        v17 = 0;
      }
LABEL_27:
      if (v17 >= v15)
        v20 = v15;
      else
        v20 = v17;
      do
      {
        if (v19 <= v18)
          goto LABEL_33;
        v21 = v19--;
      }
      while (strchr(v14, v16[v21 - 1]));
      v20 = v21;
LABEL_33:
      if (v17 <= v15)
      {
        if (v20 > v15)
        {
          v17 = v20;
        }
        else
        {
          if (v20 >= v17)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v16)
            {
              LODWORD(v67) = v20 - v17;
              v22 = (_WORD *)operator new[]();
              v68 = v22;
              memcpy(v22, &v16[v17], (v20 - v17));
              *((_BYTE *)v22 + (v20 - v17)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v58[8])((NString *)&v58, v22, (const unsigned int *)&v67);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v68)
                MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
              __n = (size_t)&off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v48 = &off_24C7F32C0;
              v49 = 2;
              v50 = (char *)operator new[]();
              strcpy(v50, "M=");
              v45 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v46 = strlen(__str);
                v47 = (void *)(*v45)((NString *)&v45, &v46);
                memcpy(v47, __str, v46 + 1);
                NString::operator+((uint64_t)&v48, (uint64_t)&v45, (uint64_t)&__n);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v23);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v13);
          }
          v42 = "Start and end indices conflict, start [%d], end [%d]";
          v15 = v20;
        }
      }
      Error::chuck((Error *)v42, v13, v17, v15);
    }
    LODWORD(__n) = 0;
    if (*(_DWORD *)(a1 + 256))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 8))(a1 + 248, *(_QWORD *)(a1 + 264));
      v24 = (**(uint64_t (***)(uint64_t, size_t *))(a1 + 248))(a1 + 248, &__n);
      *(_QWORD *)(a1 + 264) = v24;
      v25 = __n;
      *(_DWORD *)(a1 + 256) = __n;
      *(_BYTE *)(v24 + v25) = 0;
    }
    v26 = *(void **)(a1 + 264);
    if (!(_DWORD)v63)
    {
      if (!HIBYTE(v65))
        Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v12, 0, 0);
      if (HIDWORD(v63))
      {
        LODWORD(v63) = 1;
      }
      else
      {
        *(_DWORD *)__str = 1;
        (*(void (**)(BOOL *, char *, _QWORD))(*(_QWORD *)v61 + 48))(v61, __str, v64);
      }
    }
    memcpy(v26, __src, __n);
    *(_DWORD *)(a1 + 544) = __n;
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v10))
    {
      v10 = (const char *)v55;
      if (!v55)
        break;
      v55 = *(_QWORD *)(v55 + 8);
    }
    v58 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    *(_QWORD *)v61 = &off_24C7F3100;
    if (__src)
      MEMORY[0x212BAC9C0](__src, 0x1000C8052888210);
  }
  if (!v44)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v10);
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v28 = *(_DWORD **)(a1 + 264);
  v29 = *(unsigned int *)(a1 + 256);
  v30 = *(unsigned int *)(a1 + 288);
  v31 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v30 == v31)
  {
    v32 = *(_DWORD *)(a1 + 288);
    goto LABEL_68;
  }
  v33 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 288) = v31;
  *(_QWORD *)(a1 + 280) = operator new[]();
  v32 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v30 && v32)
  {
    v34 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v34) = *(_QWORD *)(v33 + 8 * v34);
      ++v34;
    }
    while (v34 < v30 && v34 < *(unsigned int *)(a1 + 540));
  }
  else if (!v33)
  {
    goto LABEL_68;
  }
  MEMORY[0x212BAC9C0](v33, 0x50C80EE9192B6);
  v32 = *(_DWORD *)(a1 + 540);
LABEL_68:
  v35 = (unint64_t)v28 + v29;
  if (v32)
  {
    v36 = 0;
    do
    {
      if ((unint64_t)v28 >= v35)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v27, *((_QWORD *)a2 + 2));
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v36) = v28;
      v37 = v28 + 1;
      v38 = *v28;
      if ((unint64_t)&v28[2 * *v28 + 1] > v35)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v27, *((_QWORD *)a2 + 2));
      if (v38)
      {
        v39 = 0;
        do
        {
          if (*v37 >= *(_DWORD *)(a1 + 536))
            Error::chuck((Error *)"NFastFixedDistribution::read() - invalid gaussian index in M=%d, comp %d, in file %s", v27, v36, v39, *((_QWORD *)a2 + 2));
          v37 += 2;
          v39 = (v39 + 1);
        }
        while (v38 != (_DWORD)v39);
        v37 = &v28[2 * (v38 - 1) + 3];
      }
      ++v36;
      v28 = v37;
    }
    while (v36 < *(unsigned int *)(a1 + 540));
  }
  else
  {
    v37 = v28;
  }
  if (v37 != (_DWORD *)v35)
    Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector under/overflows block in file %s", v27, *((_QWORD *)a2 + 2));
  v43 = &off_24C7F17F8;
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void sub_20D9DC648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t (**a38)(NString *__hidden this, const unsigned int *),uint64_t a39,uint64_t a40,uint64_t (**a41)(),uint64_t a42)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a34);
  a38 = &off_24C7F32C0;
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  a41 = &off_24C7F3100;
  if (a42)
    MEMORY[0x212BAC9C0](a42, 0x1000C8052888210);
  if (a24)
    (*(void (**)(uint64_t))(*(_QWORD *)a24 + 8))(a24);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  int *v36;
  int v37;
  int *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  float v43;
  float v44;
  _QWORD v46[2];
  int v47;
  int v48;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v46[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v46[1] = v22;
  v47 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = *(int **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v37 = *v36;
  if (*v36)
  {
    v38 = v36 + 1;
    v39 = -1073741823;
    do
    {
      v40 = v39;
      v48 = *v38;
      v41 = NFastFixedGaussians<signed char,int,unsigned char>::score(a1 + 8, &v48, (uint64_t)v46, v23, v24, v25, v26, v27, v28, v29, v30)- v38[1];
      if (v41 <= v40)
        v39 = v40;
      else
        v39 = v41;
      if (v41 >= v40)
        v41 = v40;
      if (v41 != -1073741823)
      {
        v42 = v39 - v41;
        if (v42 <= *(_DWORD *)(a1 + 500))
          v39 += *(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v42 >> *(_DWORD *)(a1 + 496)));
      }
      v38 += 2;
      --v37;
    }
    while (v37);
    v43 = (float)v39;
  }
  else
  {
    v43 = -1073700000.0;
  }
  v44 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v44 * v43;
}

void sub_20D9DCBE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int *v5;
  int v6;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v5 = *(int **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v6 = *v5;
  if (*v5)
  {
    v9 = v5 + 2;
    v10 = 3221225473;
    do
    {
      v12 = *(v9 - 1);
      if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + v12))
      {
        v13 = (uint64_t)rintf(*(float *)(*(_QWORD *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10)
          v11 = v10;
        else
          v11 = v13;
        if (v13 >= (int)v10)
          v13 = v10;
        if (v13 != -1073741823)
        {
          v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500))
            v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
                               + v11);
        }
      }
      else
      {
        v11 = v10;
      }
      v9 += 2;
      v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::componentScore(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  int v36;
  float v37;
  _QWORD v39[2];
  int v40;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v39[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v39[1] = v22;
  v40 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = NFastFixedGaussians<signed char,int,unsigned char>::score(a1 + 8, a2, (uint64_t)v39, v23, v24, v25, v26, v27, v28, v29, v30);
  v37 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v37 * (float)v36;
}

void sub_20D9DCF08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v3 = *(unsigned int **)(*(_QWORD *)(result + 280) + 8 * *a2);
  v4 = *v3;
  if ((_DWORD)v4)
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      v12 = v4 - v7;
      do
      {
        v13 = *v5;
        v5 += 2;
        *(_BYTE *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    v7 = v4 & 0xFFFFFFFE;
    v5 += 2 * v7;
    v8 = v3 + 3;
    v9 = v7;
    do
    {
      v10 = *(v8 - 2);
      v11 = *v8;
      v8 += 4;
      *(_BYTE *)(v6 + v10) = 1;
      *(_BYTE *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * *a2) + 4);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::posteriorWeightedMean() - not implemented", a2);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::baseGMM() - not implemented for fixed-point models", a2);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void *NFastFixedGaussians<signed char,int,unsigned char>::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _BYTE *a6)
{
  const char *v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  void *result;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  uint64_t (**v36)(NString *, const unsigned int *);
  unsigned int v37;
  void *v38;
  uint64_t (**v39)(NString *__hidden, const unsigned int *);
  int v40;
  char *v41;
  uint64_t (**v42)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**i)();
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t (**v49)(NString *__hidden, const unsigned int *);
  int v50;
  void *__s1;
  unsigned int v52;
  char __str[8];
  uint64_t v54;
  void *v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  NGaussianFixedPointScales::operator=(a1 + 32, a4);
  v13 = *a5;
  v14 = 2 * *(_DWORD *)(a4 + 184) + ((-2 * *(_DWORD *)(a4 + 184)) & 2) + 8;
  *(_DWORD *)(a1 + 232) = v14;
  *(_DWORD *)(a1 + 236) = v13;
  v15 = *a5 * v14;
  v52 = v15;
  if (*a6)
  {
    v16 = *(_QWORD *)(a3 + 8);
    if (!v16)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
    result = (void *)(*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(_QWORD *)v16 + 72))(v16, &v52, a1);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16);
    if ((_DWORD)result != v52)
      Error::chuck((Error *)"NFastFixedGaussians::read() - not enough gaussian data in file %s (%d out of %d bytes)", v18, *(_QWORD *)(a2 + 16), result, v52);
  }
  else
  {
    v49 = &off_24C7F32C0;
    v50 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v46 = 0;
    v47 = 0;
    i = off_24C7F13C0;
    v48 = 0;
    if (v15 != *(_DWORD *)(a1 + 8))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 8))(a1, *(_QWORD *)(a1 + 16));
      v19 = (**(uint64_t (***)(uint64_t, unsigned int *))a1)(a1, &v52);
      *(_QWORD *)(a1 + 16) = v19;
      v20 = v52;
      *(_DWORD *)(a1 + 8) = v52;
      *(_BYTE *)(v19 + v20) = 0;
      v15 = v52;
    }
    v35 = *(void **)(a1 + 16);
    *(_QWORD *)(a1 + 24) = v35;
    bzero(v35, v15);
    if (*a5)
    {
      v22 = *(_QWORD *)(a3 + 8);
      if (!v22)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v21);
      LOBYTE(v39) = 35;
      (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v22 + 80))(&v42, v22, &v39);
      v24 = (char *)operator new[]();
      strcpy(v24, "\r\n\t ");
      v25 = __n;
      v26 = (char *)__s2;
      if ((_DWORD)__n)
      {
        v27 = 0;
        while (strchr(v24, v26[v27]))
        {
          if (v25 == ++v27)
          {
            v28 = v25;
            v29 = v25;
            v27 = v25;
            goto LABEL_16;
          }
        }
        v28 = v27;
        v29 = v25;
      }
      else
      {
        v28 = 0;
        v29 = 0;
        v27 = 0;
      }
LABEL_16:
      if (v27 >= v25)
        v30 = v25;
      else
        v30 = v27;
      do
      {
        if (v29 <= v28)
          goto LABEL_22;
        v31 = v29--;
      }
      while (strchr(v24, v26[v31 - 1]));
      v30 = v31;
LABEL_22:
      if (v27 <= v25)
      {
        if (v30 <= v25)
        {
          if (v30 >= v27)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v26)
            {
              LODWORD(v54) = v30 - v27;
              v32 = (void *)operator new[]();
              v55 = v32;
              memcpy(v32, &v26[v27], (v30 - v27));
              *((_BYTE *)v32 + (v30 - v27)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v49[8])((NString *)&v49, v32, (const unsigned int *)&v54);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v55)
                MEMORY[0x212BAC9C0](v55, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
              v42 = &off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v39 = &off_24C7F32C0;
              v40 = 2;
              v41 = (char *)operator new[]();
              strcpy(v41, "G=");
              v36 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v37 = strlen(__str);
                v38 = (void *)(*v36)((NString *)&v36, &v37);
                memcpy(v38, __str, v37 + 1);
                NString::operator+((uint64_t)&v39, (uint64_t)&v36, (uint64_t)&v42);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v33);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v23);
          }
          Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v23, v27, v30);
        }
        v27 = v30;
      }
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v23, v27, v25);
    }
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, v34))
    {
      v34 = v46;
      if (!v46)
        break;
      v46 = *(_QWORD *)(v46 + 8);
    }
    v49 = &off_24C7F32C0;
    result = __s1;
    if (__s1)
      return (void *)MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
  }
  return result;
}

void sub_20D9DDCAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a33);
  if (!a39)
    _Unwind_Resume(a1);
  MEMORY[0x212BAC9C0](a39, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_QWORD *NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2558;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F78;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return a1;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::~NFastFixedDistribution(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &off_24C7F2558;
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 42));
  a1[38] = &off_24C7F32C0;
  v2 = a1[40];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  a1[34] = &off_24C7F2F78;
  v3 = a1[35];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x50C80EE9192B6);
  a1[31] = &off_24C7F32C0;
  v4 = a1[33];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NGaussianFixedPointScales::~NGaussianFixedPointScales((NGaussianFixedPointScales *)(a1 + 5));
  a1[1] = &off_24C7F32C0;
  v5 = a1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::read(uint64_t a1, const NString *a2)
{
  _BYTE *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _WORD *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  const char *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned __int16 *v36;
  int v37;
  uint64_t v38;
  uint64_t result;
  const char *v40;
  char *v41;
  char *v42;
  uint64_t (**v43)();
  uint64_t v44;
  uint64_t (**v45)(NString *, const unsigned int *);
  unsigned int v46;
  void *v47;
  uint64_t (**v48)(NString *__hidden, const unsigned int *);
  int v49;
  char *v50;
  size_t __n;
  size_t v52;
  void *__s2;
  uint64_t (**i)();
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t (**v58)(NString *__hidden, const unsigned int *);
  int v59;
  void *__s1;
  BOOL v61[8];
  void *__src;
  uint64_t v63;
  float v64;
  __int16 v65;
  char __str[8];
  uint64_t v67;
  _WORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 1;
  v68 = (_WORD *)operator new[]();
  *v68 = 114;
  v43 = (uint64_t (**)())&off_24C7F33E0;
  v44 = 0;
  NFilePtr::open((NFilePtr *)&v43, a2, (const NString *)__str);
  *(_QWORD *)__str = &off_24C7F32C0;
  if (v68)
    MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
  *(_QWORD *)__str = &off_24C7F32C0;
  LODWORD(v67) = 0;
  v4 = (_BYTE *)operator new[]();
  v68 = v4;
  *v4 = 0;
  v61[0] = 0;
  NChunkGaussianMixtureModelsHeader::read((NChunkGaussianMixtureModelsHeader *)(a1 + 296), a2, (NFilePtr *)&v43, (const NString *)__str, v61);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  if (*(_BYTE *)(a1 + 328) != 8
    || *(_BYTE *)(a1 + 329) != 8
    || *(_BYTE *)(a1 + 330) != 32
    || *(_BYTE *)(a1 + 331) != 16
    || *(_BYTE *)(a1 + 332) != 16
    || *(_BYTE *)(a1 + 333) != 16)
  {
    NChunkGaussianMixtureModelsHeader::encodingString((NChunkGaussianMixtureModelsHeader *)(a1 + 296), (uint64_t)__str);
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header encoding (%s) does not match class  encoding (%d-%d-%d).", v40, v68, 8, 32, 16);
  }
  if (*(_BYTE *)(a1 + 549))
    Error::chuck((Error *)"NFastFixedDistribution::read() - internal error, header usesd spec (%d) does not match class  encoding (%d).", v5, 1, 1);
  if (*(_DWORD *)(a1 + 536) > 0x10000u)
  {
    v41 = "NFastFixedDistribution::read() - more gaussians that index range provided by this format";
    goto LABEL_97;
  }
  NFastFixedGaussians<signed char,int,unsigned char>::read(a1 + 8, (uint64_t)a2, (uint64_t)&v43, a1 + 336, (int *)(a1 + 536), (_BYTE *)(a1 + 548));
  if (*(_BYTE *)(a1 + 548))
  {
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v6);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, a1 + 544, a1 + 248);
    v9 = *(unsigned int *)(a1 + 544);
    if ((_DWORD)v7 != (_DWORD)v9)
      Error::chuck((Error *)"NFastFixedDistribution::read() - not enough weight data in file %s (%d out of %d bytes)", v8, *((_QWORD *)a2 + 2), v7, v9);
    if (!v44)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
    *(_DWORD *)v61 = 2;
    (*(void (**)(char *__return_ptr, uint64_t, BOOL *))(*(_QWORD *)v44 + 64))(__str, v44, v61);
    v10 = v67;
    *(_QWORD *)__str = &off_24C7F32C0;
    if (v68)
      MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
    if (v10)
      Error::chuck((Error *)"NFastFixedDistribution::read() - extraneous data at end of file %s", v5, *((_QWORD *)a2 + 2));
  }
  else
  {
    *(_QWORD *)v61 = &off_24C7F10D8;
    __src = 0;
    v63 = 0;
    v64 = 2.0;
    v65 = 257;
    v58 = &off_24C7F32C0;
    v59 = 0;
    __s1 = (void *)operator new[]();
    *(_BYTE *)__s1 = 0;
    v55 = 0;
    v56 = 0;
    i = off_24C7F13C0;
    v57 = 0;
    if (*(_DWORD *)(a1 + 540))
    {
      v42 = "Index %d outside of range [0,%d]";
      if (!v44)
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v11);
      LOBYTE(v48) = 35;
      (*(void (**)(size_t *__return_ptr, uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v44 + 80))(&__n, v44, &v48);
      v13 = (char *)operator new[]();
      strcpy(v13, "\r\n\t ");
      v14 = v52;
      v15 = (char *)__s2;
      if ((_DWORD)v52)
      {
        v16 = 0;
        while (strchr(v13, v15[v16]))
        {
          if (v14 == ++v16)
          {
            v17 = v14;
            v18 = v14;
            v16 = v14;
            goto LABEL_28;
          }
        }
        v17 = v16;
        v18 = v14;
      }
      else
      {
        v17 = 0;
        v18 = 0;
        v16 = 0;
      }
LABEL_28:
      if (v16 >= v14)
        v19 = v14;
      else
        v19 = v16;
      do
      {
        if (v18 <= v17)
          goto LABEL_34;
        v20 = v18--;
      }
      while (strchr(v13, v15[v20 - 1]));
      v19 = v20;
LABEL_34:
      if (v16 <= v14)
      {
        if (v19 > v14)
        {
          v16 = v19;
        }
        else
        {
          if (v19 >= v16)
          {
            *(_QWORD *)__str = &off_24C7F32C0;
            if (v15)
            {
              LODWORD(v67) = v19 - v16;
              v21 = (_WORD *)operator new[]();
              v68 = v21;
              memcpy(v21, &v15[v16], (v19 - v16));
              *((_BYTE *)v21 + (v19 - v16)) = 0;
              ((void (*)(NString *, const void *, const unsigned int *))v58[8])((NString *)&v58, v21, (const unsigned int *)&v67);
              *(_QWORD *)__str = &off_24C7F32C0;
              if (v68)
                MEMORY[0x212BAC9C0](v68, 0x1000C8077774924);
              MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
              __n = (size_t)&off_24C7F32C0;
              if (__s2)
                MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
              v48 = &off_24C7F32C0;
              v49 = 2;
              v50 = (char *)operator new[]();
              strcpy(v50, "M=");
              v45 = &off_24C7F32C0;
              if ((snprintf(__str, 0x80uLL, "%d", 0) - 129) > 0xFFFFFF7F)
              {
                v46 = strlen(__str);
                v47 = (void *)(*v45)((NString *)&v45, &v46);
                memcpy(v47, __str, v46 + 1);
                NString::operator+((uint64_t)&v48, (uint64_t)&v45, (uint64_t)&__n);
              }
              Error::chuck((Error *)"NString::NString: cannot convert int to string", v22);
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v12);
          }
          v42 = "Start and end indices conflict, start [%d], end [%d]";
          v14 = v19;
        }
      }
      Error::chuck((Error *)v42, v12, v16, v14);
    }
    LODWORD(__n) = 0;
    if (*(_DWORD *)(a1 + 256))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 8))(a1 + 248, *(_QWORD *)(a1 + 264));
      v23 = (**(uint64_t (***)(uint64_t, size_t *))(a1 + 248))(a1 + 248, &__n);
      *(_QWORD *)(a1 + 264) = v23;
      v24 = __n;
      *(_DWORD *)(a1 + 256) = __n;
      *(_BYTE *)(v23 + v24) = 0;
    }
    v25 = *(void **)(a1 + 264);
    if (!(_DWORD)v63)
    {
      if (!HIBYTE(v65))
        Error::chuck((Error *)"NAutoArray::operator[] AutoResize=false and out-of-bounds (size = %d, [] = %d)", v11, 0, 0);
      if (HIDWORD(v63))
      {
        LODWORD(v63) = 1;
      }
      else
      {
        *(_DWORD *)__str = 1;
        (*(void (**)(BOOL *, char *, _QWORD))(*(_QWORD *)v61 + 48))(v61, __str, v64);
      }
    }
    memcpy(v25, __src, __n);
    *(_DWORD *)(a1 + 544) = __n;
    for (i = off_24C7F13C0; ; ((void (*)(uint64_t, uint64_t))i[9])((uint64_t)&i, (uint64_t)v5))
    {
      v5 = (const char *)v55;
      if (!v55)
        break;
      v55 = *(_QWORD *)(v55 + 8);
    }
    v58 = &off_24C7F32C0;
    if (__s1)
      MEMORY[0x212BAC9C0](__s1, 0x1000C8077774924);
    *(_QWORD *)v61 = &off_24C7F3170;
    if (__src)
      MEMORY[0x212BAC9C0](__src, 0x1000C80BDFB0063);
  }
  if (!v44)
  {
    v41 = "NSmartPointer::checkptr() - pointer unset";
LABEL_97:
    Error::chuck((Error *)v41, v5);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v27 = *(unsigned __int16 **)(a1 + 264);
  v28 = *(unsigned int *)(a1 + 256);
  v29 = *(unsigned int *)(a1 + 288);
  v30 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v29 == v30)
  {
    v31 = *(_DWORD *)(a1 + 288);
    goto LABEL_69;
  }
  v32 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 288) = v30;
  *(_QWORD *)(a1 + 280) = operator new[]();
  v31 = *(_DWORD *)(a1 + 540);
  if ((_DWORD)v29 && v31)
  {
    v33 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v33) = *(_QWORD *)(v32 + 8 * v33);
      ++v33;
    }
    while (v33 < v29 && v33 < *(unsigned int *)(a1 + 540));
  }
  else if (!v32)
  {
    goto LABEL_69;
  }
  MEMORY[0x212BAC9C0](v32, 0x50C80EE9192B6);
  v31 = *(_DWORD *)(a1 + 540);
LABEL_69:
  v34 = (unint64_t)v27 + v28;
  if (v31)
  {
    v35 = 0;
    do
    {
      if ((unint64_t)v27 >= v34)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v26, *((_QWORD *)a2 + 2));
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * v35) = v27;
      v36 = v27 + 1;
      v37 = *v27;
      if ((unint64_t)&v27[2 * *v27 + 1] > v34)
        Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector overflows block in file %s", v26, *((_QWORD *)a2 + 2));
      if (*v27)
      {
        v38 = 0;
        do
        {
          if (*(_DWORD *)(a1 + 536) <= *v36)
            Error::chuck((Error *)"NFastFixedDistribution::read() - invalid gaussian index in M=%d, comp %d, in file %s", v26, v35, v38, *((_QWORD *)a2 + 2));
          v36 += 2;
          v38 = (v38 + 1);
        }
        while (v37 != (_DWORD)v38);
        v36 = &v27[2 * (v37 - 1) + 3];
      }
      ++v35;
      v27 = v36;
    }
    while (v35 < *(unsigned int *)(a1 + 540));
  }
  else
  {
    v36 = v27;
  }
  if (v36 != (unsigned __int16 *)v34)
    Error::chuck((Error *)"NFastFixedDistribution::read() - mixture weight vector under/overflows block in file %s", v26, *((_QWORD *)a2 + 2));
  v43 = &off_24C7F17F8;
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void sub_20D9DF444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t (**a38)(NString *__hidden this, const unsigned int *),uint64_t a39,uint64_t a40,uint64_t (**a41)(),uint64_t a42)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a34);
  a38 = &off_24C7F32C0;
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  a41 = &off_24C7F3170;
  if (a42)
    MEMORY[0x212BAC9C0](a42, 0x1000C80BDFB0063);
  if (a24)
    (*(void (**)(uint64_t))(*(_QWORD *)a24 + 8))(a24);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  _WORD *v36;
  int v37;
  unsigned __int16 *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  float v43;
  float v44;
  _QWORD v46[2];
  int v47;
  int v48;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v46[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v46[1] = v22;
  v47 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = *(_WORD **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v37 = (unsigned __int16)*v36;
  if (*v36)
  {
    v38 = v36 + 1;
    v39 = -1073741823;
    do
    {
      v40 = v39;
      v48 = *v38;
      v41 = NFastFixedGaussians<signed char,int,unsigned char>::score(a1 + 8, &v48, (uint64_t)v46, v23, v24, v25, v26, v27, v28, v29, v30)- v38[1];
      if (v41 <= v40)
        v39 = v40;
      else
        v39 = v41;
      if (v41 >= v40)
        v41 = v40;
      if (v41 != -1073741823)
      {
        v42 = v39 - v41;
        if (v42 <= *(_DWORD *)(a1 + 500))
          v39 += *(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v42 >> *(_DWORD *)(a1 + 496)));
      }
      v38 += 2;
      --v37;
    }
    while (v37);
    v43 = (float)v39;
  }
  else
  {
    v43 = -1073700000.0;
  }
  v44 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v44 * v43;
}

void sub_20D9DF9AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _WORD *v5;
  int v6;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v5 = *(_WORD **)(*(_QWORD *)(a1 + 280) + 8 * *a2);
  v6 = (unsigned __int16)*v5;
  if (*v5)
  {
    v9 = v5 + 2;
    v10 = 3221225473;
    do
    {
      v12 = *(v9 - 1);
      if (*(_BYTE *)(*(_QWORD *)(a3 + 8) + v12))
      {
        v13 = (uint64_t)rintf(*(float *)(*(_QWORD *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10)
          v11 = v10;
        else
          v11 = v13;
        if (v13 >= (int)v10)
          v13 = v10;
        if (v13 != -1073741823)
        {
          v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500))
            v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
                               + v11);
        }
      }
      else
      {
        v11 = v10;
      }
      v9 += 2;
      v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::componentScore(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  int v36;
  float v37;
  _QWORD v39[2];
  int v40;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1);
  v8 = *(unsigned int *)(a3 + 16);
  v9 = operator new[]();
  v10 = v9;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = *(_QWORD *)(a3 + 8);
    if (v8 < 8)
      goto LABEL_7;
    if ((unint64_t)(v9 - v12) < 0x20)
      goto LABEL_7;
    v11 = v8 & 0xFFFFFFF8;
    v13 = (_OWORD *)(v9 + 16);
    v14 = (__int128 *)(v12 + 16);
    v15 = v11;
    do
    {
      v16 = *v14;
      *(v13 - 1) = *(v14 - 1);
      *v13 = v16;
      v13 += 2;
      v14 += 2;
      v15 -= 8;
    }
    while (v15);
    if (v11 != v8)
    {
LABEL_7:
      v17 = v8 - v11;
      v18 = 4 * v11;
      v19 = (_DWORD *)(v9 + 4 * v11);
      v20 = (int *)(v12 + v18);
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v17;
      }
      while (v17);
    }
  }
  v39[0] = &off_24C7F3138;
  v22 = operator new[]();
  v31 = v22;
  v39[1] = v22;
  v40 = v8;
  if ((_DWORD)v8)
  {
    v32 = 0;
    v33 = *(_QWORD *)(v7 + 104);
    do
    {
      v35 = *(float *)(v10 + 4 * v32);
      LODWORD(v24) = *(_DWORD *)(v33 + 4 * v32);
      if (v35 > *(float *)&v24)
      {
        v34 = *(float *)&v24 * *(float *)(*(_QWORD *)(v7 + 56) + 4 * v32);
      }
      else
      {
        *(float *)&v24 = -*(float *)&v24;
        LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v7 + 56) + 4 * v32);
        if (v35 >= *(float *)&v24)
          v34 = v35 * *(float *)&v25;
        else
          v34 = *(float *)&v25 * *(float *)&v24;
      }
      *(float *)&v23 = rintf(v34);
      *(_WORD *)(v22 + 2 * v32++) = (uint64_t)*(float *)&v23;
    }
    while (v8 != v32);
  }
  v36 = NFastFixedGaussians<signed char,int,unsigned char>::score(a1 + 8, a2, (uint64_t)v39, v23, v24, v25, v26, v27, v28, v29, v30);
  v37 = *(float *)(v6 + 44);
  MEMORY[0x212BAC9C0](v31, 0x1000C80BDFB0063);
  MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
  return v37 * (float)v36;
}

void sub_20D9DFCD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  _WORD *v3;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v3 = *(_WORD **)(*(_QWORD *)(result + 280) + 8 * *a2);
  v4 = (unsigned __int16)*v3;
  if (*v3)
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a3 + 8);
    if ((_DWORD)v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      v12 = v4 - v7;
      do
      {
        v13 = *v5;
        v5 += 2;
        *(_BYTE *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    v7 = (unsigned __int16)v4 & 0xFFFE;
    v5 += 2 * v7;
    v8 = v3 + 3;
    v9 = v7;
    do
    {
      v10 = *(v8 - 2);
      v11 = *v8;
      v8 += 4;
      *(_BYTE *)(v6 + v10) = 1;
      *(_BYTE *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4)
      goto LABEL_7;
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 8 * *a2) + 2);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::posteriorWeightedMean() - not implemented", a2);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NFastFixedDistribution::baseGMM() - not implemented for fixed-point models", a2);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

uint64_t read_gaussian_models(uint64_t (***a1)(NString *__hidden this, const unsigned int *), const NString *a2)
{
  uint64_t v2;
  void (**v4)(NDistributionLoader *__hidden);
  uint64_t v5;

  v4 = &off_24C7F1FD8;
  v5 = 0;
  v2 = NDistributionLoader::read((NDistributionLoader *)&v4, a1, a2);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  return v2;
}

void sub_20D9DFE18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_20D9E2D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D9E3510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3086(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3087(uint64_t a1)
{

}

objc_class *getCSUtilsClass()
{
  Class Class;
  objc_class *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v3 = 0;
  v4 = &v3;
  v5 = 0x2050000000;
  Class = (Class)getCSUtilsClass_softClass;
  v6 = getCSUtilsClass_softClass;
  if (!getCSUtilsClass_softClass)
  {
    if (!CoreSpeechFoundationLibraryCore_frameworkLibrary)
    {
      v7 = xmmword_24C7F4118;
      v8 = 0;
      CoreSpeechFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
    }
    Class = objc_getClass("CSUtils");
    v4[3] = (uint64_t)Class;
    getCSUtilsClass_softClass = (uint64_t)Class;
  }
  v1 = Class;
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_20D9E3C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t VTInternalPreferencesSynchronize()
{
  return CFPreferencesAppSynchronize(CFSTR("com.apple.voicetrigger"));
}

void _VTPreferencesSetValueForKey(CFPropertyListRef value, CFStringRef key)
{
  CFPreferencesSetAppValue(key, value, CFSTR("com.apple.voicetrigger"));
}

uint64_t _VTNotBackedupPreferencesSynchronize()
{
  return CFPreferencesAppSynchronize(CFSTR("com.apple.voicetrigger.notbackedup"));
}

void _VTNotBackedupPreferencesSetValueForKey(CFPropertyListRef value, CFStringRef key)
{
  CFPreferencesSetAppValue(key, value, CFSTR("com.apple.voicetrigger.notbackedup"));
}

void _VTReloadVoiceTrigger()
{
  dispatch_time_t v0;

  CFPreferencesAppSynchronize(CFSTR("com.apple.voicetrigger"));
  v0 = dispatch_time(0, 50000000);
  dispatch_after(v0, MEMORY[0x24BDAC9B8], &__block_literal_global_66);
}

CFPropertyListRef _VTPreferencesValueForKey(const __CFString *a1)
{
  return (id)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.voicetrigger"));
}

CFPropertyListRef _VTNotBackedupPreferencesValueForKey(const __CFString *a1)
{
  return (id)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.voicetrigger.notbackedup"));
}

void NZFile::~NZFile(NZFile *this, const char *a2)
{
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F3228;
  if (*((_BYTE *)this + 52))
    Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  *((_BYTE *)this + 52) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

{
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F3228;
  if (!*((_BYTE *)this + 52))
  {
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
    *((_BYTE *)this + 52) = 0;
    *(_QWORD *)this = off_24C7F3428;
    *((_QWORD *)this + 1) = &off_24C7F32C0;
    v3 = *((_QWORD *)this + 3);
    if (v3)
      MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
    JUMPOUT(0x212BAC9D8);
  }
  Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
}

{
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F3228;
  if (*((_BYTE *)this + 52))
    Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
  v4 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  *((_BYTE *)this + 52) = 0;
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

uint64_t NZFile::open(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;

  v4 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 128))(a1, a2, a3, &v4);
}

uint64_t NZFile::close(NZFile *this, const char *a2)
{
  char *v2;
  uint64_t result;
  int v4;

  if (*((_BYTE *)this + 52))
    Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
  v4 = 0;
  v2 = (char *)this + 8;
  result = (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  v2[44] = 0;
  return result;
}

uint64_t NZFile::isOpen(NZFile *this)
{
  return *((unsigned __int8 *)this + 52);
}

void NZFile::eof(NZFile *this, const char *a2)
{
  Error::chuck((Error *)"NZFile::eof() - Not available because compiled without zlib", a2);
}

uint64_t NZFile::good(NZFile *this)
{
  if (((*(uint64_t (**)(NZFile *))(*(_QWORD *)this + 40))(this) & 1) != 0)
    return 0;
  else
    return (*(uint64_t (**)(NZFile *))(*(_QWORD *)this + 32))(this);
}

uint64_t NZFile::read@<X0>(NZFile *this@<X0>, uint64_t a2@<X8>)
{
  _BYTE *v4;
  uint64_t result;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  int v7;
  uint64_t v8;
  int v9;

  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 0;
  v4 = (_BYTE *)operator new[]();
  *(_QWORD *)(a2 + 16) = v4;
  *v4 = 0;
  while (1)
  {
    result = (*(uint64_t (**)(NZFile *))(*(_QWORD *)this + 40))(this);
    if ((result & 1) != 0)
      break;
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), NZFile *, void *))(*(_QWORD *)this + 64))(&v6, this, &NZFILE_READ_LENGTH);
    if (v7)
    {
      v9 = v7;
      (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a2 + 72))(a2, v8, &v9);
    }
    v6 = &off_24C7F32C0;
    if (v8)
      MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  }
  return result;
}

void sub_20D9E4658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;

  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  *v11 = v12;
  v14 = v11[2];
  if (v14)
    MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NZFile::read(NZFile *this, const unsigned int *a2)
{
  const char *v4;
  const char *v5;

  if (((*(uint64_t (**)(NZFile *))(*(_QWORD *)this + 32))(this) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1)
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v4, *((_QWORD *)this + 3));
      *(_BYTE *)operator new[]() = 0;
      Error::chuck((Error *)"NZFile::read() - Can't read from gz compressed file because compiled without zlib", v5);
    }
    Error::chuck((Error *)"NZFile::read() - file %s not opened in read mode", v4, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NZFile::read() - file %s is not open", v4, *((_QWORD *)this + 3));
}

void sub_20D9E4758(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NZFile::read(NZFile *this, const unsigned int *a2, NString *a3)
{
  const char *v5;

  if (((*(uint64_t (**)(NZFile *, const unsigned int *, NString *))(*(_QWORD *)this + 32))(this, a2, a3) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1)
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v5, *((_QWORD *)this + 3));
      Error::chuck((Error *)"NZFile::read() - Not available because compiled without zlib", v5);
    }
    Error::chuck((Error *)"NZFile::read() - file %s not opened in read mode", v5, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NZFile::read() - file %s is not open", v5, *((_QWORD *)this + 3));
}

void NZFile::readLine(NZFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v5;
  _BYTE *v6;
  const char *v7;

  if (((*(uint64_t (**)(NZFile *, const char *))(*(_QWORD *)this + 32))(this, a2) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
    {
      *(_QWORD *)a3 = &off_24C7F32C0;
      *(_DWORD *)(a3 + 8) = 0;
      v6 = (_BYTE *)operator new[]();
      *(_QWORD *)(a3 + 16) = v6;
      *v6 = 0;
      *(_BYTE *)operator new[]() = 0;
      Error::chuck((Error *)"NZFile::readLine() - Not available because compiled without zlib", v7);
    }
    Error::chuck((Error *)"NZFile::readLine() - file %s not opened in read mode", v5, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NZFile::readLine() - file %s is not open", v5, *((_QWORD *)this + 3));
}

void sub_20D9E48C4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *v1 = v4;
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NZFile::readString(NZFile *this)
{
  const char *v2;

  if (((*(uint64_t (**)(NZFile *))(*(_QWORD *)this + 32))(this) & 1) != 0)
  {
    if (!*((_DWORD *)this + 12))
      Error::chuck((Error *)"NZFile::readString() - Not available because compiled without zlib", v2);
    Error::chuck((Error *)"NZFile::readString() - file %s not opened in read mode", v2, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NZFile::readString() - file %s is not open", v2, *((_QWORD *)this + 3));
}

void NZFile::write(NZFile *this, const NString *a2)
{
  const char *v3;

  if (((*(uint64_t (**)(NZFile *, const NString *))(*(_QWORD *)this + 32))(this, a2) & 1) != 0)
  {
    if (*((_DWORD *)this + 12) == 1)
      Error::chuck((Error *)"NZFile::write() - Not available because compiled without zlib", v3);
    Error::chuck((Error *)"NZFile::write() - file %s not opened in write mode", v3, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NZFile::write() - file %s is not open", v3, *((_QWORD *)this + 3));
}

void NZFile::setPosition(NZFile *this, const char *a2)
{
  Error::chuck((Error *)"NZFile::setPosition() - not supported by NZFile", a2);
}

void NZFile::getPosition(NZFile *this, const char *a2)
{
  Error::chuck((Error *)"NZFile::getPosition() - not supported by NZFile", a2);
}

void NZFile::open(NZFile *this, const NString *a2, const NString *a3, const unsigned int *a4)
{
  const char *v8;
  _BYTE *v9;
  int v10;

  (*(void (**)(NZFile *))(*(_QWORD *)this + 24))(this);
  v9 = (_BYTE *)*((_QWORD *)a3 + 2);
  if (*((_DWORD *)a3 + 2) == 1)
  {
    if (*v9 == 114)
    {
      v10 = 0;
      goto LABEL_6;
    }
    v9 = (_BYTE *)*((_QWORD *)a3 + 2);
    if (*v9 == 119)
    {
      v10 = 1;
LABEL_6:
      *((_DWORD *)this + 12) = v10;
      *((_QWORD *)this + 5) = 0;
      if (!*a4)
        Error::chuck((Error *)"NZFile::open() - Can't open gz compressed file '%s' because compiled without zlib", v8, *((_QWORD *)a2 + 2));
      Error::chuck((Error *)"NZFile::open() - offset open not supported", v8);
    }
  }
  Error::chuck((Error *)"NZFile::open() - unrecognized file mode %s", v8, v9);
}

void NZFile::NZFile(NZFile *this)
{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F3228;
  *((_BYTE *)this + 52) = 0;
}

{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F3228;
  *((_BYTE *)this + 52) = 0;
}

void NZFile::NZFile(NZFile *this, const NString *a2, const NString *a3, const unsigned int *a4)
{
  _BYTE *v8;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v8 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v8;
  *v8 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F3228;
  *((_BYTE *)this + 52) = 0;
  NZFile::open(this, a2, a3, a4);
}

{
  _BYTE *v8;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v8 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v8;
  *v8 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F3228;
  *((_BYTE *)this + 52) = 0;
  NZFile::open(this, a2, a3, a4);
}

void sub_20D9E4C0C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  *v1 = v2;
  v1[1] = v3;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9E4CC4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  *v1 = v2;
  v1[1] = v3;
  v5 = v1[3];
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NZipFile::~NZipFile(NZipFile *this)
{
  NFile *v2;
  std::ios_base *v3;
  uint64_t v4;
  int v5;
  int v6;

  *(_QWORD *)this = &off_24C7F3408;
  v2 = (NZipFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v5 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 80) + 64))((char *)this + 640, "", &v6);
  *((_DWORD *)this + 167) = 0;
  *((_BYTE *)this + 688) = 0;
  *((_QWORD *)this + 80) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 82);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NFile::~NFile(v2);
}

{
  NFile *v2;
  std::ios_base *v3;
  uint64_t v4;
  int v5;
  int v6;

  *(_QWORD *)this = &off_24C7F3408;
  v2 = (NZipFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v5 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 80) + 64))((char *)this + 640, "", &v6);
  *((_DWORD *)this + 167) = 0;
  *((_BYTE *)this + 688) = 0;
  *((_QWORD *)this + 80) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 82);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NFile::~NFile(v2);
  JUMPOUT(0x212BAC9D8);
}

{
  NFile *v2;
  std::ios_base *v3;
  uint64_t v4;
  int v5;
  int v6;

  *(_QWORD *)this = &off_24C7F3408;
  v2 = (NZipFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v5 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 80) + 64))((char *)this + 640, "", &v6);
  *((_DWORD *)this + 167) = 0;
  *((_BYTE *)this + 688) = 0;
  *((_QWORD *)this + 80) = &off_24C7F32C0;
  v4 = *((_QWORD *)this + 82);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  NFile::~NFile(v2);
}

void NZipFile::NZipFile(NZipFile *this)
{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F3408;
  NFile::NFile((NZipFile *)((char *)this + 8));
  *((_QWORD *)this + 80) = &off_24C7F32C0;
  *((_DWORD *)this + 162) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 82) = v2;
  *v2 = 0;
  *((_DWORD *)this + 171) = 0;
  *((_BYTE *)this + 688) = 0;
  *(_OWORD *)((char *)this + 664) = 0u;
}

{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F3408;
  NFile::NFile((NZipFile *)((char *)this + 8));
  *((_QWORD *)this + 80) = &off_24C7F32C0;
  *((_DWORD *)this + 162) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 82) = v2;
  *v2 = 0;
  *((_DWORD *)this + 171) = 0;
  *((_BYTE *)this + 688) = 0;
  *(_OWORD *)((char *)this + 664) = 0u;
}

void sub_20D9E5420(_Unwind_Exception *a1)
{
  NFile *v1;

  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

void sub_20D9E54B0(_Unwind_Exception *a1)
{
  NFile *v1;

  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

void NZipFile::NZipFile(NZipFile *this, const NString *a2)
{
  NFile *v4;
  _BYTE *v5;
  _WORD *v6;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  _WORD *v9;

  *(_QWORD *)this = &off_24C7F3408;
  v4 = (NZipFile *)((char *)this + 8);
  v7 = &off_24C7F32C0;
  v8 = 1;
  v9 = (_WORD *)operator new[]();
  *v9 = 114;
  NFile::NFile(v4, a2, (const NString *)&v7);
  v7 = &off_24C7F32C0;
  if (v9)
    MEMORY[0x212BAC9C0](v9, 0x1000C8077774924);
  *((_QWORD *)this + 80) = &off_24C7F32C0;
  *((_DWORD *)this + 162) = 0;
  v5 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 82) = v5;
  *v5 = 0;
  *((_QWORD *)this + 83) = 0;
  *((_QWORD *)this + 85) = 0;
  *((_QWORD *)this + 84) = 0;
  *((_BYTE *)this + 688) = 0;
  v7 = &off_24C7F32C0;
  v8 = 1;
  v6 = (_WORD *)operator new[]();
  v9 = v6;
  *v6 = 114;
  NFile::open(v4, a2, (const NString *)&v7);
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  LODWORD(v7) = 0;
  (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*((_QWORD *)this + 80) + 64))((char *)this + 640, "", &v7);
  *((_DWORD *)this + 167) = 0;
  *((_BYTE *)this + 688) = 0;
}

void sub_20D9E5638(_Unwind_Exception *a1)
{
  NFile *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  *(_QWORD *)(v2 + 640) = v4;
  v6 = *(_QWORD *)(v2 + 656);
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

NZipFile *NZipFile::open(NZipFile *this, const NString *a2)
{
  NFile *v4;
  _WORD *v5;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  _WORD *v9;

  v4 = (NZipFile *)((char *)this + 8);
  v7 = &off_24C7F32C0;
  v8 = 1;
  v5 = (_WORD *)operator new[]();
  v9 = v5;
  *v5 = 114;
  NFile::open(v4, a2, (const NString *)&v7);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  LODWORD(v7) = 0;
  (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*((_QWORD *)this + 80) + 64))((char *)this + 640, "", &v7);
  *((_DWORD *)this + 167) = 0;
  *((_BYTE *)this + 688) = 0;
  return this;
}

void sub_20D9E5784(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NZipFile::close(NZipFile *this)
{
  std::ios_base *v2;
  uint64_t result;
  int v4;
  int v5;

  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v2 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v2, v2->__rdstate_ | 4);
    }
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  v5 = 0;
  result = (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 80) + 64))((char *)this + 640, "", &v5);
  *((_DWORD *)this + 167) = 0;
  *((_BYTE *)this + 688) = 0;
  return result;
}

uint64_t NZipFile::start(NZipFile *this)
{
  NFile *v2;
  const char *v3;
  char *v4;
  unsigned int v5;
  int v6;
  const char *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t result;
  const char *v15;
  const char *v16;
  unsigned int v17;
  unsigned int v18[2];
  uint64_t v19;
  uint64_t v20;
  unsigned int v21[2];
  int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)this + 83) = 0;
  *((_BYTE *)this + 688) = 0;
  v2 = (NZipFile *)((char *)this + 8);
  v21[0] = -1;
  NFile::setPosition((NZipFile *)((char *)this + 8), v21);
  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)v2 + 32))(v2) & 1) == 0)
    Error::chuck((Error *)"NFile::getPosition() - cannot get position, file %s is not open", v3, *((_QWORD *)this + 4));
  if (*((_DWORD *)this + 158))
  {
    v4 = (char *)this + *(_QWORD *)(*((_QWORD *)this + 8) - 24) + 64;
    if ((v4[32] & 5) != 0)
    {
      v5 = -1;
      goto LABEL_8;
    }
    (*(void (**)(unsigned int *__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v4 + 5) + 32))(v21, *((_QWORD *)v4 + 5), 0, 1, 16);
  }
  else
  {
    std::istream::tellg();
  }
  v5 = v24;
LABEL_8:
  if (v5 <= 0x15)
    Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v3, *((_QWORD *)this + 4), "file not large enough to be a zipfile");
  if (v5 >= 0x10016)
    v6 = 0x10000;
  else
    v6 = v5 - 22;
  *(_QWORD *)v21 = &off_24C7F32C0;
  v22 = 0;
  v23 = operator new[]();
  *(_BYTE *)v23 = 0;
  if (!v6)
    goto LABEL_32;
  v8 = 0;
  v9 = v5 >= 0x10016 ? 65558 : v5;
  v10 = 22 - v9;
  while (1)
  {
    v18[0] = v5 - 22 + v8;
    NFile::setPosition(v2, v18);
    v17 = 22;
    NFile::read(v2, &v17, (uint64_t)v18);
    (*(void (**)(unsigned int *, uint64_t, uint64_t *))(*(_QWORD *)v21 + 64))(v21, v20, &v19);
    *(_QWORD *)v18 = &off_24C7F32C0;
    if (v20)
      MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
    if (v22 != 22)
      Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v7, *((_QWORD *)this + 4), "failed to read central dir record");
    if (*(_DWORD *)v23 == 101010256)
      break;
    if (v10 == --v8)
      Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v7, *((_QWORD *)this + 4), "failed to find central dir record");
  }
  if (-v8 == v6)
  {
LABEL_32:
    v15 = "failed to find central dir record";
    goto LABEL_38;
  }
  if (*(_DWORD *)(v23 + 4))
  {
    v15 = "detected multi-disk zip, not supported";
    goto LABEL_38;
  }
  v11 = *(unsigned __int16 *)(v23 + 8);
  if (v11 != *(unsigned __int16 *)(v23 + 10))
  {
    v15 = "inconsistent multi-disk settings";
LABEL_38:
    Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v7, *((_QWORD *)this + 4), v15);
  }
  v12 = *(_DWORD *)(v23 + 12);
  v13 = *(_DWORD *)(v23 + 16);
  v18[0] = v13;
  if (-v8 != *(unsigned __int16 *)(v23 + 20))
  {
    v16 = "unexpected comment size";
    goto LABEL_42;
  }
  if (v13 > v5)
  {
    v16 = "central dir offset outside file limits";
    goto LABEL_42;
  }
  if (v13 + v12 > v5)
  {
    v16 = "central dir body outside file limits";
LABEL_42:
    Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v7, *((_QWORD *)this + 4), v16);
  }
  *((_DWORD *)this + 166) = v11;
  *((_DWORD *)this + 167) = 0;
  NFile::setPosition(v2, v18);
  NZipFile::nextHeader((uint64_t)this);
  *(_QWORD *)v21 = &off_24C7F32C0;
  result = v23;
  if (v23)
    return MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
  return result;
}

void sub_20D9E5CD4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_20D9E5CE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (!a18)
    _Unwind_Resume(exception_object);
  MEMORY[0x212BAC9C0](a18, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NZipFile::nextHeader(uint64_t this)
{
  uint64_t v1;
  NFile *v2;
  const char *v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  const char *v8;
  _BYTE v9[16];
  uint64_t v10;
  unsigned int v11[2];
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  _BYTE v17[8];
  int v18;
  uint64_t v19;

  *(_BYTE *)(this + 688) = 0;
  if (*(_DWORD *)(this + 668) >= *(_DWORD *)(this + 664))
    return this;
  v1 = this;
  v2 = (NFile *)(this + 8);
  v11[0] = 46;
  NFile::read((NFile *)(this + 8), v11, (uint64_t)v17);
  if (v18 != 46)
    Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v3, *(_QWORD *)(v1 + 32), "failed to read local file header");
  v4 = v19;
  if (*(_DWORD *)v19 != 33639248)
  {
    v8 = "missing central dir file header sig";
    goto LABEL_18;
  }
  if (*(_WORD *)(v19 + 34))
  {
    v8 = "header implies multi-disk zip";
LABEL_18:
    Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v3, *(_QWORD *)(v1 + 32), v8);
  }
  *(_DWORD *)(v1 + 672) = *(unsigned __int16 *)(v19 + 10);
  *(_DWORD *)(v1 + 676) = *(_DWORD *)(v4 + 20);
  v5 = *(unsigned __int16 *)(v4 + 28);
  v6 = *(unsigned __int16 *)(v4 + 30);
  v15 = v6;
  v16 = v5;
  v14 = *(unsigned __int16 *)(v4 + 32);
  v7 = *(_DWORD *)(v4 + 42);
  *(_DWORD *)(v1 + 680) = v7;
  *(_DWORD *)(v1 + 684) = v5 + v6 + v7 + 30;
  NFile::read(v2, &v16, (uint64_t)v11);
  if ((unsigned int *)(v1 + 640) != v11)
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(v1 + 640) + 64))(v1 + 640, v13, &v12);
  *(_QWORD *)v11 = &off_24C7F32C0;
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  NFile::read(v2, &v15, (uint64_t)v11);
  NFile::read(v2, &v14, (uint64_t)v9);
  ++*(_DWORD *)(v1 + 668);
  *(_BYTE *)(v1 + 688) = 1;
  if (v10)
    MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  if (v13)
    MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  return MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
}

void sub_20D9E5F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v17;

  if (a17)
    MEMORY[0x212BAC9C0](a17, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NZipFile::valid(NZipFile *this)
{
  return *((unsigned __int8 *)this + 688);
}

uint64_t NZipFile::operator++(uint64_t this)
{
  if (*(_BYTE *)(this + 688))
    return NZipFile::nextHeader(this);
  return this;
}

uint64_t NZipFile::operator*(uint64_t a1)
{
  return a1 + 640;
}

void NZipFile::getCurrentSubFile(NZipFile *this, NFilePtr *a2)
{
  uint64_t v3;
  const char *v5;
  char *v6;
  unsigned int v7;
  const char *v8;
  int v9;
  int v10;
  const char *v11;
  unsigned int v12;
  const NString *v13;
  unsigned __int16 *v14;
  int v15;
  int v16;
  BOOL v17;
  const char *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 688))
    Error::chuck((Error *)"NZipFile::getCurrentSubFile() - reading iterator in invalid state", (const char *)a2);
  v3 = *((unsigned int *)this + 168);
  if ((_DWORD)v3)
    Error::chuck((Error *)"NZipFile::getCurrentSubFile() - compression method %d not currently supported in subfile %s in zipfile %s", (const char *)a2, v3, *((_QWORD *)this + 82), *((_QWORD *)this + 4));
  if (((*(uint64_t (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8) & 1) == 0)
    Error::chuck((Error *)"NFile::getPosition() - cannot get position, file %s is not open", v5, *((_QWORD *)this + 4));
  if (*((_DWORD *)this + 158))
  {
    v6 = (char *)this + *(_QWORD *)(*((_QWORD *)this + 8) - 24) + 64;
    if ((v6[32] & 5) != 0)
    {
      v7 = -1;
      goto LABEL_10;
    }
    (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v6 + 5) + 32))(&v21, *((_QWORD *)v6 + 5), 0, 1, 16);
  }
  else
  {
    std::istream::tellg();
  }
  v7 = v24;
LABEL_10:
  v20 = v7;
  NFile::setPosition((NZipFile *)((char *)this + 8), (const unsigned int *)this + 170);
  v19 = 30;
  NFile::read((NZipFile *)((char *)this + 8), &v19, (uint64_t)&v21);
  if (v22 == 30)
  {
    if (*(_DWORD *)v23 == 67324752)
    {
      if (*(unsigned __int16 *)(v23 + 4) > 0xAu)
      {
        v18 = "Cannot decode this subfile";
      }
      else
      {
        if (*((_DWORD *)this + 168) == *(unsigned __int16 *)(v23 + 8))
        {
          v9 = *(_DWORD *)(v23 + 18);
          if (!v9 || v9 == *((_DWORD *)this + 169))
          {
            v10 = *(unsigned __int16 *)(v23 + 26);
            if (!*(_WORD *)(v23 + 26) || *((_DWORD *)this + 162) == v10)
            {
              v19 = v10 + *(unsigned __int16 *)(v23 + 28) + *((_DWORD *)this + 170) + 30;
              if ((NFile::setPosition((NZipFile *)((char *)this + 8), &v20) & 1) != 0)
              {
                v12 = *((_DWORD *)this + 162);
                if (v12 > 2)
                {
                  v14 = (unsigned __int16 *)(*((_QWORD *)this + 82) + v12 - 3);
                  v15 = *v14;
                  v16 = *((unsigned __int8 *)v14 + 2);
                  v17 = v15 == 26414 && v16 == 122;
                  v13 = (NZipFile *)((char *)this + 16);
                  if (v17)
                    NFilePtr::openOffsetZFile(a2, v13, &v19);
                }
                else
                {
                  v13 = (NZipFile *)((char *)this + 16);
                }
                NFilePtr::openOffsetFile(a2, v13, &v19, (const unsigned int *)this + 169);
              }
              Error::chuck((Error *)"NZipFile::getCurrentSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", v11, *((_QWORD *)this + 82), *((_QWORD *)this + 4), "failed to return to central directory");
            }
            Error::chuck((Error *)"NZipFile::getCurrentSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", v8, *((_QWORD *)this + 82), *((_QWORD *)this + 4), "local header has a different filename to central dir");
          }
          Error::chuck((Error *)"NZipFile::getCurrentSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", v8, *((_QWORD *)this + 82), *((_QWORD *)this + 4), "local header has a different size to central dir");
        }
        v18 = "local header compression method different to central dir";
      }
    }
    else
    {
      v18 = "missing local file header sig";
    }
    Error::chuck((Error *)"NZipFile::getCurrentSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", v8, *((_QWORD *)this + 82), *((_QWORD *)this + 4), v18);
  }
  Error::chuck((Error *)"NZipFile::getCurrentSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", v8, *((_QWORD *)this + 82), *((_QWORD *)this + 4), "failed to read local file header");
}

void sub_20D9E6314(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NFilePtr::openOffsetZFile(NFilePtr *this, const NString *a2, const unsigned int *a3)
{
  uint64_t v5;
  _BYTE *v6;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  _WORD *v9;

  v5 = operator new();
  v7 = &off_24C7F32C0;
  v8 = 1;
  v9 = (_WORD *)operator new[]();
  *v9 = 114;
  *(_QWORD *)v5 = off_24C7F3428;
  *(_QWORD *)(v5 + 8) = &off_24C7F32C0;
  *(_DWORD *)(v5 + 16) = 0;
  v6 = (_BYTE *)operator new[]();
  *(_QWORD *)(v5 + 24) = v6;
  *v6 = 0;
  *(_DWORD *)(v5 + 32) = 256;
  *(_QWORD *)v5 = &off_24C7F3228;
  *(_BYTE *)(v5 + 52) = 0;
  NZFile::open((NZFile *)v5, a2, (const NString *)&v7, a3);
}

void sub_20D9E6438(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  *v1 = v4;
  v1[1] = v3;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9D8](v1, 0x1091C40807AD00ALL);
  _Unwind_Resume(a1);
}

void NFilePtr::openOffsetFile(NFilePtr *this, const NString *a2, const unsigned int *a3, const unsigned int *a4)
{
  NOffsetFile *v8;
  uint64_t (**v9)(NString *__hidden, const unsigned int *);
  int v10;
  _WORD *v11;

  v8 = (NOffsetFile *)operator new();
  v9 = &off_24C7F32C0;
  v10 = 1;
  v11 = (_WORD *)operator new[]();
  *v11 = 114;
  NOffsetFile::NOffsetFile(v8, a2, (const NString *)&v9, a3, a4);
  (*(void (**)(NFilePtr *, NOffsetFile *))(*(_QWORD *)this + 16))(this, v8);
  JUMPOUT(0x212BAC9C0);
}

void sub_20D9E657C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_20D9E65A0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9D8](v1, 0x10F1C4009619B1CLL);
  _Unwind_Resume(a1);
}

void NZipFile::getSubFile(const void **this, const void **a2, NFilePtr *a3)
{
  const char *v6;
  size_t v7;

  NZipFile::start((NZipFile *)this);
  while (*((_BYTE *)this + 688))
  {
    v7 = *((unsigned int *)a2 + 2);
    if ((_DWORD)v7 == *((_DWORD *)this + 162) && !memcmp(this[82], a2[2], v7))
      NZipFile::getCurrentSubFile((NZipFile *)this, a3);
    NZipFile::nextHeader((uint64_t)this);
  }
  Error::chuck((Error *)"NZipFile::getSubFile() - failed to find subfile %s in zipfile %s", v6, a2[2], this[4]);
}

void NFidFile::~NFidFile(NFidFile *this)
{
  NFile *v2;
  std::ios_base *v3;
  int v4;

  *(_QWORD *)this = &off_24C7F33C0;
  *((_BYTE *)this + 648) = 0;
  v2 = (NFidFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  NFile::~NFile(v2);
}

{
  NFile *v2;
  std::ios_base *v3;
  int v4;

  *(_QWORD *)this = &off_24C7F33C0;
  *((_BYTE *)this + 648) = 0;
  v2 = (NFidFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  NFile::~NFile(v2);
  JUMPOUT(0x212BAC9D8);
}

{
  NFile *v2;
  std::ios_base *v3;
  int v4;

  *(_QWORD *)this = &off_24C7F33C0;
  *((_BYTE *)this + 648) = 0;
  v2 = (NFidFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  NFile::~NFile(v2);
}

void NFidFile::NFidFile(NFidFile *this)
{
  *(_QWORD *)this = &off_24C7F33C0;
  NFile::NFile((NFidFile *)((char *)this + 8));
  *((_BYTE *)this + 648) = 0;
  *((_QWORD *)this + 80) = 0;
}

{
  *(_QWORD *)this = &off_24C7F33C0;
  NFile::NFile((NFidFile *)((char *)this + 8));
  *((_BYTE *)this + 648) = 0;
  *((_QWORD *)this + 80) = 0;
}

void NFidFile::NFidFile(NFidFile *this, const NString *a2)
{
  NFile *v4;
  _WORD *v5;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  int v7;
  _WORD *v8;

  *(_QWORD *)this = &off_24C7F33C0;
  v4 = (NFidFile *)((char *)this + 8);
  v6 = &off_24C7F32C0;
  v7 = 1;
  v8 = (_WORD *)operator new[]();
  *v8 = 114;
  NFile::NFile(v4, a2, (const NString *)&v6);
  v6 = &off_24C7F32C0;
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  *((_BYTE *)this + 648) = 0;
  *((_QWORD *)this + 80) = 0;
  v6 = &off_24C7F32C0;
  v7 = 1;
  v5 = (_WORD *)operator new[]();
  v8 = v5;
  *v5 = 114;
  NFile::open(v4, a2, (const NString *)&v6);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  NFidFile::readHeader(this);
}

void sub_20D9E6950(_Unwind_Exception *a1)
{
  NFile *v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

uint64_t NFidFile::readHeader(NFidFile *this)
{
  _DWORD *v2;
  const char *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  int v17;
  const char *v19;
  unsigned int v20;
  char v21[8];
  unsigned int v22;
  uint64_t v23;

  v2 = (_DWORD *)operator new[]();
  v20 = 40;
  NFile::read((NFidFile *)((char *)this + 8), &v20, (uint64_t)v21);
  v4 = v22;
  if ((v22 & 3) != 0)
  {
    if (v23)
      MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
    goto LABEL_17;
  }
  v5 = v22 >> 2;
  v6 = v23;
  if (v22 >> 2 != 10)
  {
    MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
    v2 = (_DWORD *)operator new[]();
    if (v4 <= 3)
    {
      if (v6)
        MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
LABEL_29:
      Error::chuck((Error *)"NFidFile::readHeader() - Problem reading \"%s\": %s", v3, *((_QWORD *)this + 4), "cannot read header (need 40bytes)");
    }
  }
  v7 = 0;
  if (v5 <= 1)
    v8 = 1;
  else
    v8 = v5;
  if (v8 < 8)
    goto LABEL_14;
  if ((unint64_t)v2 - v6 < 0x20)
    goto LABEL_14;
  v7 = v8 & 0x3FFFFFF8;
  v9 = v2 + 4;
  v10 = (__int128 *)(v6 + 16);
  v11 = v7;
  do
  {
    v12 = *v10;
    *(v9 - 1) = *(v10 - 1);
    *v9 = v12;
    v9 += 2;
    v10 += 2;
    v11 -= 8;
  }
  while (v11);
  if (v7 != v8)
  {
LABEL_14:
    v13 = v8 - v7;
    v14 = 4 * v7;
    v15 = &v2[v7];
    v16 = (int *)(v6 + v14);
    do
    {
      v17 = *v16++;
      *v15++ = v17;
      --v13;
    }
    while (v13);
  }
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  if (v5 != 10)
    goto LABEL_29;
LABEL_17:
  if (*v2 != 172247366)
  {
    v19 = "does not start with valid cookie";
    goto LABEL_26;
  }
  if (v2[1] != 1)
  {
    v19 = "only version 1 fidfile supported";
    goto LABEL_26;
  }
  if ((v2[2] & 0xF) != 6)
  {
    v19 = "only supports file offset and location fidfiles";
    goto LABEL_26;
  }
  *((_DWORD *)this + 160) = v2[5];
  if (v2[6] != 1)
  {
    v19 = "only supports hash algorithm 1";
LABEL_26:
    Error::chuck((Error *)"NFidFile::readHeader() - Problem reading \"%s\": %s", v3, *((_QWORD *)this + 4), v19);
  }
  *((_DWORD *)this + 161) = v2[7];
  *((_BYTE *)this + 648) = 1;
  return MEMORY[0x212BAC9C0](v2, 0x1000C8052888210);
}

void sub_20D9E6C0C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

NFidFile *NFidFile::open(NFidFile *this, const NString *a2)
{
  NFile *v4;
  _WORD *v5;
  uint64_t (**v7)(NString *__hidden, const unsigned int *);
  int v8;
  _WORD *v9;

  *((_BYTE *)this + 648) = 0;
  v4 = (NFidFile *)((char *)this + 8);
  v7 = &off_24C7F32C0;
  v8 = 1;
  v5 = (_WORD *)operator new[]();
  v9 = v5;
  *v5 = 114;
  NFile::open(v4, a2, (const NString *)&v7);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  NFidFile::readHeader(this);
  return this;
}

void sub_20D9E6D00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFidFile::close(NFidFile *this)
{
  uint64_t v2;
  uint64_t result;
  std::ios_base *v4;
  int v5;

  v2 = *((_QWORD *)this + 1);
  *((_BYTE *)this + 648) = 0;
  result = (*(uint64_t (**)(void))(v2 + 32))();
  if ((_DWORD)result)
  {
    if (!std::filebuf::close())
    {
      v4 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 6) - 24) + 48);
      std::ios_base::clear(v4, v4->__rdstate_ | 4);
    }
    v5 = 0;
    return (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  return result;
}

void NFidFile::getSubFile(NFidFile *this, const NString *a2, NFilePtr *a3)
{
  uint64_t v6;
  unsigned int v7;
  char *v8;
  int v9;
  unsigned int v10;
  const char *v11;
  char v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  size_t v19;
  void *v20;
  BOOL v21;
  unsigned int v22;
  unsigned int v23;
  BOOL v24;
  uint64_t v25;
  unsigned __int16 *v26;
  int v27;
  int v28;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37[4];
  void *__s1;
  unsigned int v39[2];
  unsigned int *v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;

  if (*((_BYTE *)this + 648))
  {
    v6 = *((unsigned int *)a2 + 2);
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = (char *)*((_QWORD *)a2 + 2);
      do
      {
        v9 = *v8++;
        v7 = v9 + 65599 * v7;
        --v6;
      }
      while (v6);
    }
    else
    {
      v7 = 0;
    }
    v39[0] = *((_DWORD *)this + 161) + 4 * (v7 % *((_DWORD *)this + 160));
    if ((NFile::setPosition((NFidFile *)((char *)this + 8), v39) & 1) != 0)
    {
      v37[0] = 4;
      NFile::read((NFidFile *)((char *)this + 8), v37, (uint64_t)v39);
      if ((_DWORD)v40 == 4)
      {
        v42 = *v41;
        v10 = v42;
        MEMORY[0x212BAC9C0]();
        if (!v10)
          Error::chuck((Error *)"NFidFile::getSubFile() - failed to find subfile %s in fidfile %s", v11, *((_QWORD *)a2 + 2), *((_QWORD *)this + 4));
        if ((NFile::setPosition((NFidFile *)((char *)this + 8), &v42) & 1) != 0)
        {
          *(_QWORD *)v39 = &off_24C7F3100;
          v40 = (unsigned int *)operator new[]();
          LODWORD(v41) = 2;
          while (1)
          {
            NFile::readString((NFidFile *)((char *)this + 8), (uint64_t)v37);
            v33 = 8;
            NFile::read((NFidFile *)((char *)this + 8), &v33, (uint64_t)&v34);
            if ((v35 & 3) != 0)
            {
              if (v36)
                MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
              Error::chuck((Error *)"NFidFile::getSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", v13, *((_QWORD *)a2 + 2), *((_QWORD *)this + 4), "could not reach hash chain item info");
            }
            v43 = v35 >> 2;
            v14 = v36;
            (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)v39 + 24))((uint64_t)v39, v36, (int *)&v43);
            if (v14)
              MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
            v16 = v40;
            v17 = *v40;
            v18 = v40[1];
            *v40 &= ~0x80000000;
            v16[1] = v18 & 0x7FFFFFFF;
            v19 = *((unsigned int *)a2 + 2);
            v20 = __s1;
            if ((_DWORD)v19 == v37[2])
              break;
            v21 = 0;
            if (__s1)
              goto LABEL_23;
LABEL_12:
            v12 = ((v18 | v17) & 0x80000000) != 0 || v21;
            if ((v12 & 1) != 0)
            {
              if (v21)
              {
                v22 = v40[1];
                v37[0] = *v40;
                v34 = v22;
                v23 = *((_DWORD *)a2 + 2);
                v24 = v23 >= 3;
                v25 = v23 - 3;
                if (v24)
                {
                  v26 = (unsigned __int16 *)(*((_QWORD *)a2 + 2) + v25);
                  v27 = *v26;
                  v28 = *((unsigned __int8 *)v26 + 2);
                  if (v27 == 26414 && v28 == 122)
                    NFilePtr::openOffsetZFile(a3, (NFidFile *)((char *)this + 16), v37);
                }
                NFilePtr::openOffsetFile(a3, (NFidFile *)((char *)this + 16), v37, &v34);
              }
              Error::chuck((Error *)"NFidFile::getSubFile() - failed to find subfile %s in fidfile %s", v15, *((_QWORD *)a2 + 2), *((_QWORD *)this + 4));
            }
          }
          v21 = memcmp(__s1, *((const void **)a2 + 2), v19) == 0;
          if (!v20)
            goto LABEL_12;
LABEL_23:
          MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
          goto LABEL_12;
        }
        v30 = *((_QWORD *)a2 + 2);
        v31 = *((_QWORD *)this + 4);
        v32 = "could not reach hash chain";
      }
      else
      {
        NString::~NString((NString *)v39);
        v30 = *((_QWORD *)a2 + 2);
        v31 = *((_QWORD *)this + 4);
        v32 = "could not read hashblock slot";
      }
    }
    else
    {
      v30 = *((_QWORD *)a2 + 2);
      v31 = *((_QWORD *)this + 4);
      v32 = "could not reach hashblock slot";
    }
  }
  else
  {
    v30 = *((_QWORD *)a2 + 2);
    v31 = *((_QWORD *)this + 4);
    v32 = "fidfile is not open and ready";
  }
  Error::chuck((Error *)"NFidFile::getSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", (const char *)a2, a3, v30, v31, v32);
}

void sub_20D9E71E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a20)
    MEMORY[0x212BAC9C0](a20, 0x1000C8052888210);
  _Unwind_Resume(exception_object);
}

void NAutoString::~NAutoString(NAutoString *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
}

uint64_t NAutoString::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v5;

  if (a1 != a2)
  {
    v3 = *(_QWORD *)(a2 + 16);
    v5 = *(_DWORD *)(a2 + 8);
    (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 64))(a1, v3, &v5);
  }
  return a1;
}

uint64_t NAutoString::operator=(uint64_t a1, char *__s)
{
  int v5;

  v5 = strlen(__s);
  (*(void (**)(uint64_t, char *, int *))(*(_QWORD *)a1 + 64))(a1, __s, &v5);
  return a1;
}

uint64_t NAutoString::operator+=(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  int v6;

  v3 = *(_DWORD *)(a2 + 8);
  if (v3)
  {
    v4 = *(_QWORD *)(a2 + 16);
    v6 = v3;
    (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 72))(a1, v4, &v6);
  }
  return a1;
}

void *NAutoString::assignTo(NAutoString *this, const void *__src, const unsigned int *a3)
{
  size_t v5;
  void *result;
  void *v7;
  int v8;

  if (!__src)
    Error::chuck((Error *)"NAutoString::assignTo() - Null pointer passed to assign", 0, a3);
  v5 = *a3;
  if (v5 >= *((_DWORD *)this + 6))
  {
    v8 = *((_DWORD *)this + 7) + v5;
    v7 = (void *)(**(uint64_t (***)(NAutoString *, int *))this)(this, &v8);
    memcpy(v7, __src, v5);
    *((_BYTE *)v7 + v5) = 0;
    result = (void *)(*(uint64_t (**)(NAutoString *, _QWORD))(*(_QWORD *)this + 8))(this, *((_QWORD *)this + 2));
    *((_QWORD *)this + 2) = v7;
    *((_DWORD *)this + 6) = v8;
  }
  else
  {
    result = memcpy(*((void **)this + 2), __src, *a3);
    *(_BYTE *)(*((_QWORD *)this + 2) + v5) = 0;
  }
  *((_DWORD *)this + 2) = v5;
  return result;
}

void *NAutoString::appendTo(NAutoString *this, const void *__src, const unsigned int *a3)
{
  uint64_t v6;
  size_t v7;
  unsigned int v8;
  void *result;
  char *v10;
  unsigned int v11;

  if (!__src)
    Error::chuck((Error *)"NAutoString::appendTo() - Null pointer passed to assign", 0, a3);
  v6 = *((unsigned int *)this + 2);
  v7 = *a3;
  v8 = v7 + v6;
  if ((v7 + v6) >= *((_DWORD *)this + 6))
  {
    v11 = *((_DWORD *)this + 7) + v8;
    v10 = (char *)(**(uint64_t (***)(NAutoString *, int *))this)(this, (int *)&v11);
    memcpy(v10, *((const void **)this + 2), *((unsigned int *)this + 2));
    memcpy(&v10[*((unsigned int *)this + 2)], __src, *a3);
    v10[v8] = 0;
    result = (void *)(*(uint64_t (**)(NAutoString *, _QWORD))(*(_QWORD *)this + 8))(this, *((_QWORD *)this + 2));
    *((_QWORD *)this + 2) = v10;
    *((_DWORD *)this + 6) = v11;
  }
  else
  {
    result = memcpy((void *)(*((_QWORD *)this + 2) + v6), __src, v7);
    *(_BYTE *)(*((_QWORD *)this + 2) + v8) = 0;
  }
  *((_DWORD *)this + 2) = v8;
  return result;
}

void NAutoString::NAutoString(NAutoString *this)
{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 2) = v2;
  *((_QWORD *)this + 3) = 0;
  *v2 = 0;
  *(_QWORD *)this = &off_24C7F11D8;
}

{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 2) = v2;
  *((_QWORD *)this + 3) = 0;
  *v2 = 0;
  *(_QWORD *)this = &off_24C7F11D8;
}

void NAutoString::NAutoString(NAutoString *this, const unsigned int *a2, const unsigned int *a3)
{
  _BYTE *v6;
  _BYTE *v7;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 2) = v6;
  *v6 = 0;
  *(_QWORD *)this = &off_24C7F11D8;
  *((_DWORD *)this + 6) = *a2;
  *((_DWORD *)this + 7) = *a3;
  MEMORY[0x212BAC9C0]();
  v7 = (_BYTE *)(**(uint64_t (***)(NAutoString *, char *))this)(this, (char *)this + 24);
  *((_QWORD *)this + 2) = v7;
  *v7 = 0;
}

{
  _BYTE *v6;
  _BYTE *v7;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 2) = v6;
  *v6 = 0;
  *(_QWORD *)this = &off_24C7F11D8;
  *((_DWORD *)this + 6) = *a2;
  *((_DWORD *)this + 7) = *a3;
  MEMORY[0x212BAC9C0]();
  v7 = (_BYTE *)(**(uint64_t (***)(NAutoString *, char *))this)(this, (char *)this + 24);
  *((_QWORD *)this + 2) = v7;
  *v7 = 0;
}

void sub_20D9E7A0C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *v1 = v2;
  v4 = v1[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9E7AE8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *v1 = v2;
  v4 = v1[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NAutoString::NAutoString(NAutoString *this, const NAutoString *a2)
{
  void *v4;
  int v5;
  int v6;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  v5 = *((_DWORD *)a2 + 2);
  memcpy(v4, *((const void **)a2 + 2), (v5 + 1));
  *(_QWORD *)this = &off_24C7F11D8;
  v6 = *((_DWORD *)a2 + 7);
  *((_DWORD *)this + 6) = v5;
  *((_DWORD *)this + 7) = v6;
}

{
  void *v4;
  int v5;
  int v6;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  v5 = *((_DWORD *)a2 + 2);
  memcpy(v4, *((const void **)a2 + 2), (v5 + 1));
  *(_QWORD *)this = &off_24C7F11D8;
  v6 = *((_DWORD *)a2 + 7);
  *((_DWORD *)this + 6) = v5;
  *((_DWORD *)this + 7) = v6;
}

void NAutoString::NAutoString(NAutoString *this, const NString *a2)
{
  const NString *v2;
  void *v4;
  const void *v5;

  v2 = a2;
  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  v5 = (const void *)*((_QWORD *)v2 + 2);
  LODWORD(v2) = *((_DWORD *)v2 + 2);
  memcpy(v4, v5, ((_DWORD)v2 + 1));
  *(_QWORD *)this = &off_24C7F11D8;
  *((_DWORD *)this + 6) = (_DWORD)v2;
  *((_DWORD *)this + 7) = (_DWORD)v2;
}

{
  const NString *v2;
  void *v4;
  const void *v5;

  v2 = a2;
  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  v5 = (const void *)*((_QWORD *)v2 + 2);
  LODWORD(v2) = *((_DWORD *)v2 + 2);
  memcpy(v4, v5, ((_DWORD)v2 + 1));
  *(_QWORD *)this = &off_24C7F11D8;
  *((_DWORD *)this + 6) = (_DWORD)v2;
  *((_DWORD *)this + 7) = (_DWORD)v2;
}

void sub_20D9E7F1C(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  id *v3;
  uint64_t v4;

  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 104));
  _Unwind_Resume(a1);
}

void sub_20D9E8174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_20D9E86EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_20D9E88A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3409(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3410(uint64_t a1)
{

}

void sub_20D9E8A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t AccelStaticMFCC::init(AccelStaticMFCC *this, const char *a2, unsigned int *a3, unsigned int *a4, const BOOL *a5, float *a6, const BOOL *a7, const BOOL *a8, double a9, const BOOL *a10, const unsigned int *a11, const float *a12, const float *a13, const unsigned int *a14, const unsigned int *a15, const float *a16, const float *a17, const float *a18, const float *a19)
{
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD *v26;
  __int128 *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int *v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  _OWORD *v41;
  __int128 *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  int *v48;
  int v49;
  const float *v50;
  const unsigned int *v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v58;
  _OWORD *v59;
  __int128 *v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  uint64_t v64;
  _DWORD *v65;
  int *v66;
  int v67;
  unsigned int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  uint64_t result;

  if (*a4 >> 30)
    Error::chuck((Error *)"AccelStaticMFCC::init() - windowlen too large (%u >2^30)", a2, a3, *a4);
  *((_DWORD *)this + 123) = *(_DWORD *)a2;
  *((_DWORD *)this + 124) = *a15;
  v20 = *a4;
  *((_DWORD *)this + 122) = *a4;
  *((float *)this + 125) = *a6;
  v21 = *((_DWORD *)this + 12);
  if (v21 != v20)
  {
    v22 = *((_QWORD *)this + 5);
    *((_DWORD *)this + 12) = v20;
    v23 = operator new[]();
    *((_QWORD *)this + 5) = v23;
    v20 = *((_DWORD *)this + 122);
    if (v21 >= v20)
      v24 = v20;
    else
      v24 = v21;
    if ((_DWORD)v24)
    {
      v25 = 0;
      if (v24 < 8)
        goto LABEL_12;
      if ((unint64_t)(v23 - v22) <= 0x1F)
        goto LABEL_12;
      v25 = v24 & 0xFFFFFFF8;
      v26 = (_OWORD *)(v23 + 16);
      v27 = (__int128 *)(v22 + 16);
      v28 = v25;
      do
      {
        v29 = *v27;
        *(v26 - 1) = *(v27 - 1);
        *v26 = v29;
        v26 += 2;
        v27 += 2;
        v28 -= 8;
      }
      while (v28);
      if (v25 != v24)
      {
LABEL_12:
        v30 = v24 - v25;
        v31 = 4 * v25;
        v32 = (_DWORD *)(v23 + 4 * v25);
        v33 = (int *)(v22 + v31);
        do
        {
          v34 = *v33++;
          *v32++ = v34;
          --v30;
        }
        while (v30);
      }
    }
    else if (!v22)
    {
      goto LABEL_17;
    }
    MEMORY[0x212BAC9C0](v22, 0x1000C8052888210);
    v20 = *((_DWORD *)this + 122);
  }
LABEL_17:
  v35 = *((_DWORD *)this + 18);
  if (v35 == v20)
    goto LABEL_35;
  v36 = *((_QWORD *)this + 8);
  *((_DWORD *)this + 18) = v20;
  v37 = operator new[]();
  *((_QWORD *)this + 8) = v37;
  LODWORD(v38) = *((_DWORD *)this + 122);
  if (v35 >= v38)
    v38 = v38;
  else
    v38 = v35;
  if ((_DWORD)v38)
  {
    if (v38 >= 8 && (unint64_t)(v37 - v36) > 0x1F)
    {
      v40 = v38 & 0xFFFFFFF8;
      v41 = (_OWORD *)(v37 + 16);
      v42 = (__int128 *)(v36 + 16);
      v43 = v40;
      do
      {
        v44 = *v42;
        *(v41 - 1) = *(v42 - 1);
        *v41 = v44;
        v41 += 2;
        v42 += 2;
        v43 -= 8;
      }
      while (v43);
      if (v40 == v38)
        goto LABEL_34;
    }
    else
    {
      v40 = 0;
    }
    v45 = v38 - v40;
    v46 = 4 * v40;
    v47 = (_DWORD *)(v37 + 4 * v40);
    v48 = (int *)(v36 + v46);
    do
    {
      v49 = *v48++;
      *v47++ = v49;
      --v45;
    }
    while (v45);
LABEL_34:
    MEMORY[0x212BAC9C0](v36, 0x1000C8052888210);
    goto LABEL_35;
  }
  if (v36)
    goto LABEL_34;
LABEL_35:
  v50 = a19;
  v51 = a14;
  v52 = *((_DWORD *)this + 6);
  v53 = *((_DWORD *)this + 124);
  if (v52 != v53)
  {
    v54 = *((_QWORD *)this + 2);
    *((_DWORD *)this + 6) = v53;
    v55 = operator new[]();
    *((_QWORD *)this + 2) = v55;
    LODWORD(v56) = *((_DWORD *)this + 124);
    if (v52 >= v56)
      v56 = v56;
    else
      v56 = v52;
    if (!(_DWORD)v56)
    {
      v50 = a19;
      v51 = a14;
      if (!v54)
        goto LABEL_53;
      goto LABEL_52;
    }
    if (v56 >= 8 && (unint64_t)(v55 - v54) > 0x1F)
    {
      v58 = v56 & 0xFFFFFFF8;
      v59 = (_OWORD *)(v55 + 16);
      v60 = (__int128 *)(v54 + 16);
      v61 = v58;
      do
      {
        v62 = *v60;
        *(v59 - 1) = *(v60 - 1);
        *v59 = v62;
        v59 += 2;
        v60 += 2;
        v61 -= 8;
      }
      while (v61);
      if (v58 == v56)
        goto LABEL_52;
    }
    else
    {
      v58 = 0;
    }
    v63 = v56 - v58;
    v64 = 4 * v58;
    v65 = (_DWORD *)(v55 + 4 * v58);
    v66 = (int *)(v54 + v64);
    do
    {
      v67 = *v66++;
      *v65++ = v67;
      --v63;
    }
    while (v63);
LABEL_52:
    MEMORY[0x212BAC9C0](v54, 0x1000C8052888210);
    v50 = a19;
    v51 = a14;
  }
LABEL_53:
  *((_BYTE *)this + 88) = 0;
  v68 = *a3;
  *((_DWORD *)this + 105) = *a3;
  v69 = *a4;
  *((_DWORD *)this + 106) = *a4;
  *((_BYTE *)this + 428) = *a5;
  v70 = 1;
  do
  {
    v71 = v70;
    v70 *= 2;
  }
  while (v71 < v69);
  *((_DWORD *)this + 108) = v71;
  *((_DWORD *)this + 109) = (v71 >> 1) + 1;
  *((_BYTE *)this + 440) = *a10;
  *((float *)this + 111) = *a16 * *a17;
  *((_BYTE *)this + 448) = *a7;
  v72 = *a11;
  *((_DWORD *)this + 113) = *a11;
  *((_DWORD *)this + 114) = v68 >> 1;
  *((float *)this + 115) = *a12;
  *((float *)this + 116) = *a13;
  *((float *)this + 117) = *a18;
  *(float *)&a9 = *v50;
  *((float *)this + 118) = *v50;
  v73 = *(unsigned __int8 *)a8;
  *((_BYTE *)this + 449) = v73;
  *((_DWORD *)this + 119) = *v51;
  if (v73)
    v74 = v72;
  else
    v74 = *((_DWORD *)this + 124);
  *((_DWORD *)this + 120) = v74;
  AccelWin2MFCC::initProc((AccelStaticMFCC *)((char *)this + 88), a9);
  result = AccelWin2MFCC::initData((void **)this + 11);
  *((_DWORD *)this + 104) = 1065353216;
  *((_BYTE *)this + 88) = 1;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 126) = *((_DWORD *)this + 122) + 1;
  *((_QWORD *)this + 64) = 0;
  *((_BYTE *)this + 508) = 0;
  *(_BYTE *)this = 1;
  return result;
}

uint64_t AccelStaticMFCC::reset(uint64_t this)
{
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 504) = *(_DWORD *)(this + 488) + 1;
  *(_QWORD *)(this + 512) = 0;
  *(_BYTE *)(this + 508) = 0;
  return this;
}

uint64_t AccelStaticMFCC::start(uint64_t result, const char *a2, int *a3, int *a4)
{
  int v4;
  int v5;

  if (!*(_BYTE *)result)
    Error::chuck((Error *)"AccelStaticMFCC::start() - AccelStaticMFCC::init() has to be called before starting", a2);
  if (*(_QWORD *)(result + 512))
    Error::chuck((Error *)"AccelStaticMFCC::start() - frames undrained from previous chunk - call isFrame() or reset()", a2);
  v4 = *a3;
  if (!a2 && v4)
    Error::chuck((Error *)"AccelStaticMFCC::start() - pointer to chunk is NULL", 0);
  v5 = *a4;
  if (*a4 >= 2)
    Error::chuck((Error *)"NAccelStaticMFCC::start() - unsupported sample type", a2);
  *(_QWORD *)(result + 512) = a2;
  *(_DWORD *)(result + 520) = v4;
  *(_DWORD *)(result + 524) = v5;
  *(_BYTE *)(result + 508) = 0;
  return result;
}

uint64_t AccelStaticMFCC::isFrame(AccelStaticMFCC *this, const char *a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  vDSP_Length v9;
  float *v11;
  const float *v12;
  vDSP_Length v13;
  float *v14;
  unsigned int v15;
  const void *v16;
  size_t v17;
  const float *v18;
  size_t v19;
  unsigned int v20;
  int16x4_t v21;
  int v22;
  uint64_t result;
  int v24;
  uint64_t v25;
  float v26;
  _BOOL4 v27;
  float v28;
  uint64_t v29;
  _DWORD *v30;
  _DWORD *v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _OWORD *v39;
  __int128 *v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  int *v46;
  int v47;
  int v48;
  int v49;
  BOOL v50;
  int v51;
  char v52;
  float __C;
  float v54;
  float __B;
  float v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 64);
  v4 = *((_DWORD *)this + 130);
  if (!v3)
  {
    if (v4)
      Error::chuck((Error *)"AccelStaticMFCC::isFrame() - AccelStaticMFCC::start() has tobe called before computing next frame", a2);
    v3 = 0;
  }
  v5 = *((_DWORD *)this + 131);
  v6 = *((_DWORD *)this + 126);
  if (v6 > v4 || *((_BYTE *)this + 508))
  {
    v7 = *((_DWORD *)this + 122);
    if (v7 + 1 <= v6 || *((_BYTE *)this + 508))
    {
      v8 = v6 + ~v7;
      v9 = v4 - v8;
      if (v4 <= v8)
        goto LABEL_29;
      if (v8 < v6 && *((_BYTE *)this + 508) != 0)
        goto LABEL_29;
      v11 = (float *)*((_QWORD *)this + 8);
      if (v5 == 1)
      {
        __B = 32767.0;
        v12 = (const float *)(v3 + 4 * v8);
LABEL_22:
        vDSP_vsmul(v12, 1, &__B, v11, 1, v9);
        __C = 32767.0;
        v54 = -32767.0;
        vDSP_vclip(v11, 1, &v54, &__C, v11, 1, v9);
LABEL_29:
        result = 0;
        v24 = *((_DWORD *)this + 126) - *((_DWORD *)this + 130);
        *((_DWORD *)this + 126) = v24;
        *((_DWORD *)this + 20) = *((_DWORD *)this + 122) - v24 + 1;
        *((_QWORD *)this + 64) = 0;
        *((_BYTE *)this + 508) = 0;
        return result;
      }
      v12 = (const float *)(v3 + 2 * v8);
    }
    else
    {
      v19 = 4 * (v7 + 1 - v6);
      memmove(*((void **)this + 8), (const void *)(*((_QWORD *)this + 8) + 4 * (*((_DWORD *)this + 20) - (v7 + 1 - v6))), v19);
      v12 = (const float *)*((_QWORD *)this + 64);
      v11 = (float *)(*((_QWORD *)this + 8) + v19);
      v9 = *((unsigned int *)this + 130);
      if (v5 == 1)
      {
        __B = 32767.0;
        goto LABEL_22;
      }
    }
    vDSP_vflt16((const __int16 *)v12, 1, v11, 1, v9);
    goto LABEL_29;
  }
  v13 = *((unsigned int *)this + 122);
  v14 = (float *)*((_QWORD *)this + 5);
  v15 = v13 + 1 - v6;
  if ((int)v13 + 1 <= v6)
  {
    v20 = v6 + ~(_DWORD)v13;
    if (v5 == 1)
    {
      __B = 32767.0;
      v18 = (const float *)(v3 + 4 * v20);
LABEL_25:
      vDSP_vsmul(v18, 1, &__B, v14, 1, v13);
      __C = 32767.0;
      v54 = -32767.0;
      vDSP_vclip(v14, 1, &v54, &__C, v14, 1, v13);
      v22 = *((_DWORD *)this + 126);
      if (!v22)
        goto LABEL_31;
LABEL_34:
      v25 = (v22 - 1);
      if (v5 == 1)
      {
        v26 = *(float *)(v3 + 4 * v25);
        v27 = v26 < -1.0 || v26 > 1.0;
        v28 = -32767.0;
        if (v26 > 1.0 && v26 >= -1.0)
          v28 = 32767.0;
        *(float *)v21.i32 = v26 * 32767.0;
        if (v27)
          *(float *)v21.i32 = v28;
      }
      else
      {
        v21.i16[0] = *(_WORD *)(v3 + 2 * v25);
        *(float *)v21.i32 = (float)vmovl_s16(v21).i32[0];
      }
      goto LABEL_44;
    }
    v18 = (const float *)(v3 + 2 * v20);
  }
  else
  {
    v16 = (const void *)(*((_QWORD *)this + 8) + 4 * (*((_DWORD *)this + 20) - v15));
    if (v15 >= v13)
    {
      memcpy(*((void **)this + 5), v16, 4 * v13);
      v22 = *((_DWORD *)this + 126);
      if (v22)
        goto LABEL_34;
      goto LABEL_31;
    }
    v17 = 4 * ((_DWORD)v13 + 1 - v6);
    memcpy(*((void **)this + 5), v16, v17);
    v13 = (*((_DWORD *)this + 126) - 1);
    v18 = (const float *)*((_QWORD *)this + 64);
    v14 = (float *)(*((_QWORD *)this + 5) + v17);
    if (v5 == 1)
    {
      __B = 32767.0;
      goto LABEL_25;
    }
  }
  vDSP_vflt16((const __int16 *)v18, 1, v14, 1, v13);
  v22 = *((_DWORD *)this + 126);
  if (v22)
    goto LABEL_34;
LABEL_31:
  v21.i32[0] = *(_DWORD *)(*((_QWORD *)this + 8) + 4 * (*((_DWORD *)this + 20) - 1));
LABEL_44:
  *((_DWORD *)this + 21) = v21.i32[0];
  __B = 1.0;
  v56 = -*((float *)this + 125);
  vDSP_conv(*((const float **)this + 5), 1, &v56, -1, *((float **)this + 5), 1, (*((_DWORD *)this + 122) - 1), 2uLL);
  v29 = 4 * (*((_DWORD *)this + 122) - 1);
  *(float *)(*((_QWORD *)this + 5) + v29) = *((float *)this + 21)
                                          - (float)(*(float *)(*((_QWORD *)this + 5) + v29) * *((float *)this + 125));
  v30 = (_DWORD *)AccelWin2MFCC::run((uint64_t)this + 88, (uint64_t)this + 32);
  if ((_DWORD *)((char *)this + 8) != v30)
  {
    v31 = v30;
    v32 = *((_DWORD *)this + 6);
    v33 = v30[4];
    if (v32 != v33)
    {
      v34 = *((_QWORD *)this + 2);
      if (v34)
      {
        MEMORY[0x212BAC9C0](v34, 0x1000C8052888210);
        v33 = v31[4];
      }
      *((_DWORD *)this + 6) = v33;
      *((_QWORD *)this + 2) = operator new[]();
      v32 = *((_DWORD *)this + 6);
    }
    if (v32)
    {
      v35 = 0;
      v36 = *((_QWORD *)v31 + 1);
      v37 = *((_QWORD *)this + 2);
      v38 = v32;
      if (v32 < 8)
        goto LABEL_55;
      if ((unint64_t)(v37 - v36) < 0x20)
        goto LABEL_55;
      v35 = v32 & 0xFFFFFFF8;
      v39 = (_OWORD *)(v37 + 16);
      v40 = (__int128 *)(v36 + 16);
      v41 = v38 & 0xFFFFFFF8;
      do
      {
        v42 = *v40;
        *(v39 - 1) = *(v40 - 1);
        *v39 = v42;
        v39 += 2;
        v40 += 2;
        v41 -= 8;
      }
      while (v41);
      if (v35 != v38)
      {
LABEL_55:
        v43 = v38 - v35;
        v44 = 4 * v35;
        v45 = (_DWORD *)(v37 + v44);
        v46 = (int *)(v36 + v44);
        do
        {
          v47 = *v46++;
          *v45++ = v47;
          --v43;
        }
        while (v43);
      }
    }
  }
  v48 = *((_DWORD *)this + 126);
  v49 = *((_DWORD *)this + 123);
  v50 = __CFADD__(v49, v48);
  v51 = v49 + v48;
  v52 = v50;
  *((_DWORD *)this + 126) = v51;
  *((_BYTE *)this + 508) = v52;
  return 1;
}

float AccelStaticMFCC::preemph(AccelStaticMFCC *this)
{
  uint64_t v2;
  uint64_t v3;
  float result;
  float v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v5 = -*((float *)this + 125);
  vDSP_conv(*((const float **)this + 5), 1, &v5, -1, *((float **)this + 5), 1, (*((_DWORD *)this + 122) - 1), 2uLL);
  v2 = *((_QWORD *)this + 5);
  v3 = 4 * (*((_DWORD *)this + 122) - 1);
  result = *((float *)this + 21) - (float)(*(float *)(v2 + v3) * *((float *)this + 125));
  *(float *)(v2 + v3) = result;
  return result;
}

uint64_t AccelStaticMFCC::getFrame(AccelStaticMFCC *this)
{
  return (uint64_t)this + 8;
}

uint64_t AccelStaticMFCC::getWindow(AccelStaticMFCC *this)
{
  return (uint64_t)this + 32;
}

uint64_t AccelStaticMFCC::getScalingFactor(AccelStaticMFCC *this)
{
  return (uint64_t)this + 416;
}

void sub_20D9E9C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_20D9EA5B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getCSActivationEventNotifierClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!CoreSpeechLibraryCore_frameworkLibrary)
  {
    CoreSpeechLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!CoreSpeechLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("CSActivationEventNotifier");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getCSActivationEventNotifierClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getCSActivationEventClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!CoreSpeechLibraryCore_frameworkLibrary)
  {
    CoreSpeechLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!CoreSpeechLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("CSActivationEvent");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getCSActivationEventClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

id getCSVoiceTriggerXPCServiceClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getCSVoiceTriggerXPCServiceClass_softClass;
  v7 = getCSVoiceTriggerXPCServiceClass_softClass;
  if (!getCSVoiceTriggerXPCServiceClass_softClass)
  {
    v3[0] = MEMORY[0x24BDAC760];
    v3[1] = 3221225472;
    v3[2] = __getCSVoiceTriggerXPCServiceClass_block_invoke;
    v3[3] = &unk_24C7F5000;
    v3[4] = &v4;
    __getCSVoiceTriggerXPCServiceClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_20D9EB434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getCSVoiceTriggerXPCServiceClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!CoreSpeechLibraryCore_frameworkLibrary)
  {
    CoreSpeechLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!CoreSpeechLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("CSVoiceTriggerXPCService");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getCSVoiceTriggerXPCServiceClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void *NFilePtr::open(NFilePtr *this, const NString *a2, const NString *a3)
{
  uint64_t v6;
  NPipeFile *v7;
  NPipeFile *v8;
  void *result;
  int *v10;
  int v11;
  int v12;
  int v14;
  void *v15;
  int v16;
  void *v17;
  _DWORD *v18;
  const char *v19;
  unsigned int v20;
  NZFile *v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  void *v30;
  int v31;
  void *v32;
  _DWORD *v33;
  unsigned int v34;
  const char *v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  void *v40;
  void *v41;
  _DWORD *v42;
  char *v43;
  const char *v45;
  NBase64File *v46;
  uint64_t v47;
  const void *v48;
  const char *v49;
  unsigned int v50;
  uint64_t v51;
  size_t v52;
  uint64_t v53;
  NBase64File *v54;
  uint64_t (**v55)(NString *__hidden, const unsigned int *);
  int v56;
  void *v57;
  unsigned int v58[2];
  unsigned int v59;
  void *v60;
  unsigned int v61[2];
  int v62;
  void *v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v6 = *((unsigned int *)a2 + 2);
  if (v6 < 7)
    goto LABEL_2;
  v10 = (int *)*((_QWORD *)a2 + 2);
  v11 = *v10;
  v12 = *(int *)((char *)v10 + 3);
  if (v11 != 1684957549 || v12 != 980968804)
  {
    v14 = v6 - 6;
    if ((int)v6 - 6 >= 1)
    {
      v15 = (void *)*((_QWORD *)a2 + 2);
      v16 = v6 - 6;
      v17 = v15;
      while (1)
      {
        v18 = memchr(v17, 46, v16);
        if (!v18)
          goto LABEL_35;
        v20 = (_DWORD)v18 - (_DWORD)v15;
        if (*v18 == 1684629038 && *(_DWORD *)((char *)v18 + 3) == 791624292)
          break;
        v16 = v6 - v20 - 7;
        v17 = (char *)v18 + 1;
        if (v16 <= 0)
          goto LABEL_35;
      }
      if ((v20 & 0x80000000) == 0)
      {
        v25 = v20 + 4;
        if (v25 <= v6)
        {
          *(_QWORD *)v58 = &off_24C7F32C0;
          if (v15)
          {
            v59 = v20 + 4;
            v60 = (void *)operator new[]();
            memcpy(v60, v15, v20 + 4);
            *((_BYTE *)v60 + v25) = 0;
            NFidFile::NFidFile((NFidFile *)v61, (const NString *)v58);
            v27 = *((unsigned int *)a2 + 2);
            v28 = v27 - (v20 + 7);
            if (v27 >= v20 + 7)
            {
              v29 = *((_QWORD *)a2 + 2);
              v55 = &off_24C7F32C0;
              if (v29)
              {
                v56 = v27 - (v20 + 7);
                v57 = (void *)operator new[]();
                memcpy(v57, (const void *)(v29 + v20 + 7), v28);
                *((_BYTE *)v57 + v28) = 0;
                NFidFile::getSubFile((NFidFile *)v61, (const NString *)&v55, this);
              }
              Error::chuck((Error *)"Null pointer passed to string constructor", v26);
            }
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v26, v20 + 7, v27);
          }
LABEL_69:
          Error::chuck((Error *)"Null pointer passed to string constructor", v19);
        }
        goto LABEL_68;
      }
LABEL_35:
      if (v14 >= 1)
      {
        v30 = (void *)*((_QWORD *)a2 + 2);
        v31 = v6 - 6;
        v32 = v30;
        while (1)
        {
          v33 = memchr(v32, 46, v31);
          if (!v33)
            goto LABEL_50;
          v34 = (_DWORD)v33 - (_DWORD)v30;
          if (*v33 == 1885960750 && *(_DWORD *)((char *)v33 + 3) == 791624304)
            break;
          v31 = v6 - v34 - 7;
          v32 = (char *)v33 + 1;
          if (v31 <= 0)
            goto LABEL_50;
        }
        if ((v34 & 0x80000000) != 0)
        {
LABEL_50:
          v40 = (void *)*((_QWORD *)a2 + 2);
          v41 = v40;
          while (1)
          {
            v42 = memchr(v41, 46, v14);
            if (!v42)
              goto LABEL_2;
            v43 = (char *)((char *)v42 - (_BYTE *)v40);
            if (*v42 == 875979310 && *(_DWORD *)((char *)v42 + 3) == 791624244)
            {
              if ((int)v43 < 1)
              {
                if ((_DWORD)v43)
                  goto LABEL_2;
                v54 = (NBase64File *)operator new();
                v58[0] = 7;
                NString::tail(a2, (const char *)v58, (uint64_t)v61);
                NBase64File::NBase64File(v54, (const NString *)v61, a3);
                (*(void (**)(NFilePtr *, NBase64File *))(*(_QWORD *)this + 16))(this, v54);
                *(_QWORD *)v61 = &off_24C7F32C0;
              }
              else
              {
                v46 = (NBase64File *)operator new();
                v47 = *((unsigned int *)a2 + 2);
                if (v47 < v43)
                  Error::chuck((Error *)"Index %d outside of range [0,%d]", v45, v43, v47);
                v48 = (const void *)*((_QWORD *)a2 + 2);
                *(_QWORD *)v61 = &off_24C7F32C0;
                if (!v48)
                  Error::chuck((Error *)"Null pointer passed to string constructor", v45);
                v62 = (int)v43;
                v63 = (void *)operator new[]();
                memcpy(v63, v48, v43);
                *((_BYTE *)v63 + v43) = 0;
                v50 = (_DWORD)v43 + 7;
                v51 = *((unsigned int *)a2 + 2);
                v52 = (v51 - ((_DWORD)v43 + 7));
                if (v51 < (int)v43 + 7)
                  Error::chuck((Error *)"Index %d outside of range [0,%d]", v49, ((_DWORD)v43 + 7), v51);
                v53 = *((_QWORD *)a2 + 2);
                *(_QWORD *)v58 = &off_24C7F32C0;
                if (!v53)
                  Error::chuck((Error *)"Null pointer passed to string constructor", v49);
                v59 = v52;
                v60 = (void *)operator new[]();
                memcpy(v60, (const void *)(v53 + v50), v52);
                *((_BYTE *)v60 + v52) = 0;
                NBase64File::NBase64File(v46, (const NString *)v61, (const NString *)v58, a3);
                (*(void (**)(NFilePtr *, NBase64File *))(*(_QWORD *)this + 16))(this, v46);
                *(_QWORD *)v58 = &off_24C7F32C0;
                if (v60)
                  MEMORY[0x212BAC9C0](v60, 0x1000C8077774924);
                *(_QWORD *)v61 = &off_24C7F32C0;
              }
              result = v63;
              if (v63)
                return (void *)MEMORY[0x212BAC9C0](v63, 0x1000C8077774924);
              return result;
            }
            v14 = v6 - (_DWORD)v43 - 7;
            v41 = (char *)v42 + 1;
            if (v14 <= 0)
              goto LABEL_2;
          }
        }
        v25 = v34 + 4;
        if (v25 <= v6)
        {
          *(_QWORD *)v58 = &off_24C7F32C0;
          if (v30)
          {
            v59 = v34 + 4;
            v60 = (void *)operator new[]();
            memcpy(v60, v30, v34 + 4);
            *((_BYTE *)v60 + v25) = 0;
            NZipFile::NZipFile((NZipFile *)v61, (const NString *)v58);
            v37 = *((unsigned int *)a2 + 2);
            v38 = v37 - (v34 + 7);
            if (v37 >= v34 + 7)
            {
              v39 = *((_QWORD *)a2 + 2);
              v55 = &off_24C7F32C0;
              if (v39)
              {
                v56 = v37 - (v34 + 7);
                v57 = (void *)operator new[]();
                memcpy(v57, (const void *)(v39 + v34 + 7), v38);
                *((_BYTE *)v57 + v38) = 0;
                NZipFile::getSubFile((const void **)v61, (const void **)&v55, this);
              }
              Error::chuck((Error *)"Null pointer passed to string constructor", v36);
            }
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v36, v34 + 7, v37);
          }
          goto LABEL_69;
        }
LABEL_68:
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v19, v25, v6);
      }
    }
LABEL_2:
    if (NString::endswith(a2, "|") && NString::operator==((uint64_t)a3, "r"))
    {
      v7 = (NPipeFile *)operator new();
      v58[0] = 1;
      NString::cuttail(a2, (const char *)v58, (uint64_t)v61);
      NPipeFile::NPipeFile(v7, (const NString *)v61, a3);
    }
    if (NString::startswith(a2, "|") && NString::operator==((uint64_t)a3, "w"))
    {
      v8 = (NPipeFile *)operator new();
      v58[0] = 1;
      NString::tail(a2, (const char *)v58, (uint64_t)v61);
      NPipeFile::NPipeFile(v8, (const NString *)v61, a3);
    }
    if (NString::endswith(a2, ".gz"))
    {
      v22 = (NZFile *)operator new();
      v61[0] = 0;
      NZFile::NZFile(v22, a2, a3, v61);
    }
    v23 = operator new();
    NFile::NFile((NFile *)v23, a2, a3);
    return (void *)(*(uint64_t (**)(NFilePtr *, uint64_t))(*(_QWORD *)this + 16))(this, v23);
  }
  v23 = operator new();
  *(_QWORD *)v23 = off_24C7F3428;
  *(_QWORD *)(v23 + 8) = &off_24C7F32C0;
  *(_DWORD *)(v23 + 16) = 0;
  v24 = (_BYTE *)operator new[]();
  *(_QWORD *)(v23 + 24) = v24;
  *v24 = 0;
  *(_DWORD *)(v23 + 32) = 256;
  *(_QWORD *)v23 = &off_24C7F1540;
  *(_QWORD *)(v23 + 48) = 0;
  *(_QWORD *)(v23 + 56) = 0;
  *(_QWORD *)(v23 + 40) = 0;
  *(_QWORD *)(v23 + 61) = 0;
  NMemoryFile::open((NMemoryFile *)v23, a2, a3);
  return (void *)(*(uint64_t (**)(NFilePtr *, uint64_t))(*(_QWORD *)this + 16))(this, v23);
}

void sub_20D9EBDD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19)
  {
    MEMORY[0x212BAC9C0](a19, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void NBNNSIRDistribution::~NBNNSIRDistribution(NBNNSIRDistribution *this)
{
  NBNNSIRDistribution::~NBNNSIRDistribution(this);
  JUMPOUT(0x212BAC9D8);
}

{
  size_t v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  *(_QWORD *)this = &off_24C7F1ED0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  v2 = *((unsigned int *)this + 16);
  if ((_DWORD)v2)
    munmap(*((void **)this + 9), v2);
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = 0;
  v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 4) + 64))((char *)this + 32, "", &v6);
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = 0;
  v3 = *((unsigned int *)this + 34);
  if ((_DWORD)v3)
    munmap(*((void **)this + 18), v3);
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = 0;
  v7 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 13) + 64))((char *)this + 104, "", &v7);
  *((_QWORD *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 26) = &off_24C7F3100;
  v4 = *((_QWORD *)this + 27);
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8052888210);
  *((_QWORD *)this + 23) = &off_24C7F3100;
  v5 = *((_QWORD *)this + 24);
  if (v5)
    MEMORY[0x212BAC9C0](v5, 0x1000C8052888210);
  NLoadedMemory::~NLoadedMemory((NBNNSIRDistribution *)((char *)this + 80));
  NLoadedMemory::~NLoadedMemory((NBNNSIRDistribution *)((char *)this + 8));
}

uint64_t NBNNSIRDistribution::size(NBNNSIRDistribution *this)
{
  return (*((_DWORD *)this + 38) * *((_DWORD *)this + 41));
}

uint64_t NBNNSIRDistribution::dimen(NBNNSIRDistribution *this)
{
  return (uint64_t)this + 156;
}

uint64_t NBNNSIRDistribution::numFrames(NBNNSIRDistribution *this)
{
  return *((unsigned int *)this + 40);
}

uint64_t NBNNSIRDistribution::frameSize(NBNNSIRDistribution *this)
{
  return (uint64_t)this + 168;
}

uint64_t NBNNSIRDistribution::scoreCacheTypes(NBNNSIRDistribution *this)
{
  return 4;
}

uint64_t NBNNSIRDistribution::read(NBNNSIRDistribution *this, const NString *a2)
{
  NLoadedMemory *v4;
  size_t v5;
  const char *v6;
  unint64_t WorkspaceSize_v2;
  const char *v8;
  uint64_t v10;
  const char *v11;
  _QWORD v12[2];

  *((_QWORD *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 42) = 0;
  v4 = (NBNNSIRDistribution *)((char *)this + 8);
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  v5 = *((unsigned int *)this + 16);
  if ((_DWORD)v5)
    munmap(*((void **)this + 9), v5);
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = 0;
  LODWORD(v12[0]) = 0;
  (*(void (**)(char *, const char *, _QWORD *))(*((_QWORD *)this + 4) + 64))((char *)this + 32, "", v12);
  NLoadedMemory::load(v4, a2);
  v6 = (const char *)*((unsigned int *)this + 4);
  if (v6 < 4 || **((_DWORD **)this + 3) != -673472473)
    Error::chuck((Error *)"NBNNSIRDistribution::read() - missing cookie in %s", v6, *((_QWORD *)a2 + 2));
  v12[0] = *((_QWORD *)this + 3);
  v12[1] = v6;
  WorkspaceSize_v2 = BNNSGraphGetWorkspaceSize_v2();
  if (WorkspaceSize_v2 == -1)
  {
    v10 = *((_QWORD *)a2 + 2);
    v11 = "Invalid BNNSIR";
    goto LABEL_11;
  }
  if (WorkspaceSize_v2 >= 0xFFFFFFFF80000000)
  {
    v10 = *((_QWORD *)a2 + 2);
    v11 = "BNNSIR Sizes >= 2^31";
LABEL_11:
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v8, v11, v10);
  }
  return NBNNSIRDistribution::determineStateWiring(this, v12, 0, a2);
}

void NBNNSIRDistribution::score(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::score not implemented yet() - not supported for this distribution type", a2);
}

uint64_t NBNNSIRDistribution::scoreAll(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t (**v22)(NString *__hidden, const unsigned int *);
  int v23;
  _BYTE *v24;
  unsigned int v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a1 + 156);
  if (!(_DWORD)v4)
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSIR not loaded", (const char *)a2);
  if (*(_DWORD *)(a2 + 16) != (_DWORD)v4)
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - input vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v4);
  v6 = (*(_DWORD *)(a1 + 152) * *(_DWORD *)(a1 + 164));
  if (*(_DWORD *)(a3 + 16) != (_DWORD)v6)
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - output (dist) vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a3 + 16), v6);
  if (a4)
  {
    v8 = *(char **)(a4 + 8);
  }
  else
  {
    if (*(_DWORD *)(a1 + 200) >= 3u)
      Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - state uninitialized", (const char *)a2);
    v8 = &v26;
  }
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 172)] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 172) + 8] = 4 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 176)] = *(_QWORD *)(a3 + 8);
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 176) + 8] = 4 * *(unsigned int *)(a3 + 16);
  BNNSGraphContextMake();
  if (*(_QWORD *)(a1 + 96))
  {
    v9 = BNNSGraphContextSetWeights();
    if ((_DWORD)v9)
    {
      v20 = v9;
      BNNSGraphContextDestroy_v2();
      Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSGraphContextSetWeights fails with error %d", v21, v20);
    }
  }
  v22 = &off_24C7F32C0;
  v23 = 0;
  v24 = (_BYTE *)operator new[]();
  *v24 = 0;
  BNNSGraphContextSetMessageLogMask();
  BNNSGraphContextSetMessageLogCallback();
  v10 = BNNSGraphContextExecute_v2();
  BNNSGraphContextDestroy_v2();
  if ((_DWORD)v10)
  {
    if (NString::operator==((uint64_t)&v22, ""))
    {
      v25 = 7;
      ((void (*)(NString *, const void *, const unsigned int *))v22[8])((NString *)&v22, "Unknown", &v25);
    }
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSGraphExecute fails with error \"%s\" (%d)", v19, v24, v10);
  }
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 172)] = 0;
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 172) + 8] = 0;
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 176)] = 0;
  *(_QWORD *)&v8[16 * *(unsigned int *)(a1 + 176) + 8] = 0;
  if (a4)
  {
    v11 = *(unsigned int *)(a1 + 200);
    if ((_DWORD)v11)
    {
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = *(unsigned int *)(*(_QWORD *)(a1 + 192) + v13);
        if (v14 < v11)
        {
          v15 = *(_QWORD *)(a4 + 8);
          v16 = *(_QWORD *)(v15 + v12);
          v17 = 16 * v14;
          *(_QWORD *)(v15 + v12) = *(_QWORD *)(v15 + v17);
          *(_QWORD *)(*(_QWORD *)(a4 + 8) + v17) = v16;
        }
        v13 += 4;
        v12 += 16;
      }
      while (4 * v11 != v13);
    }
  }
  v22 = &off_24C7F32C0;
  result = (uint64_t)v24;
  if (v24)
    return MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  return result;
}

void sub_20D9EC948(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NBNNSIRDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::scoreUsingCache() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::componentScore(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::componentScore() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::numComponents(NBNNSIRDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::numComponents() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::setComponentMask(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::setComponentMask() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::firstComponentId(NBNNSIRDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::firstComponentId() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::posteriorWeightedMean() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::baseGMM(NBNNSIRDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::baseGMM() - not supported for this distribution type", a2);
}

void NBNNSIRDistribution::fixedPointScalesP(NBNNSIRDistribution *this, const char *a2)
{
  Error::chuck((Error *)"NBNNSIRDistribution::fixedPointScalesP() - not supported for this distribution type", a2);
}

uint64_t NBNNSIRDistribution::allocateStateP(NBNNSIRDistribution *this, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  if (!*((_DWORD *)this + 39))
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSIR not loaded", a2);
  v3 = *((unsigned int *)this + 50);
  if (v3 < 3)
    return 0;
  v4 = operator new();
  *(_QWORD *)v4 = &off_24C7F03B0;
  v6 = operator new[]();
  v7 = v6;
  v8 = 0;
  *(_QWORD *)(v4 + 8) = v6;
  *(_DWORD *)(v4 + 16) = v3;
  do
  {
    v9 = (_QWORD *)(v6 + v8);
    *v9 = 0;
    v9[1] = 0;
    v8 += 16;
  }
  while (16 * v3 != v8);
  v10 = 0;
  v11 = 0;
  do
  {
    v14 = *(unsigned int *)(*((_QWORD *)this + 24) + v11);
    if (v14 < v3)
    {
      *(_QWORD *)(v7 + 16 * v14) = operator new[]();
      v15 = *((_QWORD *)this + 27);
      v7 = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v7 + 16 * v14 + 8) = *(unsigned int *)(v15 + 4 * v14);
      if (*(_DWORD *)(v15 + v11))
        v12 = operator new[]();
      else
        v12 = *(_QWORD *)(v7 + 16 * v14);
      v13 = (uint64_t *)(v7 + v10);
      *v13 = v12;
      v13[1] = *(unsigned int *)(*((_QWORD *)this + 27) + 4 * v14);
    }
    v11 += 4;
    v10 += 16;
  }
  while (4 * v3 != v11);
  return v4;
}

void sub_20D9ECB8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10A1C40DF6760FDLL);
  _Unwind_Resume(a1);
}

uint64_t NBNNSIRDistribution::deallocateState(uint64_t this, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a2)
  {
    v3 = *(unsigned int *)(this + 200);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 0;
      do
      {
        if (!*(_DWORD *)(*(_QWORD *)(this + 216) + v5))
          *(_QWORD *)(a2[1] + v4) = 0;
        v5 += 4;
        v4 += 16;
      }
      while (4 * v3 != v5);
    }
    *(_QWORD *)(a2[1] + 16 * *(unsigned int *)(this + 172)) = 0;
    *(_QWORD *)(a2[1] + 16 * *(unsigned int *)(this + 176)) = 0;
    if ((_DWORD)v3)
    {
      v6 = 0;
      v7 = a2[1];
      v8 = 16 * v3;
      do
      {
        v9 = *(_QWORD *)(v7 + v6);
        if (v9)
        {
          MEMORY[0x212BAC9D8](v9, 0x1000C4077774924);
          v7 = a2[1];
        }
        *(_QWORD *)(v7 + v6) = 0;
        v7 = a2[1];
        *(_QWORD *)(v7 + v6 + 8) = 0;
        v6 += 16;
      }
      while (v8 != v6);
    }
    return (*(uint64_t (**)(_QWORD *))(*a2 + 8))(a2);
  }
  return this;
}

void NBNNSIRDistribution::resetState(NBNNSIRDistribution *this, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;

  if (a2)
  {
    v3 = *((unsigned int *)this + 50);
    if ((_DWORD)v3)
    {
      v5 = 0;
      v6 = 0;
      v7 = 4 * v3;
      do
      {
        v8 = *(unsigned int *)(*((_QWORD *)this + 27) + v6);
        if ((_DWORD)v8)
          bzero(*(void **)(a2[1] + v5), v8);
        v6 += 4;
        v5 += 16;
      }
      while (v7 != v6);
    }
  }
}

_QWORD *NArray<bnns_graph_argument_t>::~NArray(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24C7F03B0;
  v2 = a1[1];
  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x10A2C808DAD38D9);
  return a1;
}

void NArray<bnns_graph_argument_t>::~NArray(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_24C7F03B0;
  v1 = a1[1];
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x10A2C808DAD38D9);
  JUMPOUT(0x212BAC9D8);
}

uint64_t NArray<bnns_graph_argument_t>::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  if (a1 != a2)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (v6)
      {
        MEMORY[0x212BAC9C0](v6, 0x10A2C808DAD38D9);
        v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 8) = operator new[]();
      v4 = *(_DWORD *)(a1 + 16);
    }
    if (v4)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        *(_OWORD *)(*(_QWORD *)(a1 + 8) + v7) = *(_OWORD *)(*(_QWORD *)(a2 + 8) + v7);
        ++v8;
        v7 += 16;
      }
      while (v8 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

__n128 NArray<bnns_graph_argument_t>::fromArray(uint64_t a1, uint64_t a2, int *a3)
{
  int v5;
  int v6;
  uint64_t v7;
  __n128 result;
  uint64_t v10;
  unint64_t v11;

  v5 = *(_DWORD *)(a1 + 16);
  v6 = *a3;
  if (v5 != *a3)
  {
    v7 = *(_QWORD *)(a1 + 8);
    if (v7)
    {
      MEMORY[0x212BAC9C0](v7, 0x10A2C808DAD38D9);
      v6 = *a3;
    }
    *(_DWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 8) = operator new[]();
    v5 = *(_DWORD *)(a1 + 16);
  }
  if (v5)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      result = *(__n128 *)(a2 + v10);
      *(__n128 *)(*(_QWORD *)(a1 + 8) + v10) = result;
      ++v11;
      v10 += 16;
    }
    while (v11 < *(unsigned int *)(a1 + 16));
  }
  return result;
}

uint64_t NArray<bnns_graph_argument_t>::resize(uint64_t result, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  unint64_t v8;

  v2 = *(unsigned int *)(result + 16);
  if ((_DWORD)v2 != *a2)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 16) = *a2;
    result = operator new[]();
    *(_QWORD *)(v4 + 8) = result;
    if ((_DWORD)v2)
      v6 = *a2 == 0;
    else
      v6 = 1;
    if (!v6)
    {
      v7 = 0;
      v8 = 1;
      do
      {
        *(_OWORD *)(*(_QWORD *)(v4 + 8) + v7) = *(_OWORD *)(v5 + v7);
        if (v8 >= v2)
          break;
        v7 += 16;
      }
      while (v8++ < *a2);
LABEL_12:
      JUMPOUT(0x212BAC9C0);
    }
    if (v5)
      goto LABEL_12;
  }
  return result;
}

uint64_t NBNNSIRDistribution::scoreAll(NArray<float> const&,NArray<float>&,void *)const::$_0::__invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((_DWORD)result == 8 && a2 && a4)
  {
    result = *(_QWORD *)(a4 + 8);
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  }
  return result;
}

uint64_t NBNNSIRDistribution::determineStateWiring(NBNNSIRDistribution *this, const void *a2, const char *a3, const NString *a4)
{
  unint64_t InputCount;
  const char *v8;
  unint64_t v9;
  unint64_t OutputCount;
  __n128 v11;
  unsigned int v12;
  unint64_t v13;
  char *v14;
  size_t v15;
  __n128 v16;
  unint64_t v17;
  size_t v18;
  const char *v19;
  const char *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  __int128 *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  int *v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;
  _OWORD *v45;
  __int128 *v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  int *v52;
  int v53;
  unint64_t v54;
  uint64_t v55;
  _BYTE *v56;
  uint64_t v57;
  unsigned int v58;
  unsigned int v59;
  const char *v60;
  unint64_t ArgumentPosition;
  const char *v62;
  const char *v63;
  unint64_t v64;
  unsigned int v65;
  const char *v66;
  uint64_t v67;
  void *v69;
  unsigned int v70;
  unint64_t v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  unsigned int v75;
  const char *v76;
  const char *v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  const char *v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  _BYTE *v89;
  unint64_t v90;
  const char *v92;
  const NString *v93;
  const char *v94;
  const char *v95;
  uint64_t v96;
  const char *v97;
  _QWORD v98[3];
  const char *v99;
  const char *v100;
  const NString *v101;
  _BYTE *v102;
  NBNNSIRDistribution *v103;
  unsigned int v104;
  unsigned int *v105;
  unint64_t *v106;
  unsigned int v107;
  uint64_t v108;
  unint64_t v109;
  char *v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  char *v114;
  const void *v115;
  char *v116;
  size_t v117;
  uint64_t (**v118)(NString *__hidden, const unsigned int *);
  unsigned int v119;
  void *v120;
  uint64_t (**v121)(NString *__hidden, const unsigned int *);
  int v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  int64x2_t v128;
  int64x2_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  uint64_t v133;

  v133 = *MEMORY[0x24BDAC8D0];
  v115 = a2;
  InputCount = BNNSGraphGetInputCount();
  if (InputCount == -1)
    goto LABEL_138;
  v9 = InputCount;
  if (InputCount >= 0xFFFFFFFF80000000)
  {
LABEL_139:
    v96 = *((_QWORD *)a4 + 2);
    v97 = "BNNSIR Sizes >= 2^31";
    goto LABEL_141;
  }
  OutputCount = BNNSGraphGetOutputCount();
  if (OutputCount == -1)
  {
LABEL_138:
    v96 = *((_QWORD *)a4 + 2);
    v97 = "Invalid BNNSIR";
    goto LABEL_141;
  }
  v12 = OutputCount;
  if (OutputCount >= 0xFFFFFFFF80000000)
    goto LABEL_139;
  if (!(_DWORD)v9 || (_DWORD)v9 != (_DWORD)OutputCount)
  {
    v96 = *((_QWORD *)a4 + 2);
    v97 = "Currently only support numinputs=numoutputs";
LABEL_141:
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v8, v97, v96);
  }
  MEMORY[0x24BDAC7A8](v11);
  v14 = (char *)v98 - ((v13 + 15) & 0xFFFFFFFF0);
  if (v13 >= 0x200)
    v15 = 512;
  else
    v15 = v13;
  bzero((char *)v98 - ((v13 + 15) & 0xFFFFFFFF0), v15);
  v117 = v12;
  MEMORY[0x24BDAC7A8](v16);
  if (v17 >= 0x200)
    v18 = 512;
  else
    v18 = v17;
  v116 = (char *)v98 - ((v17 + 15) & 0xFFFFFFFF0);
  bzero(v116, v18);
  v108 = v9;
  v110 = v14;
  if (BNNSGraphGetInputNames_v2())
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v19, "BNNSGraphGetInputNames failed", *((_QWORD *)a4 + 2));
  if (BNNSGraphGetOutputNames_v2())
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v20, "BNNSGraphGetOutputNames failed", *((_QWORD *)a4 + 2));
  v21 = 2 * v9;
  v22 = *((_DWORD *)this + 50);
  v23 = 2 * v9;
  if (v22 != 2 * (_DWORD)v9)
  {
    v24 = *((_QWORD *)this + 24);
    *((_DWORD *)this + 50) = v21;
    v25 = operator new[]();
    *((_QWORD *)this + 24) = v25;
    if (v22 >= v21)
      v26 = v21;
    else
      v26 = v22;
    if ((_DWORD)v26)
    {
      v27 = 0;
      if (v26 < 8)
        goto LABEL_25;
      if ((unint64_t)(v25 - v24) <= 0x1F)
        goto LABEL_25;
      v27 = v26 & 0xFFFFFFF8;
      v28 = (_OWORD *)(v25 + 16);
      v29 = (__int128 *)(v24 + 16);
      v30 = v27;
      do
      {
        v31 = *v29;
        *(v28 - 1) = *(v29 - 1);
        *v28 = v31;
        v28 += 2;
        v29 += 2;
        v30 -= 8;
      }
      while (v30);
      if (v27 != v26)
      {
LABEL_25:
        v32 = v26 - v27;
        v33 = 4 * v27;
        v34 = (_DWORD *)(v25 + 4 * v27);
        v35 = (int *)(v24 + v33);
        do
        {
          v36 = *v35++;
          *v34++ = v36;
          --v32;
        }
        while (v32);
      }
    }
    else if (!v24)
    {
LABEL_30:
      v23 = *((_DWORD *)this + 50);
      goto LABEL_31;
    }
    MEMORY[0x212BAC9C0](v24, 0x1000C8052888210);
    goto LABEL_30;
  }
LABEL_31:
  if (v23)
  {
    v37 = 0;
    v38 = *((_QWORD *)this + 24);
    do
      *(_DWORD *)(v38 + 4 * v37++) = -1;
    while (v37 < *((unsigned int *)this + 50));
  }
  v39 = *((_DWORD *)this + 56);
  if (v39 == v21)
    goto LABEL_53;
  v40 = *((_QWORD *)this + 27);
  *((_DWORD *)this + 56) = v21;
  v41 = operator new[]();
  *((_QWORD *)this + 27) = v41;
  if (v39 >= v21)
    v42 = v21;
  else
    v42 = v39;
  if (!(_DWORD)v42)
  {
    if (!v40)
      goto LABEL_52;
    goto LABEL_51;
  }
  if (v42 >= 8 && (unint64_t)(v41 - v40) > 0x1F)
  {
    v44 = v42 & 0xFFFFFFF8;
    v45 = (_OWORD *)(v41 + 16);
    v46 = (__int128 *)(v40 + 16);
    v47 = v44;
    do
    {
      v48 = *v46;
      *(v45 - 1) = *(v46 - 1);
      *v45 = v48;
      v45 += 2;
      v46 += 2;
      v47 -= 8;
    }
    while (v47);
    if (v44 == v42)
      goto LABEL_51;
  }
  else
  {
    v44 = 0;
  }
  v49 = v42 - v44;
  v50 = 4 * v44;
  v51 = (_DWORD *)(v41 + 4 * v44);
  v52 = (int *)(v40 + v50);
  do
  {
    v53 = *v52++;
    *v51++ = v53;
    --v49;
  }
  while (v49);
LABEL_51:
  MEMORY[0x212BAC9C0](v40, 0x1000C8052888210);
LABEL_52:
  v21 = *((_DWORD *)this + 56);
LABEL_53:
  if (v21)
  {
    v54 = 0;
    v55 = *((_QWORD *)this + 27);
    do
      *(_DWORD *)(v55 + 4 * v54++) = 0;
    while (v54 < *((unsigned int *)this + 56));
  }
  v56 = (_BYTE *)operator new[]();
  v101 = a4;
  v102 = v56;
  bzero(v56, v117);
  v57 = 0;
  v111 = 0;
  v112 = 0;
  v105 = &v119;
  v106 = &v126;
  v58 = -1;
  v98[2] = "BNNSGraphGetTensorDescriptor failed";
  v99 = "Invalid BNNSIR";
  v100 = "input dimension >2";
  v59 = -1;
  v103 = this;
  v113 = a3;
  v109 = v9;
  do
  {
    v107 = v59;
    v60 = *(const char **)&v110[8 * v57];
    ArgumentPosition = BNNSGraphGetArgumentPosition();
    v59 = ArgumentPosition;
    if (ArgumentPosition == -1)
      goto LABEL_126;
    if (ArgumentPosition >= 0xFFFFFFFF80000000)
    {
      v99 = "BNNSIR Sizes >= 2^31";
LABEL_126:
      Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v62, v99, *((_QWORD *)v101 + 2));
    }
    if (BNNSGraphGetTensorDescriptor_v2())
    {
      v93 = v101;
      v92 = "BNNSGraphGetTensorDescriptor failed";
LABEL_130:
      Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v63, v92, *((_QWORD *)v93 + 2));
    }
    if (*(_DWORD *)(*((_QWORD *)this + 27) + 4 * v59))
    {
      v92 = "tensor arg position already set";
      v93 = v101;
      goto LABEL_130;
    }
    v64 = MEMORY[0x212BAC660](&v125);
    if (v64 == -1)
    {
      v92 = "Invalid BNNSIR";
      v93 = v101;
      goto LABEL_130;
    }
    if (v64 > 0xFFFFFFFF7FFFFFFFLL)
    {
      v92 = "BNNSIR Sizes >= 2^31";
      v93 = v101;
      goto LABEL_130;
    }
    *(_DWORD *)(*((_QWORD *)this + 27) + 4 * v59) = v64;
    if (!(_DWORD)v64)
    {
      v92 = "tensor has zero size";
      v93 = v101;
      goto LABEL_130;
    }
    if (!v60)
      Error::chuck((Error *)"Null pointer passed to string constructor", v63);
    v65 = strlen(v60);
    v114 = (char *)operator new[]();
    memcpy(v114, v60, v65 + 1);
    v67 = v65 - 3;
    if (v65 >= 3 && *(_WORD *)&v114[v67] == 26975 && v114[v67 + 2] == 110)
    {
      v104 = v58;
      v118 = &off_24C7F32C0;
      v119 = v65 - 3;
      v69 = (void *)operator new[]();
      v120 = v69;
      memcpy(v69, v114, v65 - 3);
      *((_BYTE *)v69 + v67) = 0;
      v121 = &off_24C7F32C0;
      v122 = 4;
      v123 = (char *)operator new[]();
      strcpy(v123, "_out");
      NString::operator+((uint64_t)&v118, (uint64_t)&v121, (uint64_t)&v124);
    }
    v70 = v109;
    if (v58 < v109)
    {
      v94 = "more than one external input identified";
LABEL_133:
      v100 = v94;
LABEL_134:
      Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v66, v100, *((_QWORD *)v101 + 2));
    }
    if (v132 != 65568)
    {
      v94 = "input not float32 type";
      goto LABEL_133;
    }
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(v128), (int32x4_t)vceqzq_s64(v129))))) & 1) != 0|| v130|| v131)
    {
      goto LABEL_134;
    }
    v71 = v127;
    if (v127)
      v72 = v126;
    else
      v72 = 1;
    if (!v127)
      v71 = v126;
    v111 = v71;
    v112 = v72;
    v58 = v57;
    MEMORY[0x212BAC9C0](v114, 0x1000C8077774924);
    ++v57;
  }
  while (v57 != v108);
  if (v58 >= v70)
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v73, "no external input identified", *((_QWORD *)v101 + 2));
  v74 = 0;
  v75 = -1;
  do
  {
    if (!v102[v74])
    {
      if (v75 < v70)
        Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v73, "more than one external output identified", *((_QWORD *)v101 + 2));
      v75 = v74;
    }
    ++v74;
  }
  while (v117 != v74);
  if (v75 >= v70)
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v73, "no external output identified", *((_QWORD *)v101 + 2));
  if (BNNSGraphGetTensorDescriptor_v2())
  {
    v77 = "BNNSGraphGetTensorDescriptor failed";
    goto LABEL_148;
  }
  if (v132 != 65568)
  {
    v77 = "output not float32 type";
    goto LABEL_148;
  }
  v77 = "output dimension >2";
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(v128), (int32x4_t)vceqzq_s64(v129))))) & 1) != 0|| v130|| v131)
  {
LABEL_148:
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v76, v77, *((_QWORD *)v101 + 2));
  }
  if (v127)
    v78 = v126;
  else
    v78 = 1;
  if (v127)
    v79 = v127;
  else
    v79 = v126;
  v80 = BNNSGraphGetArgumentPosition();
  v82 = v80;
  v84 = v111;
  v83 = v112;
  if (v80 == -1)
    goto LABEL_135;
  if (v80 > 0xFFFFFFFF7FFFFFFFLL)
    goto LABEL_136;
  v85 = *((_QWORD *)this + 27);
  *(_DWORD *)(v85 + 4 * v59) = 0;
  *(_DWORD *)(v85 + 4 * v80) = 0;
  v86 = *((_DWORD *)this + 50);
  if (v86 <= 2)
  {
    if (v86)
    {
      v87 = *((_QWORD *)this + 24);
      *((_DWORD *)this + 50) = 0;
      *((_QWORD *)this + 24) = operator new[]();
      if (v87)
        MEMORY[0x212BAC9C0](v87, 0x1000C8052888210);
    }
    if (*((_DWORD *)this + 56))
    {
      v88 = *((_QWORD *)this + 27);
      *((_DWORD *)this + 56) = 0;
      *((_QWORD *)this + 27) = operator new[]();
      if (v88)
        MEMORY[0x212BAC9C0](v88, 0x1000C8052888210);
    }
  }
  if (v79 == -1)
    goto LABEL_135;
  v89 = v102;
  if (v79 > 0xFFFFFFFF7FFFFFFFLL)
    goto LABEL_136;
  *((_DWORD *)this + 38) = v79;
  if (v83 == -1)
  {
LABEL_135:
    v95 = "Invalid BNNSIR";
    goto LABEL_137;
  }
  if (v83 > 0xFFFFFFFF7FFFFFFFLL)
  {
LABEL_136:
    v95 = "BNNSIR Sizes >= 2^31";
LABEL_137:
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v81, v95, *((_QWORD *)v101 + 2));
  }
  *((_DWORD *)this + 40) = v83;
  if (v84 == -1)
    goto LABEL_135;
  if (v84 > 0xFFFFFFFF7FFFFFFFLL)
    goto LABEL_136;
  *((_DWORD *)this + 42) = v84;
  if (v78 == -1)
    goto LABEL_135;
  if (v78 > 0xFFFFFFFF7FFFFFFFLL)
    goto LABEL_136;
  *((_DWORD *)this + 41) = v78;
  v90 = v83 * v84;
  if (v83 * v84 == -1)
    goto LABEL_135;
  if (v90 >= 0xFFFFFFFF80000000)
    goto LABEL_136;
  *((_DWORD *)this + 39) = v90;
  *((_DWORD *)this + 43) = v59;
  *((_DWORD *)this + 44) = v82;
  return MEMORY[0x212BAC9C0](v89, 0x1000C8077774924);
}

void sub_20D9EDE14(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](*(_QWORD *)(v1 + 144), 0x1000C8077774924);
  MEMORY[0x212BAC9C0](*(_QWORD *)(v1 + 48), 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NBNNSIRDistribution::NBNNSIRDistribution(NBNNSIRDistribution *this)
{
  char *v2;
  const char *v3;
  _BYTE *v4;
  const char *v5;
  _BYTE *v6;
  int v7;
  const char *v8;
  int v9;
  unint64_t v10;
  void *memptr;

  *(_QWORD *)this = &off_24C7F1ED0;
  *((_QWORD *)this + 1) = &off_24C7F17B0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = &off_24C7F2108;
  v2 = (char *)this + 32;
  *((_DWORD *)this + 14) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v3, 1, *((unsigned int *)this + 14));
  v4 = memptr;
  *((_QWORD *)this + 10) = &off_24C7F17B0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = v4;
  *((_QWORD *)this + 4) = &off_24C7F2108;
  *v4 = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = &off_24C7F2108;
  *((_DWORD *)this + 32) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v5, 1, *((unsigned int *)this + 32));
  v6 = memptr;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 15) = v6;
  *((_QWORD *)this + 13) = &off_24C7F2108;
  *v6 = 0;
  *((_DWORD *)this + 34) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 44) = 0;
  *((_QWORD *)this + 23) = &off_24C7F3100;
  *((_QWORD *)this + 24) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_QWORD *)this + 26) = &off_24C7F3100;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  v7 = getpagesize();
  if (v7 <= 0)
    Error::chuck((Error *)"NBNNSIRDistribution::NBNNSIRDistribution() - cannot determine page size for allocation", v8);
  v9 = v7;
  *((_DWORD *)this + 14) = v7;
  v10 = v7;
  if (*((_QWORD *)this + 6) % (unint64_t)v7)
  {
    LODWORD(memptr) = *((_DWORD *)this + 10);
    (*(void (**)(char *))(*((_QWORD *)this + 4) + 64))(v2);
  }
  *((_DWORD *)this + 32) = v9;
  if (*((_QWORD *)this + 15) % v10)
  {
    LODWORD(memptr) = *((_DWORD *)this + 28);
    (*(void (**)(char *))(*((_QWORD *)this + 13) + 64))((char *)this + 104);
  }
}

void sub_20D9EE21C(_Unwind_Exception *a1)
{
  NLoadedMemory *v1;
  _QWORD *v2;
  NLoadedMemory *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v2[26] = v4;
  v6 = v2[27];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8052888210);
  v2[23] = v4;
  v7 = v2[24];
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8052888210);
  NLoadedMemory::~NLoadedMemory(v3);
  NLoadedMemory::~NLoadedMemory(v1);
  _Unwind_Resume(a1);
}

uint64_t NBNNSIRDistribution::reset(NBNNSIRDistribution *this)
{
  size_t v2;
  size_t v3;
  char *v4;
  uint64_t v5;
  uint64_t result;
  int v7;
  int v8;

  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  v2 = *((unsigned int *)this + 16);
  if ((_DWORD)v2)
    munmap(*((void **)this + 9), v2);
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = 0;
  v7 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 4) + 64))((char *)this + 32, "", &v7);
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = 0;
  v3 = *((unsigned int *)this + 34);
  if ((_DWORD)v3)
    munmap(*((void **)this + 18), v3);
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = 0;
  v8 = 0;
  v5 = *((_QWORD *)this + 13);
  v4 = (char *)this + 104;
  result = (*(uint64_t (**)(char *, const char *, int *))(v5 + 64))(v4, "", &v8);
  *((_QWORD *)v4 + 6) = 0;
  *((_DWORD *)v4 + 14) = 0;
  *((_DWORD *)v4 + 16) = 0;
  return result;
}

uint64_t NBNNSIRDistribution::setWeightsFile(NBNNSIRDistribution *this, const NString *a2)
{
  size_t v4;
  int v5;

  if (*((_DWORD *)a2 + 2))
    return NLoadedMemory::load((NBNNSIRDistribution *)((char *)this + 80), a2);
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = 0;
  v4 = *((unsigned int *)this + 34);
  if ((_DWORD)v4)
    munmap(*((void **)this + 18), v4);
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = 0;
  v5 = 0;
  return (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 13) + 64))((char *)this + 104, "", &v5);
}

uint64_t NBNNSIRDistribution::getDimensions(NBNNSIRDistribution *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v5;

  if (a2[2])
    return 0;
  if (a2[3])
    return 0;
  if (a2[4])
    return 0;
  if (a2[5])
    return 0;
  if (a2[6])
    return 0;
  if (a2[7])
    return 0;
  if (a2[1])
    v5 = *a2++;
  else
    v5 = 1;
  *a3 = v5;
  *a4 = *a2;
  return 1;
}

uint64_t NBNNSIRDistribution::flipStateOutputsToInputs(uint64_t this, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2)
  {
    v2 = *(unsigned int *)(this + 200);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 0;
      do
      {
        v5 = *(unsigned int *)(*(_QWORD *)(this + 192) + v4);
        if (v5 < v2)
        {
          v6 = a2[1];
          v7 = *(_QWORD *)(v6 + v3);
          v8 = 16 * v5;
          *(_QWORD *)(v6 + v3) = *(_QWORD *)(v6 + v8);
          *(_QWORD *)(a2[1] + v8) = v7;
        }
        v4 += 4;
        v3 += 16;
      }
      while (4 * v2 != v4);
    }
  }
  return this;
}

void sub_20D9F0478(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_20D9F07AC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  NSObject *v9;

  __cxa_begin_catch(a1);
  v9 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_20D965000, v9, OS_LOG_TYPE_DEFAULT, "recognizeWavData failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20D9F079CLL);
}

void sub_20D9F0C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_20D9F0DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_20D9F1040(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_20D9F13F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9F16B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_20D9F1854(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9F18E0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  NSObject *v9;

  __cxa_begin_catch(a1);
  v9 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_20D965000, v9, OS_LOG_TYPE_DEFAULT, "endAudio failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20D9F18D0);
}

void sub_20D9F196C(void *a1)
{
  NSObject *v1;
  __int16 v2;

  __cxa_begin_catch(a1);
  v1 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    v2 = 0;
    _os_log_impl(&dword_20D965000, v1, OS_LOG_TYPE_DEFAULT, "runRecognition failed", (uint8_t *)&v2, 2u);
  }
  __cxa_end_catch();
}

void sub_20D9F1B60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *N16ByteAlignedString::allocate(N16ByteAlignedString *this, const unsigned int *a2)
{
  const char *v4;
  void *memptr;

  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, *((unsigned int *)this + 6), *a2 + 1, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v4, *a2 + 1, *((unsigned int *)this + 6));
  return memptr;
}

void N16ByteAlignedString::deallocate(N16ByteAlignedString *this, char *a2)
{
  free(a2);
}

void N16ByteAlignedString::~N16ByteAlignedString(void **this)
{
  *this = &off_24C7F2108;
  free(this[2]);
  this[2] = 0;
  *this = &off_24C7F32C0;
}

{
  *this = &off_24C7F2108;
  free(this[2]);
  this[2] = 0;
  *this = &off_24C7F32C0;
  JUMPOUT(0x212BAC9D8);
}

{
  *this = &off_24C7F2108;
  free(this[2]);
  this[2] = 0;
  *this = &off_24C7F32C0;
}

uint64_t N16ByteAlignedString::allocate2(N16ByteAlignedString *this, const unsigned int *a2, const unsigned int *a3)
{
  if (*a3)
    *((_DWORD *)this + 6) = *a3;
  return (**(uint64_t (***)(N16ByteAlignedString *, const unsigned int *))this)(this, a2);
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this)
{
  const char *v2;
  _BYTE *v3;
  void *memptr;

  *(_QWORD *)this = &off_24C7F2108;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 6));
  v3 = memptr;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = v3;
  *(_QWORD *)this = &off_24C7F2108;
  *v3 = 0;
}

{
  const char *v2;
  _BYTE *v3;
  void *memptr;

  *(_QWORD *)this = &off_24C7F2108;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 6));
  v3 = memptr;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = v3;
  *(_QWORD *)this = &off_24C7F2108;
  *v3 = 0;
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const N16ByteAlignedString *a2)
{
  int v4;
  void *v5;
  unsigned int v6;

  *(_QWORD *)this = &off_24C7F2108;
  v6 = *((_DWORD *)a2 + 2);
  v4 = *((_DWORD *)a2 + 6);
  if (v4)
    *((_DWORD *)this + 6) = v4;
  v5 = N16ByteAlignedString::allocate(this, &v6);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 2) = v5;
  *(_QWORD *)this = &off_24C7F2108;
  memcpy(v5, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

{
  int v4;
  void *v5;
  unsigned int v6;

  *(_QWORD *)this = &off_24C7F2108;
  v6 = *((_DWORD *)a2 + 2);
  v4 = *((_DWORD *)a2 + 6);
  if (v4)
    *((_DWORD *)this + 6) = v4;
  v5 = N16ByteAlignedString::allocate(this, &v6);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 2) = v5;
  *(_QWORD *)this = &off_24C7F2108;
  memcpy(v5, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const NString *a2)
{
  void *v4;
  unsigned int v5;

  *(_QWORD *)this = &off_24C7F2108;
  v5 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 6) = 16;
  v4 = N16ByteAlignedString::allocate(this, &v5);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 2) = v4;
  *(_QWORD *)this = &off_24C7F2108;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

{
  void *v4;
  unsigned int v5;

  *(_QWORD *)this = &off_24C7F2108;
  v5 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 6) = 16;
  v4 = N16ByteAlignedString::allocate(this, &v5);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 2) = v4;
  *(_QWORD *)this = &off_24C7F2108;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const char *__s)
{
  const unsigned int *v3;
  void *v5;

  *((_DWORD *)this + 2) = 0;
  v3 = (const unsigned int *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F2108;
  if (!__s)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  *((_DWORD *)this + 2) = strlen(__s);
  *((_DWORD *)this + 6) = 16;
  v5 = N16ByteAlignedString::allocate(this, v3);
  *((_QWORD *)this + 2) = v5;
  memcpy(v5, __s, (*((_DWORD *)this + 2) + 1));
}

{
  const unsigned int *v3;
  void *v5;

  *((_DWORD *)this + 2) = 0;
  v3 = (const unsigned int *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F2108;
  if (!__s)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  *((_DWORD *)this + 2) = strlen(__s);
  *((_DWORD *)this + 6) = 16;
  v5 = N16ByteAlignedString::allocate(this, v3);
  *((_QWORD *)this + 2) = v5;
  memcpy(v5, __s, (*((_DWORD *)this + 2) + 1));
}

void sub_20D9F2038(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &off_24C7F32C0;
  v3 = v1[2];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9F20FC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &off_24C7F32C0;
  v3 = v1[2];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const char *a2, const unsigned int *a3)
{
  const char *v5;
  void *v7;

  *((_DWORD *)this + 2) = 0;
  v5 = (char *)this + 8;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F2108;
  if (!a2)
    Error::chuck((Error *)"Null pointer passed to string constructor", v5, a3);
  *((_DWORD *)this + 2) = *a3;
  *((_DWORD *)this + 6) = 16;
  v7 = N16ByteAlignedString::allocate(this, (const unsigned int *)v5);
  *((_QWORD *)this + 2) = v7;
  memcpy(v7, a2, *a3);
  *(_BYTE *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

{
  const char *v5;
  void *v7;

  *((_DWORD *)this + 2) = 0;
  v5 = (char *)this + 8;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F2108;
  if (!a2)
    Error::chuck((Error *)"Null pointer passed to string constructor", v5, a3);
  *((_DWORD *)this + 2) = *a3;
  *((_DWORD *)this + 6) = 16;
  v7 = N16ByteAlignedString::allocate(this, (const unsigned int *)v5);
  *((_QWORD *)this + 2) = v7;
  memcpy(v7, a2, *a3);
  *(_BYTE *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

{
  const char *v6;
  void *v7;
  size_t v8;
  void *memptr;

  *(_QWORD *)this = &off_24C7F2108;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, *a3 + 1, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v6, *a3 + 1, *((unsigned int *)this + 6));
  v7 = memptr;
  v8 = *a3;
  *((_DWORD *)this + 2) = v8;
  *((_QWORD *)this + 2) = v7;
  *(_QWORD *)this = &off_24C7F2108;
  memset(v7, *(unsigned __int8 *)a2, v8);
  *(_BYTE *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

{
  const char *v6;
  void *v7;
  size_t v8;
  void *memptr;

  *(_QWORD *)this = &off_24C7F2108;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, *a3 + 1, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v6, *a3 + 1, *((unsigned int *)this + 6));
  v7 = memptr;
  v8 = *a3;
  *((_DWORD *)this + 2) = v8;
  *((_QWORD *)this + 2) = v7;
  *(_QWORD *)this = &off_24C7F2108;
  memset(v7, *(unsigned __int8 *)a2, v8);
  *(_BYTE *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

void sub_20D9F21C4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &off_24C7F32C0;
  v3 = v1[2];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9F228C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v3;

  *v1 = &off_24C7F32C0;
  v3 = v1[2];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t N16ByteAlignedString::setAlignment(uint64_t this, unsigned int *a2)
{
  unsigned int v2;
  int v3;

  v2 = *a2;
  if (*a2)
    *(_DWORD *)(this + 24) = v2;
  else
    v2 = *(_DWORD *)(this + 24);
  if (*(_QWORD *)(this + 16) % (unint64_t)v2)
  {
    v3 = *(_DWORD *)(this + 8);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 64))(this);
  }
  return this;
}

void sub_20D9F42BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 216), 8);
  _Unwind_Resume(a1);
}

void sub_20D9F6948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4411(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4412(uint64_t a1)
{

}

void sub_20D9F9F3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_20D9FA1C0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not reset NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not reset NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not reset NDAPI : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FA190);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FA35C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not resetbest NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not resetbest NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not resetbest NDAPI : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FA32CLL);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FA500(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not analyze wavdata : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not analyze wavdata : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not analyze wavdata : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FA4D0);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FA69C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not analize wavdata : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not analize wavdata : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not analize wavdata : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FA66CLL);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FABFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9FAC80(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not get super vector : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not get super vector : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not get super vector : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FAC50);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FB048(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not update sat : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not update sat : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not update sat : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FB018);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FB1EC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not get score of super vector : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not get score of super vector : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not get score of super vector : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FB1BCLL);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FB390(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  void *v10;
  void *v11;
  uint64_t (*v12)(void *);
  NSObject *v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _QWORD *v17;
  NSObject *v18;
  uint64_t v19;

  if (a2)
  {
    if (a2 == 3)
    {
      v10 = __cxa_begin_catch(a1);
      v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v12 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
        v13 = v11;
        v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "Could not delete SAT vector : %{public}s", (uint8_t *)&a9, 0xCu);

      }
    }
    else
    {
      v15 = __cxa_begin_catch(a1);
      v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v17 = v15;
        v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(_QWORD *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not delete SAT vector  : %{public}s", (uint8_t *)&a9, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_20D965000, v16, OS_LOG_TYPE_ERROR, "Could not delete SAT vector  : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FB360);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FB5A4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf)
{
  void *v12;
  void *v13;
  uint64_t (*v14)(void *);
  NSObject *v15;
  uint64_t v16;
  _QWORD *v17;
  NSObject *v18;
  _QWORD *v19;
  NSObject *v20;
  uint64_t v21;

  if (a2)
  {
    if (a2 == 3)
    {
      v12 = __cxa_begin_catch(a1);
      v13 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        v14 = *(uint64_t (**)(void *))(*(_QWORD *)v12 + 16);
        v15 = v13;
        v16 = v14(v12);
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = v16;
        _os_log_error_impl(&dword_20D965000, v15, OS_LOG_TYPE_ERROR, "Could not get SAT vector count : %{public}s", (uint8_t *)&buf, 0xCu);

      }
    }
    else
    {
      v17 = __cxa_begin_catch(a1);
      v18 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        v19 = v17;
        v20 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          v21 = v19[2];
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = v21;
          _os_log_error_impl(&dword_20D965000, v20, OS_LOG_TYPE_ERROR, "Could not get SAT vector count : %{public}s", (uint8_t *)&buf, 0xCu);
        }

      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl(&dword_20D965000, v18, OS_LOG_TYPE_ERROR, "Could not get SAT vector count : unknown reason", (uint8_t *)&buf, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x20D9FB554);
  }
  _Unwind_Resume(a1);
}

void sub_20D9FB738(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9FB7B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9FB828(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20D9FBB10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_20D9FBC24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_20D9FBD40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_20D9FBE78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_20D9FBF30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  void *v10;
  void *v11;
  _QWORD *v12;
  NSObject *v13;
  _QWORD *v14;
  NSObject *v15;
  uint64_t (*v16)(void *);
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;

  if (!a2)
    _Unwind_Resume(exception_object);
  if (a2 == 3)
  {
    v10 = __cxa_begin_catch(exception_object);
    v11 = (void *)VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      v16 = *(uint64_t (**)(void *))(*(_QWORD *)v10 + 16);
      v17 = v11;
      v18 = v16(v10);
      LODWORD(a9) = 136446210;
      *(_QWORD *)((char *)&a9 + 4) = v18;
      _os_log_error_impl(&dword_20D965000, v17, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&a9, 0xCu);

    }
  }
  else
  {
    v12 = __cxa_begin_catch(exception_object);
    v13 = VTLogContextFacilityVoiceTrigger;
    if (a2 == 2)
    {
      v14 = v12;
      v15 = (id)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v19 = v14[2];
        LODWORD(a9) = 136446210;
        *(_QWORD *)((char *)&a9 + 4) = v19;
        _os_log_error_impl(&dword_20D965000, v15, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&a9, 0xCu);
      }

      __cxa_end_catch();
LABEL_14:
      JUMPOUT(0x20D9FBEF4);
    }
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(a9) = 0;
      _os_log_error_impl(&dword_20D965000, v13, OS_LOG_TYPE_ERROR, "unknown reason", (uint8_t *)&a9, 2u);
    }
  }
  __cxa_end_catch();
  goto LABEL_14;
}

void sub_20D9FC220(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_20D9FC4E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void NConfigSection::NConfigSection(NConfigSection *this, const NString *a2)
{
  void *v4;
  unsigned int v5;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
  v5 = 10;
  *((_QWORD *)this + 3) = &off_24C7F2AB0;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)this + 32, &v5, 0);
}

{
  void *v4;
  unsigned int v5;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
  v5 = 10;
  *((_QWORD *)this + 3) = &off_24C7F2AB0;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)this + 32, &v5, 0);
}

void sub_20D9FC934(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *v1 = v2;
  v4 = v1[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20D9FC9F8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *v1 = v2;
  v4 = v1[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NConfigSection::sOpt(NConfigSection *this, const NString *a2)
{
  char *v4;
  const char *v5;

  v4 = (char *)this + 24;
  if (!NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v5, *((_QWORD *)a2 + 2), *((_QWORD *)this + 2));
  return NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
}

BOOL NMap<NString,NString>::contains(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  size_t v5;
  char *v6;
  _BYTE *v7;
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  size_t v12;
  int v13;
  uint64_t v14;
  _BOOL8 v15;

  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v5 = *(unsigned int *)(a2 + 8);
  v6 = (char *)operator new[]();
  memcpy(v6, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v7 = (_BYTE *)operator new[]();
  *v7 = *v4;
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v9 = *(_DWORD *)(a1 + 28);
  if (!v9)
    Error::chuck((Error *)"NHash::contains() - zero length hash table", v8);
  v10 = 0;
  if ((_DWORD)v5)
  {
    v11 = v6;
    v12 = v5;
    do
    {
      v13 = *v11++;
      v10 = v13 + 65599 * v10;
      --v12;
    }
    while (v12);
  }
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v10 % v9) + 8);
  if (v14)
  {
    do
    {
      if ((_DWORD)v5 == *(_DWORD *)(v14 + 24) && !memcmp(*(const void **)(v14 + 32), v6, v5))
        break;
      v14 = *(_QWORD *)(v14 + 8);
    }
    while (v14);
    v15 = v14 != 0;
  }
  else
  {
    v15 = 0;
  }
  MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  return v15;
}

void sub_20D9FCC04(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_20D9FCDF8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NConfigSection::iOpt(NConfigSection *this, const NString *a2)
{
  char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  const char *v11;
  char *__endptr;

  v4 = (char *)this + 24;
  if (!NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::iOpt() - Option '%s' not found in section '%s'", v5, *((_QWORD *)a2 + 2), *((_QWORD *)this + 2));
  v6 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
  if (!*(_DWORD *)(v6 + 8)
    || (v7 = v6,
        __endptr = 0,
        strtol(*(const char **)(v6 + 16), &__endptr, 10),
        __endptr != (char *)(*(_QWORD *)(v7 + 16) + *(unsigned int *)(v7 + 8))))
  {
    v10 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
    Error::chuck((Error *)"NConfigSection::iOpt() - Cannot extract integer from '%s' option %s.%s", v11, *(_QWORD *)(v10 + 16), *((_QWORD *)this + 2), *((_QWORD *)a2 + 2));
  }
  v8 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
  return strtol(*(const char **)(v8 + 16), 0, 10);
}

float NConfigSection::fOpt(NConfigSection *this, const NString *a2)
{
  char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  const char *v11;
  char *v12;

  v4 = (char *)this + 24;
  if (!NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::fOpt() - Option '%s' not found in section '%s'", v5, *((_QWORD *)a2 + 2), *((_QWORD *)this + 2));
  v6 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
  if (!*(_DWORD *)(v6 + 8)
    || (v7 = v6,
        v12 = 0,
        strtod(*(const char **)(v6 + 16), &v12),
        v12 != (char *)(*(_QWORD *)(v7 + 16) + *(unsigned int *)(v7 + 8))))
  {
    v10 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
    Error::chuck((Error *)"NConfigSection::fOpt() - Cannot extract float from '%s' option %s.%s", v11, *(_QWORD *)(v10 + 16), *((_QWORD *)this + 2), *((_QWORD *)a2 + 2));
  }
  v8 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
  return atof(*(const char **)(v8 + 16));
}

uint64_t NConfigSection::bOpt(NConfigSection *this, const NString *a2)
{
  char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  _DWORD *v9;
  unsigned __int16 *v10;
  int v12;
  int v13;
  const char *v16;

  v4 = (char *)this + 24;
  if (!NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::bOpt() - Option '%s' not found in section '%s'", v5, *((_QWORD *)a2 + 2), *((_QWORD *)this + 2));
  v6 = NMap<NString,NString>::operator[]((uint64_t)v4, (uint64_t)a2);
  v7 = v6;
  v8 = *(_DWORD *)(v6 + 8);
  if (v8 == 4)
  {
    v9 = *(_DWORD **)(v6 + 16);
    if (*v9 == 1702195828 || *v9 == 1702195796 || *v9 == 1163219540)
      return 1;
  }
  else if (v8 == 3)
  {
    v10 = *(unsigned __int16 **)(v6 + 16);
    if (*v10 == 25977 && *((_BYTE *)v10 + 2) == 115)
      return 1;
    v12 = *v10;
    v13 = *((unsigned __int8 *)v10 + 2);
    if (v12 == 25945 && v13 == 115)
      return 1;
  }
  else if (v8 == 1 && **(_BYTE **)(v6 + 16) == 49)
  {
    return 1;
  }
  if (NString::operator==(v6, "YES") || NString::operator==(v7, "T"))
    return 1;
  if (!NString::operator==(v7, "0")
    && !NString::operator==(v7, "false")
    && !NString::operator==(v7, "False")
    && !NString::operator==(v7, "FALSE")
    && !NString::operator==(v7, "no")
    && !NString::operator==(v7, "No")
    && !NString::operator==(v7, "NO")
    && !NString::operator==(v7, "F"))
  {
    Error::chuck((Error *)"NConfigSection::bOpt() - Cannot extract BOOL from '%s' option %s.%s", v16, *(_QWORD *)(v7 + 16), *((_QWORD *)this + 2), *((_QWORD *)a2 + 2));
  }
  return 0;
}

const NString *NConfigSection::sOptDefault(NConfigSection *this, const NString *a2, const NString *a3)
{
  char *v6;
  const char *v7;

  v6 = (char *)this + 24;
  if (!NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return a3;
  if (!NMap<NString,NString>::contains((uint64_t)v6, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::sOpt() - Option '%s' not found in section '%s'", v7, *((_QWORD *)a2 + 2), *((_QWORD *)this + 2));
  return (const NString *)NMap<NString,NString>::operator[]((uint64_t)v6, (uint64_t)a2);
}

BOOL NConfigSection::hasOpt(NConfigSection *this, const NString *a2)
{
  return NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2);
}

uint64_t NConfigSection::iOptDefault(NConfigSection *this, const NString *a2, const int *a3)
{
  if (NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return NConfigSection::iOpt(this, a2);
  else
    return *(unsigned int *)a3;
}

float NConfigSection::fOptDefault(NConfigSection *this, const NString *a2, const float *a3)
{
  if (NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return NConfigSection::fOpt(this, a2);
  else
    return *a3;
}

float NConfigSection::bOptDefault(NConfigSection *this, const NString *a2, const BOOL *a3)
{
  if (NMap<NString,NString>::contains((uint64_t)this + 24, (uint64_t)a2))
    return (float)NConfigSection::bOpt(this, a2);
  else
    return (float)*a3;
}

uint64_t NConfigSection::setOpt(NConfigSection *this, const NString *a2, const NString *a3)
{
  uint64_t v4;

  v4 = NMap<NString,NString>::operator[]((uint64_t)this + 24, (uint64_t)a2);
  return (*(uint64_t (**)(uint64_t, const NString *))(*(_QWORD *)v4 + 32))(v4, a3);
}

uint64_t NConfigSection::appendOpt(NConfigSection *this, const NString *a2, const NString *a3)
{
  uint64_t v4;

  v4 = NMap<NString,NString>::operator[]((uint64_t)this + 24, (uint64_t)a2);
  return (*(uint64_t (**)(uint64_t, const NString *))(*(_QWORD *)v4 + 48))(v4, a3);
}

void NConfig::NConfig(NConfig *this, const BOOL *a2)
{
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t (***v7)(NString *__hidden, const unsigned int *);
  uint64_t (***v8)(NString *__hidden, const unsigned int *);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t (**v14)(NString *__hidden, const unsigned int *);
  int v15;
  _BYTE *v16;
  uint64_t (**v17)(NString *__hidden, const unsigned int *);
  int v18;
  _BYTE *v19;
  uint64_t (**v20)();
  uint64_t (**v21)();
  uint64_t v22;
  uint64_t (**v23)(NString *__hidden, const unsigned int *);

  *(_QWORD *)this = &off_24C7F2A90;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0xB00000000;
  *((_QWORD *)this + 1) = &off_24C7F2B88;
  NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::resize((uint64_t)this + 8, (_DWORD *)this + 7);
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 40) = *a2;
  if (*a2)
  {
    v4 = (_BYTE *)operator new[]();
    *v4 = 0;
    v17 = &off_24C7F32C0;
    v18 = 0;
    v5 = (_BYTE *)operator new[]();
    *v5 = *v4;
    LODWORD(v14) = 10;
    v19 = v5;
    v20 = &off_24C7F2AB0;
    NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)&v21, (unsigned int *)&v14, 0);
    v14 = &off_24C7F32C0;
    v15 = 0;
    v6 = (_BYTE *)operator new[]();
    v16 = v6;
    *v6 = 0;
    v7 = (uint64_t (***)(NString *__hidden, const unsigned int *))NMap<NString,NConfigSection>::operator[]((uint64_t)this, (uint64_t)&v14);
    v8 = v7;
    if (v7 != &v17)
    {
      ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), _BYTE *, int *))(*v7)[8])(v7, v19, &v18);
      *(uint64_t (***)(NString *__hidden, const unsigned int *))((char *)v8 + 52) = v23;
      NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=((uint64_t)(v8 + 4), (uint64_t)&v21);
    }
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
    v20 = &off_24C7F2AB0;
    v21 = &off_24C7F2CA0;
    v9 = v22;
    if (v22)
    {
      v10 = *(_QWORD *)(v22 - 8);
      if (v10)
      {
        v11 = v22 + 32 * v10;
        v12 = v11;
        do
        {
          *(_QWORD *)(v12 - 32) = off_24C7F1480;
          v12 -= 32;
          for (i = *(_QWORD *)(v12 + 8); i; i = *(_QWORD *)(v11 - 24))
          {
            *(_QWORD *)(v11 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v11 - 32) + 72))(v12);
          }
          *(_QWORD *)(v11 - 16) = 0;
          *(_DWORD *)(v11 - 8) = 0;
          v11 = v12;
        }
        while (v12 != v9);
      }
      MEMORY[0x212BAC9C0](v9 - 16, 0x10A1C80F4A7E088);
    }
    v17 = &off_24C7F32C0;
    if (v19)
      MEMORY[0x212BAC9C0](v19, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  }
}

void sub_20D9FD664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  _QWORD *v5;
  uint64_t v6;
  va_list va;

  va_start(va, a5);
  NConfigSection::~NConfigSection((NConfigSection *)va);
  MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  NMap<NString,NConfigSection>::~NMap(v5);
  _Unwind_Resume(a1);
}

uint64_t NMap<NString,NConfigSection>::operator[](uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  const char *v11;
  unsigned int v12;
  size_t v13;
  unsigned int v14;
  char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unsigned int v21;
  char *v22;
  int v23;
  size_t v24;
  unsigned int v25;
  char *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  void *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t j;
  void *__src;
  uint64_t (**v39)();
  uint64_t (**v40)();
  uint64_t v41;
  uint64_t (**v42)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**v45)(NString *__hidden, const unsigned int *);
  int v46;
  void *v47;
  _QWORD v48[2];
  uint64_t v49;
  unsigned int v50[3];

  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v5 = (_BYTE *)operator new[]();
  *v5 = *v4;
  v50[0] = 10;
  __src = v5;
  v39 = &off_24C7F2AB0;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)&v40, v50, 0);
  v42 = &off_24C7F32C0;
  LODWORD(__n) = *(_DWORD *)(a2 + 8);
  __s2 = (void *)operator new[]();
  memcpy(__s2, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v45 = &off_24C7F32C0;
  v46 = 0;
  v47 = (void *)operator new[]();
  memcpy(v47, __src, 1uLL);
  NMap<NString,NString>::NMap((uint64_t)v48, (uint64_t)&v39);
  v39 = &off_24C7F2AB0;
  v40 = &off_24C7F2CA0;
  v6 = v41;
  if (v41)
  {
    v7 = *(_QWORD *)(v41 - 8);
    if (v7)
    {
      v8 = v41 + 32 * v7;
      v9 = v8;
      do
      {
        *(_QWORD *)(v9 - 32) = off_24C7F1480;
        v9 -= 32;
        for (i = *(_QWORD *)(v9 + 8); i; i = *(_QWORD *)(v8 - 24))
        {
          *(_QWORD *)(v8 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v8 - 32) + 72))(v9);
        }
        *(_QWORD *)(v8 - 16) = 0;
        *(_DWORD *)(v8 - 8) = 0;
        v8 = v9;
      }
      while (v9 != v6);
    }
    MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80F4A7E088);
  }
  if (__src)
    MEMORY[0x212BAC9C0](__src, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v12 = *(_DWORD *)(a1 + 28);
  if (!v12)
  {
    v31 = "NHash::contains() - zero length hash table";
    goto LABEL_54;
  }
  v13 = __n;
  if ((_DWORD)__n)
  {
    v14 = 0;
    v15 = (char *)__s2;
    v16 = __n;
    do
    {
      v17 = *v15++;
      v14 = v17 + 65599 * v14;
      --v16;
    }
    while (v16);
  }
  else
  {
    v14 = 0;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v19 = *(_QWORD *)(v18 + 32 * (v14 % v12) + 8);
  if (v19)
  {
    v20 = __s2;
    while ((_DWORD)v13 != *(_DWORD *)(v19 + 24) || memcmp(*(const void **)(v19 + 32), v20, v13))
    {
      v19 = *(_QWORD *)(v19 + 8);
      if (!v19)
        goto LABEL_23;
    }
  }
  else
  {
LABEL_23:
    v21 = 0;
    if ((_DWORD)v13)
    {
      v22 = (char *)__s2;
      do
      {
        v23 = *v22++;
        v21 = v23 + 65599 * v21;
        --v13;
      }
      while (v13);
    }
    (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)(v18 + 32 * (v21 % v12)) + 32))(v18 + 32 * (v21 % v12), &v42);
    v12 = *(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 32);
  }
  if (!v12)
  {
    v31 = "NHash::get() - zero length hash table";
    goto LABEL_54;
  }
  v24 = __n;
  if ((_DWORD)__n)
  {
    v25 = 0;
    v26 = (char *)__s2;
    v27 = __n;
    do
    {
      v28 = *v26++;
      v25 = v28 + 65599 * v25;
      --v27;
    }
    while (v27);
  }
  else
  {
    v25 = 0;
  }
  v29 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v25 % v12) + 8);
  if (!v29)
  {
    v31 = "NLinkedList::get Attempted to get element that is not in list";
LABEL_54:
    Error::chuck((Error *)v31, v11);
  }
  v30 = __s2;
  v31 = "NLinkedList::get Attempted to get element that is not in list";
  while ((_DWORD)v24 != *(_DWORD *)(v29 + 24) || memcmp(*(const void **)(v29 + 32), v30, v24))
  {
    v29 = *(_QWORD *)(v29 + 8);
    if (!v29)
      goto LABEL_54;
  }
  v48[0] = &off_24C7F2AB0;
  v48[1] = &off_24C7F2CA0;
  v32 = v49;
  if (v49)
  {
    v33 = *(_QWORD *)(v49 - 8);
    if (v33)
    {
      v34 = v49 + 32 * v33;
      v35 = v34;
      do
      {
        *(_QWORD *)(v35 - 32) = off_24C7F1480;
        v35 -= 32;
        for (j = *(_QWORD *)(v35 + 8); j; j = *(_QWORD *)(v34 - 24))
        {
          *(_QWORD *)(v34 - 24) = *(_QWORD *)(j + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v34 - 32) + 72))(v35);
        }
        *(_QWORD *)(v34 - 16) = 0;
        *(_DWORD *)(v34 - 8) = 0;
        v34 = v35;
      }
      while (v35 != v32);
    }
    MEMORY[0x212BAC9C0](v32 - 16, 0x10A1C80F4A7E088);
  }
  v45 = &off_24C7F32C0;
  if (v47)
    MEMORY[0x212BAC9C0](v47, 0x1000C8077774924);
  v42 = &off_24C7F32C0;
  if (__s2)
    MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
  return v29 + 40;
}

void sub_20D9FDBD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t v23;
  uint64_t v24;

  if (a23)
    MEMORY[0x212BAC9C0](a23, 0x1000C8077774924);
  a18 = v24;
  if (a20)
    MEMORY[0x212BAC9C0](a20, 0x1000C8077774924);
  NConfigSection::~NConfigSection((NConfigSection *)&a10);
  MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_20D9FDC84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  NMap<NString,NConfigSection>::HashItem::~HashItem((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *NMap<NString,NConfigSection>::HashItem::~HashItem(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;

  a1[6] = &off_24C7F2AB0;
  a1[7] = &off_24C7F2CA0;
  v2 = a1[8];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1480;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  a1[3] = &off_24C7F32C0;
  v7 = a1[5];
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  *a1 = &off_24C7F32C0;
  v8 = a1[2];
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  return a1;
}

_QWORD *NHash<NMap<NString,NConfigSection>::HashItem>::~NHash(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  *a1 = &off_24C7F2C68;
  v2 = a1[1];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 - 8);
    if (v3)
    {
      v4 = v2 + 32 * v3;
      v5 = v4;
      do
      {
        *(_QWORD *)(v5 - 32) = off_24C7F1420;
        v5 -= 32;
        for (i = *(_QWORD *)(v5 + 8); i; i = *(_QWORD *)(v4 - 24))
        {
          *(_QWORD *)(v4 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 32) + 72))(v5);
        }
        *(_QWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 = v5;
      }
      while (v5 != v2);
    }
    MEMORY[0x212BAC9C0](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NHash<NMap<NString,NConfigSection>::HashItem>::~NHash(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  *a1 = &off_24C7F2C68;
  v1 = a1[1];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = v1 + 32 * v2;
      v4 = v3;
      do
      {
        *(_QWORD *)(v4 - 32) = off_24C7F1420;
        v4 -= 32;
        for (i = *(_QWORD *)(v4 + 8); i; i = *(_QWORD *)(v3 - 24))
        {
          *(_QWORD *)(v3 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v3 - 32) + 72))(v4);
        }
        *(_QWORD *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 = v4;
      }
      while (v4 != v1);
    }
    MEMORY[0x212BAC9C0](v1 - 16, 0x10A1C80F4A7E088);
  }
  JUMPOUT(0x212BAC9D8);
}

uint64_t NConfig::load(NConfig *this, const NString *a2, const NString *a3)
{
  _WORD *v6;
  const char *v7;
  uint64_t result;
  uint64_t (**v9)(NString *__hidden, const unsigned int *);
  uint64_t v10;
  uint64_t v11;
  uint64_t (**v12)();
  uint64_t v13;
  uint64_t (**v14[2])(NString *__hidden, const unsigned int *);
  uint64_t v15;

  v9 = &off_24C7F32C0;
  LODWORD(v10) = 1;
  v6 = (_WORD *)operator new[]();
  *v6 = 114;
  v13 = 0;
  v11 = (uint64_t)v6;
  v12 = (uint64_t (**)())&off_24C7F33E0;
  NFilePtr::open((NFilePtr *)&v12, a2, (const NString *)&v9);
  if (!v13)
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7, v9, v10);
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v13 + 56))(v14);
  NConfig::loadString(this, v14, a3, a2);
  v14[0] = &off_24C7F32C0;
  if (v15)
    MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  v12 = &off_24C7F17F8;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v9 = &off_24C7F32C0;
  result = v11;
  if (v11)
    return MEMORY[0x212BAC9C0](v11, 0x1000C8077774924);
  return result;
}

void sub_20D9FE068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  if (a13)
    (*(void (**)(uint64_t))(*(_QWORD *)a13 + 8))(a13);
  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

_BYTE *NConfig::loadString(NConfig *this, uint64_t (***a2)(NString *__hidden this, const unsigned int *), const NString *a3, const NString *a4)
{
  const char *v5;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  uint64_t (*v7)(NString *__hidden, const unsigned int *);
  uint64_t (*v8)(NString *__hidden, const unsigned int *);
  uint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  unsigned int v13;
  __int128 v14;
  const char *v15;
  uint64_t v16;
  uint64_t (**v17)(NString *__hidden, const unsigned int *);
  char *v18;
  size_t v19;
  const char *v20;
  char *v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  void *v27;
  int v28;
  const char *v29;
  const char *v30;
  unsigned int v31;
  _BYTE *v32;
  size_t v33;
  void *v34;
  const char *v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  _BYTE *v39;
  _BYTE *v40;
  unsigned int v41;
  int v42;
  const char *v44;
  char *v45;
  uint64_t v46;
  _BYTE *v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  _BYTE *v54;
  uint64_t v55;
  size_t v56;
  void *v57;
  unsigned int v58;
  int v59;
  int v60;
  void *v61;
  _QWORD *v62;
  int v63;
  unsigned int v64;
  _BYTE *v65;
  unsigned int v66;
  int v67;
  uint64_t v69;
  unsigned int v70;
  unsigned __int8 *v71;
  int v72;
  BOOL v74;
  int v75;
  BOOL v76;
  const char *v77;
  char *v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  char *v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  const char *v94;
  int v95;
  char *v96;
  uint64_t v97;
  char *v98;
  size_t v99;
  const char *v100;
  char *v101;
  size_t v102;
  size_t v103;
  size_t v104;
  uint64_t v105;
  void *v106;
  int v107;
  void *v108;
  _BYTE *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  void *v117;
  _BYTE *v118;
  size_t v119;
  size_t v120;
  void *v121;
  unsigned int *v122;
  unsigned int *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t i;
  void *v129;
  const char *v130;
  char *v131;
  uint64_t v132;
  _BYTE *v133;
  uint64_t v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  unsigned int v138;
  unsigned __int8 *v139;
  int v140;
  uint64_t v142;
  uint64_t v143;
  size_t v144;
  void *v145;
  const char *v146;
  char *v147;
  size_t v148;
  void *v149;
  const char *v150;
  char *v151;
  uint64_t v152;
  _BYTE *v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  uint64_t v157;
  uint64_t v158;
  size_t v159;
  void *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  _BYTE *result;
  char *v168;
  char *v169;
  char *v170;
  uint64_t v171;
  NString *v175;
  unsigned int v176[2];
  unsigned int v177;
  void *v178;
  uint64_t (**v179)();
  uint64_t (**v180)();
  uint64_t v181;
  uint64_t v182;
  uint64_t (**v183)(NString *__hidden, const unsigned int *);
  int v184;
  _WORD *v185;
  unsigned int v186[2];
  unsigned int v187;
  void *v188;
  uint64_t (**v189)(NString *__hidden, const unsigned int *);
  unsigned int v190;
  void *v191;
  uint64_t (**v192)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s;
  uint64_t (**v195)(NString *__hidden, const unsigned int *);
  int v196;
  _BYTE *v197;
  uint64_t (**v198)();
  uint64_t v199;
  int v200;
  uint64_t (***v201)(NString *__hidden, const unsigned int *);
  uint64_t (**v202)(NString *__hidden, const unsigned int *);
  int v203;
  char *v204;
  __int16 v205;
  int v206;
  char v207;
  uint64_t (**v208)(NString *__hidden, const unsigned int *);
  unsigned int v209;
  _BYTE *v210;
  uint64_t (**v211)(NString *__hidden, const unsigned int *);
  unsigned int v212;
  _BYTE *v213;
  uint64_t (**v214)(NString *__hidden, const unsigned int *);
  unsigned int v215;
  _BYTE *v216;
  uint64_t (**v217)(NString *__hidden, const unsigned int *);
  unsigned int v218;
  _BYTE *v219;
  uint64_t (**v220)(NString *__hidden, const unsigned int *);
  unsigned int v221;
  _BYTE *v222;

  v220 = &off_24C7F32C0;
  v221 = 0;
  v222 = (_BYTE *)operator new[]();
  *v222 = 0;
  v217 = &off_24C7F32C0;
  v218 = 0;
  v219 = (_BYTE *)operator new[]();
  *v219 = 0;
  v214 = &off_24C7F32C0;
  v215 = 0;
  v216 = (_BYTE *)operator new[]();
  *v216 = 0;
  v211 = &off_24C7F32C0;
  v212 = 0;
  v213 = (_BYTE *)operator new[]();
  *v213 = 0;
  v201 = a2;
  v202 = &off_24C7F32C0;
  v203 = 4;
  v204 = (char *)operator new[]();
  strcpy(v204, " \t\r\n");
  v205 = 0;
  v206 = 0;
  v207 = 0;
  v208 = &off_24C7F32C0;
  v209 = 0;
  v210 = (_BYTE *)operator new[]();
  *v210 = 0;
  v176[0] = 2;
  ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), const char *, unsigned int *))v202[8])(&v202, "\r\n", v176);
  v205 = 257;
  v198 = &off_24C7F2E28;
  v199 = 0;
  v200 = 0;
  v195 = &off_24C7F32C0;
  v196 = 0;
  v197 = (_BYTE *)operator new[]();
  *v197 = 0;
  v192 = &off_24C7F32C0;
  LODWORD(__n) = 0;
  __s = (void *)operator new[]();
  *(_BYTE *)__s = 0;
  if (*((_DWORD *)a2 + 2) >= 0x10u)
  {
    v6 = a2[2];
    v8 = *v6;
    v7 = v6[1];
    if (v8 == (uint64_t (*)(NString *__hidden, const unsigned int *))0x7369727561766F4ELL
      && v7 == (uint64_t (*)(NString *__hidden, const unsigned int *))0x3220656C69667320)
    {
      v10 = operator new[]();
      strcpy((char *)v10, "oiuasdv34r76adsfvjhwtg98eerfv34");
      *(_QWORD *)v176 = &off_24C7F32C0;
      v177 = 31;
      v11 = (_OWORD *)operator new[]();
      v12 = 0;
      v13 = 0;
      v178 = v11;
      v14 = *(_OWORD *)(v10 + 16);
      *v11 = *(_OWORD *)v10;
      v11[1] = v14;
      do
        v13 += *((char *)v11 + v12++);
      while (v12 != 31);
      LOWORD(v179) = bswap32(v13) >> 16;
      MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
      v16 = *((unsigned int *)a2 + 2);
      if (v16 <= 0x10)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v15, 17, v16);
      v17 = a2[2];
      if (!v17)
        Error::chuck((Error *)"Null pointer passed to string constructor", v15);
      v18 = (char *)operator new[]();
      v19 = (v16 - 17);
      memcpy(v18, (char *)v17 + 17, v19);
      v18[v19] = 0;
      v21 = (char *)operator new[]();
      strcpy(v21, "\r\n\t ");
      if ((_DWORD)v16 == 17)
      {
        v23 = 0;
        v24 = 0;
        v22 = 0;
      }
      else
      {
        v22 = 0;
        while (strchr(v21, v18[v22]))
        {
          if (v19 == ++v22)
          {
            v23 = (v16 - 17);
            v24 = v19;
            v22 = v19;
            goto LABEL_18;
          }
        }
        v23 = v22;
        v24 = v19;
      }
LABEL_18:
      if (v22 >= v19)
        v25 = v19;
      else
        v25 = v22;
      while (v24 > v23)
      {
        v26 = v24--;
        if (!strchr(v21, v18[v26 - 1]))
        {
          v25 = v26;
          break;
        }
      }
      if (v22 > v19)
      {
        v168 = "Index %d outside of range [0,%d]";
      }
      else if (v25 > v19)
      {
        v168 = "Index %d outside of range [0,%d]";
        v22 = v25;
      }
      else
      {
        if (v25 >= v22)
        {
          v189 = &off_24C7F32C0;
          v190 = v25 - v22;
          v27 = (void *)operator new[]();
          v191 = v27;
          memcpy(v27, &v18[v22], (v25 - v22));
          *((_BYTE *)v27 + (v25 - v22)) = 0;
          MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
          MEMORY[0x212BAC9C0](v18, 0x1000C8077774924);
          NScrambler::unscramble((NScrambler *)v176, (const NString *)&v189, (uint64_t)v186);
          ((void (*)(NString *, const void *, const unsigned int *))v195[8])((NString *)&v195, v188, &v187);
          *(_QWORD *)v186 = &off_24C7F32C0;
          if (v188)
            MEMORY[0x212BAC9C0](v188, 0x1000C8077774924);
          v201 = &v195;
          v206 = 0;
          v207 = 0;
          v186[0] = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v208[8])((NString *)&v208, "", v186);
          MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
          if (v178)
            MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          goto LABEL_31;
        }
        v168 = "Start and end indices conflict, start [%d], end [%d]";
        v19 = v25;
      }
      Error::chuck((Error *)v168, v20, v22, v19);
    }
  }
LABEL_31:
  v206 = 0;
  NStringSplitIterator::operator++((uint64_t *)&v201, v5);
  v28 = 0;
  LODWORD(v175) = 0;
  v170 = "Index %d outside of range [0,%d]";
  v169 = "NConfig::load() - Missing whitespace after #include at %s";
  while (v207)
  {
    ((void (*)(NString *, const void *, const unsigned int *))v192[8])((NString *)&v192, v210, &v209);
    v31 = __n;
    v32 = __s;
    v33 = (__n - 8);
    if (__n < 8)
      goto LABEL_104;
    if (*(_QWORD *)__s == 0x6564756C636E6923)
    {
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (!__s)
        Error::chuck((Error *)"Null pointer passed to string constructor", v30);
      v177 = __n - 8;
      v34 = (void *)operator new[]();
      v178 = v34;
      memcpy(v34, v32 + 8, v33);
      *((_BYTE *)v34 + v33) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v211[8])((NString *)&v211, v34, &v177);
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (v178)
        MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
      if (!v212)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v35, 0, 0xFFFFFFFFLL);
      v36 = (char)*v213;
      if ((v36 & 0x80000000) != 0)
        v37 = __maskrune(v36, 0x4000uLL);
      else
        v37 = *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v36 + 60) & 0x4000;
      if (!v37)
        goto LABEL_328;
      v38 = v212;
      if (v212)
      {
        v39 = v213;
        if (*v213 == 35)
          goto LABEL_59;
        if (v212 < 2)
          goto LABEL_58;
        v40 = v213 + 1;
        v41 = 1;
        while (1)
        {
          if (*v40 == 35)
          {
            v42 = *(v40 - 1);
            if (v42 == 32 || v42 == 9)
              break;
          }
          ++v41;
          ++v40;
          if (v212 == v41)
            goto LABEL_57;
        }
        v212 = v41;
        v213[v41] = 0;
        v38 = v212;
LABEL_57:
        if (v38)
        {
LABEL_58:
          v39 = v213;
          if (*v213 == 59)
          {
LABEL_59:
            *v39 = 0;
            v212 = 0;
          }
          else if (v38 >= 2)
          {
            v137 = 0;
            v138 = v38 - 1;
            while (1)
            {
              v139 = &v213[v137++];
              if (v139[1] == 59)
              {
                v140 = *v139;
                if (v140 == 32 || v140 == 9)
                  break;
              }
              if (v138 == (_DWORD)v137)
                goto LABEL_60;
            }
            v212 = v137;
            v213[v137] = 0;
          }
        }
      }
LABEL_60:
      v45 = (char *)operator new[]();
      strcpy(v45, "\r\n\t ");
      v46 = v212;
      v47 = v213;
      if (v212)
      {
        v48 = 0;
        while (strchr(v45, (char)v47[v48]))
        {
          if (v46 == ++v48)
          {
            v49 = v46;
            v50 = v46;
            v48 = v46;
            goto LABEL_67;
          }
        }
        v49 = v48;
        v50 = v46;
      }
      else
      {
        v49 = 0;
        v50 = 0;
        v48 = 0;
      }
LABEL_67:
      if (v48 >= v46)
        v51 = v46;
      else
        v51 = v48;
      while (v50 > v49)
      {
        v52 = v50--;
        if (!strchr(v45, (char)v47[v52 - 1]))
        {
          v51 = v52;
          break;
        }
      }
      if (v48 > v46)
        goto LABEL_338;
      if (v51 > v46)
      {
        v48 = v51;
LABEL_338:
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v44, v48, v46);
      }
      if (v51 < v48)
        Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v44, v48, v51);
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (!v47)
        Error::chuck((Error *)"Null pointer passed to string constructor", v44);
      v177 = v51 - v48;
      v53 = (void *)operator new[]();
      v178 = v53;
      memcpy(v53, &v47[v48], (v51 - v48));
      *((_BYTE *)v53 + (v51 - v48)) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v211[8])((NString *)&v211, v53, &v177);
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (v178)
        MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v45, 0x1000C8077774924);
      if (!v212 || (v54 = v213, *v213 != 34) || (v55 = v212 - 1, v213[v55] != 34))
      {
        v169 = "NConfig::load() - Missing quotes #include at %s";
LABEL_328:
        Error::chuck((Error *)v169, v35, __s);
      }
      if (v212 == 1)
        Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v35, 1, v55);
      *(_QWORD *)v176 = &off_24C7F32C0;
      v56 = v212 - 2;
      v177 = v212 - 2;
      v57 = (void *)operator new[]();
      v178 = v57;
      memcpy(v57, v54 + 1, v56);
      *((_BYTE *)v57 + v56) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v211[8])((NString *)&v211, v57, &v177);
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (v178)
        MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
      v58 = v212;
      if (!v212)
        goto LABEL_98;
      v59 = v212 - 7;
      if ((int)(v212 - 7) >= 1)
      {
        v60 = (int)v213;
        v61 = v213;
        do
        {
          v62 = memchr(v61, 36, v59);
          if (!v62)
            break;
          v63 = (_DWORD)v62 - v60;
          if (*v62 == 0x29544F4F524E2824)
          {
            if (v63 == -1)
              break;
            v189 = &off_24C7F32C0;
            v190 = 8;
            v191 = (void *)operator new[]();
            memcpy(v191, "$(NROOT)", v190 + 1);
            ((void (*)(NString *@<X0>, const NString *@<X1>, const NString *@<X2>, uint64_t@<X8>))v211[14])((NString *)&v211, (const NString *)&v189, a3, (uint64_t)v176);
            v211[4]((NString *)&v211, v176);
            *(_QWORD *)v176 = &off_24C7F32C0;
            if (v178)
              MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
            v189 = &off_24C7F32C0;
            if (v191)
              MEMORY[0x212BAC9C0](v191, 0x1000C8077774924);
            goto LABEL_103;
          }
          v59 = v58 - v63 - 8;
          v61 = (char *)v62 + 1;
        }
        while (v59 > 0);
      }
      if (*v213 != 47)
      {
LABEL_98:
        NString::dirname(a4, (uint64_t)v176);
        v64 = v177;
        if (v178)
          MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
        if (v64)
        {
          NString::dirname(a4, (uint64_t)v186);
          v183 = &off_24C7F32C0;
          v184 = 1;
          v185 = (_WORD *)operator new[]();
          *v185 = 47;
          NString::operator+((uint64_t)v186, (uint64_t)&v183, (uint64_t)&v189);
        }
      }
LABEL_103:
      NConfig::load(this, (const NString *)&v211, a3);
      v176[0] = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v217[8])((NString *)&v217, "", v176);
      v32 = __s;
      v31 = __n;
LABEL_104:
      if (!v31)
        goto LABEL_130;
    }
    if (*v32 == 35)
    {
      *v32 = 0;
      LODWORD(__n) = 0;
    }
    else
    {
      if (v31 < 2)
        goto LABEL_118;
      v65 = v32 + 1;
      v66 = 1;
      while (1)
      {
        if (*v65 == 35)
        {
          v67 = *(v65 - 1);
          if (v67 == 32 || v67 == 9)
            break;
        }
        ++v66;
        ++v65;
        if (v31 == v66)
          goto LABEL_117;
      }
      LODWORD(__n) = v66;
      v32[v66] = 0;
      v31 = __n;
LABEL_117:
      if (v31)
      {
LABEL_118:
        if (*(_BYTE *)__s == 59)
        {
          *(_BYTE *)__s = 0;
          LODWORD(__n) = 0;
        }
        else if (v31 >= 2)
        {
          v69 = 0;
          v70 = v31 - 1;
          while (1)
          {
            v71 = (unsigned __int8 *)__s + v69++;
            if (v71[1] == 59)
            {
              v72 = *v71;
              if (v72 == 32 || v72 == 9)
                break;
            }
            if (v70 == (_DWORD)v69)
              goto LABEL_130;
          }
          LODWORD(__n) = v69;
          *((_BYTE *)__s + v69) = 0;
        }
      }
    }
LABEL_130:
    if (v218)
      v74 = (_DWORD)__n == 0;
    else
      v74 = 1;
    v175 = (NString *)((_DWORD)v175 + 1);
    if (v74 || ((v75 = *(unsigned __int8 *)__s, v75 != 32) ? (v76 = v75 == 9) : (v76 = 1), !v76))
    {
      v85 = (char *)operator new[]();
      strcpy(v85, "\r\n\t ");
      v86 = __n;
      v87 = (char *)__s;
      if ((_DWORD)__n)
      {
        v88 = 0;
        while (strchr(v85, v87[v88]))
        {
          if (v86 == ++v88)
          {
            v89 = v86;
            v90 = v86;
            v88 = v86;
            goto LABEL_151;
          }
        }
        v89 = v88;
        v90 = v86;
      }
      else
      {
        v89 = 0;
        v90 = 0;
        v88 = 0;
      }
LABEL_151:
      if (v88 >= v86)
        v91 = v86;
      else
        v91 = v88;
      while (v90 > v89)
      {
        v92 = v90--;
        if (!strchr(v85, v87[v92 - 1]))
        {
          v91 = v92;
          break;
        }
      }
      if (v88 > v86)
        goto LABEL_326;
      if (v91 > v86)
      {
        v88 = v91;
        goto LABEL_326;
      }
      if (v91 < v88)
      {
        v170 = "Start and end indices conflict, start [%d], end [%d]";
        v86 = v91;
LABEL_326:
        Error::chuck((Error *)v170, v84, v88, v86);
      }
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (!v87)
        Error::chuck((Error *)"Null pointer passed to string constructor", v84);
      v177 = v91 - v88;
      v93 = (void *)operator new[]();
      v178 = v93;
      memcpy(v93, &v87[v88], (v91 - v88));
      *((_BYTE *)v93 + (v91 - v88)) = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v192[8])((NString *)&v192, v93, &v177);
      *(_QWORD *)v176 = &off_24C7F32C0;
      if (v178)
        MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
      MEMORY[0x212BAC9C0](v85, 0x1000C8077774924);
      v95 = __n;
      if (!(_DWORD)__n)
        goto LABEL_32;
      v96 = (char *)__s;
      if (*(_BYTE *)__s == 91)
      {
        v97 = (__n - 1);
        if (*((_BYTE *)__s + v97) == 93)
        {
          if ((_DWORD)__n == 1)
            Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v94, 1, v97);
          v98 = (char *)operator new[]();
          v99 = (v95 - 2);
          memcpy(v98, v96 + 1, v99);
          v98[v99] = 0;
          v101 = (char *)operator new[]();
          strcpy(v101, "\r\n\t ");
          if ((_DWORD)v99)
          {
            v102 = 0;
            while (strchr(v101, v98[v102]))
            {
              if (v99 == ++v102)
              {
                v103 = v99;
                v104 = v99;
                v102 = v99;
                goto LABEL_209;
              }
            }
            v103 = v102;
            v104 = v99;
          }
          else
          {
            v103 = 0;
            v104 = 0;
            v102 = 0;
          }
LABEL_209:
          if (v102 >= v99)
            v119 = v99;
          else
            v119 = v102;
          while (v104 > v103)
          {
            v120 = v104--;
            if (!strchr(v101, v98[v120 - 1]))
            {
              v119 = v120;
              break;
            }
          }
          if (v102 > v99)
            goto LABEL_343;
          if (v119 > v99)
          {
            v102 = v119;
LABEL_343:
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v100, v102, v99);
          }
          if (v119 < v102)
            Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v100, v102, v119);
          *(_QWORD *)v176 = &off_24C7F32C0;
          v177 = v119 - v102;
          v121 = (void *)operator new[]();
          v178 = v121;
          memcpy(v121, &v98[v102], (v119 - v102));
          *((_BYTE *)v121 + (v119 - v102)) = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v220[8])((NString *)&v220, v121, &v177);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (v178)
            MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          MEMORY[0x212BAC9C0](v101, 0x1000C8077774924);
          MEMORY[0x212BAC9C0](v98, 0x1000C8077774924);
          if (!NMap<NString,NConfigSection>::contains((uint64_t)this, (uint64_t)&v220))
          {
            *(_QWORD *)v176 = &off_24C7F32C0;
            v177 = v221;
            v178 = (void *)operator new[]();
            memcpy(v178, v222, v221 + 1);
            LODWORD(v189) = 10;
            v179 = &off_24C7F2AB0;
            NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)&v180, (unsigned int *)&v189, 0);
            v122 = (unsigned int *)NMap<NString,NConfigSection>::operator[]((uint64_t)this, (uint64_t)&v220);
            v123 = v122;
            if (v122 != v176)
            {
              (*(void (**)(unsigned int *, void *, unsigned int *))(*(_QWORD *)v122 + 64))(v122, v178, &v177);
              *(_QWORD *)(v123 + 13) = v182;
              NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=((uint64_t)(v123 + 8), (uint64_t)&v180);
            }
            v179 = &off_24C7F2AB0;
            v180 = &off_24C7F2CA0;
            v124 = v181;
            if (v181)
            {
              v125 = *(_QWORD *)(v181 - 8);
              if (v125)
              {
                v126 = v181 + 32 * v125;
                v127 = v126;
                do
                {
                  *(_QWORD *)(v127 - 32) = off_24C7F1480;
                  v127 -= 32;
                  for (i = *(_QWORD *)(v127 + 8); i; i = *(_QWORD *)(v126 - 24))
                  {
                    *(_QWORD *)(v126 - 24) = *(_QWORD *)(i + 8);
                    (*(void (**)(uint64_t))(*(_QWORD *)(v126 - 32) + 72))(v127);
                  }
                  *(_QWORD *)(v126 - 16) = 0;
                  *(_DWORD *)(v126 - 8) = 0;
                  v126 = v127;
                }
                while (v127 != v124);
              }
              MEMORY[0x212BAC9C0](v124 - 16, 0x10A1C80F4A7E088);
            }
            *(_QWORD *)v176 = &off_24C7F32C0;
            if (v178)
              MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          }
LABEL_32:
          v176[0] = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v217[8])((NString *)&v217, "", v176);
          goto LABEL_33;
        }
      }
      v176[0] = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v217[8])((NString *)&v217, "", v176);
      v176[0] = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v214[8])((NString *)&v214, "", v176);
      v105 = __n;
      if ((int)__n >= 1)
      {
        v106 = __s;
        v107 = __n;
        v108 = __s;
        while (1)
        {
          v109 = memchr(v108, 58, v107);
          if (!v109)
            goto LABEL_201;
          v110 = ((_DWORD)v109 - (_DWORD)v106);
          if (*v109 == 58)
            break;
          v107 = v105 + ~(_DWORD)v110;
          v108 = v109 + 1;
          if (v107 <= 0)
            goto LABEL_201;
        }
        if ((_DWORD)v110 == -1)
        {
LABEL_201:
          if ((int)v105 >= 1)
          {
            v106 = __s;
            v116 = v105;
            v117 = __s;
            while (1)
            {
              v118 = memchr(v117, 61, v116);
              if (!v118)
                goto LABEL_291;
              v110 = ((_DWORD)v118 - (_DWORD)v106);
              if (*v118 == 61)
                break;
              v116 = v105 + ~(_DWORD)v110;
              v117 = v118 + 1;
              if (v116 <= 0)
                goto LABEL_291;
            }
            if ((_DWORD)v110 != -1)
              goto LABEL_234;
          }
        }
        else
        {
LABEL_234:
          if (v110 > v105)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v29, v110, v105);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (!v106)
            Error::chuck((Error *)"Null pointer passed to string constructor", v29);
          v177 = v110;
          v129 = (void *)operator new[]();
          v178 = v129;
          memcpy(v129, v106, v110);
          *((_BYTE *)v129 + v110) = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v217[8])((NString *)&v217, v129, &v177);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (v178)
            MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          v131 = (char *)operator new[]();
          v171 = (v110 + 1);
          strcpy(v131, "\r\n\t ");
          v132 = v218;
          v133 = v219;
          if (v218)
          {
            v134 = 0;
            while (strchr(v131, (char)v133[v134]))
            {
              if (v132 == ++v134)
              {
                v135 = v132;
                v136 = v132;
                v134 = v132;
                goto LABEL_255;
              }
            }
            v135 = v134;
            v136 = v132;
          }
          else
          {
            v135 = 0;
            v136 = 0;
            v134 = 0;
          }
LABEL_255:
          if (v134 >= v132)
            v142 = v132;
          else
            v142 = v134;
          while (v136 > v135)
          {
            v143 = v136--;
            if (!strchr(v131, (char)v133[v143 - 1]))
            {
              v142 = v143;
              break;
            }
          }
          if (v134 > v132)
            goto LABEL_354;
          if (v142 > v132)
          {
            v134 = v142;
LABEL_354:
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v130, v134, v132);
          }
          v144 = (v142 - v134);
          if (v142 < v134)
            Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v130, v134, v142);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (!v133)
            Error::chuck((Error *)"Null pointer passed to string constructor", v130);
          v177 = v142 - v134;
          v145 = (void *)operator new[]();
          v178 = v145;
          memcpy(v145, &v133[v134], v144);
          *((_BYTE *)v145 + v144) = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v217[8])((NString *)&v217, v145, &v177);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (v178)
            MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          MEMORY[0x212BAC9C0](v131, 0x1000C8077774924);
          if (v110 >= __n)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v146, v171, __n);
          v147 = (char *)__s;
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (!__s)
            Error::chuck((Error *)"Null pointer passed to string constructor", v146);
          v148 = (__n - v171);
          v177 = __n - v171;
          v149 = (void *)operator new[]();
          v178 = v149;
          memcpy(v149, &v147[v171], v148);
          *((_BYTE *)v149 + v148) = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v214[8])((NString *)&v214, v149, &v177);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (v178)
            MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          v151 = (char *)operator new[]();
          strcpy(v151, "\r\n\t ");
          v152 = v215;
          v153 = v216;
          if (v215)
          {
            v154 = 0;
            while (strchr(v151, (char)v153[v154]))
            {
              if (v152 == ++v154)
              {
                v155 = v152;
                v156 = v152;
                v154 = v152;
                goto LABEL_278;
              }
            }
            v155 = v154;
            v156 = v152;
          }
          else
          {
            v155 = 0;
            v156 = 0;
            v154 = 0;
          }
LABEL_278:
          if (v154 >= v152)
            v157 = v152;
          else
            v157 = v154;
          while (v156 > v155)
          {
            v158 = v156--;
            if (!strchr(v151, (char)v153[v158 - 1]))
            {
              v157 = v158;
              break;
            }
          }
          if (v154 > v152)
            goto LABEL_349;
          if (v157 > v152)
          {
            v154 = v157;
LABEL_349:
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v150, v154, v152);
          }
          v159 = (v157 - v154);
          if (v157 < v154)
            Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v150, v154, v157);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (!v153)
            Error::chuck((Error *)"Null pointer passed to string constructor", v150);
          v177 = v157 - v154;
          v160 = (void *)operator new[]();
          v178 = v160;
          memcpy(v160, &v153[v154], v159);
          *((_BYTE *)v160 + v159) = 0;
          ((void (*)(NString *, const void *, const unsigned int *))v214[8])((NString *)&v214, v160, &v177);
          *(_QWORD *)v176 = &off_24C7F32C0;
          if (v178)
            MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
          MEMORY[0x212BAC9C0](v151, 0x1000C8077774924);
          v28 = 0;
        }
      }
LABEL_291:
      if (v218)
      {
        if (!*((_BYTE *)this + 40) && !v221)
          Error::chuck((Error *)"NConfig::load() - No options allowed outside of section at line %d: %s", v29, v175, __s);
        v189 = &off_24C7F32C0;
        v190 = 8;
        v191 = (void *)operator new[]();
        memcpy(v191, "$(NROOT)", v190 + 1);
        ((void (*)(NString *@<X0>, const NString *@<X1>, const NString *@<X2>, uint64_t@<X8>))v214[14])((NString *)&v214, (const NString *)&v189, a3, (uint64_t)v176);
        v214[4]((NString *)&v214, v176);
        *(_QWORD *)v176 = &off_24C7F32C0;
        if (v178)
          MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
        v189 = &off_24C7F32C0;
        if (v191)
          MEMORY[0x212BAC9C0](v191, 0x1000C8077774924);
        v161 = NMap<NString,NConfigSection>::operator[]((uint64_t)this, (uint64_t)&v220);
        v162 = NMap<NString,NString>::operator[](v161 + 24, (uint64_t)&v217);
        (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v162 + 32))(v162, &v214);
      }
      goto LABEL_33;
    }
    v78 = (char *)operator new[]();
    strcpy(v78, "\r\n\t ");
    v79 = __n;
    v80 = (char *)__s;
    if ((_DWORD)__n)
    {
      v81 = 0;
      while (strchr(v78, v80[v81]))
      {
        if (v79 == ++v81)
        {
          v82 = v79;
          v83 = v79;
          v81 = v79;
          goto LABEL_180;
        }
      }
      v82 = v81;
      v83 = v79;
    }
    else
    {
      v82 = 0;
      v83 = 0;
      v81 = 0;
    }
LABEL_180:
    if (v81 >= v79)
      v111 = v79;
    else
      v111 = v81;
    while (v83 > v82)
    {
      v112 = v83--;
      if (!strchr(v78, v80[v112 - 1]))
      {
        v111 = v112;
        break;
      }
    }
    if (v81 > v79)
      goto LABEL_332;
    if (v111 > v79)
    {
      v81 = v111;
      goto LABEL_332;
    }
    if (v111 < v81)
    {
      v170 = "Start and end indices conflict, start [%d], end [%d]";
      v79 = v111;
LABEL_332:
      Error::chuck((Error *)v170, v77, v81, v79);
    }
    v189 = &off_24C7F32C0;
    if (!v80)
      Error::chuck((Error *)"Null pointer passed to string constructor", v77);
    v190 = v111 - v81;
    v113 = (void *)operator new[]();
    v191 = v113;
    memcpy(v113, &v80[v81], (v111 - v81));
    *((_BYTE *)v113 + (v111 - v81)) = 0;
    *(_QWORD *)v186 = &off_24C7F32C0;
    v187 = 8;
    v188 = (void *)operator new[]();
    memcpy(v188, "$(NROOT)", v187 + 1);
    ((void (*)(NString *@<X0>, const NString *@<X1>, const NString *@<X2>, uint64_t@<X8>))v189[14])((NString *)&v189, (const NString *)v186, a3, (uint64_t)v176);
    v189[4]((NString *)&v189, v176);
    *(_QWORD *)v176 = &off_24C7F32C0;
    if (v178)
      MEMORY[0x212BAC9C0](v178, 0x1000C8077774924);
    ((void (*)(NString *, const void *, const unsigned int *))v214[8])((NString *)&v214, v191, &v190);
    *(_QWORD *)v186 = &off_24C7F32C0;
    if (v188)
      MEMORY[0x212BAC9C0](v188, 0x1000C8077774924);
    v189 = &off_24C7F32C0;
    if (v191)
      MEMORY[0x212BAC9C0](v191, 0x1000C8077774924);
    MEMORY[0x212BAC9C0](v78, 0x1000C8077774924);
    ++v28;
    if (v215)
    {
      if (v28)
      {
        v189 = &off_24C7F32C0;
        v190 = 1;
        v191 = (void *)operator new[]();
        *(_WORD *)v191 = 10;
        NString::operator+((uint64_t)&v189, (uint64_t)&v214, (uint64_t)v176);
      }
      v114 = NMap<NString,NConfigSection>::operator[]((uint64_t)this, (uint64_t)&v220);
      v115 = NMap<NString,NString>::operator[](v114 + 24, (uint64_t)&v217);
      (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v115 + 48))(v115, &v214);
      v28 = 0;
    }
LABEL_33:
    NStringSplitIterator::operator++((uint64_t *)&v201, v29);
  }
  v192 = &off_24C7F32C0;
  if (__s)
    MEMORY[0x212BAC9C0](__s, 0x1000C8077774924);
  v195 = &off_24C7F32C0;
  if (v197)
    MEMORY[0x212BAC9C0](v197, 0x1000C8077774924);
  v163 = v199;
  if (v199)
  {
    v164 = *(_QWORD *)(v199 - 8);
    if (v164)
    {
      v165 = 24 * v164;
      do
      {
        *(_QWORD *)(v163 + v165 - 24) = &off_24C7F32C0;
        v166 = *(_QWORD *)(v163 + v165 - 8);
        if (v166)
          MEMORY[0x212BAC9C0](v166, 0x1000C8077774924);
        v165 -= 24;
      }
      while (v165);
    }
    MEMORY[0x212BAC9C0](v163 - 16, 0x1091C800F2A5985);
  }
  v208 = &off_24C7F32C0;
  if (v210)
    MEMORY[0x212BAC9C0](v210, 0x1000C8077774924);
  v202 = &off_24C7F32C0;
  if (v204)
    MEMORY[0x212BAC9C0](v204, 0x1000C8077774924);
  v211 = &off_24C7F32C0;
  if (v213)
    MEMORY[0x212BAC9C0](v213, 0x1000C8077774924);
  v214 = &off_24C7F32C0;
  if (v216)
    MEMORY[0x212BAC9C0](v216, 0x1000C8077774924);
  v217 = &off_24C7F32C0;
  if (v219)
    MEMORY[0x212BAC9C0](v219, 0x1000C8077774924);
  v220 = &off_24C7F32C0;
  result = v222;
  if (v222)
    return (_BYTE *)MEMORY[0x212BAC9C0](v222, 0x1000C8077774924);
  return result;
}

void sub_20D9FFE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;
  uint64_t v45;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  MEMORY[0x212BAC9C0](v44, 0x1000C8077774924);
  if (a23)
    MEMORY[0x212BAC9C0](a23, 0x1000C8077774924);
  if (a40)
    MEMORY[0x212BAC9C0](a40, 0x1000C8077774924);
  if (a43)
    MEMORY[0x212BAC9C0](a43, 0x1000C8077774924);
  NArray<NString>::~NArray(&a44);
  *(_QWORD *)(v45 - 208) = &off_24C7F32C0;
  v47 = *(_QWORD *)(v45 - 192);
  if (v47)
    MEMORY[0x212BAC9C0](v47, 0x1000C8077774924);
  *(_QWORD *)(v45 - 248) = &off_24C7F32C0;
  v48 = *(_QWORD *)(v45 - 232);
  if (v48)
    MEMORY[0x212BAC9C0](v48, 0x1000C8077774924);
  *(_QWORD *)(v45 - 184) = &off_24C7F32C0;
  v49 = *(_QWORD *)(v45 - 168);
  if (v49)
    MEMORY[0x212BAC9C0](v49, 0x1000C8077774924);
  *(_QWORD *)(v45 - 160) = &off_24C7F32C0;
  v50 = *(_QWORD *)(v45 - 144);
  if (v50)
    MEMORY[0x212BAC9C0](v50, 0x1000C8077774924);
  *(_QWORD *)(v45 - 136) = &off_24C7F32C0;
  v51 = *(_QWORD *)(v45 - 120);
  if (v51)
    MEMORY[0x212BAC9C0](v51, 0x1000C8077774924);
  *(_QWORD *)(v45 - 112) = &off_24C7F32C0;
  v52 = *(_QWORD *)(v45 - 96);
  if (v52)
    MEMORY[0x212BAC9C0](v52, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void *NStringSplitIterator::operator++(uint64_t *a1, const char *a2)
{
  uint64_t v2;
  unsigned int *v4;
  uint64_t v5;
  void *v6;
  size_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  void *result;
  const char *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t (**v25)(NString *__hidden, const unsigned int *);
  uint64_t v26;
  void *v27;
  unsigned int v28;

  v2 = *a1;
  if (!*a1)
    Error::chuck((Error *)"NStringSplitIterator::operator++() - input string unset", a2);
  v4 = (unsigned int *)a1 + 9;
  v5 = *((unsigned int *)a1 + 9);
  v6 = (void *)a1[3];
  v7 = *((unsigned int *)a1 + 4);
  v8 = *(unsigned int *)(v2 + 8);
  v9 = *((unsigned __int8 *)a1 + 32);
  if (*((_BYTE *)a1 + 32))
    v10 = 1;
  else
    v10 = v5 >= v8;
  if (!v10)
  {
    v12 = *(_QWORD *)(v2 + 16);
    while (memchr(v6, *(char *)(v12 + v5), v7))
    {
      *v4 = ++v5;
      if (v8 == v5)
      {
        v28 = v8;
        LODWORD(v5) = v8;
        goto LABEL_15;
      }
    }
  }
  v28 = v5;
  if (v5 >= v8)
  {
LABEL_15:
    if (v9)
      v13 = (_DWORD)v5 == (_DWORD)v8;
    else
      v13 = 0;
    v14 = v13;
    *((_BYTE *)a1 + 40) = v14;
    if (!v13)
    {
      LODWORD(v25) = 0;
      result = (void *)(*(uint64_t (**)(uint64_t *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(a1[6] + 64))(a1 + 6, "", &v25);
      goto LABEL_27;
    }
  }
  else
  {
    v5 = v5;
    v11 = *(_QWORD *)(v2 + 16);
    do
    {
      if (memchr(v6, *(char *)(v11 + v5), v7))
        break;
      *v4 = ++v5;
    }
    while (v8 != v5);
    *((_BYTE *)a1 + 40) = 1;
  }
  NString::slice((NString *)v2, &v28, v4, (uint64_t)&v25);
  if (a1 + 6 != (uint64_t *)&v25)
    (*(void (**)(uint64_t *, void *, uint64_t *))(a1[6] + 64))(a1 + 6, v27, &v26);
  v25 = &off_24C7F32C0;
  result = v27;
  if (v27)
    result = (void *)MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
LABEL_27:
  v17 = *((unsigned int *)a1 + 9);
  if (*((_BYTE *)a1 + 33) && v17 < v8)
  {
    v18 = *(_DWORD *)(*a1 + 8);
    if (v17 >= v18)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v16, *((unsigned int *)a1 + 9), v18 - 1, v25);
    v19 = *(_QWORD *)(*a1 + 16);
    v20 = *(unsigned __int8 *)(v19 + v17);
    v21 = (v8 - 1);
    v22 = v18 - 1;
    v23 = v19 + 1;
    do
    {
      *v4 = v17 + 1;
      if (v21 == v17)
        break;
      if (v22 == v17)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v16, v17 + 1, v22, v25);
      v24 = *(unsigned __int8 *)(v23 + v17);
      if (v24 == v20)
        break;
      result = memchr(v6, (char)v24, v7);
      ++v17;
    }
    while (result);
  }
  else
  {
    *v4 = v17 + 1;
  }
  return result;
}

void sub_20DA00624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

BOOL NMap<NString,NConfigSection>::contains(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  const char *v11;
  unsigned int v12;
  size_t v13;
  unsigned int v14;
  char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  void *v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t j;
  void *__src;
  uint64_t (**v28)();
  uint64_t (**v29)();
  uint64_t v30;
  uint64_t (**v31)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**v34)(NString *__hidden, const unsigned int *);
  int v35;
  void *v36;
  _QWORD v37[2];
  uint64_t v38;
  unsigned int v39;

  v4 = (_BYTE *)operator new[]();
  *v4 = 0;
  v5 = (_BYTE *)operator new[]();
  *v5 = *v4;
  v39 = 10;
  __src = v5;
  v28 = &off_24C7F2AB0;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)&v29, &v39, 0);
  v31 = &off_24C7F32C0;
  LODWORD(__n) = *(_DWORD *)(a2 + 8);
  __s2 = (void *)operator new[]();
  memcpy(__s2, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v34 = &off_24C7F32C0;
  v35 = 0;
  v36 = (void *)operator new[]();
  memcpy(v36, __src, 1uLL);
  NMap<NString,NString>::NMap((uint64_t)v37, (uint64_t)&v28);
  v28 = &off_24C7F2AB0;
  v29 = &off_24C7F2CA0;
  v6 = v30;
  if (v30)
  {
    v7 = *(_QWORD *)(v30 - 8);
    if (v7)
    {
      v8 = v30 + 32 * v7;
      v9 = v8;
      do
      {
        *(_QWORD *)(v9 - 32) = off_24C7F1480;
        v9 -= 32;
        for (i = *(_QWORD *)(v9 + 8); i; i = *(_QWORD *)(v8 - 24))
        {
          *(_QWORD *)(v8 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v8 - 32) + 72))(v9);
        }
        *(_QWORD *)(v8 - 16) = 0;
        *(_DWORD *)(v8 - 8) = 0;
        v8 = v9;
      }
      while (v9 != v6);
    }
    MEMORY[0x212BAC9C0](v6 - 16, 0x10A1C80F4A7E088);
  }
  if (__src)
    MEMORY[0x212BAC9C0](__src, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  v12 = *(_DWORD *)(a1 + 28);
  if (!v12)
    Error::chuck((Error *)"NHash::contains() - zero length hash table", v11, &off_24C7F32C0);
  v13 = __n;
  if ((_DWORD)__n)
  {
    v14 = 0;
    v15 = (char *)__s2;
    v16 = __n;
    do
    {
      v17 = *v15++;
      v14 = v17 + 65599 * v14;
      --v16;
    }
    while (v16);
  }
  else
  {
    v14 = 0;
  }
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * (v14 % v12) + 8);
  if (v18)
  {
    v19 = __s2;
    do
    {
      if ((_DWORD)v13 == *(_DWORD *)(v18 + 24) && !memcmp(*(const void **)(v18 + 32), v19, v13))
        break;
      v18 = *(_QWORD *)(v18 + 8);
    }
    while (v18);
    v20 = v18 != 0;
  }
  else
  {
    v20 = 0;
  }
  v37[0] = &off_24C7F2AB0;
  v37[1] = &off_24C7F2CA0;
  v21 = v38;
  if (v38)
  {
    v22 = *(_QWORD *)(v38 - 8);
    if (v22)
    {
      v23 = v38 + 32 * v22;
      v24 = v23;
      do
      {
        *(_QWORD *)(v24 - 32) = off_24C7F1480;
        v24 -= 32;
        for (j = *(_QWORD *)(v24 + 8); j; j = *(_QWORD *)(v23 - 24))
        {
          *(_QWORD *)(v23 - 24) = *(_QWORD *)(j + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v23 - 32) + 72))(v24);
        }
        *(_QWORD *)(v23 - 16) = 0;
        *(_DWORD *)(v23 - 8) = 0;
        v23 = v24;
      }
      while (v24 != v21);
    }
    MEMORY[0x212BAC9C0](v21 - 16, 0x10A1C80F4A7E088);
  }
  v34 = &off_24C7F32C0;
  if (v36)
    MEMORY[0x212BAC9C0](v36, 0x1000C8077774924);
  v31 = &off_24C7F32C0;
  if (__s2)
    MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
  return v20;
}

void sub_20DA009CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  NMap<NString,NConfigSection>::HashItem::~HashItem((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_20DA009E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  uint64_t v22;
  uint64_t v23;

  if (a22)
    MEMORY[0x212BAC9C0](a22, 0x1000C8077774924);
  a17 = v23;
  if (a19)
    MEMORY[0x212BAC9C0](a19, 0x1000C8077774924);
  NConfigSection::~NConfigSection((NConfigSection *)&a9);
  MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NConfig::section(NConfig *this, const NString *a2)
{
  const char *v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  const char *v12;
  unsigned int v13;
  size_t v14;
  unsigned int v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  void *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t j;
  void *__src;
  uint64_t (**v29)();
  uint64_t (**v30)();
  uint64_t v31;
  uint64_t (**v32)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__s2;
  uint64_t (**v35)(NString *__hidden, const unsigned int *);
  int v36;
  void *v37;
  _QWORD v38[2];
  uint64_t v39;
  unsigned int v40;

  if (!NMap<NString,NConfigSection>::contains((uint64_t)this, (uint64_t)a2))
    Error::chuck((Error *)"NConfigSection::section() - Section '%s' not found", v4, *((_QWORD *)a2 + 2));
  v5 = (_BYTE *)operator new[]();
  *v5 = 0;
  v6 = (_BYTE *)operator new[]();
  *v6 = *v5;
  v40 = 10;
  __src = v6;
  v29 = &off_24C7F2AB0;
  NHash<NMap<NString,NString>::HashItem>::NHash((uint64_t)&v30, &v40, 0);
  v32 = &off_24C7F32C0;
  LODWORD(__n) = *((_DWORD *)a2 + 2);
  __s2 = (void *)operator new[]();
  memcpy(__s2, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
  v35 = &off_24C7F32C0;
  v36 = 0;
  v37 = (void *)operator new[]();
  memcpy(v37, __src, 1uLL);
  NMap<NString,NString>::NMap((uint64_t)v38, (uint64_t)&v29);
  v29 = &off_24C7F2AB0;
  v30 = &off_24C7F2CA0;
  v7 = v31;
  if (v31)
  {
    v8 = *(_QWORD *)(v31 - 8);
    if (v8)
    {
      v9 = v31 + 32 * v8;
      v10 = v9;
      do
      {
        *(_QWORD *)(v10 - 32) = off_24C7F1480;
        v10 -= 32;
        for (i = *(_QWORD *)(v10 + 8); i; i = *(_QWORD *)(v9 - 24))
        {
          *(_QWORD *)(v9 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v9 - 32) + 72))(v10);
        }
        *(_QWORD *)(v9 - 16) = 0;
        *(_DWORD *)(v9 - 8) = 0;
        v9 = v10;
      }
      while (v10 != v7);
    }
    MEMORY[0x212BAC9C0](v7 - 16, 0x10A1C80F4A7E088);
  }
  if (__src)
    MEMORY[0x212BAC9C0](__src, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  v13 = *((_DWORD *)this + 7);
  if (!v13)
  {
    v21 = "NHash::get() - zero length hash table";
    goto LABEL_39;
  }
  v14 = __n;
  if ((_DWORD)__n)
  {
    v15 = 0;
    v16 = (char *)__s2;
    v17 = __n;
    do
    {
      v18 = *v16++;
      v15 = v18 + 65599 * v15;
      --v17;
    }
    while (v17);
  }
  else
  {
    v15 = 0;
  }
  v19 = *(_QWORD *)(*((_QWORD *)this + 2) + 32 * (v15 % v13) + 8);
  if (!v19)
  {
    v21 = "NLinkedList::get Attempted to get element that is not in list";
LABEL_39:
    Error::chuck((Error *)v21, v12);
  }
  v20 = __s2;
  v21 = "NLinkedList::get Attempted to get element that is not in list";
  while ((_DWORD)v14 != *(_DWORD *)(v19 + 24) || memcmp(*(const void **)(v19 + 32), v20, v14))
  {
    v19 = *(_QWORD *)(v19 + 8);
    if (!v19)
      goto LABEL_39;
  }
  v38[0] = &off_24C7F2AB0;
  v38[1] = &off_24C7F2CA0;
  v22 = v39;
  if (v39)
  {
    v23 = *(_QWORD *)(v39 - 8);
    if (v23)
    {
      v24 = v39 + 32 * v23;
      v25 = v24;
      do
      {
        *(_QWORD *)(v25 - 32) = off_24C7F1480;
        v25 -= 32;
        for (j = *(_QWORD *)(v25 + 8); j; j = *(_QWORD *)(v24 - 24))
        {
          *(_QWORD *)(v24 - 24) = *(_QWORD *)(j + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v24 - 32) + 72))(v25);
        }
        *(_QWORD *)(v24 - 16) = 0;
        *(_DWORD *)(v24 - 8) = 0;
        v24 = v25;
      }
      while (v25 != v22);
    }
    MEMORY[0x212BAC9C0](v22 - 16, 0x10A1C80F4A7E088);
  }
  v35 = &off_24C7F32C0;
  if (v37)
    MEMORY[0x212BAC9C0](v37, 0x1000C8077774924);
  v32 = &off_24C7F32C0;
  if (__s2)
    MEMORY[0x212BAC9C0](__s2, 0x1000C8077774924);
  return v19 + 40;
}

void sub_20DA00E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v24;
  uint64_t v25;

  if (a24)
    MEMORY[0x212BAC9C0](a24, 0x1000C8077774924);
  a19 = v25;
  if (a21)
    MEMORY[0x212BAC9C0](a21, 0x1000C8077774924);
  NConfigSection::~NConfigSection((NConfigSection *)&a11);
  MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_20DA00ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  NMap<NString,NConfigSection>::HashItem::~HashItem((uint64_t *)va);
  _Unwind_Resume(a1);
}

void AccelFFT::~AccelFFT(vDSP_DFT_SetupStruct **this)
{
  vDSP_DFT_SetupStruct *v2;
  vDSP_DFT_SetupStruct *v3;

  v2 = *this;
  if (v2)
    vDSP_DFT_DestroySetup(v2);
  this[3] = (vDSP_DFT_SetupStruct *)&off_24C7F3090;
  v3 = this[4];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
}

{
  vDSP_DFT_SetupStruct *v2;
  vDSP_DFT_SetupStruct *v3;

  v2 = *this;
  if (v2)
    vDSP_DFT_DestroySetup(v2);
  this[3] = (vDSP_DFT_SetupStruct *)&off_24C7F3090;
  v3 = this[4];
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8052888210);
}

vDSP_DFT_Setup AccelFFT::init(vDSP_DFT_SetupStruct **this, const char *a2, unsigned int *a3, const unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  BOOL v7;
  vDSP_DFT_SetupStruct *v12;
  unsigned int v14;
  vDSP_DFT_SetupStruct *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _OWORD *v20;
  __int128 *v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  int *v27;
  int v28;
  vDSP_DFT_Setup result;

  v4 = *(unsigned int *)a2;
  v5 = *a3;
  v6 = *a4;
  if ((_DWORD)v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (v7 || (_DWORD)v6 == 0)
    Error::chuck((Error *)"AccelFFT::init() - these lengths have to be strictly positive: a_iWindowLen (=%u), a_iDFTLen (=%u) and a_iNPoints (=%u)", a2, v4, *a3, v6);
  v12 = *this;
  if (v12)
  {
    vDSP_DFT_DestroySetup(v12);
    v5 = *a3;
  }
  *((_DWORD *)this + 3) = v5;
  *((_DWORD *)this + 5) = *a4;
  *((_DWORD *)this + 4) = *(_DWORD *)a2;
  v14 = *((_DWORD *)this + 10);
  if (v14 != v5)
  {
    v15 = this[4];
    *((_DWORD *)this + 10) = v5;
    v16 = operator new[]();
    this[4] = (vDSP_DFT_SetupStruct *)v16;
    v5 = *((_DWORD *)this + 3);
    if (v14 >= v5)
      v17 = v5;
    else
      v17 = v14;
    if (!(_DWORD)v17)
    {
      if (!v15)
        goto LABEL_28;
      goto LABEL_27;
    }
    if (v17 >= 8 && (unint64_t)(v16 - (_QWORD)v15) > 0x1F)
    {
      v19 = v17 & 0xFFFFFFF8;
      v20 = (_OWORD *)(v16 + 16);
      v21 = (__int128 *)((char *)v15 + 16);
      v22 = v19;
      do
      {
        v23 = *v21;
        *(v20 - 1) = *(v21 - 1);
        *v20 = v23;
        v20 += 2;
        v21 += 2;
        v22 -= 8;
      }
      while (v22);
      if (v19 == v17)
        goto LABEL_27;
    }
    else
    {
      v19 = 0;
    }
    v24 = v17 - v19;
    v25 = 4 * v19;
    v26 = (_DWORD *)(v16 + 4 * v19);
    v27 = (int *)((char *)v15 + v25);
    do
    {
      v28 = *v27++;
      *v26++ = v28;
      --v24;
    }
    while (v24);
LABEL_27:
    MEMORY[0x212BAC9C0](v15, 0x1000C8052888210);
    v5 = *((_DWORD *)this + 3);
  }
LABEL_28:
  result = vDSP_DFT_zrop_CreateSetup(0, v5, vDSP_DFT_FORWARD);
  *this = result;
  *((_BYTE *)this + 8) = 1;
  return result;
}

void AccelFFT::zeroPadData(uint64_t a1, uint64_t a2)
{
  memcpy(*(void **)(a1 + 32), *(const void **)(a2 + 8), 4 * *(unsigned int *)(a1 + 16));
  bzero((void *)(*(_QWORD *)(a1 + 32) + 4 * *(unsigned int *)(a1 + 16)), 4 * (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 16)));
}

void AccelFFT::run(uint64_t a1, uint64_t a2, const DSPSplitComplex *a3)
{
  uint64_t v4;
  float __B;

  if (!*(_BYTE *)(a1 + 8))
    Error::chuck((Error *)"AccelFFT::run() - You need to call AccelFFT::init() before running the FFT", (const char *)a2);
  v4 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v4 != *(_DWORD *)(a1 + 16))
    Error::chuck((Error *)"AccelFFT::run() - length of input array should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 16), v4);
  memcpy(*(void **)(a1 + 32), *(const void **)(a2 + 8), 4 * v4);
  bzero((void *)(*(_QWORD *)(a1 + 32) + 4 * *(unsigned int *)(a1 + 16)), 4 * (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 16)));
  vDSP_ctoz(*(const DSPComplex **)(a1 + 32), 2, a3, 1, (unint64_t)*(unsigned int *)(a1 + 12) >> 1);
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)a1, a3->realp, a3->imagp, a3->realp, a3->imagp);
  __B = 0.5;
  vDSP_vsmul(a3->realp, 1, &__B, a3->realp, 1, (unint64_t)*(unsigned int *)(a1 + 12) >> 1);
  vDSP_vsmul(a3->imagp, 1, &__B, a3->imagp, 1, (unint64_t)*(unsigned int *)(a1 + 12) >> 1);
}

void sub_20DA014D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Error::error(Error *this, const char *a2, ...)
{
  FILE **v3;
  va_list va;

  va_start(va, a2);
  v3 = (FILE **)MEMORY[0x24BDAC8D8];
  fwrite("ERROR: ", 7uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  vfprintf(*v3, (const char *)this, va);
  fputc(10, *v3);
  exit(1);
}

uint64_t Error::warning(Error *this, const char *a2, ...)
{
  FILE **v3;
  va_list va;

  va_start(va, a2);
  v3 = (FILE **)MEMORY[0x24BDAC8D8];
  fwrite("WARNING: ", 9uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  vfprintf(*v3, (const char *)this, va);
  return fputc(10, *v3);
}

void Error::chuck(Error *this, const char *a2, ...)
{
  NString *exception;
  char __str[1024];
  uint64_t v4;
  va_list va;

  va_start(va, a2);
  v4 = *MEMORY[0x24BDAC8D0];
  vsnprintf(__str, 0x3FFuLL, (const char *)this, va);
  exception = (NString *)__cxa_allocate_exception(0x18uLL);
  NString::NString(exception, __str);
}

void sub_20DA03170(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sanity_check_model(uint64_t a1, unint64_t a2, unsigned int *a3)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;

  if (*(_DWORD *)a1 != 1330397763 || *(_DWORD *)(a1 + 4) != 171013698)
    return 0;
  v3 = 0;
  if (!(a2 >> 30) && *(_DWORD *)(a1 + 8) == 2)
  {
    v4 = *(_DWORD *)(a1 + 28);
    v6 = *(unsigned int *)(a1 + 12);
    v5 = *(unsigned int *)(a1 + 16);
    v7 = *(unsigned int *)(a1 + 20);
    v8 = *(_DWORD *)(a1 + 24);
    v10 = *(_DWORD *)(a1 + 32);
    v9 = *(_DWORD *)(a1 + 36);
    v12 = *(_DWORD *)(a1 + 40);
    v11 = *(_DWORD *)(a1 + 44);
    v3 = (v5 | v6 | v7 | v8 | v4 | v10 | v9 | v12 | v11) >> 30;
    if ((_DWORD)v3)
      return 0;
    if (v8 >= v7 && v6 + 44 <= v5 && v5 + 68 <= v7 && v10 >= v4 + v8)
    {
      v13 = v9 + v10;
      if (v12 >= v13 && v11 + v12 <= a2)
      {
        v14 = 0;
        v15 = -2;
        v16 = 0;
        if (v6 <= a2 && a2 >= 0x30 && v13 <= a2)
        {
          if (v6 >= 0x40 && *(_DWORD *)(a1 + 48) == 1919706177)
          {
            v15 = 0;
            v16 = *(_DWORD *)(a1 + 52);
            v17 = 52;
            v18 = 52;
LABEL_20:
            v19 = 0;
            v20 = 0;
            v21 = 67;
            v22 = 1;
            v23 = 1;
            while (1)
            {
              v23 += v21;
              v20 += v23;
              if (v19 <= 0xFFE && v22 < v17)
              {
                ++v19;
              }
              else
              {
                v23 %= 0xFFF1u;
                v20 %= 0xFFF1u;
                if (v22 >= v17)
                  goto LABEL_28;
                v19 = 0;
              }
              v21 = *(unsigned __int8 *)(a1 + v22++);
            }
          }
          v16 = 0;
          v15 = -1;
          if ((_DWORD)v13)
          {
            v17 = v13;
            v18 = v13;
            goto LABEL_20;
          }
          v23 = 1;
          v18 = 0;
          v20 = 0;
LABEL_28:
          if (v18 >= v13)
          {
            v14 = v23 | (v20 << 16);
          }
          else
          {
            v24 = (v20 + 4 * v23) % 0xFFF1;
            v25 = v18 + 4;
            v26 = (v13 - v25);
            if ((_DWORD)v26)
            {
              v28 = 0;
              v29 = 0;
              v30 = a1 + v25;
              while (1)
              {
                while (1)
                {
                  v23 += *(unsigned __int8 *)(v30 + v29);
                  v24 += v23;
                  v31 = v29 + 1;
                  if (v28 > 0xFFE || v31 >= v26)
                    break;
                  ++v28;
                  ++v29;
                }
                v23 %= 0xFFF1u;
                v24 %= 0xFFF1u;
                if (v31 >= v26)
                  break;
                v28 = 0;
                ++v29;
              }
            }
            v14 = v23 | (v24 << 16);
          }
        }
        if (a3)
          *a3 = v14;
        if (v15 == -1 || !v15 && v14 == v16)
          return NDeepnetDistribution::verifyMemoryImage((NDeepnetDistribution *)(a1 + *(unsigned int *)(a1 + 24)), (const char *)(a1 + 28), a3) == 0;
        return 0;
      }
    }
  }
  return v3;
}

IntNovDetectE *_nde_create(const char *a1, unint64_t a2)
{
  uint64_t v3;
  const char *v4;
  unint64_t v5;
  uint64_t v6;
  IntNovDetectE *v7;
  const char *v9;
  unsigned int v10;
  uint64_t v11;
  size_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;

  if (!NMemPool::m_bLocked)
    return 0;
  v16 = 0;
  if (!sanity_check_model((uint64_t)a1, a2, &v16))
    return 0;
  v3 = *((unsigned int *)a1 + 4);
  v4 = &a1[*((unsigned int *)a1 + 3)];
  v5 = *((unsigned int *)a1 + 6);
  if (v4[40])
  {
    v6 = *((unsigned int *)a1 + 5);
    if (v6 + 12 > v5)
      return 0;
    v9 = &a1[v6];
  }
  else
  {
    v9 = 0;
  }
  v10 = *((_DWORD *)a1 + 7);
  v11 = *((unsigned int *)a1 + 8);
  v14 = *((_DWORD *)a1 + 9);
  v15 = v10;
  v12 = *((unsigned int *)a1 + 11);
  if (v12 >> 30)
    Error::chuck((Error *)"NMemPool::init - pool size too large", (const char *)v12);
  NMemPool::m_pData = (uint64_t)&a1[*((unsigned int *)a1 + 10)];
  NMemPool::m_iSize = v12;
  NMemPool::m_iAlignBytes = 16;
  NMemPool::m_bLocked = 0;
  NMemPool::m_iPos = 0;
  bzero((void *)NMemPool::m_pData, v12);
  v7 = (IntNovDetectE *)operator new();
  IntNovDetectE::IntNovDetectE(v7);
  if ((gIsMultiInstance & 1) == 0)
    gpNovDetect = (uint64_t)v7;
  *((_DWORD *)v7 + 274) = v16;
  v13 = IntNovDetectE::init((uint64_t)v7, (uint64_t)v4, (uint64_t)&a1[v3], (uint64_t)v9, &a1[v5], &v15, &a1[v11], &v14);
  NMemPool::m_bLocked = 1;
  if (v13)
  {
    IntNovDetectE::~IntNovDetectE(v7);
    MEMORY[0x212BAC9D8]();
    v7 = 0;
    gpNovDetect = 0;
  }
  return v7;
}

void sub_20DA03868(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  __cxa_end_catch();
  *(_BYTE *)(v1 + 408) = 1;
  JUMPOUT(0x20DA03834);
}

void sub_20DA0387C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9D8](v1, 0x10F0C401ECB8852);
  _Unwind_Resume(a1);
}

IntNovDetectE *nde_create(const char *a1, unint64_t a2)
{
  IntNovDetectE *result;

  result = 0;
  if (a2 >= 0x30 && a1 && ((gpNovDetect != 0) & ~gIsMultiInstance) == 0)
  {
    result = _nde_create(a1, a2);
    if ((gIsMultiInstance & 1) == 0)
      gHasValidModel = result != 0;
  }
  return result;
}

uint64_t nde_process(uint64_t a1, const char *a2, signed int a3, char *a4, uint64_t a5)
{
  BOOL v7;
  BOOL v8;
  uint64_t result;
  char v10;
  __int16 v11;

  if (!a4)
    return 0xFFFFFFFFLL;
  if (!gHasValidModel)
  {
    result = 0;
LABEL_18:
    v10 = 0;
    goto LABEL_19;
  }
  v7 = a1 == 0;
  if ((gIsMultiInstance & 1) == 0)
  {
    if (a1)
      v8 = gpNovDetect == a1;
    else
      v8 = 0;
    v7 = !v8;
  }
  result = 0xFFFFFFFFLL;
  if (!a5)
    goto LABEL_18;
  if (!a2)
    goto LABEL_18;
  if (a3 < 0)
    goto LABEL_18;
  if (v7)
    goto LABEL_18;
  v11 = 0;
  result = IntNovDetectE::process(a1, a2, a3, (_BYTE *)&v11 + 1, &v11, a5);
  if (!v11)
    goto LABEL_18;
  v10 = 1;
LABEL_19:
  *a4 = v10;
  return result;
}

uint64_t nde_process_v2(uint64_t a1, const char *a2, signed int a3, int *a4, uint64_t a5)
{
  uint64_t v5;
  BOOL v7;
  BOOL v8;
  int v9;
  __int16 v11;

  v5 = gHasValidModel;
  if (gHasValidModel)
  {
    v7 = a1 == 0;
    if ((gIsMultiInstance & 1) == 0)
    {
      if (a1)
        v8 = gpNovDetect == a1;
      else
        v8 = 0;
      v7 = !v8;
    }
    v5 = 0xFFFFFFFFLL;
    if (a5)
    {
      if (a4)
      {
        if (a2)
        {
          if ((a3 & 0x80000000) == 0 && !v7)
          {
            v11 = 0;
            v5 = IntNovDetectE::process(a1, a2, a3, (_BYTE *)&v11 + 1, &v11, a5);
            v9 = HIBYTE(v11);
            *a4 = HIBYTE(v11);
            if ((_BYTE)v11)
              *a4 = v9 | 2;
          }
        }
      }
    }
  }
  return v5;
}

uint64_t nde_processframe(uint64_t a1, float32x4_t *a2, unsigned int a3, BOOL *a4, uint64_t a5)
{
  uint64_t v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  char v11;
  char v12;

  if (!a4)
    return 0xFFFFFFFFLL;
  v12 = 0;
  v6 = gHasValidModel;
  if (gHasValidModel)
  {
    v7 = a1 == 0;
    if ((gIsMultiInstance & 1) == 0)
    {
      if (a1)
        v8 = gpNovDetect == a1;
      else
        v8 = 0;
      v7 = !v8;
    }
    v9 = 0;
    v6 = 0xFFFFFFFFLL;
    if (a5 && a2 && (a3 & 0x80000000) == 0 && !v7)
    {
      v6 = IntNovDetectE::processframe(a1, a2, a3, &v12, &v11, a5);
      v9 = v12 != 0;
    }
  }
  else
  {
    v9 = 0;
  }
  *a4 = v9;
  return v6;
}

uint64_t nde_processframe_v2(uint64_t a1, float32x4_t *a2, unsigned int a3, int *a4, uint64_t a5)
{
  uint64_t v5;
  BOOL v7;
  BOOL v8;
  int v9;
  __int16 v11;

  v11 = 0;
  v5 = gHasValidModel;
  if (gHasValidModel)
  {
    v7 = a1 == 0;
    if ((gIsMultiInstance & 1) == 0)
    {
      if (a1)
        v8 = gpNovDetect == a1;
      else
        v8 = 0;
      v7 = !v8;
    }
    v5 = 0xFFFFFFFFLL;
    if (a5)
    {
      if (a4)
      {
        if (a2)
        {
          if ((a3 & 0x80000000) == 0 && !v7)
          {
            v5 = IntNovDetectE::processframe(a1, a2, a3, (_BYTE *)&v11 + 1, &v11, a5);
            v9 = HIBYTE(v11);
            *a4 = HIBYTE(v11);
            if ((_BYTE)v11)
              *a4 = v9 | 2;
          }
        }
      }
    }
  }
  return v5;
}

uint64_t nde_getchecksum(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  if ((gIsMultiInstance & 1) != 0)
  {
    if (!a1)
      return 0xFFFFFFFFLL;
LABEL_7:
    result = 0;
    *a2 = *(_DWORD *)(a1 + 1096);
    return result;
  }
  result = 0xFFFFFFFFLL;
  if (a1 && gpNovDetect == a1)
    goto LABEL_7;
  return result;
}

uint64_t nde_reset(IntNovDetectE *a1)
{
  uint64_t v1;

  v1 = gHasValidModel;
  if (gHasValidModel)
  {
    if ((gIsMultiInstance & 1) != 0)
    {
      if (!a1)
        return 0xFFFFFFFFLL;
LABEL_7:
      IntNovDetectE::reset(a1);
      return 0;
    }
    v1 = 0xFFFFFFFFLL;
    if (a1 && (IntNovDetectE *)gpNovDetect == a1)
      goto LABEL_7;
  }
  return v1;
}

uint64_t nde_destroy(IntNovDetectE *a1)
{
  uint64_t v1;

  v1 = gHasValidModel;
  if (!gHasValidModel)
  {
    gHasValidModel = 1;
    return v1;
  }
  if ((gIsMultiInstance & 1) != 0)
  {
    if (!a1)
      return 0xFFFFFFFFLL;
LABEL_8:
    IntNovDetectE::~IntNovDetectE(a1);
    MEMORY[0x212BAC9D8]();
    v1 = 0;
    gpNovDetect = 0;
    return v1;
  }
  v1 = 0xFFFFFFFFLL;
  if (a1 && (IntNovDetectE *)gpNovDetect == a1)
    goto LABEL_8;
  return v1;
}

uint64_t nde_enable_multiinstance()
{
  gpNovDetect = 0;
  gHasValidModel = 1;
  gIsMultiInstance = 1;
  return 0;
}

uint64_t NDBlobBuildBlob(const char *a1, const char *a2, N16ByteAlignedString *a3, int a4, void *a5, unsigned int a6)
{
  uint64_t result;
  const char *v13;
  size_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  BOOL v21[8];
  unsigned int v22;
  void *v23;
  unsigned int v24;
  void *memptr;
  int v26;
  void *v27;
  _QWORD v28[2];
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a5)
  {
    v21[0] = 0;
    NConfig::NConfig((NConfig *)v28, v21);
    *(_QWORD *)v21 = &off_24C7F32C0;
    v22 = strlen(a1);
    v23 = (void *)operator new[]();
    memcpy(v23, a1, v22 + 1);
    memptr = &off_24C7F32C0;
    v26 = strlen(a2);
    v27 = (void *)operator new[]();
    memcpy(v27, a2, (v26 + 1));
    NConfig::load((NConfig *)v28, (const NString *)v21, (const NString *)&memptr);
    memptr = &off_24C7F32C0;
    if (v27)
      MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
    *(_QWORD *)v21 = &off_24C7F32C0;
    if (v23)
      MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
    *(_QWORD *)v21 = &off_24C7F2108;
    v24 = 16;
    memptr = 0;
    if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
      Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v13, 1, v24);
    v22 = 0;
    v23 = memptr;
    *(_QWORD *)v21 = &off_24C7F2108;
    *(_BYTE *)memptr = 0;
    BlobBuilder::buildBlob((BlobBuilder *)v28, (const NConfig *)v21, a3, a4);
    v14 = v22;
    v15 = v23;
    if (v22 <= a6)
    {
      bzero(a5, a6);
      memcpy(a5, v15, v14);
    }
    *(_QWORD *)v21 = &off_24C7F2108;
    free(v15);
    v28[0] = &off_24C7F2A90;
    v28[1] = &off_24C7F2C68;
    v16 = v29;
    if (v29)
    {
      v17 = *(_QWORD *)(v29 - 8);
      if (v17)
      {
        v18 = v29 + 32 * v17;
        v19 = v18;
        do
        {
          *(_QWORD *)(v19 - 32) = off_24C7F1420;
          v19 -= 32;
          for (i = *(_QWORD *)(v19 + 8); i; i = *(_QWORD *)(v18 - 24))
          {
            *(_QWORD *)(v18 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v18 - 32) + 72))(v19);
          }
          *(_QWORD *)(v18 - 16) = 0;
          *(_DWORD *)(v18 - 8) = 0;
          v18 = v19;
        }
        while (v19 != v16);
      }
      MEMORY[0x212BAC9C0](v16 - 16, 0x10A1C80F4A7E088);
    }
    if (v14 <= a6)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_20DA04254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, __int128 buf, uint64_t a20)
{
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t i;
  void *v27;
  void *v28;
  _QWORD *v29;
  NSObject *v30;
  _QWORD *v31;
  NSObject *v32;
  uint64_t (*v33)(void *);
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;

  if (!a2)
    _Unwind_Resume(exception_object);
  N16ByteAlignedString::~N16ByteAlignedString((void **)&a12);
  *(_QWORD *)&buf = &off_24C7F2A90;
  *((_QWORD *)&buf + 1) = &off_24C7F2C68;
  v22 = a20;
  if (a20)
  {
    v23 = *(_QWORD *)(a20 - 8);
    if (v23)
    {
      v24 = a20 + 32 * v23;
      v25 = v24;
      do
      {
        *(_QWORD *)(v25 - 32) = off_24C7F1420;
        v25 -= 32;
        for (i = *(_QWORD *)(v25 + 8); i; i = *(_QWORD *)(v24 - 24))
        {
          *(_QWORD *)(v24 - 24) = *(_QWORD *)(i + 8);
          (*(void (**)(uint64_t))(*(_QWORD *)(v24 - 32) + 72))(v25);
        }
        *(_QWORD *)(v24 - 16) = 0;
        *(_DWORD *)(v24 - 8) = 0;
        v24 = v25;
      }
      while (v25 != v22);
    }
    MEMORY[0x212BAC9C0](v22 - 16, 0x10A1C80F4A7E088);
  }
  if (a2 == 3)
  {
    v27 = __cxa_begin_catch(exception_object);
    v28 = (void *)VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      v33 = *(uint64_t (**)(void *))(*(_QWORD *)v27 + 16);
      v34 = v28;
      v35 = v33(v27);
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = v35;
      _os_log_error_impl(&dword_20D965000, v34, OS_LOG_TYPE_ERROR, "CorealisRT Blob build failed: %{public}s", (uint8_t *)&buf, 0xCu);

    }
  }
  else
  {
    v29 = __cxa_begin_catch(exception_object);
    v30 = VTLogContextFacilityVoiceTrigger;
    if (a2 == 2)
    {
      v31 = v29;
      v32 = (id)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v36 = v31[2];
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = v36;
        _os_log_error_impl(&dword_20D965000, v32, OS_LOG_TYPE_ERROR, "CorealisRT Blob build failed: %{public}s", (uint8_t *)&buf, 0xCu);
      }

      __cxa_end_catch();
LABEL_22:
      JUMPOUT(0x20DA04200);
    }
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_20D965000, v30, OS_LOG_TYPE_ERROR, "CorealisRT Blob build failed: Unknown throw", (uint8_t *)&buf, 2u);
    }
  }
  __cxa_end_catch();
  goto LABEL_22;
}

uint64_t NDBlobGetBlobSize(const char *a1, const char *a2, N16ByteAlignedString *a3, int a4, _DWORD *a5)
{
  uint64_t result;
  const char *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  BOOL v18[8];
  int v19;
  void *v20;
  int v21;
  void *memptr;
  int v23;
  void *v24;
  _QWORD v25[2];
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a5)
  {
    *a5 = 0;
    v18[0] = 0;
    NConfig::NConfig((NConfig *)v25, v18);
    *(_QWORD *)v18 = &off_24C7F32C0;
    v19 = strlen(a1);
    v20 = (void *)operator new[]();
    memcpy(v20, a1, (v19 + 1));
    memptr = &off_24C7F32C0;
    v23 = strlen(a2);
    v24 = (void *)operator new[]();
    memcpy(v24, a2, (v23 + 1));
    NConfig::load((NConfig *)v25, (const NString *)v18, (const NString *)&memptr);
    memptr = &off_24C7F32C0;
    if (v24)
      MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
    *(_QWORD *)v18 = &off_24C7F32C0;
    if (v20)
      MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
    v21 = 16;
    memptr = 0;
    if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
      Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v11, 1, 16);
    v19 = 0;
    v20 = memptr;
    *(_QWORD *)v18 = &off_24C7F2108;
    *(_BYTE *)memptr = 0;
    BlobBuilder::buildBlob((BlobBuilder *)v25, (const NConfig *)v18, a3, a4);
    v12 = v19;
    *(_QWORD *)v18 = &off_24C7F2108;
    free(v20);
    v25[0] = &off_24C7F2A90;
    v25[1] = &off_24C7F2C68;
    v13 = v26;
    if (v26)
    {
      v14 = *(_QWORD *)(v26 - 8);
      if (v14)
      {
        v15 = v26 + 32 * v14;
        v16 = v15;
        do
        {
          *(_QWORD *)(v16 - 32) = off_24C7F1420;
          v16 -= 32;
          for (i = *(_QWORD *)(v16 + 8); i; i = *(_QWORD *)(v15 - 24))
          {
            *(_QWORD *)(v15 - 24) = *(_QWORD *)(i + 8);
            (*(void (**)(uint64_t))(*(_QWORD *)(v15 - 32) + 72))(v16);
          }
          *(_QWORD *)(v15 - 16) = 0;
          *(_DWORD *)(v15 - 8) = 0;
          v15 = v16;
        }
        while (v16 != v13);
      }
      MEMORY[0x212BAC9C0](v13 - 16, 0x10A1C80F4A7E088);
    }
    result = 0;
    *a5 = v12;
  }
  return result;
}

void sub_20DA0477C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, __int128 buf)
{
  void *v21;
  void *v22;
  _QWORD *v23;
  NSObject *v24;
  _QWORD *v25;
  NSObject *v26;
  uint64_t (*v27)(void *);
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;

  if (!a2)
    _Unwind_Resume(a1);
  N16ByteAlignedString::~N16ByteAlignedString(&a12);
  NConfig::~NConfig((NConfig *)&buf);
  if (a2 == 3)
  {
    v21 = __cxa_begin_catch(a1);
    v22 = (void *)VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      v27 = *(uint64_t (**)(void *))(*(_QWORD *)v21 + 16);
      v28 = v22;
      v29 = v27(v21);
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = v29;
      _os_log_error_impl(&dword_20D965000, v28, OS_LOG_TYPE_ERROR, "Failed to get CorealisRT Blob size: %{public}s", (uint8_t *)&buf, 0xCu);

    }
  }
  else
  {
    v23 = __cxa_begin_catch(a1);
    v24 = VTLogContextFacilityVoiceTrigger;
    if (a2 == 2)
    {
      v25 = v23;
      v26 = (id)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v30 = v25[2];
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = v30;
        _os_log_error_impl(&dword_20D965000, v26, OS_LOG_TYPE_ERROR, "Failed to get CorealisRT Blob size: %{public}s", (uint8_t *)&buf, 0xCu);
      }

      __cxa_end_catch();
LABEL_14:
      JUMPOUT(0x20DA0472CLL);
    }
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_20D965000, v24, OS_LOG_TYPE_ERROR, "Faied to get CorealisRT Blob size: Unknown throw", (uint8_t *)&buf, 2u);
    }
  }
  __cxa_end_catch();
  goto LABEL_14;
}

uint64_t NDBlobGetDefaultBlobSize()
{
  return 0xFFFFFFFFLL;
}

uint64_t NDBlobBuildDefaultBlob()
{
  return 0xFFFFFFFFLL;
}

void NFile::~NFile(NFile *this)
{
  NFile::~NFile(this);
  JUMPOUT(0x212BAC9D8);
}

{
  std::ios_base *v2;
  uint64_t v3;
  int v4;

  *(_QWORD *)this = &off_24C7F2AF0;
  if (*((_QWORD *)this + 23))
  {
    if (!std::filebuf::close())
    {
      v2 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 40);
      std::ios_base::clear(v2, v2->__rdstate_ | 4);
    }
    v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  }
  MEMORY[0x212BAC8C4]((char *)this + 64);
  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8]((char *)this + 472);
  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
}

uint64_t NFile::open(NFile *this, const NString *a2, const NString *a3)
{
  _QWORD *v6;
  const char *v7;
  _BYTE *v8;
  int v9;
  int v10;
  uint64_t v11;
  std::ios_base *v12;
  std::ios_base::iostate v13;
  const char *v14;
  uint64_t result;

  (*(void (**)(NFile *))(*(_QWORD *)this + 24))(this);
  v6 = (_QWORD *)((char *)this + 40);
  std::ios_base::clear((std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 40), 0);
  v8 = (_BYTE *)*((_QWORD *)a3 + 2);
  if (*((_DWORD *)a3 + 2) != 1)
    goto LABEL_16;
  v9 = *v8;
  if (v9 == 114)
  {
    v10 = 0;
    goto LABEL_8;
  }
  if (v9 == 119)
  {
    v10 = 1;
    goto LABEL_8;
  }
  v8 = (_BYTE *)*((_QWORD *)a3 + 2);
  if (*v8 != 97)
LABEL_16:
    Error::chuck((Error *)"NFile::open() - invalid mode %s", v7, v8);
  v10 = 2;
LABEL_8:
  *((_DWORD *)this + 156) = v10;
  v11 = std::filebuf::open();
  v12 = (std::ios_base *)((char *)v6 + *(_QWORD *)(*((_QWORD *)this + 5) - 24));
  if (v11)
    v13 = 0;
  else
    v13 = v12->__rdstate_ | 4;
  std::ios_base::clear(v12, v13);
  if (!*((_QWORD *)this + 23))
    Error::chuck((Error *)"NFile::open() - file %s failed to open (mode %s)", v14, *((_QWORD *)a2 + 2), *((_QWORD *)a3 + 2));
  if (*(_DWORD *)((char *)v6 + *(_QWORD *)(*v6 - 24) + 32))
    Error::chuck((Error *)"NFile::open() - file %s opens with error (mode %s)", v14, *((_QWORD *)a2 + 2), *((_QWORD *)a3 + 2));
  result = (uint64_t)this + 8;
  if ((NFile *)((char *)this + 8) != a2)
    return (*(uint64_t (**)(uint64_t, _QWORD, char *))(*(_QWORD *)result + 64))(result, *((_QWORD *)a2 + 2), (char *)a2 + 8);
  return result;
}

uint64_t NFile::close(NFile *this)
{
  uint64_t result;
  std::ios_base *v3;
  int v4;

  result = (*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this);
  if ((_DWORD)result)
  {
    if (!std::filebuf::close())
    {
      v3 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 40);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    v4 = 0;
    return (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 1) + 64))((char *)this + 8, "", &v4);
  }
  return result;
}

BOOL NFile::isOpen(NFile *this)
{
  return *((_QWORD *)this + 23) != 0;
}

uint64_t NFile::eof(NFile *this)
{
  return (*((unsigned __int8 *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 72) >> 1) & 1;
}

BOOL NFile::good(NFile *this)
{
  return *(_DWORD *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 72) == 0;
}

uint64_t NFile::read@<X0>(NFile *this@<X0>, uint64_t a2@<X8>)
{
  const char *v4;
  _BYTE *v5;
  int64_t v6;
  void *v7;
  const char *v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  void *v13;
  int v15;

  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::read() - cannot read, file %s is not open", v4, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 156))
    Error::chuck((Error *)"NFile::read() - cannot read, file %s not opened in read mode", v4, *((_QWORD *)this + 3));
  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 0;
  v5 = (_BYTE *)operator new[]();
  *(_QWORD *)(a2 + 16) = v5;
  *v5 = 0;
  v6 = *((unsigned int *)this + 8);
  v7 = (void *)operator new[]();
  bzero(v7, v6);
  *((_BYTE *)v7 + v6) = 0;
  std::istream::read();
  v9 = *((_QWORD *)this + 6);
  if (v9 != v6)
  {
    if (v6 < v9)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v8, *((_QWORD *)this + 6), v6);
    v10 = (void *)operator new[]();
    memcpy(v10, v7, v9);
    *((_BYTE *)v10 + v9) = 0;
    if ((_DWORD)v9)
    {
      v15 = v9;
      (*(void (**)(uint64_t, void *, int *))(*(_QWORD *)a2 + 72))(a2, v10, &v15);
    }
    goto LABEL_12;
  }
  if ((_DWORD)v6)
  {
    v15 = v6;
    (*(void (**)(uint64_t, void *, int *))(*(_QWORD *)a2 + 72))(a2, v7, &v15);
  }
  while (*((_QWORD *)this + 6) == v6)
  {
    v6 <<= v6 < 0x80000;
    v10 = (void *)operator new[]();
    bzero(v10, v6);
    *((_BYTE *)v10 + v6) = 0;
    std::istream::read();
    v12 = *((_QWORD *)this + 6);
    if (v6 == v12)
    {
      if ((_DWORD)v6)
      {
        v15 = v6;
        (*(void (**)(uint64_t, void *, int *))(*(_QWORD *)a2 + 72))(a2, v10, &v15);
      }
    }
    else
    {
      if (v6 < v12)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v11, *((_QWORD *)this + 6), v6);
      v13 = (void *)operator new[]();
      memcpy(v13, v10, v12);
      *((_BYTE *)v13 + v12) = 0;
      if ((_DWORD)v12)
      {
        v15 = v12;
        (*(void (**)(uint64_t, void *, int *))(*(_QWORD *)a2 + 72))(a2, v13, &v15);
      }
      MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
    }
LABEL_12:
    MEMORY[0x212BAC9C0](v10, 0x1000C8077774924);
  }
  return MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
}

void sub_20DA04EE4()
{
  uint64_t v0;

  MEMORY[0x212BAC9C0](v0, 0x1000C8077774924);
  JUMPOUT(0x20DA04F18);
}

void sub_20DA04F14(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  MEMORY[0x212BAC9C0](v3, 0x1000C8077774924);
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  *v1 = v4;
  v6 = v1[2];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NFile::read(NFile *this@<X0>, const unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v6;
  size_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  void *v12;

  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) != 0)
  {
    if (!*((_DWORD *)this + 156))
    {
      v7 = *a2;
      if ((_DWORD)v7 != -1)
      {
        v8 = (void *)operator new[]();
        bzero(v8, v7);
        *((_BYTE *)v8 + v7) = 0;
        std::istream::read();
        v10 = *((_QWORD *)this + 6);
        if (*a2 <= v10)
        {
          *(_QWORD *)a3 = &off_24C7F32C0;
          *(_DWORD *)(a3 + 8) = v7;
          v12 = (void *)operator new[]();
          *(_QWORD *)(a3 + 16) = v12;
          memcpy(v12, v8, (v7 + 1));
        }
        else
        {
          if (v7 < v10)
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, *((_QWORD *)this + 6), v7);
          *(_QWORD *)a3 = &off_24C7F32C0;
          *(_DWORD *)(a3 + 8) = v10;
          v11 = (void *)operator new[]();
          *(_QWORD *)(a3 + 16) = v11;
          memcpy(v11, v8, v10);
          *((_BYTE *)v11 + v10) = 0;
        }
        JUMPOUT(0x212BAC9C0);
      }
      Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((_QWORD *)this + 3));
    }
    Error::chuck((Error *)"NFile::read() - cannot read, file %s not opened in read mode", v6, *((_QWORD *)this + 3));
  }
  Error::chuck((Error *)"NFile::read() - cannot read, file %s is not open", v6, *((_QWORD *)this + 3));
}

void sub_20DA05110(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFile::read(NFile *this, const unsigned int *a2, NString *a3)
{
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t (**v12)(NString *__hidden, const unsigned int *);
  int v13;
  void *v14;

  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::read() - cannot read, file %s is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 156))
    Error::chuck((Error *)"NFile::read() - cannot read, file %s not opened in read mode", v6, *((_QWORD *)this + 3));
  if (*a2 == -1)
    Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((_QWORD *)this + 3));
  (*(void (**)(NString *, const unsigned int *))(*(_QWORD *)a3 + 56))(a3, a2);
  std::istream::read();
  v8 = *((_QWORD *)this + 6);
  if (*a2 > v8)
  {
    v9 = *((unsigned int *)a3 + 2);
    if (v9 < v8)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v7, *((_QWORD *)this + 6), v9);
    v10 = (const void *)*((_QWORD *)a3 + 2);
    v12 = &off_24C7F32C0;
    if (!v10)
      Error::chuck((Error *)"Null pointer passed to string constructor", v7);
    v13 = v8;
    v14 = (void *)operator new[]();
    memcpy(v14, v10, v8);
    *((_BYTE *)v14 + v8) = 0;
    (*(void (**)(NString *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 32))(a3, &v12);
    v12 = &off_24C7F32C0;
    if (v14)
      MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  }
  return *((unsigned int *)a3 + 2);
}

void sub_20DA052B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NFile::readLine@<X0>(NFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE *v6;

  *(_QWORD *)a3 = &off_24C7F32C0;
  *(_DWORD *)(a3 + 8) = 0;
  v6 = (_BYTE *)operator new[]();
  *(_QWORD *)(a3 + 16) = v6;
  *v6 = 0;
  return (*(uint64_t (**)(NFile *, const char *, uint64_t))(*(_QWORD *)this + 128))(this, a2, a3);
}

void sub_20DA05354(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *v1 = v2;
  v4 = v1[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NFile::readString@<X0>(NFile *this@<X0>, uint64_t a2@<X8>)
{
  const char *v4;
  const char *v5;
  _BYTE *v6;
  const char *v7;
  _BYTE *v9;

  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::readString() - cannot read, file %s is not open", v4, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 156))
    Error::chuck((Error *)"NFile::readString() - cannot read, file %s not opened in read mode", v4, *((_QWORD *)this + 3));
  std::istream::read();
  if (*((_QWORD *)this + 6) != 4)
    Error::chuck((Error *)"NFile::readString() - failed to read length for embedded binary string in %s", v5, *((_QWORD *)this + 3));
  v6 = (_BYTE *)operator new[]();
  bzero(v6, 0);
  *v6 = 0;
  std::istream::read();
  if (*((_QWORD *)this + 6))
    Error::chuck((Error *)"NFile::readString() - failed to read embedded binary string in %s", v7, *((_QWORD *)this + 3));
  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 0;
  v9 = (_BYTE *)operator new[]();
  *(_QWORD *)(a2 + 16) = v9;
  *v9 = 0;
  return MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
}

void sub_20DA05508(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFile::write(NFile *this, const NString *a2)
{
  const char *v3;

  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::write() cannot write, file %s is not open", v3, *((_QWORD *)this + 3));
  if (!*((_DWORD *)this + 156))
    Error::chuck((Error *)"NFile::write() cannot write, file %s opened in read mode", v3, *((_QWORD *)this + 3));
  return std::ostream::write();
}

uint64_t NFile::setPosition(NFile *this, const unsigned int *a2)
{
  const char *v4;
  uint64_t v5;
  int v6;
  _QWORD *v7;
  char *v8;
  _QWORD *v9;
  char *v10;
  const char *v11;
  _BYTE v13[16];
  _QWORD v14[16];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::setPosition() - cannot set position, file %s is not open", v4, *((_QWORD *)this + 3));
  v5 = *a2;
  v6 = *((_DWORD *)this + 156);
  if ((_DWORD)v5 == -1)
  {
    if (v6)
    {
      v9 = (_QWORD *)((char *)this + 56);
      MEMORY[0x212BAC918](v13, (char *)this + 56);
      v10 = (char *)v9 + *(_QWORD *)(*v9 - 24);
      if ((v10[32] & 5) == 0)
      {
        (*(void (**)(_QWORD *__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v10 + 5) + 32))(v14, *((_QWORD *)v10 + 5), 0, 2, 16);
        if (v15 == -1)
          std::ios_base::clear((std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)), *(_DWORD *)((char *)v9 + *(_QWORD *)(*v9 - 24) + 32) | 4);
      }
      goto LABEL_11;
    }
  }
  else if (v6)
  {
    v7 = (_QWORD *)((char *)this + 56);
    MEMORY[0x212BAC918](v13, (char *)this + 56);
    v8 = (char *)v7 + *(_QWORD *)(*v7 - 24);
    if ((v8[32] & 5) == 0)
    {
      (*(void (**)(_QWORD *__return_ptr, _QWORD, uint64_t, _QWORD, uint64_t))(**((_QWORD **)v8 + 5) + 32))(v14, *((_QWORD *)v8 + 5), v5, 0, 16);
      if (v15 == -1)
        std::ios_base::clear((std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)), *(_DWORD *)((char *)v7 + *(_QWORD *)(*v7 - 24) + 32) | 4);
    }
LABEL_11:
    MEMORY[0x212BAC924](v13);
    goto LABEL_13;
  }
  std::istream::seekg();
LABEL_13:
  if (*(_DWORD *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 72))
    Error::chuck((Error *)"NFile::setPosition() - problem with stream, file %s", v11, *((_QWORD *)this + 3));
  return 1;
}

void sub_20DA0577C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  MEMORY[0x212BAC924](va);
  _Unwind_Resume(a1);
}

uint64_t NFile::getPosition(NFile *this)
{
  const char *v2;
  char *v3;
  _QWORD v5[18];

  v5[17] = *MEMORY[0x24BDAC8D0];
  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::getPosition() - cannot get position, file %s is not open", v2, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 156))
  {
    v3 = (char *)this + *(_QWORD *)(*((_QWORD *)this + 7) - 24) + 56;
    if ((v3[32] & 5) != 0)
      return -1;
    (*(void (**)(_QWORD *__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v3 + 5) + 32))(v5, *((_QWORD *)v3 + 5), 0, 1, 16);
  }
  else
  {
    std::istream::tellg();
  }
  return v5[16];
}

uint64_t NFile::readLine(NFile *this, const char *a2, NString *a3)
{
  const char *v6;
  char *v7;
  _QWORD *v8;
  std::ios_base *v9;
  std::ios_base::iostate rdstate;
  const char *v11;
  std::ios_base::iostate v12;
  int v13;
  uint64_t v14;
  const void *v15;
  void *v16;
  uint64_t (**v18)(NString *__hidden, const unsigned int *);
  int v19;
  void *v20;
  uint64_t (**v21)(NString *, const unsigned int *);
  unsigned int v22;
  uint64_t v23;

  if (((*(uint64_t (**)(NFile *))(*(_QWORD *)this + 32))(this) & 1) == 0)
    Error::chuck((Error *)"NFile::readLine() - cannot read, file %s is not open", v6, *((_QWORD *)this + 3));
  if (*((_DWORD *)this + 156))
    Error::chuck((Error *)"NFile::readLine() - cannot read, file %s not opened in read mode", v6, *((_QWORD *)this + 3));
  v21 = &off_24C7F32C0;
  v22 = 0;
  v7 = (char *)operator new[]();
  v23 = (uint64_t)v7;
  *v7 = 0;
  if (*((_DWORD *)this + 8))
  {
    NString::deallocate((NString *)&v21, v7);
    v23 = (*v21)((NString *)&v21, (const unsigned int *)this + 8);
    v22 = *((_DWORD *)this + 8);
    *(_BYTE *)(v23 + v22) = 0;
    v7 = (char *)v23;
  }
  v8 = (_QWORD *)((char *)this + 40);
  std::istream::getline();
  (*(void (**)(NString *, char *))(*(_QWORD *)a3 + 40))(a3, v7);
  v9 = (std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24));
  rdstate = v9->__rdstate_;
  if ((rdstate & 2) == 0 && (rdstate & 5) != 0)
  {
    do
    {
      if (*((_DWORD *)this + 8) - 1 != *((_DWORD *)this + 12))
        break;
      std::ios_base::clear(v9, 0);
      std::istream::getline();
      v18 = &off_24C7F32C0;
      if (!v7)
        Error::chuck((Error *)"Null pointer passed to string constructor", v11);
      v19 = strlen(v7);
      v20 = (void *)operator new[]();
      memcpy(v20, v7, (v19 + 1));
      (*(void (**)(NString *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 48))(a3, &v18);
      v18 = &off_24C7F32C0;
      if (v20)
        MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
      v9 = (std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24));
      v12 = v9->__rdstate_;
      if ((v12 & 2) != 0)
        break;
    }
    while ((v12 & 5) != 0);
  }
  v13 = *((_DWORD *)a3 + 2);
  if (v13)
  {
    v14 = (v13 - 1);
    v15 = (const void *)*((_QWORD *)a3 + 2);
    if (*((_BYTE *)v15 + v14) == 13)
    {
      v18 = &off_24C7F32C0;
      v19 = v13 - 1;
      v16 = (void *)operator new[]();
      v20 = v16;
      memcpy(v16, v15, (v13 - 1));
      *((_BYTE *)v16 + v14) = 0;
      (*(void (**)(NString *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 32))(a3, &v18);
      v18 = &off_24C7F32C0;
      if (v20)
        MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
    }
  }
  if (*a2)
    (*(void (**)(NString *, _QWORD))(*(_QWORD *)a3 + 120))(a3, *a2);
  v21 = &off_24C7F32C0;
  if (v23)
    MEMORY[0x212BAC9C0](v23, 0x1000C8077774924);
  return (v13 + 1);
}

void sub_20DA05B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void (__cdecl ***std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this)))(std::fstream *__hidden this)
{
  _QWORD *v2;

  v2 = a1 + 54;
  MEMORY[0x212BAC8C4](a1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8](v2);
  return a1;
}

void std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this))
{
  _QWORD *v1;

  v1 = a1 + 54;
  MEMORY[0x212BAC8C4](a1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8](v1);
  JUMPOUT(0x212BAC9D8);
}

void `non-virtual thunk to'std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this))
{
  MEMORY[0x212BAC8C4](a1 + 1);
  std::iostream::~basic_iostream();
  JUMPOUT(0x212BAC9A8);
}

{
  _QWORD *v1;

  v1 = a1 + 52;
  MEMORY[0x212BAC8C4](a1 + 1);
  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8](v1);
  JUMPOUT(0x212BAC9D8);
}

void `virtual thunk to'std::fstream::~fstream(_QWORD *a1)
{
  void (__cdecl ***v1)(std::fstream *__hidden);

  v1 = (void (__cdecl ***)(std::fstream *__hidden))((char *)a1 + *(_QWORD *)(*a1 - 24));
  MEMORY[0x212BAC8C4](v1 + 3);
  std::iostream::~basic_iostream();
  JUMPOUT(0x212BAC9A8);
}

{
  void (__cdecl ***v1)(std::fstream *__hidden);

  v1 = (void (__cdecl ***)(std::fstream *__hidden))((char *)a1 + *(_QWORD *)(*a1 - 24));
  MEMORY[0x212BAC8C4](v1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8](v1 + 54);
  JUMPOUT(0x212BAC9D8);
}

void NFile::NFile(NFile *this)
{
  _BYTE *v2;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v2;
  *v2 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F2AF0;
  *((_QWORD *)this + 5) = &unk_24C7F04B0;
  *((_QWORD *)this + 59) = &unk_24C7F04D8;
  *((_QWORD *)this + 6) = 0;
  std::ios_base::init((std::ios_base *)((char *)this + 472), (char *)this + 64);
  *((_QWORD *)this + 76) = 0;
  *((_DWORD *)this + 154) = -1;
  MEMORY[0x212BAC8B8]((char *)this + 64);
}

void sub_20DA06014(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  std::iostream::~basic_iostream();
  MEMORY[0x212BAC9A8](v2);
  *v1 = v3;
  v1[1] = v4;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NFile::NFile(NFile *this, const NString *a2, const NString *a3)
{
  _BYTE *v6;

  *(_QWORD *)this = off_24C7F3428;
  *((_QWORD *)this + 1) = &off_24C7F32C0;
  *((_DWORD *)this + 4) = 0;
  v6 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 3) = v6;
  *v6 = 0;
  *((_DWORD *)this + 8) = 256;
  *(_QWORD *)this = &off_24C7F2AF0;
  *((_QWORD *)this + 5) = &unk_24C7F04B0;
  *((_QWORD *)this + 59) = &unk_24C7F04D8;
  *((_QWORD *)this + 6) = 0;
  std::ios_base::init((std::ios_base *)((char *)this + 472), (char *)this + 64);
  *((_QWORD *)this + 76) = 0;
  *((_DWORD *)this + 154) = -1;
  MEMORY[0x212BAC8B8]((char *)this + 64);
  (*(void (**)(NFile *, const NString *, const NString *))(*(_QWORD *)this + 16))(this, a2, a3);
}

void sub_20DA06170(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void (__cdecl ***v2)(std::fstream *__hidden);
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  std::fstream::~fstream(v2);
  *v1 = v3;
  v1[1] = v4;
  v6 = v1[3];
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFile::flush(NFile *this)
{
  return std::ostream::flush();
}

void NDEFrameProc::NDEFrameProc(NDEFrameProc *this)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F31A8;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 0;
  *((_BYTE *)this + 36) = 0;
}

{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24C7F31A8;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 0;
  *((_BYTE *)this + 36) = 0;
}

float NDEFrameProc::init(NDEFrameProc *this, unsigned int *a2, float *a3, float *a4, const BOOL *a5)
{
  unsigned int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  _OWORD *v16;
  __int128 *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  int *v23;
  int v24;
  float result;

  v9 = *((_DWORD *)this + 4);
  if (v9 != *a2)
  {
    v11 = *((_QWORD *)this + 1);
    *((_DWORD *)this + 4) = *a2;
    v12 = operator new[]();
    *((_QWORD *)this + 1) = v12;
    LODWORD(v13) = *a2;
    if (v9 >= *a2)
      v13 = v13;
    else
      v13 = v9;
    if (!(_DWORD)v13)
    {
      if (!v11)
        goto LABEL_19;
      goto LABEL_18;
    }
    if (v13 >= 8 && (unint64_t)(v12 - v11) > 0x1F)
    {
      v15 = v13 & 0xFFFFFFF8;
      v16 = (_OWORD *)(v12 + 16);
      v17 = (__int128 *)(v11 + 16);
      v18 = v15;
      do
      {
        v19 = *v17;
        *(v16 - 1) = *(v17 - 1);
        *v16 = v19;
        v16 += 2;
        v17 += 2;
        v18 -= 8;
      }
      while (v18);
      if (v15 == v13)
        goto LABEL_18;
    }
    else
    {
      v15 = 0;
    }
    v20 = v13 - v15;
    v21 = 4 * v15;
    v22 = (_DWORD *)(v12 + 4 * v15);
    v23 = (int *)(v11 + v21);
    do
    {
      v24 = *v23++;
      *v22++ = v24;
      --v20;
    }
    while (v20);
LABEL_18:
    MEMORY[0x212BAC9C0](v11, 0x1000C8052888210);
  }
LABEL_19:
  *((float *)this + 7) = *a3;
  *((_BYTE *)this + 36) = *a5;
  result = *a4;
  *((float *)this + 8) = *a4;
  *((_BYTE *)this + 24) = 1;
  return result;
}

NDEFrameProc *NDEFrameProc::apply(NDEFrameProc *this, float32x4_t *a2, const unsigned int *a3)
{
  uint64_t v4;
  uint64_t v5;
  const float *v7;
  unint64_t v8;
  uint64_t v9;
  const float *v10;
  float32x4_t *v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v15;
  float32x4_t v17;
  const float *v18;
  _OWORD *v19;
  uint64_t v20;
  float32x4_t v21;
  __int128 v22;
  float v23;
  __int128 v24;
  float v25;
  __int128 v26;
  uint64_t v27;
  float *v28;
  float *v29;
  float v30;
  unint64_t v31;
  BOOL v33;
  float32x4_t v35;
  float32x4_t *v36;
  float32x4_t *v37;
  uint64_t v38;
  float32x4_t v39;
  uint64_t v40;
  uint64_t v41;
  float *v42;
  float *v43;
  float v44;
  float32x4_t v46;
  float v47;
  __int128 v48;
  __int128 v49;
  float32x4_t v50;

  if (!*((_BYTE *)this + 24))
    Error::chuck((Error *)"NDEFrameProc::doLog() - init() must be called first", (const char *)a2, a3);
  v4 = *a3;
  v5 = *((unsigned int *)this + 4);
  if ((_DWORD)v4 != (_DWORD)v5)
    Error::chuck((Error *)"NDEFrameProc::doLog() - input frame size mismatch (%d != %d)", (const char *)a2, *a3, v5);
  if (!*((_BYTE *)this + 36))
  {
    if (!(_DWORD)v4)
      return this;
    v10 = (const float *)((char *)this + 28);
    v11 = (float32x4_t *)*((_QWORD *)this + 1);
    if (v4 > 0xB)
    {
      v12 = 0;
      v31 = (unint64_t)v11->u64 + 4 * v4;
      v33 = v11 < (float32x4_t *)this + 2 && (unint64_t)v10 < v31;
      if ((v31 <= (unint64_t)a2 || v11 >= (float32x4_t *)&a2->f32[v4]) && !v33)
      {
        v12 = v4 & 0xFFFFFFF8;
        v35 = vld1q_dup_f32(v10);
        v36 = v11 + 1;
        v37 = a2 + 1;
        v38 = v12;
        do
        {
          v39 = vaddq_f32(*v37, v35);
          v36[-1] = vaddq_f32(v37[-1], v35);
          *v36 = v39;
          v36 += 2;
          v37 += 2;
          v38 -= 8;
        }
        while (v38);
        if (v12 == v4)
          return this;
      }
    }
    else
    {
      v12 = 0;
    }
    v40 = v4 - v12;
    v41 = v12;
    v42 = &v11->f32[v41];
    v43 = &a2->f32[v41];
    do
    {
      v44 = *v43++;
      *v42++ = v44 + *v10;
      --v40;
    }
    while (v40);
    return this;
  }
  if (!(_DWORD)v4)
    return this;
  v7 = (const float *)((char *)this + 28);
  v8 = *((_QWORD *)this + 1);
  if (v4 <= 7)
  {
    v9 = 0;
LABEL_25:
    v27 = v4 - v9;
    v28 = (float *)(v8 + 4 * v9);
    v29 = &a2->f32[v9];
    do
    {
      v30 = *v29++;
      *v28++ = logf(v30 + *v7);
      --v27;
    }
    while (v27);
    return this;
  }
  v9 = 0;
  v13 = v8 + 4 * v4;
  v15 = v8 < (unint64_t)this + 32 && (unint64_t)v7 < v13;
  if (v13 > (unint64_t)a2 && v8 < (unint64_t)a2->u64 + 4 * v4)
    goto LABEL_25;
  if (v15)
    goto LABEL_25;
  v9 = v4 & 0xFFFFFFFC;
  v17 = vld1q_dup_f32(v7);
  v46 = v17;
  v18 = (const float *)a2;
  v19 = (_OWORD *)*((_QWORD *)this + 1);
  v20 = v9;
  do
  {
    v21 = *(float32x4_t *)v18;
    v18 += 4;
    v50 = vaddq_f32(v21, v46);
    v47 = logf(v50.f32[1]);
    *(float *)&v22 = logf(v50.f32[0]);
    *((float *)&v22 + 1) = v47;
    v48 = v22;
    v23 = logf(v50.f32[2]);
    v24 = v48;
    *((float *)&v24 + 2) = v23;
    v49 = v24;
    v25 = logf(v50.f32[3]);
    v26 = v49;
    *((float *)&v26 + 3) = v25;
    *v19++ = v26;
    v20 -= 4;
  }
  while (v20);
  if (v9 != v4)
    goto LABEL_25;
  return this;
}

uint64_t NDEFrameProc::frameSize(NDEFrameProc *this)
{
  return *((unsigned int *)this + 4);
}

float NDEFrameProc::get_framerate(NDEFrameProc *this)
{
  return *((float *)this + 8);
}

void softLink_AnalyticsSendEventLazy(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v1 = a1;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v2 = getAnalyticsSendEventLazySymbolLoc_ptr;
  v7 = getAnalyticsSendEventLazySymbolLoc_ptr;
  if (getAnalyticsSendEventLazySymbolLoc_ptr)
    goto LABEL_7;
  v8 = 0;
  if (CoreAnalyticsLibraryCore_frameworkLibrary)
  {
    v2 = (void *)CoreAnalyticsLibraryCore_frameworkLibrary;
  }
  else
  {
    v9 = xmmword_24C7F4818;
    v10 = 0;
    CoreAnalyticsLibraryCore_frameworkLibrary = _sl_dlopen();
    v3 = v8;
    v2 = (void *)CoreAnalyticsLibraryCore_frameworkLibrary;
    if (!CoreAnalyticsLibraryCore_frameworkLibrary)
    {
      v3 = (void *)abort_report_np();
      goto LABEL_11;
    }
    if (v8)
      goto LABEL_12;
  }
  while (1)
  {
    v2 = dlsym(v2, "AnalyticsSendEventLazy");
    v5[3] = (uint64_t)v2;
    getAnalyticsSendEventLazySymbolLoc_ptr = v2;
LABEL_7:
    _Block_object_dispose(&v4, 8);
    if (v2)
      break;
    dlerror();
    v3 = (void *)abort_report_np();
LABEL_11:
    __break(1u);
LABEL_12:
    free(v3);
  }
  ((void (*)(const __CFString *, id))v2)(CFSTR("com.apple.voicetrigger"), v1);

}

void sub_20DA078C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL gIsPrime(unsigned int *a1)
{
  unsigned int v1;
  _BOOL8 result;
  unsigned int v3;

  v1 = *a1;
  if (*a1 - 1 < 3)
    return 1;
  if ((v1 & 1) == 0)
    return 0;
  if (v1 < 9)
    return 1;
  v3 = 3;
  while (1)
  {
    result = v1 % v3 != 0;
    if (!(v1 % v3))
      break;
    v3 += 2;
    if (v3 * v3 > v1)
      return 1;
  }
  return result;
}

uint64_t gNextPrime(const unsigned int *a1)
{
  uint64_t result;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  result = *a1;
  if ((result - 1) >= 2)
  {
    v2 = result | 1;
    if ((result & 0xFFFFFFFE) >= 3)
    {
      while (v2 >= 9)
      {
        v3 = 3;
        while (v2 % v3)
        {
          v3 += 2;
          if (v3 * v3 > v2)
            return v2;
        }
        result = (v2 + 2);
        v4 = v2 + 1;
        v2 = result;
        if (v4 <= 2)
          return result;
      }
    }
    return v2;
  }
  return result;
}

void NOffsetFile::~NOffsetFile(NOffsetFile *this)
{
  NFile::~NFile(this);
  JUMPOUT(0x212BAC9D8);
}

BOOL NOffsetFile::eof(NOffsetFile *this)
{
  return (*((_BYTE *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 72) & 2) != 0
      || *((_DWORD *)this + 159) >= *((_DWORD *)this + 158);
}

BOOL NOffsetFile::good(NOffsetFile *this)
{
  return !*(_DWORD *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 5) - 24) + 72)
      && *((_DWORD *)this + 159) < *((_DWORD *)this + 158);
}

void NOffsetFile::read(NOffsetFile *this@<X0>, uint64_t a2@<X8>)
{
  int v2;
  unsigned int v3;

  v2 = *((_DWORD *)this + 158);
  if (v2 == -1)
  {
    *((_DWORD *)this + 159) = -1;
    NFile::read(this, a2);
  }
  else
  {
    v3 = v2 - *((_DWORD *)this + 159);
    *((_DWORD *)this + 159) = v2;
    NFile::read(this, &v3, a2);
  }
}

void NOffsetFile::read(NOffsetFile *this@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  int v3;
  unsigned int v4;
  unsigned int v5;

  v3 = *((_DWORD *)this + 159);
  v4 = *((_DWORD *)this + 158) - v3;
  if (*a2 < v4)
    v4 = *a2;
  v5 = v4;
  *((_DWORD *)this + 159) = v4 + v3;
  NFile::read(this, &v5, a3);
}

uint64_t NOffsetFile::read(NOffsetFile *this, unsigned int *a2, NString *a3)
{
  int v3;
  unsigned int v4;
  unsigned int v6;

  v3 = *((_DWORD *)this + 159);
  v4 = *((_DWORD *)this + 158) - v3;
  if (*a2 < v4)
    v4 = *a2;
  v6 = v4;
  *((_DWORD *)this + 159) = v4 + v3;
  return NFile::read(this, &v6, a3);
}

uint64_t NOffsetFile::readString@<X0>(NOffsetFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  const char *v6;
  uint64_t result;
  const char *v8;
  int v9;
  uint64_t (**v10)(NString *__hidden, const unsigned int *);
  int v11;
  int *v12;
  int v13;

  if ((*((_DWORD *)this + 159) + 4) > *((_DWORD *)this + 158))
    goto LABEL_8;
  v9 = 4;
  (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *), NOffsetFile *, int *))(*(_QWORD *)this + 64))(&v10, this, &v9);
  if (v11 != 4)
  {
    v10 = &off_24C7F32C0;
    if (v12)
      MEMORY[0x212BAC9C0](v12, 0x1000C8077774924);
LABEL_8:
    Error::chuck((Error *)"NOffsetFile::readString() - cannot read length for embedded binary string in %s", a2, *((_QWORD *)this + 3));
  }
  v13 = *v12;
  v5 = v13;
  v10 = &off_24C7F32C0;
  MEMORY[0x212BAC9C0]();
  if ((v5 + *((_DWORD *)this + 159)) > *((_DWORD *)this + 158))
    Error::chuck((Error *)"NOffsetFile::readString() - cannot read embedded binary string in %s", v6, *((_QWORD *)this + 3));
  result = (*(uint64_t (**)(NOffsetFile *, int *))(*(_QWORD *)this + 64))(this, &v13);
  if (*(_DWORD *)(a3 + 8) != v13)
    Error::chuck((Error *)"NOffsetFile::readString() - failed to read embedded binary string in %s", v8, *((_QWORD *)this + 3));
  return result;
}

void sub_20DA09FCC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v4;

  *v1 = v2;
  v4 = v1[2];
  if (v4)
    MEMORY[0x212BAC9C0](v4, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NOffsetFile::setPosition(NOffsetFile *this, const unsigned int *a2)
{
  uint64_t result;
  unsigned int v5;
  unsigned int v6;

  if (*a2 + *((_DWORD *)this + 157) > *((_DWORD *)this + 158))
    return 0;
  v6 = *a2 + *((_DWORD *)this + 157);
  result = NFile::setPosition(this, &v6);
  if ((result & 1) != 0)
    v5 = *a2 + *((_DWORD *)this + 157);
  else
    v5 = *((_DWORD *)this + 158);
  *((_DWORD *)this + 159) = v5;
  return result;
}

uint64_t NOffsetFile::getPosition(NOffsetFile *this)
{
  return (*((_DWORD *)this + 159) - *((_DWORD *)this + 157));
}

uint64_t NOffsetFile::readLine(NOffsetFile *this, const char *a2, NString *a3)
{
  const char *v5;
  unsigned int Line;
  int v7;
  uint64_t v8;
  unsigned int v9;
  size_t v10;
  const void *v11;
  uint64_t result;
  uint64_t (**v13)(NString *__hidden, const unsigned int *);
  int v14;
  void *v15;

  Line = NFile::readLine(this, a2, a3);
  v7 = *((_DWORD *)this + 159);
  v8 = *((unsigned int *)a3 + 2);
  v9 = *((_DWORD *)this + 158);
  if ((int)v8 + v7 > v9)
  {
    v10 = v9 - v7;
    if (v8 < (_DWORD)v8 + v7 - v9)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v5, v9 - v7, v8);
    v11 = (const void *)*((_QWORD *)a3 + 2);
    v13 = &off_24C7F32C0;
    if (!v11)
      Error::chuck((Error *)"Null pointer passed to string constructor", v5);
    v14 = v9 - v7;
    v15 = (void *)operator new[]();
    memcpy(v15, v11, v10);
    *((_BYTE *)v15 + v10) = 0;
    (*(void (**)(NString *, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a3 + 32))(a3, &v13);
    v13 = &off_24C7F32C0;
    if (v15)
      MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
    v9 = *((_DWORD *)this + 158);
    v7 = *((_DWORD *)this + 159);
  }
  if (v7 + Line <= v9)
    result = Line;
  else
    result = v9 - v7;
  *((_DWORD *)this + 159) = result + v7;
  return result;
}

void sub_20DA0A198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NOffsetFile::open(NOffsetFile *this, const NString *a2, const NString *a3, const unsigned int *a4, const unsigned int *a5)
{
  unsigned int v8;
  uint64_t result;
  const char *v10;

  *((_DWORD *)this + 157) = *a4;
  v8 = *a5 + *a4;
  *((_DWORD *)this + 158) = v8;
  *((_DWORD *)this + 159) = v8;
  NFile::open(this, a2, a3);
  result = NFile::setPosition(this, a4);
  if ((result & 1) == 0)
    Error::chuck((Error *)"NOffsetFile::open() - opened at invalid offset %d in %s\n", v10, *a4, *((_QWORD *)a2 + 2));
  *((_DWORD *)this + 159) = *((_DWORD *)this + 157);
  return result;
}

void NOffsetFile::NOffsetFile(NOffsetFile *this)
{
  uint64_t v1;

  NFile::NFile(this);
  *(_QWORD *)v1 = &off_24C7F15D0;
  *(_DWORD *)(v1 + 628) = 0;
  *(_QWORD *)(v1 + 632) = 0xFFFFFFFFLL;
}

{
  uint64_t v1;

  NFile::NFile(this);
  *(_QWORD *)v1 = &off_24C7F15D0;
  *(_DWORD *)(v1 + 628) = 0;
  *(_QWORD *)(v1 + 632) = 0xFFFFFFFFLL;
}

void NOffsetFile::NOffsetFile(NOffsetFile *this, const NString *a2, const NString *a3, const unsigned int *a4, const unsigned int *a5)
{
  uint64_t v10;
  unsigned int v11;
  const char *v12;

  NFile::NFile(this);
  *(_QWORD *)v10 = &off_24C7F15D0;
  *(_QWORD *)(v10 + 628) = 0xFFFFFFFF00000000;
  *(_DWORD *)(v10 + 636) = 0;
  *(_DWORD *)(v10 + 628) = *a4;
  v11 = *a5 + *a4;
  *(_DWORD *)(v10 + 632) = v11;
  *(_DWORD *)(v10 + 636) = v11;
  NFile::open((NFile *)v10, a2, a3);
  if ((NFile::setPosition(this, a4) & 1) == 0)
    Error::chuck((Error *)"NOffsetFile::open() - opened at invalid offset %d in %s\n", v12, *a4, *((_QWORD *)a2 + 2));
  *((_DWORD *)this + 159) = *((_DWORD *)this + 157);
}

void sub_20DA0A364(_Unwind_Exception *a1)
{
  NFile *v1;

  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

void sub_20DA0A624(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_20DA0A8A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  void *v9;
  uint64_t v10;
  NSObject *v12;

  __cxa_begin_catch(a1);
  v12 = *(NSObject **)(v10 + 2744);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_20D965000, v12, OS_LOG_TYPE_DEFAULT, "endAudio failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20DA0A890);
}

void sub_20DA0A990(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  void *v9;
  NSObject *v11;

  __cxa_begin_catch(a1);
  v11 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
  {
    a9 = 0;
    _os_log_error_impl(&dword_20D965000, v11, OS_LOG_TYPE_ERROR, "processAudioBuffer failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20DA0A974);
}

void sub_20DA0A9F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20DA0AA88(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  void *v9;
  NSObject *v11;

  __cxa_begin_catch(a1);
  v11 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
  {
    a9 = 0;
    _os_log_error_impl(&dword_20D965000, v11, OS_LOG_TYPE_ERROR, "processAudioBuffer failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x20DA0AA6CLL);
}

void sub_20DA0AAE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20DA0AE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_20DA0B0B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_20DA0B370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{

  _Unwind_Resume(a1);
}

uint64_t NScrambler::NScrambler(uint64_t a1, uint64_t a2)
{
  char *v4;
  unsigned int v5;
  uint64_t v6;
  int v7;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v4 = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = v4;
  memcpy(v4, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v5 = 0;
  v6 = *(unsigned int *)(a1 + 8);
  if (*(_DWORD *)(a1 + 8))
  {
    do
    {
      v7 = *v4++;
      v5 += v7;
      --v6;
    }
    while (v6);
  }
  *(_WORD *)(a1 + 24) = bswap32(v5) >> 16;
  return a1;
}

{
  char *v4;
  unsigned int v5;
  uint64_t v6;
  int v7;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v4 = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = v4;
  memcpy(v4, *(const void **)(a2 + 16), (*(_DWORD *)(a2 + 8) + 1));
  v5 = 0;
  v6 = *(unsigned int *)(a1 + 8);
  if (*(_DWORD *)(a1 + 8))
  {
    do
    {
      v7 = *v4++;
      v5 += v7;
      --v6;
    }
    while (v6);
  }
  *(_WORD *)(a1 + 24) = bswap32(v5) >> 16;
  return a1;
}

uint64_t NScrambler::keystream(NScrambler *this)
{
  uint64_t v1;

  v1 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = *((_BYTE *)this + 25) + v1;
  return v1;
}

void *NScrambler::convert@<X0>(NScrambler *this@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  char *v7;
  void *result;
  char v9;
  char v10;

  *(_QWORD *)a3 = &off_24C7F32C0;
  v6 = *((unsigned int *)a2 + 2);
  *(_DWORD *)(a3 + 8) = v6;
  v7 = (char *)operator new[]();
  *(_QWORD *)(a3 + 16) = v7;
  for (result = memcpy(v7, a2[2], (*((_DWORD *)a2 + 2) + 1)); v6; --v6)
  {
    v9 = *v7;
    v10 = *((_BYTE *)this + 24);
    *((_BYTE *)this + 24) = *((_BYTE *)this + 25) + v10;
    *v7++ = v10 ^ v9;
  }
  return result;
}

void NScrambler::scramble(NScrambler *this@<X0>, const NString *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  void *v7;
  unint64_t v8;
  uint64_t v9;
  char v10;
  char v11;
  uint64_t (**v12)(NString *__hidden, const unsigned int *);
  unsigned int v13;
  void *v14;

  v12 = &off_24C7F32C0;
  v13 = *((_DWORD *)a2 + 2);
  v6 = v13;
  v7 = (void *)operator new[]();
  v14 = v7;
  memcpy(v7, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
  v9 = 0;
  if (v13)
  {
    do
    {
      v10 = *((_BYTE *)v7 + v9);
      v11 = *((_BYTE *)this + 24);
      *((_BYTE *)this + 24) = *((_BYTE *)this + 25) + v11;
      *((_BYTE *)v7 + v9++) = v11 ^ v10;
    }
    while (v6 != v9);
  }
  base64_encode((const NString *)&v12, a3, v8);
  JUMPOUT(0x212BAC9C0);
}

void sub_20DA0B670(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void *base64_encode@<X0>(const NString *a1@<X0>, uint64_t a2@<X8>, unint64_t a3@<D0>)
{
  _BYTE *v5;
  unint64_t v6;
  unsigned int v7;
  char v8;
  char v9;
  unsigned int v10;
  char *v11;
  unsigned int v12;
  char *v13;
  _WORD *v14;
  _WORD *v15;
  void *v16;
  void *v17;
  void *result;
  double v19;
  int v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  uint64_t (**v24)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__src;
  int32x2_t v27;
  unsigned int v28;

  LODWORD(a3) = *((_DWORD *)a1 + 2);
  v19 = (double)a3;
  LODWORD(__n) = 0;
  v5 = (_BYTE *)operator new[]();
  *v5 = 0;
  __src = v5;
  v24 = &off_24C7F11D8;
  v27 = vmovn_s64((int64x2_t)vcvtq_u64_f64(vmulq_n_f64((float64x2_t)xmmword_20DA246B0, v19)));
  MEMORY[0x212BAC9C0]();
  v6 = 0;
  v7 = 0;
  __src = (void *)NString::allocate((NString *)&v24, (const unsigned int *)&v27);
  *(_BYTE *)__src = 0;
  while (v6 < *((unsigned int *)a1 + 2))
  {
    *(&v21 + v7++) = *(_BYTE *)(*((_QWORD *)a1 + 2) + v6);
    if (v7 == 3)
    {
      v8 = base64_table[((unint64_t)v22 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v21 & 3))];
      LOBYTE(v20) = base64_table[(unint64_t)v21 >> 2];
      BYTE1(v20) = v8;
      v9 = base64_table[v23 & 0x3F];
      BYTE2(v20) = base64_table[((unint64_t)v23 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v22 & 0xF))];
      HIBYTE(v20) = v9;
      v10 = __n + 4;
      if ((__n + 4) < v27.i32[0])
      {
        *(_DWORD *)((char *)__src + __n) = v20;
        *((_BYTE *)__src + v10) = 0;
      }
      else
      {
        v28 = v27.i32[1] + v10;
        v11 = (char *)(*v24)((NString *)&v24, &v28);
        memcpy(v11, __src, __n);
        *(_DWORD *)&v11[__n] = v20;
        v11[v10] = 0;
        v24[1]((NString *)&v24, (const unsigned int *)__src);
        __src = v11;
        v27.i32[0] = v28;
      }
      v7 = 0;
      LODWORD(__n) = v10;
    }
    ++v6;
  }
  if (v7)
  {
    bzero(&v21 + v7, 2 - v7 + 1);
    LOBYTE(v20) = base64_table[(unint64_t)v21 >> 2];
    BYTE1(v20) = base64_table[((unint64_t)v22 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v21 & 3))];
    BYTE2(v20) = base64_table[((unint64_t)v23 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v22 & 0xF))];
    HIBYTE(v20) = base64_table[v23 & 0x3F];
    v12 = v7 + 1 + __n;
    if (v12 >= v27.i32[0])
    {
      v28 = v27.i32[1] + v12;
      v13 = (char *)(*v24)((NString *)&v24, &v28);
      memcpy(v13, __src, __n);
      memcpy(&v13[__n], &v20, v7 + 1);
      v13[v12] = 0;
      v24[1]((NString *)&v24, (const unsigned int *)__src);
      __src = v13;
      v27.i32[0] = v28;
    }
    else
    {
      memcpy((char *)__src + __n, &v20, v7 + 1);
      *((_BYTE *)__src + v12) = 0;
    }
    LODWORD(__n) = v12;
    v14 = (_WORD *)operator new[]();
    *v14 = 61;
    v28 = 1;
    ((void (*)(NAutoString *, const void *, const unsigned int *))v24[9])((NAutoString *)&v24, v14, &v28);
    MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
    if (v7 != 2)
    {
      v15 = (_WORD *)operator new[]();
      *v15 = 61;
      v28 = 1;
      ((void (*)(NAutoString *, const void *, const unsigned int *))v24[9])((NAutoString *)&v24, v15, &v28);
      MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
    }
  }
  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = __n;
  v16 = (void *)operator new[]();
  *(_QWORD *)(a2 + 16) = v16;
  v17 = __src;
  result = memcpy(v16, __src, (__n + 1));
  v24 = &off_24C7F32C0;
  if (v17)
    return (void *)MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  return result;
}

void sub_20DA0BA9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *NScrambler::unscramble@<X0>(NScrambler *this@<X0>, const NString *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  char v10;
  char v11;
  void *result;
  uint64_t (**v13)(NString *__hidden, const unsigned int *);
  unsigned int v14;
  void *v15;
  uint64_t (**v16)(NString *__hidden, const unsigned int *);
  unsigned int v17;
  void *__src;

  v16 = &off_24C7F32C0;
  v17 = 0;
  __src = (void *)operator new[]();
  *(_BYTE *)__src = 0;
  *(_QWORD *)a3 = &off_24C7F32C0;
  *(_DWORD *)(a3 + 8) = 0;
  v6 = (_BYTE *)operator new[]();
  *(_QWORD *)(a3 + 16) = v6;
  *v6 = 0;
  base64_decode(a2, 1, (uint64_t)&v13);
  ((void (*)(uint64_t (***)(NString *__hidden, const unsigned int *), void *, unsigned int *))v16[8])(&v16, v15, &v14);
  v13 = &off_24C7F32C0;
  if (v15)
    MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  v13 = &off_24C7F32C0;
  v7 = v17;
  v14 = v17;
  v8 = (void *)operator new[]();
  v15 = v8;
  memcpy(v8, __src, v17 + 1);
  v9 = 0;
  if (v7)
  {
    do
    {
      v10 = *((_BYTE *)v8 + v9);
      v11 = *((_BYTE *)this + 24);
      *((_BYTE *)this + 24) = *((_BYTE *)this + 25) + v11;
      *((_BYTE *)v8 + v9++) = v11 ^ v10;
    }
    while (v7 != v9);
  }
  NString::assignTo((NString *)a3, v8, &v14);
  v13 = &off_24C7F32C0;
  if (v15)
    MEMORY[0x212BAC9C0](v15, 0x1000C8077774924);
  v16 = &off_24C7F32C0;
  result = __src;
  if (__src)
    return (void *)MEMORY[0x212BAC9C0](__src, 0x1000C8077774924);
  return result;
}

void sub_20DA0BCA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  _QWORD *v14;
  uint64_t v15;
  uint64_t v17;

  if (a11)
    MEMORY[0x212BAC9C0](a11, 0x1000C8077774924);
  v17 = v14[2];
  *v14 = v15;
  if (v17)
    MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
  if (a14)
    MEMORY[0x212BAC9C0](a14, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *base64_decode@<X0>(const NString *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v5;
  _BYTE *v6;
  uint64_t v7;
  unsigned int v8;
  const char *v9;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  int v13;
  int v14;
  BOOL v15;
  uint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char *v21;
  char *v22;
  int v23;
  int v24;
  unsigned int v26;
  uint64_t v27;
  unsigned __int8 v28;
  unsigned int v29;
  unsigned __int8 v30;
  unsigned int v31;
  char *v32;
  void *v33;
  void *v34;
  void *result;
  unsigned __int8 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  unsigned __int8 v40;
  __int16 v41;
  char v42;
  uint64_t (**v43)(NString *__hidden, const unsigned int *);
  size_t __n;
  void *__src;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;

  v5 = *((_DWORD *)a1 + 2);
  LODWORD(__n) = 0;
  v6 = (_BYTE *)operator new[]();
  *v6 = 0;
  __src = v6;
  v43 = &off_24C7F11D8;
  v46 = v5;
  v47 = ((double)v5 * 0.5);
  MEMORY[0x212BAC9C0]();
  v7 = 0;
  v8 = 0;
  __src = (void *)NString::allocate((NString *)&v43, &v46);
  *(_BYTE *)__src = 0;
  v10 = MEMORY[0x24BDAC740];
  while (1)
  {
    v12 = *((_DWORD *)a1 + 2);
    if (v7 >= v12)
      break;
    v13 = *(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7);
    if (*(char *)(*((_QWORD *)a1 + 2) + v7) < 0)
    {
      v14 = __maskrune(*(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7), 0x500uLL);
      v12 = *((_DWORD *)a1 + 2);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * *(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7) + 60) & 0x500;
    }
    v15 = (v13 & 0xFFFFFFFB) != 0x2B && v14 == 0;
    if (v15 && a2 == 0)
      break;
    if (v7 >= v12)
      goto LABEL_49;
    v17 = *(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7);
    if ((_DWORD)v17 == 61)
      break;
    if ((v17 & 0x80) != 0)
      v18 = __maskrune(*(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7), 0x500uLL);
    else
      v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x500;
    if ((v17 & 0xFFFFFFFB) == 0x2B || v18)
    {
      v12 = *((_DWORD *)a1 + 2);
      if (v7 >= v12)
LABEL_49:
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v7, v12 - 1);
      *(&v37 + v8++) = *(_BYTE *)(*((_QWORD *)a1 + 2) + v7);
      if (v8 == 4)
      {
        v37 = base64_revtable[v37];
        v19 = base64_revtable[v39];
        v38 = base64_revtable[v38];
        v39 = v19;
        v40 = base64_revtable[v40];
        LOBYTE(v41) = (4 * v37) | (v38 >> 4) & 3;
        HIBYTE(v41) = (16 * v38) | (v19 >> 2) & 0xF;
        v42 = v40 + ((_BYTE)v19 << 6);
        v20 = __n + 3;
        if ((int)__n + 3 < v46)
        {
          v11 = (char *)__src + __n;
          *(_WORD *)v11 = v41;
          v11[2] = v42;
          *((_BYTE *)__src + v20) = 0;
        }
        else
        {
          v48 = v47 + v20;
          v21 = (char *)(*v43)((NString *)&v43, &v48);
          memcpy(v21, __src, __n);
          v22 = &v21[__n];
          *(_WORD *)v22 = v41;
          v22[2] = v42;
          v21[v20] = 0;
          v43[1]((NString *)&v43, (const unsigned int *)__src);
          __src = v21;
          v46 = v48;
        }
        v8 = 0;
        LODWORD(__n) = v20;
      }
    }
    v7 = (v7 + 1);
  }
  if (v7 < v12)
  {
    v23 = *(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7);
    v24 = *(char *)(*((_QWORD *)a1 + 2) + v7) < 0
        ? __maskrune(*(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7), 0x500uLL)
        : *(_DWORD *)(v10 + 4 * *(unsigned __int8 *)(*((_QWORD *)a1 + 2) + v7) + 60) & 0x500;
    if ((v23 & 0xFFFFFFFB) != 0x2B && v24 == 0)
    {
      v26 = *((_DWORD *)a1 + 2);
      if (v7 >= v26)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v7, v26 - 1);
      v27 = *(char *)(*((_QWORD *)a1 + 2) + v7);
      if ((_DWORD)v27 != 61)
        Error::chuck((Error *)"NScrambler::invalid input at position %d of %d, character code \\x%02x", v9, v7, *((unsigned int *)a1 + 2), v27);
    }
  }
  if (v8)
  {
    if (v7 <= 3)
      bzero(&v37 + v7, (3 - v7) + 1);
    v28 = base64_revtable[v38];
    v29 = base64_revtable[v39];
    v30 = base64_revtable[v40];
    LOBYTE(v41) = (4 * base64_revtable[v37]) | (v28 >> 4) & 3;
    HIBYTE(v41) = (16 * v28) | (v29 >> 2) & 0xF;
    v42 = v30 + ((_BYTE)v29 << 6);
    v31 = v8 - 1 + __n;
    if (v31 >= v46)
    {
      v48 = v47 + v31;
      v32 = (char *)(*v43)((NString *)&v43, &v48);
      memcpy(v32, __src, __n);
      memcpy(&v32[__n], &v41, v8 - 1);
      v32[v31] = 0;
      v43[1]((NString *)&v43, (const unsigned int *)__src);
      __src = v32;
      v46 = v48;
    }
    else
    {
      memcpy((char *)__src + __n, &v41, v8 - 1);
      *((_BYTE *)__src + v31) = 0;
    }
    LODWORD(__n) = v31;
  }
  else
  {
    v31 = __n;
  }
  *(_QWORD *)a3 = &off_24C7F32C0;
  *(_DWORD *)(a3 + 8) = v31;
  v33 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v33;
  v34 = __src;
  result = memcpy(v33, __src, (__n + 1));
  v43 = &off_24C7F32C0;
  if (v34)
    return (void *)MEMORY[0x212BAC9C0](v34, 0x1000C8077774924);
  return result;
}

void sub_20DA0C22C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NString::allocate(NString *this, const unsigned int *a2)
{
  return operator new[]();
}

void NString::deallocate(NString *this, char *a2)
{
  if (a2)
    JUMPOUT(0x212BAC9C0);
}

void NString::~NString(NString *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  JUMPOUT(0x212BAC9D8);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C7F32C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
}

uint64_t NString::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, *(_QWORD *)(a2 + 16), a2 + 8);
  return a1;
}

uint64_t NString::operator=(uint64_t a1, char *__s)
{
  int v5;

  if (!__s)
    Error::chuck((Error *)"NString::assignTo() - Null pointer passed to assign", 0);
  v5 = strlen(__s);
  (*(void (**)(uint64_t, char *, int *))(*(_QWORD *)a1 + 64))(a1, __s, &v5);
  return a1;
}

uint64_t NString::operator+=(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  int v6;

  v3 = *(_DWORD *)(a2 + 8);
  if (v3)
  {
    v4 = *(_QWORD *)(a2 + 16);
    v6 = v3;
    (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 72))(a1, v4, &v6);
  }
  return a1;
}

uint64_t NString::newAllocation(NString *this, const unsigned int *a2)
{
  uint64_t v4;

  if (*a2 != *((_DWORD *)this + 2))
  {
    (*(void (**)(NString *, _QWORD))(*(_QWORD *)this + 8))(this, *((_QWORD *)this + 2));
    v4 = (**(uint64_t (***)(NString *, const unsigned int *))this)(this, a2);
    *((_QWORD *)this + 2) = v4;
    *((_DWORD *)this + 2) = *a2;
    *(_BYTE *)(v4 + *a2) = 0;
  }
  return *((_QWORD *)this + 2);
}

uint64_t NString::assignTo(NString *this, const void *a2, const unsigned int *a3)
{
  void *v5;
  uint64_t result;
  size_t __n;

  if (!a2)
    Error::chuck((Error *)"NString::assignTo() - Null pointer passed to assign", 0, a3);
  LODWORD(__n) = *a3;
  v5 = (void *)(**(uint64_t (***)(NString *, size_t *))this)(this, &__n);
  memcpy(v5, a2, __n);
  *((_BYTE *)v5 + __n) = 0;
  result = (*(uint64_t (**)(NString *, _QWORD))(*(_QWORD *)this + 8))(this, *((_QWORD *)this + 2));
  *((_DWORD *)this + 2) = __n;
  *((_QWORD *)this + 2) = v5;
  return result;
}

uint64_t NString::appendTo(NString *this, const void *a2, const unsigned int *a3)
{
  char *v6;
  uint64_t result;
  unsigned int v8;

  if (!a2)
    Error::chuck((Error *)"NString::appendTo() - Null pointer passed to assign", 0, a3);
  v8 = *a3 + *((_DWORD *)this + 2);
  v6 = (char *)(**(uint64_t (***)(NString *, unsigned int *))this)(this, &v8);
  memcpy(v6, *((const void **)this + 2), *((unsigned int *)this + 2));
  memcpy(&v6[*((unsigned int *)this + 2)], a2, *a3);
  v6[v8] = 0;
  result = (*(uint64_t (**)(NString *, _QWORD))(*(_QWORD *)this + 8))(this, *((_QWORD *)this + 2));
  *((_DWORD *)this + 2) = v8;
  *((_QWORD *)this + 2) = v6;
  return result;
}

uint64_t NString::chomp(uint64_t this)
{
  int v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  int v5;

  v1 = *(_DWORD *)(this + 8);
  if (v1)
  {
    v2 = (v1 - 1);
    if (!(_DWORD)v2)
    {
      v3 = *(_BYTE **)(this + 16);
      if (*v3 != 10)
        return this;
LABEL_7:
      *v3 = 0;
      --*(_DWORD *)(this + 8);
      return this;
    }
    v4 = *(_QWORD *)(this + 16);
    if (*(_BYTE *)(v4 + v2) == 10)
    {
      *(_BYTE *)(v4 + v2) = 0;
      v5 = *(_DWORD *)(this + 8);
      *(_DWORD *)(this + 8) = v5 - 1;
      v3 = (_BYTE *)(*(_QWORD *)(this + 16) + (v5 - 2));
      if (*v3 == 13)
        goto LABEL_7;
    }
  }
  return this;
}

NString *NString::printf(NString *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  (*(void (**)(NString *, const char *, uint64_t *))(*(_QWORD *)this + 96))(this, a2, (uint64_t *)va);
  return this;
}

NString *NString::vprintf(NString *this, const char *a2, va_list a3)
{
  int v5;
  char *v6;
  int v7;
  const char *v8;
  int v9;
  unsigned int v11[2];
  uint64_t (**v12)(NString *__hidden, const unsigned int *);
  unsigned int v13;
  uint64_t v14;
  va_list v15;

  v15 = a3;
  v5 = 256;
  do
  {
    v12 = &off_24C7F32C0;
    v13 = 0;
    v6 = (char *)operator new[]();
    v14 = (uint64_t)v6;
    *v6 = 0;
    v11[0] = v5;
    if (v5 != v13)
    {
      v12[1]((NString *)&v12, (const unsigned int *)v6);
      v14 = (*v12)((NString *)&v12, v11);
      v13 = v11[0];
      *(_BYTE *)(v14 + v11[0]) = 0;
      v6 = (char *)v14;
    }
    *(_QWORD *)v11 = v15;
    v7 = vsnprintf(v6, v5, a2, v15);
    v9 = v7;
    if (v7 < 0)
    {
      if (v5 >= 0x20000000)
        Error::chuck((Error *)"NString::vprintf() - Repeated failure to format string", v8);
      v5 *= 2;
    }
    else if (v7 >= v5)
    {
      v5 = v7 + 1;
      v9 = -1;
    }
    else
    {
      (*(void (**)(NString *, char *))(*(_QWORD *)this + 40))(this, v6);
    }
    v12 = &off_24C7F32C0;
    if (v14)
      MEMORY[0x212BAC9C0](v14, 0x1000C8077774924);
  }
  while (v9 < 0);
  return this;
}

void sub_20DA0D8D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

NString *NString::replace(NString *this, const NString *a2, const NString *a3)
{
  _QWORD v5[2];
  uint64_t v6;

  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)this + 112))(v5);
  (*(void (**)(NString *, _QWORD *))(*(_QWORD *)this + 32))(this, v5);
  v5[0] = &off_24C7F32C0;
  if (v6)
    MEMORY[0x212BAC9C0](v6, 0x1000C8077774924);
  return this;
}

void sub_20DA0D97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x212BAC9C0](a12, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *NString::creplace@<X0>(NString *this@<X0>, const NString *a2@<X1>, const NString *a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  void *result;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  void *v21;
  const void *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  uint64_t (**v26)(NString *__hidden, const unsigned int *);
  int v27;
  void *__src;
  unsigned int v29;

  v26 = &off_24C7F32C0;
  v27 = 0;
  __src = (void *)operator new[]();
  *(_BYTE *)__src = 0;
  v9 = *((_DWORD *)a2 + 2);
  if (!v9)
  {
    *(_QWORD *)a4 = &off_24C7F32C0;
    *(_DWORD *)(a4 + 8) = *((_DWORD *)this + 2);
    v11 = (void *)operator new[]();
LABEL_5:
    *(_QWORD *)(a4 + 16) = v11;
    result = memcpy(v11, *((const void **)this + 2), (*((_DWORD *)this + 2) + 1));
    v13 = __src;
    v26 = &off_24C7F32C0;
    if (!__src)
      return result;
    return (void *)MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  }
  v10 = *((_DWORD *)this + 2);
  if (v10 < v9)
  {
    *(_QWORD *)a4 = &off_24C7F32C0;
    *(_DWORD *)(a4 + 8) = v10;
    v11 = (void *)operator new[]();
    goto LABEL_5;
  }
  LODWORD(v14) = 0;
  v15 = 0;
  do
  {
    v16 = v14;
    if (v9)
    {
      v17 = 0;
      if (v10 <= v14)
        v14 = v14;
      else
        v14 = v10;
      while (1)
      {
        if ((_DWORD)v14 - v16 == v17)
          Error::chuck((Error *)"Index %d outside of range [0,%d]", v8, v14, v10 - 1);
        v18 = *((_QWORD *)this + 2);
        if (*(unsigned __int8 *)(v18 + (v16 + v17)) != *(unsigned __int8 *)(*((_QWORD *)a2 + 2) + v17))
          break;
        if (v9 == ++v17)
        {
          v19 = (const void *)(v18 + v15);
          goto LABEL_21;
        }
      }
    }
    else
    {
      v20 = *((_QWORD *)this + 2);
      if (!v20)
        Error::chuck((Error *)"Null pointer passed to string constructor", v8);
      v19 = (const void *)(v20 + v15);
LABEL_21:
      v21 = (void *)operator new[]();
      memcpy(v21, v19, v16 - v15);
      *((_BYTE *)v21 + v16 - v15) = 0;
      if (v16 != v15)
      {
        v29 = v16 - v15;
        ((void (*)(NString *, const void *, const unsigned int *))v26[9])((NString *)&v26, v21, &v29);
      }
      MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
      if (*((_DWORD *)a3 + 2))
      {
        v22 = (const void *)*((_QWORD *)a3 + 2);
        v29 = *((_DWORD *)a3 + 2);
        ((void (*)(NString *, const void *, const unsigned int *))v26[9])((NString *)&v26, v22, &v29);
      }
      v9 = *((_DWORD *)a2 + 2);
      v15 = v9 + v16;
      v16 = v9 + v16 - 1;
      v10 = *((_DWORD *)this + 2);
    }
    LODWORD(v14) = v16 + 1;
  }
  while (v16 + 1 <= v10 - v9);
  if (v10 > v15)
  {
    v23 = *((_QWORD *)this + 2);
    if (!v23)
      Error::chuck((Error *)"Null pointer passed to string constructor", v8);
    v24 = (void *)operator new[]();
    memcpy(v24, (const void *)(v23 + v15), v10 - v15);
    *((_BYTE *)v24 + v10 - v15) = 0;
    if (v10 != v15)
    {
      v29 = v10 - v15;
      ((void (*)(NString *, const void *, const unsigned int *))v26[9])((NString *)&v26, v24, &v29);
    }
    MEMORY[0x212BAC9C0](v24, 0x1000C8077774924);
  }
  *(_QWORD *)a4 = &off_24C7F32C0;
  *(_DWORD *)(a4 + 8) = v27;
  v25 = (void *)operator new[]();
  *(_QWORD *)(a4 + 16) = v25;
  v13 = __src;
  result = memcpy(v25, __src, (v27 + 1));
  v26 = &off_24C7F32C0;
  if (v13)
    return (void *)MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  return result;
}

void sub_20DA0DCE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;

  MEMORY[0x212BAC9C0](v13, 0x1000C8077774924);
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NString::stripComments(uint64_t this, unsigned __int8 a2)
{
  unsigned int v2;
  _BYTE *v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int8 *v6;
  int v7;

  v2 = *(_DWORD *)(this + 8);
  if (v2)
  {
    v3 = *(_BYTE **)(this + 16);
    if (*v3 == a2)
    {
      *v3 = 0;
      *(_DWORD *)(this + 8) = 0;
    }
    else if (v2 >= 2)
    {
      v4 = 0;
      v5 = v2 - 1;
      while (1)
      {
        v6 = &v3[v4++];
        if (v6[1] == a2)
        {
          v7 = *v6;
          if (v7 == 32 || v7 == 9)
            break;
        }
        if (v5 == (_DWORD)v4)
          return this;
      }
      *(_DWORD *)(this + 8) = v4;
      v3[v4] = 0;
    }
  }
  return this;
}

void NString::NString(NString *this)
{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 2) = v2;
  *v2 = 0;
}

{
  _BYTE *v2;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = 0;
  v2 = (_BYTE *)operator new[]();
  *((_QWORD *)this + 2) = v2;
  *v2 = 0;
}

void NString::NString(NString *this, const NString *a2)
{
  void *v4;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

{
  void *v4;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

void NString::NString(NString *this, const char *__s)
{
  void *v4;

  *(_QWORD *)this = &off_24C7F32C0;
  if (!__s)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  *((_DWORD *)this + 2) = strlen(__s);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __s, (*((_DWORD *)this + 2) + 1));
}

{
  void *v4;

  *(_QWORD *)this = &off_24C7F32C0;
  if (!__s)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  *((_DWORD *)this + 2) = strlen(__s);
  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __s, (*((_DWORD *)this + 2) + 1));
}

void NString::NString(NString *this, const char *a2, const unsigned int *a3)
{
  void *v6;

  *(_QWORD *)this = &off_24C7F32C0;
  if (!a2)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0, a3);
  *((_DWORD *)this + 2) = *a3;
  v6 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v6;
  memcpy(v6, a2, *a3);
  *((_BYTE *)v6 + *((unsigned int *)this + 2)) = 0;
}

{
  void *v6;

  *(_QWORD *)this = &off_24C7F32C0;
  if (!a2)
    Error::chuck((Error *)"Null pointer passed to string constructor", 0, a3);
  *((_DWORD *)this + 2) = *a3;
  v6 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v6;
  memcpy(v6, a2, *a3);
  *((_BYTE *)v6 + *((unsigned int *)this + 2)) = 0;
}

{
  void *v5;
  size_t v6;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *a3;
  v5 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v5;
  v6 = *((unsigned int *)this + 2);
  memset(v5, *(unsigned __int8 *)a2, v6);
  *((_BYTE *)v5 + v6) = 0;
}

{
  void *v5;
  size_t v6;

  *(_QWORD *)this = &off_24C7F32C0;
  *((_DWORD *)this + 2) = *a3;
  v5 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v5;
  v6 = *((unsigned int *)this + 2);
  memset(v5, *(unsigned __int8 *)a2, v6);
  *((_BYTE *)v5 + v6) = 0;
}

void NString::NString(NString *this, const int *a2)
{
  const char *v3;
  void *v4;
  char __str[128];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24C7F32C0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F)
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  *((_DWORD *)this + 2) = strlen(__str);
  v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

{
  const char *v3;
  void *v4;
  char __str[128];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24C7F32C0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F)
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  *((_DWORD *)this + 2) = strlen(__str);
  v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

void NString::NString(NString *this, const unsigned int *a2)
{
  const char *v3;
  void *v4;
  char __str[128];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24C7F32C0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F)
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  *((_DWORD *)this + 2) = strlen(__str);
  v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

{
  const char *v3;
  void *v4;
  char __str[128];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24C7F32C0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F)
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  *((_DWORD *)this + 2) = strlen(__str);
  v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

void NString::NString(NString *this, const double *a2)
{
  const char *v3;
  void *v4;
  char __str[512];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24C7F32C0;
  if ((snprintf(__str, 0x200uLL, "%f", *a2) - 513) <= 0xFFFFFDFF)
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v3);
  *((_DWORD *)this + 2) = strlen(__str);
  v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

{
  const char *v3;
  void *v4;
  char __str[512];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24C7F32C0;
  if ((snprintf(__str, 0x200uLL, "%f", *a2) - 513) <= 0xFFFFFDFF)
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v3);
  *((_DWORD *)this + 2) = strlen(__str);
  v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((_QWORD *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

uint64_t NString::pointer(NString *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t NString::length(NString *this)
{
  return *((unsigned int *)this + 2);
}

void NString::operator+(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  size_t v6;
  void *v7;
  const char *v8;
  size_t v9;
  const void *v10;
  char *v11;
  void *v12;

  v6 = *(unsigned int *)(a1 + 8);
  v7 = (void *)operator new[]();
  memcpy(v7, *(const void **)(a1 + 16), (*(_DWORD *)(a1 + 8) + 1));
  v9 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v9)
  {
    v10 = *(const void **)(a2 + 16);
    if (!v10)
      Error::chuck((Error *)"NString::appendTo() - Null pointer passed to assign", v8);
    v11 = (char *)operator new[]();
    memcpy(v11, v7, v6);
    memcpy(&v11[v6], v10, v9);
    v11[(v9 + v6)] = 0;
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
    LODWORD(v6) = v9 + v6;
    v7 = v11;
  }
  *(_QWORD *)a3 = &off_24C7F32C0;
  *(_DWORD *)(a3 + 8) = v6;
  v12 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v12;
  memcpy(v12, v7, (v6 + 1));
  JUMPOUT(0x212BAC9C0);
}

void sub_20DA0E848(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

BOOL NString::operator==(uint64_t a1, uint64_t a2)
{
  size_t v2;

  v2 = *(unsigned int *)(a2 + 8);
  return (_DWORD)v2 == *(_DWORD *)(a1 + 8) && memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v2) == 0;
}

BOOL NString::operator==(uint64_t a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return v4 == *(_DWORD *)(a1 + 8) && memcmp(*(const void **)(a1 + 16), __s, v4) == 0;
}

BOOL NString::operator!=(uint64_t a1, uint64_t a2)
{
  size_t v2;

  v2 = *(unsigned int *)(a2 + 8);
  return (_DWORD)v2 != *(_DWORD *)(a1 + 8) || memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v2) != 0;
}

uint64_t NString::operator<(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) >> 31;
}

BOOL NString::operator<=(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) < 1;
}

BOOL NString::operator>(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) > 0;
}

BOOL NString::operator>=(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) >= 0;
}

uint64_t NString::operator[](uint64_t a1, const char *a2)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(unsigned int *)a2;
  v3 = *(_DWORD *)(a1 + 8);
  if (v2 >= v3)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v3 - 1);
  return *(_QWORD *)(a1 + 16) + v2;
}

{
  uint64_t v2;
  unsigned int v3;

  v2 = *(unsigned int *)a2;
  v3 = *(_DWORD *)(a1 + 8);
  if (v2 >= v3)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v3 - 1);
  return *(_QWORD *)(a1 + 16) + v2;
}

void *NString::slice@<X0>(NString *this@<X0>, const unsigned int *a2@<X1>, const unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  size_t v10;
  void *v11;
  void *result;

  v5 = *a2;
  v6 = *((unsigned int *)this + 2);
  if (v5 > v6)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, a3, *a2, v6);
  v7 = *a3;
  if (v7 > v6)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, a3, *a3, v6);
  if (v7 < v5)
    Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", (const char *)a2, *a2, v7);
  v8 = *((_QWORD *)this + 2);
  *(_QWORD *)a4 = &off_24C7F32C0;
  if (!v8)
    Error::chuck((Error *)"Null pointer passed to string constructor", (const char *)a2);
  v9 = (const void *)(v8 + v5);
  v10 = (v7 - v5);
  *(_DWORD *)(a4 + 8) = v10;
  v11 = (void *)operator new[]();
  *(_QWORD *)(a4 + 16) = v11;
  result = memcpy(v11, v9, v10);
  *((_BYTE *)v11 + v10) = 0;
  return result;
}

void *NString::head@<X0>(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  void *v8;
  void *result;

  v4 = *(unsigned int *)a2;
  v5 = *((unsigned int *)this + 2);
  if (v4 > v5)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v5);
  v6 = (const void *)*((_QWORD *)this + 2);
  *(_QWORD *)a3 = &off_24C7F32C0;
  if (!v6)
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  *(_DWORD *)(a3 + 8) = v4;
  v8 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v8;
  result = memcpy(v8, v6, *(unsigned int *)a2);
  *((_BYTE *)v8 + v4) = 0;
  return result;
}

void *NString::tail@<X0>(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  size_t v8;
  void *v9;
  void *result;

  v4 = *(unsigned int *)a2;
  v5 = *((unsigned int *)this + 2);
  if (v5 < v4)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v5);
  v6 = *((_QWORD *)this + 2);
  *(_QWORD *)a3 = &off_24C7F32C0;
  if (!v6)
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  v7 = (const void *)(v6 + v4);
  v8 = (v5 - v4);
  *(_DWORD *)(a3 + 8) = v8;
  v9 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v9;
  result = memcpy(v9, v7, v8);
  *((_BYTE *)v9 + v8) = 0;
  return result;
}

void *NString::cuttail@<X0>(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  size_t v5;
  const void *v6;
  void *v7;
  void *result;

  v4 = *((unsigned int *)this + 2);
  v5 = (v4 - *(_DWORD *)a2);
  if (v4 < *(_DWORD *)a2)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, (v4 - *(_DWORD *)a2), v4);
  v6 = (const void *)*((_QWORD *)this + 2);
  *(_QWORD *)a3 = &off_24C7F32C0;
  if (!v6)
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  *(_DWORD *)(a3 + 8) = v5;
  v7 = (void *)operator new[]();
  *(_QWORD *)(a3 + 16) = v7;
  result = memcpy(v7, v6, v5);
  *((_BYTE *)v7 + v5) = 0;
  return result;
}

uint64_t NString::uppercase@<X0>(NString *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;

  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 0;
  result = operator new[]();
  v5 = result;
  *(_QWORD *)(a2 + 16) = result;
  *(_BYTE *)result = 0;
  if (*((_DWORD *)this + 2))
  {
    MEMORY[0x212BAC9C0](result, 0x1000C8077774924);
    result = operator new[]();
    v6 = result;
    *(_QWORD *)(a2 + 16) = result;
    v7 = *((unsigned int *)this + 2);
    *(_DWORD *)(a2 + 8) = v7;
    *(_BYTE *)(result + v7) = 0;
    if ((_DWORD)v7)
    {
      for (i = 0; i < v9; ++i)
      {
        result = __toupper(*(char *)(*((_QWORD *)this + 2) + i));
        *(_BYTE *)(v6 + i) = result;
        v9 = *((unsigned int *)this + 2);
      }
    }
    else
    {
      v9 = 0;
    }
    v5 = v6;
  }
  else
  {
    v9 = 0;
  }
  *(_BYTE *)(v5 + v9) = 0;
  return result;
}

void sub_20DA0EE10(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *v1 = v3;
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NString::lowercase@<X0>(NString *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;

  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = 0;
  result = operator new[]();
  v5 = result;
  *(_QWORD *)(a2 + 16) = result;
  *(_BYTE *)result = 0;
  if (*((_DWORD *)this + 2))
  {
    MEMORY[0x212BAC9C0](result, 0x1000C8077774924);
    result = operator new[]();
    v6 = result;
    *(_QWORD *)(a2 + 16) = result;
    v7 = *((unsigned int *)this + 2);
    *(_DWORD *)(a2 + 8) = v7;
    *(_BYTE *)(result + v7) = 0;
    if ((_DWORD)v7)
    {
      for (i = 0; i < v9; ++i)
      {
        result = __tolower(*(char *)(*((_QWORD *)this + 2) + i));
        *(_BYTE *)(v6 + i) = result;
        v9 = *((unsigned int *)this + 2);
      }
    }
    else
    {
      v9 = 0;
    }
    v5 = v6;
  }
  else
  {
    v9 = 0;
  }
  *(_BYTE *)(v5 + v9) = 0;
  return result;
}

void sub_20DA0EF38(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *v1 = v3;
  MEMORY[0x212BAC9C0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

float NString::tofloat(const char **this)
{
  return atof(this[2]);
}

uint64_t NString::toint(const char **this, const unsigned int *a2)
{
  return strtol(this[2], 0, *a2);
}

unint64_t NString::touint(const char **this, const unsigned int *a2)
{
  return strtoul(this[2], 0, *a2);
}

BOOL NString::checkFloat(NString *this)
{
  char *v3;

  if (!*((_DWORD *)this + 2))
    return 0;
  v3 = 0;
  strtod(*((const char **)this + 2), &v3);
  return v3 == (char *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2));
}

BOOL NString::checkInt(NString *this, const unsigned int *a2)
{
  char *__endptr;

  if (!*((_DWORD *)this + 2))
    return 0;
  __endptr = 0;
  strtol(*((const char **)this + 2), &__endptr, *a2);
  return __endptr == (char *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2));
}

BOOL NString::checkUint(NString *this, const unsigned int *a2)
{
  char *__endptr;

  if (!*((_DWORD *)this + 2))
    return 0;
  __endptr = 0;
  strtoul(*((const char **)this + 2), &__endptr, *a2);
  return __endptr == (char *)(*((_QWORD *)this + 2) + *((unsigned int *)this + 2));
}

BOOL NString::toBOOL(NString *this)
{
  _BOOL8 v1;
  _BYTE v3[8];
  int v4;
  _DWORD *v5;

  NString::lowercase(this, (uint64_t)v3);
  if (v4 == 4)
  {
    v1 = *v5 == 1702195828;
    if (!v5)
      return v1;
    goto LABEL_5;
  }
  v1 = 0;
  if (v5)
LABEL_5:
    MEMORY[0x212BAC9C0](v5, 0x1000C8077774924);
  return v1;
}

BOOL NString::startswith(NString *this, const char *__s)
{
  unsigned int v4;

  v4 = strlen(__s);
  return *((_DWORD *)this + 2) >= v4 && memcmp(*((const void **)this + 2), __s, v4) == 0;
}

BOOL NString::startswith(NString *this, const void **a2)
{
  size_t v2;

  v2 = *((unsigned int *)a2 + 2);
  return *((_DWORD *)this + 2) >= v2 && memcmp(*((const void **)this + 2), a2[2], v2) == 0;
}

BOOL NString::endswith(NString *this, const char *__s)
{
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  uint64_t v7;

  v4 = strlen(__s);
  v5 = *((_DWORD *)this + 2);
  v6 = v5 >= v4;
  v7 = v5 - v4;
  return v6 && memcmp((const void *)(*((_QWORD *)this + 2) + v7), __s, v4) == 0;
}

BOOL NString::endswith(NString *this, const void **a2)
{
  unsigned int v2;
  size_t v3;

  v2 = *((_DWORD *)this + 2);
  v3 = *((unsigned int *)a2 + 2);
  return v2 >= v3 && memcmp((const void *)(*((_QWORD *)this + 2) + v2 - v3), a2[2], v3) == 0;
}

uint64_t NString::contains(NString *this, const char *__s)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  BOOL v7;
  int v8;
  int v9;
  void *v10;
  void *v11;
  char *v12;
  char *v13;
  uint64_t v14;

  v4 = strlen(__s);
  v5 = v4;
  v6 = *((_DWORD *)this + 2);
  if (v6)
    v7 = v4 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = v6 - v4 + 1;
    if (v8 >= 1)
    {
      v9 = *__s;
      v10 = (void *)*((_QWORD *)this + 2);
      v11 = v10;
      do
      {
        v12 = (char *)memchr(v11, v9, v8);
        if (!v12)
          break;
        v13 = v12;
        v14 = ((_DWORD)v12 - (_DWORD)v10);
        if (!memcmp(v12, __s, v5))
          return v14;
        v8 = v6 - v5 - v14;
        v11 = v13 + 1;
      }
      while (v8 > 0);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t NString::contains(NString *this, const NString *a2)
{
  int v2;
  size_t v3;
  int v4;
  char *v5;
  int v6;
  void *v7;
  void *v8;
  char *v9;
  char *v10;
  uint64_t v11;

  v2 = *((_DWORD *)this + 2);
  if (v2)
  {
    v3 = *((unsigned int *)a2 + 2);
    if ((_DWORD)v3)
    {
      v4 = v2 - v3 + 1;
      if (v4 >= 1)
      {
        v5 = (char *)*((_QWORD *)a2 + 2);
        v6 = *v5;
        v7 = (void *)*((_QWORD *)this + 2);
        v8 = v7;
        do
        {
          v9 = (char *)memchr(v8, v6, v4);
          if (!v9)
            break;
          v10 = v9;
          v11 = ((_DWORD)v9 - (_DWORD)v7);
          if (!memcmp(v9, v5, v3))
            return v11;
          v4 = v2 - v3 - v11;
          v8 = v10 + 1;
        }
        while (v4 > 0);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t NString::contains(NString *this, const char *a2)
{
  size_t v2;
  void *v3;
  void *v4;

  v2 = *((unsigned int *)this + 2);
  if (!(_DWORD)v2)
    return 0xFFFFFFFFLL;
  v3 = (void *)*((_QWORD *)this + 2);
  v4 = memchr(v3, *(unsigned __int8 *)a2, v2);
  if (v4)
    return ((_DWORD)v4 - (_DWORD)v3);
  else
    return 0xFFFFFFFFLL;
}

uint64_t NString::containsafter(NString *this, const NString *a2, const unsigned int *a3)
{
  uint64_t v3;
  unsigned int v4;
  size_t v5;
  int v6;
  char *v7;
  int v8;
  uint64_t v9;
  void *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v3 = *a3;
  v4 = *((_DWORD *)this + 2);
  if (v3 >= v4)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, *a3, v4 - 1);
  v5 = *((unsigned int *)a2 + 2);
  if ((_DWORD)v5)
  {
    v6 = v4 - (v3 + v5) + 1;
    if (v6 >= 1)
    {
      v7 = (char *)*((_QWORD *)a2 + 2);
      v8 = *v7;
      v9 = *((_QWORD *)this + 2);
      v10 = (void *)(v9 + v3);
      do
      {
        v11 = (char *)memchr(v10, v8, v6);
        if (!v11)
          break;
        v12 = v11;
        v13 = ((_DWORD)v11 - v9);
        if (!memcmp(v11, v7, v5))
          return v13;
        v6 = v4 - (v5 + v13);
        v10 = v12 + 1;
      }
      while (v6 > 0);
    }
  }
  return 0xFFFFFFFFLL;
}

_QWORD *operator<<(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  size_t v4;

  v3 = *(const char **)(a2 + 16);
  v4 = strlen(v3);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
}

uint64_t operator<<(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  return a1;
}

void *NString::split@<X0>(NString *this@<X0>, const NString *a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)a4 = off_24C7F13C0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 24) = 0;
  return NString::split((uint64_t)this, a4, (uint64_t)a2, a3);
}

void sub_20DA0F5EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  NLinkedList<NString>::~NLinkedList(v1);
  _Unwind_Resume(a1);
}

void *NString::split(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  const char *v5;
  void *result;
  uint64_t v7;
  const char *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  void *v13;
  size_t v14;
  const char *v15;
  unsigned int v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  void *v20;
  uint64_t v22;
  uint64_t (**v25)(NString *__hidden, const unsigned int *);
  unsigned int v26;
  void *v27;

  v5 = *(const char **)(a1 + 16);
  result = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
  v22 = a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = v5;
    v9 = 0;
    v10 = 0;
    v11 = *a4;
    do
    {
      v12 = v10;
      v13 = *(void **)(a3 + 16);
      v14 = *(unsigned int *)(a3 + 8);
      if (v7 <= (int)v10 + 1)
        v10 = (v10 + 1);
      else
        v10 = v7;
      v15 = v8;
      while (1)
      {
        result = memchr(v13, *v15, v14);
        if (!result)
          break;
        ++v15;
        v12 = (v12 + 1);
        if ((_DWORD)v10 == (_DWORD)v12)
        {
          v16 = 0;
          goto LABEL_17;
        }
      }
      v16 = v7 - v12;
      if (v7 > v12)
      {
        v17 = 0;
        while (1)
        {
          result = memchr(v13, v15[v17], v14);
          if (result)
            break;
          v12 = (v12 + 1);
          ++v17;
          if ((_DWORD)v7 == (_DWORD)v12)
          {
            v8 = &v15[v17];
            v10 = v7;
            if (v9 == v11)
              goto LABEL_18;
            goto LABEL_22;
          }
        }
        v8 = &v15[v17];
        v16 = v17;
        v10 = v12;
        if (v9 == v11)
          goto LABEL_18;
        goto LABEL_22;
      }
      v16 = 0;
      v10 = v12;
LABEL_17:
      v8 = v15;
      if (v9 == v11)
      {
LABEL_18:
        v18 = v8;
        v25 = &off_24C7F32C0;
        v26 = strlen(v15);
        v27 = (void *)operator new[]();
        memcpy(v27, v15, v26 + 1);
        (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a2 + 40))(a2, &v25);
        v25 = &off_24C7F32C0;
        result = v27;
        if (v27)
          result = (void *)MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
        v9 = v11 + 1;
        v8 = v18;
        goto LABEL_26;
      }
LABEL_22:
      if (v16)
      {
        v19 = v8;
        v25 = &off_24C7F32C0;
        v26 = v16;
        v20 = (void *)operator new[]();
        v27 = v20;
        memcpy(v20, v15, v16);
        *((_BYTE *)v20 + v26) = 0;
        (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a2 + 40))(a2, &v25);
        v25 = &off_24C7F32C0;
        result = v27;
        if (v27)
          result = (void *)MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
        ++v9;
        v8 = v19;
      }
LABEL_26:
      v7 = *(unsigned int *)(v22 + 8);
      if (v10 >= v7)
        break;
      v11 = *a4;
    }
    while (v9 <= *a4);
  }
  return result;
}

void sub_20DA0F860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16)
    MEMORY[0x212BAC9C0](a16, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *NString::split(uint64_t a1, _QWORD *a2, uint64_t a3, unsigned int *a4)
{
  char *v4;
  void *v5;
  size_t v6;
  int v7;
  int v8;
  BOOL v9;
  BOOL v10;
  void *v11;
  void *result;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  int v26;
  int v27;

  v4 = *(char **)(a1 + 16);
  v5 = *(void **)(a3 + 16);
  v6 = *(unsigned int *)(a3 + 8);
  v27 = 0;
  v7 = *(_DWORD *)(a1 + 8);
  if (v7)
  {
    v8 = 0;
    v9 = 1;
    do
    {
      v10 = v9;
      v11 = memchr(v5, *v4, v6);
      v9 = v11 != 0;
      if (v10 && !v11)
        v27 = ++v8;
      ++v4;
      --v7;
    }
    while (v7);
  }
  else
  {
    v8 = 0;
  }
  if (v8 - 1 > *a4)
    v27 = *a4 + 1;
  result = (void *)(*(uint64_t (**)(_QWORD *, int *))(*a2 + 32))(a2, &v27);
  v26 = 0;
  v13 = *(_DWORD *)(a1 + 8);
  if (v13)
  {
    v14 = 0;
    v15 = 0;
    v16 = *(char **)(a1 + 16);
    do
    {
      v18 = *a4;
      if (v15 > *a4)
        return result;
      if (v14 < v13)
      {
        while (1)
        {
          result = memchr(v5, *v16, v6);
          if (!result)
            break;
          ++v16;
          if (v13 == ++v14)
          {
            v19 = 0;
            v26 = 0;
            v20 = v16;
            v14 = v13;
            if (v15 == v18)
              goto LABEL_12;
            goto LABEL_30;
          }
        }
      }
      v20 = v16;
      v26 = 0;
      v19 = v13 - v14;
      if (v13 <= v14)
      {
        v19 = 0;
        if (v15 == v18)
          goto LABEL_12;
      }
      else
      {
        v21 = 0;
        while (1)
        {
          result = memchr(v5, v16[v21], v6);
          if (result)
            break;
          v26 = ++v21;
          if (!(v14 - v13 + (_DWORD)v21))
          {
            v16 += v21;
            v14 = v13;
            goto LABEL_29;
          }
        }
        v16 += v21;
        v14 += v21;
        v19 = v21;
LABEL_29:
        if (v15 == v18)
        {
LABEL_12:
          v17 = a2[1] + 24 * v15;
          result = (void *)(*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v17 + 40))(v17, v20);
          goto LABEL_13;
        }
      }
LABEL_30:
      if (!v19)
        goto LABEL_14;
      v22 = a2[1] + 24 * v15;
      result = (void *)(*(uint64_t (**)(uint64_t, char *, int *))(*(_QWORD *)v22 + 64))(v22, v20, &v26);
LABEL_13:
      ++v15;
LABEL_14:
      v13 = *(_DWORD *)(a1 + 8);
    }
    while (v14 < v13);
  }
  return result;
}

uint64_t NString::split(uint64_t a1, _QWORD *a2, unsigned __int8 a3)
{
  int v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  BOOL v9;
  BOOL v10;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned __int8 *v15;
  unsigned int v16;
  unsigned __int8 *i;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  v5 = a3;
  v6 = *(unsigned __int8 **)(a1 + 16);
  v21 = 0;
  v7 = *(_DWORD *)(a1 + 8);
  if (v7)
  {
    v8 = 0;
    v9 = 1;
    do
    {
      v10 = v9;
      v9 = *v6 == a3;
      if (v10 && *v6 != a3)
        v21 = ++v8;
      ++v6;
      --v7;
    }
    while (v7);
  }
  result = (*(uint64_t (**)(_QWORD *, int *))(*a2 + 32))(a2, &v21);
  v12 = *(_DWORD *)(a1 + 8);
  if (v12)
  {
    v13 = 0;
    v14 = 0;
    v15 = *(unsigned __int8 **)(a1 + 16);
    do
    {
      if (v12 <= v13 + 1)
        v16 = v13 + 1;
      else
        v16 = v12;
      for (i = v15; *i == v5; ++i)
      {
        if (v16 == ++v13)
          return result;
      }
      v18 = v12 - v13;
      if (v12 <= v13)
      {
        v15 = i;
      }
      else
      {
        v19 = 0;
        while (i[v19] != v5)
        {
          ++v13;
          ++v19;
          if (v12 == v13)
          {
            v15 = &i[v19];
            v13 = v12;
            if (!v18)
              goto LABEL_25;
            goto LABEL_24;
          }
        }
        v15 = &i[v19];
        if (!(_DWORD)v19)
          continue;
LABEL_24:
        v20 = a2[1] + 24 * v14;
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 64))(v20);
        ++v14;
        v12 = *(_DWORD *)(a1 + 8);
      }
LABEL_25:
      ;
    }
    while (v13 < v12);
  }
  return result;
}

void NString::hexcoded(NString *this@<X0>, uint64_t a2@<X8>)
{
  size_t v4;
  _BYTE *v5;
  unint64_t v6;

  v4 = (2 * *((_DWORD *)this + 2));
  *(_QWORD *)a2 = &off_24C7F32C0;
  *(_DWORD *)(a2 + 8) = v4;
  v5 = (_BYTE *)operator new[]();
  *(_QWORD *)(a2 + 16) = v5;
  bzero(v5, v4);
  v5[v4] = 0;
  if (*((_DWORD *)this + 2))
  {
    v6 = 0;
    do
    {
      snprintf(v5, 3uLL, "%2.2x", *(unsigned __int8 *)(*((_QWORD *)this + 2) + v6));
      v5 += 2;
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 2));
  }
  *v5 = 0;
}

char *NString::hexdecoded@<X0>(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  _BYTE *v13;
  char *result;
  uint64_t (**v15)(NString *__hidden, const unsigned int *);
  unsigned int v16;
  _BYTE *v17;
  uint64_t (**v18)(NString *__hidden, const unsigned int *);
  int v19;
  char *v20;

  if ((*((_BYTE *)this + 8) & 1) != 0)
    Error::chuck((Error *)"NString::hexdecoded() - string is odd number of chars", a2);
  *(_QWORD *)a3 = &off_24C7F32C0;
  *(_DWORD *)(a3 + 8) = 0;
  v5 = (_BYTE *)operator new[]();
  *(_QWORD *)(a3 + 16) = v5;
  *v5 = 0;
  LODWORD(v18) = *((_DWORD *)this + 2) >> 1;
  if ((_DWORD)v18 != *(_DWORD *)(a3 + 8))
  {
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a3 + 8))(a3, v5);
    v6 = (**(uint64_t (***)(uint64_t, _QWORD))a3)(a3, &v18);
    *(_QWORD *)(a3 + 16) = v6;
    v7 = v18;
    *(_DWORD *)(a3 + 8) = (_DWORD)v18;
    *(_BYTE *)(v6 + v7) = 0;
    v5 = *(_BYTE **)(a3 + 16);
  }
  v18 = &off_24C7F32C0;
  v19 = 0;
  v20 = (char *)operator new[]();
  *v20 = 0;
  v9 = *((unsigned int *)this + 2);
  if ((_DWORD)v9)
  {
    v10 = 0;
    do
    {
      v11 = v10 + 2;
      if (v9 < (int)v10 + 2)
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v8, (v10 + 2), v9);
      if (v10 == 4294967294)
        Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", v8, 4294967294, 0);
      v12 = *((_QWORD *)this + 2);
      v15 = &off_24C7F32C0;
      if (!v12)
        Error::chuck((Error *)"Null pointer passed to string constructor", v8);
      v16 = 2;
      v13 = (_BYTE *)operator new[]();
      v17 = v13;
      *(_WORD *)v13 = *(_WORD *)(v12 + v10);
      v13[2] = 0;
      ((void (*)(NString *, const void *, const unsigned int *))v18[8])((NString *)&v18, v13, &v16);
      v15 = &off_24C7F32C0;
      if (v17)
        MEMORY[0x212BAC9C0](v17, 0x1000C8077774924);
      LODWORD(v15) = 0;
      if (sscanf(v20, "%x", &v15) != 1)
        Error::chuck((Error *)"NString::hexdecoded() - cannot parse \"%s\" (position %d) as hex", v8, v20, v10);
      *v5++ = (_BYTE)v15;
      v9 = *((unsigned int *)this + 2);
      v10 += 2;
    }
    while (v9 > v11);
  }
  *v5 = 0;
  v18 = &off_24C7F32C0;
  result = v20;
  if (v20)
    return (char *)MEMORY[0x212BAC9C0](v20, 0x1000C8077774924);
  return result;
}

void sub_20DA0FF50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;

  *v18 = v19;
  v21 = v18[2];
  if (v21)
    MEMORY[0x212BAC9C0](v21, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void *NString::strip@<X0>(NString *this@<X0>, const NString *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v13;
  unsigned int v14;

  v5 = *((unsigned int *)this + 2);
  v6 = (char *)*((_QWORD *)a2 + 2);
  if ((_DWORD)v5)
  {
    v7 = 0;
    v8 = *((_QWORD *)this + 2);
    while (strchr(v6, *(char *)(v8 + v7)))
    {
      if (v5 == ++v7)
      {
        v9 = v5;
        v10 = v5;
        LODWORD(v7) = v5;
        goto LABEL_8;
      }
    }
    v9 = v7;
    v10 = v5;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    LODWORD(v7) = 0;
  }
LABEL_8:
  v14 = v7;
  if (v7 < v5)
    LODWORD(v5) = v7;
  while (v10 > v9)
  {
    v11 = v10--;
    if (!strchr(v6, *(char *)(*((_QWORD *)this + 2) + v11 - 1)))
    {
      LODWORD(v5) = v11;
      break;
    }
  }
  v13 = v5;
  return NString::slice(this, &v14, &v13, a3);
}

_WORD *NString::dirname@<X0>(NString *this@<X0>, uint64_t a2@<X8>)
{
  char *v4;
  char *v5;
  const char *v6;
  unsigned int v7;
  uint64_t v8;
  void *v9;
  _WORD *result;
  __int16 v11;

  v4 = (char *)*((_QWORD *)this + 2);
  v5 = strrchr(v4, 47);
  if (!v5)
  {
    *(_QWORD *)a2 = &off_24C7F32C0;
    *(_DWORD *)(a2 + 8) = 1;
    result = (_WORD *)operator new[]();
    *(_QWORD *)(a2 + 16) = result;
    v11 = 46;
LABEL_8:
    *result = v11;
    return result;
  }
  v7 = (_DWORD)v5 - (_DWORD)v4;
  if (v5 == v4)
  {
    *(_QWORD *)a2 = &off_24C7F32C0;
    *(_DWORD *)(a2 + 8) = 1;
    result = (_WORD *)operator new[]();
    *(_QWORD *)(a2 + 16) = result;
    v11 = 47;
    goto LABEL_8;
  }
  v8 = *((unsigned int *)this + 2);
  if (v8 < v7)
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, v5 - v4, v8);
  *(_QWORD *)a2 = &off_24C7F32C0;
  if (!v4)
    Error::chuck((Error *)"Null pointer passed to string constructor", v6);
  *(_DWORD *)(a2 + 8) = v7;
  v9 = (void *)operator new[]();
  *(_QWORD *)(a2 + 16) = v9;
  result = memcpy(v9, v4, v7);
  *((_BYTE *)v9 + v7) = 0;
  return result;
}

char *NString::prefixDirname@<X0>(NString *this@<X0>, uint64_t a2@<X8>)
{
  char *v4;
  char *v5;
  const char *v6;
  size_t v7;
  uint64_t v8;
  char *v9;
  char *result;

  v4 = (char *)*((_QWORD *)this + 2);
  v5 = strrchr(v4, 47);
  if (v5)
  {
    v7 = ((_DWORD)v5 - (_DWORD)v4 + 1);
    v8 = *((unsigned int *)this + 2);
    if (v7 > v8)
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, ((_DWORD)v5 - (_DWORD)v4 + 1), v8);
    *(_QWORD *)a2 = &off_24C7F32C0;
    if (!v4)
      Error::chuck((Error *)"Null pointer passed to string constructor", v6);
    *(_DWORD *)(a2 + 8) = v7;
    v9 = (char *)operator new[]();
    *(_QWORD *)(a2 + 16) = v9;
    memcpy(v9, v4, v7);
    result = &v9[v7];
  }
  else
  {
    *(_QWORD *)a2 = &off_24C7F32C0;
    *(_DWORD *)(a2 + 8) = 0;
    result = (char *)operator new[]();
    *(_QWORD *)(a2 + 16) = result;
  }
  *result = 0;
  return result;
}

void *NString::basename@<X0>(char **this@<X0>, uint64_t a2@<X8>)
{
  char *v4;
  char *v5;
  int v6;
  size_t v7;
  void *v8;
  void *v9;
  char *v10;
  size_t v11;
  void *result;

  v4 = strrchr(this[2], 47);
  if (v4)
  {
    v5 = v4 + 1;
    *(_QWORD *)a2 = &off_24C7F32C0;
    v6 = strlen(v4 + 1);
    *(_DWORD *)(a2 + 8) = v6;
    v7 = (v6 + 1);
    v8 = (void *)operator new[]();
    v9 = v8;
    v10 = v5;
    v11 = v7;
  }
  else
  {
    *(_QWORD *)a2 = &off_24C7F32C0;
    *(_DWORD *)(a2 + 8) = *((_DWORD *)this + 2);
    v8 = (void *)operator new[]();
    v9 = v8;
    v10 = this[2];
    v11 = (*((_DWORD *)this + 2) + 1);
  }
  result = memcpy(v8, v10, v11);
  *(_QWORD *)(a2 + 16) = v9;
  return result;
}

void NString::basename(char **this@<X0>, const NString *a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  char *v7;
  unsigned int v8;
  char *v9;
  char *v10;
  char *v11;
  size_t v12;
  size_t v13;
  const void *v14;
  size_t v15;
  void *v16;
  void *v17;

  v6 = strrchr(this[2], 47);
  if (v6)
  {
    v7 = v6 + 1;
    v8 = strlen(v6 + 1);
    v9 = (char *)operator new[]();
    v10 = v9;
    v11 = v7;
    v12 = v8 + 1;
  }
  else
  {
    v8 = *((_DWORD *)this + 2);
    v9 = (char *)operator new[]();
    v10 = v9;
    v11 = this[2];
    v12 = (*((_DWORD *)this + 2) + 1);
  }
  memcpy(v9, v11, v12);
  v13 = *((unsigned int *)a2 + 2);
  if (v8 >= v13
    && (v14 = (const void *)*((_QWORD *)a2 + 2), v15 = v8 - v13, !memcmp(&v10[v15], v14, v13)))
  {
    *(_QWORD *)a3 = &off_24C7F32C0;
    *(_DWORD *)(a3 + 8) = v15;
    v17 = (void *)operator new[]();
    *(_QWORD *)(a3 + 16) = v17;
    memcpy(v17, v10, v15);
    *((_BYTE *)v17 + v15) = 0;
  }
  else
  {
    *(_QWORD *)a3 = &off_24C7F32C0;
    *(_DWORD *)(a3 + 8) = v8;
    v16 = (void *)operator new[]();
    *(_QWORD *)(a3 + 16) = v16;
    memcpy(v16, v10, v8 + 1);
  }
  JUMPOUT(0x212BAC9C0);
}

void sub_20DA1050C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NString::hashValue(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  int v4;

  v1 = *(unsigned int *)(this + 8);
  if (!(_DWORD)v1)
    return 0;
  v2 = this;
  LODWORD(this) = 0;
  v3 = *(char **)(v2 + 16);
  do
  {
    v4 = *v3++;
    this = (v4 + 65599 * this);
    --v1;
  }
  while (v1);
  return this;
}

uint64_t operator<<(uint64_t a1, _DWORD *a2)
{
  const char *v3;
  uint64_t (**v5)(NString *__hidden, const unsigned int *);
  int v6;
  void *v7;
  char __str[128];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = &off_24C7F32C0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F)
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  v6 = strlen(__str);
  v7 = (void *)operator new[]();
  memcpy(v7, __str, (v6 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a1 + 48))(a1, &v5);
  v5 = &off_24C7F32C0;
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  return a1;
}

{
  const char *v3;
  uint64_t (**v5)(NString *__hidden, const unsigned int *);
  int v6;
  void *v7;
  char __str[128];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = &off_24C7F32C0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F)
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  v6 = strlen(__str);
  v7 = (void *)operator new[]();
  memcpy(v7, __str, (v6 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a1 + 48))(a1, &v5);
  v5 = &off_24C7F32C0;
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  return a1;
}

void sub_20DA10674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_20DA107A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t operator<<(uint64_t a1, float *a2)
{
  double v3;
  const char *v4;
  uint64_t (**v6)(NString *__hidden, const unsigned int *);
  int v7;
  void *v8;
  char __str[512];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v6 = &off_24C7F32C0;
  if ((snprintf(__str, 0x200uLL, "%f", v3) - 513) <= 0xFFFFFDFF)
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v4);
  v7 = strlen(__str);
  v8 = (void *)operator new[]();
  memcpy(v8, __str, (v7 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a1 + 48))(a1, &v6);
  v6 = &off_24C7F32C0;
  if (v8)
    MEMORY[0x212BAC9C0](v8, 0x1000C8077774924);
  return a1;
}

void sub_20DA108E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t operator<<(uint64_t a1, double *a2)
{
  const char *v3;
  uint64_t (**v5)(NString *__hidden, const unsigned int *);
  int v6;
  void *v7;
  char __str[512];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = &off_24C7F32C0;
  if ((snprintf(__str, 0x200uLL, "%f", *a2) - 513) <= 0xFFFFFDFF)
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v3);
  v6 = strlen(__str);
  v7 = (void *)operator new[]();
  memcpy(v7, __str, (v6 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(NString *__hidden, const unsigned int *)))(*(_QWORD *)a1 + 48))(a1, &v5);
  v5 = &off_24C7F32C0;
  if (v7)
    MEMORY[0x212BAC9C0](v7, 0x1000C8077774924);
  return a1;
}

void sub_20DA10A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x212BAC9C0](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void NTimer::~NTimer(NTimer *this)
{
  JUMPOUT(0x212BAC9D8);
}

void NTimer::NTimer(NTimer *this)
{
  *(_QWORD *)this = &off_24C7F3208;
  *((_WORD *)this + 4) = 0;
}

{
  *(_QWORD *)this = &off_24C7F3208;
  *((_WORD *)this + 4) = 0;
}

uint64_t NTimer::running(NTimer *this)
{
  return (uint64_t)this + 8;
}

uint64_t NTimer::start(NTimer *this)
{
  uint64_t result;

  times((tms *)((char *)this + 16));
  result = gettimeofday((timeval *)this + 5, 0);
  *((_WORD *)this + 4) = 257;
  return result;
}

uint64_t NTimer::stop(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 8))
  {
    v1 = this;
    times((tms *)(this + 48));
    this = gettimeofday((timeval *)(v1 + 96), 0);
    *(_BYTE *)(v1 + 8) = 0;
  }
  return this;
}

double NTimer::elapsed(uint64_t a1, const char *a2)
{
  int v2;
  __int128 v4;
  uint64_t v5;
  clock_t tms_utime;
  uint64_t v7;
  double result;
  clock_t tms_stime;
  clock_t tms_cutime;
  uint64_t v11;
  uint64_t v12;
  timeval v13;
  tms v14;

  if (!*(_BYTE *)(a1 + 9))
    Error::chuck((Error *)"NTimer::elapsed(): timer not started, cannot call elapsed", a2);
  v2 = (int)a2;
  if (*(_BYTE *)(a1 + 8))
  {
    times(&v14);
    gettimeofday(&v13, 0);
  }
  else
  {
    v4 = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&v14.tms_utime = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&v14.tms_cutime = v4;
    v13 = *(timeval *)(a1 + 96);
  }
  v5 = sysconf(3);
  switch(v2)
  {
    case 0:
      tms_utime = v14.tms_utime;
      v7 = *(_QWORD *)(a1 + 16);
      goto LABEL_12;
    case 1:
      tms_utime = v14.tms_stime;
      v7 = *(_QWORD *)(a1 + 24);
      goto LABEL_12;
    case 3:
      tms_stime = v14.tms_utime;
      tms_cutime = v14.tms_cutime;
      v11 = *(_QWORD *)(a1 + 16);
      v12 = *(_QWORD *)(a1 + 32);
      goto LABEL_11;
    case 4:
      tms_stime = v14.tms_stime;
      tms_cutime = v14.tms_cstime;
      v11 = *(_QWORD *)(a1 + 24);
      v12 = *(_QWORD *)(a1 + 40);
LABEL_11:
      tms_utime = tms_cutime + tms_stime;
      v7 = v11 + v12;
LABEL_12:
      result = (double)(tms_utime - v7) / (double)v5;
      break;
    default:
      result = (double)(v13.tv_usec - *(_DWORD *)(a1 + 88)) / 1000000.0 + (double)(v13.tv_sec - *(_QWORD *)(a1 + 80));
      break;
  }
  return result;
}

char *NVersion::release@<X0>(uint64_t a1@<X8>)
{
  char *result;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 20;
  result = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = result;
  strcpy(result, "gitrelno_unavailable");
  return result;
}

double NVersion::releaseDate@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 28;
  v3 = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = v3;
  strcpy(v3, "Sat Aug  3 09:26:23 PDT 2024");
  return *(double *)":26:23 PDT 2024";
}

_QWORD *NVersion::buildType@<X0>(uint64_t a1@<X8>)
{
  _QWORD *result;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 7;
  result = (_QWORD *)operator new[]();
  *(_QWORD *)(a1 + 16) = result;
  *result = 0x657361656C6552;
  return result;
}

double NVersion::buildDate@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 24;
  v3 = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = v3;
  strcpy(v3, "Sat Aug  3 09:26:23 2024");
  return *(double *)"3 09:26:23 2024";
}

double NVersion::compilerVersion@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 61;
  v3 = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = v3;
  strcpy(v3, "Apple clang version 16.0.0 (clang-1600.0.25.3) [+internal-os]");
  return *(double *)" [+internal-os]";
}

void *NVersion::compileFlags@<X0>(uint64_t a1@<X8>)
{
  void *v3;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 407;
  v3 = (void *)operator new[]();
  *(_QWORD *)(a1 + 16) = v3;
  return memcpy(v3, "-DAPPLEACCEL -DNOZLIB -DNO_BOUNDS_CHECK -DNLOGOFF -DAPPLEACCEL -O3 -DACCELERATE_NEW_LAPACK -DACCELERATE_LAPACK_ILP64 -DUSE_BNNSIR -Wno-error=deprecated-declarations -Wno-error=objc-designated-initializers -Wno-error=nonnull -Wno-error=#warnings -Wno-error=nullability-declspec -Wno-error=format -Wno-error=format-extra-args -Wno-error=deprecated-implementations -Wno-error=documentation -arch undefined_arch", 0x198uLL);
}

char *NVersion::buildMachine@<X0>(uint64_t a1@<X8>)
{
  char *result;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 8;
  result = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = result;
  strcpy(result, "withheld");
  return result;
}

double NVersion::versionMessage@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  *(_QWORD *)a1 = &off_24C7F32C0;
  *(_DWORD *)(a1 + 8) = 61;
  v3 = (char *)operator new[]();
  *(_QWORD *)(a1 + 16) = v3;
  strcpy(v3, "Novalib gitrelno_unavailable Release Sat Aug  3 09:26:23 2024");
  return *(double *)"3 09:26:23 2024";
}

void sub_20DA1475C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_20DA15680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_20DA19BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ndapilog_callback(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v2 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_INFO))
  {
    v3 = 136446210;
    v4 = a1;
    _os_log_impl(&dword_20D965000, v2, OS_LOG_TYPE_INFO, "NDAPI: %{public}s", (uint8_t *)&v3, 0xCu);
  }
}

uint64_t __Block_byref_object_copy__6237(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = MEMORY[0x212BACF9C](*(_QWORD *)(a2 + 40));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__6238(uint64_t a1)
{

}

uint64_t _VoiceTriggerEnabledDidChange(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_voiceTriggerEnabledDidChange");
}

uint64_t _PhraseSpotterEnabledDidChange(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_phraseSpotterEnabledDidChange");
}

id VTBuildVersion()
{
  return (id)MGCopyAnswer();
}

id _baseDir()
{
  __CFString *v0;
  void *v1;

  CPSharedResourcesDirectory();
  v0 = (__CFString *)objc_claimAutoreleasedReturnValue();
  if (-[__CFString rangeOfString:](v0, "rangeOfString:", CFSTR("root")) != 0x7FFFFFFFFFFFFFFFLL)
  {

    v0 = CFSTR("/var/mobile");
  }
  -[__CFString stringByAppendingPathComponent:](v0, "stringByAppendingPathComponent:", CFSTR("Library"));
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  return v1;
}

void *VTLogDirectory()
{
  __CFString *v0;
  void *v1;
  void *v2;

  CPSharedResourcesDirectory();
  v0 = (__CFString *)objc_claimAutoreleasedReturnValue();
  if (-[__CFString rangeOfString:](v0, "rangeOfString:", CFSTR("root")) != 0x7FFFFFFFFFFFFFFFLL)
  {

    v0 = CFSTR("/var/mobile");
  }
  -[__CFString stringByAppendingPathComponent:](v0, "stringByAppendingPathComponent:", CFSTR("Library"));
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v1, "stringByAppendingPathComponent:", CFSTR("Logs/CrashReporter/VoiceTrigger/"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

id VTAudioLogDirectory()
{
  if (VTAudioLogDirectory_onceToken != -1)
    dispatch_once(&VTAudioLogDirectory_onceToken, &__block_literal_global_6289);
  return (id)VTAudioLogDirectory_logPath;
}

id VTMakeTimestampedAudioLogFilenameWithPrefixAndSuffix(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  int v6;
  void *v7;
  void *v8;
  char v9;
  id v10;
  void *v11;
  char v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  void *v17;
  __CFString *v18;
  const __CFString *v19;
  void *v20;
  void *v21;
  uint64_t v23;
  NSObject *v24;
  void *v25;
  id v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  void *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  v4 = a2;
  +[VTPreferences sharedPreferences](VTPreferences, "sharedPreferences");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "fileLoggingIsEnabled");

  if (v6)
  {
    v7 = (void *)MEMORY[0x24BDD17C8];
    if (VTAudioLogDirectory_onceToken != -1)
      dispatch_once(&VTAudioLogDirectory_onceToken, &__block_literal_global_6289);
    objc_storeStrong((id *)&_VTGetOrCreateAudioLogDirectory_audioFileDir, (id)VTAudioLogDirectory_logPath);
    objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v8, "fileExistsAtPath:isDirectory:", _VTGetOrCreateAudioLogDirectory_audioFileDir, 0);

    v10 = 0;
    if ((v9 & 1) == 0)
    {
      objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v26 = 0;
      v12 = objc_msgSend(v11, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", _VTGetOrCreateAudioLogDirectory_audioFileDir, 1, 0, &v26);
      v10 = v26;

      if ((v12 & 1) == 0)
      {
        v13 = (void *)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
        {
          v23 = _VTGetOrCreateAudioLogDirectory_audioFileDir;
          v24 = v13;
          objc_msgSend(v10, "localizedDescription");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543618;
          v28 = v23;
          v29 = 2114;
          v30 = v25;
          _os_log_error_impl(&dword_20D965000, v24, OS_LOG_TYPE_ERROR, "Couldn't create voice trigger log directory at path %{public}@ %{public}@", buf, 0x16u);

        }
        v14 = (void *)_VTGetOrCreateAudioLogDirectory_audioFileDir;
        _VTGetOrCreateAudioLogDirectory_audioFileDir = (uint64_t)CFSTR("/tmp");

      }
    }
    v15 = (id)_VTGetOrCreateAudioLogDirectory_audioFileDir;

    v16 = (void *)_dateFormatter;
    objc_msgSend(MEMORY[0x24BDBCE60], "date");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "stringFromDate:", v17);
    v18 = (__CFString *)objc_claimAutoreleasedReturnValue();

    v19 = &stru_24C7F6FB8;
    if (v18)
      v19 = v18;
    objc_msgSend(v7, "stringWithFormat:", CFSTR("%@/%@%@%@"), v15, v3, v19, v4);
    v20 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v20, "stringByReplacingOccurrencesOfString:withString:", CFSTR(" "), CFSTR("_"));
    v21 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v21 = 0;
  }

  return v21;
}

void VTLogInitIfNeeded()
{
  if (VTLogInitIfNeeded_once != -1)
    dispatch_once(&VTLogInitIfNeeded_once, &__block_literal_global_21_6307);
}

void AccelWindow::init(AccelWindow *this, const char *a2, const BOOL *a3, const BOOL *a4, double a5)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  _OWORD *v15;
  __int128 *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  float32x2_t v28;
  int32x2_t v29;
  float32x2_t v30;
  float32x2_t *v31;
  uint64_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float v35;
  float v36;
  float64x2_t v37;
  float64x2_t v38;
  float v39;
  float v40;

  v8 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_BYTE *)this + 5) = *a3;
  v9 = *((_DWORD *)this + 6);
  if (v9 != v8)
  {
    v10 = *((_QWORD *)this + 2);
    *((_DWORD *)this + 6) = v8;
    v11 = operator new[]();
    *((_QWORD *)this + 2) = v11;
    LODWORD(v12) = *(_DWORD *)this;
    if (v9 >= *(_DWORD *)this)
      v12 = v12;
    else
      v12 = v9;
    if ((_DWORD)v12)
    {
      if (v12 >= 8 && (unint64_t)(v11 - v10) > 0x1F)
      {
        v14 = v12 & 0xFFFFFFF8;
        v15 = (_OWORD *)(v11 + 16);
        v16 = (__int128 *)(v10 + 16);
        v17 = v14;
        do
        {
          v18 = *v16;
          *(v15 - 1) = *(v16 - 1);
          *v15 = v18;
          v15 += 2;
          v16 += 2;
          v17 -= 8;
        }
        while (v17);
        if (v14 == v12)
          goto LABEL_18;
      }
      else
      {
        v14 = 0;
      }
      v19 = v12 - v14;
      v20 = 4 * v14;
      v21 = (_DWORD *)(v11 + 4 * v14);
      v22 = (int *)(v10 + v20);
      do
      {
        v23 = *v22++;
        *v21++ = v23;
        --v19;
      }
      while (v19);
LABEL_18:
      MEMORY[0x212BAC9C0](v10, 0x1000C8052888210);
      goto LABEL_19;
    }
    if (v10)
      goto LABEL_18;
  }
LABEL_19:
  *((_BYTE *)this + 6) = *a4;
  *((_DWORD *)this + 8) = 1;
  if (!*(_DWORD *)a2)
  {
    *((_BYTE *)this + 4) = 0;
    Error::chuck((Error *)"NWindow::init() - window length cannot be zero", a2);
  }
  v24 = *(unsigned int *)this;
  if (*((_BYTE *)this + 5))
  {
    if (!(_DWORD)v24)
      goto LABEL_30;
    v25 = *((_QWORD *)this + 2);
    if ((_DWORD)v24 == 1)
    {
      v26 = 0;
      v27 = (float)1u + -1.0;
      do
      {
LABEL_29:
        v35 = cosf((float)((float)v26 * 6.2832) / v27);
        v27 = (float)v24 + -1.0;
        v36 = v35 * -0.46 + 0.54;
        *(float *)(v25 + 4 * v26++) = v36;
      }
      while (v24 != v26);
      goto LABEL_30;
    }
    v26 = v24 & 0xFFFFFFFE;
    *(float *)&a5 = (float)v24 + -1.0;
    v28 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
    v29 = (int32x2_t)0x100000000;
    v30 = (float32x2_t)vdup_n_s32(0x40C90FD0u);
    v37 = (float64x2_t)vdupq_n_s64(0x3FE147AE147AE148uLL);
    v38 = (float64x2_t)vdupq_n_s64(0xBFDD70A3D70A3D71);
    v31 = (float32x2_t *)*((_QWORD *)this + 2);
    v32 = v26;
    do
    {
      v33 = vdiv_f32(vmul_f32(vcvt_f32_u32((uint32x2_t)v29), v30), v28);
      v39 = v33.f32[0];
      v40 = cosf(v33.f32[1]);
      v34.f32[0] = cosf(v39);
      v34.f32[1] = v40;
      *v31++ = vcvt_f32_f64(vmlaq_f64(v37, v38, vcvtq_f64_f32(v34)));
      v29 = vadd_s32(v29, (int32x2_t)0x200000002);
      v32 -= 2;
    }
    while (v32);
    v27 = (float)v24 + -1.0;
    if (v26 != v24)
      goto LABEL_29;
  }
  else if ((_DWORD)v24)
  {
    memset_pattern16(*((void **)this + 2), &unk_20DA246D0, 4 * v24);
  }
LABEL_30:
  *((_BYTE *)this + 4) = 1;
}

void AccelWindow::initHamming(AccelWindow *this, double a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float v5;
  float32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t *v9;
  uint64_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  float64x2_t v15;
  float64x2_t v16;
  float v17;
  float v18;

  v2 = *(unsigned int *)this;
  if (*((_BYTE *)this + 5))
  {
    if (!(_DWORD)v2)
      return;
    v3 = *((_QWORD *)this + 2);
    if ((_DWORD)v2 == 1)
    {
      v4 = 0;
      v5 = (float)1u + -1.0;
      do
      {
LABEL_10:
        v13 = cosf((float)((float)v4 * 6.2832) / v5);
        v5 = (float)v2 + -1.0;
        v14 = v13 * -0.46 + 0.54;
        *(float *)(v3 + 4 * v4++) = v14;
      }
      while (v2 != v4);
      return;
    }
    v4 = v2 & 0xFFFFFFFE;
    *(float *)&a2 = (float)v2 + -1.0;
    v6 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0);
    v7 = (int32x2_t)0x100000000;
    v8 = (float32x2_t)vdup_n_s32(0x40C90FD0u);
    v15 = (float64x2_t)vdupq_n_s64(0x3FE147AE147AE148uLL);
    v16 = (float64x2_t)vdupq_n_s64(0xBFDD70A3D70A3D71);
    v9 = (float32x2_t *)*((_QWORD *)this + 2);
    v10 = v4;
    do
    {
      v11 = vdiv_f32(vmul_f32(vcvt_f32_u32((uint32x2_t)v7), v8), v6);
      v17 = v11.f32[0];
      v18 = cosf(v11.f32[1]);
      v12.f32[0] = cosf(v17);
      v12.f32[1] = v18;
      *v9++ = vcvt_f32_f64(vmlaq_f64(v15, v16, vcvtq_f64_f32(v12)));
      v7 = vadd_s32(v7, (int32x2_t)0x200000002);
      v10 -= 2;
    }
    while (v10);
    v5 = (float)v2 + -1.0;
    if (v4 != v2)
      goto LABEL_10;
  }
  else if ((_DWORD)v2)
  {
    memset_pattern16(*((void **)this + 2), &unk_20DA246D0, 4 * v2);
  }
}

void AccelWindow::apply(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;

  if (!*((_BYTE *)a1 + 4))
    Error::chuck((Error *)"AccelWindow::apply() - AccelWindow::init() has to be called before running", (const char *)a2);
  v2 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v2 != *a1)
    Error::chuck((Error *)"AccelWindow::apply() - length of input array should be %d, not %d", (const char *)a2, *a1, v2);
  AccelWindow::applyHamming(a1, a2);
}

void AccelWindow::applyHamming(unsigned int *a1, uint64_t a2)
{
  float __B;
  float __C;

  __C = 0.0;
  vDSP_meanv(*(const float **)(a2 + 8), 1, &__C, *a1);
  __B = -__C;
  if (*((_BYTE *)a1 + 6))
    vDSP_vsadd(*(const float **)(a2 + 8), 1, &__B, *(float **)(a2 + 8), 1, *a1);
  vDSP_vmul(*(const float **)(a2 + 8), 1, *((const float **)a1 + 2), 1, *(float **)(a2 + 8), 1, *a1);
}

float AccelWindow::getOffset(unsigned int *a1, uint64_t a2)
{
  float __C;

  __C = 0.0;
  vDSP_meanv(*(const float **)(a2 + 8), 1, &__C, *a1);
  return __C;
}

uint64_t AccelWindow::getHamming(AccelWindow *this)
{
  return (uint64_t)this + 8;
}

unsigned int *AccelWindow::rescale(unsigned int *result, uint64_t a2)
{
  uint64_t v2;
  int *v3;
  float v4;
  float *v5;
  uint64_t v6;
  float v7;
  int v10;
  int v11;
  float32x4_t *v12;
  float v13;
  uint64_t v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t v17;
  uint64_t v18;
  float *v19;

  v2 = *result;
  if ((_DWORD)v2)
  {
    v3 = *(int **)(a2 + 8);
    v4 = 0.0;
    v5 = (float *)v3;
    v6 = *result;
    do
    {
      v7 = *v5;
      if (*v5 > v4 || v7 < (float)-v4)
      {
        if (v7 > 32766.0 || v7 < -32766.0)
          goto LABEL_19;
        if (v7 <= 0.0)
          v4 = -v7;
        else
          v4 = *v5;
      }
      ++v5;
      --v6;
    }
    while (v6);
    if (v4 >= 32766.0)
    {
LABEL_19:
      result[8] = 1;
      do
      {
        v11 = 1191181312;
        if (*(float *)v3 > 32766.0 || (v11 = -956302336, *(float *)v3 < -32766.0))
          *v3 = v11;
        ++v3;
        --v2;
      }
      while (v2);
    }
    else
    {
      if (v4 <= 0.0)
        v10 = 0x7FFF;
      else
        v10 = (int)(float)(32767.0 / v4);
      result[8] = v10;
      v12 = *(float32x4_t **)(a2 + 8);
      v13 = (float)v10;
      if (v2 < 8)
      {
        v14 = 0;
LABEL_32:
        v18 = v2 - v14;
        v19 = &v12->f32[v14];
        do
        {
          *v19 = *v19 * v13;
          ++v19;
          --v18;
        }
        while (v18);
        return result;
      }
      v14 = v2 & 0xFFFFFFF8;
      v15 = v12 + 1;
      v16 = v14;
      do
      {
        v17 = vmulq_n_f32(*v15, v13);
        v15[-1] = vmulq_n_f32(v15[-1], v13);
        *v15 = v17;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v14 != v2)
        goto LABEL_32;
    }
  }
  else
  {
    result[8] = 0x7FFF;
  }
  return result;
}

uint64_t AccelWindow::getScalingFactor(AccelWindow *this)
{
  return *((unsigned int *)this + 8);
}

void NLoadedMemory::~NLoadedMemory(NLoadedMemory *this)
{
  size_t v2;
  int v3;

  *(_QWORD *)this = &off_24C7F17B0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = *((unsigned int *)this + 14);
  if ((_DWORD)v2)
    munmap(*((void **)this + 8), v2);
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
  v3 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 3) + 64))((char *)this + 24, "", &v3);
  *((_QWORD *)this + 3) = &off_24C7F2108;
  free(*((void **)this + 5));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
}

{
  size_t v2;
  int v3;

  *(_QWORD *)this = &off_24C7F17B0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = *((unsigned int *)this + 14);
  if ((_DWORD)v2)
    munmap(*((void **)this + 8), v2);
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
  v3 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 3) + 64))((char *)this + 24, "", &v3);
  *((_QWORD *)this + 3) = &off_24C7F2108;
  free(*((void **)this + 5));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
  JUMPOUT(0x212BAC9D8);
}

{
  size_t v2;
  int v3;

  *(_QWORD *)this = &off_24C7F17B0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = *((unsigned int *)this + 14);
  if ((_DWORD)v2)
    munmap(*((void **)this + 8), v2);
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
  v3 = 0;
  (*(void (**)(char *, const char *, int *))(*((_QWORD *)this + 3) + 64))((char *)this + 24, "", &v3);
  *((_QWORD *)this + 3) = &off_24C7F2108;
  free(*((void **)this + 5));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = &off_24C7F32C0;
}

void NLoadedMemory::NLoadedMemory(NLoadedMemory *this)
{
  const char *v2;
  _BYTE *v3;
  void *memptr;

  *(_QWORD *)this = &off_24C7F17B0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = &off_24C7F2108;
  *((_DWORD *)this + 12) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 12));
  v3 = memptr;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = v3;
  *((_QWORD *)this + 3) = &off_24C7F2108;
  *v3 = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
}

{
  const char *v2;
  _BYTE *v3;
  void *memptr;

  *(_QWORD *)this = &off_24C7F17B0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = &off_24C7F2108;
  *((_DWORD *)this + 12) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 12));
  v3 = memptr;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = v3;
  *((_QWORD *)this + 3) = &off_24C7F2108;
  *v3 = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
}

uint64_t NLoadedMemory::reset(NLoadedMemory *this)
{
  size_t v2;
  int v4;

  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = *((unsigned int *)this + 14);
  if ((_DWORD)v2)
    munmap(*((void **)this + 8), v2);
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
  v4 = 0;
  return (*(uint64_t (**)(char *, const char *, int *))(*((_QWORD *)this + 3) + 64))((char *)this + 24, "", &v4);
}

uint64_t NLoadedMemory::setAlignment(uint64_t this, unsigned int *a2)
{
  unsigned int v2;
  int v3;

  v2 = *a2;
  if (*a2)
    *(_DWORD *)(this + 48) = v2;
  else
    v2 = *(_DWORD *)(this + 48);
  if (*(_QWORD *)(this + 40) % (unint64_t)v2)
  {
    v3 = *(_DWORD *)(this + 32);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(this + 24) + 64))(this + 24);
  }
  return this;
}

uint64_t NLoadedMemory::load(NLoadedMemory *this, const NString *a2)
{
  size_t v4;
  void **v5;
  uint64_t v6;
  const char **v7;
  const char *v8;
  unsigned int *v9;
  unsigned int v10;
  int *v11;
  int v12;
  int v13;
  _DWORD *v15;
  _WORD *v16;
  const char *v17;
  uint64_t result;
  uint64_t (**v19)(NString *__hidden, const unsigned int *);
  const void *v20;
  size_t v21;
  void *v22;
  const char *v23;
  int v24;
  uint64_t (**v25)(NString *__hidden, const unsigned int *);
  int v26;
  uint64_t v27;
  uint64_t (**v28)();
  uint64_t v29;
  uint64_t (**v30)(NString *__hidden, const unsigned int *);
  unsigned int v31;
  void *v32;
  void *v33;

  v5 = (void **)((char *)this + 56);
  v4 = *((unsigned int *)this + 14);
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  if ((_DWORD)v4)
    munmap(*((void **)this + 8), v4);
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = 0;
  v7 = (const char **)((char *)this + 24);
  v6 = *((_QWORD *)this + 3);
  LODWORD(v30) = 0;
  (*(void (**)(char *, const char *, uint64_t (***)(NString *__hidden, const unsigned int *)))(v6 + 64))((char *)this + 24, "", &v30);
  LODWORD(v33) = 0;
  v10 = *((_DWORD *)a2 + 2);
  if (v10 >= 7)
  {
    v11 = (int *)*((_QWORD *)a2 + 2);
    v12 = *v11;
    v13 = *(int *)((char *)v11 + 3);
    if (v12 == 1684957549 && v13 == 980968804)
    {
      v30 = 0;
      result = NMemoryFile::getMemoryBlockParams(a2, (const NString *)&v30, (const void **)&v33, v9);
      if ((result & 1) == 0)
        Error::chuck((Error *)"NLoadedMemory::read() - %s does not define a memory block", v23, *((_QWORD *)a2 + 2));
      v19 = v30;
      v5 = &v33;
      goto LABEL_25;
    }
  }
  else if (v10 < 4)
  {
    goto LABEL_11;
  }
  v15 = (_DWORD *)*((_QWORD *)a2 + 2);
  if (*v15 != 980443501)
  {
LABEL_11:
    v25 = &off_24C7F32C0;
    v26 = 1;
    v16 = (_WORD *)operator new[]();
    *v16 = 114;
    v29 = 0;
    v27 = (uint64_t)v16;
    v28 = (uint64_t (**)())&off_24C7F33E0;
    NFilePtr::open((NFilePtr *)&v28, a2, (const NString *)&v25);
    if (!v29)
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v17);
    (*(void (**)(uint64_t (***__return_ptr)(NString *__hidden, const unsigned int *)))(*(_QWORD *)v29 + 56))(&v30);
    if (v7 != (const char **)&v30)
      (*((void (**)(char *, void *, unsigned int *))*v7 + 8))((char *)this + 24, v32, &v31);
    v30 = &off_24C7F32C0;
    if (v32)
      MEMORY[0x212BAC9C0](v32, 0x1000C8077774924);
    v28 = &off_24C7F17F8;
    if (v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
    v25 = &off_24C7F32C0;
    result = v27;
    if (v27)
      result = MEMORY[0x212BAC9C0](v27, 0x1000C8077774924);
    v19 = (uint64_t (**)(NString *__hidden, const unsigned int *))*((_QWORD *)this + 5);
    v5 = (void **)((char *)this + 32);
    goto LABEL_25;
  }
  v30 = &off_24C7F32C0;
  if (!v15)
    Error::chuck((Error *)"Null pointer passed to string constructor", v8);
  v20 = v15 + 1;
  v21 = v10 - 4;
  v31 = v10 - 4;
  v22 = (void *)operator new[]();
  v32 = v22;
  memcpy(v22, v20, v21);
  *((_BYTE *)v22 + v21) = 0;
  NLoadedMemory::mapFile(this, (const char **)&v30);
  result = MEMORY[0x212BAC9C0](v22, 0x1000C8077774924);
  v19 = (uint64_t (**)(NString *__hidden, const unsigned int *))*((_QWORD *)this + 8);
LABEL_25:
  v24 = *(_DWORD *)v5;
  *((_QWORD *)this + 2) = v19;
  *((_DWORD *)this + 2) = v24;
  return result;
}

void sub_20DA1F64C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x212BAC9C0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NLoadedMemory::mapFile(NLoadedMemory *this, const char **a2)
{
  int v4;
  const char *v5;
  int v6;
  size_t v7;
  int v8;
  void *v9;
  uint64_t result;
  const char *v11;
  const char *v12;
  const char *v13;

  v4 = open(a2[2], 0);
  if (v4 == -1)
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot open %s", v5, a2[2]);
  v6 = v4;
  v7 = lseek(v4, 0, 2);
  if (v7 >> 31)
  {
    close(v6);
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot determine size of %s", v12, a2[2]);
  }
  v8 = v7;
  v9 = mmap(0, v7, 1, 1, v6, 0);
  if (v9 == (void *)-1)
  {
    close(v6);
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot map %s", v13, a2[2]);
  }
  *((_QWORD *)this + 8) = v9;
  *((_DWORD *)this + 14) = v8;
  result = close(v6);
  if ((_DWORD)result == -1)
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot close %s", v11, a2[2]);
  return result;
}

void sub_20DA1FA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getBKDeviceClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!BiometricKitLibraryCore_frameworkLibrary)
  {
    BiometricKitLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!BiometricKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("BKDevice");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getBKDeviceClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getBKDeviceManagerClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!BiometricKitLibraryCore_frameworkLibrary)
  {
    BiometricKitLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!BiometricKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("BKDeviceManager");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getBKDeviceManagerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t AFPreferencesAssistantEnabled()
{
  return MEMORY[0x24BE08EB0]();
}

uint64_t AFPreferencesMobileUserSessionLanguage()
{
  return MEMORY[0x24BE08EC0]();
}

uint64_t AFSiriActivationBuiltInMicVoiceTrigger()
{
  return MEMORY[0x24BE08F68]();
}

uint64_t AFSiriActivationBuiltInMicVoiceTriggerPrewarm()
{
  return MEMORY[0x24BE08F70]();
}

OSStatus AudioConverterConvertComplexBuffer(AudioConverterRef inAudioConverter, UInt32 inNumberPCMFrames, const AudioBufferList *inInputData, AudioBufferList *outOutputData)
{
  return MEMORY[0x24BDB67E8](inAudioConverter, *(_QWORD *)&inNumberPCMFrames, inInputData, outOutputData);
}

OSStatus AudioConverterNew(const AudioStreamBasicDescription *inSourceFormat, const AudioStreamBasicDescription *inDestinationFormat, AudioConverterRef *outAudioConverter)
{
  return MEMORY[0x24BDB6818](inSourceFormat, inDestinationFormat, outAudioConverter);
}

OSStatus AudioFileClose(AudioFileID inAudioFile)
{
  return MEMORY[0x24BDB6838](inAudioFile);
}

OSStatus AudioFileOpenURL(CFURLRef inFileRef, AudioFilePermissions inPermissions, AudioFileTypeID inFileTypeHint, AudioFileID *outAudioFile)
{
  return MEMORY[0x24BDB6878](inFileRef, inPermissions, *(_QWORD *)&inFileTypeHint, outAudioFile);
}

int BNNSFilterApply(void *filter, const void *in, void *out)
{
  return MEMORY[0x24BDB2820](filter, in, out);
}

void *__cdecl BNNSFilterCreateLayerFullyConnected(const BNNSLayerParametersFullyConnected *layer_params, const BNNSFilterParameters *filter_params)
{
  return (void *)MEMORY[0x24BDB2860](layer_params, filter_params);
}

void BNNSFilterDestroy(void *filter)
{
  MEMORY[0x24BDB2878](filter);
}

uint64_t BNNSGraphContextDestroy_v2()
{
  return MEMORY[0x24BDB28D0]();
}

uint64_t BNNSGraphContextExecute_v2()
{
  return MEMORY[0x24BDB28D8]();
}

uint64_t BNNSGraphContextMake()
{
  return MEMORY[0x24BDB28E8]();
}

uint64_t BNNSGraphContextSetMessageLogCallback()
{
  return MEMORY[0x24BDB2900]();
}

uint64_t BNNSGraphContextSetMessageLogMask()
{
  return MEMORY[0x24BDB2908]();
}

uint64_t BNNSGraphContextSetWeights()
{
  return MEMORY[0x24BDB2910]();
}

uint64_t BNNSGraphGetArgumentPosition()
{
  return MEMORY[0x24BDB2928]();
}

uint64_t BNNSGraphGetInputCount()
{
  return MEMORY[0x24BDB2930]();
}

uint64_t BNNSGraphGetInputNames_v2()
{
  return MEMORY[0x24BDB2938]();
}

uint64_t BNNSGraphGetOutputCount()
{
  return MEMORY[0x24BDB2940]();
}

uint64_t BNNSGraphGetOutputNames_v2()
{
  return MEMORY[0x24BDB2948]();
}

uint64_t BNNSGraphGetTensorDescriptor_v2()
{
  return MEMORY[0x24BDB2950]();
}

uint64_t BNNSGraphGetWorkspaceSize_v2()
{
  return MEMORY[0x24BDB2958]();
}

size_t BNNSNDArrayGetDataSize(const BNNSNDArrayDescriptor *array)
{
  return MEMORY[0x24BDB2970](array);
}

unsigned __int8 *__cdecl CC_MD5(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x24BDAC300](data, *(_QWORD *)&len, md);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x24BDBBDC0](theDict, key);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x24BDBBE68](cf1, cf2);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x24BDBC040](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x24BDBC050]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x24BDBC070](center, name, object, userInfo, deliverImmediately);
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x24BDBC088](center, observer, name, object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x24BDBC150](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC160](key, applicationID);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
  MEMORY[0x24BDBC198](key, value, applicationID);
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x24BDBC300]();
}

uint64_t CPSharedResourcesDirectory()
{
  return MEMORY[0x24BE04730]();
}

OSStatus ExtAudioFileCreateWithURL(CFURLRef inURL, AudioFileTypeID inFileType, const AudioStreamBasicDescription *inStreamDesc, const AudioChannelLayout *inChannelLayout, UInt32 inFlags, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x24BDB6AC0](inURL, *(_QWORD *)&inFileType, inStreamDesc, inChannelLayout, *(_QWORD *)&inFlags, outExtAudioFile);
}

OSStatus ExtAudioFileDispose(ExtAudioFileRef inExtAudioFile)
{
  return MEMORY[0x24BDB6AD0](inExtAudioFile);
}

OSStatus ExtAudioFileGetProperty(ExtAudioFileRef inExtAudioFile, ExtAudioFilePropertyID inPropertyID, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return MEMORY[0x24BDB6AE0](inExtAudioFile, *(_QWORD *)&inPropertyID, ioPropertyDataSize, outPropertyData);
}

OSStatus ExtAudioFileOpenURL(CFURLRef inURL, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x24BDB6AF8](inURL, outExtAudioFile);
}

OSStatus ExtAudioFileRead(ExtAudioFileRef inExtAudioFile, UInt32 *ioNumberFrames, AudioBufferList *ioData)
{
  return MEMORY[0x24BDB6B08](inExtAudioFile, ioNumberFrames, ioData);
}

OSStatus ExtAudioFileSetProperty(ExtAudioFileRef inExtAudioFile, ExtAudioFilePropertyID inPropertyID, UInt32 inPropertyDataSize, const void *inPropertyData)
{
  return MEMORY[0x24BDB6B18](inExtAudioFile, *(_QWORD *)&inPropertyID, *(_QWORD *)&inPropertyDataSize, inPropertyData);
}

OSStatus ExtAudioFileWrapAudioFileID(AudioFileID inFileID, Boolean inForWriting, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x24BDB6B28](inFileID, inForWriting, outExtAudioFile);
}

OSStatus ExtAudioFileWrite(ExtAudioFileRef inExtAudioFile, UInt32 inNumberFrames, const AudioBufferList *ioData)
{
  return MEMORY[0x24BDB6B38](inExtAudioFile, *(_QWORD *)&inNumberFrames, ioData);
}

IOHIDManagerRef IOHIDManagerCreate(CFAllocatorRef allocator, IOOptionBits options)
{
  return (IOHIDManagerRef)MEMORY[0x24BDD8480](allocator, *(_QWORD *)&options);
}

IOReturn IOHIDManagerOpen(IOHIDManagerRef manager, IOOptionBits options)
{
  return MEMORY[0x24BDD8490](manager, *(_QWORD *)&options);
}

void IOHIDManagerRegisterDeviceMatchingCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
  MEMORY[0x24BDD84A0](manager, callback, context);
}

void IOHIDManagerRegisterDeviceRemovalCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
  MEMORY[0x24BDD84B8](manager, callback, context);
}

void IOHIDManagerRegisterInputReportCallback(IOHIDManagerRef manager, IOHIDReportCallback callback, void *context)
{
  MEMORY[0x24BDD84C0](manager, callback, context);
}

void IOHIDManagerScheduleWithRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  MEMORY[0x24BDD84D8](manager, runLoop, runLoopMode);
}

void IOHIDManagerSetDeviceMatching(IOHIDManagerRef manager, CFDictionaryRef matching)
{
  MEMORY[0x24BDD84E8](manager, matching);
}

uint64_t IOPSDrawingUnlimitedPower()
{
  return MEMORY[0x24BDD8800]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x24BED8440]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x24BED8468]();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return MEMORY[0x24BE67138]();
}

uint64_t MKBGetDeviceLockState()
{
  return MEMORY[0x24BE67160]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x24BDD1000](format);
}

uint64_t PLLogRegisteredEvent()
{
  return MEMORY[0x24BE74F58]();
}

uint64_t PLShouldLogRegisteredEvent()
{
  return MEMORY[0x24BE74F70]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _MACleanV1Repository()
{
  return MEMORY[0x24BE66C20]();
}

uint64_t _MAMigrateAssets()
{
  return MEMORY[0x24BE66C28]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x24BEDADD8]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x24BEDADE0]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x24BEDADF0]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x24BEDADF8]();
}

uint64_t std::istream::read()
{
  return MEMORY[0x24BEDAE18]();
}

uint64_t std::istream::seekg()
{
  return MEMORY[0x24BEDAE30]();
}

uint64_t std::istream::tellg()
{
  return MEMORY[0x24BEDAE38]();
}

uint64_t std::istream::getline()
{
  return MEMORY[0x24BEDAE58]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x24BEDAEF0]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x24BEDAF10]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF18]();
}

{
  return MEMORY[0x24BEDAF60]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x24BEDB010]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x24BEDB048]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x24BEDB050]();
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

uint64_t operator delete[]()
{
  return off_24C7EFC88();
}

void operator delete(void *__p)
{
  off_24C7EFC90(__p);
}

uint64_t operator delete()
{
  return off_24C7EFC98();
}

uint64_t operator new[]()
{
  return off_24C7EFCA0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24C7EFCA8(__sz);
}

uint64_t operator new()
{
  return off_24C7EFCB0();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x24BDAC7D8](a1);
  return result;
}

float __exp10f(float a1)
{
  float result;

  MEMORY[0x24BDAC7E0](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC930](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC938](*(_QWORD *)&a1);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x24BDACB60]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB88](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x24BEAE670]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x24BDAD010]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x24BDAD170](*(_QWORD *)&__upper_bound);
}

double atof(const char *a1)
{
  double result;

  MEMORY[0x24BDAD250](a1);
  return result;
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

uint64_t cblas_sgemm_NEWLAPACK_ILP64()
{
  return MEMORY[0x24BDB2BD8]();
}

uint64_t cblas_sgemv_NEWLAPACK_ILP64()
{
  return MEMORY[0x24BDB2BF0]();
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

float cosf(float a1)
{
  float result;

  MEMORY[0x24BDADBE8](a1);
  return result;
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADC60](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCA8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEC8](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x24BDADF18](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x24BDADF60](object, queue);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x24BDADF68](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x24BDADF70](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x24BDADFB0](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x24BDADFD0](source, start, interval, leeway);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x24BDADFE0](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x24BDAE068]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

void exit(int a1)
{
  MEMORY[0x24BDAE268](*(_QWORD *)&a1);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x24BDAE270](__x);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x24BDAE288](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x24BDAE438](*(_QWORD *)&a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

float frexpf(float a1, int *a2)
{
  float result;

  MEMORY[0x24BDAE488](a2, a1);
  return result;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getpagesize(void)
{
  return MEMORY[0x24BDAE6B8]();
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x24BDAE958]();
}

long double ldexp(long double __x, int __e)
{
  long double result;

  MEMORY[0x24BDAEA30](*(_QWORD *)&__e, __x);
  return result;
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAA8](__x);
  return result;
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAB0](__x);
  return result;
}

float log10f(float a1)
{
  float result;

  MEMORY[0x24BDAEAB8](a1);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAD8](__x);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x24BDAEAF8](a1);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x24BDAEB20](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x24BDAEB30]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x24BDAEB48]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x24BDAEC68](info);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x24BDAED80](memptr, alignment, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x24BDAF138](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x24BDAF148](*(_QWORD *)&token, state64);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x24BDAF160](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x24BDAF168](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x24BDAF170](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x24BEDD030](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x24BEDD038](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x24BEDD088](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x24BEDD0B0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x24BEDD0C0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x24BEDD0E8](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x24BEDD160]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3D0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x24BEDD420](location, obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD458](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

uint64_t os_variant_is_darwinos()
{
  return MEMORY[0x24BDAF4E8]();
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAF690](a1, a2);
  return result;
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x24BDAFB80](__from, __to, __ec);
}

float sinf(float a1)
{
  float result;

  MEMORY[0x24BDAFE20](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFEA0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFFA8](__s, *(_QWORD *)&__c);
}

double strtod(const char *a1, char **a2)
{
  double result;

  MEMORY[0x24BDAFFD0](a1, a2);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0030](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x24BDB00F0](*(_QWORD *)&a1);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x24BDB00F8](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

clock_t times(tms *a1)
{
  return MEMORY[0x24BDB0250](a1);
}

void vDSP_DFT_DestroySetup(vDSP_DFT_Setup __Setup)
{
  MEMORY[0x24BDB3110](__Setup);
}

void vDSP_DFT_Execute(const vDSP_DFT_SetupStruct *__Setup, const float *__Ir, const float *__Ii, float *__Or, float *__Oi)
{
  MEMORY[0x24BDB3118](__Setup, __Ir, __Ii, __Or, __Oi);
}

vDSP_DFT_Setup vDSP_DFT_zrop_CreateSetup(vDSP_DFT_Setup __Previous, vDSP_Length __Length, vDSP_DFT_Direction __Direction)
{
  return (vDSP_DFT_Setup)MEMORY[0x24BDB3128](__Previous, __Length, *(_QWORD *)&__Direction);
}

void vDSP_conv(const float *__A, vDSP_Stride __IA, const float *__F, vDSP_Stride __IF, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __P)
{
  MEMORY[0x24BDB3198](__A, __IA, __F, __IF, __C, __IC, __N, __P);
}

FFTSetup vDSP_create_fftsetup(vDSP_Length __Log2n, FFTRadix __Radix)
{
  return (FFTSetup)MEMORY[0x24BDB31A0](__Log2n, *(_QWORD *)&__Radix);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
  MEMORY[0x24BDB31A8](__C, __IC, __Z, __IZ, __N);
}

void vDSP_dotpr(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB31D0](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_fft_zip(FFTSetup __Setup, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __Log2N, FFTDirection __Direction)
{
  MEMORY[0x24BDB31F0](__Setup, __C, __IC, __Log2N, *(_QWORD *)&__Direction);
}

void vDSP_hamm_window(float *__C, vDSP_Length __N, int __Flag)
{
  MEMORY[0x24BDB3200](__C, __N, *(_QWORD *)&__Flag);
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB3248](__A, __IA, __C, __N);
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB32D0](__A, __I, __C, __N);
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB32F0](__A, __IA, __C, __N);
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3308](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vclip(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x24BDB3328](__A, __IA, __B, __C, __D, __ID, __N);
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3368](__A, __C, __IC, __N);
}

void vDSP_vfix16(const float *__A, vDSP_Stride __IA, __int16 *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3378](__A, __IA, __C, __IC, __N);
}

void vDSP_vflt16(const __int16 *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3398](__A, __IA, __C, __IC, __N);
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3430](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vneg(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3440](__A, __IA, __C, __IC, __N);
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3498](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB34F0](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_zvmags(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB35C0](__A, __IA, __C, __IC, __N);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0370](a1, a2, a3);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

void vvexpf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x24BDB3B30](a1, a2, a3);
}

void vvlogf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x24BDB3B58](a1, a2, a3);
}

void vvrecf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x24BDB3B68](a1, a2, a3);
}

void vvsqrtf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x24BDB3B90](a1, a2, a3);
}

void vvtanhf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x24BDB3BA0](a1, a2, a3);
}

