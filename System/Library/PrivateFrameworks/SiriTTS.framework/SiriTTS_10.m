uint64_t pipeline_loc_DetermineEngine(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  const char *v12;
  int v13;
  uint64_t v14;
  const char **v15;

  v15 = 0;
  result = vector_GetSize(a2);
  if (!a3)
  {
    while (1)
LABEL_9:
      log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to determine the engine of the pipeline", v7, v8, v9, v14);
  }
  v10 = result;
  *a3 = 0;
  if ((_DWORD)result)
  {
    v11 = 0;
    while (1)
    {
      if (!vector_GetElemAt(a2, v11, &v15))
        goto LABEL_9;
      v12 = *v15;
      result = strcmp(*v15, "rby/ling");
      if (!(_DWORD)result)
      {
        v13 = 1;
        goto LABEL_12;
      }
      result = strcmp(v12, "teng/synth");
      if (!(_DWORD)result)
        break;
      if (v10 == ++v11)
        return result;
    }
    v13 = 2;
LABEL_12:
    *a3 = v13;
  }
  return result;
}

uint64_t pipeline_ObjOpen(_WORD *a1, uint64_t a2, char *a3, uint64_t a4, int a5, uint64_t a6, uint64_t **a7, _DWORD *a8)
{
  uint64_t inited;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 Size;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int LogLevel;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  _WORD *v63;
  uint64_t Object;
  int v65;
  char *v66;
  char *v67;
  char *v68;
  int v69;
  char *v70;
  uint64_t v71;
  unsigned int v72;
  int v73;
  char *v75;
  unsigned int v76;
  unint64_t v77;
  _QWORD *v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t NullHandle;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _WORD *v99;
  int v100[2];
  char *v101;
  uint64_t v102;
  char *__s2;
  int v104;
  unsigned int __s[64];
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v104 = 0;
  v102 = 0;
  __s2 = 0;
  *(_QWORD *)v100 = 0;
  v101 = 0;
  v98 = 0;
  v99 = 0;
  v96 = 0;
  v97 = 0;
  inited = InitRsrcFunction(a1, a2, v100);
  if ((inited & 0x80000000) != 0)
    return inited;
  *a7 = 0;
  *a8 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjOpen : Begin %s", v17, v18, v19, (uint64_t)a3);
  *(_QWORD *)__s = 0;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"mlset", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"voiceml", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"noclmset", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"shortfragmentforceclm", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"shortfragmentforceclm_value_pipeline", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"extclccfg", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"feextcfgdataprefix", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"voicecomponentid", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"engine_support_base_release", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"engine_support_point_releases", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"lidlanguages", __s);
  if (!*(_QWORD *)__s)
  {
    v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"lidlanguages", &byte_1DEBD87CE);
    if ((v27 & 0x1FFF) == 0xA)
      goto LABEL_28;
  }
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"extraesclang", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"extraesctn", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"typeofsynthesis", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"fedatapackaging", &byte_1DEBD87CE);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  v27 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"prmigexists", 0);
  if ((v27 & 0x1FFF) == 0xA)
    goto LABEL_28;
  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"voiceoperatingpoint");
  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"uselectrawdataversion");
  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"uselectreductionversion");
  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"nnpausingthresholdpercent");
  v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"bet4nodeprunemax", 0);
  if ((v28 & 0x1FFF) != 0xA)
  {
    v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"bet4beamwidth", 0);
    if ((v28 & 0x1FFF) != 0xA)
    {
      v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"bet4nodelimit", 0);
      if ((v28 & 0x1FFF) != 0xA)
      {
        v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"bet4nodeprunemaxunvoiced", 0);
        if ((v28 & 0x1FFF) != 0xA)
        {
          v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"timbre_baseline", 0x64u);
          if ((v28 & 0x1FFF) != 0xA)
          {
            v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"pitch_baseline", 0x64u);
            if ((v28 & 0x1FFF) != 0xA)
            {
              v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"rate_baseline", 0x64u);
              if ((v28 & 0x1FFF) != 0xA)
              {
                v28 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"volume_baseline", 0x50u);
                if ((v28 & 0x1FFF) != 0xA)
                {
                  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"basicclcprosody");
                  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"punctmarks");
                  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"addondct_extended_lookup");
                  paramc_ParamRemove(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"nnpausingoverride");
                  v95 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v100 + 8), 1, 56);
                  if (!v95)
                  {
                    v27 = 2166366218;
                    log_OutPublic(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 16000, 0, v32, v33, v34, v35, v92);
                    goto LABEL_28;
                  }
                  *(_QWORD *)v95 = *(_QWORD *)v100;
                  v36 = heap_strdup(*(_QWORD *)(*(_QWORD *)v100 + 8), a3);
                  *(_QWORD *)(v95 + 8) = v36;
                  if (v36)
                  {
                    v41 = pipeline_ListPipelineComponentNames(a1, a2, a3, &v97);
                    if ((v41 & 0x80000000) != 0)
                    {
                      v27 = v41;
LABEL_59:
                      v29 = 0;
                      v30 = (uint64_t *)v95;
                      goto LABEL_29;
                    }
                    pipeline_loc_DetermineEngine(*(uint64_t *)v100, v97, &v104);
                    Size = vector_GetSize(v97);
                    *(_WORD *)(v95 + 24) = Size;
                    v43 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v100 + 8), Size, 8);
                    *(_QWORD *)(v95 + 16) = v43;
                    v44 = *(_QWORD *)v100;
                    if (v43)
                    {
                      v45 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v100 + 8), *(unsigned __int16 *)(v95 + 24), 16);
                      v46 = *(_QWORD *)(*(_QWORD *)v100 + 32);
                      v94 = v45;
                      if (v45)
                      {
                        LogLevel = log_GetLogLevel(v46);
                        LODWORD(v48) = *(unsigned __int16 *)(v95 + 24);
                        if (LogLevel >= 2)
                        {
                          compstats_ObjOpen(a1, a2, v48 + 3, v95 + 32);
                          compstats_Start(*(_QWORD *)(v95 + 32), *(_QWORD *)(v95 + 40), 0, v49, v50, v51, v52, v53);
                          v48 = *(unsigned __int16 *)(v95 + 24);
                          if (*(_QWORD *)(v95 + 32))
                          {
                            v54 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v100 + 8), v48 + 3, 8);
                            *(_QWORD *)(v95 + 48) = v54;
                            if (v54)
                            {
                              **(_QWORD **)(v95 + 48) = heap_strdup(*(_QWORD *)(*(_QWORD *)v100 + 8), "Total");
                              *(_QWORD *)(*(_QWORD *)(v95 + 48) + 8) = heap_strdup(*(_QWORD *)(*(_QWORD *)v100 + 8), "TTSEG input CB");
                              v55 = heap_strdup(*(_QWORD *)(*(_QWORD *)v100 + 8), "TTSEG output CB");
                              LODWORD(v48) = *(unsigned __int16 *)(v95 + 24);
                              *(_QWORD *)(*(_QWORD *)(v95 + 48) + 8 * *(unsigned __int16 *)(v95 + 24) + 16) = v55;
                            }
                            else
                            {
                              compstats_ObjClose(*(_QWORD *)(v95 + 32), *(_QWORD *)(v95 + 40));
                              *(_QWORD *)(v95 + 32) = safeh_GetNullHandle();
                              *(_QWORD *)(v95 + 40) = v56;
                              LODWORD(v48) = *(unsigned __int16 *)(v95 + 24);
                            }
                          }
                        }
                        if ((_DWORD)v48)
                        {
                          v57 = 0;
                          do
                          {
                            *(_QWORD *)__s = 0;
                            if (!vector_GetElemAt(v97, v57, __s))
                            {
                              log_OutPublic(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 16000, 0, v58, v59, v60, v61, v92);
                              v27 = 2166366212;
                              goto LABEL_76;
                            }
                            v62 = **(char ***)__s;
                            v101 = **(char ***)__s;
                            if (!a4 || (pipeline_Find(a4, v62, &v99) & 0x80000000) != 0)
                            {
                              Object = pipeline_PrepareForOpeningComponent(*(uint64_t **)v100, (unsigned __int16)v57, v62, (_QWORD *)v95);
                              if ((Object & 0x80000000) != 0)
                                goto LABEL_73;
                            }
                            else
                            {
                              v63 = v99;
                              *(_QWORD *)(*(_QWORD *)(v95 + 16) + 8 * v57) = v99;
                              ++*v63;
                              if (*(_QWORD *)(v95 + 32))
                                *(_QWORD *)(*(_QWORD *)(v95 + 48) + 8 * v57 + 16) = heap_strdup(*(_QWORD *)(*(_QWORD *)v100 + 8), v101);
                            }
                            ++v57;
                          }
                          while (v57 < *(unsigned __int16 *)(v95 + 24));
                        }
                        Object = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"pipeline", a3);
                        if ((Object & 0x1FFF) == 0xA
                          || (Object = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"fedatapackaging", &byte_1DEBD87CE), (Object & 0x1FFF) == 0xA))
                        {
LABEL_73:
                          v27 = Object;
                          goto LABEL_76;
                        }
                        v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"datapackagename", &byte_1DEBD87CE);
                        if ((v27 & 0x1FFF) == 0xA)
                          goto LABEL_76;
                        if ((brk_TagIteratorOpen(*(_QWORD *)(*(_QWORD *)v100 + 24), a3, "PARAMETERS/*", 1, &v98) & 0x80000000) == 0)
                        {
                          if ((brk_TagIteratorNext(v98, (uint64_t)&__s2, (uint64_t)&v101) & 0x80000000) == 0)
                          {
                            v93 = 0;
                            v65 = 0;
                            while (1)
                            {
                              v66 = __s2;
                              if (__s2 && *__s2)
                              {
                                if (!strcmp("vopversion", __s2))
                                  v65 = 1;
                                if (strcmp("waitfactor", v66))
                                  goto LABEL_185;
                                __s[0] = 1;
                                if ((paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"waitfactor", __s) & 0x80000000) == 0)v27 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"waitfactorpipelinebackup", __s[0]);
                                if ((v27 & 0x1FFF) == 0xA)
                                  goto LABEL_76;
                                v66 = __s2;
                                v93 = 1;
                                if (__s2)
                                {
LABEL_185:
                                  if (*v66 && (a5 == 0xFFFF || strncmp("audiooutput", v66, 0xBuLL)))
                                  {
                                    if (strcmp("extraesclang", v66) && strcmp("extraesctn", v66))
                                      goto LABEL_99;
                                    *(_QWORD *)__s = 0;
                                    if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"clcpreventhlpactivate", __s) & 0x80000000) == 0)
                                    {
                                      v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"clcpreventhlpactivate", "yes");
                                      if ((v27 & 0x1FFF) == 0xA)
                                        goto LABEL_76;
                                    }
                                    v66 = __s2;
                                    if (__s2)
                                    {
LABEL_99:
                                      if (*v66 && !strcmp("waitfactor", v66))
                                      {
                                        __s[0] = 0;
                                        if ((paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"waitfactorsetbyapi", __s) & 0x80000000) != 0|| __s[0] != 1)
                                        {
                                          if (v101)
                                            v70 = v101;
                                          else
                                            v70 = &byte_1DEBD87CE;
                                          v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)__s2, v70);
                                        }
                                        v69 = v27 & 0x1FFF;
LABEL_116:
                                        if (v69 == 10)
                                          goto LABEL_76;
                                        goto LABEL_117;
                                      }
                                    }
                                    if (v101)
                                      v67 = v101;
                                    else
                                      v67 = &byte_1DEBD87CE;
                                    v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)v66, v67);
                                    if ((v27 & 0x1FFF) == 0xA)
                                      goto LABEL_76;
                                    if (!strcmp("shortfragmentforceclm", __s2))
                                    {
                                      if (v101)
                                        v68 = v101;
                                      else
                                        v68 = &byte_1DEBD87CE;
                                      v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"shortfragmentforceclm_value_pipeline", v68);
                                      v69 = v27 & 0x1FFF;
                                      goto LABEL_116;
                                    }
                                  }
                                }
                              }
LABEL_117:
                              if ((brk_TagIteratorNext(v98, (uint64_t)&__s2, (uint64_t)&v101) & 0x80000000) != 0)
                                goto LABEL_120;
                            }
                          }
                          v65 = 0;
                          v93 = 0;
LABEL_120:
                          v27 = vopCheckEngineCompatibility(*(uint64_t *)v100);
                          if ((v27 & 0x80000000) != 0)
                            goto LABEL_76;
                          if (!v65)
                            v27 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"vopversion", "0.0.0");
                          if ((v27 & 0x1FFF) == 0xA)
                            goto LABEL_76;
                          if (!v93)
                          {
                            __s[0] = 1;
                            if ((paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"waitfactorpipelinebackup", __s) & 0x80000000) == 0)
                            {
                              v27 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"waitfactor", __s[0]);
                              if ((v27 & 0x1FFF) == 0xA)
                                goto LABEL_76;
                              v27 = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)v100 + 40), (uint64_t)"waitfactorpipelinebackup", __s[0]);
                              if ((v27 & 0x1FFF) == 0xA)
                                goto LABEL_76;
                            }
                          }
                          brk_TagIteratorClose(v98);
                          v98 = 0;
                        }
                        if ((pipeline_create_name_vector_for_query(*(_QWORD **)v100, a3, "OBJECTS/*", &v96) & 0x80000000) == 0)
                        {
                          v71 = v96;
                          if (!v104)
                          {
                            Object = hlp_insert_after(*(uint64_t *)v100, v96, "FE_DCTLKP|fe/fe_dctlkp", "FE_NN|fe/fe_nn", 0);
                            if ((Object & 0x80000000) != 0)
                              goto LABEL_73;
                          }
                          Object = hlp_insert_after(*(uint64_t *)v100, v71, "INET|inetspi", "CHARCOUNT|charcount", 0);
                          if ((Object & 0x80000000) != 0)
                            goto LABEL_73;
                          Object = hlp_append(*(uint64_t *)v100, v71);
                          if ((Object & 0x80000000) != 0)
                            goto LABEL_73;
                          if (vector_GetSize(v71))
                          {
                            v72 = 0;
                            v73 = 0;
                            v27 = 2166366208;
                            do
                            {
                              if (!vector_GetElemAt(v71, v72, &v102))
                                goto LABEL_76;
                              __strcpy_chk();
                              if (*(_QWORD *)__s != 0x656E697C54454E49
                                || *(_QWORD *)((char *)&__s[1] + 1) != 0x69707374656E69)
                              {
                                v75 = strchr((char *)__s, 124);
                                v101 = v75;
                                if (!v75)
                                  goto LABEL_76;
                                *v75 = 0;
                                ++v101;
                                __s2 = (char *)__s;
                                Object = pipeline_LoadObject(a1, a2, (uint64_t)__s, v101, a6, a8);
                                if ((Object & 0x80000000) != 0)
                                  goto LABEL_73;
                              }
                              v72 = (unsigned __int16)++v73;
                            }
                            while (vector_GetSize(v71) > (unsigned __int16)v73);
                          }
                        }
                        Object = pipeline_disclose_location_of_fe_clm_component(*(uint64_t *)v100, v95);
                        if ((Object & 0x80000000) != 0)
                          goto LABEL_73;
                        v27 = pipeline_disclose_processing_tnplus(*(uint64_t *)v100, v95);
                        if ((v27 & 0x80000000) != 0)
                          goto LABEL_76;
                        v76 = *(unsigned __int16 *)(v95 + 24);
                        if (*(_WORD *)(v95 + 24))
                        {
                          v77 = 0;
                          v78 = (_QWORD *)(v94 + 8);
                          while (1)
                          {
                            v79 = *(uint64_t **)(*(_QWORD *)(v95 + 16) + 8 * v77);
                            if (!v79)
                              goto LABEL_157;
                            v80 = *(_QWORD *)(v95 + 32);
                            if (v80)
                              compstats_Start(v80, *(_QWORD *)(v95 + 40), (v77 + 2), v22, v23, v24, v25, v26);
                            NullHandle = safeh_GetNullHandle();
                            if (safeh_HandlesEqual(v79[3], v79[4], NullHandle, v82))
                              break;
                            if (*(_QWORD *)(v79[2] + 48))
                            {
                              log_OutText(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen component: %s", v24, v25, v26, v79[1]);
                              *a8 = 1;
                              kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(*(_QWORD *)v100 + 40));
                              v83 = (*(uint64_t (**)(uint64_t, uint64_t))(v79[2] + 48))(v79[3], v79[4]);
                              goto LABEL_152;
                            }
LABEL_153:
                            v84 = *(_QWORD *)(v95 + 32);
                            if (v84)
                              compstats_Stop(v84, *(_QWORD *)(v95 + 40), (v77 + 2), v22, v23, v24, v25, v26);
                            if ((v27 & 0x80000000) != 0)
                            {
                              log_OutPublic(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 16001, "%s%s%s%x", v23, v24, v25, v26, "component");
                              goto LABEL_76;
                            }
                            v76 = *(unsigned __int16 *)(v95 + 24);
LABEL_157:
                            ++v77;
                            v78 += 2;
                            if (v77 >= v76)
                              goto LABEL_158;
                          }
                          log_OutText(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Open component: %s", v24, v25, v26, v79[1]);
                          kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(*(_QWORD *)v100 + 40));
                          v83 = (*(uint64_t (**)(_QWORD, _QWORD, _WORD *, uint64_t, uint64_t *))(v79[2] + 32))(*(v78 - 1), *v78, a1, a2, v79 + 3);
LABEL_152:
                          v27 = v83;
                          kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(*(_QWORD *)v100 + 40));
                          goto LABEL_153;
                        }
LABEL_158:
                        v85 = brk_TagIteratorOpen(*(_QWORD *)(*(_QWORD *)v100 + 24), a3, "RESOURCES/*", 1, &v98);
                        v27 = v85;
                        if ((v85 & 0x80000000) != 0)
                        {
                          if ((v85 & 0x1FFF) != 0xD && (v85 & 0x1FFF) != 20)
                            goto LABEL_76;
                          v27 = 0;
                        }
                        while ((brk_TagIteratorNext(v98, (uint64_t)&__s2, (uint64_t)&v101) & 0x80000000) == 0)
                        {
                          if (__s2 && !strcmp(__s2, "RESOURCE"))
                          {
                            if (v101 && *v101)
                            {
                              log_OutPublic(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 16095, "%s%s", v87, v88, v89, v90, "pipeline");
                              v27 = 2166366212;
                            }
                            else
                            {
                              log_OutPublic(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 16094, "%s%s", v87, v88, v89, v90, "pipeline");
                            }
                          }
                          else
                          {
                            log_OutPublic(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 16093, "%s%s%s%s", v87, v88, v89, v90, "pipeline");
                          }
                        }
                        brk_TagIteratorClose(v98);
                        v98 = 0;
                        v91 = *(_QWORD *)(v95 + 32);
                        if (v91 && *(_QWORD *)(v95 + 48))
                        {
                          v30 = (uint64_t *)v95;
                          compstats_Stop(v91, *(_QWORD *)(v95 + 40), 0, v22, v23, v24, v25, v26);
                          compstats_Log(v30[4], v30[5], *(_QWORD *)(*(_QWORD *)v100 + 32), "Pipeline Open", v30[6], 0, 0);
                          goto LABEL_77;
                        }
LABEL_76:
                        v30 = (uint64_t *)v95;
LABEL_77:
                        v29 = v94;
                        goto LABEL_29;
                      }
                      v27 = 2166366218;
                      goto LABEL_58;
                    }
                    v27 = 2166366218;
                  }
                  else
                  {
                    v27 = 2166366218;
                    v44 = *(_QWORD *)v100;
                  }
                  v46 = *(_QWORD *)(v44 + 32);
LABEL_58:
                  log_OutPublic(v46, (uint64_t)"TTSEG", 16000, 0, v37, v38, v39, v40, v92);
                  goto LABEL_59;
                }
              }
            }
          }
        }
      }
    }
  }
  v27 = v28;
LABEL_28:
  v29 = 0;
  v30 = 0;
LABEL_29:
  if (v97)
    vector_ObjClose(v97);
  if (v96)
    vector_ObjClose(v96);
  if (v98)
    brk_TagIteratorClose(v98);
  if (v29)
    heap_Free(*(_QWORD **)(*(_QWORD *)v100 + 8), v29);
  if ((v27 & 0x80000000) != 0)
  {
    if (v30)
      pipeline_ObjClose((uint64_t)v30, v20, v21, v22, v23, v24, v25, v26);
  }
  else
  {
    *a7 = v30;
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjOpen : End (%x)", v24, v25, v26, v27);
  return v27;
}

uint64_t pipeline_Find(uint64_t a1, char *__s2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t *i;
  uint64_t v8;

  v3 = 2166366215;
  if (a1 && __s2 && *__s2)
  {
    *a3 = 0;
    v6 = *(unsigned __int16 *)(a1 + 24);
    if (*(_WORD *)(a1 + 24))
    {
      for (i = *(uint64_t **)(a1 + 16); ; ++i)
      {
        v8 = *i;
        if (!strcmp(*(const char **)(*i + 8), __s2))
          break;
        if (!--v6)
          return 2166366228;
      }
      v3 = 0;
      *a3 = v8;
    }
    else
    {
      return 2166366228;
    }
  }
  return v3;
}

uint64_t pipeline_PrepareForOpeningComponent(uint64_t *a1, unsigned int a2, char *__s, _QWORD *a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v36;

  if (a4[4])
  {
    v8 = heap_strdup(a1[1], __s);
    v9 = a2 + 2;
    *(_QWORD *)(a4[6] + 8 * v9) = v8;
    compstats_Start(a4[4], a4[5], v9, v10, v11, v12, v13, v14);
  }
  v15 = (_WORD *)heap_Calloc((_QWORD *)a1[1], 1, 40);
  if (!v15)
  {
    v32 = 2166366218;
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16000, 0, v16, v17, v18, v19, v36);
    return v32;
  }
  v20 = v15;
  *(_QWORD *)(a4[2] + 8 * a2) = v15;
  *v15 = 1;
  v21 = heap_strdup(a1[1], __s);
  v20[1] = v21;
  if (v21)
  {
    v20[3] = safeh_GetNullHandle();
    v20[4] = v26;
    v32 = brk_InterfaceQuery(a1[3]);
    if ((v32 & 0x80000000) == 0)
    {
      v33 = a4[4];
      if (v33)
        compstats_Stop(v33, a4[5], a2 + 2, v27, v28, v29, v30, v31);
      return v32;
    }
  }
  else
  {
    v32 = 2166366218;
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16000, 0, v22, v23, v24, v25, v36);
  }
  v34 = v20[1];
  if (v34)
    heap_Free((_QWORD *)a1[1], v34);
  heap_Free((_QWORD *)a1[1], (uint64_t)v20);
  *(_QWORD *)(a4[2] + 8 * a2) = 0;
  return v32;
}

uint64_t vopCheckEngineCompatibility(uint64_t a1)
{
  uint64_t v2;
  uint64_t MajorMinorMaintAndSearchNext;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  BOOL v17;
  BOOL v18;
  _BOOL4 v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  unsigned __int8 v28;
  __int16 v29;
  char v30[32];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v26 = 0;
  __sprintf_chk(v30, 0, 0x20uLL, "%.2d.%.2d.%d", 23, 3, 2);
  v2 = 0;
  if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"engine_support_base_release", &v26) & 0x80000000) == 0 && v26)
  {
    if (*v26)
    {
      LOBYTE(v27) = 0;
      v29 = 0;
      MajorMinorMaintAndSearchNext = versionGetMajorMinorMaintAndSearchNext(v26, &v27, (_BYTE *)&v29 + 1, &v29, 0);
      if ((MajorMinorMaintAndSearchNext & 0x80000000) != 0)
      {
        v2 = MajorMinorMaintAndSearchNext;
        if ((MajorMinorMaintAndSearchNext & 0x1FFF) != 0x19)
        {
          v9 = *(_QWORD *)(a1 + 32);
          v10 = "VOP level compatibility check current engine '%s' against main '%s': failed (format error)";
LABEL_43:
          log_OutText(v9, (uint64_t)"TTSEG", 4, 0, (uint64_t)v10, v4, v5, v6, (uint64_t)v30);
          goto LABEL_44;
        }
      }
      else
      {
        if (v27 < 0x17u
          || v27 == 23 && (HIBYTE(v29) < 3u || HIBYTE(v29) == 3 && v29 <= 2u))
        {
          v7 = *(_QWORD *)(a1 + 32);
          v8 = "VOP level compatibility check current engine '%s' against main '%s': passed";
LABEL_50:
          log_OutText(v7, (uint64_t)"TTSEG", 4, 0, (uint64_t)v8, v4, v5, v6, (uint64_t)v30);
          goto LABEL_51;
        }
        v2 = 2166366233;
      }
      log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"VOP level compatibility check current engine '%s' against main '%s': did not pass", v4, v5, v6, (uint64_t)v30);
    }
    else
    {
      v2 = 0;
    }
  }
  if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"engine_support_point_releases", &v25) & 0x80000000) == 0)
  {
    v15 = v25;
    if (v25)
    {
      if (*v25)
      {
        v2 = 2166366233;
        v29 = 0;
        v28 = 0;
        v27 = 0;
        while (1)
        {
          v16 = versionGetMajorMinorMaintAndSearchNext(v15, (_BYTE *)&v29 + 1, &v29, &v28, &v27);
          if ((v16 & 0x80000000) != 0)
          {
            v2 = v16;
            goto LABEL_40;
          }
          v17 = HIBYTE(v29) == 23 && v29 == 3;
          v18 = !v17 || v28 > 2u;
          v19 = v18;
          v15 = v27;
          if (!v19 || v27 == 0)
            break;
          if (!*v27)
            goto LABEL_40;
        }
        if (!v19)
        {
          v7 = *(_QWORD *)(a1 + 32);
          v8 = "VOP level compatibility check current engine '%s' against point releases '%s': passed";
          goto LABEL_50;
        }
LABEL_40:
        v9 = *(_QWORD *)(a1 + 32);
        if ((v2 & 0x1FFF) == 0x19)
          v10 = "VOP level compatibility check current engine '%s' against point releases '%s': did not pass";
        else
          v10 = "VOP level compatibility check current engine '%s' against point releases '%s': failed (format error)";
        goto LABEL_43;
      }
    }
  }
  if ((v2 & 0x80000000) != 0)
  {
LABEL_44:
    if ((v2 & 0x1FFF) == 7)
    {
      v21 = *(_QWORD *)(a1 + 32);
      v22 = 82001;
    }
    else
    {
      if ((v2 & 0x1FFF) != 0x19)
        return v2;
      v21 = *(_QWORD *)(a1 + 32);
      v22 = 82000;
    }
    log_OutPublic(v21, (uint64_t)"TTSEG", v22, 0, v11, v12, v13, v14, v24);
    return v2;
  }
LABEL_51:
  if ((!v26 || !*v26) && (!v25 || !*v25))
    log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"VOP level compatibility check against current engine : not enabled", v12, v13, v14, v24);
  return 0;
}

uint64_t hlp_insert_after(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t (*a5)(const char *))
{
  uint64_t result;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char **v16;
  char *v17;

  v16 = 0;
  v17 = a4;
  result = vector_GetSize(a2);
  if ((_DWORD)result)
  {
    v10 = result;
    v11 = 1;
    while (1)
    {
      if (!vector_GetElemAt(a2, v11 - 1, &v16))
        goto LABEL_13;
      if (!strcmp(*v16, a3))
        break;
      if (v11++ >= v10)
        return 0;
    }
    if (!vector_GetElemAt(a2, v11, &v16))
    {
LABEL_13:
      log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to insert component '%s'", v12, v13, v14, *v17);
      return 2166366212;
    }
    if (!a5 || (result = a5(*v16), (_DWORD)result))
    {
      vector_AddElemAt(a2, v11, &v17);
      return 0;
    }
  }
  return result;
}

uint64_t hlp_append(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v7;

  v7 = "CLMOBJECT|clmobjectinterface";
  if (vector_Add(a2, &v7))
    return 0;
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to append '%s'", v3, v4, v5, *v7);
  return 2166366212;
}

uint64_t pipeline_LoadObject(_WORD *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v12;
  uint64_t inited;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t NullHandle;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;

  v48 = 0;
  v49 = a3;
  NullHandle = safeh_GetNullHandle();
  v47 = v12;
  v45 = 0;
  inited = InitRsrcFunction(a1, a2, &v48);
  if ((inited & 0x80000000) == 0)
  {
    if ((objc_GetObject(v48[6], a3, &v45) & 0x80000000) != 0)
    {
      v44 = 0;
      v42 = 0u;
      v43 = 0u;
      if (LH_stricmp(a4, "phonmap"))
        v23 = 1;
      else
        v23 = 2;
      LOBYTE(v42) = v23;
      v24 = brk_InterfaceQuery(v48[3]);
      if ((v24 & 0x80000000) != 0)
        return v24;
      log_OutText(v48[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Open component: %s", v25, v26, v27, (uint64_t)a4);
      v28 = (*(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t, __int128 *))(*((_QWORD *)&v42 + 1) + 32))(NullHandle, v47, a1, a2, &v43);
      if ((v28 & 0x80000000) != 0)
      {
        inited = v28;
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v29, v30, v31, v32, "component");
        brk_InterfaceRelease(v48[3], *((uint64_t *)&v42 + 1));
        return inited;
      }
      inited = objc_RegisterObject(v48[6], a3, &v42);
      if ((inited & 0x80000000) != 0)
      {
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v33, v34, v35, v36, "component");
      }
      else
      {
        if (!a5 || vector_Add(a5, &v49))
          return inited;
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16000, 0, v37, v38, v39, v40, v41);
        inited = 2166366218;
      }
      (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)&v42 + 1) + 40))(v43, *((_QWORD *)&v43 + 1));
      brk_InterfaceRelease(v48[3], *((uint64_t *)&v42 + 1));
      return inited;
    }
    v17 = v45[1];
    if (*(_QWORD *)(v17 + 48))
    {
      log_OutText(v48[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen object: %s", v14, v15, v16, a3);
      if (a6)
        *a6 = 1;
      inited = (*(uint64_t (**)(_QWORD, _QWORD))(v17 + 48))(v45[2], v45[3]);
      if ((inited & 0x80000000) != 0)
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v18, v19, v20, v21, "component");
    }
    objc_ReleaseObject(v48[6], a3);
  }
  return inited;
}

uint64_t pipeline_disclose_location_of_fe_clm_component(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  unsigned int v12;

  v2 = a1;
  v3 = *(unsigned __int16 *)(a2 + 24);
  if (*(_WORD *)(a2 + 24))
  {
    v4 = 0;
    v5 = 0xFFFF;
    v6 = *(_QWORD *)(a2 + 16);
    v7 = 0xFFFF;
    v8 = 0xFFFF;
    do
    {
      v9 = *(_QWORD *)(v6 + 8 * v4);
      if (v9)
      {
        v10 = *(const char **)(v9 + 8);
        if (!strcmp(v10, "fe/fe_clm"))
        {
          v8 = (unsigned __int16)v4;
        }
        else if (!strcmp(v10, "fe/fe_global"))
        {
          v7 = (unsigned __int16)v4;
        }
        else if (!strcmp(v10, "sink") || !strcmp(v10, "feeder"))
        {
          v5 = (unsigned __int16)v4;
        }
      }
      ++v4;
    }
    while (v3 != v4);
    v2 = a1;
    if (v5 != 0xFFFF)
      return 0;
  }
  else
  {
    v7 = 0xFFFF;
    v8 = 0xFFFF;
  }
  result = paramc_ParamSetUInt(*(_QWORD *)(v2 + 40), (uint64_t)"fe_clm_component", 0);
  if ((result & 0x80000000) == 0 && v8 != 0xFFFF && v7 != 0xFFFF)
  {
    if (v7 >= v8)
      v12 = 1;
    else
      v12 = 2;
    return paramc_ParamSetUInt(*(_QWORD *)(v2 + 40), (uint64_t)"fe_clm_component", v12);
  }
  return result;
}

uint64_t pipeline_disclose_processing_tnplus(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  char *v11;

  v3 = *(unsigned __int16 *)(a2 + 24);
  if (!*(_WORD *)(a2 + 24))
  {
    v10 = *(_QWORD *)(a1 + 40);
    goto LABEL_14;
  }
  v4 = 0;
  v5 = 0;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = 0xFFFF;
  do
  {
    v8 = *(_QWORD *)(v6 + 8 * v4);
    if (v8)
    {
      v9 = *(const char **)(v8 + 8);
      if (!strcmp(v9, "fe/geene_adapt"))
      {
        v5 = 1;
      }
      else if (!strcmp(v9, "sink") || !strcmp(v9, "feeder"))
      {
        v7 = (unsigned __int16)v4;
      }
    }
    ++v4;
  }
  while (v3 != v4);
  if (v7 == 0xFFFF)
  {
    v10 = *(_QWORD *)(a1 + 40);
    if (v5)
    {
      v11 = "yes";
      return paramc_ParamSetStr(v10, (uint64_t)"processingtnplus", v11);
    }
LABEL_14:
    v11 = "no";
    return paramc_ParamSetStr(v10, (uint64_t)"processingtnplus", v11);
  }
  return 0;
}

uint64_t pipeline_ResourceLoad(uint64_t *a1, int a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t ResourceOwner;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(_QWORD, _QWORD, const char *, char *, uint64_t, uint64_t, __int128 *);
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  __int128 v34;
  _QWORD *v35;

  v35 = 0;
  v14 = 2166366215;
  *(_QWORD *)&v34 = safeh_GetNullHandle();
  *((_QWORD *)&v34 + 1) = v15;
  if (a1 && a3)
  {
    if (!a4)
      a4 = &byte_1DEBD87CE;
    v16 = *a1;
    if (a7)
    {
      *a7 = safeh_GetNullHandle();
      a7[1] = v17;
    }
    ResourceOwner = pipeline_FindResourceOwner((uint64_t)a1, a3, (uint64_t *)&v35);
    if ((ResourceOwner & 0x80000000) != 0)
    {
      v30 = ResourceOwner;
      log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"TTSEG", 16077, "%s%s%s%s", v19, v20, v21, v22, "uri");
      return v30;
    }
    else
    {
      v23 = *(uint64_t (**)(_QWORD, _QWORD, const char *, char *, uint64_t, uint64_t, __int128 *))(v35[2] + 64);
      if (v23)
      {
        v24 = v23(v35[3], v35[4], a3, a4, a5, a6, &v34);
        v29 = v24;
        if ((v24 & 0x80000000) == 0)
        {
          if (a7)
            *(_OWORD *)a7 = v34;
          return v29;
        }
        if (!a2 || ((v14 = 0, v31 = v24 & 0x1FFF, v31 != 19) ? (v32 = v31 == 24) : (v32 = 1), !v32 && v31 != 1036))
        {
          log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"TTSEG", 16038, "%s%s%s%s%s%s%s%x", v25, v26, v27, v28, "component");
          return v29;
        }
      }
      else
      {
        log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"TTSEG", 16039, "%s%s%s%s%s%s", v19, v20, v21, v22, "component");
      }
    }
  }
  return v14;
}

uint64_t pipeline_ObjClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 v19;
  uint64_t v20;
  unsigned __int16 *v21;
  int v22;
  BOOL v23;
  int v24;
  uint64_t NullHandle;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v48;
  uint64_t v49;
  unsigned __int16 v50;
  uint64_t v51;
  uint64_t v52;

  if (!a1)
    return 2166366214;
  v9 = *(_QWORD *)a1;
  if (*(_QWORD *)(a1 + 16))
  {
    v10 = *(_QWORD *)(a1 + 32);
    if (v10)
    {
      compstats_Reset(v10);
      compstats_Start(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0, v11, v12, v13, v14, v15);
    }
    v16 = *(_WORD *)(a1 + 24);
    if (v16)
    {
      v17 = 0;
      v18 = (unsigned __int16)(v16 - 1) + 2;
      v19 = v16 - 1;
      do
      {
        v20 = v19;
        v21 = *(unsigned __int16 **)(*(_QWORD *)(a1 + 16) + 8 * v19);
        if (v21)
        {
          v22 = *v21;
          v23 = v22 != 0;
          v24 = v22 - 1;
          if (v24 != 0 && v23)
          {
            *v21 = v24;
          }
          else
          {
            NullHandle = safeh_GetNullHandle();
            if (!safeh_HandlesEqual(*((_QWORD *)v21 + 3), *((_QWORD *)v21 + 4), NullHandle, v26))
            {
              log_OutText(*(_QWORD *)(v9 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Close component: %s", v27, v28, v29, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v19) + 8));
              v35 = *(_QWORD *)(a1 + 32);
              if (v35)
                compstats_Start(v35, *(_QWORD *)(a1 + 40), v18, v30, v31, v32, v33, v34);
              v36 = *(_QWORD **)(*(_QWORD *)(a1 + 16) + 8 * v19);
              v42 = (*(uint64_t (**)(_QWORD, _QWORD))(v36[2] + 40))(v36[3], v36[4]);
              v43 = *(_QWORD *)(a1 + 32);
              if (v43)
                compstats_Stop(v43, *(_QWORD *)(a1 + 40), v18, v37, v38, v39, v40, v41);
              if ((v42 & 0x80000000) != 0)
              {
                log_OutPublic(*(_QWORD *)(v9 + 32), (uint64_t)"TTSEG", 16002, "%s%s%s%x", v38, v39, v40, v41, "component");
                if ((int)v17 >= 0)
                  v17 = v42;
                else
                  v17 = v17;
              }
            }
            v44 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v19);
            v45 = *(_QWORD *)(v44 + 16);
            if (v45)
            {
              v46 = brk_InterfaceRelease(*(_QWORD *)(v9 + 24), v45);
              if (v46 >= 0 || (int)v17 <= -1)
                v17 = v17;
              else
                v17 = v46;
              v44 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v19);
            }
            heap_Free(*(_QWORD **)(v9 + 8), *(_QWORD *)(v44 + 8));
            heap_Free(*(_QWORD **)(v9 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v19));
          }
        }
        v18 = (v18 - 1);
        --v19;
      }
      while (v20);
    }
    else
    {
      v17 = 0;
    }
    v48 = *(_QWORD *)(a1 + 32);
    if (v48)
    {
      compstats_Stop(v48, *(_QWORD *)(a1 + 40), 0, a4, a5, a6, a7, a8);
      compstats_Log(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(v9 + 32), "Pipeline Close", *(_QWORD *)(a1 + 48), 0, 0);
    }
    heap_Free(*(_QWORD **)(v9 + 8), *(_QWORD *)(a1 + 16));
  }
  else
  {
    v17 = 0;
  }
  v49 = *(_QWORD *)(a1 + 32);
  if (v49)
    compstats_ObjClose(v49, *(_QWORD *)(a1 + 40));
  if (*(_QWORD *)(a1 + 48))
  {
    v50 = 0;
    do
    {
      v51 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v50);
      if (v51)
        heap_Free(*(_QWORD **)(v9 + 8), v51);
      ++v50;
    }
    while (*(unsigned __int16 *)(a1 + 24) + 3 > v50);
    heap_Free(*(_QWORD **)(v9 + 8), *(_QWORD *)(a1 + 48));
  }
  v52 = *(_QWORD *)(a1 + 8);
  if (v52)
    heap_Free(*(_QWORD **)(v9 + 8), v52);
  heap_Free(*(_QWORD **)(v9 + 8), a1);
  return v17;
}

uint64_t pipeline_ObjReopen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;
  char *v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v27;
  char *v28;
  char *__s2;
  uint64_t v30;

  v9 = *(_QWORD **)a1;
  v10 = *(char **)(a1 + 8);
  __s2 = 0;
  v30 = 0;
  v28 = 0;
  log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjReopen : Begin %s", a6, a7, a8, (uint64_t)v10);
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"pipeline", v10);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"mlset", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"voiceml", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"noclmset", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm_value_pipeline", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extclccfg", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"lidlanguages", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extraesclang", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extraesctn", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"typeofsynthesis", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"uselearlyemission", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"pmksync", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"feextcfgdataprefix", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"engine_support_base_release", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"engine_support_point_releases", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"fedatapackaging", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetStr(v9[5], (uint64_t)"datapackagename", &byte_1DEBD87CE);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  paramc_ParamRemove(v9[5], (uint64_t)"voiceoperatingpoint");
  paramc_ParamRemove(v9[5], (uint64_t)"uselectrawdataversion");
  paramc_ParamRemove(v9[5], (uint64_t)"uselectreductionversion");
  paramc_ParamRemove(v9[5], (uint64_t)"nnpausingthresholdpercent");
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodeprunemax", 0);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4beamwidth", 0);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodelimit", 0);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodeprunemaxunvoiced", 0);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"timbre_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"pitch_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"rate_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"volume_baseline", 0x50u);
  if ((v14 & 0x1FFF) == 0xA)
    goto LABEL_85;
  paramc_ParamRemove(v9[5], (uint64_t)"basicclcprosody");
  paramc_ParamRemove(v9[5], (uint64_t)"punctmarks");
  paramc_ParamRemove(v9[5], (uint64_t)"addondct_extended_lookup");
  paramc_ParamRemove(v9[5], (uint64_t)"nnpausingoverride");
  if ((brk_TagIteratorOpen(v9[3], v10, "PARAMETERS/*", 1, &v30) & 0x80000000) != 0)
    goto LABEL_74;
  if ((brk_TagIteratorNext(v30, (uint64_t)&__s2, (uint64_t)&v28) & 0x80000000) == 0)
  {
    v15 = 0;
    while (1)
    {
      v16 = __s2;
      if (!__s2 || !*__s2)
        goto LABEL_65;
      if (!strcmp("waitfactor", __s2))
      {
        LODWORD(v27) = 1;
        if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactor", (unsigned int *)&v27) & 0x80000000) == 0)
          v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", v27);
        if ((v14 & 0x1FFF) == 0xA)
          goto LABEL_85;
        v16 = __s2;
        if (!__s2)
        {
          v15 = 1;
          goto LABEL_65;
        }
        v15 = 1;
        if (!*__s2)
          goto LABEL_65;
      }
      if (strncmp("audiooutput", v16, 0xBuLL))
      {
        if (!strcmp("extraesclang", v16) || !strcmp("extraesctn", v16))
        {
          v27 = 0;
          if ((paramc_ParamGetStr(v9[5], (uint64_t)"clcpreventhlpactivate", &v27) & 0x80000000) == 0)
          {
            v14 = paramc_ParamSetStr(v9[5], (uint64_t)"clcpreventhlpactivate", "yes");
            if ((v14 & 0x1FFF) == 0xA)
              goto LABEL_85;
          }
          v16 = __s2;
          if (!__s2)
            goto LABEL_41;
        }
        if (*v16 && !strcmp("waitfactor", v16))
        {
          LODWORD(v27) = 0;
          if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactorsetbyapi", (unsigned int *)&v27) & 0x80000000) != 0
            || (_DWORD)v27 != 1)
          {
            if (v28)
              v20 = v28;
            else
              v20 = &byte_1DEBD87CE;
            v14 = paramc_ParamSetStr(v9[5], (uint64_t)__s2, v20);
          }
          v19 = v14 & 0x1FFF;
        }
        else
        {
LABEL_41:
          if (v28)
            v17 = v28;
          else
            v17 = &byte_1DEBD87CE;
          v14 = paramc_ParamSetStr(v9[5], (uint64_t)v16, v17);
          if ((v14 & 0x1FFF) == 0xA)
            goto LABEL_85;
          if (strcmp("shortfragmentforceclm", __s2))
            goto LABEL_65;
          if (v28)
            v18 = v28;
          else
            v18 = &byte_1DEBD87CE;
          v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm_value_pipeline", v18);
          v19 = v14 & 0x1FFF;
        }
        if (v19 == 10)
          goto LABEL_85;
      }
LABEL_65:
      if ((brk_TagIteratorNext(v30, (uint64_t)&__s2, (uint64_t)&v28) & 0x80000000) != 0)
      {
        v21 = vopCheckEngineCompatibility((uint64_t)v9);
        if ((v21 & 0x80000000) == 0)
        {
          if (!v15)
            goto LABEL_70;
LABEL_73:
          brk_TagIteratorClose(v30);
          v30 = 0;
LABEL_74:
          v21 = hlp_pipeline_objects_reopen(v9, v10);
          if ((v21 & 0x80000000) == 0)
          {
            v21 = pipeline_disclose_location_of_fe_clm_component((uint64_t)v9, a1);
            if ((v21 & 0x80000000) == 0)
            {
              v14 = pipeline_disclose_processing_tnplus((uint64_t)v9, a1);
              if ((v14 & 0x80000000) == 0)
              {
                v22 = *(unsigned __int16 *)(a1 + 24);
                if (*(_WORD *)(a1 + 24))
                {
                  v23 = 0;
                  while (1)
                  {
                    v24 = *(uint64_t **)(*(_QWORD *)(a1 + 16) + 8 * v23);
                    if (*(_QWORD *)(v24[2] + 48))
                    {
                      log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen component: %s", v11, v12, v13, v24[1]);
                      v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v24[2] + 48))(v24[3], v24[4]);
                      if ((v14 & 0x80000000) != 0)
                      {
                        log_OutPublic(v9[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v25, v11, v12, v13, "component");
                        goto LABEL_85;
                      }
                      v22 = *(unsigned __int16 *)(a1 + 24);
                    }
                    if (++v23 >= (unint64_t)v22)
                      goto LABEL_85;
                  }
                }
              }
              goto LABEL_85;
            }
          }
        }
LABEL_84:
        v14 = v21;
        goto LABEL_85;
      }
    }
  }
  v21 = vopCheckEngineCompatibility((uint64_t)v9);
  if ((v21 & 0x80000000) != 0)
    goto LABEL_84;
LABEL_70:
  LODWORD(v27) = 1;
  if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", (unsigned int *)&v27) & 0x80000000) != 0)
    goto LABEL_73;
  v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactor", v27);
  if ((v14 & 0x1FFF) != 0xA)
  {
    v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", v27);
    if ((v14 & 0x1FFF) != 0xA)
      goto LABEL_73;
  }
LABEL_85:
  log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjReopen : End (%x)", v11, v12, v13, v14);
  return v14;
}

uint64_t hlp_pipeline_objects_reopen(_QWORD *a1, _BYTE *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char __s[256];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  v4 = pipeline_create_name_vector_for_query(a1, a2, "COMPONENTS/*", &v22);
  v5 = v22;
  if ((v4 & 0x80000000) != 0
    || (pipeline_loc_DetermineEngine((uint64_t)a1, v22, &v25),
        v4 = pipeline_create_name_vector_for_query(a1, a2, "OBJECTS/*", &v23),
        (v4 & 0x80000000) != 0)
    || (v6 = v23, !v25)
    && (v4 = hlp_insert_after((uint64_t)a1, v23, "FE_DCTLKP|fe/fe_dctlkp", "FE_NN|fe/fe_nn", 0), (v4 & 0x80000000) != 0)
    || (v4 = hlp_insert_after((uint64_t)a1, v6, "INET|inetspi", "CHARCOUNT|charcount", 0), (v4 & 0x80000000) != 0)
    || (v4 = hlp_append((uint64_t)a1, v6), (v4 & 0x80000000) != 0))
  {
    v9 = v4;
    goto LABEL_22;
  }
  if (!vector_GetSize(v6))
  {
    v9 = 0;
    goto LABEL_22;
  }
  v7 = 0;
  v8 = 0;
  v9 = 0;
  while (1)
  {
    if (!vector_GetElemAt(v6, v7, &v24))
    {
LABEL_28:
      v9 = 2166366208;
      goto LABEL_22;
    }
    __strcpy_chk();
    if (*(_QWORD *)__s != 0x656E697C54454E49 || *(_QWORD *)&__s[5] != 0x69707374656E69)
    {
      v11 = strchr(__s, 124);
      if (!v11)
        goto LABEL_28;
      *v11 = 0;
      if ((objc_GetObject(a1[6], (uint64_t)__s, &v21) & 0x80000000) == 0)
        break;
    }
LABEL_19:
    v7 = (unsigned __int16)++v8;
    if (vector_GetSize(v6) <= (unsigned __int16)v8)
      goto LABEL_22;
  }
  v15 = v21[1];
  if (!*(_QWORD *)(v15 + 48)
    || (log_OutText(a1[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen object: %s", v12, v13, v14, (uint64_t)__s),
        v9 = (*(uint64_t (**)(_QWORD, _QWORD))(v15 + 48))(v21[2], v21[3]),
        (v9 & 0x80000000) == 0))
  {
    objc_ReleaseObject(a1[6], (uint64_t)__s);
    goto LABEL_19;
  }
  log_OutPublic(a1[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v16, v17, v18, v19, "component");
  objc_ReleaseObject(a1[6], (uint64_t)__s);
LABEL_22:
  if (v5)
    vector_ObjClose(v5);
  if (v23)
    vector_ObjClose(v23);
  return v9;
}

uint64_t pipeline_FindResourceOwner(uint64_t a1, const char *a2, uint64_t *a3)
{
  uint64_t v3;
  unint64_t v7;
  _QWORD *v8;
  uint64_t (*v9)(_QWORD, _QWORD, uint64_t *);
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 v13;
  const char *v14;
  size_t v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  uint64_t v20;

  v3 = 2166366215;
  if (a1 && a2 && *a2)
  {
    v7 = 0;
    *a3 = 0;
    while (v7 < *(unsigned __int16 *)(a1 + 24))
    {
      v20 = 0;
      v8 = *(_QWORD **)(*(_QWORD *)(a1 + 16) + 8 * v7);
      v9 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t *))(v8[2] + 56);
      if (v9)
      {
        v10 = v9(v8[3], v8[4], &v20);
        v11 = *a3;
        if ((v10 & 0x80000000) == 0)
        {
          v12 = v20;
          if (v20)
          {
            if (v11)
              return 0;
            v13 = 0;
            do
            {
              v14 = *(const char **)(v12 + 8 * v13);
              if (!v14)
                break;
              v15 = strlen(*(const char **)(v12 + 8 * v13));
              if (!strncmp(a2, v14, v15)
                && ((v17 = a2[v15], v17 != 59) ? (v18 = v17 == 0) : (v18 = 1), v18))
              {
                v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v7);
                *a3 = v11;
                v16 = v11;
              }
              else
              {
                v16 = 0;
              }
              ++v13;
            }
            while (!v16);
          }
        }
      }
      else
      {
        v11 = 0;
      }
      ++v7;
      if (v11)
        return 0;
    }
    return 2166366228;
  }
  return v3;
}

uint64_t pipeline_ResourceUnload(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t (*v15)(_QWORD, _QWORD, uint64_t, uint64_t);

  v8 = 2166366215;
  if (a1)
  {
    v12 = 0;
    v13 = *a1;
    v8 = 2166366216;
    do
    {
      if (v12 >= *((unsigned __int16 *)a1 + 12))
        break;
      v14 = *(_QWORD **)(a1[2] + 8 * v12);
      v15 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(v14[2] + 72);
      if (v15)
      {
        v8 = v15(v14[3], v14[4], a2, a3);
        if ((v8 & 0x80000000) == 0)
          return v8;
      }
      ++v12;
    }
    while ((v8 & 0x1FFF) == 8);
    if ((v8 & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(v13 + 32), (uint64_t)"TTSEG", 16041, "%s%p%s%x", a5, a6, a7, a8, "handle");
  }
  return v8;
}

uint64_t pipeline_UnloadObjects(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  int i;
  int Size;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;

  v20 = 0;
  v21 = 0;
  v19 = 0;
  inited = InitRsrcFunction(a1, a2, &v21);
  if ((inited & 0x80000000) == 0)
  {
    for (i = 1; i != 3; ++i)
    {
      Size = vector_GetSize(a3);
      if (Size)
      {
        v7 = Size - 1;
        do
        {
          if (!vector_GetElemAt(a3, v7, &v20))
            break;
          if ((objc_GetObject(v21[6], *v20, &v19) & 0x80000000) == 0)
          {
            objc_ReleaseObject(v21[6], *v20);
            if (i == 1)
            {
              v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v19[1] + 40))(v19[2], v19[3]);
              if (v8 < 0)
              {
                v13 = v8;
                log_OutPublic(v21[4], (uint64_t)"TTSEG", 16100, "%s%x%s%s", v9, v10, v11, v12, "lherror");
              }
              else
              {
                v13 = brk_InterfaceRelease(v21[3], v19[1]);
              }
            }
            else
            {
              v13 = objc_UnregisterObject(v21[6], *v20);
              if (v13 < 0)
                log_OutPublic(v21[4], (uint64_t)"TTSEG", 16101, "%s%x%s%s", v14, v15, v16, v17, "lherror");
            }
            if (v13 >= 0)
              inited = inited;
            else
              inited = v13;
          }
          --v7;
        }
        while (v7 != -1);
      }
    }
  }
  return inited;
}

uint64_t pipeline_fill_CopyPartsString(const char **a1, uint64_t a2, uint64_t *a3)
{
  const char *v5;
  uint64_t v6;
  uint64_t result;
  const char *v8;

  v5 = *a1;
  if (*a1)
    v6 = strlen(*a1) + 1;
  else
    v6 = 1;
  result = heap_Alloc(a2, v6);
  *a3 = result;
  if (result)
  {
    if (v5)
      v8 = v5;
    else
      v8 = &byte_1DEBD87CE;
    strcpy((char *)result, v8);
    return 1;
  }
  return result;
}

uint64_t *pipeline_fill_ElemFreePartsString(uint64_t *result, _QWORD *a2)
{
  if (*result)
    return heap_Free(a2, *result);
  return result;
}

uint64_t is_not_sink_or_voice_switch(const char *a1)
{
  uint64_t result;

  result = strcmp(a1, "sink");
  if ((_DWORD)result)
    return strcmp(a1, "voice_switch") != 0;
  return result;
}

uint64_t is_not_sink_or_msp(const char *a1)
{
  uint64_t result;

  result = strcmp(a1, "sink");
  if ((_DWORD)result)
    return strcmp(a1, "fe/fe_msp") != 0;
  return result;
}

BOOL is_not_dspeffects(const char *a1)
{
  return strcmp(a1, "dspeffects") != 0;
}

uint64_t versionGetMajorMinorMaintAndSearchNext(char *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, char **a5)
{
  int v8;
  __int16 v9;
  int v10;
  uint64_t result;
  char *i;
  unsigned int v13;
  BOOL v14;
  int v15;
  int v16;
  BOOL v17;
  unint64_t StatusReg;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  char *v23;
  char *v24;
  char *v25;

  v8 = 0;
  v9 = 0;
  v10 = 0;
  *a4 = 0;
  result = 2166366215;
  *a3 = 0;
  *a2 = 0;
  for (i = a1; ; ++i)
  {
    v13 = *i;
    v14 = v13 > 0x2C || ((1 << v13) & 0x100100000001) == 0;
    if (!v14 || v8 < 0)
      break;
    if (v13 - 48 >= 0xA)
      v8 = -2128601081;
    else
      v8 = 0;
    if (v13 - 48 >= 0xA)
      v15 = v10;
    else
      v15 = v10 + 1;
    if ((unsigned __int16)(v9 + 1) <= 2u)
      v16 = 0;
    else
      v16 = -2128601081;
    if (v13 == 46)
    {
      v8 = v16;
      ++v9;
    }
    else
    {
      v10 = v15;
    }
  }
  v17 = v9 == 2 && (unsigned __int16)v10 >= 3u;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  if (!v17)
    v20 = -2128601081;
  else
    v20 = 0;
  if (v8 >= 0)
    v21 = v20;
  else
    v21 = v8;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  if (v8 < 0)
    return v21;
  while (v13 == 44 || v13 == 32)
  {
    v22 = *++i;
    v13 = v22;
  }
  if (a5)
  {
    *a5 = i;
    goto LABEL_39;
  }
  if (!*i)
  {
LABEL_39:
    *a2 = atoi(a1);
    v23 = strchr(a1, 46);
    if (v23)
    {
      v24 = v23 + 1;
      *a3 = atoi(v23 + 1);
      v25 = strchr(v24, 46);
      if (v25)
        *a4 = atoi(v25 + 1);
    }
    return v21;
  }
  return result;
}

uint64_t voice_switch_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2600476673;
  result = 0;
  *a2 = &IVScmp;
  return result;
}

uint64_t vscmp_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t Object;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int UInt;
  unsigned __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  unsigned __int16 v38;
  int v39;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;

  v44 = 0;
  v45 = 0;
  v5 = 2600476679;
  v43 = 0;
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, &v45);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Entering vscmp_ObjOpen", v10, v11, v12, v41);
      v13 = (_QWORD *)heap_Calloc(*(_QWORD **)(v45 + 8), 1, 928);
      v18 = v45;
      if (v13)
      {
        v19 = v13;
        v13[1] = a4;
        v13[2] = v18;
        *v13 = a3;
        Object = objc_GetObject(*(_QWORD *)(v45 + 48), (uint64_t)"SYNTHSTREAM", &v44);
        if ((Object & 0x80000000) != 0)
        {
          v26 = Object;
          log_OutPublic(*(_QWORD *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6002, 0, v21, v22, v23, v24, v42);
        }
        else
        {
          v19[8] = *(_QWORD *)(v44 + 8);
          if ((objc_GetObject(*(_QWORD *)(v45 + 48), (uint64_t)"COMPQUERY", &v44) & 0x80000000) != 0)
          {
            v19[7] = 0;
            v19[5] = safeh_GetNullHandle();
            v19[6] = v31;
          }
          else
          {
            v25 = v44;
            v19[7] = *(_QWORD *)(v44 + 8);
            *(_OWORD *)(v19 + 5) = *(_OWORD *)(v25 + 16);
          }
          UInt = paramc_ParamGetUInt(*(_QWORD *)(v45 + 40), (uint64_t)"ppmaxpcreframeblocks", (unsigned int *)&v43);
          v33 = v43;
          v34 = paramc_ParamGetUInt(*(_QWORD *)(v45 + 40), (uint64_t)"ppnumframesinblock", (unsigned int *)&v43);
          v35 = v43;
          v19[3] = 0;
          *((_DWORD *)v19 + 8) = 0;
          v36 = nuance_pcre_ObjOpen(a3, a4, (uint64_t)(v19 + 3));
          if ((v36 & 0x80000000) != 0)
          {
            v26 = v36;
          }
          else
          {
            if (v34 < 0)
              v37 = 50;
            else
              v37 = v35;
            if (UInt < 0)
              v38 = 50;
            else
              v38 = v33;
            v26 = nuance_pcre_Init((_QWORD *)v19[3], v19[4], v38, v37);
            if ((v26 & 0x80000000) == 0)
            {
              v39 = 865;
LABEL_22:
              *(_QWORD *)a5 = v19;
              *(_DWORD *)(a5 + 8) = v39;
              log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Leaving ngwcmp_ObjOpen: %x", v28, v29, v30, v26);
              return 0;
            }
          }
        }
        log_OutPublic(*(_QWORD *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6001, "%s%x", v27, v28, v29, v30, "lhError");
        *(_QWORD *)a5 = v19;
        *(_DWORD *)(a5 + 8) = 865;
        vscmp_ObjClose(v19, *(_QWORD *)(a5 + 8));
        v19 = 0;
        v39 = 0;
        goto LABEL_22;
      }
      log_OutPublic(*(_QWORD *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6000, 0, v14, v15, v16, v17, v42);
      return 2600476682;
    }
  }
  return v5;
}

uint64_t vscmp_ObjClose(_QWORD *a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t NullHandle;
  int v10;
  int v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 865, 928);
  if (v3 < 0)
    return 2600476680;
  LODWORD(v7) = v3;
  v8 = a1[2];
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Entering vscmp_ObjClose", v4, v5, v6, v18);
  NullHandle = safeh_GetNullHandle();
  if (!safeh_HandlesEqual(a1[3], a1[4], NullHandle, v10))
  {
    v11 = nuance_pcre_DeInit((_QWORD *)a1[3], a1[4]);
    if ((v11 & 0x80000000) == 0)
      v11 = nuance_pcre_ObjClose(a1[3], a1[4]);
    LODWORD(v7) = v11;
  }
  if (a1[7])
    objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"COMPQUERY");
  v12 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
  if (v12 >= 0 || (int)v7 <= -1)
    v7 = v7;
  else
    v7 = v12;
  heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Leaving vscmp_ObjClose: %x", v14, v15, v16, v7);
  return v7;
}

uint64_t vscmp_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;

  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0)
    return 2600476680;
  synstrmaux_InitStreamOpener(a1 + 72, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"VOICESWITCHCMP");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"text/plain;charset=utf-8", 0, a1 + 896);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"text/plain;charset=utf-8", a1 + 912);
  v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 72), *(_QWORD *)(a1 + 64), a3, a4);
  if ((v8 & 0x80000000) != 0)
    vscmp_ProcessEnd(a1, a2);
  return v8;
}

uint64_t vscmp_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7;
  uint64_t *v8;
  char *v9;
  const char *v10;
  char *v11;
  int v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  __int128 v20;
  signed int v21;
  signed int v22;
  char *v23;
  _BOOL4 v24;
  signed int v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  const char *v36;
  char *v38;
  char *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  size_t v44;
  unsigned __int8 *v45;
  uint64_t best_matching_voice;
  int v47;
  unint64_t v48;
  uint64_t v49;
  const char *v50;
  _BOOL4 v51;
  signed int v52;
  unsigned int v53;
  int v54;
  uint64_t *v55;
  int v56;
  char *v57;
  void *__dst;
  char __src[2];
  char *v60;
  size_t __n;
  char __s[512];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _QWORD __s2[4];

  __s2[1] = *MEMORY[0x1E0C80C00];
  v60 = 0;
  __n = 0;
  v7 = 2600476682;
  strcpy(__src, "\x1B");
  __s2[0] = 0x5C313D736F655CLL;
  v57 = 0;
  __dst = 0;
  *a5 = 1;
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0)
    return 2600476680;
  if (!*(_QWORD *)(a1 + 896) || !*(_QWORD *)(a1 + 912))
  {
    v7 = 0;
    *a5 = 1;
    return v7;
  }
  v8 = *(uint64_t **)(a1 + 16);
  v9 = (char *)heap_Alloc(v8[1], 2);
  if (v9)
  {
    v10 = v9;
    v11 = strcpy(v9, __src);
    v12 = strlen(v11);
    v13 = (char *)heap_Alloc(v8[1], (v12 + 8));
    if (!v13)
    {
      heap_Free((_QWORD *)v8[1], (uint64_t)v10);
      return v7;
    }
    v14 = (uint64_t)v13;
    v15 = strcpy(v13, v10);
    strcat(v15, (const char *)__s2);
    v16 = (*(uint64_t (**)(_QWORD, _QWORD, char *, size_t *))(*(_QWORD *)(a1 + 64) + 144))(*(_QWORD *)(a1 + 896), *(_QWORD *)(a1 + 904), (char *)&__n + 4, &__n);
    if ((v16 & 0x80000000) == 0)
    {
      if (HIDWORD(__n))
      {
        v16 = (*(uint64_t (**)(_QWORD, _QWORD, char **, char *))(*(_QWORD *)(a1 + 64) + 88))(*(_QWORD *)(a1 + 896), *(_QWORD *)(a1 + 904), &v60, (char *)&__n + 4);
        if ((v16 & 0x80000000) == 0)
        {
          v17 = (char *)heap_Calloc((_QWORD *)v8[1], 1, (HIDWORD(__n) + 1));
          v18 = v17;
          if (!v17)
          {
            v36 = 0;
            v16 = 2600476682;
            goto LABEL_30;
          }
          strncpy(v17, v60, HIDWORD(__n));
          v18[HIDWORD(__n)] = 0;
          if (!HIDWORD(__n))
          {
            v36 = 0;
            goto LABEL_73;
          }
          v53 = HIDWORD(__n);
          v56 = 0;
          v55 = 0;
          v16 = paramc_ParamGet(v8[5], (uint64_t)"fullescvoiceseqdata", &v55, &v56);
          if ((v16 & 0x80000000) == 0)
          {
            v19 = *v55;
            *(_QWORD *)&v20 = -1;
            *((_QWORD *)&v20 + 1) = -1;
            v63 = v20;
            v64 = v20;
            v65 = v20;
            v66 = v20;
            v67 = v20;
            v68 = v20;
            v69 = v20;
            v70 = v20;
            v71 = v20;
            v72 = v20;
            v73 = v20;
            v74 = v20;
            v75 = v20;
            v76 = v20;
            v77 = v20;
            v78 = v20;
            v79 = v20;
            v80 = v20;
            v81 = v20;
            v82 = v20;
            v83 = v20;
            v84 = v20;
            v85 = v20;
            v86 = v20;
            v87 = v20;
            v21 = nuance_pcre_exec(*(_QWORD **)(a1 + 24), *(_QWORD *)(a1 + 32), v19, 0, v18, SHIDWORD(__n), 0, 0xA000u, &v63, 100);
            v22 = v21;
            v23 = &v18[(int)v63];
            if (v21 < 0)
              v23 = 0;
            if ((_DWORD)v63)
              v24 = 1;
            else
              v24 = v21 < 0;
            if (v21 < 0)
            {
              v25 = v21;
              v26 = v23;
              v51 = v24;
              v27 = nuance_pcre_ErrorToLhError(v21);
              v24 = v51;
              v23 = v26;
              v22 = v25;
              v16 = v27;
              if (v27 >> 20 == 2213)
              {
                v16 = 0;
                v32 = v27 & 0x1FFF;
                if (v32 != 7778 && v32 != 20)
                {
                  if (v32 == 10)
                  {
                    v33 = v8[4];
                    v34 = 11002;
                    v35 = 0;
                  }
                  else
                  {
                    v50 = "lhError";
                    v35 = "%s%x";
                    v33 = v8[4];
                    v34 = 11027;
                  }
                  log_OutPublic(v33, (uint64_t)"VOICESWITCHCMP", v34, v35, v28, v29, v30, v31, v50);
                  v16 = 0;
                  v22 = v25;
                  v23 = v26;
                  v24 = v51;
                }
              }
            }
            v36 = 0;
            v38 = &v18[SDWORD2(v64)];
            if (v23)
            {
              v39 = &v18[SHIDWORD(v64)];
            }
            else
            {
              v38 = 0;
              v39 = 0;
            }
            if (!v23 || !v39 || !v38 || v39 == v38)
              goto LABEL_63;
            if (v24)
            {
              v36 = 0;
              v40 = ((_DWORD)v23 - (_DWORD)v18);
              HIDWORD(__n) = (_DWORD)v23 - (_DWORD)v18;
              goto LABEL_64;
            }
            v41 = v38;
            v52 = v22;
            v54 = 0;
            HIDWORD(__n) = (_DWORD)v39 - (_DWORD)v18 + 1;
            v42 = (char *)heap_Alloc(v8[1], HIDWORD(__n));
            v36 = v42;
            if (v42)
            {
              v43 = v41;
              v44 = ((_DWORD)v39 - (_DWORD)v41);
              memcpy(v42, v43, v44);
              v36[v44] = 0;
              v45 = vs_trim_voice(v36);
              if (!strcmp((const char *)v45, "(pop)") || !strcmp((const char *)v45, "(push)"))
              {
                __strcpy_chk();
                memset(v18, 32, HIDWORD(__n));
                goto LABEL_61;
              }
              best_matching_voice = vs_find_best_matching_voice((_QWORD *)a1, (char *)v45, __s, &v54);
              if ((best_matching_voice & 0x80000000) == 0)
              {
                v47 = v54;
                memset(v18, 32, HIDWORD(__n));
                if (v47)
                {
                  v48 = strlen(__s);
                  if (v48 < HIDWORD(__n))
                    memcpy(v18, __s, v48);
                  v16 = 0;
                  if ((paramc_ParamGetStr(v8[5], (uint64_t)"voice", &v57) & 0x80000000) == 0 && v57)
                  {
                    paramc_ParamSetStr(v8[5], (uint64_t)"pipelineswitchvoice", v57);
                    v16 = paramc_ParamSetStr(v8[5], (uint64_t)"vsvoicetagwithlangunknow", __s);
                  }
                  goto LABEL_62;
                }
LABEL_61:
                paramc_ParamSetStr(v8[5], (uint64_t)"pipelineswitchvoice", __s);
                v16 = paramc_ParamRemove(v8[5], (uint64_t)"vsvoicetagwithlangunknow");
                *a5 = 3;
LABEL_62:
                v22 = v52;
LABEL_63:
                v40 = HIDWORD(__n);
LABEL_64:
                if ((_DWORD)v40)
                {
                  if (v22 != -12 || (_DWORD)__n)
                  {
                    v49 = (*(uint64_t (**)(_QWORD, _QWORD, void **, uint64_t))(*(_QWORD *)(a1 + 64) + 112))(*(_QWORD *)(a1 + 912), *(_QWORD *)(a1 + 920), &__dst, v40);
                    if ((v49 & 0x80000000) != 0
                      || (memcpy(__dst, v18, v40),
                          v49 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 64) + 120))(*(_QWORD *)(a1 + 912), *(_QWORD *)(a1 + 920), v40), (v49 & 0x80000000) != 0))
                    {
                      v16 = v49;
                    }
                    else
                    {
                      v16 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 64) + 96))(*(_QWORD *)(a1 + 896), *(_QWORD *)(a1 + 904), v40);
                      if ((v16 & 0x80000000) == 0 && HIDWORD(__n) < v53 && *a5 != 3)
                        *a5 = 2;
                    }
                    goto LABEL_30;
                  }
                  goto LABEL_74;
                }
LABEL_73:
                if (!(_DWORD)__n)
                  goto LABEL_74;
LABEL_30:
                heap_Free((_QWORD *)v8[1], v14);
                heap_Free((_QWORD *)v8[1], (uint64_t)v10);
                if (v18)
                  heap_Free((_QWORD *)v8[1], (uint64_t)v18);
                if (v36)
                  heap_Free((_QWORD *)v8[1], (uint64_t)v36);
                return v16;
              }
              v7 = best_matching_voice;
            }
            v16 = v7;
            goto LABEL_30;
          }
LABEL_29:
          v36 = 0;
          goto LABEL_30;
        }
      }
      else
      {
        if (!(_DWORD)__n)
        {
          v18 = 0;
          v36 = 0;
LABEL_74:
          *a5 = 0;
          goto LABEL_30;
        }
        v16 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
      }
    }
    v18 = 0;
    goto LABEL_29;
  }
  return v7;
}

uint64_t vscmp_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0)
    return 2600476680;
  else
    return synstrmaux_CloseStreams((_WORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
}

unsigned __int8 *vs_trim_voice(const char *a1)
{
  const char *v1;
  unsigned int v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v10;

  v1 = a1;
  v2 = strlen(a1);
  v3 = (unsigned __int8 *)&v1[v2];
  v4 = v2;
  v5 = MEMORY[0x1E0C80978];
  while (1)
  {
    v7 = *--v3;
    v6 = v7;
    v8 = (1 << v7) & 0x100002600;
    if (v7 > 0x20 || v8 == 0)
    {
      if (v6 < 0)
      {
        if (!__maskrune(v6, 0x200uLL))
          goto LABEL_12;
        goto LABEL_6;
      }
      if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x200) == 0)
        break;
    }
LABEL_6:
    *v3 = 0;
    if (v4 == 1)
      return v3;
  }
  while (1)
  {
LABEL_12:
    v10 = *(unsigned __int8 *)v1;
    if (v10 <= 0x20 && ((1 << v10) & 0x100002600) != 0)
      goto LABEL_16;
    if ((char)v10 < 0)
      break;
    if ((*(_DWORD *)(v5 + 4 * (char)v10 + 60) & 0x200) == 0)
      return (unsigned __int8 *)v1;
LABEL_16:
    ++v1;
  }
  if (__maskrune((char)v10, 0x200uLL))
    goto LABEL_16;
  return (unsigned __int8 *)v1;
}

uint64_t vs_find_best_matching_voice(_QWORD *a1, char *__s, char *a3, _DWORD *a4)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v11;
  _OWORD v12[4];
  _OWORD v13[15];
  __int128 v14;
  __int128 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = 2600476681;
  v11 = 0;
  if (!a3)
    return 2600476679;
  *a3 = 0;
  if (__s)
  {
    if (strchr(__s, 58))
    {
      v4 = 0;
      if ((paramc_ParamGetStr(*(_QWORD *)(a1[2] + 40), (uint64_t)"voice", &v11) & 0x80000000) == 0 && v11)
      {
        v16 = 0;
        v14 = 0u;
        v15 = 0u;
        memset(v13, 0, sizeof(v13));
        memset(v12, 0, sizeof(v12));
        VoiceParamExtract_0(__s, "lang", (char *)v13);
        VoiceParamExtract_0(__s, "gender", (char *)&v13[6] + 8);
        VoiceParamExtract_0(__s, "ietf", (char *)v13 + 8);
        VoiceParamExtract_0(__s, "age", (char *)&v14 + 4);
        VoiceParamExtract_0(__s, "model", (char *)&v13[7] + 12);
        if (*(_QWORD *)&v13[0] == 0x6E776F6E6B6E75)
        {
          if (a4)
            *a4 = 1;
          if (strlen(__s) + 5 <= 0x1FF)
          {
            *(_QWORD *)a3 = 0x3D676E616C5C1BLL;
            *(_QWORD *)&a3[strlen(a3)] = 0x6E6B6E75656376;
            if (BYTE8(v13[6]))
            {
              strcat(a3, ",gender:");
              strcat(a3, (const char *)&v13[6] + 8);
            }
            if (BYTE4(v14))
            {
              strcat(a3, ",age:");
              strcat(a3, (const char *)&v14 + 4);
            }
            if (BYTE12(v13[7]))
            {
              *(_QWORD *)&a3[strlen(a3)] = 0x3A6C65646F6D2CLL;
              strcat(a3, (const char *)&v13[7] + 12);
            }
            *(_WORD *)&a3[strlen(a3)] = 92;
          }
        }
        else
        {
          for (i = -1;
                (((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _OWORD *, char *, uint64_t))(a1[7] + 136))(a1[5], a1[6], *(_QWORD *)(a1[2] + 24), *(_QWORD *)(a1[2] + 40), v12, a3, 512) & 0x80000000) != 0|| !*a3)&& i;
                ++i)
          {
            if (strlen((const char *)v13) == 3)
            {
              __strcpy_chk();
              BYTE2(v15) = 120;
              LOBYTE(v13[0]) = 0;
            }
          }
        }
        return 0;
      }
    }
    else if (strlen(__s) <= 0x1FF)
    {
      strcpy(a3, __s);
      return 0;
    }
  }
  return v4;
}

size_t VoiceParamExtract_0(const char *a1, const char *a2, char *a3)
{
  size_t result;
  char *v6;
  char *v7;
  char *v8;
  size_t v9;
  const char *v10;
  int v11;
  uint64_t v12;
  _BYTE v13[512];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  result = strlen(a1);
  if (result <= 0x1FF)
  {
    __strcpy_chk();
    result = (size_t)strhelper_SafeStrtok((uint64_t)v13, "{}();,", &v12);
    if (result)
    {
      v6 = (char *)result;
      while (1)
      {
        v7 = strchr(v6, 58);
        if (v7)
        {
          v8 = v7;
          v9 = strlen(a2);
          result = strncmp(v6, a2, v9);
          if (!(_DWORD)result)
            break;
        }
        result = (size_t)strhelper_SafeStrtok((uint64_t)v13, "{}();,", &v12);
        v6 = (char *)result;
        if (!result)
          return result;
      }
      v11 = v8[1];
      v10 = v8 + 1;
      if (v11)
        return (size_t)strcpy(a3, v10);
    }
  }
  return result;
}

uint64_t UnloadTuningResources(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  _QWORD *v4;
  uint64_t v5;

  v2 = a1[1797];
  if (v2)
  {
    result = 0;
    v4 = &a1[2 * v2 + 1668];
    while (1)
    {
      v5 = *(v4 - 1);
      if (v5)
      {
        result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(a1[1668] + 80))(a1[1666], a1[1667], v5, *v4);
        if ((result & 0x80000000) != 0)
          break;
      }
      v4 -= 2;
      if (!--v2)
        goto LABEL_8;
    }
  }
  else
  {
    result = 0;
LABEL_8:
    a1[1797] = 0;
  }
  return result;
}

uint64_t ELQSSMLStartParsing(uint64_t a1, unsigned __int16 *a2, unint64_t a3, int a4, int a5)
{
  uint64_t result;
  const char *Name;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  char v24[512];
  _OWORD v25[32];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni)
    return 2375032834;
  memset(v25, 0, sizeof(v25));
  ELQSSMLReset(a1);
  if (a5)
  {
    LOBYTE(v25[0]) = 0;
  }
  else
  {
    result = ELQXMLGetEncodingFromHeader(*(_QWORD *)(a1 + 2624), v25, a2, a3, a4);
    if ((_DWORD)result)
      return result;
    if (LOBYTE(v25[0]))
      goto LABEL_11;
  }
  Name = TxtEncodingGetName(a4);
  if (!Name || !*Name)
  {
    __sprintf_chk(v24, 0, 0x200uLL, "Invalid or unsupported TextEncoding in parsing XML file");
LABEL_13:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v12, v13, v14, v15, "SSML parser error");
    return 2375032839;
  }
  __strcpy_chk();
LABEL_11:
  if (ELQXMLSetEncoding(*(_QWORD *)(a1 + 2624)))
  {
    __sprintf_chk(v24, 0, 0x200uLL, "Unknown XML encoding \"%s\"");
    goto LABEL_13;
  }
  result = ELQXMLSetCallbacks(*(_QWORD *)(a1 + 2624));
  if (!(_DWORD)result)
  {
    result = ELQXMLSetNamespaceCallbacks(*(_QWORD *)(a1 + 2624));
    if (!(_DWORD)result)
    {
      result = SetInitialVoiceAndLanguage(a1);
      if (!(_DWORD)result)
      {
        *(_QWORD *)a1 = 0;
        v16 = *(_QWORD *)(a1 + 13264);
        v19 = *(_QWORD *)(v16 + 8);
        v18 = (_QWORD *)(v16 + 8);
        v17 = v19;
        if (v19)
          heap_Free(***(_QWORD ****)(a1 + 13264), v17);
        *v18 = 0;
        v18[1] = 0;
        v20 = *(_QWORD *)(a1 + 13272);
        v23 = *(_QWORD *)(v20 + 8);
        v22 = (_QWORD *)(v20 + 8);
        v21 = v23;
        if (v23)
          heap_Free(***(_QWORD ****)(a1 + 13272), v21);
        result = 0;
        *v22 = 0;
        v22[1] = 0;
        *(_DWORD *)(a1 + 2084) = 0;
        *(_QWORD *)(a1 + 2096) = 0;
        *(_BYTE *)(a1 + 2104) = 0;
      }
    }
  }
  return result;
}

uint64_t ELQSSMLIni(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  size_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  char v52[512];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v8 = ELQXMLGetControllerFromParser(a3);
  v51 = 0;
  v9 = heap_Alloc(*(_QWORD *)(a1 + 8), 14408);
  if (!v9)
  {
    v21 = 2375032842;
LABEL_10:
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v10, v11, v12, v13, "SSML parser error");
    return v21;
  }
  v14 = v9;
  *(_QWORD *)(v9 + 1552) = ELQSSMLDelete;
  *(_QWORD *)(v9 + 13320) = 0;
  *(_QWORD *)(v9 + 12992) = a1;
  v15 = (_BYTE *)(v9 + 12968);
  *(_DWORD *)(v9 + 2084) = 0;
  *(_QWORD *)(v9 + 2096) = 0;
  *(_BYTE *)(v9 + 2104) = 0;
  *(_OWORD *)(v9 + 2640) = 0u;
  *(_OWORD *)(v9 + 2656) = 0u;
  *(_QWORD *)(v9 + 2624) = a3;
  *(_DWORD *)(v9 + 8) = 3;
  *(_BYTE *)(v9 + 13196) = 0;
  *(_BYTE *)(v9 + 13228) = 0;
  *(_BYTE *)(v9 + 13128) = 0;
  *(_BYTE *)(v9 + 13000) = 0;
  strcpy((char *)(v9 + 13164), "normal");
  *(_DWORD *)(v9 + 2616) = 0;
  *(_BYTE *)(v9 + 13280) = 0;
  *(_DWORD *)(v9 + 13312) = 0;
  *(_DWORD *)(v9 + 1568) = 100;
  *(_QWORD *)(v9 + 1560) = 0x6400000050;
  *(_QWORD *)(v9 + 1572) = 0x746C7561666564;
  *(_DWORD *)(v9 + 2088) = 100;
  v16 = (_QWORD *)heap_Alloc(*(_QWORD *)(a1 + 8), 24);
  if (!v16)
  {
    v21 = 2375032842;
    *(_QWORD *)(v14 + 13264) = 0;
LABEL_9:
    heap_Free(*(_QWORD **)(a1 + 8), v14);
    goto LABEL_10;
  }
  v16[1] = 0;
  v16[2] = 0;
  *v16 = a1 + 8;
  *(_QWORD *)(v14 + 13264) = v16;
  v17 = *(_QWORD *)(v14 + 12992);
  v19 = *(_QWORD *)(v17 + 8);
  v18 = v17 + 8;
  v20 = (_QWORD *)heap_Alloc(v19, 24);
  if (!v20)
  {
    v21 = 2375032842;
    *(_QWORD *)(v14 + 13272) = 0;
    DynStringDestroy(*(_QWORD ****)(v14 + 13264));
    goto LABEL_9;
  }
  v20[1] = 0;
  v20[2] = 0;
  *v20 = v18;
  *(_QWORD *)(v14 + 13272) = v20;
  *(_QWORD *)(v14 + 2632) = a4;
  *(_QWORD *)(v14 + 2704) = 0;
  *(_QWORD *)(v14 + 12984) = 0;
  *(_QWORD *)(v14 + 2672) = 0;
  *(_QWORD *)(v14 + 2688) = 0;
  *(_QWORD *)(v14 + 2680) = 0;
  *(_DWORD *)(v14 + 2716) = 4;
  *(_QWORD *)(v14 + 2720) = 0;
  if (v8)
    ELQXMLGetNamespaceSeparator(v8, v15);
  else
    *v15 = 0;
  *(_QWORD *)(v14 + 16) = 0;
  *(_QWORD *)(v14 + 24) = 0;
  v22 = (_BYTE *)(v14 + 2728);
  v23 = 10;
  do
  {
    *v22 = 0;
    v22[512] = 0;
    v22 += 1024;
    --v23;
  }
  while (v23);
  v24 = 0;
  *(_QWORD *)(v14 + 2720) = 0;
  *(_QWORD *)(v14 + 1552) = ELQSSMLIni;
  v25 = "auxiliary";
  while (1)
  {
    if (*(_QWORD *)(v14 + 16))
    {
      v26 = 0;
      v27 = 1;
      while (LH_stricmp(*(char **)(v14 + 24 * v26 + 24), v25))
      {
        v26 = v27;
        v28 = v14 + 24 * v27;
        v30 = *(_QWORD *)(v28 + 16);
        v29 = (_QWORD *)(v28 + 16);
        ++v27;
        if (!v30)
          goto LABEL_21;
      }
      v21 = 2375032839;
      goto LABEL_29;
    }
    LODWORD(v26) = 0;
    v27 = 1;
    v29 = (_QWORD *)(v14 + 16);
LABEL_21:
    v31 = strlen(v25);
    v32 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(v14 + 12992) + 8), v31 + 1);
    *(_QWORD *)(v14 + 24 * v26 + 24) = v32;
    if (v32)
    {
      strcpy(v32, v25);
      v21 = tinystack_Ini(*(_QWORD *)(v14 + 12992), 40, v29);
      v33 = v14 + 24 * v27;
      *(_QWORD *)(v33 + 16) = 0;
      *(_QWORD *)(v33 + 24) = 0;
    }
    else
    {
      *(_DWORD *)(v14 + 2084) = -1919934454;
      strcpy((char *)(v14 + 2104), "Out of Memory");
      ELQXMLGetCurrentLineNumber(*(_QWORD *)(v14 + 2624));
      v21 = *(unsigned int *)(v14 + 2084);
    }
    if ((_DWORD)v21)
      goto LABEL_29;
    if (++v24 == 19)
      break;
    v25 = ELQSSMLIni_StacksName[v24];
    if (*(uint64_t (**)())(v14 + 1552) != ELQSSMLIni)
    {
      v21 = 2375032834;
LABEL_29:
      __sprintf_chk(v52, 0, 0x200uLL, "Unable to handle XML attribute \"%s\". Out of memory.\n", v25);
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, "%s%s", v34, v35, v36, v37, "SSML parser error");
      ELQSSMLDelete((_QWORD *)v14);
      return v21;
    }
  }
  if (ELQXMLSetUnknownEncodingHandler(*(_QWORD *)(v14 + 2624)))
  {
    __sprintf_chk(v52, 0, 0x200uLL, "Unable to set unknown encoding handler");
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, "%s%s", v39, v40, v41, v42, "SSML parser error");
    ELQSSMLDelete((_QWORD *)v14);
    return 2375032839;
  }
  else
  {
    *(_QWORD *)(v14 + 13344) = 0;
    *(_QWORD *)(v14 + 13328) = safeh_GetNullHandle();
    *(_QWORD *)(v14 + 13336) = v43;
    if ((objc_GetObject(*(_QWORD *)(*(_QWORD *)(v14 + 12992) + 48), (uint64_t)"TTSEG", &v51) & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, 0, v44, v45, v46, v47, v50);
    }
    else
    {
      v48 = v51;
      *(_OWORD *)(v14 + 13328) = *(_OWORD *)(v51 + 16);
      *(_QWORD *)(v14 + 13344) = *(_QWORD *)(v48 + 8);
    }
    *(_QWORD *)(v14 + 13352) = safeh_GetNullHandle();
    *(_QWORD *)(v14 + 13360) = v49;
    *(_QWORD *)(v14 + 14376) = 0;
    *(_QWORD *)(v14 + 1552) = ELQSSMLIni;
    v21 = 0;
    if (a2)
      *a2 = v14;
  }
  return v21;
}

uint64_t ELQSSMLReset(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  _BYTE *v13;
  unsigned int v14;

  if (result)
  {
    v1 = result;
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(result + 1552) == ELQSSMLIni)
    {
      v2 = *(_QWORD *)(result + 13264);
      v5 = *(_QWORD *)(v2 + 8);
      v4 = (_QWORD *)(v2 + 8);
      v3 = v5;
      if (v5)
        heap_Free(***(_QWORD ****)(result + 13264), v3);
      *v4 = 0;
      v4[1] = 0;
      v6 = *(_QWORD *)(v1 + 13272);
      v9 = *(_QWORD *)(v6 + 8);
      v8 = (_QWORD *)(v6 + 8);
      v7 = v9;
      if (v9)
        heap_Free(***(_QWORD ****)(v1 + 13272), v7);
      *v8 = 0;
      v8[1] = 0;
      ELQXMLReset(*(_QWORD *)(v1 + 2624));
      v10 = *(_QWORD *)(v1 + 16);
      if (v10)
      {
        v11 = 1;
        do
        {
          tinystack_Reset(v10);
          v10 = *(_QWORD *)(v1 + 24 * v11++ + 16);
        }
        while (v10);
      }
      v12 = *(_QWORD *)(v1 + 2720);
      if (v12)
      {
        v13 = (_BYTE *)(v1 + 2728);
        v14 = 1;
        do
        {
          *v13 = 0;
          v13[512] = 0;
          v13 += 1024;
        }
        while (v12 > v14++);
      }
      *(_QWORD *)(v1 + 2720) = 0;
      hashtable_ObjClose(*(_QWORD **)(v1 + 12984));
      *(_QWORD *)(v1 + 12984) = 0;
      *(_DWORD *)(v1 + 1568) = 100;
      *(_QWORD *)(v1 + 1560) = 0x6400000050;
      *(_DWORD *)(v1 + 2088) = 100;
      return ELQMemorySlotReset(*(_QWORD *)(v1 + 2672));
    }
  }
  return result;
}

uint64_t SSMLstartElement(uint64_t result, char *__s, uint64_t *a3)
{
  uint64_t v5;
  unsigned int v6;
  const char *v7;
  int v8;

  if (*(_DWORD *)(result + 2084))
    return result;
  v5 = result;
  if (!*(_QWORD *)result)
  {
    *(_DWORD *)(result + 8) = 3;
    if (SSMLstricmpElement(result, __s, "speak"))
    {
      result = LH_stricmp(__s, "text");
      if ((_DWORD)result)
      {
        *(_DWORD *)(v5 + 2084) = -1919926671;
        strcpy((char *)(v5 + 2104), "Fatal syntax error");
        result = ELQXMLGetCurrentLineNumber(*(_QWORD *)(v5 + 2624));
        goto LABEL_17;
      }
      v8 = 2;
    }
    else
    {
      result = *a3;
      if (*a3)
      {
        v6 = 1;
        do
        {
          if (!LH_stricmp((char *)result, "version"))
          {
            v7 = (const char *)a3[v6];
            if (v7)
            {
              if (!strcmp(v7, "1.0"))
                *(_DWORD *)(v5 + 8) = 0;
            }
          }
          result = a3[v6 + 1];
          v6 += 2;
        }
        while (result);
      }
      v8 = 1;
    }
    *(_DWORD *)(v5 + 8) = v8;
  }
LABEL_17:
  if (*(_DWORD *)(v5 + 8) <= 1u)
  {
    result = (uint64_t)SSML10StartConvert(v5, __s, (uint64_t)a3);
    *(_DWORD *)(v5 + 2084) = result;
  }
  ++*(_QWORD *)v5;
  return result;
}

uint64_t SSMLendElement(uint64_t result, char *a2)
{
  uint64_t v2;

  if (!*(_DWORD *)(result + 2084))
  {
    v2 = result;
    if (*(_DWORD *)(result + 8) <= 1u)
    {
      result = SSML10EndConvert(result, a2);
      *(_DWORD *)(v2 + 2084) = result;
    }
    --*(_QWORD *)v2;
  }
  return result;
}

char *SSMLCharacterDataHandlerStandard(char *result, char *a2, int a3)
{
  uint64_t v3;
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  char *v23;
  _BOOL4 v24;
  char *v25;
  unint64_t v26;
  int v27;
  int v28;
  int v29;
  void (*v30)(char *, uint64_t);
  uint64_t v31;
  char *v32;
  void (*v33)(const char *, _QWORD);
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char v41;
  char v42[32];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v35 = *((_DWORD *)result + 679);
  if (!a3)
    return result;
  v3 = (uint64_t)result;
  if (*((_DWORD *)result + 521))
    return result;
  v5 = a3;
  v6 = (char *)ELQMemorySlotReserve(*((_QWORD *(***)(uint64_t, uint64_t, int))result + 334), a3 + 1);
  if (!v6)
  {
    *(_DWORD *)(v3 + 2084) = -1919934454;
    strcpy((char *)(v3 + 2104), "Out of Memory");
    return (char *)ELQXMLGetCurrentLineNumber(*(_QWORD *)(v3 + 2624));
  }
  v7 = v6;
  v34 = 0;
  v8 = XMLGetStack(v3, "auxiliary");
  if (!v8)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(v3 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(v3 + 2084) = -1919934462;
    strcpy((char *)(v3 + 2104), "SSML Stack unavailable");
    return (char *)ELQXMLGetCurrentLineNumber(*(_QWORD *)(v3 + 2624));
  }
  v13 = v8;
  v36 = 0;
  SSMLViewOnLangFailureFromStack(v3, &v35);
  v14 = v35;
  if (v35 == 4)
    v14 = *(_DWORD *)(v3 + 2716);
  result = (char *)tinystack_View(v13, &v34);
  if ((v34 & 8) != 0)
    return SSMLFallbackStringHandler((char *)v3, a2, v5);
  if ((v34 & 0x10) != 0)
    return result;
  if ((v34 & 0x4000) == 0)
  {
    if (v14 == 1)
      return result;
    goto LABEL_17;
  }
  v15 = XMLGetStack(v3, "audio");
  tinystack_View(v15, &v36);
  if (v36 == 1)
    return SSMLFallbackStringHandler((char *)v3, a2, v5);
LABEL_17:
  strncpy(v7, a2, v5);
  v7[v5] = 0;
  if (*(_DWORD *)(v3 + 13312))
  {
    v16 = *v7;
    if (*v7)
    {
      v17 = 0;
      v18 = v7;
      do
      {
        if (v16 == 44)
        {
          if (v17)
          {
            if (v7[v17 - 1] - 48 <= 9)
            {
              v19 = 1;
              do
                v20 = v18[v19++] - 48;
              while (v20 < 0xA);
              v21 = v19 - 2;
              if (v21)
              {
                if (v21 != 3)
                  *v18 = 46;
              }
            }
          }
        }
        ++v17;
        v22 = *++v18;
        v16 = v22;
      }
      while (v22);
    }
  }
  v23 = (char *)(v3 + 13280);
  if (!*(_BYTE *)(v3 + 13280))
    return (char *)(*(uint64_t (**)(char *, _QWORD))(v3 + 2640))(v7, *(_QWORD *)(v3 + 2648));
  v37 = 0;
  v24 = *(_BYTE *)(v3 + 13128) != 101 || *(_BYTE *)(v3 + 13129) != 110 || *(unsigned __int8 *)(v3 + 13130) != 117;
  result = strhelper_SafeStrtok((uint64_t)v7, " \t\n", &v37);
  if (result)
  {
    v25 = result;
    do
    {
      v41 = 0;
      v42[0] = 0;
      if (strlen(v25) > 0xC)
        goto LABEL_54;
      v39 = 0;
      v40 = 0;
      v38 = 0;
      if (!ExtractDate(v23, v25, &v40, &v39, &v38, 0, &v41, 0))
        goto LABEL_54;
      v26 = v41 == 47 ? 0 : 80;
      if (!ExtractDate(v23, v25, &v40, &v39, &v38, 1, &v41, v26))
        goto LABEL_54;
      v27 = v40;
      if (v40 && v39)
      {
        if (v24)
          v28 = v40;
        else
          v28 = v39;
        if (v24)
          v27 = v39;
        v29 = __sprintf_chk(v42, 0, 0x20uLL, "%d/%d", v28, v27);
        if (v38)
          sprintf(&v42[v29], "/%d", v38);
      }
      if (v42[0])
      {
        v30 = *(void (**)(char *, uint64_t))(v3 + 2640);
        if (v30)
        {
          v31 = *(_QWORD *)(v3 + 2648);
          v32 = v42;
          goto LABEL_56;
        }
      }
      else
      {
LABEL_54:
        v30 = *(void (**)(char *, uint64_t))(v3 + 2640);
        if (v30)
        {
          v31 = *(_QWORD *)(v3 + 2648);
          v32 = v25;
LABEL_56:
          v30(v32, v31);
          v33 = *(void (**)(const char *, _QWORD))(v3 + 2640);
          if (v33)
            v33(" ", *(_QWORD *)(v3 + 2648));
        }
      }
      result = strhelper_SafeStrtok((uint64_t)v7, " \t\n", &v37);
      v25 = result;
    }
    while (result);
  }
  return result;
}

uint64_t SSMLStartNamespace(uint64_t result, uint64_t a2, char *__src)
{
  uint64_t v3;
  unint64_t v4;

  if (a2 | (unint64_t)__src)
  {
    v3 = result;
    v4 = *(_QWORD *)(result + 2720);
    if (v4 <= 9)
    {
      if (a2)
      {
        result = __strcpy_chk();
        v4 = *(_QWORD *)(v3 + 2720);
      }
      if (__src)
      {
        result = (uint64_t)strcpy((char *)(v3 + (v4 << 10) + 3240), __src);
        v4 = *(_QWORD *)(v3 + 2720);
      }
      *(_QWORD *)(v3 + 2720) = v4 + 1;
    }
  }
  return result;
}

uint64_t SSMLEndNamespace(uint64_t result, char *__s2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (__s2)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 2720);
    if (v3)
    {
      v5 = 0;
      v6 = result + 2728;
      v7 = *(_QWORD *)(result + 2720);
      do
      {
        result = strcmp((const char *)v6, __s2);
        if (!(_DWORD)result)
        {
          *(_BYTE *)v6 = 0;
          *(_BYTE *)(v6 + 512) = 0;
          ++v5;
        }
        v6 += 1024;
        --v7;
      }
      while (v7);
    }
    else
    {
      v5 = 0;
    }
    *(_QWORD *)(v2 + 2720) = v3 - v5;
  }
  return result;
}

uint64_t SetInitialVoiceAndLanguage(uint64_t a1)
{
  uint64_t Str;
  uint64_t v3;
  BOOL v4;
  char *v6;

  v6 = 0;
  Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 40), (uint64_t)"langcode", &v6);
  if ((Str & 0x80000000) != 0)
    return Str;
  __strcpy_chk();
  v3 = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 40), (uint64_t)"voice", &v6);
  if ((v3 & 0x80000000) == 0)
  {
    __strcpy_chk();
    *(_DWORD *)(a1 + 13160) = 0;
    if (paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 40), (uint64_t)"processingtnplus", &v6))
      v4 = 1;
    else
      v4 = v6 == 0;
    if (!v4 && !LH_stricmp(v6, "yes"))
      *(_DWORD *)(a1 + 13160) = 1;
  }
  return v3;
}

uint64_t ELQSSMLParse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v15;
  _OWORD v16[32];
  char v17[512];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v5 = 2375032834;
  if (a1 && *(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
  {
    v5 = ELQXMLParse(*(_QWORD *)(a1 + 2624));
    memset(v16, 0, sizeof(v16));
    v15 = 0;
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
    {
      v8 = *(_QWORD *)(a1 + 2096);
      v15 = v8;
      v9 = (const char *)(a1 + 2104);
    }
    else
    {
      LODWORD(v8) = 0;
      v9 = 0;
    }
    if (*(_DWORD *)(a1 + 2084))
    {
      if (!a5)
      {
        __sprintf_chk(v17, 0, 0x200uLL, "%s at line %d\n", v9, v8);
LABEL_9:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v10, v11, v12, v13, "SSML parser error");
      }
    }
    else if (!ELQXMLGetError(*(_QWORD *)(a1 + 2624))
           && !(ELQXMLGetErrorString(*(_QWORD *)(a1 + 2624), 0, (char *)v16) | a5))
    {
      __sprintf_chk(v17, 0, 0x200uLL, "%s at line %d\n", (const char *)v16, v15);
      goto LABEL_9;
    }
  }
  return v5;
}

_QWORD *ELQSSMLDelete(_QWORD *result)
{
  uint64_t v1;
  uint64_t (*v2)();
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result)
  {
    v1 = (uint64_t)result;
    v2 = (uint64_t (*)())result[194];
    if (v2 == ELQSSMLIni || v2 == ELQSSMLDelete)
    {
      DynStringDestroy((_QWORD ***)result[1659]);
      DynStringDestroy(*(_QWORD ****)(v1 + 13264));
      if (*(uint64_t (**)())(v1 + 1552) == ELQSSMLIni)
      {
        v4 = -1;
        do
          ++v4;
        while (*(_QWORD *)(v1 + 24 * v4 + 16));
        if (v4)
        {
          v5 = v4 - 1;
          do
          {
            v6 = v5;
            v7 = v1 + 24 * v5;
            tinystack_Delete(*(_QWORD **)(v7 + 16));
            heap_Free(*(_QWORD **)(*(_QWORD *)(v1 + 12992) + 8), *(_QWORD *)(v7 + 24));
            --v5;
          }
          while (v6);
        }
        *(_QWORD *)(v1 + 16) = 0;
        *(_QWORD *)(v1 + 24) = 0;
      }
      hashtable_ObjClose(*(_QWORD **)(v1 + 12984));
      v8 = *(_QWORD *)(v1 + 12992);
      v9 = *(_QWORD *)(v8 + 48);
      if (v9)
      {
        if (*(_QWORD *)(v1 + 13344))
        {
          objc_ReleaseObject(v9, (uint64_t)"TTSEG");
          *(_QWORD *)(v1 + 13344) = 0;
          v8 = *(_QWORD *)(v1 + 12992);
        }
      }
      return heap_Free(*(_QWORD **)(v8 + 8), v1);
    }
  }
  return result;
}

_QWORD *DynStringDestroy(_QWORD ***a1)
{
  uint64_t v2;
  _QWORD *v3;

  v3 = a1 + 1;
  v2 = (uint64_t)a1[1];
  if (v2)
    heap_Free(**a1, v2);
  *v3 = 0;
  v3[1] = 0;
  return heap_Free(**a1, (uint64_t)a1);
}

uint64_t ELQSSMLSetOutputFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni)
    return 2375032834;
  result = 0;
  *(_QWORD *)(a1 + 2640) = a2;
  *(_QWORD *)(a1 + 2648) = a3;
  return result;
}

uint64_t ELQSSMLSetMemorySlot(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni)
    return 2375032834;
  result = 0;
  *(_QWORD *)(a1 + 2672) = a2;
  return result;
}

uint64_t ELQSSMLSetVoiceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni)
    return 2375032834;
  result = 0;
  *(_QWORD *)(a1 + 2680) = a2;
  return result;
}

uint64_t ELQSSMLSetLangCodeConverter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni)
    return 2375032834;
  result = 0;
  *(_QWORD *)(a1 + 14384) = a2;
  *(_QWORD *)(a1 + 14392) = a3;
  *(_QWORD *)(a1 + 14400) = a4;
  return result;
}

uint64_t SSMLstricmpElement(uint64_t a1, char *__s, char *a3)
{
  uint64_t result;
  char v7;
  size_t v8;
  _QWORD *(**v9)(uint64_t, uint64_t, int);
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  char __sa[2];
  uint64_t v20;
  char v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  _BYTE v52[31];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (__s && a3)
  {
    v51 = 0u;
    memset(v52, 0, sizeof(v52));
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v38 = 0u;
    v37 = 0u;
    v36 = 0u;
    v35 = 0u;
    v34 = 0u;
    v33 = 0u;
    v32 = 0u;
    v31 = 0u;
    v30 = 0u;
    v29 = 0u;
    v28 = 0u;
    v27 = 0u;
    v26 = 0u;
    v25 = 0u;
    v24 = 0u;
    v23 = 0u;
    v22 = 0u;
    v20 = 0;
    v21 = 0;
    v7 = *(_BYTE *)(a1 + 12968);
    if (!v7 || strchr(__s, *(char *)(a1 + 12968)))
    {
      __sa[0] = v7;
      __sa[1] = 0;
      v8 = strlen(__s);
      v9 = ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), __s, v8 + 1);
      if (!v9)
        goto LABEL_20;
      v10 = (uint64_t)v9;
      v11 = strhelper_SafeStrtok((uint64_t)v9, __sa, &v20);
      if (!v11)
        goto LABEL_20;
      v12 = *(_QWORD *)(a1 + 2720);
      if (v12)
      {
        v13 = v11;
        v14 = (char *)(a1 + 3240);
        while (strcmp(v13, v14)
             && strcmp(v13, "http://www.w3.org/2001/10/synthesis")
             && strcmp(v13, "http://www.w3.org/XML/1998/namespace"))
        {
          v14 += 1024;
          if (!--v12)
            goto LABEL_22;
        }
        v15 = strhelper_SafeStrtok(v10, __sa, &v20);
        if (v15)
        {
          v16 = v15;
          v17 = "http://www.w3.org/XML/1998/namespace";
          if (LH_stricmp(v14, "http://www.w3.org/XML/1998/namespace"))
          {
            v18 = 1u;
            v17 = "http://www.w3.org/2001/10/synthesis";
            while (LH_stricmp("http://www.w3.org/2001/10/synthesis", v14)
                 || LH_stricmp(isValidElementForUri_tagsTable[v18], v16))
            {
              v18 += 2;
              if (v18 == 45)
                goto LABEL_20;
            }
          }
          *(_QWORD *)(a1 + 12976) = v17;
          goto LABEL_22;
        }
LABEL_20:
        v21 = 0;
        return LH_stricmp(&v21, a3);
      }
    }
LABEL_22:
    __strcpy_chk();
    return LH_stricmp(&v21, a3);
  }
  return result;
}

uint64_t SetSSMLError(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 2084) = a2;
  __strcpy_chk();
  return ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
}

char *SSML10StartConvert(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v11;
  unsigned int v12;
  char **v13;
  int v14;
  int v15;
  char *v16;
  int v17;
  const char *v18;
  char *v19;
  void (*v20)(char *, _QWORD);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int16 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  BOOL v52;
  uint64_t Str;
  unsigned int v54;
  char **v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(char *, _QWORD);
  char *v59;
  int v60;
  void (*v61)(char *, _QWORD);
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  char **v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char **v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  int v92;
  char **v93;
  unint64_t v94;
  uint64_t v95;
  size_t v96;
  char *v97;
  void (*v98)(char *, _QWORD);
  char *v99;
  void (*v100)(char *, _QWORD);
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  char **v110;
  char *v111;
  char *v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  uint64_t v126;
  char *v127;
  char **v128;
  void (*v129)(char *, _QWORD);
  void (*v130)(char *, _QWORD);
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  char *v140;
  const char *v141;
  uint64_t v142;
  char v143[512];
  char __s[8];
  __int16 v145;
  uint64_t v146;

  v146 = *MEMORY[0x1E0C80C00];
  v143[0] = 0;
  if (!SSMLstricmpElement(a1, a2, "speak"))
  {
    *(_QWORD *)(a1 + 2688) = 0;
    *(_QWORD *)(a1 + 2704) = 0;
    *(_DWORD *)(a1 + 2696) = 0;
    *(_DWORD *)(a1 + 2712) = 0;
    v11 = *(char **)a3;
    if (*(_QWORD *)a3)
    {
      v140 = 0;
      v12 = 1;
      v13 = (char **)a3;
      v14 = 1;
      v15 = 1;
      do
      {
        if (!LH_stricmp(v11, "version") && *(_QWORD *)(a3 + 8 * v12))
          v14 = 0;
        if (*v13)
        {
          if ((!SSMLstricmp(a1, *v13, "lang") || !SSMLstricmp(a1, *v13, "xml:lang"))
            && *(_QWORD *)(a3 + 8 * v12))
          {
            v15 = 0;
          }
          if (*v13)
          {
            if (!LH_stricmp(*v13, "autolid"))
            {
              v16 = *(char **)(a3 + 8 * v12);
              if (v16)
              {
                v17 = SSMLstricmp(a1, v16, "no");
                v18 = "yes";
                if (!v17)
                  v18 = "no";
                v140 = (char *)v18;
              }
            }
            if (*v13
              && (!SSMLstricmp(a1, *v13, "base") || !SSMLstricmp(a1, *v13, "xml:base")))
            {
              v19 = *(char **)(a3 + 8 * v12);
              if (v19)
              {
                UrlSetBaseURI(a1, v19);
                v20 = *(void (**)(char *, _QWORD))(a1 + 2640);
                if (v20)
                  v20(v143, *(_QWORD *)(a1 + 2648));
              }
            }
          }
        }
        v13 = (char **)(a3 + 8 * (v12 + 1));
        v11 = *v13;
        v12 += 2;
      }
      while (*v13);
      if (*(_DWORD *)(a1 + 2616))
      {
        if (!v14 || !v15)
        {
          if (v14)
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1458, "%s%s", v6, v7, v8, v9, "SSML parser error");
            *(_DWORD *)(a1 + 2084) = -1919926671;
            strcpy((char *)(a1 + 2104), "The \"version\" attribute is required for \"speak\" element");
            goto LABEL_195;
          }
          goto LABEL_74;
        }
LABEL_54:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1458, "%s%s", v6, v7, v8, v9, "SSML parser error");
        *(_DWORD *)(a1 + 2084) = -1919926671;
        strcpy((char *)(a1 + 2104), "The \"version\" attribute and the \"xml:lang\" attribute are required for \"speak\" element");
        v26 = *(_QWORD *)(a1 + 2624);
LABEL_196:
        ELQXMLGetCurrentLineNumber(v26);
        return (char *)*(unsigned int *)(a1 + 2084);
      }
      if (!v14)
      {
LABEL_74:
        if (v15)
        {
          v50 = *(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32);
          if (*(_DWORD *)(a1 + 2616))
          {
            log_OutPublic(v50, (uint64_t)"LIGHTSSML", 1458, "%s%s", v6, v7, v8, v9, "SSML parser error");
            *(_DWORD *)(a1 + 2084) = -1919926671;
            strcpy((char *)(a1 + 2104), "The \"xml:lang\" attribute is required for \"speak\" element\n");
            goto LABEL_195;
          }
          log_OutText(v50, (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"SSML: Warning: the \"xml:lang\" attribute is required for \"speak\" element\n", v7, v8, v9, v139);
        }
        SSMLSaveOnLangFailureIntoStack(a1, *(_DWORD *)(a1 + 2716));
        v51 = *(char **)a3;
        v52 = *(_QWORD *)a3 != 0;
        if (!v15 && !v51)
        {
          Str = 0;
LABEL_101:
          UnloadTuningResources((_QWORD *)a1);
          return (char *)Str;
        }
        Str = 0;
        v54 = 1;
        v55 = (char **)a3;
        while (1)
        {
          if (v15)
          {
            *(_QWORD *)__s = 0;
            Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 40), (uint64_t)"langcode", __s);
            if ((Str & 0x80000000) != 0)
              goto LABEL_101;
            v56 = *(_QWORD *)__s;
          }
          else
          {
            if (!v52 || SSMLstricmp(a1, v51, "lang") && SSMLstricmp(a1, *v55, "xml:lang"))
              goto LABEL_94;
            v56 = *(_QWORD *)(a3 + 8 * v54);
            if (!v56)
              goto LABEL_94;
            *(_QWORD *)__s = *(_QWORD *)(a3 + 8 * v54);
          }
          v57 = NormalizeLangCode((_QWORD *)a1, v56);
          aux_SetActiveLanguage(a1, v57, v140);
          __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\lang=%s\\", (const char *)(a1 + 13128));
          v58 = *(void (**)(char *, _QWORD))(a1 + 2640);
          if (v58)
            v58(v143, *(_QWORD *)(a1 + 2648));
          if (v15)
          {
LABEL_95:
            v59 = *(char **)a3;
            if (*(_QWORD *)a3)
            {
              v60 = 1;
              do
              {
                if (!LH_stricmp(v59, "ssft-domaintype"))
                {
                  __strcpy_chk();
                  __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\domain=%s\\", (const char *)(a1 + 13228));
                  v61 = *(void (**)(char *, _QWORD))(a1 + 2640);
                  if (v61)
                    v61(v143, *(_QWORD *)(a1 + 2648));
                }
                v59 = *(char **)(a3 + 8 * (v60 + 1));
                v60 += 2;
              }
              while (v59);
            }
            goto LABEL_101;
          }
LABEL_94:
          v55 = (char **)(a3 + 8 * (v54 + 1));
          v51 = *v55;
          v52 = *v55 != 0;
          v54 += 2;
          if (!*v55)
            goto LABEL_95;
        }
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 2616))
        goto LABEL_54;
      v140 = 0;
      v15 = 1;
    }
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"SSML: Warning: the \"version\" attribute is required for \"speak\" element\n", v7, v8, v9, v139);
    goto LABEL_74;
  }
  if (!SSMLstricmpElement(a1, a2, "meta"))
  {
    v141 = 0;
    v142 = 0;
    if (CheckTagBond(a1, &v141))
    {
      __sprintf_chk(__s, 0, 0x200uLL, "The \"%s\" element can only contain text", v141);
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v21, v22, v23, v24, "SSML parser error");
LABEL_58:
      *(_DWORD *)(a1 + 2084) = -1919926671;
      __strcpy_chk();
LABEL_59:
      ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
      ReleaseTagBond(a1);
      return (char *)*(unsigned int *)(a1 + 2084);
    }
    v31 = XMLGetStack(a1, "tagOrder");
    if (!v31)
      goto LABEL_194;
    if ((tinystack_View(v31, &v142) & 0x80000000) == 0 && v142 == 13)
    {
      __sprintf_chk(__s, 0, 0x200uLL, "The \"%s\" element can only contain text", v141);
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v36, v37, v38, v39, "SSML parser error");
      v40 = 8194;
LABEL_163:
      *(_DWORD *)(a1 + 2084) = v40 | 0x8D900000;
      __strcpy_chk();
      goto LABEL_195;
    }
    v72 = XMLGetStack(a1, "metadata");
    if (!v72)
      goto LABEL_194;
    v73 = v72;
    if ((tinystack_View(v72, &v142) & 0x80000000) == 0)
      v142 = XMLGetCurrentValue(a1);
    if ((tinystack_Push(v73, 17) & 0x80000000) == 0)
    {
      v78 = *(char **)a3;
      if (!*(_QWORD *)a3)
        goto LABEL_207;
      v79 = 0;
      v80 = 0;
      v81 = 0;
      v82 = 2;
      v83 = (char **)a3;
      do
      {
        if (LH_stricmp(v78, "name"))
        {
          if (*v83)
          {
            if (LH_stricmp(*v83, "http-equiv"))
            {
              if (*v83 && !LH_stricmp(*v83, "content"))
                v80 = 1;
            }
            else
            {
              v81 = 1;
            }
          }
        }
        else
        {
          v79 = 1;
        }
        v83 = (char **)(a3 + 8 * (v82 & 0xFFFFFFFE));
        v78 = *v83;
        v82 += 2;
      }
      while (*v83);
      if (v79 && v81)
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1462, "%s%s", v74, v75, v76, v77, "SSML parser error");
        *(_DWORD *)(a1 + 2084) = -1919926671;
        v84 = a1 + 2104;
        *(_QWORD *)(a1 + 2104) = *(_QWORD *)"Out of Memory";
        v85 = *(_QWORD *)" Memory";
LABEL_201:
        *(_QWORD *)(v84 + 6) = v85;
        goto LABEL_195;
      }
      if (v79 | v81)
      {
        if (v80)
          return 0;
        v126 = *(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32);
      }
      else
      {
LABEL_207:
        v126 = *(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32);
      }
      log_OutPublic(v126, (uint64_t)"LIGHTSSML", 1462, "%s%s", v74, v75, v76, v77, "SSML parser error");
      goto LABEL_209;
    }
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v74, v75, v76, v77, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934454;
    v84 = a1 + 2104;
    *(_QWORD *)(a1 + 2104) = *(_QWORD *)"Out of Memory";
    v85 = *(_QWORD *)" Memory";
    goto LABEL_201;
  }
  if (!SSMLstricmpElement(a1, a2, "metadata"))
  {
    v141 = 0;
    v142 = 0;
    if (CheckTagBond(a1, &v141))
    {
      v25 = v141;
LABEL_57:
      __sprintf_chk(__s, 0, 0x200uLL, "The \"%s\" element can only contain text", v25);
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1414, "%s%s", v27, v28, v29, v30, "SSML parser error");
      goto LABEL_58;
    }
    v45 = XMLGetStack(a1, "tagOrder");
    if (!v45)
    {
LABEL_194:
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v32, v33, v34, v35, "SSML parser error");
      *(_DWORD *)(a1 + 2084) = -1919934462;
      strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
      goto LABEL_195;
    }
    if ((tinystack_View(v45, &v142) & 0x80000000) != 0 || v142 != 13)
    {
      v101 = XMLGetStack(a1, "metadata");
      if (v101)
      {
        v102 = v101;
        if ((tinystack_View(v101, &v142) & 0x80000000) == 0)
          v142 = XMLGetCurrentValue(a1);
        if ((tinystack_Push(v102, 17) & 0x80000000) == 0)
          return 0;
        goto LABEL_199;
      }
      goto LABEL_194;
    }
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1414, "%s%s", v46, v47, v48, v49, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    strcpy((char *)(a1 + 2104), "\"metadata\" element must occur before all other element");
LABEL_195:
    v26 = *(_QWORD *)(a1 + 2624);
    goto LABEL_196;
  }
  if (!SSMLstricmpElement(a1, a2, "mark"))
  {
    v141 = 0;
    v142 = 0;
    if (CheckTagBond(a1, &v142))
    {
      v25 = (const char *)v142;
      goto LABEL_57;
    }
    v66 = XMLGetStack(a1, "tagOrder");
    if (v66)
    {
      v67 = v66;
      if ((tinystack_View(v66, &v141) & 0x80000000) != 0 && (tinystack_Push(v67, 13) & 0x80000000) != 0)
        goto LABEL_199;
      if (!*(_QWORD *)a3 || LH_stricmp(*(char **)a3, "name") || !*(_QWORD *)(a3 + 8))
        return 0;
      __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\mrk=%s\\");
      goto LABEL_153;
    }
    goto LABEL_194;
  }
  if (!SSMLstricmpElement(a1, a2, "break"))
  {
    v142 = 0;
    v143[0] = 0;
    *(_QWORD *)__s = 0;
    v145 = 0;
    if (CheckTagBond(a1, &v141))
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1446, "%s%s", v41, v42, v43, v44, "SSML parser error");
LABEL_105:
      *(_DWORD *)(a1 + 2084) = -1919926671;
      strcpy((char *)(a1 + 2104), "The \"%s\" element can only contain text");
      goto LABEL_59;
    }
    v89 = XMLGetStack(a1, "tagOrder");
    if (!v89)
      goto LABEL_194;
    v90 = v89;
    if ((tinystack_View(v89, &v142) & 0x80000000) != 0 && (tinystack_Push(v90, 13) & 0x80000000) != 0)
      goto LABEL_199;
    v91 = *(char **)a3;
    if (*(_QWORD *)a3)
    {
      v92 = 0;
      v93 = (char **)(a3 + 16);
      v94 = -1;
      do
      {
        if (!LH_stricmp(v91, "time"))
        {
          v95 = (uint64_t)*(v93 - 1);
          if (v95)
          {
            v96 = strlen(*(v93 - 1));
            if (*(_BYTE *)(v95 + v96 - 2) == 109)
            {
              __strncpy_chk();
              v94 = (int)LH_atoi(__s);
            }
            else if ((*(unsigned __int8 *)(v95 + v96 - 1) | 0x20) == 0x73)
            {
              __strncpy_chk();
              v97 = strrchr(__s, 44);
              if (v97)
                *v97 = 46;
              v94 = (unint64_t)(atof(__s) * 1000.0);
            }
          }
          if (v94 != -1)
          {
            __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause=%d\\", v94);
            v98 = *(void (**)(char *, _QWORD))(a1 + 2640);
            if (v98)
              v98(v143, *(_QWORD *)(a1 + 2648));
          }
          v92 = 1;
        }
        v99 = *v93;
        v93 += 2;
        v91 = v99;
      }
      while (v99);
      if (!v92)
      {
        v127 = *(char **)a3;
        if (*(_QWORD *)a3)
        {
          v128 = (char **)(a3 + 8);
          do
          {
            if (!LH_stricmp(v127, "strength"))
            {
              if (!*v128 || !LH_stricmp(*v128, "medium") || !LH_stricmp(*v128, "weak"))
                goto LABEL_221;
              if (!LH_stricmp(*v128, "none"))
              {
                __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\eos=0\\");
                v130 = *(void (**)(char *, _QWORD))(a1 + 2640);
                if (v130)
                  v130(v143, *(_QWORD *)(a1 + 2648));
                __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause=%d\\");
                goto LABEL_222;
              }
              if (LH_stricmp(*v128, "x-weak"))
              {
                if (LH_stricmp(*v128, "strong") && LH_stricmp(*v128, "x-strong"))
LABEL_221:
                  __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause\\", v139);
                else
                  __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\eos=1\\", v139);
LABEL_222:
                v129 = *(void (**)(char *, _QWORD))(a1 + 2640);
                if (v129)
                  v129(v143, *(_QWORD *)(a1 + 2648));
                goto LABEL_224;
              }
              strcpy(v143, " ");
            }
LABEL_224:
            v127 = v128[1];
            v128 += 2;
          }
          while (v127);
        }
      }
    }
    if (v143[0])
      return 0;
    __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause\\");
LABEL_153:
    v100 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v100)
      v100(v143, *(_QWORD *)(a1 + 2648));
    return 0;
  }
  if (SSMLstricmpElement(a1, a2, "prosody"))
  {
    if (SSMLstricmpElement(a1, a2, "p"))
    {
      if (SSMLstricmpElement(a1, a2, "s"))
      {
        if (SSMLstricmpElement(a1, a2, "lang"))
        {
          if (!SSMLstricmpElement(a1, a2, "phoneme"))
            return (char *)SSMLElement_PHONEME_Enter(a1, (char **)a3, (uint64_t)v143);
          if (!SSMLstricmpElement(a1, a2, "voice"))
            return (char *)SSMLElement_VOICE_Enter(a1, (char **)a3, v143);
          if (!SSMLstricmpElement(a1, a2, "emphasis"))
            return (char *)SSMLElement_EMPHASIS_Enter(a1, (_QWORD *)a3);
          if (!SSMLstricmpElement(a1, a2, "sub"))
            return (char *)SSMLElement_SUB_Enter(a1, a3);
          if (!SSMLstricmpElement(a1, a2, "say-as"))
            return (char *)SSMLElement_SAYAS_Enter(a1, (char **)a3, v143);
          if (!SSMLstricmpElement(a1, a2, "audio"))
            return (char *)SSMLElement_AUDIO_Enter(a1, (char **)a3, v143);
          if (!SSMLstricmpElement(a1, a2, "style"))
            return (char *)SSMLElement_STYLE_Enter(a1, (char **)a3, v143);
          if (!SSMLstricmpElement(a1, a2, "prompt"))
            return SSMLElement_PROMPT_Enter(a1, a3, v143);
          if (!SSMLstricmpElement(a1, a2, "desc"))
            return (char *)SSMLElement_DESC_Enter(a1, (char **)a3, v143);
          if (!SSMLstricmpElement(a1, a2, "lexicon"))
            return (char *)SSMLElement_LEXICON_Enter(a1, (char **)a3, (uint64_t)v143);
          return 0;
        }
        v86 = a1;
        v87 = (char **)a3;
        v88 = 2;
      }
      else
      {
        v86 = a1;
        v87 = (char **)a3;
        v88 = 0;
      }
    }
    else
    {
      v86 = a1;
      v87 = (char **)a3;
      v88 = 1;
    }
    return (char *)SSMLElement_Block_Enter(v86, v87, v143, v88);
  }
  v142 = 0;
  if (!*(_QWORD *)a3)
  {
    __sprintf_chk(__s, 0, 0x200uLL, "At least one attribute must be specified for \"prosody\" element");
LABEL_162:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v103, v104, v105, v106, "SSML parser error");
    v40 = 15985;
    goto LABEL_163;
  }
  if (CheckTagBond(a1, &v141))
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v62, v63, v64, v65, "SSML parser error");
    goto LABEL_105;
  }
  v107 = XMLGetStack(a1, "tagOrder");
  if (!v107)
    goto LABEL_194;
  v108 = v107;
  if ((tinystack_View(v107, &v142) & 0x80000000) != 0 && (tinystack_Push(v108, 13) & 0x80000000) != 0)
  {
LABEL_199:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v68, v69, v70, v71, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_195;
  }
  SSMLPushProsodicParameters(a1);
  v109 = *(char **)a3;
  if (!*(_QWORD *)a3)
  {
LABEL_191:
    v114 = XMLGetStack(a1, "auxiliary");
    if (!v114)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v115, v116, v117, v118, "SSML parser error");
      v124 = a1;
      v123 = -1919934462;
      goto LABEL_210;
    }
    if ((tinystack_Push(v114, 0) & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v119, v120, v121, v122, "SSML parser error");
      v123 = -1919933952;
      v124 = a1;
      goto LABEL_210;
    }
    return 0;
  }
  v110 = (char **)(a3 + 8);
  while (1)
  {
    if (!LH_stricmp(v109, "rate") && *v110)
    {
      if (!ParseAttribute(a1, *v110, 2))
      {
        __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - rate attribute");
        goto LABEL_239;
      }
      goto LABEL_190;
    }
    v111 = *(v110 - 1);
    if (!v111)
      goto LABEL_232;
    if (LH_stricmp(v111, "pitch") || !*v110)
      break;
    if (!ParseAttribute(a1, *v110, 3))
    {
      __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - pitch attribute");
      goto LABEL_242;
    }
LABEL_190:
    v109 = v110[1];
    v110 += 2;
    if (!v109)
      goto LABEL_191;
  }
  v112 = *(v110 - 1);
  if (!v112)
    goto LABEL_232;
  if (LH_stricmp(v112, "timbre") || !*v110)
  {
    v113 = *(v110 - 1);
    if (!v113 || LH_stricmp(v113, "volume") || !*v110)
    {
LABEL_232:
      __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - unknown or unimplemented attribute");
      goto LABEL_162;
    }
    if (!ParseAttribute(a1, *v110, 1))
    {
      __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - volume attribute");
LABEL_239:
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v131, v132, v133, v134, "SSML parser error");
      goto LABEL_209;
    }
    goto LABEL_190;
  }
  if (ParseAttribute(a1, *v110, 4))
    goto LABEL_190;
  __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - timbre attribute");
LABEL_242:
  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1304, "%s%s", v135, v136, v137, v138, "SSML parser error");
LABEL_209:
  v124 = a1;
  v123 = -1919926671;
LABEL_210:
  SetSSMLError(v124, v123);
  return (char *)*(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_Block_Enter(uint64_t a1, char **a2, char *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t Str;
  unsigned int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  char *v28;
  char **v29;
  uint64_t v30;
  char *v31;
  size_t v32;
  uint64_t v33;
  char *v34;
  uint64_t i;
  char *v36;
  int v37;
  const char *v38;
  char *v39;
  void (*v40)(char *, _QWORD);
  int v42;
  BOOL v43;
  unsigned int v44;
  char *v45;
  uint64_t v46;
  char *v47;
  const char *v48;
  void (*v49)(char *, _QWORD);
  char *v50;
  unsigned int v51;
  char *v52;
  _QWORD *(**v53)(uint64_t, uint64_t, int);
  char *__s2;
  unsigned int v55;
  const char *v56;
  uint64_t v57;
  char __s1[4];
  uint64_t v59;
  char *v60[66];

  v60[64] = *(char **)MEMORY[0x1E0C80C00];
  v56 = 0;
  v57 = 0;
  v55 = *(_DWORD *)(a1 + 2716);
  if (CheckTagBond(a1, &v56))
  {
    __sprintf_chk((char *)v60, 0, 0x200uLL, "The \"%s\" element can only contain text", v56);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v8, v9, v10, v11, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v12 = XMLGetStack(a1, "tagOrder");
  if (!v12)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v13, v14, v15, v16, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_42:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v17 = v12;
  if ((tinystack_View(v12, &v57) & 0x80000000) != 0 && (tinystack_Push(v17, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v18, v19, v20, v21, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_42;
  }
  v52 = a3;
  Str = SSMLViewOnLangFailureFromStack(a1, &v55);
  if (!(_DWORD)Str)
  {
    v23 = v55;
    if (v55 == 4)
      v23 = *(_DWORD *)(a1 + 2716);
    v51 = v23;
    *v52 = 0;
    v24 = *a2;
    if (*a2)
    {
      v25 = 0;
      v53 = 0;
      __s2 = 0;
      v26 = 0;
      v27 = 0;
      v50 = 0;
      v28 = "lang";
      v29 = a2;
      do
      {
        if (SSMLstricmp(a1, v24, v28) && SSMLstricmp(a1, *v29, "xml:lang")
          || (v30 = *(uint64_t *)((char *)a2 + ((8 * v25) | 8))) == 0)
        {
          if (*v29)
          {
            if (SSMLstricmp(a1, *v29, "onlangfailure")
              || (v39 = *(char **)((char *)a2 + ((8 * v25) | 8))) == 0)
            {
              if (*v29)
              {
                if (!LH_stricmp(*v29, "autolid"))
                {
                  v36 = *(char **)((char *)a2 + ((8 * v25) | 8));
                  if (v36)
                  {
                    v37 = SSMLstricmp(a1, v36, "no");
                    v38 = "yes";
                    if (!v37)
                      v38 = "no";
                    v50 = (char *)v38;
                  }
                }
              }
            }
            else
            {
              v51 = SSMLGetLangFailureCode(v39);
            }
          }
        }
        else
        {
          v31 = (char *)NormalizeLangCode((_QWORD *)a1, v30);
          v32 = strlen(v31);
          __s2 = v31;
          v53 = ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), v31, v32 + 1);
          v59 = 0;
          v60[0] = 0;
          paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 40), (uint64_t)"extraesclang", v60);
          Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 40), (uint64_t)"langcode", &v59);
          if ((Str & 0x80000000) != 0)
            return Str;
          v33 = a4;
          v34 = v28;
          for (i = 0; i != 3; ++i)
            __s1[i] = ssft_tolower(*(unsigned __int8 *)(v59 + i));
          __s1[3] = 0;
          v28 = v34;
          a4 = v33;
          if (strstr(__s1, __s2) || v60[0] && strstr(v60[0], __s2))
          {
            v27 = 1;
            if ((_DWORD)Str)
              return Str;
          }
          else
          {
            v27 = 0;
            if ((_DWORD)Str)
              return Str;
          }
        }
        if (a4 <= 1)
        {
          if (*v29)
          {
            if (!LH_stricmp(*v29, "ssft-domaintype"))
            {
              if (*(char **)((char *)a2 + ((8 * v25) | 8)))
              {
                __strcpy_chk();
                sprintf(v52, "\x1B\\domain=%s\\", (const char *)(a1 + 13196));
                v40 = *(void (**)(char *, _QWORD))(a1 + 2640);
                if (v40)
                  v40(v52, *(_QWORD *)(a1 + 2648));
              }
            }
          }
        }
        ++v26;
        v25 = 2 * v26;
        v29 = &a2[2 * v26];
        v24 = *v29;
      }
      while (*v29);
    }
    else
    {
      v27 = 0;
      v53 = 0;
      __s2 = 0;
      v50 = 0;
    }
    v42 = v51;
    v55 = v51;
    if (__s2)
      v43 = 1;
    else
      v43 = (_DWORD)a4 == 2;
    v44 = 4;
    if (v43)
    {
      v45 = v52;
      v46 = (uint64_t)v53;
      v47 = v50;
      if (!v27)
      {
        if (v51 != 4)
        {
          SSMLSaveOnLangFailureIntoStack(a1, v51);
          if (!v51)
            SSMLPushVoice(a1);
LABEL_56:
          SSMLPushLanguage(a1);
          if ((_DWORD)a4 == 1)
          {
            v45[8] = 0;
            v48 = "\n\x1B\\para\\";
          }
          else
          {
            if ((_DWORD)a4)
            {
LABEL_62:
              SSMLOnLanguageChange(a1, v46, v47, v42, v45);
              return 0;
            }
            v45[8] = 0;
            v48 = "\x1B\\eos=1\\";
          }
          *(_QWORD *)v45 = *(_QWORD *)v48;
          v49 = *(void (**)(char *, _QWORD))(a1 + 2640);
          if (v49)
            v49(v45, *(_QWORD *)(a1 + 2648));
          goto LABEL_62;
        }
        v44 = 3;
      }
    }
    else
    {
      v45 = v52;
      v46 = (uint64_t)v53;
      v47 = v50;
    }
    v55 = v44;
    SSMLSaveOnLangFailureIntoStack(a1, v44);
    v42 = v44;
    goto LABEL_56;
  }
  return Str;
}

uint64_t SSMLElement_PHONEME_Enter(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  char **v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  int v33;
  uint64_t v34;
  _BOOL8 v35;
  unsigned int v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  void (*v45)(uint64_t, _QWORD);
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  const char *v59;
  uint64_t v60;
  char v61[512];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v59 = 0;
  v60 = 0;
  if (CheckTagBond(a1, &v59))
  {
    __sprintf_chk(v61, 0, 0x200uLL, "The \"%s\" element can only contain text", v59);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1300, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  result = NewTagBond(a1, "phoneme");
  if ((_DWORD)result)
    return result;
  v11 = XMLGetStack(a1, "tagOrder");
  if (!v11)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v16 = v11;
  if ((tinystack_View(v11, &v60) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
  {
    v52 = *(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32);
LABEL_73:
    log_OutPublic(v52, (uint64_t)"LIGHTSSML", 1459, "%s%s", v17, v18, v19, v20, "SSML parser error");
    v58 = -1919933952;
LABEL_74:
    v57 = a1;
    goto LABEL_75;
  }
  v21 = *a2;
  if (!*a2)
    goto LABEL_70;
  v22 = 0;
  v23 = 1;
  v24 = 4;
  v25 = a2;
  do
  {
    if (!LH_stricmp(v21, "orthmode"))
    {
      v26 = a2[v23];
      if (v26)
      {
        if (!LH_stricmp(v26, "ignorepunct"))
          v22 = 1;
      }
    }
    if (*v25)
    {
      if (!LH_stricmp(*v25, "alphabet"))
      {
        v27 = a2[v23];
        if (v27)
        {
          if (LH_stricmp(v27, "nt-sampa")
            && LH_stricmp(a2[v23], "nts")
            && LH_stricmp(a2[v23], "x-sampa")
            && LH_stricmp(a2[v23], "x-navteq-sampa"))
          {
            if (LH_stricmp(a2[v23], "sxm-sampa"))
            {
              if (LH_stricmp(a2[v23], "lhp") && LH_stricmp(a2[v23], "x-l&h+"))
              {
                if (LH_stricmp(a2[v23], "pyt") && LH_stricmp(a2[v23], "pinyin"))
                {
                  if (LH_stricmp(a2[v23], "diacritized"))
                  {
                    if (LH_stricmp(a2[v23], "jeita"))
                    {
                      __sprintf_chk(v61, 0, 0x200uLL, "SSML: Unknown or unsupported alphabeth \"%s\"\n", a2[v23]);
                      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1300, "%s%s", v28, v29, v30, v31, "SSML parser error");
                      v24 = 0;
                    }
                    else
                    {
                      v24 = 128;
                    }
                  }
                  else
                  {
                    v24 = 64;
                  }
                }
                else
                {
                  v24 = 32;
                }
              }
              else
              {
                v24 = 16;
              }
            }
            else
            {
              v24 = 9;
            }
          }
          else
          {
            v24 = 4;
          }
        }
      }
    }
    v25 = &a2[v23 + 1];
    v21 = *v25;
    v23 += 2;
  }
  while (*v25);
  v32 = *a2;
  if (!*a2)
  {
LABEL_70:
    __sprintf_chk(v61, 0, 0x200uLL, "\"ph\" attribute is required in \"phoneme\" element");
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v53, v54, v55, v56, "SSML parser error");
    v57 = a1;
    v58 = -1919926671;
LABEL_75:
    SetSSMLError(v57, v58);
    return *(unsigned int *)(a1 + 2084);
  }
  v33 = 0;
  v34 = 0;
  v35 = v22 != 0;
  v36 = 1;
  do
  {
    if (LH_stricmp(v32, "ph"))
      goto LABEL_64;
    v37 = *(_QWORD *)(a1 + 13264);
    v38 = strhelper_StringAppend(**(uint64_t ***)v37, *(char **)(v37 + 8), a2[v36], 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v37 + 16), 0x80uLL);
    *(_QWORD *)(v37 + 8) = v38;
    if (!v38)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v39, v40, v41, v42, "SSML parser error");
      v58 = -1919934454;
      goto LABEL_74;
    }
    if (v24 > 15)
    {
      if (v24 > 63)
      {
        if (v24 == 64)
        {
          strcpy((char *)a3, "\x1B\\toi=diacritized");
LABEL_57:
          v45 = *(void (**)(uint64_t, _QWORD))(a1 + 2640);
          if (v45)
            v45(a3, *(_QWORD *)(a1 + 2648));
          goto LABEL_59;
        }
        if (v24 != 128)
          goto LABEL_59;
        *(_DWORD *)(a3 + 8) = 6386793;
        v43 = "\x1B\\toi=jeita";
      }
      else if (v24 == 16)
      {
        *(_WORD *)(a3 + 8) = 112;
        v43 = "\x1B\\toi=lhp";
      }
      else
      {
        if (v24 != 32)
          goto LABEL_59;
        *(_WORD *)(a3 + 8) = 116;
        v43 = "\x1B\\toi=pyt";
      }
LABEL_56:
      *(_QWORD *)a3 = *(_QWORD *)v43;
      goto LABEL_57;
    }
    switch(v24)
    {
      case 0:
        v44 = *(_QWORD *)(a1 + 13272);
        if (!*(_QWORD *)(v44 + 8))
          *(_QWORD *)(v44 + 8) = strhelper_StringAppend(**(uint64_t ***)v44, 0, &byte_1DEBD87CE, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v44 + 16), 0x80uLL);
        break;
      case 4:
      case 8:
        *(_WORD *)(a3 + 8) = 115;
        v43 = "\x1B\\toi=nts";
        goto LABEL_56;
      case 9:
        *(_DWORD *)(a3 + 7) = 7564664;
        v43 = "\x1B\\toi=sxms";
        goto LABEL_56;
      default:
        break;
    }
LABEL_59:
    v46 = XMLGetStack(a1, "phon");
    if (!v46)
      goto LABEL_71;
    v24 |= v35;
    if ((tinystack_Push(v46, v24) & 0x80000000) != 0)
      goto LABEL_72;
    v51 = XMLGetStack(a1, "auxiliary");
    if (!v51)
    {
LABEL_71:
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v47, v48, v49, v50, "SSML parser error");
      v57 = a1;
      v58 = -1919934462;
      goto LABEL_75;
    }
    v34 |= 8uLL;
    if ((tinystack_Push(v51, v34) & 0x80000000) != 0)
    {
LABEL_72:
      v52 = *(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32);
      goto LABEL_73;
    }
    v33 = 1;
LABEL_64:
    v32 = a2[v36 + 1];
    v36 += 2;
  }
  while (v32);
  if (!v33)
    goto LABEL_70;
  return 0;
}

uint64_t SSMLElement_VOICE_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  const char *v26;
  char *v27;
  char *v28;
  unsigned int v29;
  char **v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  int v37;
  const char *v38;
  void (*v39)(char *, _QWORD);
  void (*v40)(char *, _QWORD);
  char *v41;
  const char *v42;
  uint64_t v43;
  char v44[512];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v43 = 0;
  if (!*a2)
  {
    __sprintf_chk(v44, 0, 0x200uLL, "At least one attribute must be specified for \"voice\" element");
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1433, "%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
LABEL_5:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v42 = 0;
  if (CheckTagBond(a1, &v42))
  {
    __sprintf_chk(v44, 0, 0x200uLL, "The \"%s\" element can only contain text", v42);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v15 = XMLGetStack(a1, "tagOrder");
  if (!v15)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v16, v17, v18, v19, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    goto LABEL_5;
  }
  v20 = v15;
  if ((tinystack_View(v15, &v43) & 0x80000000) != 0 && (tinystack_Push(v20, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v21, v22, v23, v24, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_5;
  }
  SSMLPushVoice(a1);
  SSMLPushLanguage(a1);
  SSMLPushProsodicParameters(a1);
  *a3 = 0;
  v25 = *a2;
  if (!*a2)
  {
    v26 = 0;
    v27 = 0;
    v36 = 0;
    goto LABEL_50;
  }
  v26 = 0;
  v41 = 0;
  v27 = 0;
  v28 = 0;
  v29 = *(_DWORD *)(a1 + 8);
  v30 = a2 + 1;
  do
  {
    if (!LH_stricmp(v25, "name") && *v30)
    {
      if (**v30)
        v28 = *v30;
      goto LABEL_39;
    }
    if (v29 > 1)
      goto LABEL_14;
    v34 = *(v30 - 1);
    if (!v34)
      goto LABEL_39;
    if (SSMLstricmp(a1, v34, "lang") && SSMLstricmp(a1, *(v30 - 1), "xml:lang") || !*v30)
    {
      v35 = *(v30 - 1);
      if (!v35)
        goto LABEL_39;
      if (!SSMLstricmp(a1, v35, "autolid") && *v30)
      {
        SSMLstricmp(a1, *v30, "no");
        goto LABEL_39;
      }
LABEL_14:
      v31 = *(v30 - 1);
      if (v31)
      {
        if (LH_stricmp(v31, "gender") || !*v30)
        {
          v32 = *(v30 - 1);
          if (v32)
          {
            if (LH_stricmp(v32, "age") || !*v30)
            {
              v33 = *(v30 - 1);
              if (v33)
                LH_stricmp(v33, "variant");
            }
            else
            {
              v26 = *v30;
            }
          }
        }
        else
        {
          v41 = *v30;
        }
      }
      goto LABEL_39;
    }
    if (**v30)
      v27 = *v30;
LABEL_39:
    v25 = v30[1];
    v30 += 2;
  }
  while (v25);
  if (!v26)
  {
    v36 = v41;
    if (!v28)
      goto LABEL_50;
    goto LABEL_57;
  }
  v36 = v41;
  if (*v26)
  {
    v37 = atoi(v26);
    v38 = "Adult";
    if (v37 < 18)
      v38 = "Child";
    if (v37 > 0)
      v26 = v38;
  }
  if (v28)
  {
LABEL_57:
    __strcpy_chk();
    goto LABEL_65;
  }
LABEL_50:
  if (v36 || v26 || v27)
  {
    *(_WORD *)(a1 + 13000) = 40;
    if (v36)
    {
      __strcat_chk();
      __strcat_chk();
      if (v26)
      {
        __strcat_chk();
        goto LABEL_60;
      }
LABEL_61:
      if (v27)
      {
        NormalizeLangCode((_QWORD *)a1, (uint64_t)v27);
        __strcat_chk();
        goto LABEL_63;
      }
    }
    else
    {
      if (v26)
      {
LABEL_60:
        __strcat_chk();
        __strcat_chk();
        goto LABEL_61;
      }
      if (v27)
      {
        NormalizeLangCode((_QWORD *)a1, (uint64_t)v27);
LABEL_63:
        __strcat_chk();
        __strcat_chk();
      }
    }
    __strcat_chk();
  }
LABEL_65:
  if (*(_BYTE *)(a1 + 13000))
  {
    sprintf(a3, "\x1B\\voice=%s\\", "(push)");
    v39 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v39)
      v39(a3, *(_QWORD *)(a1 + 2648));
    sprintf(a3, "\x1B\\voice=%s\\", (const char *)(a1 + 13000));
    v40 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v40)
      v40(a3, *(_QWORD *)(a1 + 2648));
  }
  return 0;
}

uint64_t SSMLElement_EMPHASIS_Enter(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  const char *v20;
  uint64_t v21;
  char v22[512];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = 0;
  if (CheckTagBond(a1, &v20))
  {
    __sprintf_chk(v22, 0, 0x200uLL, "The \"%s\" element can only contain text", v20);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v8 = XMLGetStack(a1, "tagOrder");
  if (!v8)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_10:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v13 = v8;
  if ((tinystack_View(v8, &v21) & 0x80000000) != 0 && (tinystack_Push(v13, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v14, v15, v16, v17, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_10;
  }
  if (*a2 && *(_BYTE *)*a2)
    v18 = (char *)a2[1];
  else
    v18 = "moderate";
  Emphasis2Prosody(a1, v18);
  return 0;
}

uint64_t SSMLElement_SUB_Enter(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v23)(_QWORD, _QWORD);
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  const char *v36;
  char v37[512];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v35 = 0;
  v36 = 0;
  if (CheckTagBond(a1, &v36))
  {
    __sprintf_chk(v37, 0, 0x200uLL, "The \"%s\" element can only contain text", v36);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v8 = XMLGetStack(a1, "tagOrder");
  if (!v8)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    goto LABEL_10;
  }
  v13 = v8;
  if ((tinystack_View(v8, &v35) & 0x80000000) != 0 && (tinystack_Push(v13, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v14, v15, v16, v17, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_10;
  }
  if (!*(_QWORD *)a2 || LH_stricmp(*(char **)a2, "alias"))
  {
    __sprintf_chk(v37, 0, 0x200uLL, "\"alias\" attribute is required in \"sub\" element");
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v18, v19, v20, v21, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
LABEL_10:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v23 = *(void (**)(_QWORD, _QWORD))(a1 + 2640);
  if (v23)
    v23(*(_QWORD *)(a2 + 8), *(_QWORD *)(a1 + 2648));
  v24 = XMLGetStack(a1, "auxiliary");
  if (v24)
  {
    if ((tinystack_Push(v24, 16) & 0x80000000) == 0)
      return NewTagBond(a1, "sub");
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v29, v30, v31, v32, "SSML parser error");
    v34 = -1919933952;
    v33 = a1;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v25, v26, v27, v28, "SSML parser error");
    v33 = a1;
    v34 = -1919934462;
  }
  SetSSMLError(v33, v34);
  return *(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_SAYAS_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *(**v16)(uint64_t, uint64_t, int);
  char *v17;
  char *v18;
  char *v19;
  char **v20;
  uint64_t v22;
  uint64_t *v23;
  size_t v24;
  void (*v25)(char *, _QWORD);
  const char *v26;
  char v27[512];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  if (CheckTagBond(a1, &v26))
  {
    __sprintf_chk(v27, 0, 0x200uLL, "The \"%s\" element can only contain text", v26);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v10 = XMLGetStack(a1, "say-as");
  if (!v10)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v11, v12, v13, v14, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_21:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v15 = v10;
  v16 = ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 13164), 0);
  if (!v16)
  {
    *(_DWORD *)(a1 + 2084) = -1919934454;
    strcpy((char *)(a1 + 2104), "Out of Memory");
    goto LABEL_21;
  }
  tinystack_Push(v15, (uint64_t)v16);
  *a3 = 0;
  v17 = *a2;
  if (!*a2)
    goto LABEL_38;
  v18 = 0;
  v19 = 0;
  v20 = a2 + 1;
  do
  {
    if (LH_stricmp(v17, "format"))
    {
      if (!LH_stricmp(*(v20 - 1), "interpret-as"))
        v18 = *v20;
    }
    else
    {
      v19 = *v20;
    }
    v17 = v20[1];
    v20 += 2;
  }
  while (v17);
  if (!v18)
  {
    if (!v19 || LH_stricmp(v19, "slot"))
      goto LABEL_38;
    strcpy(a3, "\x1B\\slotbegin\\");
    goto LABEL_37;
  }
  if (LH_stricmp(v18, "rational")
    && LH_stricmp(v18, "real")
    && LH_stricmp(v18, "decimal"))
  {
    if (!LH_stricmp(v18, "date") && v19)
    {
      strncpy((char *)(a1 + 13280), v19, 0x1FuLL);
      *(_BYTE *)(a1 + 13311) = 0;
      goto LABEL_27;
    }
  }
  else if (*(_BYTE *)(a1 + 13128) == 101 && *(_BYTE *)(a1 + 13129) == 110)
  {
    *(_DWORD *)(a1 + 13312) = 1;
  }
  if (!v19)
    goto LABEL_28;
LABEL_27:
  if (!LH_stricmp(v19, "slot"))
  {
    sprintf(a3, "\x1B\\slotbegin=%s\\", v18);
LABEL_37:
    v24 = strlen((const char *)(a1 + 13164));
    memmove((void *)(a1 + 13165), (const void *)(a1 + 13164), v24 + 1);
    *(_BYTE *)(a1 + 13164) = 95;
    goto LABEL_38;
  }
LABEL_28:
  v22 = 0;
  v23 = &qword_1EA949200;
  do
  {
    if (!LH_stricmp(v18, (char *)*(v23 - 1)))
      break;
    ++v22;
    v23 += 2;
  }
  while (v22 != 27);
  __strcpy_chk();
  sprintf(a3, "\x1B\\tn=%s\\", (const char *)(a1 + 13164));
LABEL_38:
  v25 = *(void (**)(char *, _QWORD))(a1 + 2640);
  if (v25)
  {
    if (*a3)
      v25(a3, *(_QWORD *)(a1 + 2648));
  }
  return 0;
}

uint64_t SSMLElement_AUDIO_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  size_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  void (*v40)(char *, _QWORD);
  const char *v41;
  uint64_t v42;
  char v43[512];
  char __dst[16];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  v75 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)__dst = 0u;
  v41 = 0;
  if (CheckTagBond(a1, &v41))
  {
    __sprintf_chk(v43, 0, 0x200uLL, "The \"%s\" element can only contain text", v41);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  result = NewTagBond(a1, "audio");
  if (!(_DWORD)result)
  {
    v11 = XMLGetStack(a1, "tagOrder");
    if (v11)
    {
      v16 = v11;
      if ((tinystack_View(v11, &v42) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
        goto LABEL_29;
      v21 = *a2;
      if (*a2)
      {
        v22 = 0;
        v23 = 2;
        do
        {
          if (!LH_stricmp(v21, "src"))
            v22 = v23 - 1;
          v21 = a2[v23];
          v23 += 2;
        }
        while (v21);
      }
      else
      {
        v22 = 0;
      }
      v24 = XMLGetStack(a1, "auxiliary");
      if (v24)
      {
        if ((tinystack_Push(v24, 0x4000) & 0x80000000) == 0)
        {
          v25 = XMLGetStack(a1, "audio");
          if (!v25)
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v26, v27, v28, v29, "SSML parser error");
            v39 = a1;
            v38 = -1919934462;
LABEL_31:
            SetSSMLError(v39, v38);
            return *(unsigned int *)(a1 + 2084);
          }
          v30 = v25;
          if (v22)
          {
            v31 = *(const char **)(a1 + 13320);
            if (v31)
            {
              v32 = strlen(*(const char **)(a1 + 13320));
              v33 = a2[v22];
              if (strlen(v33) + v32 > 0x1FE)
              {
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v34, v35, v36, v37, "SSML parser error");
                v38 = -1919934460;
LABEL_30:
                v39 = a1;
                goto LABEL_31;
              }
            }
            else
            {
              v33 = a2[v22];
            }
            UriCompleteUrl(v31, v33, __dst);
            ELQSubstituteEntitiesUTF8(__dst, 1);
            sprintf(a3, "\x1B\\audio=\"%s\"", __dst);
            v40 = *(void (**)(char *, _QWORD))(a1 + 2640);
            if (v40)
              v40(a3, *(_QWORD *)(a1 + 2648));
          }
          if ((tinystack_Push(v30, 1) & 0x80000000) == 0)
            return 0;
        }
LABEL_29:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v17, v18, v19, v20, "SSML parser error");
        v38 = -1919933952;
        goto LABEL_30;
      }
    }
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  return result;
}

uint64_t SSMLElement_STYLE_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unsigned int v26;
  const char *v27;
  const char *v28;
  int v29;
  char **v30;
  size_t v31;
  _QWORD *(**v33)(uint64_t, uint64_t, int);
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  char v37[512];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v35 = 0;
  v36 = 0;
  if (!*a2)
  {
    __sprintf_chk(v37, 0, 0x200uLL, "At least one attribute must be specified for \"style\" element");
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
LABEL_26:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  if (CheckTagBond(a1, &v35))
  {
    __sprintf_chk(v37, 0, 0x200uLL, "The \"%s\" element can only contain text", v35);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v14 = XMLGetStack(a1, "tagOrder");
  if (!v14)
    goto LABEL_23;
  v19 = v14;
  if ((tinystack_View(v14, &v36) & 0x80000000) != 0 && (tinystack_Push(v19, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v20, v21, v22, v23, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_26;
  }
  v24 = XMLGetStack(a1, "style");
  if (!v24)
  {
LABEL_23:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v15, v16, v17, v18, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    goto LABEL_26;
  }
  v34 = v24;
  v25 = *a2;
  if (!*a2)
    goto LABEL_24;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = a2;
  do
  {
    if (LH_stricmp(v25, "name"))
    {
      if (*(_DWORD *)(a1 + 13160) == 1 && !LH_stricmp(*v30, "intensity"))
        v27 = a2[v26 | 1];
    }
    else
    {
      v28 = a2[v26 | 1];
    }
    v26 = 2 * (unsigned __int16)++v29;
    v30 = &a2[v26];
    v25 = *v30;
  }
  while (*v30);
  if (!v28)
  {
LABEL_24:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v15, v16, v17, v18, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    strcpy((char *)(a1 + 2104), "\"style\" element must have a name attribute\n");
    goto LABEL_26;
  }
  v31 = strlen(v28);
  if (*(_DWORD *)(a1 + 13160) && v27)
    v31 += strlen(v27) + 1;
  if (v31 - 512 <= 0xFFFFFFFFFFFFFDFELL)
  {
    *(_DWORD *)(a1 + 2084) = -1919934455;
    strcpy((char *)(a1 + 2104), "Out of Memory");
    goto LABEL_26;
  }
  v33 = ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 1572), 0);
  if (!v33)
  {
    SetSSMLError(a1, -1919934454);
    return *(unsigned int *)(a1 + 2084);
  }
  tinystack_Push(v34, (uint64_t)v33);
  *(_BYTE *)(a1 + 1572) = 0;
  __strcat_chk();
  if (*(_DWORD *)(a1 + 13160))
  {
    if (v27)
    {
      __strcat_chk();
      __strcat_chk();
    }
  }
  return ApplyCurrentStyle(a1, a3);
}

char *SSMLElement_PROMPT_Enter(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *result;
  void (*v21)(char *, _QWORD);
  uint64_t v22;
  const char *v23;
  char v24[512];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v23 = 0;
  if (CheckTagBond(a1, &v23))
  {
    __sprintf_chk(v24, 0, 0x200uLL, "The \"%s\" element can only contain text", v23);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return (char *)*(unsigned int *)(a1 + 2084);
  }
  v10 = XMLGetStack(a1, "tagOrder");
  if (!v10)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v11, v12, v13, v14, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_10:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return (char *)*(unsigned int *)(a1 + 2084);
  }
  v15 = v10;
  if ((tinystack_View(v10, &v22) & 0x80000000) != 0 && (tinystack_Push(v15, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v16, v17, v18, v19, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_10;
  }
  result = *(char **)a2;
  if (*(_QWORD *)a2)
  {
    if (!LH_stricmp(result, "id") && *(_QWORD *)(a2 + 8))
    {
      sprintf(a3, "\x1B\\prompt=%s\\", *(const char **)(a2 + 8));
      v21 = *(void (**)(char *, _QWORD))(a1 + 2640);
      if (v21)
        v21(a3, *(_QWORD *)(a1 + 2648));
    }
    return 0;
  }
  return result;
}

uint64_t SSMLElement_DESC_Enter(uint64_t a1, char **a2, char *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  char **v24;
  char *v25;
  char *v26;
  int v27;
  const char *v28;
  void (*v29)(char *, _QWORD);
  char *v31;
  const char *v32;
  uint64_t v33;
  char v34[512];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v33 = 0;
  v6 = *(_DWORD *)(a1 + 2716);
  if (CheckTagBond(a1, &v32))
  {
    __sprintf_chk(v34, 0, 0x200uLL, "The \"%s\" element can only contain text", v32);
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v7, v8, v9, v10, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v11 = XMLGetStack(a1, "tagOrder");
  if (!v11)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_28:
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v16 = v11;
  if ((tinystack_View(v11, &v33) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v17, v18, v19, v20, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_28;
  }
  v21 = *a2;
  if (*a2)
  {
    v31 = 0;
    v22 = 0;
    v23 = 1;
    v24 = a2;
    do
    {
      if (LH_stricmp(v21, "onlangfailure") || (v25 = a2[v23]) == 0)
      {
        if (*v24)
        {
          if (SSMLstricmp(a1, *v24, "lang") && SSMLstricmp(a1, *v24, "xml:lang")
            || !a2[v23])
          {
            if (*v24)
            {
              if (!LH_stricmp(*v24, "autolid"))
              {
                v26 = a2[v23];
                if (v26)
                {
                  v27 = SSMLstricmp(a1, v26, "no");
                  v28 = "yes";
                  if (!v27)
                    v28 = "no";
                  v31 = (char *)v28;
                }
              }
            }
          }
          else
          {
            v22 = (uint64_t)a2[v23];
          }
        }
      }
      else
      {
        v6 = SSMLGetLangFailureCode(v25);
      }
      v24 = &a2[v23 + 1];
      v21 = *v24;
      v23 += 2;
    }
    while (*v24);
    if (v6)
      goto LABEL_24;
    goto LABEL_32;
  }
  v22 = 0;
  v31 = 0;
  if (!v6)
LABEL_32:
    SSMLPushVoice(a1);
LABEL_24:
  SSMLOnLanguageChange(a1, v22, v31, v6, a3);
  v29 = *(void (**)(char *, _QWORD))(a1 + 2640);
  if (v29)
    v29(a3, *(_QWORD *)(a1 + 2648));
  return 0;
}

uint64_t SSMLElement_LEXICON_Enter(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned __int16 v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  void (*v14)(uint64_t, _QWORD);
  char *v15;
  char *v16;
  void (*v17)(uint64_t, _QWORD);
  const char *v18;
  size_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char __s[16];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  v32 = 0;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  *(_OWORD *)__s = 0u;
  v34 = 0u;
  if (CheckTagBond(a1, &v32))
  {
    *(_DWORD *)(a1 + 2084) = -1919926670;
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  v7 = XMLGetStack(a1, "tagOrder");
  if (!v7)
  {
    result = 2375032834;
LABEL_11:
    *(_DWORD *)(a1 + 2084) = result;
    return result;
  }
  if ((tinystack_View(v7, &v31) & 0x80000000) == 0 && v31 == 13)
  {
    v8 = 15986;
LABEL_10:
    result = v8 | 0x8D900000;
    goto LABEL_11;
  }
  if (*(_QWORD *)(a1 + 14376) == 63)
  {
LABEL_9:
    v8 = 8201;
    goto LABEL_10;
  }
  v9 = *a2;
  if (!*a2)
    goto LABEL_34;
  v10 = 0;
  v30 = 0;
  v11 = 0;
  do
  {
    if (!LH_stricmp(v9, "uri"))
      v11 = v10 + 1;
    v12 = a2[v10];
    if (v12)
    {
      if (!SSMLstricmp(a1, v12, "base") || !SSMLstricmp(a1, a2[v10], "xml:base"))
      {
        v13 = a2[v10 + 1];
        if (v13)
        {
          UrlSetBaseURI(a1, v13);
          v14 = *(void (**)(uint64_t, _QWORD))(a1 + 2640);
          if (v14)
            v14(a3, *(_QWORD *)(a1 + 2648));
        }
      }
      v15 = a2[v10];
      if (v15)
      {
        if (!SSMLstricmp(a1, v15, "type"))
        {
          v16 = a2[v10 + 1];
          if (v16)
          {
            v17 = *(void (**)(uint64_t, _QWORD))(a1 + 2640);
            if (v17)
              v17(a3, *(_QWORD *)(a1 + 2648));
            v30 = v16;
          }
        }
      }
    }
    v9 = a2[v10 + 2];
    v10 += 2;
  }
  while (v9);
  if (!v11)
  {
LABEL_34:
    result = 2375040625;
    goto LABEL_11;
  }
  v18 = *(const char **)(a1 + 13320);
  if (v18)
  {
    v19 = strlen(*(const char **)(a1 + 13320));
    v20 = a2[v11];
    if (strlen(v20) + v19 >= 0x1FF)
      goto LABEL_9;
  }
  else
  {
    v20 = a2[v11];
  }
  UriCompleteUrl(v18, v20, __s);
  ELQSubstituteEntitiesUTF8(__s, 1);
  v25 = *(_QWORD *)(a1 + 13344);
  if (v25)
  {
    if (!v30 || !*v30)
      determineMediaType(__s);
    if (((*(uint64_t (**)(_QWORD, _QWORD))(v25 + 72))(*(_QWORD *)(a1 + 13328), *(_QWORD *)(a1 + 13336)) & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1448, "%s%s", v26, v27, v28, v29, "lexicon");
      return 0;
    }
    else
    {
      result = 0;
      ++*(_QWORD *)(a1 + 14376);
    }
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1448, "%s%s", v21, v22, v23, v24, "lexicon");
    return 2375032857;
  }
  return result;
}

uint64_t SSMLstricmp(uint64_t a1, char *__s, char *a3)
{
  char *v4;
  char *v5;
  char *v6;
  int v7;

  if (!__s || !a3)
    return 0xFFFFFFFFLL;
  v4 = __s;
  v5 = strchr(__s, *(char *)(a1 + 12968));
  if (v5)
  {
    v7 = *v5;
    v6 = v5 + 1;
    if (v7)
      v4 = v6;
  }
  return LH_stricmp(v4, a3);
}

uint64_t UrlSetBaseURI(uint64_t result, char *__s1)
{
  uint64_t v3;
  const char *v4;
  size_t v5;

  v3 = result;
  v4 = *(const char **)(result + 13320);
  if (v4)
  {
    if (__s1)
    {
      result = strcmp(__s1, v4);
      if (!(_DWORD)result)
        return result;
    }
  }
  else if (!__s1 || !*__s1)
  {
    return result;
  }
  result = (uint64_t)heap_Free(*(_QWORD **)(*(_QWORD *)(v3 + 12992) + 8), (uint64_t)v4);
  if (__s1 && *__s1)
  {
    v5 = strlen(__s1);
    result = heap_Alloc(*(_QWORD *)(*(_QWORD *)(v3 + 12992) + 8), v5 + 1);
    *(_QWORD *)(v3 + 13320) = result;
    if (result)
      return (uint64_t)strcpy((char *)result, __s1);
  }
  else
  {
    *(_QWORD *)(v3 + 13320) = 0;
  }
  return result;
}

uint64_t SSMLSaveOnLangFailureIntoStack(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = XMLGetStack(a1, "onlangfailure");
  if (!v4)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    return ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
  }
  result = tinystack_Push(v4, a2);
  if ((result & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    return ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
  }
  return result;
}

uint64_t NormalizeLangCode(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v5;
  BOOL v6;
  uint64_t v8;
  int v9;

  v2 = a2;
  v9 = 1;
  v8 = 0;
  v3 = a1[1798];
  if (v3
    && ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t *, int *, _QWORD))(v3 + 32))(a1[1799], a1[1800], a2, 0, &v8, &v9, 0) & 0x80000000) == 0)
  {
    v5 = v9;
    if (v9)
    {
      v6 = 1;
    }
    else
    {
      v6 = (*(int (**)(_QWORD, _QWORD, uint64_t, uint64_t *, int *))(a1[1798] + 40))(a1[1799], a1[1800], v2, &v8, &v9) >= 0;
      v5 = v9;
    }
    if (v6 && v5 != 0)
      return v8;
  }
  return v2;
}

uint64_t aux_SetActiveLanguage(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  _BYTE v10[512];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = a1 + 13128;
  v7 = strchr((char *)(a1 + 13128), 58);
  v8 = v7;
  if (a2)
  {
    __strcpy_chk();
    if (!a3)
    {
LABEL_6:
      if (!v8)
        return __strcpy_chk();
      goto LABEL_10;
    }
  }
  else if (v7)
  {
    __strncpy_chk();
    v10[(_QWORD)&v8[-v6]] = 0;
    if (!a3)
      goto LABEL_6;
  }
  else
  {
    __strcpy_chk();
    if (!a3)
      return __strcpy_chk();
  }
  if (!SSMLstricmp(a1, a3, "no"))
LABEL_10:
    __strcat_chk();
  return __strcpy_chk();
}

uint64_t XMLGetStack(uint64_t a1, char *a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;

  result = 0;
  if (a1 && a2)
  {
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
    {
      v5 = a1 + 16;
      if (*(_QWORD *)(a1 + 16))
      {
        if (!LH_stricmp(*(char **)(a1 + 24), a2))
          return *(_QWORD *)v5;
        v6 = 1;
        while (1)
        {
          v7 = a1 + 24 * v6;
          v8 = *(_QWORD *)(v7 + 16);
          v5 = v7 + 16;
          if (!v8)
            break;
          v9 = v6;
          v10 = LH_stricmp(*(char **)(a1 + 24 * v6 + 24), a2);
          v6 = v9 + 1;
          if (!v10)
            return *(_QWORD *)v5;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t CheckTagBond(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  result = XMLGetStack(a1, "TagBond");
  if (result)
  {
    v4 = 0;
    if ((tinystack_View(result, &v4) & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      *a2 = v4;
      return 1;
    }
  }
  return result;
}

_QWORD *ReleaseTagBond(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  v3 = 0;
  result = (_QWORD *)XMLGetStack(a1, "TagBond");
  if (result)
  {
    result = (_QWORD *)tinystack_Pop((uint64_t)result, &v3);
    if (v3)
      return heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 12992) + 8), v3);
  }
  return result;
}

uint64_t XMLGetCurrentValue(uint64_t a1)
{
  uint64_t v3;
  unsigned int v4;

  if (!a1)
    return -1;
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni
    || !*(_QWORD *)(a1 + 16))
  {
    return -1;
  }
  v3 = 0;
  v4 = 1;
  while (LH_stricmp(*(char **)(a1 + 24 * v3 + 24), "metadata"))
  {
    v3 = v4;
    if (!*(_QWORD *)(a1 + 24 * v4++ + 16))
      return -1;
  }
  return *(_QWORD *)(a1 + 24 * v3 + 32);
}

uint64_t SSMLPushProsodicParameters(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char __src[20];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = XMLGetStack(a1, "volume");
  if (v2)
  {
    v3 = v2;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1560));
    result = (uint64_t)ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (!result)
      return result;
    tinystack_Push(v3, result);
  }
  v5 = XMLGetStack(a1, "pitch");
  if (v5)
  {
    v6 = v5;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1564));
    result = (uint64_t)ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (!result)
      return result;
    tinystack_Push(v6, result);
  }
  v7 = XMLGetStack(a1, "timbre");
  if (v7)
  {
    v8 = v7;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 2088));
    result = (uint64_t)ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (!result)
      return result;
    tinystack_Push(v8, result);
  }
  result = XMLGetStack(a1, "speed");
  if (result)
  {
    v9 = result;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1568));
    result = (uint64_t)ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (result)
      return tinystack_Push(v9, result);
  }
  return result;
}

uint64_t ParseAttribute(uint64_t a1, char *a2, int a3)
{
  int v5;
  int v6;
  int v7;
  int v8;
  float v9;
  double v10;
  int v11;
  double v12;
  float v13;
  double v14;
  unsigned int v15;
  uint64_t result;
  float v17;
  double v18;
  int v19;
  float v20;
  double v21;
  unsigned int v22;
  int v23;
  void (*v24)(char *, _QWORD);
  char *v25;
  char v26[512];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v26[0] = 0;
  if (!*a2)
    return 0;
  v25 = 0;
  switch(a3)
  {
    case 1:
      if (LH_stricmp(a2, "silent"))
      {
        if (LH_stricmp(a2, "x-soft"))
        {
          if (LH_stricmp(a2, "soft"))
          {
            if (!LH_stricmp(a2, "medium"))
            {
LABEL_10:
              v5 = 80;
              goto LABEL_83;
            }
            if (LH_stricmp(a2, "loud"))
            {
              if (LH_stricmp(a2, "x-loud"))
              {
                if (LH_stricmp(a2, "default"))
                  goto LABEL_84;
                goto LABEL_10;
              }
              v5 = 100;
            }
            else
            {
              v5 = 90;
            }
          }
          else
          {
            v5 = 53;
          }
        }
        else
        {
          v5 = 26;
        }
      }
      else
      {
        v5 = 0;
      }
LABEL_83:
      *(_DWORD *)(a1 + 1560) = v5;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\vol=%d\\", v5);
LABEL_84:
      if (!v26[0])
      {
        v20 = strtod(a2, &v25);
        if (*v25 == 37)
        {
          v21 = (float)(v20 * (float)*(int *)(a1 + 1560)) / 100.0 + (double)*(int *)(a1 + 1560);
          v22 = (int)v21 & ~((int)v21 >> 31);
          if (v22 >= 0x64)
            v22 = 100;
        }
        else
        {
          v23 = (int)v20;
          if ((int)v20 >= 100)
            v23 = 100;
          v22 = v23 & ~(v23 >> 31);
        }
        *(_DWORD *)(a1 + 1560) = v22;
        __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\vol=%d\\");
      }
      goto LABEL_92;
    case 2:
      if (LH_stricmp(a2, "x-fast"))
      {
        if (LH_stricmp(a2, "fast"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_17:
            v6 = 100;
            goto LABEL_46;
          }
          if (LH_stricmp(a2, "slow"))
          {
            if (LH_stricmp(a2, "x-slow"))
            {
              if (LH_stricmp(a2, "default"))
                goto LABEL_47;
              goto LABEL_17;
            }
            v6 = 50;
          }
          else
          {
            v6 = 75;
          }
        }
        else
        {
          v6 = 150;
        }
      }
      else
      {
        v6 = 200;
      }
LABEL_46:
      *(_DWORD *)(a1 + 1568) = v6;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\rate=%d\\", v6);
LABEL_47:
      if (v26[0])
        goto LABEL_92;
      v9 = strtod(a2, &v25);
      if (*v25 == 37)
      {
        v10 = (float)(v9 * (float)*(int *)(a1 + 1568)) / 100.0 + (double)*(int *)(a1 + 1568);
        v11 = (int)v10 & ~((int)v10 >> 31);
        if (v11 >= 0xC8)
          v11 = 200;
        if (v11 <= 0x32)
          v11 = 50;
      }
      else
      {
        if (v9 < 0.0)
          return 0;
        v11 = (int)(float)(v9 * (float)*(int *)(a1 + 1568));
        if (v11 >= 200)
          v11 = 200;
        if (v11 <= 50)
          v11 = 50;
      }
      *(_DWORD *)(a1 + 1568) = v11;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\rate=%d\\");
      goto LABEL_92;
    case 3:
      if (LH_stricmp(a2, "x-high"))
      {
        if (LH_stricmp(a2, "high"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_24:
            v7 = 100;
            goto LABEL_60;
          }
          if (LH_stricmp(a2, "low"))
          {
            if (LH_stricmp(a2, "x-low"))
            {
              if (LH_stricmp(a2, "default"))
                goto LABEL_61;
              goto LABEL_24;
            }
            v7 = 70;
          }
          else
          {
            v7 = 85;
          }
        }
        else
        {
          v7 = 135;
        }
      }
      else
      {
        v7 = 160;
      }
LABEL_60:
      *(_DWORD *)(a1 + 1564) = v7;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\pitch=%d\\", v7);
LABEL_61:
      if (v26[0])
        goto LABEL_92;
      v12 = strtod(a2, &v25);
      if (*v25 != 37)
        return 0;
      v13 = v12;
      v14 = (float)(v13 * (float)*(int *)(a1 + 1564)) / 100.0 + (double)*(int *)(a1 + 1564);
      v15 = (int)v14 & ~((int)v14 >> 31);
      if (v15 >= 0xC8)
        v15 = 200;
      if (v15 <= 0x32)
        v15 = 50;
      *(_DWORD *)(a1 + 1564) = v15;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\pitch=%d\\");
      goto LABEL_92;
    case 4:
      if (LH_stricmp(a2, "x-young"))
      {
        if (LH_stricmp(a2, "young"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_31:
            v8 = 100;
            goto LABEL_70;
          }
          if (LH_stricmp(a2, "old"))
          {
            if (LH_stricmp(a2, "x-old"))
            {
              if (LH_stricmp(a2, "default"))
                goto LABEL_71;
              goto LABEL_31;
            }
            v8 = 65;
          }
          else
          {
            v8 = 80;
          }
        }
        else
        {
          v8 = 120;
        }
      }
      else
      {
        v8 = 135;
      }
LABEL_70:
      *(_DWORD *)(a1 + 2088) = v8;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\timbre=%d\\", v8);
LABEL_71:
      if (!v26[0])
      {
        v17 = strtod(a2, &v25);
        if (*v25 == 37)
        {
          v18 = (float)(v17 * (float)*(int *)(a1 + 2088)) / 100.0 + (double)*(int *)(a1 + 2088);
          v19 = (int)v18 & ~((int)v18 >> 31);
          if (v19 >= 0xC8)
            v19 = 200;
          if (v19 <= 0x32)
            v19 = 50;
        }
        else
        {
          v19 = (int)v17;
          if ((int)v17 >= 200)
            v19 = 200;
          if (v19 <= 50)
            v19 = 50;
        }
        *(_DWORD *)(a1 + 2088) = v19;
        __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\timbre=%d\\");
      }
LABEL_92:
      v24 = *(void (**)(char *, _QWORD))(a1 + 2640);
      if (v24)
        v24(v26, *(_QWORD *)(a1 + 2648));
      result = 1;
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t SSMLViewOnLangFailureFromStack(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v10 = 0;
  v4 = XMLGetStack(a1, "onlangfailure");
  if (v4)
  {
    tinystack_View(v4, &v10);
    result = 0;
    *a2 = v10;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  return result;
}

uint64_t SSMLGetLangFailureCode(char *a1)
{
  uint64_t result;

  result = LH_stricmp(a1, "changevoice");
  if ((_DWORD)result)
  {
    if (LH_stricmp(a1, "ignoretext"))
    {
      if (LH_stricmp(a1, "ignorelang"))
        return 3;
      else
        return 2;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t SSMLPushVoice(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = XMLGetStack(a1, "voice");
  if (result)
  {
    v3 = result;
    result = (uint64_t)ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 13000), 0);
    if (result)
      return tinystack_Push(v3, result);
  }
  return result;
}

uint64_t SSMLPushLanguage(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = XMLGetStack(a1, "language");
  if (result)
  {
    v3 = result;
    result = (uint64_t)ELQMemorySlotSave(*(_QWORD *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 13128), 0);
    if (result)
      return tinystack_Push(v3, result);
  }
  return result;
}

uint64_t SSMLOnLanguageChange(uint64_t result, uint64_t a2, char *a3, int a4, char *a5)
{
  uint64_t v8;
  uint64_t (*v9)(char *, _QWORD);
  uint64_t v10;
  uint64_t (*v11)(char *, _QWORD);
  __int16 v12[512];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a2 | (unint64_t)a3 && a4 != 1)
  {
    v8 = result;
    if (a4)
    {
      if (a2)
        v10 = NormalizeLangCode((_QWORD *)result, a2);
      else
        v10 = 0;
      aux_SetActiveLanguage(v8, v10, a3);
      result = sprintf(a5, "\x1B\\lang=%s\\", (const char *)(v8 + 13128));
      v11 = *(uint64_t (**)(char *, _QWORD))(v8 + 2640);
      if (v11)
        return v11(a5, *(_QWORD *)(v8 + 2648));
    }
    else
    {
      if (a2)
      {
        v12[0] = 40;
        __strcat_chk();
        __strcat_chk();
        __strcat_chk();
        sprintf(a5, "\x1B\\voice=%s\\", (const char *)v12);
        result = aux_SetActiveLanguage(v8, a2, a3);
      }
      v9 = *(uint64_t (**)(char *, _QWORD))(v8 + 2640);
      if (v9)
        return v9(a5, *(_QWORD *)(v8 + 2648));
    }
  }
  return result;
}

uint64_t NewTagBond(uint64_t a1, const char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *(_QWORD *)(a1 + 12992);
  v5 = XMLGetStack(a1, "TagBond");
  if (v5)
  {
    v10 = v5;
    v11 = (char *)heap_Alloc(*(_QWORD *)(v4 + 8), 32);
    if (v11)
    {
      v16 = (uint64_t)v11;
      strcpy(v11, a2);
      if ((tinystack_Push(v10, v16) & 0x80000000) == 0)
        return 0;
    }
    log_OutPublic(*(_QWORD *)(v4 + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934454;
    strcpy((char *)(a1 + 2104), "Out of Memory");
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
  }
  ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
  return *(unsigned int *)(a1 + 2084);
}

uint64_t Emphasis2Prosody(uint64_t a1, char *a2)
{
  float64x2_t v4;
  int v5;
  uint32x2_t *v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  unsigned int v11;
  int64x2_t v12;

  SSMLPushProsodicParameters(a1);
  if (a2 && *a2 && LH_stricmp(a2, "moderate"))
  {
    if (LH_stricmp(a2, "strong"))
    {
      if (LH_stricmp(a2, "reduced"))
      {
        LH_stricmp(a2, "none");
        return OutProsodyTags(a1);
      }
      v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      v5 = (int)((float)((float)*(int *)(a1 + 1560) * -10.0) / 100.0 + (double)*(int *)(a1 + 1560));
      v6 = (uint32x2_t *)(a1 + 1564);
      v7 = *(int32x2_t *)(a1 + 1564);
      v8 = vcvt_f32_s32(v7);
      v9 = (float32x2_t)0x41200000C1200000;
    }
    else
    {
      v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      v5 = (int)((float)((float)*(int *)(a1 + 1560) * 20.0) / 100.0 + (double)*(int *)(a1 + 1560));
      v6 = (uint32x2_t *)(a1 + 1564);
      v7 = *(int32x2_t *)(a1 + 1564);
      v8 = vcvt_f32_s32(v7);
      v9 = (float32x2_t)0xC1F0000041A00000;
    }
  }
  else
  {
    v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
    v5 = (int)((float)((float)*(int *)(a1 + 1560) * 15.0) / 100.0 + (double)*(int *)(a1 + 1560));
    v6 = (uint32x2_t *)(a1 + 1564);
    v7 = *(int32x2_t *)(a1 + 1564);
    v8 = vcvt_f32_s32(v7);
    v9 = (float32x2_t)0xC1A0000041700000;
  }
  v10 = vmul_f32(v8, v9);
  v11 = v5 & ~(v5 >> 31);
  if (v11 >= 0x64)
    v11 = 100;
  *(_DWORD *)(a1 + 1560) = v11;
  v12.i64[0] = v7.i32[0];
  v12.i64[1] = v7.i32[1];
  *v6 = vmax_u32(vmin_u32((uint32x2_t)vmax_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64(vdivq_f64(vcvtq_f64_f32(v10), v4), vcvtq_f64_s64(v12)))), 0), (uint32x2_t)0xC8000000C8), (uint32x2_t)0x3200000032);
  return OutProsodyTags(a1);
}

uint64_t OutProsodyTags(uint64_t a1)
{
  void (*v2)(char *, _QWORD);
  void (*v3)(char *, _QWORD);
  void (*v4)(char *, _QWORD);
  uint64_t result;
  uint64_t (*v6)(char *, _QWORD);
  char v7[64];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\rate=%d\\", *(_DWORD *)(a1 + 1568));
  v2 = *(void (**)(char *, _QWORD))(a1 + 2640);
  if (v2)
    v2(v7, *(_QWORD *)(a1 + 2648));
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\pitch=%d\\", *(_DWORD *)(a1 + 1564));
  v3 = *(void (**)(char *, _QWORD))(a1 + 2640);
  if (v3)
    v3(v7, *(_QWORD *)(a1 + 2648));
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\timbre=%d\\", *(_DWORD *)(a1 + 2088));
  v4 = *(void (**)(char *, _QWORD))(a1 + 2640);
  if (v4)
    v4(v7, *(_QWORD *)(a1 + 2648));
  result = __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\vol=%d\\", *(_DWORD *)(a1 + 1560));
  v6 = *(uint64_t (**)(char *, _QWORD))(a1 + 2640);
  if (v6)
    return v6(v7, *(_QWORD *)(a1 + 2648));
  return result;
}

uint64_t ApplyCurrentStyle(uint64_t a1, char *a2)
{
  void (*v4)(char *, _QWORD);

  sprintf(a2, "\x1B\\style=%s\\", (const char *)(a1 + 1572));
  v4 = *(void (**)(char *, _QWORD))(a1 + 2640);
  if (v4 && *a2)
  {
    v4(a2, *(_QWORD *)(a1 + 2648));
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

char *determineMediaType(char *__s)
{
  const char *v1;
  uint64_t v2;
  const char *v3;
  size_t v4;
  size_t v5;
  const char *v6;
  size_t v8;

  if (__s)
  {
    v1 = __s;
    v2 = 0;
    while (1)
    {
      v3 = ExtensionMimeTypeMap[2 * v2];
      if (v3)
      {
        v4 = strlen(v1);
        v5 = strlen(v3);
        v6 = &v1[v4 - v5];
        if (v5 <= v4 && v6 >= v1)
          break;
      }
LABEL_12:
      if (++v2 == 8)
        return 0;
    }
    v8 = v5;
    while (strncmp(v6, v3, v8))
    {
      if (--v6 < v1)
        goto LABEL_12;
    }
    return ExtensionMimeTypeMap[2 * v2 + 1];
  }
  return __s;
}

uint64_t SSML10EndConvert(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  void (*v16)(char *, _QWORD);
  char v17[512];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!SSMLstricmpElement(a1, a2, "prosody"))
    goto LABEL_18;
  if (!SSMLstricmpElement(a1, a2, "p"))
  {
    v5 = a1;
    v6 = 1;
    return SSMLElement_Block_Exit(v5, v17, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "s"))
  {
    v5 = a1;
    v6 = 0;
    return SSMLElement_Block_Exit(v5, v17, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "lang"))
  {
    v5 = a1;
    v6 = 2;
    return SSMLElement_Block_Exit(v5, v17, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "emphasis"))
  {
LABEL_18:
    SSMLPopProsodicParameters((_DWORD *)a1);
    return 0;
  }
  if (!SSMLstricmpElement(a1, a2, "break"))
    return 0;
  if (!SSMLstricmpElement(a1, a2, "phoneme"))
  {
    v4 = 2375032842;
    v9 = *(_QWORD *)(a1 + 12992);
    v11 = *(_QWORD *)(v9 + 8);
    v10 = (uint64_t **)(v9 + 8);
    v12 = (_QWORD *)heap_Alloc(v11, 24);
    if (!v12)
      return v4;
    v13 = v12;
    *v12 = v10;
    v12[1] = 0;
    v12[2] = 0;
    v14 = strhelper_StringAppend(*v10, 0, *(char **)(*(_QWORD *)(a1 + 13264) + 8), 0xFFFFFFFFFFFFFFFFLL, v12 + 2, 0x80uLL);
    v13[1] = v14;
    if (!v14)
      return v4;
    v15 = SSMLElement_PHONEME_Exit(a1, v14);
    DynStringDestroy((_QWORD ***)v13);
    return v15;
  }
  if (!SSMLstricmpElement(a1, a2, "sub"))
    return SSMLElement_SUB_Exit(a1);
  if (!SSMLstricmpElement(a1, a2, "say-as"))
    return SSMLElement_SAYAS_Exit(a1, v17);
  if (!SSMLstricmpElement(a1, a2, "voice"))
  {
    SSMLElement_VOICE_Exit(a1, v17);
    return 0;
  }
  if (!SSMLstricmpElement(a1, a2, "speak"))
    return SSMLElement_SPEAK_Exit(a1, v17);
  if (!SSMLstricmpElement(a1, a2, "audio"))
    return SSMLElement_AUDIO_Exit(a1);
  if (!SSMLstricmpElement(a1, a2, "style"))
    return SSMLElement_STYLE_Exit(a1, v17);
  if (!SSMLstricmpElement(a1, a2, "desc"))
  {
    v16 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v16)
      v16(v17, *(_QWORD *)(a1 + 2648));
    return 0;
  }
  if (SSMLstricmpElement(a1, a2, "meta") && SSMLstricmpElement(a1, a2, "metadata"))
  {
    SSMLstricmpElement(a1, a2, "lexicon");
    return 0;
  }
  return SSMLElement_META_Exit(a1);
}

uint64_t SSMLElement_Block_Exit(uint64_t a1, char *a2, int a3)
{
  _BYTE *v6;
  void (*v7)(char *, _QWORD);
  uint64_t v8;
  int v9;
  const char *v10;
  void (*v11)(char *, _QWORD);
  uint64_t v12;
  void (*v13)(char *, _QWORD);
  uint64_t v15;
  void (*v16)(char *, _QWORD);
  int v17;
  const char *v18;
  char v19[80];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = *(_DWORD *)(a1 + 2716);
  v6 = (_BYTE *)(a1 + 13196);
  if (*(_BYTE *)(a1 + 13196))
  {
    strcpy(a2, "\x1B\\domain\\");
    v7 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v7)
      v7(a2, *(_QWORD *)(a1 + 2648));
    *v6 = 0;
  }
  v8 = SSMLViewOnLangFailureFromStack(a1, &v17);
  if (!(_DWORD)v8)
  {
    v9 = v17;
    if (v17 == 4)
      v9 = *(_DWORD *)(a1 + 2716);
    if (a3 == 1)
    {
      a2[8] = 0;
      v10 = "\n\x1B\\para\\";
    }
    else
    {
      if (a3)
      {
LABEL_14:
        if (!v9)
        {
          v15 = XMLGetStack(a1, "voice");
          if (v15)
          {
            v18 = 0;
            tinystack_Pop(v15, &v18);
            if (v18)
            {
              __strcpy_chk();
              __sprintf_chk(v19, 0, 0x50uLL, "\x1B\\voice=%s\\", v18);
              v16 = *(void (**)(char *, _QWORD))(a1 + 2640);
              if (v16)
                v16(v19, *(_QWORD *)(a1 + 2648));
            }
          }
        }
        v12 = XMLGetStack(a1, "language");
        if (v12)
        {
          v18 = 0;
          tinystack_Pop(v12, &v18);
          if (v18)
          {
            __strcpy_chk();
            __sprintf_chk(v19, 0, 0x50uLL, "\x1B\\lang=%s\\", v18);
            v13 = *(void (**)(char *, _QWORD))(a1 + 2640);
            if (v13)
              v13(v19, *(_QWORD *)(a1 + 2648));
          }
        }
        v8 = SSMLRemoveOnLangFailureFromStack(a1);
        ReleaseTagBond(a1);
        return v8;
      }
      a2[8] = 0;
      v10 = "\x1B\\eos=1\\";
    }
    *(_QWORD *)a2 = *(_QWORD *)v10;
    v11 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v11)
      v11(a2, *(_QWORD *)(a1 + 2648));
    goto LABEL_14;
  }
  return v8;
}

uint64_t SSMLElement_PHONEME_Exit(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int v14;
  char v15;
  unsigned __int8 *v16;
  int v17;
  const char *v18;
  void (*v19)(char *, _QWORD);
  void (*v20)(char *, _QWORD);
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;

  v30 = 0;
  v31 = 0;
  v4 = XMLGetStack(a1, "auxiliary");
  if (!v4)
    goto LABEL_31;
  tinystack_Pop(v4, &v31);
  if ((v31 & 8) != 0)
  {
    v11 = XMLGetStack(a1, "phon");
    if (v11)
    {
      tinystack_Pop(v11, &v30);
      v10 = (v30 & 0xE0) == 0;
      v9 = v30 & 1;
      goto LABEL_6;
    }
LABEL_31:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v9 = 0;
  v10 = 1;
LABEL_6:
  v12 = *(_QWORD *)(a1 + 13272);
  v13 = *(char **)(v12 + 8);
  if (!v13)
    goto LABEL_20;
  v14 = strncmp(*(const char **)(v12 + 8), ":\"", 2uLL);
  if (!v14)
  {
    v13 = strhelper_StringAppend(**(uint64_t ***)v12, v13, "\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v12 + 16), 0x80uLL);
    *(_QWORD *)(v12 + 8) = v13;
    if (!v13)
      goto LABEL_20;
  }
  if (v10 && *v13)
  {
    if (v9)
    {
      if (!v14)
      {
        v15 = v13[1];
        if (v15)
        {
          v16 = (unsigned __int8 *)(v13 + 2);
          do
          {
            if (memchr(".:,;?!()", v15, 9uLL))
              *(v16 - 1) = 32;
            v17 = *v16++;
            v15 = v17;
          }
          while (v17);
        }
      }
    }
    (*(void (**)(char *, _QWORD))(a1 + 2640))(v13, *(_QWORD *)(a1 + 2648));
  }
  if (!v14)
  {
LABEL_20:
    *(_WORD *)a2 = 92;
    v18 = *(const char **)(*(_QWORD *)(a1 + 13264) + 8);
    if (v18)
      strcat(a2, v18);
    v19 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v19)
      v19(a2, *(_QWORD *)(a1 + 2648));
    strcpy(a2, "\x1B\\toi=orth\\");
    v20 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v20)
      v20(a2, *(_QWORD *)(a1 + 2648));
  }
  v21 = *(_QWORD *)(a1 + 13264);
  v24 = *(_QWORD *)(v21 + 8);
  v23 = (_QWORD *)(v21 + 8);
  v22 = v24;
  if (v24)
    heap_Free(***(_QWORD ****)(a1 + 13264), v22);
  *v23 = 0;
  v23[1] = 0;
  v25 = *(_QWORD *)(a1 + 13272);
  v28 = *(_QWORD *)(v25 + 8);
  v27 = (_QWORD *)(v25 + 8);
  v26 = v28;
  if (v28)
    heap_Free(***(_QWORD ****)(a1 + 13272), v26);
  *v27 = 0;
  v27[1] = 0;
  ReleaseTagBond(a1);
  return 0;
}

uint64_t SSMLElement_SUB_Exit(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  ReleaseTagBond(a1);
  v2 = XMLGetStack(a1, "auxiliary");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLElement_SAYAS_Exit(uint64_t a1, char *a2)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v12)(char *, _QWORD);
  const char *v13;

  v4 = (_BYTE *)(a1 + 13164);
  *(_BYTE *)(a1 + 13280) = 0;
  *(_DWORD *)(a1 + 13312) = 0;
  v5 = XMLGetStack(a1, "say-as");
  if (!v5)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  v13 = 0;
  v10 = *v4;
  tinystack_Pop(v5, &v13);
  if (v13)
  {
    __strcpy_chk();
    if (*v4 == 95)
      ++v13;
    if (v10 != 95)
    {
      sprintf(a2, "\x1B\\tn=%s\\", v13);
      goto LABEL_10;
    }
LABEL_9:
    strcpy(a2, "\x1B\\slotend\\");
LABEL_10:
    v12 = *(void (**)(char *, _QWORD))(a1 + 2640);
    if (v12)
      v12(a2, *(_QWORD *)(a1 + 2648));
    goto LABEL_12;
  }
  if (v10 == 95)
    goto LABEL_9;
LABEL_12:
  ReleaseTagBond(a1);
  return 0;
}

uint64_t SSMLElement_VOICE_Exit(uint64_t a1, char *a2)
{
  uint64_t result;
  uint64_t (*v5)(char *, _QWORD);

  result = sprintf(a2, "\x1B\\voice=%s\\", "(pop)");
  v5 = *(uint64_t (**)(char *, _QWORD))(a1 + 2640);
  if (v5)
    return v5(a2, *(_QWORD *)(a1 + 2648));
  return result;
}

uint64_t SSMLElement_SPEAK_Exit(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(char *, _QWORD);
  uint64_t v10;

  v8 = SSMLRemoveOnLangFailureFromStack(a1);
  if ((_DWORD)v8)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1297, "%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = v8;
    strcpy((char *)(a1 + 2104), "Error retrieving OnLangFailure attribute");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
  }
  else
  {
    if (*(_BYTE *)(a1 + 13228))
    {
      strcpy(a2, "\x1B\\domain\\");
      v9 = *(void (**)(char *, _QWORD))(a1 + 2640);
      if (v9)
        v9(a2, *(_QWORD *)(a1 + 2648));
      *(_BYTE *)(a1 + 13228) = 0;
    }
    v10 = *(_QWORD *)(a1 + 13320);
    if (v10)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 12992) + 8), v10);
      *(_QWORD *)(a1 + 13320) = 0;
    }
  }
  return v8;
}

uint64_t SSMLElement_AUDIO_Exit(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;

  v15 = 0;
  v2 = XMLGetStack(a1, "audio");
  if (v2 && (tinystack_Pop(v2, &v15), (v7 = XMLGetStack(a1, "auxiliary")) != 0))
  {
    tinystack_Pop(v7, &v15);
    v8 = *(_QWORD *)(a1 + 13272);
    v9 = *(char **)(v8 + 8);
    if (v9)
    {
      *(_QWORD *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, v9, "\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
      v8 = *(_QWORD *)(a1 + 13272);
      v9 = *(char **)(v8 + 8);
    }
    *(_QWORD *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, v9, "\\", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
    (*(void (**)(_QWORD, _QWORD))(a1 + 2640))(*(_QWORD *)(*(_QWORD *)(a1 + 13272) + 8), *(_QWORD *)(a1 + 2648));
    v10 = *(_QWORD *)(a1 + 13272);
    v13 = *(_QWORD *)(v10 + 8);
    v12 = (_QWORD *)(v10 + 8);
    v11 = v13;
    if (v13)
      heap_Free(***(_QWORD ****)(a1 + 13272), v11);
    *v12 = 0;
    v12[1] = 0;
    ReleaseTagBond(a1);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLElement_STYLE_Exit(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *__src;

  __src = 0;
  v4 = XMLGetStack(a1, "style");
  if (v4)
  {
    if ((tinystack_Pop(v4, &__src) & 0x80000000) == 0)
    {
      strncpy((char *)(a1 + 1572), __src, 0x200uLL);
      *(_BYTE *)(a1 + 2083) = 0;
      return ApplyCurrentStyle(a1, a2);
    }
    *(_DWORD *)(a1 + 2084) = -1919934460;
    strcpy((char *)(a1 + 2104), "Out of Memory");
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
  }
  ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
  return *(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_META_Exit(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  v2 = XMLGetStack(a1, "metadata");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLPopProsodicParameters(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v7;

  v7 = 0;
  v2 = XMLGetStack((uint64_t)a1, "volume");
  if (v2)
  {
    tinystack_Pop(v2, &v7);
    if (v7)
      a1[390] = atoi(v7);
  }
  v3 = XMLGetStack((uint64_t)a1, "speed");
  if (v3)
  {
    tinystack_Pop(v3, &v7);
    if (v7)
      a1[392] = atoi(v7);
  }
  v4 = XMLGetStack((uint64_t)a1, "pitch");
  if (v4)
  {
    tinystack_Pop(v4, &v7);
    if (v7)
      a1[391] = atoi(v7);
  }
  v5 = XMLGetStack((uint64_t)a1, "timbre");
  if (v5)
  {
    tinystack_Pop(v5, &v7);
    if (v7)
      a1[522] = atoi(v7);
  }
  return OutProsodyTags((uint64_t)a1);
}

uint64_t SSMLRemoveOnLangFailureFromStack(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  v2 = XMLGetStack(a1, "onLangFailure");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(_QWORD *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

char *SSMLFallbackStringHandler(char *result, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  char *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char v10[2];

  v3 = a3;
  v5 = result;
  v10[1] = 0;
  v6 = *((_QWORD *)result + 1659);
  if (*(_QWORD *)(v6 + 8))
  {
    if (!a3)
      return result;
  }
  else
  {
    result = strhelper_StringAppend(**(uint64_t ***)v6, 0, ":\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v6 + 16), 0x80uLL);
    *(_QWORD *)(v6 + 8) = result;
    if (!v3)
      return result;
  }
  do
  {
    v7 = *a2;
    if (v7 == 92 || v7 == 34)
    {
      v10[0] = 92;
      v8 = *((_QWORD *)v5 + 1659);
      *(_QWORD *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, *(char **)(v8 + 8), v10, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
      LOBYTE(v7) = *a2;
    }
    v10[0] = v7;
    v9 = *((_QWORD *)v5 + 1659);
    result = strhelper_StringAppend(**(uint64_t ***)v9, *(char **)(v9 + 8), v10, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v9 + 16), 0x80uLL);
    *(_QWORD *)(v9 + 8) = result;
    ++a2;
    --v3;
  }
  while (v3);
  return result;
}

uint64_t ExtractDate(char *__s, char *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, uint64_t a6, _BYTE *a7, unint64_t a8)
{
  unint64_t v12;
  uint64_t v13;
  unint64_t v16;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  unint64_t *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  char __dst[12];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  if (!a6)
  {
    if (!a3)
      return 0;
    *a3 = 0;
    if (!a4)
      return 0;
    *a4 = 0;
    if (!a5)
      return 0;
    *a5 = 9999;
    if (strlen(a2) > 0xC)
      return 0;
    strncpy(__dst, a2, 0xBuLL);
    __dst[11] = 0;
    if (!LH_stricmp(__s, "mdy"))
    {
      v18 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (v18)
      {
        *a4 = (int)LH_atoi(v18);
        *a7 = a2[v32 - 1];
      }
      v19 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (v19 && a2[v32 - 1] == *a7)
        *a3 = (int)LH_atoi(v19);
      goto LABEL_43;
    }
    if (LH_stricmp(__s, "dmy"))
    {
      if (!LH_stricmp(__s, "ymd"))
      {
        v24 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v24)
        {
          *a5 = (int)LH_atoi(v24);
          *a7 = a2[v32 - 1];
        }
        v25 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (!v25 || a2[v32 - 1] != *a7)
          goto LABEL_63;
        goto LABEL_49;
      }
      if (!LH_stricmp(__s, "ydm"))
      {
        v26 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v26)
        {
          *a5 = (int)LH_atoi(v26);
          *a7 = a2[v32 - 1];
        }
        v27 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v27)
          *a3 = (int)LH_atoi(v27);
        v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (!v22)
          goto LABEL_65;
        v28 = *a7;
        v23 = a4;
        if (a2[v32 - 1] != v28)
          goto LABEL_65;
        goto LABEL_64;
      }
      if (!LH_stricmp(__s, "ym"))
      {
        v29 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v29)
          *a5 = (int)LH_atoi(v29);
        goto LABEL_59;
      }
      if (!LH_stricmp(__s, "yd"))
      {
        v30 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v30)
          *a5 = (int)LH_atoi(v30);
        goto LABEL_63;
      }
      if (LH_stricmp(__s, "my"))
      {
        if (LH_stricmp(__s, "md"))
        {
          if (!LH_stricmp(__s, "dm"))
          {
            *a5 = 0;
            v31 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
            if (v31)
              *a3 = (int)LH_atoi(v31);
            goto LABEL_59;
          }
          if (LH_stricmp(__s, "y"))
          {
            if (LH_stricmp(__s, "m"))
            {
              if (LH_stricmp(__s, "d"))
                return 0;
              *a5 = 0;
LABEL_63:
              v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
              v23 = a3;
              if (!v22)
              {
LABEL_65:
                if (*a4 - 13 <= 0xFFFFFFFFFFFFFFF3 && strchr(__s, 109)
                  || *a3 - 32 <= 0xFFFFFFFFFFFFFFE0 && strchr(__s, 100)
                  || *a5 > 0x834)
                {
                  return 0;
                }
                return a2[v32] == 0;
              }
LABEL_64:
              *v23 = (int)LH_atoi(v22);
              goto LABEL_65;
            }
            *a5 = 0;
LABEL_59:
            v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
            v23 = a4;
            if (!v22)
              goto LABEL_65;
            goto LABEL_64;
          }
LABEL_43:
          v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
          v23 = a5;
          if (!v22)
            goto LABEL_65;
          goto LABEL_64;
        }
        *a5 = 0;
        v25 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (!v25)
          goto LABEL_63;
LABEL_49:
        *a4 = (int)LH_atoi(v25);
        goto LABEL_63;
      }
      v21 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (!v21)
        goto LABEL_43;
    }
    else
    {
      v20 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (v20)
      {
        *a3 = (int)LH_atoi(v20);
        *a7 = a2[v32 - 1];
      }
      v21 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (!v21 || a2[v32 - 1] != *a7)
        goto LABEL_43;
    }
    *a4 = (int)LH_atoi(v21);
    goto LABEL_43;
  }
  v12 = *a5;
  if (*a5 < a8 || v12 > 0x63)
  {
    if (v12 <= 0x63F && strchr(__s, 121))
      return 0;
  }
  else
  {
    v13 = 1900;
    if (v12 < 0x14)
      v13 = 2000;
    *a5 = v13 + v12;
  }
  if (*a3 < 0x1E)
    return 1;
  v16 = *a4;
  if (*a4 == 2)
    return 0;
  if (*a3 == 31 && v16 - 4 <= 7)
    return dword_1DECEA9F8[v16 - 4];
  else
    return 1;
}

uint64_t lightssml_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2375032833;
  result = 0;
  *a2 = &IlightssmlCtrl;
  return result;
}

uint64_t lightssml_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v22;
  uint64_t v23;

  v23 = 0;
  inited = InitRsrcFunction(a1, a2, &v23);
  if ((inited & 0x80000000) != 0)
    return inited;
  v5 = 2375032840;
  v6 = (_QWORD *)heap_Calloc(*(_QWORD **)(v23 + 8), 1, 40);
  if (!v6)
    return 2375032842;
  v7 = (uint64_t)v6;
  v8 = *(_QWORD *)(v23 + 8);
  v6[4] = 0;
  v6[1] = 0;
  v9 = v6 + 1;
  *v6 = 0;
  v10 = v23;
  v6[2] = v8;
  v6[3] = v10;
  v11 = critsec_ObjOpen(*(_QWORD *)(v10 + 16), *(_QWORD **)(v10 + 8), v6 + 4);
  v16 = v23;
  if (v11 < 0
    || (v17 = ELQXMLIniController(v23, (uint64_t)"LTTS7XML", (uint64_t)"./", *(_QWORD *)(v7 + 32)),
        *(_QWORD *)v7 = v17,
        v16 = v23,
        !v17))
  {
    v19 = 1664;
  }
  else
  {
    v18 = VoiceInfoIni(v9, v23);
    if ((v18 & 0x80000000) == 0)
    {
      v5 = v18;
      *(_QWORD *)a3 = v7;
      *(_DWORD *)(a3 + 8) = 47834;
      return v5;
    }
    v5 = 2375040626;
    v19 = 1455;
    v16 = v23;
  }
  log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"LIGHTSSML", v19, 0, v12, v13, v14, v15, v22);
  VoiceInfoDelete(*(uint64_t (***)())(v7 + 8));
  ELQXMLDeleteController(*(_QWORD **)v7);
  v20 = *(_QWORD *)(v7 + 32);
  if (v20)
    critsec_ObjClose(v20);
  heap_Free(*(_QWORD **)(v23 + 8), v7);
  return v5;
}

uint64_t lightssml_ClassClose(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = safeh_HandleCheck(a1, a2, 47834, 40);
  if ((v3 & 0x80000000) == 0)
  {
    if (a1)
    {
      VoiceInfoDelete(*(uint64_t (***)())(a1 + 8));
      ELQXMLDeleteController(*(_QWORD **)a1);
      v4 = *(_QWORD *)(a1 + 32);
      if (v4)
        critsec_ObjClose(v4);
      heap_Free(*(_QWORD **)(a1 + 16), a1);
    }
    else
    {
      return 2375032840;
    }
  }
  return v3;
}

uint64_t lightssml_ObjOpen(_QWORD *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t Object;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v38;
  uint64_t v39;

  v38 = 0;
  v39 = 0;
  v5 = 2375032840;
  if (!a5)
    return 2375032839;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v39);
  if ((inited & 0x80000000) == 0)
  {
    log_OutText(*(_QWORD *)(v39 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ObjOpen", v10, v11, v12, v38);
    v13 = safeh_HandleCheck((uint64_t)a1, a2, 47834, 40);
    if ((v13 & 0x80000000) != 0)
    {
      v35 = v13;
      log_OutPublic(*(_QWORD *)(v39 + 32), (uint64_t)"LIGHTSSML", 1152, 0, v14, v15, v16, v17, v38);
      v5 = v35;
    }
    else if (a1)
    {
      v18 = heap_Calloc(*(_QWORD **)(v39 + 8), 1, 128);
      if (v18)
      {
        v22 = v18;
        *(_QWORD *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 435;
        if ((objc_GetObject(*(_QWORD *)(v39 + 48), (uint64_t)"LANGCODECONVERTER", &v38) & 0x80000000) == 0)
        {
          v23 = v38;
          if (*(_BYTE *)v38 != 1 || (v24 = *(_QWORD *)(v38 + 8)) == 0)
          {
            objc_ReleaseObject(*(_QWORD *)(v39 + 48), (uint64_t)"LANGCODECONVERTER");
            v31 = v39;
            v5 = 2375032845;
            v34 = 2574;
LABEL_24:
            log_OutPublic(*(_QWORD *)(v31 + 32), (uint64_t)"LIGHTSSML", v34, 0, v26, v27, v28, v29, v38);
            lightssml_ObjClose(*(_QWORD *)a5, *(_QWORD *)(a5 + 8));
            *(_QWORD *)a5 = 0;
            *(_DWORD *)(a5 + 8) = 0;
            goto LABEL_25;
          }
          *(_QWORD *)(v22 + 32) = v24;
          *(_OWORD *)(v22 + 40) = *(_OWORD *)(v23 + 16);
        }
        Object = objc_GetObject(*(_QWORD *)(v39 + 48), (uint64_t)"SYNTHSTREAM", &v38);
        if ((Object & 0x80000000) != 0)
        {
          v36 = Object;
          v34 = 1154;
          v31 = v39;
          v5 = v36;
        }
        else
        {
          *(_QWORD *)(v22 + 56) = 0;
          *(_QWORD *)(v22 + 64) = 0;
          *(_QWORD *)(v22 + 72) = 0;
          *(_QWORD *)(v22 + 16) = v39;
          *(_DWORD *)(v22 + 80) = 65001;
          *(_QWORD *)(v22 + 24) = *(_QWORD *)(v38 + 8);
          *(_DWORD *)v22 = 0;
          *(_QWORD *)(v22 + 8) = a1;
          v30 = ELQXMLIniParser(*a1, 0);
          *(_QWORD *)(v22 + 64) = v30;
          v31 = v39;
          if (v30)
          {
            v32 = ELQMemorySlotInit(v39, 1024, 0);
            *(_QWORD *)(v22 + 72) = v32;
            v31 = v39;
            if (v32)
            {
              v33 = ELQSSMLIni(v39, (uint64_t *)(v22 + 56), *(_QWORD *)(v22 + 64), 0);
              if (!v33)
              {
                ELQSSMLSetMemorySlot(*(_QWORD *)(v22 + 56), *(_QWORD *)(v22 + 72));
                ELQSSMLSetVoiceInfo(*(_QWORD *)(v22 + 56), *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8));
                ELQSSMLSetLangCodeConverter(*(_QWORD *)(v22 + 56), *(_QWORD *)(v22 + 32), *(_QWORD *)(v22 + 40), *(_QWORD *)(v22 + 48));
                v5 = 0;
                *(_DWORD *)v22 = 1;
                goto LABEL_25;
              }
              v5 = v33 | 0x8D902000;
              v34 = 1664;
              v31 = v39;
            }
            else
            {
              v5 = 2375033096;
              v34 = 1923;
            }
          }
          else
          {
            v34 = 1459;
          }
        }
        goto LABEL_24;
      }
      v5 = 2375032842;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v39 + 32), (uint64_t)"LIGHTSSML", 1153, 0, v14, v15, v16, v17, v38);
    }
LABEL_25:
    log_OutText(*(_QWORD *)(v39 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ObjOpen", v19, v20, v21, v38);
    return v5;
  }
  return inited;
}

uint64_t lightssml_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;

  v3 = safeh_HandleCheck(a1, a2, 435, 128);
  v7 = 2375032840;
  if ((v3 & 0x80000000) == 0 && a1)
  {
    v8 = v3;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ObjClose", v4, v5, v6, v15);
    ELQSSMLDelete(*(_QWORD **)(a1 + 56));
    ELQXMLDeleteParser(*(_QWORD **)(a1 + 64));
    ELQMemorySlotDelete(*(_QWORD **)(a1 + 72));
    if (*(_QWORD *)(a1 + 24))
      objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48), (uint64_t)"SYNTHSTREAM");
    if (*(_QWORD *)(a1 + 32))
      v7 = objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48), (uint64_t)"LANGCODECONVERTER");
    else
      v7 = v8;
    *(_DWORD *)a1 = 0;
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_QWORD *)(v9 + 32);
    heap_Free(*(_QWORD **)(v9 + 8), a1);
    log_OutText(v10, (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ObjClose", v11, v12, v13, v16);
  }
  return v7;
}

uint64_t lightssml_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;

  v7 = 2375032840;
  if ((safeh_HandleCheck(a1, a2, 435, 128) & 0x80000000) == 0)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ProcessStart", v8, v9, v10, v27);
    if (*(_DWORD *)a1 == 1)
    {
      v15 = 0;
      *(_DWORD *)a1 = 3;
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
      *(_QWORD *)(a1 + 120) = 0;
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a1 + 24);
      do
      {
        v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 24) + 64))(a3, a4, 217, lightssml_ProcessStart_szSSML_INPUT_NAMES[v15], 0, 0, a1 + 96);
        if ((v16 & 0x80000000) == 0)
          break;
      }
      while (v15++ != 3);
      v21 = *(_QWORD *)(a1 + 16);
      if (v16 < 0)
      {
        log_OutText(*(_QWORD *)(v21 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessStart: no SSML to process", v17, v18, v19, v28);
        paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rulesetsfrommarkup", "0");
        return 0;
      }
      else
      {
        paramc_ParamSetStr(*(_QWORD *)(v21 + 40), (uint64_t)"rulesetsfrommarkup", "1");
        v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 24) + 64))(a3, a4, 217, "text/plain;charset=utf-8",
                0,
                1,
                a1 + 112);
        if ((v22 & 0x80000000) != 0)
        {
          return v22;
        }
        else
        {
          v7 = ELQSSMLSetOutputFunction(*(_QWORD *)(a1 + 56), (uint64_t)StringBuffer_Output, a1);
          if ((v7 & 0x80000000) == 0)
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessStart", v23, v24, v25, v28);
        }
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v11, v12, v13, v14, v28);
      return 2375032849;
    }
  }
  return v7;
}

uint64_t lightssml_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  char *v24;
  size_t v25;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char *v33;
  size_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  unsigned __int8 *v43;
  unsigned int v44;
  uint64_t v45;
  char v46[16];
  char __s[8];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v44 = 0;
  strcpy(__s, "<speak>");
  strcpy(v46, "</speak>");
  v42 = 0;
  v7 = safeh_HandleCheck(a1, a2, 435, 128);
  if ((v7 & 0x80000000) != 0)
    return 2375032840;
  v11 = v7;
  v45 = 0;
  v43 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_Process", v8, v9, v10, v39);
  if ((*(_DWORD *)a1 & 0xFFFFFFFE) != 2)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v12, v13, v14, v15, v40);
    v11 = 2375032849;
    goto LABEL_14;
  }
  *a5 = 2;
  if (!*(_QWORD *)(a1 + 96) || !*(_QWORD *)(a1 + 112))
  {
    *a5 = 1;
    goto LABEL_16;
  }
  v16 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 24) + 144))();
  if ((v16 & 0x80000000) != 0)
  {
    v11 = v16;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1158, "%s%x", v17, v18, v19, v20, "lhError");
    return v11;
  }
  v11 = (*(uint64_t (**)(_QWORD, _QWORD, unsigned __int8 **, unsigned int *))(*(_QWORD *)(a1 + 24) + 88))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), &v43, &v44);
  if ((v11 & 0x80000000) == 0)
  {
    v21 = v44;
    if (v44)
    {
      v45 = 0;
      if (*(_DWORD *)a1 == 3
        && (*(_DWORD *)a1 = 2,
            *(_DWORD *)(a1 + 80) = TxtEncodingDetect(v43, v21, &v45),
            v22 = ELQSSMLStartParsing(*(_QWORD *)(a1 + 56), 0, 0, 65001, 1),
            (v22 & 0x80000000) != 0))
      {
        v11 = v22;
      }
      else
      {
        v23 = *(_DWORD *)(a1 + 80);
        if (v23 == 65001)
        {
          v24 = (char *)&v43[v45];
          v25 = v44 - v45;
        }
        else
        {
          v41 = 0;
          TxtEncodingGetOutputBytesRequired((char *)&v43[v45], v44 - v45, v23, v23, &v41);
          v29 = TxtEncodingConvert(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16), *(_DWORD *)(a1 + 80), 65001, (char *)&v43[v45], v41, 0, 0, 0);
          v24 = v29;
          if (v29)
            v25 = strlen(v29);
          else
            v25 = 0;
        }
        v11 = 2375040625;
        if (v24 && v25)
        {
          if (strstr(v24, "<speak"))
          {
            v30 = v42;
LABEL_32:
            v32 = *(_QWORD *)(a1 + 56);
            v33 = v24;
            v34 = v25;
            v35 = v30;
            goto LABEL_33;
          }
          v31 = strstr(v24, "speak>");
          v30 = v42;
          if (v31 || strstr(v24, "<?xml") || !(_DWORD)v30)
            goto LABEL_32;
          v38 = strlen(__s);
          if ((ELQSSMLParse(*(_QWORD *)(a1 + 56), (uint64_t)__s, v38, 0, 0) & 0x80000000) == 0
            && (ELQSSMLParse(*(_QWORD *)(a1 + 56), (uint64_t)v24, v25, 0, 0) & 0x80000000) == 0)
          {
            v34 = strlen(v46);
            v35 = v42;
            v33 = v46;
            v32 = *(_QWORD *)(a1 + 56);
LABEL_33:
            if ((ELQSSMLParse(v32, (uint64_t)v33, v34, v35, 0) & 0x80000000) == 0)
            {
              if (*(_DWORD *)(a1 + 80) != 65001)
                heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), (uint64_t)v24);
              v11 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), v44);
              if ((v11 & 0x80000000) == 0 && v42)
              {
                *a5 = 1;
                v36 = *(_QWORD *)(a1 + 112);
                if (!v36)
                  goto LABEL_16;
                v11 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 24) + 72))(v36, *(_QWORD *)(a1 + 120));
                *(_QWORD *)(a1 + 112) = safeh_GetNullHandle();
                *(_QWORD *)(a1 + 120) = v37;
              }
              if ((v11 & 0x80000000) == 0)
                goto LABEL_16;
            }
          }
        }
      }
LABEL_14:
      *(_DWORD *)a1 = 1;
LABEL_16:
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_Process", v13, v14, v15, v40);
      return v11;
    }
    if (v42)
    {
      *a5 = 1;
      v27 = *(_QWORD *)(a1 + 112);
      if (v27)
      {
        v11 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 24) + 72))(v27, *(_QWORD *)(a1 + 120));
        *(_QWORD *)(a1 + 112) = safeh_GetNullHandle();
        *(_QWORD *)(a1 + 120) = v28;
      }
    }
    else
    {
      *a5 = 0;
    }
  }
  return v11;
}

uint64_t lightssml_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;

  v3 = 2375032840;
  if ((safeh_HandleCheck(a1, a2, 435, 128) & 0x80000000) == 0)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ProcessEnd", v4, v5, v6, v19);
    if ((*(_DWORD *)a1 & 0xFFFFFFFE) == 2)
    {
      *(_DWORD *)a1 = 1;
      v3 = UnloadTuningResources(*(_QWORD **)(a1 + 56));
      if ((v3 & 0x80000000) == 0)
      {
        v14 = *(_QWORD *)(a1 + 96);
        if (!v14
          || (v3 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 24) + 72))(v14, *(_QWORD *)(a1 + 104)), *(_QWORD *)(a1 + 96) = safeh_GetNullHandle(), *(_QWORD *)(a1 + 104) = v15, (v3 & 0x80000000) == 0))
        {
          v16 = *(_QWORD *)(a1 + 112);
          if (v16)
          {
            v3 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 24) + 72))(v16, *(_QWORD *)(a1 + 120));
            *(_QWORD *)(a1 + 112) = safeh_GetNullHandle();
            *(_QWORD *)(a1 + 120) = v17;
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v7, v8, v9, v10, v20);
      v3 = 2375032849;
    }
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessEnd", v11, v12, v13, v20);
  }
  return v3;
}

uint64_t StringBuffer_Output(const char *a1, _QWORD *a2)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  void *__dst;

  if (!a1)
    return 0;
  v4 = strlen(a1);
  if (!(_DWORD)v4)
    return 0;
  __dst = 0;
  v5 = (*(uint64_t (**)(_QWORD, _QWORD, void **, size_t))(a2[3] + 112))(a2[14], a2[15], &__dst, v4);
  if ((v5 & 0x80000000) != 0)
    return v5;
  memcpy(__dst, a1, v4);
  v6 = (*(uint64_t (**)(_QWORD, _QWORD, size_t))(a2[3] + 120))(a2[14], a2[15], v4);
  if ((v6 & 0x80000000) == 0 && log_HasTraceTuningDataSubscriber(*(_QWORD *)(a2[2] + 32)))
    log_OutTraceTuningDataBinary(*(_QWORD *)(a2[2] + 32), 500, (uint64_t)&byte_1DEBD87CE, (uint64_t)"text/plain;charset=utf-8",
      (uint64_t)__dst,
      v4);
  return v6;
}

uint64_t ELQEntityGetCode(uint64_t result, int a2)
{
  size_t v2;
  char *v3;
  uint64_t v4;
  size_t v5;
  __int16 v6;
  char __dst;
  char v8;
  char v9;
  char v10[77];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v5 = 15;
  if (result)
  {
    v4 = 0;
    if ((a2 & 0xFFFFFFFE) == 0x4B0)
    {
      TxtEncodingConvert(0, a2, 65001, (char *)result, 0xFuLL, (uint64_t)&__dst, 0x50uLL, &v5);
    }
    else
    {
      strncpy(&__dst, (const char *)result, 0xEuLL);
      v10[12] = 0;
      v5 = strlen(&__dst);
    }
    if (__dst != 38)
      goto LABEL_15;
    v2 = v5 - 1;
    if (v5 == 1)
    {
      LOWORD(result) = 38;
      return (unsigned __int16)result;
    }
    if (*(&__dst + v2) != 59 || (*(&__dst + v2) = 0, !v8))
    {
LABEL_15:
      LOWORD(result) = 0;
      return (unsigned __int16)result;
    }
    if (v8 == 35)
    {
      if ((v9 & 0xDF) == 0x58)
      {
        if (ELQAsciiHex2num(v10, &v6))
          LOWORD(result) = v6;
        else
          LOWORD(result) = 0;
      }
      else
      {
        LODWORD(result) = UTF8ContainsCharacterFamily((uint64_t)&v9);
        if ((_DWORD)result)
          LOWORD(result) = (unsigned __int16)LH_atoi(&v9);
      }
    }
    else
    {
      v3 = &v8;
      LOWORD(v4) = 0;
      result = ELQbsearch((uint64_t)&v3, (uint64_t)&EntityList, 0xFDuLL, 16, (uint64_t (*)(uint64_t, uint64_t))EntityCompare);
      if (result)
        LOWORD(result) = *(_WORD *)(result + 8);
    }
  }
  return (unsigned __int16)result;
}

uint64_t UTF8ContainsCharacterFamily(uint64_t __s)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  size_t v4;

  if (__s)
  {
    v1 = __s;
    if (!*(_BYTE *)__s)
      return 1;
    v2 = 0;
    while (1)
    {
      v4 = 0;
      v3 = ELQGetWCharFromString((char *)__s, 65001, 0, &v4);
      if (v3)
      {
        if (ELQwisdigit(v3) != 1)
          return 0;
        v2 += v4;
      }
      else
      {
        ++v2;
      }
      __s = v1 + v2;
      if (!*(_BYTE *)(v1 + v2))
        return 1;
    }
  }
  return __s;
}

uint64_t EntityCompare(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

_BYTE *ELQSubstituteEntitiesUTF8(_BYTE *result, char a2)
{
  _BYTE *v2;
  char *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  unsigned __int16 v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  int v21;
  unsigned int v22;
  char v23;
  char v24;
  unsigned __int8 v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  char v29;
  char v31;
  _BYTE v32[3];

  if (result)
  {
    v2 = result;
    if (*result)
    {
      v4 = result;
      do
      {
        result = (_BYTE *)ELQUtf8GetByteNo(v4);
        if (result <= 1)
          v5 = 1;
        else
          v5 = (int)result;
        if (result <= 1)
        {
          v6 = *v4;
          if ((a2 & 2) != 0 && v6 == 37)
          {
            v7 = v4[1];
            if (!v4[1])
              goto LABEL_43;
            v8 = v4[2];
            if (!v4[2])
              goto LABEL_43;
            v9 = v7 - 48;
            if ((v7 - 97) >= 6)
              v10 = -1;
            else
              v10 = v7 - 87;
            if ((v7 - 65) <= 5)
              v11 = v7 - 55;
            else
              v11 = v10;
            v12 = v7 - 48;
            if (v9 > 9)
              v12 = v11;
            v13 = v8 - 48;
            if ((v8 - 97) >= 6)
              v14 = -1;
            else
              v14 = v8 - 87;
            if ((v8 - 65) <= 5)
              v15 = v8 - 55;
            else
              v15 = v14;
            v16 = v8 - 48;
            if (v13 > 9)
              v16 = v15;
            if ((v12 & 0x80000000) == 0 && (v16 & 0x80000000) == 0 && (v17 = v16 + 16 * v12) != 0)
            {
              result = (_BYTE *)TxtEncodingCharUTF16ToUTF8(v17, (uint64_t)&v31);
              v18 = v31;
              if (v31)
              {
                v19 = v32;
                do
                {
                  *v2++ = v18;
                  v20 = *v19++;
                  v18 = v20;
                }
                while (v20);
              }
              v4 += 3;
            }
            else
            {
LABEL_43:
              *v2++ = 37;
              ++v4;
            }
            continue;
          }
          if ((a2 & 1) != 0 && v6 == 38)
          {
            v21 = 0;
            v22 = 0;
            v23 = 38;
            while (1)
            {
              if (!v23)
              {
                ++v4;
                *v2++ = 38;
                goto LABEL_53;
              }
              if (v23 == 59)
                break;
              v23 = v4[++v22];
              --v21;
            }
            v25 = v4[v22 + 1];
            v4[v22 + 1] = 0;
            result = (_BYTE *)ELQEntityGetCode((uint64_t)v4, 65001);
            v4[v22 + 1] = v25;
            if ((_DWORD)result)
            {
              result = (_BYTE *)TxtEncodingCharUTF16ToUTF8(result, (uint64_t)&v31);
              v26 = v31;
              if (v31)
              {
                v27 = v32;
                do
                {
                  *v2++ = v26;
                  v28 = *v27++;
                  v26 = v28;
                }
                while (v28);
              }
              v4 += v22 + 1;
            }
            else if (v22)
            {
              do
              {
                v29 = *v4++;
                *v2++ = v29;
              }
              while (!__CFADD__(v21++, 1));
            }
            continue;
          }
        }
        do
        {
          v24 = *v4++;
          *v2++ = v24;
          --v5;
        }
        while (v5);
LABEL_53:
        ;
      }
      while (*v4);
    }
    *v2 = 0;
  }
  return result;
}

uint64_t ELQUtf8GetNext(char *a1, _BYTE *a2)
{
  unsigned int v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  char v8;

  if (!a1)
    goto LABEL_13;
  v2 = *a1;
  if (!*a1)
  {
    v3 = 0;
    if (!a2)
      return 0;
    goto LABEL_14;
  }
  if ((v2 & 0x80000000) != 0)
  {
    if (v2 + 62 < 0x1E)
    {
      v2 = 2;
      goto LABEL_24;
    }
    if ((v2 & 0xFFFFFFF0) == 0xFFFFFFE0)
    {
      v2 = 3;
      goto LABEL_24;
    }
    if ((v2 + 11) > 0xFAu)
    {
      v2 = 4;
LABEL_24:
      v3 = 1;
      if (!a2)
        return 0;
      goto LABEL_14;
    }
LABEL_13:
    v3 = 0;
    v2 = 0;
    if (!a2)
      return 0;
    goto LABEL_14;
  }
  v3 = 1;
  v2 = 1;
  if (!a2)
    return 0;
LABEL_14:
  if (v3)
  {
    if (v2 <= 1)
      v5 = 1;
    else
      v5 = v2;
    v6 = v5;
    v7 = a2;
    do
    {
      v8 = *a1++;
      *v7++ = v8;
      --v6;
    }
    while (v6);
  }
  else
  {
    v5 = 0;
  }
  a2[v5] = 0;
  return v2;
}

uint64_t ELQUtf8GetByteNo(_BYTE *a1)
{
  int v1;

  if (!a1)
    return 0;
  v1 = (char)*a1;
  if (!*a1)
    return 0;
  if ((v1 & 0x80000000) == 0)
    return 1;
  if ((v1 + 62) < 0x1E)
    return 2;
  if ((v1 & 0xFFFFFFF0) == 0xFFFFFFE0)
    return 3;
  if ((v1 + 11) > 0xFAu)
    return 4;
  else
    return 0;
}

uint64_t ELQwcsncmp(_WORD *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  _WORD *v5;
  unsigned __int16 *v6;

  if (!a3)
    return 0;
  v3 = a3 - 1;
  if (a3 != 1)
  {
    v4 = 2 * a3 - 2;
    v5 = (_WORD *)((char *)a1 + v4);
    v6 = (unsigned __int16 *)((char *)a2 + v4);
    while (*a1 && (unsigned __int16)*a1 == *a2)
    {
      ++a1;
      ++a2;
      if (!--v3)
      {
        a1 = v5;
        a2 = v6;
        return (unsigned __int16)*a1 - *a2;
      }
    }
  }
  return (unsigned __int16)*a1 - *a2;
}

uint64_t ELQGetWCharFromString(char *__s, int a2, int a3, size_t *a4)
{
  uint64_t v6;
  char *v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  size_t v14;
  char *Map;
  int v16;
  __int16 v17;
  char __sa[5];

  LOWORD(v6) = (_WORD)__s;
  if (a4)
    *a4 = 0;
  if (!__s)
    return (unsigned __int16)v6;
  if (a3)
  {
    if ((a2 - 1200) < 2)
    {
      if (*(_WORD *)__s)
      {
        v7 = __s + 2;
        do
        {
          v8 = *(unsigned __int16 *)v7;
          v7 += 2;
        }
        while (v8);
        v9 = *((unsigned __int16 *)v7 - 2);
        v10 = bswap32(v9) >> 16;
        if (a2 == 1201)
          LOWORD(v6) = v10;
        else
          LOWORD(v6) = v9;
        if (!a4)
          return (unsigned __int16)v6;
        goto LABEL_31;
      }
LABEL_33:
      LOWORD(v6) = 0;
      return (unsigned __int16)v6;
    }
    if (a2 == 65001)
    {
      v11 = 0;
      while (__s[v11++])
        ;
      v13 = v11 - 1;
      if (!(_DWORD)v13)
        goto LABEL_33;
      while (v13 >= 2)
      {
        if (__s[--v13] >= -64)
          goto LABEL_39;
      }
      LODWORD(v13) = 0;
LABEL_39:
      __s += (int)v13;
      goto LABEL_40;
    }
    if (!*__s)
      goto LABEL_33;
    v6 = __s[strlen(__s) - 1];
    goto LABEL_35;
  }
  switch(a2)
  {
    case 1200:
      LOWORD(v6) = *(_WORD *)__s;
      if (!a4 || !*(_WORD *)__s)
        return (unsigned __int16)v6;
LABEL_31:
      v14 = 2;
      goto LABEL_45;
    case 65001:
      if (!*__s)
        goto LABEL_33;
LABEL_40:
      ELQUtf8GetNext(__s, __sa);
      v17 = TxtEncodingCharUTF8ToUTF16((unsigned __int8 *)__sa);
      if (__sa[0])
      {
        LOWORD(v6) = v17;
        if (!a4)
          return (unsigned __int16)v6;
        v14 = strlen(__sa);
      }
      else
      {
        LOWORD(v6) = 0;
        if (!a4)
          return (unsigned __int16)v6;
        v14 = 1;
      }
LABEL_45:
      *a4 = v14;
      return (unsigned __int16)v6;
    case 1201:
      LOWORD(v6) = __rev16(*(unsigned __int16 *)__s);
      if (!a4 || !*(_WORD *)__s)
        return (unsigned __int16)v6;
      goto LABEL_31;
  }
  v6 = *__s;
  if (!*__s)
    return (unsigned __int16)v6;
LABEL_35:
  v14 = 1;
  Map = TxtEncodingGetMap(a2, 1);
  v16 = TxtEncodingCharToWChar(v6, Map);
  LOWORD(v6) = v16;
  if (a4 && v16)
    goto LABEL_45;
  return (unsigned __int16)v6;
}

uint64_t ELQwisdigit(unsigned int a1)
{
  int v2;
  int v3;
  int v4;
  unsigned int v5;

  if (a1 - 48 < 0xA)
    return 1;
  if (a1 < 0xA0)
    return 0;
  v2 = 0;
  v3 = 232;
  do
  {
    v4 = (v2 + v3) / 2;
    v5 = ELQwisdigit_wisdigitList[v4];
    if (v5 <= a1)
    {
      if (v5 >= a1)
        return v4 != -1;
      v2 = v4 + 1;
    }
    else
    {
      v3 = v4 - 1;
    }
  }
  while (v2 <= v3);
  v4 = -1;
  return v4 != -1;
}

uint64_t ELQAsciiHex2num(const char *a1, _WORD *a2)
{
  const char *v3;
  size_t v4;
  size_t v5;
  __int16 v6;
  int v7;
  int v8;
  __int16 v9;
  __int16 v10;
  uint64_t result;

  v3 = a1;
  v4 = strlen(a1);
  if (v4)
  {
    v5 = v4;
    v6 = 0;
    while (1)
    {
      v8 = *v3++;
      v7 = v8;
      if (memchr("ABCDEF", v8, 7uLL))
        break;
      if (memchr("abcdef", v7, 7uLL))
      {
        v9 = 16 * v6 - 97;
        goto LABEL_7;
      }
      result = (uint64_t)memchr("0987654321", v7, 0xBuLL);
      if (!result)
        return result;
      v9 = 16 * v6;
      v10 = -48;
LABEL_8:
      v6 = v10 + v9 + v7;
      if (!--v5)
        goto LABEL_13;
    }
    v9 = 16 * v6 - 65;
LABEL_7:
    v10 = 10;
    goto LABEL_8;
  }
  v6 = 0;
LABEL_13:
  *a2 = v6;
  return 1;
}

_QWORD *ELQMemorySlotInit(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  v6 = (_QWORD *)heap_Alloc(*(_QWORD *)(a1 + 8), 72);
  v7 = v6;
  if (v6)
  {
    v6[1] = a1;
    v6[4] = 0;
    v6[5] = a2;
    v6[3] = 0;
    v8 = ReallocBuffers(v6);
    v7[2] = v8;
    *((_DWORD *)v7 + 12) = a3;
    v7[7] = 0;
    v7[8] = 0;
    if (v8)
      *v7 = ELQMemorySlotInit;
    else
      return 0;
  }
  return v7;
}

uint64_t ReallocBuffers(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;

  v2 = a1[4];
  if (v2)
  {
    v3 = v2 + 100;
    a1[4] = v3;
    v4 = heap_Realloc(*(uint64_t **)(a1[1] + 8), a1[2], 24 * v3);
  }
  else
  {
    a1[4] = 100;
    v4 = heap_Alloc(*(_QWORD *)(a1[1] + 8), 2400);
  }
  v5 = v4;
  a1[2] = v4;
  if (v4)
  {
    v6 = a1[4];
    if (v6 >= 0x64)
    {
      v7 = (void *)(v4 + 24 * v6 - 2400);
      v8 = v6 - 99 >= v6;
      v9 = -99;
      if (!v8)
        v9 = 0;
      bzero(v7, 24 * v9 + 2400);
    }
  }
  return v5;
}

_QWORD *ELQMemorySlotDelete(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    if ((_QWORD *(*)(uint64_t, uint64_t, int))*result == ELQMemorySlotInit)
    {
      v2 = result[4];
      if (v2)
      {
        v3 = 24 * v2 - 24;
        do
        {
          --v2;
          heap_Free(*(_QWORD **)(v1[1] + 8), *(_QWORD *)(v1[2] + v3));
          v3 -= 24;
        }
        while (v2);
      }
      heap_Free(*(_QWORD **)(v1[1] + 8), v1[2]);
      *v1 = 0;
      return heap_Free(*(_QWORD **)(v1[1] + 8), (uint64_t)v1);
    }
  }
  return result;
}

_QWORD *(**ELQMemorySlotSave(_QWORD *(**result)(uint64_t a1, uint64_t a2, int a3), char *__src, size_t __n))(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  size_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  size_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;

  if (!result)
    return result;
  v3 = (uint64_t)result;
  if (*result != ELQMemorySlotInit)
    return 0;
  v4 = __n;
  if (__src && !__n)
    v4 = strlen(__src) + 1;
  *(_QWORD *)(v3 + 64) += v4;
  if (v4 > *(_QWORD *)(v3 + 40))
  {
    v6 = *(_QWORD *)(v3 + 24);
    goto LABEL_14;
  }
  v7 = *(_QWORD *)(v3 + 56);
  v6 = *(_QWORD *)(v3 + 24);
  if (v7 >= v6)
  {
LABEL_14:
    if (v6 >= *(_QWORD *)(v3 + 32))
    {
      result = (_QWORD *(**)(uint64_t, uint64_t, int))ReallocBuffers((_QWORD *)v3);
      *(_QWORD *)(v3 + 16) = result;
      if (!result)
        return result;
      v9 = *(_QWORD *)(v3 + 40);
      if (v4 > v9)
        v9 = v4;
      *(_QWORD *)(v3 + 40) = v9;
    }
    else
    {
      result = *(_QWORD *(***)(uint64_t, uint64_t, int))(v3 + 16);
      v9 = *(_QWORD *)(v3 + 40);
      if (v4 > v9)
        v9 = v4;
      *(_QWORD *)(v3 + 40) = v9;
      if (!result)
        return result;
    }
    v10 = &result[3 * *(_QWORD *)(v3 + 24)];
    v11 = (v9 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    v10[1] = v11;
    v10[2] = 0;
    result = (_QWORD *(**)(uint64_t, uint64_t, int))heap_Alloc(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 8), v11);
    *v10 = result;
    if (result)
    {
      result = (_QWORD *(**)(uint64_t, uint64_t, int))SaveInBuffer(__src, v4, (_QWORD *)(*(_QWORD *)(v3 + 16)+ 24 * *(_QWORD *)(v3 + 24)));
      if (result)
      {
        v12 = *(_QWORD *)(v3 + 24);
        if (*(_DWORD *)(v3 + 48))
          *(_QWORD *)(v3 + 56) = v12;
        *(_QWORD *)(v3 + 24) = v12 + 1;
      }
    }
    return result;
  }
  v8 = 24 * v7;
  while (1)
  {
    result = (_QWORD *(**)(uint64_t, uint64_t, int))SaveInBuffer(__src, v4, (_QWORD *)(*(_QWORD *)(v3 + 16) + v8));
    if (result)
      break;
    ++v7;
    v6 = *(_QWORD *)(v3 + 24);
    v8 += 24;
    if (v7 >= v6)
      goto LABEL_14;
  }
  if (*(_DWORD *)(v3 + 48))
    *(_QWORD *)(v3 + 56) = v7;
  return result;
}

void *SaveInBuffer(void *__src, size_t __n, _QWORD *a3)
{
  size_t v4;
  uint64_t v5;
  void *v6;

  v4 = (__n + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v5 = a3[2];
  if (v5 + v4 > a3[1])
    return 0;
  v6 = (void *)(*a3 + v5);
  if (__src)
    memcpy(v6, __src, __n);
  else
    bzero(v6, __n);
  a3[2] += v4;
  return v6;
}

_QWORD *(**ELQMemorySlotReserve(_QWORD *(**a1)(uint64_t a1, uint64_t a2, int a3), size_t __n))(uint64_t a1, uint64_t a2, int a3)
{
  return ELQMemorySlotSave(a1, 0, __n);
}

uint64_t ELQMemorySlotReset(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;

  if (result && *(_QWORD *(**)(uint64_t, uint64_t, int))result == ELQMemorySlotInit)
  {
    v1 = *(_QWORD *)(result + 32);
    if (v1)
    {
      v2 = (_QWORD *)(*(_QWORD *)(result + 16) + 16);
      do
      {
        *v2 = 0;
        v2 += 3;
        --v1;
      }
      while (v1);
    }
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 64) = 0;
  }
  return result;
}

uint64_t ELQbsearch(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  unint64_t v7;
  uint64_t v10;
  int v11;
  unint64_t v12;

  if (!a3)
    return 0;
  v7 = a3;
  while (1)
  {
    v10 = a2 + (v7 >> 1) * a4;
    v11 = a5(a1, v10);
    if (!v11)
      break;
    if (v11 > 0)
      a2 = v10 + a4;
    v12 = v7 - (v11 > 0);
    v7 = v12 >> 1;
    if (v12 <= 1)
      return 0;
  }
  return v10;
}

uint64_t ELQPluginGetProc(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t (*v5)(uint64_t, _QWORD);
  uint64_t v7;

  result = 2375032834;
  if (a1)
  {
    v5 = *(uint64_t (**)(uint64_t, _QWORD))(a1 + 88);
    if (v5)
    {
      if (*(uint64_t (**)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))a1 == ELQPluginIni)
      {
        v7 = v5(a2, *(_QWORD *)(a1 + 104));
        result = 0;
        *a3 = v7;
      }
    }
  }
  return result;
}

uint64_t ELQPluginIni(uint64_t a1, uint64_t (***a2)(), uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t (*a8)())
{
  uint64_t v14;
  uint64_t (**v15)();
  uint64_t (**v16)();
  char v18[512];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v14 = 2375032834;
  v15 = (uint64_t (**)())heap_Alloc(*(_QWORD *)(a1 + 8), 120);
  if (!v15)
    return 2375032842;
  v16 = v15;
  *v15 = 0;
  if (a5)
    FileFullPath(v18, a5, a4);
  else
    __strcpy_chk();
  __strcat_chk();
  v16[14] = (uint64_t (*)())a1;
  v16[11] = 0;
  v16[12] = 0;
  if (!strcmp(a6, "LTTS7XML"))
  {
    v16[11] = (uint64_t (*)())LTTS7XML;
    v16[13] = a8;
    *v16 = ELQPluginIni;
    __strcpy_chk();
    v14 = 0;
    *a2 = v16;
  }
  else
  {
    if (*v16 == ELQPluginIni)
    {
      *v16 = 0;
      v16[12] = 0;
      heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v16);
    }
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v16);
  }
  return v14;
}

uint64_t ELQPluginLoadUtilSymbols(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(const char *, _QWORD);
  uint64_t (*v5)(uint64_t);

  if (a1
    && (v2 = *(uint64_t (**)(const char *, _QWORD))(a1 + 88)) != 0
    && *(uint64_t (**)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))a1 == ELQPluginIni
    && (v5 = (uint64_t (*)(uint64_t))v2("LoadUtilSymbols", *(_QWORD *)(a1 + 104)), a2)
    && v5)
  {
    return v5(a2);
  }
  else
  {
    return 0;
  }
}

uint64_t (**ELQPluginDelete(uint64_t (**result)(uint64_t a1, uint64_t (***a2)(), uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t (*a8)())))(uint64_t a1, uint64_t (***a2)(), uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t (*a8)())
{
  if (result)
  {
    if (*result == ELQPluginIni)
    {
      *result = 0;
      result[12] = 0;
      return (uint64_t (**)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))heap_Free(*((_QWORD **)result[14] + 1), (uint64_t)result);
    }
  }
  return result;
}

uint64_t VoiceInfoIni(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t (**v5)();
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  char *v12;
  const char *v13;
  const char *v14;
  BOOL v15;
  unsigned int v16;
  const char *v17;
  const char *v18;
  _BYTE *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t *v25;
  uint64_t *v26;
  char *v27;
  _BYTE *v28;
  int v29;
  unsigned int v30;
  char *v31;
  _BYTE *v32;
  int v33;
  unsigned int v34;
  char *v35;
  _BYTE *v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  _BOOL8 *v43;
  const char *v44;
  const char *v45;
  const char *v46;
  uint64_t v47;
  _BYTE *v48;
  uint64_t v49;

  v48 = 0;
  v49 = 0;
  v47 = 0;
  v4 = (_QWORD *)heap_Alloc(*(_QWORD *)(a2 + 8), 24);
  if (!v4)
    return 2375032842;
  v5 = (uint64_t (**)())v4;
  *v4 = 0;
  v4[1] = 0;
  v6 = v4 + 1;
  v4[2] = 0;
  *a1 = v4;
  v4[2] = a2;
  *v4 = VoiceInfoIni;
  v7 = hashtable_ObjOpen(v4 + 1, a2, 32, 0);
  if ((v7 & 0x80000000) != 0)
  {
    v39 = v7;
LABEL_84:
    VoiceInfoDelete(v5);
    return v39;
  }
  hashtable_ElementSetDestructor(*v6, (uint64_t)FreeVoiceElement);
  v8 = brk_ComponentTableIteratorOpen(*(_QWORD *)(a2 + 24), (uint64_t)"pipeline/*", (uint64_t)&v49);
  v9 = v8;
  if ((v8 & 0x80000000) != 0)
  {
    v39 = v8;
    goto LABEL_84;
  }
  if ((brk_ComponentTableIteratorNext(v49) & 0x80000000) == 0)
  {
    v43 = (_BOOL8 *)v6;
    do
    {
      v9 = brk_TagIteratorOpen(*(_QWORD *)(a2 + 24), v48, "PARAMETERS/*", 1, &v47);
      if ((v9 & 0x80000000) == 0)
      {
        v45 = 0;
        v46 = 0;
        if ((brk_TagIteratorNext(v47, (uint64_t)&v46, (uint64_t)&v45) & 0x80000000) == 0)
        {
          v10 = 0;
          v44 = 0;
          v11 = 0;
          v12 = 0;
          do
          {
            v13 = v45;
            v14 = v46;
            if (v46)
              v15 = v45 == 0;
            else
              v15 = 1;
            if (!v15 && *v45)
            {
              if (!strcmp(v46, "voice"))
              {
                v12 = (char *)v13;
              }
              else if (!strcmp(v14, "langcode"))
              {
                v11 = (char *)v13;
              }
              else if (!strcmp(v14, "gender"))
              {
                v10 = v13;
              }
              else if (!strcmp(v14, "age"))
              {
                v16 = LH_atoi(v13);
                v17 = v45;
                v18 = "adult";
                if (v16 <= 0x11)
                  v18 = "child";
                if (v16)
                  v17 = v18;
                v44 = v17;
              }
            }
          }
          while ((brk_TagIteratorNext(v47, (uint64_t)&v46, (uint64_t)&v45) & 0x80000000) == 0);
          if (v12 && *v12)
          {
            v19 = strhelper_Strdup(*(_QWORD *)(a2 + 8), v12);
            if (!v19)
            {
              v40 = *(_QWORD **)(a2 + 8);
              v41 = 0;
              goto LABEL_83;
            }
            v20 = (uint64_t)v19;
            v21 = *v12;
            if (*v12)
            {
              v22 = 0;
              v23 = 1;
              do
              {
                if ((v21 - 65) < 0x1A)
                  LOBYTE(v21) = v21 + 32;
                v19[v22] = v21;
                v22 = v23;
                v21 = v12[v23++];
              }
              while (v21);
            }
            if (!hashtable_Get(*v43))
            {
              v24 = *(_QWORD **)(a2 + 8);
              v25 = (uint64_t *)heap_Alloc((uint64_t)v24, 24);
              if (!v25)
                goto LABEL_82;
              v26 = v25;
              *v25 = 0;
              v25[1] = 0;
              v25[2] = 0;
              if (v11)
              {
                if (*v11)
                  v27 = v11;
                else
                  v27 = "unknown";
              }
              else
              {
                v27 = "unknown";
              }
              v28 = strhelper_Strdup((uint64_t)v24, v27);
              *v26 = (uint64_t)v28;
              if (!v28)
                goto LABEL_81;
              v29 = *v28;
              if (*v28)
              {
                v30 = 1;
                do
                {
                  if ((v29 - 65) < 0x1A)
                    LOBYTE(v29) = v29 + 32;
                  *v28 = v29;
                  v28 = (_BYTE *)(*v26 + v30);
                  v29 = *v28;
                  ++v30;
                }
                while (*v28);
              }
              if (v10)
                v31 = *v10 ? (char *)v10 : "neutral";
              else
                v31 = "neutral";
              v32 = strhelper_Strdup((uint64_t)v24, v31);
              v26[1] = (uint64_t)v32;
              if (!v32)
                goto LABEL_81;
              v33 = *v32;
              if (*v32)
              {
                v34 = 1;
                do
                {
                  if ((v33 - 65) < 0x1A)
                    LOBYTE(v33) = v33 + 32;
                  *v32 = v33;
                  v32 = (_BYTE *)(v26[1] + v34);
                  v33 = *v32;
                  ++v34;
                }
                while (*v32);
              }
              if (v44)
                v35 = *v44 ? (char *)v44 : "adult";
              else
                v35 = "adult";
              v36 = strhelper_Strdup((uint64_t)v24, v35);
              v26[2] = (uint64_t)v36;
              if (!v36)
              {
LABEL_81:
                FreeVoiceElement(v24, v26);
LABEL_82:
                v40 = *(_QWORD **)(a2 + 8);
                v41 = v20;
LABEL_83:
                heap_Free(v40, v41);
                v39 = 2375032842;
                goto LABEL_84;
              }
              v37 = *v36;
              if (*v36)
              {
                v38 = 1;
                do
                {
                  if ((v37 - 65) < 0x1A)
                    LOBYTE(v37) = v37 + 32;
                  *v36 = v37;
                  v36 = (_BYTE *)(v26[2] + v38);
                  v37 = *v36;
                  ++v38;
                }
                while (*v36);
              }
              hashtable_Set(*v43);
            }
            heap_Free(*(_QWORD **)(a2 + 8), v20);
          }
        }
        brk_TagIteratorClose(v47);
        v47 = 0;
      }
    }
    while ((brk_ComponentTableIteratorNext(v49) & 0x80000000) == 0);
    brk_ComponentTableIteratorClose(v49);
    v39 = v9;
    if ((v9 & 0x80000000) == 0)
      return v9;
    goto LABEL_84;
  }
  brk_ComponentTableIteratorClose(v49);
  return v9;
}

_QWORD *FreeVoiceElement(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a2[2];
  if (v4)
    heap_Free(a1, v4);
  v5 = a2[1];
  if (v5)
    heap_Free(a1, v5);
  if (*a2)
    heap_Free(a1, *a2);
  return heap_Free(a1, (uint64_t)a2);
}

uint64_t (**VoiceInfoDelete(uint64_t (**result)()))()
{
  uint64_t v1;
  uint64_t (*v2)();

  if (result)
  {
    v1 = (uint64_t)result;
    if (*result == VoiceInfoIni)
    {
      v2 = result[1];
      if (v2)
        hashtable_ObjClose(v2);
      *(_QWORD *)(v1 + 8) = 0;
      return (uint64_t (**)())heap_Free(*(_QWORD **)(*(_QWORD *)(v1 + 16) + 8), v1);
    }
  }
  return result;
}

char *LTTS7XML(char *__s1)
{
  const char *v1;
  uint64_t v2;

  if (__s1)
  {
    v1 = __s1;
    v2 = 0;
    while (strcmp(v1, (&LTTS7XML_FuncTable)[v2]))
    {
      v2 += 2;
      if (v2 == 38)
        return 0;
    }
    return (&LTTS7XML_FuncTable)[v2 + 1];
  }
  return __s1;
}

uint64_t LoqXMLGetVersion(char *a1)
{
  strcpy(a1, "1.0.0");
  return 0;
}

uint64_t LoqXMLIniParser(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  _QWORD *v6;
  XML_Parser v7;
  XML_Memory_Handling_Suite v9;
  uint64_t (*v10)();

  v2 = 2375032842;
  if (!a1)
    return 2375032839;
  v5 = heap_Alloc(*(_QWORD *)(a2 + 8), 536);
  if (v5)
  {
    v6 = (_QWORD *)v5;
    *(_QWORD *)(v5 + 528) = a2;
    v9.free_fcn = (void (__cdecl *)(void *))builtin_Realloc_0;
    v10 = builtin_Free_0;
    v9.malloc_fcn = *(void *(__cdecl **)(size_t))(a2 + 8);
    v9.realloc_fcn = (void *(__cdecl *)(void *, size_t))builtin_Alloc_0;
    v7 = XML_ParserCreate_MM(0, &v9, 0);
    v6[1] = v7;
    if (v7)
    {
      v2 = 0;
      *v6 = LoqXMLIniParser;
      *a1 = v6;
    }
    else
    {
      heap_Free(*(_QWORD **)(a2 + 8), (uint64_t)v6);
    }
  }
  return v2;
}

uint64_t LoqXMLIniParserNS(_QWORD *a1, uint64_t a2, XML_Char a3)
{
  uint64_t v3;
  uint64_t v6;
  _QWORD *v7;
  XML_Parser v8;
  XML_Memory_Handling_Suite memsuite;
  uint64_t (*v11)();
  XML_Char namespaceSeparator;

  v3 = 2375032842;
  namespaceSeparator = a3;
  if (!a1)
    return 2375032839;
  v6 = heap_Alloc(*(_QWORD *)(a2 + 8), 536);
  if (v6)
  {
    v7 = (_QWORD *)v6;
    memsuite.free_fcn = (void (__cdecl *)(void *))builtin_Realloc_0;
    v11 = builtin_Free_0;
    memsuite.malloc_fcn = *(void *(__cdecl **)(size_t))(a2 + 8);
    memsuite.realloc_fcn = (void *(__cdecl *)(void *, size_t))builtin_Alloc_0;
    v8 = XML_ParserCreate_MM("uft-8", &memsuite, &namespaceSeparator);
    v7[1] = v8;
    if (v8)
    {
      v3 = 0;
      *v7 = LoqXMLIniParser;
      *a1 = v7;
    }
    else
    {
      heap_Free(*(_QWORD **)(a2 + 8), (uint64_t)v7);
    }
  }
  return v3;
}

uint64_t LoqXMLDeleteParser(uint64_t a1)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_ParserFree(*(XML_Parser *)(a1 + 8));
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 528) + 8), a1);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetEncoding(uint64_t a1, const XML_Char *a2)
{
  uint64_t v2;

  v2 = 2375032839;
  if (a1)
  {
    if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
    {
      __strcpy_chk();
      if (XML_SetEncoding(*(XML_Parser *)(a1 + 8), a2))
        return 0;
      else
        return 2375032839;
    }
    else
    {
      return 2375032834;
    }
  }
  return v2;
}

uint64_t LoqXMLGetEncoding(uint64_t a1, char *__dst)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    strcpy(__dst, (const char *)(a1 + 16));
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetCallbacks(uint64_t a1, void (__cdecl *a2)(void *, const XML_Char *, const XML_Char **), void (__cdecl *a3)(void *, const XML_Char *), void (__cdecl *a4)(void *, const XML_Char *, int), void *userData)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetUserData(*(XML_Parser *)(a1 + 8), userData);
    XML_SetElementHandler(*(XML_Parser *)(a1 + 8), a2, a3);
    XML_SetCharacterDataHandler(*(XML_Parser *)(a1 + 8), a4);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetUnknownEncodingHandler(uint64_t a1, int (__cdecl *a2)(void *, const XML_Char *, XML_Encoding *), void *a3)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetUnknownEncodingHandler(*(XML_Parser *)(a1 + 8), a2, a3);
    return 0;
  }
  return result;
}

double LoqXMLGetEncodingMap(uint64_t (**a1)(_QWORD *a1, uint64_t a2), uint64_t a2, _QWORD *a3)
{
  double result;

  if (a1 && *a1 == LoqXMLIniParser)
  {
    if (a3)
      *a3 = a2;
    *(_QWORD *)(a2 + 1040) = 0;
    result = 0.0;
    *(_OWORD *)(a2 + 1024) = 0u;
  }
  return result;
}

uint64_t LoqXMLParse(uint64_t a1, const char *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t result;
  XML_Status v8;

  if (a5)
    *a5 = 0;
  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    v8 = XML_Parse(*(XML_Parser *)(a1 + 8), a2, a3, a4);
    if (v8)
      result = 0;
    else
      result = 2375040625;
    if (a5)
    {
      if (v8)
      {
        result = 0;
        *a5 = 1;
      }
    }
  }
  return result;
}

uint64_t LoqXMLGetError(uint64_t a1, XML_Error *a2, _DWORD *a3)
{
  uint64_t result;
  int CurrentLineNumber;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (a2)
      *a2 = XML_GetErrorCode(*(XML_Parser *)(a1 + 8));
    if (a3)
    {
      CurrentLineNumber = XML_GetCurrentLineNumber(*(XML_Parser *)(a1 + 8));
      result = 0;
      *a3 = CurrentLineNumber;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLGetCurrentLineNumber(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int CurrentLineNumber;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (a2)
    {
      CurrentLineNumber = XML_GetCurrentLineNumber(*(XML_Parser *)(a1 + 8));
      result = 0;
      *a2 = CurrentLineNumber;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLSetUserData(uint64_t a1, void *a2)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetUserData(*(XML_Parser *)(a1 + 8), a2);
    return 0;
  }
  return result;
}

uint64_t LoqXMLGetUserData(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    result = 0;
    if (a2)
      *a2 = **(_QWORD **)(a1 + 8);
  }
  return result;
}

uint64_t LoqXMLReset(uint64_t a1)
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (XML_ParserReset(*(XML_Parser *)(a1 + 8), 0))
      return 0;
    else
      return 2375040625;
  }
  return result;
}

uint64_t LoqXMLGetByteOffset(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int CurrentByteIndex;
  int v6;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    CurrentByteIndex = XML_GetCurrentByteIndex(*(XML_Parser *)(a1 + 8));
    if (a2)
    {
      v6 = CurrentByteIndex;
      result = 0;
      *a2 = v6;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLSetXmlDeclHandler(uint64_t a1, void (__cdecl *a2)(void *, const XML_Char *, const XML_Char *, int))
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetXmlDeclHandler(*(XML_Parser *)(a1 + 8), a2);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetNamespaceCallbacks(uint64_t a1, void (__cdecl *a2)(void *, const XML_Char *, const XML_Char *), void (__cdecl *a3)(void *, const XML_Char *))
{
  uint64_t result;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetNamespaceDeclHandler(*(XML_Parser *)(a1 + 8), a2, a3);
    return 0;
  }
  return result;
}

uint64_t builtin_Alloc_0(uint64_t a1, unsigned int a2)
{
  return heap_Alloc(a1, a2);
}

uint64_t builtin_Realloc_0(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  return heap_Realloc(a1, a2, a3);
}

_QWORD *ELQXMLIniController(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _QWORD *v7;

  v6 = heap_Alloc(*(_QWORD *)(a1 + 8), 1216);
  v7 = (_QWORD *)v6;
  if (v6)
  {
    *(_QWORD *)(v6 + 1200) = a1;
    *(_QWORD *)(v6 + 1208) = a4;
    *(_DWORD *)(v6 + 1196) = 0;
    *(_QWORD *)(v6 + 8) = 0;
    *(_OWORD *)(v6 + 1040) = 0u;
    *(_OWORD *)(v6 + 1056) = 0u;
    *(_OWORD *)(v6 + 1072) = 0u;
    *(_OWORD *)(v6 + 1088) = 0u;
    *(_QWORD *)(v6 + 1104) = 0;
    *(_QWORD *)(v6 + 1120) = 0;
    *(_QWORD *)(v6 + 1136) = 0;
    *(_QWORD *)(v6 + 1128) = 0;
    *(_OWORD *)(v6 + 1152) = 0u;
    *(_OWORD *)(v6 + 1168) = 0u;
    *(_OWORD *)(v6 + 1177) = 0u;
    __strcpy_chk();
    __strcpy_chk();
    *v7 = ELQXMLIniController;
  }
  return v7;
}

_QWORD *ELQXMLDeleteController(_QWORD *result)
{
  uint64_t v1;
  uint64_t (**v2)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)());

  if (result)
  {
    v1 = (uint64_t)result;
    if ((_QWORD *(*)(uint64_t, uint64_t, uint64_t, uint64_t))*result == ELQXMLIniController)
    {
      critsec_Enter((_QWORD *)result[151]);
      v2 = *(uint64_t (***)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))(v1 + 8);
      if (v2)
        ELQPluginDelete(v2);
      critsec_Leave(*(_QWORD **)(v1 + 1208));
      *(_QWORD *)v1 = 0;
      return heap_Free(*(_QWORD **)(*(_QWORD *)(v1 + 1200) + 8), v1);
    }
  }
  return result;
}

uint64_t ELQXMLGetNamespaceSeparator(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = 2375032834;
  if (a1)
  {
    if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))a1 == ELQXMLIniController)
    {
      result = 0;
      *a2 = *(_BYTE *)(a1 + 1192);
    }
  }
  return result;
}

_QWORD *XMLIniParser(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v6;
  uint64_t (***v7)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)());
  _QWORD *v8;
  uint64_t v9;

  if (!a1 || *(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))a1 != ELQXMLIniController)
    return 0;
  v6 = (_QWORD *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 1200) + 8), 32);
  v3 = v6;
  if (!v6)
    return v3;
  *v6 = 0;
  critsec_Enter(*(_QWORD **)(a1 + 1208));
  v7 = (uint64_t (***)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))(a1 + 8);
  if (!*(_QWORD *)(a1 + 8))
  {
    if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))a1 != ELQXMLIniController
      || ELQPluginIni(*(_QWORD *)(a1 + 1200), (uint64_t (***)())(a1 + 8), 0, (char *)(a1 + 16), (char *)(a1 + 528), (const char *)(a1 + 16), 0, 0))
    {
      goto LABEL_14;
    }
    ELQPluginLoadUtilSymbols(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 1184));
    if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLIniParser", (uint64_t *)(a1 + 1040)))
    {
LABEL_13:
      ELQPluginDelete(*v7);
LABEL_14:
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 1200) + 8), (uint64_t)v3);
      critsec_Leave(*(_QWORD **)(a1 + 1208));
      return 0;
    }
    if (*(_QWORD *)(a1 + 1040))
    {
      if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLIniParserNS", (uint64_t *)(a1 + 1048)))
        goto LABEL_13;
      if (*(_QWORD *)(a1 + 1048))
      {
        if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLDeleteParser", (uint64_t *)(a1 + 1056)))
          goto LABEL_13;
        if (*(_QWORD *)(a1 + 1056))
        {
          if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLSetEncoding", (uint64_t *)(a1 + 1064)))
            goto LABEL_13;
          if (*(_QWORD *)(a1 + 1064))
          {
            if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetEncoding", (uint64_t *)(a1 + 1072)))goto LABEL_13;
            if (*(_QWORD *)(a1 + 1072))
            {
              if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLSetCallbacks", (uint64_t *)(a1 + 1080)))goto LABEL_13;
              if (*(_QWORD *)(a1 + 1080))
              {
                if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLSetNamespaceCallbacks", (uint64_t *)(a1 + 1088)))goto LABEL_13;
                if (*(_QWORD *)(a1 + 1088))
                {
                  if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetErrorString", (uint64_t *)(a1 + 1120)))goto LABEL_13;
                  if (*(_QWORD *)(a1 + 1120))
                  {
                    if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetError", (uint64_t *)(a1 + 1104)))goto LABEL_13;
                    if (*(_QWORD *)(a1 + 1104))
                    {
                      if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetCurrentLineNumber", (uint64_t *)(a1 + 1112)))goto LABEL_13;
                      if (*(_QWORD *)(a1 + 1112))
                      {
                        if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLParse", (uint64_t *)(a1 + 1096)))goto LABEL_13;
                        if (*(_QWORD *)(a1 + 1096))
                        {
                          if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLSetUEHandler", (uint64_t *)(a1 + 1128)))goto LABEL_13;
                          if (*(_QWORD *)(a1 + 1128))
                          {
                            if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetEncodingMap", (uint64_t *)(a1 + 1136)))goto LABEL_13;
                            if (*(_QWORD *)(a1 + 1136))
                            {
                              if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLSetUserData", (uint64_t *)(a1 + 1144)))goto LABEL_13;
                              if (*(_QWORD *)(a1 + 1144))
                              {
                                if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetUserData", (uint64_t *)(a1 + 1152)))goto LABEL_13;
                                if (*(_QWORD *)(a1 + 1152))
                                {
                                  if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLReset", (uint64_t *)(a1 + 1160)))goto LABEL_13;
                                  if (*(_QWORD *)(a1 + 1160))
                                  {
                                    if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLGetByteOffset", (uint64_t *)(a1 + 1168)))goto LABEL_13;
                                    if (*(_QWORD *)(a1 + 1168))
                                    {
                                      if (ELQPluginGetProc(*(_QWORD *)(a1 + 8), (uint64_t)"ELQXMLSetXmlDeclHandler", (uint64_t *)(a1 + 1176)))goto LABEL_13;
                                      if (*(_QWORD *)(a1 + 1176))
                                        goto LABEL_7;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    ELQPluginDelete(*v7);
  }
LABEL_7:
  v3[2] = a1;
  critsec_Leave(*(_QWORD **)(a1 + 1208));
  v8 = v3 + 1;
  v9 = *(_QWORD *)(a1 + 1200);
  if (!*(_DWORD *)(a1 + 1196))
  {
    if ((*(unsigned int (**)(_QWORD *, uint64_t))(a1 + 1040))(v8, v9))
      goto LABEL_9;
LABEL_16:
    v3[3] = a2;
    *v3 = ELQXMLIniParser;
    return v3;
  }
  if (!(*(unsigned int (**)(_QWORD *, uint64_t, _QWORD))(a1 + 1048))(v8, v9, *(char *)(a1 + 1192)))goto LABEL_16;
LABEL_9:
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 1200) + 8), (uint64_t)v3);
  return 0;
}

_QWORD *ELQXMLDeleteParser(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    if ((uint64_t (*)())*result == ELQXMLIniParser)
    {
      v2 = result[2];
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v2 == ELQXMLIniController)
      {
        (*(void (**)(_QWORD))(v2 + 1056))(result[1]);
        v2 = v1[2];
      }
      *v1 = 0;
      return heap_Free(*(_QWORD **)(*(_QWORD *)(v2 + 1200) + 8), (uint64_t)v1);
    }
  }
  return result;
}

uint64_t ELQXMLSetEncoding(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1064))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLSetCallbacks(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1080))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLSetNamespaceCallbacks(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1088))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLParse(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1096))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLGetCurrentLineNumber(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)())a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1112))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLGetError(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1104))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLGetErrorString(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *v6;

  v3 = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v4 == ELQXMLIniController)
      {
        v6 = (const char *)(*(uint64_t (**)(uint64_t))(v4 + 1120))(a2);
        *a3 = 0;
        if (v6)
        {
          strcpy(a3, v6);
          return 0;
        }
        else
        {
          return 2375032839;
        }
      }
    }
  }
  return v3;
}

uint64_t ELQXMLGetEncodingFromHeader(uint64_t a1, _BYTE *a2, unsigned __int16 *a3, unint64_t a4, int a5)
{
  unsigned __int16 *v6;
  _BYTE *v7;
  uint64_t result;
  BOOL v10;
  uint64_t v11;
  const char *v12;
  unsigned int v13;
  const char *v14;
  unsigned int v15;
  uint64_t v17;
  unsigned __int16 *v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  int v26;
  int v27;
  unsigned __int8 *v28;
  uint64_t v29;
  int v30;
  unsigned __int16 *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  unsigned __int16 v37[80];
  uint64_t v38;

  v6 = a3;
  v7 = a2;
  v38 = *MEMORY[0x1E0C80C00];
  result = 2375032839;
  if ((!a1 || *(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser) && a2 && a3)
  {
    v10 = 0;
    *a2 = 0;
    if (a4 >= 0xA)
    {
      v35 = a5;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = (char *)v6 + v11;
        v15 = *((unsigned __int8 *)v6 + v11);
        if (v15 <= 0xD && ((1 << v15) & 0x2401) != 0)
        {
LABEL_17:
          v10 = 0;
          v7 = a2;
          a5 = v35;
          goto LABEL_18;
        }
        if (!strncmp(v14, "encoding", 8uLL))
          v12 = v14;
        v11 = v13 + 1;
        if (v15 == 63 && *((_BYTE *)v6 + v11) == 62)
          break;
        ++v13;
        if (v11 + 9 >= a4)
          goto LABEL_17;
      }
      v10 = 0;
      v7 = a2;
      a5 = v35;
      if (v12)
      {
        if (v12 < v14)
        {
          while (1)
          {
            v26 = *(unsigned __int8 *)v12;
            if (v26 == 34 || v26 == 39)
              break;
            v10 = 0;
            if (++v12 == (char *)v6 + v13)
              goto LABEL_18;
          }
          v28 = (unsigned __int8 *)(v12 + 1);
          if (v12 + 1 >= v14)
          {
            v34 = 0;
          }
          else
          {
            v29 = 1;
            while (1)
            {
              v30 = v12[v29];
              if (v30 == 34 || v30 == 39)
                break;
              a2[(v29++ - 1)] = v30;
              v28 = (unsigned __int8 *)&v12[v29];
              if (&v12[v29] >= v14)
                goto LABEL_68;
            }
            v28 = (unsigned __int8 *)&v12[v29];
LABEL_68:
            v34 = v29 - 1;
          }
          if (v28 == (unsigned __int8 *)v14)
            return 2375040625;
          a2[v34] = 0;
          v10 = *a2 != 0;
        }
      }
    }
LABEL_18:
    result = 0;
    if (a5 != 65001 && !v10)
    {
      if (a1)
        v17 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1200) + 8);
      else
        v17 = 0;
      TxtEncodingConvert(v17, 65001, 1200, "encoding", 0xFFFFFFFFFFFFFFFFLL, (uint64_t)v37, 0x50uLL, 0);
      v18 = 0;
      v19 = a4 >> 1;
      v20 = a4 >> 1 > 9;
      v21 = 9;
      if (v20)
        v22 = v19;
      else
        v22 = 9;
      while (1)
      {
        if (v22 == v21)
          return 0;
        v23 = *v6;
        v20 = v23 > 0xD;
        v24 = (1 << v23) & 0x2401;
        if (!v20 && v24 != 0)
          return 0;
        if (!ELQwcsncmp(v6, v37, 8))
          v18 = v6;
        if (*v6 == 63 && v6[1] == 62)
          break;
        result = 0;
        ++v21;
        ++v6;
        if (v21 == 265)
          return result;
      }
      result = 0;
      if (v18)
      {
        while (v18 < v6)
        {
          v27 = *v18;
          if (v27 == 34 || v27 == 39)
          {
            v31 = v18 + 1;
            if (v18 + 1 >= v6)
            {
              v32 = 0;
            }
            else
            {
              v32 = 0;
              do
              {
                v33 = *v31;
                if (v33 == 34)
                  break;
                if (v33 == 39)
                  break;
                v7[v32++] = v33;
                ++v31;
              }
              while (v31 < v6);
            }
            if (v6 != v31)
            {
              result = 0;
              v7[v32] = 0;
              return result;
            }
            return 2375040625;
          }
          result = 0;
          ++v18;
        }
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetUnknownEncodingHandler(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)())a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1128))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLUnknownEncodingHandler(uint64_t result, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  int v5;
  int Id;
  _DWORD *v7;
  uint64_t i;
  int v9;
  uint64_t v10;

  if (result)
  {
    if (*(uint64_t (**)())result == ELQXMLIniParser
      && (v3 = *(_QWORD *)(result + 16)) != 0
      && (v10 = 0, *(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController))
    {
      v5 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(v3 + 1136))(*(_QWORD *)(result + 8), a3, &v10);
      result = 0;
      if (a2)
      {
        if (!v5)
        {
          Id = TxtEncodingGetId(a2);
          result = (uint64_t)TxtEncodingGetMap(Id, 1);
          if (result)
          {
            v7 = (_DWORD *)result;
            for (i = 0; i != 255; ++i)
            {
              v9 = TxtEncodingCharToWChar(i, v7);
              *(_DWORD *)(v10 + 4 * i) = v9;
              result = 1;
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ELQXMLReset(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 2375032834;
  if (!a1)
    return 2375032839;
  if (*(uint64_t (**)(_QWORD, _QWORD))a1 == ELQXMLIniParser)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_QWORD *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController)
        return (*(uint64_t (**)(_QWORD))(v3 + 1160))(*(_QWORD *)(a1 + 8));
    }
  }
  return result;
}

uint64_t ELQXMLGetControllerFromParser(uint64_t result)
{
  if (result)
  {
    if (*(uint64_t (**)())result == ELQXMLIniParser)
      return *(_QWORD *)(result + 16);
    else
      return 0;
  }
  return result;
}

uint64_t Wav2PCM(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, int a5, char *a6, uint64_t *a7, unsigned int *a8)
{
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  _DWORD *v50;
  const void *v51;
  unsigned int v52;
  uint64_t v53;
  unsigned int v54;
  unsigned int v55;
  __int16 *v56;
  unsigned int v57;
  int v58;
  unsigned __int8 v59;
  _QWORD *v60;
  uint64_t v61;
  char __s2[40];
  _QWORD v63[201];

  v63[199] = *MEMORY[0x1E0C80C00];
  v60 = 0;
  v61 = 0;
  v59 = 0;
  v57 = 0;
  v58 = 0;
  v56 = 0;
  if (!a3)
    return 2269126663;
  result = 2269126663;
  if (a8)
  {
    if (a7)
    {
      if (a6)
      {
        if (a5)
        {
          if (a4)
          {
            if (*a3)
            {
              *a6 = 0;
              *a7 = 0;
              *a8 = 0;
              result = InitRsrcFunction(a1, a2, &v61);
              if ((result & 0x80000000) == 0)
              {
                result = ssftriff_reader_ObjOpenEx(a1, a2, 4, a3, a4, a5, "WAVE", 0, (uint64_t *)&v60);
                if ((result & 0x80000000) == 0)
                {
                  v54 = 0;
                  v55 = 0;
                  while (1)
                  {
                    v21 = ssftriff_reader_OpenChunk((uint64_t)v60, &v58, &v57, &v56, v17, v18, v19, v20);
                    if ((v21 & 0x80000000) != 0)
                    {
LABEL_34:
                      if ((v21 & 0x1FFF) == 0x14)
                        v42 = 0;
                      else
                        v42 = v21;
                      if (!*a6)
                      {
                        log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 149, "%s%s", v17, v18, v19, v20, "url");
                        goto LABEL_55;
                      }
                      if (v54 != 1)
                      {
                        if (!v54)
                        {
                          log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 150, "%s%s", v17, v18, v19, v20, "url");
                          goto LABEL_55;
                        }
                        log_OutText(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAVE URL %s has %u audio chunks, will be concatenated", v18, v19, v20, (uint64_t)a3);
                      }
                      if (v55)
                      {
                        v43 = heap_Alloc(*(_QWORD *)(v61 + 8), v55);
                        *a7 = v43;
                        if (!v43)
                        {
                          log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 151, "%s%lu", v44, v45, v46, v47, "sizeBytes");
                          v53 = 2269126666;
                          goto LABEL_56;
                        }
                        v48 = (char *)v43;
                        v49 = v54;
                        v50 = v63;
                        do
                        {
                          v51 = (const void *)*((_QWORD *)v50 - 1);
                          v52 = *v50;
                          v50 += 4;
                          memcpy(v48, v51, v52);
                          v48 += v52;
                          --v49;
                        }
                        while (v49);
                      }
                      *a8 = v55;
                      v53 = v42;
                      goto LABEL_56;
                    }
                    if (v58 ^ 0x20746D66 | v59)
                    {
                      if (v58 ^ 0x61746164 | v59)
                      {
                        log_OutText(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Ignoring RIFF WAVE chunk %s in URL %s (%lu bytes)", v18, v19, v20, (uint64_t)&v58);
                      }
                      else
                      {
                        v40 = &__s2[16 * v54 + 32];
                        *(_QWORD *)v40 = v56;
                        v41 = v57;
                        *((_DWORD *)v40 + 2) = v57;
                        ++v54;
                        v55 += v41;
                        log_OutText(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAV %s: audio chunk %u, %lu bytes", v18, v19, v20, (uint64_t)a3);
                      }
                    }
                    else
                    {
                      if (v57 <= 0xF)
                      {
                        log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 143, "%s%s", v17, v18, v19, v20, "url");
                        goto LABEL_55;
                      }
                      v25 = *v56;
                      v26 = v56[1];
                      v28 = *((_DWORD *)v56 + 1);
                      v27 = *((_DWORD *)v56 + 2);
                      v29 = v56[6];
                      v30 = v56[7];
                      log_OutText(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAV %s: format %d, %d channels, %ld HZ, %ld bytes per sec, %d block align, %d bits per sample", v18, v19, v20, (uint64_t)a3);
                      if (v26 != 1)
                      {
                        log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 144, "%s%s%s%d", v31, v32, v33, v34, "url");
                        goto LABEL_55;
                      }
                      switch(v25)
                      {
                        case 7:
                          if (v28 != 8000 || v27 != 8000 || v29 != 1 || v30 != 8)
                          {
                            log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 147, "%s%s%s%s%s%ld%s%ld%s%d%s%d", v31, v32, v33, v34, "url");
                            goto LABEL_55;
                          }
                          strcpy(a6, "audio/basic");
                          break;
                        case 6:
                          if (v28 != 8000 || v27 != 8000 || v29 != 1 || v30 != 8)
                          {
                            log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 146, "%s%s%s%s%s%ld%s%ld%s%d%s%d", v31, v32, v33, v34, "url");
LABEL_55:
                            v53 = 2269126660;
LABEL_56:
                            if (v60)
                              ssftriff_reader_ObjClose(v60, v22, v23, v24, v17, v18, v19, v20);
                            return v53;
                          }
                          strcpy(a6, "audio/x-alaw-basic");
                          break;
                        case 1:
                          *(_QWORD *)a6 = 0x4C2F6F69647561;
                          LH_itoa(v30, __s2, 0xAu);
                          v35 = strcat(a6, __s2);
                          strcpy(&a6[strlen(v35)], ";endian=little;rate=");
                          LH_itoa(v28, __s2, 0xAu);
                          strcat(a6, __s2);
                          if (v30 != 16)
                          {
                            log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 145, "%s%s%s%s%s%d", v36, v37, v38, v39, "url");
                            goto LABEL_55;
                          }
                          break;
                        default:
                          log_OutPublic(*(_QWORD *)(v61 + 32), (uint64_t)"AUDIOFETCH", 148, "%s%s%s%d", v31, v32, v33, v34, "url");
                          goto LABEL_55;
                      }
                    }
                    v21 = ssftriff_reader_CloseChunk((uint64_t)v60);
                    if ((v21 & 0x80000000) != 0)
                      goto LABEL_34;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t Au2PCM(_WORD *a1, int a2, _BYTE *a3, _DWORD *a4, unsigned int a5, char *a6, _QWORD *a7, unsigned int *a8, int a9)
{
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  size_t v35;
  unsigned int v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  char __s2[32];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v44 = 0;
  if (!a3)
    return 2269126663;
  result = 2269126663;
  if (!a8)
    return result;
  if (!a7)
    return result;
  if (!a6)
    return result;
  if (!a5)
    return result;
  if (!a4)
    return result;
  if (!*a3)
    return result;
  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  result = InitRsrcFunction(a1, a2, &v44);
  if ((result & 0x80000000) != 0)
    return result;
  if (*a4 == 1684960046)
  {
    if (a5 <= 0xBF)
    {
      log_OutPublic(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 101, "%s%s", v17, v18, v19, v20, "url");
      return 2269126660;
    }
    v21 = bswap32(a4[1]);
    v25 = bswap32(a4[2]);
    v22 = bswap32(a4[3]);
    v24 = bswap32(a4[4]);
    v23 = bswap32(a4[5]);
  }
  else
  {
    v21 = 0;
    if (a9)
      v22 = 27;
    else
      v22 = 1;
    v23 = 1;
    v24 = 8000;
    v25 = a5;
  }
  v42 = v25;
  v43 = v21;
  log_OutText(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Sun Au %s: encoding %u, %u channels, %u HZ, %u data offset, %u data size", v18, v19, v20, (uint64_t)a3);
  v30 = v44;
  if (v23 != 1)
  {
    log_OutPublic(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 102, "%s%s%s%u", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  if (v22 == 1)
  {
    v32 = v42;
    v31 = v43;
    if (v24 != 8000)
    {
      log_OutPublic(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 104, "%s%s%s%s%s%u", v26, v27, v28, v29, "url");
      return 2269126660;
    }
    strcpy(a6, "audio/basic");
  }
  else
  {
    v32 = v42;
    v31 = v43;
    if (v22 == 27)
    {
      if (v24 != 8000)
      {
        log_OutPublic(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 103, "%s%s%s%s%s%u", v26, v27, v28, v29, "url");
        return 2269126660;
      }
      strcpy(a6, "audio/x-alaw-basic");
    }
    else
    {
      if (v22 != 3)
      {
        log_OutPublic(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 105, "%s%s%s%u", v26, v27, v28, v29, "url");
        return 2269126660;
      }
      strcpy(a6, "audio/L16;endian=big;rate=");
      v33 = v24;
      v34 = v30;
      LH_itoa(v33, __s2, 0xAu);
      strcat(a6, __s2);
      v30 = v34;
      v32 = v42;
      v31 = v43;
    }
  }
  if (!v32)
  {
    log_OutPublic(*(_QWORD *)(v30 + 32), (uint64_t)"AUDIOFETCH", 106, "%s%s", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  if (v32 + v31 > a5)
  {
    log_OutPublic(*(_QWORD *)(v30 + 32), (uint64_t)"AUDIOFETCH", 107, "%s%s", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  v35 = v32;
  v36 = v32;
  v37 = (void *)heap_Alloc(*(_QWORD *)(v44 + 8), v32);
  *a7 = v37;
  if (v37)
  {
    memcpy(v37, (char *)a4 + v43, v35);
    result = 0;
    *a8 = v36;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(v44 + 32), (uint64_t)"AUDIOFETCH", 108, "%s%lu", v38, v39, v40, v41, "sizeBytes");
    return 2269126666;
  }
  return result;
}

uint64_t audiofetch_LoadAPDB(uint64_t a1, int a2, const char *a3)
{
  uint64_t ReadOnly;
  const char *v6;
  int v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v21 = 0;
  ReadOnly = 2269126663;
  if (a3)
  {
    if (*a3)
    {
      ReadOnly = safeh_HandleCheck(a1, a2, 702, 64);
      if ((ReadOnly & 0x80000000) == 0 && !strncmp(a3, "x-vocalizer-speechbase://", 0x19uLL))
      {
        v6 = a3 + 25;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v7 = strlen(a3 + 25);
        v8 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), (v7 + 1));
        if (v8)
        {
          v13 = (uint64_t)v8;
          strcpy(v8, v6);
          ReadOnly = ssftmap_FindReadOnly(*(_QWORD *)(a1 + 48), v13, &v21);
          if ((ReadOnly & 0x80000000) != 0)
          {
            v24 = 0u;
            v25 = 0u;
            v22 = 0u;
            v23 = 0u;
            v23 = *(_OWORD *)a1;
            v24 = *(_OWORD *)(a1 + 16);
            LOWORD(v22) = GetEngineFreq(a1);
            *((_QWORD *)&v22 + 1) = v13;
            v14 = ssftmap_Insert(*(_QWORD *)(a1 + 48), v13, (uint64_t)&v22);
            if ((v14 & 0x80000000) != 0)
            {
              ReadOnly = v14;
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 155, "%s%s", v15, v16, v17, v18, "speechbase");
            }
            else
            {
              ReadOnly = ssftmap_FindReadOnly(*(_QWORD *)(a1 + 48), v13, &v21);
            }
          }
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v13);
        }
        else
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v9, v10, v11, v12, v20);
          return 2269126666;
        }
      }
    }
  }
  return ReadOnly;
}

uint64_t GetEngineFreq(uint64_t a1)
{
  uint64_t v1;
  unsigned int v4;

  v4 = 0;
  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
  if (!v1 || (paramc_ParamGetUInt(v1, (uint64_t)"frequencyhz", &v4) & 0x80000000) != 0)
    return 0;
  else
    return (unsigned __int16)v4;
}

uint64_t audiofetch_ReleaseAPDB(uint64_t a1, int a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  int v8;
  int v9;
  uint64_t v11;
  char *__s2;
  uint64_t *v13;

  v13 = 0;
  v5 = safeh_HandleCheck(a1, a2, 702, 64);
  if ((v5 & 0x80000000) == 0 && !strncmp(a3, "x-vocalizer-speechbase://", 0x19uLL))
  {
    v6 = ssftmap_IteratorOpen(*(_QWORD *)(a1 + 48), 0, 0, (uint64_t)&v13);
    if ((v6 & 0x80000000) != 0)
      return v6;
    v11 = 0;
    __s2 = 0;
    v7 = a3 + 25;
    while (1)
    {
      while (1)
      {
        v8 = ssftmap_IteratorNext(v13, &__s2, &v11);
        if (v8 < 0)
        {
LABEL_12:
          v9 = ssftmap_IteratorClose((uint64_t)v13);
          return v9 & (v9 >> 31);
        }
        if (!v8)
          break;
LABEL_9:
        if (v8 < 0)
          goto LABEL_12;
      }
      if (strcmp(v7, __s2))
      {
        v8 = 0;
        goto LABEL_9;
      }
      if ((ssftmap_IteratorRemove(v13) & 0x80000000) != 0)
        goto LABEL_12;
    }
  }
  return v5;
}

uint64_t audiofetch_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2269126657;
  result = 0;
  *a2 = &ITFAudioUri;
  return result;
}

uint64_t audiofetch_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2269126663;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 701;
  }
  return result;
}

uint64_t audiofetch_ClassClose()
{
  return 0;
}

uint64_t audiofetch_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  __int128 v31;
  __int128 v32;
  _QWORD *(*v33)(_QWORD *, _QWORD *);
  uint64_t v34;

  v34 = 0;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v34);
  if ((inited & 0x80000000) != 0)
    return inited;
  v11 = 2269126664;
  if ((safeh_HandleCheck(a1, a2, 701, 408) & 0x80000000) == 0)
  {
    log_OutText(*(_QWORD *)(v34 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjOpen", v12, v13, v14, v31);
    v15 = heap_Calloc(*(_QWORD **)(v34 + 8), 1, 64);
    if (v15)
    {
      v20 = (_QWORD *)v15;
      *(_QWORD *)v15 = a3;
      *(_QWORD *)(v15 + 8) = a4;
      v21 = v34;
      *(_QWORD *)(v15 + 16) = v34;
      *(_QWORD *)(v15 + 24) = a1;
      *(_DWORD *)(v15 + 32) = 1;
      *(_DWORD *)(v15 + 56) = 1;
      v22 = *(_QWORD **)(v21 + 8);
      v31 = xmmword_1EA94A420;
      v32 = *(_OWORD *)&off_1EA94A430;
      v33 = audiofetch_ElemFreeAudioVarLenBuf;
      v23 = ssftmap_ObjOpen(v22, 0, &v31, v20 + 5);
      v28 = v20[2];
      if ((v23 & 0x80000000) != 0)
      {
        v11 = v23;
      }
      else
      {
        v29 = *(_QWORD **)(v28 + 8);
        v31 = xmmword_1EA94A448;
        v32 = *(_OWORD *)off_1EA94A458;
        v33 = audiofetch_ElemFreeSpeechBase;
        v11 = ssftmap_ObjOpen(v29, 0, &v31, v20 + 6);
        if ((v11 & 0x80000000) == 0)
        {
          *(_QWORD *)a5 = v20;
          *(_DWORD *)(a5 + 8) = 702;
LABEL_12:
          log_OutText(*(_QWORD *)(v34 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjOpen", v25, v26, v27, v31);
          return v11;
        }
        v28 = v20[2];
      }
      log_OutPublic(*(_QWORD *)(v28 + 32), (uint64_t)"AUDIOFETCH", 130, 0, v24, v25, v26, v27, v31);
      *(_QWORD *)a5 = v20;
      *(_DWORD *)(a5 + 8) = 702;
      audiofetch_ObjClose(v20, *(_QWORD *)(a5 + 8));
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      goto LABEL_12;
    }
    log_OutPublic(*(_QWORD *)(v34 + 32), (uint64_t)"AUDIOFETCH", 100, 0, v16, v17, v18, v19, v31);
    v11 = 2269126666;
    goto LABEL_12;
  }
  return v11;
}

uint64_t audiofetch_ObjClose(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;

  v6 = safeh_HandleCheck((uint64_t)a1, a2, 702, 64);
  if ((v6 & 0x80000000) == 0)
  {
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjClose", v3, v4, v5, v13);
    v10 = a1[6];
    if (v10)
      v6 = ssftmap_ObjClose(v10);
    v11 = a1[5];
    if (v11)
      v6 = ssftmap_ObjClose(v11);
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjClose", v7, v8, v9, v14);
    heap_Free(*(_QWORD **)(a1[2] + 8), (uint64_t)a1);
  }
  return v6;
}

uint64_t audiofetch_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int EngineFreq;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  unsigned __int16 v21;

  v21 = 0;
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v3 = safeh_HandleCheck(a1, a2, 702, 64);
  if ((v3 & 0x80000000) != 0)
    return v3;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjReopen", v4, v5, v6, v18);
  EngineFreq = GetEngineFreq(a1);
  v8 = ssftmap_IteratorOpen(*(_QWORD *)(a1 + 48), 0, 0, (uint64_t)&v20);
  if ((v8 & 0x80000000) == 0)
  {
    while (1)
    {
      v12 = ssftmap_IteratorNext(v20, &v19, &v18);
      if (v12 < 0)
        break;
      v13 = (*(uint64_t (**)(_QWORD, unsigned __int16 *))(*(_QWORD *)(v18 + 48) + 88))(*(_QWORD *)(v18 + 56), &v21);
      if (v13 < 0 || (v14 = v13, v21 != EngineFreq))
      {
        v14 = ssftmap_IteratorRemove(v20);
        if (v14 < 0)
          goto LABEL_12;
      }
      else if (v13 < 0)
      {
        goto LABEL_12;
      }
    }
    v14 = v12;
LABEL_12:
    v8 = ssftmap_IteratorClose((uint64_t)v20);
    if (v8 >= 0 || (v14 & 0x1FFF) != 23)
      v8 = v14;
  }
  if ((v8 & 0x1FFF) == 0x17)
    v15 = 0;
  else
    v15 = v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjReopen", v9, v10, v11, v18);
  return v15;
}

uint64_t audiofetch_Reset(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  unsigned int v5;

  v5 = 0;
  result = safeh_HandleCheck(a1, a2, 702, 64);
  if ((result & 0x80000000) == 0)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
    if (v4)
    {
      result = paramc_ParamGetUInt(v4, (uint64_t)"pipelineswitchexecuting", &v5);
      if ((result & 0x80000000) != 0)
      {
        v5 = 0;
      }
      else if (v5 == 1)
      {
        return result;
      }
    }
    result = ssftmap_Clear(*(_QWORD *)(a1 + 40));
    *(_DWORD *)(a1 + 32) = 1;
  }
  return result;
}

uint64_t audiofetch_Fetch(uint64_t a1, int a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  return fetchAudio(a1, a2, a3, a4, a7, 0);
}

uint64_t audiofetch_Release(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;

  result = safeh_HandleCheck(a1, a2, 702, 64);
  if ((result & 0x80000000) == 0)
    return ssftmap_Remove(*(_QWORD *)(a1 + 40), a3);
  return result;
}

uint64_t audiofetch_FetchStreamOpen(_QWORD *a1, int a2, uint64_t a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t ReadOnly;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  unsigned int v66;
  uint64_t v67;
  int v68;

  v67 = 0;
  *a4 = 0;
  *a5 = 0;
  *(_QWORD *)a7 = 0;
  *(_DWORD *)(a7 + 8) = 0;
  v13 = safeh_HandleCheck((uint64_t)a1, a2, 702, 64);
  if ((v13 & 0x80000000) != 0)
    return v13;
  ReadOnly = ssftmap_FindReadOnly(a1[5], a3, &v67);
  if ((ReadOnly & 0x80000000) == 0)
  {
    v15 = (_QWORD *)heap_Calloc(*(_QWORD **)(a1[2] + 8), 1, 96);
    v20 = a1[2];
    if (!v15)
    {
      log_OutPublic(*(_QWORD *)(v20 + 32), (uint64_t)"AUDIOFETCH", 100, 0, v16, v17, v18, v19, v66);
      return 2269126666;
    }
    v21 = v15;
    *v15 = v20;
    v15[1] = a1;
    v22 = v67;
    v15[2] = v67;
    v23 = *(_QWORD *)(v22 + 40);
    if (v23)
    {
      ReadOnly = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v22 + 32) + 48))(v23, *(unsigned int *)(v22 + 48), *(unsigned int *)(v22 + 16));
      if ((ReadOnly & 0x80000000) != 0)
        log_OutPublic(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 157, "%s%s%s%x", v24, v25, v26, v27, "uri");
    }
    else
    {
      v28 = *(_DWORD *)(v22 + 76);
      if (v28 != 3)
      {
        v29 = 0;
        while (AudioFetchDecoderIndex[v29] != v28)
        {
          v29 += 6;
          if ((_DWORD)(v29 * 4) == 96)
          {
            log_OutPublic(*(_QWORD *)(v20 + 32), (uint64_t)"AUDIOFETCH", 162, "%s%s%s%d", v16, v17, v18, v19, "uri");
            ReadOnly = 2269126657;
            goto LABEL_19;
          }
        }
        v30 = &AudioFetchDecoderIndex[v29];
        v31 = brk_InterfaceQuery(*(_QWORD *)(v20 + 24));
        if ((v31 & 0x80000000) != 0)
        {
          ReadOnly = v31;
          log_OutPublic(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 160, "%s%s%s%s%s%x", v32, v33, v34, v35, "decoder");
        }
        else
        {
          ReadOnly = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD *))(v21[3] + 32))(v30[4], 0, *a1, a1[1], 0, 0, 0, v21 + 4);
          if ((ReadOnly & 0x80000000) != 0)
            log_OutPublic(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 161, "%s%s%s%s%s%x", v36, v37, v38, v39, "decoder");
        }
      }
    }
LABEL_19:
    if (*(_DWORD *)(v67 + 80) != 1)
    {
LABEL_36:
      if ((ReadOnly & 0x80000000) == 0)
      {
        v63 = v67;
        *a4 = *(_QWORD *)(v67 + 24);
        v64 = *(_DWORD *)(v63 + 16);
        *a5 = v64;
        if (*(_DWORD *)(v63 + 80) == 1)
          v64 = *((_DWORD *)v21 + 22);
        *a6 = v64;
        *(_QWORD *)a7 = v21;
        *(_DWORD *)(a7 + 8) = 703;
        return ReadOnly;
      }
LABEL_41:
      *(_QWORD *)a7 = v21;
      *(_DWORD *)(a7 + 8) = 703;
      audiofetch_FetchStreamClose(v21, *(_QWORD *)(a7 + 8), 0);
      *(_QWORD *)a7 = 0;
      *(_DWORD *)(a7 + 8) = 0;
      return ReadOnly;
    }
    v40 = *(unsigned int *)(v67 + 16);
    v68 = 0;
    v41 = v21[2];
    v42 = *(unsigned __int16 *)(v41 + 68);
    v43 = *(unsigned __int16 *)(v41 + 70);
    v44 = v42;
    if (*(_WORD *)(v41 + 70))
    {
      v45 = *(unsigned __int16 *)(v41 + 70);
      v46 = v42;
      do
      {
        v44 = v45;
        v45 = v46 % v45;
        v46 = v44;
      }
      while (v45);
    }
    v47 = (_QWORD *)v21[8];
    if (v47)
    {
      spxrsmp_resampler_destroy(v47);
      v21[8] = 0;
      v48 = v21[2];
      v42 = *(unsigned __int16 *)(v48 + 68);
      v43 = *(unsigned __int16 *)(v48 + 70);
    }
    v49 = spxrsmp_resampler_init(*v21, 1u, v42, v43, 7u, &v68);
    v21[8] = v49;
    if (!v68 && v49)
    {
      v54 = v21[2];
      v55 = *(unsigned __int16 *)(v54 + 70) / v44;
      *((_WORD *)v21 + 28) = v55;
      v56 = *(unsigned __int16 *)(v54 + 68) / v44;
      *((_WORD *)v21 + 29) = v56;
      *((_DWORD *)v21 + 18) = 1;
      v57 = v40 * (unint64_t)v55 / v56 + 16;
      if (v57 <= v40)
        v57 = v40;
      v58 = 2 * v57;
      v59 = v21[10];
      if (v59)
      {
        v60 = v21 + 11;
        if (v21[11] >= v58)
          goto LABEL_36;
        v61 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(v21[1] + 16) + 8), v59, v58);
        if (v61)
        {
          v21[10] = v61;
LABEL_35:
          *v60 = v58;
          goto LABEL_36;
        }
      }
      else
      {
        v62 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(v21[1] + 16) + 8), v58);
        v21[10] = v62;
        if (v62)
        {
          v60 = v21 + 11;
          goto LABEL_35;
        }
      }
    }
    ReadOnly = 2269126656;
    v21[8] = 0;
    log_OutPublic(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 137, "%s%s%s%hu%s%hu", v50, v51, v52, v53, "uri");
    goto LABEL_41;
  }
  return ReadOnly;
}

uint64_t audiofetch_FetchStreamRead(uint64_t a1, int a2, unsigned int a3, uint64_t a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t v11;
  unsigned int v12;
  unsigned int *v13;
  _WORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v30;
  uint64_t v31;
  int v32;
  __int16 v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  _WORD *v41;
  unsigned int *v42;
  unsigned int v43;
  const char *v44;
  uint64_t v45;
  __int16 v46;
  unsigned __int16 v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;

  v51 = a3;
  v49 = 0;
  *a5 = 0;
  v11 = safeh_HandleCheck(a1, a2, 703, 96);
  if ((v11 & 0x80000000) != 0)
    return v11;
  v12 = a3;
  v13 = a5;
  v14 = (_WORD *)a4;
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    v14 = *(_WORD **)(a1 + 80);
    v13 = (unsigned int *)&v49;
    v12 = *(unsigned __int16 *)(a1 + 58) * a3 / *(unsigned __int16 *)(a1 + 56);
  }
  v15 = 2269126663;
  v50 = v12;
  if (!a4 || !a3)
    return 2269126663;
  v16 = *(unsigned int *)(a1 + 48);
  v17 = *(_QWORD *)(a1 + 16);
  v18 = *(_DWORD *)(v17 + 16);
  if (v18 <= v16)
    return 2269126659;
  v19 = v18 - v16;
  if (v19 < v12)
  {
    v50 = v19;
    v12 = v19;
  }
  if (!*(_QWORD *)(v17 + 40))
  {
    if (*(_QWORD *)(a1 + 24))
    {
      if (v12)
      {
        do
        {
          v30 = *(_QWORD *)(a1 + 16);
          v31 = *(_QWORD *)(a1 + 24);
          v32 = *(unsigned __int16 *)(v30 + 72);
          v33 = v12 * v32;
          if (v12 * v32 >= 0xFFFF)
            v33 = -1;
          LOWORD(v48) = v33;
          if (v12 >> 15)
            v34 = -1;
          else
            v34 = 2 * v12;
          v47 = v34;
          v46 = 0;
          v11 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, unsigned int *, _QWORD, _WORD *, unsigned __int16 *, _QWORD, __int16 *, const char *, uint64_t))(v31 + 112))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0, *(_QWORD *)(v30 + 56) + (*(_DWORD *)(a1 + 48) * v32), &v48, 0, &v14[*v13], &v47, 0, &v46, v44, v45);
          if ((v11 & 0x80000000) != 0 || !(_WORD)v48)
          {
            v44 = "lhError";
            v45 = v11;
            log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"AUDIOFETCH", 163, "%s%s%s%x", v35, v36, v37, v38, "uri");
            v12 = v50;
          }
          else
          {
            v39 = v47;
            *(_DWORD *)(a1 + 48) += v47 >> 1;
            *v13 += v39 >> 1;
            v12 = v50 - (v39 >> 1);
            v50 = v12;
          }
        }
        while ((v11 & 0x80000000) == 0 && v12);
        v15 = 2269126663;
        if ((v11 & 0x80000000) != 0)
          return v11;
      }
      *a5 = *v13;
      if (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 80) != 1)
      {
        *a6 = *v13;
        return v11;
      }
      v40 = *(_QWORD *)(a1 + 64);
      v41 = v14;
      v42 = v13;
    }
    else
    {
      memcpy(v14, (const void *)(*(_QWORD *)(v17 + 56) + 2 * v16), 2 * v12);
      *(_DWORD *)(a1 + 48) += v12;
      *a5 = v12;
      if (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 80) != 1)
      {
        *a6 = v12;
        return v11;
      }
      v40 = *(_QWORD *)(a1 + 64);
      v42 = &v50;
      v41 = v14;
    }
    v43 = spxrsmp_resampler_process_int(v40, 0, v41, v42, a4, &v51);
    if (v43 <= 2)
      v15 = dword_1DECEAC94[v43];
    *a6 = v51;
    return v15;
  }
  v48 = v12;
  if (v12)
  {
    while (1)
    {
      v11 = (*(uint64_t (**)(_QWORD, unsigned int *, _WORD *))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32) + 72))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), &v48, &v14[*v13]);
      if ((v11 & 0x80000000) != 0)
        break;
      v24 = v48;
      v25 = v50;
      *v13 += v48;
      v50 = v25 - v24;
      if (v25 == v24)
        goto LABEL_13;
    }
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"AUDIOFETCH", 158, "%s%s%s%x", v20, v21, v22, v23, "uri");
  }
  else
  {
LABEL_13:
    *a5 = *v13;
    if (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 80) == 1)
    {
      v26 = spxrsmp_resampler_process_int(*(_QWORD *)(a1 + 64), 0, v14, v13, a4, &v51);
      v27 = -2025840623;
      v28 = -2025840630;
      if (v26 != 1)
        v28 = -2025840633;
      if (v26 != 2)
        v27 = v28;
      v13 = &v51;
      if (v26)
        v11 = v27;
      else
        v11 = 0;
    }
    *a6 = *v13;
    *(_DWORD *)(a1 + 48) += *a5;
  }
  return v11;
}

uint64_t audiofetch_FetchStreamClose(_QWORD *a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v21;
  int v22;

  v5 = safeh_HandleCheck((uint64_t)a1, a2, 703, 96);
  if ((v5 & 0x80000000) == 0)
  {
    v6 = a1[2];
    if (*(_QWORD *)(v6 + 40))
    {
      v5 = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 32) + 64))();
      if ((v5 & 0x80000000) != 0)
        log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"AUDIOFETCH", 159, "%s%s%s%x", v7, v8, v9, v10, "uri");
    }
    v11 = a1[3];
    if (v11)
    {
      v12 = a1[4];
      if (v12)
      {
        v13 = (*(uint64_t (**)(uint64_t, _QWORD))(v11 + 40))(v12, a1[5]);
        if (v13 < 0)
        {
          v18 = v13;
          log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"AUDIOFETCH", 164, "%s%x", v14, v15, v16, v17, "lhError");
          if ((int)v5 >= 0)
            LODWORD(v5) = v18;
        }
      }
      v19 = brk_InterfaceRelease(*(_QWORD *)(*a1 + 24), a1[3]);
      if (v19 >= 0 || (int)v5 <= -1)
        v5 = v5;
      else
        v5 = v19;
    }
    if (*(_DWORD *)(a1[2] + 80) == 1)
    {
      spxrsmp_resampler_destroy((_QWORD *)a1[8]);
      v21 = a1[10];
      if (v21)
        heap_Free(*(_QWORD **)(*(_QWORD *)(a1[1] + 16) + 8), v21);
      a1[10] = 0;
      a1[11] = 0;
      a1[8] = 0;
      *((_DWORD *)a1 + 18) = 0;
    }
    if (a3)
    {
      v22 = ssftmap_Remove(*(_QWORD *)(a1[1] + 40), *(_QWORD *)(a1[2] + 8));
      if (v22 >= 0 || (int)v5 <= -1)
        v5 = v5;
      else
        v5 = v22;
    }
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)a1);
  }
  return v5;
}

uint64_t audiofetch_GetAudioURI(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  int ReadOnly;
  uint64_t v9;

  v9 = 0;
  result = 2269126663;
  if (a3)
  {
    if (a4)
    {
      result = safeh_HandleCheck(a1, a2, 702, 64);
      if ((result & 0x80000000) == 0)
      {
        ReadOnly = ssftmap_FindReadOnly(*(_QWORD *)(a1 + 40), a3, &v9);
        result = 0;
        if ((ReadOnly & 0x80000000) == 0)
        {
          if (v9)
          {
            result = 0;
            *a4 = *(_QWORD *)(v9 + 24);
          }
        }
      }
    }
  }
  return result;
}

uint64_t audiofetch_FetchSsml(uint64_t a1, int a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  return fetchAudio(a1, a2, a3, a4, a7, 1);
}

uint64_t audiofetch_ElemCopyAudioVarLenBuf(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;

  if (!a1)
    return 2269126663;
  result = 0;
  ++*a1;
  *a3 = a1;
  return result;
}

_QWORD *audiofetch_ElemFreeAudioVarLenBuf(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v2 = (uint64_t)result;
    v3 = *(unsigned __int16 *)result;
    if (v3 < 2)
    {
      v5 = result[1];
      if (v5)
        heap_Free(a2, v5);
      v6 = *(_QWORD *)(v2 + 24);
      if (v6)
        heap_Free(a2, v6);
      v7 = *(_QWORD *)(v2 + 56);
      if (v7)
        heap_Free(a2, v7);
      return heap_Free(a2, v2);
    }
    else
    {
      *(_WORD *)result = v3 - 1;
    }
  }
  return result;
}

uint64_t audiofetch_ElemCopySpeechBase(__int128 *a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v3;
  _OWORD *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _OWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v3 = 2269126663;
  if (a1)
  {
    v7 = (_OWORD *)heap_Calloc(a2, 1, 64);
    if (v7)
    {
      v8 = (uint64_t)v7;
      v9 = *a1;
      v10 = a1[1];
      v11 = a1[3];
      v7[2] = a1[2];
      v7[3] = v11;
      *v7 = v9;
      v7[1] = v10;
      v12 = v7 + 3;
      v23 = 0;
      v24 = 0;
      v13 = brk_InterfaceQuery(*(_QWORD *)(*((_QWORD *)v7 + 4) + 24));
      if ((v13 & 0x80000000) != 0)
      {
        v3 = v13;
      }
      else
      {
        v14 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(v8 + 48) + 32))(*(_QWORD *)(v8 + 16), *(_QWORD *)(v8 + 24), *(_QWORD *)(v8 + 40), *(_QWORD *)(v8 + 8), v8 + 56);
        if ((v14 & 0x80000000) != 0)
        {
          v20 = v14;
          brk_InterfaceRelease(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 24), *(_QWORD *)(v8 + 48));
          *(_QWORD *)(v8 + 48) = 0;
          v3 = v20;
        }
        else
        {
          v22 = 0;
          v15 = (*(uint64_t (**)(_QWORD, __int16 *))(*(_QWORD *)v12 + 88))(*(_QWORD *)(v8 + 56), &v22);
          if ((v15 & 0x80000000) == 0 && v22 == *(_WORD *)v8)
          {
            v3 = v15;
LABEL_13:
            *a3 = v8;
            return v3;
          }
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 32), (uint64_t)"AUDIOFETCH", 134, "%s%s", v16, v17, v18, v19, "speechbase");
          (*(void (**)(uint64_t))(*(_QWORD *)(v8 + 48) + 40))(v8 + 56);
          *(_QWORD *)(v8 + 56) = 0;
          brk_InterfaceRelease(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 24), *(_QWORD *)(v8 + 48));
          *(_QWORD *)(v8 + 48) = 0;
          v3 = 2269126681;
        }
      }
      heap_Free(a2, v8);
      v8 = 0;
      goto LABEL_13;
    }
    return 2269126666;
  }
  return v3;
}

_QWORD *audiofetch_ElemFreeSpeechBase(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  if (result)
  {
    v3 = result;
    v4 = result[6];
    if (v4)
    {
      v5 = result + 7;
      if (v3[7])
      {
        (*(void (**)(_QWORD *))(v4 + 40))(v5);
        v4 = v3[6];
      }
      brk_InterfaceRelease(*(_QWORD *)(v3[4] + 24), v4);
    }
    return heap_Free(a2, (uint64_t)v3);
  }
  return result;
}

uint64_t fetchAudio(uint64_t a1, int a2, uint64_t a3, char *a4, _QWORD *a5, int a6)
{
  uint64_t v6;
  uint64_t ReadOnly;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  _BOOL8 v23;
  size_t v24;
  int v25;
  int v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  void *v60;
  size_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  char *MimeTypeFromURI;
  size_t v75;
  size_t v76;
  uint64_t v77;
  char *v78;
  char *v79;
  size_t v80;
  size_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  char *v93;
  uint64_t v94;
  unsigned int v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  char *__endptr;

  v6 = 2269126666;
  ReadOnly = 2269126663;
  if (a3 && a5 && *(_BYTE *)a3)
  {
    *a5 = 0;
    v13 = safeh_HandleCheck(a1, a2, 702, 64);
    if ((v13 & 0x80000000) == 0)
    {
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_Fetch for URI \"%s\"", v14, v15, v16, a3);
      log_OutTraceTuningData(*(uint64_t ***)(*(_QWORD *)(a1 + 16) + 32), 311, (uint64_t)"%s%s %s%s %s%s", v17, v18, v19, v20, v21, "BEG");
      if (strncmp((const char *)a3, "x-vocalizer-speechbase://", 0x19uLL))
      {
        if (a4)
        {
          if (!strncmp(a4, "cup:", 4uLL))
          {
            *(_QWORD *)&v99 = 0;
            v96 = 0;
            LODWORD(__endptr) = 0;
            MimeTypeFromURI = (char *)audiofetch_GetMimeTypeFromURI((char *)a3);
            v75 = strlen((const char *)a3);
            v76 = strlen(a4);
            v77 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), v75 + v76 + 1);
            if (v77)
            {
              v67 = (char *)v77;
              if (!strncmp(a4, "cup:", 4uLL))
              {
                sprintf(v67, "%s:%s", a4 + 4, (const char *)a3);
                v89 = strrchr(v67, 46);
                if (v89)
                  *v89 = 0;
                v90 = brk_DataOpenEx(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), (uint64_t)v67, 0, (uint64_t)&v99);
                v91 = v99;
                if ((v90 & 0x80000000) != 0)
                {
                  v6 = v90;
                }
                else
                {
                  v92 = brk_DataMapEx(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v99, 0, (uint64_t)&__endptr, (uint64_t)&v96);
                  v93 = v96;
                  if ((v92 & 0x80000000) != 0)
                  {
                    v6 = v92;
                  }
                  else
                  {
                    v6 = audiofetch_PrepareAudioTask((_WORD **)a1, (char *)a3, MimeTypeFromURI, v96, __endptr, a5);
                    v93 = v96;
                  }
                  v91 = v99;
                  if (v93)
                  {
                    brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v99, (uint64_t)v93);
                    v91 = v99;
                  }
                }
                if (v91)
                  brk_DataClose(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v91);
              }
              else
              {
                v6 = 2269126674;
              }
LABEL_54:
              heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), (uint64_t)v67);
              goto LABEL_55;
            }
            goto LABEL_55;
          }
          *(_QWORD *)&v99 = 0;
          LODWORD(__endptr) = 0;
          v96 = 0;
          v22 = strlen(a4);
          v23 = a6 != 0;
          if (v22)
          {
            v24 = v22;
            if (IsThisUrlOrRealPath(a4, 0))
            {
              while (1)
              {
                v25 = a4[v24];
                if (v25 == 47)
                  break;
                if (v25 == 92 || &a4[v24] <= a4)
                  break;
                --v24;
              }
              v78 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), v24 + 2);
              if (!v78)
                goto LABEL_55;
              v67 = v78;
              v79 = strncpy(v78, a4, v24 + 1);
              v79[v24 + 1] = 0;
              v80 = strlen(v79);
              v81 = strlen((const char *)a3);
              v82 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), v80 + v81 + 1);
              if (!v82)
                goto LABEL_54;
              v66 = v82;
              UriCompleteUrl(v67, (char *)a3, v82);
              goto LABEL_33;
            }
          }
        }
        else
        {
          *(_QWORD *)&v99 = 0;
          LODWORD(__endptr) = 0;
          v96 = 0;
          v23 = a6 != 0;
        }
        v61 = strlen((const char *)a3);
        v62 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), v61 + 1);
        if (v62)
        {
          v66 = v62;
          v67 = 0;
          strncpy(v62, (const char *)a3, v61)[v61] = 0;
LABEL_33:
          v68 = (char *)audiofetch_GetMimeTypeFromURI(v66);
          v69 = strrchr(v66, 63);
          if (v69)
            *v69 = 0;
          v70 = brk_DataOpenEx(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), (uint64_t)v66, v23, (uint64_t)&v96);
          v71 = v96;
          if ((v70 & 0x80000000) != 0)
          {
            v6 = v70;
          }
          else
          {
            v72 = brk_DataMapEx(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), (uint64_t)v96, 0, (uint64_t)&__endptr, (uint64_t)&v99);
            v73 = v99;
            if ((v72 & 0x80000000) != 0)
            {
              v6 = v72;
            }
            else
            {
              v6 = audiofetch_PrepareAudioTask((_WORD **)a1, v66, v68, (char *)v99, __endptr, a5);
              v73 = v99;
            }
            v71 = v96;
            if (v73)
            {
              brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), (uint64_t)v96, v73);
              v71 = v96;
            }
          }
          if (v71)
            brk_DataClose(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), (uint64_t)v71);
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), (uint64_t)v66);
          if (!v67)
            goto LABEL_55;
          goto LABEL_54;
        }
LABEL_55:
        ReadOnly = v6;
        goto LABEL_56;
      }
      __endptr = 0;
      v101 = 0u;
      v102 = 0u;
      v99 = 0u;
      v100 = 0u;
      v98 = 0;
      v27 = strlen((const char *)(a3 + 25));
      v28 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), (v27 + 1));
      if (!v28)
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v29, v30, v31, v32, v95);
        ReadOnly = 2269126666;
LABEL_56:
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_Fetch for URI \"%s\", %x", v63, v64, v65, a3);
        log_OutTraceTuningData(*(uint64_t ***)(*(_QWORD *)(a1 + 16) + 32), 311, (uint64_t)"%s%s %s%u", v83, v84, v85, v86, v87, "END");
        return ReadOnly;
      }
      v33 = (uint64_t)v28;
      v34 = strcpy(v28, (const char *)(a3 + 25));
      v35 = strchr(v34, 35);
      if (v35)
      {
        v40 = v35;
        strtoul(v35 + 1, &__endptr, 10);
        *v40 = 0;
        ReadOnly = ssftmap_FindReadOnly(*(_QWORD *)(a1 + 48), v33, &v98);
        if ((ReadOnly & 0x80000000) == 0)
        {
LABEL_23:
          if ((ReadOnly & 0x80000000) == 0 && v98 && *(_QWORD *)(v98 + 56))
          {
            v46 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 1, 88);
            if (v46)
            {
              v51 = v46;
              v96 = 0;
              v97 = 0;
              *(_WORD *)v46 = 1;
              v52 = v98;
              v53 = *(_QWORD *)(v98 + 48);
              *(_QWORD *)(v46 + 32) = v53;
              *(_QWORD *)(v46 + 40) = *(_QWORD *)(v52 + 56);
              *(_QWORD *)(v46 + 56) = 0;
              v54 = (*(uint64_t (**)(void))(v53 + 80))();
              if ((v54 & 0x80000000) != 0)
              {
                v94 = v54;
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 156, "%s%s%s%u%s%x", v55, v56, v57, v58, "speechbase");
                v6 = v94;
              }
              else
              {
                v59 = v97;
                *(_DWORD *)(v51 + 48) = HIDWORD(v96);
                *(_DWORD *)(v51 + 16) = v59;
                v60 = strhelper_Strdup(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), (char *)a3);
                *(_QWORD *)(v51 + 24) = v60;
                if (v60)
                  v6 = AddAudioTask(a1, v51, a5);
              }
              audiofetch_ElemFreeAudioVarLenBuf((_QWORD *)v51, *(_QWORD **)(*(_QWORD *)(a1 + 16) + 8));
              ReadOnly = v6;
            }
            else
            {
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v47, v48, v49, v50, v95);
              ReadOnly = 2269126666;
            }
          }
          goto LABEL_47;
        }
        v101 = 0u;
        v102 = 0u;
        v99 = 0u;
        v100 = 0u;
        v100 = *(_OWORD *)a1;
        v101 = *(_OWORD *)(a1 + 16);
        LOWORD(v99) = GetEngineFreq(a1);
        *((_QWORD *)&v99 + 1) = v33;
        v41 = ssftmap_Insert(*(_QWORD *)(a1 + 48), v33, (uint64_t)&v99);
        if ((v41 & 0x80000000) == 0)
        {
          ReadOnly = ssftmap_FindReadOnly(*(_QWORD *)(a1 + 48), v33, &v98);
          goto LABEL_23;
        }
        ReadOnly = v41;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 155, "%s%s", v42, v43, v44, v45, "speechbase");
      }
      else
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 154, "%s%s", v36, v37, v38, v39, "uri");
      }
LABEL_47:
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v33);
      goto LABEL_56;
    }
    return v13;
  }
  return ReadOnly;
}

uint64_t AddAudioTask(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const char *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  int v21;
  const char *v22;
  unsigned int v24;
  char v25[16];
  char __src[32];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *a3 = 0;
  v6 = *(const char **)(a2 + 24);
  if (v6)
  {
    v7 = strlen(*(const char **)(a2 + 24));
    if (v7 >= 0x51)
    {
      v6 += v7 - 80;
      v7 = strlen(v6);
    }
  }
  else
  {
    v7 = 0;
    v6 = &byte_1DEBD87CE;
  }
  v8 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), v7 + 16);
  *(_QWORD *)(a2 + 8) = v8;
  if (v8)
  {
    strcpy(__src, "__NUAN_");
    LH_utoa(*(_DWORD *)(a1 + 32), v25, 0xAu);
    __strcat_chk();
    __strcat_chk();
    strcpy(*(char **)(a2 + 8), __src);
    if (*v6)
    {
      v13 = strlen(__src);
      strcpy((char *)(*(_QWORD *)(a2 + 8) + v13), v6);
    }
    v18 = ssftmap_Insert(*(_QWORD *)(a1 + 40), *(_QWORD *)(a2 + 8), a2);
    if ((v18 & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v14, v15, v16, v17, v24);
    }
    else
    {
      v19 = *(_DWORD *)(a1 + 32);
      v20 = __CFADD__(v19, 1);
      v21 = v19 + 1;
      if (v20)
        v21 = 1;
      *(_DWORD *)(a1 + 32) = v21;
      *a3 = *(_QWORD *)(a2 + 8);
      if (*(_QWORD *)(a2 + 40))
        v22 = "Audio insertion %s: from %s, %u offset, %u duration";
      else
        v22 = "Audio insertion %s: from %s, encoding %d, %u samples";
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 3, 0, (uint64_t)v22, v15, v16, v17, (uint64_t)__src);
    }
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v9, v10, v11, v12, v24);
    return 2269126666;
  }
  return v18;
}

const char *audiofetch_GetMimeTypeFromURI(char *a1)
{
  size_t ExtensionFromURI;
  char *v3;
  uint64_t v4;
  const char *v5;
  _BYTE v7[80];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return "application/octet-stream";
  ExtensionFromURI = UriGetExtensionFromURI(a1, v7, 0x50uLL);
  if (ExtensionFromURI)
  {
    v3 = (char *)ExtensionFromURI;
    v4 = 0;
    while (LH_stricmp(v3, audiofetch_GetMimeTypeFromURI_EXT_TO_MIMETYPE_CONVERSION_MAP_T[v4]))
    {
      v4 += 2;
      if (v4 == 18)
        goto LABEL_6;
    }
    return audiofetch_GetMimeTypeFromURI_EXT_TO_MIMETYPE_CONVERSION_MAP_T[v4 + 1];
  }
  else
  {
LABEL_6:
    v5 = "application/octet-stream";
    if (!strncmp(a1, "audio/", 6uLL) && strchr(a1, 58))
      return "audio/x-wav";
  }
  return v5;
}

uint64_t audiofetch_PrepareAudioTask(_WORD **a1, char *a2, char *__s1, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int EngineFreq;
  int v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int __n;
  size_t __n_4;
  int v46;
  int v47;
  int v48;
  char __s1a[16];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  char v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v47 = 0;
  v48 = 0;
  v46 = 0;
  v53 = 0;
  v51 = 0u;
  v52 = 0u;
  *(_OWORD *)__s1a = 0u;
  v50 = 0u;
  __n_4 = 0;
  __n = 0;
  if (ParseAudioMimeType(__s1, &v48, (_WORD *)&v47 + 1, &v47, &v46))
  {
    EngineFreq = GetEngineFreq((uint64_t)a1);
    v16 = EngineFreq;
    if (v46)
      v17 = 1;
    else
      v17 = HIWORD(v47) == EngineFreq;
    v18 = !v17;
    if ((_DWORD)a5 || (v48 - 5) >= 4)
    {
      switch(v48)
      {
        case 1:
          v21 = Au2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n_4, &__n, 1);
          goto LABEL_22;
        case 5:
          v21 = Wav2PCM(*a1, (uint64_t)a1[1], a2, (uint64_t)a4, a5, __s1a, (uint64_t *)&__n_4, &__n);
          goto LABEL_22;
        case 6:
          v21 = Au2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n_4, &__n, 0);
          goto LABEL_22;
        case 7:
          v21 = NistSphere2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n_4, &__n);
          goto LABEL_22;
        case 8:
          v21 = NuanceAudio2PCM(*a1, (uint64_t)a1[1], a2, (uint64_t)a4, a5, __s1a, 0x41uLL, (uint64_t *)&__n_4, &__n);
LABEL_22:
          v19 = v21;
          if ((v21 & 0x80000000) == 0)
            goto LABEL_23;
          if (__n_4)
            heap_Free(*((_QWORD **)a1[2] + 1), __n_4);
          return v19;
        default:
          __n = a5;
          v22 = (void *)heap_Alloc(*((_QWORD *)a1[2] + 1), a5);
          __n_4 = (size_t)v22;
          if (!v22)
            goto LABEL_39;
          memcpy(v22, a4, __n);
LABEL_23:
          if (!ParseAudioMimeType(__s1a, &v48, (_WORD *)&v47 + 1, &v47, 0))
          {
            log_OutPublic(*((_QWORD *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 136, "%s%s%s%s", v23, v24, v25, v26, "uri");
            if (__n_4)
              heap_Free(*((_QWORD **)a1[2] + 1), __n_4);
            return 2269126660;
          }
          v27 = HIWORD(v47);
          v28 = heap_Calloc(*((_QWORD **)a1[2] + 1), 1, 88);
          if (v28)
          {
            v33 = (_QWORD *)v28;
            if (v27 == v16)
              v34 = v18;
            else
              v34 = 1;
            *(_WORD *)v28 = 1;
            *(_WORD *)(v28 + 68) = v27;
            *(_WORD *)(v28 + 70) = v16;
            v35 = v48;
            v36 = (unsigned __int16)v47;
            *(_WORD *)(v28 + 72) = v47;
            v37 = __n;
            *(_DWORD *)(v28 + 64) = __n;
            *(_DWORD *)(v28 + 76) = v35;
            *(_DWORD *)(v28 + 80) = v34;
            if (v36)
            {
              if (v36 != 1)
              {
                if (v36 == 2)
                  v37 >>= 1;
                else
                  v37 /= v36;
              }
              *(_DWORD *)(v28 + 16) = v37;
            }
            v38 = strhelper_Strdup(*((_QWORD *)a1[2] + 1), a2);
            v33[3] = v38;
            if (v38)
            {
              v33[7] = __n_4;
              v19 = AddAudioTask((uint64_t)a1, (uint64_t)v33, a6);
            }
            else
            {
              if (__n_4)
                heap_Free(*((_QWORD **)a1[2] + 1), __n_4);
              log_OutPublic(*((_QWORD *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 100, 0, v39, v40, v41, v42, v43);
              v19 = 2269126666;
            }
            audiofetch_ElemFreeAudioVarLenBuf(v33, *((_QWORD **)a1[2] + 1));
          }
          else
          {
            if (__n_4)
              heap_Free(*((_QWORD **)a1[2] + 1), __n_4);
            log_OutPublic(*((_QWORD *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 100, 0, v29, v30, v31, v32, v43);
LABEL_39:
            v19 = 2269126666;
          }
          break;
      }
    }
    else
    {
      return 2269126660;
    }
  }
  else
  {
    v19 = 2269126660;
    log_OutPublic(*((_QWORD *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 133, "%s%s%s%s", v11, v12, v13, v14, "uri");
  }
  return v19;
}

BOOL ParseAudioMimeType(char *__s1, int *a2, _WORD *a3, _WORD *a4, _DWORD *a5)
{
  char *v10;
  char *v11;
  int v12;
  int v13;
  int v14;

  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if (a5)
    *a5 = 0;
  if (!strcmp(__s1, "audio/wav") || !strcmp(__s1, "audio/x-wav"))
  {
    if (a5)
    {
      *a5 = 1;
      v14 = 5;
      goto LABEL_26;
    }
    return *a2 != 0;
  }
  if (!strcmp(__s1, "audio/x-nist"))
  {
    if (!a5)
      return *a2 != 0;
    *a5 = 1;
    v14 = 7;
    goto LABEL_26;
  }
  if (!strcmp(__s1, "audio/x-nuance-audio"))
  {
    if (!a5)
      return *a2 != 0;
    *a5 = 1;
    v14 = 8;
    goto LABEL_26;
  }
  if (!strcmp(__s1, "audio/x-alaw-basic"))
  {
    *a2 = 1;
    *a3 = 8000;
    goto LABEL_33;
  }
  if (!strcmp(__s1, "audio/basic"))
  {
    if (a5)
    {
      *a5 = 1;
      v14 = 6;
      goto LABEL_26;
    }
    *a2 = 2;
    *a3 = 8000;
LABEL_33:
    *a4 = 1;
    return *a2 != 0;
  }
  if (!strncmp(__s1, "audio/L16;", 0xAuLL))
  {
    *a4 = 2;
    v10 = strchr(__s1, 59);
    if (!v10)
      goto LABEL_37;
    v11 = v10;
    v12 = 0;
    v13 = 1;
    do
    {
      if (!strncmp(v11 + 1, "endian=little;", 0xEuLL))
      {
        v12 = 0;
      }
      else if (!strncmp(v11 + 1, "endian=big;", 0xBuLL))
      {
        v12 = 1;
      }
      else if (!strncmp(v11 + 1, "rate=", 5uLL))
      {
        *a3 = (unsigned __int16)LH_atou(v11 + 6);
      }
      else if (!strncmp(v11 + 1, "channels=", 9uLL))
      {
        v13 = (unsigned __int16)LH_atou(v11 + 10);
      }
      v11 = strchr(v11 + 1, 59);
    }
    while (v11);
    if (v13 == 1)
    {
      if (v12)
      {
        v14 = 4;
LABEL_26:
        *a2 = v14;
        return *a2 != 0;
      }
LABEL_37:
      v14 = 3;
      goto LABEL_26;
    }
  }
  return *a2 != 0;
}

uint64_t NistSphere2PCM(_WORD *a1, int a2, _BYTE *a3, char *a4, uint64_t a5, char *a6, _QWORD *a7, _DWORD *a8)
{
  _DWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t inited;
  int v20;
  const char *v21;
  unsigned __int8 *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  int v27;
  unsigned __int8 *v29;
  uint64_t v30;
  int v31;
  _DWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  unsigned int v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v56;
  char *v57;
  int v59;
  int v60;
  int v61;
  signed int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  BOOL v71;
  BOOL v72;
  BOOL v73;
  char *v74;
  size_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  const char *v84;
  _QWORD *v85;
  char *v86;
  unsigned int v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char __s2[32];
  _BYTE v93[19];
  __int128 v94;
  _BYTE v95[29];
  _BYTE v96[17];
  __int128 v97;
  _BYTE v98[31];
  uint64_t v99;

  v99 = *MEMORY[0x1E0C80C00];
  v90 = 0;
  v91 = 0;
  v89 = 0;
  v88 = 0;
  memset(v98, 0, sizeof(v98));
  v97 = 0u;
  *(_OWORD *)&v96[1] = 0u;
  v96[0] = 78;
  memset(v95, 0, sizeof(v95));
  v94 = 0u;
  *(_OWORD *)&v93[3] = 0u;
  qmemcpy(v93, "pcm", 3);
  if (!a3)
    return 2269126663;
  v8 = a8;
  v9 = 2269126663;
  if (a8)
  {
    v10 = a7;
    if (a7)
    {
      if (a6)
      {
        v12 = a5;
        if ((_DWORD)a5)
        {
          v13 = a4;
          if (a4)
          {
            v14 = (uint64_t)a3;
            if (*a3)
            {
              *a6 = 0;
              *a7 = 0;
              *a8 = 0;
              inited = InitRsrcFunction(a1, a2, &v91);
              if ((inited & 0x80000000) != 0)
                return inited;
              v20 = 0;
              v21 = 0;
              v22 = (unsigned __int8 *)&v13[v12];
              v86 = a6;
              v23 = -(uint64_t)v13;
              v24 = -(uint64_t)v12;
              v25 = v13;
              while (1)
              {
                if (v25 >= (char *)v22)
                {
LABEL_72:
                  log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 109, "%s%s", v15, v16, v17, v18, "url");
                  return 2269126660;
                }
                v26 = 0;
                while (1)
                {
                  v27 = v25[v26];
                  if (v27 == 10 || v27 == 13)
                    break;
                  ++v26;
                  if (!&v25[v23 + v24 + v26])
                    goto LABEL_72;
                }
                v29 = (unsigned __int8 *)&v25[v26];
                if (!v20)
                {
                  if (v26 < 7)
                    goto LABEL_91;
                  v81 = v14;
                  v83 = v13;
                  v33 = v8;
                  v34 = v12;
                  v35 = v10;
                  v36 = v21;
                  v37 = v24;
                  v38 = inited;
                  v39 = v23;
                  v40 = strncmp("NIST_1A", v25, 7uLL);
                  inited = v38;
                  v24 = v37;
                  v21 = v36;
                  v10 = v35;
                  v12 = v34;
                  v8 = v33;
                  v14 = v81;
                  v13 = v83;
                  if (v40 || (v23 = v39, v41 = v25[7], v20 = 1, v41 != 10) && v41 != 13)
                  {
LABEL_91:
                    log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 110, "%s%s", v15, v16, v17, v18, "url");
                    return 2269126660;
                  }
                  goto LABEL_58;
                }
                if (v20 != 2)
                {
                  v85 = v10;
                  if (v25 >= (char *)v29)
                  {
                    v48 = v23;
                    v49 = inited;
                  }
                  else
                  {
                    v30 = 0;
                    do
                    {
                      v31 = v25[v30];
                      if (v31 != 32 && v31 != 9)
                      {
                        v48 = v23;
                        v49 = inited;
                        v25 += v30;
                        goto LABEL_48;
                      }
                      ++v30;
                    }
                    while (v26 != v30);
                    v48 = v23;
                    v49 = inited;
                    v25 += v26;
                  }
LABEL_48:
                  v50 = LH_atou(v25);
                  v21 = v50;
                  if (!(_DWORD)v50 || v50 >= v12)
                  {
                    log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 111, "%s%s%s%u", v15, v16, v17, v18, "url");
                    return 2269126660;
                  }
                  v20 = 2;
                  inited = v49;
                  v23 = v48;
                  v10 = v85;
                  goto LABEL_58;
                }
                if ((unint64_t)&v25[v23 + v26] >= v21)
                  goto LABEL_72;
                v82 = v23;
                v84 = v21;
                v42 = inited;
                if (buf_token_strcmp("end_head", v25, (uint64_t)&v25[v26]))
                {
                  if (!buf_token_strcmp("sample_rate", v25, (uint64_t)v29))
                  {
                    v46 = v91;
                    v47 = (int *)&v90 + 1;
LABEL_55:
                    v51 = buf_parse_value_int(v46, v14, v25, (unint64_t)v29, v47, v43, v44, v45);
                    goto LABEL_56;
                  }
                  if (!buf_token_strcmp("sample_count", v25, (uint64_t)v29))
                  {
                    v46 = v91;
                    v47 = (int *)&v90;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("sample_sig_bits", v25, (uint64_t)v29))
                  {
                    v46 = v91;
                    v47 = (int *)&v89 + 1;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("sample_n_bytes", v25, (uint64_t)v29))
                  {
                    v46 = v91;
                    v47 = (int *)&v89;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("channel_count", v25, (uint64_t)v29))
                  {
                    v46 = v91;
                    v47 = &v88;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("sample_byte_format", v25, (uint64_t)v29))
                  {
                    v56 = v91;
                    v57 = v96;
                    goto LABEL_70;
                  }
                  if (!buf_token_strcmp("sample_coding", v25, (uint64_t)v29))
                  {
                    v56 = v91;
                    v57 = v93;
LABEL_70:
                    v51 = buf_parse_value_str(v56, v14, (unsigned __int8 *)v25, (unint64_t)v29, v57, v16, v17, v18);
LABEL_56:
                    inited = v51;
                    v20 = 2;
                    v21 = v84;
                    goto LABEL_57;
                  }
                  v20 = 2;
                }
                else
                {
                  v20 = 3;
                }
                v21 = v84;
                inited = v42;
LABEL_57:
                v23 = v82;
LABEL_58:
                if ((inited & 0x80000000) != 0)
                  return inited;
                if (v29 < v22)
                {
                  while (1)
                  {
                    v52 = *v29;
                    v53 = v52 > 0x20;
                    v54 = (1 << v52) & 0x100002600;
                    if (v53 || v54 == 0)
                      break;
                    if (++v29 >= v22)
                    {
                      v29 = v22;
                      break;
                    }
                  }
                }
                v25 = (char *)v29;
                if (v20 == 3)
                {
                  v87 = inited;
                  v60 = v88;
                  v59 = v89;
                  v61 = v90;
                  v62 = HIDWORD(v90);
                  v63 = (int)v21;
                  log_OutText(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"NIST SPHERE %s: %s %s, %d channels, %d HZ, %d sample sig bits, %d bytes per sample, %u data offset, %d sample count", v16, v17, v18, v14);
                  if (v60 != 1)
                  {
                    log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 112, "%s%s%s%d", v64, v65, v66, v67, "url");
                    return 2269126660;
                  }
                  if (v61 < 0)
                  {
                    log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 119, "%s%s%s%d", v64, v65, v66, v67, "url");
                    return 2269126660;
                  }
                  if (v59 <= 0)
                  {
                    log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 120, "%s%s%s%d", v64, v65, v66, v67, "url");
                    return 2269126660;
                  }
                  if (!(*(_DWORD *)v93 ^ 0x77616C75 | v93[4]))
                  {
                    v71 = v62 == 8000 || v62 == 0;
                    if (!v71 || v59 != 1)
                      goto LABEL_125;
                    v68 = v63;
LABEL_103:
                    strcpy(v86, "audio/basic");
                    goto LABEL_129;
                  }
                  v68 = v63;
                  if (!(*(_DWORD *)v93 ^ 0x77616C61 | v93[4]))
                    goto LABEL_104;
                  if (*(_DWORD *)v93 != 7168880)
                  {
                    if (*(_DWORD *)v96 != 1814918509 || *(_DWORD *)&v96[3] != 7823724)
                    {
                      if (*(_DWORD *)v96 != 1634479457 || *(unsigned __int16 *)&v96[4] != 119)
                      {
                        log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 115, "%s%s%s%s%s%d%s%d%s%s", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
LABEL_104:
                      v72 = v62 == 8000 || v62 == 0;
                      if (!v72 || v59 != 1)
                      {
                        log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 113, "%s%s%s%s%s%d%s%d", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
                      strcpy(v86, "audio/x-alaw-basic");
LABEL_129:
                      if (!v61)
                      {
                        log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 116, "%s%s", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
                      v75 = (v61 * v59);
                      if ((int)v75 + v68 > v12)
                      {
                        log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 117, "%s%s", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
                      v76 = (void *)heap_Alloc(*(_QWORD *)(v91 + 8), v75);
                      *v10 = v76;
                      if (v76)
                      {
                        memcpy(v76, &v13[v63], v75);
                        *v8 = v75;
                        return v87;
                      }
                      else
                      {
                        log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 118, "%s%s%s%lu", v77, v78, v79, v80, "url");
                        return 2269126666;
                      }
                    }
                    v73 = v62 == 8000 || v62 == 0;
                    if (!v73 || v59 != 1)
                    {
LABEL_125:
                      log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 114, "%s%s%s%s%s%d%s%d", v64, v65, v66, v67, "url");
                      return 2269126660;
                    }
                    goto LABEL_103;
                  }
                  if (v62 < 1 || v59 != 2)
                  {
LABEL_117:
                    v9 = 2269126660;
                    log_OutPublic(*(_QWORD *)(v91 + 32), (uint64_t)"AUDIOFETCH", 115, "%s%s%s%s%s%d%s%d%s%s", v64, v65, v66, v67, "url");
                    return v9;
                  }
                  if (*(unsigned __int16 *)v96 ^ 0x3130 | v96[2])
                  {
                    if (*(unsigned __int16 *)v96 ^ 0x3031 | v96[2])
                    {
                      if (*(unsigned __int16 *)v96 != 78 && *(unsigned __int16 *)v96 != 49)
                        goto LABEL_117;
                      goto LABEL_126;
                    }
                    v74 = v86;
                    strcpy(v86, "audio/L16;endian=big;rate=");
                  }
                  else
                  {
LABEL_126:
                    v74 = v86;
                    strcpy(v86, "audio/L16;endian=little;rate=");
                  }
                  LH_itoa(v62, __s2, 0xAu);
                  strcat(v74, __s2);
                  v68 = v63;
                  goto LABEL_129;
                }
              }
            }
          }
        }
      }
    }
  }
  return v9;
}

uint64_t buf_token_strcmp(const char *a1, const char *a2, uint64_t a3)
{
  size_t v6;
  uint64_t result;
  size_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;

  v6 = strlen(a1);
  if (v6 > a3 - (uint64_t)a2)
    return 0xFFFFFFFFLL;
  v8 = v6;
  result = strncmp(a1, a2, v6);
  if (!(_DWORD)result)
  {
    v9 = a2[v8];
    v10 = v9 > 0x20;
    v11 = (1 << v9) & 0x100002600;
    return v10 || v11 == 0;
  }
  return result;
}

uint64_t buf_parse_value_int(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  uint64_t v17;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *i;
  int v25;

  v10 = a3;
  if ((unint64_t)a3 < a4)
  {
    v12 = a4 - (_QWORD)a3;
    while (1)
    {
      v13 = *(unsigned __int8 *)v10;
      if (v13 == 9 || v13 == 32)
        break;
      ++v10;
      if (!--v12)
      {
        v10 = (const char *)a4;
        break;
      }
    }
  }
  if ((unint64_t)v10 >= a4)
  {
LABEL_15:
    v17 = 2269126660;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"AUDIOFETCH", 121, "%s%s", (uint64_t)a5, a6, a7, a8, "url");
  }
  else
  {
    v14 = a4 - (_QWORD)v10;
    while (1)
    {
      v15 = *(unsigned __int8 *)v10;
      if (v15 != 32 && v15 != 9)
        break;
      ++v10;
      if (!--v14)
        goto LABEL_15;
    }
    if (buf_token_strcmp("-i", v10, a4))
    {
      v17 = 2269126660;
      log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"AUDIOFETCH", 122, "%s%s", v20, v21, v22, v23, "url");
    }
    else
    {
      for (i = v10 + 2; (unint64_t)i < a4; ++i)
      {
        v25 = *(unsigned __int8 *)i;
        if (v25 != 32 && v25 != 9)
        {
          v17 = 0;
          *a5 = atoi(i);
          return v17;
        }
      }
      v17 = 2269126660;
      log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"AUDIOFETCH", 123, "%s%s", v20, v21, v22, v23, "url");
    }
  }
  return v17;
}

uint64_t buf_parse_value_str(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  int v12;
  unint64_t v13;
  const char *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  int v24;
  uint64_t v27;

  if ((unint64_t)a3 < a4)
  {
    v11 = a4 - (_QWORD)a3;
    while (1)
    {
      v12 = *a3;
      if (v12 == 9 || v12 == 32)
        break;
      ++a3;
      if (!--v11)
      {
        a3 = (unsigned __int8 *)a4;
        break;
      }
    }
  }
  if ((unint64_t)a3 >= a4)
  {
LABEL_12:
    v16 = 2269126660;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"AUDIOFETCH", 124, "%s%s", (uint64_t)a5, a6, a7, a8, "url");
  }
  else
  {
    v13 = a4 - (_QWORD)a3;
    v14 = (const char *)(a3 + 2);
    while (1)
    {
      v15 = *((unsigned __int8 *)v14 - 2);
      if (v15 != 9 && v15 != 32)
        break;
      ++v14;
      if (!--v13)
        goto LABEL_12;
    }
    if (v15 == 45 && *(v14 - 1) == 115 && *(unsigned __int8 *)v14 - 48 < 0xA)
    {
      v17 = atoi(v14);
      if (v17 >= 63)
        v22 = 63;
      else
        v22 = v17;
      if ((unint64_t)v14 < a4)
      {
        while (*(unsigned __int8 *)v14 - 48 <= 9)
        {
          if ((unint64_t)++v14 >= a4)
          {
            v14 = (const char *)a4;
            break;
          }
        }
      }
      if ((unint64_t)v14 < a4)
      {
        v23 = a4 - (_QWORD)v14;
        while (1)
        {
          v24 = *(unsigned __int8 *)v14;
          if (v24 != 32 && v24 != 9)
            break;
          ++v14;
          if (!--v23)
          {
            v14 = (const char *)a4;
            break;
          }
        }
      }
      if ((unint64_t)&v14[v22] <= a4)
      {
        v27 = v22;
        strncpy(a5, v14, v22);
        v16 = 0;
        a5[v27] = 0;
      }
      else
      {
        v16 = 2269126660;
        log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"AUDIOFETCH", 126, "%s%s", v18, v19, v20, v21, "url");
      }
    }
    else
    {
      v16 = 2269126660;
      log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"AUDIOFETCH", 125, "%s%s", (uint64_t)a5, a6, a7, a8, "url");
    }
  }
  return v16;
}

uint64_t naudec_New(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t inited;
  _QWORD *v8;
  _WORD **v9;
  uint64_t v10;
  uint64_t v12;

  v3 = 2269126663;
  if (a3)
  {
    v12 = 0;
    inited = InitRsrcFunction(a1, a2, &v12);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      v8 = (_QWORD *)heap_Alloc(*(_QWORD *)(v12 + 8), 64);
      *a3 = (uint64_t)v8;
      if (v8)
      {
        *v8 = a1;
        v8[1] = a2;
        v9 = (_WORD **)*a3;
        *((_OWORD *)v9 + 2) = 0u;
        *((_OWORD *)v9 + 3) = 0u;
        *((_OWORD *)v9 + 1) = 0u;
        v10 = nauread_New(*v9, (uint64_t)v9[1], (uint64_t *)v9 + 2);
        if ((v10 & 0x80000000) != 0)
        {
          v3 = v10;
LABEL_10:
          naudec_Destroy(a3);
          return v3;
        }
        v3 = genidec_New(*v9, (uint64_t)v9[1], v9 + 3);
        if ((v3 & 0x80000000) != 0)
          goto LABEL_10;
      }
      else
      {
        return 2269126666;
      }
    }
  }
  return v3;
}

uint64_t naudec_Destroy(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t inited;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v10;

  v1 = 2269126663;
  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      v10 = 0;
      inited = InitRsrcFunction(*(_WORD **)v3, *(_QWORD *)(v3 + 8), &v10);
      if ((inited & 0x80000000) != 0)
      {
        return inited;
      }
      else
      {
        v5 = *a1;
        if (*(_QWORD *)(*a1 + 16))
          v1 = nauread_Destroy((uint64_t *)(*a1 + 16));
        else
          v1 = 0;
        v7 = *(_QWORD *)(v5 + 24);
        v6 = (uint64_t *)(v5 + 24);
        if (v7)
        {
          v8 = genidec_Destroy(v6);
          if ((int)v1 >= 0)
            v1 = v8;
          else
            v1 = v1;
        }
        heap_Free(*(_QWORD **)(v10 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return v1;
}

uint64_t naudec_OpenInputMemory(uint64_t a1, const char *a2, uint64_t a3, int a4)
{
  uint64_t result;

  result = 2269126663;
  if (a1 && *(_QWORD *)(a1 + 16))
  {
    result = nauread_ExtOpen(*(_QWORD *)(a1 + 16), "memory", a2, a3, a4);
    if ((result & 0x80000000) == 0)
      return nauread_ReadHeader(*(_QWORD *)(a1 + 16));
  }
  return result;
}

uint64_t naudec_Decode(_WORD **a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t Info;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  size_t v20;
  unint64_t v21;
  uint64_t inited;
  uint64_t v23;
  size_t v24;
  _WORD *v25;
  unint64_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  unsigned int Data;
  int v36;
  size_t v37;
  unint64_t v38;
  int v39;
  uint64_t v40;
  unsigned __int16 v41;
  size_t v42;

  v41 = 0;
  v40 = 0;
  Info = nauread_GetInfo((uint64_t)a1[2], 0, &v41, 0, &v40);
  if ((Info & 0x80000000) != 0)
    return Info;
  v7 = (unint64_t)v41 >> 3;
  v8 = (v40 * v7);
  *a3 = v8;
  v42 = 0;
  *a2 = 0;
  Info = InitRsrcFunction(*a1, (int)a1[1], &v42);
  if ((Info & 0x80000000) != 0)
    return Info;
  v9 = 2269126666;
  v10 = heap_Alloc(*(_QWORD *)(v42 + 8), v8);
  *a2 = v10;
  if (!v10)
    return v9;
  v11 = v10;
  v12 = *a3;
  Info = nauread_BeginReadData((uint64_t)a1[2]);
  if ((Info & 0x80000000) != 0)
    return Info;
  v39 = 0;
  v37 = 0;
  v38 = 0;
  v13 = genidec_RequestSamples(a1[3], 0, 1000, &v39, (uint64_t *)&v38, &v37);
  LODWORD(v18) = v13;
  if (v13 < 0 || v13 == 6 || !(_DWORD)v12)
  {
LABEL_27:
    Data = nauread_EndReadData((uint64_t)a1[2]);
    if ((_DWORD)v18 == 6)
      return Data;
    else
      return v18;
  }
  v19 = 0;
  while (1)
  {
    v20 = v37;
    v21 = v38;
    if ((unint64_t)a1[5] >= v37)
      goto LABEL_13;
    v42 = 0;
    inited = InitRsrcFunction(*a1, (int)a1[1], &v42);
    if ((inited & 0x80000000) != 0)
      break;
    v23 = heap_Realloc(*(uint64_t **)(v42 + 8), (uint64_t)a1[4], v20);
    a1[4] = (_WORD *)v23;
    if (!v23)
      goto LABEL_34;
    a1[5] = (_WORD *)v20;
LABEL_13:
    v42 = 0;
    v25 = a1[6];
    v24 = (size_t)a1[7];
    v26 = v21 - (_QWORD)v25;
    if ((_WORD *)v21 == v25)
    {
      v27 = v20 - v24;
      if (v20 <= v24)
        goto LABEL_23;
    }
    else
    {
      v28 = (size_t)v25 + v24;
      if ((unint64_t)v25 + v24 <= v21)
      {
        if ((_WORD *)((char *)v25 + v24) != (_WORD *)v21)
        {
          v18 = 2269126660;
          goto LABEL_35;
        }
        v18 = nauread_ReadData((uint64_t)a1[2], a1[4], v20, &v42, v14, v15, v16, v17);
        a1[6] = (_WORD *)v21;
        v24 = v42;
        goto LABEL_22;
      }
      v29 = v20 + v21;
      memmove(a1[4], (char *)a1[4] + v26, v24 - v26);
      v24 = (size_t)a1[7] - v26;
      a1[6] = (_WORD *)v21;
      a1[7] = (_WORD *)v24;
      v27 = v29 - v28;
      if (v29 == v28)
        goto LABEL_23;
    }
    v18 = nauread_ReadData((uint64_t)a1[2], (char *)a1[4] + v24, v27, &v42, v14, v15, v16, v17);
    v24 = (size_t)a1[7] + v42;
LABEL_22:
    a1[7] = (_WORD *)v24;
    if ((v18 & 0x80000000) != 0)
      goto LABEL_35;
LABEL_23:
    v42 = v24;
    v36 = v12 / v7;
    v30 = genidec_Decode(a1[3], (uint64_t)a1[4], &v42, v11, (uint64_t)&v36);
    if ((v30 & 0x80000000) != 0)
    {
      v18 = v30;
      goto LABEL_35;
    }
    v31 = v36;
    v19 += v36;
    v32 = genidec_RequestSamples(a1[3], v19, 1000, &v39, (uint64_t *)&v38, &v37);
    LODWORD(v18) = v32;
    if ((v32 & 0x80000000) == 0 && v32 != 6)
    {
      v33 = (v31 * v7);
      v11 += v33;
      v12 -= v33;
      if (v12)
        continue;
    }
    goto LABEL_27;
  }
  v9 = inited;
LABEL_34:
  v18 = v9;
LABEL_35:
  nauread_EndReadData((uint64_t)a1[2]);
  return v18;
}

uint64_t NuanceAudio2PCM(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, int a5, char *a6, size_t a7, uint64_t *a8, _DWORD *a9)
{
  uint64_t v9;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  BOOL v18;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  _WORD **v25;

  v9 = 2269126663;
  if (a3)
  {
    v15 = !a9 || a8 == 0;
    v16 = v15 || a6 == 0;
    v17 = v16 || a5 == 0;
    v18 = v17 || a4 == 0;
    if (!v18 && *a3 != 0)
    {
      v25 = 0;
      *a6 = 0;
      *a8 = 0;
      *a9 = 0;
      v21 = naudec_New(a1, a2, (uint64_t *)&v25);
      if ((v21 & 0x80000000) == 0)
      {
        if ((naudec_OpenInputMemory((uint64_t)v25, a3, a4, a5) & 0x80000000) == 0)
        {
          if (v25)
          {
            if (v25[3])
            {
              if ((nauread_GetContentType((uint64_t)v25[2], a6, a7) & 0x80000000) == 0)
              {
                if (v25)
                {
                  v22 = v25[3];
                  if (v22)
                  {
                    if ((nauread_OpenDecoder((uint64_t)v25[2], v22) & 0x80000000) == 0)
                    {
                      naudec_Decode(v25, a8, a9);
                      if (v25)
                      {
                        v23 = v25[3];
                        if (v23)
                          genidec_Close(v23);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return naudec_Destroy((uint64_t *)&v25);
      }
      return v21;
    }
  }
  return v9;
}

uint64_t genidec_New(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t inited;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;

  if (!a3)
    return 2269126663;
  v11 = 0;
  inited = InitRsrcFunction(a1, a2, &v11);
  if ((inited & 0x80000000) == 0)
  {
    v7 = (_QWORD *)heap_Alloc(*(_QWORD *)(v11 + 8), 40);
    *a3 = v7;
    if (v7)
    {
      *v7 = a1;
      v7[1] = a2;
      v8 = (_QWORD *)*a3;
      v8[2] = 0;
      v8[3] = safeh_GetNullHandle();
      v8[4] = v9;
    }
    else
    {
      return 2269126666;
    }
  }
  return inited;
}

uint64_t genidec_Destroy(uint64_t *a1)
{
  uint64_t inited;
  uint64_t v3;
  uint64_t v5;

  inited = 2269126663;
  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      v5 = 0;
      inited = InitRsrcFunction(*(_WORD **)v3, *(_QWORD *)(v3 + 8), &v5);
      if ((inited & 0x80000000) == 0)
      {
        heap_Free(*(_QWORD **)(v5 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return inited;
}

uint64_t genidec_Open(_QWORD *a1, char *__s1, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  int v11;
  uint64_t inited;
  uint64_t v14;

  v5 = 2269126676;
  if (!a1)
    return 2269126663;
  if (a1[2])
    return 2269126673;
  if (!strcmp(__s1, "vssq5"))
  {
    if (a3 > 15999)
    {
      if (a3 == 16000)
        goto LABEL_20;
      v11 = 22050;
    }
    else
    {
      if (a3 == 8000)
        goto LABEL_20;
      v11 = 11025;
    }
    if (a3 != v11)
      return v5;
    goto LABEL_20;
  }
  if (strcmp(__s1, "rhelp"))
    return v5;
  if (a3 > 15999)
  {
    if (a3 != 22050 && a3 != 16000)
      return v5;
  }
  else if (a3 != 8000 && a3 != 11025)
  {
    return v5;
  }
LABEL_20:
  v14 = 0;
  inited = InitRsrcFunction((_WORD *)*a1, a1[1], &v14);
  if ((inited & 0x80000000) == 0)
  {
    inited = brk_InterfaceQuery(*(_QWORD *)(v14 + 24));
    if ((inited & 0x80000000) == 0)
      return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD *))(a1[2] + 32))(*a1, a1[1], a4, a5, a1 + 3);
  }
  return inited;
}

uint64_t genidec_Close(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = 2269126663;
  if (a1)
  {
    v3 = a1[2];
    if (v3)
    {
      v4 = (*(uint64_t (**)(_QWORD, _QWORD))(v3 + 40))(a1[3], a1[4]);
      a1[2] = 0;
      a1[3] = safeh_GetNullHandle();
      a1[4] = v5;
      return v4;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t genidec_RequestSamples(_QWORD *a1, int a2, int a3, _DWORD *a4, uint64_t *a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;

  result = 2269126663;
  if (a1 && a4 && a5 && a6)
  {
    v11 = a1[2];
    if (v11)
    {
      v15 = a3;
      v16 = a2;
      v12 = *a5;
      v13 = 0;
      v14 = v12;
      result = (*(uint64_t (**)(_QWORD, _QWORD, int *, int *, _QWORD, unsigned int *, unsigned int *))(v11 + 104))(a1[3], a1[4], &v16, &v15, 0, &v14, &v13);
      *a4 = v15;
      *a5 = v14;
      *a6 = v13;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t genidec_Decode(_QWORD *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v8;
  unsigned int v9;

  result = 2269126663;
  if (a1 && a2 && a3 && a4 && a5)
  {
    v8 = a1[2];
    if (v8)
    {
      v9 = *a3;
      result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, unsigned int *, uint64_t))(v8 + 112))(a1[3], a1[4], a2, &v9, a4);
      *a3 = v9;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_New(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t inited;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;

  if (!a3)
    return 2269126663;
  v10 = 0;
  inited = InitRsrcFunction(a1, a2, &v10);
  if ((inited & 0x80000000) == 0)
  {
    v7 = (_QWORD *)heap_Alloc(*(_QWORD *)(v10 + 8), 96);
    *a3 = (uint64_t)v7;
    if (v7)
    {
      *v7 = a1;
      v7[1] = a2;
      v8 = *a3;
      *(_QWORD *)(v8 + 16) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      *(_WORD *)(v8 + 28) = 0;
      *(_OWORD *)(v8 + 30) = 0u;
      *(_OWORD *)(v8 + 46) = 0u;
      *(_DWORD *)(v8 + 64) = 0;
      *(_QWORD *)(v8 + 80) = 0;
      *(_QWORD *)(v8 + 88) = 0;
      *(_QWORD *)(v8 + 72) = 0;
    }
    else
    {
      return 2269126666;
    }
  }
  return inited;
}

uint64_t nauread_Destroy(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t inited;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v1 = 2269126663;
  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      v13 = 0;
      inited = InitRsrcFunction(*(_WORD **)v3, *(_QWORD *)(v3 + 8), &v13);
      if ((inited & 0x80000000) != 0)
      {
        return inited;
      }
      else
      {
        v1 = nauread_Close(*a1, v5, v6, v7, v8, v9, v10, v11);
        heap_Free(*(_QWORD **)(v13 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return v1;
}

uint64_t nauread_Close(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (!a1)
    return 2269126663;
  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    result = ssftriff_reader_ObjClose((_QWORD *)result, a2, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 28) = 0;
    *(_OWORD *)(a1 + 30) = 0u;
    *(_OWORD *)(a1 + 46) = 0u;
    *(_DWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 72) = 0;
  }
  return result;
}

uint64_t nauread_ExtOpen(uint64_t a1, char *__s1, const char *a3, uint64_t a4, int a5)
{
  uint64_t result;
  uint64_t v11;

  result = 2269126663;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      return 2269126673;
    }
    else
    {
      if (!strcmp(__s1, "broker"))
      {
        v11 = 0;
      }
      else if (!strcmp(__s1, "file"))
      {
        v11 = 1;
      }
      else
      {
        v11 = 4 * (strcmp(__s1, "memory") == 0);
      }
      return ssftriff_reader_ObjOpenEx(*(_WORD **)a1, *(_QWORD *)(a1 + 8), v11, a3, a4, a5, "NUAU", 0, (uint64_t *)(a1 + 16));
    }
  }
  return result;
}

uint64_t nauread_ReadHeader(uint64_t a1)
{
  int v1;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int inited;
  uint64_t v26;
  void *v27;
  unint64_t v28;
  unsigned int *v29;
  unsigned int *v30;

  v1 = -2025840636;
  if (!a1)
    return 2269126663;
  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
    return 2269126673;
  LODWORD(v30) = 0;
  result = ssftriff_reader_FindChunk(v3, "NAUH", 0, (unsigned int *)&v30, 0);
  if ((result & 0x80000000) != 0)
    return result;
  v29 = 0;
  v30 = 0;
  v9 = nauread_OpenChunk(a1, "NAUF", &v30, &v29, v5, v6, v7, v8);
  if (v9 < 0)
    goto LABEL_21;
  if ((unint64_t)v29 > 5)
  {
    v10 = v30;
    *(_DWORD *)(a1 + 24) = *v30;
    *(_WORD *)(a1 + 28) = *((_WORD *)v10 + 2);
    v9 = ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
    if (v9 < 0)
      goto LABEL_21;
    v29 = 0;
    v30 = 0;
    v9 = nauread_OpenChunk(a1, "NAUX", &v30, &v29, v11, v12, v13, v14);
    if (v9 < 0)
      goto LABEL_21;
    if ((unint64_t)v29 > 3)
    {
      *(_QWORD *)(a1 + 80) = *v30;
      v9 = ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
      if (v9 < 0)
        goto LABEL_21;
      v29 = 0;
      v30 = 0;
      v9 = nauread_OpenChunk(a1, "NAUC", &v30, &v29, v15, v16, v17, v18);
      if (v9 < 0)
        goto LABEL_21;
      if ((unint64_t)v29 < 0x20)
      {
        __strcpy_chk();
        v9 = ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
        if (v9 < 0)
          goto LABEL_21;
        v28 = 0;
        v29 = 0;
        v9 = nauread_OpenChunk(a1, "NAUI", &v29, &v28, v19, v20, v21, v22);
        if (v9 < 0)
          goto LABEL_21;
        v23 = v28;
        if (v28 >= 4)
        {
          v24 = *v29;
          *(_DWORD *)(a1 + 64) = v24;
          if (v23 >= (v24 + 4))
          {
            v30 = 0;
            inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v30);
            if (inited < 0)
            {
              v1 = inited;
            }
            else
            {
              v26 = *(_QWORD *)(a1 + 72);
              if (v26)
              {
                heap_Free(*((_QWORD **)v30 + 1), v26);
                *(_QWORD *)(a1 + 72) = 0;
              }
              v27 = (void *)heap_Alloc(*((_QWORD *)v30 + 1), v24);
              *(_QWORD *)(a1 + 72) = v27;
              if (v27)
              {
                memcpy(v27, v29 + 1, *(unsigned int *)(a1 + 64));
                v9 = ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
LABEL_21:
                v1 = v9;
                goto LABEL_27;
              }
              v1 = -2025840630;
            }
          }
        }
      }
    }
  }
  ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
LABEL_27:
  LODWORD(result) = ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
  if (v1 >= 0)
    return result;
  else
    return v1;
}

uint64_t nauread_GetContentType(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v3;
  size_t v7;
  char __s[16];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = 2269126665;
  v7 = a3;
  if (!a1)
    return 2269126663;
  if (!*(_QWORD *)(a1 + 16))
    return 2269126673;
  if (a3)
  {
    *a2 = 0;
    if (nauread_strapp(a2, &v7, "audio/L"))
    {
      LH_itoa(*(unsigned __int16 *)(a1 + 28), __s, 0xAu);
      if (nauread_strapp(a2, &v7, __s))
      {
        if (nauread_strapp(a2, &v7, ";endian=little;rate="))
        {
          LH_itoa(*(_DWORD *)(a1 + 24), __s, 0xAu);
          if (nauread_strapp(a2, &v7, __s))
            return 0;
          else
            return 2269126665;
        }
      }
    }
  }
  return v3;
}

char *nauread_strapp(char *a1, size_t *a2, char *__s)
{
  size_t v6;

  v6 = strlen(__s);
  if (*a2 <= v6)
    return 0;
  *a2 -= v6;
  strcat(a1, __s);
  return a1;
}

uint64_t nauread_GetInfo(uint64_t a1, _DWORD *a2, _WORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v5;

  v5 = 2269126663;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      if (a2)
        *a2 = *(_DWORD *)(a1 + 24);
      if (a3)
        *a3 = *(_WORD *)(a1 + 28);
      if (a4)
        *a4 = a1 + 30;
      v5 = 0;
      if (a5)
        *a5 = *(_QWORD *)(a1 + 80);
    }
    else
    {
      return 2269126673;
    }
  }
  return v5;
}

uint64_t nauread_OpenDecoder(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 2269126663;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
      return genidec_Open(a2, (char *)(a1 + 30), *(_DWORD *)(a1 + 24), *(_QWORD *)(a1 + 72), *(unsigned int *)(a1 + 64));
    else
      return 2269126673;
  }
  return result;
}

uint64_t nauread_BeginReadData(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  unsigned int v4;

  result = 2269126663;
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      v4 = 0;
      result = ssftriff_reader_FindChunk(v3, "NAUD", 0, &v4, 0);
      *(_QWORD *)(a1 + 88) = v4;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_EndReadData(uint64_t a1)
{
  uint64_t result;

  result = 2269126663;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      result = ssftriff_reader_CloseChunk(*(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 88) = 0;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_ReadData(uint64_t a1, void *a2, size_t a3, size_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  size_t v12;
  uint64_t ChunkData;
  void *__src;

  v8 = 2269126663;
  if (a4)
  {
    *a4 = 0;
    if (a1)
    {
      v11 = *(_QWORD *)(a1 + 16);
      if (v11)
      {
        if (*(_QWORD *)(a1 + 88) >= a3)
          v12 = a3;
        else
          v12 = *(_QWORD *)(a1 + 88);
        if (v12)
        {
          __src = 0;
          ChunkData = ssftriff_reader_GetChunkData(v11, v12, &__src, (uint64_t)a4, a5, a6, a7, a8);
          if ((ChunkData & 0x80000000) != 0)
          {
            return ChunkData;
          }
          else
          {
            v8 = ssftriff_reader_Seek(*(_QWORD *)(a1 + 16), v12, 1);
            if ((v8 & 0x80000000) == 0)
            {
              memcpy(a2, __src, v12);
              *a4 = v12;
              *(_QWORD *)(a1 + 88) -= v12;
            }
          }
        }
        else
        {
          return 6;
        }
      }
      else
      {
        return 2269126673;
      }
    }
  }
  return v8;
}

uint64_t nauread_OpenChunk(uint64_t a1, const char *a2, _QWORD *a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  char __s1[4];
  char v13;
  unsigned int v14;

  v14 = 0;
  v13 = 0;
  *(_DWORD *)__s1 = 0;
  v10 = ssftriff_reader_OpenChunk(*(_QWORD *)(a1 + 16), __s1, &v14, a3, a5, a6, a7, a8);
  *a4 = v14;
  if (!strcmp(__s1, a2))
    return v10;
  else
    return 2269126660;
}

uint64_t spxrsmp_resampler_init(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  return spxrsmp_resampler_init_frac(a1, a2, a3, a4, a3, a4, a5, a6);
}

uint64_t spxrsmp_resampler_init_frac(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, int a5, int a6, unsigned int a7, int *a8)
{
  uint64_t v9;
  int v10;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _DWORD *v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;

  if (a7 >= 0xB)
  {
    v9 = 0;
    if (a8)
    {
      v10 = 3;
LABEL_21:
      *a8 = v10;
      return v9;
    }
    return v9;
  }
  v9 = heap_Calloc(*(_QWORD **)(a1 + 8), 136, 1);
  if (!v9)
  {
LABEL_19:
    if (a8)
    {
      v10 = 1;
      goto LABEL_21;
    }
    return v9;
  }
  v18 = *(_QWORD **)(a1 + 8);
  *(_QWORD *)(v9 + 60) = 0;
  *(_QWORD *)(v9 + 8) = 0;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)v9 = v18;
  *(_DWORD *)(v9 + 112) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  *(_QWORD *)(v9 + 96) = 0;
  *(_QWORD *)(v9 + 120) = 0;
  *(_DWORD *)(v9 + 52) = 1065353216;
  *(_DWORD *)(v9 + 24) = -1;
  *(_DWORD *)(v9 + 28) = a2;
  *(_DWORD *)(v9 + 40) = 160;
  v19 = (int)(4 * a2);
  *(_QWORD *)(v9 + 128) = 0x100000001;
  v20 = heap_Calloc(v18, v19, 1);
  *(_QWORD *)(v9 + 72) = v20;
  if (!v20)
  {
LABEL_18:
    heap_Free(*(_QWORD **)(a1 + 8), v9);
    v9 = 0;
    goto LABEL_19;
  }
  v21 = heap_Calloc(*(_QWORD **)v9, v19, 1);
  *(_QWORD *)(v9 + 88) = v21;
  v22 = *(_QWORD **)v9;
  if (!v21)
  {
LABEL_17:
    heap_Free(v22, *(_QWORD *)(v9 + 72));
    goto LABEL_18;
  }
  v23 = (_DWORD *)heap_Calloc(v22, v19, 1);
  *(_QWORD *)(v9 + 80) = v23;
  if (!v23)
  {
    heap_Free(*(_QWORD **)v9, *(_QWORD *)(v9 + 88));
    v22 = *(_QWORD **)v9;
    goto LABEL_17;
  }
  if (a2)
  {
    v24 = *(_DWORD **)(v9 + 72);
    v25 = *(_DWORD **)(v9 + 88);
    v26 = a2;
    do
    {
      *v24++ = 0;
      *v25++ = 0;
      *v23++ = 0;
      --v26;
    }
    while (v26);
  }
  if (*(_DWORD *)(v9 + 24) != a7)
  {
    *(_DWORD *)(v9 + 24) = a7;
    if (*(_DWORD *)(v9 + 60))
      update_filter((_QWORD **)v9);
  }
  spxrsmp_resampler_set_rate_frac(v9, a3, a4, a5, a6);
  update_filter((_QWORD **)v9);
  *(_DWORD *)(v9 + 60) = 1;
  if (a8)
  {
    v10 = 0;
    goto LABEL_21;
  }
  return v9;
}

uint64_t spxrsmp_resampler_set_rate_frac(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;

  if (*(_DWORD *)(a1 + 8) != a4
    || *(_DWORD *)(a1 + 12) != a5
    || *(_DWORD *)(a1 + 16) != a2
    || *(_DWORD *)(a1 + 20) != (_DWORD)a3)
  {
    v5 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 8) = a4;
    *(_DWORD *)(a1 + 12) = a5;
    *(_DWORD *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 20) = a3;
    if (a2 >= a3)
      v6 = a3;
    else
      v6 = a2;
    if (v6 >= 2)
    {
      v12 = 2;
      do
      {
        if (!(a2 % v12))
        {
          while (1)
          {
            v13 = a3 / v12;
            if (a3 % v12)
              break;
            a2 /= v12;
            *(_DWORD *)(a1 + 16) = a2;
            *(_DWORD *)(a1 + 20) = v13;
            a3 = a3 / v12;
            if (a2 % v12)
              goto LABEL_21;
          }
        }
        v13 = a3;
LABEL_21:
        ++v12;
        if (a2 >= v13)
          v14 = v13;
        else
          v14 = a2;
        a3 = v13;
      }
      while (v12 <= v14);
    }
    if (v5 && *(_DWORD *)(a1 + 28))
    {
      v7 = 0;
      v8 = *(_QWORD *)(a1 + 80);
      do
      {
        v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(v8 + 4 * v7) / v5;
        *(_DWORD *)(v8 + 4 * v7) = v9;
        v10 = *(_DWORD *)(a1 + 20);
        if (v9 >= v10)
          *(_DWORD *)(v8 + 4 * v7) = v10 - 1;
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 28));
    }
    if (*(_DWORD *)(a1 + 60))
      update_filter((_QWORD **)a1);
  }
  return 0;
}

void update_filter(_QWORD **a1)
{
  unsigned int v2;
  int v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  float *v11;
  BOOL v12;
  BOOL v13;
  BOOL v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(uint64_t, unsigned int, uint64_t, int *, uint64_t, int *);
  unsigned int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  _QWORD *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  unint64_t v55;
  int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  unsigned int v63;
  unint64_t v64;
  unsigned int v65;
  int v67;
  int v68;
  _QWORD *v69;
  int v70;
  int v71;
  unint64_t v72;
  _QWORD *v73;
  int v74;
  unsigned int v75;
  int v76;
  int v77;
  uint64_t v78;
  unsigned int v79;
  unsigned int v80;

  v2 = *((_DWORD *)a1 + 8);
  v3 = *((_DWORD *)a1 + 6);
  v4 = (unsigned int *)((char *)&quality_map + 24 * v3);
  v6 = *v4;
  v5 = v4[1];
  *((_DWORD *)a1 + 14) = v5;
  *((_DWORD *)a1 + 8) = v6;
  v8 = *((_DWORD *)a1 + 4);
  v7 = *((_DWORD *)a1 + 5);
  if (v8 <= v7)
  {
    *((_DWORD *)a1 + 13) = *((_DWORD *)&quality_map + 6 * v3 + 3);
  }
  else
  {
    v9 = v8 * v6 / v7 - 1;
    v10 = v5 >> (2 * v7 < v8) >> (4 * v7 < v8) >> (8 * v7 < v8) >> (16 * v7 < v8);
    v11 = (float *)((char *)&quality_map + 24 * v3);
    if (v10 <= 1)
      v5 = 1;
    else
      v5 = v5 >> (2 * v7 < v8) >> (4 * v7 < v8) >> (8 * v7 < v8) >> (16 * v7 < v8);
    *((float *)a1 + 13) = (float)(v11[2] * (float)v7) / (float)v8;
    v6 = (v9 & 0xFFFFFFF8) + 8;
    *((_DWORD *)a1 + 8) = v6;
    if (4 * v7 < v8
      || (v10 ? (v12 = 2 * v7 >= v8) : (v12 = 0),
          v12 ? (v13 = 8 * v7 >= v8) : (v13 = 0),
          v13 ? (v14 = 16 * v7 >= v8) : (v14 = 0),
          !v14))
    {
      *((_DWORD *)a1 + 14) = v5;
    }
  }
  v15 = (uint64_t)a1[13];
  if (v7 <= 16 * v5 + 128)
  {
    if (v15)
    {
      v17 = v6 * v7;
      if (*((_DWORD *)a1 + 28) < v17)
      {
        v15 = heap_Realloc(*a1, (uint64_t)a1[13], (int)(2 * v17));
        a1[13] = (_QWORD *)v15;
        *((_DWORD *)a1 + 28) = *((_DWORD *)a1 + 5) * *((_DWORD *)a1 + 8);
        if (!v15)
          goto LABEL_44;
      }
    }
    else
    {
      v15 = heap_Calloc(*a1, (int)(2 * v7 * v6), 1);
      a1[13] = (_QWORD *)v15;
      if (!v15)
      {
LABEL_44:
        v26 = resampler_basic_direct_single;
        goto LABEL_45;
      }
    }
    v27 = *((_DWORD *)a1 + 5);
    if (v27)
    {
      v80 = v2;
      v28 = 0;
      v29 = 0;
      v30 = *((unsigned int *)a1 + 8);
      if ((int)v30 >= 0)
        v31 = *((_DWORD *)a1 + 8);
      else
        v31 = v30 + 1;
      v32 = 1 - (v31 >> 1);
      do
      {
        if ((_DWORD)v30)
        {
          v33 = 0;
          v34 = *((float *)a1 + 13);
          v35 = *((_QWORD *)&quality_map + 3 * *((int *)a1 + 6) + 2);
          do
          {
            *(_WORD *)(v15 + 2 * (v28 + v33)) = sinc(v30, v35, v34, (float)(v32 + v33) - (float)((float)v29 / (float)v27));
            ++v33;
          }
          while (v30 != v33);
        }
        ++v29;
        v28 += v30;
      }
      while (v29 != v27);
      v2 = v80;
    }
    goto LABEL_44;
  }
  if (v15)
  {
    v16 = v6 * v5 + 8;
    if (*((_DWORD *)a1 + 28) < v16)
    {
      v15 = heap_Realloc(*a1, (uint64_t)a1[13], (int)(2 * v16));
      a1[13] = (_QWORD *)v15;
      *((_DWORD *)a1 + 28) = *((_DWORD *)a1 + 14) * *((_DWORD *)a1 + 8) + 8;
      if (!v15)
        goto LABEL_32;
    }
  }
  else
  {
    v15 = heap_Calloc(*a1, (int)(2 * v5 * v6 + 16), 1);
    a1[13] = (_QWORD *)v15;
    if (!v15)
    {
LABEL_32:
      v26 = resampler_basic_interpolate_single;
      goto LABEL_45;
    }
  }
  v18 = *((_DWORD *)a1 + 14);
  v19 = *((_DWORD *)a1 + 8);
  v20 = v19 * v18 + 4;
  if (v20 < -3)
    goto LABEL_32;
  v21 = 0;
  v22 = (float)v18;
  v23 = *((float *)a1 + 13);
  v24 = *((_QWORD *)&quality_map + 3 * *((int *)a1 + 6) + 2);
  v25 = v20 + 4;
  v26 = resampler_basic_interpolate_single;
  do
  {
    *(_WORD *)(v15 + 2 * v21) = sinc(v19, v24, v23, (float)((float)(v21 - 4) / v22) - (float)(v19 >> 1));
    ++v21;
  }
  while (v25 != v21);
LABEL_45:
  a1[15] = v26;
  v36 = *((_DWORD *)a1 + 4);
  v37 = *((_DWORD *)a1 + 5);
  *((_DWORD *)a1 + 11) = v36 / v37;
  *((_DWORD *)a1 + 12) = v36 % v37;
  v38 = (uint64_t)a1[12];
  if (!v38)
  {
    v67 = *((_DWORD *)a1 + 7);
    v68 = *((_DWORD *)a1 + 8) + *((_DWORD *)a1 + 10) - 1;
    *((_DWORD *)a1 + 9) = v68;
    v69 = (_QWORD *)heap_Calloc(*a1, 2 * v68 * v67, 1);
LABEL_80:
    a1[12] = v69;
    if (v69)
    {
      v71 = *((_DWORD *)a1 + 9);
      if (v71 * *((_DWORD *)a1 + 7))
        bzero(v69, 2 * (v71 * *((_DWORD *)a1 + 7)));
    }
    return;
  }
  v39 = *((_DWORD *)a1 + 8);
  if (!*((_DWORD *)a1 + 16))
  {
    v70 = v39 + *((_DWORD *)a1 + 10) - 1;
    *((_DWORD *)a1 + 9) = v70;
    v69 = (_QWORD *)heap_Realloc(*a1, v38, 2 * v70 * *((_DWORD *)a1 + 7));
    goto LABEL_80;
  }
  if (v39 <= v2)
  {
    if (v39 < v2 && *((_DWORD *)a1 + 7))
    {
      v72 = 0;
      v73 = a1[11];
      do
      {
        v74 = *((_DWORD *)v73 + v72);
        v75 = (v2 - *((_DWORD *)a1 + 8)) >> 1;
        *((_DWORD *)v73 + v72) = v75;
        v76 = *((_DWORD *)a1 + 8);
        v77 = v74 + v75;
        v78 = (v77 + v76 - 1);
        if (v77 + v76 != 1)
        {
          v79 = *((_DWORD *)a1 + 9) * v72;
          do
          {
            *(_WORD *)(v38 + 2 * v79) = *(_WORD *)(v38 + 2 * (v75 + v79));
            ++v79;
            --v78;
          }
          while (v78);
        }
        *((_DWORD *)v73 + v72++) = v77;
      }
      while (v72 < *((unsigned int *)a1 + 7));
    }
  }
  else
  {
    v40 = *((int *)a1 + 9);
    v41 = v39 + *((_DWORD *)a1 + 10) - 1;
    if (v41 > v40)
    {
      *((_DWORD *)a1 + 9) = v41;
      v38 = heap_Realloc(*a1, v38, (int)(2 * v41 * *((_DWORD *)a1 + 7)));
      a1[12] = (_QWORD *)v38;
    }
    v42 = (*((_DWORD *)a1 + 7) - 1);
    if ((int)v42 >= 0)
    {
      v43 = a1[11];
      v44 = v2 - 2;
      v45 = v38 + 2 * v40 * v42;
      while (1)
      {
        v46 = *((unsigned int *)v43 + v42);
        v47 = v2 + 2 * v46;
        if (v38)
          break;
        *((_DWORD *)v43 + v42) = 0;
        v52 = *((_DWORD *)a1 + 8);
        if (v47 < v52)
          goto LABEL_74;
        *((_DWORD *)v43 + v42) = (v47 - v52) >> 1;
LABEL_75:
        v45 -= 2 * v40;
        if (v42-- <= 0)
          return;
      }
      if ((int)(v44 + v46) >= 0)
      {
        v48 = 2 * (v44 + v46);
        v49 = v44 + *((_DWORD *)a1 + 9) * v42 + 2 * v46;
        do
        {
          *(_WORD *)(v38 + 2 * v49) = *(_WORD *)(v45 + v48);
          v48 -= 2;
          --v49;
        }
        while (v48 != -2);
      }
      if ((_DWORD)v46)
      {
        v50 = *((_DWORD *)a1 + 9) * v42;
        v51 = v46;
        do
        {
          *(_WORD *)(v38 + 2 * v50++) = 0;
          --v51;
        }
        while (v51);
      }
      *((_DWORD *)v43 + v42) = 0;
      v52 = *((_DWORD *)a1 + 8);
      v53 = v47 - v52;
      if (v47 >= v52)
      {
        *((_DWORD *)v43 + v42) = v53 >> 1;
        v62 = *((_DWORD *)a1 + 8) + (v53 >> 1) - 1;
        if (*((_DWORD *)a1 + 8) + (v53 >> 1) != 1)
        {
          v63 = *((_DWORD *)a1 + 9) * v42;
          do
          {
            *(_WORD *)(v38 + 2 * v63) = *(_WORD *)(v38 + 2 * ((v53 >> 1) + v63));
            ++v63;
            --v62;
          }
          while (v62);
        }
        goto LABEL_75;
      }
      v54 = 2 * v46;
      v55 = v47 - 1;
      if (v47 == 1)
      {
        v61 = 0;
      }
      else
      {
        v56 = *((_DWORD *)a1 + 9) * v42;
        v57 = v52 + v56;
        v58 = v44 + v54 + v56;
        v59 = v57 - 2;
        v60 = v47 - 1;
        do
        {
          *(_WORD *)(v38 + 2 * v59--) = *(_WORD *)(v38 + 2 * v58--);
          --v60;
        }
        while (v60);
        v61 = v47 - 1;
      }
      v64 = v52 - 1;
      if (v61 < v64)
      {
        v65 = ~v2 + v52 + *((_DWORD *)a1 + 9) * v42 - v54;
        do
        {
          *(_WORD *)(v38 + 2 * v65) = 0;
          ++v55;
          --v65;
        }
        while (v55 < v64);
      }
LABEL_74:
      *((_DWORD *)a1[9] + v42) += (v52 - v47) >> 1;
      goto LABEL_75;
    }
  }
}

_QWORD *spxrsmp_resampler_destroy(_QWORD *result)
{
  _QWORD **v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v1 = (_QWORD **)result;
    v2 = (_QWORD *)*result;
    v3 = result[12];
    if (v3)
      heap_Free((_QWORD *)*result, v3);
    v4 = (uint64_t)v1[13];
    if (v4)
      heap_Free(*v1, v4);
    v5 = (uint64_t)v1[9];
    if (v5)
      heap_Free(*v1, v5);
    v6 = (uint64_t)v1[11];
    if (v6)
      heap_Free(*v1, v6);
    v7 = (uint64_t)v1[10];
    if (v7)
      heap_Free(*v1, v7);
    return heap_Free(v2, (uint64_t)v1);
  }
  return result;
}

uint64_t spxrsmp_resampler_process_int(uint64_t a1, unsigned int a2, _WORD *a3, unsigned int *a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v6;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  _WORD *v18;
  uint64_t v19;
  _WORD *v20;
  _WORD *v21;
  _WORD *v22;
  uint64_t result;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;

  v28 = a5;
  v6 = *(_QWORD *)(a1 + 96);
  if (!v6 || !*(_QWORD *)(a1 + 104))
    return 1;
  v10 = *a4;
  v11 = *a6;
  v13 = *(_DWORD *)(a1 + 32);
  v12 = *(_DWORD *)(a1 + 36);
  v14 = *(int *)(a1 + 128);
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 88) + 4 * a2)
    || (v11 -= speex_resampler_magic(a1, a2, &v28, v11), !*(_DWORD *)(*(_QWORD *)(a1 + 88) + 4 * a2)))
  {
    if (v10 && v11)
    {
      v15 = v13 - 1;
      v16 = v12 - (v13 - 1);
      v17 = v28;
      v18 = (_WORD *)(v6 + 2 * v12 * a2 + 2 * v15);
      do
      {
        if (v10 >= v16)
          v19 = v16;
        else
          v19 = v10;
        v26 = v11;
        v27 = v19;
        if (a3)
        {
          if ((_DWORD)v19)
          {
            v20 = a3;
            v21 = v18;
            do
            {
              *v21++ = *v20;
              v20 += v14;
              --v19;
            }
            while (v19);
          }
        }
        else if ((_DWORD)v19)
        {
          v22 = v18;
          do
          {
            *v22++ = 0;
            --v19;
          }
          while (v19);
        }
        speex_resampler_process_native(a1, a2, &v27, v17, &v26);
        v11 -= v26;
        if (a3)
          a3 += v27 * v14;
        else
          a3 = 0;
        v10 -= v27;
        if (!v10)
          break;
        v17 += 2 * *(_DWORD *)(a1 + 132) * v26;
      }
      while (v11);
    }
  }
  result = 0;
  *a4 -= v10;
  *a6 -= v11;
  return result;
}

uint64_t speex_resampler_magic(uint64_t a1, unsigned int a2, uint64_t *a3, unsigned int a4)
{
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t result;
  unsigned int v17;
  unsigned int v18;

  v18 = a4;
  v7 = *(_QWORD *)(a1 + 96);
  v17 = *(_DWORD *)(*(_QWORD *)(a1 + 88) + 4 * a2);
  v8 = *(_DWORD *)(a1 + 32);
  v9 = *(_DWORD *)(a1 + 36);
  speex_resampler_process_native(a1, a2, &v17, *a3, &v18);
  v10 = *(_QWORD *)(a1 + 88);
  v11 = *(_DWORD *)(v10 + 4 * a2);
  v13 = v11 - v17;
  v12 = v11 == v17;
  *(_DWORD *)(v10 + 4 * a2) = v13;
  if (!v12)
  {
    v14 = v17;
    v15 = v8 - 1;
    do
    {
      *(_WORD *)(v7 + 2 * v9 * a2 + 2 * v15) = *(_WORD *)(v7 + 2 * v9 * a2 + 2 * (v14 + v15));
      ++v15;
      --v13;
    }
    while (v13);
  }
  result = v18;
  *a3 += 2 * *(_DWORD *)(a1 + 132) * v18;
  return result;
}

uint64_t speex_resampler_process_native(uint64_t a1, unsigned int a2, unsigned int *a3, uint64_t a4, _DWORD *a5)
{
  int v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  _WORD *v16;

  v9 = *(_DWORD *)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 96) + 2 * *(_DWORD *)(a1 + 36) * a2;
  *(_DWORD *)(a1 + 64) = 1;
  result = (*(uint64_t (**)(void))(a1 + 120))();
  v12 = *(_QWORD *)(a1 + 72);
  v13 = *(_DWORD *)(v12 + 4 * a2);
  if (v13 < (int)*a3)
    *a3 = v13;
  *a5 = result;
  *(_DWORD *)(v12 + 4 * a2) -= *a3;
  if (v9 >= 2)
  {
    v14 = *a3;
    v15 = (v9 - 1);
    v16 = (_WORD *)v10;
    do
    {
      *v16++ = *(_WORD *)(v10 + 2 * v14++);
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t sinc(int a1, uint64_t a2, float a3, float a4)
{
  double v4;
  double v5;
  double v6;
  double v7;
  int v8;
  long double v11;
  float v12;
  double v13;

  v4 = a4;
  v5 = fabs(a4);
  if (v5 >= 0.000000999999997)
  {
    if (v5 <= (float)((float)a1 * 0.5))
    {
      v11 = a3 * 32768.0 * sin((float)(a3 * a4) * 3.14159265) / ((float)(a3 * a4) * 3.14159265);
      v12 = (v4 + v4) / (double)a1;
      v13 = v11 * compute_func(a2, fabsf(v12));
      if (v13 >= -32767.0)
      {
        if (v13 <= 32766.0)
          v8 = (int)v13;
        else
          LOWORD(v8) = 0x7FFF;
      }
      else
      {
        LOWORD(v8) = 0x8000;
      }
    }
    else
    {
      LOWORD(v8) = 0;
    }
  }
  else
  {
    v6 = a3 * 32768.0;
    v7 = 32767.0;
    if (v6 <= 32766.0)
      v7 = v6;
    v8 = (int)v7;
    if (v6 < -32767.0)
      LOWORD(v8) = 0x8000;
  }
  return (__int16)v8;
}

uint64_t resampler_basic_direct_single(uint64_t a1, unsigned int a2, uint64_t a3, int *a4, uint64_t a5, int *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  int16x4_t *v21;
  int16x4_t *v22;
  int32x4_t v23;
  int16x4_t v24;
  int16x4_t v25;
  int16x4_t v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 72);
  v8 = *(_QWORD *)(a1 + 80);
  v9 = *(_DWORD *)(v7 + 4 * a2);
  v10 = *(_DWORD *)(v8 + 4 * a2);
  v11 = *a4;
  if (v9 >= *a4)
  {
    result = 0;
  }
  else
  {
    v12 = 0;
    v13 = *(int *)(a1 + 32);
    v14 = *(_QWORD *)(a1 + 104);
    v15 = *(_DWORD *)(a1 + 44);
    v16 = *(_DWORD *)(a1 + 48);
    v17 = *(_DWORD *)(a1 + 20);
    v18 = *(int *)(a1 + 132);
    result = *a6 & ~(*a6 >> 31);
    while (v12 != result)
    {
      if ((int)v13 < 1)
      {
        LOWORD(v28) = 0;
      }
      else
      {
        v20 = 0;
        v21 = (int16x4_t *)(v14 + 2 * v10 * v13);
        v22 = (int16x4_t *)(a3 + 2 * v9);
        v23 = 0uLL;
        do
        {
          v24 = *v21++;
          v25 = v24;
          v26 = *v22++;
          v23 = vmlal_s16(v23, v26, v25);
          v20 += 4;
        }
        while (v20 < v13);
        v27 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v23.i8, 1), v23), vaddq_s32(vdupq_laneq_s32(v23, 2), vdupq_laneq_s32(v23, 3))).u32[0];
        v28 = (v27 + 0x4000) >> 15;
        if (v28 <= -32767)
          LOWORD(v28) = -32767;
        if (v27 > 1073725439)
          LOWORD(v28) = 0x7FFF;
      }
      v29 = v12 + 1;
      *(_WORD *)(a5 + 2 * v12 * v18) = v28;
      v9 += v15;
      v30 = v10 + v16;
      if (v30 < v17)
      {
        v31 = 0;
      }
      else
      {
        ++v9;
        v31 = v17;
      }
      v10 = v30 - v31;
      v12 = v29;
      if (v9 >= v11)
      {
        result = v29;
        break;
      }
    }
  }
  *(_DWORD *)(v7 + 4 * v6) = v9;
  *(_DWORD *)(v8 + 4 * v6) = v10;
  return result;
}

uint64_t resampler_basic_interpolate_single(uint64_t a1, unsigned int a2, uint64_t a3, int *a4, uint64_t a5, int *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  __int16 *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  __int16 v39;
  int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 72);
  v8 = *(_QWORD *)(a1 + 80);
  v9 = *(_DWORD *)(v7 + 4 * a2);
  v10 = *(_DWORD *)(v8 + 4 * a2);
  v11 = *a4;
  if (v9 >= *a4)
  {
    v17 = 0;
  }
  else
  {
    v46 = *(_QWORD *)(a1 + 80);
    v47 = *(_QWORD *)(a1 + 72);
    v48 = a2;
    v12 = 0;
    v13 = *(_DWORD *)(a1 + 44);
    v14 = *(_DWORD *)(a1 + 48);
    v15 = *(_DWORD *)(a1 + 20);
    v16 = *(unsigned int *)(a1 + 32);
    v17 = *a6 & ~(*a6 >> 31);
    v18 = *(int *)(a1 + 132);
    while (v12 != v17)
    {
      v19 = *(_DWORD *)(a1 + 56);
      if ((int)v16 < 1)
      {
        v24 = 0;
        v23 = 0;
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = *(_QWORD *)(a1 + 104);
        v26 = v16;
        v27 = (__int16 *)(a3 + 2 * v9);
        do
        {
          v28 = *v27++;
          v29 = v19 * ++v20 - v19 * v10 / v15;
          v24 += *(__int16 *)(v25 + 2 * (v29 + 2)) * v28;
          v23 += *(__int16 *)(v25 + 2 * (v29 + 3)) * v28;
          v22 += *(__int16 *)(v25 + 2 * (v29 + 4)) * v28;
          v21 += *(__int16 *)(v25 + 2 * (v29 + 5)) * v28;
          --v26;
        }
        while (v26);
      }
      v30 = (int)(((__int16)v15 >> 1) + ((v19 * v10 % v15) << 15)) / (int)v15;
      v31 = (__int16)v30;
      v32 = 2 * (__int16)v30;
      v33 = (v32 * (__int16)v30 + 0x8000) >> 16;
      v34 = v33 * v32 + 0x8000;
      v35 = 5461 * (v34 >> 16);
      v36 = v35 + 2147478188 * (__int16)v30 + 0x4000;
      v37 = v30 + ((v33 - (v34 >> 16)) >> 1);
      v38 = 2147472726 * v31 + (v33 << 14) - v35 + 0x4000;
      if ((_WORD)v37 + (unsigned __int16)(v38 >> 15) + (unsigned __int16)(v36 >> 15))
        v39 = 0x8000;
      else
        v39 = 0x7FFF;
      v40 = (v24 >> 16) * (__int16)(v36 >> 15)
          + (v23 >> 16) * (__int16)v37
          + ((((unsigned __int16)v24 >> 1) * (__int16)(v36 >> 15)) >> 15)
          + (v22 >> 16) * (__int16)(v39 - (v37 + (v38 >> 15) + (v36 >> 15)))
          + ((((unsigned __int16)v23 >> 1) * (__int16)v37) >> 15)
          + (v21 >> 16) * (__int16)(v38 >> 15)
          + ((((unsigned __int16)v22 >> 1)
            * (__int16)(v39 - (v37 + (v38 >> 15) + (v36 >> 15)))) >> 15)
          + ((((unsigned __int16)v21 >> 1) * (__int16)(v38 >> 15)) >> 15);
      v41 = (v40 + 0x2000) >> 14;
      if (v41 <= -32767)
        LOWORD(v41) = -32767;
      if (v40 > 536862719)
        LOWORD(v41) = 0x7FFF;
      v42 = v12 + 1;
      *(_WORD *)(a5 + 2 * v12 * v18) = v41;
      v43 = v10 + v14;
      if (v10 + v14 < v15)
        v9 += v13;
      else
        v9 += v13 + 1;
      if (v43 < v15)
        v44 = 0;
      else
        v44 = v15;
      v10 = v43 - v44;
      ++v12;
      if (v9 >= v11)
      {
        v17 = v42;
        break;
      }
    }
    v7 = v47;
    v6 = v48;
    v8 = v46;
  }
  *(_DWORD *)(v7 + 4 * v6) = v9;
  *(_DWORD *)(v8 + 4 * v6) = v10;
  return v17;
}

double compute_func(uint64_t a1, float a2)
{
  float v2;
  signed int v3;
  float v4;
  double v5;
  float v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double *v12;

  v2 = (float)*(int *)(a1 + 8) * a2;
  v3 = vcvtms_s32_f32(v2);
  v4 = v2 - (float)(int)floorf(v2);
  v5 = v4;
  v6 = v4 * v4;
  v7 = (float)(v4 * (float)(v4 * v4));
  v8 = v7 * 0.166666667 + v5 * -0.166666667;
  v9 = v6;
  v10 = v5 + v9 * 0.5 + v7 * -0.5;
  v11 = v9 * 0.5 + v5 * -0.333333333 + v7 * -0.166666667;
  v12 = (double *)(*(_QWORD *)a1 + 8 * v3);
  return v12[1] * (1.0 - v8 - v10 - v11) + v11 * *v12 + v10 * v12[2] + v8 * v12[3];
}

uint64_t audioinserter_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2341478401;
  result = 0;
  *a2 = &IAudioInserter;
  return result;
}

uint64_t audioins_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Object;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t ParamU32;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  int v45;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD v51[3];

  v5 = 2341478410;
  v49 = 0;
  v50 = 0;
  if (!a5)
    return 2341478407;
  inited = InitRsrcFunction(a3, a4, &v50);
  if ((inited & 0x80000000) != 0)
    return inited;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  log_OutText(*(_QWORD *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Entering audioins_ObjOpen", v10, v11, v12, v47);
  v13 = (_QWORD *)heap_Calloc(*(_QWORD **)(v50 + 8), 1, 1056);
  v18 = v50;
  if (v13)
  {
    v19 = (uint64_t)v13;
    v13[1] = a4;
    v13[2] = v18;
    *v13 = a3;
    Object = objc_GetObject(*(_QWORD *)(v50 + 48), (uint64_t)"SYNTHSTREAM", &v49);
    if ((Object & 0x80000000) != 0)
    {
      v31 = Object;
      log_OutPublic(*(_QWORD *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2574, 0, v21, v22, v23, v24, v48);
      v5 = v31;
      goto LABEL_27;
    }
    *(_QWORD *)(v19 + 848) = *(_QWORD *)(v49 + 8);
    if ((objc_GetObject(*(_QWORD *)(v50 + 48), (uint64_t)"AUDIOFETCHER", &v49) & 0x80000000) == 0)
    {
      v29 = v49;
      if (*(_BYTE *)v49 == 1)
      {
        v30 = *(_QWORD *)(v49 + 8);
        if (v30)
        {
          *(_QWORD *)(v19 + 920) = v30;
          *(_OWORD *)(v19 + 928) = *(_OWORD *)(v29 + 16);
LABEL_15:
          ParamU32 = audioins_GetParamU32(v19, (uint64_t)"frequencyhz", (unsigned int *)(v19 + 944), 0x1F40u);
          if ((ParamU32 & 0x80000000) != 0
            || (ParamU32 = audioins_GetParamU32(v19, (uint64_t)"audiooutputbufsamples", (unsigned int *)(v19 + 948), 0x400u), (ParamU32 & 0x80000000) != 0)|| (ParamU32 = audioins_SetDefaultAudioProsodyParameters(v19), (ParamU32 & 0x80000000) != 0))
          {
            v5 = ParamU32;
          }
          else
          {
            v37 = WSOLA__Create(*(_QWORD *)(v19 + 16), *(_WORD *)(v19 + 944));
            *(_QWORD *)(v19 + 1032) = v37;
            if (v37)
            {
              WSOLA__Initialise(v37);
              WSOLA__SetTimeScaleFactor(*(_WORD **)(v19 + 1032), 100);
              v38 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(v19 + 1032) + 328), 2048);
              *(_QWORD *)(v19 + 1040) = v38;
              if (v38)
              {
                v39 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(v19 + 1032) + 328), 2048);
                *(_QWORD *)(v19 + 1048) = v39;
                if (v39)
                {
                  v40 = 0;
                  v41 = v50;
                  do
                  {
                    v42 = *(_QWORD *)(v41 + 40);
                    v43 = off_1EA94A6C0[v40];
                    v51[0] = v19;
                    v51[1] = audioinserter_loc_ParamCheckChange;
                    v51[2] = audioinserter_loc_ParamLearnChange;
                    v44 = paramc_ListenerAdd(v42, v43, v51);
                    v5 = v44;
                    if (v40 > 4)
                      break;
                    ++v40;
                  }
                  while ((v44 & 0x80000000) == 0);
                  if ((v44 & 0x80000000) == 0)
                  {
                    v45 = 13546;
LABEL_28:
                    *(_QWORD *)a5 = v19;
                    *(_DWORD *)(a5 + 8) = v45;
                    log_OutText(*(_QWORD *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Leaving audioins_ObjOpen: %x", v33, v34, v35, v5);
                    return v5;
                  }
                }
              }
            }
          }
LABEL_27:
          log_OutPublic(*(_QWORD *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2580, "%s%x", v32, v33, v34, v35, "lhError");
          *(_QWORD *)a5 = v19;
          *(_DWORD *)(a5 + 8) = 13546;
          audioins_ObjClose((_QWORD *)v19, *(_QWORD *)(a5 + 8));
          v19 = 0;
          v45 = 0;
          goto LABEL_28;
        }
      }
      objc_ReleaseObject(*(_QWORD *)(v50 + 48), (uint64_t)"AUDIOFETCHER");
    }
    log_OutPublic(*(_QWORD *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2560, 0, v25, v26, v27, v28, v48);
    goto LABEL_15;
  }
  log_OutPublic(*(_QWORD *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2577, 0, v14, v15, v16, v17, v48);
  return v5;
}

uint64_t audioins_ObjClose(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  __int128 v22;
  uint64_t (*v23)(uint64_t, char *, const char *);

  if ((safeh_HandleCheck((uint64_t)a1, a2, 13546, 1056) & 0x80000000) != 0)
    return 2341478408;
  v6 = a1[2];
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Entering audioins_ObjClose", v3, v4, v5, v21);
  v7 = 0;
  do
  {
    v8 = *(_QWORD *)(v6 + 40);
    v9 = off_1EA94A6C0[v7];
    *(_QWORD *)&v22 = a1;
    *((_QWORD *)&v22 + 1) = audioinserter_loc_ParamCheckChange;
    v23 = audioinserter_loc_ParamLearnChange;
    v10 = paramc_ListenerRemove(v8, v9, &v22);
    v11 = v10;
    if (v7 > 4)
      break;
    ++v7;
  }
  while ((v10 & 0x80000000) == 0);
  if (a1[106])
  {
    v12 = objc_ReleaseObject(*(_QWORD *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if (v12 >= 0 || (int)v11 <= -1)
      v11 = v11;
    else
      v11 = v12;
  }
  if (a1[115])
  {
    v14 = objc_ReleaseObject(*(_QWORD *)(v6 + 48), (uint64_t)"AUDIOFETCHER");
    if (v14 >= 0 || (int)v11 <= -1)
      v11 = v11;
    else
      v11 = v14;
  }
  v16 = a1[129];
  if (v16)
  {
    heap_Free(*(_QWORD **)(v16 + 328), a1[130]);
    heap_Free(*(_QWORD **)(a1[129] + 328), a1[131]);
    WSOLA__Remove(a1 + 129);
    a1[129] = 0;
  }
  heap_Free(*(_QWORD **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Leaving audioins_ObjClose: %x", v17, v18, v19, v11);
  return v11;
}

uint64_t audioins_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  char v9[48];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if ((safeh_HandleCheck(a1, a2, 13546, 1056) & 0x80000000) != 0)
    return 2341478408;
  synstrmaux_InitStreamOpener(a1 + 24, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER");
  *(_QWORD *)(a1 + 952) = 0;
  *(_DWORD *)(a1 + 960) = 0;
  v7 = audioins_SetDefaultAudioProsodyParameters(a1);
  if ((v7 & 0x80000000) == 0 && *(_QWORD *)(a1 + 920))
  {
    if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 944), v9, 0x30uLL) <= 0x2F)
    {
      synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)v9, 1, a1 + 856);
      synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        0,
        a1 + 888);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)v9, a1 + 872);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        a1 + 904);
      v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 24), *(_QWORD *)(a1 + 848), a3, a4);
      if ((v7 & 0x80000000) != 0)
        synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(_QWORD *)(a1 + 848));
    }
    else
    {
      return 9;
    }
  }
  return v7;
}

uint64_t audioins_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7;
  uint64_t inserted;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  int v45;
  unint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  __int128 *v50;
  __int128 *v51;
  int v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;

  v95 = 0;
  v96 = 0;
  v94 = 0;
  v92 = 0;
  v93 = 0;
  v7 = safeh_HandleCheck(a1, a2, 13546, 1056);
  if ((v7 & 0x80000000) != 0)
    return 2341478408;
  *a5 = 1;
  if (!*(_QWORD *)(a1 + 920))
    return v7;
  if (*(_QWORD *)(a1 + 968))
  {
    inserted = audioins_InsertAudio(a1);
    if ((inserted & 0x80000000) == 0 && !*(_DWORD *)(a1 + 992))
      inserted = audioins_InsertAudioEnd(a1);
    *a5 = 2;
    return inserted;
  }
  inserted = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), (char *)&v96 + 4, &v95);
  if ((inserted & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, "%s%x", v9, v10, v11, v12, "lhError");
    return inserted;
  }
  if (!HIDWORD(v96))
  {
    v34 = *(_QWORD *)(a1 + 856);
    if (v34)
    {
      inserted = (*(uint64_t (**)(uint64_t, _QWORD, char *, int *))(*(_QWORD *)(a1 + 848) + 144))(v34, *(_QWORD *)(a1 + 864), (char *)&v95 + 4, &v94);
      if ((inserted & 0x80000000) != 0)
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2569, "%s%x", v35, v36, v37, v38, "lhError");
    }
    else
    {
      HIDWORD(v95) = 0;
      v94 = 1;
    }
    if ((inserted & 0x80000000) == 0 && (_DWORD)v95 && v94)
    {
      inserted = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 24), *(_QWORD *)(a1 + 848));
      v24 = 0;
    }
    else if (HIDWORD(v95))
    {
      v24 = 1;
    }
    else
    {
      v24 = 0;
      *a5 = 0;
    }
    goto LABEL_58;
  }
  v13 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 848) + 88))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), &v93, (char *)&v96 + 4);
  if ((v13 & 0x80000000) != 0)
  {
    inserted = v13;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, "%s%x", v14, v15, v16, v17, "lhError");
    return inserted;
  }
  inserted = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 848) + 112))(*(_QWORD *)(a1 + 904), *(_QWORD *)(a1 + 912), &v92, HIDWORD(v96));
  if ((inserted & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2570, "%s%x", v18, v19, v20, v21, "lhError");
    (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 96))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), 0);
    return inserted;
  }
  v22 = HIDWORD(v96);
  HIDWORD(v96) >>= 5;
  if (v22 <= 0x1F)
  {
    LODWORD(v23) = 0;
    v24 = 1;
LABEL_16:
    v25 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 120))(*(_QWORD *)(a1 + 904), *(_QWORD *)(a1 + 912), (32 * v23));
    if ((v25 & 0x80000000) != 0)
    {
      inserted = v25;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2570, "%s%x", v26, v27, v28, v29, "lhError");
      (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 96))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), 0);
    }
    else
    {
      inserted = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 96))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), (32 * v23));
      if ((inserted & 0x80000000) != 0)
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, "%s%x", v30, v31, v32, v33, "lhError");
    }
    goto LABEL_54;
  }
  v39 = 0;
  v41 = v92;
  v40 = v93;
  v42 = 12;
  while (2)
  {
    v23 = v39;
    if (*(_DWORD *)(v40 + v42) != *(_DWORD *)(a1 + 956))
      *(_DWORD *)(a1 + 960) = 0;
    v43 = v41 + v42;
    v44 = *(_OWORD *)(v40 + v42 - 12);
    *(_OWORD *)(v43 + 4) = *(_OWORD *)(v40 + v42 + 4);
    *(_OWORD *)(v43 - 12) = v44;
    v45 = *(_DWORD *)(v41 + v42) + *(_DWORD *)(a1 + 952);
    *(_DWORD *)v43 = v45;
    if (*(_DWORD *)(v41 + v42 - 12) != 33)
      *(_DWORD *)(v41 + v42) = *(_DWORD *)(a1 + 960) + v45;
    HIDWORD(v46) = *(_DWORD *)(v40 + v42 - 12);
    LODWORD(v46) = HIDWORD(v46) - 8;
    switch((v46 >> 1))
    {
      case 0u:
        *(_DWORD *)(a1 + 956) = *(_DWORD *)(v40 + v42);
        *(_DWORD *)(a1 + 960) += *(_DWORD *)(a1 + 944) * *(_DWORD *)(v40 + v42 + 12) / 0x3E8u;
        goto LABEL_41;
      case 5u:
        *(_DWORD *)(a1 + 1020) = *(_DWORD *)(v40 + v42 + 12);
        *(_DWORD *)(a1 + 1016) = 1;
        goto LABEL_41;
      case 8u:
        *(_DWORD *)(a1 + 1008) = *(_DWORD *)(v40 + v42 + 12);
        *(_DWORD *)(a1 + 1004) = 1;
        goto LABEL_41;
      case 9u:
        v62 = *(_QWORD *)(a1 + 856);
        if (v62)
        {
          (*(void (**)(uint64_t, _QWORD, uint64_t *))(*(_QWORD *)(a1 + 848) + 136))(v62, *(_QWORD *)(a1 + 864), &v96);
          inserted = (*(uint64_t (**)(_QWORD, _QWORD, char *, int *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), (char *)&v95 + 4, &v94);
          v63 = v96 >> 1;
          v64 = HIDWORD(v95) >> 1;
          v40 = v93;
        }
        else
        {
          v63 = 0;
          v64 = 0;
          v94 = 1;
        }
        HIDWORD(v95) = v64;
        LODWORD(v96) = v63;
        v65 = (*(_DWORD *)(a1 + 960) + *(_DWORD *)(v40 + v42));
        if ((inserted & 0x80000000) != 0 || !v94 && v64 + v63 <= v65)
        {
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert audio skipped! u32AudioPos=%d, iAudioPos=%d, cAudio = %d, iAudioPos + cAudio = %d", v19, v20, v21, v65);
LABEL_43:
          v24 = 1;
          if ((inserted & 0x80000000) != 0)
            goto LABEL_54;
LABEL_44:
          if ((_DWORD)v23)
          {
            if ((_DWORD)v23 == 1)
            {
              LODWORD(v23) = 1;
            }
            else
            {
              v47 = 0;
              v48 = 0;
              v49 = v92;
              while (1)
              {
                do
                {
                  v50 = (__int128 *)(v49 + 32 * v47++);
                  v51 = (__int128 *)(v49 + 32 * v47);
                  v52 = v48;
                  if (*((_DWORD *)v50 + 3) > *((_DWORD *)v51 + 3))
                  {
                    v90 = *v50;
                    v53 = v90;
                    v91 = v50[1];
                    v54 = v91;
                    v55 = v51[1];
                    *v50 = *v51;
                    v50[1] = v55;
                    *v51 = v53;
                    v51[1] = v54;
                    v52 = 1;
                    v48 = 1;
                  }
                }
                while (v47 != (_DWORD)v23 - 1);
                if (!v52)
                  break;
                v47 = 0;
                v48 = 0;
              }
            }
          }
          goto LABEL_16;
        }
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert audio NOT skipped! u32AudioPos=%d, iAudioPos=%d, cAudio = %d, iAudioPos + cAudio = %d", v19, v20, v21, v65);
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Before insert audio, I will write audio: u32AudioPos=%d, iAudioPos=%d, u32AudioPos-iAudioPos=%d (%d Bytes))", v66, v67, v68, v65);
        if (*(_QWORD *)(a1 + 856))
        {
          if (v65 > v96)
          {
            inserted = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 128))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880));
            if ((inserted & 0x80000000) != 0)
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2578, "%s%x", v69, v70, v71, v72, "lhError");
          }
        }
        if (v94)
        {
          (*(void (**)(_QWORD, _QWORD, uint64_t *))(*(_QWORD *)(a1 + 848) + 136))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), &v96);
          v76 = v96 >> 1;
          LODWORD(v96) = v96 >> 1;
          if ((inserted & 0x80000000) == 0 && v76 < *(_DWORD *)(v92 + v42))
          {
            *(_QWORD *)&v90 = 0;
            v77 = *(_DWORD *)(v92 + v42) - v76;
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert %u silence samples at %u", v73, v74, v75, v77);
            v78 = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _QWORD))(*(_QWORD *)(a1 + 848) + 112))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), &v90, 2 * v77);
            if ((v78 & 0x80000000) == 0)
              v78 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 120))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), 2 * v77);
            inserted = v78;
          }
        }
        if (log_HasTraceTuningDataSubscriber(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32)))
          log_OutTraceTuningData(*(uint64_t ***)(*(_QWORD *)(a1 + 16) + 32), 312, (uint64_t)"%s%s %s%s", v79, v80, v81, v82, v83, "BEG");
        if ((inserted & 0x80000000) != 0)
          goto LABEL_89;
        v84 = audioins_InsertAudioStart((_QWORD *)a1, *(_QWORD *)(v93 + v42 + 12));
        if ((v84 & 0x80000000) != 0)
          goto LABEL_88;
        inserted = audioins_InsertAudio(a1);
        if ((inserted & 0x80000000) == 0 && !*(_DWORD *)(a1 + 992))
        {
          v84 = audioins_InsertAudioEnd(a1);
LABEL_88:
          inserted = v84;
        }
LABEL_89:
        LODWORD(v23) = v23 + 1;
        if (log_HasTraceTuningDataSubscriber(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32)))
          log_OutTraceTuningData(*(uint64_t ***)(*(_QWORD *)(a1 + 16) + 32), 312, (uint64_t)"%s%u %s%s %s%u", v85, v86, v87, v88, v89, "POSREF");
        v24 = 0;
        *a5 = 2;
        if ((inserted & 0x80000000) == 0)
          goto LABEL_44;
LABEL_54:
        if ((_DWORD)v23 == HIDWORD(v96) && (_DWORD)v95)
          *a5 = 2;
LABEL_58:
        if ((inserted & 0x80000000) == 0)
        {
          if (v24)
          {
            v56 = *(_QWORD *)(a1 + 856);
            if (v56)
            {
              inserted = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, char *))(*(_QWORD *)(a1 + 848) + 128))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), v56, *(_QWORD *)(a1 + 864), 0xFFFFFFFFLL, (char *)&v95 + 4);
              if ((inserted & 0x80000000) != 0)
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2578, "%s%x", v57, v58, v59, v60, "lhError");
            }
          }
        }
        return inserted;
      default:
LABEL_41:
        ++v39;
        v42 += 32;
        if (v23 + 1 < (unint64_t)HIDWORD(v96))
          continue;
        LODWORD(v23) = v23 + 1;
        goto LABEL_43;
    }
  }
}

uint64_t audioins_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  if ((safeh_HandleCheck(a1, a2, 13546, 1056) & 0x80000000) != 0)
    return 2341478408;
  audioins_InsertAudioEnd(a1);
  WSOLA__Initialise(*(_QWORD *)(a1 + 1032));
  v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(_QWORD *)(a1 + 848));
  v4 = *(_QWORD *)(a1 + 920);
  if (v4)
    (*(void (**)(_QWORD, _QWORD))(v4 + 56))(*(_QWORD *)(a1 + 928), *(_QWORD *)(a1 + 936));
  return v3;
}

uint64_t audioins_GetParamU32(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t UInt;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  UInt = paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), a2, a3);
  if ((UInt & 0x80000000) != 0)
  {
    *a3 = a4;
    UInt = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), a2, a4);
    if ((UInt & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2579, "%s%s%s%x", v9, v10, v11, v12, "parameter");
  }
  return UInt;
}

uint64_t audioins_SetDefaultAudioProsodyParameters(uint64_t a1)
{
  unsigned int *v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)(a1 + 1004) = 0;
  *(_QWORD *)(a1 + 1016) = 0;
  v2 = (unsigned int *)(a1 + 1000);
  result = audioins_GetParamU32(a1, (uint64_t)"volume", (unsigned int *)(a1 + 1000), 0x50u);
  if ((result & 0x80000000) == 0)
  {
    result = audioins_GetParamU32(a1, (uint64_t)"audioinsertervolume", v2, *(_DWORD *)(a1 + 1000));
    if ((result & 0x80000000) == 0)
    {
      result = audioins_GetParamU32(a1, (uint64_t)"rate", (unsigned int *)(a1 + 1012), 0x64u);
      if ((result & 0x80000000) == 0)
      {
        result = audioins_GetParamU32(a1, (uint64_t)"audioinserterrate", (unsigned int *)(a1 + 1012), *(_DWORD *)(a1 + 1012));
        if ((result & 0x80000000) == 0)
        {
          v4 = 0;
          result = audioins_GetParamU32(a1, (uint64_t)"audioinsertervolumeadjust", &v4, 1u);
          *(_DWORD *)(a1 + 1024) = v4 != 0;
          if ((result & 0x80000000) == 0)
          {
            v5 = 0;
            result = audioins_GetParamU32(a1, (uint64_t)"audioinserterrateadjust", &v5, 1u);
            *(_DWORD *)(a1 + 1028) = v5 != 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t audioinserter_loc_ParamCheckChange(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;

  *a4 = 1;
  if (!strcmp(__s1, "frequencyhz"))
  {
    result = 2341478417;
    if (!*(_QWORD *)(a1 + 856) && !*(_QWORD *)(a1 + 872))
      return 0;
LABEL_11:
    *a4 = 0;
    return result;
  }
  if (strcmp(__s1, "audioinsertervolume"))
  {
    if (strcmp(__s1, "audioinserterrate") || (atoi(a3) - 401) > 0xFFFFFEA0)
      return 0;
    goto LABEL_10;
  }
  if (atoi(a3) > 0x64)
  {
LABEL_10:
    result = 2341478415;
    goto LABEL_11;
  }
  return 0;
}

uint64_t audioinserter_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (!strcmp(__s1, "frequencyhz"))
  {
    result = 2341478417;
    if (!*(_QWORD *)(a1 + 856) && !*(_QWORD *)(a1 + 872))
    {
      v7 = LH_atou(a3);
      result = 0;
      *(_DWORD *)(a1 + 944) = v7;
    }
  }
  else if (!strcmp(__s1, "audiooutputbufsamples"))
  {
    v8 = LH_atou(a3);
    result = 0;
    if (!v8)
      v8 = 1024;
    *(_DWORD *)(a1 + 948) = v8;
  }
  else if (!strcmp(__s1, "audioinsertervolume"))
  {
    v9 = atoi(a3);
    result = 0;
    *(_DWORD *)(a1 + 1000) = v9;
  }
  else if (!strcmp(__s1, "audioinserterrate"))
  {
    v10 = atoi(a3);
    result = 0;
    *(_DWORD *)(a1 + 1012) = v10;
  }
  else if (!strcmp(__s1, "audioinsertervolumeadjust"))
  {
    v11 = atoi(a3);
    result = 0;
    *(_DWORD *)(a1 + 1024) = v11 != 0;
  }
  else if (!strcmp(__s1, "audioinserterrateadjust"))
  {
    v12 = atoi(a3);
    result = 0;
    *(_DWORD *)(a1 + 1028) = v12 != 0;
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t audioins_InsertAudio(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v24;
  __int16 *v25;
  unsigned int v26;
  unsigned int v27;

  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 1024;
  v2 = *(_DWORD *)(a1 + 948);
  v3 = *(_DWORD *)(a1 + 996);
  if (v2 >= v3)
    v4 = v3;
  else
    v4 = v2;
  if (*(_DWORD *)(a1 + 1028))
  {
    v5 = 1020;
    if (!*(_DWORD *)(a1 + 1016))
      v5 = 1012;
    v6 = *(_DWORD *)(a1 + v5);
    v7 = v2 >= *(_DWORD *)(a1 + 992);
    if (v4 <= 0x400)
    {
      v8 = *(_QWORD *)(a1 + 1048);
    }
    else
    {
      v8 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 1032) + 328), *(_QWORD *)(a1 + 1048), 2 * v4);
      *(_QWORD *)(a1 + 1048) = v8;
    }
    v19 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, unsigned int *, unsigned int *))(*(_QWORD *)(a1 + 920) + 88))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), v4, v8, &v27, &v26);
    if ((v19 & 0x80000000) == 0)
    {
      if (*(_DWORD *)(a1 + 1024))
      {
        v21 = 1008;
        if (!*(_DWORD *)(a1 + 1004))
          v21 = 1000;
        vol_ScaleToLevel(*(__int16 **)(a1 + 1048), v26, *(unsigned __int16 *)(a1 + v21));
      }
      WSOLA__rateChange_bet4_approach(*(_QWORD *)(a1 + 1032), v7, v6, *(__int16 **)(a1 + 1048), v26, *(_WORD **)(a1 + 1040), (int *)&v24, *(_QWORD *)(a1 + 848), *(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880));
      v20 = v24;
      goto LABEL_24;
    }
LABEL_27:
    (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 120))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), 0);
    return v19;
  }
  v9 = (*(uint64_t (**)(_QWORD, _QWORD, __int16 **, _QWORD))(*(_QWORD *)(a1 + 848) + 112))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), &v25, (2 * v4));
  if ((v9 & 0x80000000) != 0)
  {
    v19 = v9;
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_29:
    log_OutPublic(v22, (uint64_t)"AUDIOINSERTER", 2578, "%s%s%s%x", v10, v11, v12, v13, "uri");
    return v19;
  }
  v14 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, __int16 *, unsigned int *, unsigned int *))(*(_QWORD *)(a1 + 920) + 88))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), v4, v25, &v27, &v26);
  if ((v14 & 0x80000000) != 0)
  {
    v19 = v14;
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 1024))
  {
    v18 = 1008;
    if (!*(_DWORD *)(a1 + 1004))
      v18 = 1000;
    vol_ScaleToLevel(v25, v27, *(unsigned __int16 *)(a1 + v18));
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert %u audio samples for %s", v15, v16, v17, 0);
  v19 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 120))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), 2 * v26);
  if ((v19 & 0x80000000) != 0)
  {
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_29;
  }
  v20 = v26;
LABEL_24:
  *(_DWORD *)(a1 + 952) += v20;
  *(_DWORD *)(a1 + 992) -= v27;
  return v19;
}

uint64_t audioins_InsertAudioEnd(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 968);
  if (v2)
  {
    v3 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 920) + 96))(v2, *(_QWORD *)(a1 + 976), 1);
    *(_QWORD *)(a1 + 968) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 976) = v4;
  }
  else
  {
    v3 = 0;
  }
  *(_QWORD *)(a1 + 984) = 0;
  *(_DWORD *)(a1 + 992) = 0;
  return v3;
}

uint64_t audioins_InsertAudioStart(_QWORD *a1, uint64_t a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v6;
  char *v7;
  _QWORD *v8;
  char v9;
  uint64_t v10;
  uint64_t (*v11)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *);
  uint64_t NullHandle;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  unsigned int v23;
  uint64_t v24;

  v4 = 0;
  v24 = 0;
  v5 = a1 + 123;
  v6 = a1 + 124;
  v7 = (char *)a1 + 996;
  v8 = a1 + 121;
  v9 = 1;
  v10 = a2;
  do
  {
    if ((v4 & 1) != 0)
    {
      v11 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *))(a1[115] + 64);
      NullHandle = safeh_GetNullHandle();
      v14 = v11(a1[116], a1[117], a2, 0, NullHandle, v13, &v24);
      if ((v14 & 0x80000000) != 0)
      {
        v21 = v14;
        goto LABEL_9;
      }
      v10 = v24;
    }
    v19 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD *, _QWORD *, char *, _QWORD *))(a1[115] + 80))(a1[116], a1[117], v10, v5, v6, v7, v8);
    v20 = ((v19 & 0x1FFF) == 20) & v9;
    v4 = 1;
    v9 = 0;
  }
  while ((v20 & 1) != 0);
  v21 = v19;
  if ((v19 & 0x80000000) == 0)
    return v21;
LABEL_9:
  log_OutPublic(*(_QWORD *)(a1[2] + 32), (uint64_t)"AUDIOINSERTER", 2561, 0, v15, v16, v17, v18, v23);
  return v21;
}

uint64_t vol_ScaleToLevel(__int16 *a1, unsigned int a2, int a3)
{
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  __int16 v7;

  if (a3 != 80 && a2)
  {
    v3 = aVolScaleFactor_0[a3];
    v4 = a2;
    do
    {
      v5 = *a1 * v3;
      v6 = v5 >> 15;
      if (v5 < -1073709056)
        LOWORD(v6) = -32767;
      if (v5 <= 0x3FFFFFFF)
        v7 = v6;
      else
        v7 = 0x7FFF;
      *a1++ = v7;
      --v4;
    }
    while (v4);
  }
  return 0;
}

uint64_t dsp_interpolatate_init(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  *a1 = 0;
  v6 = dsp_malloc(a2, 0x20u);
  if (!v6)
    return 4294967294;
  v7 = v6;
  result = 0;
  *(_QWORD *)v7 = a2;
  *(_QWORD *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 12) = a3;
  *(_DWORD *)(v7 + 16) = 0;
  *a1 = v7;
  return result;
}

uint64_t dsp_interpolatate_deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if (!*a1)
    return 0;
  *(_DWORD *)(v2 + 16) = 0;
  dsp_free(*(_QWORD *)v2);
  result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_interpolate_set_target_rate(uint64_t result, float a2)
{
  *(float *)(result + 8) = a2;
  return result;
}

uint64_t dsp_interpolate_execute(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 24);
  if (v1)
    return v1();
  else
    return 0xFFFFFFFFLL;
}

uint64_t dsp_interpolate_linear(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int *a6)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  int v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  unsigned int v20;
  BOOL v21;

  v6 = result;
  v7 = 0;
  LODWORD(result) = 0;
  v8 = 0;
  v9 = *(_DWORD *)(v6 + 12);
  *a6 = 0;
  v10 = *(float *)(v6 + 16);
  v11 = *(unsigned int *)(v6 + 12);
  v12 = *(float *)(v6 + 8);
  v13 = v10;
  do
  {
    if ((_DWORD)v11)
    {
      v14 = 0;
      v15 = v11;
      do
      {
        v16 = v10 * (float)*(__int16 *)(a3 + 2 * (v9 + v14));
        v17 = v16 + (float)((float)(1.0 - v10) * (float)*(__int16 *)(a3 + 2 * (v8 + v14)));
        if (v17 >= -32767.0)
          v18 = v16 + (float)((float)(1.0 - v10) * (float)*(__int16 *)(a3 + 2 * (v8 + v14)));
        else
          v18 = -32767.0;
        if (v17 <= 32767.0)
          v19 = v18;
        else
          v19 = 32767.0;
        *(_WORD *)(a2 + 2 * (v7 + v14++)) = (int)v19;
        --v15;
      }
      while (v15);
    }
    result = (result + 1);
    v13 = v13 + v12;
    v20 = v13;
    v10 = v13 - (float)v13;
    v21 = v13 >= (float)(a4 - 1) || (_DWORD)result == a5;
    v8 = v11 * v20;
    v9 = v11 * v20 + v11;
    v7 += v11;
  }
  while (!v21 && a4 - 1 > v20);
  *(float *)(v6 + 16) = v10;
  *a6 = v20;
  return result;
}

uint64_t dsp_interpolate_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  return 0;
}

uint64_t dsp_tempo_changer_init(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v4 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    v9 = dsp_malloc(a2, 0x60u);
    if (v9)
    {
      v10 = v9;
      *(_QWORD *)v9 = a2;
      *(_QWORD *)(v9 + 80) = 0;
      *(_DWORD *)(v9 + 72) = 1;
      *(_DWORD *)(v9 + 8) = a3;
      v11 = (_QWORD *)(v9 + 16);
      *(_DWORD *)(v9 + 32) = a4;
      v12 = signal_fifo_init((uint64_t *)(v9 + 16), a2, a3);
      if ((_DWORD)v12)
      {
        v4 = v12;
      }
      else
      {
        v13 = signal_fifo_init((uint64_t *)(v10 + 24), a2, a3);
        if ((_DWORD)v13)
        {
          v4 = v13;
          v14 = v11;
        }
        else
        {
          v4 = dsp_tempo_changer_set_target_tempo(v10, 1.0);
          if (!(_DWORD)v4)
          {
            *a1 = v10;
            return v4;
          }
          signal_fifo_deinit(v11);
          v14 = (_QWORD *)(v10 + 24);
        }
        signal_fifo_deinit(v14);
      }
      dsp_free(a2);
    }
    else
    {
      return 4294967294;
    }
  }
  return v4;
}

uint64_t dsp_tempo_changer_set_target_tempo(uint64_t a1, float a2)
{
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  void *v9;
  uint64_t result;
  float v11;
  unsigned int v12;

  *(float *)(a1 + 12) = a2;
  *(_QWORD *)(a1 + 36) = 0xF00000028;
  v4 = *(_DWORD *)(a1 + 32);
  v5 = 8 * v4 / 0x3E8u;
  *(_DWORD *)(a1 + 52) = 8;
  *(_DWORD *)(a1 + 56) = v5;
  v6 = 40 * v4 / 0x3E8u;
  v7 = 15 * v4 / 0x3E8u;
  *(_DWORD *)(a1 + 44) = v6;
  *(_DWORD *)(a1 + 48) = v7;
  v8 = 2 * v5;
  if (v6 < 2 * v5)
  {
    *(_DWORD *)(a1 + 44) = v8;
    v6 = 2 * v5;
  }
  if (!*(_QWORD *)(a1 + 80))
  {
    v9 = (void *)dsp_malloc(*(_QWORD *)a1, v8 * *(_DWORD *)(a1 + 8));
    *(_QWORD *)(a1 + 80) = v9;
    if (!v9)
      return 4294967294;
    dsp_memset(v9, 0, (2 * *(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8)));
    *(_DWORD *)(a1 + 72) = 1;
    v5 = *(_DWORD *)(a1 + 56);
    v6 = *(_DWORD *)(a1 + 44);
    v7 = *(_DWORD *)(a1 + 48);
  }
  result = 0;
  v11 = (float)(v6 - v5) * a2;
  *(float *)(a1 + 60) = v11;
  v12 = (v11 + 0.5 + (double)v5);
  if (v6 > v12)
    v12 = v6;
  *(_DWORD *)(a1 + 68) = v12 + v7;
  return result;
}

uint64_t dsp_tempo_changer_deinit(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if (!*a1)
    return 0;
  signal_fifo_deinit(v2 + 2);
  signal_fifo_deinit(v2 + 3);
  if (v2[10])
  {
    dsp_free(*v2);
    v2[10] = 0;
  }
  dsp_free(*v2);
  result = 0;
  *a1 = 0;
  return result;
}

uint64_t wsola_exec(uint64_t a1)
{
  unsigned int v2;
  uint64_t rd_ptr;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  float v7;
  float v8;
  float v9;
  unsigned int v10;
  float v11;
  unsigned int v12;
  float v13;
  unsigned int v14;
  uint64_t result;
  uint64_t wr_ptr;
  uint64_t v17;
  unsigned int v18;
  int v19;
  int v20;
  float v21;
  int v22;
  float v23;
  float v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  float v28;

  v2 = 0;
  do
  {
    if (*(_DWORD *)(a1 + 72))
    {
      *(_DWORD *)(a1 + 72) = 0;
      *(_DWORD *)(a1 + 64) = 0;
      goto LABEL_31;
    }
    rd_ptr = signal_fifo_get_rd_ptr(*(_QWORD *)(a1 + 16));
    if ((*(_DWORD *)(a1 + 48) - 9) > 0xFFFFFFFA)
    {
      v4 = 0;
      v5 = 0;
      v8 = -3.4028e38;
    }
    else
    {
      v4 = 0;
      v5 = 0;
      v6 = 4;
      v7 = -3.4028e38;
      v8 = -3.4028e38;
      do
      {
        v9 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v6), *(__int16 **)(a1 + 80));
        if (v9 > v8)
        {
          v8 = v9;
          v5 = v6;
          v7 = v9;
          v4 = v6;
        }
        if (v9 > v7)
        {
          v7 = v9;
          v4 = v6;
        }
        v6 += 8;
      }
      while (v6 < *(_DWORD *)(a1 + 48) - 4);
      if (v5 > 0xFFFFFFFB)
        goto LABEL_18;
    }
    v10 = v5;
    do
    {
      v11 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v10), *(__int16 **)(a1 + 80));
      if (v11 > v8)
      {
        v8 = v11;
        v5 = v10;
      }
      ++v10;
    }
    while (v10 < v5 + 4);
LABEL_18:
    v12 = v4 + 4;
    if (v4 <= 0xFFFFFFFB)
    {
      do
      {
        v13 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v4), *(__int16 **)(a1 + 80));
        if (v13 > v8)
        {
          v8 = v13;
          v5 = v4;
        }
        ++v4;
      }
      while (v4 < v12);
    }
    v14 = *(_DWORD *)(a1 + 56);
    result = signal_fifo_ensure_free_space(*(_QWORD *)(a1 + 24), v14);
    if ((_DWORD)result)
      return result;
    wr_ptr = signal_fifo_get_wr_ptr(*(_QWORD *)(a1 + 24));
    v17 = signal_fifo_get_rd_ptr(*(_QWORD *)(a1 + 16));
    v18 = *(_DWORD *)(a1 + 56);
    if (v18)
    {
      v19 = 0;
      v20 = 0;
      v21 = 1.0 / (float)v14;
      v22 = *(_DWORD *)(a1 + 8);
      v23 = 0.0;
      v24 = 1.0;
      do
      {
        if (v22)
        {
          v25 = 0;
          v26 = *(_QWORD *)(a1 + 80);
          do
          {
            *(_WORD *)(wr_ptr + 2 * (v19 + v25)) = (int)(float)((float)(v24
                                                                                      * (float)*(__int16 *)(v26 + 2 * (v19 + v25)))
                                                                              + (float)(v23
                                                                                      * (float)*(__int16 *)(v17 + 2 * v22 * v5 + 2 * (v19 + v25))));
            ++v25;
          }
          while (v22 != v25);
        }
        v23 = v21 + v23;
        v24 = v24 - v21;
        ++v20;
        v19 += v22;
      }
      while (v20 != v18);
    }
    result = signal_fifo_push_samples_nodata(*(_QWORD *)(a1 + 24), v18);
    if ((_DWORD)result)
      return result;
    v2 = *(_DWORD *)(a1 + 56) + v5;
LABEL_31:
    v27 = signal_fifo_get_rd_ptr(*(_QWORD *)(a1 + 16));
    result = signal_fifo_push_samples(*(_QWORD *)(a1 + 24), (const void *)(v27 + 2 * *(_DWORD *)(a1 + 8) * v2), *(_DWORD *)(a1 + 44) - 2 * *(_DWORD *)(a1 + 56));
    if ((_DWORD)result)
      return result;
    dsp_memcpy(*(void **)(a1 + 80), (const void *)(v27 + 2 * (*(_DWORD *)(a1 + 44) + v2 - 2 * *(_DWORD *)(a1 + 56)) * *(_DWORD *)(a1 + 8)), (2 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 56)));
    v28 = *(float *)(a1 + 60) + *(float *)(a1 + 64);
    *(float *)(a1 + 64) = v28;
    signal_fifo_pop_samples(*(_DWORD **)(a1 + 16), (int)v28);
    *(float *)(a1 + 64) = *(float *)(a1 + 64) - (float)(int)v28;
  }
  while (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) >= *(_DWORD *)(a1 + 68));
  return 0;
}

uint64_t dsp_tempo_push_samples_from_fifo(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = signal_fifo_move_samples(*(_QWORD *)(a1 + 16), a2);
  if ((result & 0x80000000) == 0)
  {
    if (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) <= *(_DWORD *)(a1 + 68))
      return 0;
    else
      return wsola_exec(a1);
  }
  return result;
}

uint64_t dsp_tempo_reset(uint64_t a1)
{
  uint64_t result;

  result = dsp_tempo_changer_set_target_tempo(a1, 1.0);
  if (!(_DWORD)result)
  {
    result = signal_fifo_clear(*(_QWORD *)(a1 + 16));
    if (!(_DWORD)result)
    {
      result = signal_fifo_clear(*(_QWORD *)(a1 + 24));
      if (!(_DWORD)result)
      {
        if (*(_QWORD *)(a1 + 80))
        {
          dsp_free(*(_QWORD *)a1);
          *(_QWORD *)(a1 + 80) = 0;
        }
        result = 0;
        *(_DWORD *)(a1 + 72) = 1;
      }
    }
  }
  return result;
}

float cross_correlation(uint64_t a1, __int16 *a2, __int16 *a3)
{
  uint64_t v3;
  float v4;
  __int16 *v5;
  uint64_t v6;
  int v7;
  float v8;
  int v9;
  float v10;
  int v11;
  float result;

  v3 = (*(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8));
  if (!(_DWORD)v3)
    goto LABEL_5;
  v4 = 0.0;
  v5 = a3;
  v6 = (*(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8));
  do
  {
    v7 = *v5++;
    v4 = v4 + (float)((float)v7 * (float)v7);
    --v6;
  }
  while (v6);
  if (v4 <= 1.1755e-38)
LABEL_5:
    v4 = 1.0;
  *(float *)(a1 + 88) = v4;
  v8 = 0.0;
  if ((_DWORD)v3)
  {
    do
    {
      v9 = *a2++;
      v10 = (float)v9;
      v11 = *a3++;
      v8 = v8 + (float)(v10 * (float)v11);
      --v3;
    }
    while (v3);
  }
  result = v8 / v4;
  if (result < 0.0)
    return -result;
  return result;
}

uint64_t rateTrans_init(uint64_t **a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;

  v3 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    v7 = dsp_malloc(a2, 0x40u);
    if (v7)
    {
      v8 = (uint64_t *)v7;
      *(_QWORD *)v7 = a2;
      *(_DWORD *)(v7 + 48) = 1;
      v9 = (_QWORD *)(v7 + 8);
      v10 = signal_fifo_init((uint64_t *)(v7 + 8), a2, a3);
      if ((_DWORD)v10)
      {
        v3 = v10;
      }
      else
      {
        v11 = signal_fifo_init(v8 + 2, a2, a3);
        if ((_DWORD)v11)
        {
          v3 = v11;
          v12 = v9;
        }
        else
        {
          v13 = signal_fifo_init(v8 + 3, a2, a3);
          if ((_DWORD)v13)
          {
            v3 = v13;
          }
          else
          {
            v14 = dsp_biquad_init(v8 + 4, a2, a3, 1);
            if ((_DWORD)v14)
            {
              v3 = v14;
            }
            else
            {
              v3 = dsp_interpolatate_init(v8 + 5, a2, a3);
              if (!(_DWORD)v3)
              {
                set_DctBrk(v8[5], (uint64_t)dsp_interpolate_linear);
                *a1 = v8;
                return v3;
              }
              dsp_biquad_deinit(v8 + 4);
            }
            signal_fifo_deinit(v8 + 3);
          }
          signal_fifo_deinit(v9);
          v12 = v8 + 2;
        }
        signal_fifo_deinit(v12);
      }
      dsp_free(a2);
    }
    else
    {
      return 4294967294;
    }
  }
  return v3;
}

uint64_t rateTrans_deinit(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if (!*a1)
    return 0;
  dsp_interpolatate_deinit(v2 + 5);
  dsp_biquad_deinit(v2 + 4);
  signal_fifo_deinit(v2 + 1);
  signal_fifo_deinit(v2 + 2);
  signal_fifo_deinit(v2 + 3);
  dsp_free(*v2);
  result = 0;
  *a1 = 0;
  return result;
}

uint64_t rateTrans_set_rate(uint64_t a1, float a2)
{
  float v3;

  *(float *)(a1 + 52) = a2;
  if (a2 <= 1.0)
  {
    if (a2 < 1.1755e-38)
      return 0xFFFFFFFFLL;
    v3 = a2 * 0.5;
  }
  else
  {
    v3 = 1.0 / (float)(a2 + a2);
  }
  *(float *)(a1 + 56) = v3 * 0.9;
  dsp_interpolate_set_target_rate(*(_QWORD *)(a1 + 40), a2);
  return dsp_biquad_create_low_pass_filter(*(_QWORD *)(a1 + 32), *(float *)(a1 + 56));
}

uint64_t rateTrans_elaborate(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  _DWORD *v4;

  if (!*(_DWORD *)(a1 + 48))
  {
    v3 = *(_QWORD *)(a1 + 24);
    v4 = *(_DWORD **)(a1 + 8);
    goto LABEL_6;
  }
  if (*(float *)(a1 + 52) > 1.0)
  {
    result = dsp_biquad_process_fifos(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 16), *(_DWORD **)(a1 + 8));
    if ((_DWORD)result)
      return result;
    v4 = *(_DWORD **)(a1 + 16);
    v3 = *(_QWORD *)(a1 + 24);
LABEL_6:
    result = rateTrans_do_trans(a1, v3, v4);
    if ((_DWORD)result)
      return result;
    return 0;
  }
  result = rateTrans_do_trans(a1, *(_QWORD *)(a1 + 16), *(_DWORD **)(a1 + 8));
  if (!(_DWORD)result)
  {
    result = dsp_biquad_process_fifos(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 24), *(_DWORD **)(a1 + 16));
    if (!(_DWORD)result)
      return 0;
  }
  return result;
}

uint64_t rateTrans_push_samples_from_fifo(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = signal_fifo_move_samples(*(_QWORD *)(a1 + 8), a2);
  if ((result & 0x80000000) == 0)
    return rateTrans_elaborate(a1);
  return result;
}

uint64_t rateTrans_push_samples_to_fifo(uint64_t a1, uint64_t a2)
{
  return signal_fifo_move_samples(a2, *(_QWORD *)(a1 + 24));
}

uint64_t rateTrans_reset(uint64_t a1)
{
  uint64_t result;

  *(_DWORD *)(a1 + 48) = 1;
  result = dsp_interpolate_reset(*(_QWORD *)(a1 + 40));
  if (!(_DWORD)result)
  {
    dsp_biquad_flush(*(_QWORD *)(a1 + 32));
    result = signal_fifo_clear(*(_QWORD *)(a1 + 8));
    if (!(_DWORD)result)
    {
      result = signal_fifo_clear(*(_QWORD *)(a1 + 16));
      if (!(_DWORD)result)
        return signal_fifo_clear(*(_QWORD *)(a1 + 24));
    }
  }
  return result;
}

uint64_t rateTrans_do_trans(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int num_unread_samples;
  uint64_t result;
  uint64_t v8;
  int v9;
  unsigned int v10;

  num_unread_samples = signal_fifo_get_num_unread_samples(a3);
  if (num_unread_samples < 2)
    return 0;
  v8 = (int)((float)((float)num_unread_samples / *(float *)(a1 + 52)) + 1.0);
  result = signal_fifo_ensure_free_space(a2, v8);
  if (!(_DWORD)result)
  {
    signal_fifo_get_rd_ptr((uint64_t)a3);
    signal_fifo_get_wr_ptr(a2);
    v9 = dsp_interpolate_execute(*(_QWORD *)(a1 + 40));
    if (v9 <= (int)v8)
    {
      v10 = v9;
      signal_fifo_pop_samples(a3, 0);
      return signal_fifo_push_samples_nodata(a2, v10);
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t dsp_malloc(uint64_t a1, unsigned int a2)
{
  return heap_Alloc(a1, a2);
}

void *dsp_memcpy(void *a1, const void *a2, size_t __n)
{
  return memcpy(a1, a2, __n);
}

void *dsp_memset(void *a1, int a2, size_t __len)
{
  return memset(a1, a2, __len);
}

void *dsp_memmove_samples(void *a1, const void *a2, unsigned int a3)
{
  return memmove(a1, a2, 2 * a3);
}

uint64_t dsp_timbre_init(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;

  v4 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    v9 = (_QWORD *)dsp_malloc(a2, 0x50u);
    if (v9)
    {
      v10 = (uint64_t)v9;
      *v9 = a2;
      v11 = v9 + 7;
      v12 = signal_fifo_init(v9 + 7, a2, a3);
      if ((_DWORD)v12)
      {
        v4 = v12;
      }
      else
      {
        v13 = signal_fifo_init((uint64_t *)(v10 + 48), a2, a3);
        if ((_DWORD)v13)
        {
          v4 = v13;
          v14 = v11;
        }
        else
        {
          v15 = dsp_tempo_changer_init((uint64_t *)(v10 + 64), a2, a3, a4);
          if (!(_DWORD)v15)
          {
            v4 = rateTrans_init((uint64_t **)(v10 + 72), a2, a3);
            if (!(_DWORD)v4)
            {
              *(_DWORD *)(v10 + 40) = 0;
              dsp_timbre_reset(v10);
              *a1 = v10;
              return v4;
            }
            signal_fifo_deinit(v11);
            signal_fifo_deinit((_QWORD *)(v10 + 48));
            dsp_tempo_changer_deinit((_QWORD *)(v10 + 64));
            goto LABEL_12;
          }
          v4 = v15;
          signal_fifo_deinit(v11);
          v14 = (_QWORD *)(v10 + 48);
        }
        signal_fifo_deinit(v14);
      }
LABEL_12:
      dsp_free(a2);
      return v4;
    }
    return 4294967294;
  }
  return v4;
}

uint64_t dsp_timbre_reset(uint64_t a1)
{
  uint64_t result;

  result = dsp_tempo_reset(*(_QWORD *)(a1 + 64));
  if (!(_DWORD)result)
  {
    result = rateTrans_reset(*(_QWORD *)(a1 + 72));
    if (!(_DWORD)result)
    {
      *(_QWORD *)(a1 + 8) = 0x3F80000000000000;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 1065353216;
      *(_QWORD *)(a1 + 40) = 0;
      result = signal_fifo_clear(*(_QWORD *)(a1 + 48));
      if (!(_DWORD)result)
      {
        result = signal_fifo_clear(*(_QWORD *)(a1 + 56));
        if (!(_DWORD)result)
        {
          signal_fifo_set_backlog_size(*(_QWORD *)(a1 + 48), 0);
          return dsp_timbre_recalculate(a1);
        }
      }
    }
  }
  return result;
}

uint64_t dsp_timbre_deinit(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if (!*a1)
    return 0;
  signal_fifo_deinit(v2 + 7);
  signal_fifo_deinit(v2 + 6);
  dsp_tempo_changer_deinit(v2 + 8);
  rateTrans_deinit(v2 + 9);
  dsp_free(*v2);
  result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_timbre_set_target_timbre(uint64_t a1, float a2)
{
  *(float *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 20) = a2 != 0.0;
  *(_DWORD *)(a1 + 24) = 1;
  return 0;
}

uint64_t dsp_timbre_push_samples(uint64_t a1, __int16 *a2, int a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float v9;
  __int16 *v10;
  int v11;
  uint64_t result;
  int v13;
  int v14;
  uint64_t v15;
  const void *v16;
  unsigned int v17;
  int v18;
  int v19;

  LODWORD(v3) = a3;
  v6 = LDOString_BorrowAllocator(*(_QWORD *)(a1 + 64));
  if (!v6)
    return 4294967293;
  v7 = v6;
  if ((_DWORD)v3)
  {
    v8 = v3;
    v9 = 0.0;
    v10 = a2;
    do
    {
      v11 = *v10++;
      v9 = v9 + (float)v11;
      --v8;
    }
    while (v8);
  }
  else
  {
    v9 = 0.0;
  }
  *(float *)(a1 + 40) = v9 / (float)v3;
  v13 = *(_DWORD *)(a1 + 44);
  if (v13 == 3)
  {
    if (!*(_DWORD *)(a1 + 24))
    {
LABEL_20:
      result = signal_fifo_push_samples(*(_QWORD *)(a1 + 48), a2, v3);
      if (!(_DWORD)result)
      {
        result = dsp_tempo_push_samples_from_fifo(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 48));
        if (!(_DWORD)result)
        {
          result = rateTrans_push_samples_from_fifo(*(_QWORD *)(a1 + 72), v7);
          if (!(_DWORD)result)
          {
            result = rateTrans_push_samples_to_fifo(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 56));
            if ((result & 0x80000000) == 0)
              return 0;
          }
        }
      }
      return result;
    }
    *(_DWORD *)(a1 + 24) = 0;
    v13 = 4;
  }
  else
  {
    if (v13)
      goto LABEL_16;
    if (!*(_DWORD *)(a1 + 24) || (v14 = *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) = 0, !v14))
    {
LABEL_17:
      v15 = *(_QWORD *)(a1 + 56);
      v16 = a2;
      v17 = v3;
      goto LABEL_18;
    }
    v13 = 1;
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = v13;
LABEL_16:
  switch(v13)
  {
    case 0:
      goto LABEL_17;
    case 1:
      signal_fifo_set_backlog_size(*(_QWORD *)(a1 + 48), 0);
      result = dsp_tempo_push_samples_from_fifo(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 48));
      if ((_DWORD)result)
        return result;
      result = rateTrans_push_samples_from_fifo(*(_QWORD *)(a1 + 72), v7);
      if ((_DWORD)result)
        return result;
      result = rateTrans_push_samples_to_fifo(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 56));
      if ((_DWORD)result)
        return result;
      *(_DWORD *)(a1 + 44) = 2;
LABEL_29:
      if (!(_DWORD)v3)
        return 0;
      v3 = v3;
      while (2)
      {
        v18 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 28) = v18 + 1;
        if (*(float *)(a1 + 40) < 3.0 || v18 >= 2047)
          goto LABEL_50;
        result = signal_fifo_push_samples(*(_QWORD *)(a1 + 48), a2, 1u);
        if (!(_DWORD)result)
        {
          result = dsp_tempo_push_samples_from_fifo(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 48));
          if (!(_DWORD)result)
          {
            result = rateTrans_push_samples_from_fifo(*(_QWORD *)(a1 + 72), v7);
            if (!(_DWORD)result)
            {
              result = rateTrans_push_samples_to_fifo(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 56));
              if ((result & 0x80000000) == 0)
              {
                ++a2;
                if (!--v3)
                  return 0;
                continue;
              }
            }
          }
        }
        return result;
      }
    case 2:
      goto LABEL_29;
    case 3:
      goto LABEL_20;
    case 4:
      if (!(_DWORD)v3)
        return 0;
      v3 = v3;
      break;
    default:
      return 0;
  }
  while (1)
  {
    v19 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = v19 + 1;
    if (*(float *)(a1 + 40) < 3.0 || v19 >= 2047)
      break;
    result = signal_fifo_push_samples(*(_QWORD *)(a1 + 48), a2, 1u);
    if ((_DWORD)result)
      return result;
    result = dsp_tempo_push_samples_from_fifo(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 48));
    if ((_DWORD)result)
      return result;
    result = rateTrans_push_samples_from_fifo(*(_QWORD *)(a1 + 72), v7);
    if ((_DWORD)result)
      return result;
    result = rateTrans_push_samples_to_fifo(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 56));
    if ((result & 0x80000000) != 0)
      return result;
    ++a2;
    if (!--v3)
      return 0;
  }
LABEL_50:
  result = dsp_timbre_recalculate(a1);
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a1 + 44) = 3;
    v15 = *(_QWORD *)(a1 + 48);
    v16 = a2;
    v17 = v3;
LABEL_18:
    result = signal_fifo_push_samples(v15, v16, v17);
    if ((_DWORD)result)
      return result;
    return 0;
  }
  return result;
}

uint64_t dsp_timbre_recalculate(uint64_t a1)
{
  float v2;
  float v3;
  uint64_t result;

  v2 = 1.1755e-38;
  if ((float)((float)(*(float *)(a1 + 8) / 100.0) + 1.0) >= 1.1755e-38)
    v2 = (float)(*(float *)(a1 + 8) / 100.0) + 1.0;
  v3 = (float)(*(float *)(a1 + 16) + -1.0) + v2;
  *(float *)(a1 + 32) = (float)(*(float *)(a1 + 12) + -1.0) + (float)(1.0 / v2);
  *(float *)(a1 + 36) = v3;
  result = rateTrans_set_rate(*(_QWORD *)(a1 + 72), v3);
  if (!(_DWORD)result)
    return dsp_tempo_changer_set_target_tempo(*(_QWORD *)(a1 + 64), *(float *)(a1 + 32));
  return result;
}

uint64_t dsp_timbre_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  return signal_fifo_get_samples(*(_QWORD *)(a1 + 56), a2, a3);
}

uint64_t dsp_timbre_flush(uint64_t a1)
{
  signal_fifo_set_backlog_size(*(_QWORD *)(a1 + 48), 0);
  return 0;
}

uint64_t dspeffects_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2360352769;
  result = 0;
  *a2 = &IDspEffects;
  return result;
}

uint64_t dspeffects_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t Object;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t ParamU32;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t *v51;
  _QWORD v52[3];

  v5 = 2360352778;
  v50 = 0;
  v51 = 0;
  if (!a5)
    return 2360352775;
  inited = InitRsrcFunction(a3, a4, &v51);
  if ((inited & 0x80000000) != 0)
    return inited;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  log_OutText(v51[4], (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Entering dspeffects_ObjOpen", v10, v11, v12, v48);
  v13 = heap_Calloc((_QWORD *)v51[1], 1, 992);
  if (v13)
  {
    v18 = v13;
    *(_QWORD *)(v13 + 960) = 0x6400000000;
    v19 = heap_Alloc(v51[1], 256);
    *(_QWORD *)(v18 + 952) = v19;
    v20 = v51;
    if (v19)
    {
      *(_QWORD *)(v18 + 8) = a4;
      *(_QWORD *)(v18 + 16) = v20;
      *(_QWORD *)v18 = a3;
      Object = objc_GetObject(v51[6], (uint64_t)"SYNTHSTREAM", &v50);
      if ((Object & 0x80000000) != 0)
      {
        v32 = 2574;
        v33 = v51;
        v5 = Object;
        goto LABEL_22;
      }
      *(_QWORD *)(v18 + 848) = *(_QWORD *)(v50 + 8);
      if ((objc_GetObject(v51[6], (uint64_t)"AUDIOFETCHER", &v50) & 0x80000000) == 0)
      {
        v30 = v50;
        if (*(_BYTE *)v50 == 1)
        {
          v31 = *(_QWORD *)(v50 + 8);
          if (v31)
          {
            *(_QWORD *)(v18 + 920) = v31;
            *(_OWORD *)(v18 + 928) = *(_OWORD *)(v30 + 16);
            goto LABEL_17;
          }
        }
        objc_ReleaseObject(v51[6], (uint64_t)"AUDIOFETCHER");
      }
      log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2560, 0, v26, v27, v28, v29, v49);
LABEL_17:
      ParamU32 = dspeffects_GetParamU32(v18, (uint64_t)"frequencyhz", (unsigned int *)(v18 + 980), 0x1F40u);
      if ((ParamU32 & 0x80000000) != 0
        || (ParamU32 = dspeffects_GetParamS32(v18, (int *)(v18 + 976)), (ParamU32 & 0x80000000) != 0))
      {
        v5 = ParamU32;
        goto LABEL_24;
      }
      v39 = dspeffects_GetParamU32(v18, (uint64_t)"timbre", (unsigned int *)(v18 + 968), 0x64u);
      v40 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(v18 + 976), *(_DWORD *)(v18 + 968));
      *(_DWORD *)(v18 + 968) = v40;
      *(_DWORD *)(v18 + 972) = v40;
      if ((v39 & 0x80000000) != 0)
      {
        v5 = v39;
        goto LABEL_24;
      }
      v41 = dsp_timbre_init((uint64_t *)(v18 + 944), v51[1], 1, *(_DWORD *)(v18 + 980));
      v33 = v51;
      if (!v41)
      {
        v44 = 0;
        do
        {
          v45 = v33[5];
          v46 = off_1EA94A6F0[v44];
          v52[0] = v18;
          v52[1] = dspeffects_loc_ParamCheckChange;
          v52[2] = dspeffects_loc_ParamLearnChange;
          v47 = paramc_ListenerAdd(v45, v46, v52);
          v5 = v47;
          if (v44 > 1)
            break;
          ++v44;
        }
        while ((v47 & 0x80000000) == 0);
        if ((v47 & 0x80000000) == 0)
        {
          v42 = 55546;
          goto LABEL_25;
        }
LABEL_24:
        log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2580, "%s%x", v35, v36, v37, v38, "lhError");
        *(_QWORD *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 55546;
        dspeffects_ObjClose((_QWORD *)v18, *(_QWORD *)(a5 + 8));
        v18 = 0;
        v42 = 0;
LABEL_25:
        *(_QWORD *)a5 = v18;
        *(_DWORD *)(a5 + 8) = v42;
        log_OutText(v51[4], (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Leaving dspeffects_ObjOpen: %x", v36, v37, v38, v5);
        return v5;
      }
      v32 = 2577;
LABEL_22:
      log_OutPublic(v33[4], (uint64_t)"DSPEFFECTS", v32, 0, v22, v23, v24, v25, v49);
      goto LABEL_24;
    }
    heap_Free((_QWORD *)v51[1], v18);
  }
  log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2577, 0, v14, v15, v16, v17, v49);
  return v5;
}

uint64_t dspeffects_ObjClose(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  __int128 v21;
  uint64_t (*v22)(uint64_t, char *, const char *);

  if ((safeh_HandleCheck((uint64_t)a1, a2, 55546, 992) & 0x80000000) != 0)
    return 2360352776;
  v6 = a1[2];
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Entering dspeffects_ObjClose", v3, v4, v5, v20);
  dsp_timbre_deinit(a1 + 118);
  v7 = 0;
  do
  {
    v8 = *(_QWORD *)(v6 + 40);
    v9 = off_1EA94A6F0[v7];
    *(_QWORD *)&v21 = a1;
    *((_QWORD *)&v21 + 1) = dspeffects_loc_ParamCheckChange;
    v22 = dspeffects_loc_ParamLearnChange;
    v10 = paramc_ListenerRemove(v8, v9, &v21);
    v11 = v10;
    if (v7 > 1)
      break;
    ++v7;
  }
  while ((v10 & 0x80000000) == 0);
  if (a1[106])
  {
    v12 = objc_ReleaseObject(*(_QWORD *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if (v12 >= 0 || (int)v11 <= -1)
      v11 = v11;
    else
      v11 = v12;
  }
  if (a1[115])
  {
    v14 = objc_ReleaseObject(*(_QWORD *)(v6 + 48), (uint64_t)"AUDIOFETCHER");
    if (v14 >= 0 || (int)v11 <= -1)
      v11 = v11;
    else
      v11 = v14;
  }
  heap_Free(*(_QWORD **)(v6 + 8), a1[119]);
  heap_Free(*(_QWORD **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Leaving dspEffects_ObjClose: %x", v16, v17, v18, v11);
  return v11;
}

uint64_t dspeffects_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t ParamU32;
  int v11;
  char v13[48];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v7 = 2360352776;
  v8 = safeh_HandleCheck(a1, a2, 55546, 992);
  if ((v8 & 0x80000000) == 0)
  {
    v9 = v8;
    synstrmaux_InitStreamOpener(a1 + 24, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS");
    if (*(_QWORD *)(a1 + 920))
    {
      *(_DWORD *)(a1 + 960) = 0;
      if (!dsp_timbre_reset(*(_QWORD *)(a1 + 944)))
      {
        ParamU32 = dspeffects_GetParamU32(a1, (uint64_t)"frequencyhz", (unsigned int *)(a1 + 980), 0x1F40u);
        if ((ParamU32 & 0x80000000) != 0
          || (ParamU32 = dspeffects_GetParamS32(a1, (int *)(a1 + 976)), (ParamU32 & 0x80000000) != 0))
        {
          v7 = ParamU32;
        }
        else
        {
          dspeffects_GetParamU32(a1, (uint64_t)"timbre", (unsigned int *)(a1 + 968), 0x64u);
          v11 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 976), *(_DWORD *)(a1 + 968));
          *(_DWORD *)(a1 + 968) = v11;
          *(_DWORD *)(a1 + 972) = v11;
          if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 980), v13, 0x30uLL) > 0x2F)
            return 9;
          synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)v13, 1, a1 + 856);
          synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
            0,
            a1 + 888);
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)v13, a1 + 872);
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
            a1 + 904);
          v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 24), *(_QWORD *)(a1 + 848), a3, a4);
          dsp_timbre_set_target_timbre(*(_QWORD *)(a1 + 944), (float)*(unsigned int *)(a1 + 968) + -100.0);
          *(_DWORD *)(a1 + 984) = 0;
          if ((v7 & 0x80000000) == 0)
            return v7;
        }
        synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(_QWORD *)(a1 + 848));
        return v7;
      }
      return 2360352778;
    }
    else
    {
      return v9;
    }
  }
  return v7;
}

uint64_t dspeffects_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _OWORD *v31;
  uint64_t v32;
  __int128 v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  int samples;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;

  v81 = 0;
  v80 = 0;
  v79 = 0;
  v7 = safeh_HandleCheck(a1, a2, 55546, 992);
  if ((v7 & 0x80000000) != 0)
    return 2360352776;
  *(_DWORD *)(a1 + 988) = 1;
  *a5 = 1;
  v8 = *(_DWORD *)(a1 + 960);
  if (v8 == 2)
  {
    result = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 24), *(_QWORD *)(a1 + 848));
    *(_DWORD *)(a1 + 960) = 3;
    return result;
  }
  if (v8 == 1)
    goto LABEL_6;
  v9 = v7;
  if (!v8)
  {
    *(_DWORD *)(a1 + 960) = 1;
LABEL_6:
    if (((*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), (char *)&v80 + 4, &v80) & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, "%s%x", v10, v11, v12, v13, "lhError");
    }
    else if (((*(uint64_t (**)(_QWORD, _QWORD, unsigned int *, int *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), &v81, &v79) & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, "%s%x", v14, v15, v16, v17, "lhError");
    }
    v84 = 0;
    v85 = 0;
    v83 = 0;
    v82 = 0;
    v9 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 848) + 88))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), &v85, (char *)&v83 + 4);
    if ((v9 & 0x80000000) != 0)
    {
      HIDWORD(v83) = 0;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, "%s%x", v19, v20, v21, v22, "lhError");
    }
    else if (HIDWORD(v83))
    {
      v27 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *))(*(_QWORD *)(a1 + 848) + 112))(*(_QWORD *)(a1 + 904), *(_QWORD *)(a1 + 912), &v84);
      if ((v27 & 0x80000000) != 0)
      {
        HIDWORD(v83) = 0;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2570, "%s%x", v23, v24, v25, v26, "lhError");
      }
      else
      {
        v28 = HIDWORD(v83);
        if (HIDWORD(v83) >= 0x20)
        {
          v29 = 0;
          v30 = (unint64_t)HIDWORD(v83) >> 5;
          do
          {
            v31 = (_OWORD *)(v84 + 32 * v29);
            v32 = v85 + 32 * v29;
            v33 = *(_OWORD *)(v32 + 16);
            *v31 = *(_OWORD *)v32;
            v31[1] = v33;
            if (*(_DWORD *)v32 == 17)
            {
              v34 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 976), *(_DWORD *)(v32 + 24));
              *(_DWORD *)(a1 + 968) = v34;
              v35 = v85 + 32 * v29;
              *(_DWORD *)(a1 + 964) = *(_DWORD *)(v35 + 24);
              if (*(_DWORD *)(a1 + 972) != v34)
              {
                v36 = *(_DWORD *)(v35 + 12);
                v86 = 0;
                v87 = 0;
                if (v36)
                {
                  (*(void (**)(_QWORD, _QWORD, uint64_t *))(*(_QWORD *)(a1 + 848) + 136))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), &v87);
                  v37 = (*(uint64_t (**)(_QWORD, _QWORD, char *, char *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), (char *)&v87 + 4, (char *)&v86 + 4);
                  if (v36 > v87 >> 1)
                  {
                    v38 = v36 - (v87 >> 1);
                    v39 = v36 >= v87 >> 1 ? v36 - (v87 >> 1) : 0;
                    *(_DWORD *)(a1 + 984) -= v39;
                    if (v38)
                    {
                      while (1)
                      {
                        v40 = v38 >= 0x80 ? 128 : v38;
                        v37 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t *))(*(_QWORD *)(a1 + 848) + 80))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), *(_QWORD *)(a1 + 952), (2 * v40), &v86);
                        if ((v37 & 0x80000000) != 0)
                          break;
                        if (!(_DWORD)v86)
                          goto LABEL_40;
                        if (dsp_timbre_push_samples(*(_QWORD *)(a1 + 944), *(__int16 **)(a1 + 952), v86 >> 1))return 2360352778;
                        v45 = v86;
                        do
                        {
                          samples = dsp_timbre_get_samples(*(_QWORD *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
                          LODWORD(v86) = samples;
                          if (!samples)
                            break;
                          v37 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 104))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), *(_QWORD *)(a1 + 952), (2 * samples));
                          if ((v37 & 0x80000000) != 0)
                          {
                            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v47, v48, v49, v50, "lhError");
                            break;
                          }
                        }
                        while ((_DWORD)v86);
                        v38 -= v45 >> 1;
                        if (!v38)
                          goto LABEL_40;
                      }
                      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v41, v42, v43, v44, "lhError");
                    }
                  }
                }
                else
                {
                  v37 = 0;
                }
LABEL_40:
                v51 = *(_DWORD *)(a1 + 968);
                *(_DWORD *)(a1 + 972) = v51;
                if (dsp_timbre_set_target_timbre(*(_QWORD *)(a1 + 944), (float)v51 + -100.0))
                  return 2360352778;
                if ((v37 & 0x80000000) != 0)
                  return v37;
                *(_DWORD *)(a1 + 988) = 0;
                v27 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, int *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), &v83, &v82);
                if ((v27 & 0x80000000) != 0)
                  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, "%s%x", v52, v53, v54, v55, "lhError");
              }
            }
            ++v29;
          }
          while (v29 != v30);
          v28 = HIDWORD(v83);
        }
        (*(void (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 848) + 120))(*(_QWORD *)(a1 + 904), *(_QWORD *)(a1 + 912), v28);
      }
      (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 96))(*(_QWORD *)(a1 + 888), *(_QWORD *)(a1 + 896), HIDWORD(v83));
      v9 = v27;
    }
    v56 = *(_DWORD *)(a1 + 968);
    if (*(_DWORD *)(a1 + 972) == v56
      || (*(_DWORD *)(a1 + 972) = v56,
          !dsp_timbre_set_target_timbre(*(_QWORD *)(a1 + 944), (float)v56 + -100.0)))
    {
      if ((v9 & 0x80000000) == 0)
      {
        if (((*(uint64_t (**)(_QWORD, _QWORD, unsigned int *, int *))(*(_QWORD *)(a1 + 848) + 144))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), &v81, &v79) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, "%s%x", v57, v58, v59, v60, "lhError");
        v61 = v81;
        if (v81)
        {
          do
          {
            LODWORD(v85) = 0;
            if (v61 >= 0x80)
              v62 = 128;
            else
              v62 = v61;
            v9 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 848) + 80))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), *(_QWORD *)(a1 + 952), v62, &v85);
            if ((v9 & 0x80000000) != 0)
            {
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v63, v64, v65, v66, "lhError");
              goto LABEL_81;
            }
            if (dsp_timbre_push_samples(*(_QWORD *)(a1 + 944), *(__int16 **)(a1 + 952), v85 >> 1))
            {
              v9 = 2360352778;
              goto LABEL_81;
            }
            v71 = v85;
            if ((int)v85 >= 0)
              v72 = v85;
            else
              v72 = v85 + 1;
            *(_DWORD *)(a1 + 984) -= v72 >> 1;
            while (1)
            {
              v73 = dsp_timbre_get_samples(*(_QWORD *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
              LODWORD(v85) = v73;
              if (v73 < 1)
                break;
              *(_DWORD *)(a1 + 988) = 0;
              *(_DWORD *)(a1 + 984) += v73;
              v9 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 104))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), *(_QWORD *)(a1 + 952), (2 * v73));
              if ((v9 & 0x80000000) != 0)
              {
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v67, v68, v69, v70, "lhError");
                goto LABEL_75;
              }
              if ((int)v85 <= 0)
                goto LABEL_75;
            }
            if (*(_DWORD *)(a1 + 988))
              *a5 = 0;
LABEL_75:
            v61 -= v71;
          }
          while (v61);
          if ((v9 & 0x80000000) == 0)
            goto LABEL_82;
LABEL_81:
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, "%s%x", v67, v68, v69, v70, "lhError");
        }
        else
        {
          v9 = 0;
        }
LABEL_82:
        if ((v9 & 0x80000000) == 0 && (_DWORD)v80 && v79 && *(_DWORD *)(a1 + 960) == 1)
        {
          v9 = 2360352778;
          if (!dsp_timbre_flush(*(_QWORD *)(a1 + 944)))
          {
            v74 = dsp_timbre_get_samples(*(_QWORD *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
            if (v74)
            {
              while (1)
              {
                v9 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 848) + 104))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), *(_QWORD *)(a1 + 952), (2 * v74));
                if ((v9 & 0x80000000) != 0)
                  break;
                v74 = dsp_timbre_get_samples(*(_QWORD *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
                if (!v74)
                  goto LABEL_95;
              }
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v75, v76, v77, v78, "lhError");
            }
            else
            {
              v9 = 0;
LABEL_95:
              *(_DWORD *)(a1 + 960) = 2;
              *a5 = 2;
            }
          }
        }
        else if (!v81)
        {
          *a5 = 0;
        }
      }
    }
    else
    {
      return 2360352778;
    }
  }
  return v9;
}

uint64_t dspeffects_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  if ((safeh_HandleCheck(a1, a2, 55546, 992) & 0x80000000) != 0)
    return 2360352776;
  v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(_QWORD *)(a1 + 848));
  v4 = *(_QWORD *)(a1 + 920);
  if (v4)
    (*(void (**)(_QWORD, _QWORD))(v4 + 56))(*(_QWORD *)(a1 + 928), *(_QWORD *)(a1 + 936));
  return v3;
}

uint64_t dspeffects_GetParamU32(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t UInt;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  UInt = paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), a2, a3);
  if ((UInt & 0x80000000) != 0)
  {
    *a3 = a4;
    UInt = paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), a2, a4);
    if ((UInt & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2579, "%s%s%s%x", v9, v10, v11, v12, "parameter");
  }
  return UInt;
}

uint64_t dspeffects_GetParamS32(uint64_t a1, int *a2)
{
  uint64_t Int;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"timbre_baseline", a2);
  if ((Int & 0x80000000) != 0)
  {
    *a2 = 100;
    Int = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"timbre_baseline", 0x64u);
    if ((Int & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2579, "%s%s%s%x", v5, v6, v7, v8, "parameter");
  }
  return Int;
}

uint64_t dspeffects_loc_ParamCheckChange(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;

  *a4 = 1;
  if (!strcmp(__s1, "frequencyhz"))
  {
    result = 2360352785;
    if (!*(_QWORD *)(a1 + 856) && !*(_QWORD *)(a1 + 872))
      return 0;
LABEL_11:
    *a4 = 0;
    return result;
  }
  if (strcmp(__s1, "timbre"))
  {
    if (strcmp(__s1, "timbre_baseline") || (atoi(a3) - 201) > 0xFFFFFF68)
      return 0;
    goto LABEL_10;
  }
  if ((atoi(a3) - 201) < 0xFFFFFF69)
  {
LABEL_10:
    result = 2360352783;
    goto LABEL_11;
  }
  return 0;
}

uint64_t dspeffects_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;

  if (!strcmp(__s1, "frequencyhz"))
  {
    v6 = 2360352785;
    if (!*(_QWORD *)(a1 + 856) && !*(_QWORD *)(a1 + 872))
    {
      v6 = 0;
      *(_DWORD *)(a1 + 980) = LH_atou(a3);
    }
  }
  else
  {
    v6 = 0;
  }
  if (!strcmp(__s1, "timbre_baseline"))
  {
    v7 = LH_atoi(a3);
    *(_DWORD *)(a1 + 976) = v7;
    *(_DWORD *)(a1 + 968) = MapProsodyValue_Scaling(50, 100, 200, v7, *(_DWORD *)(a1 + 964));
  }
  if (!strcmp(__s1, "timbre"))
  {
    *(_DWORD *)(a1 + 964) = atoi(a3);
    v8 = *(_DWORD *)(a1 + 976);
    v9 = atoi(a3);
    *(_DWORD *)(a1 + 968) = MapProsodyValue_Scaling(50, 100, 200, v8, v9);
  }
  return v6;
}

uint64_t signal_fifo_init(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;

  v3 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    v7 = dsp_malloc(a2, 0x28u);
    if (v7)
    {
      v8 = v7;
      *(_QWORD *)v7 = a2;
      *(_DWORD *)(v7 + 8) = a3;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 0;
      *(_QWORD *)(v7 + 16) = 0;
      v3 = check_minimum_space((_QWORD *)v7, 0x800u / (unsigned __int16)a3);
      if ((_DWORD)v3)
        dsp_free(a2);
      else
        *a1 = v8;
    }
    else
    {
      return 4294967294;
    }
  }
  return v3;
}

uint64_t check_minimum_space(_QWORD *a1, unsigned int a2)
{
  int v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t result;

  v4 = *((_DWORD *)a1 + 7);
  v3 = *((_DWORD *)a1 + 8);
  v5 = *((_DWORD *)a1 + 6);
  v6 = v4 - v3;
  v7 = v4 - v3 + a2;
  if (v5 >= v7)
  {
    if (v5 - v4 >= a2)
    {
      return 0;
    }
    else
    {
      dsp_memmove_samples((void *)a1[2], (const void *)(a1[2] + 2 * (*((_DWORD *)a1 + 2) * v3)), *((_DWORD *)a1 + 2) * v6);
      result = 0;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 8) = 0;
    }
  }
  else
  {
    if (v7 <= v5 + 2048)
      v8 = v5 + 2048;
    else
      v8 = v4 - v3 + a2;
    v9 = v5 + 2048 + ((v8 + ~v5) & 0xFFFFF800);
    *((_DWORD *)a1 + 6) = v9;
    v10 = (void *)dsp_malloc(*a1, 2 * v9 * *((_DWORD *)a1 + 2));
    if (v10)
    {
      v11 = v10;
      v12 = a1[2];
      if (v12)
      {
        if (*((_DWORD *)a1 + 6))
        {
          dsp_memcpy(v10, (const void *)(v12 + 2 * (*((_DWORD *)a1 + 2) * *((_DWORD *)a1 + 8))), (2 * v6 * *((_DWORD *)a1 + 2)));
          dsp_free(*a1);
        }
      }
      result = 0;
      a1[2] = v11;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 8) = 0;
      *((_DWORD *)a1 + 6) = v9;
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

uint64_t signal_fifo_deinit(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)*a1;
  if (!*a1)
    return 0;
  if (v2[2])
  {
    dsp_free(*v2);
    v2[2] = 0;
    *((_DWORD *)v2 + 6) = 0;
  }
  dsp_free(*v2);
  result = 0;
  *a1 = 0;
  return result;
}

uint64_t signal_fifo_set_backlog_size(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

uint64_t signal_fifo_get_rd_ptr(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16) + 2 * (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 32));
  return result;
}

uint64_t signal_fifo_get_num_unread_samples(_DWORD *a1)
{
  unsigned int v1;
  unsigned int v2;
  BOOL v3;
  unsigned int v4;

  v1 = a1[9];
  v2 = a1[7] - a1[8];
  v3 = v2 >= v1;
  v4 = v2 - v1;
  if (v3)
    return v4;
  else
    return 0;
}

uint64_t signal_fifo_get_wr_ptr(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16) + 2 * (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 28));
  return result;
}

uint64_t signal_fifo_push_samples(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v6;
  int v7;
  void *v8;

  v6 = check_minimum_space((_QWORD *)a1, a3);
  if (!(_DWORD)v6)
  {
    if (a1)
    {
      v7 = *(_DWORD *)(a1 + 8);
      v8 = (void *)(*(_QWORD *)(a1 + 16) + 2 * (v7 * *(_DWORD *)(a1 + 28)));
    }
    else
    {
      v8 = 0;
      v7 = MEMORY[8];
    }
    dsp_memcpy(v8, a2, 2 * a3 * v7);
    *(_DWORD *)(a1 + 28) += a3;
  }
  return v6;
}

uint64_t signal_fifo_push_samples_nodata(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = check_minimum_space((_QWORD *)a1, a2);
  if (!(_DWORD)result)
    *(_DWORD *)(a1 + 28) += a2;
  return result;
}

uint64_t signal_fifo_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;

  v3 = *(_DWORD *)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 36);
  v5 = *(_DWORD *)(a1 + 28) - v3;
  v6 = v5 >= v4;
  v7 = v5 - v4;
  if (!v6)
    v7 = 0;
  if (v7 >= a3)
    v8 = a3;
  else
    v8 = v7;
  if ((_DWORD)v8)
  {
    dsp_memcpy(a2, (const void *)(*(_QWORD *)(a1 + 16) + 2 * (*(_DWORD *)(a1 + 8) * v3)), (2 * v8 * *(_DWORD *)(a1 + 8)));
    *(_DWORD *)(a1 + 32) += v8;
  }
  return v8;
}

uint64_t signal_fifo_pop_samples(_DWORD *a1, unsigned int a2)
{
  unsigned int v2;
  int v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;

  v3 = a1[8];
  v2 = a1[9];
  v4 = a1[7] - v3;
  v5 = v4 >= v2;
  LODWORD(v6) = v4 - v2;
  if (!v5)
    LODWORD(v6) = 0;
  if (v6 >= a2)
    v6 = a2;
  else
    v6 = v6;
  a1[8] = v6 + v3;
  return v6;
}

uint64_t signal_fifo_move_samples(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t result;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;

  v2 = (_DWORD *)a2;
  if (a2)
  {
    v3 = *(_DWORD *)(a2 + 32);
    a2 = *(_QWORD *)(a2 + 16) + 2 * (*(_DWORD *)(a2 + 8) * v3);
  }
  else
  {
    v3 = MEMORY[0x20];
  }
  v4 = v2[9];
  v5 = v2[7] - v3;
  v6 = v5 >= v4;
  v7 = v5 - v4;
  if (v6)
    v8 = v7;
  else
    v8 = 0;
  result = signal_fifo_push_samples(a1, (const void *)a2, v8);
  if (!(_DWORD)result)
  {
    v11 = v2[8];
    v10 = v2[9];
    v12 = v2[7] - v11;
    v6 = v12 >= v10;
    v13 = v12 - v10;
    if (!v6)
      v13 = 0;
    if (v13 >= v8)
      v13 = v8;
    v2[8] = v13 + v11;
    return v8;
  }
  return result;
}

uint64_t signal_fifo_clear(uint64_t a1)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  check_minimum_space((_QWORD *)a1, 0x800u / *(_DWORD *)(a1 + 8));
  return 0;
}

uint64_t dsp_biquad_init(_QWORD *a1, uint64_t a2, int a3, int a4)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v8 = (_QWORD *)dsp_malloc(a2, 0x38u);
  if (v8)
  {
    v9 = v8;
    *a1 = 0;
    *v8 = a2;
    v10 = dsp_malloc(a2, 4 * a3 * a4);
    v9[5] = v10;
    if (v10)
    {
      v11 = dsp_malloc(a2, 4 * a3 * a4);
      v9[6] = v11;
      if (v11)
      {
        result = 0;
        *((_DWORD *)v9 + 2) = 0;
        *((_DWORD *)v9 + 3) = a3;
        *((_DWORD *)v9 + 4) = a4;
        *a1 = v9;
        return result;
      }
      dsp_free(a2);
    }
    dsp_free(a2);
  }
  return 4294967294;
}

_QWORD *dsp_biquad_deinit(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = (_QWORD *)*result;
    if (*result)
    {
      dsp_free(*v1);
      dsp_free(*v1);
      return (_QWORD *)dsp_free(*v1);
    }
  }
  return result;
}

uint64_t dsp_biquad_create_low_pass_filter(uint64_t a1, float a2)
{
  long double v3;
  float32x2_t v9;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;
  float32x2_t v15;
  uint64_t v16;
  _DWORD *v17;
  _DWORD *v18;

  *(_DWORD *)(a1 + 8) = 1;
  v3 = tan((float)(a2 * 3.1416));
  *(float *)&v3 = v3;
  __asm { FMOV            V4.2S, #-1.0 }
  _D4.f32[0] = *(float *)&v3 + 1.0;
  v9 = vmla_n_f32(_D4, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v3, 0), *(float *)&v3);
  __asm { FMOV            V2.2S, #1.0 }
  v11 = vdiv_f32(_D2, v9);
  v12 = vadd_f32(v9, v9);
  v13 = (float32x2_t)vdup_lane_s32((int32x2_t)v11, 0);
  v14 = (float)((float)(1.0 - *(float *)&v3) + (float)(*(float *)&v3 * *(float *)&v3)) * v11.f32[0];
  v11.i32[1] = v12.i32[1];
  v13.f32[0] = *(float *)&v3 * *(float *)&v3;
  v15 = vmul_f32(v11, v13);
  *(_DWORD *)(a1 + 20) = v15.i32[0];
  *(float *)(a1 + 24) = v15.f32[0] + v15.f32[0];
  *(float32x2_t *)(a1 + 28) = v15;
  *(float *)(a1 + 36) = v14;
  v16 = (*(_DWORD *)(a1 + 16) * *(_DWORD *)(a1 + 12));
  if ((_DWORD)v16)
  {
    v17 = *(_DWORD **)(a1 + 40);
    v18 = *(_DWORD **)(a1 + 48);
    do
    {
      *v17++ = 0;
      *v18++ = 0;
      --v16;
    }
    while (v16);
  }
  return 0;
}

float dsp_biquad_process(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;

  v3 = *(unsigned int *)(a1 + 16);
  if (!(_DWORD)v3)
    return 0.0;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 48);
  do
  {
    v6 = *(float *)(v4 + 4 * a2) + (float)(a3 * *(float *)(a1 + 20));
    *(float *)(v4 + 4 * a2) = (float)(*(float *)(v5 + 4 * a2) + (float)(a3 * *(float *)(a1 + 24)))
                              - (float)(*(float *)(a1 + 32) * v6);
    *(float *)(v5 + 4 * a2++) = (float)(a3 * *(float *)(a1 + 28)) - (float)(*(float *)(a1 + 36) * v6);
    a3 = v6;
    --v3;
  }
  while (v3);
  return v6;
}

uint64_t dsp_biquad_process_fifos(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t num_unread_samples;
  uint64_t rd_ptr;
  uint64_t wr_ptr;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t i;
  float v13;
  float v14;
  float v15;

  num_unread_samples = signal_fifo_get_num_unread_samples(a3);
  rd_ptr = signal_fifo_get_rd_ptr((uint64_t)a3);
  signal_fifo_ensure_free_space(a2, num_unread_samples);
  wr_ptr = signal_fifo_get_wr_ptr(a2);
  if ((_DWORD)num_unread_samples)
  {
    v9 = wr_ptr;
    v10 = 0;
    v11 = *(unsigned int *)(a1 + 12);
    do
    {
      if (v11)
      {
        for (i = 0; i < v11; ++i)
        {
          v13 = dsp_biquad_process(a1, i, (float)*(__int16 *)(rd_ptr + 2 * i));
          if (v13 >= -32767.0)
            v14 = v13;
          else
            v14 = -32767.0;
          if (v13 <= 32767.0)
            v15 = v14;
          else
            v15 = 32767.0;
          *(_WORD *)(v9 + 2 * i) = (int)v15;
          v11 = *(unsigned int *)(a1 + 12);
        }
      }
      rd_ptr += 2 * v11;
      v9 += 2 * v11;
      ++v10;
    }
    while (v10 != (_DWORD)num_unread_samples);
  }
  signal_fifo_pop_samples(a3, num_unread_samples);
  return signal_fifo_push_samples_nodata(a2, num_unread_samples);
}

uint64_t dsp_biquad_flush(uint64_t result)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;

  v1 = *(unsigned int *)(result + 12);
  if ((_DWORD)v1)
  {
    v2 = *(_DWORD **)(result + 40);
    v3 = *(_DWORD **)(result + 48);
    do
    {
      *v2++ = 0;
      *v3++ = 0;
      --v1;
    }
    while (v1);
  }
  return result;
}

uint64_t DICT_Init(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v7;
  unsigned int *v8;
  kaldi::nnet1::UpdatableComponent *v9;
  char __src;

  __src = 0;
  v7 = BINTREE_Construct(a2, 0, a3);
  *(_QWORD *)a1 = v7;
  if (!v7)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  *(_QWORD *)(a1 + 8) = CompFunc1;
  *(_QWORD *)(a1 + 16) = CompFunc2;
  *(_DWORD *)(a1 + 64) = -1;
  *(_QWORD *)(a1 + 72) = a2;
  v8 = (unsigned int *)(a1 + 24);
  ARRAY_Init((uint64_t)v8, a2, 1, a4);
  v9 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v8, &__src);
  if ((_DWORD)v9 == -1)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v9);
  else
    return 0;
}

uint64_t CompFunc1(uint64_t a1, int a2, int a3)
{
  return strcmp((const char *)(*(_QWORD *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a2)), (const char *)(*(_QWORD *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a3)));
}

uint64_t CompFunc2(uint64_t a1, char *__s1, int a3)
{
  return strcmp(__s1, (const char *)(*(_QWORD *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a3)));
}

uint64_t DICT_Destruct(uint64_t *a1)
{
  uint64_t v1;

  v1 = (uint64_t)(a1 + 3);
  BINTREE_Destruct(*a1);
  return ARRAY_Flush(v1);
}

uint64_t DICT_Add(uint64_t a1, char *__s, void *a3, int a4, _DWORD *a5)
{
  int v9;
  kaldi::nnet1::UpdatableComponent *v10;
  unsigned int v11;
  kaldi::nnet1::UpdatableComponent *v12;
  int v13;
  const char *v14;
  size_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int __src;

  __src = a4;
  v9 = strlen(__s);
  v10 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), __s, v9 + 1, 1u);
  *a5 = 1;
  if ((_DWORD)v10 == -1)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v10);
  v11 = v10;
  v12 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), &__src, 4, 4u);
  if ((_DWORD)v12 == -1)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
  v12 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), a3, __src, 1u);
  if ((_DWORD)v12 == -1)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
  v12 = (kaldi::nnet1::UpdatableComponent *)BINTREE_Add((uint64_t *)a1, (uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1 + 8), v11);
  if ((_DWORD)v12 == -1)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
  v13 = (int)v12;
  v21 = 0;
  v12 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), &v21, 4, 4u);
  if ((_DWORD)v12 == -1)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
  if (!v13)
    return 0;
  v14 = (const char *)(*(_QWORD *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * v13));
  v15 = strlen(v14);
  result = 0;
  v17 = (uint64_t)&v14[v15 + 1];
  v18 = 4 - (v17 & 3);
  if ((v17 & 3) == 0)
    v18 = 0;
  v19 = *(unsigned int *)(v17 + v18) + v17 + v18 + 4;
  v20 = 4 - (v19 & 3);
  if ((v19 & 3) == 0)
    v20 = 0;
  *(_DWORD *)(v19 + v20) = v11;
  *a5 = 0;
  return result;
}

uint64_t DICT_Find(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  int v7;
  const char *v8;
  size_t v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  char *v13;
  uint64_t v14;
  int v15;

  v7 = *(_DWORD *)(a1 + 64);
  if (v7 == -1)
  {
    v7 = BINTREE_Find(*(_QWORD *)a1, a1 + 8, a2);
    if (v7)
      goto LABEL_3;
LABEL_11:
    *a4 = 1;
    return 0;
  }
  if (!v7)
    goto LABEL_11;
LABEL_3:
  *a4 = 0;
  v8 = (const char *)(*(_QWORD *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * v7));
  *(_QWORD *)a3 = v8;
  v9 = (size_t)&v8[strlen(v8) + 1];
  v10 = 4 - (v9 & 3);
  if ((v9 & 3) == 0)
    v10 = 0;
  v11 = (unsigned int *)(v9 + v10);
  v12 = *v11++;
  v13 = (char *)v11 + v12;
  *(_DWORD *)(a3 + 16) = v12;
  *(_QWORD *)(a3 + 8) = v11;
  if ((v13 & 3) != 0)
    v14 = 4 - (v13 & 3);
  else
    v14 = 0;
  v15 = *(_DWORD *)&v13[v14];
  *(_DWORD *)(a1 + 64) = v15;
  if (v15)
  {
    *(_DWORD *)(a3 + 20) = 1;
  }
  else
  {
    *(_DWORD *)(a3 + 20) = 0;
    *(_DWORD *)(a1 + 64) = -1;
  }
  return 0;
}

uint64_t DICT_Remove(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;

  *a3 = 0;
  v8 = a1 + 8;
  result = BINTREE_Find(*(_QWORD *)a1, a1 + 8, a2);
  if ((_DWORD)result)
  {
    v10 = *(_QWORD *)(a1 + 32);
    v11 = *a3 + 1;
    do
    {
      v12 = v10
          + (*(_DWORD *)(a1 + 48) * result)
          + strlen((const char *)(v10 + (*(_DWORD *)(a1 + 48) * result)))
          + 1;
      v13 = 4 - (v12 & 3);
      if ((v12 & 3) == 0)
        v13 = 0;
      v14 = v12 + v13 + *(int *)(v12 + v13) + 4;
      v15 = 4 - (v14 & 3);
      if ((v14 & 3) == 0)
        v15 = 0;
      v17 = *(_DWORD *)(v14 + v15);
      LODWORD(result) = v17;
      *a3 = v11++;
    }
    while ((_DWORD)result);
    result = BINTREE_Remove(*(_QWORD *)a1, v8, a2, &v17);
    if ((_DWORD)result)
      v16 = -1;
    else
      v16 = v17 == 0;
  }
  else
  {
    v16 = 1;
  }
  *a4 = v16;
  return result;
}

size_t DICTITT_Current@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4;
  const char *v5;
  size_t result;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  char *v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  int v16;

  v4 = a1[16];
  if (v4 == -1)
    v4 = *(_DWORD *)BINTREEITT_Current(a1 + 2);
  v5 = (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + *(_DWORD *)(*(_QWORD *)a1 + 48) * v4);
  *(_QWORD *)a2 = v5;
  result = strlen(v5);
  v7 = (uint64_t)&v5[result + 1];
  v8 = 4 - (v7 & 3);
  if ((v7 & 3) == 0)
    v8 = 0;
  v9 = (unsigned int *)(v7 + v8);
  v11 = *v9++;
  v10 = v11;
  v12 = (char *)v9 + v11;
  *(_QWORD *)(a2 + 8) = v9;
  if ((v12 & 3) != 0)
    v13 = 4 - (v12 & 3);
  else
    v13 = 0;
  v14 = *(_DWORD *)&v12[v13];
  v15 = v14 == 0;
  if (!v14)
    v14 = -1;
  a1[16] = v14;
  v16 = !v15;
  *(_DWORD *)(a2 + 16) = v10;
  *(_DWORD *)(a2 + 20) = v16;
  return result;
}

uint64_t DICTITT_Init(uint64_t a1, uint64_t *a2)
{
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 64) = -1;
  return BINTREEITT_Init(a1 + 8, *a2);
}

double ARRAY_Init(uint64_t a1, uint64_t a2, int a3, int a4)
{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a2;
  return result;
}

uint64_t ARRAY_Add(unsigned int *a1, void *__src)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t result;
  int v9;

  v9 = 0;
  v4 = *a1;
  v5 = a1[5];
  if (*a1 >= v5)
  {
    v7 = a1[4] + v5;
    a1[5] = v7;
    v6 = OOCAllocator_Realloc(*((_QWORD *)a1 + 4), *((_QWORD *)a1 + 1), a1[6] * v7, &v9);
    *((_QWORD *)a1 + 1) = v6;
    if (v9)
      return 0xFFFFFFFFLL;
    v4 = *a1;
  }
  else
  {
    v6 = *((_QWORD *)a1 + 1);
  }
  memcpy((void *)(v6 + a1[6] * v4), __src, a1[6]);
  result = *a1;
  *a1 = result + 1;
  return result;
}

uint64_t ARRAY_AddBuf(unsigned int *a1, void *__src, int a3, unsigned int a4)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  int v17;

  v7 = *a1;
  v8 = a1[5];
  v9 = a1[6];
  v17 = 0;
  if (v7 % a4)
    v10 = a4 - v7 % a4;
  else
    v10 = 0;
  v11 = v10 + v7;
  v12 = v11 + a3;
  if ((int)v11 + a3 <= v8)
  {
    v15 = *((_QWORD *)a1 + 1);
LABEL_12:
    memcpy((void *)(v15 + v11 * v9), __src, v9 * a3);
    *a1 = v12;
    return v11;
  }
  v13 = a1[4] + v8;
  if (v12 <= v13)
    v14 = v13;
  else
    v14 = v11 + a3;
  v15 = OOCAllocator_Realloc(*((_QWORD *)a1 + 4), *((_QWORD *)a1 + 1), v14 * v9, &v17);
  *((_QWORD *)a1 + 1) = v15;
  if (!v17)
  {
    a1[5] = v14;
    goto LABEL_12;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ARRAY_Destroy(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  int v3;
  char *v4;

  if (*(_DWORD *)a1 <= a2)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pThis");
  v2 = *(int *)(a1 + 24);
  v3 = *(_DWORD *)a1 - 1;
  *(_DWORD *)a1 = v3;
  v4 = (char *)(*(_QWORD *)(a1 + 8) + (int)(v2 * a2));
  memcpy(v4, &v4[v2], v2 * (v3 - a2));
  return 0;
}

uint64_t ARRAY_Flush(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    OOCAllocator_Free(v2, *(_QWORD *)(a1 + 8));
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return 0;
}

uint64_t BINTREE_Construct(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6;
  uint64_t v8;
  int v9;

  v9 = 0;
  v6 = OOCAllocator_Calloc(a1, 1, 24, &v9);
  v8 = v6;
  if (v9)
    return 0;
  *(_DWORD *)(v6 + 12) = a3;
  *(_QWORD *)(v6 + 16) = a1;
  if (BINTREE_IncreaseHeap(&v8, a2))
    return 0;
  else
    return v8;
}

uint64_t BINTREE_IncreaseHeap(uint64_t *a1, unsigned int a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  unsigned int *v7;
  _DWORD *v8;
  unsigned int v9;
  unsigned int v10;
  int v11;

  v4 = *a1;
  v11 = 0;
  v5 = *(_DWORD *)v4;
  if (!a2)
    a2 = *(_DWORD *)(v4 + 12) + v5;
  if (a2 < v5)
    return 0;
  v7 = (unsigned int *)OOCAllocator_Realloc(*(_QWORD *)(v4 + 16), v4, 20 * a2 + 24, &v11);
  if (v11)
    return 1;
  *a1 = (uint64_t)v7;
  v8 = v7 + 6;
  v9 = *v7;
  v10 = *v7 + 1;
  *v7 = a2;
  v7[1] = v10;
  if (v10 < a2)
  {
    v9 = v10 - 1;
    do
    {
      v8[5 * v9 + 2] = v9 + 2;
      ++v9;
    }
    while (a2 - 1 != v9);
  }
  result = 0;
  v8[5 * v9 + 2] = 0;
  return result;
}

uint64_t BINTREE_NewNode(uint64_t *a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t result;
  _DWORD *v5;
  unsigned int v6;
  int32x2_t *v7;
  uint64_t v9;

  v3 = *a1;
  v9 = v3;
  if (*(_DWORD *)(v3 + 4))
    goto LABEL_2;
  if (!BINTREE_IncreaseHeap(&v9, 0))
  {
    v3 = v9;
    *a1 = v9;
LABEL_2:
    v6 = *(_DWORD *)(v3 + 4);
    v5 = (_DWORD *)(v3 + 4);
    result = v6;
    v7 = (int32x2_t *)&v5[5 * v6];
    *v5 = v7[1].i32[0];
    v7[2].i8[0] = 0;
    *v7 = vdup_n_s32(a2);
    v7[1] = 0;
    return result;
  }
  return 0xFFFFFFFFLL;
}

uint64_t BINTREE_Add(uint64_t *a1, uint64_t (**a2)(_QWORD, _QWORD, _QWORD), unsigned int a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  _DWORD *v12;
  int v13;
  int v14;
  int v15;
  _DWORD *v16;
  unsigned int *v17;
  unsigned int v18;
  _DWORD *v19;
  int v20;
  int v21;
  _DWORD *v22;
  int *v23;
  int *v24;
  unsigned int *v25;
  int v26;
  int *v27;
  int v28;
  int v29;
  int v30;
  _DWORD *v31;
  int v32;
  int *v33;
  char v34;
  _DWORD *v35;
  char *v36;
  int v37;
  int v38;
  unsigned int *v39;
  _DWORD *v40;
  char *v41;
  int v42;
  int v43;
  _DWORD *v44;
  int v45;
  _DWORD *v46;
  int v47;
  _DWORD *v48;
  _DWORD *v49;
  int v50;
  _DWORD *v51;
  char *v52;
  int v53;
  int v54;
  char v55;
  _DWORD *v56;
  int v57;
  int v58;
  char v59;
  _DWORD *v60;
  _DWORD *v61;
  int v62;
  _DWORD *v63;
  int v64;
  _DWORD *v65;
  _DWORD *v66;
  int v67;
  uint64_t v68;
  int v69;
  unsigned int v70;

  result = BINTREE_NewNode(a1, a3);
  if ((_DWORD)result != -1)
  {
    v7 = result;
    v8 = *a1;
    v9 = *(_DWORD *)(*a1 + 8);
    if (v9)
    {
      v69 = result;
      v70 = a3;
      v10 = 0;
      v11 = 0;
      v68 = *a1;
      v12 = (_DWORD *)(v8 + 4);
      v13 = *(_DWORD *)(*a1 + 8);
      while (1)
      {
        v14 = v13;
        v15 = v13;
        v16 = &v12[5 * v13];
        v18 = v16[1];
        v17 = v16 + 1;
        v19 = v12;
        v20 = *((unsigned __int8 *)v17 + 12);
        v21 = (*a2)(a2, v70, v18);
        if (!v21)
          break;
        if (v20)
        {
          v9 = v15;
          v11 = v10;
        }
        v22 = &v19[5 * v15];
        v23 = v22 + 2;
        v24 = v22 + 3;
        if (v21 >= 0)
          v23 = v24;
        v13 = *v23;
        v10 = v14;
        v12 = v19;
        if (!*v23)
        {
          *v23 = v69;
          v25 = &v19[5 * v9];
          v26 = (*a2)(a2, v70, v25[1]);
          v27 = (int *)(v25 + 2);
          v67 = v26;
          if (v26 < 0)
            v28 = 1;
          else
            v28 = -1;
          v65 = v25 + 2;
          v66 = v25 + 3;
          if (v26 >= 0)
            v27 = (int *)(v25 + 3);
          v29 = *v27;
          if (*v27 != v69)
          {
            v30 = *v27;
            do
            {
              v31 = &v19[5 * v30];
              v32 = (*a2)(a2, v70, v31[1]);
              v33 = v31 + 2;
              if (v32 < 0)
                v34 = 1;
              else
                v34 = -1;
              if (v32 >= 0)
                v33 = v31 + 3;
              *((_BYTE *)v31 + 16) = v34;
              v30 = *v33;
            }
            while (v30 != v69);
          }
          v35 = &v19[5 * v9];
          v38 = *((char *)v35 + 16);
          v36 = (char *)(v35 + 4);
          v37 = v38;
          if (!v38)
          {
            result = 0;
            *v36 = v28;
            return result;
          }
          if (!(v28 + v37))
          {
            result = 0;
            *v36 = 0;
            return result;
          }
          v40 = &v19[5 * v29];
          v43 = *((unsigned __int8 *)v40 + 16);
          v41 = (char *)(v40 + 4);
          v42 = v43;
          if ((v67 & 0x80000000) == 0)
          {
            v44 = &v19[5 * v29];
            v47 = v44[2];
            v46 = v44 + 2;
            v45 = v47;
            if (v42 == 255)
            {
              v48 = v66;
              goto LABEL_35;
            }
            v51 = &v19[5 * v45];
            v54 = *((char *)v51 + 16);
            v52 = (char *)(v51 + 4);
            v53 = v54;
            *v46 = *((_DWORD *)v52 - 1);
            *v66 = *((_DWORD *)v52 - 2);
            *((_DWORD *)v52 - 2) = v9;
            *((_DWORD *)v52 - 1) = v29;
            if (v54 != 1)
            {
              if (v53)
              {
                if (v53 == -1)
                {
                  v55 = 1;
                  goto LABEL_44;
                }
LABEL_51:
                *v52 = 0;
                if (v11)
                {
                  v60 = &v19[5 * v11];
                  v62 = v60[2];
                  v61 = v60 + 2;
                  if (v9 == v62 || (v63 = &v19[5 * v11], v64 = v63[3], v61 = v63 + 3, v9 == v64))
                  {
                    result = 0;
                    *v61 = v45;
                  }
                  else
                  {
                    return 0;
                  }
                }
                else
                {
                  result = 0;
                  *(_DWORD *)(v68 + 8) = v45;
                }
                return result;
              }
LABEL_45:
              *v41 = 0;
              goto LABEL_49;
            }
            v59 = -1;
LABEL_48:
            *v41 = v59;
            goto LABEL_49;
          }
          v49 = &v19[5 * v29];
          v50 = v49[3];
          v46 = v49 + 3;
          v45 = v50;
          if (v42 == 1)
          {
            v48 = v65;
LABEL_35:
            *v48 = v45;
            *v46 = v9;
          }
          else
          {
            v56 = &v19[5 * v45];
            v58 = *((char *)v56 + 16);
            v52 = (char *)(v56 + 4);
            v57 = v58;
            *v46 = *((_DWORD *)v52 - 2);
            *v65 = *((_DWORD *)v52 - 1);
            *((_DWORD *)v52 - 2) = v29;
            *((_DWORD *)v52 - 1) = v9;
            if (v58 == -1)
            {
              v59 = 1;
              goto LABEL_48;
            }
            if (!v57)
              goto LABEL_45;
            if (v57 != 1)
              goto LABEL_51;
            v55 = -1;
LABEL_44:
            *v36 = v55;
            v36 = v41;
LABEL_49:
            v41 = v52;
            v29 = v45;
          }
          *v36 = 0;
          v52 = v41;
          v45 = v29;
          goto LABEL_51;
        }
      }
      v39 = &v19[5 * v15];
      v19[5 * v69 + 2] = *v19;
      *v19 = v69;
      result = *v17;
      *v17 = v70;
      if (*v39 == -1)
        *v39 = v70;
    }
    else
    {
      result = 0;
      *(_DWORD *)(v8 + 8) = v7;
    }
  }
  return result;
}

uint64_t BINTREE_Remove(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v8;
  double v9;
  uint64_t v10;
  int v11;
  int v12;
  kaldi::nnet1::UpdatableComponent *v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t result;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  _BYTE *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  unsigned int *v51;
  unsigned int *v52;
  uint64_t v53;
  uint64_t v54;
  _BYTE *v55;
  char v56;
  int v57;
  _DWORD *v58;
  uint64_t v59;
  _BYTE *v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unsigned int *v67;
  unsigned int *v68;
  uint64_t v69;
  uint64_t v70;
  _BYTE *v71;
  char v72;
  int v73;
  _DWORD *v74;
  uint64_t v75;
  _BYTE *v76;
  int v77;
  int v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  unsigned int *v83;
  unsigned int *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  unsigned int *v88;
  unsigned int *v89;
  _DWORD *v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  unsigned int __src;
  int v95;

  __src = *(_DWORD *)(a1 + 8);
  v8 = __src;
  v95 = 0;
  v93 = 0;
  v91 = 0u;
  v92 = 0u;
  v9 = ARRAY_Init((uint64_t)&v91, *(_QWORD *)(a1 + 16), 4, 64);
  if (!(_DWORD)v8)
    goto LABEL_19;
  v10 = a1 + 4;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, double))(a2 + 8))(a2, a3, *(unsigned int *)(a1 + 4 + 20 * v8 + 4), v9);
  if (v11)
  {
    v12 = v11;
    while (1)
    {
      v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
      if ((_DWORD)v13 == -1)
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
      v14 = v10 + 20 * v8;
      v15 = (unsigned int *)(v14 + 12);
      v16 = (unsigned int *)(v14 + 8);
      if (v12 >= 0)
        v17 = v15;
      else
        v17 = v16;
      v8 = *v17;
      __src = v8;
      if (!(_DWORD)v8)
        goto LABEL_19;
      v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a2 + 8))(a2, a3, *(unsigned int *)(v10 + 20 * v8 + 4));
      if (!v12)
        goto LABEL_12;
    }
  }
  v17 = (unsigned int *)&v95;
LABEL_12:
  v18 = __src;
  if (!__src)
  {
LABEL_19:
    ARRAY_Flush((uint64_t)&v91);
    result = 0;
    *a4 = 0;
    return result;
  }
  v19 = *(unsigned int *)(v10 + 20 * v8 + 12);
  if ((_DWORD)v19)
  {
    v20 = 0;
    v21 = *(unsigned int *)(v10 + 20 * v8 + 12);
    do
    {
      v22 = v20;
      v20 = v21;
      v23 = v10 + 20 * v21;
      v25 = *(_DWORD *)(v23 + 8);
      v24 = (_DWORD *)(v23 + 8);
      v21 = v25;
    }
    while (v25);
    *v24 = *(_DWORD *)(v10 + 20 * v8 + 8);
    if (v22)
    {
      v26 = v10 + 20 * v20;
      *(_DWORD *)(v10 + 20 * v22 + 8) = *(_DWORD *)(v26 + 12);
      *(_DWORD *)(v26 + 12) = v19;
    }
    *v17 = v20;
    *(_BYTE *)(v10 + 20 * v20 + 16) = *(_BYTE *)(v10 + 20 * v8 + 16);
  }
  else
  {
    v28 = *(_DWORD *)(v10 + 20 * v8 + 8);
    if (v28)
    {
      v29 = 0;
      v30 = *(unsigned int *)(v10 + 20 * v8 + 8);
      do
      {
        v31 = v29;
        v29 = v30;
        v32 = v10 + 20 * v30;
        v34 = *(_DWORD *)(v32 + 12);
        v33 = (_DWORD *)(v32 + 12);
        v30 = v34;
      }
      while (v34);
      *v33 = 0;
      if (v31)
      {
        v35 = v10 + 20 * v29;
        *(_DWORD *)(v10 + 20 * v31 + 12) = *(_DWORD *)(v35 + 8);
        *(_DWORD *)(v35 + 8) = v28;
      }
      *(_BYTE *)(v10 + 20 * v29 + 16) = *(_BYTE *)(v10 + 20 * v8 + 16);
    }
    else
    {
      LODWORD(v29) = 0;
    }
    *v17 = v29;
  }
  if (v17 == (unsigned int *)&v95)
  {
    v36 = v95;
    *(_DWORD *)(a1 + 8) = v95;
    if (!v36)
      goto LABEL_115;
    goto LABEL_32;
  }
  if (*(_DWORD *)(a1 + 8))
  {
LABEL_32:
    v37 = *v17;
    __src = v37;
    if (v37)
    {
      v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
      if ((_DWORD)v13 == -1)
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
      v38 = v10 + 20 * v37;
      if (v19)
      {
        for (__src = *(_DWORD *)(v38 + 12); __src; __src = *(_DWORD *)(v10 + 20 * __src + 8))
        {
          v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
          if ((_DWORD)v13 == -1)
            return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
        }
      }
      else
      {
        for (__src = *(_DWORD *)(v38 + 8); __src; __src = *(_DWORD *)(v10 + 20 * __src + 12))
        {
          v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
          if ((_DWORD)v13 == -1)
            return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
        }
      }
    }
    v39 = *(unsigned int *)(*((_QWORD *)&v91 + 1) + (DWORD2(v92) * (v91 - 1)));
    ARRAY_Destroy((uint64_t)&v91, v91 - 1);
    v40 = 0;
    v41 = v10 + 20 * v39;
    do
    {
      if (v40)
      {
        if (*(_DWORD *)(v41 + 8) == v40)
          goto LABEL_50;
        if (*(_DWORD *)(v41 + 12) == v40)
        {
LABEL_48:
          v42 = *(_BYTE *)(v41 + 16) + 1;
LABEL_51:
          *(_BYTE *)(v41 + 16) = v42;
        }
      }
      else
      {
        if (*(_DWORD *)(v41 + 8))
          goto LABEL_48;
        if (*(_DWORD *)(v41 + 12))
        {
LABEL_50:
          v42 = *(_BYTE *)(v41 + 16) - 1;
          goto LABEL_51;
        }
        *(_BYTE *)(v41 + 16) = 0;
      }
      v43 = 0;
      if ((_DWORD)v91)
      {
        v44 = v41;
        if (*((_QWORD *)&v91 + 1))
        {
          v43 = *(unsigned int *)(*((_QWORD *)&v91 + 1) + (DWORD2(v92) * (v91 - 1)));
          ARRAY_Destroy((uint64_t)&v91, v91 - 1);
          v44 = v10 + 20 * v43;
        }
      }
      else
      {
        v44 = v41;
      }
      v46 = (_BYTE *)(v41 + 16);
      v45 = *(unsigned __int8 *)(v41 + 16);
      if (!*(_BYTE *)(v41 + 16))
      {
        v63 = 1;
        goto LABEL_78;
      }
      if (v45 != 2)
      {
        if (v45 != 254)
        {
          v63 = 0;
LABEL_78:
          v40 = v39;
          if (!v43)
            goto LABEL_114;
          goto LABEL_108;
        }
        v47 = 0;
        if (v39)
        {
          v48 = v39;
          do
          {
            ++v47;
            v49 = v10 + 20 * v48;
            v50 = *(char *)(v49 + 16);
            v51 = (unsigned int *)(v49 + 12);
            v52 = (unsigned int *)(v49 + 8);
            if (v50 < 0)
              v52 = v51;
            v48 = *v52;
          }
          while ((_DWORD)v48);
        }
        v53 = *(unsigned int *)(v41 + 12);
        v54 = v10 + 20 * v53;
        v57 = *(unsigned __int8 *)(v54 + 16);
        v55 = (_BYTE *)(v54 + 16);
        v56 = v57;
        v58 = v55 - 8;
        v40 = *((unsigned int *)v55 - 2);
        if (v57 == 1)
        {
          v59 = v10 + 20 * v40;
          v62 = *(char *)(v59 + 16);
          v60 = (_BYTE *)(v59 + 16);
          v61 = v62;
          *v58 = *((_DWORD *)v60 - 1);
          *(_DWORD *)(v41 + 12) = *((_DWORD *)v60 - 2);
          *((_DWORD *)v60 - 2) = v39;
          *((_DWORD *)v60 - 1) = v53;
          if (v62 == 1)
          {
            *v55 = -1;
          }
          else
          {
            if (v61)
            {
              if (v61 == -1)
              {
                *v46 = 1;
                goto LABEL_89;
              }
              goto LABEL_90;
            }
            *v55 = 0;
          }
          v55 = (_BYTE *)(v41 + 16);
LABEL_89:
          *v55 = 0;
LABEL_90:
          *v60 = 0;
        }
        else
        {
          *(_DWORD *)(v41 + 12) = v40;
          *v58 = v39;
          *(_BYTE *)(v41 + 16) = ~v56;
          ++*v55;
          v40 = v53;
        }
        v79 = 0;
        if (v40)
        {
          v80 = v40;
          do
          {
            ++v79;
            v81 = v10 + 20 * v80;
            v82 = *(char *)(v81 + 16);
            v83 = (unsigned int *)(v81 + 12);
            v84 = (unsigned int *)(v81 + 8);
            if (v82 < 0)
              v84 = v83;
            v80 = *v84;
          }
          while ((_DWORD)v80);
        }
        goto LABEL_107;
      }
      v47 = 0;
      if (v39)
      {
        v64 = v39;
        do
        {
          ++v47;
          v65 = v10 + 20 * v64;
          v66 = *(char *)(v65 + 16);
          v67 = (unsigned int *)(v65 + 12);
          v68 = (unsigned int *)(v65 + 8);
          if (v66 < 0)
            v68 = v67;
          v64 = *v68;
        }
        while ((_DWORD)v64);
      }
      v69 = *(unsigned int *)(v41 + 8);
      v70 = v10 + 20 * v69;
      v73 = *(unsigned __int8 *)(v70 + 16);
      v71 = (_BYTE *)(v70 + 16);
      v72 = v73;
      v74 = v71 - 4;
      v40 = *((unsigned int *)v71 - 1);
      if (v73 != 255)
      {
        *(_DWORD *)(v41 + 8) = v40;
        *v74 = v39;
        *(_BYTE *)(v41 + 16) = 1 - v72;
        --*v71;
        v40 = v69;
        goto LABEL_102;
      }
      v75 = v10 + 20 * v40;
      v78 = *(char *)(v75 + 16);
      v76 = (_BYTE *)(v75 + 16);
      v77 = v78;
      *v74 = *((_DWORD *)v76 - 2);
      *(_DWORD *)(v41 + 8) = *((_DWORD *)v76 - 1);
      *((_DWORD *)v76 - 2) = v69;
      *((_DWORD *)v76 - 1) = v39;
      if (v78 == -1)
      {
        *v71 = 1;
        goto LABEL_99;
      }
      if (!v77)
      {
        *v71 = 0;
LABEL_99:
        v71 = (_BYTE *)(v41 + 16);
LABEL_100:
        *v71 = 0;
        goto LABEL_101;
      }
      if (v77 == 1)
      {
        *v46 = -1;
        goto LABEL_100;
      }
LABEL_101:
      *v76 = 0;
LABEL_102:
      v79 = 0;
      if (v40)
      {
        v85 = v40;
        do
        {
          ++v79;
          v86 = v10 + 20 * v85;
          v87 = *(char *)(v86 + 16);
          v88 = (unsigned int *)(v86 + 12);
          v89 = (unsigned int *)(v86 + 8);
          if (v87 < 0)
            v89 = v88;
          v85 = *v89;
        }
        while ((_DWORD)v85);
      }
LABEL_107:
      v63 = v47 != v79;
      if (!v43)
      {
LABEL_114:
        *(_DWORD *)(a1 + 8) = v40;
        break;
      }
LABEL_108:
      v90 = (_DWORD *)(v44 + 8);
      if (v39 == *(_DWORD *)(v44 + 8) || (v90 = (_DWORD *)(v44 + 12), v39 == *(_DWORD *)(v44 + 12)))
        *v90 = v40;
      v41 = v44;
      v39 = v43;
    }
    while (v63);
  }
LABEL_115:
  ARRAY_Flush((uint64_t)&v91);
  result = 0;
  *a4 = v18;
  return result;
}

uint64_t BINTREE_DeleteSubTree(uint64_t result, unsigned int a2)
{
  uint64_t v3;
  unsigned int *v4;
  uint64_t v6;
  unsigned int *v7;
  int v8;

  v3 = result;
  v4 = (unsigned int *)(result + 4);
  v6 = result + 4 + 20 * a2;
  v8 = *(_DWORD *)(v6 + 8);
  v7 = (unsigned int *)(v6 + 8);
  if (v8)
    result = BINTREE_DeleteSubTree(result);
  if (v4[5 * a2 + 3])
    result = BINTREE_DeleteSubTree(v3);
  *v7 = *v4;
  *v4 = a2;
  return result;
}

uint64_t BINTREE_Find(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  unsigned int *v7;
  int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;

  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v6 = a1 + 4;
  while (1)
  {
    v7 = (unsigned int *)(v6 + 20 * v3);
    v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a2 + 8))(a2, a3, *v7);
    if (!v8)
      break;
    v9 = v6 + 20 * v3;
    v10 = (unsigned int *)(v9 + 8);
    v11 = (unsigned int *)(v9 + 12);
    if (v8 < 0)
      v11 = v10;
    v3 = *v11;
    if (!(_DWORD)v3)
      return 0;
  }
  return *v7;
}

uint64_t BINTREE_Destruct(uint64_t a1)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    BINTREE_DeleteSubTree(a1, v2);
    *(_DWORD *)(a1 + 8) = 0;
  }
  return OOCAllocator_Free(*(_QWORD *)(a1 + 16), a1);
}

uint64_t BINTREEITT_Inc(unsigned int *a1)
{
  unsigned int v2;
  unsigned int *v3;
  uint64_t v4;
  kaldi::nnet1::UpdatableComponent *v5;
  uint64_t result;
  unsigned int __src;

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    v4 = *((_QWORD *)a1 + 1) + 4;
    *a1 = *(_DWORD *)(*((_QWORD *)a1 + 3) + a1[10] * (v2 - 1));
    ARRAY_Destroy((uint64_t)(a1 + 4), v2 - 1);
    __src = *(_DWORD *)(v4 + 20 * *a1 + 12);
    if (__src)
    {
      while (1)
      {
        v5 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v3, &__src);
        if ((_DWORD)v5 == -1)
          break;
        __src = *(_DWORD *)(v4 + 20 * __src + 8);
        if (!__src)
          return 0;
      }
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v5);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    result = 0;
    *a1 = 0;
  }
  return result;
}

uint64_t BINTREEITT_Current(unsigned int *a1)
{
  return *((_QWORD *)a1 + 1) + 20 * *a1 + 4;
}

uint64_t BINTREEITT_ReStart(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  int v8;
  kaldi::nnet1::UpdatableComponent *v9;
  uint64_t result;
  unsigned int __src;

  v2 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = 0;
  v3 = (unsigned int *)(a1 + 16);
  v4 = *(_DWORD *)(v2 + 8);
  __src = v4;
  if (v4)
  {
    v5 = v2 + 4;
    while (1)
    {
      v6 = v5 + 20 * v4;
      v8 = *(_DWORD *)(v6 + 8);
      v7 = (unsigned int *)(v6 + 8);
      if (!v8)
        break;
      v9 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v3, &__src);
      if ((_DWORD)v9 == -1)
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v9);
      v4 = *v7;
      __src = *v7;
    }
    *(_DWORD *)a1 = v4;
    __src = *(_DWORD *)(v5 + 20 * v4 + 12);
    if (!__src)
      return 0;
    while (1)
    {
      v9 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v3, &__src);
      if ((_DWORD)v9 == -1)
        break;
      __src = *(_DWORD *)(v5 + 20 * __src + 8);
      if (!__src)
        return 0;
    }
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v9);
  }
  else
  {
    result = 0;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

uint64_t BINTREEITT_Init(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 8) = a2;
  ARRAY_Init(a1 + 16, *(_QWORD *)(a2 + 16), 4, 64);
  return BINTREEITT_ReStart(a1);
}

_QWORD *err_ErrorGetCallback(_QWORD *result, _QWORD *a2)
{
  *result = 0;
  *a2 = 0;
  return result;
}

uint64_t err_GenerateErrorNotSupported()
{
  return 8;
}

uint64_t err_GenerateErrorInternal()
{
  return 9;
}

uint64_t err_GenerateErrorCallback()
{
  return 6;
}

uint64_t err_GenerateErrorLimit()
{
  return 7;
}

uint64_t err_GenerateErrorVersion()
{
  return 5;
}

uint64_t VoConObject_Con2(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  result = RefCounted_Con((uint64_t)a1, 1);
  if (!(_DWORD)result)
  {
    v5 = 0;
    *a1 = &__VoConObject;
    a1[6] = a2;
    a1[3] = &unk_1EA937D78;
    a1[4] = 0;
    result = PNEW_NullLogger_Con(a2, &v5);
    if (!(_DWORD)result)
      a1[5] = v5 + 24;
  }
  return result;
}

uint64_t VoConObject_Des(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    return RefCounted_Des(a1);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 72))(v2 - *(_QWORD *)(*(_QWORD *)v2 + 88));
  if (!(_DWORD)result)
    return RefCounted_Des(a1);
  return result;
}

uint64_t VoConObject_GetLogger(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (!v1)
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 80))(v1 - *(_QWORD *)(*(_QWORD *)v1 + 88));
  return *(_QWORD *)(a1 + 40);
}

uint64_t VoConObject_GetUserData(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 32);
  return 0;
}

BOOL VoConObject_IsClosable(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 2;
}

uint64_t VoConObject_QueryInterface(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = a1 + 24;
  if (a2 != 256370412)
    v3 = 0;
  *a3 = v3;
  return 0;
}

uint64_t VoConObject_SetLogger(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 40);
  if (!v4
    || (result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 72))(v4 - *(_QWORD *)(*(_QWORD *)v4 + 88)),
        !(_DWORD)result))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 88));
    result = 0;
    *(_QWORD *)(a1 + 40) = a2;
  }
  return result;
}

uint64_t VoConObject_SetUserData(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = a2;
  return 0;
}

void *GetVoConObjectClass()
{
  return &__VoConObject;
}

uint64_t GetNull()
{
  return 0;
}

uint64_t Object_Des()
{
  return 0;
}

void *GetObjectClass()
{
  return &__Object;
}

uint64_t OOC_PlacementDeleteObject(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  if (!(_DWORD)v4)
    OOCAllocator_Free(a1, a2);
  return v4;
}

uint64_t Object_Con(_QWORD *a1)
{
  *a1 = &__Object;
  return 0;
}

uint64_t RefCounted_Con(uint64_t a1, int a2)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__RefCounted;
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = a2;
  }
  return result;
}

uint64_t RefCounted_DecRefCount(uint64_t a1)
{
  uint64_t v2;

  if (atomic_decrement((_DWORD *)(a1 + 8)) != 1)
    return 0;
  *(_DWORD *)(a1 + 8) = 1;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
    return OOC_PlacementDeleteObject(v2, a1);
  else
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

uint64_t RefCounted_GetRefCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t RefCounted_IncRefCount(uint64_t a1)
{
  return atomic_increment((_DWORD *)(a1 + 8));
}

void *GetRefCountedClass()
{
  return &__RefCounted;
}

uint64_t OOCAllocator_Con(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __int128 v3;

  v3 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 32) = a3;
  return 0;
}

uint64_t OOCAllocator_Calloc(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  int ErrorInternal;

  if (!a2)
  {
    ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    v6 = 0;
    goto LABEL_7;
  }
  v5 = (*(uint64_t (**)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 32));
  if (!v5)
  {
    ErrorInternal = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_6;
  }
  v6 = v5;
  ErrorInternal = 0;
LABEL_7:
  *a4 = ErrorInternal;
  return v6;
}

uint64_t OOCAllocator_Free(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(_QWORD))(result + 24))(*(_QWORD *)(result + 32));
  return result;
}

uint64_t OOCAllocator_Malloc(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  int ErrorInternal;

  if (!a2)
  {
    ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    v5 = 0;
    goto LABEL_7;
  }
  v4 = (*(uint64_t (**)(_QWORD))a1)(*(_QWORD *)(a1 + 32));
  if (!v4)
  {
    ErrorInternal = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_6;
  }
  v5 = v4;
  ErrorInternal = 0;
LABEL_7:
  *a3 = ErrorInternal;
  return v5;
}

uint64_t OOCAllocator_Realloc(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  int ErrorInternal;

  if (!a3)
  {
    ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    v6 = 0;
    goto LABEL_7;
  }
  v5 = (*(uint64_t (**)(_QWORD))(a1 + 16))(*(_QWORD *)(a1 + 32));
  if (!v5)
  {
    ErrorInternal = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_6;
  }
  v6 = v5;
  ErrorInternal = 0;
LABEL_7:
  *a4 = ErrorInternal;
  return v6;
}

uint64_t atomic_increment(_DWORD *a1)
{
  uint64_t v1;

  v1 = *a1;
  *a1 = v1 + 1;
  return v1;
}

uint64_t atomic_decrement(_DWORD *a1)
{
  uint64_t v1;

  v1 = *a1;
  *a1 = v1 - 1;
  return v1;
}

uint64_t PtrList_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a1 + 32) = a2;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = &__PtrList;
    *(_DWORD *)(a1 + 24) = a4;
    return _PtrList_ResizeList(a1, a3);
  }
  return result;
}

uint64_t _PtrList_ResizeList(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;

  result = 0;
  v8 = 0;
  v4 = *(_DWORD *)(a1 + 20);
  if (v4 < a2)
  {
    v5 = *(_DWORD *)(a1 + 24) + v4;
    if (v5 <= a2)
      v6 = a2;
    else
      v6 = v5;
    v7 = OOCAllocator_Realloc(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 8), 8 * v6, &v8);
    result = v8;
    if (!v8)
    {
      *(_QWORD *)(a1 + 8) = v7;
      *(_DWORD *)(a1 + 20) = v6;
    }
  }
  return result;
}

uint64_t PtrList_Des(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    OOCAllocator_Free(*(_QWORD *)(a1 + 32), v2);
    *(_QWORD *)(a1 + 8) = 0;
  }
  return Object_Des();
}

uint64_t PtrList_Append(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!(_DWORD)result)
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v6 + 1;
    *(_QWORD *)(v5 + 8 * v6) = a2;
  }
  return result;
}

uint64_t PNEW_PtrList_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t result;
  unsigned int v12;

  v12 = 0;
  v10 = OOCAllocator_Malloc(a1, 40, &v12);
  result = v12;
  if (!v12)
  {
    result = PtrList_Con(v10, a2, a3, a4);
    v12 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t PtrList_ItemN(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t PtrList_Find(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t *, uint64_t *))
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = a2;
  if (!*(_DWORD *)(a1 + 16))
    return 0;
  v5 = 0;
  while (1)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v5);
    if (!a3(&v8, &v7))
      break;
    if (++v5 >= (unint64_t)*(unsigned int *)(a1 + 16))
      return 0;
  }
  return v7;
}

uint64_t PtrList_Prepend(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;

  result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!(_DWORD)result)
  {
    v5 = *(_DWORD *)(a1 + 16);
    if (v5)
    {
      v6 = *(unsigned int *)(a1 + 16);
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v6) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * (v6 - 1));
        --v6;
      }
      while ((_DWORD)v6);
    }
    **(_QWORD **)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 16) = v5 + 1;
  }
  return result;
}

uint64_t PtrList_Remove(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(unsigned int *)(result + 16);
  if ((_DWORD)v2)
  {
    v3 = 0;
    while (*(_QWORD *)(*(_QWORD *)(result + 8) + 8 * v3) != a2)
    {
      if (v2 == ++v3)
        return result;
    }
    v4 = (v2 - 1);
    if (v4 > v3)
    {
      do
      {
        *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * v3) = *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * v3 + 8);
        ++v3;
      }
      while (v4 != v3);
    }
    *(_DWORD *)(result + 16) = v4;
  }
  return result;
}

uint64_t PtrList_RemoveAll(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t PtrList_UdSort(uint64_t result, uint64_t (*a2)(char *, char *, uint64_t), uint64_t a3)
{
  unsigned int v4;

  v4 = *(_DWORD *)(result + 16);
  if (v4)
    return lhstdlib_udqsort(*(_QWORD *)(result + 8), v4, 8u, a3, a2);
  return result;
}

void *GetPtrListClass()
{
  return &__PtrList;
}

uint64_t PtrStack_Con(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 16) = a3;
    *(_QWORD *)a1 = &__PtrStack;
    *(_QWORD *)(a1 + 8) = a2;
  }
  return result;
}

uint64_t PtrStack_Des(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    OOCAllocator_Free(*(_QWORD *)(a1 + 8), v1);
  return Object_Des();
}

uint64_t PtrStack_Put(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v9;

  v4 = *(_DWORD *)(a1 + 24);
  v5 = v4 + 1;
  if (v4 + 1 <= *(_DWORD *)(a1 + 20))
  {
    v6 = *(_QWORD *)(a1 + 32);
    goto LABEL_5;
  }
  v9 = 0;
  v6 = OOCAllocator_Realloc(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 32), 8 * (*(_DWORD *)(a1 + 16) + v4), &v9);
  *(_QWORD *)(a1 + 32) = v6;
  v7 = v9;
  if (!v9)
  {
    *(_DWORD *)(a1 + 20) += *(_DWORD *)(a1 + 16);
    v4 = *(_DWORD *)(a1 + 24);
    v5 = v4 + 1;
LABEL_5:
    v7 = 0;
    *(_QWORD *)(v6 + 8 * v4) = a2;
    *(_DWORD *)(a1 + 24) = v5;
  }
  return v7;
}

uint64_t PtrStack_Remove(uint64_t a1)
{
  int v1;
  uint64_t result;

  v1 = *(_DWORD *)(a1 + 24);
  if (!v1)
    return 3;
  result = 0;
  *(_DWORD *)(a1 + 24) = v1 - 1;
  return result;
}

uint64_t PNEW_PtrStack_Con(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 40, &v10);
  result = v10;
  if (!v10)
  {
    result = Object_Con((_QWORD *)v8);
    if ((_DWORD)result)
    {
      v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(_QWORD *)(v8 + 32) = 0;
      *(_DWORD *)(v8 + 20) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      *(_DWORD *)(v8 + 16) = a3;
      *(_QWORD *)v8 = &__PtrStack;
      *(_QWORD *)(v8 + 8) = a2;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PtrQueue_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__PtrQueue;
    *(_QWORD *)(a1 + 8) = 0;
    result = PNEW_PtrList_Con(a2, a2, a3, a4, (uint64_t *)(a1 + 8));
    if (!(_DWORD)result)
    {
      *(_QWORD *)(a1 + 24) = a2;
      *(_DWORD *)(a1 + 16) = a3;
      *(_DWORD *)(a1 + 20) = a4;
    }
  }
  return result;
}

uint64_t PtrQueue_Des(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    OOC_PlacementDeleteObject(*(_QWORD *)(a1 + 24), v1);
  Object_Des();
  return 0;
}

BOOL PtrQueue_IsEmpty(uint64_t a1)
{
  return kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 8)) == 0;
}

uint64_t PtrQueue_Item(uint64_t a1)
{
  if (kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 8)))
    return PtrList_ItemN(*(_QWORD *)(a1 + 8), 0);
  else
    return 0;
}

uint64_t PtrQueue_NrItems(uint64_t a1)
{
  return kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 8));
}

uint64_t PtrQueue_Put(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20)
    || kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 8)) != *(_DWORD *)(a1 + 16))
  {
    return PtrList_Append(*(_QWORD *)(a1 + 8), a2);
  }
  else
  {
    return err_GenerateErrorLimit();
  }
}

uint64_t PtrQueue_Remove(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  if (kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 8))
    || (result = kaldi::StandardInputImpl::MyType(0), !(_DWORD)result))
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = PtrQueue_Item(a1);
    PtrList_Remove(v3, v4);
    return 0;
  }
  return result;
}

uint64_t adler3200(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  int v7;
  unsigned __int8 *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;

  if (!a2)
    return 1;
  v3 = HIWORD(a1);
  v4 = (unsigned __int16)a1;
  if (a3 < 0x10)
  {
    for (; a3; --a3)
    {
      v5 = *a2++;
      v4 += v5;
      v3 += v4;
    }
    if (v4 > 0xFFF0)
      v4 -= 65521;
    v3 %= 0xFFF1u;
    return v4 | (v3 << 16);
  }
  if (a3 >> 4 >= 0x15B)
  {
    do
    {
      a3 -= 5552;
      v7 = -347;
      v8 = a2;
      do
      {
        v9 = v4 + *v8;
        v10 = v9 + v3;
        v11 = v9 + v8[1];
        v12 = v10 + v11;
        v13 = v11 + v8[2];
        v14 = v12 + v13;
        v15 = v13 + v8[3];
        v16 = v14 + v15;
        v17 = v15 + v8[4];
        v18 = v16 + v17;
        v19 = v17 + v8[5];
        v20 = v18 + v19;
        v21 = v19 + v8[6];
        v22 = v20 + v21;
        v23 = v21 + v8[7];
        v24 = v22 + v23;
        v25 = v23 + v8[8];
        v26 = v24 + v25;
        v27 = v25 + v8[9];
        v28 = v26 + v27;
        v29 = v27 + v8[10];
        v30 = v28 + v29;
        v31 = v29 + v8[11];
        v32 = v30 + v31;
        v33 = v31 + v8[12];
        v34 = v32 + v33;
        v35 = v33 + v8[13];
        v36 = v34 + v35;
        v37 = v35 + v8[14];
        v38 = v36 + v37;
        v4 = v37 + v8[15];
        v3 = v38 + v4;
        v8 += 16;
      }
      while (!__CFADD__(v7++, 1));
      a2 += 5552;
      v4 %= 0xFFF1u;
      v3 %= 0xFFF1u;
    }
    while (a3 >> 4 > 0x15A);
    if (!a3)
      return v4 | (v3 << 16);
    if (a3 < 0x10)
      goto LABEL_23;
  }
  do
  {
    a3 -= 16;
    v40 = v4 + *a2;
    v41 = v40 + v3;
    v42 = v40 + a2[1];
    v43 = v41 + v42;
    v44 = v42 + a2[2];
    v45 = v43 + v44;
    v46 = v44 + a2[3];
    v47 = v45 + v46;
    v48 = v46 + a2[4];
    v49 = v47 + v48;
    v50 = v48 + a2[5];
    v51 = v49 + v50;
    v52 = v50 + a2[6];
    v53 = v51 + v52;
    v54 = v52 + a2[7];
    v55 = v53 + v54;
    v56 = v54 + a2[8];
    v57 = v55 + v56;
    v58 = v56 + a2[9];
    v59 = v57 + v58;
    v60 = v58 + a2[10];
    v61 = v59 + v60;
    v62 = v60 + a2[11];
    v63 = v61 + v62;
    v64 = v62 + a2[12];
    v65 = v63 + v64;
    v66 = v64 + a2[13];
    v67 = v65 + v66;
    v68 = v66 + a2[14];
    v69 = v67 + v68;
    v4 = v68 + a2[15];
    v3 = v69 + v4;
    a2 += 16;
  }
  while (a3 > 0xF);
  if (a3)
  {
LABEL_23:
    do
    {
      v70 = *a2++;
      v4 += v70;
      v3 += v4;
      --a3;
    }
    while (a3);
  }
  v4 %= 0xFFF1u;
  v3 %= 0xFFF1u;
  return v4 | (v3 << 16);
}

uint64_t _DataSectionRandomReader_ConInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9)
{
  uint64_t result;
  BOOL v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t (**v24)();
  unsigned int v25;

  result = RefCounted_Con(a1, 1);
  v25 = result;
  if ((_DWORD)result)
    return result;
  *(_QWORD *)a1 = &__DataSectionRandomReader;
  *(_QWORD *)(a1 + 24) = &off_1EA937510;
  *(_QWORD *)(a1 + 80) = a4;
  *(_QWORD *)(a1 + 88) = a5;
  v18 = (a8 & 1) != 0 && (__int16)a8 <= -1;
  v19 = a8 & 0x7FFE;
  v20 = !v18 || v19 == 0;
  v21 = v19 << 15;
  if (v20)
    v21 = a8;
  *(_DWORD *)(a1 + 48) = v21;
  *(_QWORD *)(a1 + 32) = &off_1EA937550;
  *(_QWORD *)(a1 + 40) = a6;
  v22 = a7;
  *(_QWORD *)(a1 + 64) = a7;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 104) = a2;
  *(_DWORD *)(a1 + 152) = a9;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = xmmword_1DEC43890;
  if (v21)
  {
    v23 = v21 + 4;
    v22 = a7 - 4 * ((a7 + (unint64_t)v21 + 3) / v23);
    *(_QWORD *)(a1 + 56) = v22;
    if (v21 <= 0x1000)
    {
      *(_DWORD *)(a1 + 112) = 1;
      *(_QWORD *)(a1 + 120) = OOCAllocator_Malloc(a2, v23, &v25);
      result = v25;
      if (v25)
        return result;
      v21 = *(_DWORD *)(a1 + 48);
      v22 = *(_QWORD *)(a1 + 56);
      v24 = *(uint64_t (***)())(a1 + 24);
      goto LABEL_16;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 56) = a7;
  }
  v24 = &off_1EA937510;
LABEL_16:
  if (v22 < v21)
    v21 = v22;
  *(_DWORD *)(a1 + 96) = v22;
  *(_DWORD *)(a1 + 100) = v21;
  return ((uint64_t (*)(uint64_t, _QWORD))*v24)(a1 + 24 - (_QWORD)v24[7], 0);
}

uint64_t DataSectionRandomReader_Des(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[11];
  if (!v2
    || (result = (**(uint64_t (***)(uint64_t))v2)(v2 - *(_QWORD *)(*(_QWORD *)v2 + 8)), !(_DWORD)result))
  {
    OOCAllocator_Free(a1[13], a1[15]);
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t DataSectionRandomReader_Clone(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v4;
  unsigned int v5;
  unsigned int v7;
  unsigned __int16 v8;

  v4 = *(_QWORD *)(a1 + 64);
  v5 = v4 - a2;
  if (v4 < a2)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"startOffset");
  v7 = *(_DWORD *)(a1 + 48);
  if (HIWORD(v7))
    v8 = (v7 >> 15) | 0x8001;
  else
    v8 = *(_DWORD *)(a1 + 48);
  return PNEW_DataSectionRandomReader_Con(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), a3, *(_QWORD *)(a1 + 40) + a2, v5, v8, a4);
}

uint64_t PNEW_DataSectionRandomReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, uint64_t *a9)
{
  uint64_t v17;
  uint64_t result;
  unsigned int v19;

  v19 = 0;
  v17 = OOCAllocator_Malloc(a1, 160, &v19);
  result = v19;
  if (!v19)
  {
    result = _DataSectionRandomReader_ConInternal(v17, a2, a3, a4, a5, a6, a7, a8, 0);
    v19 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      *(_QWORD *)(v17 + 16) = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t DataSectionRandomReader_GetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t DataSectionRandomReader_Read(uint64_t a1, char *__dst, unint64_t a3)
{
  int v4;
  uint64_t v5;

  if (*(unsigned int *)(a1 + 96) >= a3)
    return __DataSectionRandomReader_ReadInternalInterruptible(a1, a3, 0, __dst, &v5, &v4);
  else
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
}

uint64_t __DataSectionRandomReader_ReadInternalInterruptible(uint64_t a1, unint64_t a2, int a3, char *__dst, uint64_t *a5, _DWORD *a6)
{
  char *v8;
  unint64_t v10;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char v29[4];
  unsigned int v30;

  v8 = __dst;
  v10 = a2;
  v30 = 0;
  *a6 = 0;
  if (*(_DWORD *)(a1 + 48))
  {
    v12 = 0;
    if (a2)
    {
      do
      {
        v13 = *(unsigned int *)(a1 + 100);
        if (v10 >= v13)
          v14 = *(unsigned int *)(a1 + 100);
        else
          v14 = v10;
        if (*(_DWORD *)(a1 + 112))
        {
          v15 = *(_QWORD *)(a1 + 144);
          if (*(_QWORD *)(a1 + 128) != *(_QWORD *)(a1 + 136))
          {
            v16 = v13 + v15 + 4;
            v17 = (**(uint64_t (***)(_QWORD, uint64_t, uint64_t, _QWORD))(a1 + 72))(*(_QWORD *)(a1 + 120), 1, v16, *(_QWORD *)(a1 + 80));
            if (!__DataSectionRandomReader_ReadCallOk(a1, v16, v17, 0, a6, &v30))
              return v30;
            v18 = *(_QWORD *)(a1 + 120);
            *(_QWORD *)(a1 + 136) = *(_QWORD *)(a1 + 128);
            v19 = *(_DWORD *)(v18 + *(_QWORD *)(a1 + 144) + *(unsigned int *)(a1 + 100));
            v20 = adler3200(0, 0, 0);
            if (v19 != adler3200(v20, *(unsigned __int8 **)(a1 + 120), *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 144)))return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC not valid");
            v15 = *(_QWORD *)(a1 + 144);
          }
          memcpy(v8, (const void *)(*(_QWORD *)(a1 + 120) + v15), v14);
          *(_QWORD *)(a1 + 144) += v14;
        }
        else
        {
          v21 = (**(uint64_t (***)(void *, uint64_t, size_t, _QWORD))(a1 + 72))(v8, 1, v14, *(_QWORD *)(a1 + 80));
          v22 = __DataSectionRandomReader_ReadCallOk(a1, v14, v21, a3, a6, &v30);
          v14 = v21;
          if (!v22)
            return v30;
        }
        v23 = *(_DWORD *)(a1 + 100) - v14;
        *(_DWORD *)(a1 + 100) = v23;
        if (v23)
        {
          v12 += v14;
        }
        else
        {
          v24 = *(_DWORD *)(a1 + 112);
          if (!v24)
          {
            v25 = (**(uint64_t (***)(char *, uint64_t, uint64_t, _QWORD))(a1 + 72))(v29, 1, 4, *(_QWORD *)(a1 + 80));
            if (!__DataSectionRandomReader_ReadCallOk(a1, 4, v25, a3, a6, &v30))
              return v30;
            v24 = *(_DWORD *)(a1 + 112);
          }
          v26 = *(unsigned int *)(a1 + 48);
          v12 += v14;
          if ((unint64_t)*(unsigned int *)(a1 + 96) - v12 < v26)
            LODWORD(v26) = *(_DWORD *)(a1 + 96) - v12;
          *(_DWORD *)(a1 + 100) = v26;
          if (v24)
          {
            *(_QWORD *)(a1 + 128) += *(_QWORD *)(a1 + 144) + 4;
            *(_QWORD *)(a1 + 144) = 0;
          }
        }
        v8 += v14;
        v10 -= v14;
      }
      while (v10);
    }
    *(_DWORD *)(a1 + 96) -= v12;
    *a5 = v12;
  }
  else
  {
    v27 = (**(uint64_t (***)(void *, uint64_t, unint64_t, _QWORD))(a1 + 72))(__dst, 1, a2, *(_QWORD *)(a1 + 80));
    *a5 = v27;
    __DataSectionRandomReader_ReadCallOk(a1, v10, v27, a3, a6, &v30);
  }
  return v30;
}

uint64_t DataSectionRandomReader_ReadInterruptible(uint64_t a1, char *__dst, unint64_t a3, _DWORD *a4)
{
  uint64_t v5;

  *a4 = 0;
  if (*(unsigned int *)(a1 + 96) >= a3)
    return __DataSectionRandomReader_ReadInternalInterruptible(a1, a3, 0, __dst, &v5, a4);
  else
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
}

uint64_t DataSectionRandomReader_ReadPartial(uint64_t a1, char *__dst, unint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  int v8;

  if (*(unsigned int *)(a1 + 96) >= a3)
    v6 = a3;
  else
    v6 = *(unsigned int *)(a1 + 96);
  return __DataSectionRandomReader_ReadInternalInterruptible(a1, v6, 1, __dst, a4, &v8);
}

uint64_t DataSectionRandomReader_Seek(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;

  v2 = *(_QWORD *)(a1 + 56);
  if (v2 < a2)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"seek offset out of range");
  v5 = v2 - a2;
  *(_DWORD *)(a1 + 96) = v2 - a2;
  v6 = *(_DWORD *)(a1 + 48);
  v7 = a2 / v6;
  v8 = a2 + 4 * v7;
  if (v6 + v6 * v7 - a2 < v5)
    v5 = v6 + v6 * v7 - a2;
  *(_DWORD *)(a1 + 100) = v5;
  if (!*(_DWORD *)(a1 + 112))
  {
    if (!(*(unsigned int (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 72) + 8))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 40) + v8, 0))return 0;
    return err_GenerateErrorCallback();
  }
  v9 = v7 * (v6 + 4);
  if (*(_QWORD *)(a1 + 136) != v9
    && (*(unsigned int (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 72) + 8))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 40) + v9, 0))
  {
    return err_GenerateErrorCallback();
  }
  *(_QWORD *)(a1 + 128) = v9;
  *(_QWORD *)(a1 + 144) = v8 - v9;
  return 0;
}

uint64_t PNEW_DataSectionRandomReader_ConForInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, uint64_t *a10)
{
  uint64_t v18;
  uint64_t result;
  unsigned int v20;

  v20 = 0;
  v18 = OOCAllocator_Malloc(a1, 160, &v20);
  result = v20;
  if (!v20)
  {
    result = _DataSectionRandomReader_ConInternal(v18, a2, a3, a4, a5, a6, a7, a8, a9);
    v20 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v18);
      *a10 = 0;
      return v20;
    }
    else
    {
      *(_QWORD *)(v18 + 16) = a1;
      *a10 = v18;
    }
  }
  return result;
}

uint64_t __DataSectionRandomReader_ReadCallOk(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result;
  int ErrorCallback;
  int v12;

  if (a3 == a2)
    return 1;
  if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 72) + 16))(*(_QWORD *)(a1 + 80)))
  {
    ErrorCallback = err_GenerateErrorCallback();
LABEL_5:
    v12 = ErrorCallback;
    result = 0;
    *a6 = v12;
    return result;
  }
  if (a4)
  {
    result = 0;
    *a5 = 0;
  }
  else
  {
    if (!*(_DWORD *)(a1 + 152))
    {
      ErrorCallback = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
      goto LABEL_5;
    }
    result = 0;
    *a5 = 1;
  }
  return result;
}

uint64_t BinBlockStreamReader_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v6;
  uint64_t inited;
  char *v8;
  uint64_t v10;

  v6 = _BinBlockStreamReader_ConInternal(a1, a2, a3, a4, a5, 1, 0);
  if (!(_DWORD)v6)
  {
    v10 = 0;
    inited = _BinBlockStreamReader_InitInternal(a1, 0, 1, (int *)&v10 + 1, &v10);
    if ((_DWORD)inited)
    {
      v6 = inited;
      BinBlockStreamReader_Des(a1);
    }
    else
    {
      if ((_DWORD)v10 == 1)
      {
        v8 = "Not enough data in stream";
      }
      else
      {
        if (HIDWORD(v10) != 1)
          return 0;
        v8 = "Checksum error in data header";
      }
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
    }
  }
  return v6;
}

uint64_t _BinBlockStreamReader_ConInternal(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7)
{
  uint64_t result;
  _OWORD *v15;
  __int128 v16;
  _DWORD *v17;
  unsigned int v18;

  result = RefCounted_Con(a1, 1);
  v18 = result;
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__BinBlockStreamReader;
    *(_QWORD *)(a1 + 24) = &unk_1EA936ED0;
    *(_QWORD *)(a1 + 32) = &unk_1EA936EE0;
    *(_WORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 40) = &unk_1EA936FC8;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 54) = 0;
    *(_QWORD *)(a1 + 120) = a2;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_DWORD *)(a1 + 144) = a6;
    *(_QWORD *)(a1 + 148) = 0;
    *(_QWORD *)(a1 + 160) = a7;
    v15 = (_OWORD *)OOCAllocator_Malloc(a2, 32, &v18);
    *(_QWORD *)(a1 + 80) = v15;
    result = v18;
    if (!v18)
    {
      v16 = a3[1];
      *v15 = *a3;
      v15[1] = v16;
      *(_QWORD *)(a1 + 88) = a4;
      if (a5)
      {
        *(_DWORD *)(a1 + 64) = *a5;
        v17 = (_DWORD *)OOCAllocator_Malloc(a2, 4, &v18);
        *(_QWORD *)(a1 + 96) = v17;
        result = v18;
        if (v18)
          return result;
        *v17 = *a5;
      }
      else
      {
        *(_QWORD *)(a1 + 96) = 0;
        *(_DWORD *)(a1 + 64) = 1;
      }
      return PNEW_ParamDB_Con(a2, a2, (_QWORD *)(a1 + 136));
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_InitInternal(uint64_t a1, int a2, int a3, int *a4, _DWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v20;
  uint64_t v21;
  unsigned int ParameterSection;
  char *v23;
  int v24;
  unint64_t v25;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  _DWORD *v32;
  unsigned int *v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  unsigned __int16 v42;
  unsigned __int16 v43;
  int v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  *a5 = 0;
  v9 = *(_QWORD *)(a1 + 136);
  if (a2)
    v10 = 2;
  else
    v10 = 0;
  v36 = ParamDB_AddPublicParam(v9, 987249153, v10, (uint64_t)__BinBlockStreamReader_IsValidInterruptibleStatus);
  if (v36)
    return v36;
  v34 = 0;
  v35 = 0;
  v33 = 0;
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, _QWORD))(a1 + 80))(&v37, 1, 28, *(_QWORD *)(a1 + 88)) != 28)
  {
    if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 80) + 16))(*(_QWORD *)(a1 + 88)))
      goto LABEL_11;
    if (ParamDB_GetParam(*(_QWORD *)(a1 + 136), 987249153) == 2)
    {
      *a5 = 1;
      return v36;
    }
    if (!a3)
      goto LABEL_57;
    v23 = "Not enough data in stream";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  v11 = v37;
  v12 = v38;
  *(_DWORD *)(a1 + 48) = v37;
  *(_DWORD *)(a1 + 52) = v12;
  v13 = v39;
  *(_DWORD *)(a1 + 56) = v39;
  v14 = v40;
  *(_WORD *)(a1 + 60) = v40;
  v15 = v41;
  v16 = v42;
  *(_WORD *)(a1 + 72) = v42;
  v17 = v43;
  if (*(_DWORD *)(a1 + 64))
  {
    if (v45)
    {
      if (v12 + v11 + v13 + v14 + v15 + v16 + v43 + v44 != v45)
        goto LABEL_57;
      v18 = 0;
    }
    else
    {
      v18 = 1;
    }
    if (v16)
      v20 = v18;
    else
      v20 = 1;
  }
  else
  {
    v20 = 0;
  }
  if (v15 != 1)
  {
    if (!a3)
      goto LABEL_57;
    v23 = "data has wrong byte ordering";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, _QWORD))(a1 + 80))(&v37, 1, 12, *(_QWORD *)(a1 + 88)) != 12)
  {
    if (!(*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 80) + 16))(*(_QWORD *)(a1 + 88)))
    {
      if (ParamDB_GetParam(*(_QWORD *)(a1 + 136), 987249153) == 2)
      {
        *a5 = 1;
      }
      else if (a3)
      {
        v36 = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
      }
      else
      {
        *a4 = 1;
      }
      goto LABEL_45;
    }
LABEL_11:
    if (a3)
      return err_GenerateErrorCallback();
LABEL_57:
    v24 = 1;
    goto LABEL_58;
  }
  if (v37 != 270012440 || v38 != v17 || v39 != 0x10000)
  {
    if (!a3)
      goto LABEL_57;
    v23 = "Wrong stream format";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  v36 = PNEW_DataSectionReader_ConForInterruptibleStream(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), (*(_DWORD *)(a1 + 112) + 40), v17, *(_DWORD *)(a1 + 64), *(unsigned __int16 *)(a1 + 72), &v35);
  if (v36)
    return v36;
  v21 = (**(uint64_t (***)(uint64_t))(v35 + 24))(v35 + 24 - *(_QWORD *)(*(_QWORD *)(v35 + 24) + 48));
  v36 = (*(uint64_t (**)(uint64_t, unsigned int **, unint64_t *, int *, _DWORD *))(*(_QWORD *)(v35 + 32)
                                                                                                 + 16))(v35 + 32 - *(_QWORD *)(*(_QWORD *)(v35 + 32) + 48), &v33, &v34, a4, a5);
  if (v36)
    return v36;
  if (*a5)
  {
    ParameterSection = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 32))(v35);
    goto LABEL_29;
  }
  if (*a4 == 1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 32))(v35);
  v25 = v34;
  if (v34 < 4 || v34 == v21)
  {
    if (a3)
      return err_GenerateErrorLimit();
    goto LABEL_57;
  }
  v26 = v33;
  v27 = *v33;
  *(_DWORD *)(a1 + 68) = v27;
  if ((_DWORD)v27 == -1 || v25 < 12 * v27 + 4)
  {
    if (!a3)
    {
      *a4 = 1;
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 32))(v35);
    }
    v23 = "Stream data not consistent";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  if ((_DWORD)v27)
  {
    v29 = OOCAllocator_Malloc(*(_QWORD *)(a1 + 120), 12 * v27, &v36);
    *(_QWORD *)(a1 + 104) = v29;
    if (v36)
      return v36;
    v30 = *(unsigned int *)(a1 + 68);
    if ((_DWORD)v30)
    {
      v31 = v26 + 2;
      v32 = (_DWORD *)(v29 + 8);
      do
      {
        *(v32 - 2) = *(v31 - 1);
        *(v32 - 1) = *v31;
        *v32 = v31[1];
        v32 += 3;
        v31 += 3;
        --v30;
      }
      while (v30);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 104) = 0;
  }
  v36 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 32))(v35);
  if (v36)
    return v36;
  *(_DWORD *)(a1 + 128) = 0;
  if (ParamDB_GetParam(*(_QWORD *)(a1 + 136), 987249153) != 2)
  {
    ParameterSection = __BinBlockStreamReader_ReadParameterSection((_QWORD *)a1);
LABEL_29:
    v36 = ParameterSection;
    if (ParameterSection)
      return v36;
  }
LABEL_45:
  if (v20)
  {
    v24 = 2;
LABEL_58:
    *a4 = v24;
  }
  return v36;
}

uint64_t BinBlockStreamReader_Des(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 120);
  result = OOC_PlacementDeleteObject(v2, *(_QWORD *)(a1 + 136));
  if (!(_DWORD)result)
  {
    v4 = *(_QWORD *)(a1 + 104);
    if (v4)
      OOCAllocator_Free(v2, v4);
    v5 = *(_QWORD *)(a1 + 80);
    if (v5)
    {
      if (!*(_DWORD *)(a1 + 112) && *(_DWORD *)(a1 + 144))
      {
        if ((*(unsigned int (**)(_QWORD))(v5 + 24))(*(_QWORD *)(a1 + 88)))
          return err_GenerateErrorCallback();
        v5 = *(_QWORD *)(a1 + 80);
      }
      OOCAllocator_Free(v2, v5);
    }
    v6 = *(_QWORD *)(a1 + 96);
    if (v6)
      OOCAllocator_Free(v2, v6);
    result = RefCounted_Des(a1);
    if (!(_DWORD)result)
    {
      v7 = *(_QWORD *)(a1 + 160);
      if (v7)
        return (**(uint64_t (***)(uint64_t))v7)(v7 - *(_QWORD *)(*(_QWORD *)v7 + 8));
      else
        return 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_BorrowIStream(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t BinBlockStreamReader_BorrowIStreamInst(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t BinBlockStreamReader_BorrowIStreamParams(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t BinBlockStreamReader_CheckCRC(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 200))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40)
                                                                                                 + 208));
}

uint64_t BinBlockStreamReader_CheckCRCInterruptible(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  int Param;
  int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  _OWORD v21[7];
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  unsigned int v29;

  v25 = *(unsigned int *)(a1 + 112);
  *a3 = 0;
  if (*(_DWORD *)(a1 + 152))
  {
    result = 0;
    *a2 = 2;
  }
  else
  {
    v28 = 0;
    v26 = 0u;
    v27 = 0u;
    v24 = 1;
    v7 = *(_QWORD *)(a1 + 80);
    v8 = *(_QWORD *)(a1 + 88);
    v9 = *(_QWORD *)(a1 + 120);
    result = PtrStack_Con((uint64_t)&v26, v9, 1);
    v29 = result;
    if (!(_DWORD)result)
    {
      if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD))(v7 + 8))(v8, *(unsigned int *)(a1 + 112), 0))
      {
        return err_GenerateErrorCallback();
      }
      else
      {
        v10 = 0;
        do
        {
          if (v10)
          {
            result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v10 + 32))(*(_QWORD *)v10);
            v29 = result;
            if (!(_DWORD)result)
            {
              OOCAllocator_Free(v9, (uint64_t)v10);
              v10 = *(_DWORD **)(v28 + 8 * (DWORD2(v27) - 1));
              result = PtrStack_Remove((uint64_t)&v26);
              v29 = result;
              if (!(_DWORD)result)
              {
                v11 = v10[2];
                goto LABEL_17;
              }
            }
            return result;
          }
          v10 = (_DWORD *)OOCAllocator_Malloc(v9, 16, &v29);
          result = v29;
          if (!v29)
          {
            result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v9, (_OWORD *)v7, v8, &v24, v25, 1, 0, 0, 0, v10, a2, a3);
            v29 = result;
            if (!(_DWORD)result)
              goto LABEL_15;
          }
          return result;
LABEL_15:
          if ((*a2 - 1) < 2 || *a3 == 1)
            break;
          v11 = 0;
          v10[2] = 0;
LABEL_17:
          while (v11 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)v10 + 32) + 96))(*(_QWORD *)v10 + 32 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v10 + 32) + 224)))
          {
            v23 = 0;
            v22 = 0;
            result = __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(*(_QWORD *)v10, v10[2], &v23, &v22, &v25, a2, a3);
            v29 = result;
            if ((_DWORD)result)
              return result;
            if (*a2 == 1 || *a3 == 1)
              goto LABEL_40;
            if (v22 == -1)
            {
              ++v10[2];
              result = PtrStack_Put((uint64_t)&v26, (uint64_t)v10);
              v29 = result;
              if ((_DWORD)result)
                return result;
              v10 = 0;
              break;
            }
            v20 = 0u;
            memset(v21, 0, sizeof(v21));
            v19 = 0u;
            v17 = 0;
            v18 = 0;
            Param = ParamDB_GetParam(*(_QWORD *)(*(_QWORD *)v10 + 136), 987249153);
            v13 = *(_DWORD *)(*(_QWORD *)v10 + 64);
            v14 = *(unsigned __int16 *)(*(_QWORD *)v10 + 72);
            if (Param == 2)
              result = DataSectionReader_ConForInterruptibleStream(&v19, v9, v7, v8, v25, v23, v13, v14);
            else
              result = DataSectionReader_Con(&v19, v9, v7, v8, v25, v23, v13, v14);
            v29 = result;
            if ((_DWORD)result)
              return result;
            v15 = (**((uint64_t (***)(char *))&v20 + 1))((char *)&v20
                                                                 - *(_QWORD *)(*((_QWORD *)&v20 + 1) + 48) + 8);
            v18 = v15;
            while (v18 == v15 && !*a2 && !*a3)
            {
              result = (*(uint64_t (**)(char *, uint64_t *, uint64_t *, int *, _DWORD *))(*(_QWORD *)&v21[0]
                                                                                                + 16))((char *)v21 - *(_QWORD *)(*(_QWORD *)&v21[0] + 48), &v17, &v18, a2, a3);
              v29 = result;
              if ((_DWORD)result)
                return result;
            }
            result = (*(uint64_t (**)(__int128 *))(v19 + 32))(&v19);
            v29 = result;
            if ((_DWORD)result)
              return result;
            if (*a2 == 1 || *a3 == 1)
              goto LABEL_39;
            v11 = v10[2] + 1;
            v10[2] = v11;
          }
        }
        while (DWORD2(v27));
LABEL_39:
        if (!v10)
          goto LABEL_42;
LABEL_40:
        for (result = PtrStack_Put((uint64_t)&v26, (uint64_t)v10); ; result = PtrStack_Remove((uint64_t)&v26))
        {
          v29 = result;
          if ((_DWORD)result)
            break;
LABEL_42:
          if (!DWORD2(v27))
            return (*(uint64_t (**)(__int128 *))(v26 + 16))(&v26);
          v16 = *(_QWORD **)(v28 + 8 * (DWORD2(v27) - 1));
          if (*v16)
          {
            result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v16 + 32))(*v16);
            v29 = result;
            if ((_DWORD)result)
              return result;
          }
          OOCAllocator_Free(v9, (uint64_t)v16);
        }
      }
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_CreateForInterruptibleStreamInternal(uint64_t a1, _OWORD *a2, uint64_t a3, _DWORD *a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD *a10, int *a11, _DWORD *a12)
{
  uint64_t result;
  _DWORD *v16;
  _DWORD *v17;

  v17 = 0;
  result = _PNEW_BinBlockStreamReader_ConInternal(a1, a1, a2, a3, a4, a8, a9, (uint64_t *)&v17);
  if (!(_DWORD)result)
  {
    v16 = v17;
    *a10 = v17;
    v16[28] = a5;
    result = _BinBlockStreamReader_InitInternal((uint64_t)v16, a6, a7, a11, a12);
    if (!(_DWORD)result)
    {
      if (*a12)
      {
        result = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v16 + 32))(v16);
        if (!(_DWORD)result)
          *a10 = 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(uint64_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t result;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _DWORD v18[3];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *a3 = *(unsigned int *)(*(_QWORD *)(a1 + 104) + 12 * a2 + 4);
  *a6 = 0;
  *a7 = 0;
  if ((*(unsigned int (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 80) + 8))(*(_QWORD *)(a1 + 88), (*(_DWORD *)(a1 + 112) + *(_DWORD *)(*(_QWORD *)(a1 + 104) + 12 * a2 + 8)), 0))
  {
    return err_GenerateErrorCallback();
  }
  if ((**(uint64_t (***)(_DWORD *, uint64_t, uint64_t, _QWORD))(a1 + 80))(v18, 1, 12, *(_QWORD *)(a1 + 88)) == 12)
  {
    v16 = v18[0];
    v15 = v18[1];
    *a4 = v18[2];
    v17 = *(_QWORD *)(a1 + 104);
    result = 0;
    if (*(_QWORD *)(v17 + 12 * a2) == __PAIR64__(v15, v16))
    {
      *a5 = (*(_DWORD *)(a1 + 112) + *(_DWORD *)(v17 + 12 * a2 + 8) + 12);
      *a3 = v15;
    }
    else
    {
      *a6 = 1;
    }
  }
  else if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 80) + 16))(*(_QWORD *)(a1 + 88)))
  {
    return err_GenerateErrorCallback();
  }
  else if (ParamDB_GetParam(*(_QWORD *)(a1 + 136), 987249153) == 2)
  {
    result = 0;
    *a7 = 1;
  }
  else
  {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_CheckDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  int v5;

  v5 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 40) + 56))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40) + 208), a2, a3, &v5);
  if ((_DWORD)result)
    v4 = 1;
  else
    v4 = v5 == 0;
  if (!v4)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t BinBlockStreamReader_CheckDependencyInterruptible(uint64_t a1, int a2, const char *a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  int v11;
  uint64_t v12;
  char *__s;
  uint64_t v14;

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 32))(a1 + 32 - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 224), 270065117) != 1)return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer not compatible (no dependency section)");
  __s = 0;
  v14 = 0;
  v12 = 0;
  v11 = 0;
  v9 = *(_QWORD *)(a1 + 40);
  v8 = a1 + 40;
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *, int *, _DWORD *))(v9 + 8))(v8 - *(_QWORD *)(v9 + 208), 270065117, 0, &v14, &v11, a4);
  if (!(_DWORD)result)
  {
    if (*a4)
    {
      return 0;
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, char **, uint64_t *, _DWORD *))(*(_QWORD *)v14 + 8))(v14 - *(_QWORD *)(*(_QWORD *)v14 + 48), &__s, &v12, a4);
      if (!(_DWORD)result)
      {
        if (*a4)
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 32))(v8 - *(_QWORD *)(*(_QWORD *)v8 + 208), v14);
        result = _BinBlockStreamReader_CheckDependency(__s, v12, a2, a3);
        if (!(_DWORD)result)
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 32))(v8 - *(_QWORD *)(*(_QWORD *)v8 + 208), v14);
      }
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_CheckDependency(char *__s, int a2, int a3, const char *a4)
{
  char *v6;
  char *v7;
  char *v8;
  const char *v9;
  int v10;
  uint64_t result;

  v6 = __s;
  v7 = &__s[a2];
  v8 = "Buffer not compatible (dependency not found)";
  while (v6 < v7)
  {
    v9 = v6 + 4;
    v10 = *(_DWORD *)v6;
    v6 += (strlen(v6 + 4) + 8) & 0xFFFFFFFC;
    if (v10 == a3)
    {
      result = strcmp(a4, v9);
      if (!(_DWORD)result)
        return result;
      v8 = "Buffer not compatible (dependency do not match)";
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
    }
  }
  return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
}

uint64_t BinBlockStreamReader_CheckVersion(uint64_t a1, unsigned int a2)
{
  int v3;

  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 64))(a1 + 32 - *(_QWORD *)(*(_QWORD *)(a1 + 32)
                                                                                              + 224));
  if ((v3 ^ a2) >> 16 || BYTE1(v3) > BYTE1(a2))
    return err_GenerateErrorVersion();
  else
    return 0;
}

BOOL BinBlockStreamReader_IsVersionAccepted(unsigned int a1, int a2)
{
  return !((a2 ^ a1) >> 16) && BYTE1(a1) <= BYTE1(a2);
}

uint64_t BinBlockStreamReader_FetchBinBlockStreamReader(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  uint64_t v6;
  uint64_t result;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;

  v13 = 0;
  v11 = 0;
  v6 = *(_QWORD *)(a1 + 120);
  v9 = 0;
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v12, &v13, &v11, &v9);
  if (!(_DWORD)result)
  {
    if ((_DWORD)v9 == 1)
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
    if (v13 == -1)
    {
      v10 = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
      result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v6, *(_OWORD **)(a1 + 80), *(_QWORD *)(a1 + 88), *(_DWORD **)(a1 + 96), v11, 0, 1, 1, a1 + 24, &v10, (int *)&v9 + 1, &v9);
      if (!(_DWORD)result)
      {
        if ((_DWORD)v9 == 1)
        {
          v8 = "Not enough data in stream";
        }
        else
        {
          if (HIDWORD(v9) != 1)
          {
            result = 0;
            *a4 = v10 + 32;
            *(_DWORD *)(a1 + 128) = 1;
            return result;
          }
          v8 = "Checksum error in data header";
        }
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
      }
    }
    else
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
    }
  }
  return result;
}

uint64_t __BinBlockStreamReader_SeekSection(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5, _QWORD *a6, _DWORD *a7)
{
  uint64_t v7;
  uint64_t v9;
  int v10;
  int *v11;
  int v12;
  int v13;
  uint64_t result;
  int v15;

  v7 = *(unsigned int *)(a1 + 68);
  if (!(_DWORD)v7)
  {
    v13 = 0;
    LODWORD(v9) = 0;
    goto LABEL_9;
  }
  v9 = 0;
  v10 = 0;
  v11 = *(int **)(a1 + 104);
  while (1)
  {
    v12 = *v11;
    v11 += 3;
    if (v12 == a2)
      break;
LABEL_6:
    if (v7 == ++v9)
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Data not found in the stream");
  }
  if (v10 != a3)
  {
    ++v10;
    goto LABEL_6;
  }
  v15 = 0;
  result = __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(a1, v9, a4, a5, a6, &v15, a7);
  if (!(_DWORD)result)
  {
    if (v15 == 1)
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC checking failed");
    v13 = *(_DWORD *)(a1 + 68);
LABEL_9:
    if ((_DWORD)v9 == v13)
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Data not found in the stream");
    else
      return 0;
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchBinBlockStreamReaderInterruptible(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5)
{
  uint64_t v8;
  uint64_t result;
  char *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v15 = 0;
  v13 = 0;
  v8 = *(_QWORD *)(a1 + 120);
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v14, &v15, &v13, a5);
  if (!(_DWORD)result)
  {
    if (*a5)
      return 0;
    v12 = 0;
    v11 = 0;
    if (v15 != -1)
    {
      v10 = "Stream format not supported";
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v10);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v8, *(_OWORD **)(a1 + 80), *(_QWORD *)(a1 + 88), *(_DWORD **)(a1 + 96), v13, 1, 1, 1, a1 + 24, &v12, &v11, a5);
    if (!(_DWORD)result)
    {
      if (!*a5)
      {
        *a4 = v12 + 40;
        *(_DWORD *)(a1 + 128) = 1;
        if (v11 != 1)
          return 0;
        v10 = "Checksum error in data header";
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v10);
      }
      result = 0;
      *a4 = 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  int v5;

  v5 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 40) + 152))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40) + 208), a2, a3, &v5);
  if ((_DWORD)result)
    v4 = 1;
  else
    v4 = v5 == 0;
  if (!v4)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyInterruptible(_QWORD *a1, int a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t result;
  char *v9;
  const void *v10;
  int v11;
  size_t v12;
  size_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  char *__s;
  uint64_t v18;
  unsigned int v19;

  *a3 = 0;
  *a4 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(_QWORD *)(a1[4] + 224) + 32, 270065117);
  if ((_DWORD)result)
  {
    if ((_DWORD)result == 1)
    {
      __s = 0;
      v18 = 0;
      v16 = 0;
      v15 = 0;
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *, int *, _DWORD *))(a1[5] + 8))((uint64_t)a1 - *(_QWORD *)(a1[5] + 208) + 40, 270065117, 0, &v18, &v15, a4);
      if (!(_DWORD)result)
      {
        if (*a4)
        {
          return 0;
        }
        else
        {
          result = (*(uint64_t (**)(uint64_t, char **, uint64_t *, _DWORD *))(*(_QWORD *)v18 + 8))(v18 - *(_QWORD *)(*(_QWORD *)v18 + 48), &__s, &v16, a4);
          v19 = result;
          if (!(_DWORD)result)
          {
            if (!*a4)
            {
              v9 = __s;
              while (v9 < &__s[v16])
              {
                v10 = v9 + 4;
                v11 = *(_DWORD *)v9;
                v12 = strlen(v9 + 4);
                v9 += ((_DWORD)v12 + 8) & 0xFFFFFFFC;
                if (v11 == a2)
                {
                  v13 = v12 + 1;
                  v14 = (void *)OOCAllocator_Malloc(a1[15], v12 + 1, &v19);
                  *a3 = v14;
                  result = v19;
                  if (v19)
                    return result;
                  memcpy(v14, v10, v13);
                  return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(_QWORD *)(a1[5] + 208) + 40, v18);
                }
              }
            }
            return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(_QWORD *)(a1[5] + 208) + 40, v18);
          }
        }
      }
    }
    else
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer not compatible (no dependency section)");
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyTypes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  int v5;

  v5 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 40) + 184))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40) + 208), a2, a3, &v5);
  if ((_DWORD)result)
    v4 = 1;
  else
    v4 = v5 == 0;
  if (!v4)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyTypesInterruptible(_QWORD *a1, uint64_t *a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result;
  char *v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  const char *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  const char *v18;
  int v19;
  int v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  unsigned int v25;

  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(_QWORD *)(a1[4] + 224) + 32, 270065117);
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 1)
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer not compatible (no dependency section)");
    v23 = 0;
    v24 = 0;
    v22 = 0;
    v21 = 0;
    v9 = (char *)(a1 + 5);
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *, int *, _DWORD *))(a1[5] + 8))((uint64_t)a1 - *(_QWORD *)(a1[5] + 208) + 40, 270065117, 0, &v24, &v21, a4);
    if (!(_DWORD)result)
    {
      if (*a4)
        return 0;
      result = (*(uint64_t (**)(uint64_t, const char **, uint64_t *, _DWORD *))(*(_QWORD *)v24 + 8))(v24 - *(_QWORD *)(*(_QWORD *)v24 + 48), &v23, &v22, a4);
      v25 = result;
      if (!(_DWORD)result)
      {
        if (*a4)
          return (*(uint64_t (**)(char *, uint64_t))(*(_QWORD *)v9 + 32))(&v9[-*(_QWORD *)(*(_QWORD *)v9 + 208)], v24);
        v10 = *a3;
        if (v22 >= 5)
        {
          v11 = v23;
          v12 = (unint64_t)&v23[v22];
          v13 = v23 + 4;
          do
          {
            v14 = strlen(v13);
            *a3 = ++v10;
            v11 += (v14 + 8) & 0xFFFFFFFC;
            v13 = v11 + 4;
          }
          while ((unint64_t)(v11 + 4) < v12);
        }
        v15 = OOCAllocator_Malloc(a1[15], 8 * v10, &v25);
        *a2 = v15;
        result = v25;
        if (!v25)
        {
          if (*a3)
          {
            v16 = 0;
            v17 = 1;
            v18 = v23;
            do
            {
              v19 = strlen(v18 + 4);
              *(_QWORD *)(v15 + 8 * v16) = *(unsigned int *)v18;
              v18 += (v19 + 8) & 0xFFFFFFFC;
              v16 = v17;
            }
            while (*a3 > (unint64_t)v17++);
          }
          return (*(uint64_t (**)(char *, uint64_t))(*(_QWORD *)v9 + 32))(&v9[-*(_QWORD *)(*(_QWORD *)v9 + 208)], v24);
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchRawSectionDataStreamReaderInterruptible(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(a1, a2, a3, 1, a4, a5, a6);
}

uint64_t _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(uint64_t a1, int a2, int a3, int a4, _QWORD *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v12;
  BOOL v13;
  int v14;
  uint64_t result;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  v21 = 0;
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v12 = *(_QWORD *)(a1 + 120);
  if (a4)
    v13 = 0;
  else
    v13 = *(_DWORD *)(a1 + 64) == 1;
  v14 = v13;
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v20, &v21, &v19, a7);
  if (!(_DWORD)result)
  {
    if (*a7)
    {
      return 0;
    }
    else
    {
      v16 = v21;
      if (a4 || v21 != -1)
      {
        if (a4 == 1)
          v17 = 0;
        else
          v17 = *(unsigned __int16 *)(a1 + 72);
        result = PNEW_DataSectionReader_ConForInterruptibleStream(v12, v12, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), v19, v20, v14, v17, &v18);
        if (!(_DWORD)result)
        {
          *a5 = v18 + 32;
          *a6 = v16;
          *(_DWORD *)(a1 + 128) = 1;
        }
      }
      else
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchSectionDataStreamReader(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5)
{
  uint64_t v8;
  uint64_t result;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v15 = 0;
  v13 = 0;
  v14 = 0;
  v12 = 0;
  v8 = *(_QWORD *)(a1 + 120);
  v11 = 0;
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v14, &v15, &v13, &v11);
  if (!(_DWORD)result)
  {
    if (v11 == 1)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
    }
    else
    {
      v10 = v15;
      if (v15 == -1)
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
      }
      else
      {
        result = PNEW_DataSectionReader_Con(v8, v8, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), v13, v14, *(_DWORD *)(a1 + 64), *(unsigned __int16 *)(a1 + 72), &v12);
        if (!(_DWORD)result)
        {
          *a4 = v12 + 24;
          *a5 = v10;
          *(_DWORD *)(a1 + 128) = 1;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchSectionDataStreamReaderInterruptible(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(a1, a2, a3, 0, a4, a5, a6);
}

uint64_t BinBlockStreamReader_GetAlignment(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 60);
}

uint64_t BinBlockStreamReader_GetCRCBlockSize(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t BinBlockStreamReader_GetCRCBlockSizeInterruptible(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t BinBlockStreamReader_GetNrSectionInstances(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;

  v2 = *(unsigned int *)(result + 68);
  if (!(_DWORD)v2)
    return 0;
  v3 = result;
  LODWORD(result) = 0;
  v4 = *(int **)(v3 + 104);
  do
  {
    v5 = *v4;
    v4 += 3;
    if (v5 == a2)
      result = (result + 1);
    else
      result = result;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t BinBlockStreamReader_GetNrSections(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t BinBlockStreamReader_GetSectionDataIfAvailable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result;
  BOOL v8;
  int v9;

  v9 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 40) + 64))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40) + 208), a2, a3, a4, a5, a6, a7, &v9);
  if ((_DWORD)result)
    v8 = 1;
  else
    v8 = v9 == 0;
  if (!v8)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataIfAvailableInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t *a6, uint64_t *a7, _DWORD *a8)
{
  unsigned int v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned int v24;

  *a8 = 0;
  *a6 = 0;
  *a7 = 0;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 32))(a1 + 32 - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 224), a3);
  result = 0;
  if (v16 > a4)
  {
    v23 = 0;
    v22 = 0;
    v19 = *(_QWORD *)(a1 + 40);
    v18 = a1 + 40;
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, int *, _DWORD *))(v19 + 8))(v18 - *(_QWORD *)(v19 + 208), a3, a4, &v23, &v22, a8);
    v24 = result;
    if (!(_DWORD)result)
    {
      if (*a8)
        return 0;
      if ((v22 ^ a5) >> 16 || BYTE1(v22) > BYTE1(a5))
        return err_GenerateErrorVersion();
      v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23 - *(_QWORD *)(*(_QWORD *)v23 + 48));
      if (!v20)
      {
        v21 = 0;
LABEL_14:
        if (*a8)
        {
          OOCAllocator_Free(a2, v21);
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 32))(v18 - *(_QWORD *)(*(_QWORD *)v18 + 208), v23);
        }
        else
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 32))(v18 - *(_QWORD *)(*(_QWORD *)v18 + 208), v23);
          if (!(_DWORD)result)
          {
            *a6 = v21;
            *a7 = v20;
          }
        }
        return result;
      }
      v21 = OOCAllocator_Malloc(a2, v20, &v24);
      result = v24;
      if (!v24)
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(_QWORD *)v23 + 32))(v23 - *(_QWORD *)(*(_QWORD *)v23 + 48), v21, a8);
        v24 = result;
        if (!(_DWORD)result)
          goto LABEL_14;
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataRandomReader(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5)
{
  uint64_t v8;
  uint64_t result;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v15 = 0;
  v13 = 0;
  v14 = 0;
  v12 = 0;
  v8 = *(_QWORD *)(a1 + 120);
  v11 = 0;
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v14, &v15, &v13, &v11);
  if (!(_DWORD)result)
  {
    if (v11 == 1)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
    }
    else
    {
      v10 = v15;
      if (v15 == -1)
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
      }
      else
      {
        result = PNEW_DataSectionRandomReader_Con(v8, v8, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), a1 + 24, v13, v14, *(unsigned __int16 *)(a1 + 72), &v12);
        if (!(_DWORD)result)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          result = 0;
          *a4 = v12 + 24;
          *a5 = v10;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataRandomReaderInterruptible(uint64_t a1, int a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int Param;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  v22 = 0;
  v20 = 0;
  v21 = 0;
  v19 = 0;
  v10 = *(_QWORD *)(a1 + 120);
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v21, &v22, &v20, a6);
  if (!(_DWORD)result)
  {
    if (*a6 == 1)
    {
      return 0;
    }
    else
    {
      v12 = v22;
      if (v22 == -1)
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
      }
      else
      {
        v13 = *(_QWORD *)(a1 + 88);
        v18 = *(_QWORD *)(a1 + 80);
        v14 = v20;
        v15 = v21;
        v16 = *(unsigned __int16 *)(a1 + 72);
        Param = ParamDB_GetParam(*(_QWORD *)(a1 + 136), 987249153);
        result = PNEW_DataSectionRandomReader_ConForInterruptible(v10, v10, v18, v13, a1 + 24, v14, v15, v16, Param == 2, &v19);
        if (!(_DWORD)result)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          result = 0;
          *a4 = v19 + 32;
          *a5 = v12;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionID(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t result;
  int v5;
  unsigned int v6;
  uint64_t v7;

  *a3 = 0;
  v3 = *(_QWORD *)(a1 + 104);
  result = *(unsigned int *)(v3 + 12 * a2);
  if (a2)
  {
    v5 = 0;
    v6 = a2 - 1;
    do
    {
      v7 = v6;
      if (*(_DWORD *)(v3 + 12 * v6) == (_DWORD)result)
        *a3 = ++v5;
      --v6;
    }
    while (v7);
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionVersion(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v9 = 0;
  v6 = 0;
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v8, &v9, &v7, &v6);
  if (!(_DWORD)result && v6 != 1)
  {
    if (v9 == -1)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
    }
    else
    {
      result = 0;
      *a4 = v9;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t BinBlockStreamReader_GetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t BinBlockStreamReader_GetVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t BinBlockStreamReader_IsDataSection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  BOOL v5;
  int v6;

  v6 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 40) + 176))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40) + 208), a2, a3, a4, &v6);
  if ((_DWORD)result)
    v5 = 0;
  else
    v5 = v6 == 1;
  if (v5)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t BinBlockStreamReader_IsDataSectionInterruptible(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v9 = 0;
  result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v8, &v9, &v7, a5);
  if (!(_DWORD)result)
    *a4 = v9 != -1;
  return result;
}

BOOL BinBlockStreamReader_IsValidHeaderCRC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 148) == 0;
}

uint64_t BinBlockStreamReader_NotifyFinished(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
}

uint64_t BinBlockStreamReader_ReturnBinBlockStreamReader(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v5)(uint64_t);

  *(_DWORD *)(a1 + 128) = 0;
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 144))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224))
                                         + 32);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 144))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224));
  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnBinBlockStreamReaderInterruptible(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v5)(uint64_t);

  *(_DWORD *)(a1 + 128) = 0;
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 208))
                                         + 32);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 208));
  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnDependency(uint64_t a1, uint64_t a2)
{
  OOCAllocator_Free(*(_QWORD *)(a1 + 120), a2);
  return 0;
}

uint64_t BinBlockStreamReader_ReturnDependencyTypes(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 192))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40)
                                                                                                 + 208));
}

uint64_t BinBlockStreamReader_ReturnDependencyTypesInterruptible(uint64_t a1, uint64_t a2)
{
  OOCAllocator_Free(*(_QWORD *)(a1 + 120), a2);
  return 0;
}

uint64_t BinBlockStreamReader_ReturnRawSectionDataStreamReaderInterruptible(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 32))(a1 + 40 - *(_QWORD *)(*(_QWORD *)(a1 + 40)
                                                                                                + 208));
}

uint64_t BinBlockStreamReader_ReturnSectionDataStreamReader(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v5)(uint64_t);

  *(_DWORD *)(a1 + 128) = 0;
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 48))
                                         + 32);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 48));
  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnSectionDataStreamReaderInterruptible(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v5)(uint64_t);

  *(_DWORD *)(a1 + 128) = 0;
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 48))
                                         + 32);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 48));
  return v5(v3);
}

uint64_t _PNEW_BinBlockStreamReader_ConInternal(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v16;
  uint64_t result;
  unsigned int v18;

  v18 = 0;
  v16 = OOCAllocator_Malloc(a1, 168, &v18);
  result = v18;
  if (!v18)
  {
    result = _BinBlockStreamReader_ConInternal(v16, a2, a3, a4, a5, a6, a7);
    v18 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
      return v18;
    }
    else
    {
      *(_QWORD *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
  return result;
}

BOOL __BinBlockStreamReader_IsValidInterruptibleStatus(unsigned int a1)
{
  return a1 < 3;
}

uint64_t __BinBlockStreamReader_ReadParameterSection(_QWORD *a1)
{
  unsigned int v2;
  uint64_t result;
  char *v4;
  int v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  uint64_t v9;

  v2 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(_QWORD *)(a1[4] + 224) + 32, 987184693);
  if (v2 >= 2)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer corrupted (more than one parameter section)");
  if (v2 == 1)
  {
    v9 = 0;
    v8 = 0;
    v6 = 0;
    v7 = 0;
    v5 = 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *, int *, int *))(a1[5] + 8))((uint64_t)a1 - *(_QWORD *)(a1[5] + 208) + 40, 987184693, 0, &v9, &v8, &v5);
    if (!(_DWORD)result)
    {
      if (v5)
      {
LABEL_6:
        v4 = "Not enough data in stream";
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v4);
      }
      result = (*(uint64_t (**)(uint64_t, unsigned __int16 **, uint64_t *, int *))(*(_QWORD *)v9 + 8))(v9 - *(_QWORD *)(*(_QWORD *)v9 + 48), &v7, &v6, &v5);
      if (!(_DWORD)result)
      {
        if (v5)
          goto LABEL_6;
        result = ParamDB_LoadBinaryBuffer(a1[17], v7);
        if (!(_DWORD)result)
        {
          if (!ParamDB_GetParam(a1[17], 987249153))
          {
            v4 = "Stream interruptible status can not be UNKNOWN";
            return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v4);
          }
          return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(_QWORD *)(a1[5] + 208) + 40, v9);
        }
      }
    }
  }
  else
  {
    ParamDB_SetParam(a1[17], 987249153, 1);
    return 0;
  }
  return result;
}

uint64_t PNEW_BinBlockStreamReader_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 168, &v14);
  result = v14;
  if (!v14)
  {
    result = BinBlockStreamReader_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(_QWORD *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t DataSectionReader_Con(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8)
{
  uint64_t v16;

  v16 = RefCounted_Con((uint64_t)a1, 1);
  if (!(_DWORD)v16)
  {
    *a1 = &__DataSectionReader;
    a1[3] = &unk_1EA9375A8;
    a1[4] = &unk_1EA9375E0;
    __DataSectionReader_ConInternal((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, 0);
  }
  return v16;
}

uint64_t __DataSectionReader_ConInternal(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, int a9)
{
  uint64_t v9;
  BOOL v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;

  v9 = result;
  *(_QWORD *)(result + 96) = a3;
  *(_QWORD *)(result + 104) = a4;
  *(_DWORD *)(result + 40) = a7;
  v10 = (a8 & 1) != 0 && (__int16)a8 <= -1;
  v11 = a8 & 0x7FFE;
  v12 = !v10 || v11 == 0;
  v13 = v11 << 15;
  if (v12)
    v14 = a8;
  else
    v14 = v13;
  *(_DWORD *)(result + 72) = v14;
  if (v14 <= 0x4000)
    v15 = 0x4000;
  else
    v15 = v14;
  *(_QWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 56) = v15;
  *(_QWORD *)(result + 64) = a5;
  v16 = a6;
  *(_QWORD *)(result + 88) = a6;
  *(_QWORD *)(result + 128) = a2;
  *(_DWORD *)(result + 136) = a9;
  if (v14)
  {
    *(_QWORD *)(result + 80) = a6 - 4 * ((a6 + (unint64_t)v14 + 3) / (v14 + 4));
    result = adler3200(0, 0, 0);
    *(_DWORD *)(v9 + 120) = result;
    v14 = *(_DWORD *)(v9 + 72);
    v16 = *(_QWORD *)(v9 + 80);
  }
  else
  {
    *(_QWORD *)(result + 80) = a6;
  }
  if (v16 < v14)
    v14 = v16;
  *(_DWORD *)(v9 + 112) = v16;
  *(_DWORD *)(v9 + 116) = v14;
  return result;
}

uint64_t DataSectionReader_ConForInterruptibleStream(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8)
{
  uint64_t v16;

  v16 = RefCounted_Con((uint64_t)a1, 1);
  if (!(_DWORD)v16)
  {
    *a1 = &__DataSectionReader;
    a1[3] = &unk_1EA9375A8;
    a1[4] = &unk_1EA9375E0;
    __DataSectionReader_ConInternal((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, 1);
  }
  return v16;
}

uint64_t DataSectionReader_Des(uint64_t a1)
{
  OOCAllocator_Free(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48));
  return RefCounted_Des(a1);
}

uint64_t DataSectionReader_BorrowDataBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  int v5;

  v5 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 32) + 8))(a1 + 32 - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), a2, a3, &v5);
  if ((_DWORD)result)
    v4 = 1;
  else
    v4 = v5 == 0;
  if (!v4)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  BOOL v5;
  int v6;

  v6 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(a1 + 32 - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), a2, a3, &v6, a4);
  if ((_DWORD)result)
    v5 = 0;
  else
    v5 = v6 == 1;
  if (v5)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC check failure");
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockWithCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  BOOL v5;
  int v6;

  v6 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 32) + 16))(a1 + 32 - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), a2, a3, a4, &v6);
  if ((_DWORD)result)
    v5 = 1;
  else
    v5 = v6 == 0;
  if (!v5)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockWithCheckInterruptible(uint64_t a1, _QWORD *a2, _QWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v10;
  uint64_t result;
  uint64_t v12;
  unsigned int v13;

  v13 = 0;
  v10 = *(unsigned __int8 **)(a1 + 48);
  if (v10
    || (v10 = (unsigned __int8 *)OOCAllocator_Malloc(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 56) + 4, &v13),
        *(_QWORD *)(a1 + 48) = v10,
        (result = v13) == 0))
  {
    v12 = 0;
    result = __DataSectionReader_FillBufferWithCheck(a1, v10, *(_QWORD *)(a1 + 56), &v12, a4, a5);
    v13 = result;
    if (!(_DWORD)result)
    {
      if (*a5)
      {
        if (*(_DWORD *)(a1 + 136))
        {
          OOCAllocator_Free(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48));
          *(_QWORD *)(a1 + 48) = 0;
          return v13;
        }
        else
        {
          result = 0;
          *a4 = 0;
        }
      }
      else
      {
        result = 0;
        *a2 = *(_QWORD *)(a1 + 48);
        *a3 = v12;
      }
    }
  }
  return result;
}

uint64_t __DataSectionReader_FillBufferWithCheck(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t *a4, _DWORD *a5, _DWORD *a6)
{
  unint64_t v6;
  unint64_t v11;
  uint64_t v13;
  uint64_t ErrorCallback;
  unsigned __int8 *v15;
  unint64_t v16;
  uint64_t v17;
  char v18;
  int v19;
  unsigned __int8 *v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  _BYTE v27[4];

  *a5 = 2 * (*(_DWORD *)(a1 + 72) == 0);
  *a6 = 0;
  *a4 = 0;
  v6 = *(unsigned int *)(a1 + 112);
  if (!(_DWORD)v6)
    return 0;
  if (v6 >= a3)
    v11 = a3;
  else
    v11 = *(unsigned int *)(a1 + 112);
  if (*(_DWORD *)(a1 + 72))
  {
    v13 = 0;
    ErrorCallback = 0;
    v15 = a2;
    while (1)
    {
      if (!v11)
        goto LABEL_47;
      v16 = v11 >= *(unsigned int *)(a1 + 116) ? *(unsigned int *)(a1 + 116) : v11;
      if (*(_DWORD *)(a1 + 72) && (v11 > v16 + 4 || *(unsigned __int8 **)(a1 + 48) == a2))
      {
        v18 = 0;
        v17 = 4;
      }
      else
      {
        v17 = 0;
        v18 = 1;
      }
      if ((**(uint64_t (***)(unsigned __int8 *, uint64_t, uint64_t, _QWORD))(a1 + 96))(v15, 1, v17 + v16, *(_QWORD *)(a1 + 104)) != v17 + v16)break;
      if (*(_DWORD *)(a1 + 40))
        *(_DWORD *)(a1 + 120) = adler3200(*(_DWORD *)(a1 + 120), v15, v16);
      v19 = *(_DWORD *)(a1 + 116) - v16;
      *(_DWORD *)(a1 + 116) = v19;
      if (v19)
      {
        v13 += v16;
      }
      else
      {
        if ((v18 & 1) != 0)
        {
          v20 = v27;
          if ((**(uint64_t (***)(_BYTE *, uint64_t, uint64_t, _QWORD))(a1 + 96))(v27, 1, 4, *(_QWORD *)(a1 + 104)) != 4)
          {
            if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 96) + 16))(*(_QWORD *)(a1 + 104)))
            {
              ErrorCallback = err_GenerateErrorCallback();
              goto LABEL_34;
            }
            *a6 = 1;
            v22 = 3;
LABEL_36:
            if (v22 != 3)
              return ErrorCallback;
            goto LABEL_47;
          }
        }
        else
        {
          v20 = &v15[v16];
        }
        if (*(_DWORD *)(a1 + 40))
        {
          if (*(_DWORD *)v20 != *(_DWORD *)(a1 + 120))
          {
            *a5 = 1;
LABEL_34:
            v22 = 4;
            goto LABEL_36;
          }
          *(_DWORD *)(a1 + 120) = adler3200(0, 0, 0);
        }
        v21 = *(unsigned int *)(a1 + 72);
        v13 += v16;
        if ((unint64_t)*(unsigned int *)(a1 + 112) - v13 < v21)
          LODWORD(v21) = *(_DWORD *)(a1 + 112) - v13;
        *(_DWORD *)(a1 + 116) = v21;
      }
      v15 += v16;
      v11 -= v16;
    }
    if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 96) + 16))(*(_QWORD *)(a1 + 104)))
      return err_GenerateErrorCallback();
    *a6 = 1;
LABEL_47:
    *(_DWORD *)(a1 + 112) -= v13;
    *a4 = v13;
  }
  else
  {
    v23 = (**(uint64_t (***)(unsigned __int8 *, uint64_t, unint64_t, _QWORD))(a1 + 96))(a2, 1, v11, *(_QWORD *)(a1 + 104));
    if (v23 != v11)
    {
      if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 96) + 16))(*(_QWORD *)(a1 + 104)))
        return err_GenerateErrorCallback();
      *a6 = 1;
    }
    ErrorCallback = 0;
    *(_DWORD *)(a1 + 112) -= v23;
    *a4 = v23;
  }
  return ErrorCallback;
}

uint64_t DataSectionReader_FillData(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  result = __DataSectionReader_FillBufferWithCheck(a1, a2, *(_QWORD *)(a1 + 80), &v4, (_DWORD *)&v3 + 1, &v3);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v3) == 1)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC error");
    }
    else if ((_DWORD)v3)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DataSectionReader_FillDataInterruptible(uint64_t a1, unsigned __int8 *a2, _DWORD *a3)
{
  uint64_t result;
  int v6;
  uint64_t v7;

  v6 = 0;
  result = __DataSectionReader_FillBufferWithCheck(a1, a2, *(_QWORD *)(a1 + 80), &v7, &v6, a3);
  if (!(_DWORD)result)
  {
    if (v6 == 1)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC error");
    }
    else if (*a3 && !*(_DWORD *)(a1 + 136))
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DataSectionReader_GetDataBlockSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t DataSectionReader_GetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t PNEW_DataSectionReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, _QWORD *a9)
{
  _QWORD *v17;
  uint64_t result;
  unsigned int v19;

  v19 = 0;
  v17 = (_QWORD *)OOCAllocator_Malloc(a1, 144, &v19);
  result = v19;
  if (!v19)
  {
    result = DataSectionReader_Con(v17, a2, a3, a4, a5, a6, a7, a8);
    v19 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      v17[2] = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t PNEW_DataSectionReader_ConForInterruptibleStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, _QWORD *a9)
{
  _QWORD *v17;
  uint64_t result;
  unsigned int v19;

  v19 = 0;
  v17 = (_QWORD *)OOCAllocator_Malloc(a1, 144, &v19);
  result = v19;
  if (!v19)
  {
    result = DataSectionReader_ConForInterruptibleStream(v17, a2, a3, a4, a5, a6, a7, a8);
    v19 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      v17[2] = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t ParamDB_Con(_QWORD *a1, uint64_t a2)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    *a1 = &__ParamDB;
    a1[1] = a2;
    return PNEW_PtrList_Con(a2, a2, 0xAu, 10, a1 + 2);
  }
  return result;
}

uint64_t ParamDB_Des(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  if (kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 16)))
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(a1 + 8);
      v4 = PtrList_ItemN(*(_QWORD *)(a1 + 16), v2);
      OOCAllocator_Free(v3, v4);
      ++v2;
    }
    while (v2 < kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 16)));
  }
  result = OOC_PlacementDeleteObject(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
  if (!(_DWORD)result)
    return Object_Des();
  return result;
}

uint64_t __ParamDB_AddParam(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v13;
  uint64_t result;
  int v15;
  unsigned int v16;
  int v17;

  v16 = 0;
  v17 = a2;
  PtrList_Find(*(_QWORD *)(a1 + 16), (uint64_t)&v17, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  v13 = OOCAllocator_Malloc(*(_QWORD *)(a1 + 8), 48, &v16);
  result = v16;
  if (!v16)
  {
    v15 = v17;
    *(_QWORD *)(v13 + 16) = a6;
    *(_DWORD *)v13 = v15;
    *(_DWORD *)(v13 + 4) = a3;
    if (a6)
      *a6 = a3;
    else
      *(_DWORD *)(v13 + 8) = a3;
    *(_QWORD *)(v13 + 24) = a4;
    *(_QWORD *)(v13 + 40) = a5;
    *(_DWORD *)(v13 + 32) = a7;
    *(_DWORD *)(v13 + 36) = 0;
    return PtrList_Append(*(_QWORD *)(a1 + 16), v13);
  }
  return result;
}

uint64_t ParamDB_AddPublicParam(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, 0, 0, 1);
}

BOOL CompareItem(_DWORD **a1, _DWORD **a2)
{
  return **a1 != **a2;
}

uint64_t ParamDB_GetParam(uint64_t a1, int a2)
{
  uint64_t v2;
  unsigned int *v3;
  int v5;

  v5 = a2;
  v2 = PtrList_Find(*(_QWORD *)(a1 + 16), (uint64_t)&v5, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  v3 = *(unsigned int **)(v2 + 16);
  if (!v3)
    v3 = (unsigned int *)(v2 + 8);
  return *v3;
}

uint64_t __ParamDB_LoadParams(uint64_t a1, unsigned __int16 *a2, int a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int (*v13)(uint64_t);
  _DWORD *v14;
  uint64_t result;
  uint64_t v16;
  unsigned int i;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int (*v21)(uint64_t);
  _DWORD *v22;
  unsigned int v23;
  int v24;
  _DWORD *v25;
  int v26;
  int v27;

  v26 = 0;
  v5 = *a2;
  v6 = a2[1];
  v7 = a2 + 2;
  if (a2[1])
  {
    v8 = 0;
    v9 = &v7[4 * v5];
    do
    {
      v10 = *((unsigned int *)v9 + 1);
      v26 = *(_DWORD *)v9;
      v11 = PtrList_Find(*(_QWORD *)(a1 + 16), (uint64_t)&v26, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
      if (v11)
      {
        v12 = v11;
        v13 = *(unsigned int (**)(uint64_t))(v11 + 24);
        if (v13 && !v13(v10))
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"The paramDB buffer is corrupt");
        v14 = *(_DWORD **)(v12 + 16);
        if (v14)
          *v14 = v10;
        else
          *(_DWORD *)(v12 + 8) = v10;
        v27 = v26;
        v16 = PtrList_Find(*(_QWORD *)(a1 + 16), (uint64_t)&v27, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
        *(_DWORD *)(v16 + 4) = v10;
        *(_DWORD *)(v16 + 36) = 1;
      }
      else if (a3)
      {
        result = __ParamDB_AddParam(a1, v26, v10, (uint64_t)ParameterCheck_NoCheck, 0, 0, 0);
        if ((_DWORD)result)
          return result;
      }
      ++v8;
      v9 += 4;
    }
    while (v8 < v6);
  }
  if ((_DWORD)v5)
  {
    for (i = 0; i < v5; ++i)
    {
      v18 = *((unsigned int *)v7 + 1);
      v26 = *(_DWORD *)v7;
      v19 = PtrList_Find(*(_QWORD *)(a1 + 16), (uint64_t)&v26, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
      if (v19)
      {
        v20 = v19;
        v21 = *(unsigned int (**)(uint64_t))(v19 + 24);
        if (v21 && !v21(v18))
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"The paramDB buffer is corrupt");
        v22 = *(_DWORD **)(v20 + 16);
        if (v22)
          *v22 = v18;
        else
          *(_DWORD *)(v20 + 8) = v18;
      }
      else if (a3)
      {
        result = __ParamDB_AddParam(a1, v26, v18, (uint64_t)ParameterCheck_NoCheck, 0, 0, 0);
        if ((_DWORD)result)
          return result;
      }
      v7 += 4;
    }
  }
  if (!v6)
  {
    result = kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 16));
    if (!(_DWORD)result)
      return result;
    v23 = 0;
    v24 = 0;
    do
    {
      v25 = (_DWORD *)PtrList_ItemN(*(_QWORD *)(a1 + 16), v23);
      if (!v25[8])
        v25[1] = v25[2];
      v23 = (unsigned __int16)++v24;
    }
    while (kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 16)) > (unsigned __int16)v24);
  }
  return 0;
}

uint64_t ParamDB_LoadBinaryBuffer(uint64_t a1, unsigned __int16 *a2)
{
  return __ParamDB_LoadParams(a1, a2, 0);
}

uint64_t ParamDB_SetParam(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  _DWORD *v5;
  int v6;

  v6 = a2;
  result = PtrList_Find(*(_QWORD *)(a1 + 16), (uint64_t)&v6, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  v5 = *(_DWORD **)(result + 16);
  if (v5)
    *v5 = a3;
  else
    *(_DWORD *)(result + 8) = a3;
  return result;
}

uint64_t PNEW_ParamDB_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 24, &v8);
  result = v8;
  if (!v8)
  {
    result = ParamDB_Con(v6, a2);
    v8 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t ParameterCheck_NoCheck()
{
  return 1;
}

uint64_t NullLogger_GetTimerMs(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t NullLogger_IsEnabled()
{
  return 0;
}

uint64_t NullLogger_LogBinaryData()
{
  return 0;
}

uint64_t NullLogger_LogTextArg0()
{
  return 0;
}

uint64_t NullLogger_LogTextArg1()
{
  return 0;
}

uint64_t NullLogger_LogTextArg2()
{
  return 0;
}

uint64_t NullLogger_LogTextArg3()
{
  return 0;
}

uint64_t NullLogger_LogTextArg4()
{
  return 0;
}

uint64_t NullLogger_LogTextArgVar()
{
  return 0;
}

uint64_t PNEW_NullLogger_Con(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t result;
  unsigned int v6;

  v6 = 0;
  v4 = (_QWORD *)OOCAllocator_Malloc(a1, 32, &v6);
  result = v6;
  if (!v6)
  {
    result = RefCounted_Con((uint64_t)v4, 1);
    if ((_DWORD)result)
    {
      v6 = result;
      OOCAllocator_Free(a1, (uint64_t)v4);
      *a2 = 0;
      return v6;
    }
    else
    {
      *v4 = &__NullLogger;
      v4[2] = a1;
      v4[3] = &unk_1EA937B70;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t lhstdlib_qsort(uint64_t result, unsigned int a2, unsigned int a3, uint64_t (*a4)(_BYTE *, _BYTE *))
{
  unsigned int v4;
  _BYTE *v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  _BYTE *v14;
  char v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  char v27;
  uint64_t v28;
  char v29;
  _BYTE *v30;
  _BYTE *v31;
  uint64_t v32;
  char v33;
  BOOL v34;
  BOOL v35;
  unint64_t v36;
  int v37;
  uint64_t v38;
  _BYTE *v40;
  int v41;
  _BYTE *v42;
  uint64_t v43;
  _OWORD v44[15];
  _OWORD v45[15];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (a2 >= 2)
  {
    v4 = a3;
    if (a3)
    {
      v6 = (_BYTE *)result;
      v7 = 0;
      memset(v45, 0, sizeof(v45));
      memset(v44, 0, sizeof(v44));
      v8 = result + (a2 - 1) * a3;
      v9 = a3;
      v43 = -(uint64_t)a3;
      v38 = -2 * a3;
      v37 = -2 * a3;
      v36 = ~(unint64_t)a3;
      v10 = -a3;
      while (1)
      {
        v11 = ((int)v8 - (int)v6) / v4 + 1;
        if (v11 < 9)
          break;
        v41 = v7;
        v40 = &v6[v9];
        while (1)
        {
          v12 = (v11 >> 1) * v4;
          if ((_DWORD)v12)
          {
            v13 = v4;
            v14 = v6;
            do
            {
              v15 = v14[v12];
              v14[v12] = *v14;
              *v14++ = v15;
              --v13;
            }
            while (v13);
          }
          v16 = (_BYTE *)(v8 + v9);
          v17 = v6;
          while (1)
          {
            v18 = v17;
            v19 = v9;
            do
            {
              v20 = v19;
              v17 = &v18[v19];
              if ((unint64_t)&v18[v19] > v8)
                break;
              result = a4(&v18[v19], v6);
              v19 = v20 + v9;
            }
            while ((int)result < 1);
            v21 = 0;
            v42 = v16;
            v22 = (unint64_t)&v16[v43];
            do
            {
              v23 = (_BYTE *)v22;
              v24 = v21;
              if (v22 <= (unint64_t)v6)
                break;
              result = a4((_BYTE *)v22, v6);
              v22 = (unint64_t)&v23[v43];
              v21 = v24 + v9;
            }
            while ((result & 0x80000000) == 0);
            if (v23 < v17)
              break;
            v16 = v23;
            if (v23 != v17)
            {
              v25 = 0;
              v26 = &v18[v20];
              do
              {
                v27 = v26[v25];
                v26[v25] = v23[v25];
                v23[v25++] = v27;
              }
              while (v10 + (_DWORD)v25);
              v16 = v23;
            }
          }
          if (v23 != v6)
          {
            v28 = 0;
            do
            {
              v29 = v6[v28];
              v6[v28] = v23[v28];
              v23[v28++] = v29;
            }
            while ((_DWORD)v9 != (_DWORD)v28);
          }
          if ((uint64_t)&v42[v36 - (_QWORD)v6 - v24] >= (uint64_t)(v8 - (_QWORD)v18 - v20))
            break;
          if ((unint64_t)&v18[v20] < v8)
          {
            *((_QWORD *)v45 + v41) = &v18[v20];
            *((_QWORD *)v44 + v41++) = v8;
          }
          v4 = a3;
          if (v40 >= v23)
          {
            v7 = v41;
            goto LABEL_47;
          }
          v8 = (unint64_t)&v42[v38 - v24];
          v11 = (v37 - (int)v6 + (int)v42 - (int)v24) / a3 + 1;
          if (v11 < 9)
          {
            v7 = v41;
            goto LABEL_30;
          }
        }
        if (v40 >= v23)
        {
          v7 = v41;
        }
        else
        {
          *((_QWORD *)v45 + v41) = v6;
          *((_QWORD *)v44 + v41) = &v42[v38 - v24];
          v7 = v41 + 1;
        }
        v6 = &v18[v20];
        v34 = (unint64_t)&v18[v20] >= v8;
        v4 = a3;
        if (v34)
        {
LABEL_47:
          v35 = __OFSUB__(v7--, 1);
          if (v7 < 0 != v35)
            return result;
          v6 = (_BYTE *)*((_QWORD *)v45 + v7);
          v8 = *((_QWORD *)v44 + v7);
        }
      }
LABEL_30:
      while (v8 > (unint64_t)v6)
      {
        v30 = v6;
        if ((unint64_t)&v6[v9] <= v8)
        {
          v31 = &v6[v9];
          v30 = v6;
          do
          {
            result = a4(v31, v30);
            if ((int)result > 0)
              v30 = v31;
            v31 += v9;
          }
          while ((unint64_t)v31 <= v8);
        }
        if (v30 != (_BYTE *)v8)
        {
          v32 = 0;
          do
          {
            v33 = v30[v32];
            v30[v32] = *(_BYTE *)(v8 + v32);
            *(_BYTE *)(v8 + v32++) = v33;
          }
          while ((_DWORD)v9 != (_DWORD)v32);
        }
        v8 += v43;
      }
      goto LABEL_47;
    }
  }
  return result;
}

uint64_t lhstdlib_udqsort(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t (*a5)(char *, char *, uint64_t))
{
  uint64_t v8;
  int v9;
  unsigned int v10;
  char *v11;
  char *v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  int v16;
  unsigned int v17;
  char *v18;
  char v19;
  unsigned int v20;
  char *v21;
  char *v22;
  char v23;
  int v24;
  unsigned int v25;
  char *v26;
  char v27;
  char *v28;
  char *v29;
  unsigned int v30;
  char *v31;
  char *v32;
  char v33;
  char *v34;
  BOOL v35;
  char *v36;
  char *v37;
  uint64_t v38;
  char v39;
  int v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 >= 2 && a3)
  {
    v71 = 0u;
    v70 = 0u;
    v69 = 0u;
    v68 = 0u;
    v67 = 0u;
    v66 = 0u;
    v65 = 0u;
    v64 = 0u;
    v63 = 0u;
    v62 = 0u;
    v61 = 0u;
    v60 = 0u;
    v59 = 0u;
    v58 = 0u;
    v42 = 0u;
    v43 = 0u;
    v44 = 0u;
    v45 = 0u;
    v46 = 0u;
    v47 = 0u;
    v48 = 0u;
    v50 = 0u;
    v51 = 0u;
    v52 = 0u;
    v53 = 0u;
    v54 = 0u;
    v55 = 0u;
    v56 = 0;
    v57 = result;
    v8 = a3;
    v72 = 0;
    v41 = result + (a2 - 1) * a3;
    v9 = 1;
    v49 = 0u;
    while (1)
    {
      v10 = v9 - 1;
      v11 = (char *)*(&v57 + v10);
      v40 = v10;
      v12 = (char *)*(&v41 + v10);
      v13 = ((int)v12 - (int)v11) / a3 + 1;
      if (v13 >= 9)
        break;
      v28 = v12;
LABEL_44:
      while (v28 > v11)
      {
        v36 = v11;
        if (&v11[a3] <= v28)
        {
          v37 = &v11[v8];
          v36 = v11;
          do
          {
            result = a5(v37, v36, a4);
            if ((int)result > 0)
              v36 = v37;
            v37 += a3;
          }
          while (v37 <= v28);
        }
        if (v36 != v28)
        {
          v38 = 0;
          do
          {
            v39 = v36[v38];
            v36[v38] = v28[v38];
            v28[v38++] = v39;
          }
          while ((_DWORD)v8 != (_DWORD)v38);
        }
        v28 -= a3;
      }
      v9 = v40;
      if (v40 <= 0)
        return result;
    }
    while (1)
    {
      v14 = (v13 >> 1) * a3;
      v15 = &v11[v14];
      v16 = a5(&v11[v14], v11, a4);
      if ((_DWORD)v14 && v16 < 0)
      {
        v17 = a3;
        v18 = v11;
        do
        {
          v19 = v18[v14];
          v18[v14] = *v18;
          *v18++ = v19;
          --v17;
        }
        while (v17);
      }
      if ((a5(v12, &v11[v14], a4) & 0x80000000) != 0 && v15 != v12)
      {
        v20 = a3;
        v21 = v12;
        v22 = &v11[v14];
        do
        {
          v23 = *v22;
          *v22++ = *v21;
          *v21++ = v23;
          --v20;
        }
        while (v20);
      }
      v24 = a5(&v11[v14], v11, a4);
      if ((_DWORD)v14 && v24 < 0)
      {
        v25 = a3;
        v26 = v11;
        do
        {
          v27 = v26[v14];
          v26[v14] = *v26;
          *v26++ = v27;
          --v25;
        }
        while (v25);
      }
      v28 = &v11[a3];
      v29 = &v12[-a3];
      do
      {
        while ((a5(v28, v15, a4) & 0x80000000) != 0)
          v28 += a3;
        result = a5(v29, v15, a4);
        if ((int)result >= 1)
        {
          do
          {
            v29 -= a3;
            result = a5(v29, v15, a4);
          }
          while ((int)result > 0);
        }
        if (v28 <= v29)
        {
          if (v28 != v29)
          {
            v30 = a3;
            v31 = v29;
            v32 = v28;
            do
            {
              v33 = *v32;
              *v32++ = *v31;
              *v31++ = v33;
              --v30;
            }
            while (v30);
          }
          if (v15 == v29)
            v34 = v28;
          else
            v34 = v15;
          if (v15 == v28)
            v15 = v29;
          else
            v15 = v34;
          v28 += a3;
          v29 -= a3;
        }
      }
      while (v28 <= v29);
      if (v29 - v11 > v12 - v28)
        break;
      v29 = v12;
      v35 = v28 >= v12;
      v12 = v28;
      if (!v35)
        goto LABEL_39;
LABEL_41:
      v13 = ((int)v28 - (int)v11) / a3 + 1;
      v12 = v28;
      if (v13 <= 8)
        goto LABEL_44;
    }
    v28 = v11;
    v35 = v11 >= v29;
    v11 = v29;
    if (v35)
    {
      v11 = v29;
    }
    else
    {
LABEL_39:
      *(&v57 + v40) = (uint64_t)v28;
      *(&v41 + v40++) = (uint64_t)v29;
    }
    v28 = v12;
    goto LABEL_41;
  }
  return result;
}

unint64_t lhstdlib_bsearch(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, unint64_t), _DWORD *a6)
{
  uint64_t v8;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  _DWORD *v22;

  v8 = (a3 - 1) * a4;
  if (v8 < 0)
  {
    v19 = 0;
    v12 = a2;
    goto LABEL_20;
  }
  v22 = a6;
  v11 = a2 + v8;
  v12 = a2;
  while (a3 < 2)
  {
    if (!a3)
      goto LABEL_15;
    v13 = a5(a1, v12);
    if (!v13)
    {
      v19 = v12;
      goto LABEL_19;
    }
    v14 = v12 + a4;
    v15 = v11 - a4;
    v16 = v13 >= 0;
    a3 = 1;
LABEL_11:
    if (v16)
      v12 = v14;
    else
      v11 = v15;
    if (v12 > v11)
    {
LABEL_15:
      v19 = 0;
      goto LABEL_19;
    }
  }
  v17 = a3 >> 1;
  v18 = (a3 & 1) + (a3 >> 1) - 1;
  v19 = v12 + v18 * a4;
  v20 = a5(a1, v19);
  if (v20)
  {
    v14 = v19 + a4;
    v15 = v19 - a4;
    v16 = v20 >= 0;
    if (v20 < 0)
      a3 = v18;
    else
      a3 = v17;
    goto LABEL_11;
  }
  v12 += v18 * a4;
LABEL_19:
  a6 = v22;
LABEL_20:
  *a6 = (v12 - a2) / a4;
  return v19;
}

uint64_t utf8_str_to_utf16(uint64_t a1, char *__s, uint64_t *a3, unint64_t *a4)
{
  size_t v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  _WORD *v12;
  _WORD *v14;
  _WORD *v16;
  unsigned __int8 *v17;
  unsigned int v18;

  v18 = 0;
  v8 = strlen(__s);
  v17 = (unsigned __int8 *)__s;
  if (!v8)
  {
    v14 = (_WORD *)*a3;
    if (!*a3)
    {
      if (!a1)
        return err_GenerateErrorLimit();
      v14 = (_WORD *)OOCAllocator_Malloc(a1, 2, &v18);
      *a3 = (uint64_t)v14;
      if (v18)
        return v18;
      *a4 = 2;
    }
    *v14 = 0;
    return v18;
  }
  v9 = v8;
  v10 = utf8_utf16_byte_count(&v17);
  if (v10 == -1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  v11 = v10;
  if (v10 < *a4)
  {
    v12 = (_WORD *)*a3;
    goto LABEL_5;
  }
  if (!a1)
    return err_GenerateErrorLimit();
  v12 = (_WORD *)OOCAllocator_Realloc(a1, *a3, v10 + 2, &v18);
  *a3 = (uint64_t)v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    v16 = v12;
    v17 = (unsigned __int8 *)__s;
    if (!utf8_to_utf16((char **)&v17, (unint64_t)&__s[v9], &v16, (unint64_t)v12 + v11))
    {
      *v16 = 0;
      return v18;
    }
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  }
  return v18;
}

uint64_t utf16_str_to_utf8(uint64_t a1, unsigned __int16 *a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _BYTE *v14;
  _BYTE *v16;
  unsigned __int16 *v17;
  unsigned int v18;

  v18 = 0;
  v8 = utf16_byte_count(a2);
  v17 = a2;
  if (!v8)
  {
    v14 = (_BYTE *)*a3;
    if (!*a3)
    {
      if (!a1)
        return err_GenerateErrorLimit();
      v14 = (_BYTE *)OOCAllocator_Malloc(a1, 1, &v18);
      *a3 = (uint64_t)v14;
      if (v18)
        return v18;
      *a4 = 1;
    }
    *v14 = 0;
    return v18;
  }
  v9 = v8;
  v10 = utf16_utf8_byte_count(&v17);
  if (v10 == -1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  v11 = v10;
  if (v10 < *a4)
  {
    v12 = *a3;
    goto LABEL_5;
  }
  if (!a1)
    return err_GenerateErrorLimit();
  v12 = OOCAllocator_Realloc(a1, *a3, v10 + 1, &v18);
  *a3 = v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    v16 = (_BYTE *)v12;
    v17 = a2;
    if (!utf16_to_utf8(&v17, (char *)a2 + v9, &v16, v12 + v11))
    {
      *v16 = 0;
      return v18;
    }
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  }
  return v18;
}

uint64_t utf8_to_utf16(char **a1, unint64_t a2, _WORD **a3, unint64_t a4)
{
  return priv_utf8_to_utf16(a1, a2, a3, a4, 0);
}

uint64_t priv_utf8_to_utf16(char **a1, unint64_t a2, _WORD **a3, unint64_t a4, _QWORD *a5)
{
  char *v5;
  _WORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  v5 = *a1;
  if (a3)
    v6 = *a3;
  else
    v6 = 0;
  if ((unint64_t)v5 < a2)
  {
    v7 = 0;
    while (1)
    {
      v8 = *v5;
      v9 = trailing_bytes_for_utf8_start_byte[v8];
      if (v9 == -1)
        goto LABEL_44;
      if ((unint64_t)&v5[v9] >= a2)
      {
        v19 = 2;
        goto LABEL_45;
      }
      if ((v8 & 0xF8) == 0xF0)
      {
        v10 = v5[1];
        if (v10 > -65)
          goto LABEL_40;
        v11 = v5[2];
        if (v11 > -65)
        {
LABEL_41:
          v5 += 2;
          goto LABEL_44;
        }
        v12 = v5[3];
        if (v12 > -65)
        {
          v5 += 3;
          goto LABEL_44;
        }
        v5 += 4;
        v8 = v12
           + ((((unint64_t)v10 << 6) + (v8 << 12) + v11) << 6);
      }
      else if ((v8 & 0xF0) == 0xE0)
      {
        v13 = v5[1];
        if (v13 > -65)
        {
LABEL_40:
          ++v5;
          goto LABEL_44;
        }
        v14 = v5[2];
        if (v14 > -65)
          goto LABEL_41;
        v5 += 3;
        v8 = ((unint64_t)v13 << 6) + (v8 << 12) + v14;
      }
      else if ((v8 & 0xE0) == 0xC0)
      {
        v15 = v5[1];
        if (v15 > -65)
        {
          v19 = 1;
          ++v5;
          goto LABEL_45;
        }
        v5 += 2;
        v8 = v15 + (v8 << 6);
      }
      else
      {
        ++v5;
      }
      v16 = v8 - priv_utf8_to_utf16_shifted_utf8_marks[v9];
      if (v16 >> 16)
      {
        if (v16 >> 16 > 0x10)
        {
LABEL_38:
          v5 += (char)~(_BYTE)v9;
LABEL_44:
          v19 = 1;
          goto LABEL_45;
        }
        v17 = v16 & 0x3FF | 0xDC00;
        LODWORD(v16) = ((v16 + 67043328) >> 10) - 10240;
        if (v6)
        {
LABEL_27:
          if (v17)
            v18 = 2;
          else
            v18 = 1;
          if ((unint64_t)&v6[v18] > a4)
          {
            v5 += ~(_DWORD)v9;
            v19 = 3;
            goto LABEL_45;
          }
          *v6 = v16;
          if (v17)
          {
            v6[1] = v17;
            v6 += 2;
          }
          else
          {
            ++v6;
          }
        }
      }
      else
      {
        if ((v16 | 0x400) >> 10 == 55)
          goto LABEL_38;
        v17 = 0;
        if (v6)
          goto LABEL_27;
      }
      ++v7;
      if ((unint64_t)v5 >= a2)
        goto LABEL_37;
    }
  }
  v7 = 0;
LABEL_37:
  v19 = 0;
LABEL_45:
  *a1 = v5;
  if (a3)
    *a3 = v6;
  if (a5)
    *a5 = v7;
  return v19;
}

uint64_t priv_utf16_to_utf8(unsigned __int16 **a1, unint64_t a2, _BYTE **a3, unint64_t a4)
{
  unsigned __int16 *v4;
  _BYTE *v5;
  unsigned __int16 *v6;
  unint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *a1;
  if (a3)
    v5 = *a3;
  else
    v5 = 0;
  if ((unint64_t)v4 >= a2)
  {
    v14 = 0;
    goto LABEL_37;
  }
  v6 = *a1;
  while (1)
  {
    v8 = *v6++;
    v7 = v8;
    v9 = v8 & 0xFC00;
    if (v9 == 55296)
      break;
    if (v9 == 56320)
      goto LABEL_32;
    if (v5)
      goto LABEL_13;
LABEL_29:
    v4 = v6;
    if ((unint64_t)v6 >= a2)
    {
      v14 = 0;
      v4 = v6;
      goto LABEL_37;
    }
  }
  if ((unint64_t)v6 >= a2)
  {
    v14 = 2;
    goto LABEL_37;
  }
  v10 = *v6;
  if ((v10 & 0xFC00) != 0xDC00)
  {
LABEL_32:
    v14 = 1;
    goto LABEL_37;
  }
  v7 = (v10 - 56320) + (v7 << 10) - 56557568;
  v6 = v4 + 2;
  if (!v5)
    goto LABEL_29;
LABEL_13:
  if (v7 < 0x80)
  {
    if ((unint64_t)(v5 + 1) > a4)
      goto LABEL_33;
    LODWORD(v11) = 0;
    *v5 = v7;
    goto LABEL_28;
  }
  if (v7 < 0x10000)
    v11 = 2;
  else
    v11 = 3;
  if (v7 <= 0x7FF)
    v12 = 1;
  else
    v12 = v11;
  v13 = &v5[v12];
  if ((unint64_t)(v13 + 1) <= a4)
  {
    *v13 = v7 & 0x3F | 0x80;
    if (v7 <= 0x7FF)
    {
      *(v13 - 1) = (v7 >> 6) | 0xC0;
      LODWORD(v11) = 1;
    }
    else
    {
      *(v13 - 1) = (v7 >> 6) & 0x3F | 0x80;
      if ((v7 - 2048) >> 11 > 0x1E)
      {
        *(v13 - 2) = (v7 >> 12) & 0x3F | 0x80;
        *(v13 - 3) = (v7 >> 18) | 0xF0;
      }
      else
      {
        *(v13 - 2) = (v7 >> 12) | 0xE0;
      }
    }
LABEL_28:
    v5 += (v11 + 1);
    goto LABEL_29;
  }
LABEL_33:
  v15 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 >> 16)
    v15 = 0x7FFFFFFFFFFFFFFELL;
  v4 = &v6[v15];
  v14 = 3;
LABEL_37:
  *a1 = v4;
  if (a3)
    *a3 = v5;
  return v14;
}

uint64_t utf16_utf8_byte_count(unsigned __int16 **a1)
{
  _WORD *v1;
  _WORD *v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;

  v1 = *a1;
  v2 = *a1 + 1;
  v3 = **a1;
  if (**a1)
  {
    v4 = 0;
    while (1)
    {
      if (v3 > 0x7F)
      {
        if (v3 > 0x7FF)
        {
          if (v3 >> 11 <= 0x1A)
            goto LABEL_12;
          if (v3 >> 10 > 0x36)
          {
            if (v3 < 0xE000)
            {
LABEL_17:
              v4 = -1;
              v2 = v1;
              goto LABEL_16;
            }
LABEL_12:
            v4 += 3;
            goto LABEL_13;
          }
          if ((*v2 & 0xFC00) != 0xDC00)
            goto LABEL_17;
          v4 += 4;
          v2 = v1 + 2;
        }
        else
        {
          v4 += 2;
        }
      }
      else
      {
        ++v4;
      }
LABEL_13:
      v1 = v2;
      v5 = (unsigned __int16)*v2++;
      v3 = v5;
      if (!v5)
        goto LABEL_16;
    }
  }
  v4 = 0;
LABEL_16:
  *a1 = v2;
  return v4;
}

uint64_t utf8_utf16_byte_count(unsigned __int8 **a1)
{
  uint64_t v1;
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  v1 = 0;
  v2 = *a1;
  while (1)
  {
    v3 = v2;
    v6 = *v2;
    v4 = v2 + 1;
    v5 = v6;
    if (!v6)
      break;
    v7 = trailing_bytes_for_utf8_start_byte[v5];
    if ((v5 & 0xF8) == 0xF0)
      v8 = 4;
    else
      v8 = 2;
    v1 += v8;
    v2 = &v4[v7];
    if (v7 == -1)
    {
      v1 = -1;
      goto LABEL_9;
    }
  }
  v3 = v4;
LABEL_9:
  *a1 = v3;
  return v1;
}

uint64_t utf8full_check(char **a1, unint64_t a2)
{
  return priv_utf8_to_utf16(a1, a2, 0, 0, 0);
}

uint64_t utf16_byte_count(_WORD *a1)
{
  __int16 v1;
  uint64_t result;
  unsigned __int16 *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v1 = *a1;
  if (!*a1)
    return 0;
  result = 0;
  v4 = a1 + 1;
  do
  {
    v5 = v1 & 0xFC00;
    if (v5 == 55296)
      v6 = 4;
    else
      v6 = 2;
    if (v5 == 56320)
      v7 = 0;
    else
      v7 = v6;
    result += v7;
    v8 = *v4++;
    v1 = v8;
  }
  while (v8);
  return result;
}

uint64_t catParseFormatString(char *a1, char *a2, _QWORD *a3, _BYTE *a4)
{
  size_t v8;
  uint64_t result;
  size_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char v15;
  char __s1[13];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v8 = strlen(a1);
  if (v8 - 13 < 0xFFFFFFFFFFFFFFF4)
    return 0xFFFFFFFFLL;
  v10 = v8;
  *a4 = a1[v8 - 1];
  v11 = strpbrk(a1, "123456789");
  if (v11)
  {
    v12 = &a1[v10 + ~(unint64_t)v11];
    __memcpy_chk();
    __s1[(_QWORD)v12] = 0;
    v13 = atoi(__s1);
  }
  else
  {
    v13 = 0;
  }
  *a3 = v13;
  __s1[0] = *a1;
  __s1[1] = 0;
  v14 = strpbrk(__s1, "-+0 #");
  if (v14)
    v15 = *v14;
  else
    v15 = 32;
  result = 0;
  *a2 = v15;
  return result;
}

size_t catUnsignedLongToASCII(char *__s, int a2, unint64_t a3, unsigned int a4, int a5, unint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v13;
  char v14;
  int v15;
  char v16;
  BOOL v17;
  uint64_t v18;
  const char *v19;
  size_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;
  char *v24;
  _BYTE v26[19];
  char v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v28 = 0;
  if (a4)
  {
    v13 = 0;
    if (a5)
      v14 = 55;
    else
      v14 = 87;
    do
    {
      v15 = a3 % a4;
      if (v15 << 24 >= 167772160)
        v16 = v14;
      else
        v16 = 48;
      v26[v13-- + 19] = v16 + v15;
      v17 = a3 >= a4;
      a3 /= a4;
    }
    while (v17);
    v18 = -v13;
    v19 = &v28 + v13;
    if (__s)
    {
LABEL_10:
      v20 = strlen(__s);
      v21 = v20 + v18;
      goto LABEL_15;
    }
  }
  else
  {
    if (a3 > 0xFF)
      return 4294967293;
    v19 = &v27;
    v27 = a3;
    v18 = 1;
    if (__s)
      goto LABEL_10;
  }
  v20 = 0;
  v21 = v18;
LABEL_15:
  if (a6 >= v20 + v18)
    v23 = a6 - (v20 + v18);
  else
    v23 = 0;
  v22 = v23 + v21;
  if (a7)
  {
    if (a8 - (uint64_t)a7 <= v22)
    {
      return 4294967294;
    }
    else
    {
      if (a2 == 32)
      {
        memset(a7, 32, v23);
        v24 = &a7[v23];
        if (__s)
        {
          memcpy(v24, __s, v20);
          v24 += v20;
        }
      }
      else
      {
        if (__s)
        {
          memcpy(a7, __s, v20);
          a7 += v20;
        }
        memset(a7, a2, v23);
        v24 = &a7[v23];
      }
      strcpy(v24, v19);
    }
  }
  return v22;
}

size_t spr_pcat(void *a1, uint64_t a2, char *a3, const char *a4)
{
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  __int16 v12;

  v12 = 0;
  v11 = 0;
  if ((catParseFormatString(a3, (char *)&v12 + 1, &v11, &v12) & 0x80000000) == 0)
  {
    if ((char)v12 == 115)
    {
      if ((SHIBYTE(v12) | 0x10) == 0x30)
      {
        v8 = strlen(a4);
        if (v8 <= v11)
          v9 = v11;
        else
          v9 = v8;
        if (v11 >= v8)
          v10 = v11 - v8;
        else
          v10 = 0;
        if (a1)
        {
          if (a2 - (uint64_t)a1 <= v9)
          {
            return 4294967294;
          }
          else
          {
            memset(a1, HIBYTE(v12), v10);
            strcpy((char *)a1 + v10, a4);
          }
        }
        return v9;
      }
    }
    else if ((char)v12 == 112)
    {
      return catUnsignedLongToASCII(0, 48, (unint64_t)a4, 0x10u, 1, 0x10uLL, (char *)a1, a2);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t spr_pcat_noerr(void *a1, uint64_t a2, char *a3, const char *a4)
{
  uint64_t result;

  LODWORD(result) = spr_pcat(a1, a2, a3, a4);
  if ((_DWORD)result == -2)
    return 0;
  else
    return result;
}

uint64_t LHString_Con(_QWORD *a1, uint64_t a2)
{
  return LHString_ConFromCPtr(a1, a2, gc_szEmptyString);
}

uint64_t LHString_ConFromCPtr(_QWORD *a1, uint64_t a2, const char *a3)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    *a1 = &__LHString;
    return LHString_ConFromCPtrInterval((uint64_t)a1, a2, a3, 0);
  }
  return result;
}

uint64_t LHString_ConFromCPtrInterval(uint64_t a1, uint64_t a2, const char *a3, const char *a4)
{
  uint64_t result;
  int v9;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__LHString;
    *(_QWORD *)(a1 + 24) = a2;
    result = __LHString_GetCopy(a1, a3, a4, (char **)(a1 + 8));
    if (!(_DWORD)result)
    {
      v9 = strlen(*(const char **)(a1 + 8));
      result = 0;
      *(_QWORD *)(a1 + 16) = (v9 + 1);
    }
  }
  return result;
}

uint64_t __LHString_GetCopy(uint64_t a1, const char *a2, const char *a3, char **a4)
{
  const char *v6;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  char *v10;
  unsigned int v12;

  if (a2)
    v6 = a2;
  else
    v6 = (const char *)&gc_szEmptyString;
  if (!a3)
    a3 = &v6[strlen(v6)];
  v12 = 0;
  v7 = (_DWORD)a3 - (_DWORD)v6;
  v8 = (char *)OOCAllocator_Malloc(*(_QWORD *)(a1 + 24), ((_DWORD)a3 - (_DWORD)v6 + 1), &v12);
  v9 = v12;
  if (!v12)
  {
    v10 = strncpy(v8, v6, v7);
    v10[v7] = 0;
    *a4 = v10;
    return v12;
  }
  return v9;
}

uint64_t LHString_Reserve(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;

  result = 0;
  v8 = 0;
  if (*(_DWORD *)(a1 + 16) >= a2)
    goto LABEL_4;
  v7 = OOCAllocator_Realloc(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 8), a2, &v8);
  *(_QWORD *)(a1 + 8) = v7;
  if (v7)
  {
    *(_DWORD *)(a1 + 16) = a2;
    result = v8;
LABEL_4:
    *(_DWORD *)(a1 + 20) = a3;
    return result;
  }
  return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
}

uint64_t LHString_Des(uint64_t *a1)
{
  OOCAllocator_Free(a1[3], a1[1]);
  a1[2] = 0;
  return Object_Des();
}

uint64_t LHString_Append(uint64_t a1, const char *a2)
{
  const char *v3;

  v3 = a2;
  return LHString_AppendEx(a1, &v3, 1u);
}

uint64_t LHString_AppendEx(uint64_t a1, const char **a2, unsigned int a3)
{
  const char **v4;
  int v6;
  uint64_t v7;
  const char **v8;
  unsigned int v9;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  size_t v18;
  size_t v19;

  v4 = a2;
  v6 = 0;
  if (a3)
  {
    v7 = a3;
    v8 = a2;
    do
    {
      if (*v8)
        v6 += strlen(*v8);
      ++v8;
      --v7;
    }
    while (v7);
  }
  v9 = strlen(*(const char **)(a1 + 8));
  if (v9 == -1 || v9 >= ~v6)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"string too long");
  v12 = v6 + v9 + 1;
  while (1)
  {
    v13 = *(_DWORD *)(a1 + 16);
    if (v12 <= v13)
      break;
    v14 = *(_DWORD *)(a1 + 20);
    v15 = v14 + v13;
    if (v14)
      v16 = v15;
    else
      v16 = v12;
    result = LHString_Reserve(a1, v16, v14);
    if ((_DWORD)result)
      return result;
  }
  if (a3)
  {
    v17 = a3;
    do
    {
      if (*v4)
      {
        v18 = strlen(*v4);
        if (v18)
        {
          v19 = v18;
          if (v18 + strlen(*(const char **)(a1 + 8)) < *(unsigned int *)(a1 + 16))
            strncat(*(char **)(a1 + 8), *v4, v19);
        }
      }
      ++v4;
      --v17;
    }
    while (v17);
  }
  return 0;
}

size_t LHString_Length(uint64_t a1)
{
  return strlen(*(const char **)(a1 + 8));
}

uint64_t LHString_Erase(uint64_t a1)
{
  return LHString_SetContentFromNCPtr(a1, gc_szEmptyString, 0);
}

uint64_t LHString_SetContentFromCPtr(uint64_t a1, char *__s)
{
  unsigned int v4;

  v4 = strlen(__s);
  return LHString_SetContentFromNCPtr(a1, __s, v4);
}

uint64_t LHString_SetContentFromNCPtr(uint64_t a1, const char *a2, unsigned int a3)
{
  size_t v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t result;

  v6 = a3 + 1;
  while (1)
  {
    v7 = *(_DWORD *)(a1 + 16);
    if (v6 <= v7)
      break;
    v8 = *(_DWORD *)(a1 + 20);
    v9 = v8 + v7;
    if (v8)
      v10 = v9;
    else
      v10 = v6;
    result = LHString_Reserve(a1, v10, v8);
    if ((_DWORD)result)
      return result;
  }
  bzero(*(void **)(a1 + 8), v6);
  strncpy(*(char **)(a1 + 8), a2, a3);
  return 0;
}

uint64_t LHString_Split(uint64_t a1, char *__s2, uint64_t a3)
{
  char *v3;
  char *v7;
  uint64_t result;
  uint64_t v9;

  v3 = *(char **)(a1 + 8);
  if (!*v3)
    return 0;
  v9 = 0;
  while (1)
  {
    v7 = strstr(v3, __s2);
    result = PNEW_LHString_ConFromCPtrInterval(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24), v3, v7, &v9);
    if ((_DWORD)result)
      break;
    if (**(_BYTE **)(v9 + 8))
    {
      result = PtrList_Append(a3, v9);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      result = OOC_PlacementDeleteObject(*(_QWORD *)(a1 + 24), v9);
      if ((_DWORD)result)
        return result;
    }
    v3 = v7 + 1;
    if (!v7)
      return 0;
  }
  return result;
}

uint64_t PNEW_LHString_ConFromCPtrInterval(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t result;
  unsigned int v12;

  v12 = 0;
  v10 = OOCAllocator_Malloc(a1, 32, &v12);
  result = v12;
  if (!v12)
  {
    result = LHString_ConFromCPtrInterval(v10, a2, a3, a4);
    v12 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetLHStringClass()
{
  return &__LHString;
}

uint64_t lhi_IsValidLanguageString(uint64_t result)
{
  uint64_t v1;
  size_t v2;
  unint64_t v3;
  int v4;

  if (result)
  {
    v1 = result;
    v2 = strlen((const char *)result);
    if (v2 < 3)
      return 0;
    if (v2 != 3)
    {
      v3 = 3;
      while (1)
      {
        v4 = *(unsigned __int8 *)(v1 + v3);
        if (v4 != 124 && v4 != 0)
          break;
        v3 += 4;
        if (v3 >= v2)
          return 1;
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t lhi_LogPhoneticTranscriptions(uint64_t a1, const char *a2, const char *a3, uint64_t a4, unint64_t a5)
{
  uint64_t result;
  unint64_t v10;
  char *v11;
  unsigned int v12;
  const char *v13;
  char *v14;
  int v15;
  const char *v16;
  char v18;
  _BYTE v19[17];

  result = 0;
  *(_QWORD *)&v19[1] = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    if (a5)
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1 - *(_QWORD *)(*(_QWORD *)a1 + 88));
      if ((_DWORD)result)
      {
        v16 = a2;
        v10 = 0;
        v11 = &v18;
        v12 = 1;
        do
        {
          if (*(_DWORD *)(a4 + 24 * v10) == 1)
          {
            v13 = *(const char **)(a4 + 24 * v10 + 8);
            v14 = v11;
          }
          else
          {
            v14 = v11;
            v13 = "<non-phonetic>";
          }
          v11 += (int)spr_pcat_noerr(v14, (uint64_t)v19, "s", v13);
          if (a5 == v12)
            break;
          v10 = v12;
          v11 += (int)spr_pcat_noerr(v11, (uint64_t)v19, "s", " ");
          ++v12;
        }
        while (a5 > v10);
        *v11 = 0;
        return (*(uint64_t (**)(uint64_t, const char *, const char *, ...))(*(_QWORD *)a1 + 32))(a1 - *(_QWORD *)(*(_QWORD *)a1 + 88), v16, "Found %d transcriptions for '%s': %s", v15, v16, a3);
      }
    }
  }
  return result;
}

uint64_t EDConstants_Con(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    *a1 = &__EDConstants;
    a1[1] = a2;
    if (a3 == 24)
      return 0;
    else
      return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"u32BufferSize");
  }
  return result;
}

uint64_t PNEW_EDConstants_Con(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v10);
  result = v10;
  if (!v10)
  {
    result = EDConstants_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t CDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v10 = 0;
  result = VoConObject_Con2((_QWORD *)a1, a2);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__CDSHash;
    *(_QWORD *)(a1 + 104) = a2;
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a3 + 56))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224)) == 388438978)
    {
      v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 64))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224));
      if (BinBlockStreamReader_IsVersionAccepted(v7, 0x10000))
      {
        v11 = 0;
        v12 = 0;
        result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1162560581, 0, &v10);
        if (!(_DWORD)result)
        {
          result = PNEW_EHashTableFSM_Con2(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 104), v10, (uint64_t *)(a1 + 56));
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v10);
            if (!(_DWORD)result)
            {
              result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), *(_QWORD *)(a1 + 104), 1128612933, 0, 0x10000, &v12, &v11);
              if (!(_DWORD)result)
              {
                v8 = v11 >> 2;
                *(_DWORD *)(a1 + 64) = v11 >> 2;
                v9 = v12 + 2 * v8;
                *(_QWORD *)(a1 + 72) = v12;
                *(_QWORD *)(a1 + 80) = v9;
                result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), *(_QWORD *)(a1 + 104), 1329808453, 0, 0x10000, a1 + 88, &v11);
                if (!(_DWORD)result)
                  return PNEW_EDConstants_Con(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 88), v11, (_QWORD *)(a1 + 96));
              }
            }
          }
        }
      }
      else
      {
        return err_GenerateErrorVersion();
      }
    }
    else
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Wrong Buffer Type");
    }
  }
  return result;
}

uint64_t CDSHash_Des(_QWORD *a1)
{
  uint64_t result;

  result = _CDSHash_Cleanup(a1);
  if (!(_DWORD)result)
    return VoConObject_Des((uint64_t)a1);
  return result;
}

uint64_t _CDSHash_Cleanup(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  OOCAllocator_Free(a1[13], a1[11]);
  a1[11] = 0;
  v2 = a1[12];
  if (v2)
  {
    result = OOC_PlacementDeleteObject(a1[13], v2);
    if ((_DWORD)result)
      return result;
    a1[12] = 0;
  }
  OOCAllocator_Free(a1[13], a1[9]);
  a1[9] = 0;
  v4 = a1[7];
  if (!v4)
    return 0;
  result = OOC_PlacementDeleteObject(a1[13], v4);
  if (!(_DWORD)result)
    a1[7] = 0;
  return result;
}

uint64_t CDSHash_DecodeKey(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  v3 = (a2 - 1);
  if (a2 == 1)
  {
    v3 = 0;
  }
  else
  {
    v4 = 0;
    v6 = *(_QWORD *)(result + 72);
    v5 = *(_QWORD *)(result + 80);
    do
    {
      v7 = 0;
      do
      {
        v8 = (unsigned __int16)v7;
        v9 = *(unsigned __int16 *)(v5 + 2 * (unsigned __int16)v7++);
      }
      while (v9 != *(unsigned __int16 *)(a3 + 2 * v4));
      *(_WORD *)(a3 + 2 * v4++) = *(_WORD *)(v6 + 2 * v8);
    }
    while (v4 != v3);
  }
  *(_WORD *)(a3 + 2 * v3) = 0;
  return result;
}

uint64_t CDSHash_GetInputHash(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned int *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unint64_t v14;
  unint64_t v15;
  __int16 v17;
  int v18;
  unsigned int v19;

  v19 = 0;
  v10 = LH_wcslen(a2);
  v11 = v10 + 1;
  v12 = OOCAllocator_Malloc(*(_QWORD *)(a1 + 104), 2 * (v10 + 1), &v19);
  if (v19)
    return v19;
  v13 = (unsigned __int16 *)v12;
  if (v10)
  {
    v14 = 0;
    while (1)
    {
      v18 = 0;
      v17 = *(_WORD *)(a2 + 2 * v14);
      if (!v17)
      {
        v11 = v14 + 1;
        goto LABEL_14;
      }
      if (lhstdlib_bsearch((uint64_t)&v17, *(_QWORD *)(a1 + 72), *(unsigned int *)(a1 + 64), 2uLL, (uint64_t (*)(uint64_t, unint64_t))CmpLH_U16, &v18))
      {
        v15 = v14 + 1;
      }
      else
      {
        if (!a3 || !v14)
        {
          *a5 = 0;
          if (v13)
            goto LABEL_19;
          return v19;
        }
        v15 = v14 + 1;
        v11 = v14 + 1;
      }
      v13[v14] = *(_WORD *)(*(_QWORD *)(a1 + 80) + 2 * v18);
      v14 = v15;
      if (v15 >= v11 - 1)
        goto LABEL_14;
    }
  }
  v11 = 1;
LABEL_14:
  v13[v11 - 1] = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 8);
  if (!EHashTableFSM_HashLongestMatch(*(uint64_t **)(a1 + 56), v13, v11, a4, a5) && (!a3 || !*a5))
    *a5 = 0;
LABEL_19:
  OOCAllocator_Free(*(_QWORD *)(a1 + 104), (uint64_t)v13);
  return v19;
}

uint64_t CmpLH_U16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

uint64_t CDSHash_GetNbrKeyEntries(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 12) | (*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 10) << 16);
}

uint64_t CDSHash_UnhashKey(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56));
}

void *GetCDSHashClass()
{
  return &__CDSHash;
}

uint64_t CDSBase_Con(_QWORD *a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t v8;

  v8 = 0;
  result = PNEW_BinBlockStreamReader_Con(a2, a2, a3, a4, a5, &v8);
  if (!(_DWORD)result)
  {
    result = CDSHash_Con((uint64_t)a1, a2, v8 + 32);
    if (!(_DWORD)result)
    {
      *a1 = &__CDSBase;
      result = _CDSBase_Init((uint64_t)a1, v8 + 32);
      if (!(_DWORD)result)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
    }
  }
  return result;
}

uint64_t _CDSBase_Init(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224)) != 388438978)
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Wrong Buffer Type");
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224));
  if (!BinBlockStreamReader_IsVersionAccepted(v4, 0x10000))
    return err_GenerateErrorVersion();
  v7 = 0;
  v8 = 0;
  result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a2)(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224), 1096172613, 0, &v6);
  if (!(_DWORD)result)
  {
    result = PNEW_EHashTableFSM_Con2(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 104), v6, (uint64_t *)(a1 + 112));
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224), v6);
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a2 + 48))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224), *(_QWORD *)(a1 + 104), 1145128005, 0, 0x10000, a1 + 120, &v7);
        if (!(_DWORD)result)
        {
          result = PNEW_EBitMap_Con(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 120), (uint64_t *)(a1 + 128));
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)a2 + 48))(a2 - *(_QWORD *)(*(_QWORD *)a2 + 224), *(_QWORD *)(a1 + 104), 1128547397, 0, 0x10000, &v8, &v7);
            if (!(_DWORD)result)
            {
              *(_QWORD *)(a1 + 136) = v8;
              *(_DWORD *)(a1 + 144) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 18);
              *(_BYTE *)(a1 + 147) = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CDSBase_Des(_QWORD *a1)
{
  uint64_t result;

  OOCAllocator_Free(a1[13], a1[17]);
  OOCAllocator_Free(a1[13], a1[15]);
  result = OOC_PlacementDeleteObject(a1[13], a1[16]);
  if (!(_DWORD)result)
  {
    result = OOC_PlacementDeleteObject(a1[13], a1[14]);
    if (!(_DWORD)result)
      return CDSHash_Des(a1);
  }
  return result;
}

uint64_t CDSBase_GetFieldSeparator(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 2);
}

uint64_t CDSBase_GetNbrValueEntries(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 16) | (*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 14) << 16);
}

uint64_t CDSBase_GetOutputString(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, unsigned int *a5, int *a6, unsigned int *a7)
{
  uint64_t result;
  int v13;
  uint64_t v14;
  uint64_t NBits;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  _BYTE *v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;

  v26 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  result = CDSHash_GetInputHash(a1, a2, a3, &v26, a7);
  v27 = result;
  if (!(_DWORD)result)
  {
    if (!*a7)
      return 0;
    v13 = **(unsigned __int16 **)(*(_QWORD *)(a1 + 96) + 8);
    v14 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)(v14 + 16) = (v26 * v13);
    NBits = EBitMap_GetNBits(v14, v13);
    v16 = OOCAllocator_Malloc(*(_QWORD *)(a1 + 104), 2 * *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 4), &v27);
    result = v27;
    if (!v27)
    {
      v17 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 112) + 32))(*(_QWORD *)(a1 + 112), NBits, v16);
      v18 = OOCAllocator_Malloc(*(_QWORD *)(a1 + 104), v17 + 1, &v27);
      result = v27;
      if (!v27)
      {
        if (v17)
        {
          v19 = 0;
          v20 = (_BYTE *)v18;
          v21 = (unsigned __int16 *)v16;
          v22 = v17;
          do
          {
            v23 = *v21++;
            v24 = *(char *)(*(_QWORD *)(a1 + 136) + v23);
            *v20++ = *(_BYTE *)(*(_QWORD *)(a1 + 136) + v23);
            if (*(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 2) == v24)
              ++v19;
            --v22;
          }
          while (v22);
          v25 = v19 + 1;
        }
        else
        {
          v25 = 1;
          if (!v16)
          {
LABEL_15:
            *(_BYTE *)(v18 + v17) = 0;
            *a4 = v18;
            *a5 = v17;
            *a6 = v25;
            return v27;
          }
        }
        OOCAllocator_Free(*(_QWORD *)(a1 + 104), v16);
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t CDSBase_GetTranscriptionType(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 22);
}

void *GetCDSBaseClass()
{
  return &__CDSBase;
}

uint64_t EBitMap_AlignAddr(uint64_t result, char a2)
{
  int v2;

  v2 = *(_DWORD *)(result + 16);
  while ((v2++ & ~(-1 << a2)) != 0)
    ;
  *(_QWORD *)(result + 16) = (v2 - 1);
  return result;
}

uint64_t EBitMap_GetNBits(uint64_t a1, int a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;

  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(a1 + 16);
  v4 = v3 + a2;
  *(_QWORD *)(a1 + 16) = v4;
  if (v4 <= v3)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = v3;
    do
    {
      v5 |= *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + ((unint64_t)v6 >> v2)) >> (v6 & 7) << (v6 - v3);
      v6 = (v6 & 0xFFFFFFF8) + 8;
    }
    while (v6 < v4);
  }
  return v5 & ~(-1 << a2);
}

uint64_t PNEW_EBitMap_Con(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = OOCAllocator_Malloc(a1, 32, &v8);
  result = v8;
  if (!v8)
  {
    result = Object_Con((_QWORD *)v6);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *(_QWORD *)v6 = &__EBitMap;
      *(_QWORD *)(v6 + 8) = a2;
      *(_QWORD *)(v6 + 16) = 0;
      *(_DWORD *)(v6 + 24) = 3;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t EHuffmanBitmap_Decode(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;

  EHuffman_Reset(a1);
  v4 = *(_DWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 16) >> v4;
  v6 = *(_QWORD *)(a2 + 16) & 7;
  while (EHuffman_Eat(a1))
  {
    if ((_DWORD)v6 == 7)
    {
      ++v5;
      LODWORD(v6) = 0;
    }
    else
    {
      LODWORD(v6) = v6 + 1;
    }
  }
  *(_QWORD *)(a2 + 16) = ((v5 << v4) | v6) + 1;
  return EHuffman_GetResult(a1);
}

uint64_t PNEW_EHuffmanBitmap_Con2(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 64, &v10);
  result = v10;
  if (!v10)
  {
    result = EHuffman_Con2(v8, a2, a3);
    if ((_DWORD)result)
    {
      v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *v8 = &__EHuffmanBitmap;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t _EHashTable_Con(_QWORD *a1)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
    *a1 = &__EHashTable;
  return result;
}

void *GetEHashTableClass()
{
  return &__EHashTable;
}

uint64_t EHashTableFSM_Con2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = _EHashTable_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    v7 = 0;
    v8 = 0;
    *(_QWORD *)a1 = &__EHashTableFSM;
    *(_QWORD *)(a1 + 96) = a2;
    result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1313231686, 0, &v7);
    if (!(_DWORD)result)
    {
      result = PNEW_EHashTableFirstNode_Con2(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96), v7, (uint64_t *)(a1 + 8));
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v7);
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), *(_QWORD *)(a1 + 96), 1296192326, 0, 0x10000, a1 + 16, &v8);
          if (!(_DWORD)result)
          {
            *(_DWORD *)(a1 + 32) = 8 * v8;
            result = PNEW_EBitMap_Con(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 16), (uint64_t *)(a1 + 24));
            if (!(_DWORD)result)
            {
              result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1145656134, 0, &v7);
              if (!(_DWORD)result)
              {
                result = PNEW_EHuffmanBitmap_Con2(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96), v7, (_QWORD *)(a1 + 40));
                if (!(_DWORD)result)
                {
                  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v7);
                  if (!(_DWORD)result)
                  {
                    result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1313166150, 0, &v7);
                    if (!(_DWORD)result)
                    {
                      result = PNEW_EHuffmanBitmap_Con2(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96), v7, (_QWORD *)(a1 + 48));
                      if (!(_DWORD)result)
                      {
                        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v7);
                        if (!(_DWORD)result)
                        {
                          result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1179603782, 0, &v7);
                          if (!(_DWORD)result)
                          {
                            result = PNEW_EHuffmanBitmap_Con2(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96), v7, (_QWORD *)(a1 + 56));
                            if (!(_DWORD)result)
                            {
                              result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v7);
                              if (!(_DWORD)result)
                              {
                                result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1095258950, 0, &v7);
                                if (!(_DWORD)result)
                                {
                                  result = PNEW_EHuffmanBitmap_Con2(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96), v7, (_QWORD *)(a1 + 64));
                                  if (!(_DWORD)result)
                                  {
                                    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v7);
                                    if (!(_DWORD)result)
                                    {
                                      result = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD, uint64_t *))a3)(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), 1229738822, 0, &v7);
                                      if (!(_DWORD)result)
                                      {
                                        result = PNEW_EHuffmanBitmap_Con2(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96), v7, (_QWORD *)(a1 + 72));
                                        if (!(_DWORD)result)
                                        {
                                          result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), v7);
                                          if (!(_DWORD)result)
                                          {
                                            result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), *(_QWORD *)(a1 + 96), 1329812294, 0, 0x10000, a1 + 80, &v8);
                                            if (!(_DWORD)result)
                                              return PNEW_FSMConstants_Con(*(_QWORD *)(a1 + 96), *(unsigned __int16 **)(a1 + 80), (uint64_t *)(a1 + 88));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t EHashTableFSM_Des(_QWORD *a1)
{
  uint64_t result;

  result = _EHashTableFSM_Cleanup(a1);
  if (!(_DWORD)result)
    return Object_Des();
  return result;
}

uint64_t _EHashTableFSM_Cleanup(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = a1[11];
  if (v2)
  {
    result = OOC_PlacementDeleteObject(a1[12], v2);
    if ((_DWORD)result)
      return result;
    a1[11] = 0;
  }
  OOCAllocator_Free(a1[12], a1[10]);
  a1[10] = 0;
  v4 = a1[9];
  if (v4)
  {
    result = OOC_PlacementDeleteObject(a1[12], v4);
    if ((_DWORD)result)
      return result;
    a1[9] = 0;
  }
  v5 = a1[8];
  if (v5)
  {
    result = OOC_PlacementDeleteObject(a1[12], v5);
    if ((_DWORD)result)
      return result;
    a1[8] = 0;
  }
  v6 = a1[7];
  if (v6)
  {
    result = OOC_PlacementDeleteObject(a1[12], v6);
    if ((_DWORD)result)
      return result;
    a1[7] = 0;
  }
  v7 = a1[6];
  if (v7)
  {
    result = OOC_PlacementDeleteObject(a1[12], v7);
    if ((_DWORD)result)
      return result;
    a1[6] = 0;
  }
  v8 = a1[5];
  if (v8)
  {
    result = OOC_PlacementDeleteObject(a1[12], v8);
    if ((_DWORD)result)
      return result;
    a1[5] = 0;
  }
  v9 = a1[3];
  if (v9)
  {
    result = OOC_PlacementDeleteObject(a1[12], v9);
    if ((_DWORD)result)
      return result;
    a1[3] = 0;
  }
  OOCAllocator_Free(a1[12], a1[2]);
  a1[2] = 0;
  v10 = a1[1];
  if (!v10)
    return 0;
  result = OOC_PlacementDeleteObject(a1[12], v10);
  if (!(_DWORD)result)
    a1[1] = 0;
  return result;
}

uint64_t EHashTableFSM_Hash(uint64_t *a1, unsigned __int16 *a2, unsigned int a3, int *a4)
{
  return EHashTableFSM_HashLongestMatch(a1, a2, a3, a4, 0);
}

uint64_t EHashTableFSM_HashLongestMatch(uint64_t *a1, unsigned __int16 *a2, unsigned int a3, int *a4, unsigned int *a5)
{
  uint64_t result;
  unsigned int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int LeafWidth;
  unsigned int v35;
  unint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  BOOL v40;
  unsigned int v41;
  unint64_t v42;
  uint64_t v43;
  int v44;
  unsigned int *v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned __int16 *v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;

  v53 = 0;
  *a4 = 0;
  if (a5)
    *a5 = 0;
  result = EHashTableFirstNode_Hash(a1[1], *a2, a4, &v53);
  if ((_DWORD)result)
  {
    v11 = v53;
    v12 = a1[11];
    if (v53 <= *(unsigned __int8 *)(v12 + 18))
    {
      v11 = *(_DWORD *)(v12 + 8);
      v53 = v11;
    }
    if (a3 == 1)
      return 1;
    v47 = a3 - 1;
    v48 = a5;
    if (a3)
    {
      v50 = a2;
      v13 = 0;
      v14 = *(unsigned __int16 *)(v12 + 14);
      v51 = *(unsigned __int16 *)(v12 + 12);
      v52 = 0;
      v15 = 1;
      v16 = v11;
      v49 = a3;
      while (1)
      {
        v17 = a1[3];
        *(_QWORD *)(v17 + 16) = v16;
        v18 = EHuffmanBitmap_Decode(a1[5], v17);
        v19 = v18;
        if (v18 < v51)
          break;
        if (v18 != v51)
        {
          if (v18 - v51 <= 1)
            v22 = 1;
          else
            v22 = v18 - v51;
          v23 = v15 + v22;
          do
          {
            v24 = v14;
            if (v15 < a3)
              v24 = v50[v15];
            v25 = EHuffmanBitmap_Decode(a1[6], a1[3]);
            if (v14 == v25)
            {
              v13 = *a4;
              v52 = v15;
            }
            if (v24 != v25)
              goto LABEL_77;
            ++v15;
            --v22;
          }
          while (v22);
          v15 = v23;
        }
        if (v15 == a3)
          goto LABEL_75;
        v26 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        v16 = v26;
        v27 = a1[11];
        v28 = *(unsigned __int8 *)(v27 + 18);
        if (v26 > v28)
          v16 = v26 << *(_BYTE *)(v27 + 16);
        if (v16)
        {
          if (v16 <= v28)
          {
            v29 = a1[3];
LABEL_70:
            EBitMap_AlignAddr(v29, *(_BYTE *)(v27 + 16));
            v16 = *(_QWORD *)(a1[3] + 16);
          }
        }
        else
        {
          LeafWidth = EHuffman_GetLeafWidth(a1[9]);
          v16 = EBitMap_GetNBits(a1[3], LeafWidth) << *(_BYTE *)(a1[11] + 16);
        }
LABEL_71:
        if (v15 > a3)
        {
          v11 = v53;
          goto LABEL_74;
        }
      }
      v20 = v14;
      if (v15 < a3)
        v20 = v50[v15];
      v21 = EHuffmanBitmap_Decode(a1[6], a1[3]);
      if (v14 == (unsigned __int16)v21)
      {
        v13 = *a4;
        if (v20 == v14)
        {
          v52 = v15;
LABEL_43:
          v35 = 1;
          if (v19 >= 2)
          {
            while (1)
            {
              if (v20 <= (unsigned __int16)v21)
                goto LABEL_57;
              v21 += EHuffmanBitmap_Decode(a1[7], a1[3]);
              if (v14 != (unsigned __int16)v21)
                break;
              v13 = *a4;
              if (v14 != v20)
              {
                v39 = v13 + 1;
                v52 = v15;
LABEL_55:
                *a4 = v39;
                goto LABEL_56;
              }
              v52 = v15;
LABEL_56:
              if (++v35 >= v19)
                goto LABEL_57;
            }
            v36 = EHuffmanBitmap_Decode(a1[9], a1[3]);
            v16 = v36;
            v37 = a1[11];
            if (v36 > *(unsigned __int8 *)(v37 + 18))
              v16 = v36 << *(_BYTE *)(v37 + 16);
            if (!v16)
            {
              v38 = EHuffman_GetLeafWidth(a1[9]);
              v16 = EBitMap_GetNBits(a1[3], v38) << *(_BYTE *)(a1[11] + 16);
            }
            if (v20 == (unsigned __int16)v21)
              goto LABEL_56;
            v39 = *a4 + EHuffmanBitmap_Decode(a1[8], a1[3]);
            goto LABEL_55;
          }
LABEL_57:
          if (v20 != (unsigned __int16)v21)
            goto LABEL_77;
          ++v15;
          a3 = v49;
          if (v15 == v49)
            goto LABEL_75;
          if (v16 > *(unsigned __int8 *)(a1[11] + 18))
            goto LABEL_71;
          EHuffmanBitmap_Decode(a1[8], a1[3]);
          v40 = v19 >= v35;
          v41 = v19 - v35;
          if (v41 != 0 && v40)
          {
            do
            {
              v20 += EHuffmanBitmap_Decode(a1[7], a1[3]);
              if (v14 != (unsigned __int16)v20)
              {
                v42 = EHuffmanBitmap_Decode(a1[9], a1[3]);
                v43 = a1[11];
                if (v42 > *(unsigned __int8 *)(v43 + 18))
                  v42 <<= *(_BYTE *)(v43 + 16);
                if (!v42)
                {
                  v44 = EHuffman_GetLeafWidth(a1[9]);
                  EBitMap_GetNBits(a1[3], v44);
                }
                EHuffmanBitmap_Decode(a1[8], a1[3]);
              }
              --v41;
            }
            while (v41);
          }
          v29 = a1[3];
          v27 = a1[11];
          goto LABEL_70;
        }
        v33 = v13 + 1;
        v52 = v15;
      }
      else
      {
        v30 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        v16 = v30;
        v31 = a1[11];
        if (v30 > *(unsigned __int8 *)(v31 + 18))
          v16 = v30 << *(_BYTE *)(v31 + 16);
        if (!v16)
        {
          v32 = EHuffman_GetLeafWidth(a1[9]);
          v16 = EBitMap_GetNBits(a1[3], v32) << *(_BYTE *)(a1[11] + 16);
        }
        if (v20 == (unsigned __int16)v21)
          goto LABEL_43;
        v33 = *a4 + EHuffmanBitmap_Decode(a1[8], a1[3]);
      }
      *a4 = v33;
      goto LABEL_43;
    }
    v13 = 0;
    v52 = 0;
LABEL_74:
    if (v11 == 1)
    {
LABEL_75:
      v45 = v48;
      if (!v48)
        return 1;
      result = 1;
      v46 = v47;
    }
    else
    {
LABEL_77:
      result = 0;
      *a4 = v13;
      v45 = v48;
      v46 = v52;
      if (!v48)
        return result;
    }
    *v45 = v46;
  }
  return result;
}

uint64_t EHashTableFSM_Unhash(uint64_t *a1, unsigned int a2, _WORD *a3)
{
  _WORD *v3;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int LeafWidth;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  unsigned __int16 v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  unsigned int v43;
  _WORD *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;

  v3 = a3;
  v47 = 0;
  v48 = a2;
  EHashTableFirstNode_Unhash(a1[1], &v48, a3, &v47);
  v5 = v47;
  v6 = a1[11];
  if (v47 <= *(unsigned __int8 *)(v6 + 18))
  {
    v7 = *(unsigned int *)(v6 + 8);
    *(_QWORD *)(a1[3] + 16) = v7;
    if (v5 >= 2)
    {
      v8 = 1;
      do
      {
        _EHashTableFSM_SkipState(a1);
        ++v8;
      }
      while (v8 < v47);
      LODWORD(v7) = *(_DWORD *)(a1[3] + 16);
      v6 = a1[11];
    }
    v47 = v7;
    v5 = v7;
  }
  v9 = *(unsigned __int16 *)(v6 + 14);
  v10 = *(unsigned __int16 *)(v6 + 12);
  v11 = 1;
  v12 = v5;
  v44 = v3;
  v43 = v10;
  do
  {
    while (1)
    {
      while (1)
      {
        v13 = a1[3];
        *(_QWORD *)(v13 + 16) = v12;
        v14 = EHuffmanBitmap_Decode(a1[5], v13);
        if (v14 >= v10)
          break;
        if (!v14)
        {
          v34 = v11;
          goto LABEL_67;
        }
        v15 = 0;
        v16 = 0;
        v46 = v14;
        v17 = v14 - 1;
        while (1)
        {
          v18 = v16 ? 56 : 48;
          v15 += EHuffmanBitmap_Decode(*(uint64_t *)((char *)a1 + v18), a1[3]);
          if (v9 == (unsigned __int16)v15)
          {
            v19 = 1;
          }
          else
          {
            v20 = EHuffmanBitmap_Decode(a1[9], a1[3]);
            v12 = v20;
            v21 = a1[11];
            if (v20 > *(unsigned __int8 *)(v21 + 18))
              v12 = v20 << *(_BYTE *)(v21 + 16);
            if (!v12)
            {
              LeafWidth = EHuffman_GetLeafWidth(a1[9]);
              v12 = EBitMap_GetNBits(a1[3], LeafWidth) << *(_BYTE *)(a1[11] + 16);
            }
            v19 = EHuffmanBitmap_Decode(a1[8], a1[3]);
            if (v19 >= v48)
            {
              v23 = a1[11];
              if (v12 <= *(unsigned __int8 *)(v23 + 18))
              {
                v24 = a1[3];
                v45 = *(_QWORD *)(v24 + 16);
                if (v16 + 1 < v46)
                {
                  v25 = v17;
                  v26 = v15;
                  do
                  {
                    v26 += EHuffmanBitmap_Decode(a1[7], a1[3]);
                    if (v9 != (unsigned __int16)v26)
                    {
                      v27 = EHuffmanBitmap_Decode(a1[9], a1[3]);
                      v28 = a1[11];
                      if (v27 > *(unsigned __int8 *)(v28 + 18))
                        v27 <<= *(_BYTE *)(v28 + 16);
                      if (!v27)
                      {
                        v29 = EHuffman_GetLeafWidth(a1[9]);
                        EBitMap_GetNBits(a1[3], v29);
                      }
                      EHuffmanBitmap_Decode(a1[8], a1[3]);
                    }
                    --v25;
                  }
                  while (v25);
                  v24 = a1[3];
                  v23 = a1[11];
                }
                EBitMap_AlignAddr(v24, *(_BYTE *)(v23 + 16));
                if (v12 >= 2)
                {
                  v30 = 2;
                  do
                    _EHashTableFSM_SkipState(a1);
                  while (v12 > v30++);
                }
                v32 = a1[3];
                v12 = *(_QWORD *)(v32 + 16);
                *(_QWORD *)(v32 + 16) = v45;
              }
            }
          }
          v33 = v48;
          if (v19 >= v48)
            break;
          v48 -= v19;
          ++v16;
          --v17;
          if (v16 == v46)
          {
            v34 = v11;
            v3 = v44;
            v10 = v43;
            goto LABEL_67;
          }
        }
        v3 = v44;
        if (v44)
          v44[v11] = v15;
        *(_QWORD *)(a1[3] + 16) = v12;
        v10 = v43;
        if (v9 != (unsigned __int16)v15)
        {
          v34 = (v11 + 1);
          goto LABEL_67;
        }
        v48 = v33 - 1;
        if (v33 == 1)
          return v11;
      }
      if (v14 != v10)
        break;
LABEL_49:
      --v48;
      v11 = (v11 - 1);
      if (!v48)
        return v11;
    }
    if (v14 - v10 <= 1)
      v35 = 1;
    else
      v35 = v14 - v10;
    v34 = (v11 + v35);
    do
    {
      v36 = EHuffmanBitmap_Decode(a1[6], a1[3]);
      if (v3)
        v3[v11] = v36;
      LODWORD(v11) = v11 + 1;
      --v35;
    }
    while (v35);
    if (v9 == v36)
    {
      LODWORD(v11) = v34;
      goto LABEL_49;
    }
    v37 = EHuffmanBitmap_Decode(a1[9], a1[3]);
    v12 = v37;
    v38 = a1[11];
    v39 = *(unsigned __int8 *)(v38 + 18);
    if (v37 > v39)
      v12 = v37 << *(_BYTE *)(v38 + 16);
    if (v12)
    {
      if (v12 <= v39)
      {
        EBitMap_AlignAddr(a1[3], *(_BYTE *)(v38 + 16));
        if (v12 >= 2)
        {
          v40 = 1;
          do
          {
            _EHashTableFSM_SkipState(a1);
            ++v40;
          }
          while (v40 < v12);
        }
        v12 = *(_QWORD *)(a1[3] + 16);
      }
    }
    else
    {
      v41 = EHuffman_GetLeafWidth(a1[9]);
      v12 = EBitMap_GetNBits(a1[3], v41) << *(_BYTE *)(a1[11] + 16);
    }
LABEL_67:
    v11 = v34;
  }
  while (v48);
  return v11;
}

uint64_t _EHashTableFSM_SkipState(uint64_t *a1)
{
  unsigned int v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  unsigned int v6;
  unsigned __int16 v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned __int16 v16;
  unint64_t v17;
  uint64_t v18;
  int LeafWidth;

  v2 = EHuffmanBitmap_Decode(a1[5], a1[3]);
  v3 = a1[11];
  v4 = *(unsigned __int16 *)(v3 + 14);
  LODWORD(v3) = *(unsigned __int16 *)(v3 + 12);
  v5 = v2 >= v3;
  v6 = v2 - v3;
  if (v5)
  {
    if (v6)
    {
      v15 = v6 <= 1 ? 1 : v6;
      do
      {
        v16 = EHuffmanBitmap_Decode(a1[6], a1[3]);
        --v15;
      }
      while (v15);
      if (v4 != v16)
      {
        v17 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        v18 = a1[11];
        if (v17 > *(unsigned __int8 *)(v18 + 18))
          v17 <<= *(_BYTE *)(v18 + 16);
        if (!v17)
        {
          LeafWidth = EHuffman_GetLeafWidth(a1[9]);
          EBitMap_GetNBits(a1[3], LeafWidth);
        }
      }
    }
  }
  else
  {
    v7 = EHuffmanBitmap_Decode(a1[6], a1[3]);
    if (v4 != v7)
    {
      v8 = EHuffmanBitmap_Decode(a1[9], a1[3]);
      v9 = a1[11];
      if (v8 > *(unsigned __int8 *)(v9 + 18))
        v8 <<= *(_BYTE *)(v9 + 16);
      if (!v8)
      {
        v10 = EHuffman_GetLeafWidth(a1[9]);
        EBitMap_GetNBits(a1[3], v10);
      }
      EHuffmanBitmap_Decode(a1[8], a1[3]);
    }
    if (v2 >= 2)
    {
      v11 = v2 - 1;
      do
      {
        v7 += EHuffmanBitmap_Decode(a1[7], a1[3]);
        if (v4 != v7)
        {
          v12 = EHuffmanBitmap_Decode(a1[9], a1[3]);
          v13 = a1[11];
          if (v12 > *(unsigned __int8 *)(v13 + 18))
            v12 <<= *(_BYTE *)(v13 + 16);
          if (!v12)
          {
            v14 = EHuffman_GetLeafWidth(a1[9]);
            EBitMap_GetNBits(a1[3], v14);
          }
          EHuffmanBitmap_Decode(a1[8], a1[3]);
        }
        --v11;
      }
      while (v11);
    }
  }
  return EBitMap_AlignAddr(a1[3], *(_BYTE *)(a1[11] + 16));
}

uint64_t PNEW_EHashTableFSM_Con2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 104, &v10);
  result = v10;
  if (!v10)
  {
    result = EHashTableFSM_Con2(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_Con2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    v8 = 0;
    *(_QWORD *)a1 = &__EHashTableFirstNode;
    *(_QWORD *)(a1 + 48) = a2;
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), a2, 1313164870, 0, 0x10000, a1 + 16, &v8);
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 8) = v8 >> 1;
      result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, unint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), *(_QWORD *)(a1 + 48), 1414745670, 0, 0x10000, a1 + 24, &v8);
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, unint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), *(_QWORD *)(a1 + 48), 1095257670, 0, 0x10000, a1 + 40, &v8);
        if (!(_DWORD)result)
        {
          v7 = 4 * (unint64_t)*(unsigned int *)(a1 + 8) / v8;
          *(_DWORD *)(a1 + 32) = v7;
          if ((v7 - 1) >= 2)
            return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"invalid hash value width");
          else
            return 0;
        }
      }
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_Des(uint64_t *a1)
{
  _EHashTableFirstNode_Cleanup(a1);
  return Object_Des();
}

uint64_t _EHashTableFirstNode_Cleanup(uint64_t *a1)
{
  OOCAllocator_Free(a1[6], a1[5]);
  a1[5] = 0;
  OOCAllocator_Free(a1[6], a1[3]);
  a1[3] = 0;
  OOCAllocator_Free(a1[6], a1[2]);
  a1[2] = 0;
  return 0;
}

uint64_t EHashTableFirstNode_Hash(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 32);
  if (v7 == 1)
  {
    if (v4)
    {
      v8 = 0;
      v9 = 0;
      while (*(unsigned __int16 *)(v5 + 2 * v8) < a2)
      {
        v9 += *(_DWORD *)(v6 + 4 * v8++);
        if (v4 == (_DWORD)v8)
          return 0;
      }
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v7 != 2 || !v4)
  {
LABEL_13:
    LODWORD(v8) = 0;
    v9 = 0;
    goto LABEL_14;
  }
  v8 = 0;
  v9 = 0;
  while (*(unsigned __int16 *)(v5 + 2 * v8) < a2)
  {
    v9 += *(unsigned __int16 *)(v6 + 2 * v8++);
    if (v4 == (_DWORD)v8)
      return 0;
  }
LABEL_14:
  if ((_DWORD)v8 == v4 || *(unsigned __int16 *)(v5 + 2 * v8) != a2)
    return 0;
  *a3 = v9;
  *a4 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v8);
  return 1;
}

uint64_t EHashTableFirstNode_Unhash(uint64_t result, unsigned int *a2, _WORD *a3, _DWORD *a4)
{
  unsigned __int16 *v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;

  v4 = *(unsigned __int16 **)(result + 40);
  v5 = *a2 + 1;
  v6 = *(_DWORD *)(result + 32);
  if (v6 != 1)
  {
    if (v6 == 2)
    {
      v7 = *v4;
      if (v5 > v7)
      {
        v8 = 0;
        do
        {
          v5 -= v7;
          v7 = v4[++v8];
        }
        while (v5 > v7);
        goto LABEL_12;
      }
    }
LABEL_11:
    v8 = 0;
    goto LABEL_12;
  }
  v9 = *(_DWORD *)v4;
  if (*(_DWORD *)v4 >= v5)
    goto LABEL_11;
  v8 = 0;
  do
  {
    v5 -= v9;
    v9 = *(_DWORD *)&v4[2 * ++v8];
  }
  while (v9 < v5);
LABEL_12:
  *a2 = v5;
  if (a3)
    *a3 = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v8);
  *a4 = *(_DWORD *)(*(_QWORD *)(result + 24) + 4 * v8);
  return result;
}

uint64_t PNEW_EHashTableFirstNode_Con2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 56, &v10);
  result = v10;
  if (!v10)
  {
    result = EHashTableFirstNode_Con2(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSMConstants_Con(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__FSMConstants;
    *(_WORD *)(a1 + 12) = bswap32(*a2) >> 16;
    *(_DWORD *)(a1 + 8) = bswap32(*(_DWORD *)((char *)a2 + 7));
    *(_WORD *)(a1 + 14) = bswap32(a2[2]) >> 16;
    *(_BYTE *)(a1 + 16) = *((_BYTE *)a2 + 2);
    *(_BYTE *)(a1 + 17) = *((_BYTE *)a2 + 3);
    *(_BYTE *)(a1 + 18) = *((_BYTE *)a2 + 6);
  }
  return result;
}

uint64_t PNEW_FSMConstants_Con(uint64_t a1, unsigned __int16 *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = OOCAllocator_Malloc(a1, 24, &v8);
  result = v8;
  if (!v8)
  {
    result = FSMConstants_Con(v6, a2);
    v8 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _ELeaf_Con(_QWORD *a1)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
    *a1 = &__ELeaf;
  return result;
}

void *GetELeafClass()
{
  return &__ELeaf;
}

uint64_t EHuffman_Con2(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unsigned __int16 **v7;
  int v8;
  uint64_t v10;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    v10 = 0;
    *a1 = &__EHuffman;
    a1[7] = a2;
    v7 = (unsigned __int16 **)(a1 + 1);
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), a2, 1381258568, 0, 0x10000, a1 + 1, &v10);
    if (!(_DWORD)result)
    {
      v8 = (*v7)[1];
      if (v8 == 8 || v8 == 16)
      {
        result = _EHuffman_CreateTree((uint64_t)a1, (uint64_t)(*v7 + 2), v8, **v7);
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD *, uint64_t *))(*(_QWORD *)a3 + 48))(a3 - *(_QWORD *)(*(_QWORD *)a3 + 224), a1[7], 1162630472, 0, 0x10000, a1 + 4, &v10);
          if (!(_DWORD)result)
            return _EHuffman_CreateLeafArray((uint64_t)a1, a1[4] + 2, *(unsigned __int16 *)a1[4], v10 - 2);
        }
      }
      else
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"invalid width of huffman tree buffer");
      }
    }
  }
  return result;
}

uint64_t _EHuffman_CreateTree(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v6;

  if (a3 == 16)
  {
    v6 = 0;
    result = PNEW_ETree16_Con(*(_QWORD *)(a1 + 56), a2, a4, &v6);
    if ((_DWORD)result)
      return result;
    goto LABEL_6;
  }
  if (a3 == 8)
  {
    v6 = 0;
    result = PNEW_ETree08_Con(*(_QWORD *)(a1 + 56), a2, a4, &v6);
    if ((_DWORD)result)
      return result;
LABEL_6:
    *(_QWORD *)(a1 + 24) = v6;
    return result;
  }
  return 0;
}

uint64_t _EHuffman_CreateLeafArray(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;

  v6 = 0;
  result = PNEW_ELeaf08_Con(*(_QWORD *)(a1 + 56), a2, a3, 8 * a4 / (unint64_t)a3, &v6);
  if (!(_DWORD)result)
    *(_QWORD *)(a1 + 48) = v6;
  return result;
}

uint64_t EHuffman_Des(uint64_t *a1)
{
  uint64_t result;

  result = _EHuffman_Cleanup(a1);
  if (!(_DWORD)result)
    return Object_Des();
  return result;
}

uint64_t _EHuffman_Cleanup(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = a1[3];
  if (v2)
  {
    result = OOC_PlacementDeleteObject(a1[7], v2);
    if ((_DWORD)result)
      return result;
    a1[3] = 0;
  }
  OOCAllocator_Free(a1[7], a1[1]);
  a1[1] = 0;
  v4 = a1[6];
  if (v4)
  {
    result = OOC_PlacementDeleteObject(a1[7], v4);
    if ((_DWORD)result)
      return result;
    a1[6] = 0;
  }
  OOCAllocator_Free(a1[7], a1[4]);
  result = 0;
  a1[4] = 0;
  return result;
}

uint64_t EHuffman_Eat(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 24))(*(_QWORD *)(a1 + 24));
}

uint64_t EHuffman_GetLeafWidth(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48));
}

uint64_t EHuffman_GetResult(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48), *(unsigned int *)(*(_QWORD *)(a1 + 24) + 12));
}

uint64_t EHuffman_Reset(uint64_t a1)
{
  return ETree_Reset(*(_QWORD *)(a1 + 24));
}

void *GetEHuffmanClass()
{
  return &__EHuffman;
}

uint64_t _ETree_Con(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__ETree;
    *(_DWORD *)(a1 + 8) = a3 - 1;
    *(_DWORD *)(a1 + 12) = a3 - 1;
    *(_QWORD *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 24) = a4;
  }
  return result;
}

uint64_t ETree_Reset(uint64_t result)
{
  *(_DWORD *)(result + 12) = *(_DWORD *)(result + 8);
  return result;
}

void *GetETreeClass()
{
  return &__ETree;
}

uint64_t ELeaf08_GetLeafWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t ELeaf08_GetResult(uint64_t a1, int a2)
{
  int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;

  v2 = *(_DWORD *)(a1 + 16);
  v3 = v2 * a2 + v2;
  if (v2 * a2 >= v3)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = v2 * a2;
    do
    {
      v4 |= *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + ((unint64_t)v5 >> 3)) >> (v5 & 7) << (v5 - v2 * a2);
      v5 = (v5 & 0xFFFFFFF8) + 8;
    }
    while (v5 < v3);
  }
  return v4 & ~(-1 << v2);
}

uint64_t PNEW_ELeaf08_Con(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t result;
  unsigned int v12;

  v12 = 0;
  v10 = OOCAllocator_Malloc(a1, 24, &v12);
  result = v12;
  if (!v12)
  {
    result = _ELeaf_Con((_QWORD *)v10);
    if ((_DWORD)result)
    {
      v12 = result;
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *(_QWORD *)v10 = &__ELeaf08;
      *(_QWORD *)(v10 + 8) = a2;
      *(_DWORD *)(v10 + 16) = a3;
      *(_DWORD *)(v10 + 20) = a4;
      *a5 = v10;
    }
  }
  return result;
}

BOOL ETree08_Eat(uint64_t a1, int a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned int v4;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = (unsigned __int8 *)(v2 + 2 * *(unsigned int *)(a1 + 12));
  if (!a2)
    ++v3;
  v4 = *v3;
  *(_DWORD *)(a1 + 12) = v4;
  return *(unsigned __int8 *)(v2 + 2 * v4) != 255;
}

uint64_t PNEW_ETree08_Con(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 32, &v10);
  result = v10;
  if (!v10)
  {
    result = _ETree_Con((uint64_t)v8, a2, a3, 8);
    if ((_DWORD)result)
    {
      v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *v8 = &__ETree08;
      *a4 = v8;
    }
  }
  return result;
}

BOOL ETree16_Eat(uint64_t a1, int a2)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(unsigned __int16 *)(v2 + 4 * *(unsigned int *)(a1 + 12) + 2 * (a2 == 0));
  *(_DWORD *)(a1 + 12) = v3;
  return *(__int16 *)(v2 + 4 * v3) != -1;
}

uint64_t PNEW_ETree16_Con(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 32, &v10);
  result = v10;
  if (!v10)
  {
    result = _ETree_Con((uint64_t)v8, a2, a3, 16);
    if ((_DWORD)result)
    {
      v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *v8 = &__ETree16;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t fi_init(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, _QWORD *a5, int a6, uint64_t a7, uint64_t a8, __int16 a9, unsigned __int8 a10)
{
  uint64_t inited;
  uint64_t v18;
  _QWORD *v19;
  uint64_t ObjcForThisApi_1;
  uint64_t AddRefCountedObject;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  _QWORD v31[5];
  int v32;
  __int16 v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v36 = 0;
  v37 = 0;
  v35 = 0;
  inited = InitRsrcFunction(a1, a2, &v37);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(a3, a4, &v36);
  if ((inited & 0x80000000) != 0)
    return inited;
  v18 = heap_Calloc(*(_QWORD **)(v37 + 8), 1, 16);
  if (!v18)
    return 2692751370;
  v19 = (_QWORD *)v18;
  v31[4] = 0;
  v31[0] = a1;
  v31[1] = a2;
  v31[2] = a3;
  v31[3] = a4;
  __strcpy_chk();
  v32 = a6;
  v34 = a10;
  v33 = a9;
  ObjcForThisApi_1 = getObjcForThisApi_1(v37, v36);
  AddRefCountedObject = objc_GetAddRefCountedObject(ObjcForThisApi_1, a7, (uint64_t (*)(_QWORD, _QWORD, uint64_t, __int128 *, uint64_t))fi_ObjcLoad, (void (*)(_QWORD, _QWORD, __int128 *))fi_ObjcClose, (uint64_t)v31, &v35);
  if ((AddRefCountedObject & 0x80000000) != 0)
  {
    v28 = AddRefCountedObject;
  }
  else
  {
    v22 = *(_QWORD *)(v35 + 32);
    v19[1] = v22;
    v23 = *(uint64_t **)v22;
    if (!parse_fi_binary_model(*(uint64_t **)v22, *(_QWORD *)(v22 + 8), v19))
    {
      v28 = 0;
      *a5 = v19;
      return v28;
    }
    log_OutText(*v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)"parse binary model failed!", v24, v25, v26, v30);
    v27 = getObjcForThisApi_1(v37, v36);
    objc_ReleaseObject(v27, v22 + 16);
    v28 = 2692751367;
  }
  heap_Free(*(_QWORD **)(v37 + 8), (uint64_t)v19);
  return v28;
}

uint64_t fi_ObjcLoad(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  _BYTE __dst[408];
  const void *v36;
  uint64_t v37;
  uint64_t *v38;
  const void *v39;
  uint64_t v40;
  unsigned __int8 v41;
  _QWORD *v42;

  v36 = 0;
  v37 = 0;
  inited = InitRsrcFunction(a1, a2, &v36);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(*(_WORD **)(a5 + 16), *(_QWORD *)(a5 + 24), &v37);
  if ((inited & 0x80000000) != 0)
    return inited;
  v11 = 2692751367;
  memcpy(__dst, v36, sizeof(__dst));
  *(_OWORD *)&__dst[32] = *(_OWORD *)(v37 + 32);
  v12 = *(unsigned int *)(a5 + 40);
  v13 = *(unsigned __int8 *)(a5 + 46);
  v14 = *(unsigned __int16 *)(a5 + 44);
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v38 = 0;
  v39 = 0;
  v15 = heap_Calloc(*(_QWORD **)&__dst[8], 1, 272);
  if (v15)
  {
    v16 = v15;
    if (fi_rsc_create(__dst, &v38))
    {
LABEL_5:
      if (v38)
      {
        fi_rsc_destroy(v38);
        v38 = 0;
      }
      heap_Free(*(_QWORD **)&__dst[8], v16);
      goto LABEL_10;
    }
    *(_QWORD *)v16 = v38;
    if ((ssftriff_reader_ObjOpen(a1, a2, v12, a3, (char *)(a5 + 32), v14 | (v13 << 16), (uint64_t *)&v42) & 0x80000000) != 0)
    {
      v11 = 2692751364;
      goto LABEL_5;
    }
    v29 = ssftriff_reader_OpenChunk((uint64_t)v42, (_BYTE *)&v40 + 4, (unsigned int *)&v40, &v39, v25, v26, v27, v28);
    v33 = v29;
    if ((v29 & 0x80000000) != 0)
    {
      v11 = v29;
      goto LABEL_5;
    }
    if (HIDWORD(v40) ^ 0x4D424946 | v41)
    {
      log_OutText(*v38, (uint64_t)"FastInfer", 0, 0, (uint64_t)"not found chunk: %s", v30, v31, v32, (uint64_t)"FIBM");
      goto LABEL_5;
    }
    v34 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))v38[1])(v38[2], v40);
    *(_QWORD *)(v16 + 8) = v34;
    if (!v34)
    {
      v11 = 2692751370;
      goto LABEL_5;
    }
    memcpy(v34, v39, v40);
    strcpy((char *)(v16 + 16), a3);
    *(_QWORD *)(a4 + 32) = v16;
    v11 = v33;
  }
  else
  {
    v11 = 2692751370;
  }
LABEL_10:
  if (v42)
  {
    ssftriff_reader_CloseChunk((uint64_t)v42);
    ssftriff_reader_ObjClose(v42, v17, v18, v19, v20, v21, v22, v23);
  }
  return v11;
}

uint64_t fi_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  v8 = 0;
  result = InitRsrcFunction(a1, a2, &v8);
  if ((result & 0x80000000) == 0)
  {
    v5 = *(_QWORD **)(a3 + 32);
    if (!v5)
      return 0;
    v6 = v8;
    v7 = (_QWORD *)*v5;
    if (v5[1])
    {
      (*(void (**)(_QWORD))(v7[1] + 48))(v7[2]);
      v5[1] = 0;
    }
    else if (!v7)
    {
LABEL_7:
      heap_Free(*(_QWORD **)(v6 + 8), (uint64_t)v5);
      return 0;
    }
    fi_rsc_destroy(v7);
    goto LABEL_7;
  }
  return result;
}

uint64_t getObjcForThisApi_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char *__s1;

  v2 = a1;
  __s1 = 0;
  if (a2
    && ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
     || !__s1
     || !*__s1
     || !strcmp(__s1, "internal")))
  {
    v2 = a2;
  }
  return *(_QWORD *)(v2 + 48);
}

uint64_t fi_deinit(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t ObjcForThisApi_1;
  uint64_t v8;

  if (!a3)
    return 0;
  if (*a3)
    fi_net_destroy(*a3);
  v6 = a3[1];
  ObjcForThisApi_1 = getObjcForThisApi_1(a1, a2);
  v8 = objc_ReleaseObject(ObjcForThisApi_1, v6 + 16);
  heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)a3);
  return v8;
}

uint64_t fi_predict(uint64_t ***a1, const void **a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  v8 = 2692751360;
  if (!a1)
    return 2692751367;
  v9 = *a1;
  v10 = *v9;
  if (!fi_net_predict(v9, a2, a3, a4, a5, a6, a7, a8))
    return 0;
  log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"FI Prediction failed!", v11, v12, v13, v15);
  return v8;
}

double fabs_fdlibm(double a1)
{
  return fabs(a1);
}

BOOL almost_equal_floats(double a1, float a2)
{
  float v2;
  float32x2_t v4;

  v2 = fabs((float)(*(float *)&a1 - a2));
  if (v2 < 0.00001)
    return 1;
  *((float *)&a1 + 1) = a2;
  v4 = vcvt_f32_f64(vabsq_f64(vcvtq_f64_f32(*(float32x2_t *)&a1)));
  if (v4.f32[0] <= v4.f32[1])
    v4.f32[0] = v4.f32[1];
  return (float)(v2 / v4.f32[0]) < 0.01;
}

float fast_exp_single(float a1)
{
  return expf(fmaxf(fminf(a1, 80.0), -80.0));
}

void fast_exp(float *a1, int a2, float *a3)
{
  float *v3;
  float *v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  float v8;

  v3 = a3;
  v4 = a1;
  if (((a3 | a1) & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      v5 = a2;
      do
      {
        v6 = *v4++;
        *v3++ = expf(fmaxf(fminf(v6, 80.0), -80.0));
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    v7 = a2;
    do
    {
      v8 = *v4++;
      *v3++ = expf(fmaxf(fminf(v8, 80.0), -80.0));
      --v7;
    }
    while (v7);
  }
}

float Q_rsqrt(float a1)
{
  return (float)((float)((float)((float)(a1 * -0.5) * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1)))
                       * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1)))
               + 1.5)
       * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1));
}

float Q_powf_1_75(float a1)
{
  return (float)(a1 * a1)
       * (float)((float)((float)((float)((float)(a1 * -0.25)
                                       * (float)(COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))
                                               * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))))
                               * (float)(COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))
                                       * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))))
                       + 1.25)
               * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2)));
}

float *fill_array_f32(float *result, unsigned int a2, float a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((result & 0x1F) != 0)
  {
    if (a2)
    {
      v3 = a2;
      do
      {
        *result++ = a3;
        --v3;
      }
      while (v3);
    }
  }
  else if (a2)
  {
    v4 = a2;
    do
    {
      *result++ = a3;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t max_array_f32(uint64_t result, float *a2, float *a3)
{
  uint64_t v3;
  uint64_t v4;

  if (((a3 | a2) & 0x1F) != 0)
  {
    if ((_DWORD)result)
    {
      v3 = result;
      do
      {
        if (*a3 > *a2)
          *a2 = *a3;
        ++a2;
        ++a3;
        --v3;
      }
      while (v3);
    }
  }
  else if ((_DWORD)result)
  {
    v4 = result;
    do
    {
      if (*a3 > *a2)
        *a2 = *a3;
      ++a2;
      ++a3;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t relu_array_f32(uint64_t result, float *a2)
{
  uint64_t v2;
  uint64_t v3;

  if ((a2 & 0x1F) != 0)
  {
    if ((_DWORD)result)
    {
      v2 = result;
      do
      {
        if (*a2 < 0.0)
          *a2 = 0.0;
        ++a2;
        --v2;
      }
      while (v2);
    }
  }
  else if ((_DWORD)result)
  {
    v3 = result;
    do
    {
      if (*a2 < 0.0)
        *a2 = 0.0;
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t leaky_array_f32(uint64_t result, float *a2, float a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((a2 & 0x1F) != 0)
  {
    if ((_DWORD)result)
    {
      v3 = result;
      do
      {
        if (*a2 < 0.0)
          *a2 = *a2 * a3;
        ++a2;
        --v3;
      }
      while (v3);
    }
  }
  else if ((_DWORD)result)
  {
    v4 = result;
    do
    {
      if (*a2 < 0.0)
        *a2 = *a2 * a3;
      ++a2;
      --v4;
    }
    while (v4);
  }
  return result;
}

float softsign_array_f32(unsigned int a1, float *a2)
{
  uint64_t v2;
  float result;
  float v4;
  uint64_t v5;
  float v6;

  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      v2 = a1;
      result = 1.0;
      do
      {
        v4 = fabs(*a2);
        *a2 = *a2 / (float)(v4 + 1.0);
        ++a2;
        --v2;
      }
      while (v2);
    }
  }
  else if (a1)
  {
    v5 = a1;
    result = 1.0;
    do
    {
      v6 = fabs(*a2);
      *a2 = *a2 / (float)(v6 + 1.0);
      ++a2;
      --v5;
    }
    while (v5);
  }
  return result;
}

void gmm_c(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;

  if (a2 >= 1)
  {
    v10 = 0;
    v11 = a2;
    v12 = a1;
    do
    {
      if (a1 >= 1)
      {
        v13 = 0;
        v14 = *(float *)(a5 + 4 * v10) * *(float *)(a5 + 4 * v10);
        v15 = *(float *)(a3 + 4 * v10)
            * (float)((float)((float)((float)((float)((float)(v14 * 6.2832) * -0.5)
                                            * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)))
                                    * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)))
                            + 1.5)
                    * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)));
        v16 = 1.0 / (float)((float)(v14 * 2.0) + 1.0e-10);
        do
        {
          v17 = (float)(int)v13 - *(float *)(a4 + 4 * v10);
          *(float *)(a6 + 4 * v13) = *(float *)(a6 + 4 * v13)
                                   + (float)(v15 * expf(fmaxf(fminf(v16 * (float)-(float)(v17 * v17), 80.0), -80.0)));
          ++v13;
        }
        while (v12 != v13);
      }
      ++v10;
    }
    while (v10 != v11);
  }
}

double exp_fdlibm(double a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  double v4;
  double v5;
  double v6;
  double v7;
  int v8;
  unint64_t v9;
  double v10;
  double v11;
  double v12;
  int v13;

  v1 = *(_QWORD *)&a1 >> 63;
  v2 = HIDWORD(*(_QWORD *)&a1) & 0x7FFFFFFFLL;
  if (v2 < 0x40862E42)
  {
    if (v2 < 0x3FD62E43)
    {
      v8 = 0;
      v6 = 0.0;
      if (a1 + 1.0e300 > 1.0 && v2 >> 20 <= 0x3E2)
        return a1 + 1.0;
      v7 = 0.0;
LABEL_19:
      v10 = a1
          - a1
          * a1
          * (a1
           * a1
           * (a1 * a1 * (a1 * a1 * (a1 * a1 * 0.000000041381368 + -0.00000165339022) + 0.0000661375632) + -0.00277777778)
           + 0.166666667);
      v11 = a1 * v10;
      if (v8)
      {
        v12 = v6 - (v7 - v11 / (2.0 - v10)) + 1.0;
        v13 = v8 << 20;
        if (v8 < -1021)
          return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v6 - (v7 - v11 / (2.0 - v10)) + 1.0) | ((unint64_t)(v13 + 1048576000 + HIDWORD(v12)) << 32))
               * 9.33263619e-302;
        v9 = COERCE_UNSIGNED_INT64(v6 - (v7 - v11 / (2.0 - v10)) + 1.0) | ((unint64_t)(v13 + HIDWORD(v12)) << 32);
        return *(double *)&v9;
      }
      a1 = a1 - v11 / (v10 + -2.0);
      return a1 + 1.0;
    }
    if (v2 <= 0x3FF0A2B1)
    {
      v6 = a1 - dbl_1DECEB640[v1];
      v7 = dbl_1DECEB650[v1];
      v8 = (a1 >= 0.0) - (*(_QWORD *)&a1 >> 63);
LABEL_18:
      a1 = v6 - v7;
      goto LABEL_19;
    }
LABEL_17:
    v8 = (int)(dbl_1DECEB630[v1] + a1 * 1.44269504);
    v6 = a1 + (double)v8 * -0.69314718;
    v7 = (double)v8 * 1.90821493e-10;
    goto LABEL_18;
  }
  if (v2 >> 20 < 0x7FF)
  {
    if (a1 > 709.782713)
    {
      v9 = 0x7FF0000000000000;
      return *(double *)&v9;
    }
    v4 = 0.0;
    if (a1 < -745.133219)
      return v4;
    goto LABEL_17;
  }
  v3 = HIDWORD(a1) & 0xFFFFF | LODWORD(a1);
  v4 = 0.0;
  if (a1 >= 0.0)
    v4 = a1;
  v5 = a1 + a1;
  if (v3)
    return v5;
  return v4;
}

double log_fdlibm(double a1)
{
  uint64_t v1;
  int v2;
  unsigned int v4;
  int v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;

  v1 = HIDWORD(*(_QWORD *)&a1);
  if (SHIDWORD(a1) >= 0x100000)
  {
    v2 = -1023;
  }
  else
  {
    if (!(HIDWORD(a1) & 0x7FFFFFFF | LODWORD(a1)))
      return 4286578690.0;
    if ((*(_QWORD *)&a1 & 0x8000000000000000) != 0)
      return 2147483650.0;
    a1 = a1 * 1.80143985e16;
    v1 = HIDWORD(*(_QWORD *)&a1);
    v2 = -1077;
  }
  if ((int)v1 >= 2146435072)
    return a1 + a1;
  v4 = (v1 & 0xFFFFF) + 614244;
  v5 = v2 + ((int)v1 >> 20) + (v4 >> 20);
  v6 = COERCE_DOUBLE(LODWORD(a1) | ((unint64_t)((v4 & 0x100000 | v1 & 0xFFFFF) ^ 0x3FF00000) << 32)) + -1.0;
  if ((((_DWORD)v1 + 2) & 0xFFFFFu) > 2)
  {
    v9 = v6 / (v6 + 2.0);
    v10 = (double)v5;
    v11 = v9 * v9;
    v12 = v11 * v11 * (v11 * v11 * (v11 * v11 * 0.153138377 + 0.222221984) + 0.4)
        + v11 * (v11 * v11 * (v11 * v11 * (v11 * v11 * 0.147981986 + 0.181835722) + 0.285714287) + 0.666666667);
    if ((int)(((v1 & 0xFFFFF) - 398458) | (440401 - (v1 & 0xFFFFF))) < 1)
    {
      v16 = v6 - v12;
      if (!v5)
        return v6 - v9 * v16;
      v15 = v10 * -1.90821493e-10 + v9 * v16;
    }
    else
    {
      v13 = v6 * (v6 * 0.5);
      v14 = v13 + v12;
      if (!v5)
      {
        v8 = v13 - v9 * v14;
        return v6 - v8;
      }
      v15 = v13 - (v10 * 1.90821493e-10 + v9 * v14);
    }
    return -(v15 - v6 - v10 * 0.69314718);
  }
  v7 = fabs(v6);
  if (v7 >= 1.0e-150 && v7 / fmax(v7, 0.0) >= 0.00000001)
  {
    v8 = v6 * v6 * (v6 * -0.333333333 + 0.5);
    if (v5)
      return -(v8 + (double)v5 * -1.90821493e-10 - v6 - (double)v5 * 0.69314718);
    return v6 - v8;
  }
  if (v5)
    return (double)v5 * 1.90821493e-10 + (double)v5 * 0.69314718;
  else
    return 0.0;
}

float get_amp(uint64_t a1, float *a2, unsigned int a3)
{
  uint64_t v3;
  float *v4;
  float result;

  if (a3)
  {
    v3 = a3;
    v4 = (float *)(a1 + 4);
    do
    {
      result = sqrtf((float)(*v4 * *v4) + (float)(*(v4 - 1) * *(v4 - 1)));
      *a2++ = result;
      v4 += 2;
      --v3;
    }
    while (v3);
  }
  return result;
}

float reflect_padding(uint64_t a1, int a2, int a3)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  float result;

  if (a3)
  {
    v3 = a3 + 1;
    if ((a3 + 1) > 2)
      v4 = (a3 + 1);
    else
      v4 = 2;
    v5 = a3 - 1;
    v6 = v4 - 1;
    v7 = v6;
    do
    {
      *(_DWORD *)(a1 + 4 * v5--) = *(_DWORD *)(a1 + 4 * v3++);
      --v7;
    }
    while (v7);
    v8 = a3 + a2;
    v9 = a3 + a2 - 2;
    do
    {
      result = *(float *)(a1 + 4 * v9);
      *(float *)(a1 + 4 * v8++) = result;
      --v9;
      --v6;
    }
    while (v6);
  }
  return result;
}

float interleave(int a1, int *a2, float *a3, uint64_t a4)
{
  uint64_t v4;
  float *v5;
  int v6;
  float v7;
  float result;
  uint64_t v9;
  float *v10;
  int v11;
  float v12;

  if ((((a3 | a2) | a4) & 0x1F) != 0)
  {
    if (a1 >= 1)
    {
      v4 = a1;
      v5 = (float *)(a4 + 4);
      do
      {
        v6 = *a2++;
        *((_DWORD *)v5 - 1) = v6;
        v7 = *a3++;
        result = v7;
        *v5 = v7;
        v5 += 2;
        --v4;
      }
      while (v4);
    }
  }
  else if (a1 >= 1)
  {
    v9 = a1;
    v10 = (float *)(a4 + 4);
    do
    {
      v11 = *a2++;
      *((_DWORD *)v10 - 1) = v11;
      v12 = *a3++;
      result = v12;
      *v10 = v12;
      v10 += 2;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t sample_from_pdf(float *a1, int a2, float a3, float a4, float a5)
{
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t result;
  float *v20;
  uint64_t v21;
  uint64_t v22;

  v9 = a2;
  if (a2 <= 0)
  {
    fast_exp(a1, a2, a1);
    v16 = 1.0e-18;
  }
  else
  {
    v10 = 0;
    v11 = a3 + 1.0;
    do
    {
      a1[v10] = v11 * a1[v10];
      ++v10;
    }
    while (a2 != v10);
    fast_exp(a1, a2, a1);
    v12 = 0.0;
    v13 = v9;
    v14 = a1;
    do
    {
      v15 = *v14++;
      v12 = v12 + v15;
      --v13;
    }
    while (v13);
    v16 = v12 + 1.0e-18;
  }
  v17 = 1.0 / v16;
  v18 = fmaxf(-(float)(a4 - (float)(v17 * *a1)), 0.0);
  *a1 = v18;
  result = (a2 - 1);
  if (a2 > 1)
  {
    v20 = a1 + 1;
    v21 = v9 - 1;
    do
    {
      v18 = v18 + fmaxf((float)(v17 * *v20) - a4, 0.0);
      *v20++ = v18;
      --v21;
    }
    while (v21);
    v22 = 0;
    while ((float)(a1[(int)result] * a5) > a1[v22])
    {
      if (result == ++v22)
        return result;
    }
    return v22;
  }
  return result;
}

float prepare_cdf(float *a1, unsigned int a2, float a3, float a4)
{
  uint64_t v7;
  float v8;
  uint64_t v9;
  float v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  uint64_t v17;

  if (a2)
  {
    v7 = 0;
    v8 = a3 + 1.0;
    v9 = a2;
    do
    {
      a1[v7] = v8 * a1[v7];
      ++v7;
    }
    while (a2 != v7);
    fast_exp(a1, a2, a1);
    v10 = 0.0;
    v11 = a1;
    do
    {
      v12 = *v11++;
      v10 = v10 + v12;
      --v9;
    }
    while (v9);
    v13 = v10 + 1.0e-18;
  }
  else
  {
    fast_exp(a1, 0, a1);
    v13 = 1.0e-18;
  }
  v14 = 1.0 / v13;
  v15 = fmaxf(-(float)(a4 - (float)(v14 * *a1)), 0.0);
  *a1 = v15;
  if (a2 >= 2)
  {
    v16 = a1 + 1;
    v17 = a2 - 1;
    do
    {
      v15 = v15 + fmaxf((float)(v14 * *v16) - a4, 0.0);
      *v16++ = v15;
      --v17;
    }
    while (v17);
  }
  return a1[a2 - 1];
}

uint64_t sample_cdf(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t v3;
  uint64_t v5;
  float v6;
  uint64_t result;

  v3 = a2 - 1;
  if (a2 == 1)
    return 0;
  v5 = 0;
  v6 = *(float *)(a1 + 4 * v3) * a3;
  result = a2 >> 1;
  while (*(float *)(a1 + 4 * v5) < v6)
  {
    if (v3 == ++v5)
      return result;
  }
  return v5;
}

void celt_lpc(void *a1, void *a2, float *a3, unsigned int a4)
{
  float v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float *v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  unint64_t v18;
  uint64_t v19;
  float v20;
  float v21;

  v8 = *a3;
  v9 = 4 * a4;
  bzero(a1, v9);
  bzero(a2, v9);
  if (*a3 != 0.0)
  {
    v10 = 0;
    v11 = -1;
    do
    {
      if (v10 == a4)
        break;
      v12 = 0.0;
      if (v10)
      {
        v13 = (float *)a1;
        v14 = v10;
        do
        {
          v15 = *v13++;
          v12 = v12 + (float)(v15 * a3[v14--]);
        }
        while (v14);
      }
      v16 = v10 + 1;
      v17 = (float)-(float)(v12 + a3[(v10 + 1)]) / v8;
      *((float *)a2 + v10) = v17;
      *((float *)a1 + v10) = v17;
      if (((v10 + 1) & 0xFFFFFFFELL) != 0)
      {
        v18 = 0;
        v19 = v11;
        do
        {
          v20 = *((float *)a1 + v18);
          v21 = *((float *)a1 + v19);
          *((float *)a1 + v18) = v20 + (float)(v17 * v21);
          *((float *)a1 + v19) = v21 + (float)(v17 * v20);
          ++v18;
          --v19;
        }
        while (v18 < v16 >> 1);
      }
      v8 = v8 + (float)((float)-(float)(v17 * v17) * v8);
      ++v11;
      v10 = v16;
    }
    while (v8 >= (float)(*a3 * 0.001));
  }
}

float ulaw2lin8(float a1)
{
  float v1;
  float v2;

  v1 = a1 + -128.0;
  v2 = flt_1DECEB5F0[v1 >= 0.0];
  return v2 * (float)(expf(fmaxf(fminf((float)(fabsf(v1) * 0.0078125) * 5.5452, 80.0), -80.0)) + -1.0);
}

uint64_t lin2ulaw8(float a1)
{
  float v1;
  float v2;
  float v3;
  float v4;
  BOOL v5;
  float v6;

  v1 = (float)(fabsf(a1) * 0.007782) + 1.0;
  if (a1 < 0.0)
    v2 = -(float)((float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
                                        + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                                + -1.5)
                                                        * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 128.0)/ 5.5452);
  else
    v2 = (float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
                               + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 128.0)/ 5.5452;
  v3 = v2 + 128.0;
  if (v3 < 0.0)
    v3 = 0.0;
  v4 = v3 + 0.5;
  v5 = v3 <= 255.0;
  v6 = 255.5;
  if (v5)
    return v4;
  return v6;
}

float ulaw2lin7(float a1)
{
  float v1;
  float v2;

  v1 = a1 + -64.0;
  v2 = flt_1DECEB5F8[v1 >= 0.0];
  return v2 * (float)(expf(fmaxf(fminf((float)(fabsf(v1) * 0.015625) * 4.852, 80.0), -80.0)) + -1.0);
}

uint64_t lin2ulaw7(float a1)
{
  float v1;
  float v2;
  float v3;
  float v4;
  BOOL v5;
  float v6;

  v1 = (float)(fabsf(a1) * 0.0038757) + 1.0;
  if (a1 < 0.0)
    v2 = -(float)((float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
                                        + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                                + -1.5)
                                                        * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 64.0)/ 4.852);
  else
    v2 = (float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
                               + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 64.0)/ 4.852;
  v3 = v2 + 64.0;
  if (v3 < 0.0)
    v3 = 0.0;
  v4 = v3 + 0.5;
  v5 = v3 <= 127.0;
  v6 = 127.5;
  if (v5)
    return v4;
  return v6;
}

uint64_t opus_fft_alloc_twiddles(uint64_t *a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  __float2 v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  uint64_t v29;
  unint64_t v30;
  __int16 *v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  _WORD *v35;
  uint64_t v36;
  uint64_t v38;

  *a3 = 0;
  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 64))(a1[2], 1, 64);
  v10 = v6;
  if (v6)
  {
    *(_DWORD *)v6 = a2;
    *(float *)(v6 + 4) = 1.0 / (float)a2;
    v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 8 * a2);
    *(_QWORD *)(v10 + 56) = v11;
    if (v11)
    {
      v15 = a2;
      if (a2)
      {
        v16 = 0;
        v17 = (float *)(v11 + 4);
        do
        {
          v18 = __sincosf_stret((float)(-6.2832 / (float)a2) * (float)v16);
          *(v17 - 1) = v18.__cosval;
          *v17 = v18.__sinval;
          ++v16;
          v17 += 2;
        }
        while (a2 != v16);
      }
      v19 = 0;
      v20 = 0;
      *(_DWORD *)(v10 + 8) = -1;
      v21 = v10 + 12;
      v22 = 1;
      v23 = a2;
      v24 = 4;
      do
      {
        v25 = v22;
        v26 = v19;
        if (v23 % v24)
        {
          do
          {
            v27 = v24 + 2;
            if (v24 == 2)
              v27 = 3;
            if (v24 == 4)
              v24 = 2;
            else
              v24 = v27;
            if (v24 * v24 > v23 || v24 > 0x7D00)
              v24 = v23;
          }
          while (v23 % v24);
          if (v24 > 5)
          {
            v36 = 7;
            goto LABEL_37;
          }
        }
        v29 = 2 * v20;
        *(_WORD *)(v21 + 2 * v29) = v24;
        if (v24 == 2 && v20 >= 2)
        {
          *(_WORD *)(v21 + 2 * v29) = 4;
          *(_WORD *)(v10 + 16) = 2;
        }
        v23 /= v24;
        ++v20;
        ++v22;
        v19 = v26 + 2;
      }
      while (v23 > 1);
      if (v20 >= 2)
      {
        v30 = (unint64_t)v25 >> 1;
        if (v30 <= 1)
          v30 = 1;
        v31 = (__int16 *)(v10 + 12);
        do
        {
          v32 = *v31;
          *v31 = *(_WORD *)(v21 + 2 * v26);
          v31 += 2;
          *(_WORD *)(v21 + 2 * v26) = v32;
          v26 -= 2;
          --v30;
        }
        while (v30);
      }
      if (v20)
      {
        v33 = 0;
        v34 = 2 * v25;
        do
        {
          a2 /= *(unsigned __int16 *)(v21 + 2 * v33);
          *(_WORD *)(v21 + 2 * (v33 + 1)) = a2;
          v33 += 2;
        }
        while (v34 != v33);
      }
      v35 = (_WORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 2 * v15);
      *(_QWORD *)(v10 + 48) = v35;
      if (v35)
      {
        compute_bitrev_table(0, v35, 1, (unsigned __int16 *)(v10 + 12));
        v36 = 0;
        goto LABEL_42;
      }
    }
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v38);
    v36 = 10;
LABEL_37:
    if (*(_QWORD *)(v10 + 56))
    {
      (*(void (**)(uint64_t))(a1[1] + 80))(a1[2]);
      *(_QWORD *)(v10 + 56) = 0;
    }
    if (*(_QWORD *)(v10 + 48))
    {
      (*(void (**)(uint64_t))(a1[1] + 80))(a1[2]);
      *(_QWORD *)(v10 + 48) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(a1[1] + 80))(a1[2], v10);
    v10 = 0;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v38);
    v36 = 10;
  }
LABEL_42:
  *a3 = v10;
  return v36;
}

uint64_t compute_bitrev_table(uint64_t result, _WORD *a2, uint64_t a3, unsigned __int16 *a4)
{
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  unsigned __int16 *v10;
  uint64_t v11;
  uint64_t v12;

  v5 = result;
  v6 = *a4;
  v7 = a4[1];
  if (v7 == 1)
  {
    if (*a4)
    {
      v8 = 0;
      do
      {
        *a2 = v8++ + result;
        a2 += a3;
      }
      while (v6 > (unsigned __int16)v8);
    }
  }
  else if (*a4)
  {
    v9 = 0;
    v10 = a4 + 2;
    v11 = v6 * a3;
    v12 = 2 * a3;
    do
    {
      result = compute_bitrev_table((unsigned __int16)v5, a2, v11, v10);
      v5 += v7;
      ++v9;
      a2 = (_WORD *)((char *)a2 + v12);
    }
    while ((int)v6 > (__int16)v9);
  }
  return result;
}

uint64_t opus_fft_impl(uint64_t result, int8x16_t *a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  int8x16_t *v14;
  float32x4_t v15;
  int8x16_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  float *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  float *v30;
  uint64_t v31;
  float *v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  uint64_t v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  float *v71;
  float v72;
  float v73;
  float *v74;
  float v75;
  float v76;
  float *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  float *v86;
  uint64_t v87;
  float *v88;
  float *v89;
  float *v90;
  __int8 *v91;
  float *v92;
  float *v93;
  float *v94;
  float *v95;
  float *v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float *i;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  float v155;
  float v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  float *v168;
  float *v169;
  float *v170;
  char *v171;
  float *v172;
  float *v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float *v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float *v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  float *i32;
  int v202;
  uint64_t v203;
  uint64_t v204;
  __int8 *v206;
  _DWORD v207[8];
  uint64_t v208;

  v208 = *MEMORY[0x1E0C80C00];
  v2 = 1;
  v3 = *(_DWORD *)(result + 8);
  v207[0] = 1;
  v4 = (unsigned __int16 *)(result + 14);
  v5 = -1;
  v6 = 1;
  do
  {
    v6 *= *(v4 - 1);
    v207[v2] = v6;
    v7 = *v4;
    v4 += 2;
    ++v2;
    v5 += 2;
  }
  while (v7 != 1);
  v202 = v3 & ~(v3 >> 31);
  v8 = *(unsigned __int16 *)(result + 2 * v5 + 12);
  v206 = &a2->i8[4];
  i32 = (float *)a2[2].i32;
  v9 = v2 - 2;
  v203 = result;
  do
  {
    v10 = v8;
    v204 = v9;
    if (v9)
    {
      v11 = 2 * v9;
      v8 = *(unsigned __int16 *)(result + 4 * (int)v9 + 10);
      v12 = v9;
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v8 = 1;
    }
    switch(*(_WORD *)(result + 2 * v11 + 12))
    {
      case 2:
        v13 = v207[v12];
        if (v10 == 1)
        {
          if (v13)
          {
            v14 = a2;
            do
            {
              v15 = (float32x4_t)vextq_s8(*v14, *v14, 8uLL);
              v16.i64[0] = vaddq_f32(v15, *(float32x4_t *)v14).u64[0];
              v16.i64[1] = vsubq_f32(v15, *(float32x4_t *)v14).i64[1];
              *v14++ = v16;
              --v13;
            }
            while (v13);
          }
        }
        else
        {
          for (i = i32; v13; --v13)
          {
            v137 = *i;
            v138 = i[1];
            v139 = *(i - 8);
            v140 = *(i - 7);
            *i = v139 - *i;
            i[1] = v140 - v138;
            *(i - 8) = v137 + v139;
            *(i - 7) = v138 + v140;
            v141 = i[2];
            v142 = i[3];
            v143 = (float)(v141 + v142) * 0.70711;
            v144 = (float)(v142 - v141) * 0.70711;
            v145 = *(i - 6);
            v146 = *(i - 5);
            i[2] = v145 - v143;
            i[3] = v146 - v144;
            *(i - 6) = v145 + v143;
            *(i - 5) = v144 + v146;
            v148 = i[4];
            v147 = i[5];
            v149 = *(i - 4);
            v150 = *(i - 3);
            i[4] = v149 - v147;
            i[5] = v148 + v150;
            *(i - 4) = v147 + v149;
            *(i - 3) = v150 - v148;
            v152 = i[6];
            v151 = i[7];
            v153 = (float)(v151 - v152) * 0.70711;
            v154 = (float)(v151 + v152) * -0.70711;
            v155 = *(i - 2);
            v156 = *(i - 1);
            i[6] = v155 - v153;
            i[7] = v156 - v154;
            *(i - 2) = v155 + v153;
            *(i - 1) = v154 + v156;
            i += 16;
          }
        }
        break;
      case 3:
        v17 = v207[v12];
        if ((_DWORD)v17)
        {
          v18 = 0;
          v19 = 0;
          v20 = ((_DWORD)v17 << v202);
          v21 = *(_QWORD *)(v203 + 56);
          v22 = v10;
          v23 = *(float *)(v21 + 8 * v20 * (unint64_t)v10 + 4);
          v24 = 2 * v10;
          v25 = (float *)(v21 + 4);
          v26 = 16 * v20;
          v27 = 4 * v22;
          v28 = 8 * v20;
          do
          {
            v29 = v25;
            v30 = v25;
            v31 = v22;
            v32 = (float *)&v206[8 * v18];
            do
            {
              v33 = &v32[v24];
              v34 = v32[v24 - 1];
              v35 = v32[v24];
              v36 = *(v29 - 1);
              v37 = (float)(v34 * v36) - (float)(v35 * *v29);
              v38 = (float)(v36 * v35) + (float)(v34 * *v29);
              v39 = &v32[v27];
              v40 = v32[v27 - 1];
              v41 = v32[4 * v22];
              v42 = *(v30 - 1);
              v43 = (float)(v40 * v42) - (float)(v41 * *v30);
              v44 = (float)(v42 * v41) + (float)(v40 * *v30);
              v45 = v38 + v44;
              v46 = v38 - v44;
              *(v33 - 1) = *(v32 - 1) - (float)((float)(v37 + v43) * 0.5);
              *v33 = *v32 - (float)(v45 * 0.5);
              v47 = v23 * (float)(v37 - v43);
              v48 = v23 * v46;
              *(v32 - 1) = (float)(v37 + v43) + *(v32 - 1);
              *v32 = v45 + *v32;
              v32 += 2;
              v49 = *v33 - v47;
              *(v39 - 1) = v48 + *(v33 - 1);
              *v39 = v49;
              v50 = *(v33 - 1) - v48;
              v51 = v47 + *v33;
              *(v33 - 1) = v50;
              *v33 = v51;
              v30 = (float *)((char *)v30 + v26);
              v29 = (float *)((char *)v29 + v28);
              --v31;
            }
            while (v31);
            ++v19;
            v18 += v8;
          }
          while (v19 != v17);
        }
        break;
      case 4:
        v52 = v207[v12];
        if (v10 == 1)
        {
          if ((_DWORD)v52)
          {
            v53 = (float *)a2;
            do
            {
              v54 = v53[1];
              v55 = v53[4];
              v56 = v53[5];
              v57 = *v53 - v55;
              v58 = v54 - v56;
              v59 = *v53 + v55;
              v60 = v54 + v56;
              v61 = v53[2];
              v62 = v53[3];
              v63 = v53[6];
              v64 = v53[7];
              v53[4] = v59 - (float)(v61 + v63);
              v53[5] = v60 - (float)(v62 + v64);
              *v53 = v59 + (float)(v61 + v63);
              v53[1] = v60 + (float)(v62 + v64);
              v53[2] = v57 + (float)(v62 - v64);
              v53[3] = v58 - (float)(v61 - v63);
              v53[6] = v57 - (float)(v62 - v64);
              v53[7] = v58 + (float)(v61 - v63);
              v53 += 8;
              LODWORD(v52) = v52 - 1;
            }
            while ((_DWORD)v52);
          }
        }
        else if ((_DWORD)v52)
        {
          v157 = 0;
          v158 = 0;
          v159 = ((_DWORD)v52 << v202);
          v160 = *(_QWORD *)(v203 + 56) + 4;
          v161 = 24 * v159;
          v162 = 16 * v159;
          v163 = 8 * v159;
          do
          {
            if (v10)
            {
              v164 = 0;
              v165 = (uint64_t)&v206[8 * v10 + 8 * v157];
              v166 = (uint64_t)&v206[16 * v10 + 8 * v157];
              v167 = (uint64_t)&v206[24 * v10 + 8 * v157];
              v168 = (float *)v160;
              v169 = (float *)v160;
              v170 = (float *)v160;
              v171 = &v206[8 * v157];
              do
              {
                v172 = (float *)&v171[v164];
                v173 = (float *)(v165 + v164);
                v174 = *(float *)(v165 + v164 - 4);
                v175 = *(float *)(v165 + v164);
                v176 = *(v168 - 1);
                v177 = (float)(v174 * v176) - (float)(v175 * *v168);
                v178 = (float)(v176 * v175) + (float)(v174 * *v168);
                v179 = (float *)(v166 + v164);
                v180 = *(float *)(v166 + v164 - 4);
                v181 = *(float *)(v166 + v164);
                v182 = *(v169 - 1);
                v183 = (float)(v180 * v182) - (float)(v181 * *v169);
                v184 = (float)(v182 * v181) + (float)(v180 * *v169);
                v185 = (float *)(v167 + v164);
                v186 = *(float *)(v167 + v164 - 4);
                v187 = *(float *)(v167 + v164);
                v188 = *(v170 - 1);
                v189 = (float)(v186 * v188) - (float)(v187 * *v170);
                v190 = (float)(v188 * v187) + (float)(v186 * *v170);
                v191 = *(float *)&v171[v164 - 4];
                v192 = *(float *)&v171[v164];
                v193 = v191 - v183;
                v194 = v192 - v184;
                v195 = v183 + v191;
                v196 = v184 + v192;
                v197 = v177 + v189;
                v198 = v178 + v190;
                v199 = v177 - v189;
                v200 = v178 - v190;
                *(v179 - 1) = v195 - v197;
                *v179 = v196 - v198;
                *(v172 - 1) = v195 + v197;
                *v172 = v198 + v196;
                *(v173 - 1) = v193 + v200;
                *v173 = v194 - v199;
                v164 += 8;
                *(v185 - 1) = v193 - v200;
                *v185 = v194 + v199;
                v170 = (float *)((char *)v170 + v161);
                v169 = (float *)((char *)v169 + v162);
                v168 = (float *)((char *)v168 + v163);
              }
              while (8 * v10 != (_DWORD)v164);
            }
            ++v158;
            v157 += v8;
          }
          while (v158 != v52);
        }
        break;
      case 5:
        v65 = v207[v12];
        if ((_DWORD)v65)
        {
          v66 = 0;
          v67 = 0;
          v68 = ((_DWORD)v65 << v202);
          v69 = *(_QWORD *)(v203 + 56);
          v70 = v68 * (unint64_t)v10;
          v71 = (float *)(v69 + 8 * v70);
          v72 = *v71;
          v73 = v71[1];
          v74 = (float *)(v69 + 16 * v70);
          v75 = *v74;
          v76 = v74[1];
          v77 = (float *)(v69 + 4);
          v78 = 24 * v68;
          v79 = 32 * v68;
          v80 = 16 * v68;
          v81 = 8 * v68;
          do
          {
            if (v10)
            {
              v82 = 0;
              v83 = (uint64_t)&a2[2 * v10].i64[v66];
              v84 = (uint64_t)&a2->i64[3 * v10 + v66];
              v85 = (uint64_t)&a2[v10].i64[v66];
              v86 = v77;
              v87 = (uint64_t)&a2->i64[v10 + v66];
              v88 = v77;
              v89 = v77;
              v90 = v77;
              v91 = &a2->i8[8 * v66];
              do
              {
                v92 = (float *)(v83 + v82);
                v93 = (float *)(v84 + v82);
                v94 = (float *)(v85 + v82);
                v95 = (float *)(v87 + v82);
                v96 = (float *)&v91[v82];
                v98 = *(float *)&v91[v82];
                v97 = *(float *)&v91[v82 + 4];
                v99 = *(v86 - 1);
                v100 = *(float *)(v87 + v82);
                v101 = *(float *)(v87 + v82 + 4);
                v102 = (float)(v100 * v99) - (float)(v101 * *v86);
                v103 = (float)(v99 * v101) + (float)(v100 * *v86);
                v105 = *(float *)(v85 + v82);
                v104 = *(float *)(v85 + v82 + 4);
                v106 = *(v88 - 1);
                v107 = (float)(v105 * v106) - (float)(v104 * *v88);
                v108 = (float)(v106 * v104) + (float)(v105 * *v88);
                v109 = *(v90 - 1);
                v110 = *(float *)(v84 + v82);
                v111 = *(float *)(v84 + v82 + 4);
                v112 = (float)(v110 * v109) - (float)(v111 * *v90);
                v113 = v109 * v111;
                v114 = *(v89 - 1);
                v115 = *(float *)(v83 + v82);
                v116 = *(float *)(v83 + v82 + 4);
                v117 = v113 + (float)(v110 * *v90);
                v118 = (float)(v115 * v114) - (float)(v116 * *v89);
                v119 = (float)(v114 * v116) + (float)(v115 * *v89);
                v120 = v102 + v118;
                v121 = v103 + v119;
                v122 = v102 - v118;
                v123 = v103 - v119;
                v124 = v107 + v112;
                v125 = v108 + v117;
                v126 = v107 - v112;
                v127 = v108 - v117;
                *v96 = v98 + (float)(v124 + v120);
                v96[1] = v97 + (float)(v125 + v121);
                v128 = v98 + (float)((float)(v75 * v124) + (float)(v120 * v72));
                v129 = v97 + (float)((float)(v75 * v125) + (float)(v121 * v72));
                v130 = (float)(v76 * v127) + (float)(v123 * v73);
                v131 = (float)(v76 * v126) + (float)(v122 * v73);
                v132 = v98 + (float)((float)(v72 * v124) + (float)(v120 * v75));
                v133 = v97 + (float)((float)(v72 * v125) + (float)(v121 * v75));
                v134 = (float)(v127 * v73) - (float)(v123 * v76);
                *v95 = v128 - v130;
                v95[1] = v129 + v131;
                v135 = (float)(v122 * v76) - (float)(v126 * v73);
                *v92 = v130 + v128;
                v92[1] = v129 - v131;
                v82 += 8;
                v90 = (float *)((char *)v90 + v78);
                *v94 = v134 + v132;
                v94[1] = v133 + v135;
                *v93 = v132 - v134;
                v93[1] = v133 - v135;
                v89 = (float *)((char *)v89 + v79);
                v88 = (float *)((char *)v88 + v80);
                v86 = (float *)((char *)v86 + v81);
              }
              while (8 * v10 != v82);
            }
            ++v67;
            v66 += v8;
          }
          while (v67 != v65);
        }
        break;
      default:
        break;
    }
    result = v203;
    v9 = v204 - 1;
  }
  while (v204 > 0);
  return result;
}

uint64_t opus_fft_c(unsigned int *a1, float32x2_t *a2, int8x16_t *a3)
{
  uint64_t v3;
  const float *v4;
  unsigned __int16 *v5;
  float32x2_t v6;
  uint64_t v7;
  unsigned int v8;
  float32x2_t v9;

  v3 = *a1;
  if ((_DWORD)v3)
  {
    v4 = (const float *)(a1 + 1);
    v5 = (unsigned __int16 *)*((_QWORD *)a1 + 6);
    v6 = vld1_dup_f32(v4);
    do
    {
      v8 = *v5++;
      v7 = v8;
      v9 = *a2++;
      *(float32x2_t *)&a3->i8[8 * v7] = vmul_f32(v6, v9);
      --v3;
    }
    while (v3);
  }
  return opus_fft_impl((uint64_t)a1, a3);
}

float window_function(int a1, float a2, float a3)
{
  float v3;

  v3 = -1.0;
  if (a1 == 1)
    return 1.0 - fabsf((float)(a2 - (float)((float)(a3 + -1.0) * 0.5)) / (float)(a3 * 0.5));
  if (!a1)
    return (float)(cosf((float)(a2 * 6.2832) / (float)(a3 + -1.0)) * -0.5) + 0.5;
  return v3;
}

uint64_t fi_stft(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  uint64_t v14;
  float *v15;
  float *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int i;
  _OWORD v21[4];
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = 0;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v14 = a7;
  v15 = (float *)(a2 + 4 * a7);
  v16 = &v15[a7];
  reflect_padding(a3, a5, a7 >> 1);
  v17 = fft_plan_dft_r2c_1d(a1, v14, (uint64_t)v16, a4, 3u, (unsigned int *)&v23);
  if (!(_DWORD)v17)
  {
    v18 = a8 + a8 * (a5 / a8);
    if (v18)
    {
      for (i = 0; i < v18; i += a8)
      {
        xmy_toz(a7, v15, (float *)(a3 + 4 * i), v16);
        v21[2] = v25;
        v21[3] = v26;
        v22 = v27;
        v21[0] = v23;
        v21[1] = v24;
        fft_execute((unsigned int *)v21);
        *(_QWORD *)&v25 = v25 + 8 * v14;
      }
    }
    *(_QWORD *)&v25 = &v16[a7];
  }
  fft_destroy_plan(a1, (uint64_t)&v23);
  return v17;
}

uint64_t fi_istft(uint64_t *a1, float *a2, uint64_t a3, float *a4, unsigned int a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t v10;
  uint64_t *v13;
  int v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, uint64_t, uint64_t);
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  float *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  float *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  float *v44;
  double v45;
  uint64_t v47;
  float *v48;
  uint64_t *v49;
  float *v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  unsigned int v54;
  int v55;
  int v57;
  _OWORD v58[4];
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;

  LODWORD(v10) = a5;
  v13 = a1;
  v14 = a8 * a5;
  v57 = a7 - a8;
  v64 = 0;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v52 = a7 + a8 - 1;
  v15 = v52 / a8;
  v16 = v52 / a8 - 1;
  v17 = v52 / a8 < a5 && a7 >= a8;
  v19 = a1[1];
  v18 = a1[2];
  v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v19 + 16);
  v21 = v16 * a8;
  v55 = a8 * a5 + a7 - a8;
  v53 = v16 * a8 + a7;
  if (v17)
    v22 = v21 + a7;
  else
    v22 = a8 * a5 + (_DWORD)a7 - a8;
  v23 = v20(v18, v22, 4);
  if (v23)
  {
    v27 = (float *)v23;
    v54 = a8;
    v51 = v14;
    v28 = &a2[a7];
    v29 = fft_plan_dft_c2r_1d((uint64_t)v13, a7, (uint64_t)&v28[a7 + a7], (uint64_t)&v28[a7], 3u, (unsigned int *)&v60);
    if ((_DWORD)v29)
    {
      v30 = v29;
LABEL_40:
      v45 = fft_destroy_plan((uint64_t)v13, (uint64_t)&v60);
      (*(void (**)(uint64_t, float *, double))(v13[1] + 48))(v13[2], v27, v45);
      return v30;
    }
    v50 = a2;
    v31 = a7 + ((_DWORD)v10 - 1) * v54;
    v32 = a4;
    bzero(a4, 4 * v31);
    if ((_DWORD)v10)
    {
      v48 = v27;
      v49 = v13;
      v33 = 0;
      v34 = 0;
      v10 = v10;
      v35 = v10;
      do
      {
        *(_QWORD *)&v61 = a3 + 8 * v33;
        v58[2] = v62;
        v58[3] = v63;
        v59 = v64;
        v58[0] = v60;
        v58[1] = v61;
        fft_execute((unsigned int *)v58);
        fi_multiply_add_ansic(&a4[v34], &v28[a7], v28, a7);
        v34 += v54;
        v33 += a7;
        --v35;
      }
      while (v35);
      v27 = v48;
      v13 = v49;
      v32 = a4;
      if (v15 < v10)
      {
        if (a7 < v54)
        {
          log_OutText(*v49, (uint64_t)"FastInfer", 0, 0, (uint64_t)"hop_size > window_size!", v36, v37, v38, (uint64_t)v48);
          v30 = 7;
          goto LABEL_40;
        }
        if (v52 >= v54)
        {
          v41 = 0;
          if (v15 <= 1)
            v42 = 1;
          else
            v42 = v15;
          do
          {
            axpy(a7, v50, 1, &v48[v41], 1, 1.0);
            v41 += v54;
            --v42;
          }
          while (v42);
        }
        v43 = v53;
        if ((_DWORD)v53)
        {
          v44 = v48;
          do
          {
            if (*v44 != 0.0)
              *v44 = 1.0 / *v44;
            ++v44;
            --v43;
          }
          while (v43);
        }
        xmy(v15 * v54, v48, 1, a4, 1);
        xmy(v57, &v48[v15 * v54], 1, &a4[v51], 1);
        do
        {
          xmy(v54, &v48[v21], 1, &a4[v15 * v54], 1);
          ++v15;
        }
        while (v15 != (_DWORD)v10);
LABEL_39:
        v30 = 0;
        goto LABEL_40;
      }
      v39 = 0;
      do
      {
        axpy(a7, v50, 1, &v48[v39], 1, 1.0);
        v39 += v54;
        --v10;
      }
      while (v10);
    }
    if ((_DWORD)v31)
    {
      v40 = v27;
      do
      {
        if (*v40 != 0.0)
          *v40 = 1.0 / *v40;
        ++v40;
        --v31;
      }
      while (v31);
    }
    xmy(v55, v27, 1, v32, 1);
    goto LABEL_39;
  }
  log_OutText(*v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed", v24, v25, v26, v47);
  fft_destroy_plan((uint64_t)v13, (uint64_t)&v60);
  return 10;
}

float xmy(int a1, float *a2, int a3, float *a4, int a5)
{
  uint64_t v5;
  float result;
  uint64_t v7;

  if ((a2 & 0x1F) != 0)
  {
    if (a1 >= 1)
    {
      v5 = a1;
      do
      {
        result = *a2 * *a4;
        *a4 = result;
        a4 += a5;
        a2 += a3;
        --v5;
      }
      while (v5);
    }
  }
  else if (a1 >= 1)
  {
    v7 = a1;
    do
    {
      result = *a2 * *a4;
      *a4 = result;
      a4 += a5;
      a2 += a3;
      --v7;
    }
    while (v7);
  }
  return result;
}

float xmy_toz(int a1, float *a2, float *a3, float *a4)
{
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  float result;
  uint64_t v9;
  float v10;
  float v11;
  float v12;

  if (((a3 | a2) & 0xF) != 0)
  {
    if (a1 >= 1)
    {
      v4 = a1;
      do
      {
        v5 = *a3++;
        v6 = v5;
        v7 = *a2++;
        result = v6 * v7;
        *a4++ = result;
        --v4;
      }
      while (v4);
    }
  }
  else if (a1 >= 1)
  {
    v9 = a1;
    do
    {
      v10 = *a3++;
      v11 = v10;
      v12 = *a2++;
      result = v11 * v12;
      *a4++ = result;
      --v9;
    }
    while (v9);
  }
  return result;
}

float *fi_multiply_add_ansic(float *result, float *a2, float *a3, unsigned int a4)
{
  uint64_t v4;
  float v5;
  float v6;
  float v7;

  if (a4)
  {
    v4 = a4;
    do
    {
      v5 = *a2++;
      v6 = v5;
      v7 = *a3++;
      *result = *result + (float)(v6 * v7);
      ++result;
      --v4;
    }
    while (v4);
  }
  return result;
}

float fi_multiply_multiply_add_ansic(float *a1, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float result;

  if (a6)
  {
    v6 = a6;
    do
    {
      v7 = *a1++;
      v8 = v7;
      v9 = *a2++;
      v10 = v9;
      v11 = *a3++;
      v12 = v11;
      v13 = *a4++;
      result = (float)(v12 * v13) + (float)(v8 * v10);
      *a5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t fft_plan_dft_c2r_1d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int *a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;

  *(_OWORD *)a6 = 0u;
  *((_OWORD *)a6 + 1) = 0u;
  *((_QWORD *)a6 + 8) = 0;
  *((_OWORD *)a6 + 2) = 0u;
  *((_OWORD *)a6 + 3) = 0u;
  *((_QWORD *)a6 + 4) = 0;
  *((_QWORD *)a6 + 5) = a4;
  *((_QWORD *)a6 + 2) = a3;
  *((_QWORD *)a6 + 3) = 0;
  *a6 = a2;
  a6[1] = 2;
  a6[2] = a5;
  v9 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16));
  *((_QWORD *)a6 + 6) = v9;
  if (v9)
  {
    v10 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), a2, 4);
    *((_QWORD *)a6 + 7) = v10;
    if (v10)
    {
      v11 = (*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), (unint64_t)(5 * a2) >> 2, 4);
      *((_QWORD *)a6 + 8) = v11;
      if (v11)
      {
        v12 = (_DWORD *)*((_QWORD *)a6 + 7);
        *v12 = 0;
        makewt(*a6 >> 2, v12, v11);
        makect(*a6 >> 2, *((_QWORD *)a6 + 7), (float *)(*((_QWORD *)a6 + 8) + 4 * ((unint64_t)*a6 >> 2)));
        return 0;
      }
    }
    if (*((_QWORD *)a6 + 6))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
      *((_QWORD *)a6 + 6) = 0;
    }
  }
  if (*((_QWORD *)a6 + 7))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *((_QWORD *)a6 + 7) = 0;
  }
  if (*((_QWORD *)a6 + 8))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *((_QWORD *)a6 + 8) = 0;
  }
  return 10;
}

void makewt(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v6;
  float v7;
  float v8;
  __float2 v9;
  float *v10;
  unint64_t v11;
  __float2 v12;
  __float2 v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  float v18;
  __int128 *v19;
  _OWORD *v20;
  unint64_t v21;
  __int128 v22;
  BOOL v23;

  *a2 = a1;
  a2[1] = 1;
  if ((int)a1 >= 3)
  {
    v6 = a1 >> 1;
    v7 = 0.7854 / (float)(int)v6;
    v8 = cosf(v7 * (float)(int)v6);
    *(_DWORD *)a3 = 1065353216;
    *(float *)(a3 + 4) = v8;
    if ((_DWORD)v6 == 4)
    {
      v9 = __sincosf_stret(v7 + v7);
      *(float *)(a3 + 8) = v9.__cosval;
      *(float *)(a3 + 12) = v9.__sinval;
    }
    else if (a1 >= 0xA)
    {
      makeipt(a1, (uint64_t)a2);
      *(float *)(a3 + 8) = 0.5 / cosf(v7 + v7);
      *(float *)(a3 + 12) = 0.5 / cosf(v7 * 6.0);
      v10 = (float *)(a3 + 28);
      v11 = 4;
      do
      {
        v12 = __sincosf_stret(v7 * (float)(int)v11);
        *(v10 - 3) = v12.__cosval;
        *(v10 - 2) = v12.__sinval;
        v13 = __sincosf_stret((float)(v7 * 3.0) * (float)(int)v11);
        *(v10 - 1) = v13.__cosval;
        *v10 = -v13.__sinval;
        v11 += 4;
        v10 += 4;
      }
      while (v11 < v6);
    }
    if (a1 >= 6)
    {
      v14 = 0;
      do
      {
        v15 = v14 + v6;
        v16 = v6 >> 1;
        *(_DWORD *)(a3 + 4 * v15) = 1065353216;
        *(float *)(a3 + 4 * (v15 + 1)) = v8;
        if ((_DWORD)v16 == 4)
        {
          v17 = *(_DWORD *)(a3 + 4 * (v14 + 5));
          *(_DWORD *)(a3 + 4 * (v15 + 2)) = *(_DWORD *)(a3 + 4 * (v14 + 4));
          *(_DWORD *)(a3 + 4 * (v15 + 3)) = v17;
        }
        else if (v6 >= 0xA)
        {
          v18 = *(float *)(a3 + 4 * (v14 + 6));
          *(float *)(a3 + 4 * (v15 + 2)) = 0.5 / *(float *)(a3 + 4 * (v14 + 4));
          *(float *)(a3 + 4 * (v15 + 3)) = 0.5 / v18;
          v19 = (__int128 *)(a3 + 32 + 4 * v14);
          v20 = (_OWORD *)(a3 + 16 + 4 * v15);
          v21 = 4;
          do
          {
            v22 = *v19;
            v19 += 2;
            *v20++ = v22;
            v21 += 4;
          }
          while (v21 < v16);
        }
        v14 = v15;
        v23 = v6 > 5;
        LODWORD(v6) = v6 >> 1;
      }
      while (v23);
    }
  }
}

void makect(unsigned int a1, uint64_t a2, float *a3)
{
  uint64_t v5;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t i;
  __float2 v10;

  *(_DWORD *)(a2 + 4) = a1;
  if ((int)a1 >= 2)
  {
    LODWORD(v5) = a1 >> 1;
    v6 = 0.7854 / (float)(a1 >> 1);
    v7 = cosf(v6 * (float)(a1 >> 1));
    *a3 = v7;
    a3[v5] = v7 * 0.5;
    if (a1 >= 4)
    {
      if (v5 <= 2)
        v5 = 2;
      else
        v5 = v5;
      v8 = 4 * a1 - 4;
      for (i = 1; i != v5; ++i)
      {
        v10 = __sincosf_stret(v6 * (float)(int)i);
        a3[i] = v10.__cosval * 0.5;
        *(float *)((char *)a3 + v8) = v10.__sinval * 0.5;
        v8 -= 4;
      }
    }
  }
}

uint64_t fft_plan_dft_r2c_1d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int *a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;

  *(_OWORD *)a6 = 0u;
  *((_OWORD *)a6 + 1) = 0u;
  *((_QWORD *)a6 + 8) = 0;
  *((_OWORD *)a6 + 2) = 0u;
  *((_OWORD *)a6 + 3) = 0u;
  *((_QWORD *)a6 + 2) = 0;
  *((_QWORD *)a6 + 3) = a3;
  *((_QWORD *)a6 + 4) = a4;
  *((_QWORD *)a6 + 5) = 0;
  *a6 = a2;
  a6[1] = 1;
  a6[2] = a5;
  v9 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16));
  *((_QWORD *)a6 + 6) = v9;
  if (v9)
  {
    v10 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), a2, 4);
    *((_QWORD *)a6 + 7) = v10;
    if (v10)
    {
      v11 = (*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), (unint64_t)(5 * a2) >> 2, 4);
      *((_QWORD *)a6 + 8) = v11;
      if (v11)
      {
        v12 = (_DWORD *)*((_QWORD *)a6 + 7);
        *v12 = 0;
        makewt(*a6 >> 2, v12, v11);
        makect(*a6 >> 2, *((_QWORD *)a6 + 7), (float *)(*((_QWORD *)a6 + 8) + 4 * ((unint64_t)*a6 >> 2)));
        return 0;
      }
    }
    if (*((_QWORD *)a6 + 6))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
      *((_QWORD *)a6 + 6) = 0;
    }
  }
  if (*((_QWORD *)a6 + 7))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *((_QWORD *)a6 + 7) = 0;
  }
  if (*((_QWORD *)a6 + 8))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *((_QWORD *)a6 + 8) = 0;
  }
  return 10;
}

float32_t fft_execute(unsigned int *a1)
{
  unint64_t v1;
  float *v2;
  _DWORD *v3;
  float *v4;
  int *v5;
  uint64_t v6;
  float32_t result;
  float *v8;
  float *v9;
  float v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  float *v14;
  float *v15;
  float v16;
  unint64_t v17;
  unint64_t v18;
  float *v19;
  float *v20;
  float v21;
  float32_t *v22;
  float *v23;
  uint64_t v24;
  float *v25;
  float *v26;
  float v27;
  float v28;

  v1 = *a1;
  v2 = (float *)*((_QWORD *)a1 + 2);
  v3 = (_DWORD *)*((_QWORD *)a1 + 4);
  if (a1[1] == 1)
  {
    v4 = (float *)*((_QWORD *)a1 + 6);
    v5 = (int *)*((_QWORD *)a1 + 7);
    v6 = *((_QWORD *)a1 + 8);
    if (v2)
    {
      memcpy(*((void **)a1 + 6), v2, 4 * (2 * v1));
      result = cftfsub(2 * v1, (uint64_t)v4, (uint64_t)v5, *v5, v6);
      if ((int)v1 >= 1)
      {
        v8 = (float *)(v3 + 1);
        v9 = v4 + 1;
        do
        {
          *(v8 - 1) = *(v9 - 1);
          v10 = *v9;
          v9 += 2;
          result = -v10;
          *v8 = -v10;
          v8 += 2;
          --v1;
        }
        while (v1);
      }
    }
    else
    {
      memcpy(*((void **)a1 + 6), *((const void **)a1 + 3), 4 * v1);
      rdft(v1, 1, v4, v5, v6);
      *v3 = *(_DWORD *)v4;
      v3[1] = 0;
      v17 = v1 >> 1;
      if ((int)v1 >= 4)
      {
        v18 = v17 - 1;
        v19 = (float *)(v3 + 3);
        v20 = v4 + 3;
        do
        {
          *(v19 - 1) = *(v20 - 1);
          v21 = *v20;
          v20 += 2;
          *v19 = -v21;
          v19 += 2;
          --v18;
        }
        while (v18);
      }
      result = v4[1];
      v22 = (float32_t *)&v3[2 * v17];
      *v22 = result;
      v22[1] = 0.0;
    }
  }
  else
  {
    v11 = *((_QWORD *)a1 + 6);
    v12 = (int *)*((_QWORD *)a1 + 7);
    v13 = *((_QWORD *)a1 + 8);
    if (v3)
    {
      memcpy(*((void **)a1 + 6), v2, 4 * (2 * v1));
      result = cftbsub(2 * v1, v11, (uint64_t)v12, *v12, v13);
      if ((int)v1 >= 1)
      {
        v14 = (float *)(v3 + 1);
        v15 = (float *)(v11 + 4);
        do
        {
          *(v14 - 1) = *(v15 - 1);
          v16 = *v15;
          v15 += 2;
          result = -v16;
          *v14 = -v16;
          v14 += 2;
          --v1;
        }
        while (v1);
      }
    }
    else
    {
      v23 = (float *)*((_QWORD *)a1 + 5);
      *(float *)v11 = *v2;
      *(float *)(v11 + 4) = v2[2 * (v1 >> 1)];
      if ((int)v1 >= 4)
      {
        v24 = (v1 >> 1) - 1;
        v25 = v2 + 3;
        v26 = (float *)(v11 + 12);
        do
        {
          *(v26 - 1) = *(v25 - 1);
          v27 = *v25;
          v25 += 2;
          *v26 = -v27;
          v26 += 2;
          --v24;
        }
        while (v24);
      }
      result = rdft(v1, -1, (float *)v11, v12, v13);
      if ((int)v1 >= 1)
      {
        do
        {
          v28 = *(float *)v11;
          v11 += 4;
          result = v28 + v28;
          *v23++ = v28 + v28;
          --v1;
        }
        while (v1);
      }
    }
  }
  return result;
}

double fft_destroy_plan(uint64_t a1, uint64_t a2)
{
  double result;

  if (*(_QWORD *)(a2 + 48))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *(_QWORD *)(a2 + 48) = 0;
  }
  if (*(_QWORD *)(a2 + 56))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *(_QWORD *)(a2 + 56) = 0;
  }
  if (*(_QWORD *)(a2 + 64))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 80))(*(_QWORD *)(a1 + 16));
    *(_QWORD *)(a2 + 64) = 0;
  }
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  return result;
}

float32_t cftfsub(unsigned int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  if ((int)a1 < 9)
  {
    if (a1 == 4)
    {
      v11.i64[0] = *(_QWORD *)a2;
      v12.i64[0] = *(_QWORD *)(a2 + 8);
      v11.i64[1] = *(_QWORD *)a2;
      v12.i64[1] = v12.i64[0];
      *(_QWORD *)&v13 = vaddq_f32(v11, v12).u64[0];
      v10 = vsubq_f32(v11, v12);
      *((_QWORD *)&v13 + 1) = v10.i64[1];
      *(_OWORD *)a2 = v13;
    }
    else if (a1 == 8)
    {
      v10.f32[0] = cftf040((float *)a2);
    }
  }
  else if (a1 < 0x21)
  {
    if (a1 == 32)
    {
      cftf161((float *)a2, (float *)(a5 + 4 * (a4 - 8)));
      *(double *)v10.i64 = bitrv216(a2);
    }
    else
    {
      cftf081((float *)a2, a5);
      v10.i64[0] = *(_QWORD *)(a2 + 8);
      *(_QWORD *)&v14 = *(_QWORD *)(a2 + 48);
      v15 = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a2 + 32);
      *((_QWORD *)&v14 + 1) = v10.i64[0];
      *(_OWORD *)(a2 + 24) = v14;
      *(_QWORD *)(a2 + 48) = v15;
    }
  }
  else
  {
    cftf1st(a1, (float *)a2, (float *)(a5 + 4 * (int)(a4 - (a1 >> 2))));
    if (a1 < 0x201)
    {
      if (a1 < 0x81)
        cftfx41(a1, (float *)a2, a4, a5);
      else
        cftleaf(a1, 1, (float *)a2, a4, a5);
    }
    else
    {
      cftrec4(a1, a2, a4, a5);
    }
    v10.f32[0] = bitrv2(a1, a3, a2);
  }
  return v10.f32[0];
}

float32_t cftbsub(unsigned int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  __int128 v13;

  if ((int)a1 < 9)
  {
    if (a1 == 4)
    {
      v11.i64[0] = *(_QWORD *)a2;
      v12.i64[0] = *(_QWORD *)(a2 + 8);
      v11.i64[1] = *(_QWORD *)a2;
      v12.i64[1] = v12.i64[0];
      *(_QWORD *)&v13 = vaddq_f32(v11, v12).u64[0];
      v10 = vsubq_f32(v11, v12);
      *((_QWORD *)&v13 + 1) = v10.i64[1];
      *(_OWORD *)a2 = v13;
    }
    else if (a1 == 8)
    {
      v10.f32[0] = cftb040((float *)a2);
    }
  }
  else if (a1 < 0x21)
  {
    if (a1 == 32)
    {
      cftf161((float *)a2, (float *)(a5 + 4 * (a4 - 8)));
      *(double *)v10.i64 = bitrv216neg(a2);
    }
    else
    {
      cftf081((float *)a2, a5);
      *(double *)v10.i64 = bitrv208neg(a2);
    }
  }
  else
  {
    cftb1st(a1, (float *)a2, (float *)(a5 + 4 * (int)(a4 - (a1 >> 2))));
    if (a1 < 0x201)
    {
      if (a1 < 0x81)
        cftfx41(a1, (float *)a2, a4, a5);
      else
        cftleaf(a1, 1, (float *)a2, a4, a5);
    }
    else
    {
      cftrec4(a1, a2, a4, a5);
    }
    v10.f32[0] = bitrv2conj(a1, a3, a2);
  }
  return v10.f32[0];
}

float32_t rdft(int a1, int a2, float *a3, int *a4, uint64_t a5)
{
  int v9;
  uint64_t v10;
  float v11;
  float32_t result;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;

  v9 = a4[1];
  v10 = *a4;
  if (a2 < 0)
  {
    result = (float)(*a3 - a3[1]) * 0.5;
    v13 = *a3 - result;
    *a3 = v13;
    a3[1] = result;
    if (a1 < 5)
    {
      if (a1 == 4)
      {
        v20 = a3[2];
        v21 = a3[3];
        v22 = result - v21;
        result = result + v21;
        *a3 = v13 + v20;
        a3[1] = result;
        a3[2] = v13 - v20;
        a3[3] = v22;
      }
    }
    else
    {
      rftbsub(a1, (uint64_t)a3, v9, a5 + 4 * v10);
      return cftbsub(a1, (uint64_t)a3, (uint64_t)a4, v10, a5);
    }
  }
  else
  {
    if (a1 < 5)
    {
      v11 = *a3;
      if (a1 == 4)
      {
        v15 = a3[1];
        v14 = a3[2];
        v16 = v11 - v14;
        v17 = a3[3];
        v11 = v11 + v14;
        a3[1] = v15 + v17;
        a3[2] = v16;
        a3[3] = v15 - v17;
      }
    }
    else
    {
      cftfsub(a1, (uint64_t)a3, (uint64_t)a4, *a4, a5);
      rftfsub(a1, (uint64_t)a3, v9, a5 + 4 * v10);
      v11 = *a3;
    }
    v18 = a3[1];
    v19 = v11 - v18;
    result = v11 + v18;
    *a3 = result;
    a3[1] = v19;
  }
  return result;
}

float rftfsub(int a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4;
  int v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  float *v10;
  float *v11;
  unint64_t v12;
  float result;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  if (a1 >= 6)
  {
    v4 = a1 >> 1;
    v5 = 2 * a3 / (int)v4;
    v6 = (float *)(a4 - 4 * v5 + 4 * a3);
    v7 = 4 * v5;
    v8 = -4 * v5;
    v9 = (float *)(a2 + 4 * a1 - 4);
    v10 = (float *)(a4 + v7);
    v11 = (float *)(a2 + 12);
    v12 = 2;
    result = 0.5;
    do
    {
      v14 = 0.5 - *v6;
      v15 = *(v11 - 1);
      v16 = v15 - *(v9 - 1);
      v17 = *v11 + *v9;
      v18 = (float)(v14 * v16) - (float)(*v10 * v17);
      v19 = (float)(*v10 * v16) + (float)(v14 * v17);
      v20 = *v11 - v19;
      *(v11 - 1) = v15 - v18;
      *v11 = v20;
      v12 += 2;
      v6 = (float *)((char *)v6 + v8);
      v21 = *v9 - v19;
      *(v9 - 1) = *(v9 - 1) + v18;
      *v9 = v21;
      v9 -= 2;
      v10 = (float *)((char *)v10 + v7);
      v11 += 2;
    }
    while (v12 < v4);
  }
  return result;
}

float rftbsub(int a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4;
  int v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  float *v10;
  float *v11;
  unint64_t v12;
  float result;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  if (a1 >= 6)
  {
    v4 = a1 >> 1;
    v5 = 2 * a3 / (int)v4;
    v6 = (float *)(a4 - 4 * v5 + 4 * a3);
    v7 = 4 * v5;
    v8 = -4 * v5;
    v9 = (float *)(a2 + 4 * a1 - 4);
    v10 = (float *)(a4 + v7);
    v11 = (float *)(a2 + 12);
    v12 = 2;
    result = 0.5;
    do
    {
      v14 = 0.5 - *v6;
      v15 = *(v11 - 1);
      v16 = v15 - *(v9 - 1);
      v17 = *v11 + *v9;
      v18 = (float)(*v10 * v17) + (float)(v14 * v16);
      v19 = (float)(v14 * v17) - (float)(*v10 * v16);
      v20 = *v11 - v19;
      *(v11 - 1) = v15 - v18;
      *v11 = v20;
      v12 += 2;
      v6 = (float *)((char *)v6 + v8);
      v21 = *v9 - v19;
      *(v9 - 1) = *(v9 - 1) + v18;
      *v9 = v21;
      v9 -= 2;
      v10 = (float *)((char *)v10 + v7);
      v11 += 2;
    }
    while (v12 < v4);
  }
  return result;
}

uint64_t makeipt(uint64_t result, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  _DWORD *v5;
  _DWORD *v6;
  int *v7;
  uint64_t v8;
  int v9;
  BOOL v10;

  *(_QWORD *)(a2 + 8) = 0x1000000000;
  if ((int)result >= 33)
  {
    v2 = 2;
    do
    {
      v3 = 2 * v2;
      if (v2 < 2 * v2)
      {
        v4 = 16 * v2;
        v5 = (_DWORD *)(a2 + 4 * (v2 + (uint64_t)v3));
        v6 = (_DWORD *)(a2 + 8 * v2);
        v7 = (int *)(a2 + 4 * v2);
        v8 = v3 - (uint64_t)v2;
        do
        {
          v9 = *v7++;
          *v6++ = 4 * v9;
          *v5++ = v4 + 4 * v9;
          --v8;
        }
        while (v8);
      }
      v2 = v3;
      v10 = result > 0x83;
      result = result >> 2;
    }
    while (v10);
  }
  return result;
}

float cftf1st(int a1, float *a2, float *a3)
{
  uint64_t v3;
  int v4;
  float v5;
  float v6;
  float v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float v19;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float *v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float *v71;
  float *v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float *v98;
  float *v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float *v114;
  float v115;
  float v116;
  float *v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  uint64_t v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float *v142;
  float v143;
  float v144;
  float v145;
  float *v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float *v151;
  float *v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float *v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float result;

  v3 = 2 * (a1 >> 3);
  v4 = 4 * (a1 >> 3);
  v5 = a2[v4];
  v6 = a2[1];
  v7 = *a2 + v5;
  v8 = &a2[4 * (a1 >> 3)];
  v9 = v8[1];
  v10 = v6 + v9;
  v11 = *a2 - v5;
  v12 = 2 * (a1 >> 3);
  v13 = a2[v12];
  v14 = v6 - v9;
  v15 = a2[6 * (a1 >> 3)];
  v16 = v13 + v15;
  v17 = a2[(int)(v3 | 1)];
  v18 = (6 * (a1 >> 3)) | 1;
  v19 = a2[v18];
  v20 = v13 - v15;
  *a2 = v7 + v16;
  a2[1] = v10 + (float)(v17 + v19);
  a2[v12] = v7 - v16;
  a2[(int)(v3 | 1)] = v10 - (float)(v17 + v19);
  a2[v4] = v11 - (float)(v17 - v19);
  v8[1] = v14 + v20;
  a2[6 * (a1 >> 3)] = v11 + (float)(v17 - v19);
  a2[v18] = v14 - v20;
  v21 = (uint64_t)a1 >> 3;
  v22 = a3[1];
  v23 = a3[2];
  v24 = a3[3];
  v25 = v21 - 2;
  if (a1 < 40)
  {
    v48 = 0.0;
    v47 = 1.0;
    v49 = 1.0;
    v50 = 0.0;
  }
  else
  {
    v26 = 0;
    v27 = 24 * (_DWORD)v21;
    v28 = v27 + 12;
    v29 = 4 * v4;
    v30 = v29 + 12;
    v31 = v29 - 4;
    v32 = v27 - 4;
    v33 = a3 + 7;
    v34 = 24 * (a1 >> 3) + 16;
    v35 = 2 * (a1 >> 3);
    v36 = v35 * 4 - 8;
    v37 = 8 * v3 + 16;
    v38 = 8 * v3 - 8;
    v39 = 12 * v3 - 8;
    v40 = 1.0;
    v41 = 0.0;
    v42 = 0.0;
    v43 = 16 * v3 - 16;
    v44 = 2;
    v45 = (v3 << 34) - 0x200000000;
    v46 = 1.0;
    do
    {
      v47 = v33[v26 - 3];
      v48 = v33[v26 - 2];
      v49 = v33[v26 - 1];
      v50 = v33[v26];
      v51 = v40 + v49;
      v52 = &a2[v26];
      v53 = (float *)((char *)a2 + v37);
      v54 = *(float *)((char *)a2 + v37 - 8);
      v55 = a2[v26 + 2];
      v56 = a2[v26 + 3];
      v57 = v41 + v50;
      v58 = v55 + v54;
      v59 = *(float *)((char *)a2 + v30);
      v60 = v56 + v59;
      v61 = v55 - v54;
      v62 = v56 - v59;
      v63 = a2[v26 + 4];
      v64 = a2[v26 + 5];
      v65 = *(float *)((char *)a2 + v37);
      v66 = *(float *)((char *)a2 + v37 + 4);
      v67 = v63 + v65;
      v68 = v64 + v66;
      v69 = v63 - v65;
      v70 = v64 - v66;
      v71 = &a2[v35];
      v72 = (float *)((char *)a2 + v34);
      v73 = *(float *)((char *)a2 + v34 - 8);
      v74 = v23 * (float)(v46 + v47);
      v75 = a2[v35 + 2];
      v76 = a2[v35 + 3];
      v77 = v75 + v73;
      v78 = *(float *)((char *)a2 + v28);
      v79 = v23 * (float)(v42 + v48);
      v80 = v76 + v78;
      v81 = v75 - v73;
      v82 = v76 - v78;
      v84 = a2[v35 + 4];
      v83 = a2[v35 + 5];
      v85 = v24 * v51;
      v87 = *(float *)((char *)a2 + v34);
      v86 = *(float *)((char *)a2 + v34 + 4);
      v88 = v84 + v87;
      v89 = v84 - v87;
      v90 = v24 * v57;
      v52[2] = v58 + v77;
      v52[3] = v60 + v80;
      v52[4] = v67 + v88;
      v52[5] = v68 + (float)(v83 + v86);
      v71[2] = v58 - v77;
      v71[3] = v60 - v80;
      v71[4] = v67 - v88;
      v71[5] = v68 - (float)(v83 + v86);
      *(v53 - 2) = (float)(v74 * (float)(v61 - v82)) - (float)(v79 * (float)(v62 + v81));
      v91 = v69 - (float)(v83 - v86);
      *(float *)((char *)a2 + v30) = (float)(v79 * (float)(v61 - v82)) + (float)(v74 * (float)(v62 + v81));
      v92 = v61 + v82;
      v93 = v62 - v81;
      *v53 = (float)(v47 * v91) - (float)(v48 * (float)(v70 + v89));
      v53[1] = (float)(v48 * v91) + (float)(v47 * (float)(v70 + v89));
      v94 = (float)((float)(v24 * v57) * v93) + (float)(v85 * v92);
      v95 = (float)(v85 * v93) - (float)((float)(v24 * v57) * v92);
      v96 = v69 + (float)(v83 - v86);
      *(v72 - 2) = v94;
      v97 = v70 - v89;
      *(float *)((char *)a2 + v28) = v95;
      *v72 = (float)(v50 * v97) + (float)(v49 * v96);
      v72[1] = (float)(v49 * v97) - (float)(v50 * v96);
      v98 = (float *)((char *)a2 + v36);
      v99 = (float *)((char *)a2 + v39);
      v101 = *(float *)((char *)a2 + v39 - 4);
      v100 = *(float *)((char *)a2 + v39);
      v102 = *(float *)((char *)a2 + v36);
      v103 = *(float *)((char *)a2 + v36 + 4);
      v104 = v102 + v100;
      v105 = *(float *)((char *)a2 + v32);
      v106 = v102 - v100;
      v107 = *(float *)((char *)a2 + v36 - 8);
      v108 = *(float *)((char *)a2 + v36 - 4);
      v109 = *(float *)((char *)a2 + v39 - 8);
      v110 = v107 + v109;
      v111 = v108 + v101;
      v112 = v107 - v109;
      v113 = v108 - v101;
      v114 = (float *)((char *)a2 + v38);
      v115 = *(float *)((char *)a2 + v38 - 4);
      v116 = *(float *)((char *)a2 + v38);
      v117 = (float *)((char *)a2 + v43);
      v118 = v103 + v105;
      v119 = *(float *)((char *)a2 + v43 + 4);
      v120 = *(float *)((char *)a2 + v43 + 8);
      v121 = v116 + v120;
      v122 = *(float *)((char *)a2 + v31);
      v123 = v103 - v105;
      v124 = (v45 >> 30) | 4;
      v125 = *(float *)((char *)a2 + v124);
      v126 = v116 - v120;
      v127 = *(float *)((char *)a2 + v38 - 8);
      v128 = v122 + v125;
      v129 = *(float *)((char *)a2 + v43);
      v130 = v127 + v129;
      v131 = v122 - v125;
      v132 = v127 - v129;
      *v98 = v104 + v121;
      v98[1] = v118 + v128;
      *(v98 - 2) = v110 + v130;
      *(v98 - 1) = v111 + (float)(v115 + v119);
      *v114 = v104 - v121;
      *(float *)((char *)a2 + v31) = v118 - v128;
      *(v114 - 2) = v110 - v130;
      *(v114 - 1) = v111 - (float)(v115 + v119);
      v133 = (float)(v79 * (float)(v106 - v131)) - (float)(v74 * (float)(v123 + v126));
      v134 = (float)(v74 * (float)(v106 - v131)) + (float)(v79 * (float)(v123 + v126));
      v135 = v106 + v131;
      v136 = v123 - v126;
      *v99 = v133;
      *(float *)((char *)a2 + v32) = v134;
      v44 += 4;
      *(v99 - 2) = (float)(v48 * (float)(v112 - (float)(v115 - v119))) - (float)(v47 * (float)(v113 + v132));
      *(v99 - 1) = (float)(v47 * (float)(v112 - (float)(v115 - v119))) + (float)(v48 * (float)(v113 + v132));
      v28 += 16;
      v30 += 16;
      v31 -= 16;
      v26 += 4;
      v34 += 16;
      v117[2] = (float)(v85 * v136) + (float)(v90 * v135);
      v36 -= 16;
      v37 += 16;
      v35 += 4;
      v38 -= 16;
      *(float *)((char *)a2 + v124) = (float)(v90 * v136) - (float)(v85 * v135);
      v39 -= 16;
      v45 -= 0x400000000;
      v43 -= 16;
      v41 = v50;
      v32 -= 16;
      *v117 = (float)(v49 * (float)(v113 - v132)) + (float)(v50 * (float)(v112 + (float)(v115 - v119)));
      v117[1] = (float)(v50 * (float)(v113 - v132)) - (float)(v49 * (float)(v112 + (float)(v115 - v119)));
      v40 = v49;
      v42 = v48;
      v46 = v47;
    }
    while (v44 < v25);
  }
  v137 = v23 * (float)(v22 + v47);
  v138 = v23 * (float)(v22 + v48);
  v139 = v24 * (float)(v49 - v22);
  v140 = v24 * (float)(v50 - v22);
  v141 = a2[v25];
  v142 = &a2[5 * v21];
  v143 = *(v142 - 2);
  v144 = *(v142 - 1);
  v145 = v141 + v143;
  v146 = &a2[v21];
  v147 = *(v146 - 1);
  v148 = v147 + v144;
  v149 = v141 - v143;
  v150 = v147 - v144;
  v151 = &a2[3 * (int)v21];
  v152 = &a2[7 * v21];
  v153 = *(v152 - 2);
  v154 = *(v151 - 2);
  v155 = *(v151 - 1);
  v156 = v154 + v153;
  v157 = &a2[7 * (_DWORD)v21];
  v158 = *(v157 - 1);
  v159 = v154 - v153;
  a2[v25] = v145 + v156;
  *(v146 - 1) = v148 + (float)(v155 + v158);
  *(v151 - 2) = v145 - v156;
  *(v151 - 1) = v148 - (float)(v155 + v158);
  v160 = v149 - (float)(v155 - v158);
  *(v142 - 2) = (float)(v137 * v160) - (float)(v138 * (float)(v150 + v159));
  *(v142 - 1) = (float)(v138 * v160) + (float)(v137 * (float)(v150 + v159));
  v161 = v149 + (float)(v155 - v158);
  v162 = v150 - v159;
  *(v152 - 2) = (float)(v140 * v162) + (float)(v139 * v161);
  *(v157 - 1) = (float)(v139 * v162) - (float)(v140 * v161);
  v163 = v146[1];
  v164 = v142[1];
  v165 = *v146 + *v142;
  v166 = v163 + v164;
  v167 = *v146 - *v142;
  v168 = v163 - v164;
  v169 = v151[1];
  v170 = v157[1];
  v171 = *v151 + *v157;
  v172 = v169 + v170;
  v173 = *v151 - *v157;
  v174 = v169 - v170;
  *v146 = v165 + v171;
  v146[1] = v166 + v172;
  *v151 = v165 - v171;
  v151[1] = v166 - v172;
  *v142 = v22 * (float)((float)(v167 - v174) - (float)(v168 + v173));
  v142[1] = v22 * (float)((float)(v168 + v173) + (float)(v167 - v174));
  v175 = v167 + v174;
  v176 = v168 - v173;
  *v157 = -(float)(v22 * (float)(v176 + v175));
  v157[1] = -(float)(v22 * (float)(v176 - v175));
  v177 = v146[2];
  v178 = v146[3];
  v179 = v142[2];
  v180 = v142[3];
  v181 = v177 + v179;
  v182 = v178 + v180;
  v183 = v177 - v179;
  v184 = v178 - v180;
  v185 = v151[2];
  v186 = v151[3];
  v187 = v157[2];
  v188 = v157[3];
  v189 = v185 + v187;
  v190 = v186 + v188;
  v191 = v185 - v187;
  v192 = v186 - v188;
  v146[2] = v181 + v189;
  v146[3] = v182 + v190;
  v151[2] = v181 - v189;
  v151[3] = v182 - v190;
  v142[2] = (float)(v138 * (float)(v183 - v192)) - (float)(v137 * (float)(v184 + v191));
  v142[3] = (float)(v137 * (float)(v183 - v192)) + (float)(v138 * (float)(v184 + v191));
  v193 = v183 + v192;
  v194 = (float)(v139 * (float)(v184 - v191)) + (float)(v140 * v193);
  result = (float)(v140 * (float)(v184 - v191)) - (float)(v139 * v193);
  v157[2] = v194;
  v157[3] = result;
  return result;
}

void cftrec4(int a1, uint64_t a2, int a3, uint64_t a4)
{
  int v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  int v12;

  v7 = a1;
  v8 = a1;
  if (a1 >= 513)
  {
    v9 = a1;
    do
    {
      v8 = v9 >> 2;
      cftmdl1(v9 >> 2, (float *)(a2 + 4 * (int)(v7 - (v9 >> 2))), a4 + 4 * (int)(a3 - (v9 >> 3)));
      v10 = v9 > 0x803;
      v9 >>= 2;
    }
    while (v10);
  }
  cftleaf(v8, 1, (float *)(a2 + 4 * (v7 - v8)), a3, a4);
  if (v7 - v8 >= 1)
  {
    v11 = 1;
    do
    {
      v12 = cfttree(v8, v7 - v8, v11, a2, a3, a4);
      cftleaf(v8, v12, (float *)(a2 + 4 * (-2 * v8 + v7)), a3, a4);
      ++v11;
      v7 -= v8;
    }
    while (v7 - v8 > 0);
  }
}

float cftleaf(int a1, int a2, float *a3, int a4, uint64_t a5)
{
  float *v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;

  v7 = (float *)(a5 + 4 * a4 - 32);
  if (a1 == 512)
  {
    v8 = a5 + 4 * a4;
    v9 = v8 - 256;
    cftmdl1(128, a3, v8 - 256);
    cftf161(a3, v7);
    v10 = (float *)(v8 - 128);
    cftf162(a3 + 32, (float *)(v8 - 128));
    cftf161(a3 + 64, v7);
    cftf161(a3 + 96, v7);
    v11 = v8 - 512;
    cftmdl2(128, a3 + 128, v11);
    cftf161(a3 + 128, v7);
    cftf162(a3 + 160, v10);
    cftf161(a3 + 192, v7);
    cftf162(a3 + 224, v10);
    cftmdl1(128, a3 + 256, v9);
    cftf161(a3 + 256, v7);
    cftf162(a3 + 288, v10);
    cftf161(a3 + 320, v7);
    cftf161(a3 + 352, v7);
    v12 = a3 + 384;
    if (a2)
    {
      cftmdl1(128, v12, v9);
      cftf161(a3 + 480, v7);
    }
    else
    {
      cftmdl2(128, v12, v11);
      cftf162(a3 + 480, v10);
    }
    cftf161(a3 + 384, v7);
    cftf162(a3 + 416, v10);
    return cftf161(a3 + 448, v7);
  }
  else
  {
    v13 = a5 + 4 * a4;
    v14 = v13 - 128;
    cftmdl1(64, a3, v13 - 128);
    cftf081(a3, (uint64_t)v7);
    cftf082(a3 + 16, v7);
    cftf081(a3 + 32, (uint64_t)v7);
    cftf081(a3 + 48, (uint64_t)v7);
    v15 = v13 - 256;
    cftmdl2(64, a3 + 64, v15);
    cftf081(a3 + 64, (uint64_t)v7);
    cftf082(a3 + 80, v7);
    cftf081(a3 + 96, (uint64_t)v7);
    cftf082(a3 + 112, v7);
    cftmdl1(64, a3 + 128, v14);
    cftf081(a3 + 128, (uint64_t)v7);
    cftf082(a3 + 144, v7);
    cftf081(a3 + 160, (uint64_t)v7);
    cftf081(a3 + 176, (uint64_t)v7);
    v16 = a3 + 192;
    if (a2)
    {
      cftmdl1(64, v16, v14);
      cftf081(a3 + 240, (uint64_t)v7);
    }
    else
    {
      cftmdl2(64, v16, v15);
      cftf082(a3 + 240, v7);
    }
    cftf081(a3 + 192, (uint64_t)v7);
    cftf082(a3 + 208, v7);
    return cftf081(a3 + 224, (uint64_t)v7);
  }
}

float cftfx41(int a1, float *a2, int a3, uint64_t a4)
{
  uint64_t v5;
  float *v6;
  uint64_t v8;

  v5 = a4 + 4 * a3;
  v6 = (float *)(v5 - 32);
  if (a1 == 128)
  {
    v8 = a3;
    cftf161(a2, (float *)(v5 - 32));
    cftf162(a2 + 32, (float *)(a4 + 4 * v8 - 128));
    cftf161(a2 + 64, v6);
    return cftf161(a2 + 96, v6);
  }
  else
  {
    cftf081(a2, v5 - 32);
    cftf082(a2 + 16, v6);
    cftf081(a2 + 32, (uint64_t)v6);
    return cftf081(a2 + 48, (uint64_t)v6);
  }
}

float bitrv2(int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _DWORD *v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  _DWORD *v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  _DWORD *v60;
  int v61;
  uint64_t v62;
  int v63;
  _DWORD *v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  _DWORD *v69;
  int v70;
  int v71;
  _DWORD *v72;
  int v73;
  uint64_t v74;
  _DWORD *v75;
  int v76;
  int v77;
  _DWORD *v78;
  int v79;
  uint64_t v80;
  _DWORD *v81;
  int v82;
  int v83;
  _DWORD *v84;
  int v85;
  _DWORD *v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  int v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  _DWORD *v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  int v101;
  _DWORD *v102;
  int v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  int v107;
  _DWORD *v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  uint64_t v114;
  int v115;
  _DWORD *v116;
  int v117;
  int v118;
  uint64_t v119;
  int v120;
  _DWORD *v121;
  int v122;
  int v123;
  _DWORD *v124;
  int v125;
  int v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  int v132;
  _DWORD *v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  int v139;
  _DWORD *v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  int *v144;
  int v145;
  uint64_t v146;
  int v147;
  int *v148;
  int v149;
  int v150;
  int v151;
  int *v152;
  int v153;
  int *v154;
  int v155;
  int v156;
  int v157;
  float result;
  uint64_t v159;
  int v160;
  _DWORD *v161;
  int v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  int v177;
  int v178;
  int *v179;
  int *v180;
  int *v181;
  uint64_t v182;
  int *v183;
  uint64_t v184;
  int v185;
  int v186;
  int *v187;
  int v188;
  uint64_t v189;
  int v190;
  int v191;
  int *v192;
  int v193;
  int v194;
  int v195;
  int v196;
  uint64_t v197;
  int v198;
  int v199;
  int *v200;
  int v201;
  int *v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  _DWORD *v208;
  int v209;
  int v210;
  int v211;
  _DWORD *v212;
  int v213;
  int v214;
  int v215;
  _DWORD *v216;
  int v217;
  uint64_t v218;
  uint64_t v219;
  int v220;
  int v221;
  uint64_t v222;
  _DWORD *v223;
  int v224;
  int v225;
  uint64_t v226;
  uint64_t v227;
  int v228;
  _DWORD *v229;
  int v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  int v236;
  uint64_t v237;
  unint64_t v238;
  uint64_t v239;
  uint64_t v240;

  v3 = a1 >> 2;
  if (a1 < 36)
  {
    v8 = a1 >> 1;
    v9 = 4;
    v4 = 1;
    if (v3 == 8)
    {
LABEL_8:
      v10 = 0;
      v11 = 8 * v4;
      v12 = v4;
      v13 = a2 + 4 * v4;
      v231 = 2 * (int)v9 + v8;
      v232 = v4;
      v233 = a2;
      do
      {
        v14 = v10 + v12;
        if (v10)
        {
          v15 = 0;
          v16 = 0;
          v234 = v10 + v12;
          v17 = *(int *)(a2 + 4 * v14);
          v18 = 4 * (int)v10;
          v239 = (v9 << 33) + (v17 << 33);
          v240 = 8 * v17;
          v238 = ((unint64_t)(3 * v9) << 32) + (v17 << 33);
          v19 = v231 + (int)v9 + 2 * v17;
          v237 = (v19 << 32) + 0x300000000;
          v236 = 2 * v17;
          v20 = v9 + 2 * v17;
          v21 = 2 * (v9 + v17);
          v22 = 3 * v9 + 2 * v17;
          v23 = v8 + 3 * v9 + 2 + 2 * v17;
          v24 = v231 + 2 * v17;
          v25 = (v24 << 32) + 0x300000000;
          v26 = (v24 << 32) + 0x200000000;
          v27 = (int)v9 + (uint64_t)v8 + 2 * v17;
          v28 = (v27 << 32) + 0x300000000;
          v29 = (v27 << 32) + 0x200000000;
          v30 = 4 * (int)v9 + 8 * v17;
          v31 = a3 + 8 * (int)v9 + 8 * v17;
          v32 = a3 + 12 * (int)v9 + 8 * v17;
          v33 = 4 * v19;
          v34 = 4 * v27;
          v35 = 4 * v24;
          v36 = a3;
          v235 = v10;
          v37 = 4 * v8 + 8 * v17;
          do
          {
            v38 = v13;
            v39 = v18 + 2 * *(int *)(v13 + v16);
            v40 = (_DWORD *)(v36 + v240);
            v41 = *(_DWORD *)(v36 + v240);
            v42 = *(_DWORD *)(v36 + v240 + 4);
            v43 = (4 * v39) | 4;
            v44 = *(_DWORD *)(a3 + v43);
            *v40 = *(_DWORD *)(a3 + 4 * v39);
            v40[1] = v44;
            *(_DWORD *)(a3 + 4 * v39) = v41;
            v45 = (int)v39 + (uint64_t)(int)v11;
            v46 = (_DWORD *)(v36 + v30);
            *(_DWORD *)(a3 + v43) = v42;
            v47 = *(_DWORD *)(v36 + v30);
            v48 = *(_DWORD *)(v36 + v30 + 4);
            v49 = (4 * v45) | 4;
            v50 = *(_DWORD *)(a3 + v49);
            *v46 = *(_DWORD *)(a3 + 4 * v45);
            v46[1] = v50;
            *(_DWORD *)(a3 + 4 * v45) = v47;
            *(_DWORD *)(a3 + v49) = v48;
            v51 = *(_DWORD *)(v31 + 4 * v16);
            v52 = (int)v45 - (uint64_t)(int)v9;
            v53 = ((v239 + v15) >> 30) | 4;
            v54 = *(_DWORD *)(a3 + v53);
            v55 = (4 * v52) | 4;
            v56 = *(_DWORD *)(a3 + v55);
            *(_DWORD *)(v31 + 4 * v16) = *(_DWORD *)(a3 + 4 * v52);
            *(_DWORD *)(a3 + v53) = v56;
            *(_DWORD *)(a3 + 4 * v52) = v51;
            *(_DWORD *)(a3 + v55) = v54;
            v57 = v11 + (int)v52;
            v58 = *(_DWORD *)(v32 + 4 * v16);
            v59 = ((uint64_t)(v238 + v15) >> 30) | 4;
            v60 = (_DWORD *)(a3 + 4 * v57);
            v61 = *(_DWORD *)(a3 + v59);
            v62 = (4 * v57) | 4;
            v63 = *(_DWORD *)(a3 + v62);
            *(_DWORD *)(v32 + 4 * v16) = *v60;
            *(_DWORD *)(a3 + v59) = v63;
            *v60 = v58;
            *(_DWORD *)(a3 + v62) = v61;
            v57 += 2;
            v64 = (_DWORD *)(v36 + v33);
            v65 = *(_DWORD *)(v36 + v33);
            v66 = *(_DWORD *)(v36 + v33 + 4);
            v67 = v60[3];
            *v64 = *(_DWORD *)(a3 + 4 * v57);
            v64[1] = v67;
            *(_DWORD *)(a3 + 4 * v57) = v65;
            v60[3] = v66;
            v68 = (int)v57 - (uint64_t)(int)v11;
            v69 = (_DWORD *)(v36 + v35);
            v70 = *(_DWORD *)(v36 + v35);
            v71 = *(_DWORD *)(v36 + v35 + 4);
            v72 = (_DWORD *)(a3 + 4 * v68);
            v73 = v72[1];
            *v69 = *v72;
            v69[1] = v73;
            *v72 = v70;
            v72[1] = v71;
            v74 = (int)v68 + (uint64_t)(int)v9;
            v75 = (_DWORD *)(v36 + v34);
            v76 = *(_DWORD *)(v36 + v34);
            v77 = *(_DWORD *)(v36 + v34 + 4);
            v78 = (_DWORD *)(a3 + 4 * v74);
            v79 = v78[1];
            *v75 = *v78;
            v75[1] = v79;
            *v78 = v76;
            v78[1] = v77;
            v80 = (int)v74 - (uint64_t)(int)v11;
            v81 = (_DWORD *)(v36 + v37);
            v82 = *(_DWORD *)(v36 + v37);
            v83 = *(_DWORD *)(v36 + v37 + 4);
            v84 = (_DWORD *)(a3 + 4 * v80);
            v85 = v84[1];
            *v81 = *v84;
            v81[1] = v85;
            *v84 = v82;
            v84[1] = v83;
            v86 = (_DWORD *)(a3 + 4 * ((int)v80 + (uint64_t)v8));
            v87 = *(_DWORD *)(v36 + v37 + 8);
            v88 = *(_DWORD *)(v36 + v37 + 12);
            v89 = v86[1];
            v81[2] = *v86;
            v81[3] = v89;
            *v86 = v87;
            v86[1] = v88;
            v90 = (v29 + v15) >> 30;
            v91 = *(_DWORD *)(a3 + v90);
            v92 = (v28 + v15) >> 30;
            v93 = *(_DWORD *)(a3 + v92);
            v94 = (int)v74 + v8;
            v95 = (_DWORD *)(a3 + 4 * v94);
            v96 = v95[1];
            *(_DWORD *)(a3 + v90) = *v95;
            *(_DWORD *)(a3 + v92) = v96;
            *v95 = v91;
            v95[1] = v93;
            v97 = v94 - (int)v9;
            v98 = (v26 + v15) >> 30;
            v99 = *(_DWORD *)(a3 + v98);
            v100 = (v25 + v15) >> 30;
            v101 = *(_DWORD *)(a3 + v100);
            v102 = (_DWORD *)(a3 + 4 * v97);
            v103 = v102[1];
            *(_DWORD *)(a3 + v98) = *v102;
            *(_DWORD *)(a3 + v100) = v103;
            *v102 = v99;
            v102[1] = v101;
            v104 = (int)v97 + (uint64_t)(int)v11;
            v105 = *(_DWORD *)(a3 + 4 * (v23 + (int)v16));
            v106 = (v237 + v15) >> 30;
            v107 = *(_DWORD *)(a3 + v106);
            v108 = (_DWORD *)(a3 + 4 * v104);
            v109 = v108[1];
            *(_DWORD *)(a3 + 4 * (v23 + (int)v16)) = *v108;
            *(_DWORD *)(a3 + v106) = v109;
            *v108 = v105;
            v108[1] = v107;
            LODWORD(v106) = v22 + v16 + 2;
            v104 -= 2;
            v110 = *(_DWORD *)(a3 + 4 * (int)v106);
            LODWORD(v98) = v22 + v16 + 3;
            v111 = *(_DWORD *)(a3 + 4 * (int)v98);
            v112 = *(v108 - 1);
            *(_DWORD *)(a3 + 4 * (int)v106) = *(_DWORD *)(a3 + 4 * v104);
            *(_DWORD *)(a3 + 4 * (int)v98) = v112;
            *(_DWORD *)(a3 + 4 * v104) = v110;
            *(v108 - 1) = v111;
            LODWORD(v106) = v21 + v16 + 2;
            v113 = *(_DWORD *)(a3 + 4 * (int)v106);
            v114 = (int)v104 - (uint64_t)(int)v11;
            LODWORD(v98) = v21 + v16 + 3;
            v115 = *(_DWORD *)(a3 + 4 * (int)v98);
            v116 = (_DWORD *)(a3 + 4 * v114);
            v117 = v116[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v116;
            *(_DWORD *)(a3 + 4 * (int)v98) = v117;
            *v116 = v113;
            v116[1] = v115;
            LODWORD(v106) = v20 + v16 + 2;
            v118 = *(_DWORD *)(a3 + 4 * (int)v106);
            v119 = (int)v114 + (uint64_t)(int)v9;
            LODWORD(v98) = v20 + v16 + 3;
            v120 = *(_DWORD *)(a3 + 4 * (int)v98);
            v121 = (_DWORD *)(a3 + 4 * v119);
            v122 = v121[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v121;
            *(_DWORD *)(a3 + 4 * (int)v98) = v122;
            *v121 = v118;
            v121[1] = v120;
            LODWORD(v106) = v236 + v16 + 2;
            v123 = *(_DWORD *)(a3 + 4 * (int)v106);
            v124 = (_DWORD *)(a3 + 4 * ((int)v119 - (uint64_t)(int)v11));
            v125 = v124[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v124;
            LODWORD(v98) = v236 + v16 + 3;
            v126 = *(_DWORD *)(a3 + 4 * (int)v98);
            *(_DWORD *)(a3 + 4 * (int)v98) = v125;
            v13 = v38;
            *v124 = v123;
            v124[1] = v126;
            v16 += 4;
            v36 += 16;
            v15 += 0x400000000;
            --v10;
          }
          while (v10);
          v12 = v232;
          a2 = v233;
          v14 = v234;
          v10 = v235;
        }
        else
        {
          LODWORD(v18) = 0;
        }
        v127 = 2 * *(int *)(a2 + 4 * v14) + (int)v18;
        v128 = v127 + 2;
        v129 = (int)v127 + (uint64_t)v8;
        v130 = *(_DWORD *)(a3 + 4 * (v127 + 2));
        v131 = a3 + 4 * v127;
        v132 = *(_DWORD *)(v131 + 12);
        v133 = (_DWORD *)(a3 + 4 * v129);
        v134 = v133[1];
        *(_DWORD *)(a3 + 4 * v128) = *v133;
        *(_DWORD *)(v131 + 12) = v134;
        *v133 = v130;
        v133[1] = v132;
        v135 = (int)v128 + (uint64_t)(int)v9;
        v136 = (int)v129 + (uint64_t)(int)v11;
        v137 = *(_DWORD *)(a3 + 4 * v135);
        v138 = (4 * v135) | 4;
        v139 = *(_DWORD *)(a3 + v138);
        v140 = (_DWORD *)(a3 + 4 * v136);
        v141 = v140[1];
        *(_DWORD *)(a3 + 4 * v135) = *v140;
        *(_DWORD *)(a3 + v138) = v141;
        *v140 = v137;
        v140[1] = v139;
        v142 = (int)v135 + (uint64_t)(int)v9;
        v143 = (int)v136 - (uint64_t)(int)v9;
        v144 = (int *)(a3 + 4 * v142);
        v145 = *v144;
        v146 = (4 * v142) | 4;
        v147 = *(_DWORD *)(a3 + v146);
        v148 = (int *)(a3 + 4 * v143);
        v149 = v148[1];
        *v144 = *v148;
        *(_DWORD *)(a3 + v146) = v149;
        *v148 = v145;
        v148[1] = v147;
        v150 = *(v144 - 2);
        v151 = *(v144 - 1);
        v152 = (int *)(a3 + 4 * ((int)v143 - (uint64_t)v8));
        v153 = v152[1];
        *(v144 - 2) = *v152;
        *(v144 - 1) = v153;
        *v152 = v150;
        v152[1] = v151;
        v154 = (int *)(a3 + 4 * ((int)v142 + v8));
        v155 = *v154;
        v156 = v154[1];
        v157 = *(_DWORD *)(a3 + 4 * ((int)v143 + 3));
        *v154 = *(_DWORD *)(a3 + 4 * ((int)v143 + 2));
        v154[1] = v157;
        *(_DWORD *)(a3 + 4 * ((int)v143 + 2)) = v155;
        *(_DWORD *)(a3 + 4 * ((int)v143 + 3)) = v156;
        LODWORD(v142) = v142 + v9;
        result = *(float *)(a3 + 4 * (int)v142);
        v159 = (4 * (int)v142) | 4;
        v160 = *(_DWORD *)(a3 + v159);
        v161 = (_DWORD *)(a3 + 4 * ((int)v143 + (int)v11));
        v162 = v161[1];
        *(_DWORD *)(a3 + 4 * (int)v142) = *v161;
        *(_DWORD *)(a3 + v159) = v162;
        *(float *)v161 = result;
        v161[1] = v160;
        ++v10;
      }
      while (v10 != v12);
      return result;
    }
  }
  else
  {
    v4 = 1;
    do
    {
      v5 = v4;
      v4 *= 2;
      v6 = v3 >> 2;
      v7 = v3 > 0x23;
      v3 >>= 2;
    }
    while (v7);
    v8 = a1 >> 1;
    v9 = (8 * v5);
    if (v6 == 8)
    {
      if (v4 < 1)
        return result;
      goto LABEL_8;
    }
    if (v4 < 1)
      return result;
  }
  v163 = 0;
  v164 = v4;
  v165 = (int)v9;
  v166 = v8;
  v167 = v8 + v9 + 2;
  v168 = a3 + 4;
  v169 = a2 + 4 * v4;
  v170 = v165 + v8;
  do
  {
    v171 = v163 + v164;
    if (v163)
    {
      v172 = 0;
      v173 = *(_DWORD *)(a2 + 4 * v171);
      v174 = 4 * (int)v163;
      v175 = v170 + v173;
      v176 = (v175 << 32) + 0x300000000;
      v177 = v165 + v173;
      v178 = v167 + v173;
      v179 = (int *)(v168 + 4 * v173);
      v180 = (int *)(v168 + 4 * (v165 + v173));
      v181 = (int *)(a3 + 8 + 4 * (v166 + v173));
      v182 = v163;
      v183 = (int *)(v168 + 4 * v175);
      do
      {
        v184 = *(int *)(v169 + v172) + v174;
        v185 = *(v179 - 1);
        v186 = *v179;
        v187 = (int *)(a3 + 4 * v184);
        v188 = v187[1];
        *(v179 - 1) = *v187;
        *v179 = v188;
        *v187 = v185;
        v187[1] = v186;
        v189 = v165 + (int)v184;
        v190 = *(v180 - 1);
        v191 = *v180;
        v192 = (int *)(a3 + 4 * v189);
        v193 = v192[1];
        *(v180 - 1) = *v192;
        *v180 = v193;
        *v192 = v190;
        v192[1] = v191;
        v194 = *(v183 - 1);
        v195 = *v183;
        v196 = v192[3];
        *(v183 - 1) = *(_DWORD *)(a3 + 4 * (v189 + 2));
        *v183 = v196;
        *(_DWORD *)(a3 + 4 * (v189 + 2)) = v194;
        v192[3] = v195;
        v197 = (int)v189 + 2 - v165;
        v198 = *(v181 - 2);
        v199 = *(v181 - 1);
        v200 = (int *)(a3 + 4 * v197);
        v201 = v200[1];
        *(v181 - 2) = *v200;
        *(v181 - 1) = v201;
        *v200 = v198;
        v200[1] = v199;
        v202 = (int *)(a3 + 4 * ((int)v197 + (int)v166));
        v203 = *v181;
        v204 = v181[1];
        v205 = v202[1];
        *v181 = *v202;
        v181[1] = v205;
        v181 += 4;
        *v202 = v203;
        v202[1] = v204;
        v206 = *(_DWORD *)(a3 + 4 * (v178 + (int)v172));
        v207 = *(_DWORD *)(a3 + (v176 >> 30));
        v208 = (_DWORD *)(a3 + 4 * ((int)v189 + 2 + (int)v166));
        v209 = v208[1];
        *(_DWORD *)(a3 + 4 * (v178 + (int)v172)) = *v208;
        *(_DWORD *)(a3 + (v176 >> 30)) = v209;
        *v208 = v206;
        v208[1] = v207;
        LODWORD(v208) = v177 + v172 + 2;
        v210 = *(_DWORD *)(a3 + 4 * (int)v208);
        LODWORD(v202) = v177 + v172 + 3;
        v211 = *(_DWORD *)(a3 + 4 * (int)v202);
        LODWORD(v189) = v189 + v166;
        v212 = (_DWORD *)(a3 + 4 * (int)v189);
        v213 = v212[1];
        *(_DWORD *)(a3 + 4 * (int)v208) = *v212;
        *(_DWORD *)(a3 + 4 * (int)v202) = v213;
        *v212 = v210;
        v212[1] = v211;
        LODWORD(v208) = v173 + v172 + 2;
        v214 = *(_DWORD *)(a3 + 4 * (int)v208);
        LODWORD(v202) = v173 + v172 + 3;
        v215 = *(_DWORD *)(a3 + 4 * (int)v202);
        v216 = (_DWORD *)(a3 + 4 * ((int)v189 - v165));
        v217 = v216[1];
        *(_DWORD *)(a3 + 4 * (int)v208) = *v216;
        v172 += 4;
        v176 += 0x400000000;
        v179 += 4;
        *(_DWORD *)(a3 + 4 * (int)v202) = v217;
        *v216 = v214;
        v216[1] = v215;
        v180 += 4;
        v183 += 4;
        --v182;
      }
      while (v182);
    }
    else
    {
      LODWORD(v174) = 0;
    }
    v218 = *(int *)(a2 + 4 * v171) + (uint64_t)(int)v174;
    v219 = v218 + 2;
    v220 = v218 + v166;
    v221 = *(_DWORD *)(a3 + 4 * (v218 + 2));
    v222 = a3 + 4 * v218;
    v223 = (_DWORD *)(a3 + 4 * ((int)v218 + (int)v166));
    v224 = v223[1];
    *(_DWORD *)(a3 + 4 * v219) = *v223;
    v225 = *(_DWORD *)(v222 + 12);
    *(_DWORD *)(v222 + 12) = v224;
    *v223 = v221;
    v223[1] = v225;
    v226 = v165 + (int)v219;
    LODWORD(v219) = v220 + v165;
    v227 = a3 + 4 * v226;
    result = *(float *)v227;
    v228 = *(_DWORD *)(v227 + 4);
    v229 = (_DWORD *)(a3 + 4 * (int)v219);
    v230 = v229[1];
    *(_DWORD *)v227 = *v229;
    *(_DWORD *)(v227 + 4) = v230;
    *(float *)v229 = result;
    v229[1] = v228;
    ++v163;
  }
  while (v163 != v164);
  return result;
}

float cftf161(float *a1, float *a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float result;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;

  v2 = a1[1];
  v3 = a1[16];
  v4 = a1[17];
  v5 = *a1 + v3;
  v6 = v2 + v4;
  v7 = *a1 - v3;
  v8 = v2 - v4;
  v9 = a1[8];
  v10 = a1[9];
  v11 = a1[24];
  v12 = a1[25];
  v13 = v10 - v12;
  v122 = v5 + (float)(v9 + v11);
  v123 = v6 + (float)(v10 + v12);
  v118 = v6 - (float)(v10 + v12);
  v119 = v5 - (float)(v9 + v11);
  v117 = v7 - (float)(v10 - v12);
  v14 = v8 + (float)(v9 - v11);
  v15 = v7 + v13;
  v16 = v8 - (float)(v9 - v11);
  v17 = a1[2];
  v18 = a1[3];
  v19 = a1[18];
  v20 = a1[19];
  v21 = v17 + v19;
  v22 = v18 + v20;
  v23 = v17 - v19;
  v24 = v18 - v20;
  v25 = a1[10];
  v26 = a1[11];
  v27 = a1[26];
  v28 = a1[27];
  v29 = v25 - v27;
  v30 = v26 - v28;
  v120 = v22 + (float)(v26 + v28);
  v121 = v21 + (float)(v25 + v27);
  v31 = v21 - (float)(v25 + v27);
  v32 = a2[2];
  v33 = a2[3];
  v34 = v22 - (float)(v26 + v28);
  v35 = (float)(v32 * (float)(v23 - v30)) - (float)(v33 * (float)(v24 + v29));
  v36 = (float)(v33 * (float)(v23 - v30)) + (float)(v32 * (float)(v24 + v29));
  v37 = v23 + v30;
  v38 = v24 - v29;
  v39 = (float)(v33 * (float)(v23 + v30)) - (float)(v32 * v38);
  v40 = (float)(v32 * v37) + (float)(v33 * v38);
  v41 = a1[6];
  v42 = a1[7];
  v43 = a1[22];
  v44 = a1[23];
  v45 = a1[14];
  v46 = a1[15];
  v47 = a1[30];
  v48 = a1[31];
  v49 = (float)(v41 - v43) - (float)(v46 - v48);
  v50 = (float)(v42 - v44) + (float)(v45 - v47);
  v51 = (float)(v33 * v49) - (float)(v32 * v50);
  v52 = (float)(v32 * v49) + (float)(v33 * v50);
  v53 = (float)(v41 - v43) + (float)(v46 - v48);
  v54 = (float)(v42 - v44) - (float)(v45 - v47);
  v55 = (float)(v32 * v53) - (float)(v33 * v54);
  v56 = v33 * v53;
  v58 = a1[4];
  v57 = a1[5];
  v59 = v56 + (float)(v32 * v54);
  v60 = a1[20];
  v61 = a1[21];
  v62 = v58 + v60;
  v63 = v58 - v60;
  v64 = v57 + v61;
  v65 = v57 - v61;
  v67 = a1[12];
  v66 = a1[13];
  v68 = a1[28];
  v69 = a1[29];
  v70 = v67 + v68;
  v71 = v67 - v68;
  v72 = v66 + v69;
  v73 = v66 - v69;
  v74 = v62 + v70;
  v75 = v62 - v70;
  v76 = v64 + v72;
  v77 = v64 - v72;
  v78 = (float)(v63 - v73) - (float)(v65 + v71);
  v79 = (float)(v65 + v71) + (float)(v63 - v73);
  v80 = v63 + v73;
  v81 = v65 - v71;
  v82 = v81 + v80;
  v83 = v81 - v80;
  v84 = v41 + v43;
  v85 = v42 + v44;
  v86 = v84 + (float)(v45 + v47);
  v87 = v84 - (float)(v45 + v47);
  v88 = (float)(v42 + v44) + (float)(v46 + v48);
  v89 = v85 - (float)(v46 + v48);
  v90 = a2[1];
  v91 = v90 * v82;
  v92 = v15 - v91;
  v93 = v15 + v91;
  v94 = v90 * v83;
  v95 = v16 - v94;
  v96 = v16 + v94;
  v97 = v39 - v55;
  v98 = v39 + v55;
  v99 = v40 - v59;
  v100 = v40 + v59;
  a1[24] = v92 + v97;
  a1[25] = v95 + v99;
  a1[26] = v92 - v97;
  a1[27] = v95 - v99;
  a1[28] = v93 - v100;
  a1[29] = v96 + v98;
  v101 = v90 * v78;
  v102 = v90 * v79;
  a1[30] = v93 + v100;
  a1[31] = v96 - v98;
  v103 = v117 + v101;
  v104 = v14 + v102;
  v105 = v117 - v101;
  v106 = v14 - v102;
  v107 = v35 + v51;
  v108 = v35 - v51;
  a1[16] = v103 + v107;
  a1[17] = v104 + (float)(v36 + v52);
  a1[18] = v103 - v107;
  a1[19] = v104 - (float)(v36 + v52);
  a1[20] = v105 - (float)(v36 - v52);
  a1[21] = v106 + v108;
  a1[22] = v105 + (float)(v36 - v52);
  a1[23] = v106 - v108;
  v109 = v90 * (float)((float)(v31 - v89) - (float)(v34 + v87));
  v110 = v90 * (float)((float)(v34 + v87) + (float)(v31 - v89));
  v111 = v34 - v87;
  v112 = v90 * (float)((float)(v31 + v89) - v111);
  v113 = v90 * (float)(v111 + (float)(v31 + v89));
  v114 = v118 + v75;
  v115 = v118 - v75;
  a1[8] = (float)(v119 - v77) + v109;
  a1[9] = v114 + v110;
  a1[10] = (float)(v119 - v77) - v109;
  a1[11] = v114 - v110;
  a1[12] = (float)(v119 + v77) - v113;
  a1[13] = v115 + v112;
  a1[14] = (float)(v119 + v77) + v113;
  a1[15] = v115 - v112;
  *a1 = (float)(v122 + v74) + (float)(v121 + v86);
  a1[1] = (float)(v123 + v76) + (float)(v120 + v88);
  a1[2] = (float)(v122 + v74) - (float)(v121 + v86);
  a1[3] = (float)(v123 + v76) - (float)(v120 + v88);
  a1[4] = (float)(v122 - v74) - (float)(v120 - v88);
  a1[5] = (float)(v123 - v76) + (float)(v121 - v86);
  result = (float)(v123 - v76) - (float)(v121 - v86);
  a1[6] = (float)(v122 - v74) + (float)(v120 - v88);
  a1[7] = result;
  return result;
}

double bitrv216(uint64_t a1)
{
  double result;
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;

  result = *(double *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)&v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)&v4 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)&v5 = *(_QWORD *)(a1 + 96);
  v6 = *(_QWORD *)(a1 + 104);
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)&v7 = *(_QWORD *)(a1 + 64);
  *((_QWORD *)&v7 + 1) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)&v9 = *(_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 8) = v7;
  *((_QWORD *)&v5 + 1) = v2;
  *(_OWORD *)(a1 + 24) = v5;
  v10 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 80);
  *((double *)&v9 + 1) = result;
  *((_QWORD *)&v4 + 1) = v6;
  *((_QWORD *)&v3 + 1) = v10;
  *(_OWORD *)(a1 + 80) = v4;
  *(_OWORD *)(a1 + 96) = v3;
  *(_OWORD *)(a1 + 56) = v9;
  *(_QWORD *)(a1 + 112) = v8;
  return result;
}

float cftf081(float *a1, uint64_t a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float result;

  v2 = *(float *)(a2 + 4);
  v3 = a1[1];
  v4 = a1[8];
  v5 = a1[9];
  v6 = *a1 + v4;
  v7 = v3 + v5;
  v8 = *a1 - v4;
  v9 = v3 - v5;
  v10 = a1[4];
  v11 = a1[5];
  v12 = a1[12];
  v13 = a1[13];
  v14 = v10 + v12;
  v15 = v11 + v13;
  v16 = v10 - v12;
  v17 = v11 - v13;
  v18 = v6 + v14;
  v19 = v7 + v15;
  v20 = v6 - v14;
  v21 = v7 - v15;
  v22 = v8 - v17;
  v23 = v9 + v16;
  v24 = v8 + v17;
  v25 = v9 - v16;
  v26 = a1[2];
  v27 = a1[3];
  v28 = a1[10];
  v29 = a1[11];
  v30 = v26 + v28;
  v31 = v27 + v29;
  v32 = v26 - v28;
  v33 = v27 - v29;
  v34 = a1[6];
  v35 = a1[7];
  v36 = a1[14];
  v37 = a1[15];
  v38 = v34 + v36;
  v39 = v35 + v37;
  v40 = v34 - v36;
  v41 = v35 - v37;
  v42 = v30 + v38;
  v43 = v30 - v38;
  v44 = v32 - v41;
  v45 = v32 + v41;
  v46 = v33 + v40;
  v47 = v33 - v40;
  v48 = v2 * (float)(v44 - v46);
  v49 = v2 * (float)(v46 + v44);
  v50 = v2 * (float)(v45 - v47);
  v51 = v2 * (float)(v47 + v45);
  a1[8] = v22 + v48;
  a1[9] = v23 + v49;
  a1[10] = v22 - v48;
  a1[11] = v23 - v49;
  a1[12] = v24 - v51;
  a1[13] = v25 + v50;
  a1[14] = v24 + v51;
  a1[15] = v25 - v50;
  *a1 = v18 + v42;
  a1[1] = v19 + (float)(v31 + v39);
  a1[2] = v18 - v42;
  a1[3] = v19 - (float)(v31 + v39);
  a1[4] = v20 - (float)(v31 - v39);
  a1[5] = v21 + v43;
  result = v21 - v43;
  a1[6] = v20 + (float)(v31 - v39);
  a1[7] = result;
  return result;
}

float cftf040(float *a1)
{
  float v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float result;

  v1 = a1[1];
  v2 = a1[4];
  v3 = a1[5];
  v4 = *a1 + v2;
  v5 = v1 + v3;
  v6 = *a1 - v2;
  v7 = v1 - v3;
  v8 = a1[2];
  v9 = a1[3];
  v10 = a1[6];
  v11 = a1[7];
  v12 = v8 + v10;
  v13 = v9 + v11;
  v14 = v8 - v10;
  v15 = v9 - v11;
  *a1 = v4 + v12;
  a1[1] = v5 + v13;
  a1[2] = v6 - v15;
  a1[3] = v7 + v14;
  a1[4] = v4 - v12;
  a1[5] = v5 - v13;
  result = v6 + v15;
  a1[6] = result;
  a1[7] = v7 - v14;
  return result;
}

float cftb1st(int a1, float *a2, float *a3)
{
  uint64_t v3;
  int v4;
  float v5;
  float v6;
  float v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float v19;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float *v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float *v73;
  float *v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float *v96;
  float *v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float *v112;
  float v113;
  float *v114;
  float v115;
  float v116;
  float v117;
  float v118;
  uint64_t v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float *v142;
  float v143;
  float v144;
  float v145;
  float *v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float *v151;
  float *v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float *v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float result;

  v3 = 2 * (a1 >> 3);
  v4 = 4 * (a1 >> 3);
  v5 = a2[v4];
  v6 = a2[1];
  v7 = *a2 + v5;
  v8 = &a2[4 * (a1 >> 3)];
  v9 = v8[1];
  v10 = (float)-v6 - v9;
  v11 = *a2 - v5;
  v12 = 2 * (a1 >> 3);
  v13 = a2[v12];
  v14 = v9 - v6;
  v15 = a2[6 * (a1 >> 3)];
  v16 = v13 + v15;
  v17 = a2[(int)(v3 | 1)];
  v18 = (6 * (a1 >> 3)) | 1;
  v19 = a2[v18];
  v20 = v13 - v15;
  *a2 = v7 + v16;
  a2[1] = v10 - (float)(v17 + v19);
  a2[v12] = v7 - v16;
  a2[(int)(v3 | 1)] = v10 + (float)(v17 + v19);
  a2[v4] = v11 + (float)(v17 - v19);
  v8[1] = v14 + v20;
  a2[6 * (a1 >> 3)] = v11 - (float)(v17 - v19);
  a2[v18] = v14 - v20;
  v21 = (uint64_t)a1 >> 3;
  v22 = a3[1];
  v23 = a3[2];
  v24 = a3[3];
  v25 = v21 - 2;
  if (a1 < 40)
  {
    v48 = 0.0;
    v47 = 1.0;
    v49 = 1.0;
    v50 = 0.0;
  }
  else
  {
    v26 = 0;
    v27 = 24 * (_DWORD)v21;
    v28 = v27 + 12;
    v29 = 4 * v4;
    v30 = v29 + 12;
    v31 = v29 - 4;
    v32 = v27 - 4;
    v33 = a3 + 7;
    v34 = 24 * (a1 >> 3) + 16;
    v35 = 2 * (a1 >> 3);
    v36 = v35 * 4 - 8;
    v37 = 8 * v3 + 16;
    v38 = 8 * v3 - 8;
    v39 = 12 * v3 - 8;
    v40 = 1.0;
    v41 = 0.0;
    v42 = 0.0;
    v43 = 16 * v3 - 16;
    v44 = 2;
    v45 = (v3 << 34) - 0x200000000;
    v46 = 1.0;
    do
    {
      v47 = v33[v26 - 3];
      v48 = v33[v26 - 2];
      v49 = v33[v26 - 1];
      v50 = v33[v26];
      v51 = v40 + v49;
      v52 = &a2[v26];
      v53 = (float *)((char *)a2 + v37);
      v54 = *(float *)((char *)a2 + v37 - 8);
      v55 = v41 + v50;
      v56 = a2[v26 + 2];
      v57 = a2[v26 + 3];
      v58 = v56 + v54;
      v59 = *(float *)((char *)a2 + v30);
      v60 = -v57;
      v61 = v56 - v54;
      v62 = v59 - v57;
      v63 = a2[v26 + 4];
      v64 = a2[v26 + 5];
      v65 = v60 - v59;
      v67 = *(float *)((char *)a2 + v37);
      v66 = *(float *)((char *)a2 + v37 + 4);
      v68 = v63 + v67;
      v69 = (float)-v64 - v66;
      v70 = v63 - v67;
      v71 = v23 * (float)(v46 + v47);
      v72 = v66 - v64;
      v73 = &a2[v35];
      v74 = (float *)((char *)a2 + v34);
      v75 = *(float *)((char *)a2 + v34 - 8);
      v76 = v23 * (float)(v42 + v48);
      v78 = a2[v35 + 2];
      v77 = a2[v35 + 3];
      v79 = v78 + v75;
      v80 = *(float *)((char *)a2 + v28);
      v81 = v77 + v80;
      v82 = v24 * v51;
      v83 = v78 - v75;
      v84 = v77 - v80;
      v86 = a2[v35 + 4];
      v85 = a2[v35 + 5];
      v87 = v24 * v55;
      v88 = *(float *)((char *)a2 + v34);
      v89 = *(float *)((char *)a2 + v34 + 4);
      v90 = v86 + v88;
      v91 = v85 + v89;
      v92 = v86 - v88;
      v93 = v85 - v89;
      v52[4] = v68 + v90;
      v52[5] = v69 - v91;
      v52[2] = v58 + v79;
      v52[3] = v65 - v81;
      v73[2] = v58 - v79;
      v73[3] = v65 + v81;
      v73[4] = v68 - v90;
      v73[5] = v69 + v91;
      *(v53 - 2) = (float)(v71 * (float)(v61 + v84)) - (float)(v76 * (float)(v62 + v83));
      *(float *)((char *)a2 + v30) = (float)(v76 * (float)(v61 + v84)) + (float)(v71 * (float)(v62 + v83));
      v94 = v62 - v83;
      *v53 = (float)(v47 * (float)(v70 + v93)) - (float)(v48 * (float)(v72 + v92));
      v53[1] = (float)(v48 * (float)(v70 + v93)) + (float)(v47 * (float)(v72 + v92));
      *(v74 - 2) = (float)(v87 * v94) + (float)(v82 * (float)(v61 - v84));
      v95 = v70 - v93;
      *(float *)((char *)a2 + v28) = (float)(v82 * v94) - (float)(v87 * (float)(v61 - v84));
      *v74 = (float)(v50 * (float)(v72 - v92)) + (float)(v49 * v95);
      v74[1] = (float)(v49 * (float)(v72 - v92)) - (float)(v50 * v95);
      v96 = (float *)((char *)a2 + v36);
      v97 = (float *)((char *)a2 + v39);
      v99 = *(float *)((char *)a2 + v39 - 4);
      v98 = *(float *)((char *)a2 + v39);
      v100 = *(float *)((char *)a2 + v36);
      v101 = *(float *)((char *)a2 + v36 + 4);
      v102 = v100 + v98;
      v103 = -v101;
      v104 = *(float *)((char *)a2 + v32);
      v105 = v100 - v98;
      v107 = *(float *)((char *)a2 + v36 - 8);
      v106 = *(float *)((char *)a2 + v36 - 4);
      v108 = *(float *)((char *)a2 + v39 - 8);
      v109 = v107 + v108;
      v110 = -v106;
      v111 = v107 - v108;
      v112 = (float *)((char *)a2 + v38);
      v113 = *(float *)((char *)a2 + v38);
      v114 = (float *)((char *)a2 + v43);
      v115 = *(float *)((char *)a2 + v31);
      v116 = v99 - v106;
      v117 = *(float *)((char *)a2 + v43 + 4);
      v118 = *(float *)((char *)a2 + v43 + 8);
      v119 = (v45 >> 30) | 4;
      v120 = *(float *)((char *)a2 + v119);
      v121 = v104 - v101;
      v122 = v113 + v118;
      v123 = v115 + v120;
      v124 = v113 - v118;
      v125 = v115 - v120;
      v126 = v103 - v104;
      v128 = *(float *)((char *)a2 + v38 - 8);
      v127 = *(float *)((char *)a2 + v38 - 4);
      v129 = *(float *)((char *)a2 + v43);
      v130 = v127 + v117;
      v131 = v110 - v99;
      v132 = v127 - v117;
      *v96 = v102 + v122;
      v96[1] = v126 - v123;
      *(v96 - 2) = v109 + (float)(v128 + v129);
      *(v96 - 1) = v131 - v130;
      *v112 = v102 - v122;
      *(float *)((char *)a2 + v31) = v126 + v123;
      *(v112 - 2) = v109 - (float)(v128 + v129);
      *(v112 - 1) = v131 + v130;
      v133 = (float)(v76 * (float)(v105 + v125)) - (float)(v71 * (float)(v121 + v124));
      v134 = (float)(v71 * (float)(v105 + v125)) + (float)(v76 * (float)(v121 + v124));
      v135 = v105 - v125;
      v136 = v121 - v124;
      *v97 = v133;
      *(float *)((char *)a2 + v32) = v134;
      v44 += 4;
      *(v97 - 2) = (float)(v48 * (float)(v111 + v132)) - (float)(v47 * (float)(v116 + (float)(v128 - v129)));
      *(v97 - 1) = (float)(v47 * (float)(v111 + v132)) + (float)(v48 * (float)(v116 + (float)(v128 - v129)));
      v28 += 16;
      v30 += 16;
      v31 -= 16;
      v26 += 4;
      v34 += 16;
      v114[2] = (float)(v82 * v136) + (float)(v87 * v135);
      v36 -= 16;
      v37 += 16;
      v35 += 4;
      v38 -= 16;
      *(float *)((char *)a2 + v119) = (float)(v87 * v136) - (float)(v82 * v135);
      v39 -= 16;
      v45 -= 0x400000000;
      v43 -= 16;
      v41 = v50;
      v32 -= 16;
      *v114 = (float)(v49 * (float)(v116 - (float)(v128 - v129))) + (float)(v50 * (float)(v111 - v132));
      v114[1] = (float)(v50 * (float)(v116 - (float)(v128 - v129))) - (float)(v49 * (float)(v111 - v132));
      v40 = v49;
      v42 = v48;
      v46 = v47;
    }
    while (v44 < v25);
  }
  v137 = v23 * (float)(v22 + v47);
  v138 = v23 * (float)(v22 + v48);
  v139 = v24 * (float)(v49 - v22);
  v140 = v24 * (float)(v50 - v22);
  v141 = a2[v25];
  v142 = &a2[5 * v21];
  v143 = *(v142 - 2);
  v144 = *(v142 - 1);
  v145 = v141 + v143;
  v146 = &a2[v21];
  v147 = *(v146 - 1);
  v148 = (float)-v147 - v144;
  v149 = v141 - v143;
  v150 = v144 - v147;
  v151 = &a2[3 * (int)v21];
  v152 = &a2[7 * v21];
  v153 = *(v152 - 2);
  v154 = *(v151 - 2);
  v155 = *(v151 - 1);
  v156 = v154 + v153;
  v157 = &a2[7 * (_DWORD)v21];
  v158 = *(v157 - 1);
  v159 = v154 - v153;
  a2[v25] = v145 + v156;
  *(v146 - 1) = v148 - (float)(v155 + v158);
  *(v151 - 2) = v145 - v156;
  *(v151 - 1) = v148 + (float)(v155 + v158);
  v160 = v149 + (float)(v155 - v158);
  *(v142 - 2) = (float)(v137 * v160) - (float)(v138 * (float)(v150 + v159));
  *(v142 - 1) = (float)(v138 * v160) + (float)(v137 * (float)(v150 + v159));
  v161 = v149 - (float)(v155 - v158);
  v162 = v150 - v159;
  *(v152 - 2) = (float)(v140 * v162) + (float)(v139 * v161);
  *(v157 - 1) = (float)(v139 * v162) - (float)(v140 * v161);
  v163 = v146[1];
  v164 = v142[1];
  v165 = *v146 + *v142;
  v166 = (float)-v163 - v164;
  v167 = *v146 - *v142;
  v168 = v164 - v163;
  v169 = v151[1];
  v170 = v157[1];
  v171 = *v151 + *v157;
  v172 = v169 + v170;
  v173 = *v151 - *v157;
  v174 = v169 - v170;
  *v146 = v165 + v171;
  v146[1] = v166 - v172;
  *v151 = v165 - v171;
  v151[1] = v166 + v172;
  *v142 = v22 * (float)((float)(v167 + v174) - (float)(v168 + v173));
  v142[1] = v22 * (float)((float)(v168 + v173) + (float)(v167 + v174));
  v175 = v167 - v174;
  v176 = v168 - v173;
  *v157 = -(float)(v22 * (float)(v176 + v175));
  v157[1] = -(float)(v22 * (float)(v176 - v175));
  v177 = v146[2];
  v178 = v146[3];
  v179 = v142[2];
  v180 = v142[3];
  v181 = v177 + v179;
  v182 = (float)-v178 - v180;
  v183 = v177 - v179;
  v184 = v180 - v178;
  v185 = v151[2];
  v186 = v151[3];
  v187 = v157[2];
  v188 = v157[3];
  v189 = v185 + v187;
  v190 = v186 + v188;
  v191 = v185 - v187;
  v192 = v186 - v188;
  v146[2] = v181 + v189;
  v146[3] = v182 - v190;
  v151[2] = v181 - v189;
  v151[3] = v182 + v190;
  v142[2] = (float)(v138 * (float)(v183 + v192)) - (float)(v137 * (float)(v184 + v191));
  v142[3] = (float)(v137 * (float)(v183 + v192)) + (float)(v138 * (float)(v184 + v191));
  v193 = v183 - v192;
  v194 = (float)(v139 * (float)(v184 - v191)) + (float)(v140 * v193);
  result = (float)(v140 * (float)(v184 - v191)) - (float)(v139 * v193);
  v157[2] = v194;
  v157[3] = result;
  return result;
}

float bitrv2conj(int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  float v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  float v49;
  float v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  float v54;
  uint64_t v55;
  float v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  float v63;
  uint64_t v64;
  int v65;
  float v66;
  float v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  float v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  float v77;
  uint64_t v78;
  float v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  float v83;
  uint64_t v84;
  float v85;
  int v86;
  uint64_t v87;
  float v88;
  float v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  float v95;
  float v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  float v100;
  uint64_t v101;
  int v102;
  float v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  float v108;
  float v109;
  int v110;
  float v111;
  float v112;
  uint64_t v113;
  float v114;
  uint64_t v115;
  int v116;
  float v117;
  int v118;
  float v119;
  uint64_t v120;
  uint64_t v121;
  float v122;
  int v123;
  uint64_t v124;
  float v125;
  float v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  float v132;
  uint64_t v133;
  float v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  float v139;
  uint64_t v140;
  float v141;
  uint64_t v142;
  uint64_t v143;
  float *v144;
  float v145;
  uint64_t v146;
  float v147;
  float *v148;
  float v149;
  int v150;
  float v151;
  float *v152;
  float v153;
  float *v154;
  float v155;
  float v156;
  float v157;
  float *v158;
  float v159;
  uint64_t v160;
  float v161;
  float *v162;
  float v163;
  float result;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  int v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  int v179;
  int v180;
  float *v181;
  float *v182;
  uint64_t v183;
  uint64_t v184;
  float *v185;
  uint64_t v186;
  int v187;
  float v188;
  float *v189;
  float v190;
  uint64_t v191;
  int v192;
  float *v193;
  float v194;
  float v195;
  int v196;
  float v197;
  float v198;
  uint64_t v199;
  int v200;
  float v201;
  uint64_t v202;
  float v203;
  int v204;
  float v205;
  uint64_t v206;
  float v207;
  int v208;
  uint64_t v209;
  float v210;
  float v211;
  int v212;
  uint64_t v213;
  float v214;
  uint64_t v215;
  float v216;
  int v217;
  float v218;
  uint64_t v219;
  float v220;
  uint64_t v221;
  uint64_t v222;
  int v223;
  uint64_t v224;
  int v225;
  float v226;
  uint64_t v227;
  float v228;
  uint64_t v229;
  float *v230;
  float v231;
  float v232;
  float *v233;
  float v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  int v240;
  uint64_t v241;
  unint64_t v242;
  uint64_t v243;
  uint64_t v244;

  v3 = a1 >> 2;
  if (a1 < 36)
  {
    v8 = a1 >> 1;
    v9 = 4;
    v4 = 1;
    if (v3 == 8)
    {
LABEL_8:
      v10 = 0;
      v11 = 8 * v4;
      v12 = v4;
      v13 = a2 + 4 * v4;
      v235 = 2 * (int)v9 + v8;
      v236 = v4;
      v237 = a2;
      do
      {
        v14 = v10 + v12;
        if (v10)
        {
          v15 = 0;
          v16 = 0;
          v238 = v10 + v12;
          v17 = *(int *)(a2 + 4 * v14);
          v18 = 4 * (int)v10;
          v243 = (v9 << 33) + (v17 << 33);
          v244 = 8 * v17;
          v242 = ((unint64_t)(3 * v9) << 32) + (v17 << 33);
          v19 = v235 + (int)v9 + 2 * v17;
          v241 = (v19 << 32) + 0x300000000;
          v240 = 2 * v17;
          v20 = v9 + 2 * v17;
          v21 = 2 * (v9 + v17);
          v22 = 3 * v9 + 2 * v17;
          v23 = v8 + 3 * v9 + 2 + 2 * v17;
          v24 = v235 + 2 * v17;
          v25 = (v24 << 32) + 0x300000000;
          v26 = (v24 << 32) + 0x200000000;
          v27 = (int)v9 + (uint64_t)v8 + 2 * v17;
          v28 = (v27 << 32) + 0x300000000;
          v29 = (v27 << 32) + 0x200000000;
          v30 = 4 * (int)v9 + 8 * v17;
          v31 = a3 + 8 * (int)v9 + 8 * v17;
          v32 = a3 + 12 * (int)v9 + 8 * v17;
          v33 = 4 * v19;
          v34 = 4 * v27;
          v35 = 4 * v24;
          v36 = a3;
          v239 = v10;
          v37 = 4 * v8 + 8 * v17;
          do
          {
            v38 = v13;
            v39 = v18 + 2 * *(int *)(v13 + v16);
            v40 = v36 + v244;
            v41 = *(_DWORD *)(v36 + v244);
            v42 = -*(float *)(v36 + v244 + 4);
            v43 = (4 * v39) | 4;
            v44 = -*(float *)(a3 + v43);
            *(_DWORD *)v40 = *(_DWORD *)(a3 + 4 * v39);
            *(float *)(v40 + 4) = v44;
            *(_DWORD *)(a3 + 4 * v39) = v41;
            *(float *)(a3 + v43) = v42;
            v45 = (int)v39 + (uint64_t)(int)v11;
            v46 = v36 + v30;
            v47 = *(_DWORD *)(v36 + v30);
            v48 = (4 * v45) | 4;
            v49 = -*(float *)(v36 + v30 + 4);
            v50 = -*(float *)(a3 + v48);
            *(_DWORD *)v46 = *(_DWORD *)(a3 + 4 * v45);
            *(float *)(v46 + 4) = v50;
            *(_DWORD *)(a3 + 4 * v45) = v47;
            *(float *)(a3 + v48) = v49;
            v51 = (int)v45 - (uint64_t)(int)v9;
            v52 = *(_DWORD *)(v31 + 4 * v16);
            v53 = ((v243 + v15) >> 30) | 4;
            v54 = *(float *)(a3 + v53);
            v55 = (4 * v51) | 4;
            v56 = -*(float *)(a3 + v55);
            *(_DWORD *)(v31 + 4 * v16) = *(_DWORD *)(a3 + 4 * v51);
            *(float *)(a3 + v53) = v56;
            *(_DWORD *)(a3 + 4 * v51) = v52;
            *(float *)(a3 + v55) = -v54;
            v57 = v11 + (int)v51;
            v58 = *(_DWORD *)(v32 + 4 * v16);
            v59 = ((uint64_t)(v242 + v15) >> 30) | 4;
            v60 = a3 + 4 * v57;
            v61 = (4 * v57) | 4;
            v62 = -*(float *)(a3 + v59);
            v63 = -*(float *)(a3 + v61);
            *(_DWORD *)(v32 + 4 * v16) = *(_DWORD *)v60;
            *(float *)(a3 + v59) = v63;
            *(_DWORD *)v60 = v58;
            *(float *)(a3 + v61) = v62;
            v57 += 2;
            v64 = v36 + v33;
            v65 = *(_DWORD *)(v36 + v33);
            v66 = -*(float *)(v36 + v33 + 4);
            v67 = -*(float *)(v60 + 12);
            *(_DWORD *)v64 = *(_DWORD *)(a3 + 4 * v57);
            *(float *)(v64 + 4) = v67;
            *(_DWORD *)(a3 + 4 * v57) = v65;
            v68 = (int)v57 - (uint64_t)(int)v11;
            *(float *)(v60 + 12) = v66;
            v69 = v36 + v35;
            v70 = *(_DWORD *)(v36 + v35);
            v71 = a3 + 4 * v68;
            v72 = -*(float *)(v36 + v35 + 4);
            v73 = -*(float *)(v71 + 4);
            *(_DWORD *)v69 = *(_DWORD *)v71;
            *(float *)(v69 + 4) = v73;
            *(_DWORD *)v71 = v70;
            *(float *)(v71 + 4) = v72;
            v74 = (int)v68 + (uint64_t)(int)v9;
            v75 = v36 + v34;
            v76 = *(_DWORD *)(v36 + v34);
            v77 = -*(float *)(v36 + v34 + 4);
            v78 = a3 + 4 * v74;
            v79 = -*(float *)(v78 + 4);
            *(_DWORD *)v75 = *(_DWORD *)v78;
            *(float *)(v75 + 4) = v79;
            *(_DWORD *)v78 = v76;
            *(float *)(v78 + 4) = v77;
            v80 = (int)v74 - (uint64_t)(int)v11;
            v81 = v36 + v37;
            v82 = *(_DWORD *)(v36 + v37);
            v83 = -*(float *)(v36 + v37 + 4);
            v84 = a3 + 4 * v80;
            v85 = -*(float *)(v84 + 4);
            *(_DWORD *)v81 = *(_DWORD *)v84;
            *(float *)(v81 + 4) = v85;
            *(_DWORD *)v84 = v82;
            *(float *)(v84 + 4) = v83;
            v86 = *(_DWORD *)(v36 + v37 + 8);
            v87 = a3 + 4 * ((int)v80 + (uint64_t)v8);
            v88 = -*(float *)(v36 + v37 + 12);
            v89 = -*(float *)(v87 + 4);
            *(_DWORD *)(v81 + 8) = *(_DWORD *)v87;
            *(float *)(v81 + 12) = v89;
            *(_DWORD *)v87 = v86;
            *(float *)(v87 + 4) = v88;
            v90 = (v29 + v15) >> 30;
            v91 = (v28 + v15) >> 30;
            v92 = *(_DWORD *)(a3 + v90);
            v93 = (int)v74 + v8;
            v94 = a3 + 4 * v93;
            v95 = -*(float *)(a3 + v91);
            v96 = -*(float *)(v94 + 4);
            *(_DWORD *)(a3 + v90) = *(_DWORD *)v94;
            *(float *)(a3 + v91) = v96;
            v97 = v93 - (int)v9;
            v98 = (v26 + v15) >> 30;
            *(_DWORD *)v94 = v92;
            *(float *)(v94 + 4) = v95;
            v99 = (v25 + v15) >> 30;
            v100 = *(float *)(a3 + v99);
            v101 = a3 + 4 * v97;
            v102 = *(_DWORD *)(a3 + v98);
            v103 = -*(float *)(v101 + 4);
            *(_DWORD *)(a3 + v98) = *(_DWORD *)v101;
            *(float *)(a3 + v99) = v103;
            *(_DWORD *)v101 = v102;
            *(float *)(v101 + 4) = -v100;
            v104 = *(_DWORD *)(a3 + 4 * (v23 + (int)v16));
            v105 = (v241 + v15) >> 30;
            v106 = (int)v97 + (uint64_t)(int)v11;
            v107 = a3 + 4 * v106;
            v108 = -*(float *)(v107 + 4);
            v109 = -*(float *)(a3 + v105);
            *(_DWORD *)(a3 + 4 * (v23 + (int)v16)) = *(_DWORD *)v107;
            *(float *)(a3 + v105) = v108;
            *(_DWORD *)v107 = v104;
            *(float *)(v107 + 4) = v109;
            LODWORD(v105) = v22 + v16 + 2;
            v106 -= 2;
            LODWORD(v99) = v22 + v16 + 3;
            v110 = *(_DWORD *)(a3 + 4 * (int)v105);
            v111 = *(float *)(a3 + 4 * (int)v99);
            v112 = -*(float *)(v107 - 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)(a3 + 4 * v106);
            *(float *)(a3 + 4 * (int)v99) = v112;
            *(_DWORD *)(a3 + 4 * v106) = v110;
            LODWORD(v105) = v21 + v16 + 2;
            v113 = (int)v106 - (uint64_t)(int)v11;
            *(float *)(v107 - 4) = -v111;
            LODWORD(v99) = v21 + v16 + 3;
            v114 = *(float *)(a3 + 4 * (int)v99);
            v115 = a3 + 4 * v113;
            v116 = *(_DWORD *)(a3 + 4 * (int)v105);
            v117 = -*(float *)(v115 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v115;
            *(float *)(a3 + 4 * (int)v99) = v117;
            LODWORD(v105) = v20 + v16 + 2;
            *(_DWORD *)v115 = v116;
            *(float *)(v115 + 4) = -v114;
            v118 = *(_DWORD *)(a3 + 4 * (int)v105);
            LODWORD(v99) = v20 + v16 + 3;
            v119 = *(float *)(a3 + 4 * (int)v99);
            v120 = (int)v113 + (uint64_t)(int)v9;
            v121 = a3 + 4 * v120;
            v122 = *(float *)(v121 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v121;
            *(float *)(a3 + 4 * (int)v99) = -v122;
            *(_DWORD *)v121 = v118;
            *(float *)(v121 + 4) = -v119;
            LODWORD(v105) = v240 + v16 + 2;
            v123 = *(_DWORD *)(a3 + 4 * (int)v105);
            v124 = a3 + 4 * ((int)v120 - (uint64_t)(int)v11);
            v125 = *(float *)(v124 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v124;
            LODWORD(v99) = v240 + v16 + 3;
            v126 = *(float *)(a3 + 4 * (int)v99);
            *(float *)(a3 + 4 * (int)v99) = -v125;
            *(_DWORD *)v124 = v123;
            *(float *)(v124 + 4) = -v126;
            v13 = v38;
            v16 += 4;
            v36 += 16;
            v15 += 0x400000000;
            --v10;
          }
          while (v10);
          v12 = v236;
          a2 = v237;
          v14 = v238;
          v10 = v239;
        }
        else
        {
          LODWORD(v18) = 0;
        }
        v127 = 2 * *(int *)(a2 + 4 * v14) + (int)v18;
        v128 = v127 + 2;
        *(float *)(a3 + ((4 * v127) | 4)) = -*(float *)(a3 + ((4 * v127) | 4));
        v129 = *(_DWORD *)(a3 + 4 * (v127 + 2));
        v130 = (int)v127 + (uint64_t)v8;
        v131 = a3 + 4 * v127;
        v132 = -*(float *)(v131 + 12);
        v133 = a3 + 4 * v130;
        v134 = -*(float *)(v133 + 4);
        *(_DWORD *)(a3 + 4 * v128) = *(_DWORD *)v133;
        *(float *)(v131 + 12) = v134;
        *(_DWORD *)v133 = v129;
        *(float *)(v133 + 4) = v132;
        *(float *)(v133 + 12) = -*(float *)(v133 + 12);
        v135 = (int)v128 + (uint64_t)(int)v9;
        v136 = (int)v130 + (uint64_t)(int)v11;
        v137 = *(_DWORD *)(a3 + 4 * v135);
        v138 = (4 * v135) | 4;
        v139 = -*(float *)(a3 + v138);
        v140 = a3 + 4 * v136;
        v141 = -*(float *)(v140 + 4);
        *(_DWORD *)(a3 + 4 * v135) = *(_DWORD *)v140;
        *(float *)(a3 + v138) = v141;
        *(_DWORD *)v140 = v137;
        *(float *)(v140 + 4) = v139;
        v142 = (int)v135 + (uint64_t)(int)v9;
        v143 = (int)v136 - (uint64_t)(int)v9;
        v144 = (float *)(a3 + 4 * v142);
        v145 = *v144;
        v146 = (4 * v142) | 4;
        v147 = *(float *)(a3 + v146);
        v148 = (float *)(a3 + 4 * v143);
        v149 = -v148[1];
        *v144 = *v148;
        *(float *)(a3 + v146) = v149;
        *v148 = v145;
        v148[1] = -v147;
        v150 = *((_DWORD *)v144 - 2);
        v151 = -*(v144 - 1);
        v152 = (float *)(a3 + 4 * ((int)v143 - (uint64_t)v8));
        v153 = -v152[1];
        *(v144 - 2) = *v152;
        *(v144 - 1) = v153;
        *(_DWORD *)v152 = v150;
        v152[1] = v151;
        v154 = (float *)(a3 + 4 * ((int)v142 + v8));
        v155 = *v154;
        v156 = -v154[1];
        v157 = -*(float *)(a3 + 4 * ((int)v143 + 3));
        *v154 = *(float *)(a3 + 4 * ((int)v143 + 2));
        v154[1] = v157;
        *(float *)(a3 + 4 * ((int)v143 + 2)) = v155;
        *(float *)(a3 + 4 * ((int)v143 + 3)) = v156;
        LODWORD(v142) = v142 + v9;
        v158 = (float *)(a3 + 4 * (int)v142);
        *(v158 - 1) = -*(v158 - 1);
        v159 = *v158;
        v160 = (4 * (int)v142) | 4;
        v161 = -*(float *)(a3 + v160);
        v162 = (float *)(a3 + 4 * ((int)v143 + (int)v11));
        v163 = -v162[1];
        *v158 = *v162;
        *(float *)(a3 + v160) = v163;
        *v162 = v159;
        v162[1] = v161;
        result = -v162[3];
        v162[3] = result;
        ++v10;
      }
      while (v10 != v12);
      return result;
    }
  }
  else
  {
    v4 = 1;
    do
    {
      v5 = v4;
      v4 *= 2;
      v6 = v3 >> 2;
      v7 = v3 > 0x23;
      v3 >>= 2;
    }
    while (v7);
    v8 = a1 >> 1;
    v9 = (8 * v5);
    if (v6 == 8)
    {
      if (v4 < 1)
        return result;
      goto LABEL_8;
    }
    if (v4 < 1)
      return result;
  }
  v165 = 0;
  v166 = v4;
  v167 = (int)v9;
  v168 = v8;
  v169 = v8 + v9 + 2;
  v170 = a3 + 4;
  v171 = a2 + 4 * v4;
  v172 = v167 + v8;
  do
  {
    v173 = v165 + v166;
    if (v165)
    {
      v174 = 0;
      v175 = *(_DWORD *)(a2 + 4 * v173);
      v176 = 4 * (int)v165;
      v177 = v172 + v175;
      v178 = (v177 << 32) + 0x300000000;
      v179 = v167 + v175;
      v180 = v169 + v175;
      v181 = (float *)(v170 + 4 * v175);
      v182 = (float *)(v170 + 4 * (v167 + v175));
      v183 = a3 + 8 + 4 * (v168 + v175);
      v184 = v165;
      v185 = (float *)(v170 + 4 * v177);
      do
      {
        v186 = *(int *)(v171 + v174) + v176;
        v187 = *((_DWORD *)v181 - 1);
        v188 = -*v181;
        v189 = (float *)(a3 + 4 * v186);
        v190 = -v189[1];
        *(v181 - 1) = *v189;
        *v181 = v190;
        *(_DWORD *)v189 = v187;
        v189[1] = v188;
        v191 = v167 + (int)v186;
        v192 = *((_DWORD *)v182 - 1);
        v193 = (float *)(a3 + 4 * v191);
        v194 = -*v182;
        v195 = -v193[1];
        *(v182 - 1) = *v193;
        *v182 = v195;
        *(_DWORD *)v193 = v192;
        v193[1] = v194;
        v196 = *((_DWORD *)v185 - 1);
        v197 = -*v185;
        v198 = -v193[3];
        *(v185 - 1) = *(float *)(a3 + 4 * (v191 + 2));
        *v185 = v198;
        *(_DWORD *)(a3 + 4 * (v191 + 2)) = v196;
        v193[3] = v197;
        v199 = (int)v191 + 2 - v167;
        v200 = *(_DWORD *)(v183 - 8);
        v201 = -*(float *)(v183 - 4);
        v202 = a3 + 4 * v199;
        v203 = -*(float *)(v202 + 4);
        *(_DWORD *)(v183 - 8) = *(_DWORD *)v202;
        *(float *)(v183 - 4) = v203;
        *(_DWORD *)v202 = v200;
        *(float *)(v202 + 4) = v201;
        v204 = *(_DWORD *)v183;
        v205 = -*(float *)(v183 + 4);
        v206 = a3 + 4 * ((int)v199 + (int)v168);
        v207 = -*(float *)(v206 + 4);
        *(_DWORD *)v183 = *(_DWORD *)v206;
        *(float *)(v183 + 4) = v207;
        v183 += 16;
        *(_DWORD *)v206 = v204;
        *(float *)(v206 + 4) = v205;
        v208 = *(_DWORD *)(a3 + 4 * (v180 + (int)v174));
        v209 = a3 + 4 * ((int)v191 + 2 + (int)v168);
        v210 = -*(float *)(a3 + (v178 >> 30));
        v211 = -*(float *)(v209 + 4);
        *(_DWORD *)(a3 + 4 * (v180 + (int)v174)) = *(_DWORD *)v209;
        *(float *)(a3 + (v178 >> 30)) = v211;
        *(_DWORD *)v209 = v208;
        *(float *)(v209 + 4) = v210;
        LODWORD(v209) = v179 + v174 + 2;
        v212 = *(_DWORD *)(a3 + 4 * (int)v209);
        LODWORD(v206) = v179 + v174 + 3;
        v213 = (int)v191 + (int)v168;
        v214 = -*(float *)(a3 + 4 * (int)v206);
        v215 = a3 + 4 * v213;
        v216 = -*(float *)(v215 + 4);
        *(_DWORD *)(a3 + 4 * (int)v209) = *(_DWORD *)v215;
        *(float *)(a3 + 4 * (int)v206) = v216;
        LODWORD(v209) = v175 + v174 + 2;
        *(_DWORD *)v215 = v212;
        *(float *)(v215 + 4) = v214;
        v217 = *(_DWORD *)(a3 + 4 * (int)v209);
        LODWORD(v206) = v175 + v174 + 3;
        v218 = *(float *)(a3 + 4 * (int)v206);
        v219 = a3 + 4 * (v213 - v167);
        v220 = *(float *)(v219 + 4);
        *(_DWORD *)(a3 + 4 * (int)v209) = *(_DWORD *)v219;
        v174 += 4;
        v178 += 0x400000000;
        v181 += 4;
        *(float *)(a3 + 4 * (int)v206) = -v220;
        *(_DWORD *)v219 = v217;
        *(float *)(v219 + 4) = -v218;
        v182 += 4;
        v185 += 4;
        --v184;
      }
      while (v184);
    }
    else
    {
      LODWORD(v176) = 0;
    }
    v221 = *(int *)(a2 + 4 * v173) + (uint64_t)(int)v176;
    v222 = v221 + 2;
    v223 = v221 + v168;
    v224 = a3 + 4 * v221;
    *(float *)(v224 + 4) = -*(float *)(v224 + 4);
    v225 = *(_DWORD *)(a3 + 4 * (v221 + 2));
    v226 = -*(float *)(v224 + 12);
    v227 = a3 + 4 * ((int)v221 + (int)v168);
    v228 = -*(float *)(v227 + 4);
    *(_DWORD *)(a3 + 4 * v222) = *(_DWORD *)v227;
    *(float *)(v224 + 12) = v228;
    *(_DWORD *)v227 = v225;
    *(float *)(v227 + 4) = v226;
    *(float *)(v227 + 12) = -*(float *)(v227 + 12);
    v229 = v167 + (int)v222;
    LODWORD(v222) = v223 + v167;
    v230 = (float *)(a3 + 4 * v229);
    *(v230 - 1) = -*(v230 - 1);
    v231 = *v230;
    v232 = -v230[1];
    v233 = (float *)(a3 + 4 * (int)v222);
    v234 = -v233[1];
    *v230 = *v233;
    v230[1] = v234;
    *v233 = v231;
    v233[1] = v232;
    result = -v233[3];
    v233[3] = result;
    ++v165;
  }
  while (v165 != v166);
  return result;
}

double bitrv216neg(uint64_t a1)
{
  double result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;

  result = *(double *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)&v6 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)&v7 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)&v8 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)&v9 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)&v11 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)&v10 = *(_QWORD *)(a1 + 120);
  v12 = *(_QWORD *)(a1 + 64);
  *((_QWORD *)&v10 + 1) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)&v13 = *(_QWORD *)(a1 + 104);
  *((_QWORD *)&v8 + 1) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 8) = v10;
  *(_OWORD *)(a1 + 24) = v8;
  *((_QWORD *)&v13 + 1) = v4;
  *((double *)&v6 + 1) = result;
  *(_OWORD *)(a1 + 40) = v13;
  *((_QWORD *)&v11 + 1) = v5;
  *(_OWORD *)(a1 + 72) = v11;
  *((_QWORD *)&v7 + 1) = v2;
  *(_OWORD *)(a1 + 88) = v7;
  *((_QWORD *)&v9 + 1) = v3;
  *(_OWORD *)(a1 + 104) = v9;
  *(_OWORD *)(a1 + 56) = v6;
  *(_QWORD *)(a1 + 120) = v12;
  return result;
}

double bitrv208neg(uint64_t a1)
{
  double result;
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  uint64_t v5;
  __int128 v6;

  result = *(double *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)&v4 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)&v3 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 32);
  *((_QWORD *)&v3 + 1) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)&v6 = *(_QWORD *)(a1 + 40);
  *((double *)&v6 + 1) = result;
  *(_OWORD *)(a1 + 8) = v3;
  *((_QWORD *)&v4 + 1) = v2;
  *(_OWORD *)(a1 + 40) = v4;
  *(_OWORD *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 56) = v5;
  return result;
}

float cftb040(float *a1)
{
  float v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float result;

  v1 = a1[1];
  v2 = a1[4];
  v3 = a1[5];
  v4 = *a1 + v2;
  v5 = v1 + v3;
  v6 = *a1 - v2;
  v7 = v1 - v3;
  v8 = a1[2];
  v9 = a1[3];
  v10 = a1[6];
  v11 = a1[7];
  v12 = v8 + v10;
  v13 = v9 + v11;
  v14 = v8 - v10;
  v15 = v9 - v11;
  *a1 = v4 + v12;
  a1[1] = v5 + v13;
  a1[2] = v6 + v15;
  a1[3] = v7 - v14;
  a1[4] = v4 - v12;
  a1[5] = v5 - v13;
  result = v6 - v15;
  a1[6] = result;
  a1[7] = v7 + v14;
  return result;
}

float cftmdl1(int a1, float *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  int v19;
  float v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float *v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float *v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float *v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  uint64_t v79;
  float v80;
  float v81;
  float v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  float v87;
  float *v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float result;

  v3 = (uint64_t)a1 >> 3;
  v4 = 2 * (a1 >> 3);
  v5 = 4 * (a1 >> 3);
  v6 = a2[v5];
  v7 = a2[1];
  v8 = *a2 + v6;
  v9 = &a2[4 * (a1 >> 3)];
  v10 = v9[1];
  v11 = v7 + v10;
  v12 = *a2 - v6;
  v13 = v7 - v10;
  v14 = 2 * (a1 >> 3);
  v15 = a2[v14];
  v16 = a2[6 * (a1 >> 3)];
  v17 = v15 + v16;
  v18 = a2[(int)(v4 | 1)];
  v19 = (6 * (a1 >> 3)) | 1;
  v20 = a2[v19];
  v21 = v15 - v16;
  *a2 = v8 + v17;
  a2[1] = v11 + (float)(v18 + v20);
  a2[v14] = v8 - v17;
  a2[(int)(v4 | 1)] = v11 - (float)(v18 + v20);
  a2[v5] = v12 - (float)(v18 - v20);
  a2[6 * (a1 >> 3)] = v12 + (float)(v18 - v20);
  v9[1] = v13 + v21;
  a2[v19] = v13 - v21;
  v22 = *(float *)(a3 + 4);
  if (a1 >= 24)
  {
    v23 = 24 * (_DWORD)v3;
    v24 = v23 + 12;
    v25 = 4 * v5;
    v26 = v25 + 12;
    v27 = v25 - 4;
    v28 = v23 - 4;
    v29 = (float *)(a3 + 28);
    v30 = 8 * (a1 >> 3) - 8;
    v31 = 16 * (a1 >> 3) - 8;
    v32 = 24 * (a1 >> 3) - 8;
    v33 = 32 * (a1 >> 3) - 8;
    v34 = 4 * v4 + 8;
    v35 = 8 * v4 + 8;
    v36 = 12 * v4 + 8;
    v37 = 2;
    v38 = 3;
    v39 = (v4 << 34) - 0x200000000;
    do
    {
      v40 = *(v29 - 3);
      v41 = *(v29 - 2);
      v43 = *(v29 - 1);
      v42 = *v29;
      v44 = &a2[v38];
      v45 = a2[v38 - 1];
      v46 = a2[v38];
      v47 = *(float *)((char *)a2 + v35);
      v48 = *(float *)((char *)a2 + v26);
      v49 = v45 + v47;
      v50 = v46 + v48;
      v51 = v45 - v47;
      v52 = (float *)((char *)a2 + v34);
      v53 = *(float *)((char *)a2 + v36);
      v54 = v46 - v48;
      v55 = *(float *)((char *)a2 + v34);
      v56 = *(float *)((char *)a2 + v34 + 4);
      v57 = v55 + v53;
      v58 = *(float *)((char *)a2 + v24);
      v59 = v55 - v53;
      v60 = v56 - v58;
      *(v44 - 1) = v49 + v57;
      *v44 = v50 + (float)(v56 + v58);
      v61 = v50 - (float)(v56 + v58);
      v62 = v51 - (float)(v56 - v58);
      *v52 = v49 - v57;
      v52[1] = v61;
      v63 = (float)(v41 * v62) + (float)(v40 * (float)(v54 + v59));
      *(float *)((char *)a2 + v35) = (float)(v40 * v62) - (float)(v41 * (float)(v54 + v59));
      v64 = v51 + v60;
      v65 = v54 - v59;
      *(float *)((char *)a2 + v26) = v63;
      *(float *)((char *)a2 + v36) = (float)(v42 * v65) + (float)(v43 * v64);
      *(float *)((char *)a2 + v24) = (float)(v43 * v65) - (float)(v42 * v64);
      v66 = (float *)((char *)a2 + v30);
      v67 = *(float *)((char *)a2 + v32);
      v68 = *(float *)((char *)a2 + v30);
      v69 = *(float *)((char *)a2 + v30 + 4);
      v70 = v68 + v67;
      v71 = *(float *)((char *)a2 + v28);
      v72 = *(float *)((char *)a2 + v31);
      v73 = v69 + v71;
      v74 = v68 - v67;
      v75 = *(float *)((char *)a2 + v33);
      v76 = *(float *)((char *)a2 + v27);
      v77 = v69 - v71;
      v78 = v72 + v75;
      v79 = (v39 >> 30) | 4;
      v80 = *(float *)((char *)a2 + v79);
      v81 = v72 - v75;
      *v66 = v70 + v78;
      v66[1] = v73 + (float)(v76 + v80);
      *(float *)((char *)a2 + v31) = v70 - v78;
      *(float *)((char *)a2 + v27) = v73 - (float)(v76 + v80);
      *(float *)((char *)a2 + v32) = (float)(v41 * (float)(v74 - (float)(v76 - v80)))
                                   - (float)(v40 * (float)(v77 + v81));
      v82 = (float)(v40 * (float)(v74 - (float)(v76 - v80))) + (float)(v41 * (float)(v77 + v81));
      v83 = v74 + (float)(v76 - v80);
      *(float *)((char *)a2 + v28) = v82;
      v37 += 2;
      *(float *)((char *)a2 + v33) = (float)(v43 * (float)(v77 - v81)) + (float)(v42 * v83);
      v24 += 8;
      v26 += 8;
      v27 -= 8;
      *(float *)((char *)a2 + v79) = (float)(v42 * (float)(v77 - v81)) - (float)(v43 * v83);
      v28 -= 8;
      v29 += 4;
      v30 -= 8;
      v31 -= 8;
      v39 -= 0x200000000;
      v32 -= 8;
      v33 -= 8;
      v34 += 8;
      v35 += 8;
      v36 += 8;
      v38 += 2;
    }
    while (v37 < v3);
  }
  v84 = 3 * v3;
  v85 = 5 * v3;
  v86 = 7 * v3;
  v87 = a2[5 * v3];
  v88 = &a2[v3];
  v89 = v88[1];
  v90 = a2[(int)v85 + 1];
  v91 = *v88 + v87;
  v92 = v89 + v90;
  v93 = *v88 - v87;
  v94 = v89 - v90;
  v95 = a2[v84];
  v96 = a2[v86];
  v97 = v95 + v96;
  v98 = a2[(int)v84 + 1];
  v99 = a2[(int)v86 + 1];
  v100 = v95 - v96;
  *v88 = v91 + v97;
  v88[1] = v92 + (float)(v98 + v99);
  a2[v84] = v91 - v97;
  a2[(int)v84 + 1] = v92 - (float)(v98 + v99);
  a2[v85] = v22 * (float)((float)(v93 - (float)(v98 - v99)) - (float)(v94 + v100));
  a2[(int)v85 + 1] = v22 * (float)((float)(v94 + v100) + (float)(v93 - (float)(v98 - v99)));
  v101 = v93 + (float)(v98 - v99);
  v102 = v94 - v100;
  a2[v86] = -(float)(v22 * (float)(v102 + v101));
  result = -(float)(v22 * (float)(v102 - v101));
  a2[(int)v86 + 1] = result;
  return result;
}

uint64_t cfttree(int a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  unsigned int v10;
  float *v11;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;

  v10 = a1;
  if ((a3 & 3) != 0)
  {
    v11 = (float *)(a4 + 4 * (a2 - a1));
    if ((a3 & 1) == 0)
    {
      cftmdl2(a1, v11, a6 + 4 * (a5 - a1));
      return 0;
    }
    cftmdl1(a1, v11, a6 + 4 * (a5 - (a1 >> 1)));
    return 1;
  }
  do
  {
    v12 = a3;
    v10 *= 4;
    a3 >>= 2;
  }
  while ((v12 & 0xC) == 0);
  if (((v12 >> 2) & 1) == 0)
  {
    if ((int)v10 >= 129)
    {
      do
      {
        cftmdl2(v10, (float *)(a4 + 4 * (int)(a2 - v10)), a6 + 4 * (int)(a5 - v10));
        v13 = v10 > 0x203;
        v10 >>= 2;
      }
      while (v13);
    }
    return 0;
  }
  if ((int)v10 < 129)
    return 1;
  v14 = (v12 >> 2) & 1;
  do
  {
    cftmdl1(v10, (float *)(a4 + 4 * (int)(a2 - v10)), a6 + 4 * (int)(a5 - (v10 >> 1)));
    v13 = v10 > 0x203;
    v10 >>= 2;
  }
  while (v13);
  return v14;
}

float cftmdl2(int a1, float *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float *v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float *v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float *v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float *v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  uint64_t v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  float *v114;
  float *v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float *v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float result;

  v3 = a1 >> 3;
  v4 = (uint64_t)a1 >> 3;
  v5 = 2 * (a1 >> 3);
  v6 = *(float *)(a3 + 4);
  v7 = &a2[4 * (a1 >> 3)];
  v8 = a2[1];
  v9 = v7[1];
  v10 = *a2 - v9;
  v11 = v8 + *v7;
  v12 = *a2 + v9;
  v13 = v8 - *v7;
  v14 = 2 * (a1 >> 3);
  v15 = a2[v14];
  v16 = &a2[6 * (a1 >> 3)];
  v17 = v16[1];
  v18 = v15 - v17;
  v19 = (int)(v5 | 1);
  v20 = a2[v19];
  v21 = v20 + *v16;
  v22 = v15 + v17;
  v23 = v20 - *v16;
  v24 = v6 * (float)(v18 - v21);
  v25 = v6 * (float)(v18 + v21);
  *a2 = v10 + v24;
  a2[1] = v11 + v25;
  a2[v14] = v10 - v24;
  a2[v19] = v11 - v25;
  v26 = v6 * (float)(v22 - v23);
  v27 = v6 * (float)(v22 + v23);
  *v7 = v12 - v27;
  v7[1] = v13 + v26;
  *v16 = v12 + v27;
  v16[1] = v13 - v26;
  if (a1 >= 24)
  {
    v28 = 4 * v3;
    v29 = a3 + 16 * v3;
    v30 = 24 * v3 + 8;
    v31 = (float *)(a3 + 28);
    v32 = 8 * v5 + 8;
    v33 = 4 * v5 + 12;
    v34 = 16 * v5 - 8;
    v35 = (float *)(v29 - 8);
    v36 = 24 * (_DWORD)v4;
    v37 = v36 + 12;
    v38 = 4 * v28;
    v39 = 4 * v28 + 12;
    v40 = v38 - 4;
    v41 = v36 - 4;
    v42 = 4 * v5 - 8;
    v43 = 8 * v5 - 8;
    v44 = 12 * v5 - 8;
    v45 = 2;
    v46 = 2;
    v47 = (v5 << 34) - 0x200000000;
    do
    {
      v48 = *(v31 - 3);
      v49 = *(v31 - 2);
      v51 = *(v31 - 1);
      v50 = *v31;
      v52 = *(v35 - 2);
      v53 = *(v35 - 1);
      v54 = *v35;
      v55 = v35[1];
      v56 = &a2[v46];
      v57 = *(float *)((char *)a2 + v39);
      v58 = *(float *)((char *)a2 + v32);
      v59 = a2[v46];
      v60 = a2[v46 + 1];
      v61 = v59 - v57;
      v62 = v60 + v58;
      v63 = v59 + v57;
      v64 = (float *)((char *)a2 + v33);
      v65 = *(float *)((char *)a2 + v33 - 4);
      v66 = *(float *)((char *)a2 + v33);
      v67 = v60 - v58;
      v68 = *(float *)((char *)a2 + v37);
      v69 = *(float *)((char *)a2 + v30);
      v70 = v65 - v68;
      v71 = v66 + v69;
      v72 = v65 + v68;
      v73 = v66 - v69;
      v74 = v49 * v61;
      v75 = (float)(v48 * v61) - (float)(v49 * v62);
      v76 = v74 + (float)(v48 * v62);
      v77 = (float)(v53 * v70) - (float)(v52 * v71);
      v78 = (float)(v52 * v70) + (float)(v53 * v71);
      *v56 = v75 + v77;
      v56[1] = v76 + v78;
      *(v64 - 1) = v75 - v77;
      *v64 = v76 - v78;
      v79 = (float)(v50 * v67) + (float)(v51 * v63);
      v80 = (float)(v51 * v67) - (float)(v50 * v63);
      v81 = (float)(v54 * v73) + (float)(v55 * v72);
      v82 = (float)(v55 * v73) - (float)(v54 * v72);
      *(float *)((char *)a2 + v32) = v79 + v81;
      *(float *)((char *)a2 + v39) = v80 + v82;
      *(float *)((char *)a2 + v30) = v79 - v81;
      *(float *)((char *)a2 + v37) = v80 - v82;
      v83 = (float *)((char *)a2 + v42);
      v84 = *(float *)((char *)a2 + v41);
      v85 = *(float *)((char *)a2 + v42);
      v86 = *(float *)((char *)a2 + v42 + 4);
      v87 = *(float *)((char *)a2 + v44);
      v88 = *(float *)((char *)a2 + v43);
      v89 = v85 - v84;
      v90 = (v47 >> 30) | 4;
      v91 = *(float *)((char *)a2 + v90);
      v92 = v86 + v87;
      v93 = v85 + v84;
      v94 = *(float *)((char *)a2 + v40);
      v95 = *(float *)((char *)a2 + v34);
      v96 = v86 - v87;
      v97 = v88 - v91;
      v98 = v94 + v95;
      v99 = v88 + v91;
      v100 = v94 - v95;
      v101 = (float)(v52 * v89) - (float)(v53 * v92);
      v102 = (float)(v53 * v89) + (float)(v52 * v92);
      v103 = (float)(v49 * v97) - (float)(v48 * v98);
      v104 = (float)(v48 * v97) + (float)(v49 * v98);
      *v83 = v101 + v103;
      v83[1] = v102 + v104;
      v105 = (float)(v55 * v96) + (float)(v54 * v93);
      v106 = (float)(v54 * v96) - (float)(v55 * v93);
      *(float *)((char *)a2 + v43) = v101 - v103;
      v107 = (float)(v51 * v100) + (float)(v50 * v99);
      *(float *)((char *)a2 + v40) = v102 - v104;
      *(float *)((char *)a2 + v44) = v105 + v107;
      v108 = (float)(v50 * v100) - (float)(v51 * v99);
      *(float *)((char *)a2 + v41) = v106 + v108;
      v45 += 2;
      v46 += 2;
      *(float *)((char *)a2 + v34) = v105 - v107;
      v30 += 8;
      v31 += 4;
      v32 += 8;
      *(float *)((char *)a2 + v90) = v106 - v108;
      v33 += 8;
      v34 -= 8;
      v35 -= 4;
      v37 += 8;
      v39 += 8;
      v40 -= 8;
      v41 -= 8;
      v47 -= 0x200000000;
      v42 -= 8;
      v43 -= 8;
      v44 -= 8;
    }
    while (v45 < v4);
  }
  v109 = *(float *)(a3 + 4 * v5);
  v110 = *(float *)(a3 + 4 * v19);
  v111 = 3 * v4;
  v112 = 5 * v4;
  v113 = 7 * v4;
  v114 = &a2[v4];
  v115 = &a2[v112];
  v116 = v115[1];
  v117 = v114[1];
  v118 = *v114 - v116;
  v119 = v117 + *v115;
  v120 = *v114 + v116;
  v121 = a2[v111];
  v122 = v117 - *v115;
  v123 = &a2[v113];
  v124 = v123[1];
  v125 = a2[(int)v111 + 1];
  v126 = v121 - v124;
  v127 = a2[(int)v113];
  v128 = v125 + v127;
  v129 = v121 + v124;
  v130 = v125 - v127;
  v131 = (float)(v109 * v118) - (float)(v110 * v119);
  v132 = (float)(v110 * v118) + (float)(v109 * v119);
  v133 = (float)(v110 * v126) - (float)(v109 * v128);
  v134 = (float)(v109 * v126) + (float)(v110 * v128);
  *v114 = v131 + v133;
  v114[1] = v132 + v134;
  a2[v111] = v131 - v133;
  a2[(int)v111 + 1] = v132 - v134;
  v135 = (float)(v110 * v120) - (float)(v109 * v122);
  v136 = (float)(v109 * v120) + (float)(v110 * v122);
  v137 = (float)(v109 * v129) - (float)(v110 * v130);
  v138 = (float)(v110 * v129) + (float)(v109 * v130);
  *v115 = v135 - v137;
  v115[1] = v136 - v138;
  a2[(int)v113] = v135 + v137;
  result = v136 + v138;
  v123[1] = result;
  return result;
}

float cftf162(float *a1, float *a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float result;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;

  v2 = a1[2];
  v3 = a1[3];
  v5 = a1[18];
  v4 = a1[19];
  v6 = a2[4];
  v7 = a2[5];
  v114 = (float)(v7 * (float)(v2 - v4)) + (float)(v6 * (float)(v3 + v5));
  v116 = (float)(v6 * (float)(v2 - v4)) - (float)(v7 * (float)(v3 + v5));
  v8 = a1[10];
  v9 = a1[11];
  v11 = a1[26];
  v10 = a1[27];
  v13 = a2[6];
  v12 = a2[7];
  v111 = (float)(v13 * (float)(v8 - v10)) - (float)(v12 * (float)(v9 + v11));
  v113 = (float)-(float)(v13 * (float)(v9 + v11)) - (float)(v12 * (float)(v8 - v10));
  v14 = v2 + v4;
  v15 = v3 - v5;
  v109 = (float)(v13 * v15) - (float)(v12 * v14);
  v110 = (float)(v12 * v15) + (float)(v13 * v14);
  v16 = (float)(v6 * (float)(v9 - v11)) - (float)(v7 * (float)(v8 + v10));
  v17 = a1[4];
  v18 = a1[5];
  v20 = a1[20];
  v19 = a1[21];
  v21 = a2[8];
  v22 = a2[9];
  v23 = (float)(v21 * (float)(v17 - v19)) - (float)(v22 * (float)(v18 + v20));
  v107 = (float)(v22 * (float)(v17 - v19)) + (float)(v21 * (float)(v18 + v20));
  v108 = (float)(v7 * (float)(v9 - v11)) + (float)(v6 * (float)(v8 + v10));
  v24 = a1[12];
  v25 = a1[13];
  v27 = a1[28];
  v26 = a1[29];
  v28 = (float)(v22 * (float)(v24 - v26)) - (float)(v21 * (float)(v25 + v27));
  v29 = (float)(v21 * (float)(v24 - v26)) + (float)(v22 * (float)(v25 + v27));
  v30 = v17 + v19;
  v31 = v18 - v20;
  v106 = (float)(v22 * v30) - (float)(v21 * v31);
  v104 = (float)(v21 * v30) + (float)(v22 * v31);
  v32 = (float)(v21 * (float)(v24 + v26)) - (float)(v22 * (float)(v25 - v27));
  v33 = (float)(v22 * (float)(v24 + v26)) + (float)(v21 * (float)(v25 - v27));
  v34 = a1[6];
  v35 = a1[7];
  v37 = a1[22];
  v36 = a1[23];
  v38 = v34 - v36;
  v39 = a1[14];
  v40 = a1[15];
  v42 = a1[30];
  v41 = a1[31];
  v43 = (float)(v7 * (float)(v39 - v41)) - (float)(v6 * (float)(v40 + v42));
  v44 = (float)(v6 * (float)(v39 - v41)) + (float)(v7 * (float)(v40 + v42));
  v45 = v34 + v36;
  v46 = (float)(v6 * (float)(v35 - v37)) + (float)(v7 * v45);
  v47 = a2[1];
  v48 = (float)(v7 * (float)(v35 - v37)) - (float)(v6 * v45);
  v49 = a1[8];
  v50 = a1[9];
  v51 = v35 + v37;
  v52 = (float)(v12 * v51) + (float)(v13 * v38);
  v53 = (float)(v13 * v51) - (float)(v12 * v38);
  v54 = v39 + v41;
  v56 = a1[24];
  v55 = a1[25];
  v57 = v40 - v42;
  v58 = (float)-(float)(v13 * v57) - (float)(v12 * v54);
  v59 = (float)(v13 * v54) - (float)(v12 * v57);
  v60 = v47 * (float)((float)(v49 - v55) - (float)(v50 + v56));
  v61 = a1[1];
  v62 = a1[16];
  v63 = a1[17];
  v64 = *a1 - v63;
  v65 = v64 + v60;
  v66 = v64 - v60;
  v67 = v47 * (float)((float)(v49 - v55) + (float)(v50 + v56));
  v68 = (float)(v61 + v62) + v67;
  v69 = (float)(v61 + v62) - v67;
  v70 = *a1 + v63;
  v71 = v61 - v62;
  v72 = v47 * (float)((float)(v49 + v55) + (float)(v50 - v56));
  v103 = v70 - v72;
  v73 = v70 + v72;
  v74 = v47 * (float)((float)(v49 + v55) - (float)(v50 - v56));
  v75 = v71 + v74;
  v105 = v71 - v74;
  v76 = v114 + v111;
  v77 = v114 - v111;
  v78 = v109 - v16;
  v115 = v109 + v16;
  v79 = v23 + v28;
  v80 = v23 - v28;
  v81 = v107 + v29;
  v82 = v107 - v29;
  v83 = v32;
  v84 = v106 - v32;
  v85 = v104 - v33;
  v112 = v104 + v33;
  v86 = v52 + v43;
  v87 = v52 - v43;
  v88 = v53 + v44;
  v89 = v53 - v44;
  v90 = v46 + v58;
  v91 = v46 - v58;
  v92 = v48 + v59;
  v93 = v48 - v59;
  *a1 = (float)(v65 + v79) + (float)((float)(v116 + v113) + v86);
  a1[1] = (float)(v68 + v81) + (float)(v76 + v88);
  a1[2] = (float)(v65 + v79) - (float)((float)(v116 + v113) + v86);
  a1[3] = (float)(v68 + v81) - (float)(v76 + v88);
  a1[4] = (float)(v65 - v79) - (float)(v76 - v88);
  a1[5] = (float)(v68 - v81) + (float)((float)(v116 + v113) - v86);
  a1[6] = (float)(v65 - v79) + (float)(v76 - v88);
  a1[7] = (float)(v68 - v81) - (float)((float)(v116 + v113) - v86);
  v94 = v47 * (float)((float)((float)(v116 - v113) - v89) - (float)(v77 + v87));
  v95 = v47 * (float)((float)((float)(v116 - v113) - v89) + (float)(v77 + v87));
  a1[8] = (float)(v66 - v82) + v94;
  a1[9] = (float)(v69 + v80) + v95;
  a1[10] = (float)(v66 - v82) - v94;
  a1[11] = (float)(v69 + v80) - v95;
  v96 = v47 * (float)((float)((float)(v116 - v113) + v89) - (float)(v77 - v87));
  v97 = v47 * (float)((float)((float)(v116 - v113) + v89) + (float)(v77 - v87));
  a1[12] = (float)(v66 + v82) - v97;
  a1[13] = (float)(v69 - v80) + v96;
  a1[14] = (float)(v66 + v82) + v97;
  a1[15] = (float)(v69 - v80) - v96;
  a1[16] = (float)(v103 + v84) + (float)((float)(v110 - v108) - v90);
  a1[17] = (float)(v75 + v85) + (float)(v78 - v92);
  a1[18] = (float)(v103 + v84) - (float)((float)(v110 - v108) - v90);
  a1[19] = (float)(v75 + v85) - (float)(v78 - v92);
  a1[20] = (float)(v103 - v84) - (float)(v78 + v92);
  a1[21] = (float)(v75 - v85) + (float)((float)(v110 - v108) + v90);
  a1[22] = (float)(v103 - v84) + (float)(v78 + v92);
  a1[23] = (float)(v75 - v85) - (float)((float)(v110 - v108) + v90);
  v98 = v47 * (float)((float)((float)(v110 + v108) + v93) - (float)(v115 - v91));
  v99 = v47 * (float)((float)((float)(v110 + v108) + v93) + (float)(v115 - v91));
  a1[24] = (float)(v73 - v112) + v98;
  a1[25] = (float)(v105 + (float)(v106 + v83)) + v99;
  a1[26] = (float)(v73 - v112) - v98;
  a1[27] = (float)(v105 + (float)(v106 + v83)) - v99;
  v100 = v47 * (float)((float)((float)(v110 + v108) - v93) - (float)(v115 + v91));
  v101 = v47 * (float)((float)((float)(v110 + v108) - v93) + (float)(v115 + v91));
  a1[28] = (float)(v73 + v112) - v101;
  a1[29] = (float)(v105 - (float)(v106 + v83)) + v100;
  result = (float)(v73 + v112) + v101;
  a1[30] = result;
  a1[31] = (float)(v105 - (float)(v106 + v83)) - v100;
  return result;
}

float cftf082(float *a1, float *a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float result;

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = a1[1];
  v7 = a1[8];
  v6 = a1[9];
  v8 = *a1 - v6;
  v9 = v5 + v7;
  v10 = *a1 + v6;
  v11 = v5 - v7;
  v12 = a1[4];
  v13 = a1[5];
  v15 = a1[12];
  v14 = a1[13];
  v16 = v2 * (float)((float)(v12 - v14) - (float)(v13 + v15));
  v17 = v2 * (float)((float)(v12 - v14) + (float)(v13 + v15));
  v18 = v12 + v14;
  v19 = v13 - v15;
  v20 = v2 * (float)(v18 - v19);
  v21 = v2 * (float)(v18 + v19);
  v22 = a1[2];
  v23 = a1[3];
  v25 = a1[10];
  v24 = a1[11];
  v26 = (float)(v3 * (float)(v22 - v24)) - (float)(v4 * (float)(v23 + v25));
  v27 = (float)(v4 * (float)(v22 - v24)) + (float)(v3 * (float)(v23 + v25));
  v28 = v22 + v24;
  v29 = v23 - v25;
  v30 = (float)(v4 * v28) - (float)(v3 * v29);
  v31 = (float)(v3 * v28) + (float)(v4 * v29);
  v32 = a1[6];
  v33 = a1[7];
  v35 = a1[14];
  v34 = a1[15];
  v36 = (float)(v4 * (float)(v32 - v34)) - (float)(v3 * (float)(v33 + v35));
  v37 = (float)(v3 * (float)(v32 - v34)) + (float)(v4 * (float)(v33 + v35));
  v38 = v32 + v34;
  v39 = v33 - v35;
  v40 = (float)(v3 * v38) - (float)(v4 * v39);
  v41 = (float)(v4 * v38) + (float)(v3 * v39);
  *a1 = (float)(v8 + v16) + (float)(v26 + v36);
  a1[1] = (float)(v9 + v17) + (float)(v27 + v37);
  a1[2] = (float)(v8 + v16) - (float)(v26 + v36);
  a1[3] = (float)(v9 + v17) - (float)(v27 + v37);
  a1[4] = (float)(v8 - v16) - (float)(v27 - v37);
  a1[5] = (float)(v9 - v17) + (float)(v26 - v36);
  a1[6] = (float)(v8 - v16) + (float)(v27 - v37);
  a1[7] = (float)(v9 - v17) - (float)(v26 - v36);
  a1[8] = (float)(v10 - v21) + (float)(v30 - v40);
  a1[9] = (float)(v11 + v20) + (float)(v31 - v41);
  a1[10] = (float)(v10 - v21) - (float)(v30 - v40);
  a1[11] = (float)(v11 + v20) - (float)(v31 - v41);
  v42 = v10 + v21;
  v43 = v11 - v20;
  a1[12] = v42 - (float)(v31 + v41);
  a1[13] = v43 + (float)(v30 + v40);
  result = v42 + (float)(v31 + v41);
  a1[14] = result;
  a1[15] = v43 - (float)(v30 + v40);
  return result;
}

uint64_t axpy(uint64_t result, float *a2, int a3, float *a4, int a5, float a6)
{
  uint64_t v6;
  uint64_t v7;

  if (((a4 | a2) & 0x1F) != 0)
  {
    if ((int)result >= 1)
    {
      v6 = result;
      do
      {
        *a4 = *a4 + (float)(a6 * *a2);
        a4 += a5;
        a2 += a3;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)result >= 1)
  {
    v7 = result;
    do
    {
      *a4 = *a4 + (float)(a6 * *a2);
      a4 += a5;
      a2 += a3;
      --v7;
    }
    while (v7);
  }
  return result;
}

float dot(float *a1, signed int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  float *v6;
  float result;
  float *v8;
  float v9;
  float v10;
  float v11;
  unsigned int v12;
  float *v13;
  float *v14;
  unint64_t v15;
  float v16;
  float v17;
  float v18;

  v5 = (~a5 + a2);
  if ((int)v5 < 1)
  {
    v12 = 0;
    result = 0.0;
  }
  else
  {
    v6 = (float *)(a3 + 4 * a5);
    result = 0.0;
    v8 = a1;
    do
    {
      v9 = *v8++;
      v10 = v9;
      v11 = *v6++;
      result = result + (float)(v10 * v11);
      --v5;
    }
    while (v5);
    v12 = a2 - a5 - 1;
  }
  if ((int)v12 < a2)
  {
    v13 = (float *)(a4 + 4 * (a5 - a2 + 1 + (unint64_t)v12));
    v14 = &a1[v12];
    v15 = a2 - (unint64_t)v12;
    do
    {
      v16 = *v14++;
      v17 = v16;
      v18 = *v13++;
      result = result + (float)(v17 * v18);
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t src_generate_fir_coeffs(uint64_t *a1, unsigned int a2, float **a3, float a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float v21;
  float v22;
  float v23;
  unsigned int v24;
  int i;
  int v26;
  float v27;
  int v28;
  int v29;
  float v30;
  unsigned int v31;
  int j;
  int v33;
  float v34;
  int v35;
  float *v36;
  float *v37;
  float v38;
  uint64_t v40;

  v8 = a2;
  v9 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2, 4);
  if (!v9)
    goto LABEL_26;
  v13 = (float *)v9;
  if (a2)
  {
    v14 = 0;
    v15 = a4 + a4;
    do
    {
      v16 = v15 * (float)((float)v14 - (float)((float)(int)(a2 - 1) * 0.5));
      v17 = 1.0;
      if (v16 != 0.0)
        v17 = sinf(v16 * 3.1416) / (float)(v16 * 3.1416);
      v13[v14++] = v15 * v17;
    }
    while (v8 != v14);
  }
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v8, 4);
  if (v18)
  {
    if (a2)
    {
      v19 = 0;
      do
      {
        v20 = 0;
        v21 = (float)((float)((float)((float)v19 * 2.0) + 2.0) - (float)((float)a2 + 1.0))
            / (float)((float)a2 + 1.0);
        v22 = (float)(sqrtf(1.0 - (float)(v21 * v21)) * 3.2) * 0.5;
        v23 = 0.0;
        v24 = 1;
        for (i = 2; i != 11; ++i)
        {
          if (v24 >= 2)
          {
            v28 = 0;
            v26 = 1;
            v27 = v22;
            do
            {
              v27 = v22 * v27;
              v26 *= v28 + 2;
              ++v28;
            }
            while (v20 != v28);
          }
          else
          {
            v26 = 1;
            v27 = v22;
          }
          v23 = v23 + (float)((float)(v27 / (float)v26) * (float)(v27 / (float)v26));
          ++v24;
          ++v20;
        }
        v29 = 0;
        v30 = 0.0;
        v31 = 1;
        for (j = 2; j != 11; ++j)
        {
          if (v31 >= 2)
          {
            v35 = 0;
            v33 = 1;
            v34 = 1.6;
            do
            {
              v34 = v34 * 1.6;
              v33 *= v35 + 2;
              ++v35;
            }
            while (v29 != v35);
          }
          else
          {
            v33 = 1;
            v34 = 1.6;
          }
          v30 = v30 + (float)((float)(v34 / (float)v33) * (float)(v34 / (float)v33));
          ++v31;
          ++v29;
        }
        *(float *)(v18 + 4 * v19++) = (float)(v23 + 1.0) / (float)(v30 + 1.0);
      }
      while (v19 != v8);
      v36 = v13;
      v37 = (float *)v18;
      do
      {
        v38 = *v37++;
        *v36 = v38 * *v36;
        ++v36;
        --v8;
      }
      while (v8);
    }
    *a3 = v13;
    (*(void (**)(uint64_t, uint64_t))(a1[1] + 48))(a1[2], v18);
    return 0;
  }
  else
  {
LABEL_26:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v40);
    return 10;
  }
}

uint64_t src_generate_fir_filter(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;

  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
  if (!v12)
    goto LABEL_13;
  v16 = v12;
  v17 = a3 / a4;
  v18 = a3 % a4 ? (v17 + 1) : v17;
  v19 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], v18 * a4, 4);
  if (!v19)
    goto LABEL_13;
  v20 = 0;
  do
  {
    v21 = v20 + 1;
    if ((_DWORD)v18)
    {
      v22 = 0;
      v23 = v18;
      do
      {
        *(_DWORD *)(v19 + 4 * (v21 * v18 + ~(_DWORD)v22++)) = *(_DWORD *)(a2 + 4 * v20);
        v20 += a4;
        --v23;
      }
      while (v23);
    }
    v20 = v21;
  }
  while (v21 != a4);
  *(_QWORD *)v16 = v19;
  *(_DWORD *)(v16 + 8) = a4;
  *(_DWORD *)(v16 + 12) = v18;
  *(_DWORD *)(v16 + 16) = a4;
  *(_DWORD *)(v16 + 20) = a5;
  *(_QWORD *)(v16 + 24) = 0;
  *(_DWORD *)(v16 + 40) = v18 - 1;
  v24 = (*(uint64_t (**)(uint64_t))(a1[1] + 16))(a1[2]);
  *(_QWORD *)(v16 + 32) = v24;
  if (v24)
  {
    result = 0;
    *a6 = v16;
  }
  else
  {
LABEL_13:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v26);
    return 10;
  }
  return result;
}

uint64_t src_generate(uint64_t *a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t fir_filter;
  float *v9;
  float *v11;

  v11 = 0;
  *a4 = 0;
  fir_filter = src_generate_fir_coeffs(a1, 0x108u, &v11, 0.5 / (float)a2);
  v9 = v11;
  if (!(_DWORD)fir_filter)
  {
    fir_filter = src_generate_fir_filter(a1, (uint64_t)v11, 0x108u, a2, a3, a4);
    if (!v9)
      return fir_filter;
    goto LABEL_3;
  }
  if (v11)
LABEL_3:
    (*(void (**)(uint64_t, float *))(a1[1] + 48))(a1[2], v9);
  return fir_filter;
}

uint64_t src_filt(uint64_t *a1, int *a2, unsigned int a3, uint64_t a4)
{
  int v6;
  unsigned int v7;
  uint64_t v9;
  unsigned int v10;
  signed int v11;
  uint64_t v12;
  _DWORD *v13;
  unsigned int v14;
  _DWORD *v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t *v25;
  int v26;
  int v27;

  v7 = *((_DWORD *)a1 + 6);
  v6 = *((_DWORD *)a1 + 7);
  if (v6 >= (int)a3)
  {
    v9 = 0;
    v13 = (_DWORD *)a1[4];
  }
  else
  {
    LODWORD(v9) = 0;
    v10 = *((_DWORD *)a1 + 4);
    v11 = *((_DWORD *)a1 + 3);
    v26 = *((_DWORD *)a1 + 5) % v10;
    v27 = *((_DWORD *)a1 + 5);
    v12 = *a1;
    v25 = a1;
    v13 = (_DWORD *)a1[4];
    do
    {
      v14 = v9;
      v15 = v13;
      v16 = dot((float *)(v12 + 4 * v11 * v7), v11, (uint64_t)v13, (uint64_t)a2, v6);
      v13 = v15;
      v9 = v14 + 1;
      *(float *)(a4 + 4 * v14) = v16 * (float)v10;
      v6 += (v7 + v27) / v10;
      v7 = (v7 + v26) % v10;
    }
    while (v6 < (int)a3);
    a1 = v25;
  }
  *((_DWORD *)a1 + 6) = v7;
  *((_DWORD *)a1 + 7) = v6 - a3;
  v17 = *((unsigned int *)a1 + 10);
  if (v17 >= a3)
  {
    v18 = v17 - a3;
    if ((_DWORD)v17 != a3)
    {
      v19 = a3;
      v20 = v13;
      do
      {
        *v20++ = v13[v19++];
        --v18;
      }
      while (v18);
    }
    if (a3)
    {
      v21 = a3;
      v22 = v17 - a3;
      do
      {
        v23 = *a2++;
        v13[v22++] = v23;
        --v21;
      }
      while (v21);
    }
  }
  else
  {
    memcpy(v13, &a2[a3 - v17], 4 * v17);
  }
  return v9;
}

void gemm(uint64_t *a1, int a2, int a3, uint64_t a4, float *a5, char *a6, float32x4_t *a7, _DWORD *a8, uint64_t a9)
{
  int v14;
  unsigned int v15;

  if (!a8)
  {
    v14 = 1;
    v15 = a4;
LABEL_5:
    gemm_v2((uint64_t)a1, v14, a2, a3, a4, (uint64_t)a5, a4, (uint64_t)a6, v15, a7, a3);
    return;
  }
  if (*a8)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Block Sparse only support SSE or NEON \n", (uint64_t)a5, (uint64_t)a7, (uint64_t)a8, a9);
    return;
  }
  v14 = a8[2];
  if (v14)
    v15 = a4;
  else
    v15 = a3;
  if (!a8[4])
    goto LABEL_5;
  gemm_v5((uint64_t)a1, v14, a2, a3, a4, a5, a4, a6, v15, a7->f32, a3, (uint64_t)a8);
}

void gemm_ex(uint64_t *a1, int a2, int a3, int a4, float *a5, uint64_t a6, char *a7, uint64_t a8, float32x4_t *a9, int a10, _DWORD *a11)
{
  int v17;

  if (!a11)
  {
    v17 = 1;
LABEL_5:
    gemm_v2((uint64_t)a1, v17, a2, a3, a4, (uint64_t)a5, a6, (uint64_t)a7, a8, a9, a10);
    return;
  }
  if (*a11)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Block Sparse only support SSE or NEON\n", (uint64_t)a5, a6, a8, (uint64_t)a9);
    return;
  }
  v17 = a11[2];
  if (!a11[4])
    goto LABEL_5;
  gemm_v5((uint64_t)a1, v17, a2, a3, a4, a5, a6, a7, a8, a9->f32, a10, (uint64_t)a11);
}

void fast_tanh(float *a1, int a2, float *a3)
{
  float *v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  float v8;

  v4 = a1;
  if ((a1 & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      v5 = a2;
      do
      {
        v6 = 1.0;
        if (*v4 <= 9.0)
        {
          v6 = -1.0;
          if (*v4 >= -9.0)
            v6 = tanhf(*v4);
        }
        *a3++ = v6;
        ++v4;
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    v7 = a2;
    do
    {
      v8 = 1.0;
      if (*v4 <= 9.0)
      {
        v8 = -1.0;
        if (*v4 >= -9.0)
          v8 = tanhf(*v4);
      }
      *a3++ = v8;
      ++v4;
      --v7;
    }
    while (v7);
  }
}

void gelu_array_f32(unsigned int a1, float *a2)
{
  float *v2;
  uint64_t v3;
  float v4;
  float v5;
  uint64_t v6;
  float v7;
  float v8;

  v2 = a2;
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      v3 = a1;
      do
      {
        v4 = *v2;
        v5 = (float)(*v2 * (float)(*v2 * (float)(*v2 * 0.035677))) + (float)(*v2 * 0.79789);
        *v2++ = v4 * (float)(1.0 - (float)(1.0 / (float)(expf(v5 + v5) + 1.0)));
        --v3;
      }
      while (v3);
    }
  }
  else if (a1)
  {
    v6 = a1;
    do
    {
      v7 = *v2;
      v8 = (float)(*v2 * (float)(*v2 * (float)(*v2 * 0.035677))) + (float)(*v2 * 0.79789);
      *v2++ = v7 * (float)(1.0 - (float)(1.0 / (float)(expf(v8 + v8) + 1.0)));
      --v6;
    }
    while (v6);
  }
}

void sigmoid_c(float *a1, unsigned int a2, float *a3)
{
  uint64_t v5;
  float v6;
  float v7;

  if (a2)
  {
    v5 = a2;
    do
    {
      v6 = *a1++;
      v7 = 1.0 / (fast_exp_single(-v6) + 1.0);
      *a3++ = v7;
      --v5;
    }
    while (v5);
  }
}

void softmax_simple(float *a1, unsigned int a2, float *a3)
{
  float *v3;
  uint64_t v4;
  float v5;
  uint64_t v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  float *v12;
  float v13;
  float v14;

  v3 = a3;
  if (a2)
  {
    v4 = a2;
    v5 = -3.4028e38;
    v6 = a2;
    v7 = a1;
    do
    {
      v8 = *v7++;
      v9 = v8;
      if (v8 > v5)
        v5 = v9;
      --v6;
    }
    while (v6);
    do
    {
      *(float *)((char *)a3 + v6) = *(float *)((char *)a1 + v6) - v5;
      v6 += 4;
    }
    while (4 * a2 != v6);
    fast_exp(a3, a2, a3);
    v10 = 0.0;
    v11 = v4;
    v12 = v3;
    do
    {
      v13 = *v12++;
      v10 = v10 + v13;
      --v11;
    }
    while (v11);
    if (v10 != 0.0)
    {
      v14 = 1.0 / v10;
      do
      {
        *v3 = v14 * *v3;
        ++v3;
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    fast_exp(a3, 0, a3);
  }
}

void softmax_simple_temp(float *a1, unsigned int a2, float *a3, float a4)
{
  float *v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;

  if (a4 >= 0.00000001)
  {
    v4 = a3;
    if (a2)
    {
      v5 = a2;
      v6 = -3.4028e38;
      v7 = a2;
      v8 = a1;
      v9 = 1.0 / a4;
      do
      {
        v10 = *v8++;
        v11 = v10;
        if (v10 > v6)
          v6 = v11;
        --v7;
      }
      while (v7);
      do
      {
        *(float *)((char *)a3 + v7) = v9 * (float)(*(float *)((char *)a1 + v7) - v6);
        v7 += 4;
      }
      while (4 * a2 != v7);
      fast_exp(a3, a2, a3);
      v12 = 0.0;
      v13 = v5;
      v14 = v4;
      do
      {
        v15 = *v14++;
        v12 = v12 + v15;
        --v13;
      }
      while (v13);
      if (v12 != 0.0)
      {
        v16 = 1.0 / v12;
        do
        {
          *v4 = v16 * *v4;
          ++v4;
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      fast_exp(a3, 0, a3);
    }
  }
}

void softmax(float *a1, unsigned int a2, int a3, float *a4, float a5)
{
  int v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  int v18;

  if (a5 >= 0.00000001)
  {
    if (a3 == 1)
    {
      if ((float)(a5 + -1.0) >= 0.00000001 || (float)(1.0 - a5) >= 0.00000001)
        softmax_simple_temp(a1, a2, a4, a5);
      else
        softmax_simple(a1, a2, a4);
    }
    else if (a2)
    {
      v8 = 0;
      v9 = a2;
      v10 = -3.4028e38;
      v11 = a2;
      v12 = 1.0 / a5;
      do
      {
        if (a1[v8] > v10)
          v10 = a1[v8];
        v8 += a3;
        --v11;
      }
      while (v11);
      v13 = 0;
      v14 = v12 * v10;
      v15 = 0.0;
      v16 = a2;
      do
      {
        v17 = expf((float)(v12 * a1[v13]) - v14);
        v15 = v15 + v17;
        a4[v13] = v17;
        v13 += a3;
        --v16;
      }
      while (v16);
      if (v15 != 0.0)
      {
        v18 = 0;
        do
        {
          a4[v18] = (float)(1.0 / v15) * a4[v18];
          v18 += a3;
          --v9;
        }
        while (v9);
      }
    }
  }
}

uint64_t oneNorm(uint64_t result, unsigned int a2, int a3, uint64_t a4)
{
  unsigned int v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  unsigned int v8;
  float v9;

  if (a2)
  {
    v4 = 0;
    v5 = a2;
    v6 = 0.0;
    v7 = a2;
    do
    {
      v6 = v6 + *(float *)(result + 4 * v4);
      v4 += a3;
      --v7;
    }
    while (v7);
    if (v6 != 0.0)
    {
      v8 = 0;
      v9 = 1.0 / v6;
      do
      {
        *(float *)(a4 + 4 * v8) = v9 * *(float *)(a4 + 4 * v8);
        v8 += a3;
        --v5;
      }
      while (v5);
    }
  }
  return result;
}

uint64_t getLargestIdx(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  float v4;
  float v5;

  if (a2 < 1)
    return 0xFFFFFFFFLL;
  v2 = 0;
  LODWORD(v3) = -1;
  v4 = -3.4028e38;
  do
  {
    v5 = *(float *)(a1 + 4 * v2);
    if (v5 >= v4)
      v3 = v2;
    else
      v3 = v3;
    if (v5 >= v4)
      v4 = *(float *)(a1 + 4 * v2);
    ++v2;
  }
  while (a2 != v2);
  return v3;
}

uint64_t sparse_sgemv_accum16_c(uint64_t result, float *a2, int a3, int *a4, uint64_t a5)
{
  unint64_t i;
  int v6;
  int v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  uint64_t v25;
  float v26;

  if (a3 >= 1)
  {
    for (i = 0; i < a3; i += 16)
    {
      v7 = *a4++;
      v6 = v7;
      if (v7 >= 1)
      {
        v8 = (float *)(result + 4 * i);
        v9 = *v8;
        v10 = v8[1];
        v11 = v8[2];
        v12 = v8[3];
        v13 = v8[4];
        v14 = v8[5];
        v15 = v8[6];
        v16 = v8[7];
        v17 = v8[8];
        v18 = v8[9];
        v19 = v8[10];
        v20 = v8[11];
        v21 = v8[12];
        v22 = v8[13];
        v23 = v8[14];
        v24 = v8[15];
        do
        {
          v25 = *a4++;
          v26 = *(float *)(a5 + 4 * v25);
          v9 = v9 + (float)(*a2 * v26);
          *v8 = v9;
          v10 = v10 + (float)(a2[1] * v26);
          v8[1] = v10;
          v11 = v11 + (float)(a2[2] * v26);
          v8[2] = v11;
          v12 = v12 + (float)(a2[3] * v26);
          v8[3] = v12;
          v13 = v13 + (float)(a2[4] * v26);
          v8[4] = v13;
          v14 = v14 + (float)(a2[5] * v26);
          v8[5] = v14;
          v15 = v15 + (float)(a2[6] * v26);
          v8[6] = v15;
          v16 = v16 + (float)(a2[7] * v26);
          v8[7] = v16;
          v17 = v17 + (float)(a2[8] * v26);
          v8[8] = v17;
          v18 = v18 + (float)(a2[9] * v26);
          v8[9] = v18;
          v19 = v19 + (float)(a2[10] * v26);
          v8[10] = v19;
          v20 = v20 + (float)(a2[11] * v26);
          v8[11] = v20;
          v21 = v21 + (float)(a2[12] * v26);
          v8[12] = v21;
          v22 = v22 + (float)(a2[13] * v26);
          v8[13] = v22;
          v23 = v23 + (float)(a2[14] * v26);
          v8[14] = v23;
          v24 = v24 + (float)(a2[15] * v26);
          v8[15] = v24;
          a2 += 16;
          --v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

float accum4(unsigned int a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float result;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;

  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      v6 = a1;
      do
      {
        v7 = *a2++;
        v8 = v7;
        v9 = *a3++;
        v10 = v8 + v9;
        v11 = *a4++;
        v12 = v10 + v11;
        v13 = *a5++;
        result = v12 + v13;
        *a6++ = result;
        --v6;
      }
      while (v6);
    }
  }
  else if (a1)
  {
    v15 = a1;
    do
    {
      v16 = *a2++;
      v17 = v16;
      v18 = *a3++;
      v19 = v17 + v18;
      v20 = *a4++;
      v21 = v19 + v20;
      v22 = *a5++;
      result = v21 + v22;
      *a6++ = result;
      --v15;
    }
    while (v15);
  }
  return result;
}

float *_inv_preemphasis(float *result, unsigned int a2, float a3)
{
  float v4;
  float v5;
  uint64_t v6;

  if (a3 != 0.0 && a2 >= 2)
  {
    v4 = *result++;
    v5 = v4;
    v6 = a2 - 1;
    do
    {
      v5 = *result + (float)(a3 * v5);
      *result++ = v5;
      --v6;
    }
    while (v6);
  }
  return result;
}

float *_scale_to_one(float *result, unsigned int a2)
{
  uint64_t v2;
  float v3;
  uint64_t v4;
  float *v5;
  float v6;
  float v7;

  if (a2)
  {
    v2 = a2;
    v3 = 0.01;
    v4 = a2;
    v5 = result;
    do
    {
      v6 = *v5++;
      v7 = fabsf(v6);
      if (v7 > v3)
        v3 = v7;
      --v4;
    }
    while (v4);
    do
    {
      *result = *result / v3;
      ++result;
      --v2;
    }
    while (v2);
  }
  return result;
}

float *_scale_to_pcm16(float *result, unsigned int a2)
{
  float v2;
  uint64_t v3;
  float *v4;
  float v5;
  float v6;

  if (a2)
  {
    v2 = 0.01;
    v3 = a2;
    v4 = result;
    do
    {
      v5 = *v4++;
      v6 = fabsf(v5);
      if (v6 > v2)
        v2 = v6;
      --v3;
    }
    while (v3);
    do
    {
      *((_WORD *)result + v3) = (int)((float)((float)(result[v3] * 32767.0) / v2) + 0.5);
      ++v3;
    }
    while (a2 != v3);
  }
  return result;
}

float32x4_t V2AddDot1x4(int a1, float *a2, __int32 *a3, int a4, float32x4_t *a5)
{
  float32x4_t v5;
  float v6;
  float32x4_t v7;
  __int32 *v8;
  float32x4_t result;

  if (a1 < 1)
  {
    v5 = 0uLL;
  }
  else
  {
    v5 = 0uLL;
    do
    {
      v6 = *a2++;
      v7.i32[0] = *a3;
      v8 = &a3[3 * a4];
      v7.i32[1] = a3[a4];
      v7.i32[2] = a3[2 * a4];
      ++a3;
      v7.i32[3] = *v8;
      v5 = vmlaq_n_f32(v5, v7, v6);
      --a1;
    }
    while (a1);
  }
  result = vaddq_f32(v5, *a5);
  *a5 = result;
  return result;
}

float V2AddDot4x1(int a1, float *a2, int a3, float *a4, uint64_t a5, float *a6, int a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  float result;

  if (a1 < 1)
  {
    v10 = 0.0;
    v9 = 0.0;
    v8 = 0.0;
    v7 = 0.0;
  }
  else
  {
    v7 = 0.0;
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    do
    {
      v11 = a2[a3];
      v12 = a2[2 * a3];
      v13 = *a2;
      v14 = a2[3 * a3];
      ++a2;
      v15 = *a4++;
      v10 = v10 + (float)(v13 * v15);
      v9 = v9 + (float)(v11 * v15);
      v8 = v8 + (float)(v12 * v15);
      v7 = v7 + (float)(v14 * v15);
      --a1;
    }
    while (a1);
  }
  *a6 = v10 + *a6;
  a6[a7] = v9 + a6[a7];
  a6[2 * a7] = v8 + a6[2 * a7];
  v16 = 3 * a7;
  result = v7 + a6[v16];
  a6[v16] = result;
  return result;
}

float V2AddDot4x4(int a1, uint64_t a2, int a3, uint64_t a4, int a5, float32x4_t *a6, int a7)
{
  uint64_t v7;
  float32x4_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float32x4_t v25;
  float v26;
  float *v27;
  float v28;
  float v29;
  float *v30;
  float v31;
  float *v32;
  float v33;
  float result;

  if (a1 < 1)
  {
    v8 = 0uLL;
    v21 = 0.0;
    v20 = 0.0;
    v19 = 0.0;
    v18 = 0.0;
    v17 = 0.0;
    v16 = 0.0;
    v15 = 0.0;
    v14 = 0.0;
    v13 = 0.0;
    v12 = 0.0;
    v11 = 0.0;
    v10 = 0.0;
  }
  else
  {
    v7 = 0;
    v8 = 0uLL;
    v9 = a4 + 8 * a5;
    v10 = 0.0;
    v11 = 0.0;
    v12 = 0.0;
    v13 = 0.0;
    v14 = 0.0;
    v15 = 0.0;
    v16 = 0.0;
    v17 = 0.0;
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0.0;
    v21 = 0.0;
    do
    {
      v22 = *(float *)(a2 + 4 * a3 + 4 * v7);
      v23 = *(float *)(a2 + 8 * a3 + 4 * v7);
      v24 = *(float *)(a2 + 12 * a3 + 4 * v7);
      v25.i32[0] = *(_DWORD *)(a4 + 4 * v7);
      v26 = *(float *)(a4 + 12 * a5 + 4 * v7);
      v21 = v21 + (float)(v22 * v25.f32[0]);
      v17 = v17 + (float)(v23 * v25.f32[0]);
      v13 = v13 + (float)(v24 * v25.f32[0]);
      v25.i32[1] = *(_DWORD *)(a4 + 4 * a5 + 4 * v7);
      v25.i64[1] = __PAIR64__(LODWORD(v26), *(_DWORD *)(v9 + 4 * v7));
      v8 = vmlaq_n_f32(v8, v25, *(float *)(a2 + 4 * v7));
      v20 = v20 + (float)(v22 * v25.f32[1]);
      v19 = v19 + (float)(v22 * *(float *)(v9 + 4 * v7));
      v18 = v18 + (float)(v22 * v26);
      v16 = v16 + (float)(v23 * v25.f32[1]);
      v15 = v15 + (float)(v23 * *(float *)(v9 + 4 * v7));
      v14 = v14 + (float)(v23 * v26);
      v12 = v12 + (float)(v24 * v25.f32[1]);
      v11 = v11 + (float)(v24 * *(float *)(v9 + 4 * v7));
      v10 = v10 + (float)(v24 * v26);
      ++v7;
    }
    while (a1 != (_DWORD)v7);
  }
  *a6 = vaddq_f32(v8, *a6);
  v27 = &a6->f32[a7];
  v28 = v27[1];
  *v27 = v21 + *v27;
  v27[1] = v20 + v28;
  v29 = v18 + v27[3];
  v27[2] = v19 + v27[2];
  v27[3] = v29;
  a6->f32[2 * a7] = v17 + a6->f32[2 * a7];
  v30 = &a6->f32[2 * a7];
  v31 = v30[2];
  v30[1] = v16 + v30[1];
  v30[2] = v15 + v31;
  v30[3] = v14 + v30[3];
  a6->f32[3 * a7] = v13 + a6->f32[3 * a7];
  v32 = &a6->f32[3 * a7];
  v33 = v32[2];
  v32[1] = v12 + v32[1];
  v32[2] = v11 + v33;
  result = v10 + v32[3];
  v32[3] = result;
  return result;
}

void gemm_v2(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, float32x4_t *a10, int a11)
{
  int v12;
  int v14;
  int v15;
  int padded_len;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float32x4_t *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  float *v30;
  uint64_t v31;
  float32x4_t *v32;
  __int32 *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  float *v38;
  float v39;
  float *v40;
  uint64_t v41;
  float *v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  float32x4_t *v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  __int32 *v54;
  uint64_t v55;
  float *v56;
  float v57;
  int v58;
  float *v59;
  float v60;
  float v61;
  float v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  float32x4_t *v73;
  float32x4_t *v74;
  uint64_t v76;
  uint64_t v77;

  v12 = a3;
  if (a3 >= 0)
    v14 = a3;
  else
    v14 = a3 + 3;
  if (a4 >= 0)
    v15 = a4;
  else
    v15 = a4 + 3;
  padded_len = get_padded_len(a7, 8u);
  v17 = get_padded_len(a9, 8u);
  v71 = v17;
  if (a2)
  {
    LODWORD(v19) = v15 & 0xFFFFFFFC;
    if (v12 < 4)
    {
      v34 = 0;
      v33 = (__int32 *)a8;
      v32 = a10;
      v24 = a4;
    }
    else
    {
      v64 = v12;
      v76 = 0;
      v20 = 0;
      v63 = v15 & 0xFFFFFFFC;
      v19 = (int)v19;
      v21 = (int)(v14 & 0xFFFFFFFC);
      v22 = 16 * v17;
      v66 = 4 * v17;
      v23 = a10;
      v24 = a4;
      v65 = v21;
      v69 = (int)v19;
      v67 = v22;
      do
      {
        v73 = v23;
        if (v24 < 4)
        {
          v28 = 0;
        }
        else
        {
          v25 = 0;
          v26 = v19;
          v27 = a8;
          do
          {
            V2AddDot4x4(a5, a6 + 4 * v20 * padded_len, padded_len, v27, v71, v23, a11);
            v25 += 4;
            ++v23;
            v27 += v22;
          }
          while (v25 < v26);
          v28 = v25;
          v24 = a4;
          v21 = v65;
        }
        if ((int)v28 < v24)
        {
          v29 = &a10[v76].f32[v28];
          v30 = (float *)(a8 + v66 * v28);
          v31 = a4 - v28;
          do
          {
            V2AddDot4x1(a5, (float *)(a6 + 4 * v20 * padded_len), padded_len, v30, v18, v29++, a11);
            v30 = (float *)((char *)v30 + v66);
            --v31;
          }
          while (v31);
        }
        v20 += 4;
        v23 = &v73[a11];
        v76 += a11;
        v24 = a4;
        v19 = v69;
        v22 = v67;
      }
      while (v20 < v21);
      v33 = (__int32 *)a8;
      v32 = a10;
      v34 = v20;
      v12 = v64;
      LODWORD(v19) = v63;
    }
    if ((int)v34 < v12)
    {
      v44 = v71;
      v45 = (int)v19;
      v46 = v34;
      v47 = padded_len;
      v48 = v12;
      v49 = v24;
      v70 = padded_len;
      v50 = (float32x4_t *)((char *)v32 + 4 * a11 * (unint64_t)v34);
      v51 = 4 * a11;
      v68 = v48;
      do
      {
        if (v24 < 4)
        {
          v55 = 0;
        }
        else
        {
          v52 = 0;
          v77 = v46;
          v53 = (float *)(a6 + 4 * v46 * v47);
          v54 = v33;
          v74 = v50;
          do
          {
            V2AddDot1x4(a5, v53, v54, v71, v50);
            v52 += 4;
            ++v50;
            v54 += 4 * v71;
          }
          while (v52 < v45);
          v55 = v52;
          v24 = a4;
          v44 = v71;
          v32 = a10;
          v46 = v77;
          v47 = v70;
          v51 = 4 * a11;
          v48 = v68;
          v50 = v74;
        }
        if ((int)v55 < v24)
        {
          do
          {
            if (a5 < 1)
            {
              v57 = 0.0;
            }
            else
            {
              v56 = (float *)&v33[v55 * v44];
              v57 = 0.0;
              v58 = a5;
              v59 = (float *)(a6 + 4 * v46 * v47);
              do
              {
                v60 = *v59++;
                v61 = v60;
                v62 = *v56++;
                v57 = v57 + (float)(v61 * v62);
                --v58;
              }
              while (v58);
            }
            v32->f32[v55 + v46 * a11] = v57 + v32->f32[v55 + v46 * a11];
            ++v55;
          }
          while (v55 != v49);
        }
        ++v46;
        v50 = (float32x4_t *)((char *)v50 + v51);
      }
      while (v46 != v48);
    }
  }
  else if (v12 >= 1)
  {
    v35 = 0;
    v36 = 4 * v17;
    do
    {
      if (a5 >= 1)
      {
        v37 = 0;
        v38 = (float *)a8;
        do
        {
          if (a4 >= 1)
          {
            v39 = *(float *)(a6 + 4 * v35 * padded_len + 4 * v37);
            v40 = v38;
            v41 = a4;
            v42 = &a10->f32[v35 * a11];
            do
            {
              v43 = *v40++;
              *v42 = *v42 + (float)(v39 * v43);
              ++v42;
              --v41;
            }
            while (v41);
          }
          ++v37;
          v38 = (float *)((char *)v38 + v36);
        }
        while (v37 != a5);
      }
      ++v35;
    }
    while (v35 != v12);
  }
}

void gemm_v5(uint64_t a1, int a2, int a3, int a4, int a5, float *a6, uint64_t a7, char *a8, unsigned int a9, float *a10, int a11, uint64_t a12)
{
  float *v12;
  float *v19;
  float v20;
  float v21;
  int padded_len;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  float v28;
  float *v29;
  char *v30;
  uint64_t v31;
  float v32;
  float v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  float *v39;
  uint64_t v40;
  int v41;

  if (a12)
  {
    v12 = *(float **)(a12 + 24);
    if (v12)
    {
      v19 = a10;
      v20 = *v12;
      v21 = v12[1];
      padded_len = get_padded_len(a7, 8u);
      v23 = get_padded_len(a9, 0x20u);
      if (a2)
      {
        if (a3 >= 1)
        {
          v24 = 0;
          do
          {
            if (a4 >= 1)
            {
              v25 = 0;
              v26 = v24 * a11;
              v27 = a8;
              do
              {
                if (a5 >= 1)
                {
                  v28 = a10[v25 + v26];
                  v29 = a6;
                  v30 = v27;
                  v31 = a5;
                  do
                  {
                    v32 = *v29++;
                    v33 = v32;
                    v34 = *v30++;
                    v28 = v28 + (float)(v33 * (float)(v21 + (float)(v20 * (float)v34)));
                    a10[v25 + v26] = v28;
                    --v31;
                  }
                  while (v31);
                }
                ++v25;
                v27 += v23;
              }
              while (v25 != a4);
            }
            ++v24;
            a6 += padded_len;
          }
          while (v24 != a3);
        }
      }
      else if (a3 >= 1)
      {
        v35 = 0;
        do
        {
          if (a5 >= 1)
          {
            v36 = 0;
            v37 = a8;
            do
            {
              if (a4 >= 1)
              {
                v38 = v37;
                v39 = v19;
                v40 = a4;
                do
                {
                  v41 = *v38++;
                  *v39 = *v39 + (float)(a6[v36 + v35 * padded_len] * (float)(v21 + (float)(v20 * (float)v41)));
                  ++v39;
                  --v40;
                }
                while (v40);
              }
              ++v36;
              v37 += v23;
            }
            while (v36 != a5);
          }
          ++v35;
          v19 += a11;
        }
        while (v35 != a3);
      }
    }
  }
}

uint64_t pack_bsc_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  unsigned int padded_len;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;

  padded_len = get_padded_len(a3, 4u);
  v12 = get_padded_len(a4, 4u);
  v13 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), 1, 32);
  if (!v13)
    return 10;
  v14 = v13;
  result = 0;
  *(_DWORD *)(v14 + 24) = padded_len >> 2;
  *(_DWORD *)(v14 + 28) = v12 >> 2;
  v16 = a5 + 4 * (16 * a2);
  *(_QWORD *)v14 = a5;
  *(_QWORD *)(v14 + 8) = v16 + 4 * (v12 >> 2) + 4;
  *(_QWORD *)(v14 + 16) = v16;
  *a6 = v14;
  return result;
}

uint64_t get_bsc_data_len(int a1, uint64_t a2)
{
  return 17 * a1 + (get_padded_len(a2, 4u) >> 2) + 1;
}

uint64_t pack_bsr_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  unsigned int padded_len;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;

  padded_len = get_padded_len(a3, 4u);
  v12 = get_padded_len(a4, 4u);
  v13 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), 1, 32);
  if (!v13)
    return 10;
  v14 = v13;
  result = 0;
  *(_DWORD *)(v14 + 24) = padded_len >> 2;
  *(_DWORD *)(v14 + 28) = v12 >> 2;
  v16 = a5 + 4 * (16 * a2);
  *(_QWORD *)v14 = a5;
  *(_QWORD *)(v14 + 8) = v16;
  *(_QWORD *)(v14 + 16) = v16 + 4 * (padded_len >> 2) + 4;
  *a6 = v14;
  return result;
}

const char *fi_layer_type_to_name(unsigned int a1)
{
  if (a1 > 0x49)
    return "[]";
  else
    return off_1EA94A708[a1];
}

uint64_t fi_layer_if_has_weights(unsigned int a1)
{
  if (a1 > 0x47)
    return 0;
  else
    return dword_1DECEB798[a1];
}

uint64_t fi_layer_free(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 136);
    if (v1)
      return v1();
  }
  return result;
}

uint64_t fi_layer_find_weights_via_offset(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t (*v5)(uint64_t);
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;

  *(_QWORD *)(a1 + 72) = a2 + *a3;
  v5 = *(uint64_t (**)(uint64_t))(a1 + 184);
  if (!v5 || (result = v5(a1), !(_DWORD)result))
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 152))(a1, a1 + 96, a1 + 112);
    if (!(_DWORD)result)
    {
      v7 = *(unsigned int *)(a1 + 96);
      v8 = *(_DWORD *)(a1 + 112) + v7;
      *(_DWORD *)(a1 + 80) = v8;
      *(_DWORD *)(a1 + 116) = 0;
      v9 = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(a1 + 104) = v9 + v7;
      *(_QWORD *)(a1 + 88) = v9;
      *a3 += v8;
    }
  }
  return result;
}

uint64_t fi_shape_set(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  int v6;

  if (!a4)
    return 7;
  result = 0;
  *(_DWORD *)a4 = a1;
  v6 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a4 + 4) = *(_QWORD *)a2;
  *(_DWORD *)(a4 + 12) = v6;
  *(_DWORD *)(a4 + 16) = a3;
  return result;
}

uint64_t fi_shape_merge(_DWORD *a1, _DWORD *a2)
{
  uint64_t v2;
  int v3;
  _BOOL8 v4;

  v2 = 7;
  if (a1 && a2)
  {
    if (*a1 == *a2)
    {
      v3 = a1[4];
      v2 = 7;
      if (v3 && v3 == a2[4])
      {
        v4 = *a1 == 2 && a1[1] == a2[1];
        v2 = 0;
        a2[v4 + 1] += a1[v4 + 1];
      }
    }
    else
    {
      return 7;
    }
  }
  return v2;
}

uint64_t fi_shape_dump(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"FI_SHAPE_T(%s): ndim=%d, dims=(%d, %d, %d), elemBytes=%d", a6, a7, a8, a3);
}

__n128 fi_shape_copy(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[1].n128_u32[0] = a2[1].n128_u32[0];
  *a1 = result;
  return result;
}

uint64_t fi_shape_get_step(_DWORD *a1)
{
  if (*a1 == 1)
    return 1;
  else
    return a1[1];
}

uint64_t fi_shape_get_input_dim(int *a1, int *a2)
{
  int v2;
  int v3;
  uint64_t result;

  v2 = *a1;
  if (*a1 == 3)
  {
    v3 = a1[2] * a1[1] * a1[3];
    goto LABEL_7;
  }
  if (v2 == 2)
  {
    v3 = a1[2];
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    v3 = a1[1];
LABEL_7:
    result = 0;
    *a2 = v3;
    return result;
  }
  return 7;
}

uint64_t fi_shape_get_conv_chw(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;

  if (*a1 == 2)
  {
    result = 0;
    *a3 = a1[1];
    *a4 = a1[2];
    *a2 = 1;
  }
  else if (*a1 == 3)
  {
    result = 0;
    *a2 = a1[1];
    *a3 = a1[2];
    *a4 = a1[3];
  }
  else
  {
    return 7;
  }
  return result;
}

uint64_t fi_shape_get_channel(_DWORD *a1)
{
  if (*a1 == 3)
    return a1[1];
  else
    return 1;
}

uint64_t fi_shape_get_size(int *a1, int *a2)
{
  int v3;
  uint64_t result;
  int v5;

  v3 = *a1;
  if (*a1 == 3)
  {
    result = 0;
    v5 = a1[2] * a1[1] * a1[3];
  }
  else if (v3 == 2)
  {
    result = 0;
    v5 = a1[2] * a1[1];
  }
  else if (v3 == 1)
  {
    result = 0;
    v5 = a1[1];
  }
  else
  {
    v5 = 0;
    result = 7;
  }
  *a2 = v5;
  return result;
}

uint64_t fi_shape_get_bytes(int *a1, _DWORD *a2)
{
  int v2;
  int v3;
  uint64_t v4;

  v2 = *a1;
  if (*a1 == 3)
  {
    v3 = a1[2] * a1[1] * a1[3];
  }
  else if (v2 == 2)
  {
    v3 = a1[2] * a1[1];
  }
  else
  {
    if (v2 != 1)
      return 7;
    v3 = a1[1];
  }
  v4 = 0;
  *a2 = a1[4] * v3;
  return v4;
}

uint64_t fi_shape_is_same(unsigned int *a1, _DWORD *a2)
{
  uint64_t v2;
  int *v3;
  int *v4;
  int v5;
  int v6;
  int v7;

  v2 = *a1;
  if ((_DWORD)v2 == *a2 && a1[4] == a2[4])
  {
    if (!(_DWORD)v2)
      return 1;
    v3 = (int *)(a1 + 1);
    v4 = a2 + 1;
    while (1)
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *v4++;
      if (v5 != v7)
        break;
      if (!--v2)
        return 1;
    }
  }
  return 0;
}

uint64_t fi_get_activation(const char *a1)
{
  uint64_t result;

  result = strcmp(a1, "linear");
  if ((_DWORD)result)
  {
    if (!strcmp(a1, "sigmoid"))
    {
      return 1;
    }
    else if (!strcmp(a1, "hardsigmoid"))
    {
      return 6;
    }
    else if (!strcmp(a1, "tanh"))
    {
      return 2;
    }
    else if (!strcmp(a1, "relu"))
    {
      return 3;
    }
    else if (!strcmp(a1, "elu"))
    {
      return 4;
    }
    else if (!strcmp(a1, "leaky"))
    {
      return 5;
    }
    else if (!strcmp(a1, "softsign"))
    {
      return 7;
    }
    else if (!strcmp(a1, "softmax"))
    {
      return 9;
    }
    else if (!strcmp(a1, "softplus"))
    {
      return 8;
    }
    else if (!strcmp(a1, "tanh_approx"))
    {
      return 10;
    }
    else if (!strcmp(a1, "sigmoid_approx"))
    {
      return 11;
    }
    else if (!strcmp(a1, "gelu"))
    {
      return 12;
    }
    else if (!strcmp(a1, "leaky_dot_two"))
    {
      return 13;
    }
    else if (!strcmp(a1, "leaky_dot_two_inverse"))
    {
      return 14;
    }
    else
    {
      return 3;
    }
  }
  return result;
}

void fi_activate_array(float *a1, uint64_t a2, int a3)
{
  float *v4;
  float *v5;
  float *v6;
  uint64_t v7;
  int v8;
  float v9;

  v4 = a1;
  switch(a3)
  {
    case 0:
      return;
    case 1:
      v5 = a1;
      goto LABEL_3;
    case 2:
      v6 = a1;
      goto LABEL_5;
    case 3:
      relu_array_f32(a2, a1);
      return;
    case 7:
      softsign_array_f32(a2, a1);
      return;
    case 9:
      softmax(a1, a2, 1, a1, 1.0);
      return;
    case 10:
      v6 = a1;
LABEL_5:
      fast_tanh(a1, a2, v6);
      return;
    case 11:
      v5 = a1;
LABEL_3:
      sigmoid(a1, a2, v5);
      return;
    case 12:
      gelu_array_f32(a2, a1);
      return;
    case 13:
      v9 = 0.2;
      goto LABEL_18;
    case 14:
      v9 = 5.0;
LABEL_18:
      leaky_array_f32(a2, a1, v9);
      break;
    default:
      if ((_DWORD)a2)
      {
        v7 = a2;
        do
        {
          activate(a3, *v4);
          *(_DWORD *)v4++ = v8;
          --v7;
        }
        while (v7);
      }
      break;
  }
}

void activate(int a1, float a2)
{
  double v2;
  float v3;

  switch(a1)
  {
    case 1:
    case 11:
      exp_fdlibm((float)-a2);
      break;
    case 2:
    case 10:
      if (a2 <= 350.0)
        exp_fdlibm((float)(a2 + a2));
      break;
    case 4:
      if (a2 < 0.0)
        exp_fdlibm(a2);
      break;
    case 7:
      fabs_fdlibm(a2);
      break;
    case 8:
      v2 = exp_fdlibm(a2);
      log_fdlibm(v2 + 1.0);
      break;
    case 12:
      v3 = (float)((float)((float)(a2 * 0.035677) * a2) * a2) + (float)(a2 * 0.79789);
      if (v3 <= 350.0)
        exp_fdlibm((float)(v3 + v3));
      break;
    default:
      return;
  }
}

uint64_t alloc_aligned_mem(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  if (!a3)
    return 0;
  if (-8 - a2 < a3)
    return 0;
  result = heap_Alloc(a1, a2 + a3 + 7);
  if (result)
  {
    v5 = result;
    result += 8 + ((((a2 - 1) & ~(result + 8)) + 1) & (a2 - 1));
    *(_QWORD *)(result - 8) = v5;
  }
  return result;
}

void *calloc_aligned_mem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v4;
  void *v5;
  void *v6;

  v4 = a4 * a3;
  v5 = (void *)alloc_aligned_mem(a1, a2, a4 * a3);
  v6 = v5;
  if (v5)
    bzero(v5, v4);
  return v6;
}

uint64_t realloc_aligned_mem(uint64_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a4)
    return 0;
  v6 = a2;
  if (a2)
  {
    if (-8 - a3 >= a4)
    {
      v7 = *(_QWORD *)(a2 - 8);
      v8 = heap_Realloc(a1, v7, a3 + a4 + 7);
      if (v8)
      {
        v9 = v8;
        if (v8 != v7)
        {
          v10 = v6 - v7;
          v11 = ((((a3 - 1) & ~(v8 + 8)) + 1) & (a3 - 1)) + 8;
          v6 = v8 + v11;
          if (v11 != v10)
            memmove((void *)(v8 + v11), (const void *)(v8 + v10), a4);
          *(_QWORD *)(v6 - 8) = v9;
        }
        return v6;
      }
    }
    return 0;
  }
  return alloc_aligned_mem((uint64_t)a1, a3, a4);
}

_QWORD *free_aligned_mem(_QWORD *result, uint64_t a2)
{
  if (a2)
    return heap_Free(result, *(_QWORD *)(a2 - 8));
  return result;
}

uint64_t alloc_aligned_32_mem(uint64_t a1, unint64_t a2)
{
  return alloc_aligned_mem(a1, 32, a2);
}

uint64_t realloc_aligned_32_mem(uint64_t *a1, uint64_t a2, size_t a3)
{
  return realloc_aligned_mem(a1, a2, 32, a3);
}

void *calloc_aligned_32_mem(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v3;
  void *v4;
  void *v5;

  v3 = a3 * a2;
  v4 = (void *)alloc_aligned_mem(a1, 32, a3 * a2);
  v5 = v4;
  if (v4)
    bzero(v4, v3);
  return v5;
}

_QWORD *free_mem(_QWORD *result, uint64_t a2)
{
  if (a2)
    return heap_Free(result, a2);
  return result;
}

BOOL fi_version_cmp(uint64_t a1, int *a2, char *__s)
{
  uint64_t v6;
  uint64_t (*v7)(uint64_t, size_t);
  size_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;
  char *v17;
  int v18;
  char *v19;
  int v20;
  _BOOL8 v21;
  uint64_t v23;
  char *__lasts;

  __lasts = 0;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = **(uint64_t (***)(uint64_t, size_t))(a1 + 8);
  v8 = strlen(__s);
  v9 = (char *)v7(v6, v8 + 1);
  if (v9)
  {
    v13 = v9;
    v14 = strcpy(v9, __s);
    v15 = strtok_r(v14, ".", &__lasts);
    v16 = *a2;
    if (v16 == atoi(v15) && (v17 = strtok_r(0, ".", &__lasts), v18 = a2[1], v18 == atoi(v17)))
    {
      v19 = strtok_r(0, ".", &__lasts);
      v20 = a2[2];
      v21 = v20 == atoi(v19);
    }
    else
    {
      v21 = 0;
    }
    (*(void (**)(_QWORD, char *))(*(_QWORD *)(a1 + 8) + 48))(*(_QWORD *)(a1 + 16), v13);
  }
  else
  {
    log_OutText(*(_QWORD *)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v23);
    return 0;
  }
  return v21;
}

BOOL fi_feat_is_enabled(uint64_t a1, unsigned int a2, unsigned int a3)
{
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    if (a2 < a3)
      return *(_DWORD *)(a1 + 4 * a2) == 1;
  }
  return result;
}

uint64_t get_mat_length(int *a1)
{
  int v1;

  if (a1)
    v1 = *a1;
  else
    v1 = 0;
  return get_weight_length(a1) + v1;
}

uint64_t get_weight_length(_DWORD *a1)
{
  int v2;
  unsigned int v3;
  int v4;
  int padded_len;
  int v6;
  int v8;
  uint64_t v9;
  int v10;

  if (!a1)
  {
    padded_len = get_padded_len(0, 8u);
    v6 = 0;
    return (v6 * padded_len);
  }
  v2 = a1[1];
  if ((v2 & 8) != 0)
    v3 = 32;
  else
    v3 = 8;
  if ((v2 & 1) != 0)
  {
    v8 = a1[2];
    if ((v2 & 2) != 0)
    {
      v9 = get_padded_len(a1[4], 8u);
      v10 = v8;
    }
    else
    {
      v9 = a1[5];
      v10 = a1[2];
    }
    return get_bsc_data_len(v10, v9);
  }
  else
  {
    if ((v2 & 2) == 0)
    {
      padded_len = get_padded_len(a1[4], v3);
      v6 = a1[5];
      return (v6 * padded_len);
    }
    v4 = a1[4];
    return get_padded_len(a1[5], v3) * v4;
  }
}

uint64_t fi_net_init(uint64_t *a1, uint64_t ***a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t **v7;
  uint64_t result;
  uint64_t v9;

  v7 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
  if (v7)
  {
    result = 0;
    *v7 = a1;
    v7[24] = (uint64_t *)12345;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"alloc pNet failed!", v4, v5, v6, v9);
    result = 10;
  }
  *a2 = v7;
  return result;
}

uint64_t fi_net_layers_init(uint64_t **a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  if (!a1)
    return 7;
  v2 = *((unsigned int *)a1 + 2);
  if (!(_DWORD)v2)
    return 7;
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))((*a1)[1] + 16))((*a1)[2], v2, 8);
  a1[14] = (uint64_t *)v3;
  if (v3)
    return 0;
  log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"alloc pNet->layers failed!", v4, v5, v6, v8);
  return 10;
}

uint64_t fi_net_destroy(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)result;
    if (*(_QWORD *)(result + 112))
    {
      if (!*(_DWORD *)(result + 8))
        goto LABEL_7;
      v3 = 0;
      do
      {
        fi_layer_free(*(_QWORD *)(*(_QWORD *)(v1 + 112) + 8 * v3));
        *(_QWORD *)(*(_QWORD *)(v1 + 112) + 8 * v3++) = 0;
      }
      while (v3 < *(unsigned int *)(v1 + 8));
      if (*(_QWORD *)(v1 + 112))
      {
LABEL_7:
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_QWORD *)(v1 + 112) = 0;
      }
    }
    if (*(_QWORD *)(v1 + 144))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *(_QWORD *)(v1 + 144) = 0;
    }
    *(_DWORD *)(v1 + 152) = 0;
    if (*(_QWORD *)(v1 + 160))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *(_QWORD *)(v1 + 160) = 0;
    }
    *(_DWORD *)(v1 + 168) = 0;
    if (*(_QWORD *)(v1 + 128))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *(_QWORD *)(v1 + 128) = 0;
    }
    *(_DWORD *)(v1 + 136) = 0;
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
  }
  return result;
}

uint64_t fi_net_predict(uint64_t **a1, const void **a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return fi_net_predict_ex(a1, a2, a3, a4, 0, 0, 1, a8);
}

uint64_t fi_net_predict_ex(uint64_t **a1, const void **a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v11;
  uint64_t updated;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t glbIn;
  uint64_t v25;
  uint64_t v27;

  v8 = 7;
  if (a1 && a2 && a4)
  {
    v11 = a7;
    a1[22] = (uint64_t *)a5;
    a1[23] = (uint64_t *)a6;
    updated = fi_net_update_shape(a1, a3, a3, (uint64_t)a4, a5, a6, a7, a8);
    if ((_DWORD)updated)
    {
      v8 = updated;
      v21 = **a1;
      v22 = "fi net update shape failed!";
    }
    else
    {
      v23 = fi_net_validate_weights_length(a1, v14, v15, v16, v17, v18, v19, v20);
      if ((_DWORD)v23)
      {
        v8 = v23;
        v21 = **a1;
        v22 = "fi net weights invalid!";
      }
      else
      {
        glbIn = fi_net_allocate_glbIn((uint64_t)a1);
        if ((_DWORD)glbIn)
        {
          v8 = glbIn;
          v21 = **a1;
          v22 = "fi net allocate glbIn failed!";
        }
        else
        {
          v25 = fi_net_copy_indata_to_glbIn_then_free((uint64_t)a1, a2);
          if ((_DWORD)v25)
          {
            v8 = v25;
            v21 = **a1;
            v22 = "input data copy to aligned memory and free failed!";
          }
          else
          {
            if ((v11 & 1) != 0)
            {
              if (*a2)
                (*(void (**)(uint64_t))((*a1)[1] + 80))((*a1)[2]);
              *a2 = 0;
            }
            v8 = fi_net_forward(a1);
            if (!(_DWORD)v8)
            {
              *a4 = a1[18];
              return v8;
            }
            v21 = **a1;
            v22 = "fi net do forward failed!";
          }
        }
      }
    }
    log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v18, v19, v20, v27);
  }
  return v8;
}

uint64_t fi_net_predict_notfree_input(uint64_t **a1, const void **a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t updated;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t glbIn;
  uint64_t v24;
  uint64_t v26;

  v8 = 7;
  if (a1 && a2 && a4)
  {
    updated = fi_net_update_shape(a1, a3, a3, (uint64_t)a4, a5, a6, a7, a8);
    if ((_DWORD)updated)
    {
      v8 = updated;
      v20 = **a1;
      v21 = "fi net update shape failed!";
    }
    else
    {
      v22 = fi_net_validate_weights_length(a1, v13, v14, v15, v16, v17, v18, v19);
      if ((_DWORD)v22)
      {
        v8 = v22;
        v20 = **a1;
        v21 = "fi net weights invalid!";
      }
      else
      {
        glbIn = fi_net_allocate_glbIn((uint64_t)a1);
        if ((_DWORD)glbIn)
        {
          v8 = glbIn;
          v20 = **a1;
          v21 = "fi net allocate glbIn failed!";
        }
        else
        {
          v24 = fi_net_copy_indata_to_glbIn_then_free((uint64_t)a1, a2);
          if ((_DWORD)v24)
          {
            v8 = v24;
            v20 = **a1;
            v21 = "input data copy to aligned memory and free failed!";
          }
          else
          {
            v8 = fi_net_forward(a1);
            if (!(_DWORD)v8)
            {
              *a4 = a1[18];
              return v8;
            }
            v20 = **a1;
            v21 = "fi net do forward failed!";
          }
        }
      }
    }
    log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v17, v18, v19, v26);
  }
  return v8;
}

uint64_t fi_net_update_shape(uint64_t **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v10;
  uint64_t step;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t **v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, uint64_t **);
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36;

  v10 = (_DWORD *)a1 + 13;
  if (*((_DWORD *)a1 + 13))
  {
    *(_OWORD *)(a1 + 9) = *(_OWORD *)v10;
    *((_DWORD *)a1 + 22) = *((_DWORD *)a1 + 17);
  }
  else
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"it seems no [input] for this network,pNet->inshape won't be set by pNet->netCfg.model_inshapemake sure you set pNet->inshape correctly!", a6, a7, a8, v35);
  }
  step = fi_shape_get_step(v10);
  if ((_DWORD)step)
  {
    if ((_DWORD)step != a2)
    {
      log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Error: input data step mismatch! model step= %d, input data step= %d", v12, v13, v14, step);
      log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_net_validate_and_update_network_inshape failed!", v15, v16, v17, v36);
      return 7;
    }
  }
  else
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"data step changes from %d to %d", v12, v13, v14, 0);
    *((_DWORD *)a1 + 19) = a2;
  }
  if (!*((_DWORD *)a1 + 2))
    goto LABEL_17;
  v19 = 0;
  v20 = a1 + 9;
  do
  {
    v21 = a1[14][v19];
    *(_QWORD *)(v21 + 20) = 0;
    *(_QWORD *)(v21 + 28) = 0;
    *(_QWORD *)(v21 + 40) = 0;
    *(_QWORD *)(v21 + 48) = 0;
    *(_DWORD *)(v21 + 36) = 4;
    *(_DWORD *)(v21 + 56) = 4;
    v22 = *(uint64_t (**)(uint64_t, uint64_t **))(v21 + 144);
    if (v22)
    {
      v23 = v22(v21, v20);
      if ((_DWORD)v23)
      {
        v18 = v23;
        v29 = **a1;
        v30 = fi_layer_type_to_name(*(_DWORD *)(v21 + 8));
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update shape of %s layer failed!", v31, v32, v33, (uint64_t)v30);
        return v18;
      }
    }
    else
    {
      v24 = *(_OWORD *)v20;
      *(_DWORD *)(v21 + 36) = *((_DWORD *)v20 + 4);
      *(_OWORD *)(v21 + 20) = v24;
      v25 = *(_OWORD *)v20;
      *(_DWORD *)(v21 + 56) = *((_DWORD *)v20 + 4);
      *(_OWORD *)(v21 + 40) = v25;
    }
    ++v19;
    v26 = *((unsigned int *)a1 + 2);
    v20 = (uint64_t **)(v21 + 40);
  }
  while (v19 < v26);
  if ((_DWORD)v26)
  {
    v18 = 0;
    v27 = a1[14][(v26 - 1)];
    v28 = *(_DWORD *)(v27 + 56);
    *(_OWORD *)((char *)a1 + 92) = *(_OWORD *)(v27 + 40);
    *((_DWORD *)a1 + 27) = v28;
  }
  else
  {
LABEL_17:
    v18 = 0;
    *(_OWORD *)((char *)a1 + 92) = *(_OWORD *)(a1 + 9);
    *((_DWORD *)a1 + 27) = *((_DWORD *)a1 + 22);
  }
  return v18;
}

uint64_t fi_net_validate_weights_length(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = 0;
  log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate weights and biases length of all layers ...", a6, a7, a8, v30);
  v12 = *((unsigned int *)a1 + 2);
  if (!(_DWORD)v12)
  {
LABEL_11:
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate weights and biases length of all layers Done!", v9, v10, v11, v31);
    return 0;
  }
  v13 = 0;
  while (1)
  {
    v14 = a1[14][v13];
    if (!*(_QWORD *)(v14 + 152))
      goto LABEL_10;
    v15 = **a1;
    v16 = fi_layer_type_to_name(*(_DWORD *)(v14 + 8));
    log_OutText(v15, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate layer %s ...", v17, v18, v19, (uint64_t)v16);
    v20 = *(uint64_t (**)(uint64_t))(v14 + 184);
    if (v20)
    {
      v21 = v20(v14);
      if ((_DWORD)v21)
        break;
    }
    v22 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(v14 + 152))(v14, (char *)&v32 + 4, &v32);
    if ((_DWORD)v22)
    {
      v24 = v22;
      v25 = **a1;
      v26 = "Get wanted weight and biases length failed!";
      goto LABEL_17;
    }
    v23 = *(unsigned int *)(v14 + 96);
    if (HIDWORD(v32) != (_DWORD)v23)
    {
      v27 = **(_QWORD **)v14;
      v28 = "weights length in model: %d Bytes, but wanted: %d Bytes";
LABEL_15:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v9, v10, v11, v23);
      return 7;
    }
    v23 = *(unsigned int *)(v14 + 112);
    if ((_DWORD)v32 != (_DWORD)v23)
    {
      v27 = **(_QWORD **)v14;
      v28 = "biases length in model: %d Bytes, but wanted: %d Bytes";
      goto LABEL_15;
    }
    v12 = *((unsigned int *)a1 + 2);
LABEL_10:
    if (++v13 >= v12)
      goto LABEL_11;
  }
  v24 = v21;
  v25 = **a1;
  v26 = "dispatching weights for layer %d failed!";
  v31 = v13;
LABEL_17:
  log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v9, v10, v11, v31);
  return v24;
}

uint64_t fi_net_allocate_glbIn(uint64_t a1)
{
  uint64_t bytes;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unsigned int v8;

  v8 = 0;
  if (!a1)
    return 7;
  bytes = fi_shape_get_bytes((int *)(a1 + 72), &v8);
  if (!(_DWORD)bytes)
  {
    bytes = maybe_enlarge_array(*(uint64_t **)a1, (uint64_t *)(a1 + 160), (unsigned int *)(a1 + 168), v8);
    if ((_DWORD)bytes)
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"enlarge pNet->glbIn failed!", v3, v4, v5, v7);
    else
      bzero(*(void **)(a1 + 160), *(unsigned int *)(a1 + 168));
  }
  return bytes;
}

uint64_t fi_net_copy_indata_to_glbIn_then_free(uint64_t a1, const void **a2)
{
  const void *v3;
  uint64_t bytes;
  size_t __n;

  LODWORD(__n) = 0;
  v3 = *a2;
  bytes = fi_shape_get_bytes((int *)(a1 + 72), &__n);
  if ((_DWORD)bytes != 7)
    memcpy(*(void **)(a1 + 160), v3, __n);
  return bytes;
}

uint64_t fi_net_forward(uint64_t **a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t bytes;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  uint64_t v33;
  uint64_t **v34;
  uint64_t *v35;
  __int128 v36;
  __int128 v37;
  unsigned int v38;

  v36 = 0u;
  v37 = 0u;
  *((_QWORD *)&v36 + 1) = a1[15];
  if (!a1[20])
    return 7;
  DWORD2(v37) = *((_DWORD *)a1 + 49);
  if (!*((_DWORD *)a1 + 2))
    return 0;
  v2 = 0;
  v34 = a1 + 5;
  v35 = (uint64_t *)(a1 + 18);
  while (1)
  {
    v3 = a1[14][v2];
    LODWORD(v36) = v2;
    *(_QWORD *)&v37 = 1;
    v38 = 0;
    bytes = fi_shape_get_bytes((int *)(v3 + 40), &v38);
    if ((_DWORD)bytes)
      return bytes;
    v5 = maybe_enlarge_array(*a1, v35, (unsigned int *)a1 + 38, v38);
    if ((_DWORD)v5)
    {
      v27 = v5;
      v28 = **a1;
      v29 = "enlarge pNet->glbOut failed!";
      goto LABEL_37;
    }
    v9 = *(uint64_t (**)(uint64_t))(v3 + 160);
    if (v9)
    {
      v10 = v9(v3);
      if ((_DWORD)v10)
      {
        v27 = v10;
        v30 = **a1;
        v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
        v29 = "request global buffer failed for layer %s!";
        goto LABEL_36;
      }
    }
    v11 = maybe_enlarge_array(*a1, (uint64_t *)a1 + 16, (unsigned int *)a1 + 34, *(_DWORD *)(v3 + 248));
    if ((_DWORD)v11)
    {
      v27 = v11;
      v28 = **a1;
      v29 = "enlarge global buffer failed!";
      goto LABEL_37;
    }
    *(_QWORD *)(v3 + 240) = a1[16];
    *(_DWORD *)(v3 + 248) = *((_DWORD *)a1 + 34);
    v12 = *(uint64_t (**)(uint64_t))(v3 + 168);
    if (v12)
    {
      v13 = v12(v3);
      if ((_DWORD)v13)
        break;
    }
    v14 = (*(uint64_t (**)(uint64_t **, uint64_t, uint64_t *, uint64_t *, __int128 *))(v3 + 128))(v34, v3, a1[20], a1[18], &v36);
    if ((_DWORD)v14)
    {
      v27 = v14;
      v30 = **a1;
      v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
      v29 = "forward %s layer failed!";
      goto LABEL_36;
    }
    if (DWORD1(v37) == 1)
    {
      bytes = fi_net_update_shape_from_layer(a1, v2, v15, v16, v17, v18, v19, v20);
      if ((_DWORD)bytes)
        return bytes;
    }
    v21 = (*((_DWORD *)a1 + 2) - 1);
    if ((_DWORD)v37)
    {
      if (v2 >= v21)
        goto LABEL_17;
LABEL_16:
      v22 = a1[20];
      a1[20] = a1[18];
      a1[18] = v22;
      LODWORD(v22) = *((_DWORD *)a1 + 42);
      *((_DWORD *)a1 + 42) = *((_DWORD *)a1 + 38);
      *((_DWORD *)a1 + 38) = (_DWORD)v22;
      goto LABEL_17;
    }
    if (v2 == v21)
      goto LABEL_16;
LABEL_17:
    v23 = 20;
    if (v2 >= v21)
      v23 = 18;
    v24 = a1[22];
    if (v24)
    {
      if (*(_DWORD *)(v3 + 8) == 26)
      {
        v25 = a1[v23];
        v26 = *(_QWORD *)(v3 + 120);
        if (((unsigned int (*)(uint64_t *, uint64_t, uint64_t *, uint64_t))v24)(a1[23], v26, v25, v3 + 40))
        {
          v38 = 0;
          bytes = fi_shape_get_size((int *)(v3 + 40), (int *)&v38);
          if ((_DWORD)bytes)
            return bytes;
          memcpy(*(void **)(v26 + 80), v25, *(_DWORD *)(v3 + 56) * v38);
        }
      }
    }
    if (++v2 >= *((unsigned int *)a1 + 2))
      return 0;
  }
  v27 = v13;
  v30 = **a1;
  v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
  v29 = "assign sublayer global buffer failed for layer %s!";
LABEL_36:
  v33 = (uint64_t)v31;
  v28 = v30;
LABEL_37:
  log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v6, v7, v8, v33);
  return v27;
}

uint64_t fi_net_update_shape_from_layer(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  unint64_t v10;
  _OWORD *v11;
  unint64_t v12;
  uint64_t **v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t **);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v9 = *((_DWORD *)a1 + 2);
  if (v9 <= a2)
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid layer_i: %d!", a6, a7, a8, a2);
    return 7;
  }
  else
  {
    v10 = 0;
    v11 = a1 + 9;
    v12 = a2;
    v13 = a1 + 9;
    do
    {
      v14 = a1[14][v10];
      v15 = *(uint64_t (**)(uint64_t, uint64_t **))(v14 + 144);
      if (v15)
      {
        if (v10 > v12)
        {
          v16 = v15(a1[14][v10], v13);
          if ((_DWORD)v16)
          {
            v17 = v16;
            v20 = **a1;
            v21 = fi_layer_type_to_name(*(_DWORD *)(v14 + 8));
            log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update shape of %s layer failed!", v22, v23, v24, (uint64_t)v21);
            return v17;
          }
          v9 = *((_DWORD *)a1 + 2);
        }
        v13 = (uint64_t **)(v14 + 40);
      }
      ++v10;
    }
    while (v10 < v9);
    v17 = 0;
    if (v9)
    {
      v18 = a1[14][v9 - 1];
      v19 = *(_DWORD *)(v18 + 56);
      *(_OWORD *)((char *)a1 + 92) = *(_OWORD *)(v18 + 40);
      *((_DWORD *)a1 + 27) = v19;
    }
    else
    {
      *(_OWORD *)((char *)a1 + 92) = *v11;
      *((_DWORD *)a1 + 27) = *((_DWORD *)a1 + 22);
    }
  }
  return v17;
}

uint64_t maybe_enlarge_array(uint64_t *a1, uint64_t *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t result;
  unsigned int v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = 0;
  if (a2 && a3)
  {
    v7 = a4;
    if (*a3 >= a4)
    {
      return 0;
    }
    else
    {
      if (*a2)
      {
        (*(void (**)(uint64_t))(a1[1] + 48))(a1[2]);
        *a2 = 0;
      }
      v9 = (*(uint64_t (**)(uint64_t, _QWORD))a1[1])(a1[2], v7);
      if (v9)
      {
        v13 = v9;
        result = 0;
        *a2 = v13;
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"enlarge array failed!", v10, v11, v12, v14);
        v7 = 0;
        result = 10;
      }
      *a3 = v7;
    }
  }
  return result;
}

__n128 fi_net_borrow_output_data(uint64_t a1, char *__s1, uint64_t *a3, __n128 *a4)
{
  uint64_t v4;
  uint64_t *i;
  uint64_t v9;
  __n128 result;
  unsigned __int32 v11;

  v4 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v4)
  {
    for (i = *(uint64_t **)(a1 + 112); ; ++i)
    {
      v9 = *i;
      if (*(_DWORD *)(*i + 8) == 26 && !strcmp(__s1, *(const char **)(v9 + 120)))
        break;
      if (!--v4)
        return result;
    }
    *a3 = tee_layer_get_output_buffer(v9);
    v11 = *(_DWORD *)(v9 + 56);
    result = *(__n128 *)(v9 + 40);
    *a4 = result;
    a4[1].n128_u32[0] = v11;
  }
  return result;
}

uint64_t fi_net_reset(uint64_t a1)
{
  unint64_t v2;
  unint64_t i;
  uint64_t (*v4)(void);
  uint64_t result;

  if (!a1)
    return 7;
  *(_DWORD *)(a1 + 192) = 12345;
  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * i) + 176);
      if (v4)
      {
        result = v4();
        if ((_DWORD)result)
          return result;
        v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_update_param(uint64_t a1)
{
  unint64_t v2;
  unint64_t i;
  uint64_t (*v4)(void);
  uint64_t result;

  if (!a1)
    return 7;
  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * i) + 224);
      if (v4)
      {
        result = v4();
        if ((_DWORD)result)
          return result;
        v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_give_address(uint64_t a1)
{
  unint64_t v2;
  unint64_t i;
  uint64_t (*v4)(void);
  uint64_t result;

  if (!a1)
    return 7;
  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * i) + 232);
      if (v4)
      {
        result = v4();
        if ((_DWORD)result)
          return result;
        v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_rsc_create(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t (**v5)(uint64_t, unint64_t);
  uint64_t (**v6)(uint64_t, unint64_t);
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v4 = (_QWORD *)a1[1];
  v5 = (uint64_t (**)(uint64_t, unint64_t))calloc_aligned_32_mem((uint64_t)v4, 1, 88);
  if (v5)
  {
    v6 = v5;
    v7 = calloc_aligned_32_mem((uint64_t)v4, 1, 104);
    if (v7)
    {
      v8 = v7;
      *v6 = alloc_aligned_32_mem;
      v6[1] = (uint64_t (*)(uint64_t, unint64_t))realloc_aligned_32_mem;
      v6[2] = (uint64_t (*)(uint64_t, unint64_t))calloc_aligned_32_mem;
      v6[3] = (uint64_t (*)(uint64_t, unint64_t))alloc_aligned_mem;
      v6[4] = (uint64_t (*)(uint64_t, unint64_t))realloc_aligned_mem;
      v6[5] = (uint64_t (*)(uint64_t, unint64_t))calloc_aligned_mem;
      v6[8] = (uint64_t (*)(uint64_t, unint64_t))calloc_mem;
      v6[9] = (uint64_t (*)(uint64_t, unint64_t))alloc_mem;
      v6[6] = (uint64_t (*)(uint64_t, unint64_t))free_aligned_mem;
      v6[7] = (uint64_t (*)(uint64_t, unint64_t))realloc_mem;
      v6[10] = (uint64_t (*)(uint64_t, unint64_t))free_mem;
      v7[2] = v4;
      *v7 = a1[4];
      v7[1] = v6;
      fi_thread_init((uint64_t)(v7 + 3), a1);
      *((_DWORD *)v8 + 24) = 2;
      *a2 = v8;
      log_OutText(*v8, (uint64_t)"FastInfer", 4, 0, (uint64_t)"FI GEMM macro: (None)", v9, v10, v11, v13);
      return 0;
    }
    free_aligned_mem(v4, (uint64_t)v6);
  }
  return 10;
}

_QWORD *fi_rsc_destroy(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = (uint64_t)result;
    fi_thread_deinit((uint64_t)(result + 3), (uint64_t)result);
    v2 = *(_QWORD *)(v1 + 8);
    if (v2)
    {
      free_aligned_mem(*(_QWORD **)(v1 + 16), v2);
      *(_QWORD *)(v1 + 8) = 0;
    }
    return free_aligned_mem(*(_QWORD **)(v1 + 16), v1);
  }
  return result;
}

uint64_t get_padded_len(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  BOOL v3;
  unsigned int v4;

  v2 = result / a2 * a2;
  v3 = (_DWORD)result == v2;
  v4 = a2 + v2;
  if (v3)
    return result;
  else
    return v4;
}

uint64_t get_padded_bytes(unsigned int a1, unsigned int a2)
{
  unsigned int v2;
  int v3;
  BOOL v4;
  unsigned int v5;

  v2 = a1 >> 2;
  v3 = (a1 >> 2) / a2 * a2;
  v4 = a1 >> 2 == v3;
  v5 = a2 + v3;
  if (!v4)
    v2 = v5;
  return 4 * v2;
}

uint64_t fi_thread_init(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t result;

  if (a2)
  {
    v3 = a2[50];
    *(_QWORD *)a1 = v3;
    a2 = (_QWORD *)a2[1];
  }
  else
  {
    v3 = *(_QWORD *)a1;
  }
  *(_DWORD *)(a1 + 8) = 1;
  result = semaphore_ObjectOpen(v3, a2, 1, 1, (uint64_t *)(a1 + 16));
  if ((result & 0x80000000) != 0)
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

uint64_t fi_thread_deinit(uint64_t a1, uint64_t a2)
{
  fi_rsc_checkDestroySecondThread(a2);
  return semaphore_ObjectClose(*(_QWORD *)(a1 + 16));
}

uint64_t fi_rsc_checkDestroySecondThread(uint64_t a1)
{
  uint64_t result;

  result = semaphore_Acquire(*(_QWORD **)(a1 + 40));
  if ((result & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 32) >= 2u)
    {
      *(_QWORD *)(a1 + 80) = 0;
      if ((semaphore_Release(*(_QWORD **)(a1 + 48)) & 0x80000000) == 0)
        thread_Join(*(_QWORD **)(a1 + 64));
      semaphore_ObjectClose(*(_QWORD *)(a1 + 48));
      semaphore_ObjectClose(*(_QWORD *)(a1 + 56));
      thread_ObjClose(*(_QWORD *)(a1 + 64));
      *(_DWORD *)(a1 + 32) = 1;
    }
    return semaphore_Release(*(_QWORD **)(a1 + 40));
  }
  return result;
}

uint64_t fi_rsc_checkCreateSecondThread(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  result = semaphore_Acquire(*(_QWORD **)(a1 + 40));
  if ((result & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 32) != 1)
      return semaphore_Release(*(_QWORD **)(a1 + 40));
    log_OutText(*(_QWORD *)a1, (uint64_t)"FastInfer", 2, 0, (uint64_t)"FastInfer multithreaded mode enabled", v3, v4, v5, v10);
    v6 = (uint64_t *)(a1 + 48);
    if ((semaphore_ObjectOpen(*(_QWORD *)(a1 + 24), *(_QWORD **)(a1 + 16), 0, 1, (uint64_t *)(a1 + 48)) & 0x80000000) != 0)
      goto LABEL_12;
    v7 = (uint64_t *)(a1 + 56);
    if ((semaphore_ObjectOpen(*(_QWORD *)(a1 + 24), *(_QWORD **)(a1 + 16), 0, 1, (uint64_t *)(a1 + 56)) & 0x80000000) != 0)
    {
      v8 = *v6;
    }
    else
    {
      if ((thread_ObjOpen(*(_QWORD *)(a1 + 24), *(_QWORD **)(a1 + 16), (uint64_t *)(a1 + 64)) & 0x80000000) == 0)
      {
        if (!thread_Start(*(_QWORD **)(a1 + 64)))
        {
          v9 = 2;
          goto LABEL_13;
        }
        semaphore_ObjectClose(*v6);
        semaphore_ObjectClose(*v7);
        thread_ObjClose(*(_QWORD *)(a1 + 64));
LABEL_12:
        v9 = 0;
LABEL_13:
        *(_DWORD *)(a1 + 32) = v9;
        return semaphore_Release(*(_QWORD **)(a1 + 40));
      }
      semaphore_ObjectClose(*v6);
      v8 = *v7;
    }
    semaphore_ObjectClose(v8);
    goto LABEL_12;
  }
  return result;
}

uint64_t fastinfer_workerthread(uint64_t a1)
{
  uint64_t (*v2)(uint64_t, _QWORD);

  do
  {
    if ((semaphore_Acquire(*(_QWORD **)(a1 + 48)) & 0x80000000) != 0)
      break;
    v2 = *(uint64_t (**)(uint64_t, _QWORD))(a1 + 80);
    if (!v2)
      return 0;
    *(_DWORD *)(a1 + 88) = v2(a1, *(_QWORD *)(a1 + 72));
  }
  while ((semaphore_Release(*(_QWORD **)(a1 + 56)) & 0x80000000) == 0);
  *(_DWORD *)(a1 + 88) = 512;
  return 0;
}

BOOL fi_thread_checkQueueTask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  _BOOL8 v7;

  if ((semaphore_Acquire(*(_QWORD **)(a1 + 16)) & 0x80000000) != 0)
    return 0;
  if (*(_DWORD *)(a1 + 8) == 2)
  {
    *(_QWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 56) = a3;
    v6 = semaphore_Release(*(_QWORD **)(a1 + 24));
    v7 = v6 >= 0;
    *(_DWORD *)(a1 + 8) = ~(v6 >> 31) & 3;
  }
  else
  {
    v7 = 0;
  }
  semaphore_Release(*(_QWORD **)(a1 + 16));
  return v7;
}

uint64_t fi_thread_wait4Task(uint64_t a1)
{
  int v2;

  v2 = semaphore_Acquire(*(_QWORD **)(a1 + 32));
  if ((semaphore_Acquire(*(_QWORD **)(a1 + 16)) & 0x80000000) != 0)
    return 0;
  if (v2 < 0)
    *(_DWORD *)(a1 + 64) = 512;
  *(_DWORD *)(a1 + 8) = 2;
  semaphore_Release(*(_QWORD **)(a1 + 16));
  return *(unsigned int *)(a1 + 64);
}

uint64_t fi_argmax(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  float v4;

  if (!a2)
    return 0;
  v2 = result;
  v3 = 0;
  LODWORD(result) = 0;
  v4 = 0.0;
  do
  {
    if (*(float *)(v2 + 4 * v3) <= v4)
    {
      result = result;
    }
    else
    {
      v4 = *(float *)(v2 + 4 * v3);
      result = v3;
    }
    ++v3;
  }
  while (a2 != v3);
  return result;
}

uint64_t get_bytesOfElem(unsigned int a1, _BYTE *a2)
{
  char v2;
  uint64_t result;

  if (a1 > 2)
    return 7;
  v2 = a1;
  result = 0;
  *a2 = 0x20104u >> (8 * v2);
  return result;
}

uint64_t parse_fi_binary_model_inner(uint64_t *a1, uint64_t a2, unsigned int *a3, _DWORD *a4, _QWORD *a5)
{
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t **v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t **v23;
  __int128 *v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t **v33;
  uint64_t **v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t **v51;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t bytesOfElem;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t **v143;
  unsigned int v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t **v152;
  uint64_t *v153;
  uint64_t norm_layer;
  uint64_t v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  uint64_t tee_param;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  int v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  int v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  int v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  unint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  __int128 v392;
  __int128 v393;
  __int128 v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  unint64_t v400;
  uint64_t v401;
  uint64_t v402;
  unsigned int v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  int v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t source_layer;
  uint64_t tee_layer_take_param_ownership;
  uint64_t v425;
  __int128 v426;
  __int128 v427;
  uint64_t wavernn_layer;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t sampling_layer;
  _QWORD *v435;
  uint64_t v436;
  uint64_t v437;
  unsigned int v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  unint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t mulaw_layer;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  __int128 v456;
  __int128 v457;
  uint64_t v458;
  uint64_t v459;
  __int128 v460;
  uint64_t v461;
  uint64_t v462;
  __int128 v463;
  uint64_t v464;
  uint64_t v465;
  __int128 v466;
  uint64_t v467;
  uint64_t v468;
  __int128 v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  __int128 v474;
  __int128 v475;
  uint64_t v476;
  uint64_t v477;
  __int128 v478;
  uint64_t v479;
  uint64_t v480;
  __int128 v481;
  __int128 v482;
  __int128 v483;
  uint64_t v484;
  uint64_t v485;
  __int128 v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  __int128 v492;
  uint64_t v493;
  uint64_t gl_layer;
  uint64_t v495;
  __int128 v496;
  __int128 v497;
  uint64_t v498;
  uint64_t invpreemph_layer;
  uint64_t v500;
  __int128 v501;
  __int128 v502;
  __int128 v503;
  __int128 v504;
  __int128 v505;
  uint64_t v506;
  __int128 v507;
  __int128 v508;
  __int128 v509;
  __int128 v510;
  __int128 v511;
  __int128 v512;
  __int128 v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  __int128 v552;
  __int128 v553;
  __int128 v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  __int128 v561;
  uint64_t v562;
  uint64_t v563;
  __int128 v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t convtrans1d_layer;
  uint64_t v569;
  _QWORD *v570;
  unint64_t v571;
  int v572;
  char *v573;
  unsigned int v574;
  uint64_t *v575;
  __int128 __dst[17];
  uint64_t *v577;
  unsigned int v578;
  uint64_t v579;
  uint64_t **v580;
  uint64_t **v581;

  v9 = a1;
  v581 = 0;
  v10 = fi_net_init(a1, &v581);
  if ((_DWORD)v10)
  {
    v14 = v10;
    v15 = *v9;
    v16 = "init network failed!";
LABEL_8:
    log_OutText(v15, (uint64_t)"FastInfer", 0, 0, (uint64_t)v16, v11, v12, v13, v569);
    goto LABEL_9;
  }
  *a3 = 4;
  *((_DWORD *)v581 + 2) = *(_DWORD *)(a2 + *a4);
  *a4 += *a3;
  log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v11, v12, v13, 0);
  *a3 = 12;
  v17 = v581;
  v18 = a2 + *a4;
  v19 = *(uint64_t **)v18;
  *((_DWORD *)v581 + 5) = *(_DWORD *)(v18 + 8);
  *(uint64_t **)((char *)v17 + 12) = v19;
  *a4 += *a3;
  log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v20, v21, v22, 0);
  *a3 = 20;
  v23 = v581;
  v24 = (__int128 *)(a2 + *a4);
  v25 = *v24;
  *((_DWORD *)v581 + 17) = *((_DWORD *)v24 + 4);
  *(_OWORD *)((char *)v23 + 52) = v25;
  *a4 += *a3;
  log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v26, v27, v28, 0);
  if (fi_version_cmp((uint64_t)v9, (int *)v581 + 3, "0.0.0"))
  {
    v32 = 0;
    v33 = v581;
    v581[5] = *(uint64_t **)((char *)v581 + 12);
    *((_DWORD *)v33 + 12) = *((_DWORD *)v33 + 5);
    *((_DWORD *)v33 + 6) = 0;
  }
  else
  {
    *a3 = 12;
    v34 = v581;
    v35 = a2 + *a4;
    v36 = *(_DWORD *)(v35 + 8);
    v581[5] = *(uint64_t **)v35;
    *((_DWORD *)v34 + 12) = v36;
    *a4 += *a3;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v29, v30, v31, 0);
    *a3 = 4;
    *((_DWORD *)v581 + 6) = *(_DWORD *)(a2 + *a4);
    *a4 += *a3;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v37, v38, v39, 0);
    v40 = *((_DWORD *)v581 + 6);
    *a3 = 4 * v40;
    v41 = *a4;
    v32 = (uint64_t *)(a2 + v41);
    *a4 = v41 + 4 * v40;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v42, v43, v44, 0);
    v33 = v581;
  }
  v33[4] = v32;
  log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Network layers number: ", v29, v30, v31, *((unsigned int *)v33 + 2));
  fi_shape_dump(v9, (uint64_t)v581 + 52, (uint64_t)"non-changed network model inshape: ", v45, v46, v47, v48, v49);
  v50 = fi_net_layers_init(v581);
  if ((_DWORD)v50)
  {
    v14 = v50;
    v15 = *v9;
    v16 = "init layers failed!";
    goto LABEL_8;
  }
  if (!*((_DWORD *)v581 + 2))
  {
LABEL_175:
    log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"load model done!", v11, v12, v13, v569);
    v14 = 0;
    *a5 = v581;
    return v14;
  }
  v53 = 0;
  v575 = v9;
  while (2)
  {
    v579 = 0;
    v580 = 0;
    v577 = 0;
    *a3 = 4;
    v54 = *a4;
    v578 = *(_DWORD *)(a2 + v54);
    *a4 = v54 + 4;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v11, v12, v13, (uint64_t)&byte_1DEBD87CE);
    *a3 = 4;
    v55 = *a4;
    LODWORD(v579) = *(_DWORD *)(a2 + v55);
    *a4 = v55 + 4;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v56, v57, v58, (uint64_t)&byte_1DEBD87CE);
    if (fi_feat_is_enabled((uint64_t)v581[4], 3u, *((_DWORD *)v581 + 6)))
    {
      *a3 = 4;
      v62 = *a4;
      HIDWORD(v579) = *(_DWORD *)(a2 + v62);
      *a4 = v62 + 4;
      log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v59, v60, v61, (uint64_t)&byte_1DEBD87CE);
    }
    *a3 = 8;
    v63 = *a4;
    v577 = *(uint64_t **)(a2 + v63);
    *a4 = v63 + 8;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v59, v60, v61, (uint64_t)&byte_1DEBD87CE);
    v67 = fi_layer_type_to_name(v578);
    switch(v578)
    {
      case 0u:
        *(__int128 *)((char *)__dst + 4) = 0u;
        *(__int128 *)((char *)&__dst[1] + 4) = 0u;
        *((_QWORD *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        v162 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v162);
        *a4 = v162 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v163 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v163);
        *a4 = v163 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v164, v165, v166, (uint64_t)v67);
        *a3 = 4;
        v167 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v167);
        *a4 = v167 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v168, v169, v170, (uint64_t)v67);
        *a3 = 4;
        v171 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v171);
        *a4 = v171 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v172, v173, v174, (uint64_t)v67);
        *a3 = 4;
        v175 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v175);
        *a4 = v175 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v176, v177, v178, (uint64_t)v67);
        *a3 = 4;
        v179 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v179);
        *a4 = v179 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v180, v181, v182, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v186 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v186);
          *a4 = v186 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v183, v184, v185, (uint64_t)v67);
          *a3 = 4;
          v187 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v187);
          *a4 = v187 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v188, v189, v190, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 1u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v194 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v194);
          *a4 = v194 + 4;
          v9 = v575;
          log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v191, v192, v193, (uint64_t)v67);
        }
        else
        {
          DWORD2(__dst[1]) = 1;
          v9 = v575;
        }
        v566 = create_conv1d_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), &v580);
        if (!(_DWORD)v566)
          goto LABEL_24;
        v14 = v566;
        v15 = *v9;
        v16 = "create conv1d layer failed!";
        goto LABEL_8;
      case 1u:
        *(__int128 *)((char *)__dst + 4) = 0u;
        *(__int128 *)((char *)&__dst[1] + 4) = 0u;
        *((_QWORD *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        v195 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v195);
        *a4 = v195 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v196 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v196);
        *a4 = v196 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v197, v198, v199, (uint64_t)v67);
        *a3 = 4;
        v200 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v200);
        *a4 = v200 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v201, v202, v203, (uint64_t)v67);
        *a3 = 4;
        v204 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v204);
        *a4 = v204 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v205, v206, v207, (uint64_t)v67);
        *a3 = 4;
        v208 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v208);
        *a4 = v208 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v209, v210, v211, (uint64_t)v67);
        *a3 = 4;
        v212 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v212);
        *a4 = v212 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v213, v214, v215, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v219 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v219);
          *a4 = v219 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v216, v217, v218, (uint64_t)v67);
          *a3 = 4;
          v220 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v220);
          *a4 = v220 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v221, v222, v223, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 1u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v227 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v227);
          *a4 = v227 + 4;
          v9 = v575;
          log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v224, v225, v226, (uint64_t)v67);
        }
        else
        {
          DWORD2(__dst[1]) = 1;
          v9 = v575;
        }
        v567 = create_conv2d_layer(v9, __dst, &v577, &v580);
        if (!(_DWORD)v567)
          goto LABEL_24;
        v14 = v567;
        v15 = *v9;
        v16 = "create conv2d layer failed!";
        goto LABEL_8;
      case 2u:
        *(_QWORD *)((char *)__dst + 4) = 0;
        *a3 = 4;
        v228 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v228);
        *a4 = v228 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v229 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v229);
        *a4 = v229 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v230, v231, v232, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v236 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v236);
          *a4 = v236 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v233, v234, v235, (uint64_t)v67);
        }
        v237 = create_rnn_layer(v9, (uint64_t *)&v578, (uint64_t *)__dst, &v577, (uint64_t *)&v580);
        if (!(_DWORD)v237)
          goto LABEL_24;
        v14 = v237;
        v15 = *v9;
        v16 = "create rnn layer failed!";
        goto LABEL_8;
      case 3u:
        *(_QWORD *)((char *)__dst + 4) = 0;
        *(_QWORD *)((char *)__dst + 12) = 0;
        *(_QWORD *)((char *)&__dst[1] + 4) = 0;
        *a3 = 4;
        v238 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v238);
        *a4 = v238 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v239 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v239);
        *a4 = v239 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v240, v241, v242, (uint64_t)v67);
        *a3 = 4;
        v243 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v243);
        *a4 = v243 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v244, v245, v246, (uint64_t)v67);
        *a3 = 4;
        v247 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v247);
        *a4 = v247 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v248, v249, v250, (uint64_t)v67);
        if (LODWORD(__dst[0]) == 2)
        {
          *a3 = 4;
          v254 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v254);
          *a4 = v254 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v251, v252, v253, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v258 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v258);
          *a4 = v258 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v255, v256, v257, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 6u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v262 = *a4;
          DWORD1(__dst[1]) = *(_DWORD *)(a2 + v262);
          *a4 = v262 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v259, v260, v261, (uint64_t)v67);
        }
        v263 = create_lstm_layer(v9, &v578, __dst, &v577, v581 + 1, &v580);
        if (!(_DWORD)v263)
          goto LABEL_24;
        v14 = v263;
        v15 = *v9;
        v16 = "create lstm layer failed!";
        goto LABEL_8;
      case 4u:
        *(_QWORD *)((char *)__dst + 4) = 0;
        *(_QWORD *)((char *)__dst + 12) = 0;
        *(_QWORD *)((char *)&__dst[1] + 4) = 0;
        *a3 = 4;
        v264 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v264);
        *a4 = v264 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v265 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v265);
        *a4 = v265 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v266, v267, v268, (uint64_t)v67);
        *a3 = 4;
        v269 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v269);
        *a4 = v269 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v270, v271, v272, (uint64_t)v67);
        *a3 = 4;
        v273 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v273);
        *a4 = v273 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v274, v275, v276, (uint64_t)v67);
        if (LODWORD(__dst[0]) == 2)
        {
          *a3 = 4;
          v280 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v280);
          *a4 = v280 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v277, v278, v279, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v284 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v284);
          *a4 = v284 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v281, v282, v283, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 6u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v288 = *a4;
          DWORD1(__dst[1]) = *(_DWORD *)(a2 + v288);
          *a4 = v288 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v285, v286, v287, (uint64_t)v67);
        }
        v289 = create_blstm_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v289)
          goto LABEL_24;
        v14 = v289;
        v15 = *v9;
        v16 = "create blstm layer failed!";
        goto LABEL_8;
      case 5u:
        *(_QWORD *)&__dst[0] = 0;
        *a3 = 4;
        v290 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v290);
        *a4 = v290 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 5u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v294 = *a4;
          DWORD1(__dst[0]) = *(_DWORD *)(a2 + v294);
          *a4 = v294 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v291, v292, v293, (uint64_t)v67);
        }
        else
        {
          DWORD1(__dst[0]) = 1;
        }
        tee_param = create_fc_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 6u:
        *a3 = 4;
        v295 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v295);
        *a4 = v295 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v296 = create_softmax_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t *)&v580);
        if (!(_DWORD)v296)
          goto LABEL_24;
        v14 = v296;
        v15 = *v9;
        v16 = "create softmax layer failed!";
        goto LABEL_8;
      case 7u:
        *a3 = 4;
        v297 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v297);
        *a4 = v297 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v298 = create_flatten_layer(v9, __dst, &v580);
        if (!(_DWORD)v298)
          goto LABEL_24;
        v14 = v298;
        v15 = *v9;
        v16 = "create flatten layer failed!";
        goto LABEL_8;
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
        v68 = v53;
        *(__int128 *)((char *)__dst + 4) = 0u;
        *(__int128 *)((char *)&__dst[1] + 4) = 0u;
        *((_QWORD *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        v69 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v69);
        *a4 = v69 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v70 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v70);
        *a4 = v70 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v71, v72, v73, (uint64_t)v67);
        *a3 = 4;
        v74 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v74);
        *a4 = v74 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v75, v76, v77, (uint64_t)v67);
        *a3 = 4;
        v78 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v78);
        *a4 = v78 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v79, v80, v81, (uint64_t)v67);
        *a3 = 4;
        v82 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v82);
        *a4 = v82 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v83, v84, v85, (uint64_t)v67);
        *a3 = 4;
        v86 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v86);
        *a4 = v86 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v87, v88, v89, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v93 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v93);
          *a4 = v93 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v90, v91, v92, (uint64_t)v67);
          *a3 = 4;
          v94 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v94);
          *a4 = v94 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v95, v96, v97, (uint64_t)v67);
        }
        v98 = create_pooling1d_layer(v9, v578, __dst, &v577, &v580);
        if (!(_DWORD)v98)
          goto LABEL_23;
        v14 = v98;
        v15 = *v9;
        v16 = "create pooling1d layer failed!";
        goto LABEL_8;
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        v68 = v53;
        *(__int128 *)((char *)__dst + 4) = 0u;
        *(__int128 *)((char *)&__dst[1] + 4) = 0u;
        *((_QWORD *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        v99 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v99);
        *a4 = v99 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v100 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v100);
        *a4 = v100 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v101, v102, v103, (uint64_t)v67);
        *a3 = 4;
        v104 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v104);
        *a4 = v104 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v105, v106, v107, (uint64_t)v67);
        *a3 = 4;
        v108 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v108);
        *a4 = v108 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v109, v110, v111, (uint64_t)v67);
        *a3 = 4;
        v112 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v112);
        *a4 = v112 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v113, v114, v115, (uint64_t)v67);
        *a3 = 4;
        v116 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v116);
        *a4 = v116 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v117, v118, v119, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v123 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v123);
          *a4 = v123 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v120, v121, v122, (uint64_t)v67);
          *a3 = 4;
          v124 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v124);
          *a4 = v124 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v125, v126, v127, (uint64_t)v67);
        }
        v128 = create_pooling2d_layer(v9, v578, __dst, &v577, &v580);
        if ((_DWORD)v128)
        {
          v14 = v128;
          v15 = *v9;
          v16 = "create pooling2d layer failed!";
          goto LABEL_8;
        }
LABEL_23:
        v53 = v68;
        goto LABEL_24;
      case 0x14u:
        memset(__dst, 0, 56);
        *a3 = 4;
        v299 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v299);
        *a4 = v299 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v300 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v300);
        *a4 = v300 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v301, v302, v303, (uint64_t)v67);
        v304 = DWORD1(__dst[0]);
        *a3 = DWORD1(__dst[0]);
        v305 = *a4;
        *((_QWORD *)&__dst[0] + 1) = a2 + v305;
        *a4 = v305 + v304;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v306, v307, v308, (uint64_t)v67);
        *a3 = 4;
        v309 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v309);
        *a4 = v309 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v310, v311, v312, (uint64_t)v67);
        if (LODWORD(__dst[1]))
        {
          v316 = LODWORD(__dst[0]) * LODWORD(__dst[0]);
          *a3 = 4 * LODWORD(__dst[0]) * LODWORD(__dst[0]);
          v317 = *a4;
          v318 = a2 + v317;
          *a4 = v317 + 4 * v316;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v313, v314, v315, (uint64_t)v67);
          *((_QWORD *)&__dst[1] + 1) = v318;
        }
        *a3 = 4;
        v319 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v319);
        *a4 = v319 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v313, v314, v315, (uint64_t)v67);
        if (LODWORD(__dst[2]))
        {
          v323 = __dst[0];
          *a3 = 4 * LODWORD(__dst[0]);
          v324 = *a4;
          v325 = a2 + v324;
          *a4 = v324 + 4 * v323;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v320, v321, v322, (uint64_t)v67);
          *((_QWORD *)&__dst[2] + 1) = v325;
        }
        LODWORD(__dst[3]) = 0;
        v326 = create_label_layer(v9, (unsigned int *)__dst, &v577, (uint64_t *)&v580);
        if (!(_DWORD)v326)
          goto LABEL_24;
        v14 = v326;
        v15 = *v9;
        v16 = "create label layer failed!";
        goto LABEL_8;
      case 0x15u:
        *a3 = 4;
        v327 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v327);
        *a4 = v327 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v331 = create_repeat_layer(v9, (uint64_t *)&v578, __dst, &v577, &v580, v328, v329, v330);
        if (!(_DWORD)v331)
          goto LABEL_24;
        v14 = v331;
        v15 = *v9;
        v16 = "create repeat layer failed!";
        goto LABEL_8;
      case 0x16u:
      case 0x28u:
        norm_layer = create_norm_layer(v9, (uint64_t *)&v578, (uint64_t *)&v580);
        if (!(_DWORD)norm_layer)
          goto LABEL_24;
        v14 = norm_layer;
        v15 = *v9;
        v16 = "create norm layer failed!";
        goto LABEL_8;
      case 0x17u:
        *(_QWORD *)((char *)__dst + 4) = 0;
        *(_QWORD *)((char *)__dst + 12) = 0;
        *a3 = 4;
        v332 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v332);
        *a4 = v332 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v333 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v333);
        *a4 = v333 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v334, v335, v336, (uint64_t)v67);
        *a3 = 4;
        v337 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v337);
        *a4 = v337 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v338, v339, v340, (uint64_t)v67);
        *a3 = 4;
        v341 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v341);
        *a4 = v341 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v342, v343, v344, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v348 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v348);
          *a4 = v348 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v345, v346, v347, (uint64_t)v67);
        }
        v349 = create_gru_layer(v9, (uint64_t)&v578, __dst, &v577, (uint64_t)(v581 + 1), &v580);
        if (!(_DWORD)v349)
          goto LABEL_24;
        v14 = v349;
        v15 = *v9;
        v16 = "create gru layer failed!";
        goto LABEL_8;
      case 0x18u:
        *(_QWORD *)((char *)__dst + 4) = 0;
        *(_QWORD *)((char *)__dst + 12) = 0;
        *a3 = 4;
        v350 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v350);
        *a4 = v350 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v351 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v351);
        *a4 = v351 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v352, v353, v354, (uint64_t)v67);
        *a3 = 4;
        v355 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v355);
        *a4 = v355 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v356, v357, v358, (uint64_t)v67);
        *a3 = 4;
        v359 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v359);
        *a4 = v359 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v360, v361, v362, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v366 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v366);
          *a4 = v366 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v363, v364, v365, (uint64_t)v67);
        }
        v367 = create_bgru_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v367)
          goto LABEL_24;
        v14 = v367;
        v15 = *v9;
        v16 = "create bgru layer failed!";
        goto LABEL_8;
      case 0x19u:
        v570 = a5;
        v368 = v53;
        *a3 = 4;
        v369 = *a4;
        v572 = *(_DWORD *)(a2 + v369);
        *a4 = v369 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v370 = *a4;
        v371 = *(unsigned int *)(a2 + v370);
        *a4 = v370 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v372, v373, v374, (uint64_t)v67);
        v375 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], v371, 8);
        if (!v375)
        {
          log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v376, v377, v378, v569);
          v14 = 0;
          *v570 = v581;
          return v14;
        }
        v379 = v375;
        v380 = v371;
        v381 = v375;
        if ((_DWORD)v371)
        {
          while (1)
          {
            v382 = parse_fi_binary_model_inner(v9, a2, a3, a4, v381);
            if ((_DWORD)v382)
              break;
            v381 += 8;
            if (!--v380)
              goto LABEL_88;
          }
          v14 = v382;
          log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"parse nest layer submodel failed!", v383, v384, v385, v569);
LABEL_180:
          a5 = v570;
          goto LABEL_9;
        }
LABEL_88:
        v386 = create_nest_layer(v9, v572, v371, v379, &v580);
        v53 = v368;
        a5 = v570;
        if ((_DWORD)v386)
        {
          v14 = v386;
          v15 = *v9;
          v16 = "create nest layer failed!";
          goto LABEL_8;
        }
        goto LABEL_24;
      case 0x1Au:
        *(_QWORD *)&__dst[0] = 0;
        tee_param = create_tee_param(v9, (uint64_t *)__dst);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        *a3 = 72;
        v390 = *(_QWORD *)&__dst[0];
        v391 = a2 + *a4;
        **(_OWORD **)&__dst[0] = *(_OWORD *)v391;
        v393 = *(_OWORD *)(v391 + 32);
        v392 = *(_OWORD *)(v391 + 48);
        v394 = *(_OWORD *)(v391 + 16);
        *(_QWORD *)(v390 + 64) = *(_QWORD *)(v391 + 64);
        *(_OWORD *)(v390 + 32) = v393;
        *(_OWORD *)(v390 + 48) = v392;
        *(_OWORD *)(v390 + 16) = v394;
        *a4 += *a3;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v387, v388, v389, (uint64_t)v67);
        v395 = tee_param_alloc_sources(v9, *(uint64_t *)&__dst[0]);
        if ((_DWORD)v395)
        {
          v14 = v395;
          free_tee_param((uint64_t)v9, *(uint64_t *)&__dst[0]);
          goto LABEL_9;
        }
        v570 = a5;
        v571 = v53;
        if (*(_DWORD *)(*(_QWORD *)&__dst[0] + 68))
        {
          v399 = 0;
          v400 = 0;
          while (1)
          {
            *a3 = 4;
            v401 = *a4;
            v402 = a2;
            v403 = *(_DWORD *)(a2 + v401);
            *a4 = v401 + 4;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v396, v397, v398, (uint64_t)v67);
            *a3 = v403;
            v404 = *a4;
            v573 = (char *)(v402 + v404);
            *a4 = v404 + v403;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v405, v406, v407, (uint64_t)v67);
            *a3 = 4;
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&__dst[0] + 72) + v399 + 8) = *(_DWORD *)(v402 + *a4);
            *a4 += *a3;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v408, v409, v410, (uint64_t)v67);
            *a3 = 4;
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&__dst[0] + 72) + v399 + 12) = *(_DWORD *)(v402 + *a4);
            *a4 += *a3;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v411, v412, v413, (uint64_t)v67);
            *a3 = 4;
            v414 = *a4;
            v415 = *(_DWORD *)(v402 + v414);
            *a4 = v414 + 4;
            v9 = v575;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v416, v417, v418, (uint64_t)v67);
            v419 = *(_QWORD *)(*(_QWORD *)&__dst[0] + 72) + v399;
            *(_DWORD *)(v419 + 16) = v415;
            source_layer = tee_source_cfg_get_source_layer(v575, (_QWORD *)v419, v573, v581[14], v571, v420, v421, v422);
            if ((_DWORD)source_layer)
              break;
            ++v400;
            v399 += 24;
            a2 = v402;
            if (v400 >= *(unsigned int *)(*(_QWORD *)&__dst[0] + 68))
              goto LABEL_96;
          }
          v14 = source_layer;
          free_tee_param((uint64_t)v575, *(uint64_t *)&__dst[0]);
          goto LABEL_180;
        }
LABEL_96:
        tee_layer_take_param_ownership = create_tee_layer_take_param_ownership(v9, (uint64_t *)__dst, (uint64_t *)&v580);
        if ((_DWORD)tee_layer_take_param_ownership)
        {
          v14 = tee_layer_take_param_ownership;
          free_tee_param((uint64_t)v9, *(uint64_t *)&__dst[0]);
          v15 = *v9;
          v16 = "create tee layer failed!";
          goto LABEL_8;
        }
        v53 = v571;
        goto LABEL_24;
      case 0x1Bu:
        *a3 = 64;
        v425 = *a4;
        v426 = *(_OWORD *)(a2 + v425 + 16);
        __dst[0] = *(_OWORD *)(a2 + v425);
        __dst[1] = v426;
        v427 = *(_OWORD *)(a2 + v425 + 48);
        __dst[2] = *(_OWORD *)(a2 + v425 + 32);
        __dst[3] = v427;
        *a4 = v425 + 64;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        wavernn_layer = create_wavernn_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t)(v581 + 24), (uint64_t *)&v580);
        if (!(_DWORD)wavernn_layer)
          goto LABEL_24;
        v14 = wavernn_layer;
        v15 = *v9;
        v16 = "create wavernn layer failed!";
        goto LABEL_8;
      case 0x1Cu:
        *(_QWORD *)&__dst[0] = 0;
        *a3 = 4;
        v429 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v429);
        *a4 = v429 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v430 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v430);
        *a4 = v430 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v431, v432, v433, (uint64_t)v67);
        sampling_layer = create_sampling_layer(v9, __dst, (uint64_t)(v581 + 24), (uint64_t *)&v580);
        if (!(_DWORD)sampling_layer)
          goto LABEL_24;
        v14 = sampling_layer;
        v15 = *v9;
        v16 = "create sampling layer failed!";
        goto LABEL_8;
      case 0x1Fu:
        v435 = a5;
        *a3 = 4;
        v436 = *a4;
        v574 = *(_DWORD *)(a2 + v436);
        __dst[0] = 0uLL;
        *a4 = v436 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v437 = *a4;
        v438 = *(_DWORD *)(a2 + v437);
        *a4 = v437 + 4;
        log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v439, v440, v441, (uint64_t)v67);
        *a3 = v438;
        v442 = *a4;
        v443 = v53;
        v444 = a2 + v442;
        *a4 = v442 + v438;
        v9 = v575;
        log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v445, v446, v447, (uint64_t)v67);
        v448 = v444;
        v53 = v443;
        v449 = config_merge_layer_param(v575, (uint64_t)__dst, v574, v448, v581[14], v443);
        if (!(_DWORD)v449)
        {
          v450 = create_merge_layer(v575, __dst, &v580);
          a5 = v435;
          if ((_DWORD)v450)
          {
            v14 = v450;
            v15 = *v575;
            v16 = "create merge layer failed!";
            goto LABEL_8;
          }
LABEL_24:
          if (fi_layer_if_has_weights(v578) == 1)
          {
            LOBYTE(__dst[0]) = 0;
            bytesOfElem = get_bytesOfElem(*((_DWORD *)v581 + 12), __dst);
            if ((_DWORD)bytesOfElem)
            {
              v14 = bytesOfElem;
              v15 = *v9;
              v16 = "get bytes of elem failed!";
              goto LABEL_8;
            }
            *a3 = 4;
            *((_DWORD *)v580 + 20) = *(_DWORD *)(a2 + *a4);
            *a4 += *a3;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v11, v12, v13, (uint64_t)v67);
            *a3 = 4;
            *((_DWORD *)v580 + 24) = *(_DWORD *)(a2 + *a4);
            *a4 += *a3;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v133, v134, v135, (uint64_t)v67);
            *a3 = 4;
            *((_DWORD *)v580 + 28) = *(_DWORD *)(a2 + *a4);
            *a4 += *a3;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v136, v137, v138, (uint64_t)v67);
            v139 = *a4;
            *a4 += 32 - (*a4 & 0x1F);
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"Skip PADDING Bytes [start, len, end]:  %d,  %d, %d", v140, v141, v142, v139);
            v143 = v580;
            v144 = *((_DWORD *)v580 + 20) / LOBYTE(__dst[0]) * LOBYTE(__dst[0]);
            *a3 = v144;
            v145 = *a4;
            v143[9] = (uint64_t *)(a2 + v145);
            *a4 = v145 + v144;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v146, v147, v148, (uint64_t)v67);
            log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Layer:%s, weights bytes: %d, biases bytes: %d, total bytes: %d", v149, v150, v151, (uint64_t)v67);
            v152 = v580;
            v153 = v580[9];
            v580[13] = (uint64_t *)((char *)v153 + *((unsigned int *)v580 + 24));
            v152[11] = v153;
          }
          else
          {
            log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Layer %s does not have weights and biases, skipped.", v129, v130, v131, (uint64_t)v67);
            v152 = v580;
          }
          v581[14][v53++] = (uint64_t)v152;
          if (v53 >= *((unsigned int *)v581 + 2))
            goto LABEL_175;
          continue;
        }
        v14 = v449;
        a5 = v435;
LABEL_9:
        v51 = v581;
        *a5 = v581;
        fi_net_destroy((uint64_t)v51);
        return v14;
      case 0x20u:
        *a3 = 4;
        v451 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v451);
        *a4 = v451 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        mulaw_layer = create_mulaw_layer(v9, __dst, (uint64_t *)&v580);
        if (!(_DWORD)mulaw_layer)
          goto LABEL_24;
        v14 = mulaw_layer;
        v15 = *v9;
        v16 = "create mulaw layer failed!";
        goto LABEL_8;
      case 0x21u:
        *a3 = 20;
        v453 = *a4;
        __dst[0] = *(_OWORD *)(a2 + v453);
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v453 + 16);
        *a4 = v453 + 20;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v454 = create_ffn_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v454)
          goto LABEL_24;
        v14 = v454;
        v15 = *v9;
        v16 = "create ffn layer failed!";
        goto LABEL_8;
      case 0x22u:
        *a3 = 64;
        v455 = *a4;
        v456 = *(_OWORD *)(a2 + v455 + 16);
        __dst[0] = *(_OWORD *)(a2 + v455);
        __dst[1] = v456;
        v457 = *(_OWORD *)(a2 + v455 + 48);
        __dst[2] = *(_OWORD *)(a2 + v455 + 32);
        __dst[3] = v457;
        *a4 = v455 + 64;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v458 = create_att_layer(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v458)
          goto LABEL_24;
        v14 = v458;
        v15 = *v9;
        v16 = "create att layer failed!";
        goto LABEL_8;
      case 0x23u:
        *a3 = 44;
        v459 = *a4;
        v460 = *(_OWORD *)(a2 + v459 + 16);
        __dst[0] = *(_OWORD *)(a2 + v459);
        __dst[1] = v460;
        *(__int128 *)((char *)&__dst[1] + 12) = *(_OWORD *)(a2 + v459 + 28);
        *a4 = v459 + 44;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v461 = create_trans_enc_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v461)
          goto LABEL_24;
        v14 = v461;
        v15 = *v9;
        v16 = "create trans_enc layer failed!";
        goto LABEL_8;
      case 0x24u:
        *a3 = 48;
        v462 = *a4;
        v463 = *(_OWORD *)(a2 + v462 + 16);
        __dst[0] = *(_OWORD *)(a2 + v462);
        __dst[1] = v463;
        __dst[2] = *(_OWORD *)(a2 + v462 + 32);
        *a4 = v462 + 48;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v464 = create_trans_encoder(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v464)
          goto LABEL_24;
        v14 = v464;
        v15 = *v9;
        v16 = "create trans_encoder failed!";
        goto LABEL_8;
      case 0x25u:
        *a3 = 52;
        v465 = *a4;
        v466 = *(_OWORD *)(a2 + v465 + 16);
        __dst[0] = *(_OWORD *)(a2 + v465);
        __dst[1] = v466;
        __dst[2] = *(_OWORD *)(a2 + v465 + 32);
        LODWORD(__dst[3]) = *(_DWORD *)(a2 + v465 + 48);
        *a4 = v465 + 52;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v467 = create_trans_dec_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v467)
          goto LABEL_24;
        v14 = v467;
        v15 = *v9;
        v16 = "create trans_dec layer failed!";
        goto LABEL_8;
      case 0x26u:
        *a3 = 56;
        v468 = *a4;
        v469 = *(_OWORD *)(a2 + v468 + 16);
        __dst[0] = *(_OWORD *)(a2 + v468);
        __dst[1] = v469;
        __dst[2] = *(_OWORD *)(a2 + v468 + 32);
        *(_QWORD *)&__dst[3] = *(_QWORD *)(a2 + v468 + 48);
        *a4 = v468 + 56;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v470 = create_trans_decoder(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v470)
          goto LABEL_24;
        v14 = v470;
        v15 = *v9;
        v16 = "create trans_decoder failed!";
        goto LABEL_8;
      case 0x27u:
        *a3 = 8;
        v471 = *a4;
        *(_QWORD *)&__dst[0] = *(_QWORD *)(a2 + v471);
        *a4 = v471 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v472 = create_embedding_layer(v9, (uint64_t *)__dst, &v580);
        if (!(_DWORD)v472)
          goto LABEL_24;
        v14 = v472;
        v15 = *v9;
        v16 = "create embedding layer failed!";
        goto LABEL_8;
      case 0x29u:
        *a3 = 72;
        v473 = *a4;
        v474 = *(_OWORD *)(a2 + v473 + 48);
        __dst[2] = *(_OWORD *)(a2 + v473 + 32);
        __dst[3] = v474;
        *(_QWORD *)&__dst[4] = *(_QWORD *)(a2 + v473 + 64);
        v475 = *(_OWORD *)(a2 + v473 + 16);
        __dst[0] = *(_OWORD *)(a2 + v473);
        __dst[1] = v475;
        *a4 = v473 + 72;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v476 = create_att_albert_layer(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v476)
          goto LABEL_24;
        v14 = v476;
        v15 = *v9;
        v16 = "create att albert layer failed!";
        goto LABEL_8;
      case 0x2Au:
        *a3 = 48;
        v477 = *a4;
        v478 = *(_OWORD *)(a2 + v477 + 16);
        __dst[0] = *(_OWORD *)(a2 + v477);
        __dst[1] = v478;
        __dst[2] = *(_OWORD *)(a2 + v477 + 32);
        *a4 = v477 + 48;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v479 = create_albert_trans_enc_layer(v9, (uint64_t)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v479)
          goto LABEL_24;
        v14 = v479;
        v15 = *v9;
        v16 = "create albert trans_enc layer failed!";
        goto LABEL_8;
      case 0x2Bu:
        *a3 = 96;
        v480 = *a4;
        v481 = *(_OWORD *)(a2 + v480 + 48);
        __dst[2] = *(_OWORD *)(a2 + v480 + 32);
        __dst[3] = v481;
        v482 = *(_OWORD *)(a2 + v480 + 80);
        __dst[4] = *(_OWORD *)(a2 + v480 + 64);
        __dst[5] = v482;
        v483 = *(_OWORD *)(a2 + v480 + 16);
        __dst[0] = *(_OWORD *)(a2 + v480);
        __dst[1] = v483;
        *a4 = v480 + 96;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v484 = create_albert_trans_encoder(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)v484)
          goto LABEL_24;
        v14 = v484;
        v15 = *v9;
        v16 = "create albert trans_encoder failed!";
        goto LABEL_8;
      case 0x32u:
        *a3 = 36;
        v485 = *a4;
        v486 = *(_OWORD *)(a2 + v485 + 16);
        __dst[0] = *(_OWORD *)(a2 + v485);
        __dst[1] = v486;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v485 + 32);
        *a4 = v485 + 36;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_conv1d_norm_layer(v9, (uint64_t)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x33u:
        *a3 = 8;
        v487 = *a4;
        *(_QWORD *)&__dst[0] = *(_QWORD *)(a2 + v487);
        *a4 = v487 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_conv1d_bank(v9, (uint64_t *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x34u:
        *a3 = 16;
        v488 = *a4;
        __dst[0] = *(_OWORD *)(a2 + v488);
        *a4 = v488 + 16;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_conv1d_proj_layer(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x35u:
        *a3 = 8;
        v489 = *a4;
        *(_QWORD *)&__dst[0] = *(_QWORD *)(a2 + v489);
        *a4 = v489 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_highway_layer(v9, (uint64_t *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x36u:
        *a3 = 12;
        v490 = *a4;
        *(_QWORD *)&__dst[0] = *(_QWORD *)(a2 + v490);
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v490 + 8);
        *a4 = v490 + 12;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_highways(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x37u:
        *a3 = 36;
        v491 = *a4;
        v492 = *(_OWORD *)(a2 + v491 + 16);
        __dst[0] = *(_OWORD *)(a2 + v491);
        __dst[1] = v492;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v491 + 32);
        *a4 = v491 + 36;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_cbhg_layer(v9, (uint64_t)__dst, &v577, (uint64_t)(v581 + 1), &v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x38u:
        *a3 = 24;
        v493 = *a4;
        __dst[0] = *(_OWORD *)(a2 + v493);
        *(_QWORD *)&__dst[1] = *(_QWORD *)(a2 + v493 + 16);
        *a4 = v493 + 24;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        gl_layer = create_gl_layer(v9, (uint64_t *)&v578, __dst, (uint64_t *)&v580);
        if (!(_DWORD)gl_layer)
          goto LABEL_24;
        v14 = gl_layer;
        v15 = *v9;
        v16 = "create gl layer failed!";
        goto LABEL_8;
      case 0x3Eu:
        *a3 = 88;
        v495 = *a4;
        v496 = *(_OWORD *)(a2 + v495 + 48);
        __dst[2] = *(_OWORD *)(a2 + v495 + 32);
        __dst[3] = v496;
        __dst[4] = *(_OWORD *)(a2 + v495 + 64);
        *(_QWORD *)&__dst[5] = *(_QWORD *)(a2 + v495 + 80);
        v497 = *(_OWORD *)(a2 + v495 + 16);
        __dst[0] = *(_OWORD *)(a2 + v495);
        __dst[1] = v497;
        *a4 = v495 + 88;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_tacodecoder_layer(v9, (uint64_t)__dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x3Fu:
      case 0x42u:
        *a3 = 188;
        v155 = *a4;
        v156 = *(_OWORD *)(a2 + v155 + 144);
        __dst[8] = *(_OWORD *)(a2 + v155 + 128);
        __dst[9] = v156;
        __dst[10] = *(_OWORD *)(a2 + v155 + 160);
        *(__int128 *)((char *)&__dst[10] + 12) = *(_OWORD *)(a2 + v155 + 172);
        v157 = *(_OWORD *)(a2 + v155 + 80);
        __dst[4] = *(_OWORD *)(a2 + v155 + 64);
        __dst[5] = v157;
        v158 = *(_OWORD *)(a2 + v155 + 112);
        __dst[6] = *(_OWORD *)(a2 + v155 + 96);
        __dst[7] = v158;
        v159 = *(_OWORD *)(a2 + v155 + 16);
        __dst[0] = *(_OWORD *)(a2 + v155);
        __dst[1] = v159;
        v160 = *(_OWORD *)(a2 + v155 + 48);
        __dst[2] = *(_OWORD *)(a2 + v155 + 32);
        __dst[3] = v160;
        *a4 = v155 + 188;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_tacotron(v9, __dst, &v577, (uint64_t)(v581 + 1), v578, (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x40u:
        *a3 = 8;
        v498 = *a4;
        *(_QWORD *)&__dst[0] = *(_QWORD *)(a2 + v498);
        *a4 = v498 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        invpreemph_layer = create_invpreemph_layer(v9, (uint64_t *)&v578, __dst, (uint64_t *)&v580);
        if (!(_DWORD)invpreemph_layer)
          goto LABEL_24;
        v14 = invpreemph_layer;
        v15 = *v9;
        v16 = "create invpreemph layer failed!";
        goto LABEL_8;
      case 0x41u:
        *a3 = 180;
        v500 = *a4;
        v501 = *(_OWORD *)(a2 + v500 + 144);
        __dst[8] = *(_OWORD *)(a2 + v500 + 128);
        __dst[9] = v501;
        __dst[10] = *(_OWORD *)(a2 + v500 + 160);
        LODWORD(__dst[11]) = *(_DWORD *)(a2 + v500 + 176);
        v502 = *(_OWORD *)(a2 + v500 + 80);
        __dst[4] = *(_OWORD *)(a2 + v500 + 64);
        __dst[5] = v502;
        v503 = *(_OWORD *)(a2 + v500 + 112);
        __dst[6] = *(_OWORD *)(a2 + v500 + 96);
        __dst[7] = v503;
        v504 = *(_OWORD *)(a2 + v500 + 16);
        __dst[0] = *(_OWORD *)(a2 + v500);
        __dst[1] = v504;
        v505 = *(_OWORD *)(a2 + v500 + 48);
        __dst[2] = *(_OWORD *)(a2 + v500 + 32);
        __dst[3] = v505;
        *a4 = v500 + 180;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_lpcnet_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x43u:
        *a3 = 244;
        v506 = *a4;
        v507 = *(_OWORD *)(a2 + v506 + 208);
        __dst[12] = *(_OWORD *)(a2 + v506 + 192);
        __dst[13] = v507;
        __dst[14] = *(_OWORD *)(a2 + v506 + 224);
        LODWORD(__dst[15]) = *(_DWORD *)(a2 + v506 + 240);
        v508 = *(_OWORD *)(a2 + v506 + 144);
        __dst[8] = *(_OWORD *)(a2 + v506 + 128);
        __dst[9] = v508;
        v509 = *(_OWORD *)(a2 + v506 + 176);
        __dst[10] = *(_OWORD *)(a2 + v506 + 160);
        __dst[11] = v509;
        v510 = *(_OWORD *)(a2 + v506 + 80);
        __dst[4] = *(_OWORD *)(a2 + v506 + 64);
        __dst[5] = v510;
        v511 = *(_OWORD *)(a2 + v506 + 112);
        __dst[6] = *(_OWORD *)(a2 + v506 + 96);
        __dst[7] = v511;
        v512 = *(_OWORD *)(a2 + v506 + 16);
        __dst[0] = *(_OWORD *)(a2 + v506);
        __dst[1] = v512;
        v513 = *(_OWORD *)(a2 + v506 + 48);
        __dst[2] = *(_OWORD *)(a2 + v506 + 32);
        __dst[3] = v513;
        *a4 = v506 + 244;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_multiband_lpcnet_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x44u:
        *a3 = 264;
        v514 = *a4;
        memcpy(__dst, (const void *)(a2 + v514), 0x108uLL);
        *a4 = v514 + 264;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v515, v516, v517, (uint64_t)v67);
        tee_param = create_tacotron_stream(v9, (int32x2_t *)__dst, &v577, (uint64_t)(v581 + 1), v578, (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x45u:
        *(__int128 *)((char *)__dst + 4) = 0u;
        *(__int128 *)((char *)&__dst[1] + 4) = 0u;
        *((_QWORD *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        v518 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v518);
        *a4 = v518 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v519 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v519);
        *a4 = v519 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v520, v521, v522, (uint64_t)v67);
        *a3 = 4;
        v523 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v523);
        *a4 = v523 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v524, v525, v526, (uint64_t)v67);
        *a3 = 4;
        v527 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v527);
        *a4 = v527 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v528, v529, v530, (uint64_t)v67);
        *a3 = 4;
        v531 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v531);
        *a4 = v531 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v532, v533, v534, (uint64_t)v67);
        *a3 = 4;
        v535 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v535);
        *a4 = v535 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v536, v537, v538, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v542 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v542);
          *a4 = v542 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v539, v540, v541, (uint64_t)v67);
          *a3 = 4;
          v543 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v543);
          *a4 = v543 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v544, v545, v546, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 1u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          v550 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v550);
          *a4 = v550 + 4;
          v9 = v575;
          log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v547, v548, v549, (uint64_t)v67);
        }
        else
        {
          DWORD2(__dst[1]) = 1;
          v9 = v575;
        }
        convtrans1d_layer = create_convtrans1d_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!(_DWORD)convtrans1d_layer)
          goto LABEL_24;
        v14 = convtrans1d_layer;
        v15 = *v9;
        v16 = "create convtrans1d layer failed!";
        goto LABEL_8;
      case 0x46u:
        *a3 = 120;
        v551 = *a4;
        v552 = *(_OWORD *)(a2 + v551 + 80);
        __dst[4] = *(_OWORD *)(a2 + v551 + 64);
        __dst[5] = v552;
        __dst[6] = *(_OWORD *)(a2 + v551 + 96);
        *(_QWORD *)&__dst[7] = *(_QWORD *)(a2 + v551 + 112);
        v553 = *(_OWORD *)(a2 + v551 + 16);
        __dst[0] = *(_OWORD *)(a2 + v551);
        __dst[1] = v553;
        v554 = *(_OWORD *)(a2 + v551 + 48);
        __dst[2] = *(_OWORD *)(a2 + v551 + 32);
        __dst[3] = v554;
        *a4 = v551 + 120;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        tee_param = create_mrf_layer(v9, (unsigned int *)__dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if ((_DWORD)tee_param)
          goto LABEL_177;
        goto LABEL_24;
      case 0x47u:
        *(_QWORD *)&__dst[0] = 0;
        *a3 = 4;
        v555 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v555);
        *a4 = v555 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        v556 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v556);
        *a4 = v556 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v557, v558, v559, (uint64_t)v67);
        tee_param = create_pqmf_layer(v9, __dst, &v580);
        if (!(_DWORD)tee_param)
          goto LABEL_24;
LABEL_177:
        v14 = tee_param;
        goto LABEL_9;
      case 0x48u:
        *a3 = 44;
        v560 = *a4;
        v561 = *(_OWORD *)(a2 + v560 + 16);
        __dst[0] = *(_OWORD *)(a2 + v560);
        __dst[1] = v561;
        *(__int128 *)((char *)&__dst[1] + 12) = *(_OWORD *)(a2 + v560 + 28);
        *a4 = v560 + 44;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v562 = create_reshape_layer(v9, __dst, &v580);
        if (!(_DWORD)v562)
          goto LABEL_24;
        v14 = v562;
        v15 = *v9;
        v16 = "create reshape layer failed!";
        goto LABEL_8;
      case 0x49u:
        *a3 = 32;
        v563 = *a4;
        v564 = *(_OWORD *)(a2 + v563 + 16);
        __dst[0] = *(_OWORD *)(a2 + v563);
        __dst[1] = v564;
        *a4 = v563 + 32;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        v565 = create_upsample_layer(v9, __dst, &v580);
        if (!(_DWORD)v565)
          goto LABEL_24;
        v14 = v565;
        v15 = *v9;
        v16 = "create upsample layer failed!";
        goto LABEL_8;
      default:
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: unknown layer type %s!", v64, v65, v66, (uint64_t)v67);
        v14 = 7;
        goto LABEL_9;
    }
  }
}

uint64_t parse_fi_binary_model(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  unsigned int v5;

  v5 = 0;
  v4 = 0;
  return parse_fi_binary_model_inner(a1, a2, &v5, &v4, a3);
}

uint64_t create_pooling_layer(uint64_t *a1, int a2, __int128 *a3, uint64_t **a4, uint64_t ***a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v14;
  uint64_t **v15;

  v15 = 0;
  v11 = create_conv_layer(a1, a3, a4, &v15);
  if ((_DWORD)v11)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed when call create_conv_layer()!", v8, v9, v10, v14);
    v12 = v15;
  }
  else
  {
    v12 = v15;
    *((_DWORD *)v15 + 2) = a2;
    *((_DWORD *)v12 + 3) = 0;
    v12[16] = (uint64_t *)forward_pooling_layer;
    v12[17] = (uint64_t *)free_pooling_buffer;
  }
  *a5 = v12;
  return v11;
}

uint64_t create_conv_layer(uint64_t *a1, __int128 *a2, uint64_t **a3, uint64_t ***a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v11 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64)) != 0)
  {
    v13 = v12;
    v11[15] = (uint64_t *)v12;
    *v11 = a1;
    if (a3)
      *(uint64_t **)((char *)v11 + 60) = *a3;
    result = 0;
    v15 = *a2;
    v16 = a2[1];
    *(_DWORD *)(v13 + 32) = *((_DWORD *)a2 + 8);
    *(_OWORD *)v13 = v15;
    *(_OWORD *)(v13 + 16) = v16;
    v11[20] = (uint64_t *)conv_layer_request_glbBuf;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v17);
    free_conv_buffer(v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_pooling_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t **v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  char *v12;
  uint64_t conv_chw;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  unsigned int v20;
  uint64_t v21;
  int v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  char v27;
  char *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  int is_same;
  float *v40;
  float *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  float v45;
  uint64_t v46;
  float v47;
  float v48;
  float v49;
  uint64_t v50;
  float v51;
  float v52;
  uint64_t v53;
  float v54;
  uint64_t v55;
  float v56;
  float v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;
  int v61;
  unsigned int v62;
  int v63;
  int v64;
  uint64_t **v65;
  int v66;
  _DWORD *v67;
  unsigned int *v68;
  int v70;
  char v71;
  int v72;
  uint64_t v73;

  v7 = (uint64_t **)a2;
  v8 = *(int **)(a2 + 120);
  v73 = 0;
  v72 = 0;
  v9 = v8[1];
  v63 = *v8;
  v11 = v8[14];
  v10 = v8[15];
  v12 = *(char **)(a2 + 240);
  bzero(v12, *(unsigned int *)(a2 + 248));
  conv_chw = fi_shape_get_conv_chw((_DWORD *)v7 + 5, (_DWORD *)&v73 + 1, &v73, &v72);
  if ((_DWORD)conv_chw)
  {
    v17 = conv_chw;
    v18 = **v7;
    v19 = "fi_shape_get_conv_chw error!";
LABEL_5:
    log_OutText(v18, (uint64_t)"FastInfer", 0, 0, (uint64_t)v19, v14, v15, v16, v60);
    return v17;
  }
  v66 = v11;
  v70 = v10;
  v20 = HIDWORD(v73);
  v21 = im2row_2d_or_1d(*((_DWORD *)v7 + 5), a3, SHIDWORD(v73), v73, v72, (uint64_t)v8, (uint64_t)v12);
  if ((_DWORD)v21)
  {
    v17 = v21;
    v18 = **v7;
    v19 = "im2row_2d_or_1d_failed!";
    goto LABEL_5;
  }
  v68 = (unsigned int *)v7 + 5;
  if (!v20)
    return 0;
  v23 = 0;
  v24 = (v9 * v63);
  v25 = (v66 * v70);
  v65 = v7;
  v67 = v7 + 5;
  if ((_DWORD)v24)
    v26 = v12 == 0;
  else
    v26 = 1;
  v27 = v26;
  v71 = v27;
  v28 = v12 + 4;
  v61 = v25 * v9 * v63;
  v29 = 0;
  while (!(_DWORD)v25)
  {
LABEL_50:
    v17 = 0;
    ++v29;
    v23 += v61;
    if (v29 >= v20)
      return v17;
  }
  v30 = 0;
  v62 = v29;
  v31 = v29 * v25;
  v64 = v23;
  while (2)
  {
    v32 = a4;
    if (!a5)
      goto LABEL_58;
    v32 = a4;
    if (*(_DWORD *)(a5 + 16))
      goto LABEL_58;
    v33 = v28;
    v34 = v25;
    v35 = a4;
    v36 = a5;
    v37 = v12;
    v38 = v31;
    is_same = fi_shape_is_same(v68, v67);
    v31 = v38;
    v12 = v37;
    a5 = v36;
    a4 = v35;
    v7 = v65;
    v25 = v34;
    v28 = v33;
    v32 = a3;
    if (is_same)
    {
LABEL_58:
      v40 = (float *)&v12[4 * v23];
      v41 = (float *)&v28[4 * v23];
      v42 = (v31 + v30);
      v43 = (v42 * v24);
      switch(*((_DWORD *)v7 + 2))
      {
        case 8:
        case 0xC:
        case 0xE:
        case 0x12:
          if (!(_DWORD)v24)
            goto LABEL_35;
          v44 = 0;
          v45 = 0.0;
          v46 = v24;
          do
          {
            v47 = *v40++;
            v45 = v45 + v47;
            if (v47 != 0.0)
              ++v44;
            --v46;
          }
          while (v46);
          if (v44)
            v48 = v45 / (float)v44;
          else
LABEL_35:
            v48 = 0.0;
          goto LABEL_40;
        case 9:
        case 0xF:
          v48 = 0.0;
          if ((_DWORD)v24)
          {
            v53 = v24;
            do
            {
              v54 = *v40++;
              v48 = v48 + v54;
              --v53;
            }
            while (v53);
            v48 = v48 / (float)v24;
          }
LABEL_40:
          *(float *)(v32 + 4 * v42) = v48;
          goto LABEL_48;
        case 0xA:
        case 0xD:
        case 0x10:
        case 0x13:
          v49 = 0.0;
          if ((v71 & 1) == 0)
          {
            v49 = *(float *)&v12[4 * v43];
            if (v24 >= 2)
            {
              v50 = v24 - 1;
              do
              {
                v51 = *v41++;
                v52 = v51;
                if (v51 >= v49)
                  v49 = v52;
                --v50;
              }
              while (v50);
            }
          }
          goto LABEL_47;
        case 0x11:
          v49 = 0.0;
          if ((v71 & 1) == 0)
          {
            v49 = *(float *)&v12[4 * v43];
            if (v24 >= 2)
            {
              v55 = v24 - 1;
              do
              {
                v56 = *v41++;
                v57 = v56;
                if (v56 <= v49)
                  v49 = v57;
                --v55;
              }
              while (v55);
            }
          }
LABEL_47:
          *(float *)(v32 + 4 * v42) = v49;
LABEL_48:
          ++v30;
          v23 += v24;
          if (v30 != v25)
            continue;
          v20 = HIDWORD(v73);
          v23 = v64;
          v29 = v62;
          break;
        default:
          v58 = **v7;
          v59 = "Unsupported POOLING Layer - %d";
          v60 = *((unsigned int *)v7 + 2);
          goto LABEL_55;
      }
      goto LABEL_50;
    }
    break;
  }
  v58 = **v65;
  v59 = "pool: want to swap in/out but shape mismatch!";
LABEL_55:
  log_OutText(v58, (uint64_t)"FastInfer", 0, 0, (uint64_t)v59, v14, v15, v16, v60);
  return 7;
}

uint64_t conv_layer_wanted_wb_len(uint64_t a1, int *a2, _DWORD *a3)
{
  int *v6;
  _BOOL4 is_enabled;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t conv_chw;
  unsigned int v16;
  int padded_len;
  int *v18;
  unsigned int v19;
  int v20;
  char v21;
  int v22;
  _DWORD *v23;
  uint64_t v25;
  uint64_t v26;

  v6 = *(int **)(a1 + 120);
  v26 = 0;
  HIDWORD(v25) = 0;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  if (is_enabled && (v8 = *(_QWORD *)(a1 + 72)) != 0)
    v9 = (*(unsigned __int8 *)(v8 + 4) >> 3) & 1;
  else
    v9 = 0;
  if (fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 8u, *(_DWORD *)(a1 + 264)) && (v10 = *(_QWORD *)(a1 + 72)) != 0)
    v11 = (*(_DWORD *)(v10 + 4) >> 5) & 1;
  else
    v11 = 0;
  conv_chw = fi_shape_get_conv_chw((_DWORD *)(a1 + 20), (_DWORD *)&v26 + 1, &v26, (_DWORD *)&v25 + 1);
  if ((_DWORD)conv_chw)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v12, v13, v14, v25);
  }
  else
  {
    if (get_conv1d_impl(v6, (_DWORD *)(a1 + 20), v11) == 4)
    {
      if (v9)
        v16 = 32;
      else
        v16 = 8;
      padded_len = get_padded_len((v6[4] * v6[1]), v16);
      v18 = v6;
    }
    else
    {
      if (v9)
        v19 = 32;
      else
        v19 = 8;
      padded_len = get_padded_len((*v6 * HIDWORD(v26) * v6[1]), v19);
      v18 = v6 + 4;
    }
    v20 = *v18;
    if (v9)
      v21 = 0;
    else
      v21 = 2;
    v22 = (padded_len << v21) * v20;
    *a2 = v22;
    if (is_enabled)
    {
      v23 = *(_DWORD **)(a1 + 72);
      if (v23)
        LODWORD(v23) = 4 * *v23;
      *a2 = (_DWORD)v23 + v22;
    }
    if (v6[6] == 1)
      *a3 = 4 * v6[4];
    else
      *a3 = 0;
  }
  return conv_chw;
}

uint64_t get_conv1d_impl(_DWORD *a1, _DWORD *a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  int v11;

  if (*a2 != 2 || a1[5] != 1 || a1[3] != 1 || a1[12] || a1[13] || a1[9] != 1)
    return 1;
  if (a3 || a1[2] != 1)
  {
    if (a3 == 1)
    {
      v8 = a1[1];
      if (v8 == get_padded_len(v8, 8u))
      {
        v9 = a2 + 2;
        v10 = 4;
        goto LABEL_17;
      }
    }
    return 1;
  }
  v5 = a1[1];
  if (v5 == get_padded_len(v5, 8u))
  {
    v6 = a2[2];
    if (v6 == get_padded_len(v6, 8u))
      return 2;
  }
  if ((a2[2] & 3) != 2)
    return 1;
  v9 = a1 + 4;
  v10 = 3;
LABEL_17:
  v11 = *v9;
  if (v11 == get_padded_len(*v9, 8u))
    return v10;
  else
    return 1;
}

uint64_t conv_layer_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t conv_chw;
  int conv1d_impl;
  int v10;
  int v11;
  uint64_t v13;
  uint64_t v14;

  v2 = *(_DWORD **)(a1 + 120);
  v14 = 0;
  HIDWORD(v13) = 0;
  if (fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 8u, *(_DWORD *)(a1 + 264)) && (v3 = *(_QWORD *)(a1 + 72)) != 0)
    v4 = (*(_DWORD *)(v3 + 4) >> 5) & 1;
  else
    v4 = 0;
  conv_chw = fi_shape_get_conv_chw((_DWORD *)(a1 + 20), (_DWORD *)&v14 + 1, &v14, (_DWORD *)&v13 + 1);
  if ((_DWORD)conv_chw)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v5, v6, v7, v13);
  }
  else
  {
    conv1d_impl = get_conv1d_impl(v2, (_DWORD *)(a1 + 20), v4);
    if (conv1d_impl == 3)
    {
      v11 = 8 * get_padded_len(((*v2 + v2[14] * v2[15] - 1) * v2[1]), 8u);
    }
    else
    {
      if (conv1d_impl == 2)
        v10 = v2[1] * (*v2 + v2[14] * v2[15] - 1);
      else
        v10 = get_padded_len((*v2 * HIDWORD(v14) * v2[1]), 8u) * v2[15] * v2[14];
      v11 = 4 * v10;
    }
    *(_DWORD *)(a1 + 248) = v11;
  }
  return conv_chw;
}

uint64_t config_pooling_layer(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a3;
  a7[3] = a4;
  a7[4] = 1;
  a7[5] = a5;
  a7[6] = 0;
  a7[7] = a6;
  a7[8] = 0;
  return 0;
}

uint64_t config_conv_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, _DWORD *a10)
{
  *a10 = a2;
  a10[1] = a3;
  a10[2] = a4;
  a10[3] = a5;
  a10[4] = a1;
  a10[5] = a6;
  a10[6] = a7;
  a10[7] = a8;
  a10[8] = a9;
  return 0;
}

_QWORD *free_conv_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t forward_conv_layer(uint64_t a1, uint64_t *a2, const void *a3, float32x4_t *a4)
{
  uint64_t *v6;
  uint64_t v7;
  _BOOL4 is_enabled;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t conv_chw;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  int v19;
  char *v20;
  unsigned int v21;
  char *v22;
  _DWORD *v23;
  int conv1d_impl;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  char *v29;
  unsigned int v30;
  char *v31;
  char *v32;
  char *v33;
  int v34;
  int v35;
  unsigned int v36;
  char *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  __int128 *v62;
  char *v63;
  int v64;
  int v65;
  unsigned int v66;
  uint64_t *v67;
  int v68;
  uint64_t v69;
  __int128 *v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v79;
  float32x4_t *v80;
  int v81;
  unsigned int v82;
  unsigned int v83;
  char *v84;
  int v85;
  unsigned int v86;
  char *v87;
  int padded_len;
  char *v89;
  __int128 *v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  size_t v97;
  unsigned int v98;
  int v99;
  unsigned int v100;
  int v101;
  int v102;
  float32x4_t *v103;
  char *v104;
  __int128 v105;
  __int128 v106;
  int v107;
  int v108[4];

  v6 = a2;
  v7 = *a2;
  *(_QWORD *)v108 = 0;
  v107 = 0;
  is_enabled = fi_feat_is_enabled(a2[32], 7u, *((_DWORD *)a2 + 66));
  if (fi_feat_is_enabled(v6[32], 8u, *((_DWORD *)v6 + 66)) && (v9 = v6[9]) != 0)
    v10 = (*(unsigned __int8 *)(v9 + 4) >> 5) & 1;
  else
    v10 = 0;
  v105 = 0u;
  v106 = 0u;
  if (!a3)
    return 7;
  v11 = v6[15];
  v12 = (_DWORD *)v6 + 5;
  conv_chw = fi_shape_get_conv_chw((_DWORD *)v6 + 5, &v108[1], v108, &v107);
  if ((_DWORD)conv_chw)
  {
    v17 = conv_chw;
    log_OutText(*(_QWORD *)*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v14, v15, v16, v79);
    return v17;
  }
  v18 = (float *)v6[9];
  if (!v18)
    return 7;
  v91 = v7;
  v100 = *(_DWORD *)(v11 + 4) * *(_DWORD *)v11 * v108[1];
  v19 = *(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60);
  v20 = (char *)v18 + ((_DWORD)v6[12] & 0xFFFFFFFC);
  v93 = *(unsigned int *)(v11 + 16);
  if (is_enabled)
  {
    LODWORD(v106) = (*((_DWORD *)v18 + 1) >> 3) & 1;
    DWORD1(v106) = ((*((_DWORD *)v18 + 1) >> 4) & 1) == 0;
    v21 = *((_DWORD *)v18 + 1);
    LODWORD(v105) = v21 & 1;
    DWORD2(v105) = ((v21 >> 1) & 1) == 0;
    v22 = (char *)&v18[*(unsigned int *)v18];
    if ((_DWORD)v106)
    {
      v23 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(v91 + 8) + 64))(*(_QWORD *)(v91 + 16), 2, 4);
      *((_QWORD *)&v106 + 1) = v23;
      *v23 = *((_DWORD *)v18 + 7);
      v23[1] = *((_DWORD *)v18 + 8);
      v20 = (char *)v18 + *((unsigned int *)v6 + 24);
    }
    v90 = &v105;
  }
  else
  {
    v90 = 0;
    v22 = (char *)v6[9];
  }
  v104 = (char *)v6[30];
  conv1d_impl = get_conv1d_impl((_DWORD *)v11, (_DWORD *)v6 + 5, v10);
  v92 = v19;
  v89 = v22;
  if (conv1d_impl == 2)
  {
    v34 = *(_DWORD *)(v11 + 4);
    v35 = v19;
    v36 = ((*(_DWORD *)v11 - 1) >> 1) * v34;
    v95 = v34 * v35;
    v85 = *(_DWORD *)v11 >> 1;
    bzero(v104, 4 * v36);
    v37 = &v104[4 * v36];
    memcpy(v37, a3, 4 * v95);
    bzero(&v37[4 * v95], (4 * v34 * v85));
    if (*v12 != 3)
    {
      if (*(_DWORD *)(v11 + 24) == 1)
      {
        v38 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
        if ((_DWORD)v38)
        {
          v39 = 0;
          v40 = *(unsigned int *)(v11 + 16);
          do
          {
            memcpy(&a4->f32[v39], v20, 4 * v40);
            v39 += v40;
            --v38;
          }
          while (v38);
        }
      }
      LODWORD(v41) = v93;
      v42 = v92;
      gemm_ex((uint64_t *)*v6, v92, v93, v100, (float *)v104, *(unsigned int *)(v11 + 4), v22, v100, a4, v93, v90);
      goto LABEL_68;
    }
    goto LABEL_29;
  }
  v25 = conv1d_impl;
  if (conv1d_impl == 4)
  {
    v43 = *(_DWORD *)(v11 + 4);
    v44 = v43 * v19;
    v83 = v43 * v19;
    v86 = (((*(_DWORD *)v11 - 1) * *(_DWORD *)(v11 + 8)) >> 1) * v43;
    v96 = 4 * v86;
    bzero(v104, v96);
    memcpy(&v104[v96], a3, 4 * v44);
    bzero(&v104[4 * v83 + v96], v96);
  }
  else
  {
    if (conv1d_impl == 3)
    {
      v26 = *(_DWORD *)(v11 + 4);
      v94 = v26 * v19;
      v27 = (*(_DWORD *)v11 >> 1) * v26;
      v28 = ((*(_DWORD *)v11 - 1) >> 1) * v26;
      v82 = v28;
      bzero(v104, 4 * v28);
      v29 = &v104[4 * v28];
      memcpy(v29, a3, 4 * v94);
      bzero(&v29[4 * v94], 4 * v27);
      v30 = v27 + v82;
      v25 = 3;
      LODWORD(v29) = v30 + v94;
      v31 = &v104[4 * get_padded_len(v30 + v94, 8u)];
      memcpy(v31, v104 + 8, 4 * ((_DWORD)v29 - 2));
      v32 = v104 + 16;
      v33 = v31 + 16;
      goto LABEL_28;
    }
    im2row_pad((uint64_t)a3, v108[1], v108[0], v107, *(_DWORD *)v11, *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 8), *(_DWORD *)(v11 + 12), *(_DWORD *)(v11 + 20), *(_DWORD *)(v11 + 20), *(_OWORD *)(v11 + 40), HIDWORD(*(_QWORD *)(v11 + 40)), *(_QWORD *)(v11 + 48), HIDWORD(*(_OWORD *)(v11 + 40)), (uint64_t)v104);
  }
  v31 = 0;
  v32 = 0;
  v33 = 0;
LABEL_28:
  if (*v12 != 3)
  {
    if (v25 == 4)
    {
      v101 = *(_DWORD *)(v11 + 8);
      v98 = *(_DWORD *)(v11 + 4);
      padded_len = get_padded_len(v98, 8u);
      v59 = *(unsigned int *)(v11 + 16);
      if (*(_DWORD *)(v11 + 24) == 1)
      {
        v60 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
        if ((_DWORD)v60)
        {
          v61 = 0;
          do
          {
            memcpy(&a4->f32[v61], v20, 4 * v59);
            v61 += v59;
            --v60;
          }
          while (v60);
        }
      }
      v41 = v93;
      v42 = v92;
      v62 = v90;
      v63 = v104;
      if (*(_DWORD *)v11)
      {
        v64 = 0;
        v65 = 0;
        v66 = 0;
        v102 = v98 * v101;
        v99 = v59 * padded_len;
        v103 = a4;
        do
        {
          v67 = (uint64_t *)*v6;
          v81 = v41;
          v80 = a4;
          v68 = v41;
          v69 = *(unsigned int *)(v11 + 4);
          v70 = v62;
          v71 = v11;
          v72 = v6;
          v73 = v41;
          v74 = v63;
          gemm_ex(v67, v92, v68, v69, (float *)&v63[4 * v64], v69, &v89[4 * v65], v69, v80, v81, v62);
          v63 = v74;
          v41 = v73;
          v6 = v72;
          v11 = v71;
          a4 = v103;
          v62 = v70;
          ++v66;
          v65 += v99;
          v64 += v102;
        }
        while (v66 < *(_DWORD *)v11);
      }
    }
    else if (v25 == 3)
    {
      v84 = v32;
      v87 = v31;
      v97 = (size_t)v33;
      if (*(_DWORD *)(v11 + 24) == 1)
      {
        v51 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
        if ((_DWORD)v51)
        {
          v52 = 0;
          v53 = *(unsigned int *)(v11 + 16);
          do
          {
            memcpy(&a4->f32[v52], v20, 4 * v53);
            v52 += v53;
            --v51;
          }
          while (v51);
        }
      }
      v54 = v92 + 6;
      if (v92 + 3 >= 0)
        v54 = v92 + 3;
      LODWORD(v41) = v93;
      v55 = 4 * v93;
      gemm_ex((uint64_t *)*v6, v54 >> 2, v93, v100, (float *)v104, (4 * *(_DWORD *)(v11 + 4)), v89, v100, a4, 4 * v93, v90);
      if (v92 + 1 >= 0)
        v56 = v92 + 1;
      else
        v56 = v92 + 4;
      gemm_ex((uint64_t *)*v6, v56 >> 2, v93, v100, (float *)&v84[8 * *(_DWORD *)(v11 + 4) - 16], (4 * *(_DWORD *)(v11 + 4)), v89, v100, (float32x4_t *)((char *)a4 + 4 * (2 * v93)), v55, v90);
      v57 = v92 + 2;
      if (v92 + 2 < 0)
        v57 = v92 + 5;
      gemm_ex((uint64_t *)*v6, v57 >> 2, v93, v100, (float *)&v87[4 * *(unsigned int *)(v11 + 4) - 8], (4 * *(_DWORD *)(v11 + 4)), v89, v100, (float32x4_t *)((char *)a4 + 4 * v93), v55, v90);
      if (v92 >= 0)
        v58 = v92;
      else
        v58 = v92 + 3;
      gemm_ex((uint64_t *)*v6, v58 >> 2, v93, v100, (float *)(v97 + 4 * (3 * *(_DWORD *)(v11 + 4)) - 24), (4 * *(_DWORD *)(v11 + 4)), v89, v100, (float32x4_t *)((char *)a4 + 4 * (3 * v93)), v55, v90);
      v42 = v92;
    }
    else
    {
      LODWORD(v41) = v93;
      v42 = v92;
      if (*v12 == 2)
      {
        if (*(_DWORD *)(v11 + 24) == 1)
        {
          v75 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
          if ((_DWORD)v75)
          {
            v76 = 0;
            v77 = *(unsigned int *)(v11 + 16);
            do
            {
              memcpy(&a4->f32[v76], v20, 4 * v77);
              v76 += v77;
              --v75;
            }
            while (v75);
          }
        }
        v42 = v92;
        gemm((uint64_t *)*v6, v92, v93, v100, (float *)v104, v89, a4, v90, v79);
      }
    }
    goto LABEL_68;
  }
LABEL_29:
  if (*(_DWORD *)(v11 + 24) == 1)
  {
    v45 = *(unsigned int *)(v11 + 16);
    if ((_DWORD)v45)
    {
      v46 = 0;
      v47 = 0;
      v48 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
      do
      {
        if ((_DWORD)v48)
        {
          v49 = v46;
          v50 = v48;
          do
          {
            a4->i32[v49++] = *(_DWORD *)&v20[4 * v47];
            --v50;
          }
          while (v50);
        }
        ++v47;
        v46 += v48;
      }
      while (v47 != v45);
    }
  }
  LODWORD(v41) = v93;
  gemm((uint64_t *)*v6, v93, v92, v100, v18, v104, a4, 0, v79);
  v42 = v92;
LABEL_68:
  fi_activate_array(a4->f32, (v42 * v41), *(_DWORD *)(v11 + 32));
  if (*((_QWORD *)&v106 + 1))
    (*(void (**)(_QWORD))(*(_QWORD *)(v91 + 8) + 80))(*(_QWORD *)(v91 + 16));
  return 0;
}

uint64_t im2row_pad(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, uint64_t a15)
{
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t i;
  int v33;
  int v34;
  int v35;
  int v36;

  v22 = (a5 * a2 * a6);
  v36 = (~((a5 - 1) * a7) + a3 + a11 + a12) / a10;
  result = get_padded_len(v22, 8u);
  if ((v36 & 0x80000000) == 0)
  {
    v24 = 0;
    v26 = (~((a6 - 1) * a8) + a4 + a13 + a14) / a9;
    v27 = (v26 + 1);
    v28 = 4 * (int)result * (uint64_t)(int)v27;
    v29 = 4 * (int)result;
    do
    {
      if ((v26 & 0x80000000) == 0)
      {
        v30 = 0;
        result = (v24 * a10 - a11);
        v31 = a15;
        do
        {
          if ((int)v22 >= 1)
          {
            for (i = 0; i != v22; ++i)
            {
              v33 = result + (int)i / a6 % a5 * a7;
              v34 = 0;
              if (v33 < a3 && (v33 & 0x80000000) == 0)
              {
                v35 = v30 * a9 - a13 + (int)i % a6 * a8;
                if ((v35 & 0x80000000) == 0 && v35 < a4)
                  v34 = *(_DWORD *)(a1 + 4 * (v35 + (v33 + (int)i / a5 / a6 * a3) * a4));
              }
              *(_DWORD *)(v31 + 4 * i) = v34;
            }
          }
          ++v30;
          v31 += v29;
        }
        while (v30 != v27);
      }
      ++v24;
      a15 += v28;
    }
    while (v24 != v36 + 1);
  }
  return result;
}

uint64_t get_padding_size(uint64_t *a1, int *a2, int a3, _DWORD *a4, unsigned int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t conv_chw;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t windows_output_size;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v27;
  uint64_t v28;

  v12 = a2[7];
  v13 = a2[1];
  v14 = a2[3];
  v24 = a2[2];
  v25 = *a2;
  v15 = a2[5];
  v28 = 0;
  v27 = 0;
  conv_chw = fi_shape_get_conv_chw(a4, (_DWORD *)&v28 + 1, &v28, &v27);
  if (!(_DWORD)conv_chw)
  {
    *a7 = v12;
    windows_output_size = get_windows_output_size(a1, v28, v25, v24, v15, v12, a6, a7 + 1, a7 + 2);
    if ((_DWORD)windows_output_size)
      return windows_output_size;
    if (*a4 != 2)
    {
      if (*a4 == 3)
        return get_windows_output_size(a1, v27, v13, v14, v15, v12, a5, a7 + 3, a7 + 4);
      return 7;
    }
    a7[3] = 0;
    a7[4] = 0;
    if ((a3 - 10) >= 4)
    {
      if (!a3)
      {
        v22 = 1;
        goto LABEL_10;
      }
      if (a3 != 8)
        return 7;
    }
    v22 = v27;
LABEL_10:
    windows_output_size = 0;
    *a5 = v22;
    return windows_output_size;
  }
  windows_output_size = conv_chw;
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v17, v18, v19, v23);
  return windows_output_size;
}

uint64_t get_windows_output_size(uint64_t *a1, int a2, int a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int *a7, unsigned int *a8, _DWORD *a9)
{
  int v9;
  uint64_t result;
  uint64_t v11;
  const char *v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;

  if (!a5)
  {
    v11 = *a1;
    v12 = "Stride must be > 0, but got %d";
    v16 = 0;
LABEL_10:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, (uint64_t)a7, (uint64_t)a8, v16);
    return 7;
  }
  if ((_DWORD)a4)
  {
    v9 = (a3 - 1) * a4;
    if ((_DWORD)a6 == 1)
    {
      result = 0;
      v13 = (a2 + a5 - 1) / a5;
      *a7 = v13;
      v14 = v9 + 1 - a2 + (v13 - 1) * a5;
      v15 = v14 & ~(v14 >> 31);
      *a8 = v15 >> 1;
      *a9 = v15 - (v15 >> 1);
      return result;
    }
    if (!(_DWORD)a6)
    {
      result = 0;
      *a7 = (a5 + a2 + ~v9) / a5;
      *a9 = 0;
      *a8 = 0;
      return result;
    }
    v11 = *a1;
    v12 = "Supported padding: valid, same, but got: %d";
    v16 = a6;
    goto LABEL_10;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, a4, (uint64_t)"Dilation rate must be > 1, but got %d", a6, (uint64_t)a7, (uint64_t)a8, 0);
  return 7;
}

uint64_t im2row(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, uint64_t a15)
{
  int v15;
  uint64_t v16;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  int v25;
  int v26;
  int v27;

  v15 = (a3 - a5 + a11 + a12) / a10;
  if ((v15 & 0x80000000) == 0)
  {
    v16 = 0;
    v18 = (a5 * a2 * a6);
    v19 = (a4 - a6 + a13 + a14) / a9;
    v20 = (v19 + 1);
    v21 = (v15 + 1);
    do
    {
      if ((v19 & 0x80000000) == 0)
      {
        v22 = 0;
        v23 = a15;
        do
        {
          if ((int)v18 >= 1)
          {
            for (i = 0; i != v18; ++i)
            {
              v25 = v16 * a10 - a11 + (int)i / a6 % a5 * a7;
              v26 = 0;
              if (v25 < a3 && (v25 & 0x80000000) == 0)
              {
                v27 = v22 * a9 - a13 + (int)i % a6 * a8;
                if ((v27 & 0x80000000) == 0 && v27 < a4)
                  v26 = *(_DWORD *)(result + 4 * (v27 + (v25 + (int)i / a5 / a6 * a3) * a4));
              }
              *(_DWORD *)(v23 + 4 * i) = v26;
            }
          }
          ++v22;
          v23 += 4 * (int)v18;
        }
        while (v22 != v20);
      }
      ++v16;
      a15 += 4 * (int)v18 * (uint64_t)(int)v20;
    }
    while (v16 != v21);
  }
  return result;
}

uint64_t im2row_2d_or_1d(int a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  if (a1 == 2)
  {
    im2row(a2, a3, a4, a5, *(_DWORD *)a6, *(_DWORD *)(a6 + 4), *(_DWORD *)(a6 + 8), 1, 1, *(_DWORD *)(a6 + 20), *(_DWORD *)(a6 + 40), *(_DWORD *)(a6 + 44), 0, 0, a7);
    return 0;
  }
  if (a1 == 3)
  {
    im2row(a2, a3, a4, a5, *(_DWORD *)a6, *(_DWORD *)(a6 + 4), *(_DWORD *)(a6 + 8), *(_DWORD *)(a6 + 12), *(_DWORD *)(a6 + 20), *(_DWORD *)(a6 + 20), *(_OWORD *)(a6 + 40), HIDWORD(*(_QWORD *)(a6 + 40)), *(_QWORD *)(a6 + 48), HIDWORD(*(_OWORD *)(a6 + 40)), a7);
    return 0;
  }
  return 7;
}

uint64_t create_highway_layer(uint64_t *a1, uint64_t *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24);
      v19 = v15;
      if (!v15)
      {
        v21 = *a1;
        v22 = "out of memory!";
        goto LABEL_14;
      }
      v20 = *a2;
      *v15 = *a2;
      if ((v20 & 7) != 0)
      {
        v21 = *a1;
        v22 = "highway_feat must be multiple of 8!";
LABEL_14:
        log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v16, v17, v18, v31);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highway init param failed!", v28, v29, v30, v32);
        result = 7;
        goto LABEL_15;
      }
      v33 = 0x100000001;
      HIDWORD(v34) = *(_DWORD *)a2;
      v35 = 0;
      LODWORD(v34) = 5;
      if (create_fc_layer(a1, &v34, &v33, a3, a4, v15 + 1))
      {
        v26 = "create highway denseT dense layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v31);
        v21 = *a1;
        v22 = "highway network init failed!";
        goto LABEL_14;
      }
      v27 = *((_DWORD *)a2 + 1);
      HIDWORD(v34) = *(_DWORD *)a2;
      v35 = 0;
      LODWORD(v34) = 5;
      v33 = v27 | 0x100000000;
      if (create_fc_layer(a1, &v34, &v33, a3, a4, v19 + 2))
      {
        v26 = "create highway denseH dense layer failed!";
        goto LABEL_13;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 53;
      *(_QWORD *)(v7 + 128) = forward_highway_layer;
      *(_QWORD *)(v7 + 136) = free_highway_layer;
      *(_QWORD *)(v7 + 144) = highway_layer_update_shape;
      *(_QWORD *)(v7 + 152) = highway_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = highway_request_glbBuf;
      *(_QWORD *)(v7 + 184) = highway_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v23, v24, v25, v31);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_highway_layer(uint64_t a1, uint64_t a2, float *a3, void *a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  uint64_t v23;

  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(_DWORD *)v9 * fi_shape_get_step((_DWORD *)(a2 + 20));
  v11 = *(void **)(a2 + 240);
  bzero(v11, 4 * v10);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 8) + 128))(a1);
  if (!(_DWORD)v12)
  {
    bzero(a4, 4 * v10);
    v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 128))(a1);
    if ((_DWORD)v19)
    {
      v16 = v19;
      v17 = *v8;
      v18 = "highway forward dense denseH layer failed!";
      goto LABEL_6;
    }
    xmy(v10, (float *)v11, 1, (float *)a4, 1);
    if ((_DWORD)v10)
    {
      v20 = v10;
      v21 = (float *)v11;
      do
      {
        *v21 = 1.0 - *v21;
        ++v21;
        --v20;
      }
      while (v20);
    }
    xmy(v10, a3, 1, (float *)v11, 1);
    axpy(v10, (float *)v11, 1, (float *)a4, 1, 1.0);
    return 0;
  }
  v16 = v12;
  v17 = *v8;
  v18 = "highway forward dense denseT failed!";
LABEL_6:
  log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, v13, v14, v15, v23);
  return v16;
}

_QWORD *free_highway_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 8));
        fi_layer_free(*(_QWORD *)(v3 + 16));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 highway_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v15;
  __n128 *v16;
  unsigned int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = *v9;
    v12 = "Currently highway layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 8) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 16) + 144))())
  {
    v15 = *(_QWORD *)(v8 + 16);
    v17 = *(_DWORD *)(v15 + 40);
    v16 = (__n128 *)(v15 + 40);
    if (v17 >= 3)
    {
      v11 = *v9;
      v12 = "denseH output shape error: Currently highway layer only support 1D or 2D output";
      goto LABEL_3;
    }
    result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t highway_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v6;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = *(unsigned int **)(a1 + 120);
  result = (*(uint64_t (**)(void))(*((_QWORD *)v6 + 1) + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(*((_QWORD *)v6 + 2) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"highway feat size: %d\n", v9, v10, v11, *v6);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v12, v13, v14, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v15, v16, v17, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t highway_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  int *v3;
  int step;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int padded_len;
  uint64_t v10;
  unsigned int v11;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v11 = 0;
  result = fi_shape_get_input_dim(v3, (int *)&v11);
  if (!(_DWORD)result)
  {
    if (v11 == *v2)
    {
      padded_len = get_padded_len(v11, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = 4 * step * padded_len;
    }
    else
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highway: input sample dim mismatch!", v6, v7, v8, v10);
      return 7;
    }
  }
  return result;
}

uint64_t highway_dispatch_weights(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 16), v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 8), v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

uint64_t ffn_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[3], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[4], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[5], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t create_ffn_layer(uint64_t *a1, __int128 *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int32x2_t v33;
  uint64_t v34;
  int v35;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
      v19 = v15;
      if (!v15)
      {
        v26 = *a1;
        v27 = "out of memory!";
LABEL_14:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, v31);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ffn init param failed!", v28, v29, v30, v32);
        result = 7;
        goto LABEL_15;
      }
      v20 = *a2;
      *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 4);
      *(_OWORD *)v15 = v20;
      v21 = *((_DWORD *)a2 + 1);
      LODWORD(v34) = 40;
      HIDWORD(v34) = v21;
      v35 = 0;
      if (create_norm_layer(a1, &v34, (uint64_t *)(v15 + 24)))
      {
        v25 = "create ffn norm layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v22, v23, v24, v31);
        v26 = *a1;
        v27 = "ffn network init failed!";
        goto LABEL_14;
      }
      HIDWORD(v34) = *(_DWORD *)a2;
      v35 = 0;
      LODWORD(v34) = 5;
      v33 = vrev64_s32(*(int32x2_t *)((char *)a2 + 8));
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 32)))
      {
        v25 = "create ffn o1 dense layer failed!";
        goto LABEL_13;
      }
      HIDWORD(v34) = *((_DWORD *)a2 + 1);
      v35 = 0;
      LODWORD(v34) = 5;
      v33.i32[0] = *((_DWORD *)a2 + 4);
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 40)))
      {
        v25 = "create ffn o2 dense layer failed!";
        goto LABEL_13;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 33;
      *(_QWORD *)(v7 + 128) = forward_ffn_layer;
      *(_QWORD *)(v7 + 136) = free_ffn_layer;
      *(_QWORD *)(v7 + 144) = ffn_layer_update_shape;
      *(_QWORD *)(v7 + 152) = ffn_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = ffn_request_glbBuf;
      *(_QWORD *)(v7 + 184) = ffn_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v22, v23, v24, v31);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_ffn_layer(uint64_t a1, uint64_t a2, float *a3, void *a4)
{
  uint64_t *v8;
  unsigned int *v9;
  int step;
  uint64_t v11;
  char *v12;
  int padded_len;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;

  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v11 = v9[1];
  v12 = *(char **)(a2 + 240);
  padded_len = get_padded_len(v11, 8u);
  v14 = get_padded_len(v11, 8u);
  bzero(v12, 4 * (v14 * step));
  v15 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 3) + 128))(a1);
  if ((_DWORD)v15)
  {
    v19 = v15;
    v20 = *v8;
    v21 = "ffn forward norm layer failed!";
  }
  else
  {
    v22 = get_padded_len(*v9, 8u);
    bzero(&v12[4 * padded_len * step], 4 * (v22 * step));
    v23 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 4) + 128))(a1);
    if ((_DWORD)v23)
    {
      v19 = v23;
      v20 = *v8;
      v21 = "ffn forward dense o1 failed!";
    }
    else
    {
      v24 = (v11 * step);
      bzero(a4, 4 * v24);
      v19 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 5) + 128))(a1);
      if (!(_DWORD)v19)
      {
        axpy(v24, a3, 1, (float *)a4, 1, 1.0);
        return v19;
      }
      v20 = *v8;
      v21 = "ffn forward dense o2 layer failed!";
    }
  }
  log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, v26);
  return v19;
}

_QWORD *free_ffn_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[3]);
        fi_layer_free(v3[4]);
        fi_layer_free(v3[5]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 ffn_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v14;
  __n128 *v15;
  unsigned int v16;
  uint64_t v17;

  v9 = *(_QWORD **)(a1 + 120);
  v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = **(_QWORD **)a1;
    v12 = "Currently ffn layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v17);
    return result;
  }
  if (!(*(unsigned int (**)(void))(v9[3] + 144))()
    && !(*(unsigned int (**)(void))(v9[4] + 144))()
    && !(*(unsigned int (**)(void))(v9[5] + 144))())
  {
    v14 = v9[5];
    v16 = *(_DWORD *)(v14 + 40);
    v15 = (__n128 *)(v14 + 40);
    if (v16 >= 3)
    {
      v11 = **(_QWORD **)a1;
      v12 = "o2 output shape error: Currently ffn layer only support 1D or 2D output";
      goto LABEL_3;
    }
    result = *v15;
    *(_DWORD *)(a1 + 56) = v15[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t ffn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[3] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[4] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[5] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"ffn filter size: %d\n", v10, v11, v12, *(unsigned int *)(v6[4] + 12));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t ffn_request_glbBuf(uint64_t a1)
{
  unsigned int *v2;
  int *v3;
  int step;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int padded_len;
  int v10;
  int padded_bytes;
  uint64_t v12;
  unsigned int v13;

  v2 = *(unsigned int **)(a1 + 120);
  v3 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v13 = 0;
  result = fi_shape_get_input_dim(v3, (int *)&v13);
  if (!(_DWORD)result)
  {
    if (v13 == v2[1])
    {
      padded_len = get_padded_len(v13, 8u);
      v10 = get_padded_len(*v2, 8u);
      padded_bytes = get_padded_bytes(4 * step * (v10 + padded_len), 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
    else
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ffn: input sample dim mismatch!", v6, v7, v8, v12);
      return 7;
    }
  }
  return result;
}

uint64_t create_softmax_layer(uint64_t *a1, uint64_t *a2, _DWORD *a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;

  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v13
    && (v14 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4),
        (*(_QWORD *)(v13 + 120) = v14) != 0))
  {
    *v14 = *a3;
    if (a4)
      *(_QWORD *)(v13 + 60) = *a4;
    result = 0;
    v16 = *a2;
    *(_DWORD *)(v13 + 16) = *((_DWORD *)a2 + 2);
    *(_QWORD *)v13 = a1;
    *(_QWORD *)(v13 + 8) = v16;
    *(_QWORD *)(v13 + 128) = forward_softmax_layer;
    *(_QWORD *)(v13 + 136) = free_softmax_buffer;
    *(_QWORD *)(v13 + 144) = softmax_layer_update_shape;
    *a5 = v13;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v17);
    *a5 = v13;
    free_softmax_buffer((_QWORD *)v13);
    return 10;
  }
  return result;
}

uint64_t forward_softmax_layer(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  int *v7;
  int step;
  uint64_t input_dim;
  int i;
  unsigned int v12;

  v12 = 0;
  v7 = (int *)(a2 + 20);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = fi_shape_get_input_dim(v7, (int *)&v12);
  if (!(_DWORD)input_dim)
  {
    if (*v7 == 1)
    {
      softmax(a3, v12, 1, a4, **(float **)(a2 + 120));
    }
    else if (step)
    {
      for (i = 0; i != step; ++i)
        softmax(&a3[v12 * i], v12, 1, &a4[v12 * i], **(float **)(a2 + 120));
    }
  }
  return input_dim;
}

_QWORD *free_softmax_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t softmax_layer_update_shape(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  __int128 v11;
  __int128 v12;

  v9 = *a2;
  if ((v9 - 1) >= 2)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Softmax only supports 1D/2D operation, get %dD", a6, a7, a8, v9);
    return 7;
  }
  else
  {
    result = 0;
    v11 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v11;
    v12 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 56) = a2[4];
    *(_OWORD *)(a1 + 40) = v12;
  }
  return result;
}

uint64_t create_trans_decoder(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43[2];

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 104);
      v19 = v15;
      if (!v15)
      {
        v32 = *a1;
        v33 = "out of memory!";
LABEL_23:
        log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, v16, v17, v18, v38);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_decoder init param failed!", v35, v36, v37, v39);
        result = 7;
        goto LABEL_24;
      }
      v20 = *(_OWORD *)a2;
      v21 = *((_OWORD *)a2 + 1);
      v22 = *((_OWORD *)a2 + 2);
      *(_QWORD *)(v15 + 48) = *((_QWORD *)a2 + 6);
      *(_OWORD *)(v15 + 16) = v21;
      *(_OWORD *)(v15 + 32) = v22;
      *(_OWORD *)v15 = v20;
      v23 = *a2;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v23, 8);
      *(_QWORD *)(v19 + 56) = v24;
      if (!v24)
      {
        v30 = *a1;
        v31 = "out of memory!";
        goto LABEL_22;
      }
      if ((_DWORD)v23)
      {
        v28 = 0;
        v29 = 8 * v23;
        while (!create_trans_dec_layer(a1, (__int128 *)(a2 + 1), a3, a4, (uint64_t *)(*(_QWORD *)(v19 + 56) + v28)))
        {
          v28 += 8;
          if (v29 == v28)
            goto LABEL_10;
        }
        v30 = *a1;
        v31 = "create trans_decoder trans_dec layer failed!";
        goto LABEL_22;
      }
LABEL_10:
      v40 = 0;
      *(uint64_t *)((char *)v43 + 4) = 0;
      LODWORD(v43[0]) = 40;
      if (create_norm_layer(a1, v43, (uint64_t *)(v19 + 64)))
      {
        v30 = *a1;
        v31 = "create trans_decoder norm layer failed!";
LABEL_22:
        log_OutText(v30, (uint64_t)"FastInfer", 0, 0, (uint64_t)v31, v25, v26, v27, v38);
        v32 = *a1;
        v33 = "trans_decoder network init failed!";
        goto LABEL_23;
      }
      v34 = a2[12];
      LODWORD(v42) = a2[5];
      HIDWORD(v42) = v34;
      if (create_embedding_layer(a1, &v42, (uint64_t ***)(v19 + 72)))
      {
        v30 = *a1;
        v31 = "create trans_decoder emb layer failed!";
        goto LABEL_22;
      }
      HIDWORD(v43[0]) = a2[12];
      LODWORD(v43[1]) = 0;
      LODWORD(v43[0]) = 5;
      if (create_fc_layer(a1, v43, &v40, a3, a4, (uint64_t *)(v19 + 88)))
      {
        v30 = *a1;
        v31 = "create att q dense layer failed!";
        goto LABEL_22;
      }
      memset(v43, 0, 12);
      v41 = 1065353216;
      if (create_softmax_layer(a1, v43, &v41, a3, (uint64_t *)(v19 + 80)))
      {
        v30 = *a1;
        v31 = "create att softmax layer failed!";
        goto LABEL_22;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 38;
      *(_QWORD *)(v7 + 128) = transformer_decode;
      *(_QWORD *)(v7 + 136) = free_trans_decoder;
      *(_QWORD *)(v7 + 144) = trans_decoder_update_shape;
      *(_QWORD *)(v7 + 152) = trans_decoder_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_decoder_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_decoder_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_decoder_reset;
      *(_QWORD *)(v7 + 184) = trans_decoder_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v25, v26, v27, v38);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v38);
      result = 10;
    }
  }
LABEL_24:
  *a5 = v7;
  return result;
}

uint64_t transformer_decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  unsigned int step;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int padded_len;
  unsigned int v23;
  uint64_t *v24;
  float v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t **v49;
  unsigned int v50;
  _DWORD *v51;
  uint64_t v52;
  int v53;
  int v54;
  unsigned int v55;
  unsigned int padded_bytes;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  float v83;
  unsigned int *v84;
  size_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int v88;
  unsigned int v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  float v97;
  float v98;
  unint64_t v99;
  float *v100;
  float v101;
  unint64_t v102;
  float v103;
  unint64_t v104;
  unsigned int v105;
  unint64_t v106;
  _DWORD *v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unsigned int v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  uint64_t i;
  float v124;
  int v125;
  uint64_t v126;
  unint64_t v127;
  unsigned int v128;
  unint64_t v129;
  _DWORD *v130;
  unint64_t v131;
  unsigned int *v132;
  unsigned int *v133;
  unsigned int v134;
  float *v135;
  float v136;
  uint64_t v137;
  int (__cdecl *v138)(const void *, const void *);
  float v139;
  size_t v140;
  size_t v141;
  float *v142;
  float *v143;
  const void **v144;
  uint64_t v145;
  float v146;
  const void *v147;
  uint64_t v148;
  const void **v149;
  uint64_t v150;
  uint64_t *v152;
  uint64_t v153;
  uint64_t v154;
  void *__dst;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  unsigned int __nel;
  size_t __nel_4;
  uint64_t **v162;
  _DWORD *__base;
  uint64_t __n;
  uint64_t v165;
  uint64_t v168;
  int v169;
  const void **v170;
  int v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;

  if (!a2)
    return 0;
  *(_DWORD *)(a5 + 20) = 1;
  v9 = *(unsigned int **)(a2 + 120);
  if (v9)
  {
    trans_decoder_update_shape(a2, (__int128 *)(a2 + 20), a3, a4, a5, a6, a7, a8);
    step = fi_shape_get_step((_DWORD *)(a2 + 20));
    v12 = *v9;
    if ((_DWORD)v12)
    {
      v13 = (uint64_t *)*((_QWORD *)v9 + 7);
      do
      {
        v14 = *v13++;
        v15 = *(_QWORD *)(v14 + 120);
        v17 = *(_QWORD *)(v15 + 56);
        v16 = *(_QWORD *)(v15 + 64);
        v18 = *(_QWORD *)(v17 + 120);
        *(_DWORD *)(v18 + 152) = 0;
        *(_DWORD *)(v18 + 112) = 0;
        v19 = *(_QWORD *)(v16 + 120);
        *(_DWORD *)(v19 + 152) = 0;
        *(_DWORD *)(v19 + 112) = 0;
        --v12;
      }
      while (v12);
    }
    bzero(*(void **)(a2 + 240), *(unsigned int *)(a2 + 248));
    v20 = a2;
    v21 = v9[10];
    padded_len = get_padded_len(v9[5], 8u);
    v23 = padded_len;
    v24 = *(uint64_t **)v20;
    v162 = (uint64_t **)v20;
    if (v21 < 2)
    {
      v53 = v9[8] * padded_len;
      v54 = v9[7] * padded_len;
      v55 = v9[12];
      if (padded_len > v55)
        v55 = padded_len;
      padded_bytes = get_padded_bytes(8 * v55, 8u);
      v57 = *(_QWORD *)(v20 + 240);
      v58 = *v9;
      v59 = padded_bytes + 4 * v53 * (_DWORD)v58;
      v60 = (v59 + 4 * v53 * v58);
      v61 = v54 * v58;
      v62 = (v60 + 4 * v54 * v58);
      if ((_DWORD)v58)
      {
        v63 = 0;
        v64 = 0;
        v65 = v57 + v59;
        v66 = v57 + v60;
        v67 = (uint64_t *)*((_QWORD *)v9 + 7);
        v68 = v57 + padded_bytes;
        do
        {
          v69 = *v67++;
          v70 = *(_QWORD *)(v69 + 120);
          v72 = *(_QWORD *)(v70 + 56);
          v71 = *(_QWORD *)(v70 + 64);
          v73 = *(_QWORD *)(v72 + 120);
          *(_QWORD *)(v73 + 120) = v68 + 4 * v63;
          *(_QWORD *)(v73 + 128) = v65 + 4 * v63;
          v74 = *(_QWORD *)(v71 + 120);
          *(_QWORD *)(v74 + 136) = v66 + 4 * v64;
          *(_QWORD *)(v74 + 144) = v57 + v62 + 4 * v64;
          v64 += v54;
          v63 += v53;
          --v58;
        }
        while (v58);
      }
      if (v9[13])
      {
        v75 = 0;
        v76 = v57 + (v62 + 4 * v61);
        v77 = 0.0;
        while (v75 < v9[8])
        {
          v78 = forward_trans_decoder(a1, v162, a3, v75, 0, v76, v77);
          if ((_DWORD)v78)
          {
            v52 = v78;
            v148 = *v24;
LABEL_104:
            log_OutText(v148, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Transformer decode  failed!", v79, v80, v81, (uint64_t)v152);
            return v52;
          }
          v82 = v9[12];
          if ((_DWORD)v82)
          {
            v83 = -2147500000.0;
            v84 = (unsigned int *)(v76 + 4);
            do
            {
              if (v83 < *((float *)v84 - 1))
              {
                v77 = (float)*v84;
                v83 = *((float *)v84 - 1);
              }
              v84 += 3;
              --v82;
            }
            while (v82);
          }
          *(float *)(a4 + 4 * v75++) = v77;
          if (v77 == (float)v9[13])
            break;
        }
      }
      else
      {
        LODWORD(v75) = 0;
      }
      v49 = v162;
    }
    else
    {
      v152 = *(uint64_t **)v20;
      __dst = (void *)a4;
      v25 = (float)step;
      v26 = v9[7];
      v27 = v9[8];
      v28 = (float)((float)(v25 * (float)v27) / (float)v26);
      if (v27 < v28)
        v28 = v9[8];
      v175 = v28;
      v29 = v27 * padded_len;
      v30 = v26 * padded_len;
      v31 = *v9;
      v32 = v9[12];
      if (padded_len > v32)
        v32 = padded_len;
      v33 = get_padded_bytes(8 * v32, 8u);
      v34 = *(_QWORD *)(v20 + 240);
      v35 = v9[10];
      v36 = v29 * *v9 * v35;
      v37 = v33 + 4 * v36;
      v38 = (v37 + 4 * v36);
      v39 = v38 + 4 * v30 * *v9;
      v40 = v9[12];
      v41 = v39 + 4 * v30 * *v9 + 12 * v35 * v40 + 4 * (v40 + v35);
      v168 = v39;
      v170 = (const void **)(v34 + v41);
      v171 = v31;
      v156 = v41;
      v158 = v39 + 4 * v30 * *v9;
      v173 = v39 + 4 * v30 * *v9 + 12 * v35 * v40;
      if (v35)
      {
        v42 = 4 * v9[8];
        v43 = 28 * v35;
        v44 = v33 + v23 * *v9 * (8 * v27 * v35 + 8 * v26) + v40 * (12 * v35 + 4);
        v45 = (_QWORD *)(v34 + v41);
        v46 = v9[10];
        do
        {
          *v45 = v34 + (v43 + v44);
          v45 += 3;
          v44 += v42;
          --v46;
        }
        while (v46);
        v47 = (v43 + v44);
        __base = (_DWORD *)(v34 + v47);
        v48 = 2 * v35;
        v49 = (uint64_t **)v20;
        if ((_DWORD)v48)
        {
          v50 = v44 + 76 * v35;
          v51 = (_DWORD *)(v34 + v47 + 16);
          do
          {
            *((_QWORD *)v51 - 2) = v34 + v50;
            *v51 = -822083584;
            v51 += 6;
            v50 += v42;
            --v48;
          }
          while (v48);
        }
      }
      else
      {
        __base = (_DWORD *)(v34 + v41);
        v49 = (uint64_t **)v20;
      }
      v85 = v34 + v33;
      v86 = v34 + v37;
      bzero(__dst, 4 * *((unsigned int *)v49 + 11));
      v87 = *v9;
      if ((_DWORD)v87)
      {
        v88 = 0;
        v89 = 0;
        v90 = (uint64_t *)*((_QWORD *)v9 + 7);
        do
        {
          v91 = *v90++;
          v92 = *(_QWORD *)(v91 + 120);
          v94 = *(_QWORD *)(v92 + 56);
          v93 = *(_QWORD *)(v92 + 64);
          v95 = *(_QWORD *)(v94 + 120);
          *(_QWORD *)(v95 + 120) = v85 + 4 * v88;
          *(_QWORD *)(v95 + 128) = v86 + 4 * v88;
          v96 = *(_QWORD *)(v93 + 120);
          *(_QWORD *)(v96 + 136) = v34 + v38 + 4 * v89;
          *(_QWORD *)(v96 + 144) = v34 + v168 + 4 * v89;
          v89 += v30;
          v88 += v29;
          --v87;
        }
        while (v87);
      }
      v165 = v86;
      __nel_4 = v85;
      v97 = powf((float)(v175 + 5) / 6.0, *((float *)v9 + 11));
      if (v175 == 1)
      {
        v140 = v9[10];
        v144 = v170;
LABEL_100:
        v149 = v144;
        qsort(v144, v140, 0x18uLL, (int (__cdecl *)(const void *, const void *))finishedpathcmp);
        v147 = *v149;
        v150 = *((unsigned int *)v149 + 2);
        *((_DWORD *)*v149 + v150) = 1065353216;
        LODWORD(v75) = v150 + 1;
      }
      else
      {
        v98 = v97;
        v99 = 0;
        __nel = 0;
        v100 = (float *)(v34 + v158);
        v174 = v34 + v173;
        v169 = v171 * v29;
        __n = 4 * (v171 * v29);
        v172 = v23 * v27 * v171;
        v154 = v34 + v158 + 4;
        v153 = v156 + v34 + 8;
        v157 = v156 + v34 + 16;
        v159 = v34 + v158 + 8;
        v101 = -2147500000.0;
        do
        {
          v102 = v99 + 1;
          v103 = powf((float)(v99 + 6) / 6.0, *((float *)v9 + 11));
          if (v99)
          {
            v104 = v9[10];
            if ((_DWORD)v104)
            {
              v105 = 0;
              v106 = 0;
              v107 = (_DWORD *)v159;
              do
              {
                *(float *)(v174 + 4 * v106) = (float)*(v107 - 1);
                v108 = *v107;
                if (v106 != v108)
                {
                  memcpy((void *)(__nel_4 + 4 * v105), (const void *)(__nel_4 + 4 * (v108 * v169)), __n);
                  v102 = v99 + 1;
                  memcpy((void *)(v165 + 4 * v105), (const void *)(v165 + 4 * (*v107 * v169)), __n);
                  v104 = v9[10];
                }
                ++v106;
                v105 += v172;
                v107 += 3;
              }
              while (v106 < v104);
              if (v104)
              {
                v109 = 0;
                while (1)
                {
                  v110 = *v9;
                  if ((_DWORD)v110)
                  {
                    v111 = 0;
                    v112 = (uint64_t *)*((_QWORD *)v9 + 7);
                    do
                    {
                      v113 = *v112++;
                      v114 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v113 + 120) + 56) + 120);
                      *(_QWORD *)(v114 + 120) = __nel_4 + 4 * (v169 * v109) + 4 * v111;
                      *(_QWORD *)(v114 + 128) = v165 + 4 * (v169 * v109) + 4 * v111;
                      v111 += v29;
                      --v110;
                    }
                    while (v110);
                  }
                  v115 = forward_trans_decoder(a1, v162, a3, v99, v109, (uint64_t)&v100[3 * v9[12] * v109], *(float *)(v174 + 4 * v109));
                  if ((_DWORD)v115)
                    break;
                  v116 = v9[10];
                  if (v109 < (v116 - 1))
                  {
                    v117 = *v9;
                    if ((_DWORD)v117)
                    {
                      v118 = (uint64_t *)*((_QWORD *)v9 + 7);
                      do
                      {
                        v119 = *v118++;
                        v120 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v119 + 120) + 56) + 120);
                        --*(_DWORD *)(v120 + 152);
                        --v117;
                      }
                      while (v117);
                    }
                  }
                  if (++v109 >= v116)
                  {
                    v121 = v9[12];
                    if ((_DWORD)v116)
                    {
                      v122 = 0;
                      for (i = 0; i != v116; ++i)
                      {
                        if ((_DWORD)v121)
                        {
                          v124 = *((float *)&v170[3 * i + 1] + 1);
                          v125 = v122;
                          v126 = v121;
                          do
                          {
                            v100[3 * v125] = v124 + v100[3 * v125];
                            ++v125;
                            --v126;
                          }
                          while (v126);
                        }
                        v122 += v121;
                      }
                    }
                    goto LABEL_67;
                  }
                }
LABEL_96:
                v52 = v115;
                v148 = *v152;
                goto LABEL_104;
              }
            }
            LODWORD(v116) = 0;
            LODWORD(v121) = v9[12];
LABEL_67:
            qsort(v100, (v116 * v121), 0xCuLL, (int (__cdecl *)(const void *, const void *))cmpvaluefunc);
            v127 = v9[10];
            v128 = __nel;
            if (__nel > v127)
            {
              v129 = __nel - v127;
              v130 = &__base[6 * v127 + 4];
              do
              {
                *v130 = -822083584;
                v130 += 6;
                --v129;
              }
              while (v129);
              v128 = v127;
            }
            if ((_DWORD)v127)
            {
              v131 = 0;
              v133 = (unsigned int *)v153;
              v132 = (unsigned int *)v154;
              do
              {
                if (*v132 == 1)
                {
                  v134 = v128 + 1;
                  v135 = (float *)&__base[6 * v128];
                  memcpy(*(void **)v135, v170[3 * v132[1]], 4 * *v133);
                  v136 = *((float *)v132 - 1);
                  v135[3] = v136;
                  v135[4] = v136 / v103;
                  *(float *)(*(_QWORD *)v135 + 4 * v99) = (float)*v132;
                  *((_DWORD *)v135 + 2) = v99 + 1;
                  v102 = v99 + 1;
                  v127 = (unint64_t)&v100[3 * v131 + 3 * v9[10]];
                  v137 = *(_QWORD *)v127;
                  v132[1] = *(_DWORD *)(v127 + 8);
                  *(_QWORD *)(v132 - 1) = v137;
                  LODWORD(v127) = v9[10];
                  v128 = v134;
                }
                ++v131;
                v132 += 3;
                v133 += 6;
              }
              while (v131 < v127);
            }
            if (v128)
            {
              __nel = v128;
              qsort(__base, v128, 0x18uLL, (int (__cdecl *)(const void *, const void *))finishedpathcmp);
              LODWORD(v127) = v9[10];
              v101 = *(float *)&__base[6 * (v127 - 1) + 4];
            }
            else
            {
              __nel = 0;
            }
            v138 = (int (__cdecl *)(const void *, const void *))cmpdecoderIndexfunc;
          }
          else
          {
            v115 = forward_trans_decoder(a1, v49, a3, 0, 0, (uint64_t)v100, 0.0);
            if ((_DWORD)v115)
              goto LABEL_96;
            LODWORD(v127) = v9[12];
            v138 = (int (__cdecl *)(const void *, const void *))cmpvaluefunc;
          }
          qsort(v100, v127, 0xCuLL, v138);
          v139 = *v100;
          v140 = v9[10];
          if ((_DWORD)v140)
          {
            v141 = 0;
            v143 = (float *)v157;
            v142 = (float *)v159;
            v144 = v170;
            do
            {
              if (v99)
              {
                v145 = *(unsigned int *)v142;
                if (v141 != v145)
                {
                  memcpy(*((void **)v143 - 2), v144[3 * v145], 4 * v99);
                  v144 = v170;
                  v140 = v9[10];
                }
              }
              v146 = *(v142 - 2);
              *(v143 - 1) = v146;
              *v143 = v146 / v103;
              *(float *)(*((_QWORD *)v143 - 2) + 4 * v99) = (float)*((unsigned int *)v142 - 1);
              *((_DWORD *)v143 - 2) = v102;
              if (v139 < *(v143 - 1))
                v139 = *(v143 - 1);
              ++v141;
              v143 += 6;
              v142 += 3;
            }
            while (v141 < v140);
          }
          else
          {
            v140 = 0;
            v144 = v170;
          }
          v49 = v162;
          if (v102 >= v175 - 1)
            break;
          v99 = v102;
        }
        while ((float)(v139 / v98) > v101);
        if (!__nel)
          goto LABEL_100;
        qsort(__base, __nel, 0x18uLL, (int (__cdecl *)(const void *, const void *))finishedpathcmp);
        v147 = *(const void **)__base;
        LODWORD(v75) = __base[2];
      }
      memcpy(__dst, v147, 4 * v75);
    }
    v52 = 0;
    *((_DWORD *)v49 + 11) = v75;
  }
  else
  {
    log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, (uint64_t)v152);
    return 7;
  }
  return v52;
}

_QWORD *free_trans_decoder(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = *(unsigned int *)v3;
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        fi_layer_free(v3[10]);
        fi_layer_free(v3[11]);
        if ((_DWORD)v4)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            fi_layer_free(*(_QWORD *)(v3[7] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[7])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v3[7] = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t trans_decoder_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t *v9;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  const char *v14;
  uint64_t result;
  __int128 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  v8 = *(unsigned int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v13 = *v9;
    v14 = "out of memory!";
    goto LABEL_5;
  }
  v11 = *v8;
  v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 > 2u)
  {
    v13 = *v9;
    v14 = "Currently trans_decoder layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v22);
    return 7;
  }
  v16 = (__int128 *)(a1 + 20);
  if ((_DWORD)v11)
  {
    v17 = 0;
    v18 = *((_QWORD *)v8 + 7);
    v19 = 8 * v11;
    while (1)
    {
      v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v18 + v17) + 120) + 64) + 120);
      v21 = *v16;
      *(_DWORD *)(v20 + 44) = *(_DWORD *)(a1 + 36);
      *(_OWORD *)(v20 + 28) = v21;
      result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v8 + 7) + v17) + 144))();
      if ((_DWORD)result)
        break;
      v18 = *((_QWORD *)v8 + 7);
      v17 += 8;
      if (v19 == v17)
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 8) + 144))();
    if (!(_DWORD)result)
    {
      if ((*(_DWORD *)(*((_QWORD *)v8 + 8) + 40) - 1) >= 2)
      {
        v13 = **(_QWORD **)a1;
        v14 = "dense out: output shape error";
        goto LABEL_5;
      }
      result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 11) + 144))();
      if (!(_DWORD)result)
      {
        *(_DWORD *)(a1 + 40) = 1;
        *(_DWORD *)(a1 + 44) = v8[8];
        *(_DWORD *)(a1 + 56) = 4;
        result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 9) + 144))();
        if (!(_DWORD)result)
          return (*(uint64_t (**)(void))(*((_QWORD *)v8 + 10) + 144))();
      }
    }
  }
  return result;
}

uint64_t trans_decoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v12;
  unsigned int padded_bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v12 = *v9;
    padded_bytes = get_padded_bytes(4 * v9[5] * v9[8], 8u);
    if ((_DWORD)v12)
    {
      v14 = 0;
      v15 = 8 * v12;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v9 + 7) + v14) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        v14 += 8;
        if (v15 == v14)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 8) + 152))();
      if (!(_DWORD)result)
      {
        v17 = get_padded_bytes(padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 9) + 152))();
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(v17, 8u);
          result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 11) + 152))();
          if (!(_DWORD)result)
          {
            *a2 = get_padded_bytes(v18, 8u);
            *a3 = 0;
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v19, v20, v21, *(unsigned int *)(a1 + 96));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v22, v23, v24, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v25);
    return 7;
  }
  return result;
}

uint64_t trans_decoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  uint64_t result;
  uint64_t v18;
  unsigned int v19;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = *((_QWORD *)v9 + 7);
      v15 = 8 * v10;
      do
      {
        v16 = *(uint64_t (**)(void))(*(_QWORD *)(v14 + v11) + 160);
        if (v16)
        {
          result = v16();
          if ((_DWORD)result)
            return result;
          v14 = *((_QWORD *)v9 + 7);
          v13 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
          if (v13 > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      v13 = 0;
      v12 = 0;
    }
    v19 = v13;
    trans_decoder_get_reserved_glbBuf_bytes(a1, &v19);
    result = 0;
    *(_DWORD *)(a1 + 248) = v19 + v12;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t trans_decoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  unsigned int padded_bytes;

  v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    v10 = *v8;
    *((_QWORD *)v8 + 12) = v9;
    padded_bytes = get_padded_bytes(4 * v8[5] * v8[8], 8u);
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 8 * v10;
      while (1)
      {
        v13 = *(_QWORD *)(*((_QWORD *)v8 + 7) + v11);
        if (!v13)
          return 10;
        result = fi_layer_find_weights_via_offset(v13, v9, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        v11 += 8;
        if (v12 == v11)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 8), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 9), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 11), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_decoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(void);
  uint64_t v17;
  unsigned int v18;

  v9 = *(unsigned int **)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = *v9;
    trans_decoder_get_reserved_glbBuf_bytes(a1, &v18);
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = v18;
      v13 = 8 * v10;
      do
      {
        v14 = *(_QWORD *)(*((_QWORD *)v9 + 7) + v11);
        *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v12;
        *(_DWORD *)(v14 + 248) = *(_DWORD *)(a1 + 248) - v12;
        v15 = *(void (**)(void))(v14 + 168);
        if (v15)
          v15();
        v11 += 8;
      }
      while (v13 != v11);
    }
    return 0;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
}

uint64_t trans_decoder_reset(uint64_t a1)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(unsigned int **)(a1 + 120);
  v2 = *v1;
  if (!(_DWORD)v2)
    return 0;
  v4 = 0;
  v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(_QWORD *)(*((_QWORD *)v1 + 7) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_decoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

uint64_t forward_trans_decoder(uint64_t a1, uint64_t **a2, uint64_t a3, int a4, int a5, uint64_t a6, float a7)
{
  uint64_t *v11;
  unsigned int padded_len;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  size_t v17;
  float *v18;
  float *v19;
  uint64_t v20;
  float *v21;
  float *v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  float *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  float *v34;
  uint64_t v35;
  const char *v36;
  uint64_t *v37;
  size_t v38;
  float *v39;
  float *v40;
  size_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  float *v46;
  uint64_t v47;
  float v48;
  float v49;
  uint64_t v50;
  _DWORD *v51;
  uint64_t *v55;
  uint64_t v56;

  if (!a2)
    return 0;
  v55 = *a2;
  v11 = a2[15];
  padded_len = get_padded_len(*((unsigned int *)v11 + 5), 8u);
  v16 = *((_DWORD *)v11 + 12);
  if (v16 <= padded_len)
    v17 = padded_len;
  else
    v17 = v16;
  v18 = (float *)a2[30];
  v19 = &v18[v17];
  v20 = *(unsigned int *)v11;
  if ((v20 & 1) != 0)
    v21 = &v18[v17];
  else
    v21 = (float *)a2[30];
  if ((v20 & 1) != 0)
    v22 = (float *)a2[30];
  else
    v22 = &v18[v17];
  if (a7 > 0.0)
  {
    v23 = v17;
    (*(void (**)(uint64_t))(v11[9] + 128))(a1);
    v17 = v23;
  }
  v24 = *((unsigned int *)v11 + 5);
  if ((_DWORD)v24)
  {
    v25 = v11[12];
    v26 = v24 * a4;
    v27 = v21;
    do
    {
      *v27 = *(float *)(v25 + 4 * v26) + *v27;
      ++v27;
      ++v26;
      --v24;
    }
    while (v24);
  }
  v56 = a1;
  if ((_DWORD)v20)
  {
    v28 = 0;
    v29 = v20;
    v30 = (v20 - 1);
    while (1)
    {
      v31 = v17;
      bzero(v22, v17);
      v32 = v11[7];
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 8 * v28) + 120) + 64) + 120) + 104) = a3;
      v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v32 + 8 * v28) + 128))(v56);
      if ((_DWORD)v33)
        break;
      if (v22 == v18)
        v34 = v19;
      else
        v34 = v18;
      if (v28 < v30)
        v22 = v34;
      ++v28;
      v17 = v31;
      if (v29 == v28)
        goto LABEL_25;
    }
    v35 = v33;
    v37 = v55;
    v36 = "trans_decoder forward trans_dec layer failed!";
    goto LABEL_33;
  }
LABEL_25:
  if (v22 != v18)
  {
    v35 = 7;
    v36 = "(Should not be here)trans_decoder buffer switching error";
LABEL_32:
    v37 = v55;
LABEL_33:
    log_OutText(*v37, (uint64_t)"FastInfer", 0, 0, (uint64_t)v36, v13, v14, v15, a6);
    return v35;
  }
  v38 = 4 * v17;
  v39 = v19;
  v40 = v19;
  v41 = v17;
  bzero(v40, 4 * v17);
  v42 = (*(uint64_t (**)(uint64_t))(v11[8] + 128))(v56);
  if ((_DWORD)v42)
  {
    v35 = v42;
    v36 = "trans_decoder forward norm layer failed!";
    goto LABEL_32;
  }
  bzero(v18, v38);
  v43 = (*(uint64_t (**)(uint64_t))(v11[11] + 128))(v56);
  if ((_DWORD)v43)
  {
    v35 = v43;
    v36 = "att forward dense q failed!";
    goto LABEL_32;
  }
  bzero(v39, 4 * *((unsigned int *)v11 + 12));
  v44 = *((unsigned int *)v11 + 12);
  if (!(_DWORD)v44)
    return 0;
  v45 = 0.0;
  v46 = v18;
  v47 = *((unsigned int *)v11 + 12);
  do
  {
    v48 = *v46++;
    v45 = v45 + expf(v48);
    --v47;
  }
  while (v47);
  v49 = logf(v45);
  v50 = v44;
  do
  {
    v18[v41] = *v18 - v49;
    ++v18;
    --v50;
  }
  while (v50);
  v51 = (_DWORD *)(a6 + 8);
  do
  {
    v35 = 0;
    *(v51 - 2) = LODWORD(v39[v50]);
    *(v51 - 1) = v50;
    *v51 = a5;
    ++v50;
    v51 += 3;
  }
  while (v44 != v50);
  return v35;
}

uint64_t trans_decoder_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  _DWORD *v3;
  unsigned int padded_len;
  unsigned int v5;
  unsigned int v6;
  int padded_bytes;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t result;

  v3 = *(_DWORD **)(a1 + 120);
  padded_len = get_padded_len(v3[5], 8u);
  v5 = padded_len;
  v6 = v3[12];
  if (v6 <= padded_len)
    v6 = padded_len;
  padded_bytes = get_padded_bytes(8 * v6, 8u);
  v8 = v3[10];
  v9 = v3[8];
  v10 = v3[12];
  v11 = padded_bytes + 12 * v8 * v10 + 8 * v5 * (*v3 * v9 * v8 + v3[7] * *v3);
  v12 = v8 >= 2;
  v13 = 72 * v8 + 8 * v8 * v9 + 4 * (v8 * v9 + v8 + v10) + v11;
  if (v12)
    v14 = v13;
  else
    v14 = v11;
  result = get_padded_bytes(v14, 8u);
  *a2 = result;
  return result;
}

unint64_t cmpvaluefunc(float *a1, float *a2)
{
  return (__PAIR64__(*a1 < *a2, *a2) - COERCE_UNSIGNED_INT(*a1)) >> 32;
}

unint64_t finishedpathcmp(uint64_t a1, uint64_t a2)
{
  return (__PAIR64__(*(float *)(a1 + 16) < *(float *)(a2 + 16), *(_DWORD *)(a2 + 16)) - *(unsigned int *)(a1 + 16)) >> 32;
}

uint64_t cmpdecoderIndexfunc(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
}

uint64_t create_conv2d_layer(uint64_t *a1, __int128 *a2, uint64_t **a3, uint64_t ***a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v12;
  uint64_t **v13;

  v13 = 0;
  v9 = create_conv_layer(a1, a2, a3, &v13);
  if ((_DWORD)v9)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create conv layer failed!", v6, v7, v8, v12);
    v10 = v13;
  }
  else
  {
    v10 = v13;
    v13[1] = (uint64_t *)1;
    v10[16] = (uint64_t *)forward_conv_layer;
    v10[17] = (uint64_t *)free_conv_buffer;
    v10[18] = (uint64_t *)conv2d_layer_update_shape;
    v10[19] = (uint64_t *)conv_layer_wanted_wb_len;
  }
  *a4 = v10;
  return v9;
}

uint64_t conv2d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v10;
  __int128 v11;
  uint64_t result;
  int v13;
  uint64_t v14;

  if (*a2 == 3)
  {
    v10 = *(_DWORD **)(a1 + 120);
    v11 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v11;
    result = get_padding_size(*(uint64_t **)a1, v10, *(_DWORD *)(a1 + 8), a2, v10 + 14, v10 + 15, v10 + 9);
    if (!(_DWORD)result)
    {
      v13 = v10[4];
      *(_DWORD *)(a1 + 40) = 3;
      *(_DWORD *)(a1 + 44) = v13;
      *(_DWORD *)(a1 + 48) = v10[15];
      *(_DWORD *)(a1 + 52) = v10[14];
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv2d requires 3D input data", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t config_pooling1d_layer(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  return config_pooling_layer(a1, 1, a2, 1, a3, a4, a5);
}

uint64_t create_pooling1d_layer(uint64_t *a1, int a2, __int128 *a3, uint64_t **a4, uint64_t ***a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t v13;
  uint64_t **v14;

  v14 = 0;
  v10 = create_pooling_layer(a1, a2, a3, a4, &v14);
  if ((_DWORD)v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed!", v7, v8, v9, v13);
    v11 = v14;
  }
  else
  {
    v11 = v14;
    v14[18] = (uint64_t *)pooling1d_layer_update_shape;
  }
  *a5 = v11;
  return v10;
}

uint64_t pooling1d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  int v11;
  __int128 v12;
  _DWORD *v13;
  int *v14;
  uint64_t result;
  int v16;
  uint64_t v17;

  if (*a2 == 2)
  {
    v10 = *(int **)(a1 + 120);
    v11 = *(_DWORD *)(a1 + 8);
    v12 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v12;
    if ((v11 & 0xFFFFFFFE) == 0xC)
      *v10 = a2[1];
    v13 = v10 + 14;
    v14 = v10 + 15;
    result = get_padding_size(*(uint64_t **)a1, v10, v11, a2, (unsigned int *)v10 + 14, (unsigned int *)v10 + 15, v10 + 9);
    if (!(_DWORD)result)
    {
      v16 = *v14;
      *(_DWORD *)(a1 + 40) = 2;
      *(_DWORD *)(a1 + 44) = v16;
      *(_DWORD *)(a1 + 48) = *v13;
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Current conv layer only support input dim 2 or 3", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t create_reshape_layer(uint64_t *a1, __int128 *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  _OWORD *v12;
  uint64_t result;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 44),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    v12 = (_OWORD *)v11;
    result = 0;
    v14 = *a2;
    v15 = a2[1];
    *(_OWORD *)((char *)v12 + 28) = *(__int128 *)((char *)a2 + 28);
    *v12 = v14;
    v12[1] = v15;
    *((_DWORD *)v10 + 2) = 72;
    v10[16] = (uint64_t *)forward_reshape_layer;
    v10[17] = (uint64_t *)free_reshape_buffer;
    v10[18] = (uint64_t *)reshape_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v16);
    free_reshape_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_reshape_layer(uint64_t a1, uint64_t a2, const void *a3, void *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t result;
  unsigned int v9;

  v5 = *(_QWORD *)(a2 + 120);
  v9 = 0;
  if (*(_DWORD *)(v5 + 16) == 1)
  {
    result = 0;
    *(_DWORD *)(a5 + 16) = 0;
  }
  else
  {
    result = fi_shape_get_size((int *)(a2 + 40), (int *)&v9);
    if (!(_DWORD)result)
    {
      memcpy(a4, a3, 4 * v9);
      return 0;
    }
  }
  return result;
}

_QWORD *free_reshape_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t reshape_layer_update_shape(uint64_t a1, int *a2)
{
  unsigned int *v3;
  int v4;
  int v5;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v3 = *(unsigned int **)(a1 + 120);
  v4 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v4;
  v5 = a2[4];
  *(_OWORD *)(a1 + 40) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 56) = v5;
  result = fi_shape_get_size(a2, (int *)&v15 + 1);
  if (!(_DWORD)result)
  {
    v7 = *v3;
    *(_DWORD *)(a1 + 40) = *v3;
    if (v7)
    {
      v8 = v3[1];
      if (v8)
        *(_DWORD *)(a1 + 44) = v8;
      if (v7 >= 2)
      {
        v9 = v3[2];
        if (v9)
          *(_DWORD *)(a1 + 44) = v9;
        if (v7 >= 3)
        {
          v10 = v3[3];
          if (v10)
            *(_DWORD *)(a1 + 44) = v10;
        }
      }
    }
    result = fi_shape_get_size((int *)(a1 + 40), (int *)&v15);
    if (!(_DWORD)result)
    {
      if (v15 <= HIDWORD(v15))
      {
        return 0;
      }
      else
      {
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid reshape operation!", v11, v12, v13, v14);
        return 7;
      }
    }
  }
  return result;
}

uint64_t lstm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, int *a3)
{
  _BOOL4 is_enabled;
  uint64_t v7;
  int padded_len;
  uint64_t input_dim;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  int v21;
  unsigned int v22;
  BOOL v23;
  char v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  char v31;
  int v32;
  int v33;
  int v34;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;

  v37 = 0;
  v38 = 1;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v7 = *(unsigned int *)(a1 + 12);
  padded_len = get_padded_len(v7, 8u);
  input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v37);
  if ((_DWORD)input_dim)
    return input_dim;
  v10 = get_padded_len(v37, 8u);
  v11 = lstm_layer_impl_type(a1, &v38);
  if ((_DWORD)v11)
  {
    input_dim = v11;
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get LSTM impl type failed!", v12, v13, v14, v36);
    return input_dim;
  }
  if (v38 >= 2 && v38 != 3)
  {
    if (v38 != 2)
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid LSTM type: %u", v12, v13, v14, v38);
      return 7;
    }
    v15 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 16);
    v16 = get_padded_len(v15, 8u);
    if ((v15 & 3) != 0)
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"num of singulars must can be divided by 4, but got: %u", v17, v18, v19, v15);
      return 7;
    }
    input_dim = 0;
    *a2 = 4 * (v15 * (v10 + padded_len) + 4 * v7 * v16);
    v34 = 16 * v7;
LABEL_39:
    *a3 = v34;
    return input_dim;
  }
  v20 = *(int **)(a1 + 72);
  if (!v20)
  {
    if (is_enabled)
    {
      v28 = get_padded_len((4 * v7), 8u);
      v29 = 0;
LABEL_31:
      input_dim = 0;
      v30 = (v38 & 0xFFFFFFFD) == 1;
      if ((v38 & 0xFFFFFFFD) == 1)
        v31 = 3;
      else
        v31 = 5;
      v32 = v29 << v31;
      v33 = 4 * padded_len;
      if ((v38 & 0xFFFFFFFD) == 1)
        v33 = v28;
      *a2 = v32 + 4 * (v37 + v7) * v33;
      v34 = 4 * v28;
      if (!v30)
        v34 = 16 * padded_len;
      goto LABEL_39;
    }
    goto LABEL_29;
  }
  if ((v20[1] & 2) == 0 || !is_enabled)
  {
    if (is_enabled)
      goto LABEL_26;
LABEL_29:
    input_dim = 0;
    *a2 = 16 * v7 * (v10 + padded_len);
    *a3 = 16 * v7;
    return input_dim;
  }
  if (v20[2])
  {
LABEL_26:
    if (v20[2])
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"BSR and BSC haven't been implemented in LSTM yet!", v12, v13, v14, v36);
      return 7;
    }
    v28 = get_padded_len((4 * v7), 8u);
    v29 = *v20;
    goto LABEL_31;
  }
  v21 = get_padded_len((4 * v7), 8u);
  v22 = v38;
  v23 = (v38 & 0xFFFFFFFD) == 1;
  if ((v38 & 0xFFFFFFFD) == 1)
    v24 = 3;
  else
    v24 = 5;
  v25 = *v20 << v24;
  v26 = 4 * padded_len;
  if ((v38 & 0xFFFFFFFD) == 1)
    v26 = v21;
  *a2 = v25 + 4 * (v37 + v7) * v26;
  v27 = 4 * v21;
  if (!v23)
    v27 = 16 * padded_len;
  *a3 = v27;
  input_dim = 0;
  if (v22 == 3)
    *a2 += 12 * get_padded_len(v7, 8u);
  return input_dim;
}

uint64_t get_lstm_glbBufBytes(uint64_t *a1, char a2, uint64_t a3, _DWORD *a4)
{
  int padded_len;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v14;

  padded_len = get_padded_len(a3, 8u);
  v11 = 16;
  switch(a2)
  {
    case 0:
      goto LABEL_3;
    case 1:
    case 2:
    case 3:
      padded_len *= 4;
      v11 = 8;
LABEL_3:
      v12 = 0;
      *a4 = v11 * padded_len;
      break;
    default:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"not supported lstm impl!", v8, v9, v10, v14);
      v12 = 7;
      break;
  }
  return v12;
}

uint64_t create_lstm_layer_f32(uint64_t *a1, uint64_t *a2, __int128 *a3, _QWORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _OWORD *v18;
  _OWORD *v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;

  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15)
    goto LABEL_10;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16)
    goto LABEL_10;
  v17 = (_QWORD *)v16;
  v18 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 40);
  if (!v18)
    goto LABEL_10;
  v19 = v18;
  v20 = *a3;
  *(_OWORD *)((char *)v18 + 12) = *(__int128 *)((char *)a3 + 12);
  *v18 = v20;
  v21 = *a2;
  *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)(v15 + 8) = v21;
  v22 = *((unsigned int *)a2 + 1);
  *(_QWORD *)v15 = a1;
  if (a4)
    *(_QWORD *)(v15 + 60) = *a4;
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 4);
  *v17 = v23;
  if (v23
    && (v17[1] = v19,
        *(_QWORD *)(v15 + 160) = lstm_layer_request_glbBuf,
        v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 4),
        (*((_QWORD *)v19 + 4) = v24) != 0))
  {
    *(_QWORD *)(v15 + 120) = v17;
    *(_QWORD *)(v15 + 128) = forward_lstm_layer;
    *(_QWORD *)(v15 + 200) = lstm_layer_load_state;
    *(_QWORD *)(v15 + 136) = free_lstm_buffer;
    *(_QWORD *)(v15 + 144) = lstm_layer_update_shape;
    *(_QWORD *)(v15 + 152) = lstm_layer_wanted_wb_len;
    if (a5)
    {
      result = 0;
      *(_QWORD *)(v15 + 256) = *(_QWORD *)(a5 + 24);
      *(_DWORD *)(v15 + 264) = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v12, v13, v14, v26);
      result = 0;
      *(_QWORD *)(v15 + 256) = 0;
      *(_DWORD *)(v15 + 264) = 0;
    }
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v26);
    free_lstm_buffer((_QWORD *)v15);
    result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t lstm_layer_request_glbBuf(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = get_lstm_glbBufBytes(*(uint64_t **)a1, **(_DWORD **)(*(_QWORD *)(a1 + 120) + 8), *(unsigned int *)(a1 + 12), (_DWORD *)(a1 + 248));
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm gobal buffer bytes failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t lstm_layer_load_state(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  void *v11;
  uint64_t v13;
  const char *v14;
  uint64_t v15;

  v9 = **(void ***)(a1 + 120);
  if (v9)
  {
    memcpy(v9, a2, 4 * *(unsigned int *)(a1 + 12));
    v11 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 32);
    if (v11)
    {
      memcpy(v11, &a2[4 * *(unsigned int *)(a1 + 12)], 4 * *(unsigned int *)(a1 + 12));
      return 0;
    }
    v13 = **(_QWORD **)a1;
    v14 = "lstm cell setting null pointer!";
  }
  else
  {
    v13 = **(_QWORD **)a1;
    v14 = "lstm state setting null pointer!";
  }
  log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v15);
  return 10;
}

uint64_t lstm_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t vars0;

  if (*(_DWORD *)a2 == 2)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
    v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      v10 = 0;
      *(_DWORD *)(a1 + 40) = 2;
      v11 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      v10 = 0;
      v12 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D LSTM, BLSTM!", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t forward_lstm_layer_f32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  void *v5;
  unsigned int v6;
  unsigned int v7;
  _BOOL4 is_enabled;
  _BOOL4 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t input_dim;
  uint64_t lstm_step_f;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  void *v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *__dst;
  uint64_t v48;
  int v49;
  unsigned int padded_len;
  int step;
  int v52;
  uint64_t *v55;
  uint64_t (*v56)(_QWORD, void *, uint64_t, uint64_t, uint64_t, _QWORD, void *, uint64_t);
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _QWORD v61[2];

  v55 = *(uint64_t **)a1;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8);
  v5 = *(void **)(a1 + 240);
  v6 = *(_DWORD *)(v4 + 16);
  v52 = *(_DWORD *)(v4 + 12);
  v7 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v9 = is_enabled;
  v10 = *(_QWORD *)(a1 + 72);
  if (v10)
    v11 = is_enabled & (*(unsigned __int8 *)(v10 + 4) >> 1);
  else
    v11 = 0;
  v12 = *(unsigned int *)(a1 + 12);
  v61[0] = 1;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v56 = 0;
  input_dim = lstm_layer_impl_type(a1, v61);
  if (!(_DWORD)input_dim)
  {
    lstm_step_f = get_lstm_step_f(&v56, v61[0]);
    if ((_DWORD)lstm_step_f)
    {
      input_dim = lstm_step_f;
      log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm step forward function failed!", v15, v16, v17, v46);
      return input_dim;
    }
    v19 = v11 ^ 1;
    v20 = v61[0];
    if (LODWORD(v61[0]) == 2)
      v19 = 1;
    if (!v5)
    {
      log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm buf is NULL, do you forget to set pNet->glbBuf?", v15, v16, v17, v46);
      return 7;
    }
    v49 = v19;
    input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)v61 + 1);
    if (!(_DWORD)input_dim)
    {
      padded_len = get_padded_len(HIDWORD(v61[0]), 8u);
      DWORD1(v59) = v7 == 1;
      v21 = v61[0];
      if (v20 == 2 || !v9 || LODWORD(v61[0]) == 2)
      {
        LODWORD(v22) = 0;
      }
      else
      {
        v22 = *(_QWORD *)(a1 + 72);
        if (v22)
        {
          LODWORD(v59) = *(_DWORD *)(v22 + 4) & 1;
          v23 = v49;
          DWORD2(v59) = v49;
          DWORD1(v57) = 0;
          LODWORD(v22) = *(_DWORD *)(v22 + 4) & 1;
LABEL_20:
          LODWORD(v57) = v22;
          DWORD2(v57) = v23;
          get_padded_len(HIDWORD(v61[0]), 8u);
          v24 = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
          if (v21 == 2 || !v24)
          {
            v30 = *(_QWORD *)(a1 + 72);
          }
          else
          {
            if (v7 == 1 && DWORD2(v59) == 1)
            {
              v28 = *v55;
              v29 = "onehot trick only supports row major";
LABEL_34:
              log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v25, v26, v27, v46);
              v30 = 0;
              v48 = 0;
              v31 = padded_len;
              goto LABEL_35;
            }
            if (v21)
            {
              if (v21 != 3 && v21 != 1)
              {
                v28 = *v55;
                v29 = "SVD impl not supported by row major";
                goto LABEL_34;
              }
              get_padded_len((4 * v12), 8u);
            }
            else
            {
              get_padded_len(v12, 8u);
            }
            v30 = *(_QWORD *)(a1 + 72);
          }
          v48 = v30 + (*(_DWORD *)(a1 + 96) & 0xFFFFFFFC);
          v31 = padded_len;
LABEL_35:
          step = fi_shape_get_step((_DWORD *)(a1 + 20));
          if (HIDWORD(v61[0]) == (_DWORD)v31)
          {
            v32 = 0;
          }
          else
          {
            v32 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v55[1] + 16))(v55[2], v31, 4);
            if (!v32)
            {
              log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v33, v34, v35, v46);
              return 10;
            }
          }
          if (step)
          {
            __dst = (void *)v32;
            v36 = 0;
            v37 = 0;
            v38 = v30;
            while (1)
            {
              v39 = (void *)(a2 + 4 * (HIDWORD(v61[0]) * v37));
              if (HIDWORD(v61[0]) != (_DWORD)v31)
              {
                memcpy(__dst, (const void *)(a2 + 4 * (HIDWORD(v61[0]) * v37)), 4 * HIDWORD(v61[0]));
                v31 = HIDWORD(v61[0]);
                v39 = __dst;
              }
              v40 = v52 == 1 ? v36 : 0;
              v41 = a3 + 4 * v40;
              bzero(v5, *(unsigned int *)(a1 + 248));
              v42 = v56(*(_QWORD *)a1, v39, v41, v31, v12, v6, v5, v38);
              if ((_DWORD)v42)
                break;
              ++v37;
              v36 += v12;
              v31 = padded_len;
              if (step == v37)
              {
                input_dim = 0;
                goto LABEL_50;
              }
            }
            input_dim = v42;
            log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm step forward failed!", v43, v44, v45, v48);
LABEL_50:
            v32 = (uint64_t)__dst;
          }
          else
          {
            input_dim = 0;
          }
          if (v32)
            (*(void (**)(uint64_t))(v55[1] + 48))(v55[2]);
          return input_dim;
        }
      }
      LODWORD(v59) = 0;
      v23 = v49;
      DWORD2(v59) = v49;
      DWORD1(v57) = 0;
      goto LABEL_20;
    }
  }
  return input_dim;
}

uint64_t albert_trans_encoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  unsigned int v18;

  v9 = *(unsigned int **)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = *v9;
    result = albert_trans_encoder_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      if ((_DWORD)v10)
      {
        v12 = 0;
        v13 = v18;
        v14 = 8 * v10;
        do
        {
          v15 = *(_QWORD *)(*((_QWORD *)v9 + 12) + v12);
          *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          v16 = *(void (**)(void))(v15 + 168);
          if (v16)
            v16();
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t result;
  int padded_bytes;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  v3 = *(_QWORD *)(a1 + 120);
  v9 = 0;
  result = fi_shape_get_bytes((int *)(**(_QWORD **)(v3 + 96) + 40), &v9);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(v9, 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 128) + 40), &v9);
    if (!(_DWORD)result)
    {
      v6 = get_padded_bytes(v9, 8u);
      result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 144) + 40), &v9);
      if (!(_DWORD)result)
      {
        v7 = get_padded_bytes(v9, 8u);
        v8 = get_padded_bytes(v6 + 2 * padded_bytes + v7, 8u);
        result = 0;
        *a2 = v8;
      }
    }
  }
  return result;
}

_QWORD *free_albert_trans_encoder(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = *(unsigned int *)v3;
        fi_layer_free(v3[13]);
        fi_layer_free(v3[14]);
        fi_layer_free(v3[15]);
        fi_layer_free(v3[16]);
        fi_layer_free(v3[18]);
        if ((_DWORD)v4)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            fi_layer_free(*(_QWORD *)(v3[12] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[12])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v3[12] = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_albert_trans_encoder(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 152);
      v19 = v15;
      if (!v15)
      {
        v33 = *a1;
        v34 = "out of memory!";
LABEL_24:
        log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v34, v16, v17, v18, v41);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_trans_encoder init param failed!", v38, v39, v40, v41);
        result = 7;
        goto LABEL_25;
      }
      v20 = *((_OWORD *)a2 + 1);
      *v15 = *(_OWORD *)a2;
      v15[1] = v20;
      v21 = *((_OWORD *)a2 + 2);
      v22 = *((_OWORD *)a2 + 3);
      v23 = *((_OWORD *)a2 + 5);
      v15[4] = *((_OWORD *)a2 + 4);
      v15[5] = v23;
      v15[2] = v21;
      v15[3] = v22;
      v24 = *a2;
      v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v24, 8);
      *((_QWORD *)v19 + 12) = v25;
      if (!v25)
      {
        v31 = *a1;
        v32 = "out of memory!";
        goto LABEL_23;
      }
      if ((_DWORD)v24)
      {
        v29 = 0;
        v30 = 8 * v24;
        while (!create_albert_trans_enc_layer(a1, (uint64_t)(a2 + 12), a3, a4, (uint64_t *)(*((_QWORD *)v19 + 12) + v29)))
        {
          v29 += 8;
          if (v30 == v29)
            goto LABEL_10;
        }
        v31 = *a1;
        v32 = "create albert_trans_encoder albert_trans_enc layer failed!";
        goto LABEL_23;
      }
LABEL_10:
      v44 = 0;
      v41 = 0x100000000;
      v43 = 40;
      if (create_norm_layer(a1, (uint64_t *)&v43, (uint64_t *)v19 + 13))
      {
        v31 = *a1;
        v32 = "create albert_trans_encoder norm layer failed!";
LABEL_23:
        log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v26, v27, v28, v41);
        v33 = *a1;
        v34 = "albert_trans_encoder network init failed!";
        goto LABEL_24;
      }
      v35 = a2[1];
      v43 = 5;
      v44 = v35;
      if (create_fc_layer(a1, (uint64_t *)&v43, &v41, a3, a4, (uint64_t *)v19 + 16))
      {
        v31 = *a1;
        v32 = "create fc layer failed!";
        goto LABEL_23;
      }
      v36 = a2[2];
      v43 = 5;
      v44 = v36;
      v41 = 0x100000000;
      if (create_fc_layer(a1, (uint64_t *)&v43, &v41, a3, a4, (uint64_t *)v19 + 18))
      {
        v31 = *a1;
        v32 = "create classifier layer failed!";
        goto LABEL_23;
      }
      v37 = a2[22];
      LODWORD(v42) = a2[17];
      HIDWORD(v42) = v37;
      if (create_embedding_layer(a1, &v42, (uint64_t ***)v19 + 15)
        || (LODWORD(v42) = a2[17],
            HIDWORD(v42) = 32,
            create_embedding_layer(a1, &v42, (uint64_t ***)v19 + 14)))
      {
        v31 = *a1;
        v32 = "create albert_trans_encoder target_space_id emb layer failed!";
        goto LABEL_23;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 43;
      *(_QWORD *)(v7 + 128) = forward_albert_trans_encoder;
      *(_QWORD *)(v7 + 136) = free_albert_trans_encoder;
      *(_QWORD *)(v7 + 144) = albert_trans_encoder_update_shape;
      *(_QWORD *)(v7 + 152) = albert_trans_encoder_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = albert_trans_encoder_request_glbBuf;
      *(_QWORD *)(v7 + 168) = albert_trans_encoder_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = albert_trans_encoder_reset;
      *(_QWORD *)(v7 + 184) = albert_trans_encoder_dispatch_weights;
      if (!a4)
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v26, v27, v28, v41);
      result = 0;
      *(_QWORD *)(v7 + 256) = 0;
      *(_DWORD *)(v7 + 264) = 0;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v41);
      result = 10;
    }
  }
LABEL_25:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_trans_encoder(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  int *v9;
  unsigned int v13;
  unsigned int v14;
  const char *v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t updated;
  uint64_t v22;
  float *v23;
  float *v24;
  float *v25;
  int v26;
  uint64_t v27;
  float *v28;
  float *v29;
  float *v30;
  int v31;
  char *v32;
  int v33;
  size_t v34;
  float *v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  float *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  int v46;
  int i;
  int v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  int padded_len;
  float *v53;
  unsigned int step;
  unsigned int v55;
  unsigned int v56;
  float *__dst;
  int v58;
  unsigned int v59;
  float *v60;
  __int128 v61;
  int v62;
  float v63;
  int v64;

  v8 = *(uint64_t **)a2;
  v9 = *(int **)(a2 + 120);
  v64 = 0;
  v63 = 0.0;
  if (!a5)
  {
    v15 = "No opts given to encoder forward.";
LABEL_10:
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, a6, a7, a8, v50);
    updated = 7;
LABEL_11:
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_trans_encoder failed!", v17, v18, v19, v50);
    return updated;
  }
  v13 = 1;
  *(_DWORD *)(a5 + 20) = 1;
  v14 = v9[19];
  v15 = "albert_trans_encoder input too short!";
  while (v9[23] != *(float *)(a3 + 4 * (v13 - 1)))
  {
    if (v13++ > v14)
      goto LABEL_10;
  }
  if (v13 < 2)
  {
    v15 = "albert_trans_encoder input too short!";
    goto LABEL_10;
  }
  v61 = *(_OWORD *)(a2 + 20);
  if (v13 < v14)
    v14 = v13;
  v62 = *(_DWORD *)(a2 + 36);
  DWORD1(v61) = v14;
  updated = albert_trans_encoder_update_shape(a2, &v61, a3, (uint64_t)a4, (uint64_t)"albert_trans_encoder input too short!", a6, a7, a8);
  if ((_DWORD)updated)
    goto LABEL_11;
  v63 = (float)v9[21];
  v22 = v9[1];
  v58 = *v9;
  v59 = v9[17];
  updated = fi_shape_get_bytes((int *)(*((_QWORD *)v9 + 15) + 40), &v64);
  if ((_DWORD)updated)
    goto LABEL_11;
  __dst = *(float **)(a2 + 240);
  v23 = &__dst[get_padded_len(v22 * v13, 8u)];
  v56 = v22 * v13;
  padded_len = get_padded_len(v22 * v13, 8u);
  v51 = get_padded_len(v59, 8u);
  step = fi_shape_get_step((_DWORD *)(*((_QWORD *)v9 + 15) + 40));
  updated = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 15) + 128))(a1);
  if ((_DWORD)updated)
    goto LABEL_11;
  v50 = v22;
  axpy(step * v59, *((float **)v9 + 17), 1, v23, 1, 1.0);
  v24 = v23;
  if (v63 > -1.0)
  {
    updated = (*(uint64_t (**)(uint64_t, float))(*((_QWORD *)v9 + 14) + 128))(a1, v63);
    if ((_DWORD)updated)
      goto LABEL_11;
    v25 = __dst;
    v24 = v23;
    if (step)
    {
      v26 = 0;
      v27 = step;
      do
      {
        v28 = v25;
        axpy(v59, v25, 1, &v24[v26], 1, 1.0);
        v25 = v28;
        v26 += v59;
        --v27;
      }
      while (v27);
    }
  }
  v29 = &v24[padded_len];
  v30 = v24;
  v31 = get_padded_len(v59, 8u);
  bzero(v29, 4 * v31 * v13);
  updated = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 13) + 128))(a1);
  if ((_DWORD)updated)
    goto LABEL_11;
  v32 = (char *)&v29[v51 * v13];
  v33 = get_padded_len(v9[1], 8u);
  bzero(v32, 4 * v33 * v13);
  updated = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 16) + 128))(a1);
  if ((_DWORD)updated)
    goto LABEL_11;
  v53 = v29;
  v34 = 4 * get_padded_len(v56, 8u);
  v60 = v30;
  if ((v58 & 1) != 0)
  {
    memcpy(v30, v32, v34);
    v35 = __dst;
    v36 = v58;
LABEL_29:
    v37 = 0;
    v55 = v36 - 1;
    while (1)
    {
      v38 = get_padded_len(v56, 8u);
      bzero(v35, 4 * v38);
      v39 = (*(uint64_t (**)(uint64_t))(**((_QWORD **)v9 + 12) + 128))(a1);
      if ((_DWORD)v39)
        break;
      v40 = __dst;
      if (v35 != v60)
        v40 = v60;
      if (v37 >= v55)
        v30 = v35;
      else
        v30 = v40;
      ++v37;
      v35 = v30;
      if (v58 == v37)
        goto LABEL_37;
    }
    updated = v39;
    goto LABEL_11;
  }
  memcpy(__dst, v32, v34);
  v35 = v30;
  v36 = v58;
  if (v58)
    goto LABEL_29;
LABEL_37:
  if (v9[3])
  {
    bzero(v53, 4 * v50);
    v41 = v9[3];
    if (v41 == 3)
    {
      v48 = v50 * (v13 >> 1);
    }
    else
    {
      if (v41 != 2)
      {
        if (v41 == 1 && (_DWORD)v50)
        {
          v42 = 0;
          v43 = v13;
          if (v13 <= 1uLL)
            v43 = 1;
          do
          {
            v44 = v53[v42];
            v45 = v43;
            v46 = v42;
            do
            {
              v44 = v30[v46] + v44;
              v53[v42] = v44;
              v46 += v50;
              --v45;
            }
            while (v45);
            ++v42;
          }
          while (v42 != v50);
        }
LABEL_58:
        bzero(v60, 4 * v9[2]);
        updated = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 18) + 128))(a1);
        if (!(_DWORD)updated)
        {
          bzero(__dst, 4 * v9[2]);
          softmax(v60, v9[2], 1, __dst, *((float *)v9 + 20));
          memcpy(a4, __dst, 4 * v9[2]);
          return updated;
        }
        goto LABEL_11;
      }
      v49 = v9[4];
      if (v49 >= v13)
        v49 = v13 - 1;
      v48 = v49 * v50;
    }
    memcpy(v53, &v30[v48], 4 * v50);
    goto LABEL_58;
  }
  bzero(v60, 4 * v9[2] * v13);
  updated = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v9 + 18) + 128))(a1);
  if ((_DWORD)updated)
    goto LABEL_11;
  bzero(__dst, 4 * v9[2] * v13);
  for (i = 0; i != v13; ++i)
    softmax(&v60[v9[2] * i], v9[2], 1, &__dst[v9[2] * i], *((float *)v9 + 20));
  memcpy(a4, __dst, 4 * v9[2] * v13);
  return 0;
}

uint64_t albert_trans_encoder_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t *v9;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  const char *v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 *v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  __int128 v26;
  int v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  int v31;

  v8 = *(unsigned int **)(a1 + 120);
  v26 = 0uLL;
  v27 = 0;
  v9 = *(uint64_t **)a1;
  v25 = 0;
  if (!v8)
  {
    v13 = *v9;
    v14 = "out of memory!";
    goto LABEL_7;
  }
  v11 = *v8;
  v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 >= 2u)
  {
    v13 = *v9;
    v14 = "Currently albert_trans_encoder layer only support 1D input";
LABEL_7:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v24);
    return 7;
  }
  fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v25);
  if (v25 > v8[19])
  {
    v13 = *v9;
    v14 = "Encoder input shape dimension must be maximum %d. Found %d";
    v24 = v8[19];
    goto LABEL_7;
  }
  result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 15) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 13) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 16) + 144))();
      if (!(_DWORD)result)
      {
        v16 = *((_QWORD *)v8 + 12);
        if ((_DWORD)v11)
        {
          v17 = 0;
          while (1)
          {
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v16 + v17) + 144))();
            if ((_DWORD)result)
              break;
            v16 = *((_QWORD *)v8 + 12);
            v17 += 8;
            if (8 * v11 == v17)
              goto LABEL_16;
          }
        }
        else
        {
LABEL_16:
          v18 = *(_QWORD *)(v16 + 8 * (v11 - 1));
          v20 = *(_DWORD *)(v18 + 40);
          v19 = (__int128 *)(v18 + 40);
          if ((v20 - 1) >= 2)
          {
            v13 = **(_QWORD **)a1;
            v14 = "encoder out: output shape error";
            goto LABEL_7;
          }
          if (v8[3])
          {
            v26 = *v19;
            v27 = *((_DWORD *)v19 + 4);
            DWORD1(v26) = 1;
          }
          result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 18) + 144))();
          if (!(_DWORD)result)
          {
            v21 = *((_QWORD *)v8 + 18);
            v22 = *(_OWORD *)(v21 + 40);
            *(_DWORD *)(a1 + 56) = *(_DWORD *)(v21 + 56);
            *(_OWORD *)(a1 + 40) = v22;
            v28 = 0x100000001;
            v23 = v8[17];
            v29 = 32;
            v30 = v23;
            v31 = 4;
            return (*(uint64_t (**)(void))(*((_QWORD *)v8 + 14) + 144))();
          }
        }
      }
    }
  }
  return result;
}

uint64_t albert_trans_encoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    result = (*(uint64_t (**)(void))(**(_QWORD **)(v9 + 96) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(0, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 104) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 128) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 120) + 152))();
          if (!(_DWORD)result)
          {
            v16 = get_padded_bytes(v15, 8u);
            v17 = get_padded_bytes(v16 + 4 * *(_DWORD *)(v9 + 76) * *(_DWORD *)(v9 + 68), 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 144) + 152))();
            if (!(_DWORD)result)
            {
              *a2 = get_padded_bytes(v17, 8u);
              *a3 = 0;
              log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v18, v19, v20, *(unsigned int *)(a1 + 96));
              log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v21, v22, v23, *a2);
              return 0;
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v24);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  uint64_t result;
  int padded_bytes;
  uint64_t v19;
  unsigned int v20;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = *((_QWORD *)v9 + 12);
      v15 = 8 * v10;
      do
      {
        v16 = *(uint64_t (**)(void))(*(_QWORD *)(v14 + v11) + 160);
        if (v16)
        {
          result = v16();
          if ((_DWORD)result)
            return result;
          v14 = *((_QWORD *)v9 + 12);
          v13 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
          if (v13 > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      v13 = 0;
      v12 = 0;
    }
    v20 = v13;
    result = albert_trans_encoder_get_reserved_glbBuf_bytes(a1, &v20);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(v20 + v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v19);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(v8 + 136) = v9;
    padded_bytes = get_padded_bytes(4 * *(_DWORD *)(v8 + 68) * *(_DWORD *)(v8 + 76), 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 120), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 104), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 128), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          v11 = **(_QWORD **)(v8 + 96);
          if (v11)
          {
            result = fi_layer_find_weights_via_offset(v11, v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 144), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                get_padded_bytes(padded_bytes, 8u);
                return 0;
              }
            }
          }
          else
          {
            return 10;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v12);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_reset(uint64_t a1)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(unsigned int **)(a1 + 120);
  v2 = *v1;
  if (!(_DWORD)v2)
    return 0;
  v4 = 0;
  v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(_QWORD *)(*((_QWORD *)v1 + 12) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_trans_encoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

_QWORD *free_upsample_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_upsample_layer(uint64_t *a1, _OWORD *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t result;
  __int128 v14;
  uint64_t v15;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1, (v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 56)) != 0))
  {
    v12 = (uint64_t *)v11;
    result = 0;
    v14 = a2[1];
    *(_OWORD *)v12 = *a2;
    *((_OWORD *)v12 + 1) = v14;
    *((_DWORD *)v10 + 2) = 73;
    v10[15] = v12;
    v10[16] = (uint64_t *)forward_upsample_layer;
    v10[17] = (uint64_t *)free_upsample_buffer;
    v10[18] = (uint64_t *)upsample_layer_update_shape;
    v10[28] = (uint64_t *)upsample_layer_update_param;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v15);
    free_upsample_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_upsample_layer(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v12;
  int v13;
  uint64_t *v15;
  int v16;
  BOOL v17;
  uint64_t *v19;

  v7 = *(uint64_t **)a2;
  v8 = *(_QWORD *)(a2 + 120);
  v19 = 0;
  v9 = *(_DWORD *)(v8 + 4);
  if (v9 == *(_DWORD *)v8)
  {
    v10 = 0;
    *(_DWORD *)(a5 + 16) = 0;
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 44);
    v10 = src_generate(v7, v9, *(_DWORD *)v8, (uint64_t *)&v19);
    if (!(_DWORD)v10)
    {
      if (*(_DWORD *)(v8 + 32) == 1 && *(_DWORD *)(v8 + 44))
        memcpy((void *)v19[4], *(const void **)(v8 + 48), 4 * *((unsigned int *)v19 + 10));
      src_filt(v19, a3, v12, a4);
      if (*(_DWORD *)(v8 + 32) == 1)
      {
        v13 = *(_DWORD *)(v8 + 44);
        if (v13 != 2 && v13 != 5)
          memcpy(*(void **)(v8 + 48), (const void *)v19[4], 4 * *((unsigned int *)v19 + 10));
      }
      v10 = 0;
    }
  }
  v15 = v19;
  if (v19)
  {
    if (*v19)
    {
      (*(void (**)(uint64_t, _QWORD))(v7[1] + 48))(v7[2], *v19);
      *v19 = 0;
      *v19 = 0;
      v15 = v19;
    }
    if (v15[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v7[1] + 48))(v7[2], v15[4]);
      v19[4] = 0;
    }
    (*(void (**)(uint64_t))(v7[1] + 48))(v7[2]);
    v19 = 0;
  }
  if ((_DWORD)v10
    || *(_DWORD *)(v8 + 32) == 1 && ((v16 = *(_DWORD *)(v8 + 44), v16 != 5) ? (v17 = v16 == 2) : (v17 = 1), v17))
  {
    if (*(_QWORD *)(v8 + 48))
    {
      (*(void (**)(uint64_t))(v7[1] + 80))(v7[2]);
      *(_QWORD *)(v8 + 48) = 0;
    }
  }
  return v10;
}

uint64_t upsample_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _DWORD *v11;
  uint64_t result;
  __int128 v13;
  __int128 v14;
  int v15;
  uint64_t v16;

  v10 = a1 + 40;
  v11 = *(_DWORD **)(a1 + 120);
  if (*a2 == 1)
  {
    result = 0;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"upsample layer only accepts 1-dimensional input!", a6, a7, a8, v16);
    result = 7;
  }
  v13 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v13;
  v14 = *(_OWORD *)a2;
  *(_DWORD *)(v10 + 16) = a2[4];
  *(_OWORD *)v10 = v14;
  v15 = v11[1];
  if (v15 != *v11)
    *(_DWORD *)(a1 + 44) = a2[1] / *v11 * v15;
  return result;
}

uint64_t upsample_layer_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  if (a3 != 16)
    return 7;
  v4 = *(_QWORD *)(a1 + 120);
  v5 = *a2;
  v6 = a2[1];
  *(_DWORD *)(v4 + 32) = *a2;
  *(_DWORD *)(v4 + 44) = v6;
  if (v5 != 1 || v6 != 0)
    return 0;
  result = 0;
  *(_QWORD *)(v4 + 48) = *((_QWORD *)a2 + 1);
  return result;
}

uint64_t create_fc_layer(uint64_t *a1, uint64_t *a2, _QWORD *a3, _QWORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v22;

  v7 = 0;
  v8 = 7;
  if (!a1 || !a2 || !a3)
    goto LABEL_11;
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v7
    || (v17 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) == 0)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v22);
    v8 = 10;
LABEL_11:
    free_fc_buffer((_QWORD *)v7);
    goto LABEL_12;
  }
  *v17 = *a3;
  *(_QWORD *)(v7 + 120) = v17;
  v18 = *a2;
  *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)v7 = a1;
  *(_QWORD *)(v7 + 8) = v18;
  if (a4)
    *(_QWORD *)(v7 + 60) = *a4;
  if (a5)
  {
    v19 = *(_QWORD *)(a5 + 24);
    v20 = *(_DWORD *)(a5 + 16);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v14, v15, v16, v22);
    v19 = 0;
    v20 = 0;
  }
  v8 = 0;
  *(_QWORD *)(v7 + 256) = v19;
  *(_DWORD *)(v7 + 264) = v20;
  *(_QWORD *)(v7 + 128) = forward_fc_layer;
  *(_QWORD *)(v7 + 136) = free_fc_buffer;
  *(_QWORD *)(v7 + 144) = fc_layer_update_shape;
  *(_QWORD *)(v7 + 152) = fc_layer_wanted_wb_len;
LABEL_12:
  *a6 = v7;
  return v8;
}

uint64_t forward_fc_layer(uint64_t a1, uint64_t a2, float *a3, float32x4_t *a4)
{
  if (a1 && *(_DWORD *)(a1 + 8))
    return 0;
  else
    return forward_fc_layer_f32(a2, a3, a4);
}

_QWORD *free_fc_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t fc_layer_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t vars0;

  v8 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v8;
  if (*(_DWORD *)a2 == 2)
  {
    v9 = 0;
    *(_DWORD *)(a1 + 40) = 2;
    v11 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 48) = v11;
  }
  else
  {
    if (*(_DWORD *)a2 != 1)
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently fc layer only support 1D or 2D input", a6, a7, a8, vars0);
      return 7;
    }
    v9 = 0;
    v10 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v10;
  }
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
  return v9;
}

uint64_t fc_layer_wanted_wb_len(uint64_t a1, int *a2, int *a3)
{
  uint64_t v6;
  _BOOL4 is_enabled;
  _BOOL4 v8;
  uint64_t result;
  uint64_t padded_len;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  int v24;
  int v25;
  int bsc_data_len;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  _DWORD *v37;
  uint64_t v38;
  unsigned int v39;

  v39 = 0;
  v6 = *(_QWORD *)(a1 + 120);
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v8 = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v39);
  if ((_DWORD)result)
    return result;
  padded_len = get_padded_len(v39, 8u);
  v11 = *(unsigned int *)(a1 + 12);
  v12 = get_padded_len(v11, 8u);
  if (is_enabled || v8)
  {
    v16 = v12;
    v17 = *(_QWORD *)(a1 + 72);
    if (v17)
      v18 = *(unsigned int *)(v17 + 8);
    else
      v18 = 0;
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k : %d", v13, v14, v15, v18);
    v23 = *(int **)(a1 + 72);
    if (v23)
    {
      v24 = v23[1];
      if ((_DWORD)v18)
      {
        if ((v24 & 8) != 0)
        {
          log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v19, v20, v21, v38);
          return 7;
        }
        v25 = *v23;
        if ((v24 & 2) != 0)
        {
          bsc_data_len = get_bsc_data_len(v18, padded_len);
LABEL_14:
          v22 = bsc_data_len + v25;
          goto LABEL_15;
        }
LABEL_13:
        bsc_data_len = get_bsc_data_len(v18, v11);
        goto LABEL_14;
      }
      if ((v24 & 2) != 0)
      {
        v35 = v39;
        if ((v24 & 8) == 0)
        {
          v27 = 4 * (*v23 + v39 * v16);
          goto LABEL_16;
        }
        v36 = get_padded_len(v11, 0x20u) * v35;
      }
      else
      {
        if ((v24 & 8) == 0)
        {
          LODWORD(v23) = 4 * *v23;
          goto LABEL_23;
        }
        v36 = get_padded_len(v39, 0x20u) * v11;
      }
      v37 = *(_DWORD **)(a1 + 72);
      if (v37)
        LODWORD(v37) = 4 * *v37;
      v27 = (_DWORD)v37 + v36;
      goto LABEL_16;
    }
    v25 = 0;
    if ((_DWORD)v18)
      goto LABEL_13;
LABEL_23:
    v27 = (_DWORD)v23 + 4 * v11 * padded_len;
    goto LABEL_16;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k : %d", v13, v14, v15, 0);
  v22 = v11 * padded_len;
LABEL_15:
  v27 = 4 * v22;
  v16 = v11;
LABEL_16:
  *a2 = v27;
  v28 = 4 * v16;
  *a3 = 4 * v16;
  if (!*(_DWORD *)(v6 + 4))
    v28 = 0;
  *a3 = v28;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v19, v20, v21, v11);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v29, v30, v31, *(unsigned int *)(a1 + 96));
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"x=%u, padded_x=%u, h=%u, wBytes=4*(h*padded_x)=%u, bBytes=4*h=%u, wBytes+bBytes=%u", v32, v33, v34, v39);
  return 0;
}

uint64_t create_highways(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24);
      v19 = v15;
      if (!v15)
      {
        v21 = "out of memory!";
        goto LABEL_22;
      }
      v20 = *(_QWORD *)a2;
      *(_DWORD *)(v15 + 8) = a2[2];
      *(_QWORD *)v15 = v20;
      if (v20 > 0xC8)
      {
        v21 = "number of highways exploded!";
LABEL_22:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, v34);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highways init param failed!", v31, v32, v33, v35);
        result = 7;
        goto LABEL_23;
      }
      if (!(_DWORD)v20)
      {
        v21 = "number of highways must be greater than zero!";
        goto LABEL_22;
      }
      v22 = *a2;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 8);
      *(_QWORD *)(v19 + 16) = v23;
      if (!v23)
      {
        v30 = "out of memory!";
LABEL_21:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v24, v25, v26, v34);
        v21 = "highways network init failed!";
        goto LABEL_22;
      }
      if ((_DWORD)v22)
      {
        v27 = 0;
        v28 = (uint64_t *)(a2 + 1);
        v29 = 8 * v22;
        v30 = "create highways sub-highway layer failed!";
        while (!create_highway_layer(a1, v28, a3, a4, (uint64_t *)(*(_QWORD *)(v19 + 16) + v27)))
        {
          v27 += 8;
          if (v29 == v27)
            goto LABEL_15;
        }
        goto LABEL_21;
      }
LABEL_15:
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_highways;
      *(_QWORD *)(v7 + 136) = free_highways;
      *(_QWORD *)(v7 + 144) = highways_update_shape;
      *(_QWORD *)(v7 + 152) = highways_wanted_wb_len;
      *(_QWORD *)(v7 + 8) = 54;
      *(_QWORD *)(v7 + 184) = highways_dispatch_weights;
      *(_QWORD *)(v7 + 160) = highways_request_glbBuf;
      *(_QWORD *)(v7 + 168) = highways_assign_glbBuf;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v24, v25, v26, v34);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      result = 10;
    }
  }
LABEL_23:
  *a5 = v7;
  return result;
}

uint64_t forward_highways(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  unsigned int *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t bytes;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  size_t v23;

  LODWORD(v23) = 0;
  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(unsigned int **)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v22);
    return 7;
  }
  v12 = *(_QWORD *)(a2 + 240);
  v13 = *v9;
  bytes = fi_shape_get_bytes((int *)(a2 + 20), &v23);
  if (!(_DWORD)bytes)
  {
    if ((_DWORD)v13)
    {
      v15 = 0;
      while (1)
      {
        v16 = (void *)((((_BYTE)v13 + (_BYTE)v15) & 1) != 0 ? a4 : v12);
        bzero(v16, v23);
        v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v9 + 2) + 8 * v15) + 128))(a1);
        if ((_DWORD)v17)
          break;
        if (v13 == ++v15)
          return 0;
      }
      bytes = v17;
      log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highways forward sub-highway layer failed!", v18, v19, v20, v22);
      return bytes;
    }
    return 0;
  }
  return bytes;
}

_QWORD *free_highways(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (unsigned int *)result[15];
      if (v3)
      {
        v4 = *v3;
        if ((_DWORD)v4)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            fi_layer_free(*(_QWORD *)(*((_QWORD *)v3 + 2) + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (*((_QWORD *)v3 + 2))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *((_QWORD *)v3 + 2) = 0;
        }
        (*(void (**)(_QWORD, unsigned int *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 highways_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t *v9;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  const char *v14;
  __n128 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __n128 result;
  uint64_t v20;

  v8 = *(unsigned int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v13 = *v9;
    v14 = "NULL param!";
    goto LABEL_11;
  }
  v11 = *v8;
  v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 > 2u)
  {
    v13 = *v9;
    v14 = "Currently highway layer only support 1D or 2D input";
LABEL_11:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v20);
    return result;
  }
  v15 = (__n128 *)(a1 + 20);
  if (!(_DWORD)v11)
  {
LABEL_9:
    if (v15->n128_u32[0] < 3)
    {
      result = *v15;
      *(_DWORD *)(a1 + 56) = v15[1].n128_u32[0];
      *(__n128 *)(a1 + 40) = result;
      return result;
    }
    v13 = *v9;
    v14 = "final output shape error: Currently highways only support 1D or 2D output";
    goto LABEL_11;
  }
  v16 = 0;
  v17 = *((_QWORD *)v8 + 2);
  v18 = 8 * v11;
  while (!(*(unsigned int (**)(void))(*(_QWORD *)(v17 + v16) + 144))())
  {
    v17 = *((_QWORD *)v8 + 2);
    v15 = (__n128 *)(*(_QWORD *)(v17 + v16) + 40);
    v16 += 8;
    if (v18 == v16)
      goto LABEL_9;
  }
  return result;
}

uint64_t highways_wanted_wb_len(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int padded_bytes;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v12 = *v9;
    if ((_DWORD)v12)
    {
      v13 = 0;
      padded_bytes = 0;
      v15 = 8 * v12;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v9 + 2) + v13) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        v13 += 8;
        if (v15 == v13)
          goto LABEL_9;
      }
    }
    else
    {
      padded_bytes = 0;
LABEL_9:
      *a2 = padded_bytes;
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_highways: %d\n", a6, a7, a8, *v9);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v17, v18, v19, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v20, v21, v22, *a2);
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v23);
    return 7;
  }
  return result;
}

uint64_t highways_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(void);
  uint64_t result;
  uint64_t v17;
  int v18;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = *((_QWORD *)v9 + 2);
      v14 = 8 * v10;
      do
      {
        v15 = *(uint64_t (**)(void))(*(_QWORD *)(v13 + v11) + 160);
        if (v15)
        {
          result = v15();
          if ((_DWORD)result)
            return result;
          v13 = *((_QWORD *)v9 + 2);
          if (*(_DWORD *)(*(_QWORD *)(v13 + v11) + 248) > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v13 + v11) + 248);
        }
        v11 += 8;
      }
      while (v14 != v11);
    }
    else
    {
      v12 = 0;
    }
    v18 = 0;
    result = fi_shape_get_bytes((int *)(a1 + 20), &v18);
    if (!(_DWORD)result)
      *(_DWORD *)(a1 + 248) = v18 + v12;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t highways_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    v9 = *v8;
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = *(_QWORD *)(a1 + 72);
      v12 = 8 * v9;
      while (1)
      {
        v13 = *(_QWORD *)(*((_QWORD *)v8 + 2) + v10);
        if (!v13)
          break;
        result = fi_layer_find_weights_via_offset(v13, v11, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        v10 += 8;
        if (v12 == v10)
          return 0;
      }
      return 10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
}

uint64_t highways_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  unsigned int v18;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    v18 = 0;
    result = fi_shape_get_bytes((int *)(a1 + 20), &v18);
    if (!(_DWORD)result)
    {
      if ((_DWORD)v10)
      {
        v12 = 0;
        v13 = v18;
        v14 = 8 * v10;
        do
        {
          v15 = *(_QWORD *)(*((_QWORD *)v9 + 2) + v12);
          *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          v16 = *(void (**)(void))(v15 + 168);
          if (v16)
            v16();
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t config_highways_layer(int a1, int a2, int a3, _DWORD *a4)
{
  a4[1] = a2;
  a4[2] = a3;
  *a4 = a1;
  return 0;
}

uint64_t create_repeat_layer(uint64_t *a1, uint64_t *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v22;

  if (!*a3)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat count should be positive, got %d", a6, a7, a8, 0);
    v17 = 0;
    v20 = 7;
LABEL_9:
    free_repeat_buffer(v17);
    goto LABEL_10;
  }
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v17 = (_QWORD *)v13;
  if (!v13)
    goto LABEL_8;
  *(_QWORD *)v13 = a1;
  v18 = *a2;
  *(_DWORD *)(v13 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)(v13 + 8) = v18;
  if (a4)
    *(_QWORD *)(v13 + 60) = *a4;
  v19 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4);
  v17[15] = v19;
  if (!v19)
  {
LABEL_8:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v22);
    v20 = 10;
    goto LABEL_9;
  }
  v20 = 0;
  *v19 = *a3;
  v17[16] = forward_repeat_layer;
  v17[17] = free_repeat_buffer;
  v17[18] = repeat_layer_update_shape;
LABEL_10:
  *a5 = v17;
  return v20;
}

uint64_t forward_repeat_layer(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  _DWORD *v6;
  uint64_t input_dim;
  unsigned int v8;
  unint64_t v9;
  unsigned int v10;
  size_t v11;
  unsigned int v13;

  v6 = *(_DWORD **)(a2 + 120);
  v13 = 0;
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v13);
  if (!(_DWORD)input_dim && *v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = v13;
    v11 = 4 * v13;
    do
    {
      memcpy((void *)(a4 + 4 * v8), a3, v11);
      ++v9;
      v8 += v10;
    }
    while (v9 < *v6);
  }
  return input_dim;
}

_QWORD *free_repeat_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t repeat_layer_update_shape(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v8 = *(_DWORD **)(a1 + 120);
  v9 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v9;
  v10 = *a2;
  if ((_DWORD)v10 != 1)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat layer only works on 1D data, got %d", a6, a7, a8, v10);
    return 7;
  }
  if (!a2[1])
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat layer only works on data which dimension > 0", a6, a7, a8, v13);
    return 7;
  }
  v11 = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 44) = a2[1] * *v8;
  *(_DWORD *)(a1 + 56) = a2[4];
  return v11;
}

uint64_t create_blstm_layer(uint64_t *a1, uint64_t *a2, __int128 *a3, _QWORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t result;
  uint64_t v26;

  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15)
    goto LABEL_10;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16)
    goto LABEL_10;
  v17 = (_QWORD *)v16;
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 40);
  if (!v18)
    goto LABEL_10;
  v19 = v18;
  v20 = *a2;
  *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)v15 = a1;
  *(_QWORD *)(v15 + 8) = v20;
  if (a4)
    *(_QWORD *)(v15 + 60) = *a4;
  v21 = 2 * get_padded_len(*((unsigned int *)a2 + 1), 8u);
  v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4);
  *v17 = v22;
  if (v22
    && (v17[1] = v19,
        v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4),
        (*(_QWORD *)(v19 + 32) = v23) != 0))
  {
    v24 = *a3;
    *(_OWORD *)(v19 + 12) = *(__int128 *)((char *)a3 + 12);
    *(_OWORD *)v19 = v24;
    *(_QWORD *)(v15 + 120) = v17;
    *(_QWORD *)(v15 + 128) = forward_blstm_layer;
    *(_QWORD *)(v15 + 136) = free_blstm_buffer;
    *(_QWORD *)(v15 + 144) = blstm_layer_update_shape;
    *(_QWORD *)(v15 + 152) = blstm_layer_wanted_wb_len;
    *(_QWORD *)(v15 + 160) = blstm_layer_request_glbBuf;
    if (a5)
    {
      result = 0;
      *(_QWORD *)(v15 + 256) = *(_QWORD *)(a5 + 24);
      *(_DWORD *)(v15 + 264) = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v12, v13, v14, v26);
      result = 0;
      *(_QWORD *)(v15 + 256) = 0;
      *(_DWORD *)(v15 + 264) = 0;
    }
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v26);
    free_blstm_buffer((_QWORD *)v15);
    result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t forward_blstm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  _BOOL4 is_enabled;
  char *v11;
  uint64_t input_dim;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t lstm_step_f;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  const char *v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  char *v43;
  char *v44;
  _BOOL4 v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  unint64_t v49;
  _BOOL4 v50;
  int v51;
  unsigned int v52;
  char *v53;
  size_t v54;
  char *v55;
  int step;
  _BOOL4 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int *v67;
  unint64_t v68;
  uint64_t v69;
  int padded_len;
  char *v71;
  uint64_t v73[4];
  unsigned int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  char *v82;
  uint64_t v83;
  _OWORD *v84;
  _OWORD *v85;
  uint64_t v86[4];
  unsigned int v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int *v92;
  uint64_t v93;
  char *v94;
  char *v95;
  uint64_t v96;
  _OWORD *v97;
  _OWORD *v98;
  _OWORD v99[2];
  _OWORD v100[2];
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  unsigned int v105[3];

  v6 = *(uint64_t **)a2;
  v7 = *(_QWORD *)(*(_QWORD *)(a2 + 120) + 8);
  v105[0] = 0;
  v8 = *(unsigned int *)(a2 + 12);
  padded_len = get_padded_len(v8, 8u);
  v68 = *(unsigned int *)(a2 + 248);
  v69 = *(_QWORD *)(a2 + 240);
  v71 = *(char **)(v7 + 32);
  v9 = *(_DWORD *)(a2 + 16) & 0xFFFFFFFD;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 4u, *(_DWORD *)(a2 + 264));
  v11 = **(char ***)(a2 + 120);
  v103 = a3;
  v104 = 0;
  v102 = 1;
  v101 = 0;
  memset(v100, 0, sizeof(v100));
  memset(v99, 0, sizeof(v99));
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)v105);
  if ((_DWORD)input_dim)
  {
    v16 = input_dim;
    v17 = *v6;
    v18 = "get input dim function failed!";
LABEL_3:
    log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, v13, v14, v15, v58);
    goto LABEL_5;
  }
  v66 = v7;
  v16 = lstm_layer_impl_type(a2, &v102);
  if (!(_DWORD)v16)
  {
    lstm_step_f = get_lstm_step_f(&v101, v102);
    if ((_DWORD)lstm_step_f)
    {
      v16 = lstm_step_f;
      v17 = *v6;
      v18 = "get lstm step forward function failed!";
      goto LABEL_3;
    }
    v21 = get_padded_len(v105[0], 8u);
    v22 = v102;
    v23 = v105[0];
    v24 = get_padded_len(v105[0], 8u);
    v28 = *(unsigned int **)(a2 + 72);
    if (v28)
    {
      v29 = (*((unsigned __int8 *)v28 + 4) >> 1) & 1;
      if (!is_enabled)
        v29 = 0;
      if ((v29 & 1) != 0 || v9 != 1)
      {
        if (v29)
        {
          if (!v22)
          {
            v65 = v21;
            v30 = v8;
            v31 = 4 * get_padded_len(v8, 8u);
            v32 = 4;
            goto LABEL_27;
          }
          if (v22 == 3 || v22 == 1)
          {
            v65 = v21;
            v30 = v8;
            v31 = get_padded_len((4 * v8), 8u);
            v32 = 1;
LABEL_27:
            v28 = *(unsigned int **)(a2 + 72);
            if (v28)
              v42 = *v28;
            else
              v42 = 0;
            v44 = v11;
            v48 = v42 * v32;
            v36 = (uint64_t)&v28[v31 * v23 + v48];
            v49 = *(unsigned int *)(a2 + 96);
            v38 = (uint64_t)v28 + ((v49 >> 1) & 0x7FFFFFFC);
            v39 = v38 + 4 * v31 * v23 + 4 * v48;
            v40 = (uint64_t)v28 + (v49 & 0xFFFFFFFC);
            v41 = v40 + (((unint64_t)*(unsigned int *)(a2 + 112) >> 1) & 0x7FFFFFFC);
            DWORD1(v100[0]) = v9 == 1;
            v43 = v71;
            goto LABEL_31;
          }
          v33 = *v6;
          v34 = "SVD impl not supported by row major";
LABEL_22:
          log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v34, v25, v26, v27, v58);
          v16 = 7;
          goto LABEL_5;
        }
LABEL_23:
        v65 = v21;
        v30 = v8;
        v35 = 4 * v8 * v24;
        v36 = (uint64_t)&v28[v35];
        v37 = *(unsigned int *)(a2 + 96);
        v38 = (uint64_t)v28 + ((v37 >> 1) & 0x7FFFFFFC);
        v39 = v38 + 4 * v35;
        v40 = (uint64_t)v28 + (v37 & 0xFFFFFFFC);
        v41 = v40 + (((unint64_t)*(unsigned int *)(a2 + 112) >> 1) & 0x7FFFFFFC);
        DWORD1(v100[0]) = v9 == 1;
        if (!is_enabled)
        {
          v60 = v40;
          v61 = v41;
          v59 = (uint64_t)&v28[v35];
          v63 = v38 + 4 * v35;
          v64 = v38;
          v67 = (int *)v28;
          v62 = 0;
          v45 = 1;
          LODWORD(v100[0]) = 0;
          DWORD2(v100[0]) = 1;
          *(_QWORD *)&v99[0] = 0;
          v43 = v71;
          v44 = v11;
          v46 = v66;
          v47 = padded_len;
LABEL_38:
          v53 = &v43[4 * v47];
          DWORD2(v99[0]) = v45;
          v54 = 4 * v30;
          v55 = &v44[4 * v47];
          if (!*(_DWORD *)(v46 + 24))
          {
            bzero(v44, v54);
            bzero(v55, v54);
          }
          bzero(v43, v54);
          bzero(v53, v54);
          step = fi_shape_get_step((_DWORD *)(a2 + 20));
          v16 = createAlignedInputs((uint64_t)v6, v105[0], v65, step, &v103, &v104);
          if (!(_DWORD)v16)
          {
            v86[0] = a2;
            v86[1] = v101;
            v86[2] = v103;
            v86[3] = a4;
            v87 = v105[0];
            v88 = v8;
            v89 = v62;
            v90 = v69;
            v91 = v68 >> 1;
            v92 = v67;
            v93 = v60;
            v94 = v11;
            v95 = v71;
            v96 = v59;
            v97 = v100;
            v98 = v99;
            v73[2] = v103;
            v73[3] = a4;
            v74 = v105[0];
            v75 = v8;
            v76 = v62;
            v77 = v69 + ((v68 >> 1) & 0x7FFFFFFC);
            v78 = v91;
            v79 = v64;
            v80 = v61;
            v81 = v55;
            v82 = v53;
            v83 = v63;
            v84 = v100;
            v85 = v99;
            v57 = v6[3] != 0;
            v73[0] = a2;
            v73[1] = v101;
            v16 = doPasses((uint64_t)v6, v57, v86, v73);
          }
          goto LABEL_5;
        }
        v42 = 0;
        v43 = v71;
        v44 = v11;
LABEL_31:
        v50 = 1;
        v62 = v42;
        v60 = v40;
        v61 = v41;
        if (v28)
        {
          v51 = v28[1] & 1;
          v50 = ((v28[1] >> 1) & 1) == 0;
        }
        else
        {
          v51 = 0;
        }
        v47 = padded_len;
        LODWORD(v100[0]) = v51;
        DWORD2(v100[0]) = v50;
        DWORD1(v99[0]) = 0;
        v67 = (int *)v28;
        v63 = v39;
        v64 = v38;
        if (v36)
        {
          v59 = v36;
          v52 = *(_DWORD *)(v36 + 4);
          LODWORD(v99[0]) = v52 & 1;
          v45 = ((v52 >> 1) & 1) == 0;
        }
        else
        {
          v59 = 0;
          LODWORD(v99[0]) = 0;
          v45 = 1;
        }
        v46 = v66;
        goto LABEL_38;
      }
    }
    else if (v9 != 1)
    {
      goto LABEL_23;
    }
    v33 = *v6;
    v34 = "onehot trick only supports row major";
    goto LABEL_22;
  }
LABEL_5:
  if (v104)
    (*(void (**)(uint64_t))(v6[1] + 48))(v6[2]);
  return v16;
}

_QWORD *free_blstm_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = v3[1];
        if (v4)
        {
          if (*(_QWORD *)(v4 + 32))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 32) = 0;
          }
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t blstm_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t vars0;

  if (*(_DWORD *)a2 == 2)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
    v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      v10 = 0;
      *(_DWORD *)(a1 + 40) = 2;
      v11 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      v10 = 0;
      v12 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D LSTM, BLSTM!", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t blstm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t result;

  result = lstm_layer_wanted_wb_len(a1, a2, a3);
  if (!(_DWORD)result)
  {
    *a2 *= 2;
    *a3 *= 2;
  }
  return result;
}

uint64_t blstm_layer_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v2 = *(_DWORD **)(*(_QWORD *)(a1 + 120) + 8);
  v3 = *(unsigned int *)(a1 + 12);
  v9 = 0;
  result = get_lstm_glbBufBytes(*(uint64_t **)a1, *v2, v3, &v9);
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm gobal buffer bytes failed!", v5, v6, v7, v8);
    return 7;
  }
  else
  {
    *(_DWORD *)(a1 + 248) = 2 * v9;
  }
  return result;
}

uint64_t createAlignedInputs(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v10;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;

  if (a2 == a3)
    return 0;
  LODWORD(v10) = a4;
  v14 = (**(uint64_t (***)(_QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 16), 4 * (a4 * a3));
  *a6 = v14;
  if (v14)
  {
    if ((_DWORD)v10)
    {
      v18 = 0;
      v19 = 0;
      v10 = v10;
      do
      {
        memcpy((void *)(*a6 + 4 * v18), (const void *)(*a5 + 4 * v19), 4 * a2);
        v19 += a2;
        v18 += a3;
        --v10;
      }
      while (v10);
      v14 = *a6;
    }
    v7 = 0;
    *a5 = v14;
  }
  else
  {
    log_OutText(*(_QWORD *)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v6);
    return 10;
  }
  return v7;
}

uint64_t doForwardSteps(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int padded_len;
  unsigned int step;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v24;
  uint64_t *v25;

  v4 = *a2;
  v5 = *(_QWORD *)(*(_QWORD *)(*a2 + 120) + 8);
  v6 = *(_DWORD *)(v5 + 12);
  padded_len = get_padded_len(*((unsigned int *)a2 + 8), 8u);
  step = fi_shape_get_step((_DWORD *)(v4 + 20));
  if (!step)
    return 0;
  v25 = a1;
  v9 = 0;
  v10 = 0;
  v11 = 2 * step;
  while (1)
  {
    v12 = a2[3];
    v13 = *((unsigned int *)a2 + 9);
    v14 = v12 + 4 * (v10 * v13);
    if (v6 != 1)
      v14 = a2[3];
    v15 = v12 + 4 * v13;
    v16 = v12 + 4 * (v13 + v13 * v10);
    if (v6 != 1)
      v16 = v15;
    v17 = *(_DWORD *)(v5 + 20) == 1 ? v16 : v14;
    v24 = *(_OWORD *)(a2 + 9);
    v18 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))a2[1])(*(_QWORD *)v4, a2[2] + 4 * v9, v17, *((unsigned int *)a2 + 8));
    if ((_DWORD)v18)
      break;
    v10 += 2;
    v9 += padded_len;
    if (v11 == v10)
      return 0;
  }
  v22 = v18;
  log_OutText(*v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm forward failed!", v19, v20, v21, v24);
  return v22;
}

uint64_t doBackwardSteps(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int padded_len;
  unsigned int step;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v22;
  uint64_t *v23;

  v4 = *a2;
  v5 = *(_QWORD *)(*(_QWORD *)(*a2 + 120) + 8);
  v6 = *(_DWORD *)(v5 + 12);
  padded_len = get_padded_len(*((unsigned int *)a2 + 8), 8u);
  step = fi_shape_get_step((_DWORD *)(v4 + 20));
  if (!step)
    return 0;
  v23 = a1;
  v9 = step;
  v10 = 2 * step - 2;
  v11 = padded_len * (step - 1);
  while (1)
  {
    v12 = a2[3];
    v13 = *((unsigned int *)a2 + 9);
    v14 = v12 + 4 * v13;
    if (v6 == 1)
    {
      v14 = v12 + 4 * (v13 + v13 * v10);
      v12 += 4 * (v10 * v13);
    }
    v15 = *(_DWORD *)(v5 + 20) == 1 ? v12 : v14;
    v22 = *(_OWORD *)(a2 + 9);
    v16 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))a2[1])(*(_QWORD *)v4, a2[2] + 4 * v11, v15, *((unsigned int *)a2 + 8));
    if ((_DWORD)v16)
      break;
    v10 -= 2;
    v11 -= padded_len;
    if (!--v9)
      return 0;
  }
  v20 = v16;
  log_OutText(*v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm backward failed!", v17, v18, v19, v22);
  return v20;
}

uint64_t doPasses(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;

  if (a2 == 1 && *(_DWORD *)(a1 + 96) >= 2u)
  {
    fi_rsc_checkCreateSecondThread(a1);
    v7 = fi_thread_checkQueueTask(a1 + 24, (uint64_t)a4, (uint64_t)blstmPass);
    if (v7)
    {
      if (!v7)
        return 0;
      v8 = doForwardSteps((uint64_t *)a1, a3);
      v9 = fi_thread_wait4Task(a1 + 24);
      if (!(_DWORD)v8)
        return v9;
      return v8;
    }
  }
  v8 = doForwardSteps((uint64_t *)a1, a3);
  if ((_DWORD)v8)
    return v8;
  return doBackwardSteps((uint64_t *)a1, a4);
}

uint64_t create_invpreemph_layer(uint64_t *a1, uint64_t *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) != 0)
  {
    v13 = (_QWORD *)v12;
    result = 0;
    *v13 = *a3;
    *(_QWORD *)(v11 + 120) = v13;
    v15 = *a2;
    *(_DWORD *)(v11 + 16) = *((_DWORD *)a2 + 2);
    *(_QWORD *)v11 = a1;
    *(_QWORD *)(v11 + 8) = v15;
    *(_QWORD *)(v11 + 128) = forward_invpreemph_layer;
    *(_QWORD *)(v11 + 136) = free_invpreemph_buffer;
    *(_QWORD *)(v11 + 144) = invpreemph_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v16);
    free_invpreemph_buffer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_invpreemph_layer(int a1, uint64_t a2, void *__src, void *__dst, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  float v10;
  uint64_t i;
  float v12;
  float v13;

  v8 = *(unsigned int *)(a2 + 44);
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(float *)v9;
  memcpy(__dst, __src, 4 * v8);
  if (v10 > 0.01)
    _inv_preemphasis((float *)__dst, v8, v10);
  if (*(_DWORD *)(v9 + 4) == 1)
  {
    if (v10 >= 0.01)
    {
      _scale_to_pcm16((float *)__dst, v8);
    }
    else if ((_DWORD)v8)
    {
      for (i = 0; i != v8; ++i)
      {
        v12 = *((float *)__dst + i) * 32767.0;
        if (v12 > 32767.0)
          v12 = 32767.0;
        if (v12 >= -32767.0)
          v13 = v12 + 0.5;
        else
          v13 = -32766.0;
        *((_WORD *)__dst + i) = (int)v13;
      }
    }
    *(_DWORD *)(a5 + 20) = 1;
    *(_DWORD *)(a2 + 56) = 2;
  }
  else
  {
    _scale_to_one((float *)__dst, v8);
  }
  return 0;
}

_QWORD *free_invpreemph_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t invpreemph_layer_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v8;
  uint64_t v9;
  uint64_t vars0;

  v8 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v8;
  if (*(_DWORD *)a2 == 1)
  {
    v9 = 0;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently invpreemph layer only support 1D input", a6, a7, a8, vars0);
    return 7;
  }
  return v9;
}

uint64_t create_nest_layer(uint64_t *a1, int a2, int a3, uint64_t a4, uint64_t ***a5)
{
  uint64_t **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;

  v10 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v14 = v10;
  if (v10
    && (*v10 = a1,
        v10[1] = (uint64_t *)25,
        (v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16)) != 0))
  {
    v16 = v15;
    result = 0;
    *(_DWORD *)v16 = a2;
    *(_DWORD *)(v16 + 4) = a3;
    *(_QWORD *)(v16 + 8) = a4;
    v14[15] = (uint64_t *)v16;
    v14[16] = (uint64_t *)forward_nest_layer;
    v14[17] = (uint64_t *)free_nest_layer;
    v14[18] = (uint64_t *)nest_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v11, v12, v13, v18);
    free_nest_layer(v14);
    result = 10;
  }
  *a5 = v14;
  return result;
}

uint64_t forward_nest_layer(uint64_t a1, int *a2, const void *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unsigned int *v11;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t bytes;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t size;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  float v50;
  float v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  int i;
  unsigned int v61;
  uint64_t j;
  uint64_t v63;
  float v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v69;
  unint64_t v70;
  _QWORD *v71;
  int v72;
  unsigned int __n;
  unsigned int __n_4;
  unsigned int v75;

  v10 = *(_QWORD *)a2;
  v11 = (unsigned int *)*((_QWORD *)a2 + 15);
  if (v11[1])
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * v13);
      __n = 0;
      bytes = fi_shape_get_bytes((int *)(v15 + 72), &__n);
      if ((_DWORD)bytes)
        break;
      if (!__n)
      {
        log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: nest layer get input length=0 bytes!", a6, a7, a8, v69);
        v30 = 7;
        goto LABEL_34;
      }
      v17 = (void *)(**(uint64_t (***)(_QWORD))(v10 + 8))(*(_QWORD *)(v10 + 16));
      if (v17)
      {
        v21 = v17;
        memcpy(v17, a3, __n);
        v14 = v21;
      }
      else
      {
        log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v69);
      }
      *(_QWORD *)(v15 + 160) = v14;
      v22 = fi_net_forward((uint64_t **)v15);
      if ((_DWORD)v22)
      {
        v30 = v22;
        v44 = *(_QWORD *)v10;
        v45 = "nest layer forward submodel failed!";
        goto LABEL_63;
      }
      ++v13;
      v23 = v11[1];
      if (v13 >= v23)
        goto LABEL_12;
    }
    v30 = bytes;
LABEL_34:
    v44 = *(_QWORD *)v10;
    v45 = "nest layer get submodel input failed!";
    goto LABEL_63;
  }
  LODWORD(v23) = 0;
LABEL_12:
  v24 = *v11;
  v25 = (_QWORD *)*((_QWORD *)v11 + 1);
  if ((v24 - 1) < 3)
  {
    v75 = 0;
    size = fi_shape_get_size(a2 + 10, (int *)&v75);
    if ((_DWORD)size)
    {
      v30 = size;
      v31 = *(_QWORD *)v10;
      v32 = "nest layer mode %d submodel output failed!";
      v69 = v24;
LABEL_15:
      log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v27, v28, v29, v69);
      goto LABEL_62;
    }
    v46 = v75;
    memcpy(a4, *(const void **)(*v25 + 144), 4 * v75);
    if ((_DWORD)v46)
    {
      v47 = 0;
      while (v23 < 2)
      {
LABEL_47:
        if ((_DWORD)v24 == 3)
          *(float *)&a4[4 * v47] = *(float *)&a4[4 * v47] / (float)v23;
        if (++v47 == v46)
          return 0;
      }
      v48 = v25 + 1;
      v49 = v23 - 1;
      while (1)
      {
        v50 = *(float *)(*(_QWORD *)(*v48 + 144) + 4 * v47);
        if ((_DWORD)v24 == 3)
          break;
        if ((_DWORD)v24 == 2)
        {
          v51 = v50 * *(float *)&a4[4 * v47];
          goto LABEL_45;
        }
        if ((_DWORD)v24 == 1)
          break;
LABEL_46:
        ++v48;
        if (!--v49)
          goto LABEL_47;
      }
      v51 = v50 + *(float *)&a4[4 * v47];
LABEL_45:
      *(float *)&a4[4 * v47] = v51;
      goto LABEL_46;
    }
    return 0;
  }
  if ((_DWORD)v24 == 4)
  {
    v52 = *(_QWORD *)(*v25 + 144);
    v53 = *(_QWORD *)(v25[1] + 144);
    v54 = *(_DWORD *)(*v25 + 96);
    v55 = *(unsigned int *)(*v25 + 100);
    bzero(a4, 4 * (v55 * v54));
    if (v54)
    {
      v59 = 0;
      for (i = 0; i != v54; ++i)
      {
        if ((_DWORD)v55)
        {
          v61 = 0;
          for (j = 0; j != v55; ++j)
          {
            v63 = (i * v55 + j);
            v64 = *(float *)&a4[4 * v63];
            v65 = v59;
            v66 = v61;
            v67 = v55;
            do
            {
              v64 = v64 + (float)(*(float *)(v52 + 4 * v65) * *(float *)(v53 + 4 * v66));
              *(float *)&a4[4 * v63] = v64;
              ++v66;
              ++v65;
              --v67;
            }
            while (v67);
            v61 += v55;
          }
        }
        v59 += v55;
      }
    }
    log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 3, 0, (uint64_t)"nest dot output done!", v56, v57, v58, v69);
    return 0;
  }
  if (!(_DWORD)v24)
  {
    __n_4 = 0;
    if ((_DWORD)v23)
    {
      v33 = 0;
      v34 = 0;
      v23 = v23;
      v70 = v23;
      v71 = v25;
      while (1)
      {
        v35 = v25[v33];
        v36 = fi_shape_get_bytes((int *)(v35 + 92), &__n_4);
        if ((_DWORD)v36)
        {
          v30 = v36;
          goto LABEL_67;
        }
        v37 = __n_4;
        if (!__n_4)
          break;
        v38 = *(_DWORD *)(v35 + 92);
        if (v38 == 2)
        {
          v39 = a2[11];
          if (v39)
          {
            v72 = v34;
            v40 = 0;
            v41 = 0;
            v42 = a2[14];
            v43 = a2[12];
            do
            {
              memcpy(&a4[((v40 + v33 * *(_DWORD *)(v35 + 100)) * v42)], (const void *)(*(_QWORD *)(v35 + 144) + (*(_DWORD *)(v35 + 100) * v42 * v41++)), (*(_DWORD *)(v35 + 100) * v42));
              v40 += v43;
            }
            while (v39 != v41);
            v23 = v70;
            v25 = v71;
            v34 = v72;
          }
        }
        else if (v38 == 1)
        {
          memcpy(&a4[v34], *(const void **)(v35 + 144), __n_4);
          v34 += v37;
        }
        else
        {
          log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"nest layer now only support conat 1d, 2d data", v27, v28, v29, v69);
        }
        if (++v33 == v23)
          return 0;
      }
      log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"nest layer submodel output length=0!", v27, v28, v29, v69);
      v30 = 7;
LABEL_67:
      v31 = *(_QWORD *)v10;
      v32 = "nest layer concat submodel output failed!";
      goto LABEL_15;
    }
    return 0;
  }
  log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: non supported nest mode: %d", a6, a7, a8, *v11);
  v30 = 7;
LABEL_62:
  v44 = *(_QWORD *)v10;
  v45 = "nest layer gen output failed!";
LABEL_63:
  log_OutText(v44, (uint64_t)"FastInfer", 0, 0, (uint64_t)v45, a6, a7, a8, v69);
  return v30;
}

_QWORD *free_nest_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    v3 = result[15];
    if (*(_DWORD *)(v3 + 4))
    {
      v4 = 0;
      do
        fi_net_destroy(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4++));
      while (v4 < *(unsigned int *)(v3 + 4));
    }
    if (*(_QWORD *)(v3 + 8))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *(_QWORD *)(v3 + 8) = 0;
    }
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
  }
  return result;
}

uint64_t nest_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v9;
  unsigned int *v10;
  uint64_t v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  int step;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t updated;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  __n128 *v29;
  BOOL v30;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __n128 *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __n128 v50;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;

  v9 = *(uint64_t **)a1;
  v10 = *(unsigned int **)(a1 + 120);
  v11 = v10[1];
  v12 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v12;
  if ((_DWORD)v11)
  {
    v14 = 0;
    v15 = 8 * v11;
    while (1)
    {
      v16 = *(_QWORD *)(*((_QWORD *)v10 + 1) + v14);
      if (!*(_DWORD *)(v16 + 72))
      {
        v17 = *(_OWORD *)a2;
        *(_DWORD *)(v16 + 88) = a2[4];
        *(_OWORD *)(v16 + 72) = v17;
      }
      step = fi_shape_get_step(a2);
      updated = fi_net_update_shape((uint64_t **)v16, step, v19, v20, v21, v22, v23, v24);
      if ((_DWORD)updated)
        break;
      v14 += 8;
      if (v15 == v14)
        goto LABEL_7;
    }
    v34 = updated;
    v35 = *v9;
    v36 = "submodels update shape failed!";
  }
  else
  {
LABEL_7:
    v26 = *v10;
    v27 = (_QWORD *)*((_QWORD *)v10 + 1);
    v28 = v10[1];
    v29 = (__n128 *)(a1 + 40);
    switch((int)v26)
    {
      case 0:
        if (!(_DWORD)v28)
          return 0;
        v42 = 0;
        v43 = 8 * v28;
        do
        {
          v44 = v27[v42 / 8];
          v45 = (__n128 *)(v44 + 92);
          if (v42)
          {
            v46 = fi_shape_merge(v45, v29);
            if ((_DWORD)v46)
            {
              v34 = v46;
              log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"submodels outputs not able to nest!", v47, v48, v49, v80);
              fi_shape_dump(v9, v27[v42 / 8] + 92, (uint64_t)"shape to be nestd", v64, v65, v66, v67, v68);
              fi_shape_dump(v9, (uint64_t)v29, (uint64_t)"shape", v69, v70, v71, v72, v73);
              log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"concat submodels output shape failed!", v74, v75, v76, v81);
              goto LABEL_26;
            }
          }
          else
          {
            v50 = *v45;
            v29[1].n128_u32[0] = *(_DWORD *)(v44 + 108);
            *v29 = v50;
          }
          v42 += 8;
        }
        while (v43 != v42);
        return 0;
      case 1:
      case 2:
      case 3:
      case 5:
        if ((_DWORD)v28)
          v30 = v9 == 0;
        else
          v30 = 1;
        if (v30 || v27 == 0)
          goto LABEL_16;
        if (v28 < 2)
          goto LABEL_22;
        v37 = v28 - 1;
        v38 = v27;
        break;
      case 4:
        if ((_DWORD)v28 == 2)
        {
          if (fi_shape_is_same((unsigned int *)(*v27 + 92), (_DWORD *)(v27[1] + 92)))
          {
            fi_shape_copy((__n128 *)(a1 + 40), (__n128 *)(*v27 + 92));
            v34 = 0;
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
            return v34;
          }
          v62 = *v9;
          v28 = 2;
          v63 = "dot nest requires 2 submodels has the same shape, but , but got: %d";
        }
        else
        {
          v62 = *v9;
          v63 = "dot nest requires 2 submodels, but got: %d";
        }
        log_OutText(v62, (uint64_t)"FastInfer", 0, 0, (uint64_t)v63, a6, a7, a8, v28);
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update submodels' shape failed for nest mode %d", v77, v78, v79, 4);
        goto LABEL_25;
      default:
        v32 = *v9;
        v33 = "error: non supported nest mode: %d";
        goto LABEL_24;
    }
    while (fi_shape_is_same((unsigned int *)(*v38 + 92), (_DWORD *)(v38[1] + 92)))
    {
      ++v38;
      if (!--v37)
      {
LABEL_22:
        fi_shape_copy(v29, (__n128 *)(*v27 + 92));
        return 0;
      }
    }
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Only shapes with same shape can be sum nestd!", v39, v40, v41, v80);
    fi_shape_dump(v9, *v38 + 92, (uint64_t)"previous shape", v52, v53, v54, v55, v56);
    fi_shape_dump(v9, *v38 + 92, (uint64_t)"shape", v57, v58, v59, v60, v61);
LABEL_16:
    v32 = *v9;
    v33 = "submodel outshape must be the same for nest mode %d";
LABEL_24:
    log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, a6, a7, a8, v26);
LABEL_25:
    v34 = 7;
LABEL_26:
    v35 = *v9;
    v36 = "udpate nest layer output shape failed!";
  }
  log_OutText(v35, (uint64_t)"FastInfer", 0, 0, (uint64_t)v36, a6, a7, a8, v80);
  return v34;
}

uint64_t lstm_layer_impl_type(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;

  if (!a1)
    return 7;
  v2 = *(_QWORD *)(a1 + 120);
  if (!v2)
    return 7;
  v3 = *(_DWORD **)(v2 + 8);
  if (!v3)
    return 7;
  result = 0;
  *a2 = *v3;
  return result;
}

_QWORD *free_lstm_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = v3[1];
        if (v4)
        {
          if (*(_QWORD *)(v4 + 32))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 32) = 0;
          }
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t forward_lstm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = *(_QWORD *)(a2 + 120);
  v9 = *(_QWORD *)(v8 + 8);
  if (*(_DWORD *)(v9 + 24))
  {
    if (!a1)
      goto LABEL_7;
  }
  else
  {
    bzero(*(void **)v8, 4 * *(unsigned int *)(a2 + 12));
    if (!a1)
      goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 8))
    return 0;
LABEL_7:
  bzero(*(void **)(v9 + 32), 4 * *(unsigned int *)(a2 + 12));
  return forward_lstm_layer_f32(a2, a3, a4);
}

uint64_t reset_lstm_layer_hidden(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  void *v10;
  uint64_t v12;
  const char *v13;
  uint64_t v14;

  v9 = **(void ***)(a1 + 120);
  if (v9)
  {
    bzero(v9, 4 * *(unsigned int *)(a1 + 12));
    v10 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 32);
    if (v10)
    {
      bzero(v10, 4 * *(unsigned int *)(a1 + 12));
      return 0;
    }
    v12 = **(_QWORD **)a1;
    v13 = "lstm cell resetting null pointer!";
  }
  else
  {
    v12 = **(_QWORD **)a1;
    v13 = "lstm state resetting null pointer!";
  }
  log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v14);
  return 10;
}

uint64_t create_bgru_layer(uint64_t *a1, uint64_t *a2, __int128 *a3, _QWORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  uint64_t result;
  uint64_t v27;

  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15)
    goto LABEL_9;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16)
    goto LABEL_9;
  v17 = (_QWORD *)v16;
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v18)
    goto LABEL_9;
  v19 = v18;
  v20 = *a2;
  *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)(v15 + 8) = v20;
  v21 = (2 * *((_DWORD *)a2 + 1));
  *(_QWORD *)v15 = a1;
  if (a4)
    *(_QWORD *)(v15 + 60) = *a4;
  v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4);
  *v17 = v22;
  if (v22)
  {
    v17[1] = v19;
    v23 = *a3;
    *(_DWORD *)(v19 + 16) = *((_DWORD *)a3 + 4);
    *(_OWORD *)v19 = v23;
    *(_QWORD *)(v15 + 120) = v17;
    *(_QWORD *)(v15 + 128) = forward_bgru_layer;
    *(_QWORD *)(v15 + 136) = free_bgru_buffer;
    if (a5)
    {
      v24 = *(_QWORD *)(a5 + 24);
      v25 = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v12, v13, v14, v27);
      v24 = 0;
      v25 = 0;
    }
    result = 0;
    *(_QWORD *)(v15 + 256) = v24;
    *(_DWORD *)(v15 + 264) = v25;
    *(_QWORD *)(v15 + 144) = bgru_layer_update_shape;
    *(_QWORD *)(v15 + 152) = bgru_layer_wanted_wb_len;
    *(_QWORD *)(v15 + 160) = bgru_layer_request_glbBuf;
  }
  else
  {
LABEL_9:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v27);
    free_bgru_buffer((_QWORD *)v15);
    result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t forward_bgru_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char **v6;
  uint64_t v7;
  size_t v8;
  char *v9;
  char *v10;
  unsigned int padded_bytes;
  uint64_t input_dim;
  unsigned int padded_len;
  unsigned int step;
  int v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  const char *v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  unint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  void *__src;
  uint64_t v52;
  uint64_t *v53;
  int v55;
  void *v56;
  int v57;
  void *v58;
  unsigned int v59[3];

  v53 = *(uint64_t **)a2;
  v6 = *(char ***)(a2 + 120);
  v59[0] = 0;
  v7 = *(unsigned int *)(a2 + 12);
  v56 = *(void **)(a2 + 240);
  v8 = *(unsigned int *)(a2 + 248);
  v10 = *v6;
  v9 = v6[1];
  v55 = *((_DWORD *)v9 + 3);
  v58 = 0;
  v57 = 1;
  v52 = *(_QWORD *)(a2 + 72);
  padded_bytes = get_padded_bytes(*(_DWORD *)(a2 + 96), 8u);
  v47 = *(_DWORD *)(a2 + 96);
  v48 = *(_QWORD *)(a2 + 72);
  v45 = *(unsigned int *)(a2 + 112);
  if (!*((_DWORD *)v9 + 4))
  {
    bzero(v10, 4 * v7);
    bzero(&v10[4 * v7], 4 * v7);
    bzero(v10, 4 * (2 * v7));
  }
  v50 = (uint64_t)&v10[4 * v7];
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)v59);
  if ((_DWORD)input_dim)
    goto LABEL_52;
  padded_len = get_padded_len(v59[0], 8u);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = lstm_layer_impl_type(a2, &v57);
  if ((_DWORD)input_dim)
    goto LABEL_52;
  v15 = v57;
  if (v59[0] == padded_len)
  {
    v16 = v53;
  }
  else
  {
    v16 = v53;
    if (v57 != 4)
    {
      v58 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v53[1] + 16))(v53[2], padded_len, 4);
      if (!v58)
      {
LABEL_45:
        log_OutText(*v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v17, v18, v19, v40);
        input_dim = 10;
        goto LABEL_52;
      }
      v15 = v57;
    }
  }
  v44 = v8;
  if (v15 == 4)
    v20 = step * padded_len;
  else
    v20 = v59[0];
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v16[1] + 16))(v16[2], v20, 4);
  if (!v21)
    goto LABEL_45;
  v22 = (char *)v21;
  if (!step)
  {
    input_dim = 0;
    goto LABEL_51;
  }
  __src = 0;
  v23 = step;
  v24 = 0;
  v42 = v52 + 4 * (padded_bytes >> 3);
  v25 = (v45 >> 1) & 0x7FFFFFFC;
  v46 = v48 + (v47 & 0xFFFFFFFC);
  v41 = v46 + v25;
  v49 = v23;
  v43 = v23;
  while (1)
  {
    v26 = v55 == 1 ? 2 * v7 * v24 : 0;
    if (v57 == 4)
      break;
    __src = (void *)(a3 + 4 * v59[0] * v24);
    if (v59[0] != padded_len)
    {
      if (!v58)
      {
        input_dim = 0;
        v38 = "empty new input memory!";
        goto LABEL_50;
      }
      memcpy(v58, __src, 4 * v59[0]);
      __src = v58;
    }
LABEL_30:
    v30 = v57;
    if ((v57 - 5) <= 0xFFFFFFFD)
      bzero(v56, v44);
    v31 = gru_step_f32((uint64_t **)a2, v30, (uint64_t)__src, a4 + 4 * v26, v59[0], v7, (uint64_t)v56, v52, v46, (uint64_t)v10);
    if ((_DWORD)v31)
    {
      input_dim = v31;
      v38 = "gru step forward failed!";
LABEL_50:
      log_OutText(*v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)v38, v17, v18, v19, v40);
      goto LABEL_51;
    }
    if (++v24 == v49)
    {
      v32 = 0;
      v33 = v7 * (2 * v49 - 1);
      v34 = v49 - 1;
      while (1)
      {
        v35 = v55 == 1 ? v33 : v7;
        if (v57 == 4)
        {
          v36 = 4;
        }
        else
        {
          memcpy(v22, (const void *)(a3 + 4 * v59[0] * v34), 4 * v59[0]);
          v36 = v57;
          if ((v57 - 5) <= 0xFFFFFFFD)
            bzero(v56, v44);
        }
        v37 = gru_step_f32((uint64_t **)a2, v36, (uint64_t)v22, a4 + 4 * v35, v59[0], v7, (uint64_t)v56 + ((v44 >> 1) & 0x7FFFFFFC), v42, v41, v50);
        if ((_DWORD)v37)
          break;
        ++v32;
        v33 -= 2 * v7;
        --v34;
        if (v43 == v32)
        {
          input_dim = 0;
          v16 = v53;
          goto LABEL_51;
        }
      }
      input_dim = v37;
      v16 = v53;
      v38 = "gru backward failed!";
      goto LABEL_50;
    }
  }
  if (v24)
    goto LABEL_30;
  __src = (void *)a3;
  if (v59[0] == padded_len)
  {
LABEL_24:
    v28 = 0;
    v29 = v43;
    do
    {
      memcpy(&v22[4 * v28], (const void *)(a3 + 4 * v59[0] * --v29), 4 * v59[0]);
      v28 += padded_len;
    }
    while (v29);
    v16 = v53;
    goto LABEL_30;
  }
  v27 = realign_inData(v16, v49, v59[0], (uint64_t *)&v58, a3);
  if (!(_DWORD)v27)
  {
    __src = v58;
    goto LABEL_24;
  }
  input_dim = v27;
LABEL_51:
  (*(void (**)(uint64_t, char *))(v16[1] + 48))(v16[2], v22);
LABEL_52:
  if (v58)
    (*(void (**)(uint64_t))(v53[1] + 48))(v53[2]);
  return input_dim;
}

_QWORD *free_bgru_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        if (v3[1])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t bgru_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t vars0;

  if (*(_DWORD *)a2 == 2)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
    v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      v10 = 0;
      *(_DWORD *)(a1 + 40) = 2;
      v11 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      v10 = 0;
      v12 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D GRU, BGRU!", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t bgru_layer_wanted_wb_len(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v5;

  v5 = gru_layer_wanted_wb_len(a1, a2, a3);
  if (!(_DWORD)v5)
  {
    *a2 += get_padded_bytes(*a2, 8u);
    *a3 *= 2;
  }
  return v5;
}

uint64_t bgru_layer_request_glbBuf(_DWORD *a1)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;
  int step;
  int v6;
  uint64_t v7;

  v2 = a1[3];
  v7 = 0;
  v6 = 0;
  v3 = a1 + 5;
  result = fi_shape_get_input_dim(a1 + 5, (int *)&v7 + 1);
  if (!(_DWORD)result)
  {
    step = fi_shape_get_step(v3);
    result = lstm_layer_impl_type((uint64_t)a1, &v7);
    if (!(_DWORD)result)
    {
      result = get_gru_glbBufBytes(v7, HIDWORD(v7), step, v2, &v6);
      if (!(_DWORD)result)
        a1[62] = 2 * v6;
    }
  }
  return result;
}

uint64_t create_pqmf_layer(uint64_t *a1, _QWORD *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;
  uint64_t v14;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    v12 = (_QWORD *)v11;
    result = 0;
    *v12 = *a2;
    *((_DWORD *)v10 + 2) = 71;
    v10[16] = (uint64_t *)forward_pqmf_layer;
    v10[17] = (uint64_t *)free_pqmf_buffer;
    v10[18] = (uint64_t *)pqmf_layer_update_shape;
    v10[19] = (uint64_t *)pqmf_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_pqmf_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_pqmf_layer(uint64_t a1, uint64_t a2, uint64_t a3, float *a4)
{
  unsigned int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t padded_len;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  float *v17;

  v6 = *(unsigned int **)(a2 + 120);
  v7 = *(_DWORD *)(a2 + 24);
  v8 = *(_QWORD *)(a2 + 88);
  v9 = v6[1];
  padded_len = get_padded_len(*v6, 8u);
  v17 = a4;
  bzero(a4, 4 * (v9 * v7));
  if (v7 != padded_len / v9)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      if ((_DWORD)v9)
      {
        v13 = 0;
        v14 = v9;
        v15 = v11;
        do
        {
          axpy(padded_len, (float *)(v8 + 4 * v13), 1, &v17[(v9 * v12)], 1, *(float *)(a3 + 4 * v15));
          v13 += padded_len;
          ++v15;
          --v14;
        }
        while (v14);
      }
      ++v12;
      v11 += v9;
    }
    while (v12 != v7 - padded_len / v9);
  }
  return 0;
}

_QWORD *free_pqmf_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t pqmf_layer_update_shape(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  int v14;

  v14 = 0;
  if (*a2 == 2 && a2[2] == *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4))
  {
    v10 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v10;
    result = fi_shape_get_size(a2, &v14);
    if (!(_DWORD)result)
    {
      v12 = v14;
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"pqmf input must be exactly 2 dimensional and matches the pqmf bands!", a6, a7, a8, v13);
    return 7;
  }
  return result;
}

uint64_t pqmf_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v5 = *(unsigned int **)(a1 + 120);
  *a2 = 4 * get_padded_len(*v5, 8u) * v5[1];
  *a3 = 0;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"len : %d\n", v6, v7, v8, *v5);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"bands : %d\n", v9, v10, v11, v5[1]);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v12, v13, v14, *(unsigned int *)(a1 + 96));
  return 0;
}

uint64_t create_sampling_layer(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t result;
  uint64_t v15;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16)) != 0)
  {
    v13 = (_QWORD *)v12;
    result = 0;
    *v13 = *a2;
    v13[1] = a3;
    *(_QWORD *)v11 = a1;
    *(_DWORD *)(v11 + 8) = 28;
    *(_QWORD *)(v11 + 120) = v13;
    *(_QWORD *)(v11 + 128) = forward_sampling_layer;
    *(_QWORD *)(v11 + 136) = free_sampling_buffer;
    *(_QWORD *)(v11 + 144) = sampling_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v15);
    free_sampling_buffer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_sampling_layer(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  int *v7;
  int v8;
  int v9;
  unsigned int *v10;
  int *v11;
  int step;
  uint64_t result;
  float v14;
  int i;
  char *v16;
  char *v17;
  int v18[2];

  *(_QWORD *)v18 = 0;
  v7 = *(int **)(a2 + 120);
  v9 = *v7;
  v8 = v7[1];
  v10 = (unsigned int *)*((_QWORD *)v7 + 1);
  v11 = (int *)(a2 + 20);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  result = fi_shape_get_size((int *)(a2 + 40), &v18[1]);
  if (!(_DWORD)result)
  {
    result = fi_shape_get_input_dim(v11, v18);
    if (!(_DWORD)result)
    {
      if (*v11 == 1)
      {
        if (v9)
        {
          if (v9 == 1)
            gmm_type2(a3, v18[0], v10, a4, v8);
        }
        else
        {
          multinomial((uint64_t)a3, v18[0], v10, (float *)a4, v8, v14);
        }
      }
      else if (step)
      {
        for (i = 0; i != step; ++i)
        {
          v16 = &a3[4 * v18[0] * i];
          v17 = &a4[4 * *(_DWORD *)(a2 + 48) * i];
          if (v9)
          {
            if (v9 == 1)
              gmm_type2(v16, v18[0], v10, v17, v8);
          }
          else
          {
            v14 = multinomial((uint64_t)v16, v18[0], v10, (float *)v17, v8, v14);
          }
        }
      }
      return 0;
    }
  }
  return result;
}

_QWORD *free_sampling_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t sampling_layer_update_shape(uint64_t a1, __int128 *a2)
{
  int v4;
  __int128 v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;

  v14 = 0;
  v4 = **(_DWORD **)(a1 + 120);
  v5 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v5;
  result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v14);
  if ((_DWORD)result)
    return result;
  if (v4 == 1)
  {
    v10 = v14 >> 2;
    goto LABEL_6;
  }
  if (!v4)
  {
    v10 = 1;
LABEL_6:
    v14 = v10;
  }
  if (*(_DWORD *)a2 == 2)
  {
    result = 0;
    *(_DWORD *)(a1 + 40) = 2;
    v12 = v14;
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 48) = v12;
    goto LABEL_11;
  }
  if (*(_DWORD *)a2 == 1)
  {
    result = 0;
    v11 = v14;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v11;
LABEL_11:
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
    return result;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently sampling layer only support 1D or 2D input", v7, v8, v9, v13);
  return 7;
}

void gmm_type2(void *__src, unsigned int a2, unsigned int *a3, char *__dst, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  char v15;
  char v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  float *v25;
  float v26;
  float v27;
  unsigned int v28;

  v10 = a2 >> 2;
  if (a2 < 4)
  {
LABEL_9:
    memcpy(__dst, __src, a2 & 0xFFFFFFFC);
    if (a5 != 4)
    {
      if (a5 == 3 && a2 >= 4)
      {
        v19 = 0;
        if (v10 <= 1)
          v20 = 1;
        else
          v20 = v10;
        do
        {
          if (*((float *)__src + v10 + v19) <= fmaxf(*((float *)__src + v19), 0.0))
            v21 = 2;
          else
            v21 = 3;
          *(_DWORD *)&__dst[4 * v19] = *((_DWORD *)__src + (v19 + v10 * v21));
          ++v19;
        }
        while (v20 != v19);
      }
      return;
    }
    if (a2 < 4)
      return;
    v22 = (2 * v10);
    v23 = *a3;
    if (v10 <= 1)
      v24 = 1;
    else
      v24 = v10;
    v25 = (float *)__src;
    while (1)
    {
      v23 = (1103515245 * v23 + 12345) & 0x7FFFFFFF;
      v26 = (float)v23 * 4.6566e-10;
      v27 = *v25 + 0.0;
      if (v27 > v26)
        break;
      v28 = v10;
      if ((float)(v27 + v25[v10]) > v26)
        goto LABEL_28;
LABEL_29:
      ++v25;
      __dst += 4;
      ++v22;
      if (!--v24)
      {
        *a3 = v23;
        return;
      }
    }
    v28 = 0;
LABEL_28:
    *(_DWORD *)__dst = *((_DWORD *)__src + v22 + v28);
    goto LABEL_29;
  }
  v11 = 0;
  if (v10 <= 1)
    v12 = 1;
  else
    v12 = v10;
  while (1)
  {
    v13 = 0;
    v14 = 0.0;
    v15 = 1;
    do
    {
      v16 = v15;
      v17 = v11 + v13 * v10;
      v18 = exp_fdlibm(*((float *)__src + v17));
      v15 = 0;
      *(float *)&v18 = v18;
      *((_DWORD *)__src + v17) = LODWORD(v18);
      v14 = v14 + *(float *)&v18;
      v13 = 1;
    }
    while ((v16 & 1) != 0);
    if (v14 == 0.0)
      break;
    *((float *)__src + v11) = *((float *)__src + v11) / v14;
    *((float *)__src + v11 + v10) = *((float *)__src + v11 + v10) / v14;
    if (++v11 == v12)
      goto LABEL_9;
  }
}

float multinomial(uint64_t a1, int a2, unsigned int *a3, float *a4, int a5, float result)
{
  unsigned int v7;
  uint64_t v8;
  float v9;

  if (a5 == 3)
  {
    LODWORD(v8) = fi_argmax(a1, a2);
LABEL_9:
    result = (float)v8;
    *a4 = (float)v8;
    return result;
  }
  if (a5 == 4)
  {
    v7 = (1103515245 * *a3 + 12345) & 0x7FFFFFFF;
    *a3 = v7;
    if (a2)
    {
      v8 = 0;
      result = (float)v7 * 4.6566e-10;
      v9 = 0.0;
      while (1)
      {
        v9 = v9 + *(float *)(a1 + 4 * v8);
        if (v9 > result)
          break;
        if (a2 == ++v8)
          return result;
      }
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t trans_dec_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[7], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[8], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[9], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t create_trans_dec_layer(uint64_t *a1, __int128 *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BYTE v35[20];
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 80);
      v19 = v15;
      if (!v15)
      {
        v28 = *a1;
        v29 = "out of memory!";
        goto LABEL_11;
      }
      v20 = *a2;
      v21 = a2[1];
      v22 = a2[2];
      *(_DWORD *)(v15 + 48) = *((_DWORD *)a2 + 12);
      *(_OWORD *)(v15 + 16) = v21;
      *(_OWORD *)(v15 + 32) = v22;
      *(_OWORD *)v15 = v20;
      v41 = 0u;
      v40 = 0u;
      memset(v35, 0, sizeof(v35));
      v39 = 0;
      v37 = 1;
      *(_QWORD *)&v21 = *((_QWORD *)a2 + 2);
      v38 = *((_QWORD *)a2 + 3);
      v36 = v21;
      *(float *)&v40 = (float)*((unsigned int *)a2 + 8);
      *((_QWORD *)&v41 + 1) = 0;
      v42 = 1;
      if (create_att_layer(a1, (unsigned int *)&v36, a3, a4, (uint64_t *)(v15 + 56)))
        goto LABEL_7;
      v39 = 1;
      v37 = 1;
      v26 = *((_QWORD *)a2 + 2);
      v38 = *((_QWORD *)a2 + 3);
      v36 = v26;
      *(float *)&v40 = (float)*((unsigned int *)a2 + 8);
      *((_QWORD *)&v41 + 1) = 0;
      LODWORD(v42) = 1;
      if (create_att_layer(a1, (unsigned int *)&v36, a3, a4, (uint64_t *)(v19 + 64)))
      {
LABEL_7:
        v27 = "create trans_dec att layer failed!";
LABEL_8:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v23, v24, v25, v33);
        v28 = *a1;
        v29 = "trans_dec network init failed!";
LABEL_11:
        log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v16, v17, v18, v33);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_dec init param failed!", v30, v31, v32, v34);
        result = 7;
        goto LABEL_12;
      }
      *(_DWORD *)v35 = *(_DWORD *)a2;
      *(int8x16_t *)&v35[4] = vextq_s8(*(int8x16_t *)((char *)a2 + 4), *(int8x16_t *)((char *)a2 + 4), 0xCuLL);
      if (create_ffn_layer(a1, (__int128 *)v35, a3, a4, (uint64_t *)(v19 + 72)))
      {
        v27 = "create trans_dec ffn layer failed!";
        goto LABEL_8;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 37;
      *(_QWORD *)(v7 + 128) = forward_trans_dec_layer;
      *(_QWORD *)(v7 + 136) = free_trans_dec_layer;
      *(_QWORD *)(v7 + 144) = trans_dec_layer_update_shape;
      *(_QWORD *)(v7 + 152) = trans_dec_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_dec_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_dec_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_dec_layer_reset;
      *(_QWORD *)(v7 + 184) = trans_dec_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v33);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v33);
      result = 10;
    }
  }
LABEL_12:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_dec_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v7;
  _QWORD *v8;
  uint64_t bytes;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v16;
  size_t v17;

  LODWORD(v17) = 0;
  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(_QWORD **)(a2 + 120);
  bytes = fi_shape_get_bytes((int *)(v8[7] + 40), &v17);
  if (!(_DWORD)bytes)
  {
    bzero(*(void **)(a2 + 240), (2 * v17));
    v10 = (*(uint64_t (**)(uint64_t))(v8[7] + 128))(a1);
    if ((_DWORD)v10 || (v10 = (*(uint64_t (**)(uint64_t))(v8[8] + 128))(a1), (_DWORD)v10))
    {
      bytes = v10;
      v14 = "trans_dec forward att layer failed!";
LABEL_6:
      log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, v11, v12, v13, v16);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(v8[9] + 40), &v17);
    if (!(_DWORD)bytes)
    {
      bzero(a4, v17);
      bytes = (*(uint64_t (**)(uint64_t))(v8[9] + 128))(a1);
      if ((_DWORD)bytes)
      {
        v14 = "trans_dec forward ffn layer failed!";
        goto LABEL_6;
      }
    }
  }
  return bytes;
}

_QWORD *free_trans_dec_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[9]);
        fi_layer_free(v3[7]);
        fi_layer_free(v3[8]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 trans_dec_layer_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  int v19;
  __int128 v20;
  int v21;

  v8 = *(_QWORD **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = *a2;
  *(_DWORD *)(a1 + 36) = v10;
  v20 = *a2;
  v21 = *((_DWORD *)a2 + 4);
  DWORD1(v20) = 1;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = *v9;
    v12 = "Currently trans_dec layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v20);
    return result;
  }
  if (!(*(unsigned int (**)(_QWORD, __int128 *, uint64_t))(v8[7] + 144))(v8[7], &v20, a3)
    && !(*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(v8[8] + 144))(v8[8], v8[7] + 40, v15)
    && !(*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(v8[9] + 144))(v8[9], v8[8] + 40, v16))
  {
    v17 = v8[9];
    v19 = *(_DWORD *)(v17 + 40);
    v18 = (__n128 *)(v17 + 40);
    if ((v19 - 1) >= 2)
    {
      v11 = **(_QWORD **)a1;
      v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    result = *v18;
    *(_DWORD *)(a1 + 56) = v18[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t trans_dec_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[7] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[8] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[9] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v10, v11, v12, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v13, v14, v15, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t trans_dec_request_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v2 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v2[7] + 160))();
  if (!(_DWORD)result)
  {
    v4 = *(_DWORD *)(v2[7] + 248);
    result = (*(uint64_t (**)(void))(v2[8] + 160))();
    if (!(_DWORD)result)
    {
      v5 = *(_DWORD *)(v2[8] + 248);
      result = (*(uint64_t (**)(void))(v2[9] + 160))();
      if (!(_DWORD)result)
      {
        v6 = *(_DWORD *)(v2[9] + 248);
        v8 = v6;
        result = trans_dec_get_reserved_glbBuf_bytes(a1, &v8);
        if (!(_DWORD)result)
        {
          if (v5 <= v4)
            v7 = v4;
          else
            v7 = v5;
          if (v6 > v7)
            v7 = v6;
          *(_DWORD *)(a1 + 248) = v8 + v7;
        }
      }
    }
  }
  return result;
}

uint64_t trans_dec_assign_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;

  v2 = *(_QWORD **)(a1 + 120);
  v8 = 0;
  result = trans_dec_get_reserved_glbBuf_bytes(a1, &v8);
  if (!(_DWORD)result)
  {
    v4 = v8;
    v5 = v2[7];
    v6 = v2[8];
    *(_QWORD *)(v5 + 240) = *(_QWORD *)(a1 + 240) + v8;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(_QWORD *)(v6 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
    v7 = v2[9];
    *(_QWORD *)(v7 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v7 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t trans_dec_layer_reset(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 120);
  if ((*(unsigned int (**)(void))(*(_QWORD *)(v2 + 56) + 176))()
    || (result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 64) + 176))(), (_DWORD)result))
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_dec network reset failed!", v3, v4, v5, v7);
    return 7;
  }
  return result;
}

uint64_t trans_dec_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t bytes;
  int v6;

  v3 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 56) + 40), &v6);
  if (!(_DWORD)bytes)
    *a2 = get_padded_bytes(2 * v6, 8u);
  return bytes;
}

uint64_t create_att_layer(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  int padded_len;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  int v36;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 160);
      v19 = v15;
      if (!v15)
      {
        v28 = *a1;
        v29 = "out of memory!";
        goto LABEL_9;
      }
      v20 = *(_OWORD *)a2;
      v21 = *((_OWORD *)a2 + 1);
      v22 = *((_OWORD *)a2 + 3);
      *(_OWORD *)(v15 + 32) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(v15 + 48) = v22;
      *(_OWORD *)v15 = v20;
      *(_OWORD *)(v15 + 16) = v21;
      v36 = 0;
      *(_DWORD *)(v15 + 152) = 0;
      padded_len = get_padded_len(*a2, 8u);
      v24 = *a2;
      HIDWORD(v34) = 40;
      v35 = v24;
      if (create_norm_layer(a1, (uint64_t *)((char *)&v34 + 4), (uint64_t *)(v19 + 64)))
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create att norm layer failed!", v25, v26, v27, v34);
        v28 = *a1;
        v29 = "att network init failed!";
LABEL_9:
        log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v16, v17, v18, v34);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att init param failed!", v30, v31, v32, v34);
        result = 7;
        goto LABEL_10;
      }
      v35 = padded_len;
      v36 = 0;
      HIDWORD(v34) = 5;
      *(_OWORD *)(v19 + 120) = 0u;
      *(_OWORD *)(v19 + 136) = 0u;
      if (a2[2])
      {
        v33 = a2[5];
        if (v33 == 1)
        {
          if (!a2[14])
          {
            *(_QWORD *)(v19 + 136) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
            *(_QWORD *)(v19 + 144) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
          }
        }
        else if (!v33 && !a2[14])
        {
          *(_QWORD *)(v19 + 120) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
          *(_QWORD *)(v19 + 128) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
        }
      }
      *(_DWORD *)(v19 + 112) = 0;
      if (!*((_QWORD *)a2 + 6))
        *(_QWORD *)(v19 + 104) = 0;
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_att_layer;
      *(_QWORD *)(v7 + 136) = free_att_layer;
      *(_QWORD *)(v7 + 8) = 34;
      *(_QWORD *)(v7 + 144) = att_layer_update_shape;
      *(_QWORD *)(v7 + 152) = att_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = att_request_glbBuf;
      *(_QWORD *)(v7 + 176) = att_layer_reset;
      *(_QWORD *)(v7 + 184) = att_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v25, v26, v27, v34);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      result = 10;
    }
  }
LABEL_10:
  *a5 = v7;
  return result;
}

uint64_t forward_att_layer(uint64_t a1, uint64_t a2, void *a3, float32x4_t *a4)
{
  uint64_t *v7;
  unsigned int *v8;
  uint64_t step;
  unsigned int v10;
  uint64_t padded_len;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v22;
  float32x4_t *v23;
  float32x4_t *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  float32x4_t *v33;
  float32x4_t *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  BOOL v44;
  float32x4_t *v45;
  float32x4_t *v46;
  uint64_t v47;
  size_t v48;
  float32x4_t *v49;
  uint64_t v50;
  char *v51;
  int v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v60;
  unsigned int v61;
  float32x4_t *v62;
  int v63;
  unsigned int *v64;
  uint64_t __n;
  unsigned int v66;
  unsigned int v67;
  float32x4_t *v68;
  unsigned int v69;
  uint64_t v70;
  void *__src;
  char *v72;
  float32x4_t *v73;
  float *v74;
  float32x4_t *v75;
  int v76;
  int v77;
  float32x4_t *v78;
  float32x4_t *v79;
  unsigned int v81;
  uint64_t *v82;

  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v10 = step;
  padded_len = get_padded_len(step, 8u);
  v12 = *v8;
  v13 = get_padded_len(*v8, 8u);
  v14 = v8[3];
  v15 = get_padded_len(v14, 8u);
  v19 = v8[5];
  v20 = v8[2];
  if (v20)
    v21 = 0;
  else
    v21 = v19 == 1;
  if (v21)
  {
    log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"encoder decoder attention is possible only if isDecoder option has been set to 1", v16, v17, v18, v60);
    return 7;
  }
  v81 = v10;
  v70 = v8[1];
  __src = a3;
  v82 = v7;
  v69 = v8[5];
  v67 = v12;
  v76 = v15;
  if (v19 == 1)
  {
    v22 = fi_shape_get_step(v8 + 7);
    v23 = *(float32x4_t **)(a2 + 240);
    if (v8[2])
    {
      v78 = (float32x4_t *)*((_QWORD *)v8 + 17);
      v24 = (float32x4_t *)*((_QWORD *)v8 + 18);
LABEL_13:
      v68 = v24;
      v73 = v23;
      v26 = v10;
      v27 = v13;
      goto LABEL_15;
    }
  }
  else
  {
    v22 = v10 + v10 * v8[38];
    v23 = *(float32x4_t **)(a2 + 240);
    if (v20)
    {
      v78 = (float32x4_t *)*((_QWORD *)v8 + 15);
      v24 = (float32x4_t *)*((_QWORD *)v8 + 16);
      goto LABEL_13;
    }
  }
  v27 = v13;
  v26 = v10;
  bzero(&v23->f32[v13 * v10], 4 * v13 * v10);
  v68 = 0;
  v78 = (float32x4_t *)((char *)v23 + 4 * v13 * v10);
  v73 = v78;
LABEL_15:
  bzero(v23, 4 * (v27 * v26));
  v28 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 8) + 128))(a1);
  if ((_DWORD)v28)
  {
    v25 = v28;
    log_OutText(*v82, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att forward norm layer failed!", v29, v30, v31, v60);
  }
  else
  {
    v77 = v76 * v14;
    v32 = &v73->f32[(v27 * v26)];
    bzero(a4, 4 * (v27 * v26));
    gemm_v2((uint64_t)v82, 0, v26, v27, v27, (uint64_t)v23, v27, *((_QWORD *)v8 + 10), v27, a4, v27);
    __n = 4 * (v27 * v26);
    v74 = v32;
    v75 = v23;
    if (v69 == 1)
    {
      v34 = (float32x4_t *)*((_QWORD *)v8 + 17);
      v33 = (float32x4_t *)*((_QWORD *)v8 + 18);
      v35 = v70;
      v68 = v33;
      if (!v8[28])
      {
        bzero(v34, 4 * v22 * v27);
        bzero(v33, 4 * v22 * v27);
        gemm_v2((uint64_t)v82, 0, v22, v27, v27, *((_QWORD *)v8 + 13), v27, *((_QWORD *)v8 + 9), v27, v34, v27);
        gemm_v2((uint64_t)v82, 0, v22, v27, v27, *((_QWORD *)v8 + 13), v27, *((_QWORD *)v8 + 11), v27, v33, v27);
        v8[28] = 1;
      }
      v36 = v77;
    }
    else
    {
      v34 = v78;
      bzero(&v78->f32[v8[38] * v27], 4 * (v27 * v26));
      gemm_v2((uint64_t)v82, 0, v26, v27, v27, (uint64_t)v23, v27, *((_QWORD *)v8 + 9), v27, (float32x4_t *)((char *)v78 + 4 * v8[38] * v27), v27);
      v35 = v70;
      v36 = v77;
    }
    v66 = v27;
    v72 = (char *)&v32[v36];
    bzero(v32, 4 * (v36 + v36 * v35));
    v37 = v67 / v35;
    if (v35)
    {
      v38 = 0;
      v39 = 0;
      v79 = v34;
      v40 = v70;
      do
      {
        gemm_v2((uint64_t)v82, 1, v81, v22, v37, (uint64_t)a4->i64 + 4 * (v37 * v39), v27, (uint64_t)v79->i64 + 4 * (v37 * v39), v27, (float32x4_t *)&v74[v38], padded_len);
        ++v39;
        v38 += v77;
        --v40;
      }
      while (v40);
      v41 = v70 - 1;
      if ((int)v70 - 1 >= 0)
      {
        do
        {
          if (v81)
          {
            v42 = 0;
            v43 = v81;
            do
            {
              softmax(&v74[v41 * v77 + v42], v22, 1, (float *)&v72[4 * v41 * v77 + 4 * v42], *((float *)v8 + 6));
              v42 += padded_len;
              --v43;
            }
            while (v43);
          }
          v44 = __OFSUB__(v41--, 1);
        }
        while (v41 < 0 == v44);
      }
    }
    v64 = v8;
    if (v69)
    {
      v45 = v68;
      v46 = v75;
      v47 = v70;
      v48 = __n;
    }
    else
    {
      v49 = v68;
      if (!v8[2])
        v49 = a4;
      v48 = __n;
      bzero(&v49->f32[v8[38] * v66], __n);
      v45 = v49;
      v46 = v75;
      gemm_v2((uint64_t)v82, 0, v81, v66, v66, (uint64_t)v75, v66, *((_QWORD *)v8 + 11), v66, (float32x4_t *)((char *)v49 + 4 * v8[38] * v66), v66);
      v47 = v70;
    }
    bzero(v46, v48);
    v50 = v66;
    v51 = v72;
    if ((_DWORD)v47)
    {
      v52 = 0;
      v53 = 0;
      do
      {
        v54 = (uint64_t)v45->i64 + 4 * (v37 * v53);
        v63 = v50;
        v61 = v50;
        v62 = (float32x4_t *)((char *)v75 + 4 * (v37 * v53));
        v55 = v37;
        v56 = v50;
        v57 = v37;
        v58 = v51;
        gemm_v2((uint64_t)v82, 0, v81, v55, v22, (uint64_t)&v51[4 * v52], padded_len, v54, v61, v62, v63);
        v51 = v58;
        v37 = v57;
        v50 = v56;
        ++v53;
        v52 += v77;
        --v47;
      }
      while (v47);
    }
    memcpy(a4, __src, __n);
    gemm_v2((uint64_t)v82, 0, v81, v50, v50, (uint64_t)v75, v50, *((_QWORD *)v64 + 12), v50, a4, v50);
    v25 = 0;
    ++v64[38];
  }
  return v25;
}

_QWORD *free_att_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;

  if (!result)
    return result;
  v1 = result;
  v2 = *result;
  if (!*result)
    return result;
  v3 = result[15];
  if (v3)
  {
    fi_layer_free(*(_QWORD *)(v3 + 64));
    if (*(_QWORD *)(v3 + 48))
    {
      if (!*(_QWORD *)(v3 + 104))
        goto LABEL_8;
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
    }
    *(_QWORD *)(v3 + 104) = 0;
LABEL_8:
    if (*(_DWORD *)(v3 + 8))
    {
      v4 = *(_DWORD *)(v3 + 20);
      if (v4 == 1)
      {
        if (*(_DWORD *)(v3 + 56))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 136))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 136) = 0;
        }
        v5 = (_QWORD *)(v3 + 144);
        if (!*(_QWORD *)(v3 + 144))
          goto LABEL_22;
      }
      else
      {
        if (v4 || *(_DWORD *)(v3 + 56))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 120))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 120) = 0;
        }
        v5 = (_QWORD *)(v3 + 128);
        if (!*(_QWORD *)(v3 + 128))
          goto LABEL_22;
      }
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *v5 = 0;
    }
LABEL_22:
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
  }
  if (*((_DWORD *)v1 + 29))
  {
    if (v1[9])
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
    *(_OWORD *)(v1 + 11) = 0u;
    *(_OWORD *)(v1 + 13) = 0u;
    *(_OWORD *)(v1 + 9) = 0u;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
}

__n128 att_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  const char *v10;
  __n128 result;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  v8 = *(uint64_t **)a1;
  if (*a2 >= 3u)
  {
    v9 = *v8;
    v10 = "Currently att layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, a6, a7, a8, v16);
    return result;
  }
  v13 = *(_QWORD *)(a1 + 120);
  v14 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v14;
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v13 + 64) + 144))())
  {
    v15 = *(_QWORD *)(v13 + 64);
    if (*(_DWORD *)(v13 + 20) == 1)
    {
      *(_DWORD *)(v13 + 28) = 2;
      if (!v15)
      {
        v9 = *v8;
        v10 = "Must set external pointers before shape update for enc_dec att.";
        goto LABEL_3;
      }
    }
    result = *(__n128 *)(v15 + 40);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v15 + 56);
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t att_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v6;
  uint64_t v7;
  int padded_bytes;
  uint64_t padded_len;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(unsigned int **)(a1 + 120);
  v7 = (*(uint64_t (**)(void))(*((_QWORD *)v6 + 8) + 152))();
  if (!(_DWORD)v7)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    padded_len = get_padded_len(*v6, 8u);
    *a2 = padded_bytes + 16 * padded_len * padded_len;
    *a3 = 0;
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"att k kernel size: %d\n", v10, v11, v12, padded_len);
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
  }
  return v7;
}

uint64_t att_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  int v3;
  int *v4;
  unsigned int step;
  uint64_t v6;
  uint64_t result;
  int padded_len;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  int padded_bytes;
  uint64_t v17;
  unsigned int v18;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = v2[1];
  v4 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v6 = v2[3];
  v18 = 0;
  result = fi_shape_get_input_dim(v4, (int *)&v18);
  if (!(_DWORD)result)
  {
    padded_len = get_padded_len(v18, 8u);
    if (v18 != *v2)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att input sample dim mismatch! inshape: %d, but config: %d";
      v17 = v18;
      goto LABEL_6;
    }
    if (step > v6)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att: input len longer than maximum!";
LABEL_6:
      log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, v9, v10, v11, v17);
      return 7;
    }
    v14 = (padded_len * (_DWORD)v6) << (v2[2] == 0);
    v15 = get_padded_len(v6, 8u);
    padded_bytes = get_padded_bytes(4 * (v14 + ((int)v6 + (int)v6 * v3) * v15), 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes;
  }
  return result;
}

uint64_t att_dispatch_weights(uint64_t a1)
{
  uint64_t *v2;
  int padded_len;
  uint64_t v4;
  uint64_t weights_via_offset;
  unsigned int padded_bytes;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;

  v12 = 0;
  v2 = *(uint64_t **)(a1 + 120);
  padded_len = get_padded_len(*(unsigned int *)v2, 8u);
  v4 = *(_QWORD *)(a1 + 72);
  weights_via_offset = fi_layer_find_weights_via_offset(v2[8], v4, &v12);
  if (!(_DWORD)weights_via_offset)
  {
    padded_bytes = get_padded_bytes(v12, 8u);
    v2[9] = v4 + padded_bytes;
    v7 = padded_len * padded_len;
    v12 = padded_bytes + 4 * v7;
    v8 = get_padded_bytes(v12, 8u);
    v2[12] = v4 + v8;
    v12 = v8 + 4 * v7;
    v9 = get_padded_bytes(v12, 8u);
    v2[10] = v4 + v9;
    v12 = v9 + 4 * v7;
    v10 = get_padded_bytes(v12, 8u);
    v2[11] = v4 + v10;
    v12 = v10 + 4 * v7;
    get_padded_bytes(v12, 8u);
  }
  return weights_via_offset;
}

uint64_t att_layer_reset(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 120);
    if (*(_DWORD *)(v1 + 20) == 1)
    {
      *(_QWORD *)(v1 + 104) = 0;
      *(_DWORD *)(v1 + 112) = 0;
      *(_OWORD *)(v1 + 120) = 0u;
      *(_OWORD *)(v1 + 136) = 0u;
    }
  }
  return 0;
}

uint64_t config_conv1d_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  return config_conv_layer(a1, a2, 0, a3, 0, a4, a5, a6, a7, a8);
}

uint64_t create_conv1d_layer(uint64_t *a1, __int128 *a2, uint64_t **a3, uint64_t a4, uint64_t ***a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v14;
  uint64_t **v15;

  v15 = 0;
  v11 = create_conv_layer(a1, a2, a3, &v15);
  if ((_DWORD)v11)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create conv layer failed!", v8, v9, v10, v14);
    v12 = v15;
  }
  else
  {
    v12 = v15;
    v15[1] = 0;
    v12[16] = (uint64_t *)forward_conv_layer;
    v12[17] = (uint64_t *)free_conv_buffer;
    v12[18] = (uint64_t *)conv1d_layer_update_shape;
    v12[19] = (uint64_t *)conv_layer_wanted_wb_len;
    if (a4)
    {
      v12[32] = *(uint64_t **)(a4 + 24);
      *((_DWORD *)v12 + 66) = *(_DWORD *)(a4 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v8, v9, v10, v14);
      v12 = v15;
      v15[32] = 0;
      *((_DWORD *)v12 + 66) = 0;
    }
  }
  *a5 = v12;
  return v11;
}

uint64_t conv1d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v10;
  int v11;
  uint64_t result;
  int v13;
  uint64_t v14;

  if (*a2 == 2)
  {
    v10 = *(_DWORD **)(a1 + 120);
    v11 = a2[4];
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v11;
    v10[1] = a2[2];
    v10[3] = 1;
    result = get_padding_size(*(uint64_t **)a1, v10, *(_DWORD *)(a1 + 8), a2, v10 + 14, v10 + 15, v10 + 9);
    v13 = v10[14] * v10[15];
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = v13;
    *(_DWORD *)(a1 + 48) = v10[4];
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d requires input 2D input data", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t create_pooling2d_layer(uint64_t *a1, int a2, __int128 *a3, uint64_t **a4, uint64_t ***a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t v13;
  uint64_t **v14;

  v14 = 0;
  v10 = create_pooling_layer(a1, a2, a3, a4, &v14);
  if ((_DWORD)v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed!", v7, v8, v9, v13);
    v11 = v14;
  }
  else
  {
    v11 = v14;
    v14[18] = (uint64_t *)pooling2d_layer_update_shape;
  }
  *a5 = v11;
  return v10;
}

uint64_t pooling2d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  int v11;
  __int128 v12;
  _DWORD *v13;
  _DWORD *v14;
  uint64_t result;
  int channel;
  uint64_t v17;

  if (*a2 == 3)
  {
    v10 = *(int **)(a1 + 120);
    v11 = *(_DWORD *)(a1 + 8);
    v12 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v12;
    if ((v11 & 0xFFFFFFFE) == 0x12)
    {
      *v10 = a2[2];
      v10[1] = a2[3];
    }
    v13 = v10 + 14;
    v14 = v10 + 15;
    result = get_padding_size(*(uint64_t **)a1, v10, v11, a2, (unsigned int *)v10 + 14, (unsigned int *)v10 + 15, v10 + 9);
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 40) = 3;
      channel = fi_shape_get_channel(a2);
      result = 0;
      *(_DWORD *)(a1 + 44) = channel;
      *(_DWORD *)(a1 + 48) = *v14;
      *(_DWORD *)(a1 + 52) = *v13;
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Current conv layer only support input dim 2 or 3", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t forward_mulaw_layer(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t size;
  uint64_t v12;
  float v13;
  uint64_t v15;
  unsigned int v16;

  v16 = 0;
  v7 = *(_QWORD *)(a2 + 72);
  size = fi_shape_get_size((int *)(a2 + 40), (int *)&v16);
  if ((_DWORD)size)
  {
    log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"input shape of mulaw layer is illegal", v8, v9, v10, v15);
  }
  else
  {
    v12 = v16;
    if (v16)
    {
      do
      {
        v13 = *a3++;
        *a4++ = (float)*(int *)(v7 + 4 * v13);
        --v12;
      }
      while (v12);
    }
  }
  return size;
}

_QWORD *free_mulaw_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_mulaw_layer(uint64_t *a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4);
  if (v6
    && (v10 = (_DWORD *)v6,
        (v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272)) != 0))
  {
    v12 = 0;
    *v10 = *a2;
    *(_QWORD *)v11 = a1;
    *(_DWORD *)(v11 + 8) = 32;
    *(_QWORD *)(v11 + 120) = v10;
    *(_QWORD *)(v11 + 128) = forward_mulaw_layer;
    *(_QWORD *)(v11 + 136) = free_mulaw_buffer;
    *(_QWORD *)(v11 + 144) = mulaw_layer_update_shape;
    *(_QWORD *)(v11 + 152) = mulaw_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_mulaw_buffer(0);
    v11 = 0;
    v12 = 10;
  }
  *a3 = v11;
  return v12;
}

uint64_t mulaw_layer_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  __int128 v10;
  __int128 v11;
  uint64_t vars0;

  if (a2)
  {
    result = 0;
    v10 = *a2;
    *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 20) = v10;
    v11 = *a2;
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 40) = v11;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"mulaw layer cant accept this input shape", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t mulaw_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v8 = **(unsigned int **)(a1 + 120);
  if (v8 > 0x20)
    return 7;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"mu-law bits: %d\n", a6, a7, a8, v8);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
  *a2 = 4 << v8;
  *a3 = 0;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbBytes bBytes: %d %d\n", v16, v17, v18, *a2);
  return 0;
}

uint64_t create_albert_ffn_layer(uint64_t *a1, __int128 *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int32x2_t v33;
  uint64_t v34;
  int v35;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
      v19 = v15;
      if (!v15)
      {
        v26 = *a1;
        v27 = "out of memory!";
LABEL_14:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, v31);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_ffn init param failed!", v28, v29, v30, v32);
        result = 7;
        goto LABEL_15;
      }
      v20 = *a2;
      *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 4);
      *(_OWORD *)v15 = v20;
      v21 = *((_DWORD *)a2 + 1);
      LODWORD(v34) = 40;
      HIDWORD(v34) = v21;
      v35 = 0;
      if (create_norm_layer(a1, &v34, (uint64_t *)(v15 + 24)))
      {
        v25 = "create albert_ffn norm layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v22, v23, v24, v31);
        v26 = *a1;
        v27 = "albert_ffn network init failed!";
        goto LABEL_14;
      }
      HIDWORD(v34) = *(_DWORD *)a2;
      v35 = 0;
      LODWORD(v34) = 5;
      v33 = vrev64_s32(*(int32x2_t *)((char *)a2 + 8));
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 32)))
      {
        v25 = "create albert_ffn o1 dense layer failed!";
        goto LABEL_13;
      }
      HIDWORD(v34) = *((_DWORD *)a2 + 1);
      v35 = 0;
      LODWORD(v34) = 5;
      v33.i32[0] = *((_DWORD *)a2 + 4);
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 40)))
      {
        v25 = "create albert_ffn o2 dense layer failed!";
        goto LABEL_13;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 44;
      *(_QWORD *)(v7 + 128) = forward_albert_ffn_layer;
      *(_QWORD *)(v7 + 136) = free_albert_ffn_layer;
      *(_QWORD *)(v7 + 144) = albert_ffn_layer_update_shape;
      *(_QWORD *)(v7 + 152) = albert_ffn_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = albert_ffn_request_glbBuf;
      *(_QWORD *)(v7 + 184) = albert_ffn_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v22, v23, v24, v31);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_ffn_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v7;
  unsigned int *v8;
  int step;
  uint64_t v10;
  char *v11;
  int padded_len;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;

  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v10 = v8[1];
  v11 = *(char **)(a2 + 240);
  padded_len = get_padded_len(v10, 8u);
  v13 = get_padded_len(v10, 8u);
  bzero(v11, 4 * (v13 * step));
  v14 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 3) + 128))(a1);
  if ((_DWORD)v14)
  {
    v18 = v14;
    v19 = *v7;
    v20 = "albert_ffn forward norm layer failed!";
  }
  else
  {
    v21 = get_padded_len(*v8, 8u);
    bzero(&v11[4 * padded_len * step], 4 * (v21 * step));
    v22 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 4) + 128))(a1);
    if ((_DWORD)v22)
    {
      v18 = v22;
      v19 = *v7;
      v20 = "albert_ffn forward dense o1 failed!";
    }
    else
    {
      v23 = (v10 * step);
      bzero(a4, 4 * v23);
      v18 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 5) + 128))(a1);
      if (!(_DWORD)v18)
      {
        axpy(v23, (float *)v11, 1, (float *)a4, 1, 1.0);
        return v18;
      }
      v19 = *v7;
      v20 = "albert_ffn forward dense o2 layer failed!";
    }
  }
  log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)v20, v15, v16, v17, v25);
  return v18;
}

_QWORD *free_albert_ffn_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[3]);
        fi_layer_free(v3[4]);
        fi_layer_free(v3[5]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 albert_ffn_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v14;
  __n128 *v15;
  unsigned int v16;
  uint64_t v17;

  v9 = *(_QWORD **)(a1 + 120);
  v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = **(_QWORD **)a1;
    v12 = "Currently albert_ffn layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v17);
    return result;
  }
  if (!(*(unsigned int (**)(void))(v9[3] + 144))()
    && !(*(unsigned int (**)(void))(v9[4] + 144))()
    && !(*(unsigned int (**)(void))(v9[5] + 144))())
  {
    v14 = v9[5];
    v16 = *(_DWORD *)(v14 + 40);
    v15 = (__n128 *)(v14 + 40);
    if (v16 >= 3)
    {
      v11 = **(_QWORD **)a1;
      v12 = "o2 output shape error: Currently albert_ffn layer only support 1D or 2D output";
      goto LABEL_3;
    }
    result = *v15;
    *(_DWORD *)(a1 + 56) = v15[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t albert_ffn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[3] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[4] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[5] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"albert_ffn filter size: %d\n", v10, v11, v12, *(unsigned int *)(v6[4] + 12));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_ffn_request_glbBuf(uint64_t a1)
{
  unsigned int *v2;
  int *v3;
  int step;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int padded_len;
  int v10;
  int padded_bytes;
  uint64_t v12;
  unsigned int v13;

  v2 = *(unsigned int **)(a1 + 120);
  v3 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v13 = 0;
  result = fi_shape_get_input_dim(v3, (int *)&v13);
  if (!(_DWORD)result)
  {
    if (v13 == v2[1])
    {
      padded_len = get_padded_len(v13, 8u);
      v10 = get_padded_len(*v2, 8u);
      padded_bytes = get_padded_bytes(4 * step * (v10 + padded_len), 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
    else
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_ffn: input sample dim mismatch!", v6, v7, v8, v12);
      return 7;
    }
  }
  return result;
}

uint64_t albert_ffn_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[3], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[4], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[5], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[6], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[7], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[8], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

_QWORD *free_albert_trans_enc_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[7]);
        fi_layer_free(v3[6]);
        fi_layer_free(v3[8]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_albert_trans_enc_layer(uint64_t *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int32x4_t v20;
  __int128 v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  __int128 v38;
  int v39;
  unsigned int v40[4];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 72);
      v19 = v15;
      if (!v15)
      {
        v29 = *a1;
        v30 = "out of memory!";
LABEL_14:
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v16, v17, v18, v36);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert trans_enc init param failed!", v33, v34, v35, v36);
        result = 7;
        goto LABEL_15;
      }
      v20 = *(int32x4_t *)a2;
      v21 = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(v15 + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v15 + 32) = v21;
      *(int32x4_t *)v15 = v20;
      v43 = 0u;
      v42 = 0u;
      v41 = 0u;
      v37 = 0;
      v36 = 0;
      v23 = *(_DWORD *)(a2 + 24);
      v22 = *(_DWORD *)(a2 + 28);
      v40[2] = 0;
      v40[3] = v22;
      v40[0] = *(_DWORD *)a2;
      v40[1] = v23;
      v24 = *(_DWORD *)(a2 + 8);
      DWORD1(v41) = 0;
      *((_QWORD *)&v41 + 1) = v24;
      LODWORD(v42) = *(_DWORD *)(a2 + 32);
      *((_QWORD *)&v43 + 1) = 0;
      v44 = 0;
      if (create_att_albert_layer(a1, v40, a3, a4, (uint64_t *)(v15 + 48)))
      {
        v28 = "create albert trans_enc att layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v25, v26, v27, v36);
        v29 = *a1;
        v30 = "albert trans_enc network init failed!";
        goto LABEL_14;
      }
      v39 = *(_DWORD *)(a2 + 16);
      *(_QWORD *)&v31 = vrev64q_s32(*(int32x4_t *)a2).u64[0];
      *((_QWORD *)&v31 + 1) = *(_QWORD *)(a2 + 8);
      v38 = v31;
      if (create_albert_ffn_layer(a1, &v38, a3, a4, (uint64_t *)(v19 + 56)))
      {
        v28 = "create albert trans_enc ffn layer failed!";
        goto LABEL_13;
      }
      v32 = *(_DWORD *)(a2 + 20);
      LODWORD(v36) = 40;
      HIDWORD(v36) = v32;
      if (create_norm_layer(a1, &v36, (uint64_t *)(v19 + 64)))
      {
        v28 = "create albert trans_enc norm layer failed!";
        goto LABEL_13;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 42;
      *(_QWORD *)(v7 + 128) = forward_albert_trans_enc_layer;
      *(_QWORD *)(v7 + 136) = free_albert_trans_enc_layer;
      *(_QWORD *)(v7 + 144) = albert_trans_enc_layer_update_shape;
      *(_QWORD *)(v7 + 152) = albert_trans_enc_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = albert_trans_enc_request_glbBuf;
      *(_QWORD *)(v7 + 168) = albert_trans_enc_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = albert_trans_enc_layer_reset;
      *(_QWORD *)(v7 + 184) = albert_trans_enc_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v25, v26, v27, v36);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v36);
      result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_trans_enc_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v6;
  _QWORD *v7;
  char *v8;
  uint64_t v9;
  uint64_t bytes;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  int padded_bytes;
  uint64_t v18;
  uint64_t v19;
  size_t v20;

  LODWORD(v20) = 0;
  if (!a2)
    return 0;
  v6 = *(uint64_t **)a2;
  v7 = *(_QWORD **)(a2 + 120);
  v8 = *(char **)(a2 + 240);
  v9 = v7[6];
  *(_DWORD *)(*(_QWORD *)(v9 + 120) + 192) = 0;
  bytes = fi_shape_get_bytes((int *)(v9 + 40), &v20);
  if (!(_DWORD)bytes)
  {
    bzero(v8, v20);
    v11 = (*(uint64_t (**)(uint64_t))(v7[6] + 128))(a1);
    if ((_DWORD)v11)
    {
      bytes = v11;
      v15 = "albert trans_enc forward att layer failed!";
    }
    else
    {
      padded_bytes = get_padded_bytes(v20, 8u);
      bytes = fi_shape_get_bytes((int *)(v7[7] + 40), &v20);
      if ((_DWORD)bytes)
        return bytes;
      bzero(&v8[padded_bytes & 0xFFFFFFFC], v20);
      v18 = (*(uint64_t (**)(uint64_t))(v7[7] + 128))(a1);
      if ((_DWORD)v18)
      {
        bytes = v18;
        v15 = "albert trans_enc forward ffn layer failed!";
      }
      else
      {
        bzero(a4, v20);
        bytes = (*(uint64_t (**)(uint64_t))(v7[8] + 128))(a1);
        if (!(_DWORD)bytes)
          return bytes;
        v15 = "albert trans_enc forward norm layer failed!";
      }
    }
    log_OutText(*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v12, v13, v14, v19);
  }
  return bytes;
}

__n128 albert_trans_enc_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v15;
  uint64_t v16;

  v8 = *(_QWORD **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = *v9;
    v12 = "Currently albert trans_enc layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v16);
    return result;
  }
  if (!(*(unsigned int (**)(void))(v8[6] + 144))() && !(*(unsigned int (**)(void))(v8[7] + 144))())
  {
    if ((*(_DWORD *)(v8[7] + 40) - 1) >= 2)
    {
      v11 = **(_QWORD **)a1;
      v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    if (!(*(unsigned int (**)(void))(v8[8] + 144))())
    {
      v15 = v8[8];
      result = *(__n128 *)(v15 + 40);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v15 + 56);
      *(__n128 *)(a1 + 40) = result;
    }
  }
  return result;
}

uint64_t albert_trans_enc_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[6] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[7] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[8] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v10, v11, v12, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v13, v14, v15, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 48) + 160))();
  if (!(_DWORD)result)
  {
    v4 = *(_DWORD *)(*(_QWORD *)(v2 + 48) + 248);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 56) + 160))();
    if (!(_DWORD)result)
    {
      v5 = *(_DWORD *)(*(_QWORD *)(v2 + 56) + 248);
      v7 = v5;
      result = albert_trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
      if (!(_DWORD)result)
      {
        if (v5 <= v4)
          v6 = v4;
        else
          v6 = v5;
        *(_DWORD *)(a1 + 248) = v7 + v6;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = albert_trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
  if (!(_DWORD)result)
  {
    v4 = v7;
    v5 = *(_QWORD *)(v2 + 48);
    v6 = *(_QWORD *)(v2 + 56);
    *(_QWORD *)(v5 + 240) = *(_QWORD *)(a1 + 240) + v7;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(_QWORD *)(v6 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t albert_trans_enc_layer_reset(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 48) + 176))();
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert trans_enc network reset failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t albert_trans_enc_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t result;
  int padded_bytes;
  int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 48) + 40), &v7);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(v7, 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 56) + 40), &v7);
    if (!(_DWORD)result)
    {
      v6 = get_padded_bytes(v7, 8u);
      result = 0;
      *a2 = v6 + padded_bytes;
    }
  }
  return result;
}

uint64_t tee_param_alloc_sources(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v3 = *(unsigned int *)(a2 + 68);
  if ((_DWORD)v3)
  {
    v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 24 * v3);
    *(_QWORD *)(a2 + 72) = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v10);
      return 10;
    }
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 72) = 0;
  }
  return result;
}

uint64_t tee_source_cfg_get_source_layer(uint64_t *a1, _QWORD *a2, char *__s1, uint64_t *a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t result;

  *a2 = 0;
  if (a5)
  {
    v12 = a5;
    while (1)
    {
      v13 = *a4;
      if (*(_DWORD *)(*a4 + 8) == 26)
      {
        result = strcmp(__s1, *(const char **)(v13 + 120));
        if (!(_DWORD)result)
          break;
      }
      ++a4;
      if (!--v12)
        goto LABEL_6;
    }
    *a2 = v13;
  }
  else
  {
LABEL_6:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", a6, a7, a8, (uint64_t)__s1);
    return 7;
  }
  return result;
}

uint64_t create_tee_param(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 96);
  *a2 = v4;
  if (v4)
    return 0;
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v5, v6, v7, v9);
  return 10;
}

uint64_t free_tee_param(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(result + 8) + 48))(*(_QWORD *)(result + 16));
  return result;
}

uint64_t create_tee_layer_take_param_ownership(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;

  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9)
  {
    result = 0;
    *(_QWORD *)v9 = a1;
    v11 = *a2;
    *(_QWORD *)(v9 + 120) = *a2;
    *a2 = 0;
    *(_QWORD *)(v11 + 80) = 0;
    *(_DWORD *)(v11 + 88) = 0;
    *(_DWORD *)(v9 + 8) = 26;
    *(_QWORD *)(v9 + 128) = forward_tee_layer;
    *(_QWORD *)(v9 + 136) = free_tee_buffer;
    *(_QWORD *)(v9 + 144) = tee_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v12);
    free_tee_buffer(0);
    result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_tee_layer(uint64_t a1, uint64_t a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  uint64_t result;
  unsigned int v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  float v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  float *v39;
  unsigned int v40;
  float v41;
  void *v42;
  unsigned int v43;
  size_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  int v60;
  unsigned int v61;
  int v62;
  int v63;

  v5 = a2;
  v6 = *(_QWORD *)(a2 + 120);
  v51 = *(uint64_t **)a2;
  if (*(_DWORD *)(v6 + 68))
  {
    v8 = *(_DWORD *)(a2 + 40);
    v9 = (v8 - 1);
    if (v8 == 2)
    {
      v62 = *(_DWORD *)(a2 + 48);
      v54 = v62 * 4 * *(_DWORD *)(a2 + 44);
    }
    else
    {
      v54 = 4 * *(_DWORD *)(a2 + 44);
      v62 = 0;
    }
    v14 = 0;
    v15 = 0;
    v52 = (v8 - 1);
    v53 = *(_QWORD *)(a2 + 120);
    do
    {
      v16 = *(_QWORD *)(v6 + 72);
      v17 = (_DWORD *)(v16 + 24 * v14);
      v18 = *(_QWORD *)v17;
      v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v17 + 120) + 80);
      v20 = v17[3];
      if (v20 >= *(_DWORD *)(v18 + 4 * v9 + 44))
        v21 = *(_DWORD *)(v18 + 4 * v9 + 44);
      else
        v21 = v20;
      v61 = v21;
      if (*(_DWORD *)(v5 + 40) == 2)
      {
        v22 = *(_DWORD *)(v5 + 44);
        if (v22)
        {
          v23 = 0;
          v24 = v15;
          v25 = 0;
          v26 = *(_DWORD *)(v18 + 48);
          v56 = v14;
          v57 = *(_QWORD *)(v6 + 72);
          v27 = v16 + 24 * v14;
          v28 = (_DWORD *)(v27 + 8);
          v29 = (_DWORD *)(v27 + 16);
          v55 = v24;
          v30 = v24;
          v60 = v26;
          v59 = (_DWORD *)(v27 + 8);
          do
          {
            v31 = v21 - *v28;
            if (v21 > *v28)
            {
              v32 = v5;
              v33 = *v28 + v23;
              v34 = v30;
              do
              {
                v35 = *(float *)(v19 + 4 * v33);
                if (*v29 == 1)
                  v35 = exp_fdlibm(v35);
                a4[v34++] = v35;
                ++v33;
                --v31;
              }
              while (v31);
              v5 = v32;
              v22 = *(_DWORD *)(v32 + 44);
              v26 = v60;
              v21 = v61;
              v28 = v59;
            }
            ++v25;
            v30 += v62;
            v23 += v26;
          }
          while (v25 < v22);
          v9 = v52;
          v6 = v53;
          v14 = v56;
          v16 = v57;
          v15 = v55;
        }
      }
      else
      {
        v54 = 4 * *(_DWORD *)(v5 + 44);
        v36 = *(unsigned int *)(v16 + 24 * v14 + 8);
        if (v21 > v36)
        {
          v58 = *(_QWORD *)(v6 + 72);
          v37 = (_DWORD *)(v16 + 24 * v14 + 16);
          v38 = v21 - v36;
          v39 = (float *)(v19 + 4 * v36);
          v40 = v15;
          do
          {
            v41 = *v39;
            if (*v37 == 1)
              v41 = exp_fdlibm(v41);
            a4[v40++] = v41;
            ++v39;
            --v38;
          }
          while (v38);
          v16 = v58;
          v21 = v61;
        }
      }
      v15 = v21 + v15 - *(_DWORD *)(v16 + 24 * v14++ + 8);
    }
    while (v14 < *(unsigned int *)(v6 + 68));
    a3 = a4;
    v13 = v54;
  }
  else
  {
    v63 = 0;
    result = fi_shape_get_size((int *)(a2 + 20), &v63);
    if ((_DWORD)result)
      return result;
    *(_DWORD *)(a5 + 16) = 0;
    v13 = 4 * v63;
  }
  v42 = *(void **)(v6 + 80);
  if (v42)
  {
    if (*(_DWORD *)(v6 + 88) >= v13)
    {
      v44 = v13;
      goto LABEL_36;
    }
    v43 = v13;
    (*(void (**)(uint64_t))(v51[1] + 48))(v51[2]);
    v13 = v43;
    *(_QWORD *)(v6 + 80) = 0;
  }
  v44 = v13;
  v45 = v13;
  v46 = (*(uint64_t (**)(uint64_t, _QWORD))v51[1])(v51[2], v13);
  *(_QWORD *)(v6 + 80) = v46;
  if (v46)
  {
    v42 = (void *)v46;
    *(_DWORD *)(v6 + 88) = v45;
LABEL_36:
    memcpy(v42, a3, v44);
    return 0;
  }
  log_OutText(*v51, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tee layer allocation failed!", v47, v48, v49, v50);
  return 10;
}

_QWORD *free_tee_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        if (*(_QWORD *)(v3 + 72))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 80))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 72) = 0;
        }
        if (*(_QWORD *)(v3 + 80))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 80) = 0;
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t tee_layer_update_shape(uint64_t a1, int *a2)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  BOOL v26;
  int v27;

  v4 = *(_QWORD *)(a1 + 120);
  v27 = 0;
  v5 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v5;
  result = fi_shape_get_size(a2, &v27);
  if (!(_DWORD)result)
  {
    v10 = (_OWORD *)(a1 + 40);
    if (*(_DWORD *)(v4 + 68))
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      while (1)
      {
        v16 = *(_QWORD *)(v4 + 72);
        if (!v15)
        {
          v17 = *(_QWORD *)(v16 + v11);
          v15 = *(_DWORD *)(v17 + 40);
          v18 = *(_OWORD *)(v17 + 40);
          *(_DWORD *)(a1 + 56) = *(_DWORD *)(v17 + 56);
          *v10 = v18;
          v13 = v15 - 1;
        }
        v19 = *(_QWORD *)(v16 + v11);
        if (*(_DWORD *)(v19 + 40) != v15)
          break;
        v20 = *(_DWORD *)(v19 + 4 * v13 + 44);
        v23 = (int *)(v16 + v11 + 8);
        v21 = *v23;
        v22 = v23[1];
        if (v22 < v20)
          v20 = v22;
        v14 = v14 - v21 + v20;
        ++v12;
        v11 += 24;
        if (v12 >= *(unsigned int *)(v4 + 68))
        {
          *(_DWORD *)(a1 + 4 * v13 + 44) = v14;
          goto LABEL_12;
        }
      }
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Soure layer %d has wrong number of dimensions!", v7, v8, v9, v12);
    }
    else
    {
      v24 = *(_OWORD *)a2;
      *(_DWORD *)(a1 + 56) = a2[4];
      *v10 = v24;
      v14 = *(_DWORD *)(a1 + 4 * (*a2 - 1) + 44);
LABEL_12:
      v25 = *(unsigned int *)(v4 + 64);
      if ((_DWORD)v25)
        v26 = v14 == (_DWORD)v25;
      else
        v26 = 1;
      if (v26)
        return 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Output dimension %d does not match calculated output dimension %d for layer %s!", v7, v8, v9, v25);
    }
    return 7;
  }
  return result;
}

uint64_t tee_layer_get_output_buffer(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 120) + 80);
}

uint64_t config_merge_layer_param(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5, unsigned int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;

  *(_DWORD *)a2 = a3;
  v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 8 * a3);
  *(_QWORD *)(a2 + 8) = v12;
  if (v12)
  {
    if (a3)
    {
      v16 = v12;
      v17 = 0;
      v28 = a3;
      v29 = a5;
      v18 = (const char *)a4;
      v19 = a6;
      while (1)
      {
        v20 = strlen(v18);
        *(_QWORD *)(v16 + 8 * v17) = 0;
        if (!a6)
          break;
        v24 = v20;
        while (1)
        {
          v25 = *a5;
          if (*(_DWORD *)(*a5 + 8) == 26)
          {
            result = strcmp(v18, *(const char **)(v25 + 120));
            if (!(_DWORD)result)
              break;
          }
          ++a5;
          if (!--v19)
          {
            a4 = (uint64_t)v18;
            goto LABEL_13;
          }
        }
        *(_QWORD *)(v16 + 8 * v17) = v25;
        v18 += v24 + 1;
        ++v17;
        a5 = v29;
        v19 = a6;
        if (v17 == v28)
          return result;
      }
LABEL_13:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", v21, v22, v23, a4);
      return 7;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v27);
    return 10;
  }
}

uint64_t create_merge_layer(uint64_t *a1, _OWORD *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  _OWORD *v12;
  uint64_t result;
  uint64_t v14;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    v12 = (_OWORD *)v11;
    result = 0;
    *v12 = *a2;
    *((_DWORD *)v10 + 2) = 31;
    v10[16] = (uint64_t *)forward_merge_layer;
    v10[17] = (uint64_t *)free_merge_buffer;
    v10[18] = (uint64_t *)merge_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_merge_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_merge_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t output_buffer;
  uint64_t v31;
  size_t __n;

  v10 = *(unsigned int **)(a2 + 120);
  LODWORD(__n) = 0;
  v11 = *(_DWORD *)(a2 + 40);
  if (v11 == 2)
  {
    v21 = *(_DWORD *)(a2 + 44);
    if (v21)
    {
      v22 = 0;
      v23 = *(_DWORD *)(a2 + 48);
      LODWORD(v24) = *v10;
      do
      {
        if ((_DWORD)v24)
        {
          v25 = 0;
          v26 = 0;
          do
          {
            v27 = *(_QWORD *)(*((_QWORD *)v10 + 1) + 8 * v25);
            v28 = *(_DWORD *)(v27 + 56);
            v29 = *(_DWORD *)(v27 + 48);
            output_buffer = tee_layer_get_output_buffer(v27);
            memcpy((void *)(a4 + (v28 * (v26 + v22 * v23))), (const void *)(output_buffer + (v29 * v28 * v22)), (v29 * v28));
            v26 += v29;
            ++v25;
            v24 = *v10;
          }
          while (v25 < v24);
        }
        ++v22;
      }
      while (v22 != v21);
    }
    return 0;
  }
  if (v11 != 1)
  {
    log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"merge layer only support concatenation of 1d and 2d data", a6, a7, a8, v31);
    return 0;
  }
  if (!*v10)
    return 0;
  v12 = 0;
  v13 = 0;
  while (1)
  {
    v14 = *(_QWORD *)(*((_QWORD *)v10 + 1) + 8 * v12);
    result = fi_shape_get_bytes((int *)(v14 + 40), &__n);
    if ((_DWORD)result)
      break;
    if (!(_DWORD)__n)
    {
      log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"merge layer source layer output length=0!", v16, v17, v18, v31);
      return 7;
    }
    v19 = (const void *)tee_layer_get_output_buffer(v14);
    v20 = __n;
    memcpy((void *)(a4 + v13), v19, __n);
    v13 += v20;
    if (++v12 >= (unint64_t)*v10)
      return 0;
  }
  return result;
}

_QWORD *free_merge_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        if (*(_QWORD *)(v3 + 8))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 80))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 8) = 0;
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t merge_layer_update_shape(uint64_t a1, int *a2)
{
  unsigned int *v3;
  int v4;
  uint64_t size;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  int v30;

  v3 = *(unsigned int **)(a1 + 120);
  v30 = 0;
  v4 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v4;
  size = fi_shape_get_size(a2, &v30);
  if (!(_DWORD)size)
  {
    if (*v3)
    {
      v6 = **((_QWORD **)v3 + 1);
      v7 = *(_OWORD *)(v6 + 40);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v6 + 56);
      *(_OWORD *)(a1 + 40) = v7;
      v8 = **((_QWORD **)v3 + 1);
      v9 = (*(_DWORD *)(v8 + 40) - 1);
      v10 = *(_DWORD *)(v8 + 40 + 4 * v9 + 4);
      if (*v3 < 2)
      {
LABEL_7:
        size = 0;
        *(_DWORD *)(a1 + 4 * v9 + 44) = v10;
      }
      else
      {
        v11 = 1;
        while (1)
        {
          v12 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)v3 + 1) + 8 * v11) + 40);
          v13 = v12[v9 + 1];
          v14 = fi_shape_merge(v12, (_DWORD *)(a1 + 40));
          if ((_DWORD)v14)
            break;
          v10 += v13;
          if (++v11 >= (unint64_t)*v3)
            goto LABEL_7;
        }
        size = v14;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer outputs cannot be merged!", v15, v16, v17, v29);
        fi_shape_dump(*(uint64_t **)a1, *(_QWORD *)(*((_QWORD *)v3 + 1) + 8 * v11) + 40, (uint64_t)"shape to be merged", v18, v19, v20, v21, v22);
        fi_shape_dump(*(uint64_t **)a1, a1 + 40, (uint64_t)"shape", v23, v24, v25, v26, v27);
      }
    }
    else
    {
      return 7;
    }
  }
  return size;
}

uint64_t create_label_layer(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t result;
  uint64_t v24;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v11)
    goto LABEL_10;
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64);
  if (!v12)
    goto LABEL_10;
  v13 = v12;
  if (a3)
    *(_QWORD *)(v11 + 60) = *a3;
  v14 = *(_OWORD *)a2;
  v15 = *((_OWORD *)a2 + 1);
  v16 = *((_OWORD *)a2 + 2);
  *(_QWORD *)(v12 + 48) = *((_QWORD *)a2 + 6);
  *(_OWORD *)(v12 + 16) = v15;
  *(_OWORD *)(v12 + 32) = v16;
  *(_OWORD *)v12 = v14;
  v17 = *a2;
  v18 = 8 * v17;
  v19 = (*(uint64_t (**)(uint64_t, uint64_t))a1[1])(a1[2], 8 * v17);
  *(_QWORD *)(v13 + 56) = v19;
  if (v19)
  {
    if ((_DWORD)v17)
    {
      v20 = v19;
      v21 = 0;
      v22 = 0;
      do
      {
        *(_QWORD *)(v20 + v21) = *((_QWORD *)a2 + 1) + v22;
        v20 = *(_QWORD *)(v13 + 56);
        v22 += strlen(*(const char **)(v20 + v21)) + 1;
        v21 += 8;
      }
      while (v18 != v21);
    }
    result = 0;
    *(_DWORD *)(v11 + 8) = 20;
    *(_QWORD *)v11 = a1;
    *(_QWORD *)(v11 + 120) = v13;
    *(_QWORD *)(v11 + 128) = forward_label_layer;
    *(_QWORD *)(v11 + 136) = free_label_buffer;
    *(_QWORD *)(v11 + 144) = label_layer_update_shape;
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v24);
    free_label_buffer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_label_layer(uint64_t a1, uint64_t a2, float *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t v10;
  int *v11;
  unsigned int step;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t input_dim;
  int v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float *v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  _BOOL4 v56;
  uint64_t v57;
  int v58;
  float v59;
  unsigned int v60;
  float v61;
  double v62;
  double v63;
  float v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  double v68;
  float v69;
  float v70;
  double v71;
  float v72;
  float v73;
  uint64_t v74;
  int LargestIdx;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v83;
  int v84;
  unsigned int *v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  float *v89;
  uint64_t v90;
  uint64_t i;
  unsigned int v92;
  uint64_t *v93;
  uint64_t v94;
  float *v95;
  uint64_t v96;
  int v97[3];

  v9 = *(uint64_t **)a2;
  v97[0] = 0;
  v10 = *(_QWORD *)(a2 + 120);
  v11 = (int *)(a2 + 20);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = fi_shape_get_input_dim(v11, v97);
  if ((_DWORD)input_dim)
    return input_dim;
  v17 = *(_DWORD *)(v10 + 16);
  if (v17)
    v18 = step >= 2;
  else
    v18 = 0;
  if (v18)
  {
    v89 = a3;
    v28 = *(uint64_t **)a2;
    v29 = *(unsigned int **)(a2 + 120);
    v30 = *v29;
    v31 = *((_QWORD *)v29 + 3);
    v96 = *((_QWORD *)v29 + 5);
    v35 = fi_shape_get_step(v11);
    if (v35 > 1)
    {
      v88 = (v35 - 1);
      v39 = ((v35 - 1) * v30);
      v94 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v28[1] + 16))(v28[2], v39, 4);
      if (v94)
      {
        v43 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v28[1] + 16))(v28[2], (v35 * v30), 4);
        v47 = (float *)v43;
        if (v43)
        {
          v86 = v39;
          v87 = v9;
          v93 = v28;
          v95 = (float *)v43;
          v85 = v29;
          if ((_DWORD)v30)
          {
            v48 = v89;
            v49 = v30;
            do
            {
              v50 = *v48++;
              v51 = log_fdlibm(v50);
              *v47++ = v51;
              --v49;
            }
            while (v49);
            v52 = v30;
          }
          else
          {
            v52 = 0;
          }
          v92 = 0;
          v84 = v35;
          v90 = v35;
          for (i = 1; i != v90; ++i)
          {
            if ((_DWORD)v30)
            {
              v54 = 0;
              v56 = i == 1 && v96 != 0;
              do
              {
                v57 = 0;
                v58 = -1;
                v59 = -3.4028e38;
                v60 = v54;
                do
                {
                  v61 = *(float *)(v31 + 4 * v60);
                  v62 = log_fdlibm(v89[(v30 * i) + v54]);
                  v63 = v62;
                  v64 = v95[v92 + v57];
                  *(float *)&v62 = v61;
                  if (!almost_equal_floats(v62, 0.0))
                  {
                    if (!v56 || (LODWORD(v68) = *(_DWORD *)(v96 + 4 * v57), !almost_equal_floats(v68, 0.0)))
                    {
                      v69 = v63;
                      v70 = v64 + v69;
                      v71 = v61;
                      v72 = log_fdlibm(v71);
                      if ((float)(v70 + v72) > v59)
                      {
                        v73 = log_fdlibm(v71);
                        v59 = v70 + v73;
                        v58 = v57;
                      }
                    }
                  }
                  ++v57;
                  v60 += v30;
                }
                while (v52 != v57);
                if (v58 == -1)
                {
                  log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"No valid path for %d node at step %d", v65, v66, v67, v54);
                }
                else
                {
                  *(_DWORD *)(v94 + 4 * ((i - 1) * v30 + v54)) = v58;
                  v95[(v30 * i + v54)] = v59;
                }
                ++v54;
              }
              while (v54 != v52);
            }
            v92 += v30;
          }
          v74 = v88;
          if ((v88 & 0x80000000) != 0)
          {
            v53 = 0;
            input_dim = 7;
            v9 = v87;
            v28 = v93;
            v47 = v95;
          }
          else
          {
            v47 = v95;
            LargestIdx = getLargestIdx((uint64_t)&v95[v86], v30);
            if (LargestIdx == -1)
            {
              v28 = v93;
              log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Cannot find a valid value from output at %d", v76, v77, v78, v88);
              v53 = 0;
              input_dim = 7;
            }
            else
            {
              v79 = LargestIdx;
              v80 = v30 * (v84 - 2);
              v28 = v93;
              if ((LargestIdx & 0x80000000) == 0)
                goto LABEL_56;
LABEL_55:
              log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Best path broken at step %d", v76, v77, v78, v74);
LABEL_56:
              while (1)
              {
                v81 = *(_QWORD *)(*((_QWORD *)v85 + 7) + 8 * v79);
                if (!v74)
                  break;
                a4[v74--] = v81;
                v79 = *(_DWORD *)(v94 + 4 * (v79 + v80));
                v80 -= v30;
                if (v79 < 0)
                  goto LABEL_55;
              }
              input_dim = 0;
              *a4 = v81;
              v53 = 1;
            }
            v9 = v87;
          }
        }
        else
        {
          log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v44, v45, v46, v83);
          v53 = 0;
          input_dim = 10;
        }
        (*(void (**)(uint64_t, uint64_t))(v28[1] + 48))(v28[2], v94);
        if (v47)
          (*(void (**)(uint64_t, float *))(v28[1] + 48))(v28[2], v47);
        if ((v53 & 1) != 0)
          return 0;
      }
      else
      {
        log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v40, v41, v42, v83);
        input_dim = 10;
      }
    }
    else
    {
      log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"forward label layer using viterbi with invalid step = %d!", v32, v33, v34, v35);
      input_dim = 7;
    }
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"forward label layer viterbi failed!", v36, v37, v38, v83);
    return input_dim;
  }
  if (v17)
    v19 = step > 1;
  else
    v19 = 1;
  if (!v19)
    log_OutText(*v9, (uint64_t)"FastInfer", 1, 0, (uint64_t)"Disable viterbi when step < 2", v13, v14, v15, v83);
  if (!step)
    return 0;
  v20 = 0;
  while (1)
  {
    v24 = getLargestIdx((uint64_t)&a3[(v97[0] * v20)], v97[0]);
    v25 = *v9;
    if (v24 == -1)
      break;
    log_OutText(v25, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Label score: %f", v21, v22, v23, COERCE__INT64(a3[(v24 + v97[0] * v20)]));
    v26 = *(float *)(a5 + 24);
    if (v26 <= 0.0 || a3[(v24 + v97[0] * v20)] >= v26)
      v27 = *(_QWORD *)(*(_QWORD *)(v10 + 56) + 8 * v24);
    else
      v27 = 0;
    a4[v20++] = v27;
    if (step == v20)
      return 0;
  }
  log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Cannot find a valid value from output at %d", v21, v22, v23, v20);
  return 7;
}

_QWORD *free_label_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        if (*(_QWORD *)(v3 + 56))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 56) = 0;
        }
        if (*(_DWORD *)(v3 + 48))
        {
          if (*(_QWORD *)(v3 + 8))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v3 + 8) = 0;
          }
          if (*(_QWORD *)(v3 + 24))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v3 + 24) = 0;
          }
          if (*(_QWORD *)(v3 + 40))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v3 + 40) = 0;
          }
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t label_layer_update_shape(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  __int128 v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int step;
  int v18;

  v9 = **(unsigned int **)(a1 + 120);
  v18 = 0;
  a2[4] = 8;
  *(_DWORD *)(a1 + 56) = 8;
  v10 = *a2;
  if ((v10 - 1) >= 2)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"label layer only supports 1D/2D input, got %d", a6, a7, a8, v10);
    return 7;
  }
  v12 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v12;
  result = fi_shape_get_input_dim((int *)(a1 + 20), &v18);
  if ((_DWORD)result)
    return result;
  if (v18 != (_DWORD)v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"NUM of LABEL: %d not same with input data dim %d", v14, v15, v16, v9);
    return 7;
  }
  if (*a2 == 2)
  {
    *(_DWORD *)(a1 + 40) = 1;
    step = fi_shape_get_step((_DWORD *)(a1 + 20));
    result = 0;
    *(_DWORD *)(a1 + 44) = step;
    goto LABEL_12;
  }
  if (*a2 == 1)
  {
    result = 0;
    *(_QWORD *)(a1 + 40) = 0x100000001;
LABEL_12:
    *(_DWORD *)(a1 + 56) = a2[4];
    return result;
  }
  return 0;
}

uint64_t create_embedding_layer(uint64_t *a1, uint64_t *a2, uint64_t ***a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t result;
  uint64_t v13;

  v9 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9 && (v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) != 0)
  {
    v11 = (uint64_t *)v10;
    result = 0;
    *v11 = *a2;
    *v9 = a1;
    v9[15] = v11;
    v9[16] = (uint64_t *)forward_embedding_layer;
    v9[1] = (uint64_t *)39;
    v9[17] = (uint64_t *)free_embedding_buffer;
    v9[18] = (uint64_t *)embedding_layer_update_shape;
    v9[19] = (uint64_t *)embedding_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v13);
    free_embedding_buffer(v9);
    result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_embedding_layer(uint64_t a1, uint64_t a2, float *a3, uint64_t a4)
{
  uint64_t v7;
  int *v8;
  int step;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  int padded_len;
  int v17;
  unsigned int v18;
  unsigned int v19;
  size_t v20;
  unsigned int v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  unsigned int v25;

  v7 = *(_QWORD *)(a2 + 120);
  v8 = (int *)(a2 + 40);
  step = fi_shape_get_step((_DWORD *)(a2 + 40));
  v25 = 0;
  if (v7)
  {
    LODWORD(v13) = step;
    v14 = *(_QWORD *)(a2 + 88);
    result = fi_shape_get_input_dim(v8, (int *)&v25);
    if ((_DWORD)result)
      return result;
    padded_len = get_padded_len(v25, 8u);
    if (!(_DWORD)v13)
      return 0;
    v17 = padded_len;
    v18 = 0;
    v19 = v25;
    v20 = 4 * v25;
    v13 = v13;
    while (1)
    {
      v21 = *a3;
      if (*(_DWORD *)(v7 + 4) <= v21)
        break;
      memcpy((void *)(a4 + 4 * v18), (const void *)(v14 + 4 * v17 * v21), v20);
      v18 += v19;
      ++a3;
      if (!--v13)
        return 0;
    }
    v22 = **(_QWORD **)a2;
    v23 = "invalid key!";
  }
  else
  {
    v22 = **(_QWORD **)a2;
    v23 = "invalid param!";
  }
  log_OutText(v22, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v10, v11, v12, v24);
  return 7;
}

_QWORD *free_embedding_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t embedding_layer_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  const char *v13;
  uint64_t vars0;

  v8 = *(int **)(a1 + 120);
  if (!v8)
  {
    v12 = **(_QWORD **)a1;
    v13 = "invalid param!";
LABEL_7:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, vars0);
    return 7;
  }
  v9 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v9;
  if (*(_DWORD *)a2 != 1)
  {
    v12 = **(_QWORD **)a1;
    v13 = "Currently embedding layer only support 1D input";
    goto LABEL_7;
  }
  v10 = 0;
  if (*((_DWORD *)a2 + 1) == 1)
  {
    v11 = *v8;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v11;
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 48) = *v8;
  }
  *(_DWORD *)(a1 + 56) = 4;
  return v10;
}

uint64_t embedding_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  int padded_len;
  uint64_t result;
  uint64_t v15;

  v8 = *(unsigned int **)(a1 + 120);
  if (v8 && (v9 = v8[1]) != 0 && (v10 = *v8, (_DWORD)v10))
  {
    padded_len = get_padded_len(v10, 8u);
    result = 0;
    *a2 = 4 * v9 * padded_len;
    *a3 = 0;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid param!", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_enc_dispatch_weights(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 48), v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 56), v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

uint64_t create_trans_enc_layer(uint64_t *a1, __int128 *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int8x16_t v35;
  uint64_t v36;
  int v37;
  int v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64);
      v19 = v15;
      if (!v15)
      {
        v27 = *a1;
        v28 = "out of memory!";
LABEL_12:
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v16, v17, v18, v32);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_enc init param failed!", v29, v30, v31, v33);
        result = 7;
        goto LABEL_13;
      }
      v20 = *a2;
      v21 = a2[1];
      *(_OWORD *)(v15 + 28) = *(__int128 *)((char *)a2 + 28);
      *(_OWORD *)v15 = v20;
      *(_OWORD *)(v15 + 16) = v21;
      v40 = 0u;
      v41 = 0u;
      v39 = 0u;
      DWORD1(v39) = 0;
      v22 = *((_DWORD *)a2 + 6);
      v37 = 0;
      v38 = v22;
      v36 = *((_QWORD *)a2 + 2);
      *((float *)&v39 + 2) = (float)*((unsigned int *)a2 + 7);
      *(_QWORD *)&v41 = 0;
      DWORD2(v41) = 0;
      if (create_att_layer(a1, (unsigned int *)&v36, a3, a4, (uint64_t *)(v15 + 48)))
      {
        v26 = "create trans_enc att layer failed!";
LABEL_11:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v32);
        v27 = *a1;
        v28 = "trans_enc network init failed!";
        goto LABEL_12;
      }
      v34 = *(_DWORD *)a2;
      v35 = vextq_s8(*(int8x16_t *)((char *)a2 + 4), *(int8x16_t *)((char *)a2 + 4), 0xCuLL);
      if (create_ffn_layer(a1, (__int128 *)&v34, a3, a4, (uint64_t *)(v19 + 56)))
      {
        v26 = "create trans_enc ffn layer failed!";
        goto LABEL_11;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 35;
      *(_QWORD *)(v7 + 128) = forward_trans_enc_layer;
      *(_QWORD *)(v7 + 136) = free_trans_enc_layer;
      *(_QWORD *)(v7 + 144) = trans_enc_layer_update_shape;
      *(_QWORD *)(v7 + 152) = trans_enc_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_enc_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_enc_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_enc_layer_reset;
      *(_QWORD *)(v7 + 184) = trans_enc_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v32);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v32);
      result = 10;
    }
  }
LABEL_13:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_enc_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t bytes;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v17;
  size_t v18;

  LODWORD(v18) = 0;
  if (!a2)
    return 0;
  v6 = *(uint64_t **)a2;
  v7 = *(_QWORD *)(a2 + 120);
  v8 = *(void **)(a2 + 240);
  v9 = *(_QWORD *)(v7 + 48);
  *(_DWORD *)(*(_QWORD *)(v9 + 120) + 152) = 0;
  bytes = fi_shape_get_bytes((int *)(v9 + 40), &v18);
  if (!(_DWORD)bytes)
  {
    bzero(v8, v18);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 48) + 128))(a1);
    if ((_DWORD)v11)
    {
      bytes = v11;
      v15 = "trans_enc forward att layer failed!";
LABEL_5:
      log_OutText(*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v12, v13, v14, v17);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v7 + 56) + 40), &v18);
    if (!(_DWORD)bytes)
    {
      bzero(a4, v18);
      bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 56) + 128))(a1);
      if ((_DWORD)bytes)
      {
        v15 = "trans_enc forward ffn layer failed!";
        goto LABEL_5;
      }
    }
  }
  return bytes;
}

_QWORD *free_trans_enc_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 56));
        fi_layer_free(*(_QWORD *)(v3 + 48));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 trans_enc_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v15;
  __n128 *v16;
  int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = *v9;
    v12 = "Currently trans_enc layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 48) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 56) + 144))())
  {
    v15 = *(_QWORD *)(v8 + 56);
    v17 = *(_DWORD *)(v15 + 40);
    v16 = (__n128 *)(v15 + 40);
    if ((v17 - 1) >= 2)
    {
      v11 = **(_QWORD **)a1;
      v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t trans_enc_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 48) + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 56) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v9, v10, v11, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v12, v13, v14, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t trans_enc_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 48) + 160))();
  if (!(_DWORD)result)
  {
    v4 = *(_DWORD *)(*(_QWORD *)(v2 + 48) + 248);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 56) + 160))();
    if (!(_DWORD)result)
    {
      v5 = *(_DWORD *)(*(_QWORD *)(v2 + 56) + 248);
      v7 = v5;
      result = trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
      if (!(_DWORD)result)
      {
        if (v5 <= v4)
          v6 = v4;
        else
          v6 = v5;
        *(_DWORD *)(a1 + 248) = v7 + v6;
      }
    }
  }
  return result;
}

uint64_t trans_enc_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
  if (!(_DWORD)result)
  {
    v4 = v7;
    v5 = *(_QWORD *)(v2 + 48);
    v6 = *(_QWORD *)(v2 + 56);
    *(_QWORD *)(v5 + 240) = *(_QWORD *)(a1 + 240) + v7;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(_QWORD *)(v6 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t trans_enc_layer_reset(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 48) + 176))();
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_enc network reset failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t trans_enc_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t bytes;
  unsigned int v6;

  v3 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 48) + 40), &v6);
  if (!(_DWORD)bytes)
    *a2 = get_padded_bytes(v6, 8u);
  return bytes;
}

_QWORD *free_att_albert_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;

  if (!result)
    return result;
  v1 = result;
  v2 = *result;
  if (!*result)
    return result;
  v3 = result[15];
  if (v3)
  {
    fi_layer_free(*(_QWORD *)(v3 + 72));
    if (*(_QWORD *)(v3 + 56))
    {
      if (!*(_QWORD *)(v3 + 144))
        goto LABEL_8;
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
    }
    *(_QWORD *)(v3 + 144) = 0;
LABEL_8:
    if (*(_DWORD *)(v3 + 8))
    {
      v4 = *(_DWORD *)(v3 + 20);
      if (v4 == 1)
      {
        if (*(_DWORD *)(v3 + 64))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 176))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 176) = 0;
        }
        v5 = (_QWORD *)(v3 + 184);
        if (!*(_QWORD *)(v3 + 184))
          goto LABEL_22;
      }
      else
      {
        if (v4 || *(_DWORD *)(v3 + 64))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 160))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 160) = 0;
        }
        v5 = (_QWORD *)(v3 + 168);
        if (!*(_QWORD *)(v3 + 168))
          goto LABEL_22;
      }
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *v5 = 0;
    }
LABEL_22:
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
  }
  if (*((_DWORD *)v1 + 29))
  {
    if (v1[9])
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
    *(_OWORD *)(v1 + 11) = 0u;
    *(_OWORD *)(v1 + 13) = 0u;
    *(_OWORD *)(v1 + 9) = 0u;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
}

uint64_t create_att_albert_layer(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int padded_len;
  int v27;
  uint64_t v28;
  const char *v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
      v19 = v15;
      if (!v15)
      {
        v28 = *a1;
        v29 = "out of memory!";
        goto LABEL_15;
      }
      *(_OWORD *)v15 = *(_OWORD *)a2;
      v20 = *((_OWORD *)a2 + 1);
      v21 = *((_OWORD *)a2 + 2);
      v22 = *((_OWORD *)a2 + 3);
      *(_QWORD *)(v15 + 64) = *((_QWORD *)a2 + 8);
      *(_OWORD *)(v15 + 32) = v21;
      *(_OWORD *)(v15 + 48) = v22;
      *(_OWORD *)(v15 + 16) = v20;
      v36 = 0;
      *(_DWORD *)(v15 + 192) = 0;
      padded_len = get_padded_len(*a2, 8u);
      if (a2[7] == 1)
      {
        v27 = *a2;
        HIDWORD(v34) = 40;
        v35 = v27;
        if (create_norm_layer(a1, (uint64_t *)((char *)&v34 + 4), (uint64_t *)(v19 + 72)))
        {
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create att norm layer failed!", v23, v24, v25, v34);
          v28 = *a1;
          v29 = "att network init failed!";
LABEL_15:
          log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v16, v17, v18, v34);
          *(_QWORD *)(v7 + 120) = v19;
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att init param failed!", v31, v32, v33, v34);
          result = 7;
          goto LABEL_25;
        }
      }
      v35 = padded_len;
      v36 = 0;
      HIDWORD(v34) = 5;
      *(_OWORD *)(v19 + 160) = 0u;
      *(_OWORD *)(v19 + 176) = 0u;
      if (a2[2])
      {
        v30 = a2[5];
        if (v30 == 1)
        {
          if (!a2[16])
          {
            *(_QWORD *)(v19 + 176) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
            *(_QWORD *)(v19 + 184) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
          }
        }
        else if (!v30 && !a2[16])
        {
          *(_QWORD *)(v19 + 160) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
          *(_QWORD *)(v19 + 168) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
        }
      }
      *(_DWORD *)(v19 + 152) = 0;
      if (!*((_QWORD *)a2 + 7))
        *(_QWORD *)(v19 + 144) = 0;
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_att_albert_layer;
      *(_QWORD *)(v7 + 136) = free_att_albert_layer;
      *(_QWORD *)(v7 + 8) = 41;
      *(_QWORD *)(v7 + 144) = att_albert_layer_update_shape;
      *(_QWORD *)(v7 + 152) = att_albert_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = att_albert_request_glbBuf;
      *(_QWORD *)(v7 + 176) = att_albert_layer_reset;
      *(_QWORD *)(v7 + 184) = att_albert_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v34);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      result = 10;
    }
  }
LABEL_25:
  *a5 = v7;
  return result;
}

uint64_t forward_att_albert_layer(uint64_t a1, uint64_t a2, void *a3, float32x4_t *a4)
{
  uint64_t *v7;
  unsigned int *v8;
  uint64_t step;
  unsigned int v10;
  uint64_t padded_len;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  BOOL v20;
  unsigned int v21;
  float32x4_t *v22;
  float32x4_t *v23;
  uint64_t v24;
  float32x4_t *v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float32x4_t *v31;
  int v32;
  uint64_t v33;
  char *v34;
  float32x4_t *v35;
  float32x4_t *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  float v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  float32x4_t *v65;
  float32x4_t *v66;
  int v67;
  uint64_t v68;
  int v69;
  int v70;
  unsigned int v71;
  int v72;
  uint64_t v73;
  uint64_t v75;
  float32x4_t *v76;
  void *__src;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  float32x4_t *v81;
  uint64_t v82;
  float32x4_t *v83;
  uint64_t v84;
  uint64_t v85;
  float32x4_t *v86;
  char *v87;
  int v88;
  float32x4_t *v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v92;
  unsigned int v94;

  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v10 = step;
  padded_len = get_padded_len(step, 8u);
  v85 = *v8;
  v12 = get_padded_len(v85, 8u);
  v13 = v8[3];
  v14 = get_padded_len(v13, 8u);
  v18 = v8[5];
  v19 = v8[2];
  if (v19)
    v20 = 0;
  else
    v20 = v18 == 1;
  if (v20)
  {
    log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"encoder decoder attention is possible only if isDecoder option has been set to 1", v15, v16, v17, v75);
    return 7;
  }
  v90 = v13;
  v84 = v8[1];
  v79 = v8[5];
  v88 = v14;
  if (v18 == 1)
  {
    v21 = fi_shape_get_step(v8 + 9);
    v22 = *(float32x4_t **)(a2 + 240);
    if (v8[2])
    {
      v86 = (float32x4_t *)*((_QWORD *)v8 + 22);
      v23 = (float32x4_t *)*((_QWORD *)v8 + 23);
LABEL_13:
      v83 = v23;
      v25 = v22;
      goto LABEL_15;
    }
  }
  else
  {
    v21 = v10 + v10 * v8[48];
    v22 = *(float32x4_t **)(a2 + 240);
    if (v19)
    {
      v86 = (float32x4_t *)*((_QWORD *)v8 + 20);
      v23 = (float32x4_t *)*((_QWORD *)v8 + 21);
      goto LABEL_13;
    }
  }
  v25 = (float32x4_t *)((char *)v22 + 4 * v12 * v10);
  bzero(v25, 4 * v12 * v10);
  v83 = 0;
  v86 = v25;
LABEL_15:
  v80 = v12;
  v78 = v12 * v10;
  v26 = 4 * v78;
  bzero(v22, 4 * v78);
  __src = a3;
  if (v8[7] == 1)
  {
    v27 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 9) + 128))(a1);
    if ((_DWORD)v27)
    {
      v24 = v27;
      log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att forward norm layer failed!", v28, v29, v30, v75);
      return v24;
    }
  }
  else
  {
    memcpy(v22, a3, v26);
  }
  v89 = v22;
  v92 = (uint64_t)v7;
  v82 = 4 * v78;
  bzero(a4, v26);
  v31 = a4;
  if (v8[6] == 1 && v10)
  {
    v32 = 0;
    v33 = v10;
    do
    {
      memcpy(&v31->f32[v32], *((const void **)v8 + 14), 4 * v85);
      v32 += v80;
      --v33;
    }
    while (v33);
  }
  v91 = v88 * v90;
  v34 = &v25->i8[4 * v78];
  gemm_v2((uint64_t)v7, 0, v10, v80, v80, (uint64_t)v89, v80, *((_QWORD *)v8 + 11), v80, v31, v80);
  v81 = v31;
  if (v79 == 1)
  {
    v36 = (float32x4_t *)*((_QWORD *)v8 + 22);
    v35 = (float32x4_t *)*((_QWORD *)v8 + 23);
    v37 = v84;
    v83 = v35;
    v86 = v36;
    if (v8[38])
      goto LABEL_42;
    bzero(v36, 4 * v21 * v80);
    bzero(v35, 4 * v21 * v80);
    if (v8[6] == 1 && v21)
    {
      v38 = 0;
      v39 = v21;
      do
      {
        memcpy(&v36->f32[v38], *((const void **)v8 + 13), 4 * v85);
        v38 += v80;
        --v39;
      }
      while (v39);
    }
    gemm_v2(v92, 0, v21, v80, v80, *((_QWORD *)v8 + 18), v80, *((_QWORD *)v8 + 10), v80, v36, v80);
    if (v8[6] == 1 && v21 != 0)
    {
      v41 = 0;
      v42 = v21;
      do
      {
        memcpy(&v83->f32[v41], *((const void **)v8 + 15), 4 * v85);
        v41 += v80;
        --v42;
      }
      while (v42);
    }
    gemm_v2(v92, 0, v21, v80, v80, *((_QWORD *)v8 + 18), v80, *((_QWORD *)v8 + 12), v80, v83, v80);
    v8[38] = 1;
  }
  else
  {
    bzero(&v86->f32[v8[48] * v80], v82);
    if (v8[6] == 1 && v10)
    {
      v43 = 0;
      v44 = v10;
      do
      {
        memcpy(&v86->f32[v43], *((const void **)v8 + 13), 4 * v85);
        v43 += v80;
        --v44;
      }
      while (v44);
    }
    gemm_v2((uint64_t)v7, 0, v10, v80, v80, (uint64_t)v89, v80, *((_QWORD *)v8 + 10), v80, (float32x4_t *)((char *)v86 + 4 * v8[48] * v80), v80);
  }
  v37 = v84;
LABEL_42:
  v45 = (v37 + 1);
  v87 = &v34[4 * v91];
  if ((_DWORD)v37 == -1)
  {
    v46 = v80;
    v47 = v85 == -1;
  }
  else
  {
    v48 = 0;
    do
    {
      bzero(&v34[4 * v48], 4 * padded_len * v10);
      v48 += v91;
      --v45;
    }
    while (v45);
    v47 = v85 / v37;
    v46 = v80;
  }
  v49 = 0;
  v50 = 0;
  v51 = v37;
  v94 = v47;
  do
  {
    gemm_v2(v92, 1, v10, v21, v94, (uint64_t)v81->i64 + 4 * v49, v46, (uint64_t)v86->i64 + 4 * v49, v46, (float32x4_t *)&v34[4 * v50], padded_len);
    v50 += v91;
    v49 += v94;
    --v51;
  }
  while (v51);
  v52 = 0;
  v53 = 0;
  v54 = 1.0 / sqrt((double)v94);
  v55 = v84;
  do
  {
    if ((_DWORD)padded_len)
    {
      v56 = 0;
      v57 = v52;
      do
      {
        if (v21)
        {
          v58 = v21;
          v59 = v57;
          do
          {
            *(float *)&v34[4 * v59] = *(float *)&v34[4 * v59] * v54;
            ++v59;
            --v58;
          }
          while (v58);
        }
        ++v56;
        v57 += v10;
      }
      while (v56 != (_DWORD)padded_len);
    }
    ++v53;
    v52 += v91;
  }
  while (v53 != (_DWORD)v84);
  v60 = v84 - 1;
  if ((int)v84 - 1 >= 0)
  {
    do
    {
      if (v10)
      {
        v61 = 0;
        v62 = v10;
        do
        {
          softmax((float *)&v34[4 * v60 * v91 + 4 * v61], v21, 1, (float *)&v87[4 * v60 * v91 + 4 * v61], *((float *)v8 + 8));
          v61 += padded_len;
          --v62;
        }
        while (v62);
      }
      v63 = __OFSUB__(v60--, 1);
    }
    while (v60 < 0 == v63);
    v46 = v80;
    v55 = v84;
  }
  if (v79)
  {
    v64 = v46;
    v65 = v89;
  }
  else
  {
    v66 = v83;
    if (!v8[2])
      v66 = v81;
    bzero(&v66->f32[v8[48] * v46], v82);
    if (v8[6] == 1 && v10)
    {
      v67 = 0;
      v68 = v10;
      do
      {
        memcpy(&v66->f32[v67], *((const void **)v8 + 15), 4 * v85);
        v67 += v46;
        --v68;
      }
      while (v68);
    }
    v83 = v66;
    v76 = (float32x4_t *)((char *)v66 + 4 * v8[48] * v46);
    v65 = v89;
    v64 = v46;
    gemm_v2(v92, 0, v10, v46, v46, (uint64_t)v89, v46, *((_QWORD *)v8 + 12), v46, v76, v46);
    v55 = v84;
  }
  bzero(v65, v82);
  v69 = v94;
  v70 = 0;
  v71 = 0;
  do
  {
    gemm_v2(v92, 0, v10, v69, v21, (uint64_t)&v87[4 * v70], padded_len, (uint64_t)v83->i64 + 4 * v71, v64, (float32x4_t *)((char *)v89 + 4 * v71), v64);
    v69 = v94;
    v71 += v94;
    v70 += v91;
    --v55;
  }
  while (v55);
  memcpy(v81, __src, v82);
  gemm_v2(v92, 0, v10, v64, v64, (uint64_t)v89, v64, *((_QWORD *)v8 + 17), v64, v81, v64);
  bzero(v89, v82);
  if (v10)
  {
    v72 = 0;
    v73 = v10;
    do
    {
      memcpy(&v89->f32[v72], *((const void **)v8 + 16), 4 * v64);
      v72 += v64;
      --v73;
    }
    while (v73);
  }
  if (v8[6] == 1)
    axpy(v78, v89->f32, 1, v81->f32, 1, 1.0);
  v24 = 0;
  ++v8[48];
  return v24;
}

__n128 att_albert_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  const char *v10;
  __n128 result;
  uint64_t v13;
  __n128 *v14;
  __int128 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;

  v8 = *(uint64_t **)a1;
  if (*a2 >= 3u)
  {
    v9 = *v8;
    v10 = "Currently att layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, a6, a7, a8, v18);
    return result;
  }
  v13 = *(_QWORD *)(a1 + 120);
  v14 = (__n128 *)(a1 + 20);
  v15 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v15;
  if (*(_DWORD *)(v13 + 28) != 1 || !(*(unsigned int (**)(void))(*(_QWORD *)(v13 + 72) + 144))())
  {
    if (*(_DWORD *)(v13 + 20) == 1)
    {
      *(_DWORD *)(v13 + 36) = 2;
      v16 = *(_DWORD *)(v13 + 28);
      if (!*(_QWORD *)(v13 + 72))
      {
        if (v16 == 1)
        {
          v9 = *v8;
          v10 = "Must set external pointers before shape update for enc_dec att.";
          goto LABEL_3;
        }
LABEL_13:
        result = *v14;
        *(__n128 *)(a1 + 40) = *v14;
        *(_DWORD *)(a1 + 56) = v14[1].n128_u32[0];
        return result;
      }
    }
    else
    {
      v16 = *(_DWORD *)(v13 + 28);
    }
    if (v16 == 1)
    {
      v17 = *(_QWORD *)(v13 + 72);
      result = *(__n128 *)(v17 + 40);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v17 + 56);
      *(__n128 *)(a1 + 40) = result;
      return result;
    }
    goto LABEL_13;
  }
  return result;
}

uint64_t att_albert_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v6;
  uint64_t result;
  int padded_bytes;
  uint64_t padded_len;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(unsigned int **)(a1 + 120);
  if (v6[7] != 1 || (result = (*(uint64_t (**)(void))(*((_QWORD *)v6 + 9) + 152))(), !(_DWORD)result))
  {
    padded_bytes = get_padded_bytes(0, 8u);
    padded_len = get_padded_len(*v6, 8u);
    *a2 = padded_bytes + 16 * (padded_len + padded_len * padded_len);
    *a3 = 0;
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"att k kernel size: %d\n", v10, v11, v12, padded_len);
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
    return 0;
  }
  return result;
}

uint64_t att_albert_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  int v3;
  int *v4;
  unsigned int step;
  uint64_t v6;
  uint64_t result;
  int padded_len;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  int padded_bytes;
  uint64_t v17;
  unsigned int v18;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = v2[1];
  v4 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v6 = v2[3];
  v18 = 0;
  result = fi_shape_get_input_dim(v4, (int *)&v18);
  if (!(_DWORD)result)
  {
    padded_len = get_padded_len(v18, 8u);
    if (v18 != *v2)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att input sample dim mismatch! inshape: %d, but config: %d";
      v17 = v18;
      goto LABEL_6;
    }
    if (step > v6)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att: input len longer than maximum!";
LABEL_6:
      log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, v9, v10, v11, v17);
      return 7;
    }
    v14 = (padded_len * (_DWORD)v6) << (v2[2] == 0);
    v15 = get_padded_len(v6, 8u);
    padded_bytes = get_padded_bytes(4 * (v14 + ((int)v6 + (int)v6 * v3) * v15), 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes;
  }
  return result;
}

uint64_t att_albert_dispatch_weights(uint64_t a1)
{
  unsigned int *v2;
  int padded_len;
  unsigned int padded_bytes;
  uint64_t v5;
  uint64_t result;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;

  v15 = 0;
  v2 = *(unsigned int **)(a1 + 120);
  padded_len = get_padded_len(*v2, 8u);
  padded_bytes = 0;
  v5 = *(_QWORD *)(a1 + 72);
  if (v2[7] == 1)
  {
    result = fi_layer_find_weights_via_offset(*((_QWORD *)v2 + 9), v5, &v15);
    if ((_DWORD)result)
      return result;
    padded_bytes = get_padded_bytes(v15, 8u);
  }
  *((_QWORD *)v2 + 11) = v5 + padded_bytes;
  v7 = 4 * padded_len * padded_len;
  v15 = padded_bytes + v7;
  v8 = get_padded_bytes(padded_bytes + v7, 8u);
  *((_QWORD *)v2 + 14) = v5 + v8;
  v15 = v8 + 4 * padded_len;
  v9 = get_padded_bytes(v15, 8u);
  *((_QWORD *)v2 + 10) = v5 + v9;
  v15 = v9 + v7;
  v10 = get_padded_bytes(v9 + v7, 8u);
  *((_QWORD *)v2 + 13) = v5 + v10;
  v15 = v10 + 4 * padded_len;
  v11 = get_padded_bytes(v15, 8u);
  *((_QWORD *)v2 + 12) = v5 + v11;
  v15 = v11 + v7;
  v12 = get_padded_bytes(v11 + v7, 8u);
  *((_QWORD *)v2 + 15) = v5 + v12;
  v15 = v12 + 4 * padded_len;
  v13 = get_padded_bytes(v15, 8u);
  *((_QWORD *)v2 + 17) = v5 + v13;
  v15 = v13 + v7;
  v14 = get_padded_bytes(v13 + v7, 8u);
  *((_QWORD *)v2 + 16) = v5 + v14;
  get_padded_bytes(v14 + 4 * padded_len, 8u);
  return 0;
}

uint64_t att_albert_layer_reset(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 120);
    if (*(_DWORD *)(v1 + 20) == 1)
    {
      *(_QWORD *)(v1 + 144) = 0;
      *(_DWORD *)(v1 + 152) = 0;
      *(_OWORD *)(v1 + 160) = 0u;
      *(_OWORD *)(v1 + 176) = 0u;
    }
  }
  return 0;
}

uint64_t forward_convtrans1d_layer(uint64_t a1, uint64_t a2, float *a3, float32x4_t *a4, uint64_t a5)
{
  _DWORD *v8;
  char *v9;
  uint64_t v10;
  unsigned int v11;
  _BOOL4 is_enabled;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  _BOOL4 v18;
  char *v19;
  uint64_t result;
  unsigned int step;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  _DWORD *v27;
  uint64_t v28;
  const char *v29;
  int v30;
  float *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t *v39;
  _OWORD v40[2];
  uint64_t v41;

  v39 = *(uint64_t **)a2;
  v8 = *(_DWORD **)(a2 + 120);
  v9 = *(char **)(a2 + 72);
  v41 = 0;
  v10 = v8[4];
  v11 = v8[5];
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 4u, *(_DWORD *)(a2 + 264));
  v13 = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 7u, *(_DWORD *)(a2 + 264));
  memset(v40, 0, sizeof(v40));
  v17 = *(const void **)(a2 + 104);
  v18 = is_enabled || v13;
  if ((is_enabled || v13) && v9)
  {
    v19 = &v9[4 * *(unsigned int *)v9];
  }
  else
  {
    v19 = v9;
    if (!v9)
    {
      v28 = **(_QWORD **)a2;
      v29 = "convtrans1d weight not found";
LABEL_18:
      log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v14, v15, v16, v33);
      return 7;
    }
  }
  result = fi_shape_get_size((int *)(a2 + 40), (int *)&v41);
  if ((_DWORD)result)
    return result;
  v37 = v11;
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  if (!step)
  {
    v28 = **(_QWORD **)a2;
    v29 = "steps must > 0, but it is: %d";
    v33 = 0;
    goto LABEL_18;
  }
  v36 = step;
  result = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v41 + 1);
  if ((_DWORD)result)
    return result;
  if (v36 >= 2)
  {
    v22 = HIDWORD(v41);
    if (get_padded_len(HIDWORD(v41), 8u) != v22)
    {
      v28 = *v39;
      v29 = "If code reaches here, then there is possibility that GEMM in convtrans1d is incorrect!";
      goto LABEL_18;
    }
  }
  v34 = v19;
  v35 = a5;
  if (v8[6] == 1)
  {
    v23 = v37 + v37 * v36;
    if ((_DWORD)v23)
    {
      v24 = 0;
      do
      {
        memcpy(&a4->f32[v24], v17, 4 * v10);
        v24 += v10;
        --v23;
      }
      while (v23);
    }
  }
  if (v18)
  {
    v25 = v35;
    v26 = v37;
    DWORD2(v40[0]) = ((*((_DWORD *)v9 + 1) >> 1) & 1) == 0;
    v27 = v40;
  }
  else
  {
    v27 = 0;
    v25 = v35;
    v26 = v37;
  }
  v30 = HIDWORD(v41);
  if (v30 == get_padded_len(HIDWORD(v41), 8u))
    v31 = a3;
  else
    v31 = 0;
  gemm_ex(v39, v36, *v8 * v10, v8[1], v31, v8[1], v34, v8[1], a4, (*v8 * v10) >> 1, v27);
  v32 = v41 - v26 * (_DWORD)v10;
  memmove(a4, &a4->f32[(v26 >> 1) * v10], 4 * v32);
  fi_activate_array(a4->f32, v32, v8[8]);
  result = 0;
  *(_DWORD *)(a2 + 44) = v36 * v26;
  *(_DWORD *)(v25 + 20) = 1;
  return result;
}

_QWORD *free_convtrans1d_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_convtrans1d_layer(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t result;
  uint64_t v16;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64)) != 0)
  {
    *(_QWORD *)(v11 + 120) = v12;
    *(_QWORD *)v11 = a1;
    v13 = *a2;
    v14 = a2[1];
    *(_DWORD *)(v12 + 32) = *((_DWORD *)a2 + 8);
    *(_OWORD *)v12 = v13;
    *(_OWORD *)(v12 + 16) = v14;
    *(_QWORD *)(v11 + 8) = 69;
    *(_QWORD *)(v11 + 144) = convtrans1d_layer_update_shape;
    *(_QWORD *)(v11 + 152) = conv_layer_wanted_wb_len;
    *(_QWORD *)(v11 + 128) = forward_convtrans1d_layer;
    *(_QWORD *)(v11 + 136) = free_convtrans1d_layer;
    if (a3)
    {
      result = 0;
      *(_QWORD *)(v11 + 256) = *(_QWORD *)(a3 + 24);
      *(_DWORD *)(v11 + 264) = *(_DWORD *)(a3 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v8, v9, v10, v16);
      result = 0;
      *(_QWORD *)(v11 + 256) = 0;
      *(_DWORD *)(v11 + 264) = 0;
    }
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v16);
    free_convtrans1d_layer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t convtrans1d_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _DWORD *v10;
  int v11;
  uint64_t vars0;

  if (*(_DWORD *)a2 == 2)
  {
    result = 0;
    v10 = *(_DWORD **)(a1 + 120);
    v11 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v11;
    v10[1] = *(_DWORD *)(a2 + 8);
    v10[3] = 1;
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = *v10 - v10[5] + *(_DWORD *)(a2 + 4) * v10[5];
    *(_DWORD *)(a1 + 48) = v10[4];
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"convtrans1d requires input 2D input data", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t create_rnn_layer(uint64_t *a1, uint64_t *a2, uint64_t *a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;

  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v13)
    goto LABEL_10;
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v14)
    goto LABEL_10;
  v15 = (_QWORD *)v14;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 32);
  if (!v16)
    goto LABEL_10;
  v17 = v16;
  *(_QWORD *)v13 = a1;
  v18 = *a2;
  v19 = *((unsigned int *)a2 + 1);
  *(_DWORD *)(v13 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)(v13 + 8) = v18;
  if (a4)
    *(_QWORD *)(v13 + 60) = *a4;
  v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v19, 4);
  *v15 = v20;
  if (v20
    && (v15[1] = v17,
        v21 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], *((unsigned int *)a2 + 1), 4),
        (*(_QWORD *)(v17 + 16) = v21) != 0)
    && (v22 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], *((unsigned int *)a2 + 1), 4),
        (*(_QWORD *)(v17 + 24) = v22) != 0))
  {
    result = 0;
    v24 = *a3;
    *(_DWORD *)(v17 + 8) = *((_DWORD *)a3 + 2);
    *(_QWORD *)v17 = v24;
    *(_QWORD *)(v13 + 120) = v15;
    *(_QWORD *)(v13 + 128) = forward_rnn_layer;
    *(_QWORD *)(v13 + 136) = free_rnn_buffer;
    *(_QWORD *)(v13 + 144) = rnn_layer_update_shape;
    *(_QWORD *)(v13 + 152) = rnn_layer_wanted_wb_len;
    *a5 = v13;
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v25);
    *a5 = v13;
    free_rnn_buffer((_QWORD *)v13);
    return 10;
  }
  return result;
}

uint64_t forward_rnn_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  void **v8;
  void *v9;
  void *v10;
  int v11;
  int v12;
  float32x4_t *v13;
  float32x4_t *v14;
  _DWORD *v15;
  uint64_t result;
  uint64_t padded_len;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  void *v25;
  int v26;
  unsigned int v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  void *__dst;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  void *v39;
  char *v40;
  int v41;
  int step;
  unsigned int v43;

  v7 = *(uint64_t **)a2;
  v8 = *(void ***)(a2 + 120);
  v10 = *v8;
  v9 = v8[1];
  v12 = *(_DWORD *)v9;
  v11 = *((_DWORD *)v9 + 1);
  v41 = *((_DWORD *)v9 + 2);
  v13 = (float32x4_t *)*((_QWORD *)v9 + 2);
  v14 = (float32x4_t *)*((_QWORD *)v9 + 3);
  v43 = 0;
  v15 = (_DWORD *)(a2 + 20);
  result = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v43);
  if (!(_DWORD)result)
  {
    v31 = v7;
    v37 = v12;
    v38 = v11;
    v39 = v10;
    padded_len = get_padded_len(v43, 8u);
    v18 = *(unsigned int *)(a2 + 12);
    v19 = get_padded_len(v18, 8u);
    v40 = *(char **)(a2 + 72);
    if (!v41)
      bzero(v39, 4 * v18);
    step = fi_shape_get_step(v15);
    if (v43 == (_DWORD)padded_len)
    {
      __dst = 0;
    }
    else
    {
      __dst = (void *)(*(uint64_t (**)(uint64_t, uint64_t))v7[1])(v7[2], 4 * padded_len);
      if (!__dst)
      {
        log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"empty new input memory!", v20, v21, v22, v29);
        return 10;
      }
    }
    v36 = a4;
    if (step)
    {
      v23 = 0;
      v24 = 0;
      v33 = &v40[4 * (v18 * padded_len)];
      v34 = padded_len;
      v35 = a3;
      do
      {
        v25 = (void *)(a3 + 4 * v43 * v24);
        if (v43 == (_DWORD)padded_len)
        {
          v26 = v38;
        }
        else
        {
          v26 = v38;
          if (!__dst)
          {
            log_OutText(*v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)"empty new input memory!", v20, v21, v22, v29);
            return 0;
          }
          memcpy(__dst, v25, 4 * v43);
          v25 = __dst;
          padded_len = v43;
        }
        if (v26 == 1)
          v27 = v23;
        else
          v27 = 0;
        v28 = (void *)(v36 + 4 * v27);
        bzero(v13, 4 * v18);
        bzero(v14, 4 * v18);
        gemm(*(uint64_t **)a2, 1, v18, padded_len, (float *)v25, v40, v13, 0, v29);
        gemm(*(uint64_t **)a2, 1, v18, v18, (float *)v39, v33, v14, 0, v30);
        axpy(v18, v13->f32, 1, v14->f32, 1, 1.0);
        axpy(v18, (float *)&v33[4 * (v19 * v18)], 1, v14->f32, 1, 1.0);
        fi_activate_array(v14->f32, v18, v37);
        memcpy(v39, v14, 4 * v18);
        memcpy(v28, v14, 4 * v18);
        ++v24;
        v23 += v18;
        padded_len = v34;
        a3 = v35;
      }
      while (step != v24);
    }
    if (__dst)
      (*(void (**)(uint64_t))(v31[1] + 48))(v31[2]);
    return 0;
  }
  return result;
}

_QWORD *free_rnn_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = v3[1];
        if (v4)
        {
          if (*(_QWORD *)(v4 + 16))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 16) = 0;
          }
          if (*(_QWORD *)(v4 + 24))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 24) = 0;
          }
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t rnn_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t vars0;

  if (*(_DWORD *)a2 == 2)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 4);
    v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      v10 = 0;
      *(_DWORD *)(a1 + 40) = *(_DWORD *)a2;
      v11 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      v10 = 0;
      v12 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only 2D RNN is supported", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t rnn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t input_dim;
  int padded_len;
  uint64_t v8;
  unsigned int v10;

  v10 = 0;
  input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v10);
  if (!(_DWORD)input_dim)
  {
    padded_len = get_padded_len(v10, 8u);
    v8 = *(unsigned int *)(a1 + 12);
    *a2 = 4 * v8 * (get_padded_len(v8, 8u) + padded_len);
    *a3 = 4 * v8;
  }
  return input_dim;
}

uint64_t trans_encoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  unsigned int v18;

  v9 = *(unsigned int **)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = *v9;
    result = trans_dec_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      if ((_DWORD)v10)
      {
        v12 = 0;
        v13 = v18;
        v14 = 8 * v10;
        do
        {
          v15 = *(_QWORD *)(*((_QWORD *)v9 + 6) + v12);
          *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          v16 = *(void (**)(void))(v15 + 168);
          if (v16)
            v16();
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t create_trans_encoder(uint64_t *a1, unsigned int *a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  const char *v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 88);
      v19 = v15;
      if (!v15)
      {
        v31 = *a1;
        v32 = "out of memory!";
LABEL_20:
        log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v16, v17, v18, v37);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_encoder init param failed!", v34, v35, v36, v38);
        result = 7;
        goto LABEL_21;
      }
      v20 = *(_OWORD *)a2;
      v21 = *((_OWORD *)a2 + 2);
      v15[1] = *((_OWORD *)a2 + 1);
      v15[2] = v21;
      *v15 = v20;
      v22 = *a2;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 8);
      *((_QWORD *)v19 + 6) = v23;
      if (!v23)
      {
        v29 = *a1;
        v30 = "out of memory!";
        goto LABEL_19;
      }
      if ((_DWORD)v22)
      {
        v27 = 0;
        v28 = 8 * v22;
        while (!create_trans_enc_layer(a1, (__int128 *)(a2 + 1), a3, a4, (uint64_t *)(*((_QWORD *)v19 + 6) + v27)))
        {
          v27 += 8;
          if (v28 == v27)
            goto LABEL_10;
        }
        v29 = *a1;
        v30 = "create trans_encoder trans_enc layer failed!";
        goto LABEL_19;
      }
LABEL_10:
      v41 = 0;
      v40 = 40;
      if (create_norm_layer(a1, (uint64_t *)&v40, (uint64_t *)v19 + 7))
      {
        v29 = *a1;
        v30 = "create trans_encoder norm layer failed!";
LABEL_19:
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v24, v25, v26, v37);
        v31 = *a1;
        v32 = "trans_encoder network init failed!";
        goto LABEL_20;
      }
      v33 = a2[10];
      LODWORD(v39) = a2[5];
      HIDWORD(v39) = v33;
      if (create_embedding_layer(a1, &v39, (uint64_t ***)v19 + 9)
        || (LODWORD(v39) = a2[5], HIDWORD(v39) = 32,
                                  create_embedding_layer(a1, &v39, (uint64_t ***)v19 + 8)))
      {
        v29 = *a1;
        v30 = "create trans_encoder target_space_id emb layer failed!";
        goto LABEL_19;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 36;
      *(_QWORD *)(v7 + 128) = forward_trans_encoder;
      *(_QWORD *)(v7 + 136) = free_trans_encoder;
      *(_QWORD *)(v7 + 144) = trans_encoder_update_shape;
      *(_QWORD *)(v7 + 152) = trans_encoder_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_encoder_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_encoder_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_encoder_reset;
      *(_QWORD *)(v7 + 184) = trans_encoder_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v24, v25, v26, v37);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v37);
      result = 10;
    }
  }
LABEL_21:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_encoder(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t bytes;
  uint64_t v17;
  const char *v18;
  uint64_t updated;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  float *v30;
  char *v31;
  int step;
  unsigned int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  float *v43;
  int v44;
  float v45;
  unint64_t v46;
  float *v47;
  float *v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  int v52;
  float v53;
  size_t v54;

  LODWORD(v54) = 0;
  if (!a2)
    return 0;
  if (a5)
    *(_DWORD *)(a5 + 20) = 1;
  v11 = *(uint64_t **)a2;
  v12 = *(unsigned int **)(a2 + 120);
  if (!v12)
  {
    v17 = *v11;
    v18 = "config empty";
    goto LABEL_14;
  }
  v13 = v12[7];
  v14 = 1;
  while (v12[11] != *(float *)(a3 + 4 * (v14 - 1)))
  {
    if (v14++ > v13)
      return 7;
  }
  if (v14 <= 1)
  {
    v17 = *v11;
    v18 = "No input given to encoder.";
LABEL_14:
    log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, a6, a7, a8, v50);
    return 7;
  }
  v51 = *(_OWORD *)(a2 + 20);
  if (v14 < v13)
    v13 = v14;
  v52 = *(_DWORD *)(a2 + 36);
  DWORD1(v51) = v13;
  updated = trans_encoder_update_shape(a2, &v51, a3, (uint64_t)a4, a5, a6, a7, a8);
  if ((_DWORD)updated)
  {
    bytes = updated;
    v21 = *v11;
    v22 = fi_layer_type_to_name(*(_DWORD *)(a2 + 8));
    v26 = "update shape of %s layer failed!";
    v50 = (uint64_t)v22;
    v27 = v21;
  }
  else
  {
    v28 = v12[9];
    v53 = (float)v28;
    v29 = *v12;
    bytes = fi_shape_get_bytes((int *)(*((_QWORD *)v12 + 9) + 40), &v54);
    if ((_DWORD)bytes)
      return bytes;
    v30 = *(float **)(a2 + 240);
    v31 = (char *)v30 + (v54 & 0xFFFFFFFC);
    step = fi_shape_get_step((_DWORD *)(*((_QWORD *)v12 + 9) + 40));
    (*(void (**)(uint64_t))(*((_QWORD *)v12 + 9) + 128))(a1);
    if (step)
    {
      v33 = 0;
      v34 = 0;
      v35 = v12[5];
      do
      {
        if ((_DWORD)v35)
        {
          v36 = *((_QWORD *)v12 + 10);
          v37 = v35;
          v38 = v33;
          do
          {
            *(float *)&v31[4 * v38] = *(float *)(v36 + 4 * v38) + *(float *)&v31[4 * v38];
            ++v38;
            --v37;
          }
          while (v37);
        }
        ++v34;
        v33 += v35;
      }
      while (v34 != step);
    }
    if ((v28 & 0x80000000) == 0)
    {
      (*(void (**)(uint64_t))(*((_QWORD *)v12 + 8) + 128))(a1);
      if (step)
      {
        v39 = 0;
        v40 = 0;
        v41 = v12[5];
        do
        {
          if ((_DWORD)v41)
          {
            v42 = v41;
            v43 = v30;
            v44 = v39;
            do
            {
              v45 = *v43++;
              *(float *)&v31[4 * v44] = v45 + *(float *)&v31[4 * v44];
              ++v44;
              --v42;
            }
            while (v42);
          }
          ++v40;
          v39 += v41;
        }
        while (v40 != step);
      }
    }
    if ((_DWORD)v29)
    {
      v46 = 0;
      if ((v29 & 1) != 0)
        v47 = v30;
      else
        v47 = a4;
      while (1)
      {
        v48 = v47;
        bzero(v47, v54);
        v49 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v12 + 6) + 8 * v46) + 128))(a1);
        if ((_DWORD)v49)
          break;
        if (v48 == a4)
          v47 = v30;
        else
          v47 = a4;
        if (v46 >= (v29 - 1))
          v47 = v48;
        if (v29 == ++v46)
          goto LABEL_47;
      }
      bytes = v49;
      v27 = *v11;
      v26 = "trans_encoder forward trans_enc layer failed!";
    }
    else
    {
LABEL_47:
      bzero(a4, v54);
      bytes = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v12 + 7) + 128))(a1);
      if (!(_DWORD)bytes)
        return bytes;
      v27 = *v11;
      v26 = "trans_encoder forward norm layer failed!";
    }
  }
  log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v50);
  return bytes;
}

_QWORD *free_trans_encoder(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = *(unsigned int *)v3;
        fi_layer_free(v3[7]);
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        if ((_DWORD)v4)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            fi_layer_free(*(_QWORD *)(v3[6] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[6])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v3[6] = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t trans_encoder_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t *v9;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  const char *v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 *v20;
  int v21;
  __int128 v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  int v29;

  v8 = *(unsigned int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v25 = 0;
  if (!v8)
  {
    v13 = *v9;
    v14 = "out of memory!";
    goto LABEL_7;
  }
  v11 = *v8;
  v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 >= 2u)
  {
    v13 = *v9;
    v14 = "Currently trans_encoder layer only support 1D input";
LABEL_7:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v24);
    return 7;
  }
  fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v25);
  if (v25 > v8[7])
  {
    v13 = *v9;
    v14 = "Encoder input shape dimension must be maximum %d. Found %d";
    v24 = v8[7];
    goto LABEL_7;
  }
  result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 9) + 144))();
  if (!(_DWORD)result)
  {
    if ((_DWORD)v11)
    {
      v16 = 0;
      v17 = *((_QWORD *)v8 + 6);
      v18 = 8 * v11;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v17 + v16) + 144))();
        if ((_DWORD)result)
          break;
        v17 = *((_QWORD *)v8 + 6);
        v16 += 8;
        if (v18 == v16)
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 7) + 144))();
      if (!(_DWORD)result)
      {
        v19 = *((_QWORD *)v8 + 7);
        v21 = *(_DWORD *)(v19 + 40);
        v20 = (__int128 *)(v19 + 40);
        if ((v21 - 1) < 2)
        {
          v22 = *v20;
          *(_DWORD *)(a1 + 56) = *((_DWORD *)v20 + 4);
          *(_OWORD *)(a1 + 40) = v22;
          v26 = 0x100000001;
          v23 = v8[5];
          v27 = 32;
          v28 = v23;
          v29 = 4;
          return (*(uint64_t (**)(void))(*((_QWORD *)v8 + 8) + 144))();
        }
        v13 = **(_QWORD **)a1;
        v14 = "dense out: output shape error";
        goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t trans_encoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v12;
  uint64_t v13;
  int padded_bytes;
  uint64_t v15;
  uint64_t result;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = 0;
  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v12 = *v9;
    if ((_DWORD)v12)
    {
      v13 = 0;
      padded_bytes = 0;
      v15 = 8 * v12;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v9 + 6) + v13) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(HIDWORD(v27) + padded_bytes + (int)v27, 8u);
        v13 += 8;
        if (v15 == v13)
          goto LABEL_9;
      }
    }
    else
    {
      padded_bytes = 0;
LABEL_9:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 7) + 152))();
      if (!(_DWORD)result)
      {
        v17 = get_padded_bytes(HIDWORD(v27) + padded_bytes + (int)v27, 8u);
        result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 8) + 152))();
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(HIDWORD(v27) + (int)v27 + v17, 8u);
          result = (*(uint64_t (**)(_QWORD, char *, uint64_t *))(*((_QWORD *)v9 + 8) + 152))(*((_QWORD *)v9 + 9), (char *)&v27 + 4, &v27);
          if (!(_DWORD)result)
          {
            v19 = get_padded_bytes(HIDWORD(v27) + (int)v27 + v18, 8u);
            *a2 = get_padded_bytes(v19 + 4 * v9[7] * v9[5], 8u);
            *a3 = 0;
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v20, v21, v22, *(unsigned int *)(a1 + 96));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v23, v24, v25, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v26);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  uint64_t result;
  int padded_bytes;
  uint64_t v19;
  unsigned int v20;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = *((_QWORD *)v9 + 6);
      v15 = 8 * v10;
      do
      {
        v16 = *(uint64_t (**)(void))(*(_QWORD *)(v14 + v11) + 160);
        if (v16)
        {
          result = v16();
          if ((_DWORD)result)
            return result;
          v14 = *((_QWORD *)v9 + 6);
          v13 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
          if (v13 > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      v13 = 0;
      v12 = 0;
    }
    v20 = v13;
    result = trans_dec_get_reserved_glbBuf_bytes(a1, &v20);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(v20 + v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v19);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int padded_bytes;

  v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    *((_QWORD *)v8 + 10) = v9;
    padded_bytes = get_padded_bytes(4 * v8[5] * v8[7], 8u);
    result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 9), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      v11 = *v8;
      if ((_DWORD)v11)
      {
        v12 = 0;
        v13 = 8 * v11;
        while (1)
        {
          v14 = *(_QWORD *)(*((_QWORD *)v8 + 6) + v12);
          if (!v14)
            return 10;
          result = fi_layer_find_weights_via_offset(v14, v9, &padded_bytes);
          if ((_DWORD)result)
            return result;
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          v12 += 8;
          if (v13 == v12)
            goto LABEL_8;
        }
      }
      else
      {
LABEL_8:
        result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 7), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 8), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_reset(uint64_t a1)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(unsigned int **)(a1 + 120);
  v2 = *v1;
  if (!(_DWORD)v2)
    return 0;
  v4 = 0;
  v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(_QWORD *)(*((_QWORD *)v1 + 6) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_encoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

uint64_t get_lstm_step_f(_QWORD *a1, unsigned int a2)
{
  uint64_t result;

  if (a2 > 3)
    return 7;
  result = 0;
  *a1 = off_1EA94A958[a2];
  return result;
}

uint64_t lstm_step_f32_4_small_matrix(uint64_t *a1, float *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, float *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17)
{
  int padded_len;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  char *v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  size_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v43;
  char *v44;
  float *v45;
  char *v46;
  char *v47;
  float *v48;
  char *v49;
  float *v50;
  char *v52;

  padded_len = get_padded_len(a4, 8u);
  v21 = get_padded_len(a5, 8u);
  v22 = v21;
  if (a16[1] == 1 && !*a16)
    v23 = v21;
  else
    v23 = a5;
  v24 = (char *)(a14 + 4 * a15);
  v25 = (char *)(a8 + 4 * a15);
  if (a16[2])
    v26 = padded_len * a5;
  else
    v26 = v21 * a4;
  v27 = v26 + a15;
  v43 = &v25[4 * v27];
  v28 = a15 + v21 * a5;
  v49 = &v25[12 * v27];
  v44 = &v24[4 * v28];
  v46 = &v25[8 * v27];
  v47 = &v24[8 * v28];
  v45 = &a9[v23];
  v48 = &a9[2 * v23];
  v50 = &a9[3 * v23];
  v52 = &v24[12 * v28];
  bzero(a7, 16 * v21);
  v29 = (float32x4_t *)((char *)a7 + 4 * v22);
  v30 = (float32x4_t *)((char *)a7 + 8 * v22);
  v31 = (float32x4_t *)((char *)a7 + 12 * v22);
  gemm(a1, 1, a5, a4, a2, v25, a7, a16, v34);
  gemm(a1, 1, a5, a5, a10, v24, v30, a17, v35);
  axpy(a5, a9, 1, a7->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, a7->f32, 1, 1.0);
  fi_activate_array(a7->f32, a5, a13);
  gemm(a1, 1, a5, a4, a2, v43, v31, a16, v36);
  bzero(v30, 4 * a5);
  gemm(a1, 1, a5, a5, a10, v44, v30, a17, v37);
  axpy(a5, v45, 1, v31->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, v31->f32, 1, 1.0);
  fi_activate_array(v31->f32, a5, a13);
  gemm(a1, 1, a5, a4, a2, v46, v29, a16, v38);
  v32 = 4 * a5;
  bzero(v30, v32);
  gemm(a1, 1, a5, a5, a10, v47, v30, a17, v39);
  axpy(a5, v48, 1, v29->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, v29->f32, 1, 1.0);
  fi_activate_array(v29->f32, a5, a12);
  xmy(a5, a11, 1, v31->f32, 1);
  xmy(a5, a7->f32, 1, v29->f32, 1);
  axpy(a5, v31->f32, 1, v29->f32, 1, 1.0);
  bzero(v30, v32);
  gemm(a1, 1, a5, a4, a2, v49, v30, a16, v40);
  bzero(v31, v32);
  gemm(a1, 1, a5, a5, a10, v52, v31, a17, v41);
  axpy(a5, v50, 1, v30->f32, 1, 1.0);
  axpy(a5, v31->f32, 1, v30->f32, 1, 1.0);
  fi_activate_array(v30->f32, a5, a13);
  memcpy(a11, v29, v32);
  fi_activate_array(v29->f32, a5, a12);
  xmy(a5, v30->f32, 1, v29->f32, 1);
  memcpy(a10, v29, v32);
  memcpy(a3, v29, v32);
  return 0;
}

uint64_t lstm_step_f32_1_big_matrix_x_4h(uint64_t *a1, float *a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17)
{
  char *v20;
  int padded_len;
  float32_t *v22;
  float32_t *v23;
  float32_t *v24;
  uint64_t v26;
  uint64_t v27;

  v20 = (char *)(a8 + 4 * a15);
  padded_len = get_padded_len(a5, 8u);
  memcpy(a7, a9, 4 * (4 * a5));
  bzero(&a7->f32[4 * padded_len], 4 * (4 * padded_len));
  gemm(a1, 1, 4 * a5, a4, a2, v20, a7, a16, v26);
  gemm(a1, 1, 4 * a5, a5, a10, (char *)(a14 + 4 * a15), a7, a17, v27);
  v22 = &a7->f32[padded_len];
  memmove(v22, &a7->f32[a5], 4 * (3 * a5));
  v23 = &a7->f32[2 * padded_len];
  memmove(v23, &v22[a5], 4 * (2 * a5));
  v24 = &a7->f32[3 * padded_len];
  memmove(v24, &v23[a5], 4 * a5);
  fi_activate_array(a7->f32, a5, a13);
  fi_activate_array(v22, a5, a13);
  fi_activate_array(v23, a5, a12);
  fi_activate_array(v24, a5, a13);
  xmy(a5, a11, 1, v22, 1);
  xmy(a5, a7->f32, 1, v23, 1);
  axpy(a5, v22, 1, v23, 1, 1.0);
  memcpy(a11, v23, 4 * a5);
  fi_activate_array(v23, a5, a12);
  xmy(a5, v24, 1, v23, 1);
  memcpy(a10, v23, 4 * a5);
  memcpy(a3, v23, 4 * a5);
  return 0;
}

uint64_t lstm_step_f32_svd(uint64_t *a1, float *a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, char *a8, const void *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, uint64_t a15, _DWORD *a16, _DWORD *a17)
{
  int padded_len;
  unsigned int v24;
  char *v25;
  float32x4_t *v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  uint64_t v30;
  float *v31;
  float *v32;
  float *v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  padded_len = get_padded_len(a4, 8u);
  v24 = get_padded_len(a5, 8u);
  v25 = &a8[4 * (padded_len * a6)];
  bzero(a7, 32 * v24);
  v26 = &a7[v24];
  gemm(a1, 1, a6, a4, a2, a8, a7, a16, v35);
  gemm(a1, 1, a6, a5, a10, v25, v26, a17, v36);
  axpy(a6, v26->f32, 1, a7->f32, 1, 1.0);
  memcpy(v26, a9, 4 * (4 * a5));
  gemm(a1, 1, 4 * a5, a6, a7->f32, &v25[4 * v24 * a6], v26, a17, v37);
  if (v24 == (_DWORD)a5)
  {
    v27 = v24;
    v28 = 2 * v24;
    v29 = 4 * a5;
    v30 = 3 * v24;
  }
  else
  {
    v30 = 3 * v24;
    v29 = 4 * a5;
    memmove(&v26->f32[v30], &v26->f32[(3 * a5)], v29);
    v28 = 2 * v24;
    memmove(&v26->f32[v28], &v26->f32[(2 * a5)], v29);
    v27 = v24;
    memmove(&v26->f32[v24], (char *)v26 + v29, v29);
  }
  v31 = &v26->f32[v27];
  v32 = &v26->f32[v28];
  v33 = &v26->f32[v30];
  fi_activate_array(v26->f32, a5, a13);
  fi_activate_array(v31, a5, a13);
  fi_activate_array(v32, a5, a12);
  fi_activate_array(v33, a5, a13);
  fi_multiply_multiply_add_ansic(a11, v31, v26->f32, v32, a3, a5);
  memcpy(a11, a3, v29);
  fi_activate_array(a3, a5, a12);
  xmy(a5, v33, 1, a3, 1);
  memcpy(a10, a3, v29);
  return 0;
}

uint64_t lstm_step_f32_1_big_matrix_x_4h_peephole(uint64_t *a1, float *a2, float *a3, unsigned int a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17, int a18)
{
  uint64_t v19;
  float *v21;
  float *v22;
  unsigned int padded_len;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  float *v28;
  float *v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v37;
  char *v38;
  int v40;
  char *v41;
  uint64_t v43;

  v19 = a5;
  v21 = a11;
  v22 = a10;
  v38 = (char *)(a8 + 4 * a15);
  v41 = (char *)(a14 + 4 * a15);
  padded_len = get_padded_len(a5, 8u);
  v40 = get_padded_len((4 * v19), 8u);
  v24 = a1;
  memcpy(a7, a9, 16 * padded_len);
  bzero(&a7[padded_len], 16 * padded_len);
  gemm(a1, 1, 4 * v19, a4, a2, v38, a7, a16, (uint64_t)a1);
  if (a18 == 1)
    gemm(v24, 1, 4 * v19, v19, a10, v41, a7, a17, v37);
  v25 = padded_len;
  if (padded_len == (_DWORD)v19)
  {
    v43 = 2 * padded_len;
    v26 = 3 * padded_len;
  }
  else
  {
    memmove(&a7->f32[padded_len], &a7->f32[v19], 4 * (3 * v19));
    v43 = 2 * padded_len;
    memmove(&a7->f32[v43], &a7->f32[padded_len + v19], 4 * (2 * v19));
    v26 = 3 * padded_len;
    memmove(&a7->f32[v26], &a7->f32[v43 + v19], 4 * v19);
  }
  v27 = (float *)&v41[4 * (v40 * v19)];
  fi_multiply_add_ansic(a7->f32, a11, v27, v19);
  v28 = &a7->f32[v25];
  fi_multiply_add_ansic(v28, a11, &v27[v25], v19);
  v29 = &a7->f32[v43];
  v30 = &a7->f32[v26];
  fi_activate_array(a7->f32, v19, a13);
  fi_activate_array(v28, v19, a13);
  fi_activate_array(v29, v19, a12);
  fi_multiply_multiply_add_ansic(a11, v28, a7->f32, v29, a11, v19);
  fi_multiply_add_ansic(v30, a11, &v27[v43], v19);
  fi_activate_array(v30, v19, a13);
  if ((_DWORD)v19)
  {
    v19 = v19;
    do
    {
      v31 = *v30++;
      v32 = v31;
      v33 = *v21++;
      v34 = v32 * tanhf(v33);
      *v22++ = v34;
      *a3++ = v34;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t gru_layer_wanted_wb_len(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t is_enabled;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  BOOL v12;
  uint64_t *v13;
  uint64_t v14;
  const char *v15;
  uint64_t *v16;
  int *v17;
  int v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t *v28;
  int padded_len;
  int v30;
  int v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t mat_length;
  int v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  int v56;
  int v57;
  unsigned int v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;

  v71 = 0;
  is_enabled = fi_feat_is_enabled((uint64_t)a1[32], 4u, *((_DWORD *)a1 + 66));
  v7 = fi_feat_is_enabled((uint64_t)a1[32], 7u, *((_DWORD *)a1 + 66));
  v11 = (is_enabled | v7) != 0;
  if (is_enabled | v7)
    v12 = ((_DWORD)a1[2] & 0xFFFFFFFD) == 1;
  else
    v12 = 0;
  if (!v12 || (v13 = a1[9]) != 0 && (*((_BYTE *)v13 + 4) & 2) != 0)
  {
    v16 = a1[15];
    if (!v16)
      return 7;
    v17 = (int *)v16[1];
    if (!v17)
      return 7;
    v18 = *v17;
    result = fi_shape_get_input_dim((int *)a1 + 5, (int *)&v71);
    if ((_DWORD)result)
      return result;
    v20 = *((unsigned int *)a1 + 3);
    if (v18 == 2)
    {
      v28 = a1[9];
      v21 = v71;
      v22 = **a1;
      if (v28 && (*((_BYTE *)v28 + 4) & 2) != 0)
      {
        v51 = get_padded_len(*((unsigned int *)a1 + 3), 8u) * v21;
        *a2 = ((3 * (v51 + get_padded_len(v20, 8u) * (_DWORD)v20)) << (~(*((_DWORD *)v28 + 1) >> 2) & 2))
            + 24 * *(_DWORD *)v28;
        *a3 = 12 * get_padded_len(v20, 8u);
        get_padded_len(v21, 8u);
        get_padded_len(v20, 8u);
        v55 = "basic reset-after GRU impl (rowMajor): x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=(3 * padded_h * x + 3 "
              "* padded_h * h) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*6=%u, bBytes=3 * padded_h * sizeof"
              "(f32)=%u, wBytes+bBytes=%u";
      }
      else
      {
        padded_len = get_padded_len(v71, 8u);
        v30 = 3 * v20 * (get_padded_len(v20, 8u) + padded_len);
        LOBYTE(v31) = 2;
        if (v28)
        {
          v31 = ~(*((_DWORD *)v28 + 1) >> 2) & 2;
          v32 = 24 * *(_DWORD *)v28;
        }
        else
        {
          v32 = 0;
        }
        *a2 = (v30 << v31) + v32;
        *a3 = 24 * get_padded_len(v20, 8u);
        get_padded_len(v21, 8u);
        get_padded_len(v20, 8u);
        v55 = "basic reset-after GRU impl (colMajor):x=%u, h=%u, padded_x=%u, padded_h=%u,wBytes=(3 * PAD(x) * h + 3 * PA"
              "D(h) * h) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*6=%u, bBytes=3*PAD(h)*sizeof(f32)*2=%u, "
              "wBytes+bBytes=%u";
      }
      goto LABEL_49;
    }
    if (v18 != 1)
    {
      if (v18)
      {
        if ((v18 - 3) <= 1)
          return calc_GRU_IMPL_FAST_RESETAFTER_weights_size(v11, (uint64_t)a1[9], v71, *((unsigned int *)a1 + 3), **a1, a2, a3, v10);
        return 7;
      }
      v21 = v71;
      v22 = **a1;
      if ((_DWORD)is_enabled)
      {
        v23 = a1[9];
        if (v23 && (*((_BYTE *)v23 + 4) & 2) != 0)
        {
          v56 = get_padded_len(*((unsigned int *)a1 + 3), 8u) * v21;
          *a2 = ((3 * (v56 + get_padded_len(v20, 8u) * (_DWORD)v20)) << (~(*((_DWORD *)v23 + 1) >> 2) & 2))
              + 24 * *(_DWORD *)v23;
          *a3 = 12 * get_padded_len(v20, 8u);
          get_padded_len(v21, 8u);
          get_padded_len(v20, 8u);
          v55 = "basic GRU impl: x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=4*(3*padded_h*x + 3*padded_h*h)=%u, bBytes="
                "4*3*padded_h=%u, wBytes+bBytes=%u";
LABEL_49:
          log_OutText(v22, (uint64_t)"FastInfer", 4, 0, (uint64_t)v55, v52, v53, v54, v21);
          return 0;
        }
        v24 = get_padded_len(v71, 8u);
        v25 = 3 * v20 * (get_padded_len(v20, 8u) + v24);
        LOBYTE(v26) = 2;
        if (v23)
        {
          v26 = ~(*((_DWORD *)v23 + 1) >> 2) & 2;
          v27 = 24 * *(_DWORD *)v23;
        }
        else
        {
          v27 = 0;
        }
        v50 = (v25 << v26) + v27;
      }
      else
      {
        v49 = get_padded_len(v71, 8u);
        v50 = 12 * v20 * (get_padded_len(v20, 8u) + v49);
      }
      *a2 = v50;
      *a3 = 12 * get_padded_len(v20, 8u);
      get_padded_len(v21, 8u);
      get_padded_len(v20, 8u);
      v55 = "basic GRU impl: x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=4*(3*h*padded_x + 3*h*padded_h)=%u, bBytes=4*3*"
            "padded_h=%u, wBytes+bBytes=%u";
      goto LABEL_49;
    }
    v33 = a1[9];
    v34 = v71;
    v35 = **a1;
    if ((_DWORD)is_enabled && v33)
    {
      is_enabled = *((unsigned int *)v33 + 2);
      if ((_DWORD)is_enabled)
      {
        if ((*((_BYTE *)v33 + 4) & 8) != 0)
        {
          v15 = "Currently not support quantization for block sparse!";
          v14 = **a1;
          goto LABEL_9;
        }
        mat_length = get_mat_length((int *)a1[9]);
        v37 = get_padded_len(mat_length, 8u);
        v38 = get_mat_length((int *)v33);
        v39 = (int *)v33 + get_padded_len(v38, 8u);
        v40 = v39[2];
        *a2 = 4 * (get_mat_length(v39) + v37);
        *a3 = 12 * get_padded_len(v20, 8u);
        v44 = (v34 + v20);
        goto LABEL_55;
      }
    }
    else
    {
      if (!(_DWORD)is_enabled)
      {
        v44 = v71 + v20;
        v59 = get_padded_len(v44, 8u);
        *a2 = 4 * v20 * (get_padded_len(v44, 8u) + 2 * v59);
        v60 = get_padded_len(v20, 8u);
LABEL_54:
        v40 = 0;
        *a3 = 12 * v60;
LABEL_55:
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v41, v42, v43, v20);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_1 : %d\n", v61, v62, v63, is_enabled);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_2 : %d\n", v64, v65, v66, v40);
        get_padded_len(v44, 8u);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"fast GRU impl: x=%u, h=%u, padded_xh=%u, wBytes=(padded_xh*2h + padded_xh*h)=%u, bBytes=3*h=%u, wBytes+bBytes=%u", v67, v68, v69, v34);
        return 0;
      }
      if (!v33)
        goto LABEL_37;
    }
    if ((*((_BYTE *)v33 + 4) & 2) != 0)
    {
      v44 = v71 + v20;
      v57 = get_padded_len((2 * v20), 8u);
      v58 = (((get_padded_len(v20, 8u) + v57) * (_DWORD)v44) << (~(*((_DWORD *)v33 + 1) >> 2) & 2))
          + 8 * *(_DWORD *)v33;
LABEL_53:
      *a2 = v58;
      v60 = get_padded_len(v20, 8u);
      is_enabled = 0;
      goto LABEL_54;
    }
LABEL_37:
    v44 = v71 + v20;
    v45 = get_padded_len(v44, 8u);
    v46 = (get_padded_len(v44, 8u) + 2 * v45) * v20;
    LOBYTE(v47) = 2;
    if (v33)
    {
      v47 = ~(*((_DWORD *)v33 + 1) >> 2) & 2;
      v48 = 8 * *(_DWORD *)v33;
    }
    else
    {
      v48 = 0;
    }
    v58 = (v46 << v47) + v48;
    goto LABEL_53;
  }
  v14 = **a1;
  v15 = "Model desired row-major weights, which mismatch with provided column-major weights";
LABEL_9:
  log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v8, v9, v10, v70);
  return 7;
}

uint64_t calc_GRU_IMPL_FAST_RESETAFTER_weights_size(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t mat_length;
  int padded_len;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;

  if (a1 && a2)
  {
    v14 = *(unsigned int *)(a2 + 8);
    if ((_DWORD)v14)
    {
      if ((*(_BYTE *)(a2 + 4) & 8) != 0)
      {
        log_OutText(a5, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", (uint64_t)a6, (uint64_t)a7, a8, v50);
        return 7;
      }
      mat_length = get_mat_length((int *)a2);
      padded_len = get_padded_len(mat_length, 8u);
      v17 = get_mat_length((int *)a2);
      v18 = a2 + 4 * get_padded_len(v17, 8u);
      v19 = *(unsigned int *)(v18 + 8);
      *a6 = 4 * (get_mat_length((int *)v18) + padded_len);
      v20 = get_padded_len(a4, 8u);
      goto LABEL_15;
    }
LABEL_8:
    v24 = *(_DWORD *)(a2 + 4);
    if ((v24 & 2) != 0)
    {
      v28 = (3 * a4);
      if ((v24 & 8) != 0)
      {
        v35 = get_padded_len(v28, 0x20u) * a3;
        v30 = v35 + get_padded_len((3 * a4), 0x20u) * a4;
      }
      else
      {
        v29 = get_padded_len(v28, 8u) * a3;
        v30 = 4 * (v29 + get_padded_len((3 * a4), 8u) * a4);
      }
      *a6 = v30 + 8 * *(_DWORD *)a2;
      *a7 = 24 * get_padded_len(a4, 8u);
      get_padded_len(a3, 8u);
      get_padded_len(a4, 8u);
      v39 = a3;
      v40 = "fast resetafter GRU impl(rowMajor): x=%u, h=%u, padded_x=%u, padded_h=%u, wBytes=(x*PAD(3*h) + h*PAD(3*h))*s"
            "izeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*2 = %u, bBytes=3*PAD(h)*sizeof(f32)*2 = %u, wBytes+bBytes=%u";
      goto LABEL_23;
    }
    if ((v24 & 8) != 0)
    {
      v33 = get_padded_len(a3, 0x20u);
      v34 = 3 * a4 * (get_padded_len(a4, 0x20u) + v33) + 8 * *(_DWORD *)a2;
LABEL_22:
      *a6 = v34;
      *a7 = 24 * get_padded_len(a4, 8u);
      get_padded_len(a3, 8u);
      get_padded_len(a4, 8u);
      v39 = a3;
      v40 = "fast resetafter GRU impl(colMajor): x=%u, h=%u, padded_x=%u, padded_h=%u, wBytes=(PAD(x) * (3*h) + PAD(h) * "
            "(3*h)) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*2 = %u, bBytes=3*PAD(h)*sizeof(f32)*2 = %u, wBytes+bBytes=%u";
LABEL_23:
      log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)v40, v36, v37, v38, v39);
      v14 = 0;
      v19 = 0;
      goto LABEL_24;
    }
LABEL_10:
    v25 = get_padded_len(a3, 8u);
    v26 = 12 * a4 * (get_padded_len(a4, 8u) + v25);
    if (a2)
      v27 = 8 * *(_DWORD *)a2;
    else
      v27 = 0;
    v34 = v27 + v26;
    goto LABEL_22;
  }
  if (a1)
  {
    if (!a2)
      goto LABEL_10;
    goto LABEL_8;
  }
  v31 = get_padded_len(a3, 8u);
  *a6 = 12 * a4 * (get_padded_len(a4, 8u) + v31);
  v20 = get_padded_len(a4, 8u);
  v14 = 0;
  v19 = 0;
LABEL_15:
  *a7 = 24 * v20;
LABEL_24:
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v21, v22, v23, a4);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_1 : %d\n", v41, v42, v43, v14);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_2 : %d\n", v44, v45, v46, v19);
  get_padded_len(a3, 8u);
  get_padded_len(a4, 8u);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"fast GRU impl: x=%u, h=%u, padded_x=%u, padded_h=%u,wBytes=(padded_x*3h + padded_h*3h)=%u, bBytes=3*padded_h*2=%u, wBytes+bBytes=%u", v47, v48, v49, a3);
  return 0;
}

uint64_t get_gru_glbBufBytes(int a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  int padded_len;
  int v10;
  uint64_t result;
  int v12;
  int v13;

  padded_len = get_padded_len(a2, 8u);
  v10 = get_padded_len(a4, 8u);
  if ((a1 & 0xFFFFFFFD) != 0)
  {
    switch(a1)
    {
      case 4:
        v12 = get_padded_len((3 * a4), 8u);
        padded_len = v12 + v12 * a3;
        v10 = get_padded_len(a4, 8u);
        break;
      case 3:
        v13 = padded_len + 2 * get_padded_len((3 * a4), 8u);
        padded_len = 3 * get_padded_len(a4, 8u);
        goto LABEL_8;
      case 1:
        break;
      default:
        return 7;
    }
  }
  v13 = 3 * v10;
LABEL_8:
  result = 0;
  *a5 = 4 * (v13 + padded_len);
  return result;
}

uint64_t create_gru_layer(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t **a4, uint64_t a5, uint64_t ***a6)
{
  uint64_t **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  int v26;
  uint64_t result;
  uint64_t v28;

  v12 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v16 = v12;
  if (!v12)
    goto LABEL_9;
  *v12 = a1;
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v17)
    goto LABEL_9;
  v18 = (uint64_t *)v17;
  v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v19)
    goto LABEL_9;
  v20 = v19;
  v21 = *a3;
  *(_DWORD *)(v19 + 16) = *((_DWORD *)a3 + 4);
  *(_OWORD *)v19 = v21;
  v22 = *(uint64_t **)a2;
  *((_DWORD *)v16 + 4) = *(_DWORD *)(a2 + 8);
  v16[1] = v22;
  v23 = *(unsigned int *)(a2 + 4);
  if (a4)
    *(uint64_t **)((char *)v16 + 60) = *a4;
  v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v23, 4);
  *v18 = v24;
  if (v24)
  {
    v18[1] = v20;
    v16[20] = (uint64_t *)gru_layer_request_glbBuf;
    v16[15] = v18;
    v16[16] = (uint64_t *)forward_gru_layer;
    v16[17] = (uint64_t *)free_gru_buffer;
    if (a5)
    {
      v25 = *(uint64_t **)(a5 + 24);
      v26 = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v13, v14, v15, v28);
      v25 = 0;
      v26 = 0;
    }
    result = 0;
    v16[32] = v25;
    *((_DWORD *)v16 + 66) = v26;
    v16[18] = (uint64_t *)gru_layer_update_shape;
    v16[19] = (uint64_t *)gru_layer_wanted_wb_len;
    v16[22] = (uint64_t *)gru_layer_reset;
  }
  else
  {
LABEL_9:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v28);
    free_gru_buffer(v16);
    result = 10;
  }
  *a6 = v16;
  return result;
}

uint64_t gru_layer_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;
  int step;
  uint64_t v6;
  int *v7;
  unsigned int v8;

  v2 = *(unsigned int *)(a1 + 12);
  v8 = 0;
  v3 = (_DWORD *)(a1 + 20);
  result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v8);
  if (!(_DWORD)result)
  {
    step = fi_shape_get_step(v3);
    v6 = *(_QWORD *)(a1 + 120);
    if (v6 && (v7 = *(int **)(v6 + 8)) != 0)
      return get_gru_glbBufBytes(*v7, v8, step, v2, (_DWORD *)(a1 + 248));
    else
      return 7;
  }
  return result;
}

uint64_t forward_gru_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  void *v6;
  uint64_t v7;
  _BOOL4 is_enabled;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t input_dim;
  int step;
  uint64_t v18;
  unsigned int *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  void *v37;
  unsigned int v38;

  v5 = *(uint64_t **)a2;
  v6 = *(void **)(a2 + 240);
  v7 = *(_QWORD *)(*(_QWORD *)(a2 + 120) + 8);
  v37 = **(void ***)(a2 + 120);
  v34 = *(_DWORD *)(v7 + 12);
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 7u, *(_DWORD *)(a2 + 264));
  v38 = 0;
  if (!v6)
  {
    log_OutText(*v5, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru buf is NULL, do you forget to set pNet->glbBuf?", v9, v10, v11, v29);
    return 7;
  }
  v12 = *(unsigned int *)(a2 + 12);
  v13 = *(_QWORD *)(a2 + 72);
  if (is_enabled && v13 && (*(_BYTE *)(v13 + 4) & 8) != 0)
    v14 = *(unsigned int *)(a2 + 96);
  else
    v14 = *(_DWORD *)(a2 + 96) & 0xFFFFFFFC;
  v33 = v13 + v14;
  v31 = v5;
  if (!*(_DWORD *)(v7 + 16))
    bzero(v37, 4 * v12);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v38);
  if ((_DWORD)input_dim)
    return input_dim;
  v18 = *(_QWORD *)(a2 + 120);
  if (!v18)
    return 7;
  v19 = *(unsigned int **)(v18 + 8);
  if (!v19)
    return 7;
  if (!step)
    return 0;
  v20 = 0;
  v21 = 0;
  v32 = *v19;
  while (1)
  {
    v22 = v38;
    v23 = a3 + 4 * v38 * v21;
    v24 = v34 == 1 ? v20 : 0;
    v25 = a4 + 4 * v24;
    bzero(v6, *(unsigned int *)(a2 + 248));
    input_dim = gru_step_f32((uint64_t **)a2, v32, v23, v25, v22, v12, (uint64_t)v6, v13, v33, (uint64_t)v37);
    if ((_DWORD)input_dim)
      break;
    ++v21;
    v20 += v12;
    if (step == v21)
      return input_dim;
  }
  log_OutText(*v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru step forward failed!", v26, v27, v28, v30);
  return input_dim;
}

_QWORD *free_gru_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    v3 = (_QWORD *)result[15];
    if (v3)
    {
      if (v3[1])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*v3)
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *v3 = 0;
      }
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      v1[15] = 0;
    }
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
  }
  return result;
}

uint64_t gru_layer_update_shape(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;

  v2 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
  v3 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v3;
  if (v2 == 1)
  {
    *(_DWORD *)(a1 + 40) = 2;
    v4 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 48) = v4;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v5;
  }
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  return 0;
}

uint64_t gru_layer_reset(uint64_t a1)
{
  bzero(**(void ***)(a1 + 120), 4 * *(unsigned int *)(a1 + 12));
  return 0;
}

uint64_t realign_inData(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, _QWORD, uint64_t);
  int padded_len;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  if (a2 < 2)
    return 0;
  if (get_padded_len(a3, 8u) == (_DWORD)a3)
    return 0;
  v11 = a1[2];
  v12 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16);
  padded_len = get_padded_len(a3, 8u);
  v14 = v12(v11, padded_len * a2, 4);
  *a4 = v14;
  if (v14)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      v20 = *a4;
      v21 = get_padded_len(a3, 8u);
      memcpy((void *)(v20 + 4 * (v21 * v19++)), (const void *)(a5 + 4 * v18), 4 * a3);
      v18 += a3;
    }
    while (a2 != v19);
    return 0;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v5);
  return 10;
}

uint64_t gru_step_f32(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v14;

  v10 = *a1;
  if (a2 > 4)
  {
    v11 = 7;
    v12 = "get lstm step forward function failed!";
    goto LABEL_5;
  }
  v14 = a10;
  v11 = ((uint64_t (*)(void))off_1EA94A978[a2])();
  if ((_DWORD)v11)
  {
    v12 = "gru step forward failed!";
LABEL_5:
    log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v14);
  }
  return v11;
}

uint64_t gru_step_f32_basic(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, float *a8, float *a9, int a10, int a11, int a12)
{
  int padded_len;
  unsigned int v19;
  _BOOL4 is_enabled;
  _BOOL4 v21;
  unsigned int v22;
  uint64_t v23;
  int *v24;
  uint64_t mat_length;
  int *v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  unsigned int v43;
  uint64_t v44;
  _DWORD *v45;
  float32x4_t *v46;
  float32x4_t *v47;
  float32_t *v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  _DWORD *v57;
  _DWORD *v58;
  char *v59;
  char *v60;
  _DWORD *v61;
  _DWORD *v62;
  char *v63;
  char *v64;
  char *v65;
  float *v66;
  uint64_t *v68;
  void *__dst;
  _OWORD v71[2];
  _OWORD v72[2];
  _OWORD v73[2];
  _OWORD v74[2];
  _OWORD v75[2];
  _OWORD v76[3];

  v68 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v21 = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
  memset(v76, 0, 32);
  memset(v75, 0, sizeof(v75));
  memset(v74, 0, sizeof(v74));
  memset(v73, 0, sizeof(v73));
  memset(v72, 0, sizeof(v72));
  memset(v71, 0, sizeof(v71));
  __dst = a3;
  if (is_enabled)
  {
    if (a7)
    {
      v23 = *a7;
      v22 = a7[1];
      DWORD1(v76[0]) = v21;
      DWORD2(v76[0]) = ((v22 >> 1) & 1) == 0;
      LODWORD(v76[0]) = v22 & 1;
      v24 = &a7[v23];
      mat_length = get_mat_length(a7);
      v26 = &a7[get_padded_len(mat_length, 8u)];
      v28 = *v26;
      v27 = v26[1];
      DWORD1(v75[0]) = v21;
      DWORD2(v75[0]) = ((v27 >> 1) & 1) == 0;
      LODWORD(v75[0]) = v27 & 1;
      v64 = (char *)&v26[v28];
      v29 = get_mat_length(v26);
      v30 = &v26[get_padded_len(v29, 8u)];
      v32 = *v30;
      v31 = v30[1];
      DWORD1(v74[0]) = v21;
      DWORD2(v74[0]) = ((v31 >> 1) & 1) == 0;
      LODWORD(v74[0]) = v31 & 1;
      v65 = (char *)&v30[v32];
      v33 = get_mat_length(v30);
      v34 = &v30[get_padded_len(v33, 8u)];
      v36 = *v34;
      v35 = v34[1];
      DWORD1(v73[0]) = v21;
      DWORD2(v73[0]) = ((v35 >> 1) & 1) == 0;
      LODWORD(v73[0]) = v35 & 1;
      v59 = (char *)&v34[v36];
      v37 = get_mat_length(v34);
      v38 = &v34[get_padded_len(v37, 8u)];
      v40 = *v38;
      v39 = v38[1];
      DWORD1(v72[0]) = v21;
      DWORD2(v72[0]) = ((v39 >> 1) & 1) == 0;
      LODWORD(v72[0]) = v39 & 1;
      v60 = (char *)&v38[v40];
      v41 = get_mat_length(v38);
      v42 = &v38[get_padded_len(v41, 8u)];
      v44 = *v42;
      v43 = v42[1];
      DWORD1(v71[0]) = v21;
      DWORD2(v71[0]) = ((v43 >> 1) & 1) == 0;
      v63 = (char *)&v42[v44];
      v45 = v76;
      v56 = v73;
      v57 = v75;
      LODWORD(v71[0]) = v43 & 1;
      v58 = v72;
      v61 = v74;
      v62 = v71;
      a7 = v24;
    }
    else
    {
      a7 = 0;
      v64 = 0;
      v65 = 0;
      v59 = 0;
      v60 = 0;
      v63 = 0;
      *(_QWORD *)((char *)v76 + 4) = v21 | 0x100000000;
      LODWORD(v76[0]) = 0;
      *(_QWORD *)((char *)v75 + 4) = *(_QWORD *)((char *)v76 + 4);
      LODWORD(v75[0]) = 0;
      *(_QWORD *)((char *)v74 + 4) = *(_QWORD *)((char *)v76 + 4);
      LODWORD(v74[0]) = 0;
      *(_QWORD *)((char *)v73 + 4) = *(_QWORD *)((char *)v76 + 4);
      LODWORD(v73[0]) = 0;
      *(_QWORD *)((char *)v72 + 4) = *(_QWORD *)((char *)v76 + 4);
      v45 = v76;
      LODWORD(v72[0]) = 0;
      v56 = v73;
      v57 = v75;
      v58 = v72;
      *(_QWORD *)((char *)v71 + 4) = *(_QWORD *)((char *)v76 + 4);
      v61 = v74;
      v62 = v71;
    }
  }
  else
  {
    v61 = 0;
    v62 = 0;
    v57 = 0;
    v58 = 0;
    v56 = 0;
    v45 = 0;
    v64 = (char *)&a7[(padded_len * a5)];
    v65 = &v64[4 * (padded_len * a5)];
    v59 = &v65[4 * (padded_len * a5)];
    v60 = &v59[4 * v19 * a5];
    v63 = &v60[4 * v19 * a5];
  }
  v46 = (float32x4_t *)((char *)a6 + 4 * v19);
  v47 = (float32x4_t *)((char *)v46 + 4 * v19);
  v48 = &v47->f32[v19];
  v66 = &a8[v19];
  memcpy(v48, a2, 4 * a4);
  bzero(a6, 4 * a5);
  gemm(v68, 1, a5, a4, v48, (char *)a7, a6, v45, v50);
  bzero(v46, 4 * a5);
  gemm(v68, 1, a5, a5, a9, v59, v46, v56, v51);
  axpy(a5, a6->f32, 1, v46->f32, 1, 1.0);
  axpy(a5, a8, 1, v46->f32, 1, 1.0);
  fi_activate_array(v46->f32, a5, a12);
  bzero(a6, 4 * a5);
  gemm(v68, 1, a5, a4, v48, v64, a6, v57, v52);
  bzero(v47, 4 * a5);
  gemm(v68, 1, a5, a5, a9, v60, v47, v58, v53);
  axpy(a5, a6->f32, 1, v47->f32, 1, 1.0);
  axpy(a5, v66, 1, v47->f32, 1, 1.0);
  fi_activate_array(v47->f32, a5, a12);
  xmy(a5, a9, 1, v47->f32, 1);
  bzero(a6, 4 * a5);
  gemm(v68, 1, a5, a5, v47->f32, v63, a6, v61, v54);
  bzero(v47, 4 * a5);
  gemm(v68, 1, a5, a4, v48, v65, v47, v62, v55);
  axpy(a5, a6->f32, 1, v47->f32, 1, 1.0);
  axpy(a5, &v66[v19], 1, v47->f32, 1, 1.0);
  fi_activate_array(v47->f32, a5, a11);
  fill_array_f32(a6->f32, a5, 1.0);
  axpy(a5, v46->f32, 1, a6->f32, 1, -1.0);
  xmy(a5, a6->f32, 1, v47->f32, 1);
  xmy(a5, a9, 1, v46->f32, 1);
  axpy(a5, v47->f32, 1, v46->f32, 1, 1.0);
  memcpy(a9, v46, 4 * a5);
  memcpy(__dst, v46, 4 * a5);
  return 0;
}

uint64_t gru_step_f32_fast(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, char *a6, int *a7, char *a8, void *a9, int a10, int a11, int a12)
{
  unsigned int v14;
  uint64_t *v18;
  int v19;
  uint64_t v20;
  int v21;
  _BOOL4 is_enabled;
  int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  int *v29;
  int v30;
  unsigned int *v31;
  _BOOL4 v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t mat_length;
  int *v36;
  unsigned int v37;
  uint64_t v38;
  char *v39;
  char *v40;
  float32x4_t *v41;
  char *v42;
  float32_t *v43;
  char *v44;
  uint64_t v45;
  int *v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _DWORD *v53;
  char *v54;
  _BOOL4 v55;
  void *__src;
  _DWORD *v57;
  unsigned int v58;
  unsigned int v59;
  void *v60;
  uint64_t v61;
  int padded_len;
  uint64_t *v64;
  _OWORD v66[2];
  _OWORD v67[2];
  char *v68;
  uint64_t v69[2];

  v14 = a4;
  v18 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  v20 = a5 + v14;
  v21 = get_padded_len(v20, 8u);
  v68 = 0;
  v69[0] = 0;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  memset(v67, 0, sizeof(v67));
  memset(v66, 0, sizeof(v66));
  v64 = v18;
  if (!is_enabled)
  {
    v58 = 2 * a5;
    v59 = v20;
    __src = a2;
    v57 = 0;
    v60 = a3;
    v53 = 0;
    v54 = (char *)&a7[(2 * a5 * v21)];
LABEL_11:
    v55 = 1;
    v38 = a5;
    goto LABEL_12;
  }
  if (!a7)
  {
    v58 = 2 * a5;
    v59 = v20;
    __src = a2;
    v60 = a3;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 1;
    v33 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
    LODWORD(v67[0]) = 0;
    DWORD1(v67[0]) = v33 == 1;
    DWORD2(v67[0]) = 1;
LABEL_10:
    a7 = v29;
    DWORD2(v66[0]) = v32;
    LODWORD(v66[0]) = v30;
    DWORD1(v66[0]) = v33 == 1;
    v53 = v67;
    v54 = (char *)v31;
    v57 = v66;
    goto LABEL_11;
  }
  v23 = a7[2];
  if (!v23)
  {
    v58 = 2 * a5;
    v59 = v20;
    __src = a2;
    v60 = a3;
    v34 = a7[1];
    v29 = &a7[*a7];
    *(_QWORD *)&v67[0] = __PAIR64__((*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1, v34 & 1);
    DWORD2(v67[0]) = ((v34 >> 1) & 1) == 0;
    mat_length = get_mat_length(a7);
    v36 = &a7[get_padded_len(mat_length, 8u)];
    v37 = v36[1];
    v31 = (unsigned int *)&v36[*v36];
    v30 = v37 & 1;
    v32 = ((v37 >> 1) & 1) == 0;
    v33 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
    goto LABEL_10;
  }
  v24 = (2 * a5);
  v61 = a5;
  v25 = a7[1];
  DWORD2(v67[0]) = ((v25 >> 1) & 1) == 0;
  *(_QWORD *)&v67[0] = v25 & 1;
  v26 = get_padded_len(v20, 8u);
  v27 = (uint64_t)&a7[*a7];
  if ((v25 & 2) != 0)
  {
    result = pack_bsr_data((uint64_t)v64, v23, v26, v24, v27, v69);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = pack_bsc_data((uint64_t)v64, v23, v26, v24, v27, v69);
    if ((_DWORD)result)
      return result;
  }
  v45 = get_mat_length(a7);
  v46 = &a7[get_padded_len(v45, 8u)];
  v47 = v46[1];
  v48 = v46[2];
  DWORD2(v66[0]) = ((v47 >> 1) & 1) == 0;
  *(_QWORD *)&v66[0] = v47 & 1;
  v49 = get_padded_len(v20, 8u);
  v50 = (uint64_t)&v46[*v46];
  if ((v25 & 2) != 0)
  {
    result = pack_bsr_data((uint64_t)v64, v48, v49, v61, v50, (uint64_t *)&v68);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = pack_bsc_data((uint64_t)v64, v48, v49, v61, v50, (uint64_t *)&v68);
    if ((_DWORD)result)
      return result;
  }
  v58 = v24;
  v59 = v20;
  v60 = a3;
  a7 = (int *)v69[0];
  v55 = v48 == 0;
  v53 = v67;
  v54 = 0;
  __src = a2;
  v57 = v66;
  v38 = v61;
LABEL_12:
  v39 = &a8[4 * v19];
  v40 = &a6[4 * padded_len];
  v41 = (float32x4_t *)&v40[4 * v19];
  v42 = &a6[4 * v14];
  memcpy(a6, __src, 4 * v14);
  memcpy(v42, a9, 4 * v38);
  memcpy(v41, a8, 4 * v38);
  memcpy(&v41->f32[v38], v39, 4 * v38);
  gemm(v64, 1, v58, v59, (float *)a6, (char *)a7, v41, v53, v51);
  fi_activate_array(v41->f32, v58, a12);
  memmove(v40, v42, 4 * v38);
  v43 = &v41->f32[v19];
  memmove(v43, &v41->f32[v38], 4 * v38);
  xmy(v38, v41->f32, 1, (float *)v40, 1);
  memmove(v42, v40, 4 * v38);
  memcpy(v41, &v39[4 * v19], 4 * v38);
  if (v55)
    v44 = v54;
  else
    v44 = v68;
  gemm(v64, 1, v38, v59, (float *)a6, v44, v41, v57, v52);
  fi_activate_array(v41->f32, v38, a11);
  fill_array_f32((float *)a6, v38, 1.0);
  axpy(v38, v43, 1, (float *)a6, 1, -1.0);
  xmy(v38, (float *)a6, 1, v41->f32, 1);
  xmy(v38, (float *)a9, 1, v43, 1);
  axpy(v38, v41->f32, 1, v43, 1, 1.0);
  memcpy(a9, v43, 4 * v38);
  memcpy(v60, v43, 4 * v38);
  if (v69[0])
  {
    (*(void (**)(uint64_t))(v64[1] + 80))(v64[2]);
    v69[0] = 0;
  }
  if (v68)
    (*(void (**)(uint64_t))(v64[1] + 80))(v64[2]);
  return 0;
}

uint64_t gru_step_f32_basic_resetafter(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, float *a8, float *a9, int a10, int a11, int a12)
{
  int padded_len;
  unsigned int v19;
  int *v20;
  uint64_t mat_length;
  int *v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  int v30;
  const void *v31;
  float32x4_t *v32;
  float32x4_t *v33;
  float32_t *v34;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  float *v46;
  float *v47;
  float *v48;
  float *v50;
  uint64_t *v52;
  uint64_t v53;

  v52 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  v53 = a4;
  if (fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264)))
  {
    if (a7)
    {
      v20 = &a7[*a7];
      mat_length = get_mat_length(a7);
      v22 = &a7[get_padded_len(mat_length, 8u)];
      v44 = (char *)&v22[*v22];
      v23 = get_mat_length(v22);
      v24 = &v22[get_padded_len(v23, 8u)];
      v45 = (char *)&v24[*v24];
      v25 = get_mat_length(v24);
      v26 = &v24[get_padded_len(v25, 8u)];
      v36 = (uint64_t)&v26[*v26];
      v27 = get_mat_length(v26);
      v28 = &v26[get_padded_len(v27, 8u)];
      v42 = (char *)&v28[*v28];
      v29 = get_mat_length(v28);
      v30 = get_padded_len(v29, 8u);
      v43 = (char *)&v28[v30 + v28[v30]];
      a7 = v20;
    }
    else
    {
      v44 = 0;
      v45 = 0;
      v36 = 0;
      v42 = 0;
      v43 = 0;
    }
  }
  else
  {
    v44 = (char *)&a7[(padded_len * a5)];
    v45 = &v44[4 * (padded_len * a5)];
    v36 = (uint64_t)&v45[4 * (padded_len * a5)];
    v42 = (char *)(v36 + 4 * v19 * a5);
    v43 = &v42[4 * v19 * a5];
  }
  v31 = a2;
  v32 = (float32x4_t *)((char *)a6 + 4 * v19);
  v33 = (float32x4_t *)((char *)v32 + 4 * v19);
  v34 = &v33->f32[v19];
  v47 = &a8[v19];
  v50 = &v47[v19];
  v46 = &v50[v19];
  v48 = &v46[v19];
  memcpy(v34, v31, 4 * v53);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, v53, v34, (char *)a7, a6, 0, v36);
  bzero(v32, 4 * a5);
  gemm(v52, 1, a5, a5, a9, v37, v32, 0, (uint64_t)v37);
  axpy(a5, a6->f32, 1, v32->f32, 1, 1.0);
  axpy(a5, a8, 1, v32->f32, 1, 1.0);
  axpy(a5, v46, 1, v32->f32, 1, 1.0);
  fi_activate_array(v32->f32, a5, a12);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, v53, v34, v44, a6, 0, v38);
  bzero(v33, 4 * a5);
  gemm(v52, 1, a5, a5, a9, v42, v33, 0, v39);
  axpy(a5, a6->f32, 1, v33->f32, 1, 1.0);
  axpy(a5, v47, 1, v33->f32, 1, 1.0);
  axpy(a5, v48, 1, v33->f32, 1, 1.0);
  fi_activate_array(v33->f32, a5, a12);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, a5, a9, v43, a6, 0, v40);
  xmy(a5, a6->f32, 1, v33->f32, 1);
  axpy(a5, &v48[v19], 1, v33->f32, 1, 1.0);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, v53, v34, v45, a6, 0, v41);
  axpy(a5, a6->f32, 1, v33->f32, 1, 1.0);
  axpy(a5, v50, 1, v33->f32, 1, 1.0);
  fi_activate_array(v33->f32, a5, a11);
  fill_array_f32(a6->f32, a5, 1.0);
  axpy(a5, v32->f32, 1, a6->f32, 1, -1.0);
  xmy(a5, a6->f32, 1, v33->f32, 1);
  xmy(a5, a9, 1, v32->f32, 1);
  axpy(a5, v33->f32, 1, v32->f32, 1, 1.0);
  memcpy(a9, v32, 4 * a5);
  memcpy(a3, v32, 4 * a5);
  return 0;
}

uint64_t gru_step_f32_fast_resetafter(uint64_t a1, void *a2, float *a3, uint64_t a4, uint64_t a5, char *a6, int *a7, char *a8, float *a9, int a10, int a11, int a12)
{
  int v17;
  uint64_t v18;
  _BOOL4 is_enabled;
  _BOOL4 v20;
  void *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  int v33;
  char *v34;
  int v35;
  unsigned int v36;
  char *v37;
  float32x4_t *v38;
  float32x4_t *v39;
  char *v40;
  unsigned int v41;
  unsigned int v42;
  size_t v43;
  float32_t *v44;
  char *v45;
  __int128 *v46;
  float *v47;
  int v48;
  int v49;
  char *v50;
  char *v51;
  __int128 *v52;
  uint64_t v53;
  float *v54;
  size_t v55;
  float *v56;
  float *v57;
  float *v58;
  float *v59;
  float *v60;
  float *v61;
  uint64_t v62;
  uint64_t v63;
  _DWORD *v64;
  int v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t mat_length;
  unsigned int *v74;
  unsigned int *v75;
  _BOOL4 v76;
  uint64_t v77;
  unsigned int v78;
  _DWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  unsigned int *v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  char *v94;
  int v95;
  float *v96;
  uint64_t v97;
  int v98;
  unsigned int v99;
  int v100;
  unsigned int padded_len;
  char *v102;
  int v104;
  float *v105;
  uint64_t v106;
  float32_t *__dsta;
  float *v110;
  _BOOL4 v111;
  uint64_t *v112;
  uint64_t __src;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  char *v118;
  uint64_t v119[2];

  v112 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v17 = get_padded_len(a5, 8u);
  v18 = a2 & 0x1F;
  v118 = 0;
  v119[0] = 0;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v20 = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  v100 = get_padded_len(a4, 8u);
  v99 = get_padded_len((3 * a5), 8u);
  __src = (3 * a5);
  v21 = a2;
  v104 = get_padded_len(__src, 8u);
  v22 = get_padded_len(a5, 8u);
  v98 = get_padded_len(a5, 8u);
  v116 = 0u;
  v117 = 0u;
  v114 = 0u;
  v115 = 0u;
  v106 = v18;
  if (v18)
    memcpy(a6, v21, 4 * a4);
  v110 = (float *)a6;
  v111 = is_enabled || v20;
  if (!is_enabled && !v20)
  {
    v95 = v22;
    v96 = (float *)v21;
    v97 = a4;
    v93 = 0;
    v32 = a8;
    v94 = (char *)&a7[padded_len * __src];
    v33 = 1;
    v102 = (char *)a7;
LABEL_10:
    v34 = a6;
    v36 = v99;
    v35 = v100;
LABEL_11:
    v37 = &v32[4 * v17];
    v38 = (float32x4_t *)&v34[4 * v35];
    v39 = (float32x4_t *)((char *)v38 + 4 * v36);
    v40 = &v37[4 * v17 + 4 * v17];
    v41 = 2 * a5;
    __dsta = &v39->f32[v104];
    if (v17 == (_DWORD)a5)
    {
      v42 = __src;
      v43 = 4 * __src;
      v44 = (float32_t *)&v34[4 * v35];
    }
    else
    {
      memcpy(v38, v32, 4 * a5);
      memcpy(&v38->f32[a5], v37, 4 * a5);
      v44 = &v38->f32[v41];
      v32 = &v37[4 * v17];
      v43 = 4 * a5;
      v42 = __src;
    }
    memcpy(v44, v32, v43);
    v105 = &__dsta[v95];
    if (v33)
      v45 = v102;
    else
      v45 = (char *)v119[0];
    if (v111)
      v46 = &v116;
    else
      v46 = 0;
    if (v106)
      v47 = v110;
    else
      v47 = v96;
    v26 = v112;
    gemm(v112, 1, v42, v97, v47, v45, v38, v46, v91);
    if (v17 == (_DWORD)a5)
    {
      memcpy(v39, v40, 4 * v42);
      v48 = v42;
      v49 = v17;
    }
    else
    {
      v49 = v17;
      v50 = &v40[4 * v17];
      memcpy(v39, v40, 4 * a5);
      memcpy(&v39->f32[a5], v50, 4 * a5);
      v26 = v112;
      v48 = __src;
      memcpy(&v39->f32[v41], &v50[4 * v49], 4 * a5);
    }
    if (v93)
      v51 = v118;
    else
      v51 = v94;
    if (v111)
      v52 = &v114;
    else
      v52 = 0;
    gemm(v26, 1, v48, a5, a9, v51, v39, v52, v92);
    axpy((2 * a5), v38->f32, 1, v39->f32, 1, 1.0);
    fi_activate_array(v39->f32, (2 * a5), a12);
    v53 = v41;
    v54 = &v39->f32[v41];
    if (v49 == (_DWORD)a5)
    {
      xmy(a5, v39->f32, 1, &v39->f32[v41], 1);
      axpy(a5, &v38->f32[v41], 1, &v39->f32[v41], 1, 1.0);
      fi_activate_array(&v39->f32[v41], a5, a11);
      fill_array_f32(v105, a5, 1.0);
      v55 = 4 * a5;
      axpy(a5, &v39->f32[v55 / 4], 1, v105, 1, -1.0);
      v56 = a9;
      v57 = a9;
      v58 = &v39->f32[v55 / 4];
      v59 = &__dsta[v95];
      v60 = v54;
    }
    else
    {
      v61 = &v105[v98];
      v55 = 4 * a5;
      memcpy(__dsta, v54, v55);
      xmy(a5, v39->f32, 1, __dsta, 1);
      memcpy(v105, &v38->f32[v53], v55);
      axpy(a5, v105, 1, __dsta, 1, 1.0);
      fi_activate_array(__dsta, a5, a11);
      memcpy(v61, (char *)v39 + v55, v55);
      fill_array_f32(v105, a5, 1.0);
      axpy(a5, v61, 1, v105, 1, -1.0);
      v56 = a9;
      v57 = a9;
      v58 = v61;
      v59 = &__dsta[v95];
      v60 = __dsta;
    }
    fi_multiply_multiply_add_ansic(v57, v58, v59, v60, a3, a5);
    memcpy(v56, a3, v55);
    v62 = 0;
    v63 = 0;
    v64 = (_DWORD *)*((_QWORD *)&v117 + 1);
    if (*((_QWORD *)&v117 + 1))
      goto LABEL_36;
    goto LABEL_37;
  }
  v26 = v112;
  if (!a7)
  {
    v102 = 0;
    v66 = 0;
    *(_QWORD *)&v116 = 0;
    DWORD2(v116) = 1;
    LODWORD(v117) = 0;
LABEL_46:
    DWORD1(v117) = v66 ^ 1;
    v68 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v112[1] + 64))(v112[2], 2, 4);
    *((_QWORD *)&v117 + 1) = v68;
    if (!v68)
    {
      log_OutText(*v112, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v69, v70, v71, v91);
      v63 = 10;
      goto LABEL_37;
    }
    v64 = v68;
    if (a7)
    {
      *v68 = a7[7];
      v68[1] = a7[8];
      v72 = v17;
      if ((a7[1] & 8) != 0)
      {
        v77 = *a7;
        v74 = (unsigned int *)((char *)&a7[v77] + get_weight_length(a7));
      }
      else
      {
        mat_length = get_mat_length(a7);
        v74 = (unsigned int *)&a7[get_padded_len(mat_length, 8u)];
      }
      v78 = v74[1];
      v75 = &v74[*v74];
      *(_QWORD *)&v114 = v78 & 1;
      DWORD2(v114) = ((v78 >> 1) & 1) == 0;
      LODWORD(v115) = (v78 >> 3) & 1;
      v76 = ((v78 >> 4) & 1) == 0;
    }
    else
    {
      v72 = v17;
      v74 = 0;
      v75 = 0;
      *(_QWORD *)v68 = 0;
      v76 = 1;
      *(_QWORD *)&v114 = 0;
      DWORD2(v114) = 1;
      LODWORD(v115) = 0;
    }
    DWORD1(v115) = v76;
    v79 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v112[1] + 64))(v112[2], 2, 4);
    *((_QWORD *)&v115 + 1) = v79;
    if (!v79)
    {
      log_OutText(*v112, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v80, v81, v82, v91);
      v62 = 10;
LABEL_36:
      (*(void (**)(uint64_t, _DWORD *))(v26[1] + 80))(v26[2], v64);
      *((_QWORD *)&v117 + 1) = 0;
      v63 = v62;
      goto LABEL_37;
    }
    v96 = (float *)v21;
    v97 = a4;
    v95 = v22;
    v94 = (char *)v75;
    if (a7)
    {
      *v79 = v74[7];
      v83 = v74[8];
    }
    else
    {
      *v79 = 0;
      v83 = 0;
    }
    v17 = v72;
    v34 = a6;
    v32 = a8;
    v36 = v99;
    v35 = v100;
    v93 = 0;
    v79[1] = v83;
    v33 = 1;
    goto LABEL_11;
  }
  v27 = a7[2];
  if (!v27)
  {
    v67 = a7[1];
    v102 = (char *)&a7[*a7];
    *(_QWORD *)&v116 = v67 & 1;
    DWORD2(v116) = ((v67 >> 1) & 1) == 0;
    LODWORD(v117) = (v67 >> 3) & 1;
    v66 = (v67 >> 4) & 1;
    goto LABEL_46;
  }
  v28 = v17;
  v29 = a7[1];
  DWORD2(v116) = ((v29 >> 1) & 1) == 0;
  *(_QWORD *)&v116 = v29 & 1;
  if ((v29 & 8) != 0)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v23, v24, v25, v91);
    v63 = 7;
    goto LABEL_37;
  }
  v30 = (uint64_t)&a7[*a7];
  if ((v29 & 2) != 0)
    v31 = pack_bsr_data((uint64_t)v112, v27, padded_len, __src, v30, v119);
  else
    v31 = pack_bsc_data((uint64_t)v112, v27, padded_len, __src, v30, v119);
  v63 = v31;
  if (!(_DWORD)v31)
  {
    v84 = get_mat_length(a7);
    v85 = (unsigned int *)&a7[get_padded_len(v84, 8u)];
    v86 = v85[1];
    v87 = v85[2];
    v88 = *v85;
    DWORD2(v114) = ((v86 >> 1) & 1) == 0;
    *(_QWORD *)&v114 = v86 & 1;
    v89 = (uint64_t)&v85[v88];
    v90 = (v29 & 2) != 0
        ? pack_bsr_data((uint64_t)v112, v87, padded_len, __src, v89, (uint64_t *)&v118)
        : pack_bsc_data((uint64_t)v112, v87, padded_len, __src, v89, (uint64_t *)&v118);
    v63 = v90;
    v32 = a8;
    if (!(_DWORD)v90)
    {
      v93 = v87;
      v95 = v22;
      v96 = (float *)v21;
      v97 = a4;
      v33 = 0;
      v102 = 0;
      v94 = 0;
      v17 = v28;
      goto LABEL_10;
    }
  }
LABEL_37:
  if (*((_QWORD *)&v115 + 1))
  {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
    *((_QWORD *)&v115 + 1) = 0;
  }
  if (v119[0])
  {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
    v119[0] = 0;
  }
  if (v118)
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
  return v63;
}

uint64_t gru_step_f32_fast_resetafter_precompute(uint64_t a1, float *a2, float *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, char *a7, char *a8, float *a9, int a10, int a11, int a12)
{
  uint64_t *v17;
  uint64_t padded_len;
  int v19;
  unsigned int v20;
  unsigned int v21;
  _BOOL4 is_enabled;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 *v32;
  char *v33;
  char *v34;
  int v35;
  unsigned int v36;
  _DWORD *v37;
  uint64_t mat_length;
  unsigned int *v39;
  _BOOL4 v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  _DWORD *v44;
  unsigned int v45;
  char *v46;
  char *v47;
  char *v48;
  float32x4_t *v49;
  float32_t *v50;
  uint64_t v51;
  int v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  __int128 *v57;
  int v58;
  float *v59;
  float *v60;
  size_t v61;
  float *v62;
  float *v63;
  float *v64;
  float *v65;
  float *v66;
  float *v67;
  int v68;
  size_t v69;
  uint64_t v70;
  float32_t *v71;
  uint64_t v72;
  unsigned int *v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  __int128 *v82;
  int v83;
  char *v84;
  unsigned int v85;
  float32x4_t *v86;
  uint64_t **v87;
  unsigned int *v89;
  int v90;
  _BOOL4 v91;
  uint64_t *v92;
  unsigned int step;
  float *v94;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  char *v101;
  uint64_t v102[2];

  v17 = *(uint64_t **)a1;
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v85 = a4;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  v20 = 3 * a5;
  v21 = get_padded_len((3 * a5), 8u);
  v101 = 0;
  v102[0] = 0;
  LODWORD(a4) = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v87 = (uint64_t **)a1;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  v99 = 0u;
  v100 = 0u;
  v97 = 0u;
  v98 = 0u;
  v91 = (a4 | is_enabled) != 0;
  if (!(a4 | is_enabled))
  {
    v32 = 0;
    v90 = 0;
    v89 = (unsigned int *)&a7[4 * padded_len * v20];
    v84 = a7;
    v33 = a8;
    goto LABEL_21;
  }
  if (!a7)
  {
    v34 = 0;
    v35 = 0;
    *(_QWORD *)&v99 = 0;
    DWORD2(v99) = 1;
    LODWORD(v100) = 0;
LABEL_10:
    DWORD1(v100) = v35 ^ 1;
    v37 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v17[1] + 64))(v17[2], 2, 4);
    *((_QWORD *)&v100 + 1) = v37;
    v84 = v34;
    if (a7)
    {
      *v37 = *((_DWORD *)a7 + 7);
      v37[1] = *((_DWORD *)a7 + 8);
      if ((a7[4] & 8) != 0)
      {
        v42 = *(unsigned int *)a7;
        v39 = (unsigned int *)&a7[4 * v42 + get_weight_length(a7)];
      }
      else
      {
        mat_length = get_mat_length((int *)a7);
        v39 = (unsigned int *)&a7[4 * get_padded_len(mat_length, 8u)];
      }
      v43 = v39[1];
      v89 = &v39[*v39];
      *(_QWORD *)&v97 = v43 & 1;
      DWORD2(v97) = ((v43 >> 1) & 1) == 0;
      LODWORD(v98) = (v43 >> 3) & 1;
      v40 = ((v43 >> 4) & 1) == 0;
    }
    else
    {
      v39 = 0;
      v89 = 0;
      *(_QWORD *)v37 = 0;
      v40 = 1;
      *(_QWORD *)&v97 = 0;
      DWORD2(v97) = 1;
      LODWORD(v98) = 0;
    }
    DWORD1(v98) = v40;
    v44 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v17[1] + 64))(v17[2], 2, 4);
    *((_QWORD *)&v98 + 1) = v44;
    if (a7)
    {
      *v44 = v39[7];
      v45 = v39[8];
    }
    else
    {
      *v44 = 0;
      v45 = 0;
    }
    v33 = a8;
    v90 = 0;
    v44[1] = v45;
    v32 = &v99;
    goto LABEL_21;
  }
  v26 = *((_DWORD *)a7 + 2);
  if (!v26)
  {
    v36 = *((_DWORD *)a7 + 1);
    v34 = &a7[4 * *(unsigned int *)a7];
    *(_QWORD *)&v99 = v36 & 1;
    DWORD2(v99) = ((v36 >> 1) & 1) == 0;
    LODWORD(v100) = (v36 >> 3) & 1;
    v35 = (v36 >> 4) & 1;
    goto LABEL_10;
  }
  v27 = *((_DWORD *)a7 + 1);
  DWORD2(v99) = ((v27 >> 1) & 1) == 0;
  *(_QWORD *)&v99 = v27 & 1;
  if ((v27 & 8) != 0)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v23, v24, v25, v81);
    v41 = 7;
    goto LABEL_51;
  }
  v28 = v19;
  v29 = (uint64_t)&a7[4 * *(unsigned int *)a7];
  v30 = (3 * a5);
  if ((v27 & 2) != 0)
    v31 = pack_bsr_data((uint64_t)v17, v26, padded_len, v30, v29, v102);
  else
    v31 = pack_bsc_data((uint64_t)v17, v26, padded_len, v30, v29, v102);
  v41 = v31;
  if ((_DWORD)v31)
    goto LABEL_51;
  v72 = get_mat_length((int *)a7);
  v73 = (unsigned int *)&a7[4 * get_padded_len(v72, 8u)];
  v74 = v73[1];
  v75 = v73[2];
  v76 = *v73;
  DWORD2(v97) = ((v74 >> 1) & 1) == 0;
  *(_QWORD *)&v97 = v74 & 1;
  v77 = (uint64_t)&v73[v76];
  v78 = (3 * a5);
  v79 = (v27 & 2) != 0
      ? pack_bsr_data((uint64_t)v17, v75, padded_len, v78, v77, (uint64_t *)&v101)
      : pack_bsc_data((uint64_t)v17, v75, padded_len, v78, v77, (uint64_t *)&v101);
  v41 = v79;
  v33 = a8;
  if ((_DWORD)v79)
    goto LABEL_51;
  v90 = v75;
  v89 = 0;
  v32 = &v99;
  v84 = (char *)v102[0];
  v19 = v28;
LABEL_21:
  v46 = &v33[4 * v19];
  v47 = &v46[4 * v19];
  v92 = v17;
  if (!a10)
  {
    v82 = v32;
    v83 = v19;
    if (step)
    {
      v68 = 0;
      v69 = 4 * a5;
      v70 = step;
      do
      {
        v71 = &a6->f32[v68];
        memcpy(v71, a8, v69);
        memcpy(&v71[a5], v46, v69);
        memcpy(&v71[(2 * a5)], v47, v69);
        v68 += v21;
        --v70;
      }
      while (v70);
    }
    if ((a2 & 0x1F) != 0)
    {
      log_OutText(**v87, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru input not aligned!", v23, v24, v25, v81);
      v41 = 7;
      v17 = v92;
      goto LABEL_51;
    }
    v20 = 3 * a5;
    v17 = v92;
    gemm_ex(v92, step, 3 * a5, v85, a2, v85, v84, v85, a6, v21, v82);
    v19 = v83;
  }
  v48 = &v47[4 * v19];
  v49 = (float32x4_t *)((char *)a6 + 4 * v21 * step);
  v50 = &v49->f32[v21];
  v94 = &v50[v19];
  if (v19 == (_DWORD)a5)
  {
    memcpy(v49, v48, 4 * v20);
    v51 = (2 * a5);
    v52 = v19;
  }
  else
  {
    v53 = &v48[4 * v19];
    v86 = a6;
    v54 = &v53[4 * v19];
    v52 = v19;
    memcpy(v49, v48, 4 * a5);
    memcpy(&v49->f32[a5], v53, 4 * a5);
    v51 = (2 * a5);
    v55 = v54;
    a6 = v86;
    memcpy(&v49->f32[v51], v55, 4 * a5);
  }
  if (v90)
    v56 = v101;
  else
    v56 = (char *)v89;
  if (v91)
    v57 = &v97;
  else
    v57 = 0;
  v58 = v20;
  v59 = a9;
  gemm(v17, 1, v58, a5, a9, v56, v49, v57, v81);
  v60 = &a6->f32[v21 * a10];
  axpy(v51, v60, 1, v49->f32, 1, 1.0);
  fi_activate_array(v49->f32, v51, a12);
  if (v52 == (_DWORD)a5)
  {
    xmy(a5, v49->f32, 1, &v49->f32[v51], 1);
    axpy(a5, &v60[v51], 1, &v49->f32[v51], 1, 1.0);
    fi_activate_array(&v49->f32[v51], a5, a11);
    fill_array_f32(v94, a5, 1.0);
    v61 = 4 * a5;
    axpy(a5, &v49->f32[v61 / 4], 1, v94, 1, -1.0);
    v62 = a9;
    v63 = &v49->f32[v61 / 4];
    v64 = &v50[v19];
    v65 = &v49->f32[v51];
    v66 = a3;
  }
  else
  {
    v67 = &v94[v52];
    v61 = 4 * a5;
    memcpy(v50, &v49->f32[v51], v61);
    xmy(a5, v49->f32, 1, v50, 1);
    memcpy(v94, &v60[v51], v61);
    axpy(a5, v94, 1, v50, 1, 1.0);
    fi_activate_array(v50, a5, a11);
    memcpy(v67, (char *)v49 + v61, v61);
    fill_array_f32(v94, a5, 1.0);
    axpy(a5, v67, 1, v94, 1, -1.0);
    v66 = a3;
    v62 = a9;
    v63 = v67;
    v59 = a9;
    v64 = &v50[v19];
    v65 = &v49->f32[v21];
  }
  fi_multiply_multiply_add_ansic(v62, v63, v64, v65, v66, a5);
  memcpy(v59, a3, v61);
  v17 = v92;
  if (v102[0])
  {
    (*(void (**)(uint64_t))(v92[1] + 80))(v92[2]);
    v102[0] = 0;
  }
  if (v101)
  {
    (*(void (**)(uint64_t))(v92[1] + 80))(v92[2]);
    v41 = 0;
    v101 = 0;
  }
  else
  {
    v41 = 0;
  }
LABEL_51:
  if (*((_QWORD *)&v100 + 1))
  {
    (*(void (**)(uint64_t))(v17[1] + 80))(v17[2]);
    *((_QWORD *)&v100 + 1) = 0;
  }
  if (*((_QWORD *)&v98 + 1))
    (*(void (**)(uint64_t))(v17[1] + 80))(v17[2]);
  return v41;
}

uint64_t forward_fc_layer_f32(uint64_t a1, float *a2, float32x4_t *a3)
{
  unsigned int *v6;
  uint64_t v7;
  _BOOL4 v8;
  int *v9;
  uint64_t *v10;
  _BOOL4 is_enabled;
  _BOOL4 v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  const void *v18;
  int v19;
  BOOL v20;
  int v21;
  unsigned int *v22;
  uint64_t size;
  unsigned int step;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int *v34;
  unsigned int v35;
  uint64_t v36;
  char *v37;
  __int128 *v38;
  uint64_t v39;
  uint64_t (*v40)(uint64_t, _QWORD, uint64_t);
  int padded_len;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  float *v49;
  uint64_t v51;
  unsigned int v52;
  float *v53;
  int v54;
  float *v55;
  float32x4_t *v56;
  uint64_t v57;
  int *v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;
  char *v62;

  v6 = *(unsigned int **)(a1 + 72);
  v61 = 0;
  v62 = 0;
  v7 = *(unsigned int *)(a1 + 12);
  v8 = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
  v9 = *(int **)(a1 + 120);
  v10 = *(uint64_t **)a1;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v12 = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  v59 = 0u;
  v60 = 0u;
  if (v12 && v6)
  {
    v55 = a2;
    v13 = v6[1];
    v14 = *(_QWORD *)(a1 + 72);
    v15 = *(unsigned int *)(a1 + 96);
    v16 = (const void *)(v14 + v15);
    v17 = (const void *)(v14 + (v15 & 0xFFFFFFFC));
    if ((v13 & 8) != 0)
      v18 = v16;
    else
      v18 = v17;
  }
  else
  {
    if (!v6)
    {
LABEL_46:
      size = 0;
      goto LABEL_47;
    }
    v55 = a2;
    v18 = (const void *)(*(_QWORD *)(a1 + 72) + (*(_DWORD *)(a1 + 96) & 0xFFFFFFFC));
    v13 = v6[1];
  }
  v54 = v8;
  v58 = v9;
  v56 = a3;
  v19 = v12 || is_enabled;
  v20 = !v12 && !is_enabled || v6 == 0;
  v21 = !v20;
  v22 = v6;
  if (!v20)
    v22 = &v6[*v6];
  v57 = (uint64_t)v22;
  size = fi_shape_get_size((int *)(a1 + 40), (int *)&v61);
  if (!(_DWORD)size)
  {
    step = fi_shape_get_step((_DWORD *)(a1 + 20));
    if (!step)
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"steps must > 0, but it is: %d", v25, v26, v27, 0);
      size = 7;
      goto LABEL_47;
    }
    v52 = step;
    size = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v61 + 1);
    if (!(_DWORD)size)
    {
      if (!v21
        || (v28 = v6[2]) == 0
        || ((v29 = get_padded_len(HIDWORD(v61), 8u), (v13 & 3) != 3)
          ? (v30 = pack_bsc_data((uint64_t)v10, v28, v29, v7, v57, (uint64_t *)&v62))
          : (v30 = pack_bsr_data((uint64_t)v10, v28, v29, v7, v57, (uint64_t *)&v62)),
            size = v30,
            !(_DWORD)v30))
      {
        if (v52 < 2 || (v31 = HIDWORD(v61), get_padded_len(HIDWORD(v61), 8u) == (_DWORD)v31))
        {
          v53 = 0;
        }
        else
        {
          v39 = v10[2];
          v40 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v10[1] + 16);
          padded_len = get_padded_len(v31, 8u);
          v42 = v40(v39, padded_len * v52, 4);
          if (!v42)
          {
            log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v43, v44, v45, v51);
LABEL_53:
            size = 10;
            goto LABEL_47;
          }
          v46 = 0;
          v53 = (float *)v42;
          v47 = 0;
          do
          {
            v48 = get_padded_len(v31, 8u);
            memcpy(&v53[(v48 * v47++)], &v55[v46], 4 * v31);
            v46 += v31;
          }
          while (v52 != v47);
        }
        if (v58[1] == 1)
        {
          v32 = 0;
          if (v52 <= 1)
            v33 = 1;
          else
            v33 = v52;
          do
          {
            memcpy(&v56->f32[v32], v18, 4 * v7);
            v32 += v7;
            --v33;
          }
          while (v33);
        }
        if (!v19)
        {
          v38 = 0;
          v36 = v57;
          v34 = v58;
          v37 = (char *)v57;
          v49 = v55;
          v35 = v52;
LABEL_45:
          fc_gemm_wrapper(a1, v35, HIDWORD(v61), v7, v37, v49, v49, v53, v36, v56, v38);
          fi_activate_array(v56->f32, v61, *v34);
          goto LABEL_46;
        }
        if (pack_gemm_params((uint64_t)v10, v54, v6, (uint64_t)&v59))
        {
          v34 = v58;
          v35 = v52;
          v36 = v57;
          if ((v6[1] & 1) != 0)
            v37 = v62;
          else
            v37 = (char *)v57;
          v38 = &v59;
          v49 = v55;
          goto LABEL_45;
        }
        goto LABEL_53;
      }
    }
  }
LABEL_47:
  if (v62)
  {
    (*(void (**)(uint64_t))(v10[1] + 80))(v10[2]);
    v62 = 0;
  }
  if (*((_QWORD *)&v60 + 1))
    (*(void (**)(uint64_t))(v10[1] + 80))(v10[2]);
  return size;
}

uint64_t pack_gemm_params(uint64_t a1, int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v6;
  _DWORD *v7;

  v4 = a4;
  *(_DWORD *)(a4 + 4) = a2;
  if (!a3)
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 1;
    *(_QWORD *)(a4 + 16) = 0x100000000;
    goto LABEL_6;
  }
  *(_DWORD *)a4 = a3[1] & 1;
  *(_DWORD *)(a4 + 8) = ((a3[1] >> 1) & 1) == 0;
  v6 = a3[1];
  *(_DWORD *)(a4 + 16) = (v6 >> 3) & 1;
  *(_DWORD *)(a4 + 20) = ((a3[1] >> 4) & 1) == 0;
  if (((v6 >> 3) & 1) == 0)
  {
LABEL_6:
    *(_QWORD *)(a4 + 24) = 0;
    return v4;
  }
  v7 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), 2, 4);
  *(_QWORD *)(v4 + 24) = v7;
  if (!v7)
    return 0;
  *v7 = a3[7];
  v7[1] = a3[8];
  return v4;
}

void fc_gemm_wrapper(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, char *a5, float *a6, float *a7, float *a8, uint64_t a9, float32x4_t *a10, _DWORD *a11)
{
  _DWORD *v17;
  float32x4_t *v18;
  float *v19;
  float *v20;
  int padded_len;
  int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t *v25;
  uint64_t v26;
  float *v27;

  v18 = a10;
  v17 = a11;
  if (a2 < 2)
    goto LABEL_3;
  v25 = *(uint64_t **)a1;
  v27 = a8;
  v19 = a6;
  v20 = a7;
  padded_len = get_padded_len(a3, 8u);
  a7 = v20;
  v17 = a11;
  v18 = a10;
  a6 = v19;
  if (padded_len == (_DWORD)a3)
  {
LABEL_3:
    v22 = *(_DWORD *)(a1 + 16);
    if (v22 == 2)
    {
      v24 = a7[1];
      axpy(a4, (float *)(a9 + 4 * *a7 * a4), 1, v18->f32, 1, 1.0);
      v23 = v24 * a4;
      goto LABEL_9;
    }
    if (v22 == 1)
    {
      v23 = *a7 * a4;
LABEL_9:
      axpy(a4, (float *)(a9 + 4 * v23), 1, v18->f32, 1, 1.0);
      return;
    }
    gemm(*(uint64_t **)a1, a2, a4, a3, a6, a5, v18, v17, a9);
  }
  else
  {
    gemm(*(uint64_t **)a1, a2, a4, a3, v27, a5, a10, a11, (uint64_t)v25);
    if (v27)
      (*(void (**)(_QWORD, float *))(*(_QWORD *)(v26 + 8) + 48))(*(_QWORD *)(v26 + 16), v27);
  }
}

uint64_t create_flatten_layer(uint64_t *a1, _DWORD *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t result;
  uint64_t v14;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    v12 = (_DWORD *)v11;
    result = 0;
    *v12 = *a2;
    *((_DWORD *)v10 + 2) = 7;
    v10[16] = (uint64_t *)forward_flatten_layer;
    v10[17] = (uint64_t *)free_flatten_buffer;
    v10[18] = (uint64_t *)flatten_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_flatten_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_flatten_layer(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  uint64_t size;
  unsigned int v8;

  v8 = 0;
  size = fi_shape_get_size((int *)(a2 + 40), (int *)&v8);
  if (!(_DWORD)size)
    memcpy(a4, a3, 4 * v8);
  return size;
}

_QWORD *free_flatten_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t flatten_layer_update_shape(uint64_t a1, int *a2)
{
  int v4;
  uint64_t result;
  int v6;
  int v7;

  v7 = 0;
  v4 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v4;
  result = fi_shape_get_size(a2, &v7);
  if (!(_DWORD)result)
  {
    v6 = v7;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v6;
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  return result;
}

uint64_t create_norm_layer(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;

  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9)
  {
    result = 0;
    v11 = *a2;
    *(_DWORD *)(v9 + 16) = *((_DWORD *)a2 + 2);
    *(_QWORD *)v9 = a1;
    *(_QWORD *)(v9 + 8) = v11;
    *(_QWORD *)(v9 + 128) = forward_norm_layer;
    *(_QWORD *)(v9 + 136) = free_norm_buffer;
    *(_QWORD *)(v9 + 144) = norm_layer_update_shape;
    *(_QWORD *)(v9 + 152) = norm_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v12);
    result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_norm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v9;
  int *v10;
  int step;
  float *v12;
  float *v13;
  uint64_t input_dim;
  unsigned int padded_len;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  int v30;
  double v32;
  uint64_t v33;
  float *v34;
  float v35;
  float v36;
  double v37;
  uint64_t v38;
  float *v39;
  float v40;
  float v41;
  uint64_t v42;
  float *v43;
  void *v44;
  size_t v45;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  float *v51;
  unsigned int v52;
  int v53;

  v9 = *(uint64_t **)a2;
  v53 = 0;
  v10 = (int *)(a2 + 40);
  step = fi_shape_get_step((_DWORD *)(a2 + 40));
  v52 = 0;
  v12 = *(float **)(a2 + 88);
  v13 = *(float **)(a2 + 104);
  input_dim = fi_shape_get_input_dim(v10, (int *)&v52);
  if (!(_DWORD)input_dim)
  {
    v49 = a3;
    v50 = a4;
    padded_len = get_padded_len(v52, 8u);
    v19 = padded_len;
    v20 = v52;
    if (a5 && !*(_DWORD *)(a5 + 16) && v52 != padded_len)
    {
      log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Normalization layer cannot work with swapNeeded equal to 0 and an input dimension not multiple of the padding (%d).", v16, v17, v18, 8);
      v20 = v52;
    }
    if (v20 == v19)
    {
      v21 = 0;
    }
    else
    {
      v21 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v9[1] + 16))(v9[2], v19, 4);
      if (!v21)
      {
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory in normalization layer!", v22, v23, v24, v47);
        return 10;
      }
    }
    input_dim = fi_shape_get_size(v10, &v53);
    if (!(_DWORD)input_dim)
    {
      if (!step)
      {
        input_dim = 0;
        if (!v21)
          return input_dim;
        goto LABEL_35;
      }
      v51 = v12;
      v48 = v9;
      v25 = 0;
      v26 = v50;
      do
      {
        v27 = v52 * v25;
        v28 = (void *)(v49 + 4 * v27);
        v29 = v21;
        if (v52 == v19)
        {
          if (!a5 || (v29 = (void *)(v49 + 4 * v27), *(_DWORD *)(a5 + 16)))
            v29 = (void *)(v26 + 4 * v27);
        }
        memcpy(v29, (const void *)(v49 + 4 * v27), 4 * v52);
        v30 = v52;
        if (*(_DWORD *)(a2 + 8) == 40 && v52 != 0)
        {
          v32 = 0.0;
          v33 = v52;
          v34 = (float *)v29;
          do
          {
            v35 = *v34++;
            v32 = v32 + v35;
            --v33;
          }
          while (v33);
          v36 = v32 / (double)v52;
          v37 = 0.0;
          v38 = v52;
          v39 = (float *)v29;
          do
          {
            v40 = *v39++;
            v37 = v37 + (float)(v40 - v36) * (float)(v40 - v36);
            --v38;
          }
          while (v38);
          v41 = sqrt(v37 / (double)v52) + 1.0e-30;
          v42 = v52;
          v43 = (float *)v29;
          do
          {
            *v43 = (float)(*v43 - v36) / v41;
            ++v43;
            --v42;
          }
          while (v42);
        }
        xmy(v30, v51, 1, (float *)v29, 1);
        axpy(v52, v13, 1, (float *)v29, 1, 1.0);
        if (v52 != v19)
        {
          if (a5 && !*(_DWORD *)(a5 + 16))
          {
            v45 = 4 * v52;
            v44 = v28;
          }
          else
          {
            v44 = (void *)(v26 + 4 * v52 * v25);
            v45 = 4 * v52;
          }
          memcpy(v44, v29, v45);
          bzero(v21, v45);
          v26 = v50;
        }
        ++v25;
      }
      while (v25 != step);
      input_dim = 0;
      v9 = v48;
    }
    if (v21)
LABEL_35:
      (*(void (**)(uint64_t, void *))(v9[1] + 48))(v9[2], v21);
  }
  return input_dim;
}

uint64_t free_norm_buffer(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)result + 8) + 48))(*(_QWORD *)(*(_QWORD *)result + 16), result);
  return result;
}

uint64_t norm_layer_update_shape(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;

  v2 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v2;
  v3 = *a2;
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 40) = v3;
  return 0;
}

uint64_t norm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t input_dim;
  unsigned int v7;

  v7 = 0;
  input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v7);
  if (!(_DWORD)input_dim)
  {
    *a2 = 4 * get_padded_len(v7, 8u);
    *a3 = 4 * v7;
  }
  return input_dim;
}

uint64_t create_gl_layer(uint64_t *a1, uint64_t *a2, __int128 *a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v17;

  v5 = 0;
  v6 = 7;
  if (!a2 || !a3)
    goto LABEL_7;
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v5 || (v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24)) == 0)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v17);
    v6 = 10;
LABEL_7:
    free_gl_layer((_QWORD *)v5);
    goto LABEL_8;
  }
  v6 = 0;
  v14 = *a3;
  *(_QWORD *)(v13 + 16) = *((_QWORD *)a3 + 2);
  *(_OWORD *)v13 = v14;
  *(_QWORD *)(v5 + 120) = v13;
  v15 = *a2;
  *(_DWORD *)(v5 + 16) = *((_DWORD *)a2 + 2);
  *(_QWORD *)v5 = a1;
  *(_QWORD *)(v5 + 8) = v15;
  *(_QWORD *)(v5 + 128) = forward_gl_layer;
  *(_QWORD *)(v5 + 136) = free_gl_layer;
  *(_QWORD *)(v5 + 144) = gl_layer_update_shape;
  *(_QWORD *)(v5 + 160) = gl_request_glbBuf;
LABEL_8:
  *a4 = v5;
  return v6;
}

uint64_t forward_gl_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float *v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  float32x2_t *v19;
  float *v20;
  unsigned int i;
  float v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t result;
  float32x2_t *v30;
  uint64_t v31;
  float *v32;
  float v33;
  float v34;
  float v35;
  BOOL v36;
  float v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float v47;
  uint64_t v48;
  int v49;
  int j;
  uint64_t v51;
  int v52;
  float v53;
  float v54;
  float v55;
  uint64_t v56;
  float *v57;
  int v58;
  char *v59;
  float32x2_t v60;
  float32x2_t v61;
  float *v62;
  uint64_t v63;
  uint64_t v64;
  float32x2_t v65;
  float32x2_t v66;
  float v67;
  float32x2_t v68;
  float v69;
  unsigned int v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *__dst;
  float *__dsta;
  unsigned int v80;
  float *v81;
  uint64_t *v82;
  uint64_t v83;
  float *v84;
  uint64_t *v85;
  float *v86;
  int v87;
  float *v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int step;
  float32x2_t v93;
  unsigned int v94;
  unsigned int v95[3];

  v12 = *(float **)(a2 + 120);
  v13 = *((_DWORD *)v12 + 5);
  if (v13 != 1)
  {
    if (v13)
    {
      v71 = **(_QWORD **)a2;
      v72 = "must offer correct gl_type input!";
LABEL_74:
      log_OutText(v71, (uint64_t)"FastInfer", 0, 0, (uint64_t)v72, a6, a7, a8, v73);
      return 7;
    }
    v94 = 0;
    v14 = *(uint64_t **)a2;
    step = fi_shape_get_step((_DWORD *)(a2 + 20));
    v15 = *(unsigned int *)v12;
    v16 = *((_DWORD *)v12 + 1);
    fi_shape_get_size((int *)(a2 + 40), (int *)&v94);
    v17 = v94 - v15;
    v94 -= v15;
    if (*(_DWORD *)(a2 + 36) == 4)
    {
      v18 = *(_DWORD *)(a2 + 28);
      if (*(_DWORD *)v12 == 2 * v18 - 2)
      {
        v80 = v16;
        v76 = a5;
        __dst = a4;
        v19 = *(float32x2_t **)(a2 + 240);
        v90 = v15 * step;
        v82 = v14;
        v84 = (float *)&v19[v15 * step];
        v88 = &v84[v15 * step];
        v20 = &v88[v17 + v15];
        bzero(v19, 8 * v15 * step);
        v86 = v20;
        bzero(v20, 8 * v15 + 4 * (3 * v15));
        if (v18)
        {
          for (i = 0; i != v18; ++i)
          {
            if (step)
            {
              v22 = v12[2];
              v23 = i;
              v24 = i;
              v25 = step;
              do
              {
                v19[v24].f32[0] = powf(*(float *)(a3 + 4 * v23), v22);
                v24 += v15;
                v23 += v18;
                --v25;
              }
              while (v25);
            }
          }
        }
        v27 = (uint64_t)v86;
        v26 = (uint64_t)&v84[v15 * step];
        fi_istft(v82, v86, (uint64_t)v19, v88, step, *((unsigned int *)v12 + 4), v15, v80);
        get_amp((uint64_t)v19, v84, v90);
        if (*((_DWORD *)v12 + 3))
        {
          v28 = 0;
          do
          {
            result = fi_stft((uint64_t)v82, v27, v26, (uint64_t)v19, v94, *((unsigned int *)v12 + 4), v15, v80);
            if ((_DWORD)result)
              return result;
            if (v90)
            {
              v30 = v19;
              v31 = v15 * step;
              v32 = (float *)&v19[v31];
              do
              {
                v33 = v30->f32[0];
                v34 = v30->f32[1];
                if (v34 == 0.0)
                {
                  v36 = v33 <= 0.0;
                  if (v33 != 0.0)
                  {
                    v37 = *v32;
                    if (v36)
                      v37 = -*v32;
                    v30->f32[0] = v37;
                  }
                }
                else
                {
                  v35 = Q_rsqrt((float)(v34 * v34) + (float)(v33 * v33));
                  if (v35 >= 10000000.0)
                    *v30 = 0;
                  else
                    *v30 = vmul_n_f32(*v30, v35 * *v32);
                }
                ++v32;
                ++v30;
                --v31;
              }
              while (v31);
            }
            v26 = (uint64_t)&v84[v15 * step];
            bzero(v88, 4 * (v94 + v15));
            v27 = (uint64_t)v86;
            result = fi_istft(v82, v86, (uint64_t)v19, v88, step, *((unsigned int *)v12 + 4), v15, v80);
            if ((_DWORD)result)
              return result;
          }
          while (++v28 < *((_DWORD *)v12 + 3));
        }
        v38 = v94 + v80;
        memmove(__dst, (const void *)(v26 + ((2 * v15) & 0x1FFFFFFFCLL)), 4 * (v94 + v80));
        result = 0;
        v39 = v76;
        *(_DWORD *)(a2 + 44) = v38;
LABEL_29:
        *(_DWORD *)(v39 + 20) = 1;
        return result;
      }
      v71 = *v14;
      goto LABEL_73;
    }
LABEL_70:
    v71 = *v14;
    v72 = "only support f32 input!";
    goto LABEL_74;
  }
  v95[0] = 0;
  v14 = *(uint64_t **)a2;
  v91 = fi_shape_get_step((_DWORD *)(a2 + 20));
  v40 = *(unsigned int *)v12;
  v41 = *((_DWORD *)v12 + 1);
  fi_shape_get_size((int *)(a2 + 40), (int *)v95);
  v95[0] -= v40;
  if (*(_DWORD *)(a2 + 36) != 4)
    goto LABEL_70;
  v85 = v14;
  v42 = *(unsigned int *)(a2 + 28);
  if (*(_DWORD *)v12 != 2 * (_DWORD)v42 - 2)
  {
    v71 = *v85;
LABEL_73:
    v72 = "wrong number of spec n_freqs!";
    goto LABEL_74;
  }
  v75 = a2;
  v77 = a5;
  v43 = *(char **)(a2 + 240);
  v44 = (uint64_t)&v43[8 * v40 * v91];
  v45 = v44 + 8 * v40 * v91;
  v83 = v40 * v91;
  v89 = v40;
  v81 = (float *)(v45 + 4 * v83);
  v74 = v41;
  if ((_DWORD)v40)
  {
    v46 = 0;
    v47 = (float)v89;
    do
    {
      *(float *)(v45 + 4 * v83 + 4 * v89 + 4 * v46) = window_function(*((_DWORD *)v12 + 4), (float)v46, v47);
      ++v46;
    }
    while (v89 != v46);
    v48 = 0;
    do
    {
      v81[v48] = (float)(v81[v89 + v48] * v81[v89 + v48]) * v47;
      ++v48;
    }
    while (v89 != v48);
  }
  __dsta = (float *)a4;
  bzero(v43, 4 * v83 + 8 * (2 * v83));
  if (v91)
  {
    v49 = 0;
    for (j = 0; j != v91; ++j)
    {
      if ((_DWORD)v42)
      {
        v51 = 0;
        v52 = j * v89;
        do
        {
          v53 = v12[2];
          if (v53 >= 1.751 || v53 <= 1.699)
          {
            v55 = *(float *)(a3 + 4 * (v49 + v51));
            if (v53 >= 1.501 || v53 <= 1.499)
              v54 = powf(v55, v53);
            else
              v54 = (float)(v55 * v55) * Q_rsqrt(v55);
          }
          else
          {
            v54 = Q_powf_1_75(*(float *)(a3 + 4 * (v49 + v51)));
          }
          v56 = 8 * (v51 + v52);
          *(float *)&v43[v56] = v54;
          *(float *)(v44 + v56) = v54;
          *(float *)(v45 + 4 * (v51++ + v52)) = v54;
        }
        while (v42 != v51);
      }
      v49 += v42;
    }
  }
  v57 = __dsta;
  if (!*((_DWORD *)v12 + 3))
  {
LABEL_66:
    result = fi_istft(v85, v81, v44, v57, v91, *((unsigned int *)v12 + 4), v89, v74);
    if ((_DWORD)result)
      return result;
    v70 = v95[0] + v74;
    memmove(v57, &v57[v89 >> 1], 4 * (v95[0] + v74));
    v39 = v77;
    *(_DWORD *)(v75 + 44) = v70;
    if (!v77)
      return 0;
    result = 0;
    goto LABEL_29;
  }
  v58 = 0;
  v59 = &v43[8 * v83];
  v60 = (float32x2_t)vdup_n_s32(0xBF51745C);
  v61 = (float32x2_t)vdup_n_s32(0x3FE8BA2Eu);
  while (1)
  {
    v87 = v58;
    result = fi_istft(v85, v81, v44, v57, v91, *((unsigned int *)v12 + 4), v89, v74);
    if ((_DWORD)result)
      return result;
    v62 = v57;
    result = fi_stft((uint64_t)v85, (uint64_t)v81, (uint64_t)v57, (uint64_t)v43, v95[0], *((unsigned int *)v12 + 4), v89, v74);
    if ((_DWORD)result)
      return result;
    if ((int)v83 >= 1)
    {
      v63 = 0;
      v64 = 16 * v83;
      do
      {
        v65 = *(float32x2_t *)&v59[v63];
        v66 = vmla_f32(vmul_f32(v65, v60), v61, *(float32x2_t *)&v43[v63]);
        *(float32x2_t *)&v59[v63] = vmul_f32(vsub_f32(v65, v66), (float32x2_t)0x3F0000003F000000);
        if (v66.f32[1] == 0.0)
        {
          if (v66.f32[0] != 0.0)
          {
            v69 = *(float *)&v43[v64];
            if (v66.f32[0] <= 0.0)
              v69 = -v69;
            v66.f32[0] = v69;
          }
          v68 = v66;
        }
        else
        {
          v93 = v66;
          v67 = Q_rsqrt(vmul_f32(v66, v66).f32[0] + (float)(v66.f32[1] * v66.f32[1]));
          v68 = 0;
          if (v67 < 10000000.0)
            v68 = vmul_n_f32(v93, v67 * *(float *)&v43[v64]);
        }
        *(float32x2_t *)&v59[v63] = vadd_f32(v68, *(float32x2_t *)&v59[v63]);
        v64 += 4;
        v63 += 8;
      }
      while (8 * v83 != v63);
    }
    ++v58;
    v57 = v62;
    if ((v87 + 1) >= *((_DWORD *)v12 + 3))
      goto LABEL_66;
  }
}

_QWORD *free_gl_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t gl_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t vars0;

  v8 = *(_DWORD **)(a1 + 120);
  v9 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v9;
  if (*(_DWORD *)a2 == 2)
  {
    v10 = 0;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = *v8 + (*(_DWORD *)(a2 + 4) - 1) * v8[1];
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently gl layer only support 2D input", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t gl_request_glbBuf(uint64_t a1)
{
  int *v2;
  int step;
  int v4;
  uint64_t result;
  int v6;
  int v7;
  int v8;

  v2 = *(int **)(a1 + 120);
  v8 = 0;
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v4 = *v2;
  result = fi_shape_get_size((int *)(a1 + 40), &v8);
  if (!(_DWORD)result)
  {
    v6 = v4 * step;
    if (v2[5])
      v7 = (4 * step + 20) * v4 + 16 * v6;
    else
      v7 = 4 * (v8 + v4 * (step + 4)) + 8 * (3 * v6 + v4);
    *(_DWORD *)(a1 + 248) = v7;
  }
  return result;
}

_QWORD *free_tacotron_stream(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[33]);
        fi_layer_free(v3[34]);
        fi_layer_free(v3[35]);
        fi_layer_free(v3[36]);
        fi_layer_free(v3[37]);
        fi_layer_free(v3[38]);
        fi_layer_free(v3[39]);
        fi_layer_free(v3[40]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_tacotron_stream(uint64_t *a1, int32x2_t *a2, uint64_t **a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  unsigned __int32 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int32x2_t v39;

  v7 = 0;
  v8 = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v17 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 376);
      v21 = v17;
      if (!v17)
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v34);
        v8 = 10;
        goto LABEL_12;
      }
      memcpy(v17, a2, 0x108uLL);
      *((_QWORD *)v21 + 41) = 0;
      *((_DWORD *)v21 + 90) = a2[28].i32[1];
      *((_QWORD *)v21 + 43) = 0;
      *((_QWORD *)v21 + 46) = 0;
      v37 = 0;
      v22 = a2[1].u32[0];
      v38 = 5;
      v39 = (int32x2_t)v22;
      if (create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 33)
        || (v39.i32[0] = a2[1].i32[1],
            v37 = 0x100000003,
            create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 34))
        || (v39.i32[0] = a2[2].i32[0],
            create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 35)))
      {
        v26 = "create pre dense failed!";
LABEL_9:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v34);
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron init failed!", v27, v28, v29, v35);
LABEL_12:
        *(_QWORD *)(v7 + 120) = v21;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron_stream init param failed!", v30, v31, v32, v36);
        goto LABEL_13;
      }
      v39.i32[0] = a2[26].i32[0];
      LODWORD(v37) = a2[10].i32[0] == 1;
      if (create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 40))
      {
        v26 = "create post dense failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (uint64_t)&a2[2] + 4, a3, a4, (uint64_t ***)v21 + 36))
      {
        v26 = "create encoder cbhg failed!";
        goto LABEL_9;
      }
      if (create_tacodecoder_layer(a1, (uint64_t)&a2[7], a4, (uint64_t *)v21 + 37))
      {
        v26 = "create decoder failed!";
        goto LABEL_9;
      }
      v38 = 3;
      v39 = vrev64_s32(a2[25]);
      if (create_lstm_layer(a1, &v38, &a2[18], a3, a4, v21 + 304))
      {
        v26 = "create LSTM1 layer failed!";
        goto LABEL_9;
      }
      if (create_lstm_layer(a1, &v38, &a2[21].u8[4], a3, a4, v21 + 312))
      {
        v26 = "create LSTM2 layer failed!";
        goto LABEL_9;
      }
      *(_QWORD *)(v7 + 120) = v21;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      v8 = 0;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_tacotron_stream;
      *(_QWORD *)(v7 + 136) = free_tacotron_stream;
      *(_QWORD *)(v7 + 144) = tacotron_stream_update_shape;
      *(_QWORD *)(v7 + 152) = tacotron_stream_wanted_wb_len;
      *(_QWORD *)(v7 + 184) = tacotron_stream_dispatch_weights;
      *(_DWORD *)(v7 + 8) = a5;
      *(_DWORD *)(v7 + 12) = 0;
      *(_QWORD *)(v7 + 160) = tacotron_stream_request_glbBuf;
      *(_QWORD *)(v7 + 168) = tacotron_stream_assign_glbBuf;
      *(_QWORD *)(v7 + 224) = tacotron_stream_update_param;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v34);
      v8 = 10;
    }
  }
LABEL_13:
  *a6 = v7;
  return v8;
}

uint64_t forward_tacotron_stream(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t bytes;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  const char *v31;
  float v33;
  float v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t v40;
  int v41;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  void *v46;
  uint64_t *v47;
  void *v48;
  uint64_t v49;
  unsigned int v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  size_t v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  void *v62;
  size_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  unsigned int padded_len;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t alignment;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  _DWORD *v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  unsigned int *v90;
  __n128 v91;
  uint64_t v92;
  char *v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t *v97;
  unsigned int v98;
  int v99;
  uint64_t (*v100)(void);
  uint64_t (*v101)(void);
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  const void *v122;
  uint64_t v123;
  float *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  unsigned int v132;
  uint64_t v133;
  float *v134;
  float v135;
  int *v136;
  int v137;
  _DWORD *v138;
  uint64_t v139;
  unsigned int *v140;
  size_t __len;
  unint64_t v142;
  unint64_t v143;
  char *v144;
  _DWORD *v145;
  size_t v146;
  unint64_t v147;
  int v148;
  uint64_t v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  char *__dst;
  uint64_t v155;
  unsigned int v156;
  _QWORD v157[2];
  int v158;
  uint64_t v159;
  int v160;
  int v161;
  uint64_t v162;
  uint64_t v163;

  v163 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)(a2 + 120);
  v11 = *(uint64_t **)a2;
  v155 = 0;
  v160 = 0;
  v159 = 0;
  v12 = *(_DWORD *)(a2 + 24);
  v13 = *(_DWORD *)(v10 + 60);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11[1] + 16))(v11[2], 1, 64);
  if (!v14)
  {
    log_OutText(*v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v139);
    return 10;
  }
  v18 = v14;
  v151 = a5;
  v152 = a1;
  v150 = v13;
  v153 = v10;
  __dst = a4;
  v19 = *(uint64_t **)a2;
  v20 = *(_QWORD *)(a2 + 120);
  LODWORD(v157[0]) = 0;
  v21 = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(v14 + 16) = v21;
  v22 = *(_DWORD *)(v20 + 224) * get_padded_len(*(unsigned int *)(v20 + 68), 8u);
  *(_QWORD *)(v18 + 24) = v21 + 4 * v22;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v20 + 296) + 40), v157);
  if ((_DWORD)bytes)
    goto LABEL_6;
  v27 = v22 + (get_padded_bytes(v157[0], 8u) >> 2);
  *(_QWORD *)(v18 + 32) = v21 + 4 * v27;
  v28 = get_padded_len((*(_DWORD *)(v20 + 208) * *(_DWORD *)(v20 + 212)), 8u) + v27;
  *(_QWORD *)(v18 + 40) = v21 + 4 * v28;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v20 + 304) + 40), v157);
  if ((_DWORD)bytes
    || (v29 = v28 + (get_padded_bytes(v157[0], 8u) >> 2),
        *(_QWORD *)(v18 + 48) = v21 + 4 * v29,
        bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v20 + 312) + 40), v157),
        (_DWORD)bytes)
    || (*(_QWORD *)(v18 + 56) = v21 + 4 * (v29 + (get_padded_bytes(v157[0], 8u) >> 2)),
        bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v20 + 296) + 216))(),
        (_DWORD)bytes))
  {
LABEL_6:
    v30 = *v19;
    v31 = "tacotron stream pack buf manager failed!";
LABEL_7:
    log_OutText(v30, (uint64_t)"FastInfer", 0, 0, (uint64_t)v31, v23, v24, v25, v139);
    goto LABEL_8;
  }
  *(_QWORD *)v18 = a3;
  *(_QWORD *)(v18 + 8) = __dst;
  if (v12 == 3)
  {
    v33 = *(float *)(a3 + 4 * (*(_DWORD *)(a2 + 28) + 1));
    v34 = *(float *)(a3 + 4);
    if (v33 < (float)(v34 + 0.0001) && v33 > (float)(v34 + -0.0001))
    {
      **(_DWORD **)(v153 + 368) = 1;
      v35 = *(_DWORD *)(v153 + 208);
      LODWORD(v159) = 1;
      HIDWORD(v159) = v35;
      *(_DWORD *)(v151 + 20) = 1;
      bytes = fi_shape_set(2, (uint64_t)&v159, 4, a2 + 40);
      if (!(_DWORD)bytes)
      {
        bzero(__dst, 4 * (HIDWORD(v159) * v159));
        **(_QWORD **)(v153 + 344) = 1;
        *(_DWORD *)(v153 + 356) = 10000;
      }
      goto LABEL_8;
    }
  }
  v36 = v153;
  if (!*(_DWORD *)(v153 + 328))
  {
    v44 = *(_QWORD *)(a2 + 120);
    *(_DWORD *)(v44 + 352) = *(_DWORD *)v44;
    *(_DWORD *)(v44 + 356) = 0;
    v45 = *(_DWORD **)(v44 + 368);
    *v45 = 0;
    if (!*(_DWORD *)(v44 + 332))
    {
      *(_DWORD *)(v44 + 360) = *(_DWORD *)(v44 + 228);
      *v45 = 1;
    }
    v46 = *(void **)(v18 + 24);
    v47 = *(uint64_t **)a2;
    v48 = *(void **)(a2 + 240);
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 264) + 40), (_DWORD *)&v155 + 1);
    if ((_DWORD)bytes)
      goto LABEL_8;
    bzero(v48, HIDWORD(v155));
    v49 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 264) + 128))(v152);
    if ((_DWORD)v49)
    {
      bytes = v49;
      v31 = "tacotron_stream pre dense o1 forward failed!";
    }
    else
    {
      bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 272) + 40), (_DWORD *)&v155 + 1);
      if ((_DWORD)bytes)
        goto LABEL_8;
      bzero(v46, HIDWORD(v155));
      v94 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 272) + 128))(v152);
      if ((_DWORD)v94)
      {
        bytes = v94;
        v31 = "tacotron_stream pre dense o2 forward failed!";
      }
      else
      {
        bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 280) + 40), (_DWORD *)&v155 + 1);
        if ((_DWORD)bytes)
          goto LABEL_8;
        bzero(v48, HIDWORD(v155));
        v110 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 280) + 128))(v152);
        if ((_DWORD)v110)
        {
          bytes = v110;
          v31 = "tacotron_stream pre dense o3 forward failed!";
        }
        else
        {
          bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v44 + 288) + 176))();
          if ((_DWORD)bytes)
            goto LABEL_8;
          bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 288) + 40), (_DWORD *)&v155 + 1);
          if ((_DWORD)bytes)
            goto LABEL_8;
          bzero(v46, HIDWORD(v155));
          v111 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 288) + 128))(v152);
          if (!(_DWORD)v111)
          {
            v36 = v153;
            if (v12)
            {
              v120 = 0;
              v121 = 0;
              v122 = (const void *)(*(_QWORD *)(a2 + 72) + 4 * (*(_DWORD *)(v153 + 4) * *(_DWORD *)v153));
              do
              {
                memcpy((void *)(*(_QWORD *)(v18 + 16) + 4 * (*(_DWORD *)(v153 + 68) * v121)), (const void *)(*(_QWORD *)(v18 + 24) + 4 * (v120 * *(_DWORD *)(v153 + 48))), 4 * (2 * *(_DWORD *)(v153 + 48)));
                memcpy((void *)(*(_QWORD *)(v18 + 16)+ 4 * (*(_DWORD *)(v153 + 68) * v121++)+ 4 * (2 * *(_DWORD *)(v153 + 48))), v122, 4 * *(unsigned int *)(v153 + 4));
                v120 += 2;
              }
              while (v12 != v121);
            }
            goto LABEL_17;
          }
          bytes = v111;
          v31 = "tacotron_stream encoder cbhg forward failed!";
        }
      }
    }
    v30 = *v47;
    goto LABEL_7;
  }
LABEL_17:
  v37 = *(_QWORD *)(v36 + 344);
  v38 = *(_QWORD *)(a2 + 120);
  LODWORD(v157[0]) = 0;
  v39 = *(_DWORD *)(v38 + 244);
  v147 = *(unsigned int *)(v38 + 240);
  v40 = *(unsigned int *)(a2 + 24);
  v41 = *(_DWORD *)(v38 + 56);
  v149 = *(unsigned int *)(v38 + 60);
  v42 = (4 * v41 * *(_DWORD *)(v38 + 212));
  v43 = *(_QWORD *)(v38 + 296);
  if (*(_DWORD *)(v38 + 328))
  {
    bytes = (*(uint64_t (**)(uint64_t, _QWORD))(v43 + 200))(v43, *(_QWORD *)(v18 + 56));
    if ((_DWORD)bytes)
      goto LABEL_8;
  }
  else
  {
    bytes = (*(uint64_t (**)(void))(v43 + 176))();
    if ((_DWORD)bytes)
      goto LABEL_8;
    bzero(*(void **)(v18 + 32), v42);
  }
  memcpy(__dst, *(const void **)(v18 + 32), v42);
  v50 = *(_DWORD *)(v38 + 356);
  LODWORD(v51) = *(_DWORD *)(v38 + 228);
  if (v50 < v51)
  {
    v146 = (4 * v149 * v41);
    __len = (v42 - v146);
    v144 = &__dst[v42];
    v143 = (v39 + v147);
    v142 = (7 * v40);
    v140 = (unsigned int *)(v37 + 8);
    v139 = v149 - 1;
    v148 = v149 * (v50 - v147);
    v52 = v152;
    v53 = *(unsigned int *)(v38 + 356);
    v54 = v42;
    v145 = (_DWORD *)(v37 + 4);
    while (1)
    {
      v55 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v38 + 296) + 128))(v52);
      if ((_DWORD)v55)
        goto LABEL_72;
      v56 = *(_DWORD *)(v38 + 212);
      if (v56)
      {
        v57 = *(_DWORD *)(v38 + 60);
        v58 = *(char **)(v18 + 32);
        if (v56 <= v57)
        {
          v64 = *(_QWORD *)(v18 + 24);
          v61 = (const void *)(v64
                             + 4 * get_padded_len(1, 8u)
                             + 4
                             * ((*(_DWORD *)(v38 + 60) - *(_DWORD *)(v38 + 212)) * *(_DWORD *)(v38 + 56)));
          v62 = v58;
          v63 = v54;
        }
        else
        {
          memmove(*(void **)(v18 + 32), &v58[4 * *(_DWORD *)(v38 + 56) * v57], __len);
          v59 = *(_QWORD *)(v18 + 24);
          v60 = *(_QWORD *)(v18 + 32)
              + 4 * ((*(_DWORD *)(v38 + 212) - *(_DWORD *)(v38 + 60)) * *(_DWORD *)(v38 + 56));
          v61 = (const void *)(v59 + 4 * get_padded_len(1, 8u));
          v62 = (void *)v60;
          v63 = v146;
        }
        memcpy(v62, v61, v63);
      }
      v65 = &v144[((v53 - *(_DWORD *)(v38 + 356)) * v146)];
      v66 = *(_QWORD *)(v18 + 24);
      padded_len = get_padded_len(1, 8u);
      memcpy(v65, (const void *)(v66 + 4 * padded_len), v146);
      alignment = get_alignment(*(_QWORD *)(v38 + 296), v68, v69, v70, v71, v72, v73, v74);
      if (v40 < 2)
      {
        v82 = 0;
        v84 = v147;
        v85 = v149;
        v86 = v145;
      }
      else
      {
        v82 = 0;
        v83 = 1;
        v84 = v147;
        v85 = v149;
        v86 = v145;
        do
        {
          if (*(float *)(alignment + 4 * v83) > *(float *)(alignment + 4 * v82))
            v82 = v83;
          ++v83;
        }
        while (v40 != v83);
      }
      if (v53 <= v84)
      {
        if (v53 == v84)
        {
          *v86 = 0;
          if (v85 >= 2)
          {
            v89 = v149 - 1;
            v90 = v140;
            do
            {
              *v90++ = v82;
              --v89;
            }
            while (v89);
          }
        }
      }
      else
      {
        if (v82 <= v86[((v53 - v84) * v85 - 1)])
          v82 = v86[((v53 - v84) * v85 - 1)];
        if ((_DWORD)v85)
        {
          v87 = v85;
          v88 = v148;
          do
          {
            v86[v88++] = v82;
            --v87;
          }
          while (v87);
        }
      }
      v91.n128_f32[0] = get_last_alignment(*(_QWORD *)(v38 + 296), (float *)v157, v76, v77, v78, v79, v80, v81);
      if ((_DWORD)v55)
      {
LABEL_72:
        bytes = v55;
        goto LABEL_8;
      }
      v52 = v152;
      if (v53 > v40 >> 2)
      {
        if (**(float **)(v18 + 24) > *(float *)(v38 + 232)
          || (v91.n128_u32[0] = v157[0], *(float *)v157 > *(float *)(v38 + 236)))
        {
LABEL_73:
          LODWORD(v53) = v53 + 1;
          v93 = __dst;
          bzero(&__dst[((v53 - *(_DWORD *)(v38 + 356)) * v146)], v146);
          **(_DWORD **)(v38 + 368) = 1;
LABEL_74:
          v92 = v153;
          LODWORD(v51) = *(_DWORD *)(v38 + 228);
          goto LABEL_75;
        }
        if (v53 <= v143)
        {
          if (v53 > v142)
            goto LABEL_73;
        }
        else if (v53 > v142 || v86[((v53 - v143) * v149)] == (_DWORD)v40 - 1)
        {
          goto LABEL_73;
        }
      }
      if (v53 >= *(unsigned int *)(v38 + 360)
        && v53 > ((int)v149 - 1 + *(_DWORD *)(v38 + 212)) / v149 + v84
        && v86[((v53 - v84) * v149)] > v86[((v53 - v84 - 1) * v149)])
      {
        break;
      }
      ++v53;
      v51 = *(unsigned int *)(v38 + 228);
      v148 += v149;
      if (v53 >= v51)
      {
        v92 = v153;
        v93 = __dst;
        goto LABEL_75;
      }
    }
    bytes = (*(uint64_t (**)(__n128))(*(_QWORD *)(v38 + 296) + 208))(v91);
    if (!(_DWORD)bytes)
    {
      **(_DWORD **)(v38 + 368) = 0;
      LODWORD(v53) = v53 + 1;
      v93 = __dst;
      goto LABEL_74;
    }
    goto LABEL_8;
  }
  v93 = __dst;
  LODWORD(v53) = *(_DWORD *)(v38 + 356);
  v92 = v153;
LABEL_75:
  if (v53 >= v51)
    **(_DWORD **)(v38 + 368) = 1;
  v95 = v53 - *(_DWORD *)(v92 + 356);
  v96 = *(_QWORD *)(a2 + 120);
  v97 = *(uint64_t **)a2;
  v157[0] = 0;
  v157[1] = 0;
  v158 = 0;
  v156 = 0;
  v98 = *(_DWORD *)(v96 + 56);
  v99 = *(_DWORD *)(v96 + 60) * v95;
  v161 = v99;
  v162 = v98;
  if ((*(_DWORD *)(v96 + 356) + v95) < *(_DWORD *)(v96 + 228) && **(_DWORD **)(v96 + 368) == 1)
  {
    bzero(&v93[4 * (*(_DWORD *)(v96 + 212) + v99) * v98], 4 * *(_DWORD *)(v96 + 212) * v98);
    v161 = *(_DWORD *)(v96 + 212) + v99;
  }
  bytes = fi_shape_set(2, (uint64_t)&v161, 4, (uint64_t)v157);
  if (!(_DWORD)bytes)
  {
    bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v96 + 304) + 144))();
    if (!(_DWORD)bytes)
    {
      bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v96 + 312) + 144))();
      if (!(_DWORD)bytes)
      {
        v100 = *(uint64_t (**)(void))(*(_QWORD *)(v96 + 304) + 160);
        if (!v100 || (bytes = v100(), !(_DWORD)bytes))
        {
          v101 = *(uint64_t (**)(void))(*(_QWORD *)(v96 + 312) + 160);
          if (!v101 || (bytes = v101(), !(_DWORD)bytes))
          {
            bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v96 + 304) + 40), &v156);
            if (!(_DWORD)bytes)
            {
              bzero(*(void **)(v18 + 40), v156);
              bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v96 + 312) + 40), &v156);
              if (!(_DWORD)bytes)
              {
                bzero(*(void **)(v18 + 48), v156);
                if (*(_DWORD *)(v96 + 328)
                  || (bytes = reset_lstm_layer_hidden(*(_QWORD *)(v96 + 304), v102, v103, v104, v105, v106, v107, v108),
                      !(_DWORD)bytes)
                  && (bytes = reset_lstm_layer_hidden(*(_QWORD *)(v96 + 312), v112, v113, v114, v115, v116, v117, v118),
                      !(_DWORD)bytes))
                {
                  v109 = forward_lstm_layer_f32(*(_QWORD *)(v96 + 304), (uint64_t)&v93[4 * *(_DWORD *)(v96 + 212) * *(_DWORD *)(v96 + 56)], *(_QWORD *)(v18 + 40));
                  if ((_DWORD)v109)
                  {
                    bytes = v109;
                    v31 = "tacotron_stream post lstm1 forward failed!";
LABEL_106:
                    v30 = *v97;
                    goto LABEL_7;
                  }
                  v119 = forward_lstm_layer_f32(*(_QWORD *)(v96 + 312), *(_QWORD *)(v18 + 40), *(_QWORD *)(v18 + 48));
                  if ((_DWORD)v119)
                  {
                    bytes = v119;
                    v31 = "tacotron_stream post lstm2 forward failed!";
                    goto LABEL_106;
                  }
                  if (*(_DWORD *)(v96 + 216))
                    axpy(v156 >> 2, *(float **)(v18 + 40), 1, *(float **)(v18 + 48), 1, 1.0);
                  bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v96 + 320) + 144))();
                  if ((_DWORD)bytes)
                    goto LABEL_8;
                  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v96 + 320) + 40), (_DWORD *)&v155 + 1);
                  if ((_DWORD)bytes)
                    goto LABEL_8;
                  if (*(_DWORD *)(v96 + 208) == *(_DWORD *)(v96 + 56))
                  {
                    v123 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v97[1] + 16))(v97[2], (unint64_t)HIDWORD(v155) >> 2, 4);
                    if (!v123)
                    {
                      bytes = 10;
                      v31 = "Memory allocation failed!";
                      goto LABEL_106;
                    }
                    v124 = (float *)v123;
                    v125 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v96 + 320) + 128))(v152);
                    if ((_DWORD)v125)
                    {
                      bytes = v125;
                      log_OutText(*v97, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron_stream post dense forward failed!", v126, v127, v128, v139);
                      goto LABEL_129;
                    }
                    axpy(HIDWORD(v155) >> 2, v124, 1, (float *)__dst, 1, 1.0);
                  }
                  else
                  {
                    bzero(__dst, HIDWORD(v155));
                    v129 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v96 + 320) + 128))(v152);
                    if ((_DWORD)v129)
                    {
                      bytes = v129;
                      v31 = "tacotron_stream post dense forward failed!";
                      goto LABEL_106;
                    }
                    v124 = 0;
                  }
                  if (*(_DWORD *)(v96 + 80) == 2 && *(_DWORD *)(v96 + 220) != 1)
                    relu_array_f32(HIDWORD(v155) >> 2, (float *)__dst);
                  if (!v124)
                  {
                    v130 = v153;
                    goto LABEL_132;
                  }
                  bytes = 0;
LABEL_129:
                  (*(void (**)(uint64_t, float *))(v97[1] + 48))(v97[2], v124);
                  v130 = v153;
                  if ((_DWORD)bytes)
                    goto LABEL_8;
LABEL_132:
                  if (*(_DWORD *)(v130 + 328) && (*(_DWORD *)(v153 + 356) || **(_DWORD **)(v153 + 368)))
                  {
                    v131 = 0;
                  }
                  else if (v95 * v150 >= (*(_DWORD *)(v153 + 212) + *(_DWORD *)(v153 + 240) * v150))
                  {
                    v131 = *(_DWORD *)(v153 + 212) + *(_DWORD *)(v153 + 240) * v150;
                  }
                  else
                  {
                    v131 = v95 * v150;
                  }
                  if (*(_DWORD *)(v153 + 220) == 1)
                  {
                    v132 = HIDWORD(v155) >> 2;
                    if (HIDWORD(v155) >= 4)
                    {
                      if (v132 <= 1)
                        v133 = 1;
                      else
                        v133 = v132;
                      v134 = (float *)__dst;
                      do
                      {
                        v135 = *v134;
                        if (*v134 > 1.0)
                          v135 = 1.0;
                        if (v135 < 0.0)
                          v135 = 0.0;
                        *v134++ = (float)(v135 * 11.513) + -9.2103;
                        --v133;
                      }
                      while (v133);
                    }
                    fast_exp((float *)__dst, v132, (float *)__dst);
                  }
                  v136 = (int *)(a2 + 40);
                  bytes = fi_shape_get_bytes(v136, &v155);
                  if (!(_DWORD)bytes)
                  {
                    if ((_DWORD)v155 != HIDWORD(v155))
                      *(_DWORD *)(v151 + 20) = 1;
                    LODWORD(v159) = v95 * v150 - v131;
                    if (**(_DWORD **)(v153 + 368) == 1)
                      LODWORD(v159) = *(_DWORD *)(v153 + 212) + v95 * v150 - v131;
                    HIDWORD(v159) = *(_DWORD *)(v153 + 208);
                    bytes = fi_shape_set(2, (uint64_t)&v159, 4, (uint64_t)v136);
                    if (!(_DWORD)bytes)
                    {
                      if (v131)
                        memmove(__dst, &__dst[4 * HIDWORD(v159) * v131], 4 * (v159 * HIDWORD(v159)));
                      v137 = (v53 - *(_DWORD *)(v153 + 240)) * v150;
                      v138 = *(_DWORD **)(v153 + 344);
                      *v138 = v137;
                      if (!**(_DWORD **)(v153 + 368))
                        *v138 = v137 - *(_DWORD *)(v153 + 212);
                      bytes = 0;
                      *(_DWORD *)(v153 + 356) = v53;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_8:
  (*(void (**)(uint64_t, uint64_t))(v11[1] + 48))(v11[2], v18);
  return bytes;
}

uint64_t tacotron_stream_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t result;
  int step;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _QWORD v28[2];
  int v29;
  _QWORD v30[2];
  int v31;
  int v32;
  unsigned int v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 120);
  v34 = 0;
  v5 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v5;
  v6 = *(_DWORD *)(v4 + 224);
  if (*(_DWORD *)(a1 + 24) > v6)
    *(_DWORD *)(a1 + 24) = v6;
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 264) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 272) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 280) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 288) + 144))();
        if (!(_DWORD)result)
        {
          v30[0] = 0;
          v30[1] = 0;
          v31 = 0;
          v28[0] = 0;
          v28[1] = 0;
          v29 = 0;
          step = fi_shape_get_step(a2);
          v9 = *(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 48);
          v32 = step;
          v33 = v9;
          result = fi_shape_set(2, (uint64_t)&v32, 4, (uint64_t)v28);
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 296) + 144))(*(_QWORD *)(v4 + 296), v28, v10, v11, v12, v13);
            if (!(_DWORD)result)
            {
              v14 = *(_DWORD *)(v4 + 56);
              v32 = *(_DWORD *)(v4 + 60) + *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 228) + *(_DWORD *)(v4 + 212);
              v33 = v14;
              result = fi_shape_set(2, (uint64_t)&v32, 4, (uint64_t)v30);
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 304) + 144))(*(_QWORD *)(v4 + 304), v30, v15, v16, v17, v18);
                if (!(_DWORD)result)
                {
                  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 312) + 144))(*(_QWORD *)(v4 + 312), *(_QWORD *)(v4 + 304) + 40, v19, v20, v21, v22);
                  if (!(_DWORD)result)
                  {
                    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 320) + 144))(*(_QWORD *)(v4 + 320), *(_QWORD *)(v4 + 312) + 40, v23, v24, v25, v26);
                    if (!(_DWORD)result)
                    {
                      v27 = *(_DWORD *)(v4 + 208);
                      if (v27 <= 0x100)
                        v27 = 256;
                      v33 = v27;
                      return fi_shape_set(2, (uint64_t)&v32, 4, a1 + 40);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacotron_stream_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_len;
  uint64_t result;
  int padded_bytes;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;

  v8 = *(_QWORD *)(a1 + 120);
  v22 = 0;
  if (v8)
  {
    padded_len = get_padded_len(*(unsigned int *)(v8 + 4), 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 264) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(HIDWORD(v22) + (padded_len << 9) + (int)v22, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 272) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(HIDWORD(v22) + (int)v22 + padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 280) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 288) + 152))();
          if (!(_DWORD)result)
          {
            v16 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v15, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 296) + 152))();
            if (!(_DWORD)result)
            {
              v17 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v16, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 304) + 152))();
              if (!(_DWORD)result)
              {
                v18 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v17, 8u);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 312) + 152))();
                if (!(_DWORD)result)
                {
                  v19 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v18, 8u);
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 320) + 152))();
                  if (!(_DWORD)result)
                  {
                    v20 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v19, 8u);
                    result = 0;
                    *a2 = v20;
                    *a3 = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v21);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t (*v14)(void);
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    result = tacotron_stream_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      v11 = 0;
      v12 = 0;
      v13 = v9 + 264;
      do
      {
        v14 = *(uint64_t (**)(void))(*(_QWORD *)(v13 + v11) + 160);
        if (v14)
        {
          result = v14();
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)(*(_QWORD *)(v13 + v11) + 248) > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v13 + v11) + 248);
        }
        v11 += 8;
      }
      while (v11 != 64);
      v15 = v18;
      padded_bytes = get_padded_bytes(v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes + v15;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    padded_bytes = get_padded_len(*(unsigned int *)(v8 + 4), 8u) << 9;
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 264), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 272), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 280), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 288), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 296), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 304), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 312), v9, &padded_bytes);
                if (!(_DWORD)result)
                {
                  padded_bytes = get_padded_bytes(padded_bytes, 8u);
                  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 320), v9, &padded_bytes);
                  if (!(_DWORD)result)
                  {
                    get_padded_bytes(padded_bytes, 8u);
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_assign_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t reserved_glbBuf_bytes;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(void);
  uint64_t v7;
  void (*v8)(void);
  uint64_t v9;
  void (*v10)(void);
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  void (*v14)(void);
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  void (*v18)(void);
  uint64_t v19;
  void (*v20)(void);
  unsigned int v22;

  v2 = *(_QWORD **)(a1 + 120);
  v22 = 0;
  reserved_glbBuf_bytes = tacotron_stream_get_reserved_glbBuf_bytes(a1, &v22);
  if (!(_DWORD)reserved_glbBuf_bytes)
  {
    v4 = v2[33];
    v5 = v22;
    *(_QWORD *)(v4 + 240) = *(_QWORD *)(a1 + 240) + v22;
    v6 = *(void (**)(void))(v4 + 168);
    if (v6)
      v6();
    v7 = v2[34];
    *(_QWORD *)(v7 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v8 = *(void (**)(void))(v7 + 168);
    if (v8)
      v8();
    v9 = v2[35];
    *(_QWORD *)(v9 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v10 = *(void (**)(void))(v9 + 168);
    if (v10)
      v10();
    v11 = v2[36];
    *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v12 = *(void (**)(void))(v11 + 168);
    if (v12)
      v12();
    v13 = v2[37];
    *(_QWORD *)(v13 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v14 = *(void (**)(void))(v13 + 168);
    if (v14)
      v14();
    v15 = v2[38];
    *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v16 = *(void (**)(void))(v15 + 168);
    if (v16)
      v16();
    v17 = v2[39];
    *(_QWORD *)(v17 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v18 = *(void (**)(void))(v17 + 168);
    if (v18)
      v18();
    v19 = v2[40];
    *(_QWORD *)(v19 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v20 = *(void (**)(void))(v19 + 168);
    if (v20)
      v20();
  }
  return reserved_glbBuf_bytes;
}

uint64_t tacotron_stream_update_param(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;
  int v9;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  if (a3 != 40)
    return 7;
  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(_DWORD *)(a2 + 20);
  if (v5 == 1)
  {
    v6 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(v4 + 328) = v6 == 0;
    *(_DWORD *)(v4 + 332) = 1;
    if (!v6)
    {
      result = 0;
      *(_DWORD *)(v4 + 360) = *(_DWORD *)(a2 + 28) / *(_DWORD *)(v4 + 60) + *(_DWORD *)(v4 + 356);
      v8 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)v4 = v8;
      *(_DWORD *)(v4 + 352) = v8;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 328) = 0;
    *(_DWORD *)(v4 + 332) = v5;
  }
  *(_DWORD *)(v4 + 360) = *(_DWORD *)(a2 + 28) / *(_DWORD *)(v4 + 60);
  v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)v4 = v9;
  *(_DWORD *)(v4 + 352) = v9;
  if (v5)
  {
    if (*(_DWORD *)(a2 + 24) != 1)
      return 0;
  }
  result = 0;
  *(_QWORD *)(v4 + 344) = *(_QWORD *)a2;
  *(_QWORD *)(v4 + 368) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t tacotron_stream_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  int v4;
  uint64_t result;
  int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  v4 = 4 * get_padded_len(*(unsigned int *)(v3 + 68), 8u) * *(_DWORD *)(v3 + 224);
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 296) + 40), &v7);
  if (!(_DWORD)result)
  {
    v6 = get_padded_bytes(v7, 8u) + v4;
    v4 = v6 + get_padded_bytes(4 * *(_DWORD *)(v3 + 212) * *(_DWORD *)(v3 + 208), 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 304) + 40), &v7);
    if (!(_DWORD)result)
    {
      v4 += get_padded_bytes(v7, 8u);
      result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 312) + 40), &v7);
      if (!(_DWORD)result)
      {
        v4 += get_padded_bytes(v7, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 296) + 216))();
        if (!(_DWORD)result)
          v4 += 4 * v7;
      }
    }
  }
  *a2 = v4;
  return result;
}

uint64_t create_multiband_lpcnet_layer(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  __int128 v56;
  __int128 v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 416);
    v16 = v12;
    if (v12)
    {
      v17 = *a2;
      v18 = a2[1];
      v19 = a2[3];
      *(_OWORD *)(v12 + 32) = a2[2];
      *(_OWORD *)(v12 + 48) = v19;
      *(_OWORD *)v12 = v17;
      *(_OWORD *)(v12 + 16) = v18;
      v20 = a2[4];
      v21 = a2[5];
      v22 = a2[7];
      *(_OWORD *)(v12 + 96) = a2[6];
      *(_OWORD *)(v12 + 112) = v22;
      *(_OWORD *)(v12 + 64) = v20;
      *(_OWORD *)(v12 + 80) = v21;
      v23 = a2[8];
      v24 = a2[9];
      v25 = a2[11];
      *(_OWORD *)(v12 + 160) = a2[10];
      *(_OWORD *)(v12 + 176) = v25;
      *(_OWORD *)(v12 + 128) = v23;
      *(_OWORD *)(v12 + 144) = v24;
      v26 = a2[12];
      v27 = a2[13];
      v28 = a2[14];
      *(_DWORD *)(v12 + 240) = *((_DWORD *)a2 + 60);
      *(_OWORD *)(v12 + 208) = v27;
      *(_OWORD *)(v12 + 224) = v28;
      *(_OWORD *)(v12 + 192) = v26;
      v58 = 0;
      v56 = 0u;
      v57 = 0u;
      if (a2)
      {
        v29 = *((_DWORD *)a2 + 25);
        v30 = *((_DWORD *)a2 + 26);
        LODWORD(v60) = 5;
        HIDWORD(v60) = v29;
        v61 = 0;
        v59 = v30 | 0x100000000;
        v31 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v12 + 264));
        if ((_DWORD)v31)
        {
          v35 = v31;
          v36 = *a1;
          v37 = "create feature_dense1 failed!";
        }
        else
        {
          v44 = *((_DWORD *)a2 + 28);
          HIDWORD(v60) = *((_DWORD *)a2 + 27);
          v59 = v44 | 0x100000000;
          v45 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 272));
          if ((_DWORD)v45)
          {
            v35 = v45;
            v36 = *a1;
            v37 = "create feature_dense2 failed!";
          }
          else
          {
            v46 = *((_DWORD *)a2 + 30);
            HIDWORD(v60) = *((_DWORD *)a2 + 29);
            v59 = v46 | 0x100000000;
            v47 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 280));
            if ((_DWORD)v47)
            {
              v35 = v47;
              v36 = *a1;
              v37 = "create gru_a_dense failed!";
            }
            else
            {
              HIDWORD(v60) = 2 * *((_DWORD *)a2 + 44);
              LODWORD(v59) = *((_DWORD *)a2 + 46);
              HIDWORD(v59) = 1;
              v48 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 288));
              if ((_DWORD)v48)
              {
                v35 = v48;
                v36 = *a1;
                v37 = "create dual_fc_a failed!";
              }
              else
              {
                v49 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 296));
                if ((_DWORD)v49)
                {
                  v35 = v49;
                  v36 = *a1;
                  v37 = "create dual_fc_b failed!";
                }
                else
                {
                  v50 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 304));
                  if ((_DWORD)v50)
                  {
                    v35 = v50;
                    v36 = *a1;
                    v37 = "create dual_fc_c failed!";
                  }
                  else
                  {
                    if (*((_DWORD *)a2 + 48) == 1)
                    {
                      HIDWORD(v60) = *((_DWORD *)a2 + 44);
                      LODWORD(v59) = *((_DWORD *)a2 + 47);
                      HIDWORD(v59) = 1;
                    }
                    v51 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 312));
                    if ((_DWORD)v51)
                    {
                      v35 = v51;
                      v36 = *a1;
                      v37 = "create dual_fc_d failed!";
                    }
                    else
                    {
                      v52 = config_conv1d_layer(*((_DWORD *)a2 + 20), *((_DWORD *)a2 + 19), 1, 1, 1, 1, *((_DWORD *)a2 + 21), &v56);
                      if ((_DWORD)v52)
                      {
                        v35 = v52;
                        v36 = *a1;
                        v37 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
                      }
                      else
                      {
                        v53 = create_conv1d_layer(a1, &v56, 0, a3, (uint64_t ***)(v16 + 248));
                        if ((_DWORD)v53)
                        {
                          v35 = v53;
                          v36 = *a1;
                          v37 = "create feature_conv1 layer failed!";
                        }
                        else
                        {
                          v54 = *((_DWORD *)a2 + 23);
                          v58 = *((_DWORD *)a2 + 24);
                          LODWORD(v56) = *((_DWORD *)a2 + 22);
                          LODWORD(v57) = v54;
                          v35 = create_conv1d_layer(a1, &v56, 0, a3, (uint64_t ***)(v16 + 256));
                          if (!(_DWORD)v35)
                          {
                            *(_QWORD *)v11 = a1;
                            *(_QWORD *)(v11 + 8) = 67;
                            *(_QWORD *)(v11 + 120) = v16;
                            *(_QWORD *)(v11 + 128) = forward_multiband_lpcnet_layer;
                            *(_QWORD *)(v11 + 136) = free_multiband_lpcnet;
                            *(_QWORD *)(v11 + 144) = multiband_lpcnet_update_shape;
                            *(_DWORD *)(v11 + 16) = 0;
                            *(_QWORD *)(v11 + 152) = multiband_lpcnet_wanted_wb_len;
                            *(_QWORD *)(v11 + 160) = multiband_lpcnet_request_glbBuf;
                            *(_QWORD *)(v11 + 184) = multiband_lpcnet_dispatch_weights;
                            *(_QWORD *)(v11 + 168) = multiband_lpcnet_assign_glbBuf;
                            *(_QWORD *)(v11 + 224) = multiband_lpcnet_update_param;
                            goto LABEL_32;
                          }
                          v36 = *a1;
                          v37 = "create feature_conv2 layer failed!";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        log_OutText(v36, (uint64_t)"FastInfer", 0, 0, (uint64_t)v37, v32, v33, v34, v56);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", v13, v14, v15, v56);
        v35 = 7;
      }
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"LPCNet init failed!", v41, v42, v43, v56);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v56);
      v35 = 10;
    }
    *(_QWORD *)(v11 + 120) = v16;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"multiband_lpcnet init param failed!", v38, v39, v40, v56);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v56);
    v35 = 10;
  }
LABEL_32:
  *a4 = v11;
  return v35;
}

uint64_t forward_multiband_lpcnet_layer(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int step;
  int padded_len;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  int v42;
  unint64_t v43;
  int v44;
  char v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t weights_via_offset;
  int v51;
  int padded_bytes;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  const char *v62;
  uint64_t *v63;
  int v64;
  BOOL v65;
  int v67;
  int v68;
  uint64_t v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  uint64_t *v76;
  _DWORD *v77;
  uint64_t v78;
  float *v79;
  uint64_t v80;
  uint64_t v81;
  float *v82;
  float *v83;
  uint64_t v84;
  float v85;
  float v86;
  float *v87;
  uint64_t v88;
  float v89;
  float *v90;
  _DWORD *v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  float32x4_t *v96;
  float32x2_t *v97;
  float32x2_t *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  float32x2_t *v103;
  float32x2_t *v104;
  float32_t v105;
  int8x16_t *v106;
  uint64_t v107;
  float *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  float32x2_t *v119;
  float32x2_t *v120;
  float32_t v121;
  float v122;
  uint64_t v123;
  float *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  _DWORD *v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  float v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  float32x2_t *v136;
  float32x2_t *v137;
  float32_t v138;
  uint64_t v139;
  float *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  float v146;
  uint64_t v147;
  uint64_t v148;
  float32x2_t *v149;
  float32x2_t *v150;
  float32_t v151;
  uint64_t v152;
  float *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t *v156;
  uint64_t v157;
  uint64_t v158;
  unsigned int v159;
  uint64_t v160;
  int v161;
  BOOL v162;
  float (*v163)(float);
  uint64_t (*v164)(float);
  unsigned int v165;
  float v166;
  BOOL v167;
  int v168;
  float *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  int v181;
  uint64_t v182;
  uint64_t (*v183)(_QWORD, uint64_t, float *, uint64_t, _QWORD);
  uint64_t v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  uint64_t v189;
  unsigned int v190;
  uint64_t v191;
  int v192;
  unint64_t v193;
  int v194;
  _BOOL4 v195;
  unint64_t v196;
  int v197;
  float v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  unsigned int v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  unsigned int v207;
  float v208;
  float *v209;
  float *v210;
  uint64_t v211;
  float v212;
  float v213;
  float v214;
  unsigned int v215;
  float v216;
  float *v217;
  uint64_t v218;
  float v219;
  unsigned int v220;
  float v221;
  float *v222;
  float v223;
  uint64_t i;
  int v225;
  int v226;
  int v227;
  int v228;
  float *v229;
  unsigned int v230;
  uint64_t v231;
  float *v232;
  int v233;
  float *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  unsigned int v244;
  uint64_t v245;
  int v246;
  unsigned int v247;
  uint64_t v248;
  unsigned int v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  unsigned int v267;
  unsigned int v268;
  uint64_t v269;
  unsigned int v270;
  uint64_t v271;
  int v272;
  float v273;
  _BOOL4 v274;
  unsigned int v275;
  unsigned int v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float v282;
  float v283;
  float v284;
  float v285;
  float v286;
  float v287;
  float v288;
  uint64_t v289;
  unint64_t v290;
  unint64_t v291;
  int v292;
  uint64_t v293;
  uint64_t v294;
  int v295;
  int v296;
  int v297;
  float v298;
  uint64_t j;
  float v300;
  unsigned int v301;
  unsigned int v302;
  int v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  int v308;
  unsigned int v309;
  uint64_t *v310;
  int v311;
  _DWORD *__dst;
  uint64_t v313;
  float (*v314)(float);
  int v315;
  unsigned int v316;
  size_t v317;
  unsigned int v318;
  unsigned int v319;
  float *v320;
  _DWORD *v321;
  float *v322;
  uint64_t v323;
  float *v324;
  int8x16_t *__src;
  float *__srca;
  int v327;
  char *v328;
  unsigned int v329;
  float *v330;
  unsigned int v331;
  unsigned int **v332;
  unsigned int v333;
  float *v334;
  unsigned int v335;
  float *v336;
  unsigned int v337;
  uint64_t v338;
  int v339;
  float *v340;
  char *v341;
  uint64_t v342;
  uint64_t (*v343)(float);
  unsigned int v344;
  uint64_t v345;
  uint64_t v346;
  _BOOL4 v347;
  int *v348;
  uint64_t v349;
  uint64_t *v350;
  int v351;
  uint64_t *v352;
  uint64_t v353;
  uint64_t *v354;
  unint64_t v355;
  __int128 v356;
  uint64_t v357;
  int32x4_t v358;
  int v359;
  int v360;
  int v361;
  int v362;
  _DWORD v363[4];
  uint64_t v364;

  v364 = *MEMORY[0x1E0C80C00];
  v9 = *(uint64_t **)a2;
  v10 = *(_QWORD *)(a2 + 120);
  v354 = 0;
  v11 = *(_DWORD *)(a2 + 24);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], 1, 352);
  if (!v15)
  {
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v304);
    weights_via_offset = 10;
    goto LABEL_33;
  }
  if (!*(_DWORD *)(v10 + 320))
    goto LABEL_9;
  v16 = *(_DWORD *)(v10 + 332);
  if ((v16 - 1) < 2)
    goto LABEL_6;
  if (v16)
  {
    if (v16 != 5)
    {
      weights_via_offset = 7;
      goto LABEL_33;
    }
LABEL_6:
    if (v11 >= 2)
      v11 -= 2;
    else
      v11 = 0;
  }
LABEL_9:
  v346 = a3;
  v348 = a4;
  v344 = v11;
  v345 = a5;
  v352 = v9;
  v353 = v10;
  v349 = a2;
  v350 = *(uint64_t **)a2;
  v17 = *(_QWORD *)(a2 + 120);
  v18 = *(_QWORD *)(a2 + 240);
  v19 = *(_DWORD *)(v17 + 36);
  v20 = *(_QWORD *)(a2 + 72);
  LODWORD(v355) = 0;
  v21 = *(_DWORD *)(v17 + 204);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  *(_QWORD *)(v15 + 16) = v18;
  padded_len = get_padded_len(*(unsigned int *)(v17 + 136), 8u);
  *(_QWORD *)(v15 + 24) = v18 + (4 * padded_len);
  v24 = get_padded_len(*(unsigned int *)(v17 + 152), 8u) + padded_len;
  *(_QWORD *)(v15 + 32) = v18 + (4 * v24);
  v25 = get_padded_len((3 * *(_DWORD *)(v17 + 172)), 8u) + v24;
  *(_QWORD *)(v15 + 40) = v18 + (4 * v25);
  v26 = get_padded_len((3 * *(_DWORD *)(v17 + 172)), 8u) + v25;
  *(_QWORD *)(v15 + 48) = v18 + (4 * v26);
  v27 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v26;
  *(_QWORD *)(v15 + 56) = v18 + (4 * v27);
  v28 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v27;
  *(_QWORD *)(v15 + 64) = v18 + (4 * v28);
  v29 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v28;
  *(_QWORD *)(v15 + 72) = v18 + (4 * v29);
  v30 = 12 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) + 4 * v29;
  *(_QWORD *)(v15 + 80) = v18 + v30;
  v31 = get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  *(_QWORD *)(v15 + 88) = v18 + (v30 + 4 * v31);
  v32 = get_padded_len((2 * *(_DWORD *)(v17 + 176)), 8u) + v31;
  *(_QWORD *)(v15 + 96) = v18 + (v30 + 4 * v32);
  v33 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v32;
  *(_QWORD *)(v15 + 104) = v18 + (v30 + 4 * v33);
  v34 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v33;
  *(_QWORD *)(v15 + 112) = v18 + (v30 + 4 * v34);
  v35 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v34;
  *(_QWORD *)(v15 + 120) = v18 + (v30 + 4 * v35);
  v36 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v35;
  *(_QWORD *)(v15 + 168) = v18 + (v30 + 4 * v36);
  v37 = get_padded_len((*(_DWORD *)(v17 + 44) * step * *(_DWORD *)(v17 + 56)), 8u) + v36;
  *(_QWORD *)(v15 + 152) = v18 + (v30 + 4 * v37);
  v38 = get_padded_len((*(_DWORD *)(v17 + 108) * step), 8u) + v37;
  v39 = v18 + (v30 + 4 * v38);
  *(_QWORD *)(v15 + 160) = v39;
  *(_QWORD *)(v15 + 128) = v39;
  v40 = get_padded_len((*(_DWORD *)(v17 + 80) * step), 8u) + v38;
  *(_QWORD *)(v15 + 136) = v18 + (v30 + 4 * v40);
  *(_QWORD *)(v15 + 144) = v18
                         + v30
                         + 4 * (get_padded_len((*(_DWORD *)(v17 + 92) * step), 8u) + v40);
  get_padded_len((*(_DWORD *)(v17 + 100) * step), 8u);
  v41 = *(_DWORD *)(v17 + 116);
  if (v41 <= *(_DWORD *)(v17 + 92) + *(_DWORD *)(v17 + 80) + *(_DWORD *)(v17 + 100))
    v41 = *(_DWORD *)(v17 + 92) + *(_DWORD *)(v17 + 80) + *(_DWORD *)(v17 + 100);
  if (v41 <= 0x14A)
    v41 = 330;
  *(_QWORD *)(v15 + 176) = v18 + v30 + 4 * (get_padded_len(v41 * step, 8u) + v38);
  get_padded_bytes((*(_DWORD *)(v17 + 24) & 0xFFFFFFF8)+ 8 * *(_DWORD *)(v17 + 44)+ (*(_DWORD *)(v17 + 24) & 0xFFFFFFFC)+ 4 * (*(_DWORD *)(v17 + 28) + v19)+ 2 * (*(_DWORD *)(v17 + 24) & 0xFFFFFFFC)+ 20, 8u);
  v42 = v355;
  v43 = (unint64_t)v355 >> 2;
  *(_QWORD *)(v15 + 184) = v20 + 4 * v43;
  v44 = *(_DWORD *)(v17 + 124) * get_padded_len(*(unsigned int *)(v17 + 116), 8u);
  if (v21 == 1)
    v45 = 1;
  else
    v45 = 2;
  *(_QWORD *)(v15 + 192) = v20 + 4 * (((v44 << v45) + (_DWORD)v43) & 0x3FFFFFFF);
  v46 = v44 + *(_DWORD *)(v17 + 128) * get_padded_len(*(unsigned int *)(v17 + 116), 8u);
  *(_QWORD *)(v15 + 200) = v20 + 4 * (((v46 << v45) + (_DWORD)v43) & 0x3FFFFFFF);
  LODWORD(v355) = v42
                + 4
                * ((v46 + *(_DWORD *)(v17 + 132) * get_padded_len(*(unsigned int *)(v17 + 116), 8u)) << v45);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 248), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 256), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 264), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 272), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 280), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 208) = v20 + (v355 & 0xFFFFFFFC);
  v51 = *(_DWORD *)(v17 + 140);
  LODWORD(v355) = v355 + 4 * (v51 + (get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) >> 4));
  padded_bytes = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 216) = v20 + (padded_bytes & 0xFFFFFFFC);
  LODWORD(v355) = padded_bytes + 12 * *(_DWORD *)(v17 + 136);
  v53 = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 224) = v20 + (v53 & 0xFFFFFFFC);
  LODWORD(v355) = v53 + (*(_DWORD *)(v17 + 140) << 6);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 232) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u);
  v54 = get_padded_bytes(v355, 8u);
  LODWORD(v355) = v54;
  v55 = *(_DWORD *)(v17 + 160);
  *(_QWORD *)(v15 + 240) = v20 + (v54 & 0xFFFFFFFC);
  if (v55 == 1)
  {
    LODWORD(v355) = v54 + (*(_DWORD *)(v17 + 164) << 6);
    v56 = get_padded_bytes(v355, 8u);
    *(_QWORD *)(v15 + 272) = v20 + (v56 & 0xFFFFFFFC);
    LODWORD(v355) = v56 + 4 * (*(_DWORD *)(v17 + 164) + ((3 * *(_DWORD *)(v17 + 152) + 15) >> 4));
    v57 = get_padded_bytes(v355, 8u);
    *(_QWORD *)(v15 + 288) = v20 + (v57 & 0xFFFFFFFC);
    LODWORD(v355) = v57 + (*(_DWORD *)(v17 + 168) << 6);
    v58 = get_padded_bytes(v355, 8u);
    *(_QWORD *)(v15 + 280) = v20 + (v58 & 0xFFFFFFFC);
    v59 = v58 + 4 * (*(_DWORD *)(v17 + 168) + ((3 * *(_DWORD *)(v17 + 152) + 15) >> 4));
  }
  else
  {
    v60 = *(_DWORD *)(v17 + 152);
    v59 = v355 + 12 * v60 * get_padded_len((*(_DWORD *)(v17 + 136) + *(_DWORD *)(v17 + 108)), 8u);
  }
  LODWORD(v355) = v59;
  LODWORD(v355) = get_padded_bytes(v59, 8u);
  *(_QWORD *)(v15 + 248) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 256) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 12 * get_padded_len(*(unsigned int *)(v17 + 152), 8u) * *(_DWORD *)(v17 + 152);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 264) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 288), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 296) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 296), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 304) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 304), v20, &v355);
  if ((_DWORD)weights_via_offset
    || (LODWORD(v355) = get_padded_bytes(v355, 8u),
        *(_QWORD *)(v15 + 312) = v20 + (v355 & 0xFFFFFFFC),
        LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180),
        weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 312), v20, &v355),
        (_DWORD)weights_via_offset))
  {
LABEL_30:
    v61 = *v350;
    v62 = "multiband_lpcnet pack buf manager failed!";
LABEL_31:
    log_OutText(v61, (uint64_t)"FastInfer", 0, 0, (uint64_t)v62, v47, v48, v49, v304);
    goto LABEL_32;
  }
  v67 = get_padded_bytes(v355, 8u);
  LODWORD(v355) = v67;
  if (*(_DWORD *)(v17 + 192))
  {
    *(_QWORD *)(v15 + 320) = 0;
  }
  else
  {
    *(_QWORD *)(v15 + 320) = v20 + (v67 & 0xFFFFFFFC);
    v67 = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
    LODWORD(v355) = v67;
  }
  *(_QWORD *)(v15 + 328) = v20 + (v67 & 0xFFFFFFFC);
  v68 = get_padded_len(4096, 8u);
  LODWORD(v355) = v355 + 4 * v68;
  *(_QWORD *)(v15 + 336) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 60), 8u) * *(_DWORD *)(v17 + 56);
  *(_QWORD *)(v15 + 344) = v20 + (v355 & 0xFFFFFFFC);
  get_padded_len(*(unsigned int *)(v17 + 36), 8u);
  *(_QWORD *)v15 = v346;
  *(_QWORD *)(v15 + 8) = v348;
  v69 = *(_QWORD *)(v349 + 120);
  if (*(_DWORD *)(v353 + 320))
  {
    v70 = *(const void **)(v69 + 336);
    if (v70)
      memcpy(*(void **)(v15 + 96), v70, 4 * *(unsigned int *)(v69 + 44));
    v71 = *(const void **)(v69 + 344);
    if (v71)
      memcpy(*(void **)(v15 + 104), v71, 4 * *(unsigned int *)(v69 + 44));
    v72 = *(const void **)(v69 + 352);
    if (v72)
      memcpy(*(void **)(v15 + 112), v72, 4 * *(unsigned int *)(v69 + 44));
    v73 = *(const void **)(v69 + 360);
    if (v73)
      memcpy(*(void **)(v15 + 120), v73, 4 * *(unsigned int *)(v69 + 44));
    v74 = *(const void **)(v69 + 368);
    if (v74)
      memcpy(*(void **)(v15 + 16), v74, 4 * *(unsigned int *)(v69 + 136));
    v75 = *(const void **)(v69 + 376);
    if (v75)
      memcpy(*(void **)(v15 + 24), v75, 4 * *(unsigned int *)(v69 + 152));
  }
  else
  {
    bzero(*(void **)(v15 + 96), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 104), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 112), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 120), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 16), 4 * *(unsigned int *)(v69 + 136));
    bzero(*(void **)(v15 + 24), 4 * *(unsigned int *)(v69 + 152));
  }
  v76 = *(uint64_t **)v349;
  v77 = *(_DWORD **)(v349 + 120);
  v311 = *(_DWORD *)(v349 + 24);
  v363[0] = 0;
  __dst = v77;
  weights_via_offset = opus_fft_alloc_twiddles(v76, v77[6] / v77[14], (uint64_t *)(*(_QWORD *)(v15 + 176) + 4 * v77[9]));
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  v310 = v76;
  v78 = v349;
  if (v311)
  {
    v351 = 0;
    do
    {
      v327 = __dst[11];
      v315 = __dst[14];
      v341 = *(char **)(v15 + 344);
      v79 = *(float **)(v15 + 176);
      v313 = *(_QWORD *)(v15 + 168);
      v80 = *(_QWORD *)(v78 + 120);
      v81 = *(unsigned int *)(v80 + 36);
      if ((_DWORD)v81)
      {
        v82 = (float *)(*(_QWORD *)v15 + 4 * (__dst[18] * v351));
        v83 = *(float **)(v15 + 176);
        v84 = *(unsigned int *)(v80 + 36);
        do
        {
          v85 = *v82++;
          v86 = v85;
          if (v85 > 1.0)
            v86 = 1.0;
          if (v86 < 0.0)
            v86 = 0.0;
          *v83++ = (float)(v86 * 11.513) + -9.2103;
          --v84;
        }
        while (v84);
      }
      fast_exp(v79, v81, v79);
      if ((_DWORD)v81)
      {
        v87 = v79;
        v88 = v81;
        v89 = 32768.0 / (float)*(unsigned int *)(v80 + 24);
        do
        {
          *v87 = v89 * *v87;
          ++v87;
          --v88;
        }
        while (v88);
      }
      else
      {
        v81 = 0;
      }
      v338 = v81;
      v90 = &v79[v81];
      v91 = *(_DWORD **)(v78 + 120);
      v92 = v91[7];
      v93 = v91[14];
      v94 = v91[6] / v93;
      v319 = ((int)v92 - 1) / v93;
      v95 = v319 + 1;
      v336 = v90 + 2;
      v317 = v91[11];
      v332 = (unsigned int **)v90;
      v334 = &v90[v317 + 3];
      v96 = (float32x4_t *)&v334[v317];
      v330 = &v96->f32[v92];
      v97 = (float32x2_t *)&v330[v94];
      v355 = 0;
      v98 = &v97[v95];
      v356 = xmmword_1DECEC700;
      v357 = 0;
      bzero(v96, 4 * v92);
      v321 = v91;
      v340 = v79;
      gemm(*(uint64_t **)v349, 1, v92, v91[9], v79, v341, v96, &v355, v304);
      v323 = 8 * v95;
      bzero(v97, 8 * v95);
      if (v319 != -1)
      {
        v99 = 0;
        do
        {
          v97[v99].f32[0] = v96->f32[v99] * v96->f32[v99];
          ++v99;
        }
        while (v95 != v99);
        v100 = 0;
        v101 = v319 + 1;
        do
        {
          v98[v100] = v97[v100];
          ++v100;
          --v101;
        }
        while (v101);
      }
      v102 = v319 + 1;
      if (v95 < v94)
      {
        do
        {
          v103 = &v98[(v94 - v102)];
          v104 = &v98[v102];
          v105 = -v103->f32[1];
          v104->i32[0] = v103->i32[0];
          v104->f32[1] = v105;
          ++v102;
        }
        while (v102 != v94);
      }
      v106 = (int8x16_t *)&v98[v94];
      opus_fft_c(*v332, &v97[v95], v106);
      *v330 = *(float *)v106->i32;
      v342 = 2 * v317;
      if (v94 >= 2)
      {
        v107 = v94 - 1;
        v108 = &v79[v92 + 4 + v338 + v342];
        v109 = 1;
        do
        {
          *v108++ = *(float *)&v106->i32[2 * (v94 - v109++)];
          --v107;
        }
        while (v107);
      }
      __src = (int8x16_t *)&v98[v94];
      v110 = (v317 + 1);
      if ((_DWORD)v317 != -1)
      {
        v111 = (uint64_t)&v340[v338 + 3];
        v112 = (v317 + 1);
        do
        {
          *(_DWORD *)(v111 - 4) = *(_DWORD *)(v111 + v342 * 4 + 4 * v92);
          v111 += 4;
          --v112;
        }
        while (v112);
      }
      v328 = (char *)(v313 + 4 * (v327 * v351 * v315));
      celt_lpc(v328, v334, v336, v317);
      bzero(v97, v323);
      if ((_DWORD)v95)
      {
        v113 = 0;
        v114 = v319 + 1;
        do
        {
          v115 = v96->f32[2 * v319 - v113];
          v97[v113++].f32[0] = v115 * v115;
          --v114;
        }
        while (v114);
        v116 = 0;
        v117 = v319 + 1;
        do
        {
          v98[v116] = v97[v116];
          ++v116;
          --v117;
        }
        while (v117);
      }
      v118 = v319 + 1;
      if (v95 < v94)
      {
        do
        {
          v119 = &v98[(v94 - v118)];
          v120 = &v98[v118];
          v121 = -v119->f32[1];
          v120->i32[0] = v119->i32[0];
          v120->f32[1] = v121;
          ++v118;
        }
        while (v118 != v94);
      }
      opus_fft_c(*v332, &v97[v95], __src);
      v122 = (float)v94;
      *v330 = *(float *)__src->i32 * (float)v94;
      if (v94 >= 2)
      {
        v123 = v94 - 1;
        v124 = &v340[v92 + 4 + v338 + v342];
        v125 = 1;
        do
        {
          *v124++ = *(float *)&__src->i32[2 * (v94 - v125++)] * v122;
          --v123;
        }
        while (v123);
      }
      if ((_DWORD)v317 != -1)
      {
        v126 = (uint64_t)&v340[v338 + 3];
        v127 = (v317 + 1);
        do
        {
          *(_DWORD *)(v126 - 4) = *(_DWORD *)(v126 + v342 * 4 + 4 * v92);
          v126 += 4;
          --v127;
        }
        while (v127);
      }
      celt_lpc(&v328[4 * v317], v334, v336, v317);
      v128 = v321;
      if (v321[49] == 1)
      {
        bzero(v97, v323);
        v129 = v351;
        if ((_DWORD)v95)
        {
          v130 = 0;
          v131 = v319 + 1;
          do
          {
            v132 = v96->f32[2 * v319 + v130];
            v97[v130++].f32[0] = v132 * v132;
            --v131;
          }
          while (v131);
          v133 = 0;
          v134 = v319 + 1;
          do
          {
            v98[v133] = v97[v133];
            ++v133;
            --v134;
          }
          while (v134);
        }
        v135 = v319 + 1;
        if (v95 < v94)
        {
          do
          {
            v136 = &v98[(v94 - v135)];
            v137 = &v98[v135];
            v138 = -v136->f32[1];
            v137->i32[0] = v136->i32[0];
            v137->f32[1] = v138;
            ++v135;
          }
          while (v135 != v94);
        }
        opus_fft_c(*v332, &v97[v95], __src);
        *v330 = *(float *)__src->i32 * v122;
        if (v94 >= 2)
        {
          v139 = v94 - 1;
          v140 = &v340[v92 + 4 + v338 + v342];
          v141 = 1;
          do
          {
            *v140++ = *(float *)&__src->i32[2 * (v94 - v141++)] * v122;
            --v139;
          }
          while (v139);
        }
        if ((_DWORD)v317 != -1)
        {
          v142 = (uint64_t)&v340[v338 + 3];
          v143 = (v317 + 1);
          do
          {
            *(_DWORD *)(v142 - 4) = *(_DWORD *)(v142 + v342 * 4 + 4 * v92);
            v142 += 4;
            --v143;
          }
          while (v143);
        }
        celt_lpc(&v328[4 * (2 * v317)], v334, v336, v317);
        v128 = v321;
      }
      else
      {
        bzero(&v328[4 * (2 * v317)], v317);
        v129 = v351;
      }
      if (v128[50] == 1)
      {
        bzero(v97, v323);
        if ((_DWORD)v95)
        {
          v144 = 0;
          v145 = v319 + 1;
          do
          {
            v146 = v96->f32[4 * v319 - v144];
            v97[v144++].f32[0] = v146 * v146;
            --v145;
          }
          while (v145);
          v147 = 0;
          v148 = v319 + 1;
          do
          {
            v98[v147] = v97[v147];
            ++v147;
            --v148;
          }
          while (v148);
        }
        if (v95 < v94)
        {
          do
          {
            v149 = &v98[(v94 - v95)];
            v150 = &v98[v95];
            v151 = -v149->f32[1];
            v150->i32[0] = v149->i32[0];
            v150->f32[1] = v151;
            ++v95;
          }
          while (v95 != v94);
        }
        opus_fft_c(*v332, v98, __src);
        *v330 = *(float *)__src->i32 * v122;
        if (v94 >= 2)
        {
          v152 = v94 - 1;
          v153 = &v340[v92 + 4 + v338 + v342];
          v154 = 1;
          do
          {
            *v153++ = *(float *)&__src->i32[2 * (v94 - v154++)] * v122;
            --v152;
          }
          while (v152);
        }
        v78 = v349;
        if ((_DWORD)v317 != -1)
        {
          v155 = (uint64_t)&v340[v338 + 3];
          do
          {
            *(_DWORD *)(v155 - 4) = *(_DWORD *)(v155 + v342 * 4 + 4 * v92);
            v155 += 4;
            --v110;
          }
          while (v110);
        }
        celt_lpc(&v328[4 * (3 * v317)], v334, v336, v317);
      }
      else
      {
        bzero(&v328[4 * (3 * v317)], v317);
        v78 = v349;
      }
      v351 = v129 + 1;
    }
    while (v129 + 1 != v311);
  }
  v156 = (uint64_t *)(*(_QWORD *)(v15 + 176) + 4 * __dst[9]);
  v157 = *v156;
  if (*v156)
  {
    if (*(_QWORD *)(v157 + 48))
    {
      (*(void (**)(uint64_t))(v310[1] + 80))(v310[2]);
      *(_QWORD *)(v157 + 48) = 0;
    }
    if ((*(_DWORD *)(v157 + 8) & 0x80000000) != 0 && *(_QWORD *)(v157 + 56))
    {
      (*(void (**)(uint64_t))(v310[1] + 80))(v310[2]);
      *(_QWORD *)(v157 + 56) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v310[1] + 80))(v310[2], v157);
    *v156 = 0;
  }
  weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 31) + 40), v363);
  v76 = v310;
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  bzero(*(void **)(v15 + 128), v363[0]);
  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 31) + 128))(0);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 32) + 40), v363);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  bzero(*(void **)(v15 + 136), v363[0]);
  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 32) + 128))(0);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  axpy((__dst[18] * v311), *(float **)v15, 1, *(float **)(v15 + 136), 1, 1.0);
  weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 33) + 40), v363);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  bzero(*(void **)(v15 + 144), v363[0]);
  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 33) + 128))(0);
  if ((_DWORD)weights_via_offset
    || (weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 34) + 40), v363),
        (_DWORD)weights_via_offset)
    || (bzero(*(void **)(v15 + 152), v363[0]),
        weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 34) + 128))(0),
        (_DWORD)weights_via_offset)
    || (weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 35) + 40), v363),
        (_DWORD)weights_via_offset)
    || (bzero(*(void **)(v15 + 160), v363[0]),
        weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 35) + 128))(0),
        (_DWORD)weights_via_offset))
  {
LABEL_164:
    v61 = *v76;
    v62 = "multiband_lpcnet forward frame network failed!";
    goto LABEL_31;
  }
  v158 = *(_QWORD *)(v349 + 120);
  v159 = *(_DWORD *)(v349 + 24);
  v160 = *(_QWORD *)(v15 + 8);
  v324 = *(float **)(v15 + 104);
  __srca = *(float **)(v15 + 96);
  v320 = *(float **)(v15 + 120);
  v322 = *(float **)(v15 + 112);
  v161 = *(_DWORD *)(v158 + 124);
  v162 = v161 == 256;
  if (v161 == 256)
    v163 = ulaw2lin8;
  else
    v163 = ulaw2lin7;
  v314 = v163;
  v164 = lin2ulaw7;
  if (v162)
    v164 = lin2ulaw8;
  v343 = v164;
  v165 = *(_DWORD *)(v158 + 320);
  if (v165)
  {
    weights_via_offset = 7;
    v335 = *(_DWORD *)(v158 + 392);
    v337 = *(_DWORD *)(v158 + 396);
    v331 = *(_DWORD *)(v158 + 400);
    v333 = *(_DWORD *)(v158 + 404);
    v166 = *(float *)(v158 + 408);
    v9 = v352;
    v10 = v353;
    switch(*(_DWORD *)(v158 + 332))
    {
      case 0:
        v318 = 0;
        v165 = v159 - 2;
        if (v159 < 2)
          v165 = 0;
        goto LABEL_184;
      case 1:
        v165 = v159 - 4;
        if (v159 < 4)
          v165 = 0;
        v167 = v159 >= 2;
        v159 -= 2;
        if (!v167)
          v159 = 0;
        v318 = 2;
        goto LABEL_184;
      case 2:
      case 5:
        v167 = v159 >= 2;
        v159 -= 2;
        if (!v167)
          v159 = 0;
        v318 = 2;
        v165 = v159;
        goto LABEL_184;
      case 3:
      case 4:
        goto LABEL_33;
      default:
        goto LABEL_32;
    }
    goto LABEL_33;
  }
  v318 = 0;
  v166 = 0.0;
  v331 = *(_DWORD *)(v158 + 132) >> 1;
  v337 = v331;
  v333 = v331;
  v335 = v331;
LABEL_184:
  v309 = v318 + v159;
  if (v318 >= v318 + v159)
  {
LABEL_261:
    v301 = *(_DWORD *)(v353 + 12);
    if (v301 == 22050)
    {
      v302 = *(_DWORD *)(v353 + 16) * v344;
    }
    else
    {
      v9 = v352;
      weights_via_offset = src_generate(v352, 0xBu, v301 / 0x7D0, (uint64_t *)&v354);
      v10 = v353;
      if ((_DWORD)weights_via_offset)
        goto LABEL_33;
      if (*(_DWORD *)(v353 + 320) == 1 && *(_DWORD *)(v353 + 332))
        memcpy((void *)v354[4], *(const void **)(v353 + 384), 4 * *((unsigned int *)v354 + 10));
      v302 = src_filt(v354, v348, *(_DWORD *)(v353 + 16) * v344, *(_QWORD *)(v15 + 160));
      memcpy(v348, *(const void **)(v15 + 160), 4 * v302);
      if (*(_DWORD *)(v353 + 320) == 1)
      {
        v303 = *(_DWORD *)(v353 + 332);
        if (v303 != 2 && v303 != 5)
          memcpy(*(void **)(v353 + 384), (const void *)v354[4], 4 * *((unsigned int *)v354 + 10));
      }
    }
    weights_via_offset = 0;
    *(_DWORD *)(v349 + 44) = v302;
    *(_DWORD *)(v345 + 20) = 1;
    goto LABEL_32;
  }
  v168 = 0;
  v308 = v318 + v165 - 1;
  while (1)
  {
    v169 = (float *)(*(_QWORD *)(v15 + 152) + 4 * *(_DWORD *)(v158 + 108) * v318);
    memcpy(*(void **)(v15 + 80), *(const void **)(v15 + 248), 4 * (3 * *(_DWORD *)(v158 + 152)));
    if (*(_DWORD *)(v158 + 160) == 1)
      sparse_sgemv_accum16(*(_QWORD *)(v15 + 80), *(_QWORD *)(v15 + 288), (3 * *(_DWORD *)(v158 + 152)), *(_QWORD *)(v15 + 280), v169);
    else
      gemm_ex(*(uint64_t **)v349, 1, 3 * *(_DWORD *)(v158 + 152), *(_DWORD *)(v158 + 108), v169, *(unsigned int *)(v158 + 108), (char *)(*(_QWORD *)(v15 + 240) + 4 * *(unsigned int *)(v158 + 136)), *(unsigned int *)(v158 + 148), *(float32x4_t **)(v15 + 80), 3 * *(_DWORD *)(v158 + 152), 0);
    if (*(_DWORD *)(v158 + 204) == 1)
      break;
LABEL_195:
    v193 = *(unsigned int *)(v158 + 36);
    if ((_DWORD)v193)
    {
      v194 = *(_DWORD *)(v158 + 40);
      if (*(float *)(*(_QWORD *)v15 + 4 * v194 * v318) > 0.01)
      {
        v195 = 1;
LABEL_202:
        v347 = v195;
        goto LABEL_204;
      }
      v196 = 0;
      v197 = v194 * v318 + 1;
      while (v193 - 1 != v196)
      {
        v198 = *(float *)(*(_QWORD *)v15 + 4 * (v197 + v196++));
        if (v198 > 0.01)
        {
          v195 = v196 < v193;
          goto LABEL_202;
        }
      }
    }
    bzero(*(void **)(v15 + 16), 4 * *(unsigned int *)(v158 + 136));
    bzero(*(void **)(v15 + 24), 4 * *(unsigned int *)(v158 + 152));
    v347 = 0;
LABEL_204:
    v199 = *(_DWORD *)(v158 + 56);
    if (v199 <= *(_DWORD *)(v158 + 16))
    {
      v329 = 0;
      do
      {
        v339 = v168;
        v355 = 0;
        *(_QWORD *)&v356 = 0;
        if (*(_DWORD *)(v158 + 208) == 1)
          v316 = *(_DWORD *)(v158 + 152) / v199;
        else
          v316 = 0;
        v200 = *(_DWORD *)(v158 + 132) >> 1;
        v358 = vdupq_n_s32(v200);
        v201 = v200;
        v202 = v200;
        v203 = v200;
        if (v347)
        {
          v204 = *(unsigned int *)(v158 + 44);
          if ((_DWORD)v204)
          {
            v205 = *(_QWORD *)(v15 + 168);
            v206 = v318 * v199 * v204;
            v207 = v204 + v206;
            v208 = 0.0;
            v210 = v324;
            v209 = __srca;
            v211 = *(unsigned int *)(v158 + 44);
            v212 = 0.0;
            do
            {
              v213 = *v209++;
              v212 = v212 - (float)(v213 * *(float *)(v205 + 4 * v206));
              v214 = *v210++;
              v208 = v208 - (float)(v214 * *(float *)(v205 + 4 * v207++));
              ++v206;
              --v211;
            }
            while (v211);
            v355 = __PAIR64__(LODWORD(v208), LODWORD(v212));
            if (*(_DWORD *)(v158 + 196) == 1)
            {
              v215 = v204 * (v318 * v199 + 2);
              v216 = 0.0;
              v217 = v322;
              v218 = v204;
              do
              {
                v219 = *v217++;
                v216 = v216 - (float)(v219 * *(float *)(v205 + 4 * v215++));
                --v218;
              }
              while (v218);
              *(float *)&v356 = v216;
            }
            if (*(_DWORD *)(v158 + 200) == 1)
            {
              v220 = v204 * (v318 * v199 + 3);
              v221 = 0.0;
              v222 = v320;
              do
              {
                v223 = *v222++;
                v221 = v221 - (float)(v223 * *(float *)(v205 + 4 * v220++));
                --v204;
              }
              while (v204);
              *((float *)&v356 + 1) = v221;
            }
          }
          else
          {
            LODWORD(v355) = 0;
          }
          for (i = 0; i != 16; i += 4)
            *(int *)((char *)&v359 + i) = v343(*(float *)((char *)&v355 + i));
          v225 = v343(*__srca);
          v226 = v343(*v324);
          v227 = v343(*v322);
          v228 = v343(*v320);
          v229 = *(float **)(v15 + 32);
          v230 = *(_DWORD *)(v158 + 116);
          v231 = *(_QWORD *)(v15 + 184);
          v232 = (float *)(v231 + 4 * v230 * v225);
          v233 = *(_DWORD *)(v158 + 124);
          v234 = (float *)(v231 + 4 * (v233 + v226) * v230);
          if (*(_DWORD *)(v158 + 204) == 1)
          {
            accum4(v230, v232, v234, (float *)(*(_QWORD *)(v15 + 192) + 4 * v359 * v230), (float *)(*(_QWORD *)(v15 + 192) + 4 * (v360 + *(_DWORD *)(v158 + 128)) * v230), *(float **)(v15 + 48));
            accum4(*(_DWORD *)(v158 + 116), (float *)(*(_QWORD *)(v15 + 200) + 4 * *(_DWORD *)(v158 + 116) * v335), (float *)(*(_QWORD *)(v15 + 200) + 4 * (*(_DWORD *)(v158 + 132) + v337) * *(_DWORD *)(v158 + 116)), (float *)(*(_QWORD *)(v15 + 160) + 4 * *(_DWORD *)(v158 + 116) * v318), *(float **)(v15 + 48), v229);
            multiband_lpcnet_compute_sparse_gru_a(v349, v15);
            multiband_lpcnet_compute_gru_b(v349, v15);
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 288), v15, *(float **)(v15 + 296), *(_QWORD *)(v15 + 24), v235, v236, v237, v238, v304);
            v203 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (v339 & 0xFFF)));
            v358.i32[0] = v203;
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 296), v15, *(float **)(v15 + 304), *(_QWORD *)(v15 + 24) + 4 * ((2 * *(_DWORD *)(v158 + 152)) / *(_DWORD *)(v158 + 56)), v239, v240, v241, v242, v305);
            v202 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 1) & 0xFFF)));
            v358.i32[1] = v202;
            v243 = *(_QWORD *)(v15 + 72);
            v244 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
            v201 = sample_cdf(v243 + 4 * v244, *(_DWORD *)(v158 + 176), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 2) & 0xFFF)));
            v358.i32[2] = v201;
            v245 = *(_QWORD *)(v15 + 72);
            v246 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
            v200 = sample_cdf(v245 + 4 * (2 * v246), *(_DWORD *)(v158 + 176), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 3) & 0xFFF)));
          }
          else
          {
            accum4(v230, v232, v234, (float *)(v231 + 4 * (v227 + 2 * v233) * v230), (float *)(v231 + 4 * (3 * v233 + v228) * v230), *(float **)(v15 + 48));
            v247 = *(_DWORD *)(v158 + 116);
            v248 = *(_QWORD *)(v15 + 192);
            accum4(v247, (float *)(v248 + 4 * v359 * v247), (float *)(v248 + 4 * (v360 + *(_DWORD *)(v158 + 128)) * v247), (float *)(v248 + 4 * (v361 + 2 * *(_DWORD *)(v158 + 128)) * v247), (float *)(v248 + 4 * (v362 + 3 * *(_DWORD *)(v158 + 128)) * v247), *(float **)(v15 + 56));
            v249 = *(_DWORD *)(v158 + 116);
            v250 = *(_QWORD *)(v15 + 200);
            accum4(v249, (float *)(v250 + 4 * v249 * v335), (float *)(v250 + 4 * (*(_DWORD *)(v158 + 132) + v337) * v249), (float *)(v250 + 4 * (v331 + 2 * *(_DWORD *)(v158 + 132)) * v249), (float *)(v250 + 4 * (3 * *(_DWORD *)(v158 + 132) + v333) * v249), *(float **)(v15 + 64));
            accum4(*(_DWORD *)(v158 + 116), (float *)(*(_QWORD *)(v15 + 160) + 4 * *(_DWORD *)(v158 + 116) * v318), *(float **)(v15 + 48), *(float **)(v15 + 56), *(float **)(v15 + 64), v229);
            multiband_lpcnet_compute_sparse_gru_a(v349, v15);
            multiband_lpcnet_compute_gru_b(v349, v15);
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 288), v15, *(float **)(v15 + 296), *(_QWORD *)(v15 + 24), v251, v252, v253, v254, v304);
            v203 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (v339 & 0xFFF)));
            v358.i32[0] = v203;
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 296), v15, *(float **)(v15 + 304), *(_QWORD *)(v15 + 24) + 4 * v316, v255, v256, v257, v258, v306);
            v202 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 1) & 0xFFF)));
            v358.i32[1] = v202;
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 304), v15, *(float **)(v15 + 312), *(_QWORD *)(v15 + 24) + 8 * v316, v259, v260, v261, v262, v307);
            v201 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 2) & 0xFFF)));
            v358.i32[2] = v201;
            if (*(_DWORD *)(v158 + 192))
            {
              bzero(*(void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
              v186 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v158 + 312) + 128))(0);
              if ((_DWORD)v186)
                goto LABEL_264;
            }
            else
            {
              multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 312), v15, *(float **)(v15 + 320), *(_QWORD *)(v15 + 24) + 12 * v316, v263, v264, v265, v266, v304);
            }
            v200 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 3) & 0xFFF)));
          }
          v358.i32[3] = v200;
        }
        v267 = *(_DWORD *)(v158 + 124);
        v333 = v200;
        v268 = *(_DWORD *)(v158 + 176);
        v331 = v201;
        v337 = v202;
        v335 = v203;
        if (v267 != v268)
        {
          v269 = 0;
          v270 = v267 / v268;
          v271 = *(_QWORD *)(v15 + 328);
          do
          {
            v272 = v358.i32[v269] * v270;
            v358.i32[v269] = v272;
            v273 = *(float *)(v271 + 4 * (((_WORD)v339 + (_WORD)v269) & 0xFFF));
            v274 = v347;
            if (v273 >= 0.7)
              v274 = 0;
            if (v274)
            {
              v275 = v272 + (float)(v273 * (float)v270);
              v276 = *(_DWORD *)(v158 + 128);
              if (v275 >= v276)
                v275 = v276 - 1;
              v358.i32[v269] = v275;
            }
            ++v269;
          }
          while (v269 != 4);
          v337 = v358.u32[1];
          v335 = v358.i32[0];
          v333 = v358.u32[3];
          v331 = v358.u32[2];
        }
        v277 = *(float *)&v355;
        v278 = *(float *)(v158 + 212);
        v279 = v277 + (float)(v278 * v314((float)v335));
        *(float *)v363 = v279;
        v280 = *((float *)&v355 + 1);
        v281 = *(float *)(v158 + 216);
        v282 = v280 + (float)(v281 * v314((float)v337));
        *(float *)&v363[1] = v282;
        v283 = *(float *)&v356;
        v284 = *(float *)(v158 + 220);
        v285 = v283 + (float)(v284 * v314((float)v331));
        *(float *)&v363[2] = v285;
        v286 = *((float *)&v356 + 1);
        v287 = *(float *)(v158 + 224);
        v288 = v286 + (float)(v287 * v314((float)v333));
        *(float *)&v363[3] = v288;
        memmove(__srca + 1, __srca, 4 * (*(_DWORD *)(v158 + 44) - 1));
        memmove(v324 + 1, v324, 4 * (*(_DWORD *)(v158 + 44) - 1));
        memmove(v322 + 1, v322, 4 * (*(_DWORD *)(v158 + 44) - 1));
        memmove(v320 + 1, v320, 4 * (*(_DWORD *)(v158 + 44) - 1));
        v289 = 0;
        v290 = 0;
        *__srca = v279;
        *v324 = v282;
        *v322 = v285;
        *v320 = v288;
        v291 = *(unsigned int *)(v158 + 60);
        do
        {
          v292 = get_padded_len(v291, 8u);
          v363[v290] = 0;
          v291 = *(unsigned int *)(v158 + 60);
          if (v290 < v291)
          {
            v293 = 0;
            v295 = v292 + v290;
            v296 = v292 + v290 + 2 * v292;
            v297 = v290 + 2 * v292;
            v298 = 0.0;
            do
            {
              v294 = *(_QWORD *)(v15 + 336);
              v298 = (float)((float)((float)(v298
                                           + (float)(*(float *)(v294 + v289 + 4 * v293)
                                                   * *(float *)(*(_QWORD *)(v15 + 96) + v293)))
                                   + (float)(*(float *)(v294 + 4 * (v295 + v293))
                                           * *(float *)(*(_QWORD *)(v15 + 104) + v293)))
                           + (float)(*(float *)(v294 + 4 * (v297 + v293))
                                   * *(float *)(*(_QWORD *)(v15 + 112) + v293)))
                   + (float)(*(float *)(v294 + 4 * (v296 + v293))
                           * *(float *)(*(_QWORD *)(v15 + 120) + v293));
              v293 += 4;
            }
            while (v290 + v293 < v291);
            *(float *)&v363[v290] = v298;
          }
          ++v290;
          v289 += 4;
        }
        while (v290 != 4);
        for (j = 0; j != 4; ++j)
        {
          v166 = *(float *)&v363[j] + (float)(*(float *)(v158 + 52) * v166);
          if (v166 >= -32767.0)
            v300 = v166;
          else
            v300 = -32767.0;
          if (v300 > 32767.0)
            v300 = 32767.0;
          *(float *)&v363[j] = v300;
          *(float *)(v160 + 4 * (v339 + j)) = v300 * 0.000030518;
        }
        v199 = *(_DWORD *)(v158 + 56);
        v168 = v339 + 4;
        ++v329;
      }
      while (v329 < *(_DWORD *)(v158 + 16) / v199);
      v168 = v339 + 4;
    }
    if (v318 == v308 && *(_DWORD *)(v158 + 320))
    {
      *(_DWORD *)(v158 + 392) = v335;
      *(_DWORD *)(v158 + 396) = v337;
      *(_DWORD *)(v158 + 400) = v331;
      *(_DWORD *)(v158 + 404) = v333;
      *(float *)(v158 + 408) = v166;
      memcpy(*(void **)(v158 + 336), __srca, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 344), v324, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 352), v322, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 360), v320, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 368), *(const void **)(v15 + 16), 4 * *(unsigned int *)(v158 + 136));
      memcpy(*(void **)(v158 + 376), *(const void **)(v15 + 24), 4 * *(unsigned int *)(v158 + 152));
    }
    if (++v318 == v309)
      goto LABEL_261;
  }
  multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 304), v15, *(float **)(v15 + 312), (uint64_t)v169, v170, v171, v172, v173, v304);
  v174 = *(_QWORD *)(v15 + 72);
  v175 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  memcpy((void *)(v174 + 4 * v175), *(const void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
  if (!*(_DWORD *)(v158 + 192))
  {
    multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 312), v15, *(float **)(v15 + 320), (uint64_t)v169, v176, v177, v178, v179, v304);
    v187 = *(_QWORD *)(v15 + 72);
    v188 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    memcpy((void *)(v187 + 4 * (2 * v188)), *(const void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
    goto LABEL_194;
  }
  v180 = *(_QWORD *)(v15 + 72);
  v181 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  bzero((void *)(v180 + 4 * (2 * v181)), 4 * *(unsigned int *)(v158 + 176));
  v182 = *(_QWORD *)(v158 + 312);
  v183 = *(uint64_t (**)(_QWORD, uint64_t, float *, uint64_t, _QWORD))(v182 + 128);
  v184 = *(_QWORD *)(v15 + 72);
  v185 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  v186 = v183(0, v182, v169, v184 + 4 * (2 * v185), 0);
  if (!(_DWORD)v186)
  {
LABEL_194:
    v189 = *(_QWORD *)(v15 + 72);
    v190 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    prepare_cdf((float *)(v189 + 4 * v190), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48));
    v191 = *(_QWORD *)(v15 + 72);
    v192 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    prepare_cdf((float *)(v191 + 4 * (2 * v192)), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48));
    goto LABEL_195;
  }
LABEL_264:
  weights_via_offset = v186;
LABEL_32:
  v9 = v352;
  v10 = v353;
LABEL_33:
  v63 = v354;
  if (v354)
  {
    if (*v354)
    {
      (*(void (**)(uint64_t, _QWORD))(v9[1] + 48))(v9[2], *v354);
      *v354 = 0;
      *v354 = 0;
      v63 = v354;
    }
    if (v63[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v63[4]);
      v354[4] = 0;
    }
    (*(void (**)(uint64_t))(v9[1] + 48))(v9[2]);
    v354 = 0;
  }
  if (v15)
    (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v15);
  if ((_DWORD)weights_via_offset
    || *(_DWORD *)(v10 + 320) == 1 && ((v64 = *(_DWORD *)(v10 + 332), v64 != 5) ? (v65 = v64 == 2) : (v65 = 1), v65))
  {
    if (*(_QWORD *)(v10 + 336))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 336) = 0;
    }
    if (*(_QWORD *)(v10 + 368))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 368) = 0;
    }
    if (*(_QWORD *)(v10 + 376))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 376) = 0;
    }
    if (*(_QWORD *)(v10 + 384))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 384) = 0;
    }
  }
  return weights_via_offset;
}

uint64_t multiband_lpcnet_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  __int128 v11;
  unsigned int v12;
  uint64_t result;
  int v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD v17[2];
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 120);
  v17[0] = 0;
  v17[1] = 0;
  v18 = 0;
  v21 = 0;
  if (*a2 != 2)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently multiband_lpcnet layer only support 2D input", a6, a7, a8, v16);
    return 7;
  }
  v11 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v11;
  v12 = *(_DWORD *)(v9 + 72);
  v19 = a2[1];
  v20 = v12;
  fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 248) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 256) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 264) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 272) + 144))();
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 280) + 144))();
          if (!(_DWORD)result)
          {
            v19 = 1;
            v14 = *(_DWORD *)(v9 + 208);
            v15 = *(_DWORD *)(v9 + 152);
            if (*(_DWORD *)(v9 + 204) == 1)
            {
              if (v14 == 1)
                v15 = 2 * v15 / *(_DWORD *)(v9 + 56);
              v20 = v15;
              result = fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 288) + 144))();
                if (!(_DWORD)result)
                {
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 296) + 144))();
                  if (!(_DWORD)result)
                  {
                    v20 = *(_DWORD *)(*(_QWORD *)(v9 + 272) + 48);
                    result = fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
                    if (!(_DWORD)result)
                    {
LABEL_21:
                      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 304) + 144))();
                      if (!(_DWORD)result)
                      {
                        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 312) + 144))();
                        if (!(_DWORD)result)
                        {
                          result = 0;
                          *(_DWORD *)(a1 + 40) = 1;
                          *(_DWORD *)(a1 + 44) = 330 * a2[1];
                          *(_DWORD *)(a1 + 56) = 4;
                        }
                      }
                    }
                  }
                }
              }
            }
            else
            {
              if (v14 == 1)
                v15 /= *(_DWORD *)(v9 + 56);
              v20 = v15;
              fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 288) + 144))();
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 296) + 144))();
                if (!(_DWORD)result)
                  goto LABEL_21;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

_QWORD *free_multiband_lpcnet(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[31]);
        fi_layer_free(v3[32]);
        fi_layer_free(v3[33]);
        fi_layer_free(v3[34]);
        fi_layer_free(v3[35]);
        fi_layer_free(v3[36]);
        fi_layer_free(v3[37]);
        fi_layer_free(v3[38]);
        fi_layer_free(v3[39]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t multiband_lpcnet_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v11;
  int padded_len;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t result;
  char v19;
  unsigned int padded_bytes;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v11 = *(_DWORD *)(v8 + 204);
    padded_len = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    v13 = *(_DWORD *)(v8 + 124);
    v14 = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    v15 = *(_DWORD *)(v8 + 128);
    v16 = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    v17 = *(_DWORD *)(v8 + 132);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 248) + 152))();
    if (!(_DWORD)result)
    {
      v19 = v11 == 1 ? 1 : 2;
      padded_bytes = get_padded_bytes(4 * ((v13 * padded_len + v15 * v14 + v17 * v16) << v19), 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 256) + 152))();
      if (!(_DWORD)result)
      {
        v21 = get_padded_bytes(padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 264) + 152))();
        if (!(_DWORD)result)
        {
          v22 = get_padded_bytes(v21, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 272) + 152))();
          if (!(_DWORD)result)
          {
            v23 = get_padded_bytes(v22, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 280) + 152))();
            if (!(_DWORD)result)
            {
              v24 = get_padded_bytes(v23, 8u);
              v25 = *(_DWORD *)(v8 + 140);
              v26 = get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              v27 = get_padded_bytes(v24 + 4 * (v25 + (v26 >> 4)), 8u);
              v28 = get_padded_bytes(v27 + 12 * *(_DWORD *)(v8 + 136), 8u);
              v29 = get_padded_bytes(v28 + (*(_DWORD *)(v8 + 140) << 6), 8u);
              v30 = get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              if (*(_DWORD *)(v8 + 160) == 1)
              {
                v31 = get_padded_bytes(v29 + 4 * v30 + (*(_DWORD *)(v8 + 164) << 6), 8u);
                v32 = get_padded_bytes(v31 + 4 * (*(_DWORD *)(v8 + 164) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4)), 8u);
                v29 = get_padded_bytes(v32 + (*(_DWORD *)(v8 + 168) << 6), 8u);
                v33 = *(_DWORD *)(v8 + 168) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4);
              }
              else
              {
                v34 = *(_DWORD *)(v8 + 152);
                v33 = 3 * v34 * get_padded_len((*(_DWORD *)(v8 + 136) + *(_DWORD *)(v8 + 108)), 8u) + v30;
              }
              v35 = get_padded_bytes(v29 + 4 * v33, 8u);
              v36 = get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              v37 = get_padded_len(*(unsigned int *)(v8 + 152), 8u);
              v38 = 3 * *(_DWORD *)(v8 + 152);
              v39 = get_padded_len(v38, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 288) + 152))();
              if (!(_DWORD)result)
              {
                v40 = get_padded_bytes(v35 + 4 * (v36 + v38 * v37 + v39), 8u);
                v41 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                v42 = *(_DWORD *)(v8 + 180);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 296) + 152))();
                if (!(_DWORD)result)
                {
                  v43 = get_padded_bytes(v40 + 4 * v41 * v42, 8u);
                  v44 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                  v45 = *(_DWORD *)(v8 + 180);
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 304) + 152))();
                  if (!(_DWORD)result)
                  {
                    v46 = get_padded_bytes(v43 + 4 * v44 * v45, 8u);
                    v47 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                    v48 = *(_DWORD *)(v8 + 180);
                    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 312) + 152))();
                    if (!(_DWORD)result)
                    {
                      v49 = get_padded_bytes(v46 + 4 * v47 * v48, 8u);
                      if (!*(_DWORD *)(v8 + 192))
                        v49 += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                      v50 = get_padded_len(4096, 8u);
                      v51 = v50 + *(_DWORD *)(v8 + 56) * get_padded_len(*(unsigned int *)(v8 + 60), 8u);
                      v52 = get_padded_len(*(unsigned int *)(v8 + 36), 8u);
                      result = 0;
                      *a2 = v49 + 4 * (v51 + *(_DWORD *)(v8 + 28) * v52);
                      *a3 = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ERROR: param is NULL in wanted_wb_len(multiband_lpcnet)!", a6, a7, a8, v53);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t result;
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = v9 + 248;
    multiband_lpcnet_get_reserved_glbBuf_bytes(a1, &v18);
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *(uint64_t (**)(void))(*(_QWORD *)(v10 + v11) + 160);
      if (v13)
      {
        result = v13();
        if ((_DWORD)result)
          return result;
        if (*(_DWORD *)(*(_QWORD *)(v10 + v11) + 248) > v12)
          v12 = *(_DWORD *)(*(_QWORD *)(v10 + v11) + 248);
      }
      v11 += 8;
    }
    while (v11 != 72);
    v15 = v18;
    padded_bytes = get_padded_bytes(v12, 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes + v15;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  char v12;
  int v13;
  uint64_t result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int padded_len;
  uint64_t v20;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    v10 = *(_DWORD *)(v8 + 204);
    v11 = *(_DWORD *)(v8 + 124) * get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    if (v10 == 1)
      v12 = 1;
    else
      v12 = 2;
    v13 = v11 + *(_DWORD *)(v8 + 128) * get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    padded_bytes = 4
                 * ((v13 + *(_DWORD *)(v8 + 132) * get_padded_len(*(unsigned int *)(v8 + 116), 8u)) << v12);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 248), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 256), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 264), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 272), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 280), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              v15 = *(_DWORD *)(v8 + 140);
              padded_bytes += 4
                            * (v15 + (get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u) >> 4));
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + 12 * *(_DWORD *)(v8 + 136);
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 140) << 6);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              v16 = get_padded_bytes(padded_bytes, 8u);
              padded_bytes = v16;
              if (*(_DWORD *)(v8 + 160) == 1)
              {
                padded_bytes = v16 + (*(_DWORD *)(v8 + 164) << 6);
                padded_bytes = get_padded_bytes(padded_bytes, 8u)
                             + 4 * (*(_DWORD *)(v8 + 164) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4));
                padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 168) << 6);
                v17 = get_padded_bytes(padded_bytes, 8u)
                    + 4 * (*(_DWORD *)(v8 + 168) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4));
              }
              else
              {
                v18 = *(_DWORD *)(v8 + 152);
                v17 = padded_bytes
                    + 12 * v18 * get_padded_len((*(_DWORD *)(v8 + 136) + *(_DWORD *)(v8 + 108)), 8u);
              }
              padded_bytes = v17;
              padded_bytes = get_padded_bytes(v17, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 12 * get_padded_len(*(unsigned int *)(v8 + 152), 8u) * *(_DWORD *)(v8 + 152);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 288), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 296), v9, &padded_bytes);
                if (!(_DWORD)result)
                {
                  padded_bytes = get_padded_bytes(padded_bytes, 8u);
                  padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 304), v9, &padded_bytes);
                  if (!(_DWORD)result)
                  {
                    padded_bytes = get_padded_bytes(padded_bytes, 8u);
                    padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 312), v9, &padded_bytes);
                    if (!(_DWORD)result)
                    {
                      padded_bytes = get_padded_bytes(padded_bytes, 8u);
                      padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                      padded_len = get_padded_len(4096, 8u);
                      padded_bytes += 4 * padded_len;
                      padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 60), 8u) * *(_DWORD *)(v8 + 56);
                      get_padded_len(*(unsigned int *)(v8 + 36), 8u);
                      return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(void);
  uint64_t result;
  uint64_t v11;
  unsigned int v12;

  v2 = *(_QWORD *)(a1 + 120) + 248;
  v12 = 0;
  multiband_lpcnet_get_reserved_glbBuf_bytes(a1, &v12);
  v6 = 0;
  v7 = v12;
  while (1)
  {
    v8 = *(_QWORD *)(v2 + v6);
    if (!v8)
      break;
    *(_QWORD *)(v8 + 240) = *(_QWORD *)(a1 + 240) + v7;
    v9 = *(uint64_t (**)(void))(v8 + 168);
    if (v9)
    {
      result = v9();
      if ((_DWORD)result)
        return result;
    }
    v6 += 8;
    if (v6 == 72)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v3, v4, v5, v11);
  return 10;
}

float multiband_lpcnet_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  float result;

  if (*(_DWORD *)(a1 + 8) == a4 && a3 == 88)
  {
    v4 = *(_QWORD *)(a1 + 120);
    v5 = *a2;
    v6 = a2[1];
    *(_DWORD *)(v4 + 320) = *a2;
    *(_DWORD *)(v4 + 332) = v6;
    if (v5 == 1 && v6 == 0)
    {
      *(_OWORD *)(v4 + 336) = *(_OWORD *)(a2 + 2);
      *(_OWORD *)(v4 + 352) = *(_OWORD *)(a2 + 6);
      *(_OWORD *)(v4 + 368) = *(_OWORD *)(a2 + 10);
      *(_QWORD *)(v4 + 384) = *((_QWORD *)a2 + 7);
      *(int32x4_t *)(v4 + 392) = vdupq_n_s32(*(_DWORD *)(v4 + 132) >> 1);
      result = *((float *)a2 + 20);
      *(float *)(v4 + 408) = result;
    }
  }
  return result;
}

uint64_t multiband_lpcnet_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  int step;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t result;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int padded_len;
  int v22;

  v2 = *(_DWORD **)(a1 + 120);
  v22 = v2[9];
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(v2[34], 8u);
  v20 = get_padded_len(v2[38], 8u);
  v19 = get_padded_len((3 * v2[43]), 8u);
  v18 = get_padded_len((3 * v2[34]), 8u);
  v17 = get_padded_len((3 * v2[34]), 8u);
  v16 = get_padded_len((3 * v2[34]), 8u);
  v15 = get_padded_len((3 * v2[43]), 8u);
  v4 = get_padded_len(v2[44], 8u);
  v5 = get_padded_len((3 * v2[38]), 8u);
  v6 = get_padded_len((2 * v2[44]), 8u);
  v7 = get_padded_len(v2[11], 8u);
  v8 = v2[14];
  v9 = get_padded_len((v8 * step * v2[11]), 8u);
  v10 = get_padded_len((v2[27] * step), 8u);
  v11 = v2[29];
  if (v11 <= v2[23] + v2[20] + v2[25])
    v11 = v2[23] + v2[20] + v2[25];
  if (v11 <= 0x14A)
    v11 = 330;
  v12 = 12 * v4;
  v13 = get_padded_len(v11 * step, 8u);
  result = get_padded_bytes((v2[6] & 0xFFFFFFF8)+ 8 * v2[11]+ (v2[6] & 0xFFFFFFFC)+ 4 * (v2[7] + v22)+ 2 * (v2[6] & 0xFFFFFFFC)+ 20, 8u);
  *a2 = v12 + 4 * (v20 + padded_len + v19 + v18 + v17 + v16 + v15 + v5 + v6 + v8 * v7 + v9 + v10 + v13) + result;
  return result;
}

float multiband_lpcnet_compute_dual_fc(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t *v12;
  unint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float result;

  v12 = *(uint64_t **)a1;
  v13 = *(unsigned int *)(a1 + 12);
  v14 = *(void **)(a2 + 88);
  v15 = *(void **)(a2 + 72);
  bzero(v14, 4 * (v13 & 0xFFFFFFFE));
  if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t, void *, _QWORD))(a1 + 128))(0, a1, a4, v14, 0))
  {
    log_OutText(*v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)"multiband_lpcnet forward dual_fc failed!", v16, v17, v18, a9);
  }
  else
  {
    bzero(v15, 4 * (v13 >> 1));
    return fi_multiply_multiply_add_ansic((float *)v14, a3, (float *)v14 + (v13 >> 1), &a3[v13 >> 1], (float *)v15, v13 >> 1);
  }
  return result;
}

float multiband_lpcnet_compute_sparse_gru_a(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  float *v4;
  float *v5;
  void *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  float *v10;

  v3 = *(_QWORD *)(a1 + 120);
  v4 = *(float **)(a2 + 16);
  v5 = *(float **)(a2 + 32);
  v6 = *(void **)(a2 + 40);
  v7 = *(unsigned int *)(v3 + 136);
  memcpy(v6, *(const void **)(a2 + 232), 4 * (3 * v7));
  v8 = 0;
  v9 = 3;
  do
  {
    fi_multiply_add_ansic((float *)v6 + v8, (float *)(*(_QWORD *)(a2 + 216) + 4 * v8), v4, v7);
    v8 += v7;
    --v9;
  }
  while (v9);
  v10 = &v5[v7];
  sparse_sgemv_accum16(v6, *(_QWORD *)(a2 + 224), (3 * v7), *(_QWORD *)(a2 + 208), v4);
  axpy((2 * v7), (float *)v6, 1, v5, 1, 1.0);
  fi_activate_array(v5, (2 * v7), 11);
  fi_multiply_add_ansic(&v10[v7], (float *)v6 + (2 * v7), v10, v7);
  fi_activate_array(&v10[v7], v7, *(_DWORD *)(v3 + 144));
  fill_array_f32(v10, v7, 1.0);
  axpy(v7, v5, 1, v10, 1, -1.0);
  return fi_multiply_multiply_add_ansic(v4, v5, &v10[v7], v10, v4, v7);
}

float multiband_lpcnet_compute_gru_b(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  _DWORD *v4;
  char *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  float *v9;
  float *v10;
  uint64_t v12;
  float *v13;

  v3 = *(uint64_t **)a1;
  v4 = *(_DWORD **)(a1 + 120);
  v5 = *(char **)(a2 + 240);
  v6 = *(float32x4_t **)(a2 + 32);
  v13 = *(float **)(a2 + 24);
  v7 = *(float32x4_t **)(a2 + 40);
  v8 = v4[38];
  memcpy(v6, *(const void **)(a2 + 80), 4 * (3 * v8));
  v9 = *(float **)(a2 + 16);
  if (v4[40] == 1)
    sparse_sgemv_accum16(v6, v5, (3 * v8), *(_QWORD *)(a2 + 272), v9);
  else
    gemm_ex(v3, 1, 3 * v8, v4[34], v9, v4[34], v5, v4[37], v6, 3 * v8, 0);
  v10 = &v6->f32[v8];
  memcpy(v7, *(const void **)(a2 + 264), 4 * (3 * v8));
  gemm(v3, 1, 3 * v8, v8, v13, *(char **)(a2 + 256), v7, 0, v12);
  axpy((2 * v8), v7->f32, 1, v6->f32, 1, 1.0);
  fi_activate_array(v6->f32, (2 * v8), 11);
  fi_multiply_add_ansic(&v10[v8], &v7->f32[(2 * v8)], v10, v8);
  fi_activate_array(&v10[v8], v8, v4[39]);
  fill_array_f32(v10, v8, 1.0);
  axpy(v8, v6->f32, 1, v10, 1, -1.0);
  return fi_multiply_multiply_add_ansic(v13, v6->f32, &v10[v8], v10, v13, v8);
}

_QWORD *free_tacotron(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[24]);
        fi_layer_free(v3[25]);
        fi_layer_free(v3[26]);
        fi_layer_free(v3[27]);
        fi_layer_free(v3[28]);
        fi_layer_free(v3[29]);
        fi_layer_free(v3[30]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_tacotron(uint64_t *a1, __int128 *a2, uint64_t **a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;

  v7 = 0;
  v8 = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 264);
      v21 = v17;
      if (!v17)
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v43);
        v8 = 10;
        goto LABEL_12;
      }
      v22 = *a2;
      v23 = a2[1];
      v24 = a2[3];
      *(_OWORD *)(v17 + 32) = a2[2];
      *(_OWORD *)(v17 + 48) = v24;
      *(_OWORD *)v17 = v22;
      *(_OWORD *)(v17 + 16) = v23;
      v25 = a2[4];
      v26 = a2[5];
      v27 = a2[7];
      *(_OWORD *)(v17 + 96) = a2[6];
      *(_OWORD *)(v17 + 112) = v27;
      *(_OWORD *)(v17 + 64) = v25;
      *(_OWORD *)(v17 + 80) = v26;
      v28 = a2[8];
      v29 = a2[9];
      v30 = a2[10];
      *(_OWORD *)(v17 + 172) = *(__int128 *)((char *)a2 + 172);
      *(_OWORD *)(v17 + 144) = v29;
      *(_OWORD *)(v17 + 160) = v30;
      *(_OWORD *)(v17 + 128) = v28;
      v46 = 0;
      v31 = *((_DWORD *)a2 + 2);
      LODWORD(v47) = 5;
      HIDWORD(v47) = v31;
      v48 = 0;
      if (create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v17 + 192))
        || (HIDWORD(v47) = *((_DWORD *)a2 + 3),
            v46 = 0x100000003,
            create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v21 + 200)))
        || (HIDWORD(v47) = *((_DWORD *)a2 + 4),
            create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v21 + 208))))
      {
        v35 = "create pre dense failed!";
LABEL_9:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v35, v32, v33, v34, v43);
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron init failed!", v36, v37, v38, v44);
LABEL_12:
        *(_QWORD *)(v7 + 120) = v21;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron init param failed!", v39, v40, v41, v45);
        goto LABEL_13;
      }
      HIDWORD(v47) = *((_DWORD *)a2 + 45);
      LODWORD(v46) = *((_DWORD *)a2 + 20) == 1;
      if (create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v21 + 240)))
      {
        v35 = "create post dense failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (uint64_t)a2 + 20, a3, a4, (uint64_t ***)(v21 + 216)))
      {
        v35 = "create encoder cbhg failed!";
        goto LABEL_9;
      }
      if (create_tacodecoder_layer(a1, (uint64_t)a2 + 56, a4, (uint64_t *)(v21 + 224)))
      {
        v35 = "create decoder failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (uint64_t)(a2 + 9), a3, a4, (uint64_t ***)(v21 + 232)))
      {
        v35 = "create post cbhg failed!";
        goto LABEL_9;
      }
      *(_QWORD *)(v7 + 120) = v21;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      v8 = 0;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_tacotron;
      *(_QWORD *)(v7 + 136) = free_tacotron;
      *(_QWORD *)(v7 + 144) = tacotron_update_shape;
      *(_QWORD *)(v7 + 152) = tacotron_wanted_wb_len;
      *(_DWORD *)(v7 + 8) = a5;
      *(_DWORD *)(v7 + 12) = 0;
      *(_QWORD *)(v7 + 184) = tacotron_dispatch_weights;
      *(_QWORD *)(v7 + 160) = tacotron_request_glbBuf;
      *(_QWORD *)(v7 + 168) = tacotron_assign_glbBuf;
      *(_QWORD *)(v7 + 224) = tacotron_update_param;
      *(_QWORD *)(v7 + 232) = tacotron_set_align_address;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v43);
      v8 = 10;
    }
  }
LABEL_13:
  *a6 = v7;
  return v8;
}

uint64_t forward_tacotron(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5)
{
  int *v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  float v19;
  float v20;
  float v21;
  float v22;
  uint64_t bytes;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t **v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  uint64_t v59;
  float *v60;
  float v61;
  uint64_t v62;
  float v63;
  uint64_t v64;
  float v65;
  uint64_t i;
  uint64_t v67;
  float j;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  float *v72;
  float v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  BOOL v78;
  int v79;
  int v80;
  uint64_t v81;
  unsigned int padded_bytes;
  float *v83;
  uint64_t *__src;
  int __srca;
  void *__srcb;
  _QWORD *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  float *__dst;
  int v93;
  int v94;
  size_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  v10 = *(int **)(a2 + 120);
  v11 = *(uint64_t **)a2;
  v95 = 0;
  v96 = 0;
  v94 = 0;
  v97 = 0;
  v12 = *(unsigned int *)(a2 + 24);
  v13 = v10[15];
  v14 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v11[1] + 16))(v11[2], (v13 * v12 * v10[46]), 4);
  if (v14)
  {
    v18 = (_DWORD *)v14;
    __dst = a4;
    if ((_DWORD)v12 == 3)
    {
      v19 = *(float *)(a3 + 4 * (*(_DWORD *)(a2 + 28) + 1));
      v20 = *(float *)(a3 + 4);
      v21 = v20 + 0.0001;
      v22 = v20 + -0.0001;
      if (v19 < v21 && v19 > v22)
      {
        v31 = v10[45];
        LODWORD(v96) = 1;
        HIDWORD(v96) = v31;
        *(_DWORD *)(a5 + 20) = 1;
        v32 = fi_shape_set(2, (uint64_t)&v96, 4, a2 + 40);
        bytes = v32;
        if ((_DWORD)v32)
          goto LABEL_19;
        v33 = v96;
        bzero(a4, 4 * (HIDWORD(v96) * v96));
        *v18 = 1065353216;
        v34 = (uint64_t **)a2;
        v35 = v33;
        v36 = 3;
        v37 = (uint64_t)v18;
        v38 = 0;
        goto LABEL_16;
      }
    }
    v89 = a5;
    v90 = *(_QWORD *)(a2 + 240);
    bytes = fi_shape_get_bytes((int *)(*((_QWORD *)v10 + 29) + 40), (_DWORD *)&v95 + 1);
    if ((_DWORD)bytes)
      goto LABEL_19;
    padded_bytes = get_padded_bytes(HIDWORD(v95), 8u);
    __src = *(uint64_t **)a2;
    v87 = *(_QWORD **)(a2 + 120);
    v25 = *(void **)(a2 + 240);
    bytes = fi_shape_get_bytes((int *)(v87[24] + 40), &v95);
    if ((_DWORD)bytes)
      goto LABEL_19;
    bzero(v25, v95);
    v26 = (*(uint64_t (**)(uint64_t))(v87[24] + 128))(a1);
    if ((_DWORD)v26)
    {
      bytes = v26;
      v30 = "tacotron pre dense o1 forward failed!";
    }
    else
    {
      bytes = fi_shape_get_bytes((int *)(v87[25] + 40), &v95);
      if ((_DWORD)bytes)
        goto LABEL_19;
      bzero(__dst, v95);
      v41 = (*(uint64_t (**)(uint64_t))(v87[25] + 128))(a1);
      if ((_DWORD)v41)
      {
        bytes = v41;
        v30 = "tacotron pre dense o2 forward failed!";
      }
      else
      {
        bytes = fi_shape_get_bytes((int *)(v87[26] + 40), &v95);
        if ((_DWORD)bytes)
          goto LABEL_19;
        bzero(v25, v95);
        v42 = (*(uint64_t (**)(uint64_t))(v87[26] + 128))(a1);
        if ((_DWORD)v42)
        {
          bytes = v42;
          v30 = "tacotron pre dense o3 forward failed!";
        }
        else
        {
          bytes = (*(uint64_t (**)(void))(v87[27] + 176))();
          if ((_DWORD)bytes)
            goto LABEL_19;
          bytes = fi_shape_get_bytes((int *)(v87[27] + 40), &v95);
          if ((_DWORD)bytes)
            goto LABEL_19;
          bzero(__dst, v95);
          v43 = (*(uint64_t (**)(uint64_t))(v87[27] + 128))(a1);
          if (!(_DWORD)v43)
          {
            v88 = *(_QWORD *)(a2 + 72);
            v44 = v10[1];
            __srca = *v10;
            bytes = fi_shape_get_bytes((int *)(*((_QWORD *)v10 + 28) + 20), &v95);
            if ((_DWORD)bytes)
              goto LABEL_19;
            v83 = (float *)(v90 + 4 * padded_bytes);
            if ((_DWORD)v12)
            {
              v45 = 0;
              v46 = 0;
              __srcb = (void *)(v88 + 4 * (v44 * __srca));
              do
              {
                memcpy((void *)(v90 + 4 * ((v10[1] + 2 * v10[12]) * v46)), &__dst[v45 * v10[12]], 4 * (2 * v10[12]));
                v45 += 2;
                memcpy((void *)(v90 + 4 * (v45 * v10[12]) + 4 * (v10[1] * v46++)), __srcb, 4 * v10[1]);
              }
              while ((_DWORD)v12 != v46);
            }
            v93 = v12;
            forward_tacotron_decoder(a1, a2, (char *)__dst, &v95, (uint64_t)v18, v83, (unsigned int *)&v93);
            bytes = v47;
            if ((_DWORD)v47)
              goto LABEL_19;
            v48 = *(_DWORD *)(a2 + 8);
            if (v48 == 66)
            {
              v54 = v93;
              if (v93)
              {
                v55 = 0;
                v56 = 0;
                do
                {
                  __dst[v56] = 0.0;
                  if ((_DWORD)v12)
                  {
                    v57 = 0;
                    v58 = 0.0;
                    do
                    {
                      v59 = (v55 + v57);
                      if (*(float *)&v18[v59] > v58)
                      {
                        __dst[v56] = (float)v57;
                        v58 = *(float *)&v18[v59];
                      }
                      ++v57;
                    }
                    while (v12 != v57);
                  }
                  ++v56;
                  v55 += v12;
                }
                while (v56 != v54);
                if (v54 >= 2)
                {
                  v60 = __dst + 1;
                  v61 = *__dst;
                  v62 = v54 - 1;
                  do
                  {
                    v63 = *v60;
                    if (*v60 < v61)
                    {
                      *v60 = v61;
                      v63 = v61;
                    }
                    ++v60;
                    v61 = v63;
                    --v62;
                  }
                  while (v62);
                }
                v64 = 0;
                do
                {
                  __dst[v64] = __dst[v64] + 1.0;
                  ++v64;
                }
                while (v54 != v64);
                v65 = *__dst;
                *__dst = 1.0;
                if (v54 >= 2)
                {
                  for (i = 1; i != v54; ++i)
                  {
                    if (__dst[i] <= v65)
                    {
                      v67 = (float)(v65 + -0.99);
                    }
                    else
                    {
                      do
                      {
                        v65 = v65 + 1.0;
                        v67 = (float)(v65 + -0.99);
                        __dst[v67] = 0.0;
                      }
                      while (__dst[i] > v65);
                    }
                    __dst[v67] = __dst[v67] + 1.0;
                  }
                }
              }
              else
              {
                v65 = *__dst;
                *__dst = 1.0;
              }
              for (j = (float)v12 + -0.1; j > v65; __dst[(float)(v65 + -0.99)] = 0.0)
                v65 = v65 + 1.0;
              if ((_DWORD)v12)
              {
                v69 = v12;
                do
                {
                  if (*__dst < 0.5)
                    *__dst = 1.0;
                  ++__dst;
                  --v69;
                }
                while (v69);
              }
              *(_DWORD *)(v89 + 20) = 1;
              LODWORD(v96) = v12;
              v39 = fi_shape_set(1, (uint64_t)&v96, 4, a2 + 40);
              goto LABEL_17;
            }
            if (v48 != 63)
            {
              bytes = 0;
              goto LABEL_19;
            }
            v49 = v93;
            bytes = forward_tacotron_postnet(a1, a2, __dst, &v95, v93);
            if ((_DWORD)bytes)
              goto LABEL_19;
            if (v10[45] == 20)
            {
              v50 = v49 * v13;
              if ((v49 * v13) < 0xB)
              {
                LODWORD(v52) = 0;
              }
              else
              {
                v51 = 0;
                v52 = v50 - 10;
                v53 = 19;
                while (__dst[v53] <= 0.3)
                {
                  ++v51;
                  v53 += 20;
                  if (v52 == v51)
                    goto LABEL_92;
                }
                LODWORD(v52) = v51;
              }
LABEL_92:
              if ((int)v52 + 5 >= v50)
              {
                v75 = 0;
              }
              else
              {
                v75 = 0;
                v76 = v50 - v52 - 5;
                v77 = 20 * v13 * v49 - 1;
                while (__dst[v77] <= 0.3)
                {
                  ++v75;
                  v77 -= 20;
                  if (v76 == v75)
                  {
                    v75 = v76;
                    break;
                  }
                }
              }
              v78 = v52 >= 7;
              v79 = v52 - 7;
              if (!v78)
                v79 = 0;
              v91 = v79;
              v74 = v75 >= 5 ? v75 - 5 : 0;
            }
            else
            {
              if (v10[20] == 1)
              {
                v70 = v95 >> 2;
                if (v95 >= 4)
                {
                  if (v70 <= 1)
                    v71 = 1;
                  else
                    v71 = v70;
                  v72 = __dst;
                  do
                  {
                    v73 = *v72;
                    if (*v72 > 1.0)
                      v73 = 1.0;
                    if (v73 < 0.0)
                      v73 = 0.0;
                    *v72++ = (float)(v73 * 11.513) + -9.2103;
                    --v71;
                  }
                  while (v71);
                }
                fast_exp(__dst, v70, __dst);
              }
              v91 = 0;
              v74 = 0;
            }
            bytes = fi_shape_get_bytes((int *)(a2 + 40), &v94);
            if ((_DWORD)bytes)
              goto LABEL_19;
            if (v94 != (_DWORD)v95)
              *(_DWORD *)(v89 + 20) = 1;
            v80 = v10[45];
            LODWORD(v96) = v49 * v13 - (v91 + v74);
            HIDWORD(v96) = v80;
            bytes = fi_shape_set(2, (uint64_t)&v96, 4, a2 + 40);
            if ((_DWORD)bytes)
              goto LABEL_19;
            if (v91)
              memmove(__dst, &__dst[HIDWORD(v96) * v91], 4 * (v96 * HIDWORD(v96)));
            v35 = v96;
            v34 = (uint64_t **)a2;
            v36 = v12;
            v37 = (uint64_t)v18;
            v38 = v91;
LABEL_16:
            v39 = send_alignment_out(v34, v35, v36, v37, v38);
LABEL_17:
            bytes = v39;
            goto LABEL_19;
          }
          bytes = v43;
          v30 = "tacotron encoder cbhg forward failed!";
        }
      }
    }
    log_OutText(*__src, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v27, v28, v29, v81);
LABEL_19:
    (*(void (**)(uint64_t, _DWORD *))(v11[1] + 48))(v11[2], v18);
    return bytes;
  }
  log_OutText(*v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v15, v16, v17, v81);
  return 10;
}

uint64_t tacotron_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  int step;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD v24[2];
  int v25;
  _QWORD v26[2];
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 120);
  v30 = 0;
  v5 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v5;
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 192) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 200) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 208) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 216) + 144))();
        if (!(_DWORD)result)
        {
          v26[0] = 0;
          v26[1] = 0;
          v27 = 0;
          v24[0] = 0;
          v24[1] = 0;
          v25 = 0;
          step = fi_shape_get_step(a2);
          v8 = *(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 48);
          v28 = step;
          v29 = v8;
          result = fi_shape_set(2, (uint64_t)&v28, 4, (uint64_t)v24);
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 224) + 144))(*(_QWORD *)(v4 + 224), v24, v9, v10, v11, v12);
            if (!(_DWORD)result)
            {
              v13 = *(_DWORD *)(v4 + 56);
              v28 = *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 184);
              v29 = v13;
              result = fi_shape_set(2, (uint64_t)&v28, 4, (uint64_t)v26);
              if (!(_DWORD)result)
              {
                (*(void (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 232)
                                                                                             + 144))(*(_QWORD *)(v4 + 232), v26, v14, v15, v16, v17);
                v18 = 2 * *(_DWORD *)(v4 + 172);
                v28 = *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 184);
                v29 = v18;
                result = fi_shape_set(2, (uint64_t)&v28, 4, (uint64_t)v26);
                if (!(_DWORD)result)
                {
                  (*(void (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 240)
                                                                                               + 144))(*(_QWORD *)(v4 + 240), v26, v19, v20, v21, v22);
                  v23 = *(_DWORD *)(v4 + 180);
                  if (v23 <= 0x100)
                    v23 = 256;
                  v29 = v23;
                  return fi_shape_set(2, (uint64_t)&v28, 4, a1 + 40);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacotron_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_len;
  uint64_t result;
  int padded_bytes;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;

  v8 = *(_QWORD *)(a1 + 120);
  v21 = 0;
  if (v8)
  {
    padded_len = get_padded_len(*(unsigned int *)(v8 + 4), 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 192) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(HIDWORD(v21) + (padded_len << 9) + (int)v21, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 200) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(HIDWORD(v21) + (int)v21 + padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 208) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 216) + 152))();
          if (!(_DWORD)result)
          {
            v16 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v15, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 224) + 152))();
            if (!(_DWORD)result)
            {
              v17 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v16, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 232) + 152))();
              if (!(_DWORD)result)
              {
                v18 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v17, 8u);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 240) + 152))();
                if (!(_DWORD)result)
                {
                  v19 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v18, 8u);
                  result = 0;
                  *a2 = v19;
                  *a3 = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t tacotron_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t (*v14)(void);
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    result = tacotron_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      v11 = 0;
      v12 = 0;
      v13 = v9 + 192;
      do
      {
        v14 = *(uint64_t (**)(void))(*(_QWORD *)(v13 + v11) + 160);
        if (v14)
        {
          result = v14();
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)(*(_QWORD *)(v13 + v11) + 248) > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v13 + v11) + 248);
        }
        v11 += 8;
      }
      while (v11 != 56);
      v15 = v18;
      padded_bytes = get_padded_bytes(v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes + v15;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t tacotron_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    padded_bytes = get_padded_len(*(unsigned int *)(v8 + 4), 8u) << 9;
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 192), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 200), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 208), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 216), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 224), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 232), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 240), v9, &padded_bytes);
                if (!(_DWORD)result)
                {
                  get_padded_bytes(padded_bytes, 8u);
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t tacotron_assign_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t reserved_glbBuf_bytes;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(void);
  uint64_t v7;
  void (*v8)(void);
  uint64_t v9;
  void (*v10)(void);
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  void (*v14)(void);
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  void (*v18)(void);
  unsigned int v20;

  v2 = *(_QWORD **)(a1 + 120);
  v20 = 0;
  reserved_glbBuf_bytes = tacotron_get_reserved_glbBuf_bytes(a1, &v20);
  if (!(_DWORD)reserved_glbBuf_bytes)
  {
    v4 = v2[24];
    v5 = v20;
    *(_QWORD *)(v4 + 240) = *(_QWORD *)(a1 + 240) + v20;
    v6 = *(void (**)(void))(v4 + 168);
    if (v6)
      v6();
    v7 = v2[25];
    *(_QWORD *)(v7 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v8 = *(void (**)(void))(v7 + 168);
    if (v8)
      v8();
    v9 = v2[26];
    *(_QWORD *)(v9 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v10 = *(void (**)(void))(v9 + 168);
    if (v10)
      v10();
    v11 = v2[27];
    *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v12 = *(void (**)(void))(v11 + 168);
    if (v12)
      v12();
    v13 = v2[28];
    *(_QWORD *)(v13 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v14 = *(void (**)(void))(v13 + 168);
    if (v14)
      v14();
    v15 = v2[29];
    *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v16 = *(void (**)(void))(v15 + 168);
    if (v16)
      v16();
    v17 = v2[30];
    *(_QWORD *)(v17 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v18 = *(void (**)(void))(v17 + 168);
    if (v18)
      v18();
  }
  return reserved_glbBuf_bytes;
}

uint64_t tacotron_update_param(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  uint64_t result;
  _DWORD *v6;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  result = 7;
  if (a3 == 4)
  {
    v6 = *(_DWORD **)(a1 + 120);
    if (v6)
    {
      result = 0;
      *v6 = *a2;
    }
  }
  return result;
}

uint64_t tacotron_set_align_address(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 120);
  if (!v2)
    return 7;
  result = 0;
  *(_QWORD *)(v2 + 248) = a2;
  *(_DWORD *)(v2 + 256) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t send_alignment_out(uint64_t **a1, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t *v9;
  uint64_t *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v17;

  v9 = a1[15];
  if (*((_DWORD *)v9 + 64) >= (a3 * a2 + 2))
  {
    v11 = 4 * (a3 * a2);
    bzero(*(void **)v9[31], v11 + 8);
    v15 = *(_DWORD **)v9[31];
  }
  else
  {
    v10 = *a1;
    v11 = 4 * (a3 * a2);
    *(_QWORD *)v9[31] = heap_Realloc((uint64_t *)(*a1)[2], *(_QWORD *)v9[31], v11 + 8);
    v15 = *(_DWORD **)v9[31];
    if (!v15)
    {
      log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v12, v13, v14, v17);
      return 10;
    }
  }
  *v15 = a3;
  v15[1] = a2;
  memcpy(v15 + 2, (const void *)(a4 + 4 * (a5 * a3)), v11);
  return 0;
}

void forward_tacotron_decoder(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4, uint64_t a5, float *a6, unsigned int *a7)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  size_t v16;
  float *v17;
  float *v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t alignment;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const void *v34;
  int i;
  int v36;
  unsigned int v37;
  unsigned int v39;
  unsigned int v40;
  int v43;
  float v44;

  v12 = *(_QWORD *)(a2 + 120);
  v44 = 0.0;
  v13 = *(unsigned int *)(a2 + 24);
  v15 = *(_DWORD *)(v12 + 56);
  v14 = *(_DWORD *)(v12 + 60);
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v12 + 224) + 176))()
    && !fi_shape_get_bytes((int *)(a2 + 40), a4))
  {
    bzero(a3, *a4);
    *a7 = 0;
    if (*(_DWORD *)(v12 + 184))
    {
      v43 = 0;
      v16 = (4 * v14 * v15);
      v40 = 10 * v13;
      do
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v12 + 224) + 128))(a1))
          break;
        v17 = a6;
        v18 = &a6[get_padded_len(1, 8u)];
        v19 = v16;
        memcpy(&a3[v43], v18, v16);
        alignment = get_alignment(*(_QWORD *)(v12 + 224), v20, v21, v22, v23, v24, v25, v26);
        if (v14)
        {
          v34 = (const void *)alignment;
          for (i = 0; i != v14; ++i)
            memcpy((void *)(a5 + 4 * (i + *a7 * v14) * v13), v34, 4 * v13);
        }
        get_last_alignment(*(_QWORD *)(v12 + 224), &v44, v28, v29, v30, v31, v32, v33);
        if (v36)
          break;
        v16 = v19;
        v43 += v19;
        v37 = *a7;
        a6 = v17;
        if (*a7 > v13 >> 2)
        {
          if (*v17 > 0.8 || v44 > 0.8)
            goto LABEL_25;
          if (v37 < 7)
          {
            if (v37 > v40)
              goto LABEL_25;
          }
          else if (*(float *)(a5 + 4 * (v37 - 6) * v14) == (float)(v13 - 1) || v37 > v40)
          {
LABEL_25:
            bzero(&a3[v43 - (v16 >> 1)], v16 >> 1);
            ++*a7;
            return;
          }
        }
        v39 = v37 + 1;
        *a7 = v39;
      }
      while (v39 < *(_DWORD *)(v12 + 184));
    }
  }
}

uint64_t forward_tacotron_postnet(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, int a5)
{
  uint64_t v9;
  uint64_t *v10;
  void *v11;
  int v12;
  int v13;
  uint64_t bytes;
  uint64_t v16;
  uint64_t (*v17)(void);
  uint64_t (*v18)(void);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[2];
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(uint64_t **)a2;
  v11 = *(void **)(a2 + 240);
  v35[0] = 0;
  v35[1] = 0;
  v12 = *(_DWORD *)(v9 + 56);
  v13 = *(_DWORD *)(v9 + 60) * a5;
  v36 = 0;
  v37 = v13;
  v38 = v12;
  v39 = 0;
  bytes = fi_shape_set(2, (uint64_t)&v37, 4, (uint64_t)v35);
  if (!(_DWORD)bytes)
  {
    (*(void (**)(void))(*(_QWORD *)(v9 + 232) + 144))();
    v16 = *(_QWORD *)(v9 + 232);
    v17 = *(uint64_t (**)(void))(v16 + 160);
    if (v17)
    {
      bytes = v17();
      if ((_DWORD)bytes)
        return bytes;
      v16 = *(_QWORD *)(v9 + 232);
    }
    v18 = *(uint64_t (**)(void))(v16 + 168);
    if (v18)
    {
      bytes = v18();
      if ((_DWORD)bytes)
        return bytes;
      v16 = *(_QWORD *)(v9 + 232);
    }
    bytes = fi_shape_get_bytes((int *)(v16 + 40), a4);
    if (!(_DWORD)bytes)
    {
      bzero(v11, *a4);
      bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 232) + 176))();
      if (!(_DWORD)bytes)
      {
        v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 232) + 128))(a1);
        if ((_DWORD)v19)
        {
          bytes = v19;
          v23 = *v10;
          v24 = "tacotron post cbhg forward failed!";
LABEL_13:
          log_OutText(v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)v24, v20, v21, v22, v34);
          return bytes;
        }
        v25 = 2 * *(_DWORD *)(v9 + 172);
        v37 = *(_DWORD *)(v9 + 60) * a5;
        v38 = v25;
        bytes = fi_shape_set(2, (uint64_t)&v37, 4, (uint64_t)v35);
        if (!(_DWORD)bytes)
        {
          (*(void (**)(void))(*(_QWORD *)(v9 + 240) + 144))();
          bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 240) + 40), a4);
          if (!(_DWORD)bytes)
          {
            if (*(_DWORD *)(v9 + 180) != *(_DWORD *)(v9 + 56))
            {
              bzero(a3, *a4);
              bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 240) + 128))(a1);
              if (!(_DWORD)bytes)
                return bytes;
              v23 = *v10;
              v24 = "tacotron post dense forward failed!";
              goto LABEL_13;
            }
            v26 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v10[1] + 16))(v10[2], (unint64_t)*a4 >> 2, 4);
            if (v26)
            {
              v30 = (float *)v26;
              bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 240) + 128))(a1);
              if ((_DWORD)bytes)
              {
                log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron post dense forward failed!", v31, v32, v33, v34);
              }
              else
              {
                axpy(*a4 >> 2, v30, 1, (float *)a3, 1, 1.0);
                if (*(_DWORD *)(v9 + 80) == 2)
                  relu_array_f32(*a4 >> 2, (float *)a3);
              }
              (*(void (**)(uint64_t, float *))(v10[1] + 48))(v10[2], v30);
            }
            else
            {
              log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v27, v28, v29, v34);
              return 10;
            }
          }
        }
      }
    }
  }
  return bytes;
}

uint64_t tacotron_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t result;
  int padded_bytes;
  int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 232) + 40), &v7);
  if ((_DWORD)result)
  {
    padded_bytes = 0;
  }
  else
  {
    padded_bytes = get_padded_bytes(v7, 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 224) + 40), &v7);
    if (!(_DWORD)result)
    {
      v6 = get_padded_bytes(v7, 8u);
      result = 0;
      padded_bytes += v6;
    }
  }
  *a2 = padded_bytes;
  return result;
}

uint64_t create_lpcnet_layer(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v41;
  __int128 v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 288);
    v16 = v12;
    if (v12)
    {
      v17 = *a2;
      v18 = a2[1];
      v19 = a2[3];
      *(_OWORD *)(v12 + 32) = a2[2];
      *(_OWORD *)(v12 + 48) = v19;
      *(_OWORD *)v12 = v17;
      *(_OWORD *)(v12 + 16) = v18;
      v20 = a2[4];
      v21 = a2[5];
      v22 = a2[7];
      *(_OWORD *)(v12 + 96) = a2[6];
      *(_OWORD *)(v12 + 112) = v22;
      *(_OWORD *)(v12 + 64) = v20;
      *(_OWORD *)(v12 + 80) = v21;
      v23 = a2[8];
      v24 = a2[9];
      v25 = a2[10];
      *(_DWORD *)(v12 + 176) = *((_DWORD *)a2 + 44);
      *(_OWORD *)(v12 + 144) = v24;
      *(_OWORD *)(v12 + 160) = v25;
      *(_OWORD *)(v12 + 128) = v23;
      v43 = 0;
      v41 = 0u;
      v42 = 0u;
      if (a2)
      {
        v26 = *((_DWORD *)a2 + 22);
        v27 = *((_DWORD *)a2 + 23);
        LODWORD(v45) = 5;
        HIDWORD(v45) = v26;
        v46 = 0;
        v44 = v27 | 0x100000000;
        if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v12 + 200)))
        {
          v28 = *a1;
          v29 = "create feature_dense1 failed!";
        }
        else
        {
          v34 = *((_DWORD *)a2 + 25);
          HIDWORD(v45) = *((_DWORD *)a2 + 24);
          v44 = v34 | 0x100000000;
          if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v16 + 208)))
          {
            v28 = *a1;
            v29 = "create feature_dense2 failed!";
          }
          else
          {
            v35 = *((_DWORD *)a2 + 27);
            HIDWORD(v45) = *((_DWORD *)a2 + 26);
            v44 = v35 | 0x100000000;
            if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v16 + 216)))
            {
              v28 = *a1;
              v29 = "create gru_a_dense failed!";
            }
            else
            {
              HIDWORD(v45) = 2 * *((_DWORD *)a2 + 41);
              LODWORD(v44) = *((_DWORD *)a2 + 43);
              HIDWORD(v44) = 1;
              if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v16 + 224)))
              {
                v28 = *a1;
                v29 = "create dual_fc1 failed!";
              }
              else if (config_conv1d_layer(*((_DWORD *)a2 + 17), *((_DWORD *)a2 + 16), 1, 1, 1, 1, *((_DWORD *)a2 + 18), &v41))
              {
                v28 = *a1;
                v29 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
              }
              else if (create_conv1d_layer(a1, &v41, 0, a3, (uint64_t ***)(v16 + 184)))
              {
                v28 = *a1;
                v29 = "create feature_conv1 layer failed!";
              }
              else
              {
                v36 = *((_DWORD *)a2 + 20);
                v43 = *((_DWORD *)a2 + 21);
                LODWORD(v41) = *((_DWORD *)a2 + 19);
                LODWORD(v42) = v36;
                if (!create_conv1d_layer(a1, &v41, 0, a3, (uint64_t ***)(v16 + 192)))
                {
                  v30 = 0;
                  *(_QWORD *)v11 = a1;
                  *(_QWORD *)(v11 + 8) = 65;
                  *(_QWORD *)(v11 + 120) = v16;
                  *(_QWORD *)(v11 + 128) = forward_lpcnet_layer;
                  *(_QWORD *)(v11 + 136) = free_lpcnet;
                  *(_QWORD *)(v11 + 144) = lpcnet_update_shape;
                  *(_DWORD *)(v11 + 16) = 0;
                  *(_QWORD *)(v11 + 152) = lpcnet_wanted_wb_len;
                  *(_QWORD *)(v11 + 160) = lpcnet_request_glbBuf;
                  *(_QWORD *)(v11 + 184) = lpcnet_dispatch_weights;
                  *(_QWORD *)(v11 + 168) = lpcnet_assign_glbBuf;
                  *(_QWORD *)(v11 + 224) = lpcnet_update_param;
                  goto LABEL_23;
                }
                v28 = *a1;
                v29 = "create feature_conv2 layer failed!";
              }
            }
          }
        }
      }
      else
      {
        v28 = *a1;
        v29 = "config empty";
      }
      log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v13, v14, v15, v41);
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"LPCNet init failed!", v37, v38, v39, v41);
      v30 = 7;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v41);
      v30 = 10;
    }
    *(_QWORD *)(v11 + 120) = v16;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lpcnet init param failed!", v31, v32, v33, v41);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v41);
    v30 = 10;
  }
LABEL_23:
  *a4 = v11;
  return v30;
}

uint64_t forward_lpcnet_layer(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t weights_via_offset;
  BOOL v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int step;
  int padded_len;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int padded_bytes;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  uint64_t v60;
  const char *v61;
  uint64_t *v62;
  int v63;
  BOOL v64;
  uint64_t v66;
  uint64_t v67;
  const void *v68;
  const void *v69;
  const void *v70;
  unsigned int *v71;
  int v72;
  uint64_t v73;
  int32x2_t v74;
  int v75;
  float *v76;
  float *v77;
  size_t v78;
  float v79;
  uint64_t v80;
  float v81;
  float v82;
  float v83;
  float v84;
  unint64_t v85;
  float v86;
  float v87;
  unsigned int v88;
  unsigned int v89;
  float *v90;
  uint64_t v91;
  int v92;
  unsigned int *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  uint64_t v99;
  float32x2_t v100;
  float *v101;
  int32x2_t v102;
  uint64x2_t v103;
  float32x2_t v104;
  float32x2_t v105;
  float32x2_t v106;
  float32x2_t v107;
  float v108;
  uint64_t v109;
  int v110;
  unsigned int v111;
  uint64_t i;
  float v113;
  unsigned int v114;
  int j;
  const void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  float *v121;
  unsigned int v122;
  uint64_t k;
  float v124;
  float *v125;
  unsigned int v126;
  uint64_t v127;
  float v128;
  float *v129;
  uint64_t v130;
  unsigned int *v131;
  uint64_t v132;
  uint64_t v133;
  size_t v134;
  char *v135;
  unsigned int v136;
  int v137;
  uint64_t v138;
  unsigned int v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  float *v145;
  float32x2_t *v146;
  float *v147;
  size_t v148;
  int v149;
  float *v150;
  size_t v151;
  uint64_t v152;
  size_t v153;
  float *v154;
  float32x2_t *v155;
  int8x16_t *v156;
  float v157;
  uint64_t v158;
  float *v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  size_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  uint64_t v169;
  float *v170;
  int v171;
  BOOL v172;
  float (*v173)(float);
  uint64_t (*v174)(float);
  unsigned int v175;
  float v176;
  BOOL v177;
  unsigned int v178;
  unsigned int v179;
  unsigned int v180;
  unsigned int v181;
  unsigned int v182;
  uint64_t v183;
  int v184;
  float *v185;
  void *v186;
  unsigned int v187;
  unint64_t v188;
  float *v189;
  uint64_t v190;
  unint64_t v191;
  int v192;
  int v193;
  float v194;
  _BOOL4 v195;
  BOOL v196;
  int v197;
  float v198;
  uint64_t v199;
  int v200;
  unsigned int v201;
  float v202;
  float *v203;
  float v204;
  int v205;
  int v206;
  const void *v207;
  uint64_t v208;
  size_t v209;
  void *v210;
  const void *v211;
  unsigned int v212;
  uint64_t v213;
  float *v214;
  void *v215;
  float *v216;
  uint64_t v217;
  unsigned int v218;
  uint64_t v219;
  float *v220;
  _DWORD *v221;
  char *v222;
  float *v223;
  float32x4_t *v224;
  float32x4_t *v225;
  uint64_t v226;
  float *v227;
  float *v228;
  float v229;
  uint64_t *v230;
  uint64_t v231;
  float *v232;
  float *v233;
  float *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  unsigned int v239;
  unsigned int v240;
  float v241;
  _BOOL4 v242;
  float v243;
  float v244;
  float v245;
  unsigned int v246;
  unsigned int v247;
  uint64_t v248;
  int v249;
  uint64_t v250;
  uint64_t *v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  unsigned int v255;
  void *__dst;
  uint64_t *v257;
  _BOOL4 v258;
  int v259;
  void *v260;
  unsigned int *v261;
  uint64_t v262;
  float *v263;
  uint64_t (*v264)(float);
  unsigned int **v265;
  float (*v266)(float);
  char *v267;
  uint64_t v268;
  float *v269;
  float *v270;
  int64x2_t v271;
  uint64_t v272;
  int v273;
  uint64x2_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  float v278;
  float v279;
  unsigned int v280;
  uint64_t v281;
  float v282;
  float v283;
  int v284;
  int v285;
  uint64_t v286;
  int v287;
  int32x2_t v288;
  uint64_t v289;
  unsigned int v290;
  unsigned int v291;
  uint64_t v292;
  int *v293;
  unsigned int v294;
  uint64_t v295;
  uint64_t *v296;
  uint64_t v297;
  int64x2_t v298;
  uint64_t v299;
  uint64_t *v300;
  uint64_t v301;
  uint64_t *v302;
  unsigned int v303[3];

  v9 = *(uint64_t **)a2;
  v10 = *(_QWORD *)(a2 + 120);
  v302 = 0;
  v11 = *(_DWORD *)(a2 + 24);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], 1, 280);
  if (!v15)
  {
    v19 = *v9;
LABEL_6:
    log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v250);
    weights_via_offset = 10;
    goto LABEL_27;
  }
  v301 = v10;
  v292 = a5;
  v293 = a4;
  if (*(_DWORD *)(v10 + 232))
  {
    weights_via_offset = 7;
    switch(*(_DWORD *)(v10 + 244))
    {
      case 0:
      case 2:
      case 5:
        v286 = a3;
        v17 = v11 >= 2;
        v18 = v11 - 2;
        goto LABEL_9;
      case 1:
        v286 = a3;
        v17 = v11 >= 4;
        v18 = v11 - 4;
LABEL_9:
        if (!v17)
          v18 = 0;
        v294 = v18;
        goto LABEL_12;
      default:
        goto LABEL_27;
    }
  }
  v286 = a3;
  v294 = v11;
LABEL_12:
  v20 = *(uint64_t **)a2;
  v21 = *(_QWORD *)(a2 + 120);
  v22 = a2;
  v23 = *(_QWORD *)(a2 + 240);
  v24 = *(_DWORD *)(v21 + 32);
  v25 = *(_DWORD *)(v21 + 16);
  v26 = *(_QWORD *)(v22 + 72);
  v303[0] = 0;
  v295 = v22;
  v296 = v20;
  step = fi_shape_get_step((_DWORD *)(v22 + 20));
  *(_QWORD *)(v15 + 16) = v23;
  padded_len = get_padded_len(*(unsigned int *)(v21 + 124), 8u);
  *(_QWORD *)(v15 + 24) = v23 + (4 * padded_len);
  v29 = get_padded_len(*(unsigned int *)(v21 + 140), 8u) + padded_len;
  *(_QWORD *)(v15 + 32) = v23 + (4 * v29);
  v30 = get_padded_len((3 * *(_DWORD *)(v21 + 160)), 8u) + v29;
  *(_QWORD *)(v15 + 40) = v23 + (4 * v30);
  v31 = get_padded_len((3 * *(_DWORD *)(v21 + 160)), 8u) + v30;
  *(_QWORD *)(v15 + 48) = v23 + (4 * v31);
  v32 = get_padded_len(*(unsigned int *)(v21 + 164), 8u) + v31;
  *(_QWORD *)(v15 + 56) = v23 + (4 * v32);
  v33 = get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u) + v32;
  *(_QWORD *)(v15 + 64) = v23 + (4 * v33);
  v34 = get_padded_len((2 * *(_DWORD *)(v21 + 164)), 8u) + v33;
  *(_QWORD *)(v15 + 72) = v23 + (4 * v34);
  v35 = get_padded_len(*(unsigned int *)(v21 + 40), 8u) + v34;
  *(_QWORD *)(v15 + 128) = v23 + (4 * v35);
  v36 = get_padded_len((*(_DWORD *)(v21 + 40) * step), 8u) + v35;
  *(_QWORD *)(v15 + 112) = v23 + (4 * v36);
  v37 = get_padded_len((*(_DWORD *)(v21 + 96) * step), 8u) + v36;
  v38 = v23 + (4 * v37);
  *(_QWORD *)(v15 + 120) = v38;
  *(_QWORD *)(v15 + 80) = v38;
  v39 = get_padded_len((*(_DWORD *)(v21 + 60) * step), 8u) + v37;
  *(_QWORD *)(v15 + 88) = v23 + (4 * v39);
  v40 = get_padded_len((*(_DWORD *)(v21 + 68) * step), 8u) + v39;
  *(_QWORD *)(v15 + 96) = v23 + (4 * v40);
  *(_QWORD *)(v15 + 104) = v23
                         + 4 * (get_padded_len((*(_DWORD *)(v21 + 80) * step), 8u) + v40);
  get_padded_len((*(_DWORD *)(v21 + 88) * step), 8u);
  v41 = *(_DWORD *)(v21 + 104);
  if (v41 <= *(_DWORD *)(v21 + 68) + *(_DWORD *)(v21 + 60) + *(_DWORD *)(v21 + 80) + *(_DWORD *)(v21 + 88))
    v41 = *(_DWORD *)(v21 + 68) + *(_DWORD *)(v21 + 60) + *(_DWORD *)(v21 + 80) + *(_DWORD *)(v21 + 88);
  if (v41 <= 0x14A)
    v41 = 330;
  *(_QWORD *)(v15 + 136) = v23 + 4 * (get_padded_len(v41 * step, 8u) + v37);
  get_padded_bytes(8 * v24 + 4 * (v25 + v24 * v24) + 8, 8u);
  v42 = v303[0];
  *(_QWORD *)(v15 + 144) = v26 + (v303[0] & 0xFFFFFFFC);
  v43 = v42 + 4 * get_padded_len(*(unsigned int *)(v21 + 56), 8u) * *(_DWORD *)(v21 + 52);
  *(_QWORD *)(v15 + 152) = v26 + (v43 & 0xFFFFFFFC);
  v44 = v43 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 112);
  *(_QWORD *)(v15 + 160) = v26 + (v44 & 0xFFFFFFFC);
  v45 = v44 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 116);
  *(_QWORD *)(v15 + 168) = v26 + (v45 & 0xFFFFFFFC);
  v303[0] = v45 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 120);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 184), v26, v303);
  v10 = v301;
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 192), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 200), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 208), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 216), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 176) = v26 + (v303[0] & 0xFFFFFFFC);
  v49 = *(_DWORD *)(v21 + 128);
  v303[0] += 4 * (v49 + (get_padded_len((3 * *(_DWORD *)(v21 + 124)), 8u) >> 4));
  padded_bytes = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 184) = v26 + (padded_bytes & 0xFFFFFFFC);
  v303[0] = padded_bytes + 12 * *(_DWORD *)(v21 + 124);
  v51 = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 192) = v26 + (v51 & 0xFFFFFFFC);
  v303[0] = v51 + (*(_DWORD *)(v21 + 128) << 6);
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 200) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 124)), 8u);
  v52 = get_padded_bytes(v303[0], 8u);
  v303[0] = v52;
  v53 = *(_DWORD *)(v21 + 148);
  *(_QWORD *)(v15 + 208) = v26 + (v52 & 0xFFFFFFFC);
  if (v53 == 1)
  {
    v303[0] = v52 + (*(_DWORD *)(v21 + 152) << 6);
    v54 = get_padded_bytes(v303[0], 8u);
    *(_QWORD *)(v15 + 240) = v26 + (v54 & 0xFFFFFFFC);
    v303[0] = v54 + 4 * (*(_DWORD *)(v21 + 152) + ((3 * *(_DWORD *)(v21 + 140) + 15) >> 4));
    v55 = get_padded_bytes(v303[0], 8u);
    *(_QWORD *)(v15 + 256) = v26 + (v55 & 0xFFFFFFFC);
    v303[0] = v55 + (*(_DWORD *)(v21 + 156) << 6);
    v56 = get_padded_bytes(v303[0], 8u);
    *(_QWORD *)(v15 + 248) = v26 + (v56 & 0xFFFFFFFC);
    v57 = v56 + 4 * (*(_DWORD *)(v21 + 156) + ((3 * *(_DWORD *)(v21 + 140) + 15) >> 4));
  }
  else
  {
    v58 = *(_DWORD *)(v21 + 140);
    v59 = v58 * get_padded_len((*(_DWORD *)(v21 + 124) + *(_DWORD *)(v21 + 96)), 8u);
    v10 = v301;
    v57 = v303[0] + 12 * v59;
  }
  v303[0] = v57;
  v303[0] = get_padded_bytes(v57, 8u);
  *(_QWORD *)(v15 + 216) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u);
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 224) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 12 * get_padded_len(*(unsigned int *)(v21 + 140), 8u) * *(_DWORD *)(v21 + 140);
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 232) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u);
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 224), v26, v303);
  if ((_DWORD)weights_via_offset)
  {
LABEL_25:
    v60 = *v296;
    v61 = "lpcnet pack buf manager failed!";
LABEL_26:
    log_OutText(v60, (uint64_t)"FastInfer", 0, 0, (uint64_t)v61, v46, v47, v48, v250);
    goto LABEL_27;
  }
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 264) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len(*(unsigned int *)(v21 + 164), 8u) * *(_DWORD *)(v21 + 168);
  *(_QWORD *)(v15 + 272) = v26 + (v303[0] & 0xFFFFFFFC);
  get_padded_len(1024, 8u);
  *(_QWORD *)v15 = v286;
  *(_QWORD *)(v15 + 8) = v293;
  v66 = v295;
  v67 = *(_QWORD *)(v295 + 120);
  if (*(_DWORD *)(v10 + 232))
  {
    v68 = *(const void **)(v67 + 248);
    if (v68)
      memcpy(*(void **)(v15 + 72), v68, 4 * *(unsigned int *)(v67 + 40));
    v69 = *(const void **)(v67 + 256);
    if (v69)
      memcpy(*(void **)(v15 + 16), v69, 4 * *(unsigned int *)(v67 + 124));
    v70 = *(const void **)(v67 + 264);
    if (v70)
      memcpy(*(void **)(v15 + 24), v70, 4 * *(unsigned int *)(v67 + 140));
  }
  else
  {
    bzero(*(void **)(v15 + 72), 4 * *(unsigned int *)(v67 + 40));
    bzero(*(void **)(v15 + 16), 4 * *(unsigned int *)(v67 + 124));
    bzero(*(void **)(v15 + 24), 4 * *(unsigned int *)(v67 + 140));
  }
  v71 = *(unsigned int **)(v295 + 120);
  v72 = *(_DWORD *)(v295 + 24);
  v281 = *(unsigned int *)(v295 + 28);
  v297 = v71[8];
  v73 = v71[15];
  bzero(*(void **)(v15 + 80), 4 * (v73 * v72));
  v287 = v72;
  if (v72)
  {
    v75 = 0;
    v76 = *(float **)(v15 + 80);
    v77 = *(float **)v15;
    v78 = 4 * v297;
    v277 = 4 * v73;
    do
    {
      memcpy(v76, v77, v78);
      v79 = *v76 * *v76;
      if (v297 < 2)
      {
        v81 = *v76 * *v76;
      }
      else
      {
        v80 = 4;
        v81 = *v76 * *v76;
        do
        {
          v82 = v76[(unint64_t)v80 / 4];
          v81 = v81 + (float)(v82 * v82);
          v83 = v82 * 1.4;
          v76[(unint64_t)v80 / 4] = v83;
          v79 = v79 + (float)(v83 * v83);
          v80 += 4;
        }
        while (v78 != v80);
      }
      v84 = Q_rsqrt(v79 / v81);
      if ((_DWORD)v297)
      {
        v85 = 0;
        do
        {
          v76[v85 / 4] = v84 * v76[v85 / 4];
          v85 += 4;
        }
        while (v78 != v85);
      }
      v86 = v77[18];
      v76[36] = v86;
      v76[37] = v77[19];
      v87 = floorf((float)((float)(v86 * 50.0) + 0.1) + 100.0);
      if (v87 <= 0.0)
        v87 = 0.0;
      v88 = v71[13];
      if (v88 <= v87)
        v89 = v88 - 1;
      else
        v89 = v87;
      v90 = &v76[v71[9]];
      v91 = *(_QWORD *)(v15 + 144);
      v92 = get_padded_len(v71[14], 8u);
      memcpy(v90, (const void *)(v91 + 4 * v92 * v89), 4 * v71[14]);
      v77 += v281;
      v76 = (float *)((char *)v76 + v277);
      ++v75;
      v66 = v295;
    }
    while (v75 != v287);
  }
  v257 = *(uint64_t **)v66;
  v93 = *(unsigned int **)(v66 + 120);
  v259 = *(_DWORD *)(v66 + 24);
  v303[0] = 0;
  v94 = *(_QWORD *)(v15 + 136);
  v95 = v93[8];
  v96 = v93[4];
  v97 = v93[5];
  v261 = v93;
  v98 = (v95 * v95);
  if ((_DWORD)v96)
  {
    *(float *)v74.i32 = (float)v96;
    v99 = (v96 + 1) & 0x1FFFFFFFELL;
    v274 = (uint64x2_t)vdupq_n_s64(v96 - 1);
    v100 = (float32x2_t)vdup_lane_s32(v74, 0);
    v101 = (float *)(v94 + 4 * v98 + 4);
    v102 = (int32x2_t)0x100000000;
    v103 = (uint64x2_t)xmmword_1DEC3D320;
    v104 = (float32x2_t)vdup_n_s32(0x3FC90FDBu);
    v271 = vdupq_n_s64(2uLL);
    do
    {
      v298 = (int64x2_t)v103;
      v288 = vmovn_s64((int64x2_t)vcgeq_u64(v274, v103));
      v105 = vdiv_f32(vmul_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v102), (float32x2_t)0x3F0000003F000000), v104), v100);
      v278 = v105.f32[0];
      v282 = sinf(v105.f32[1]);
      v106.f32[0] = sinf(v278);
      v106.f32[1] = v282;
      v107 = vmul_f32(v106, vmul_f32(v106, v104));
      v279 = v107.f32[0];
      v283 = sinf(v107.f32[1]);
      v108 = sinf(v279);
      if ((v288.i8[0] & 1) != 0)
        *(v101 - 1) = v108;
      if ((v288.i8[4] & 1) != 0)
        *v101 = v283;
      v103 = (uint64x2_t)vaddq_s64(v298, v271);
      v102 = vadd_s32(v102, (int32x2_t)0x200000002);
      v101 += 2;
      v99 -= 2;
    }
    while (v99);
  }
  v109 = v94 + 4 * v98;
  if ((_DWORD)v95)
  {
    v110 = 0;
    v111 = 0;
    do
    {
      for (i = 0; i != v95; ++i)
      {
        v113 = cosf((float)((float)((float)((float)v111 + 0.5) * (float)i) * 3.1416)/ (float)v95);
        if (!i)
          v113 = v113 * 0.70711;
        *(float *)(v94 + 4 * (v110 + i)) = v113;
      }
      ++v111;
      v110 += v95;
    }
    while (v111 != (_DWORD)v95);
    v66 = v295;
  }
  else
  {
    v95 = 0;
  }
  weights_via_offset = opus_fft_alloc_twiddles(v257, v97, (uint64_t *)(v109 + 4 * v96 + 4 * v95 + 4 * v95));
  v10 = v301;
  v114 = v294;
  if (!(_DWORD)weights_via_offset)
  {
    if (v259)
    {
      for (j = 0; j != v259; j = v161 + 1)
      {
        v280 = v261[10];
        v284 = j;
        v116 = (const void *)(*(_QWORD *)(v15 + 80) + 4 * v261[15] * j);
        v117 = *(_QWORD *)(v15 + 136);
        v275 = *(_QWORD *)(v15 + 128);
        v118 = *(_QWORD *)(v66 + 120);
        v119 = *(unsigned int *)(v118 + 32);
        v272 = (v119 * v119);
        v299 = *(unsigned int *)(v118 + 16);
        v120 = v117 + 4 * v272 + 4 * v299;
        v121 = (float *)(v120 + 4 * v119);
        memcpy(v121, v116, 4 * v119);
        *v121 = *v121 + 4.0;
        if ((_DWORD)v119)
        {
          v122 = 0;
          for (k = 0; k != v119; ++k)
          {
            v124 = 0.0;
            v125 = (float *)(v120 + 4 * v119);
            v126 = v122;
            v127 = v119;
            do
            {
              v128 = *v125++;
              v124 = v124 + (float)(v128 * *(float *)(v117 + 4 * v126++));
              --v127;
            }
            while (v127);
            *(float *)(v120 + 4 * k) = v124 * Q_rsqrt((float)v119 * 0.5);
            v122 += v119;
          }
          v129 = (float *)(v117 + 4 * v272 + 4 * v299);
          v130 = v119;
          do
          {
            *v129 = expf(*v129 * 2.3026);
            ++v129;
            --v130;
          }
          while (v130);
        }
        v131 = *(unsigned int **)(v66 + 120);
        v132 = v131[10];
        v133 = v131[5];
        v134 = v131[6];
        v265 = (unsigned int **)&v121[v119];
        v269 = (float *)(v265 + 1);
        v289 = v132;
        v267 = (char *)v265 + 4 * v132 + 12;
        v135 = &v267[4 * v132];
        v136 = v131[8];
        bzero(v135, v134);
        if (v136 != 1)
        {
          v137 = 0;
          v138 = 0;
          v139 = v133 / 0x50;
          do
          {
            v140 = v138++;
            v141 = eband5ms_0[v138];
            v142 = (v141 - v137) * v139;
            if ((_DWORD)v142)
            {
              v143 = 0;
              v144 = v139 * v137;
              do
              {
                *(float *)&v135[4 * (v144 + v143)] = (float)(*(float *)(v120 + 4 * v138)
                                                                         * (float)((float)v143
                                                                                 / (float)v142))
                                                                 + (float)((float)(1.0
                                                                                 - (float)((float)v143
                                                                                         / (float)v142))
                                                                         * *(float *)(v120 + 4 * v140));
                ++v143;
              }
              while (v142 != v143);
            }
            v137 = v141;
          }
          while (v138 != v136 - 1);
        }
        v263 = (float *)&v135[4 * v134];
        v145 = &v263[v133];
        v146 = (float32x2_t *)&v145[2 * v134];
        *(_DWORD *)&v135[4 * (v134 - 1)] = 0;
        bzero(v145, 8 * v134);
        if ((_DWORD)v134)
        {
          v147 = &v263[v133];
          v148 = v134;
          do
          {
            v149 = *(_DWORD *)v135;
            v135 += 4;
            *(_DWORD *)v147 = v149;
            v147 += 2;
            --v148;
          }
          while (v148);
          v150 = &v145[2 * v134];
          v151 = v134;
          do
          {
            v152 = *(_QWORD *)v145;
            v145 += 2;
            *(_QWORD *)v150 = v152;
            v150 += 2;
            --v151;
          }
          while (v151);
        }
        if (v134 < v133)
        {
          v153 = v133 - v134;
          v154 = (float *)(v117 + 8 * (v119 + v289) + 20 * v134 + 4 * (v299 + v133 + v272) + 16);
          do
          {
            v155 = &v146[v153];
            *(v154 - 1) = v155->f32[0];
            *v154 = -v155->f32[1];
            v154 += 2;
            --v153;
          }
          while (v153);
        }
        v156 = (int8x16_t *)&v146[v133];
        opus_fft_c(*v265, v146, v156);
        v157 = (float)v133;
        *v263 = *(float *)v156->i32 * (float)v133;
        v158 = 8 * v289;
        if (v133 >= 2)
        {
          v159 = (float *)(v117 + v158 + 8 * v119 + 4 * v134 + 4 * v299 + 4 * v272 + 16);
          do
            *v159++ = *(float *)&v156->i32[2 * --v133] * v157;
          while (v133 != 1);
        }
        v160 = (v289 + 1);
        if ((_DWORD)v289 == -1)
        {
          *v269 = *v269 + (float)((float)(*v269 * 0.0001) + 0.70175);
          v66 = v295;
          v114 = v294;
          v161 = v284;
        }
        else
        {
          v163 = v158 + 4 * v134;
          v164 = v117 + 8 * v119 + 4 * v299 + 4 * v272 + 12;
          v165 = (v289 + 1);
          v114 = v294;
          v161 = v284;
          do
          {
            *(_DWORD *)(v164 - 4) = *(_DWORD *)(v164 + v163);
            v164 += 4;
            --v165;
          }
          while (v165);
          *v269 = *v269 + (float)((float)(*v269 * 0.0001) + 0.70175);
          v66 = v295;
          if (v160 >= 2)
          {
            v166 = 0;
            do
            {
              v162 = v117 + 8 * v119 + 4 * v299 + 4 * v272 + 12;
              *(float *)(v162 + 4 * v166) = *(float *)(v162 + 4 * v166)
                                          * (float)((float)((float)((float)(v166 + 1) * -0.00006)
                                                          * (float)(v166 + 1))
                                                  + 1.0);
              ++v166;
            }
            while (v160 - 1 != v166);
          }
        }
        celt_lpc((void *)(v275 + 4 * v280 * v161), v267, v269, v289);
      }
    }
    weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 23) + 40), v303);
    v10 = v301;
    if (!(_DWORD)weights_via_offset)
    {
      bzero(*(void **)(v15 + 88), v303[0]);
      weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 23) + 128))(0);
      if (!(_DWORD)weights_via_offset)
      {
        weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 24) + 40), v303);
        if (!(_DWORD)weights_via_offset)
        {
          bzero(*(void **)(v15 + 96), v303[0]);
          weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 24) + 128))(0);
          if (!(_DWORD)weights_via_offset)
          {
            axpy(v261[15] * v259, *(float **)(v15 + 80), 1, *(float **)(v15 + 96), 1, 1.0);
            weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 25) + 40), v303);
            if (!(_DWORD)weights_via_offset)
            {
              bzero(*(void **)(v15 + 104), v303[0]);
              weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 25) + 128))(0);
              if (!(_DWORD)weights_via_offset)
              {
                weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 26) + 40), v303);
                if (!(_DWORD)weights_via_offset)
                {
                  bzero(*(void **)(v15 + 112), v303[0]);
                  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 26) + 128))(0);
                  if (!(_DWORD)weights_via_offset)
                  {
                    weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 27) + 40), v303);
                    if (!(_DWORD)weights_via_offset)
                    {
                      bzero(*(void **)(v15 + 120), v303[0]);
                      weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 27) + 128))(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v167 = (uint64_t *)(*(_QWORD *)(v15 + 136) + 4 * v261[8] * v261[8] + 4 * v261[4] + 4 * v261[8] + 4 * v261[8]);
  v168 = *v167;
  if (*v167)
  {
    if (*(_QWORD *)(v168 + 48))
    {
      (*(void (**)(uint64_t))(v257[1] + 80))(v257[2]);
      *(_QWORD *)(v168 + 48) = 0;
    }
    if ((*(_DWORD *)(v168 + 8) & 0x80000000) != 0 && *(_QWORD *)(v168 + 56))
    {
      (*(void (**)(uint64_t))(v257[1] + 80))(v257[2]);
      *(_QWORD *)(v168 + 56) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v257[1] + 80))(v257[2], v168);
    *v167 = 0;
  }
  if ((_DWORD)weights_via_offset)
  {
    v60 = *v257;
    v61 = "lpcnet forward frame network failed!";
    goto LABEL_26;
  }
  v251 = *(uint64_t **)v66;
  v169 = *(_QWORD *)(v66 + 120);
  v254 = *(_DWORD *)(v66 + 24);
  v268 = *(_QWORD *)(v15 + 8);
  v170 = *(float **)(v15 + 72);
  v171 = *(_DWORD *)(v169 + 112);
  v172 = v171 == 256;
  if (v171 == 256)
    v173 = ulaw2lin8;
  else
    v173 = ulaw2lin7;
  v266 = v173;
  v174 = lin2ulaw7;
  if (v172)
    v174 = lin2ulaw8;
  v264 = v174;
  v270 = *(float **)(v15 + 72);
  if (*(_DWORD *)(v169 + 232))
  {
    weights_via_offset = 7;
    v175 = *(_DWORD *)(v169 + 280);
    v176 = *(float *)(v169 + 284);
    switch(*(_DWORD *)(v169 + 244))
    {
      case 0:
        v179 = v254 - 2;
        if (v254 < 2)
          v179 = 0;
        v253 = 0;
        v254 = v179;
        goto LABEL_161;
      case 1:
        v177 = v254 >= 4;
        v178 = v254 - 4;
        goto LABEL_157;
      case 2:
      case 5:
        v177 = v254 >= 2;
        v178 = v254 - 2;
LABEL_157:
        if (v177)
          v180 = v178;
        else
          v180 = 0;
        v253 = 2;
        v254 = v180;
LABEL_161:
        v170 = *(float **)(v15 + 72);
        goto LABEL_162;
      default:
        goto LABEL_27;
    }
  }
  v253 = 0;
  v176 = 0.0;
  v175 = 128;
LABEL_162:
  __dst = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v251[1] + 16))(v251[2], 1, 4 * *(unsigned int *)(v169 + 104));
  if (!__dst)
  {
    v19 = *v251;
    goto LABEL_6;
  }
  v252 = v253 + v254;
  if (v253 < v253 + v254)
  {
    v181 = 0;
    v182 = 0;
    v260 = v170 + 1;
    v183 = v253;
    v262 = v169;
    do
    {
      v290 = v182;
      v255 = v181;
      if (v181 <= 5)
        v184 = 5;
      else
        v184 = v181;
      v276 = v183;
      v185 = (float *)(*(_QWORD *)(v15 + 112) + 4 * (*(_DWORD *)(v169 + 96) * v183));
      memcpy(*(void **)(v15 + 56), *(const void **)(v15 + 216), 4 * (3 * *(_DWORD *)(v169 + 140)));
      if (*(_DWORD *)(v169 + 148) == 1)
        v186 = (void *)sparse_sgemv_accum16(*(_QWORD *)(v15 + 56), *(_QWORD *)(v15 + 256), (3 * *(_DWORD *)(v169 + 140)), *(_QWORD *)(v15 + 248), v185);
      else
        gemm_ex(*(uint64_t **)v66, 1, 3 * *(_DWORD *)(v169 + 140), *(_DWORD *)(v169 + 96), v185, *(unsigned int *)(v169 + 96), (char *)(*(_QWORD *)(v15 + 208) + 4 * *(unsigned int *)(v169 + 124)), *(unsigned int *)(v169 + 136), *(float32x4_t **)(v15 + 56), 3 * *(_DWORD *)(v169 + 140), 0);
      if (v276 - (unint64_t)v253 <= 5)
        v187 = v253;
      else
        v187 = v276 - 5;
      if (v252 >= (int)v276 + 7)
        v188 = (v276 + 7);
      else
        v188 = v252;
      v189 = *(float **)v15;
      if (v187 >= v188)
      {
        v195 = 0;
      }
      else
      {
        v190 = v253 - 5 + v184;
        v191 = v190 + 1;
        v192 = *(_DWORD *)(v66 + 28);
        v193 = v192 * v190 + 19;
        do
        {
          v194 = v189[v193];
          v195 = v194 > 0.3;
          v196 = v194 > 0.3 || v191++ >= v188;
          v193 += v192;
        }
        while (!v196);
      }
      v182 = v290;
      if (*(_DWORD *)(v169 + 12))
      {
        v258 = v195;
        v273 = 0;
        v197 = 0;
        v198 = fmaxf((float)(v189[(20 * v276 + 19)] * 1.5) + -0.5, 0.0);
        do
        {
          v199 = *(unsigned int *)(v169 + 40);
          v291 = v182;
          v285 = v197;
          if ((_DWORD)v199)
          {
            v200 = v276;
            v201 = v276 * v199;
            v202 = 0.0;
            v203 = v170;
            do
            {
              v204 = *v203++;
              v202 = v202 - (float)(v204 * *(float *)(*(_QWORD *)(v15 + 128) + 4 * v201++));
              --v199;
            }
            while (v199);
          }
          else
          {
            v202 = 0.0;
            v200 = v276;
          }
          v205 = ((uint64_t (*)(void *, float))v264)(v186, v202);
          v206 = v264(*v170);
          v207 = *(const void **)(v15 + 32);
          if (v205 == 128 && v206 == 128 && v175 == 128)
          {
            v208 = *(unsigned int *)(v169 + 104);
            if (v273 == 1)
            {
              v209 = 4 * v208;
              v210 = *(void **)(v15 + 32);
              v211 = __dst;
            }
            else
            {
              accum4(v208, (float *)(*(_QWORD *)(v15 + 120) + 4 * (v208 * v200)), (float *)(*(_QWORD *)(v15 + 152) + 4 * ((_DWORD)v208 << 7)), (float *)(*(_QWORD *)(v15 + 160) + 4 * ((_DWORD)v208 << 7)), (float *)(*(_QWORD *)(v15 + 168) + 4 * ((_DWORD)v208 << 7)), *(float **)(v15 + 32));
              v209 = 4 * *(unsigned int *)(v169 + 104);
              v210 = __dst;
              v211 = v207;
            }
            memcpy(v210, v211, v209);
            v273 = 1;
          }
          else
          {
            v212 = *(_DWORD *)(v169 + 104);
            accum4(v212, (float *)(*(_QWORD *)(v15 + 120) + 4 * v212 * v200), (float *)(*(_QWORD *)(v15 + 152) + 4 * v212 * v206), (float *)(*(_QWORD *)(v15 + 160) + 4 * v212 * v205), (float *)(*(_QWORD *)(v15 + 168) + 4 * v212 * v175), *(float **)(v15 + 32));
          }
          v213 = *(_QWORD *)(v66 + 120);
          v214 = *(float **)(v15 + 16);
          v216 = *(float **)(v15 + 32);
          v215 = *(void **)(v15 + 40);
          v217 = *(unsigned int *)(v213 + 124);
          memcpy(v215, *(const void **)(v15 + 200), 4 * (3 * v217));
          v218 = 0;
          v219 = 3;
          do
          {
            fi_multiply_add_ansic((float *)v215 + v218, (float *)(*(_QWORD *)(v15 + 184) + 4 * v218), v214, v217);
            v218 += v217;
            --v219;
          }
          while (v219);
          v220 = &v216[v217];
          sparse_sgemv_accum16(v215, *(_QWORD *)(v15 + 192), (3 * v217), *(_QWORD *)(v15 + 176), v214);
          axpy((2 * v217), (float *)v215, 1, v216, 1, 1.0);
          fi_activate_array(v216, (2 * v217), 11);
          fi_multiply_add_ansic(&v220[v217], (float *)v215 + (2 * v217), v220, v217);
          fi_activate_array(&v220[v217], v217, *(_DWORD *)(v213 + 132));
          fill_array_f32(v220, v217, 1.0);
          axpy(v217, v216, 1, v220, 1, -1.0);
          fi_multiply_multiply_add_ansic(v214, v216, &v220[v217], v220, v214, v217);
          v300 = *(uint64_t **)v295;
          v221 = *(_DWORD **)(v295 + 120);
          v222 = *(char **)(v15 + 208);
          v223 = *(float **)(v15 + 24);
          v224 = *(float32x4_t **)(v15 + 32);
          v225 = *(float32x4_t **)(v15 + 40);
          v226 = v221[35];
          memcpy(v224, *(const void **)(v15 + 56), 4 * (3 * v226));
          v227 = *(float **)(v15 + 16);
          if (v221[37] == 1)
            sparse_sgemv_accum16(v224, v222, (3 * v226), *(_QWORD *)(v15 + 240), v227);
          else
            gemm_ex(v300, 1, 3 * v226, v221[31], v227, v221[31], v222, v221[34], v224, 3 * v226, 0);
          v228 = &v224->f32[v226];
          memcpy(v225, *(const void **)(v15 + 232), 4 * (3 * v226));
          gemm(v300, 1, 3 * v226, v226, v223, *(char **)(v15 + 224), v225, 0, v250);
          axpy((2 * v226), v225->f32, 1, v224->f32, 1, 1.0);
          fi_activate_array(v224->f32, (2 * v226), 11);
          fi_multiply_add_ansic(&v228[v226], &v225->f32[(2 * v226)], v228, v226);
          fi_activate_array(&v228[v226], v226, v221[36]);
          fill_array_f32(v228, v226, 1.0);
          axpy(v226, v224->f32, 1, v228, 1, -1.0);
          v229 = fi_multiply_multiply_add_ansic(v223, v224->f32, &v228[v226], v228, v223, v226);
          v66 = v295;
          v230 = *(uint64_t **)v295;
          v231 = *(_QWORD *)(v295 + 120);
          v232 = *(float **)(v15 + 64);
          v233 = *(float **)(v15 + 264);
          v234 = *(float **)(v15 + 48);
          v235 = *(unsigned int *)(v231 + 164);
          if ((*(unsigned int (**)(_QWORD, float))(*(_QWORD *)(v231 + 224) + 128))(0, v229))
            log_OutText(*v230, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lpcnet forward dual_fc failed!", v236, v237, v238, v250);
          else
            fi_multiply_multiply_add_ansic(v232, v233, &v232[v235], &v233[v235], v234, v235);
          v10 = v301;
          v114 = v294;
          v170 = v270;
          v169 = v262;
          v239 = sample_from_pdf(*(float **)(v15 + 48), *(_DWORD *)(v262 + 164), v198, *(float *)(v262 + 44), *(float *)(*(_QWORD *)(v15 + 272) + 4 * (v291 & 0x3FF)));
          v175 = v239;
          if (*(_DWORD *)(v262 + 164) <= 0xFFu)
          {
            v240 = 0x100u / (unsigned __int16)*(_DWORD *)(v262 + 164);
            v241 = *(float *)(*(_QWORD *)(v15 + 272) + 4 * (v291 & 0x3FF));
            v175 = v239 * v240;
            v242 = v258;
            if (v241 >= 0.5)
              v242 = 0;
            if (v242)
              v175 += (float)((float)((float)(v241 * 2.16) * (float)v240) * 0.5);
          }
          v243 = v202 + v266((float)v175);
          v186 = memmove(v260, v270, 4 * (*(_DWORD *)(v262 + 40) - 1));
          *v270 = v243;
          v176 = v243 + (float)(*(float *)(v262 + 48) * v176);
          if (v176 >= -32767.0)
            v244 = v176;
          else
            v244 = -32767.0;
          if (v244 <= 32767.0)
            v245 = v244 * 0.000030518;
          else
            v245 = 1.0;
          *(float *)(v268 + 4 * v291) = v245;
          v182 = v291 + 1;
          v197 = v285 + 1;
        }
        while ((v285 + 1) < *(_DWORD *)(v262 + 12));
      }
      v183 = v276 + 1;
      v181 = v255 + 1;
    }
    while (v255 + 1 != v254);
  }
  if (*(_DWORD *)(v169 + 232))
  {
    *(_DWORD *)(v169 + 280) = v175;
    *(float *)(v169 + 284) = v176;
    memcpy(*(void **)(v169 + 248), v170, 4 * *(unsigned int *)(v169 + 40));
    memcpy(*(void **)(v169 + 256), *(const void **)(v15 + 16), 4 * *(unsigned int *)(v169 + 124));
    memcpy(*(void **)(v169 + 264), *(const void **)(v15 + 24), 4 * *(unsigned int *)(v169 + 140));
  }
  (*(void (**)(uint64_t, void *))(v251[1] + 48))(v251[2], __dst);
  v246 = *(_DWORD *)(v10 + 8);
  if (v246 == 22000)
  {
    v247 = *(_DWORD *)(v10 + 12) * v114;
    v248 = v292;
  }
  else
  {
    weights_via_offset = src_generate(v9, 0xBu, v246 / 0x7D0, (uint64_t *)&v302);
    if ((_DWORD)weights_via_offset)
      goto LABEL_27;
    if (*(_DWORD *)(v10 + 232) == 1 && *(_DWORD *)(v10 + 244))
      memcpy((void *)v302[4], *(const void **)(v10 + 272), 4 * *((unsigned int *)v302 + 10));
    v247 = src_filt(v302, v293, *(_DWORD *)(v10 + 12) * v294, *(_QWORD *)(v15 + 120));
    memcpy(v293, *(const void **)(v15 + 120), 4 * v247);
    if (*(_DWORD *)(v10 + 232) != 1 || (v249 = *(_DWORD *)(v301 + 244), v249 == 2) || v249 == 5)
    {
      v10 = v301;
    }
    else
    {
      v10 = v301;
      memcpy(*(void **)(v301 + 272), (const void *)v302[4], 4 * *((unsigned int *)v302 + 10));
    }
    v248 = v292;
    v66 = v295;
  }
  weights_via_offset = 0;
  *(_DWORD *)(v66 + 44) = v247;
  *(_DWORD *)(v248 + 20) = 1;
LABEL_27:
  v62 = v302;
  if (v302)
  {
    if (*v302)
    {
      (*(void (**)(uint64_t, _QWORD))(v9[1] + 48))(v9[2], *v302);
      *v302 = 0;
      *v302 = 0;
      v62 = v302;
    }
    if (v62[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v62[4]);
      v302[4] = 0;
    }
    (*(void (**)(uint64_t))(v9[1] + 48))(v9[2]);
    v302 = 0;
  }
  if (v15)
    (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v15);
  if ((_DWORD)weights_via_offset
    || *(_DWORD *)(v10 + 232) == 1 && ((v63 = *(_DWORD *)(v10 + 244), v63 != 5) ? (v64 = v63 == 2) : (v64 = 1), v64))
  {
    if (*(_QWORD *)(v10 + 248))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 248) = 0;
    }
    if (*(_QWORD *)(v10 + 256))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 256) = 0;
    }
    if (*(_QWORD *)(v10 + 264))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 264) = 0;
    }
    if (*(_QWORD *)(v10 + 272))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 272) = 0;
    }
  }
  return weights_via_offset;
}

uint64_t lpcnet_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  __int128 v11;
  int v12;
  uint64_t result;
  int v14;
  uint64_t v15;
  _QWORD v16[2];
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 120);
  v16[0] = 0;
  v16[1] = 0;
  v17 = 0;
  v20 = 0;
  if (*(_DWORD *)a2 == 2)
  {
    v11 = *a2;
    *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 20) = v11;
    v12 = *(_DWORD *)(v9 + 56) + *(_DWORD *)(v9 + 32) + 20;
    v18 = *((_DWORD *)a2 + 1);
    v19 = v12;
    fi_shape_set(2, (uint64_t)&v18, 4, (uint64_t)v16);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 184) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 192) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 200) + 144))();
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 208) + 144))();
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 216) + 144))();
            if (!(_DWORD)result)
            {
              v14 = *(_DWORD *)(v9 + 140);
              v18 = 1;
              v19 = v14;
              fi_shape_set(2, (uint64_t)&v18, 4, (uint64_t)v16);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 224) + 144))();
              if (!(_DWORD)result)
              {
                *(_DWORD *)(a1 + 40) = 1;
                *(_DWORD *)(a1 + 44) = 330 * *((_DWORD *)a2 + 1);
                *(_DWORD *)(a1 + 56) = 4;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently lpcnet layer only support 2D input", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

_QWORD *free_lpcnet(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[23]);
        fi_layer_free(v3[24]);
        fi_layer_free(v3[25]);
        fi_layer_free(v3[26]);
        fi_layer_free(v3[27]);
        fi_layer_free(v3[28]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t lpcnet_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_len;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    padded_len = get_padded_len(*(unsigned int *)(v8 + 56), 8u);
    v11 = *(_DWORD *)(v8 + 52);
    v12 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    v13 = *(_DWORD *)(v8 + 112);
    v14 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    v15 = *(_DWORD *)(v8 + 116);
    v16 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    v17 = *(_DWORD *)(v8 + 120);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 184) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(4 * (v11 * padded_len + v13 * v12 + v15 * v14 + v17 * v16), 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 192) + 152))();
      if (!(_DWORD)result)
      {
        v20 = get_padded_bytes(padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 200) + 152))();
        if (!(_DWORD)result)
        {
          v21 = get_padded_bytes(v20, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 208) + 152))();
          if (!(_DWORD)result)
          {
            v22 = get_padded_bytes(v21, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 216) + 152))();
            if (!(_DWORD)result)
            {
              v23 = get_padded_bytes(v22, 8u);
              v24 = *(_DWORD *)(v8 + 128);
              v25 = get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              v26 = get_padded_bytes(v23 + 4 * (v24 + (v25 >> 4)), 8u);
              v27 = get_padded_bytes(v26 + 12 * *(_DWORD *)(v8 + 124), 8u);
              v28 = get_padded_bytes(v27 + (*(_DWORD *)(v8 + 128) << 6), 8u);
              v29 = get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              if (*(_DWORD *)(v8 + 148) == 1)
              {
                v30 = get_padded_bytes(v28 + 4 * v29 + (*(_DWORD *)(v8 + 152) << 6), 8u);
                v31 = get_padded_bytes(v30 + 4 * (*(_DWORD *)(v8 + 152) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4)), 8u);
                v28 = get_padded_bytes(v31 + (*(_DWORD *)(v8 + 156) << 6), 8u);
                v32 = *(_DWORD *)(v8 + 156) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4);
              }
              else
              {
                v33 = *(_DWORD *)(v8 + 140);
                v32 = 3 * v33 * get_padded_len((*(_DWORD *)(v8 + 124) + *(_DWORD *)(v8 + 96)), 8u) + v29;
              }
              v34 = get_padded_bytes(v28 + 4 * v32, 8u);
              v35 = get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              v36 = get_padded_len(*(unsigned int *)(v8 + 140), 8u);
              v37 = 3 * *(_DWORD *)(v8 + 140);
              v38 = get_padded_len(v37, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 224) + 152))();
              if (!(_DWORD)result)
              {
                v39 = get_padded_bytes(v34 + 4 * (v35 + v37 * v36 + v38), 8u);
                v40 = get_padded_len(*(unsigned int *)(v8 + 164), 8u);
                v41 = *(_DWORD *)(v8 + 168);
                v42 = get_padded_len(1024, 8u);
                result = 0;
                *a2 = v39 + 4 * (v42 + v41 * v40);
                *a3 = 0;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ERROR: param is NULL in wanted_wb_len(lpcnet)!", a6, a7, a8, v43);
    return 7;
  }
  return result;
}

uint64_t lpcnet_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t result;
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = v9 + 184;
    lpcnet_get_reserved_glbBuf_bytes(a1, &v18);
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *(uint64_t (**)(void))(*(_QWORD *)(v10 + v11) + 160);
      if (v13)
      {
        result = v13();
        if ((_DWORD)result)
          return result;
        if (*(_DWORD *)(*(_QWORD *)(v10 + v11) + 248) > v12)
          v12 = *(_DWORD *)(*(_QWORD *)(v10 + v11) + 248);
      }
      v11 += 8;
    }
    while (v11 != 48);
    v15 = v18;
    padded_bytes = get_padded_bytes(v12, 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes + v15;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t lpcnet_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t result;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    v10 = get_padded_len(*(unsigned int *)(v8 + 56), 8u) * *(_DWORD *)(v8 + 52);
    v11 = 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 112) + 4 * v10;
    v12 = v11 + 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 116);
    padded_bytes = v12 + 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 120);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 184), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 192), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 200), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 208), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 216), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              v14 = *(_DWORD *)(v8 + 128);
              padded_bytes += 4
                            * (v14 + (get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u) >> 4));
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + 12 * *(_DWORD *)(v8 + 124);
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 128) << 6);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              v15 = get_padded_bytes(padded_bytes, 8u);
              padded_bytes = v15;
              if (*(_DWORD *)(v8 + 148) == 1)
              {
                padded_bytes = v15 + (*(_DWORD *)(v8 + 152) << 6);
                padded_bytes = get_padded_bytes(padded_bytes, 8u)
                             + 4 * (*(_DWORD *)(v8 + 152) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4));
                padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 156) << 6);
                v16 = get_padded_bytes(padded_bytes, 8u)
                    + 4 * (*(_DWORD *)(v8 + 156) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4));
              }
              else
              {
                v17 = *(_DWORD *)(v8 + 140);
                v16 = padded_bytes
                    + 12 * v17 * get_padded_len((*(_DWORD *)(v8 + 124) + *(_DWORD *)(v8 + 96)), 8u);
              }
              padded_bytes = v16;
              padded_bytes = get_padded_bytes(v16, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 12 * get_padded_len(*(unsigned int *)(v8 + 140), 8u) * *(_DWORD *)(v8 + 140);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 224), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 164), 8u) * *(_DWORD *)(v8 + 168);
                get_padded_len(1024, 8u);
                return 0;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t lpcnet_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(void);
  uint64_t result;
  uint64_t v11;
  unsigned int v12;

  v2 = *(_QWORD *)(a1 + 120) + 184;
  v12 = 0;
  lpcnet_get_reserved_glbBuf_bytes(a1, &v12);
  v6 = 0;
  v7 = v12;
  while (1)
  {
    v8 = *(_QWORD *)(v2 + v6);
    if (!v8)
      break;
    *(_QWORD *)(v8 + 240) = *(_QWORD *)(a1 + 240) + v7;
    v9 = *(uint64_t (**)(void))(v8 + 168);
    if (v9)
    {
      result = v9();
      if ((_DWORD)result)
        return result;
    }
    v6 += 8;
    if (v6 == 48)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v3, v4, v5, v11);
  return 10;
}

float lpcnet_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  float v5;
  int v6;
  float result;

  if (*(_DWORD *)(a1 + 8) == a4 && a3 == 48)
  {
    v4 = *(_QWORD *)(a1 + 120);
    v5 = *(float *)a2;
    v6 = a2[1];
    *(_DWORD *)(v4 + 232) = *a2;
    *(_DWORD *)(v4 + 244) = v6;
    if (LODWORD(v5) == 1 && v6 == 0)
    {
      *(_OWORD *)(v4 + 248) = *(_OWORD *)(a2 + 2);
      *(_OWORD *)(v4 + 264) = *(_OWORD *)(a2 + 6);
      *(_DWORD *)(v4 + 280) = a2[10];
      result = *((float *)a2 + 11);
      *(float *)(v4 + 284) = result;
    }
  }
  return result;
}

uint64_t lpcnet_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  int v3;
  int step;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t result;
  int v16;
  int padded_len;
  int v18;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = v2[8];
  v18 = v2[4];
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(v2[31], 8u);
  v16 = get_padded_len(v2[35], 8u);
  v5 = get_padded_len((3 * v2[40]), 8u);
  v6 = get_padded_len((3 * v2[40]), 8u);
  v7 = get_padded_len(v2[41], 8u);
  v8 = get_padded_len((3 * v2[35]), 8u);
  v9 = get_padded_len((2 * v2[41]), 8u);
  v10 = get_padded_len(v2[10], 8u);
  v11 = get_padded_len((v2[10] * step), 8u);
  v12 = get_padded_len((v2[24] * step), 8u);
  v13 = v2[26];
  if (v13 <= v2[17] + v2[15] + v2[20] + v2[22])
    v13 = v2[17] + v2[15] + v2[20] + v2[22];
  if (v13 <= 0x14A)
    v13 = 330;
  v14 = v16 + padded_len + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + get_padded_len(v13 * step, 8u);
  result = get_padded_bytes(8 * v3 + 4 * (v18 + v3 * v3) + 8, 8u);
  *a2 = result + 4 * v14;
  return result;
}

uint64_t create_wavernn_layer(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int v22;
  int v23;
  uint64_t v24;
  const char *v25;
  uint64_t result;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  uint64x2_t v41;
  float *v42;
  int64x2_t v43;
  int64x2_t v44;
  int32x2_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;

  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v13)
  {
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 128);
    v18 = v14;
    if (!v14)
    {
      v27 = *a1;
      v28 = "out of memory!";
LABEL_11:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v15, v16, v17, v46);
      *(_QWORD *)(v13 + 120) = v18;
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn init param failed!", v29, v30, v31, v47);
      result = 7;
      goto LABEL_12;
    }
    v19 = *a2;
    v20 = a2[1];
    v21 = a2[3];
    *(_OWORD *)(v14 + 32) = a2[2];
    *(_OWORD *)(v14 + 48) = v21;
    *(_OWORD *)v14 = v19;
    *(_OWORD *)(v14 + 16) = v20;
    v22 = *((_DWORD *)a2 + 4);
    LODWORD(v54) = 5;
    HIDWORD(v54) = v22;
    if ((*((_DWORD *)a2 + 7) - 1) >= 2)
    {
      v24 = *a1;
      v25 = "wavernn only support n_samples=1, 2, but got: %d!";
      v46 = *((unsigned int *)a2 + 7);
      goto LABEL_10;
    }
    v55 = *((_DWORD *)a2 + 7);
    v53 = 0x100000003;
    v49 = 0;
    if (create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v14 + 64))
      || (v23 = *((_DWORD *)a2 + 3),
          LODWORD(v54) = 5,
          HIDWORD(v54) = v23,
          v55 = 0,
          LODWORD(v53) = 3,
          create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v18 + 72))))
    {
      v24 = *a1;
      v25 = "create wavernn pre input dense layer failed!";
LABEL_10:
      log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v15, v16, v17, v46);
      v27 = *a1;
      v28 = "wavernn network init failed!";
      goto LABEL_11;
    }
    v32 = *((_DWORD *)a2 + 2);
    LODWORD(v54) = 23;
    HIDWORD(v54) = v32;
    v55 = *((_DWORD *)a2 + 14);
    fi_get_activation("tanh");
    fi_get_activation("hardsigmoid");
    v50 = *((_DWORD *)a2 + 15);
    v51 = *((_QWORD *)a2 + 5);
    v52 = 0x100000001;
    if (create_gru_layer(a1, (uint64_t)&v54, (__int128 *)&v50, 0, a3, (uint64_t ***)(v18 + 80)))
    {
      v24 = *a1;
      v25 = "create wavernn GRU layer failed!";
      goto LABEL_10;
    }
    v33 = *((_DWORD *)a2 + 5);
    LODWORD(v54) = 5;
    HIDWORD(v54) = v33;
    v55 = 0;
    LODWORD(v53) = 3;
    if (create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v18 + 88)))
    {
      v24 = *a1;
      v25 = "create wavernn post dense layer 0 failed!";
      goto LABEL_10;
    }
    v34 = *((_DWORD *)a2 + 7) * *((_DWORD *)a2 + 6);
    LODWORD(v54) = 5;
    HIDWORD(v54) = v34;
    v55 = *((_DWORD *)a2 + 14);
    LODWORD(v53) = 0;
    if (create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v18 + 96)))
    {
      v24 = *a1;
      v25 = "create wavernn post dense layer 1 failed!";
      goto LABEL_10;
    }
    v35 = *((_DWORD *)a2 + 13);
    LODWORD(v49) = 0;
    HIDWORD(v49) = v35;
    if (create_sampling_layer(a1, &v49, a4, (uint64_t *)(v18 + 104)))
    {
      v24 = *a1;
      v25 = "create wavernn sampling layer failed!";
      goto LABEL_10;
    }
    v48 = *((_DWORD *)a2 + 9);
    if (create_mulaw_layer(a1, &v48, (uint64_t *)(v18 + 112)))
    {
      v24 = *a1;
      v25 = "create wavernn mulaw layer failed!";
      goto LABEL_10;
    }
    v36 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], *((unsigned int *)a2 + 7), 4);
    *(_QWORD *)(v18 + 120) = v36;
    if (!v36)
    {
      v24 = *a1;
      v25 = "out of memory!";
      goto LABEL_10;
    }
    v37 = *((unsigned int *)a2 + 7);
    if ((_DWORD)v37)
    {
      v38 = *((_DWORD *)a2 + 8);
      v39 = *((_DWORD *)a2 + 6);
      v40 = (v37 + 1) & 0x1FFFFFFFELL;
      v41 = (uint64x2_t)vdupq_n_s64(v37 - 1);
      v42 = (float *)(v36 + 4);
      v43 = (int64x2_t)xmmword_1DEC3D320;
      v44 = vdupq_n_s64(2uLL);
      do
      {
        v45 = vmovn_s64((int64x2_t)vcgeq_u64(v41, (uint64x2_t)v43));
        if ((v45.i8[0] & 1) != 0)
          *(v42 - 1) = (float)v38;
        if ((v45.i8[4] & 1) != 0)
          *v42 = (float)(v39 + v38);
        v43 = vaddq_s64(v43, v44);
        v42 += 2;
        v38 += 2 * v39;
        v40 -= 2;
      }
      while (v40);
    }
    result = 0;
    *(_QWORD *)v13 = a1;
    *(_QWORD *)(v13 + 8) = 27;
    *(_QWORD *)(v13 + 120) = v18;
    *(_QWORD *)(v13 + 128) = forward_wavernn_layer;
    *(_QWORD *)(v13 + 136) = free_wavernn_layer;
    *(_QWORD *)(v13 + 144) = wavernn_layer_update_shape;
    *(_QWORD *)(v13 + 152) = wavernn_layer_wanted_wb_len;
    *(_QWORD *)(v13 + 160) = wavernn_request_glbBuf;
    *(_QWORD *)(v13 + 256) = *(_QWORD *)(a3 + 24);
    *(_DWORD *)(v13 + 264) = *(_DWORD *)(a3 + 16);
    *(_QWORD *)(v13 + 224) = wavernn_update_param;
    *(_QWORD *)(v13 + 176) = wavernn_layer_reset;
    *(_QWORD *)(v13 + 184) = wavernn_dispatch_weights;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v46);
    result = 10;
  }
LABEL_12:
  *a5 = v13;
  return result;
}

uint64_t forward_wavernn_layer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  int step;
  uint64_t input_dim;
  size_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const void *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  float *v32;
  unsigned int v33;
  uint64_t v34;
  uint64x2_t v35;
  float *v36;
  int64x2_t v37;
  int64x2_t v38;
  int32x2_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v43;
  char *v44;
  int v45;
  uint64_t *v46;
  char *__dst;
  char *v48;
  unsigned int v49;
  unsigned int v50;
  char *v52;
  unsigned int v53;

  v53 = 0;
  if (!a2)
    return 0;
  v3 = (int *)a2;
  v46 = *(uint64_t **)a2;
  v4 = *(_QWORD *)(a2 + 120);
  v6 = *(_DWORD *)(v4 + 24);
  v5 = *(unsigned int *)(v4 + 28);
  __dst = *(char **)(a2 + 240);
  v52 = &__dst[4 * get_padded_len(v5, 8u)];
  v7 = &v52[4 * get_padded_len(*(unsigned int *)(v4 + 16), 8u)];
  v8 = &v7[4 * get_padded_len(*(unsigned int *)(v4 + 12), 8u)];
  v9 = &v8[4 * get_padded_len(*(unsigned int *)(v4 + 8), 8u)];
  v10 = &v9[4 * get_padded_len(*(unsigned int *)(v4 + 20), 8u)];
  *(_QWORD *)(*(_QWORD *)(v4 + 80) + 240) = &v10[4
                                                 * get_padded_len((*(_DWORD *)(v4 + 28)* *(_DWORD *)(v4 + 24)), 8u)];
  v3 += 5;
  step = fi_shape_get_step(v3);
  input_dim = fi_shape_get_input_dim(v3, (int *)&v53);
  if (!(_DWORD)input_dim)
  {
    v48 = v8;
    v44 = v7;
    v13 = 4 * v5;
    memcpy(__dst, *(const void **)(v4 + 120), 4 * v5);
    v50 = *(_DWORD *)(v4 + 4);
    v49 = v50 * step;
    if (!(v50 * step))
    {
      input_dim = 0;
      v17 = __dst;
LABEL_26:
      if (*(_DWORD *)(v4 + 48))
      {
        memcpy(*(void **)(v4 + 120), v17, v13);
      }
      else if ((_DWORD)v5)
      {
        v33 = *(_DWORD *)(v4 + 32);
        v34 = (v5 + 1) & 0x1FFFFFFFELL;
        v35 = (uint64x2_t)vdupq_n_s64(v5 - 1);
        v36 = (float *)(*(_QWORD *)(v4 + 120) + 4);
        v37 = (int64x2_t)xmmword_1DEC3D320;
        v38 = vdupq_n_s64(2uLL);
        do
        {
          v39 = vmovn_s64((int64x2_t)vcgeq_u64(v35, (uint64x2_t)v37));
          if ((v39.i8[0] & 1) != 0)
            *(v36 - 1) = (float)v33;
          if ((v39.i8[4] & 1) != 0)
            *v36 = (float)(v6 + v33);
          v37 = vaddq_s64(v37, v38);
          v36 += 2;
          v33 += 2 * v6;
          v34 -= 2;
        }
        while (v34);
      }
      return input_dim;
    }
    v45 = 0;
    v14 = 0;
    v15 = v44;
    v16 = v9;
    v17 = __dst;
    while (1)
    {
      if (v14 % v50)
      {
        v18 = v52;
      }
      else
      {
        bzero(v15, 4 * *(unsigned int *)(v4 + 12));
        v19 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 72) + 128))(0);
        if ((_DWORD)v19)
        {
          input_dim = v19;
          v40 = *v46;
          v41 = "wavernn forward local-condition dense failed!";
LABEL_42:
          log_OutText(v40, (uint64_t)"FastInfer", 0, 0, (uint64_t)v41, v20, v21, v22, v43);
          return input_dim;
        }
        a3 += 4 * v53;
        HIDWORD(v23) = -1030792151 * (v45 + 1);
        LODWORD(v23) = HIDWORD(v23);
        v18 = v52;
        ++v45;
        if ((v23 >> 2) <= 0x28F5C28)
          log_OutText(*v46, (uint64_t)"FastInfer", 4, 0, (uint64_t)"step: %d/%d, frame: %d/%d", v20, v21, v22, v14);
        v15 = v44;
      }
      bzero(v18, 4 * *(unsigned int *)(v4 + 16));
      v24 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 64) + 128))(0);
      if ((_DWORD)v24)
      {
        input_dim = v24;
        v40 = *v46;
        v41 = "wavernn forward input dense failed!";
        goto LABEL_42;
      }
      bzero(v48, 4 * *(unsigned int *)(v4 + 8));
      v25 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 80) + 128))(0);
      if ((_DWORD)v25)
      {
        input_dim = v25;
        v40 = *v46;
        v41 = "wavernn forward rnn layer failed!";
        goto LABEL_42;
      }
      bzero(v16, 4 * *(unsigned int *)(v4 + 20));
      v26 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 88) + 128))(0);
      if ((_DWORD)v26)
      {
        input_dim = v26;
        v40 = *v46;
        v41 = "wavernn forward first output dense failed!";
        goto LABEL_42;
      }
      bzero(v10, 4 * (*(_DWORD *)(v4 + 28) * *(_DWORD *)(v4 + 24)));
      v27 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 96) + 128))(0);
      if ((_DWORD)v27)
      {
        input_dim = v27;
        v40 = *v46;
        v41 = "wavernn forward second dense failed!";
        goto LABEL_42;
      }
      if ((_DWORD)v5)
      {
        v28 = 0;
        do
          fi_activate_array((float *)&v10[4 * *(_DWORD *)(v4 + 24) * v28++], *(unsigned int *)(v4 + 24), 9);
        while ((_DWORD)v5 != v28);
      }
      bzero(__dst, 4 * *(unsigned int *)(v4 + 28));
      v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 104) + 128))(0);
      if ((_DWORD)v29)
      {
        input_dim = v29;
        v40 = *v46;
        v41 = "wavernn forward sampling failed!";
        goto LABEL_42;
      }
      input_dim = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 112) + 128))(0);
      if ((_DWORD)v5)
      {
        v30 = 0;
        v31 = v5;
        v32 = (float *)__dst;
        do
        {
          *v32 = (float)(v30 + *v32);
          ++v32;
          v30 += v6;
          --v31;
        }
        while (v31);
      }
      v14 = (v14 + v5);
      if (v14 >= v49)
      {
        v13 = 4 * v5;
        goto LABEL_26;
      }
    }
  }
  return input_dim;
}

_QWORD *free_wavernn_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        fi_layer_free(v3[10]);
        fi_layer_free(v3[11]);
        fi_layer_free(v3[12]);
        fi_layer_free(v3[13]);
        fi_layer_free(v3[14]);
        if (v3[15])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v3[15] = 0;
        }
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t wavernn_layer_update_shape(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;
  unsigned int v9;
  _QWORD v10[2];
  int v11;
  __int128 v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 120);
  v10[0] = 0;
  v10[1] = 0;
  v11 = 0;
  v9 = 0;
  v5 = *(_DWORD *)(v4 + 28) * *(_DWORD *)(v4 + 24);
  v14 = 1;
  v15 = v5;
  v16 = 0;
  v6 = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = *a2;
  *(_DWORD *)(a1 + 36) = v6;
  result = fi_shape_set(2, (uint64_t)&v14, 4, (uint64_t)v10);
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 64) + 144))();
    if (!(_DWORD)result)
    {
      v12 = *a2;
      v13 = *((_DWORD *)a2 + 4);
      DWORD1(v12) = 1;
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 144))();
      if (!(_DWORD)result)
      {
        v8 = *(_DWORD *)(v4 + 12) + *(_DWORD *)(v4 + 16);
        v14 = 1;
        v15 = v8;
        fi_shape_set(2, (uint64_t)&v14, 4, (uint64_t)v10);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 80) + 144))();
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 88) + 144))();
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 96) + 144))();
            if (!(_DWORD)result)
            {
              result = fi_shape_get_size((int *)(*(_QWORD *)(v4 + 96) + 40), (int *)&v9);
              if (!(_DWORD)result)
              {
                v14 = *(_DWORD *)(v4 + 28);
                v15 = v9 / v14;
                fi_shape_set(2, (uint64_t)&v14, 4, (uint64_t)v10);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 104) + 144))();
                if (!(_DWORD)result)
                {
                  (*(void (**)(void))(*(_QWORD *)(v4 + 112) + 144))();
                  v14 = *(_DWORD *)(v4 + 4) * *(_DWORD *)(a1 + 24);
                  v15 = 1;
                  return fi_shape_set(2, (uint64_t)&v14, 4, a1 + 40);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t wavernn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v5;
  uint64_t result;
  int padded_bytes;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;

  v13 = 0;
  v5 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v5[8] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes((int)v13 + HIDWORD(v13), 8u);
    result = (*(uint64_t (**)(void))(v5[9] + 152))();
    if (!(_DWORD)result)
    {
      v8 = get_padded_bytes(HIDWORD(v13) + (int)v13 + padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v5[10] + 152))();
      if (!(_DWORD)result)
      {
        v9 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v8, 8u);
        result = (*(uint64_t (**)(void))(v5[11] + 152))();
        if (!(_DWORD)result)
        {
          v10 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v9, 8u);
          result = (*(uint64_t (**)(void))(v5[12] + 152))();
          if (!(_DWORD)result)
          {
            v11 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v10, 8u);
            result = (*(uint64_t (**)(void))(v5[14] + 152))();
            if (!(_DWORD)result)
            {
              v12 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v11, 8u);
              result = 0;
              *a2 = v12;
              *a3 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t wavernn_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int padded_len;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t);
  uint64_t result;
  int padded_bytes;

  v2 = *(_QWORD *)(a1 + 120);
  v3 = *(_QWORD *)(v2 + 80);
  padded_len = get_padded_len(*(unsigned int *)(v2 + 28), 8u);
  v5 = get_padded_len(*(unsigned int *)(v2 + 16), 8u) + padded_len;
  v6 = get_padded_len(*(unsigned int *)(v2 + 12), 8u);
  v7 = v5 + v6 + get_padded_len(*(unsigned int *)(v2 + 8), 8u);
  v8 = v7 + get_padded_len(*(unsigned int *)(v2 + 20), 8u);
  *(_DWORD *)(a1 + 248) = 4 * (v8 + get_padded_len((*(_DWORD *)(v2 + 28) * *(_DWORD *)(v2 + 24)), 8u));
  v9 = *(uint64_t (**)(uint64_t))(v3 + 160);
  if (!v9 || (result = v9(v3), !(_DWORD)result))
  {
    padded_bytes = get_padded_bytes(*(_DWORD *)(v3 + 248), 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) += padded_bytes;
  }
  return result;
}

uint64_t wavernn_layer_reset(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64x2_t v9;
  float *v10;
  int64x2_t v11;
  int64x2_t v12;
  int32x2_t v13;

  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(v1 + 80);
  if (!v2 || (v3 = *(uint64_t (**)(void))(v2 + 176)) == 0 || (result = v3(), !(_DWORD)result))
  {
    v5 = *(unsigned int *)(v1 + 28);
    if ((_DWORD)v5)
    {
      v6 = *(_DWORD *)(v1 + 32);
      v7 = *(_DWORD *)(v1 + 24);
      v8 = (v5 + 1) & 0x1FFFFFFFELL;
      v9 = (uint64x2_t)vdupq_n_s64(v5 - 1);
      v10 = (float *)(*(_QWORD *)(v1 + 120) + 4);
      v11 = (int64x2_t)xmmword_1DEC3D320;
      v12 = vdupq_n_s64(2uLL);
      do
      {
        v13 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v11));
        if ((v13.i8[0] & 1) != 0)
          *(v10 - 1) = (float)v6;
        if ((v13.i8[4] & 1) != 0)
          *v10 = (float)(v7 + v6);
        v11 = vaddq_s64(v11, v12);
        v10 += 2;
        v6 += 2 * v7;
        v8 -= 2;
      }
      while (v8);
    }
    return 0;
  }
  return result;
}

uint64_t wavernn_update_param(uint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t vars0;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  if (a3 == 4)
  {
    result = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) = *a2;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn update param incorrect nbytes (need 4bytes)", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t wavernn_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)a1;
  v2 = *(uint64_t **)(a1 + 120);
  v3 = *(_QWORD *)(a1 + 72);
  v4 = *(_DWORD *)(a1 + 80);
  result = fi_layer_find_weights_via_offset(v2[8], v3, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v2[9], v3, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v2[10], v3, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(v2[11], v3, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(v2[12], v3, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(v2[14], v3, &padded_bytes);
            if (!(_DWORD)result)
            {
              v6 = get_padded_bytes(padded_bytes, 8u);
              padded_bytes = v6;
              if ((_DWORD)v6 == v4)
              {
                return 0;
              }
              else
              {
                log_OutText(*v1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn weights lentgh error, wanted: %d bytes, but weights file: %d bytes", v7, v8, v9, v6);
                return 7;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t create_conv1d_proj_layer(uint64_t *a1, unsigned int *a2, uint64_t **a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  int v32;

  v7 = 0;
  result = 7;
  if (!a1 || !a2)
    goto LABEL_19;
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v7)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v30);
    result = 10;
    goto LABEL_19;
  }
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 32);
  v19 = v15;
  if (!v15)
  {
    v24 = *a1;
    v25 = "out of memory!";
LABEL_18:
    log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v16, v17, v18, v30);
    *(_QWORD *)(v7 + 120) = v19;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_proj init param failed!", v27, v28, v29, v30);
    result = 7;
    goto LABEL_19;
  }
  *(_OWORD *)v15 = *(_OWORD *)a2;
  if (!*(_DWORD *)(v15 + 4))
  {
    v24 = *a1;
    v25 = "# projection feature1 must be greater than zero!";
    goto LABEL_18;
  }
  if (!*(_DWORD *)(v15 + 8))
  {
    v24 = *a1;
    v25 = "# projection feature2 must be greater than zero!";
    goto LABEL_18;
  }
  v32 = 0;
  v30 = 0u;
  v31 = 0u;
  if (config_conv1d_norm_layer(a2[1], *a2, 1, 1, 0, 1, a2[3], &v30))
  {
    v23 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
LABEL_17:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v20, v21, v22, v30);
    v24 = *a1;
    v25 = "conv1d_proj network init failed!";
    goto LABEL_18;
  }
  if (create_conv1d_norm_layer(a1, (uint64_t)&v30, a3, a4, (uint64_t *)(v19 + 16)))
  {
    v23 = "create conv1d_proj sub-conv1d_norm1 layer failed!";
    goto LABEL_17;
  }
  v26 = a2[2];
  v32 = 0;
  LODWORD(v31) = v26;
  if (create_conv1d_norm_layer(a1, (uint64_t)&v30, a3, a4, (uint64_t *)(v19 + 24)))
  {
    v23 = "create conv1d_proj sub-conv1d_norm2 layer failed!";
    goto LABEL_17;
  }
  *(_QWORD *)(v7 + 120) = v19;
  if (a3)
    *(_QWORD *)(v7 + 60) = *a3;
  *(_QWORD *)v7 = a1;
  *(_QWORD *)(v7 + 128) = forward_conv1d_proj_layer;
  *(_QWORD *)(v7 + 136) = free_conv1d_proj_layer;
  *(_QWORD *)(v7 + 144) = conv1d_proj_update_shape;
  *(_QWORD *)(v7 + 152) = conv1d_proj_wanted_wb_len;
  *(_QWORD *)(v7 + 8) = 52;
  *(_QWORD *)(v7 + 184) = conv1d_proj_dispatch_weights;
  *(_QWORD *)(v7 + 160) = conv1d_proj_request_glbBuf;
  *(_QWORD *)(v7 + 168) = conv1d_proj_assign_glbBuf;
  if (a4)
  {
    result = 0;
    *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
    *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v20, v21, v22, v30);
    result = 0;
    *(_QWORD *)(v7 + 256) = 0;
    *(_DWORD *)(v7 + 264) = 0;
  }
LABEL_19:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_proj_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  void *v12;
  uint64_t bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v21;
  size_t v22;

  LODWORD(v22) = 0;
  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(_QWORD *)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v21);
    return 7;
  }
  v12 = *(void **)(a2 + 240);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 16) + 40), &v22);
  if (!(_DWORD)bytes)
  {
    bzero(v12, v22);
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 128))(a1);
    if ((_DWORD)v14)
    {
      bytes = v14;
      v18 = *v8;
      v19 = "conv1d_proj forward sub-conv1d_proj layer 1 failed!";
LABEL_6:
      log_OutText(v18, (uint64_t)"FastInfer", 0, 0, (uint64_t)v19, v15, v16, v17, v21);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 24) + 40), &v22);
    if (!(_DWORD)bytes)
    {
      bzero(a4, v22);
      bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 24) + 128))(a1);
      if ((_DWORD)bytes)
      {
        v18 = *v8;
        v19 = "conv1d_proj forward sub-conv1d_proj layer 2 failed!";
        goto LABEL_6;
      }
    }
  }
  return bytes;
}

_QWORD *free_conv1d_proj_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 16));
        fi_layer_free(*(_QWORD *)(v3 + 24));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 conv1d_proj_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  __int128 v11;
  uint64_t v12;
  const char *v13;
  __n128 result;
  uint64_t v15;
  __n128 *v16;
  unsigned int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v12 = *v9;
    v13 = "NULL param!";
    goto LABEL_5;
  }
  v11 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v11;
  if (*(_DWORD *)a2 >= 3u)
  {
    v12 = *v9;
    v13 = "Currently conv1d_proj layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 16) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 24) + 144))())
  {
    v15 = *(_QWORD *)(v8 + 24);
    v17 = *(_DWORD *)(v15 + 40);
    v16 = (__n128 *)(v15 + 40);
    if (v17 >= 3)
    {
      v12 = *v9;
      v13 = "final output shape error: Currently conv1d_proj only support 1D or 2D output";
      goto LABEL_5;
    }
    result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t conv1d_proj_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 16) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(0, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 24) + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(padded_bytes, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"out_feats1: %d\n", v14, v15, v16, *(unsigned int *)(v9 + 4));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"out_feats2: %d\n", v17, v18, v19, *(unsigned int *)(v9 + 8));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v20, v21, v22, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v23, v24, v25, *a2);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v26);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t (*v10)(void);
  uint64_t result;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t v14;
  uint64_t v15;
  int v16;

  v9 = *(_QWORD *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v15);
    return 7;
  }
  v10 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 16) + 160);
  if (v10)
  {
    result = v10();
    if ((_DWORD)result)
      return result;
    v12 = *(_DWORD *)(*(_QWORD *)(v9 + 16) + 248);
  }
  else
  {
    v12 = 0;
  }
  v13 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 24) + 160);
  if (v13)
  {
    result = v13();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 24) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 24) + 248);
  }
  v14 = *(_QWORD *)(a1 + 120);
  v16 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v14 + 16) + 40), &v16);
  if (!(_DWORD)result)
    *(_DWORD *)(a1 + 248) = v16 + v12;
  return result;
}

uint64_t conv1d_proj_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 16), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 24), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(void);
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  unsigned int v17;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v17 = 0;
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 16) + 40), &v17);
    if (!(_DWORD)result)
    {
      v11 = v17;
      v12 = *(_QWORD *)(v9 + 16);
      *(_QWORD *)(v12 + 240) = *(_QWORD *)(a1 + 240) + v17;
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
      v14 = *(_QWORD *)(v9 + 24);
      *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v15 = *(void (**)(void))(v14 + 168);
      if (v15)
        v15();
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v16);
    return 7;
  }
  return result;
}

uint64_t config_conv1d_proj_layer(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return 0;
}

uint64_t create_mrf_layer(uint64_t *a1, unsigned int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  __int128 v58[2];
  unsigned int v59;

  v6 = 0;
  result = 7;
  if (a1 && a2)
  {
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v6)
    {
      v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 144);
      v17 = (_QWORD *)v13;
      if (!v13)
      {
        v43 = *a1;
        v44 = "out of memory!";
LABEL_37:
        log_OutText(v43, (uint64_t)"FastInfer", 0, 0, (uint64_t)v44, v14, v15, v16, v48);
        *(_QWORD *)(v6 + 120) = v17;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"MRF init param failed!", v45, v46, v47, v49);
        result = 7;
        goto LABEL_38;
      }
      v18 = *(_OWORD *)a2;
      v19 = *((_OWORD *)a2 + 1);
      v20 = *((_OWORD *)a2 + 3);
      *(_OWORD *)(v13 + 32) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(v13 + 48) = v20;
      *(_OWORD *)v13 = v18;
      *(_OWORD *)(v13 + 16) = v19;
      v21 = *((_OWORD *)a2 + 4);
      v22 = *((_OWORD *)a2 + 5);
      v23 = *((_OWORD *)a2 + 6);
      *(_QWORD *)(v13 + 112) = *((_QWORD *)a2 + 14);
      *(_OWORD *)(v13 + 80) = v22;
      *(_OWORD *)(v13 + 96) = v23;
      *(_OWORD *)(v13 + 64) = v21;
      v59 = 0;
      memset(v58, 0, sizeof(v58));
      v24 = *a2;
      v25 = a2[4];
      v26 = a2[17];
      LODWORD(v56) = 5;
      HIDWORD(v56) = v26;
      v57 = 0;
      v55 = 0x100000000;
      v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 12, 8);
      v17[15] = v27;
      if (!v27
        || (v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 12, 8),
            (v17[16] = v31) == 0))
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v28, v29, v30, v48);
LABEL_36:
        v43 = *a1;
        v44 = "MRF network init failed!";
        goto LABEL_37;
      }
      v51 = a4;
      config_conv1d_layer(a2[17], 1, 1, 1, 1, 1, a2[18], v58);
      if ((_DWORD)v24)
      {
        v53 = 0;
        v54 = 0;
        v50 = (v25 - 1);
        v52 = v25;
        while (!(_DWORD)v25)
        {
LABEL_27:
          ++v53;
          v54 += 4;
          LODWORD(v25) = v52;
          if (v53 == v24)
            goto LABEL_28;
        }
        v32 = v54;
        v33 = v52;
        v34 = v50;
        while (1)
        {
          v35 = a2[v32 + 5];
          LODWORD(v58[0]) = a2[v53 + 1];
          DWORD2(v58[0]) = v35;
          if (a2[20] != 1)
          {
            if (v34 || (v36 = a2[21]) != 0)
            {
              if (a2[22] == 1)
                v36 = 0;
              else
                v36 = a2[18];
            }
            v59 = v36;
          }
          if (create_conv1d_layer(a1, v58, 0, a3, (uint64_t ***)(v17[15] + 8 * v32)))
          {
            v41 = *a1;
            v42 = "create MRF sub-conv1d layer failed!";
            goto LABEL_35;
          }
          if (a2[20] == 1)
          {
            if (v34 || (v40 = a2[21]) != 0)
            {
              if (a2[22] == 1)
                v40 = 0;
              else
                v40 = a2[18];
            }
            LODWORD(v55) = v40;
            if (create_fc_layer(a1, &v56, &v55, 0, a3, (uint64_t *)(v17[16] + 8 * v32)))
              break;
          }
          --v34;
          ++v32;
          if (!--v33)
            goto LABEL_27;
        }
        v41 = *a1;
        v42 = "create MRF sub-fc layer failed!";
        goto LABEL_35;
      }
LABEL_28:
      LODWORD(v55) = 0;
      if (create_fc_layer(a1, &v56, &v55, 0, a3, v17 + 17))
      {
        v41 = *a1;
        v42 = "create MRF sub-residual fc layer failed!";
LABEL_35:
        log_OutText(v41, (uint64_t)"FastInfer", 0, 0, (uint64_t)v42, v37, v38, v39, v48);
        a4 = v51;
        goto LABEL_36;
      }
      *(_QWORD *)v6 = a1;
      *(_QWORD *)(v6 + 8) = 70;
      *(_QWORD *)(v6 + 120) = v17;
      *(_QWORD *)(v6 + 128) = forward_mrf_layer;
      *(_QWORD *)(v6 + 136) = free_mrf_layer;
      *(_QWORD *)(v6 + 144) = mrf_layer_update_shape;
      *(_QWORD *)(v6 + 152) = mrf_layer_wanted_wb_len;
      *(_QWORD *)(v6 + 160) = mrf_layer_request_glbBuf;
      *(_QWORD *)(v6 + 184) = mrf_layer_dispatch_weights;
      *(_QWORD *)(v6 + 168) = mrf_layer_assign_glbBuf;
      a4 = v51;
      if (a3)
      {
        result = 0;
        *(_QWORD *)(v6 + 256) = *(_QWORD *)(a3 + 24);
        *(_DWORD *)(v6 + 264) = *(_DWORD *)(a3 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v37, v38, v39, v48);
        result = 0;
        *(_QWORD *)(v6 + 256) = 0;
        *(_DWORD *)(v6 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v48);
      result = 10;
    }
  }
LABEL_38:
  *a4 = v6;
  return result;
}

uint64_t forward_mrf_layer(uint64_t a1, uint64_t a2, void *a3, float *a4)
{
  int *v7;
  uint64_t *v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t bytes;
  size_t v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  float *v21;
  float *v22;
  float *v23;
  uint64_t v24;
  float *v25;
  float *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  size_t v35;
  float *v36;
  uint64_t v37;
  const char *v38;
  size_t v40;
  float *v41;
  float *v42;
  unsigned int v43;
  uint64_t v44;
  float *v45;
  float *v46;
  size_t v47;
  float *v48;
  float *v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t *v55;
  float *v56;
  float *v57;
  float *v58;
  unsigned int v59;
  float *v60;
  void *v61;
  char *v62;
  uint64_t v63;
  unsigned int __n;
  unsigned int __n_4;

  v7 = *(int **)(a2 + 120);
  v8 = *(uint64_t **)a2;
  v9 = (int *)(a2 + 40);
  if (v7[22] != 1)
  {
    __n_4 = 0;
    v33 = *v7;
    v34 = v7[4];
    bytes = fi_shape_get_bytes(v9, &__n_4);
    if ((_DWORD)bytes)
      return bytes;
    v35 = __n_4;
    bzero(a4, __n_4);
    v36 = *(float **)(a2 + 240);
    if (v7[19] == 1)
    {
      memcpy(v36, a3, v35);
      fi_activate_array(v36, __n_4 >> 2, 14);
    }
    v15 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v7 + 17) + 128))(0);
    if ((_DWORD)v15)
      goto LABEL_34;
    v63 = v34;
    v55 = v8;
    v52 = v33;
    if (!v33)
    {
LABEL_58:
      v32 = __n_4;
      goto LABEL_59;
    }
    v59 = 0;
    v54 = 0;
    v40 = v35 >> 2;
    v41 = &v36[v35 >> 2];
    v57 = a4;
    v61 = a3;
    while (1)
    {
      v42 = (float *)a3;
      if ((_DWORD)v63)
        break;
LABEL_57:
      a4 = v57;
      axpy(__n_4 >> 2, v42, 1, v57, 1, 1.0);
      v59 += 4;
      ++v54;
      a3 = v61;
      if (v54 == v52)
        goto LABEL_58;
    }
    v43 = v59;
    v44 = v63;
    v45 = (float *)v61;
    v46 = v36;
    while (1)
    {
      v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 15) + 8 * v43) + 128))(0);
      if ((_DWORD)v29)
        goto LABEL_60;
      if (v7[20] != 1)
        break;
      if (v45 == v41)
        v47 = v40;
      else
        v47 = 0;
      v48 = &v41[v47];
      v30 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 16) + 8 * v43) + 128))(0);
      if ((_DWORD)v30)
      {
LABEL_61:
        bytes = v30;
        v37 = *v55;
        v38 = "MRF forward sub-fc layer failed!";
        goto LABEL_35;
      }
      if (!v7[23])
      {
        v46 = v48;
        v49 = v36;
LABEL_55:
        v48 = v45;
        goto LABEL_56;
      }
      axpy(__n_4 >> 2, v45, 1, v48, 1, 1.0);
      v46 = v48;
      v49 = v36;
LABEL_56:
      v42 = v46;
      ++v43;
      v45 = v48;
      v46 = v49;
      if (!--v44)
        goto LABEL_57;
    }
    if (v7[23])
    {
      axpy(__n_4 >> 2, v45, 1, v46, 1, 1.0);
      v45 = v46;
    }
    if (v46 == v36)
      v49 = v41;
    else
      v49 = v36;
    goto LABEL_55;
  }
  __n = 0;
  v10 = *v7;
  v11 = v7[4];
  bytes = fi_shape_get_bytes(v9, &__n);
  if (!(_DWORD)bytes)
  {
    v13 = __n;
    bzero(a4, __n);
    v14 = *(float **)(a2 + 240);
    memcpy(v14, a3, v13);
    fi_activate_array(v14, __n >> 2, v7[18]);
    v15 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v7 + 17) + 128))(0);
    if (!(_DWORD)v15)
    {
      v60 = (float *)a3;
      v55 = v8;
      if (v10)
      {
        v19 = 0;
        v51 = v10;
        v53 = 0;
        v20 = v13 & 0xFFFFFFFC;
        v21 = (float *)((char *)v14 + v20);
        v22 = (float *)((char *)v14 + v20 + v20);
        v62 = (char *)v22 + v20;
        v56 = a4;
        v58 = v14;
        while (1)
        {
          v23 = v14;
          if ((_DWORD)v11)
            break;
LABEL_28:
          a4 = v56;
          axpy(__n >> 2, v23, 1, v56, 1, 1.0);
          v19 += 4;
          ++v53;
          v14 = v58;
          if (v53 == v51)
            goto LABEL_29;
        }
        v24 = 0;
        v25 = v21;
        v23 = v58;
        v26 = v60;
        while (1)
        {
          if (v24)
          {
            if (v26 == v22)
              v27 = v62;
            else
              v27 = v22;
            memcpy(v27, v23, __n);
            fi_activate_array((float *)v27, __n >> 2, v7[18]);
          }
          v28 = (v19 + v24);
          v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 15) + 8 * v28) + 128))(0);
          if ((_DWORD)v29)
            break;
          if (v7[20] == 1)
          {
            if (v26 == v22)
              v25 = (float *)v62;
            else
              v25 = v22;
            v30 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 16) + 8 * v28) + 128))(0);
            if ((_DWORD)v30)
              goto LABEL_61;
            if (v7[23])
            {
              axpy(__n >> 2, v26, 1, v25, 1, 1.0);
              v26 = v25;
            }
            v31 = v21;
          }
          else
          {
            if (v7[23])
            {
              axpy(__n >> 2, v26, 1, v25, 1, 1.0);
              v26 = v25;
            }
            if (v25 == v21)
              v31 = v22;
            else
              v31 = v21;
          }
          v23 = v25;
          ++v24;
          v25 = v31;
          if (v11 == v24)
            goto LABEL_28;
        }
LABEL_60:
        bytes = v29;
        v37 = *v55;
        v38 = "MRF forward sub-conv layer failed!";
        goto LABEL_35;
      }
LABEL_29:
      v32 = __n;
LABEL_59:
      fi_activate_array(a4, v32 >> 2, v7[18]);
      return 0;
    }
LABEL_34:
    bytes = v15;
    v37 = *v8;
    v38 = "MRF forward residual fc layer failed!";
LABEL_35:
    log_OutText(v37, (uint64_t)"FastInfer", 0, 0, (uint64_t)v38, v16, v17, v18, v50);
  }
  return bytes;
}

_QWORD *free_mrf_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  int *v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (int *)result[15];
      if (v3)
      {
        v4 = *v3;
        if (*v3)
        {
          v5 = 0;
          v6 = 0;
          LODWORD(v7) = v3[4];
          do
          {
            if ((_DWORD)v7)
            {
              v8 = 0;
              do
              {
                fi_layer_free(*(_QWORD *)(*((_QWORD *)v3 + 15) + 8 * (v5 + v8)));
                fi_layer_free(*(_QWORD *)(*((_QWORD *)v3 + 16) + 8 * (v5 + v8++)));
                v7 = v3[4];
              }
              while (v8 < v7);
              v4 = *v3;
            }
            ++v6;
            v5 += 4;
          }
          while (v6 < v4);
        }
        fi_layer_free(*((_QWORD *)v3 + 17));
        if (*((_QWORD *)v3 + 15))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *((_QWORD *)v3 + 15) = 0;
        }
        if (*((_QWORD *)v3 + 16))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *((_QWORD *)v3 + 16) = 0;
        }
        (*(void (**)(_QWORD, int *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t mrf_layer_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  int v11;
  uint64_t v12;
  __int128 v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t result;
  __int128 v19;
  uint64_t v20;

  if (*(_DWORD *)a2 == 2)
  {
    v10 = *(int **)(a1 + 120);
    v11 = *v10;
    v12 = v10[4];
    v13 = *a2;
    *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 20) = v13;
    if (v11)
    {
      v14 = 0;
      v15 = 0;
      while (!(_DWORD)v12)
      {
LABEL_10:
        ++v15;
        v14 += 4;
        if (v15 == v11)
          goto LABEL_11;
      }
      v16 = v12;
      v17 = v14;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v10 + 15) + 8 * v17) + 144))();
        if ((_DWORD)result)
          break;
        if (v10[20] == 1)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v10 + 16) + 8 * v17) + 144))();
          if ((_DWORD)result)
            break;
        }
        ++v17;
        if (!--v16)
          goto LABEL_10;
      }
    }
    else
    {
LABEL_11:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v10 + 17) + 144))();
      if (!(_DWORD)result)
      {
        v19 = *a2;
        *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
        *(_OWORD *)(a1 + 40) = v19;
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently MRF layer only support 2D input", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t mrf_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int *v4;
  int v5;
  unsigned int v7;
  int v8;
  unsigned int padded_bytes;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = *(int **)(a1 + 120);
  v5 = *v4;
  if (*v4)
  {
    v7 = 0;
    v8 = 0;
    padded_bytes = 0;
    v10 = v4[4];
    while (!(_DWORD)v10)
    {
LABEL_10:
      ++v8;
      v7 += 4;
      if (v8 == v5)
        goto LABEL_13;
    }
    v11 = v10;
    v12 = v7;
    while (1)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v4 + 15) + 8 * v12) + 152))();
      if ((_DWORD)result)
        break;
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      if (v4[20] == 1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v4 + 16) + 8 * v12) + 152))();
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
      }
      ++v12;
      if (!--v11)
        goto LABEL_10;
    }
  }
  else
  {
    padded_bytes = 0;
LABEL_13:
    result = (*(uint64_t (**)(void))(*((_QWORD *)v4 + 17) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_kernels: %d\n", v14, v15, v16, *v4 % 0x64u);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v17, v18, v19, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v20, v21, v22, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t mrf_layer_request_glbBuf(uint64_t a1)
{
  int *v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t (*v13)(void);
  uint64_t (*v14)(void);
  uint64_t (*v15)(void);
  int v16;

  v2 = *(int **)(a1 + 120);
  v16 = 0;
  v3 = *v2;
  v4 = v2[4];
  result = mrf_layer_get_reserved_glbBuf_bytes(a1, &v16);
  if (!(_DWORD)result)
  {
    v6 = v16;
    if (v3)
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      do
      {
        if ((_DWORD)v4)
        {
          v10 = v4;
          v11 = v7;
          do
          {
            v12 = v11;
            v13 = *(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v11) + 160);
            if (v13)
            {
              result = v13();
              if ((_DWORD)result)
                return result;
              if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v12) + 248) > v9)
                v9 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v12) + 248);
            }
            if (v2[20] == 1)
            {
              v14 = *(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v12) + 160);
              if (v14)
              {
                result = v14();
                if ((_DWORD)result)
                  return result;
                if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v12) + 248) > v9)
                  v9 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v12) + 248);
              }
            }
            v11 = v12 + 1;
            --v10;
          }
          while (v10);
        }
        ++v8;
        v7 += 4;
      }
      while (v8 != v3);
    }
    else
    {
      v9 = 0;
    }
    v15 = *(uint64_t (**)(void))(*((_QWORD *)v2 + 17) + 160);
    if (v15)
    {
      result = v15();
      if ((_DWORD)result)
        return result;
      if (*(_DWORD *)(*((_QWORD *)v2 + 17) + 248) > v9)
        v9 = *(_DWORD *)(*((_QWORD *)v2 + 17) + 248);
    }
    result = 0;
    *(_DWORD *)(a1 + 248) = v9 + v6;
  }
  return result;
}

uint64_t mrf_layer_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int padded_bytes;

  v8 = *(int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *(_QWORD *)(a1 + 72);
  padded_bytes = 0;
  v11 = *v8;
  if (*v8)
  {
    v12 = 0;
    v13 = 0;
    v14 = v8[4];
    while (!(_DWORD)v14)
    {
LABEL_12:
      ++v13;
      v12 += 4;
      if (v13 == v11)
        goto LABEL_13;
    }
    v15 = v14;
    v16 = v12;
    while (1)
    {
      v17 = *(_QWORD *)(*((_QWORD *)v8 + 15) + 8 * v16);
      if (!v17)
        goto LABEL_16;
      result = fi_layer_find_weights_via_offset(v17, v10, &padded_bytes);
      if ((_DWORD)result)
        return result;
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      if (v8[20] == 1)
      {
        v19 = *(_QWORD *)(*((_QWORD *)v8 + 16) + 8 * v16);
        if (!v19)
          goto LABEL_16;
        result = fi_layer_find_weights_via_offset(v19, v10, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
      }
      ++v16;
      if (!--v15)
        goto LABEL_12;
    }
  }
LABEL_13:
  v20 = *((_QWORD *)v8 + 17);
  if (!v20)
  {
LABEL_16:
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"mrf: a sublayer is not initialized!", a6, a7, a8, v21);
    return 10;
  }
  result = fi_layer_find_weights_via_offset(v20, v10, &padded_bytes);
  if (!(_DWORD)result)
  {
    get_padded_bytes(padded_bytes, 8u);
    return 0;
  }
  return result;
}

uint64_t mrf_layer_assign_glbBuf(uint64_t a1)
{
  int *v2;
  int v3;
  uint64_t v4;
  uint64_t reserved_glbBuf_bytes;
  uint64_t v6;
  unsigned int v7;
  int i;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  void (*v14)(void);
  uint64_t v15;
  void (*v16)(void);
  unsigned int v18;

  v2 = *(int **)(a1 + 120);
  v18 = 0;
  v3 = *v2;
  v4 = v2[4];
  reserved_glbBuf_bytes = mrf_layer_get_reserved_glbBuf_bytes(a1, (int *)&v18);
  if (!(_DWORD)reserved_glbBuf_bytes)
  {
    v6 = v18;
    if (v3)
    {
      v7 = 0;
      for (i = 0; i != v3; ++i)
      {
        if ((_DWORD)v4)
        {
          v9 = v4;
          v10 = v7;
          do
          {
            v11 = *(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v10);
            *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v6;
            v12 = *(void (**)(void))(v11 + 168);
            if (v12)
              v12();
            if (v2[20] == 1)
            {
              v13 = *(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v10);
              *(_QWORD *)(v13 + 240) = *(_QWORD *)(a1 + 240) + v6;
              v14 = *(void (**)(void))(v13 + 168);
              if (v14)
                v14();
            }
            ++v10;
            --v9;
          }
          while (v9);
        }
        v7 += 4;
      }
    }
    v15 = *((_QWORD *)v2 + 17);
    *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v6;
    v16 = *(void (**)(void))(v15 + 168);
    if (v16)
      v16();
  }
  return reserved_glbBuf_bytes;
}

uint64_t mrf_layer_get_reserved_glbBuf_bytes(uint64_t a1, int *a2)
{
  uint64_t v3;
  uint64_t result;
  int v5;
  int v6;

  v3 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 136) + 40), &v6);
  if (!(_DWORD)result)
  {
    v5 = 4 * v6;
    if (*(_DWORD *)(v3 + 88) != 1)
      v5 = 3 * v6;
    *a2 = v5;
  }
  return result;
}

uint64_t create_cbhg_layer(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t ***a5)
{
  uint64_t **v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  __int128 v21;
  int v22;
  int v23;
  int v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 88);
      v19 = v15;
      if (!v15)
      {
        v25 = "out of memory!";
        goto LABEL_27;
      }
      v20 = *(_DWORD *)(a2 + 32);
      v21 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)v15 = *(_OWORD *)a2;
      *(_OWORD *)(v15 + 16) = v21;
      *(_DWORD *)(v15 + 32) = v20;
      v22 = *(_DWORD *)(v15 + 24);
      v23 = *(_DWORD *)(v15 + 12);
      v24 = *(_DWORD *)(v15 + 16);
      if (v23 == v22)
      {
        if (v24)
        {
LABEL_7:
          v25 = "usage of pre-highway layer mismatch!";
LABEL_27:
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v16, v17, v18, v29);
          v7[15] = (uint64_t *)v19;
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"cbhg init param failed!", v26, v27, v28, v30);
          result = 7;
          goto LABEL_28;
        }
      }
      else if (!v24)
      {
        goto LABEL_7;
      }
      if (!*(_DWORD *)(v15 + 4))
      {
        v25 = "cb_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)(v15 + 8))
      {
        v25 = "cp_feats1 must be greater than zero!";
        goto LABEL_27;
      }
      if (!v23)
      {
        v25 = "cp_feats2 must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)(v15 + 28))
      {
        v25 = "gru_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!v22)
      {
        v25 = "hw_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)v15)
      {
        v25 = "num_cb must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)(v15 + 20))
      {
        v25 = "num_hw must be greater than zero!";
        goto LABEL_27;
      }
      if (init_network(a1, v15 + 40, (int *)a2, a3, a4))
      {
        v25 = "cbhg network init failed!";
        goto LABEL_27;
      }
      v7[15] = (uint64_t *)v19;
      if (a3)
        *(uint64_t **)((char *)v7 + 60) = *a3;
      result = 0;
      *v7 = a1;
      v7[16] = (uint64_t *)forward_cbhg_layer;
      v7[17] = (uint64_t *)free_cbhg_layer;
      v7[18] = (uint64_t *)cbhg_update_shape;
      v7[19] = (uint64_t *)cbhg_wanted_wb_len;
      v7[20] = (uint64_t *)cbhg_request_glbBuf;
      v7[21] = (uint64_t *)cbhg_assign_glbBuf;
      v7[22] = (uint64_t *)cbhg_reset;
      v7[23] = (uint64_t *)cbhg_dispatch_weights;
      v7[1] = (uint64_t *)55;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v29);
      result = 10;
    }
  }
LABEL_28:
  *a5 = v7;
  return result;
}

uint64_t forward_cbhg_layer(uint64_t a1, uint64_t a2, float *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v9;
  uint64_t v10;
  char *v14;
  uint64_t bytes;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;

  v30 = 0;
  HIDWORD(v29) = 0;
  if (!a2)
    return 0;
  v9 = *(uint64_t **)a2;
  v10 = *(_QWORD *)(a2 + 120);
  if (!v10)
  {
    v22 = *v9;
    v23 = "config empty";
LABEL_9:
    log_OutText(v22, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, a6, a7, a8, v29);
    return 7;
  }
  v14 = *(char **)(a2 + 240);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 40) + 40), (_DWORD *)&v30 + 1);
  if ((_DWORD)bytes)
    return bytes;
  bzero(v14, HIDWORD(v30));
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 40) + 128))(a1);
  if ((_DWORD)v16)
  {
    bytes = v16;
    v20 = *v9;
    v21 = "cbhg forward conv1d bank failed!";
LABEL_6:
    log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v17, v18, v19, v29);
    return bytes;
  }
  max_array_f32(((*(_DWORD *)(*(_QWORD *)(v10 + 48) + 24) - 1) * *(_DWORD *)(*(_QWORD *)(v10 + 48) + 28)), (float *)v14, (float *)&v14[4 * *(unsigned int *)(*(_QWORD *)(v10 + 48) + 28)]);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 56) + 40), (_DWORD *)&v30 + 1);
  if ((_DWORD)bytes)
    return bytes;
  bzero(a4, HIDWORD(v30));
  v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 56) + 128))(a1);
  if ((_DWORD)v25)
  {
    bytes = v25;
    v20 = *v9;
    v21 = "cbhg forward conv1d projection failed!";
    goto LABEL_6;
  }
  if (fi_shape_is_same((unsigned int *)(a2 + 20), (_DWORD *)(*(_QWORD *)(v10 + 56) + 40)) != 1)
  {
    v22 = *v9;
    v23 = "cbhg residual add size mismatch!";
    goto LABEL_9;
  }
  bytes = fi_shape_get_size((int *)(a2 + 20), (int *)&v29 + 1);
  if (!(_DWORD)bytes)
  {
    axpy(HIDWORD(v29), a3, 1, (float *)a4, 1, 1.0);
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 72) + 40), &v30);
    if (!(_DWORD)bytes)
    {
      if (*(_DWORD *)(v10 + 16) == 1)
      {
        v26 = v30;
        bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 64) + 40), (_DWORD *)&v30 + 1);
        if ((_DWORD)bytes)
          return bytes;
        bzero(&v14[v26 & 0xFFFFFFFC], HIDWORD(v30));
        v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 64) + 128))(a1);
        if ((_DWORD)v27)
        {
          bytes = v27;
          v20 = *v9;
          v21 = "cbhg forward pre-highway failed!";
          goto LABEL_6;
        }
      }
      bzero(v14, v30);
      v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 72) + 128))(a1);
      if ((_DWORD)v28)
      {
        bytes = v28;
        v20 = *v9;
        v21 = "cbhg forward highway failed!";
        goto LABEL_6;
      }
      bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 80) + 40), (_DWORD *)&v30 + 1);
      if (!(_DWORD)bytes)
      {
        bzero(a4, HIDWORD(v30));
        bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 80) + 128))(a1);
        if ((_DWORD)bytes)
        {
          v20 = *v9;
          v21 = "cbhg forward bgru failed!";
          goto LABEL_6;
        }
      }
    }
  }
  return bytes;
}

_QWORD *free_cbhg_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 40));
        fi_layer_free(*(_QWORD *)(v3 + 48));
        fi_layer_free(*(_QWORD *)(v3 + 56));
        if (*(_DWORD *)(v3 + 16) == 1)
          fi_layer_free(*(_QWORD *)(v3 + 64));
        fi_layer_free(*(_QWORD *)(v3 + 72));
        fi_layer_free(*(_QWORD *)(v3 + 80));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 cbhg_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  __int128 v11;
  uint64_t v12;
  const char *v13;
  __n128 result;
  uint64_t v15;
  __n128 *v16;
  unsigned int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v12 = *v9;
    v13 = "NULL param!";
    goto LABEL_5;
  }
  v11 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v11;
  if (*(_DWORD *)a2 >= 3u)
  {
    v12 = *v9;
    v13 = "Currently cbhg layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 40) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 48) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 56) + 144))()
    && (*(_DWORD *)(v8 + 16) != 1 || !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 64) + 144))())
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 72) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 80) + 144))())
  {
    v15 = *(_QWORD *)(v8 + 80);
    v17 = *(_DWORD *)(v15 + 40);
    v16 = (__n128 *)(v15 + 40);
    if (v17 >= 3)
    {
      v12 = *v9;
      v13 = "final output shape error: Currently cbhg only support 1D or 2D output";
      goto LABEL_5;
    }
    result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t cbhg_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 40) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(0, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 56) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(padded_bytes, 8u);
        if (*(_DWORD *)(v9 + 16) == 1)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 64) + 152))();
          if ((_DWORD)result)
            return result;
          v14 = get_padded_bytes(v14, 8u);
        }
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 72) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 80) + 152))();
          if (!(_DWORD)result)
          {
            *a2 = get_padded_bytes(v15, 8u);
            *a3 = 0;
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"cb_feats: %d\n", v16, v17, v18, *(unsigned int *)(v9 + 4));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"cp_feats2: %d\n", v19, v20, v21, *(unsigned int *)(v9 + 12));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v22, v23, v24, *(unsigned int *)(a1 + 96));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v25, v26, v27, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v28);
    return 7;
  }
  return result;
}

uint64_t cbhg_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t (*v10)(void);
  uint64_t result;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t (*v14)(void);
  uint64_t (*v15)(void);
  uint64_t (*v16)(void);
  uint64_t v17;
  uint64_t v18;
  int v19;

  v9 = *(_QWORD *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  v10 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 40) + 160);
  if (v10)
  {
    result = v10();
    if ((_DWORD)result)
      return result;
    v12 = *(_DWORD *)(*(_QWORD *)(v9 + 40) + 248);
  }
  else
  {
    v12 = 0;
  }
  v13 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 56) + 160);
  if (v13)
  {
    result = v13();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 56) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 56) + 248);
  }
  if (*(_DWORD *)(v9 + 16) == 1)
  {
    v14 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 64) + 160);
    if (v14)
    {
      result = v14();
      if ((_DWORD)result)
        return result;
      if (*(_DWORD *)(*(_QWORD *)(v9 + 64) + 248) > v12)
        v12 = *(_DWORD *)(*(_QWORD *)(v9 + 64) + 248);
    }
  }
  v15 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 72) + 160);
  if (v15)
  {
    result = v15();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 72) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 72) + 248);
  }
  v16 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 80) + 160);
  if (v16)
  {
    result = v16();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 80) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 80) + 248);
  }
  v17 = *(_QWORD *)(a1 + 120);
  v19 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v17 + 40) + 40), &v19);
  if (!(_DWORD)result)
    *(_DWORD *)(a1 + 248) = v19 + v12;
  return result;
}

uint64_t cbhg_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 40), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 56), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        if (*(_DWORD *)(v8 + 16) == 1)
        {
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 64), v9, &padded_bytes);
          if ((_DWORD)result)
            return result;
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
        }
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 72), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 80), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t cbhg_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(void);
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  void (*v17)(void);
  uint64_t v18;
  void (*v19)(void);
  uint64_t v20;
  void (*v21)(void);
  uint64_t v22;
  unsigned int v23;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v23 = 0;
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 40) + 40), &v23);
    if (!(_DWORD)result)
    {
      v11 = v23;
      v12 = *(_QWORD *)(v9 + 40);
      *(_QWORD *)(v12 + 240) = *(_QWORD *)(a1 + 240) + v23;
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
      v14 = *(_QWORD *)(v9 + 56);
      *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v15 = *(void (**)(void))(v14 + 168);
      if (v15)
        v15();
      if (*(_DWORD *)(v9 + 16) == 1)
      {
        v16 = *(_QWORD *)(v9 + 64);
        *(_QWORD *)(v16 + 240) = *(_QWORD *)(a1 + 240) + v11;
        v17 = *(void (**)(void))(v16 + 168);
        if (v17)
          v17();
      }
      v18 = *(_QWORD *)(v9 + 72);
      *(_QWORD *)(v18 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v19 = *(void (**)(void))(v18 + 168);
      if (v19)
        v19();
      v20 = *(_QWORD *)(v9 + 80);
      *(_QWORD *)(v20 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v21 = *(void (**)(void))(v20 + 168);
      if (v21)
        v21();
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v22);
    return 7;
  }
  return result;
}

uint64_t cbhg_reset(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 80);
  if (v1 && (v2 = *(uint64_t (**)(void))(v1 + 176)) != 0)
    return v2();
  else
    return 0;
}

uint64_t init_network(uint64_t *a1, uint64_t a2, int *a3, uint64_t **a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t conv1d_bank;
  uint64_t v35;
  uint64_t pooling1d_layer;
  uint64_t v37;
  uint64_t conv1d_proj_layer;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t highways;
  int v43;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;

  v47 = 0;
  v46 = 0;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8);
  if (!v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v11, v12, v13, v45);
    return 10;
  }
  v14 = (uint64_t *)v10;
  v50 = 0;
  v48 = 0;
  v49 = 0;
  v18 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v18)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v45);
    v22 = 0;
LABEL_10:
    v26 = 0;
LABEL_11:
    v31 = 10;
    goto LABEL_33;
  }
  v22 = (__int128 *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 36);
  if (!v22)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v19, v20, v21, v45);
    goto LABEL_10;
  }
  v26 = (__int128 *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v26)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v23, v24, v25, v45);
    goto LABEL_11;
  }
  v27 = config_conv1d_bank_layer(*a3, a3[1], v14);
  if ((_DWORD)v27)
  {
    v31 = v27;
    v32 = *a1;
    v33 = "create cbhg: conv1d_bank cfg failed!";
LABEL_32:
    log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, v28, v29, v30, v45);
    goto LABEL_33;
  }
  conv1d_bank = create_conv1d_bank(a1, v14, a4, a5, (uint64_t *)a2);
  if ((_DWORD)conv1d_bank)
  {
    v31 = conv1d_bank;
    v32 = *a1;
    v33 = "create cbhg: conv1d_bank layer failed!";
    goto LABEL_32;
  }
  v35 = config_pooling1d_layer(2, 1, 1, 1, v22);
  if ((_DWORD)v35)
  {
    v31 = v35;
    v32 = *a1;
    v33 = "create cbhg: maxpooling cfg failed!";
    goto LABEL_32;
  }
  pooling1d_layer = create_pooling1d_layer(a1, 10, v22, a4, (uint64_t ***)(a2 + 8));
  if ((_DWORD)pooling1d_layer)
  {
    v31 = pooling1d_layer;
    v32 = *a1;
    v33 = "create cbhg: maxpooling layer failed!";
    goto LABEL_32;
  }
  v37 = config_conv1d_proj_layer(3, a3[2], a3[3], 3, v18);
  if ((_DWORD)v37)
  {
    v31 = v37;
    v32 = *a1;
    v33 = "create cbhg: conv1d_proj cfg failed!";
    goto LABEL_32;
  }
  conv1d_proj_layer = create_conv1d_proj_layer(a1, v18, a4, a5, (uint64_t *)(a2 + 16));
  if ((_DWORD)conv1d_proj_layer)
  {
    v31 = conv1d_proj_layer;
    v32 = *a1;
    v33 = "create cbhg: conv1d_proj layer failed!";
    goto LABEL_32;
  }
  if (a3[4] == 1)
  {
    v39 = a3[6];
    LODWORD(v49) = 5;
    HIDWORD(v49) = v39;
    v50 = 0;
    v48 = 0;
    v40 = create_fc_layer(a1, &v49, &v48, a4, a5, (uint64_t *)(a2 + 24));
    if ((_DWORD)v40)
    {
      v31 = v40;
      v32 = *a1;
      v33 = "create cbhg: pre highway layer failed!";
      goto LABEL_32;
    }
  }
  v41 = config_highways_layer(a3[5], a3[6], 3, &v46);
  if ((_DWORD)v41)
  {
    v31 = v41;
    v32 = *a1;
    v33 = "create cbhg: highways cfg failed!";
    goto LABEL_32;
  }
  highways = create_highways(a1, (unsigned int *)&v46, a4, a5, (uint64_t *)(a2 + 32));
  if ((_DWORD)highways)
  {
    v31 = highways;
    v32 = *a1;
    v33 = "create cbhg: highways layer failed!";
    goto LABEL_32;
  }
  v43 = a3[7];
  LODWORD(v49) = 24;
  HIDWORD(v49) = v43;
  v50 = 0;
  *(__int128 *)((char *)v26 + 4) = xmmword_1DECEC950;
  *(_DWORD *)v26 = a3[8];
  v31 = create_bgru_layer(a1, &v49, v26, a4, a5, (uint64_t *)(a2 + 40));
  if ((_DWORD)v31)
  {
    v32 = *a1;
    v33 = "create cbhg: bgru layer failed!";
    goto LABEL_32;
  }
LABEL_33:
  (*(void (**)(uint64_t, uint64_t *))(a1[1] + 48))(a1[2], v14);
  if (v18)
    (*(void (**)(uint64_t, unsigned int *))(a1[1] + 48))(a1[2], v18);
  if (v22)
    (*(void (**)(uint64_t, __int128 *))(a1[1] + 48))(a1[2], v22);
  if (v26)
    (*(void (**)(uint64_t, __int128 *))(a1[1] + 48))(a1[2], v26);
  return v31;
}

uint64_t config_conv1d_bank_layer(int a1, int a2, _DWORD *a3)
{
  *a3 = a1;
  a3[1] = a2;
  return 0;
}

uint64_t create_conv1d_bank(uint64_t *a1, uint64_t *a2, uint64_t **a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  int *v29;
  int v30;
  uint64_t v31;
  int *v32;
  int v33;
  uint64_t v34;
  char v35;
  char v36;
  uint64_t v37;
  int *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _OWORD v45[2];
  int v46;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
      v19 = v15;
      if (!v15)
      {
        v21 = *a1;
        v22 = "out of memory!";
        goto LABEL_44;
      }
      v20 = *a2;
      *v15 = *a2;
      if (v20 >= 0xC9)
      {
        v21 = *a1;
        v22 = "number of conv1d_norm exploded!";
LABEL_44:
        log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v16, v17, v18, *(uint64_t *)&v45[0]);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_bank init param failed!", v42, v43, v44, *(uint64_t *)&v45[0]);
        result = 7;
        goto LABEL_45;
      }
      if (!(_DWORD)v20)
      {
        v21 = *a1;
        v22 = "number of conv1d_norm must be greater than zero!";
        goto LABEL_44;
      }
      v46 = 0;
      memset(v45, 0, sizeof(v45));
      v23 = *(_DWORD *)a2 % 0x64u;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v23, 8);
      v19[1] = v24;
      if (!v24)
      {
        v26 = *a1;
        v27 = "out of memory!";
LABEL_42:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, *(uint64_t *)&v45[0]);
LABEL_43:
        v21 = *a1;
        v22 = "conv1d_bank network init failed!";
        goto LABEL_44;
      }
      v25 = config_conv1d_norm_layer(*((unsigned int *)a2 + 1), 1, 1, 1, 0, 1, 3, v45);
      switch((int)v23)
      {
        case 0:
          if (v25)
            goto LABEL_43;
          goto LABEL_37;
        case 1:
        case 3:
        case 4:
        case 6:
        case 7:
          goto LABEL_34;
        case 2:
          v34 = 0;
          v35 = 1;
          while (1)
          {
            v36 = v35;
            LODWORD(v45[0]) = dword_1DECEC9B0[v34];
            if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + 8 * v34)))
              goto LABEL_41;
            v35 = 0;
            v34 = 1;
            if ((v36 & 1) == 0)
              goto LABEL_37;
          }
        case 5:
          v31 = 0;
          v32 = &dword_1DECECA04;
          while (1)
          {
            v33 = *v32++;
            LODWORD(v45[0]) = v33;
            if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v31)))
              goto LABEL_41;
            v31 += 8;
            if (v31 == 40)
              goto LABEL_37;
          }
        case 8:
          if (*(_DWORD *)a2 != 108)
            goto LABEL_34;
          v37 = 0;
          v38 = &dword_1DECECA48;
          break;
        default:
          if ((_DWORD)v23 == 12)
          {
            v28 = 0;
            v29 = &dword_1DECECA18;
            do
            {
              v30 = *v29++;
              LODWORD(v45[0]) = v30;
              if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v28)))
                goto LABEL_41;
              v28 += 8;
            }
            while (v28 != 96);
          }
          else
          {
LABEL_34:
            v40 = 0;
            v41 = 0;
            do
            {
              LODWORD(v45[0]) = ++v41;
              if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v40)))
                goto LABEL_41;
              v40 += 8;
            }
            while (v23 != v41);
          }
          goto LABEL_37;
      }
      do
      {
        v39 = *v38++;
        LODWORD(v45[0]) = v39;
        if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v37)))
        {
LABEL_41:
          v26 = *a1;
          v27 = "create conv1d_bank sub-conv1d_norm layer failed!";
          goto LABEL_42;
        }
        v37 += 8;
      }
      while (v37 != 64);
LABEL_37:
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_conv1d_bank;
      *(_QWORD *)(v7 + 136) = free_conv1d_bank;
      *(_QWORD *)(v7 + 144) = conv1d_bank_update_shape;
      *(_QWORD *)(v7 + 152) = conv1d_bank_wanted_wb_len;
      *(_QWORD *)(v7 + 8) = 51;
      *(_QWORD *)(v7 + 184) = conv1d_bank_dispatch_weights;
      *(_QWORD *)(v7 + 160) = conv1d_bank_request_glbBuf;
      *(_QWORD *)(v7 + 168) = conv1d_bank_assign_glbBuf;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v16, v17, v18, *(uint64_t *)&v45[0]);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, *(uint64_t *)&v45[0]);
      result = 10;
    }
  }
LABEL_45:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_bank(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  int *v9;
  uint64_t v11;
  unsigned int v12;
  uint64_t bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  size_t v29;

  LODWORD(v29) = 0;
  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(int **)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v25);
    return 7;
  }
  v11 = *(_QWORD *)(a2 + 240);
  v12 = *v9;
  bytes = fi_shape_get_bytes((int *)(a2 + 40), &v29);
  if (!(_DWORD)bytes)
  {
    bzero(a4, v29);
    v27 = v12 % 0x64;
    if ((_DWORD)v27)
    {
      v26 = a4;
      v14 = 0;
      while (1)
      {
        v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v9 + 1) + 8 * v14) + 128))(a1);
        if ((_DWORD)v15)
          break;
        v19 = *(_QWORD *)(*((_QWORD *)v9 + 1) + 8 * v14);
        v20 = *(unsigned int *)(v19 + 44);
        if ((_DWORD)v20)
        {
          v21 = 0;
          v22 = 0;
          v23 = *(unsigned int *)(v19 + 48);
          do
          {
            memcpy(&v26[4 * (v23 * v14) + 4 * v21], (const void *)(v11 + 4 * v22), 4 * v23);
            v22 += v23;
            v21 += v27 * v23;
            --v20;
          }
          while (v20);
        }
        if (++v14 == v27)
          return 0;
      }
      bytes = v15;
      log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_bank forward sub-conv1d_bank layer failed!", v16, v17, v18, (uint64_t)v8);
      return bytes;
    }
    return 0;
  }
  return bytes;
}

_QWORD *free_conv1d_bank(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        v4 = *(_DWORD *)v3 % 0x64u;
        if ((_DWORD)v4)
        {
          for (i = 0; i != v4; ++i)
            fi_layer_free(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * i));
        }
        if (*(_QWORD *)(v3 + 8))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 8) = 0;
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

__n128 conv1d_bank_update_shape(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t *v9;
  unsigned int v11;
  __int128 v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  __n128 result;
  uint64_t v18;
  unsigned int v19;
  __n128 *v20;
  unsigned int v21;
  uint64_t v22;

  v8 = *(int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v13 = *v9;
    v14 = "NULL param!";
    goto LABEL_11;
  }
  v11 = *v8;
  v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 > 2u)
  {
    v13 = *v9;
    v14 = "Currently conv1d_bank layer only support 1D or 2D input";
LABEL_11:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v22);
    return result;
  }
  v15 = v11 % 0x64;
  if (!(_DWORD)v15)
  {
LABEL_9:
    v18 = **((_QWORD **)v8 + 1);
    v21 = *(_DWORD *)(v18 + 40);
    v20 = (__n128 *)(v18 + 40);
    v19 = v21;
    if (v21 < 3)
    {
      result = *v20;
      *(_DWORD *)(a1 + 56) = v20[1].n128_u32[0];
      *(__n128 *)(a1 + 40) = result;
      *(_DWORD *)(a1 + 4 * (v19 - 1) + 44) *= (_DWORD)v15;
      return result;
    }
    v13 = *v9;
    v14 = "final output shape error: Currently conv1d_bank only support 1D or 2D output";
    goto LABEL_11;
  }
  v16 = 0;
  while (!(*(unsigned int (**)(void))(*(_QWORD *)(*((_QWORD *)v8 + 1) + 8 * v16) + 144))())
  {
    if (v15 == ++v16)
      goto LABEL_9;
  }
  return result;
}

uint64_t conv1d_bank_wanted_wb_len(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int padded_bytes;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v12 = *(_DWORD *)v9 % 0x64u;
    if ((_DWORD)v12)
    {
      v13 = 0;
      padded_bytes = 0;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v13) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        if (v12 == ++v13)
          goto LABEL_9;
      }
    }
    else
    {
      padded_bytes = 0;
LABEL_9:
      *a2 = padded_bytes;
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_conv1d_norm: %d\n", a6, a7, a8, *(_DWORD *)v9 % 0x64u);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v16, v17, v18, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v19, v20, v21, *a2);
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param is NULL!", a6, a7, a8, v22);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  unsigned int v10;
  uint64_t result;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t (*v17)(void);
  uint64_t v18;
  int v19;

  v9 = *(int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    v19 = 0;
    result = fi_shape_get_bytes((int *)(**((_QWORD **)v9 + 1) + 40), &v19);
    if (!(_DWORD)result)
    {
      v12 = v10 % 0x64;
      v13 = v19;
      if ((_DWORD)v12)
      {
        v14 = 0;
        v15 = 0;
        v16 = *((_QWORD *)v9 + 1);
        do
        {
          v17 = *(uint64_t (**)(void))(*(_QWORD *)(v16 + 8 * v14) + 160);
          if (v17)
          {
            result = v17();
            if ((_DWORD)result)
              return result;
            v16 = *((_QWORD *)v9 + 1);
            if (*(_DWORD *)(*(_QWORD *)(v16 + 8 * v14) + 248) > v15)
              v15 = *(_DWORD *)(*(_QWORD *)(v16 + 8 * v14) + 248);
          }
          ++v14;
        }
        while (v12 != v14);
      }
      else
      {
        v15 = 0;
      }
      result = 0;
      *(_DWORD *)(a1 + 248) = v15 + v13;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_DWORD *)v8 % 0x64u;
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = *(_QWORD *)(a1 + 72);
      while (1)
      {
        v12 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * v10);
        if (!v12)
          break;
        result = fi_layer_find_weights_via_offset(v12, v11, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        if (v9 == ++v10)
          return 0;
      }
      return 10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v14);
    return 7;
  }
}

uint64_t conv1d_bank_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  unsigned int v17;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v17 = 0;
    result = fi_shape_get_bytes((int *)(**(_QWORD **)(v9 + 8) + 40), &v17);
    if (!(_DWORD)result)
    {
      v11 = *(_DWORD *)v9 % 0x64u;
      if ((_DWORD)v11)
      {
        v12 = 0;
        v13 = v17;
        do
        {
          v14 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v12);
          *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v13;
          v15 = *(void (**)(void))(v14 + 168);
          if (v15)
            v15();
          ++v12;
        }
        while (v11 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v16);
    return 7;
  }
  return result;
}

uint64_t conv1d_norm_dispatch_weights(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 40), v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 48), v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

_QWORD *free_conv1d_norm_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 40));
        fi_layer_free(*(_QWORD *)(v3 + 48));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_conv1d_norm_layer(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32[2];
  int v33;
  int v34;
  uint64_t v35;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 56);
      v19 = v15;
      if (!v15)
      {
        v27 = *a1;
        v28 = "out of memory!";
LABEL_12:
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v16, v17, v18, *(uint64_t *)&v32[0]);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_norm init param failed!", v29, v30, v31, *(uint64_t *)&v32[0]);
        result = 7;
        goto LABEL_13;
      }
      v20 = *(_OWORD *)a2;
      v21 = *(_OWORD *)(a2 + 16);
      *(_DWORD *)(v15 + 32) = *(_DWORD *)(a2 + 32);
      *(_OWORD *)v15 = v20;
      *(_OWORD *)(v15 + 16) = v21;
      v35 = 0;
      v22 = *(_OWORD *)(a2 + 16);
      v32[0] = *(_OWORD *)a2;
      v32[1] = v22;
      v33 = 0;
      if (create_conv1d_layer(a1, v32, a3, a4, (uint64_t ***)(v15 + 40)))
      {
        v26 = "create conv1d_norm conv1d layer failed!";
LABEL_11:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, *(uint64_t *)&v32[0]);
        v27 = *a1;
        v28 = "conv1d_norm network init failed!";
        goto LABEL_12;
      }
      v34 = 22;
      if (create_norm_layer(a1, (uint64_t *)&v34, (uint64_t *)(v19 + 48)))
      {
        v26 = "create conv1d_norm norm layer failed!";
        goto LABEL_11;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        *(_QWORD *)(v7 + 60) = *a3;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_conv1d_norm_layer;
      *(_QWORD *)(v7 + 136) = free_conv1d_norm_layer;
      *(_QWORD *)(v7 + 144) = conv1d_norm_layer_update_shape;
      *(_QWORD *)(v7 + 152) = conv1d_norm_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 8) = 50;
      *(_QWORD *)(v7 + 184) = conv1d_norm_dispatch_weights;
      *(_QWORD *)(v7 + 160) = conv1d_norm_request_glbBuf;
      *(_QWORD *)(v7 + 168) = conv1d_norm_assign_glbBuf;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v23, v24, v25, *(uint64_t *)&v32[0]);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, *(uint64_t *)&v32[0]);
      result = 10;
    }
  }
LABEL_13:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_norm_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v7;
  uint64_t v8;
  void *v9;
  uint64_t bytes;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  size_t v21;

  LODWORD(v21) = 0;
  if (!a2)
    return 0;
  v20 = 0;
  v7 = *(uint64_t **)a2;
  v8 = *(_QWORD *)(a2 + 120);
  v9 = *(void **)(a2 + 240);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v8 + 40) + 40), &v21);
  if (!(_DWORD)bytes)
  {
    bzero(v9, v21);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v8 + 40) + 128))(a1);
    if ((_DWORD)v11)
    {
      bytes = v11;
      v15 = *v7;
      v16 = "conv1d_norm forward conv1d layer failed!";
LABEL_5:
      log_OutText(v15, (uint64_t)"FastInfer", 0, 0, (uint64_t)v16, v12, v13, v14, v19);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v8 + 48) + 40), &v21);
    if ((_DWORD)bytes)
      return bytes;
    bzero(a4, v21);
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v8 + 48) + 128))(a1);
    if ((_DWORD)v18)
    {
      bytes = v18;
      v15 = *v7;
      v16 = "conv1d_norm forward norm layer failed!";
      goto LABEL_5;
    }
    bytes = fi_shape_get_size((int *)(a2 + 40), (int *)&v20);
    if (!(_DWORD)bytes)
      fi_activate_array((float *)a4, v20, *(_DWORD *)(v8 + 32));
  }
  return bytes;
}

__n128 conv1d_norm_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  __n128 result;
  uint64_t v15;
  __n128 *v16;
  int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    v11 = *v9;
    v12 = "Currently conv1d_norm layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 40) + 144))()
    && !(*(unsigned int (**)(void))(*(_QWORD *)(v8 + 48) + 144))())
  {
    v15 = *(_QWORD *)(v8 + 48);
    v17 = *(_DWORD *)(v15 + 40);
    v16 = (__n128 *)(v15 + 40);
    if ((v17 - 1) >= 2)
    {
      v11 = **(_QWORD **)a1;
      v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t conv1d_norm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 40) + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 48) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v9, v10, v11, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v12, v13, v14, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t conv1d_norm_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  int v4;
  uint64_t (*v5)(void);
  int v6;

  v2 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v2 + 40) + 40), &v6);
  if (!(_DWORD)result)
  {
    v4 = v6;
    v5 = *(uint64_t (**)(void))(*(_QWORD *)(v2 + 40) + 160);
    if (v5)
    {
      result = v5();
      if ((_DWORD)result)
        return result;
      v4 += *(_DWORD *)(*(_QWORD *)(v2 + 40) + 248);
    }
    result = 0;
    *(_DWORD *)(a1 + 248) = v4;
  }
  return result;
}

uint64_t conv1d_norm_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  unsigned int v14;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v14 = 0;
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 40) + 40), &v14);
    if (!(_DWORD)result)
    {
      v11 = *(_QWORD *)(v9 + 40);
      *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v14;
      v12 = *(void (**)(void))(v11 + 168);
      if (v12)
        v12();
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v13);
    return 7;
  }
  return result;
}

_QWORD *free_tacodecoder_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 88));
        fi_layer_free(*(_QWORD *)(v3 + 96));
        fi_layer_free(*(_QWORD *)(v3 + 104));
        fi_layer_free(*(_QWORD *)(v3 + 120));
        fi_layer_free(*(_QWORD *)(v3 + 184));
        if (!*(_DWORD *)(v3 + 28))
        {
          fi_layer_free(*(_QWORD *)(v3 + 112));
          if (*(_DWORD *)(v3 + 16))
          {
            fi_layer_free(*(_QWORD *)(v3 + 168));
            fi_layer_free(*(_QWORD *)(v3 + 176));
          }
          if (*(_DWORD *)(v3 + 20))
            fi_layer_free(*(_QWORD *)(v3 + 192));
        }
        fi_layer_free(*(_QWORD *)(v3 + 128));
        fi_layer_free(*(_QWORD *)(v3 + 136));
        fi_layer_free(*(_QWORD *)(v3 + 144));
        fi_layer_free(*(_QWORD *)(v3 + 152));
        fi_layer_free(*(_QWORD *)(v3 + 160));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_tacodecoder_layer(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t result;
  uint64_t v27;
  const char *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  int v41;
  _BYTE v42[20];
  uint64_t v43;
  uint64_t v44;
  int v45;
  __int128 v46[2];
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
    v16 = v12;
    if (!v12)
    {
      v27 = *a1;
      v28 = "out of memory!";
LABEL_18:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v13, v14, v15, *(uint64_t *)v42);
      *(_QWORD *)(v11 + 120) = v16;
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Taoctron decoder layer param init failed!", v30, v31, v32, *(uint64_t *)v42);
      result = 7;
      goto LABEL_19;
    }
    v17 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)v12 = *(_OWORD *)a2;
    *(_OWORD *)(v12 + 16) = v17;
    v18 = *(_OWORD *)(a2 + 32);
    v19 = *(_OWORD *)(a2 + 48);
    v20 = *(_OWORD *)(a2 + 64);
    *(_QWORD *)(v12 + 80) = *(_QWORD *)(a2 + 80);
    *(_OWORD *)(v12 + 48) = v19;
    *(_OWORD *)(v12 + 64) = v20;
    *(_OWORD *)(v12 + 32) = v18;
    v43 = 0x100000003;
    memset(v42, 0, sizeof(v42));
    v21 = *(_DWORD *)(a2 + 48);
    LODWORD(v44) = 5;
    HIDWORD(v44) = v21;
    v45 = 0;
    if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v12 + 88)))
    {
      v25 = "create tacoDecoder preNet o1 layer failed!";
LABEL_17:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v22, v23, v24, *(uint64_t *)v42);
      v27 = *a1;
      v28 = "Tacotron decoder layer init failed!";
      goto LABEL_18;
    }
    HIDWORD(v44) = *(_DWORD *)(a2 + 52);
    v43 = 0x100000003;
    if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 96)))
    {
      v25 = "create tacoDecoder preNet o2 layer failed!";
      goto LABEL_17;
    }
    HIDWORD(v44) = *(_DWORD *)(a2 + 64);
    v43 = 0x100000000;
    if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 128)))
    {
LABEL_16:
      v25 = "create tacoDecoder Decoder pre-dense layer failed!";
      goto LABEL_17;
    }
    HIDWORD(v44) = *(_DWORD *)a2 * *(_DWORD *)(a2 + 4);
    v29 = *(_DWORD *)(a2 + 24);
    if (v29 == 2)
    {
      v29 = 3;
    }
    else if (v29 != 1)
    {
LABEL_15:
      HIDWORD(v43) = 1;
      if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 136)))
        goto LABEL_16;
      v33 = *(_DWORD *)(a2 + 56);
      LODWORD(v44) = 23;
      HIDWORD(v44) = v33;
      v45 = 0;
      *(_DWORD *)v42 = *(_DWORD *)(a2 + 84);
      *(_QWORD *)&v42[4] = *(_QWORD *)(a2 + 68);
      *(_QWORD *)&v42[12] = 0x100000001;
      if (create_gru_layer(a1, (uint64_t)&v44, (__int128 *)v42, 0, a3, (uint64_t ***)(v16 + 144)))
      {
        v25 = "create tacodecoder attention-GRU layer failed!";
        goto LABEL_17;
      }
      v34 = *(_DWORD *)(a2 + 60);
      LODWORD(v44) = 23;
      HIDWORD(v44) = v34;
      *(_QWORD *)&v42[4] = *(_QWORD *)(a2 + 76);
      if (create_gru_layer(a1, (uint64_t)&v44, (__int128 *)v42, 0, a3, (uint64_t ***)(v16 + 152)))
      {
        v25 = "create tacodecoder deocder-GRU-1 layer failed!";
        goto LABEL_17;
      }
      v35 = *(_DWORD *)(a2 + 60);
      LODWORD(v44) = 23;
      HIDWORD(v44) = v35;
      *(_QWORD *)&v42[4] = *(_QWORD *)(a2 + 76);
      if (create_gru_layer(a1, (uint64_t)&v44, (__int128 *)v42, 0, a3, (uint64_t ***)(v16 + 160)))
      {
        v25 = "create tacodecoder deocder-GRU-2 layer failed!";
        goto LABEL_17;
      }
      v50 = 0;
      v48 = 0;
      v49 = 0;
      v47 = 0;
      memset(v46, 0, sizeof(v46));
      v36 = *(_DWORD *)(a2 + 28);
      if (v36)
      {
        HIDWORD(v49) = 3 * v36;
        v50 = 0;
        LODWORD(v49) = 5;
        v48 = 0x100000000;
        if (!create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 104)))
        {
          HIDWORD(v49) = *(_DWORD *)(a2 + 8);
          v50 = 0;
          LODWORD(v49) = 5;
          v48 = 0x100000002;
          if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 120)))
          {
LABEL_29:
            v40 = "create tacodecoder Attention query dense layer failed!";
LABEL_32:
            log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v40, v37, v38, v39, *(uint64_t *)v42);
            v25 = "init attention network failed!";
            goto LABEL_17;
          }
          *(_QWORD *)(v16 + 112) = 0;
          *(_QWORD *)(v16 + 192) = 0;
          *(_QWORD *)(v16 + 168) = 0;
          *(_QWORD *)(v16 + 176) = 0;
LABEL_36:
          v43 = 0x100000001;
          v44 = 0x100000005;
          result = create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 184));
          if (!(_DWORD)result)
          {
            *(_QWORD *)v11 = a1;
            *(_QWORD *)(v11 + 8) = 62;
            *(_QWORD *)(v11 + 120) = v16;
            *(_QWORD *)(v11 + 128) = forward_tacodecoder_layer;
            *(_QWORD *)(v11 + 136) = free_tacodecoder_layer;
            *(_QWORD *)(v11 + 144) = tacodecoder_layer_update_shape;
            *(_QWORD *)(v11 + 152) = tacodecoder_layer_wanted_wb_len;
            *(_QWORD *)(v11 + 160) = tacodecoder_request_glbBuf;
            *(_QWORD *)(v11 + 256) = *(_QWORD *)(a3 + 24);
            *(_DWORD *)(v11 + 264) = *(_DWORD *)(a3 + 16);
            *(_QWORD *)(v11 + 168) = tacodecoder_assign_glbBuf;
            *(_QWORD *)(v11 + 176) = tacodecoder_layer_reset;
            *(_QWORD *)(v11 + 184) = tacodecoder_dispatch_weights;
            *(_QWORD *)(v11 + 200) = tacodecoder_layer_load_state;
            *(_QWORD *)(v11 + 208) = tacodecoder_layer_save_state;
            *(_QWORD *)(v11 + 216) = tacodecoder_layer_sizeof_state;
            goto LABEL_19;
          }
          v25 = "create tacoDecoder stop dense layer failed!";
          goto LABEL_17;
        }
      }
      else
      {
        v48 = 0x100000000;
        v49 = 0x100000005;
        v50 = 0;
        if (!create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 104)))
        {
          HIDWORD(v49) = *(_DWORD *)(a2 + 8);
          v50 = 0;
          LODWORD(v49) = 5;
          v48 = 0;
          if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 112)))
          {
            v40 = "create tacodecoder Attention key dense layer failed!";
            goto LABEL_32;
          }
          HIDWORD(v49) = *(_DWORD *)(a2 + 8);
          v50 = 0;
          LODWORD(v49) = 5;
          v48 = 0;
          if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 120)))
            goto LABEL_29;
          if (*(_DWORD *)(a2 + 16))
          {
            v41 = *(_DWORD *)(a2 + 8);
            LODWORD(v49) = 5;
            HIDWORD(v49) = v41;
            v50 = 0;
            v48 = 0;
            if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 176)))
            {
              v40 = "create tacodecoder Attention location module dense layer failed!";
              goto LABEL_32;
            }
            if (config_conv1d_layer(*(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36), 1, *(_DWORD *)(a2 + 40), 0, 1, 0, v46)|| create_conv1d_layer(a1, v46, 0, a3, (uint64_t ***)(v16 + 168)))
            {
              v40 = "create tacodecoder Attention location module conv1d config failed!";
              goto LABEL_32;
            }
          }
          else
          {
            *(_QWORD *)(v16 + 168) = 0;
            *(_QWORD *)(v16 + 176) = 0;
          }
          if (*(_DWORD *)(a2 + 20))
          {
            v50 = 0;
            v48 = 0x100000001;
            v49 = 0x100000005;
            if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 192)))
            {
              v40 = "create tacodecoder Forward Attention agent dense layer failed!";
              goto LABEL_32;
            }
          }
          goto LABEL_36;
        }
      }
      v40 = "create tacodecoder Attention v dense layer failed!";
      goto LABEL_32;
    }
    LODWORD(v43) = v29;
    goto LABEL_15;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, *(uint64_t *)v42);
  result = 10;
LABEL_19:
  *a4 = v11;
  return result;
}

uint64_t forward_tacodecoder_layer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t step;
  unsigned int *v8;
  uint64_t *v9;
  void *v10;
  unsigned int padded_len;
  unsigned int v12;
  BOOL v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  void *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  char *v28;
  void *v29;
  unsigned int v30;
  void *v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  void *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  float *v49;
  void *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  char *v61;
  unsigned int v62;
  char *v63;
  unsigned int v64;
  void *v65;
  unsigned int v66;
  uint64_t v67;
  void *v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  void *v81;
  unsigned int v82;
  unsigned int v83;
  int v84;
  size_t __n;
  float *v86;
  void *v87;
  char *__src;
  void *__srca;
  uint64_t v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  void *v96[2];
  __int128 v97;
  __int128 v98;
  __int128 __dst;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;

  v103 = 0u;
  v102 = 0u;
  v101 = 0u;
  v100 = 0u;
  __dst = 0u;
  v98 = 0u;
  v97 = 0u;
  *(_OWORD *)v96 = 0u;
  v95 = 0u;
  v94 = 0u;
  v93 = 0u;
  v92 = 0u;
  v91 = 0u;
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v8 = *(unsigned int **)(a2 + 120);
  v9 = *(uint64_t **)a2;
  pack_tacodecoder_internal_buffer(a2, &v90);
  v90 = a3;
  v10 = (void *)v94;
  padded_len = get_padded_len(v8[12], 8u);
  bzero(v10, 4 * padded_len);
  if (v8[7] && !v8[5])
  {
    v12 = v8[1];
    v13 = v12 != 0;
    v14 = v12 - 1;
    if (v13)
      v15 = v14;
    else
      v15 = 0;
    if (v8[6] == 3)
      relu_array_f32(*v8, (float *)(*((_QWORD *)&v91 + 1) + 4 * *v8 * v15));
  }
  else if (v8[6] == 3)
  {
    relu_array_f32(*v8 * v8[1], *((float **)&v91 + 1));
  }
  v19 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 11) + 128))(0);
  if ((_DWORD)v19)
  {
    v20 = *v9;
    v21 = "Tacotron decoder PreNet o1 dense forward failed!";
    goto LABEL_35;
  }
  v22 = (void *)*((_QWORD *)&v94 + 1);
  v23 = get_padded_len(v8[13], 8u);
  bzero(v22, 4 * v23);
  v24 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 12) + 128))(0);
  if ((_DWORD)v24)
  {
    v19 = v24;
    v20 = *v9;
    v21 = "Tacotron decoder PreNet o2 dense forward failed!";
    goto LABEL_35;
  }
  v25 = v8[7];
  if (!(_DWORD)v25)
  {
    if (v9)
    {
      if (*(float *)v91 != 0.0)
        goto LABEL_28;
      if (v8[5])
        *(_DWORD *)v101 = 1056964608;
      v38 = (void *)*((_QWORD *)&v103 + 1);
      v39 = get_padded_len(v8[2] * step, 8u);
      bzero(v38, 4 * v39);
      v40 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 14) + 128))(0);
      if (!(_DWORD)v40)
      {
LABEL_28:
        v45 = additive_attention(v9, (_QWORD *)v8 + 11, step, v8, (uint64_t)&v90);
        if ((_DWORD)v45)
        {
          v19 = v45;
          v20 = *v9;
          v21 = "Tacotron Forward Attention Module forward failed!";
          goto LABEL_35;
        }
        v31 = (void *)*((_QWORD *)&v95 + 1);
        v29 = (void *)v92;
        goto LABEL_44;
      }
      v19 = v40;
      log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron decoder Key dense forward failed!", v41, v42, v43, __n);
    }
    else
    {
      v19 = 7;
    }
    v20 = *v9;
    v21 = "Tacotron decoder first timestep key forward failed!";
    goto LABEL_35;
  }
  v86 = (float *)*((_QWORD *)&v102 + 1);
  v87 = (void *)v103;
  __src = (char *)v102;
  if (*(float *)v91 == 0.0)
    bzero(*((void **)&v101 + 1), 4 * v25);
  v26 = (char *)v95;
  v27 = get_padded_len(v8[13], 8u);
  memcpy(v26, v22, 4 * v27);
  v28 = &v26[4 * v8[13]];
  v29 = (void *)v92;
  v30 = get_padded_len(v8[3], 8u);
  memcpy(v28, v29, 4 * v30);
  v31 = (void *)*((_QWORD *)&v95 + 1);
  v32 = get_padded_len(v8[14], 8u);
  bzero(v31, 4 * v32);
  v33 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 18) + 128))(0);
  if ((_DWORD)v33)
  {
    v19 = v33;
    v37 = "Tacotron attention rnn forward failed!";
LABEL_34:
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v37, v34, v35, v36, __n);
    v20 = *v9;
    v21 = "Tacotron GMM Attention Module forward failed!";
    goto LABEL_35;
  }
  bzero(v96[1], 4 * v8[2]);
  v44 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 15) + 128))(0);
  if ((_DWORD)v44)
  {
    v19 = v44;
    v37 = "Tacotron decoder query dense forward failed!";
    goto LABEL_34;
  }
  v46 = get_padded_len(3 * v8[7], 8u);
  bzero(__src, 4 * v46);
  v47 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 13) + 128))(0);
  if ((_DWORD)v47)
  {
    v19 = v47;
    v37 = "Tacotron attention vec_v dense forward failed!";
    goto LABEL_34;
  }
  if ((_DWORD)v25 == get_padded_len(v25, 8u))
  {
    v50 = v87;
    v49 = (float *)__src;
  }
  else
  {
    v51 = get_padded_len(v8[7], 8u);
    v49 = v86;
    bzero(v86, 4 * (3 * v51));
    __n = 4 * v25;
    memcpy(v86, __src, 4 * v25);
    v52 = get_padded_len(v25, 8u);
    memcpy(&v86[v52], &__src[4 * v25], 4 * v25);
    v53 = get_padded_len(v25, 8u);
    memcpy(&v86[2 * v53], &__src[4 * (2 * v25)], 4 * v25);
    v50 = v87;
  }
  fi_activate_array(v49, v25, 9);
  v54 = get_padded_len(v25, 8u);
  fi_activate_array(&v49[v54], v25, 8);
  v55 = get_padded_len(v25, 8u);
  fi_activate_array(&v49[2 * v55], v25, 8);
  v56 = get_padded_len(v25, 8u);
  __srca = (void *)*((_QWORD *)&v101 + 1);
  axpy(v25, &v49[v56], 1, *((float **)&v101 + 1), 1, 1.0);
  v57 = get_padded_len(step, 8u);
  bzero(v50, 4 * v57);
  v58 = get_padded_len(v25, 8u);
  gmm_c(step, v25, (uint64_t)v49, (uint64_t)__srca, (uint64_t)&v49[2 * v58], (uint64_t)v50);
  v59 = get_padded_len(v8[3], 8u);
  bzero(v29, 4 * v59);
  if ((_DWORD)step)
  {
    v60 = 0;
    do
    {
      axpy(v8[3], (float *)(a3 + 4 * v8[3] * v60), 1, (float *)v29, 1, *((float *)v50 + v60));
      ++v60;
    }
    while (step != v60);
  }
LABEL_44:
  v61 = (char *)v97;
  v62 = get_padded_len(v8[14], 8u);
  memcpy(v61, v31, 4 * v62);
  v63 = &v61[4 * v8[14]];
  v64 = get_padded_len(v8[3], 8u);
  memcpy(v63, v29, 4 * v64);
  v65 = (void *)*((_QWORD *)&v98 + 1);
  v66 = get_padded_len(v8[16], 8u);
  bzero(v65, 4 * v66);
  v67 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 16) + 128))(0);
  if ((_DWORD)v67)
  {
    v19 = v67;
    v20 = *v9;
    v21 = "Tacotron decoder pre dense forward failed!";
  }
  else
  {
    v68 = (void *)*((_QWORD *)&v97 + 1);
    v69 = get_padded_len(v8[15], 8u);
    bzero(v68, 4 * v69);
    v70 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 19) + 128))(0);
    if ((_DWORD)v70)
    {
      v19 = v70;
      v20 = *v9;
      v21 = "Tacotron decoder rnn1 forward failed!";
    }
    else
    {
      v71 = get_padded_len(v8[15], 8u);
      axpy(v71, (float *)v68, 1, (float *)v65, 1, 1.0);
      v72 = (void *)v98;
      v73 = get_padded_len(v8[15], 8u);
      bzero(v72, 4 * v73);
      v74 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 20) + 128))(0);
      if ((_DWORD)v74)
      {
        v19 = v74;
        v20 = *v9;
        v21 = "Tacotron decoder rnn2 forward failed!";
      }
      else
      {
        v75 = get_padded_len(v8[15], 8u);
        axpy(v75, (float *)v72, 1, (float *)v65, 1, 1.0);
        v76 = (void *)*((_QWORD *)&v91 + 1);
        v77 = get_padded_len(*v8 * v8[1], 8u);
        bzero(v76, 4 * v77);
        v78 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 17) + 128))(0);
        if ((_DWORD)v78)
        {
          v19 = v78;
          v20 = *v9;
          v21 = "Tacotron decoder post dense forward failed!";
        }
        else
        {
          v79 = __dst;
          memcpy((void *)__dst, v65, 4 * v8[16]);
          v80 = get_padded_len(v8[16], 8u);
          memcpy((void *)(v79 + 4 * v80), v76, 4 * v8[1] * *v8);
          v81 = (void *)v91;
          v82 = get_padded_len(1, 8u);
          bzero(v81, 4 * v82);
          v19 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 23) + 128))(0);
          if (!(_DWORD)v19)
          {
            v83 = get_padded_len(1, 8u);
            memcpy(a4, v81, 4 * v83);
            v84 = get_padded_len(1, 8u);
            memcpy(&a4[4 * v84], v76, 4 * v8[1] * *v8);
            return v19;
          }
          v20 = *v9;
          v21 = "Tacotron stop dense forward failed!";
        }
      }
    }
  }
LABEL_35:
  log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, __n);
  return v19;
}

uint64_t tacodecoder_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  __int128 v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int step;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD v77[2];
  int v78;
  _QWORD v79[2];
  int v80;
  _QWORD v81[2];
  int v82;
  _QWORD v83[2];
  int v84;
  int v85;
  uint64_t v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 120);
  v86 = 0;
  v79[0] = 0;
  v79[1] = 0;
  v80 = 0;
  v77[0] = 0;
  v77[1] = 0;
  v78 = 0;
  v5 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v5;
  v85 = 1;
  if (*(_DWORD *)(v4 + 28) && !*(_DWORD *)(v4 + 20))
    v6 = *(_DWORD *)v4;
  else
    v6 = *(_DWORD *)v4 * *(_DWORD *)(v4 + 4);
  LODWORD(v86) = v6;
  result = fi_shape_set(2, (uint64_t)&v85, 4, (uint64_t)v77);
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 88)
                                                                                             + 144))(*(_QWORD *)(v4 + 88), v77, v8, v9, v10, v11);
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 96)
                                                                                              + 144))(*(_QWORD *)(v4 + 96), *(_QWORD *)(v4 + 88) + 40, v12, v13, v14, v15);
      if (!(_DWORD)result)
      {
        v16 = *(_QWORD *)(a1 + 120);
        v89 = 0;
        v83[0] = 0;
        v83[1] = 0;
        v84 = 0;
        v81[0] = 0;
        v81[1] = 0;
        v82 = 0;
        step = fi_shape_get_step(a2);
        v18 = *(_DWORD *)(v16 + 12) + *(_DWORD *)(v16 + 52);
        v87 = 1;
        v88 = v18;
        result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v83);
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 144) + 144))(*(_QWORD *)(v16 + 144), v83, v19, v20, v21, v22);
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 120) + 144))(*(_QWORD *)(v16 + 120), *(_QWORD *)(v16 + 144) + 40, v23, v24, v25, v26);
            if (!(_DWORD)result)
            {
              if (*(_DWORD *)(v16 + 28))
              {
                result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 104) + 144))(*(_QWORD *)(v16 + 104), *(_QWORD *)(v16 + 120) + 40, v27, v28, v29, v30);
                if ((_DWORD)result)
                  return result;
              }
              else
              {
                v55 = *(_DWORD *)(v16 + 12);
                v87 = step;
                v88 = v55;
                result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v83);
                if ((_DWORD)result)
                  return result;
                result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 112) + 144))(*(_QWORD *)(v16 + 112), v83, v56, v57, v58, v59);
                if ((_DWORD)result)
                  return result;
                result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 104) + 144))(*(_QWORD *)(v16 + 104), *(_QWORD *)(v16 + 112) + 40, v60, v61, v62, v63);
                if ((_DWORD)result)
                  return result;
              }
              if (*(_DWORD *)(v16 + 28))
                goto LABEL_15;
              if (!*(_DWORD *)(v16 + 16)
                || (v87 = step, v88 = 2, result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v81), !(_DWORD)result)
                && (result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 168) + 144))(*(_QWORD *)(v16 + 168), v81, v64, v65, v66, v67), !(_DWORD)result)&& (result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 176) + 144))(*(_QWORD *)(v16 + 176), *(_QWORD *)(v16 + 168) + 40, v68, v69, v70, v71), !(_DWORD)result))
              {
                if (!*(_DWORD *)(v16 + 20)
                  || (v72 = *(_DWORD *)(v16 + 56) + *(_DWORD *)(v16 + 12),
                      v87 = 1,
                      v88 = v72,
                      result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v83),
                      !(_DWORD)result)
                  && (result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16 + 192) + 144))(*(_QWORD *)(v16 + 192), v83, v73, v74, v75, v76), !(_DWORD)result))
                {
LABEL_15:
                  v31 = *(_DWORD *)(v4 + 12) + *(_DWORD *)(v4 + 56);
                  v85 = 1;
                  LODWORD(v86) = v31;
                  result = fi_shape_set(2, (uint64_t)&v85, 4, (uint64_t)v79);
                  if (!(_DWORD)result)
                  {
                    (*(void (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 128)
                                                                                                 + 144))(*(_QWORD *)(v4 + 128), v79, v32, v33, v34, v35);
                    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 152) + 144))(*(_QWORD *)(v4 + 152), *(_QWORD *)(v4 + 128) + 40, v36, v37, v38, v39);
                    if (!(_DWORD)result)
                    {
                      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 160) + 144))(*(_QWORD *)(v4 + 160), *(_QWORD *)(v4 + 128) + 40, v40, v41, v42, v43);
                      if (!(_DWORD)result)
                      {
                        result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 136) + 144))(*(_QWORD *)(v4 + 136), *(_QWORD *)(v4 + 160) + 40, v44, v45, v46, v47);
                        if (!(_DWORD)result)
                        {
                          v85 = 1;
                          LODWORD(v86) = *(_DWORD *)(v4 + 60) + *(_DWORD *)v4 * *(_DWORD *)(v4 + 4);
                          result = fi_shape_set(2, (uint64_t)&v85, 4, (uint64_t)v79);
                          if (!(_DWORD)result)
                          {
                            result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 184) + 144))(*(_QWORD *)(v4 + 184), v79, v48, v49, v50, v51);
                            if (!(_DWORD)result)
                            {
                              v85 = 1;
                              v54 = v4;
                              v53 = *(_DWORD *)v4;
                              v52 = *(_DWORD *)(v54 + 4);
                              LODWORD(v86) = get_padded_len(1, 8u) + v53 * v52;
                              return fi_shape_set(2, (uint64_t)&v85, 4, a1 + 40);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_bytes;
  int v12;
  int v13;
  uint64_t result;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;

  v27 = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (!v8)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Null pointer input!", a6, a7, a8, v26);
    return 7;
  }
  padded_bytes = get_padded_bytes(4 * *(_DWORD *)v8 * *(_DWORD *)(v8 + 4), 8u);
  v12 = get_padded_bytes(padded_bytes + 4 * *(_DWORD *)(v8 + 56), 8u);
  v28 = 8 * *(_DWORD *)(v8 + 60);
  v13 = get_padded_bytes(v12 + v28, 8u);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 88) + 152))();
  if (!(_DWORD)result)
  {
    v15 = get_padded_bytes(v28 + v27 + v13, 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 96) + 152))();
    if (!(_DWORD)result)
    {
      v16 = get_padded_bytes(v28 + v27 + v15, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 104) + 152))();
      if (!(_DWORD)result)
      {
        v17 = get_padded_bytes(v28 + v27 + v16, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 120) + 152))();
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(v28 + v27 + v17, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 128) + 152))();
          if (!(_DWORD)result)
          {
            v19 = get_padded_bytes(v28 + v27 + v18, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 136) + 152))();
            if (!(_DWORD)result)
            {
              v20 = get_padded_bytes(v28 + v27 + v19, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 144) + 152))();
              if (!(_DWORD)result)
              {
                v21 = get_padded_bytes(v28 + v27 + v20, 8u);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 152) + 152))();
                if (!(_DWORD)result)
                {
                  v22 = get_padded_bytes(v28 + v27 + v21, 8u);
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 160) + 152))();
                  if (!(_DWORD)result)
                  {
                    v23 = get_padded_bytes(v28 + v27 + v22, 8u);
                    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 184) + 152))();
                    if (!(_DWORD)result)
                    {
                      v24 = get_padded_bytes(v28 + v27 + v23, 8u);
                      if (*(_DWORD *)(v8 + 28))
                      {
LABEL_13:
                        result = 0;
                        *a2 = v24;
                        *a3 = 0;
                        return result;
                      }
                      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 112) + 152))();
                      if (!(_DWORD)result)
                      {
                        v24 = get_padded_bytes(v28 + v27 + v24, 8u);
                        if (*(_DWORD *)(v8 + 16))
                        {
                          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 168) + 152))();
                          if ((_DWORD)result)
                            return result;
                          v25 = get_padded_bytes(v28 + v27 + v24, 8u);
                          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 176) + 152))();
                          if ((_DWORD)result)
                            return result;
                          v24 = get_padded_bytes(v28 + v27 + v25, 8u);
                        }
                        if (!*(_DWORD *)(v8 + 20))
                          goto LABEL_13;
                        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 192) + 152))();
                        if (!(_DWORD)result)
                        {
                          v24 = get_padded_bytes(v28 + v24 + v27, 8u);
                          goto LABEL_13;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t step;
  int padded_len;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t (*v27)(uint64_t);
  uint64_t result;
  uint64_t (*v29)(uint64_t);
  uint64_t (*v30)(uint64_t);
  int v31;
  int v32;
  int padded_bytes;
  uint64_t (*v34)(void);
  int v35;

  v2 = *(_QWORD *)(a1 + 120);
  v4 = *(_QWORD *)(v2 + 144);
  v3 = *(_QWORD *)(v2 + 152);
  v5 = *(_QWORD *)(v2 + 160);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(1, 8u);
  v8 = get_padded_len((*(_DWORD *)v2 * *(_DWORD *)(v2 + 4)), 8u);
  v9 = padded_len + get_padded_len(*(unsigned int *)(v2 + 12), 8u);
  v10 = v9 + get_padded_len(*(unsigned int *)(v2 + 48), 8u);
  v11 = v10 + get_padded_len(*(unsigned int *)(v2 + 52), 8u);
  v12 = v8 + v11 + get_padded_len((*(_DWORD *)(v2 + 52) + *(_DWORD *)(v2 + 12)), 8u);
  v13 = v12 + get_padded_len(*(unsigned int *)(v2 + 56), 8u);
  v14 = *(unsigned int *)(v2 + 28);
  if ((_DWORD)v14)
  {
    v15 = get_padded_len(v14, 8u);
    v16 = v15 + get_padded_len((3 * *(_DWORD *)(v2 + 28)), 8u);
    v17 = v16 + 3 * get_padded_len(*(unsigned int *)(v2 + 28), 8u) + v13;
    v18 = step;
  }
  else
  {
    v19 = get_padded_len((*(_DWORD *)(v2 + 8) * step), 8u);
    v20 = v19 + get_padded_len(step, 8u);
    v17 = v20 + get_padded_len(step, 8u) + v13;
    v18 = (2 * step);
  }
  v21 = get_padded_len(v18, 8u);
  v22 = get_padded_len(*(unsigned int *)(v2 + 8), 8u) + v21;
  v23 = v17 + get_padded_len((*(_DWORD *)(v2 + 12) + *(_DWORD *)(v2 + 56)), 8u);
  v24 = v22 + get_padded_len(*(unsigned int *)(v2 + 64), 8u);
  v25 = v24 + get_padded_len(*(unsigned int *)(v2 + 60), 8u);
  v26 = v25 + get_padded_len(*(unsigned int *)(v2 + 60), 8u);
  *(_DWORD *)(a1 + 248) = 4
                        * (v26
                         + get_padded_len((*(_DWORD *)(v2 + 60) + *(_DWORD *)v2 * *(_DWORD *)(v2 + 4)), 8u)+ v23);
  v27 = *(uint64_t (**)(uint64_t))(v4 + 160);
  if (!v27 || (result = v27(v4), !(_DWORD)result))
  {
    v29 = *(uint64_t (**)(uint64_t))(v3 + 160);
    if (!v29 || (result = v29(v3), !(_DWORD)result))
    {
      v30 = *(uint64_t (**)(uint64_t))(v5 + 160);
      if (!v30 || (result = v30(v5), !(_DWORD)result))
      {
        v31 = *(_DWORD *)(a1 + 248);
        v32 = get_padded_bytes(*(_DWORD *)(v4 + 248), 8u) + v31;
        padded_bytes = get_padded_bytes(*(_DWORD *)(v3 + 248), 8u);
        *(_DWORD *)(a1 + 248) = v32 + padded_bytes + get_padded_bytes(*(_DWORD *)(v5 + 248), 8u);
        if (*(_DWORD *)(v2 + 28))
          return 0;
        if (*(_DWORD *)(v2 + 16))
          get_padded_len((*(_DWORD *)(v2 + 32) * step), 8u);
        if (*(_DWORD *)(v2 + 20))
        {
          get_padded_len(step, 8u);
          get_padded_len((*(_DWORD *)(v2 + 56) + *(_DWORD *)(v2 + 12)), 8u);
          get_padded_len(1, 8u);
        }
        if (*(_DWORD *)(v2 + 16))
        {
          v34 = *(uint64_t (**)(void))(*(_QWORD *)(v2 + 168) + 160);
          if (!v34)
            goto LABEL_20;
          result = v34();
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)(v2 + 16))
LABEL_20:
            *(_DWORD *)(a1 + 248) += get_padded_bytes(*(_DWORD *)(*(_QWORD *)(v2 + 168) + 248), 8u);
        }
        v35 = get_padded_len((*(_DWORD *)(v2 + 8) * step), 8u);
        result = 0;
        *(_DWORD *)(a1 + 248) += v35;
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_reset(uint64_t a1)
{
  uint64_t v2;
  uint64_t step;
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t result;
  uint64_t v7;
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t (*v10)(void);
  const void *v11;
  int v12;
  int v13;
  void *v14;
  unsigned int padded_len;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  void *v19;
  unsigned int v20;
  void *v21;
  unsigned int v22;
  void *v23;
  unsigned int v24;
  _DWORD *v25;
  unsigned int v26;
  __int128 v27;
  void *__dst[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v40 = 0;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  *(_OWORD *)__dst = 0u;
  v29 = 0u;
  v27 = 0u;
  pack_tacodecoder_internal_buffer(a1, &v27);
  v2 = *(_QWORD *)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v4 = *(_QWORD *)(v2 + 144);
  if (!v4 || (v5 = *(uint64_t (**)(void))(v4 + 176)) == 0 || (result = v5(), !(_DWORD)result))
  {
    v7 = *(_QWORD *)(v2 + 152);
    if (!v7 || (v8 = *(uint64_t (**)(void))(v7 + 176)) == 0 || (result = v8(), !(_DWORD)result))
    {
      v9 = *(_QWORD *)(v2 + 160);
      if (!v9 || (v10 = *(uint64_t (**)(void))(v9 + 176)) == 0 || (result = v10(), !(_DWORD)result))
      {
        v11 = *(const void **)(a1 + 72);
        if (v11)
        {
          v12 = *(_DWORD *)(v2 + 4) * *(_DWORD *)v2;
          memcpy(__dst[0], v11, (4 * v12));
          memcpy(**(void ***)(*(_QWORD *)(v2 + 144) + 120), (const void *)(*(_QWORD *)(a1 + 72) + (4 * v12)), 4 * *(unsigned int *)(v2 + 56));
          v13 = *(_DWORD *)(v2 + 56) + v12;
          memcpy(**(void ***)(*(_QWORD *)(v2 + 152) + 120), (const void *)(*(_QWORD *)(a1 + 72) + (4 * v13)), 4 * *(unsigned int *)(v2 + 60));
          memcpy(**(void ***)(*(_QWORD *)(v2 + 160) + 120), (const void *)(*(_QWORD *)(a1 + 72) + (4 * *(_DWORD *)(v2 + 60) + 4 * v13)), 4 * *(unsigned int *)(v2 + 60));
          v14 = __dst[1];
          padded_len = get_padded_len(*(unsigned int *)(v2 + 12), 8u);
          bzero(v14, 4 * padded_len);
          v16 = (void *)*((_QWORD *)&v27 + 1);
          v17 = get_padded_len(1, 8u);
          bzero(v16, 4 * v17);
          v18 = *(unsigned int *)(v2 + 28);
          if ((_DWORD)v18)
          {
            v19 = (void *)v38;
            v20 = get_padded_len(v18, 8u);
            bzero(v19, 4 * v20);
          }
          else
          {
            v21 = (void *)v29;
            v22 = get_padded_len(step, 8u);
            bzero(v21, 4 * v22);
            v23 = (void *)*((_QWORD *)&v29 + 1);
            v24 = get_padded_len(step, 8u);
            bzero(v23, 4 * v24);
            if (*(_DWORD *)(v2 + 20))
            {
              v25 = (_DWORD *)*((_QWORD *)&v36 + 1);
              v26 = get_padded_len(step, 8u);
              bzero(v25, 4 * v26);
              if (step < 2)
              {
                if (!(_DWORD)step)
                  return 0;
              }
              else
              {
                memset_pattern16(v25 + 1, &unk_1DECECB10, 4 * (step - 2) + 4);
              }
              result = 0;
              *v25 = 1065353216;
              return result;
            }
          }
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t tacodecoder_assign_glbBuf()
{
  return 0;
}

uint64_t tacodecoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int padded_bytes;
  int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;

  v9 = *(_QWORD *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v17);
    return 7;
  }
  v10 = *(_QWORD *)(a1 + 72);
  padded_bytes = get_padded_bytes(4 * *(_DWORD *)v9 * *(_DWORD *)(v9 + 4), 8u);
  v12 = get_padded_bytes(padded_bytes + 4 * *(_DWORD *)(v9 + 56), 8u);
  v18 = get_padded_bytes(v12 + 8 * *(_DWORD *)(v9 + 60), 8u);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 88), v10, &v18);
  if (!(_DWORD)result)
  {
    v18 = get_padded_bytes(v18, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 96), v10, &v18);
    if (!(_DWORD)result)
    {
      v18 = get_padded_bytes(v18, 8u);
      v19 = v18;
      v14 = *(_QWORD *)(a1 + 120);
      v15 = *(_QWORD *)(a1 + 72);
      if (*(_DWORD *)(v14 + 28))
      {
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 104), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        v16 = *(_QWORD *)(v14 + 120);
      }
      else
      {
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 112), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 104), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        if (*(_DWORD *)(v14 + 16))
        {
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 168), v15, &v19);
          if ((_DWORD)result)
            return result;
          v19 = get_padded_bytes(v19, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 176), v15, &v19);
          if ((_DWORD)result)
            return result;
          v19 = get_padded_bytes(v19, 8u);
        }
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 120), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        if (!*(_DWORD *)(v14 + 20))
          goto LABEL_9;
        v16 = *(_QWORD *)(v14 + 192);
      }
      result = fi_layer_find_weights_via_offset(v16, v15, &v19);
      if ((_DWORD)result)
        return result;
      v19 = get_padded_bytes(v19, 8u);
LABEL_9:
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 144), v15, &v19);
      if (!(_DWORD)result)
      {
        v18 = get_padded_bytes(v19, 8u);
        v18 = get_padded_bytes(v18, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 128), v10, &v18);
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(v18, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 136), v10, &v18);
          if (!(_DWORD)result)
          {
            v18 = get_padded_bytes(v18, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 152), v10, &v18);
            if (!(_DWORD)result)
            {
              v18 = get_padded_bytes(v18, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 160), v10, &v18);
              if (!(_DWORD)result)
              {
                v18 = get_padded_bytes(v18, 8u);
                return fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 184), v10, &v18);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_load_state(uint64_t a1, float *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t step;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  char *v28;
  int padded_len;
  uint64_t v30;
  int v31;
  __int128 v32;
  void *__dst[2];
  void *v34[2];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v4 = *(uint64_t **)a1;
  v45 = 0;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v40 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  *(_OWORD *)v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  *(_OWORD *)__dst = 0u;
  v31 = 0;
  pack_tacodecoder_internal_buffer(a1, &v32);
  v5 = *(_QWORD *)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  if (!a2)
    return 0;
  v10 = step;
  if ((_DWORD)step != (float)(*a2 + 0.00001))
  {
    v25 = *v4;
    v26 = "input step mismatch with stored value!";
LABEL_8:
    log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v7, v8, v9, v30);
    return 7;
  }
  tacodecoder_layer_sizeof_state(a1, &v31);
  if (v31 != (float)(a2[1] + 0.00001))
  {
    v25 = *v4;
    v26 = "state size mismatch with stored value!";
    goto LABEL_8;
  }
  v11 = &a2[get_padded_len(2, 8u)];
  v12 = (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5);
  memcpy(__dst[0], v11, 4 * v12);
  v13 = &v11[get_padded_len(v12, 8u)];
  v14 = *(unsigned int *)(v5 + 56);
  memcpy(**(void ***)(*(_QWORD *)(v5 + 144) + 120), v13, 4 * v14);
  v15 = (char *)&v13[get_padded_len(v14, 8u)];
  v16 = *(unsigned int *)(v5 + 60);
  memcpy(**(void ***)(*(_QWORD *)(v5 + 152) + 120), v15, 4 * v16);
  v17 = &v15[4 * get_padded_len(v16, 8u)];
  v18 = *(unsigned int *)(v5 + 60);
  memcpy(**(void ***)(*(_QWORD *)(v5 + 160) + 120), v17, 4 * v18);
  v19 = &v17[4 * get_padded_len(v18, 8u)];
  v20 = *(unsigned int *)(v5 + 12);
  memcpy(__dst[1], v19, 4 * v20);
  v21 = &v19[4 * get_padded_len(v20, 8u)];
  **((_DWORD **)&v32 + 1) = *(_DWORD *)v21;
  v22 = &v21[4 * get_padded_len(1, 8u)];
  v23 = *(unsigned int *)(v5 + 28);
  if ((_DWORD)v23)
  {
    memcpy((void *)v43, v22, 4 * v23);
    v24 = v23;
LABEL_11:
    get_padded_len(v24, 8u);
    return 0;
  }
  memcpy(v34[0], v22, 4 * v10);
  v28 = &v22[4 * get_padded_len(v10, 8u)];
  memcpy(v34[1], v28, 4 * v10);
  padded_len = get_padded_len(v10, 8u);
  if (*(_DWORD *)(v5 + 20))
  {
    memcpy(*((void **)&v41 + 1), &v28[4 * padded_len], 4 * v10);
    v24 = v10;
    goto LABEL_11;
  }
  return 0;
}

uint64_t tacodecoder_layer_save_state(uint64_t a1, float *a2)
{
  uint64_t v4;
  uint64_t step;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  int padded_len;
  unsigned int v23;
  __int128 v24;
  void *__src[2];
  void *v26[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  *(_OWORD *)v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  *(_OWORD *)__src = 0u;
  v23 = 0;
  pack_tacodecoder_internal_buffer(a1, &v24);
  v4 = *(_QWORD *)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  if (a2)
  {
    v6 = step;
    *a2 = (float)step;
    tacodecoder_layer_sizeof_state(a1, &v23);
    a2[1] = (float)v23;
    v7 = &a2[get_padded_len(2, 8u)];
    v8 = (*(_DWORD *)(v4 + 4) * *(_DWORD *)v4);
    memcpy(v7, __src[0], 4 * v8);
    v9 = &v7[get_padded_len(v8, 8u)];
    v10 = *(unsigned int *)(v4 + 56);
    memcpy(v9, **(const void ***)(*(_QWORD *)(v4 + 144) + 120), 4 * v10);
    v11 = (char *)&v9[get_padded_len(v10, 8u)];
    v12 = *(unsigned int *)(v4 + 60);
    memcpy(v11, **(const void ***)(*(_QWORD *)(v4 + 152) + 120), 4 * v12);
    v13 = &v11[4 * get_padded_len(v12, 8u)];
    v14 = *(unsigned int *)(v4 + 60);
    memcpy(v13, **(const void ***)(*(_QWORD *)(v4 + 160) + 120), 4 * v14);
    v15 = &v13[4 * get_padded_len(v14, 8u)];
    v16 = *(unsigned int *)(v4 + 12);
    memcpy(v15, __src[1], 4 * v16);
    v17 = &v15[4 * get_padded_len(v16, 8u)];
    *(_DWORD *)v17 = **((_DWORD **)&v24 + 1);
    v18 = &v17[4 * get_padded_len(1, 8u)];
    v19 = *(unsigned int *)(v4 + 28);
    if ((_DWORD)v19)
    {
      memcpy(v18, (const void *)v35, 4 * v19);
      v6 = v19;
LABEL_6:
      get_padded_len(v6, 8u);
      return 0;
    }
    memcpy(v18, v26[0], 4 * v6);
    v20 = &v18[4 * get_padded_len(v6, 8u)];
    memcpy(v20, v26[1], 4 * v6);
    padded_len = get_padded_len(v6, 8u);
    if (*(_DWORD *)(v4 + 20))
    {
      memcpy(&v20[4 * padded_len], *((const void **)&v33 + 1), 4 * v6);
      goto LABEL_6;
    }
  }
  return 0;
}

uint64_t tacodecoder_layer_sizeof_state(uint64_t a1, _DWORD *a2)
{
  _DWORD *v4;
  uint64_t step;
  int padded_len;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  _QWORD v17[27];

  pack_tacodecoder_internal_buffer(a1, v17);
  v4 = *(_DWORD **)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(2, 8u);
  v7 = get_padded_len((v4[1] * *v4), 8u);
  v8 = padded_len + get_padded_len(v4[14], 8u);
  v9 = v8 + get_padded_len(v4[15], 8u);
  v10 = v9 + get_padded_len(v4[15], 8u);
  v11 = v7 + v10 + get_padded_len(v4[3], 8u);
  v12 = v11 + get_padded_len(1, 8u);
  v13 = v4[7];
  if ((_DWORD)v13)
  {
    v14 = get_padded_len(v13, 8u);
  }
  else
  {
    v15 = get_padded_len(step, 8u);
    v14 = v15 + get_padded_len(step, 8u) + v12;
    v12 = get_padded_len(step, 8u);
  }
  *a2 = v14 + v12;
  return 0;
}

float get_last_alignment(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float result;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  _OWORD v14[2];
  _OWORD v15[10];
  __int128 v16;
  uint64_t v17;

  v17 = 0;
  result = 0.0;
  v16 = 0u;
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  if (a1)
  {
    if (*(_QWORD *)(a1 + 240))
    {
      pack_tacodecoder_internal_buffer(a1, v14);
      v11 = *(_QWORD *)(a1 + 120);
      if (*(_DWORD *)(v11 + 28))
      {
        v12 = *((_QWORD *)&v16 + 1);
      }
      else
      {
        if (*(_DWORD *)(v11 + 20))
          v13 = (uint64_t *)&v15[7] + 1;
        else
          v13 = (uint64_t *)v15;
        v12 = *v13;
      }
      result = *(float *)(v12 + 4 * (*(_DWORD *)(a1 + 24) - 1));
      *a2 = result;
    }
    else
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron stop dense forward failed!", a6, a7, a8, *(uint64_t *)&v14[0]);
    }
  }
  return result;
}

uint64_t pack_tacodecoder_internal_buffer(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t step;
  int padded_len;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t result;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;

  v3 = *(_QWORD *)(a1 + 120);
  v4 = *(_QWORD *)(a1 + 240);
  v6 = *(_QWORD *)(v3 + 144);
  v5 = *(_QWORD *)(v3 + 152);
  v7 = *(_QWORD *)(v3 + 160);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  *a2 = 0;
  a2[1] = v4;
  padded_len = get_padded_len(1, 8u);
  a2[2] = v4 + (4 * padded_len);
  v10 = get_padded_len((*(_DWORD *)v3 * *(_DWORD *)(v3 + 4)), 8u) + padded_len;
  a2[3] = v4 + (4 * v10);
  v11 = get_padded_len(*(unsigned int *)(v3 + 12), 8u) + v10;
  LODWORD(v12) = 4 * v11;
  if (!*(_DWORD *)(v3 + 28))
  {
    a2[4] = v4 + v12;
    v13 = get_padded_len(step, 8u) + v11;
    a2[5] = v4 + (4 * v13);
    v14 = get_padded_len(step, 8u) + v13;
    a2[6] = v4 + (4 * v14);
    LODWORD(v12) = 4 * (get_padded_len((2 * step), 8u) + v14);
  }
  a2[7] = v4 + v12;
  v15 = get_padded_len(*(unsigned int *)(v3 + 48), 8u);
  a2[8] = v4 + (v12 + 4 * v15);
  v16 = get_padded_len(*(unsigned int *)(v3 + 52), 8u) + v15;
  a2[9] = v4 + (v12 + 4 * v16);
  v17 = get_padded_len((*(_DWORD *)(v3 + 52) + *(_DWORD *)(v3 + 12)), 8u) + v16;
  a2[10] = v4 + (v12 + 4 * v17);
  v18 = get_padded_len(*(unsigned int *)(v3 + 56), 8u) + v17;
  v19 = *(unsigned int *)(v3 + 28);
  v20 = v4 + (v12 + 4 * v18);
  if ((_DWORD)v19)
  {
    a2[22] = v20;
    v21 = get_padded_len(v19, 8u) + v18;
    a2[23] = v4 + (v12 + 4 * v21);
    v22 = v12 + 4 * (get_padded_len((3 * *(_DWORD *)(v3 + 28)), 8u) + v21);
    a2[24] = v4 + v22;
    v12 = v22 + 12 * get_padded_len(*(unsigned int *)(v3 + 28), 8u);
    a2[25] = v4 + v12;
    v23 = get_padded_len(step, 8u);
  }
  else
  {
    a2[11] = v20;
    v23 = get_padded_len((*(_DWORD *)(v3 + 8) * step), 8u) + v18;
  }
  a2[12] = v4 + (v12 + 4 * v23);
  v24 = get_padded_len(*(unsigned int *)(v3 + 8), 8u);
  a2[13] = v4 + (v12 + 4 * (v23 + v24));
  v25 = get_padded_len((*(_DWORD *)(v3 + 12) + *(_DWORD *)(v3 + 56)), 8u) + v24;
  a2[16] = v4 + (v12 + 4 * (v23 + v25));
  v26 = get_padded_len(*(unsigned int *)(v3 + 64), 8u) + v25;
  a2[14] = v4 + (v12 + 4 * (v23 + v26));
  v27 = get_padded_len(*(unsigned int *)(v3 + 60), 8u) + v26;
  a2[15] = v4 + (v12 + 4 * (v23 + v27));
  v28 = get_padded_len(*(unsigned int *)(v3 + 60), 8u) + v27;
  a2[17] = v4 + (v12 + 4 * (v23 + v28));
  v29 = v12
      + 4
      * (v23
       + get_padded_len((*(_DWORD *)(v3 + 60) + *(_DWORD *)v3 * *(_DWORD *)(v3 + 4)), 8u)
       + v28);
  *(_QWORD *)(v6 + 240) = v4 + v29;
  v30 = v29 + get_padded_bytes(*(_DWORD *)(v6 + 248), 8u);
  *(_QWORD *)(v5 + 240) = v4 + v30;
  v31 = get_padded_bytes(*(_DWORD *)(v5 + 248), 8u) + v30;
  *(_QWORD *)(v7 + 240) = v4 + v31;
  result = get_padded_bytes(*(_DWORD *)(v7 + 248), 8u);
  if (!*(_DWORD *)(v3 + 28))
  {
    v33 = result + v31;
    if (*(_DWORD *)(v3 + 16))
    {
      a2[18] = v4 + v33;
      v34 = v33 + 4 * get_padded_len((*(_DWORD *)(v3 + 32) * step), 8u);
      v35 = *(_QWORD *)(v3 + 168);
      *(_QWORD *)(v35 + 240) = v4 + v34;
      v33 = get_padded_bytes(*(_DWORD *)(v35 + 248), 8u) + v34;
    }
    if (*(_DWORD *)(v3 + 20))
    {
      a2[19] = v4 + v33;
      v36 = get_padded_len(step, 8u);
      a2[20] = v4 + v33 + 4 * v36;
      v37 = get_padded_len((*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 12)), 8u) + v36;
      a2[21] = v4 + v33 + 4 * v37;
      v33 += 4 * (get_padded_len(1, 8u) + v37);
    }
    a2[26] = v4 + v33;
    return get_padded_len((*(_DWORD *)(v3 + 8) * step), 8u);
  }
  return result;
}

uint64_t get_alignment(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  _OWORD v11[2];
  _OWORD v12[10];
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  v13 = 0u;
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  if (result)
  {
    v8 = result;
    if (!*(_QWORD *)(result + 240))
      log_OutText(**(_QWORD **)result, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Decoder get buf failed!", a6, a7, a8, *(uint64_t *)&v11[0]);
    pack_tacodecoder_internal_buffer(v8, v11);
    v9 = *(_QWORD *)(v8 + 120);
    if (*(_DWORD *)(v9 + 28))
    {
      return *((_QWORD *)&v13 + 1);
    }
    else
    {
      if (*(_DWORD *)(v9 + 20))
        v10 = (char *)&v12[7] + 8;
      else
        v10 = (char *)v12;
      return *(_QWORD *)v10;
    }
  }
  return result;
}

uint64_t additive_attention(uint64_t *a1, _QWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5)
{
  float *v10;
  float *v11;
  float *v12;
  void *v13;
  const void *v14;
  unsigned int padded_len;
  void *v16;
  const void *v17;
  unsigned int v18;
  void *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  void *v29;
  unsigned int v30;
  uint64_t v31;
  void *v32;
  const void *v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  void *v38;
  const void *v39;
  unsigned int v40;
  uint64_t v41;
  float v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  float *v46;
  float v47;
  float v48;
  float v49;
  float v50;
  void *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  unsigned int v58;
  void *v59;
  unsigned int v60;
  uint64_t v61;

  v10 = *(float **)(a5 + 152);
  v11 = *(float **)(a5 + 88);
  v12 = *(float **)(a5 + 32);
  v14 = *(const void **)(a5 + 64);
  v13 = *(void **)(a5 + 72);
  padded_len = get_padded_len(a4[13], 8u);
  memcpy(v13, v14, 4 * padded_len);
  v16 = (void *)(*(_QWORD *)(a5 + 72) + 4 * a4[13]);
  v17 = *(const void **)(a5 + 24);
  v18 = get_padded_len(a4[3], 8u);
  memcpy(v16, v17, 4 * v18);
  v19 = *(void **)(a5 + 80);
  v20 = get_padded_len(a4[14], 8u);
  bzero(v19, 4 * v20);
  v21 = (*(uint64_t (**)(_QWORD))(a2[7] + 128))(0);
  if ((_DWORD)v21)
  {
    v25 = v21;
    v26 = "Tacotron attention rnn forward failed!";
LABEL_5:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v22, v23, v24, v61);
    return v25;
  }
  bzero(*(void **)(a5 + 96), 4 * a4[2]);
  v27 = (*(uint64_t (**)(_QWORD))(a2[4] + 128))(0);
  if ((_DWORD)v27)
  {
    v25 = v27;
    v26 = "Tacotron decoder Key dense forward failed!";
    goto LABEL_5;
  }
  if (a4[4])
  {
    interleave(a3, *(int **)(a5 + 32), *(float **)(a5 + 40), *(_QWORD *)(a5 + 48));
    v29 = *(void **)(a5 + 144);
    v30 = get_padded_len(a4[8] * a3, 8u);
    bzero(v29, 4 * v30);
    v31 = (*(uint64_t (**)(_QWORD))(a2[10] + 128))(0);
    if ((_DWORD)v31)
    {
      v25 = v31;
      v26 = "Tacotron location layer conv forward failed!";
      goto LABEL_5;
    }
    v38 = *(void **)(a5 + 88);
    v39 = *(const void **)(a5 + 208);
    v40 = get_padded_len(a4[2] * a3, 8u);
    memcpy(v38, v39, 4 * v40);
    v41 = (*(uint64_t (**)(_QWORD))(a2[11] + 128))(0);
    if ((_DWORD)v41)
    {
      v25 = v41;
      v26 = "Tacotron location layer dense forward failed!";
      goto LABEL_5;
    }
  }
  else
  {
    v32 = *(void **)(a5 + 88);
    v33 = *(const void **)(a5 + 208);
    v34 = get_padded_len(a4[2] * a3, 8u);
    memcpy(v32, v33, 4 * v34);
  }
  if ((_DWORD)a3)
  {
    v35 = 0;
    do
      axpy(a4[2], *(float **)(a5 + 96), 1, (float *)(*(_QWORD *)(a5 + 88) + 4 * a4[2] * v35++), 1, 1.0);
    while ((_DWORD)a3 != v35);
  }
  fi_activate_array(v11, a4[2] * a3, 2);
  v36 = get_padded_len(a3, 8u);
  bzero(v12, 4 * v36);
  v37 = (*(uint64_t (**)(_QWORD))(a2[2] + 128))(0);
  if ((_DWORD)v37)
  {
    v25 = v37;
    v26 = "Tacotron attention vec_v dense forward failed!";
    goto LABEL_5;
  }
  fi_activate_array(v12, a3, 1);
  oneNorm((uint64_t)v12, a3, 1, (uint64_t)v12);
  axpy(a3, *(float **)(a5 + 32), 1, *(float **)(a5 + 40), 1, 1.0);
  if (a4[5])
  {
    if (!(_DWORD)a3)
      goto LABEL_23;
    v42 = **(float **)(a5 + 168);
    v43 = a3;
    v44 = 0.0;
    v45 = a3;
    v46 = v10;
    v47 = 0.0;
    do
    {
      v48 = *v46;
      v49 = *v12++;
      v50 = v49 * (float)((float)((float)(v42 * v47) + (float)(*v46 * (float)(1.0 - v42))) + 0.0000001);
      *v46++ = v50;
      v44 = v44 + v50;
      v47 = v48;
      --v45;
    }
    while (v45);
    if (v44 == 0.0)
    {
LABEL_23:
      v25 = 7;
      v26 = "Alpha sum equals zero!";
      goto LABEL_5;
    }
    do
    {
      *v10 = *v10 / v44;
      ++v10;
      --v43;
    }
    while (v43);
  }
  v51 = *(void **)(a5 + 24);
  v52 = get_padded_len(a4[3], 8u);
  bzero(v51, 4 * v52);
  v53 = a4[5];
  v54 = 152;
  if (!v53)
    v54 = 32;
  if ((_DWORD)a3)
  {
    v55 = 0;
    v56 = *(_QWORD *)(a5 + v54);
    do
    {
      axpy(a4[3], (float *)(*(_QWORD *)a5 + 4 * a4[3] * v55), 1, *(float **)(a5 + 24), 1, *(float *)(v56 + 4 * v55));
      ++v55;
    }
    while (a3 != v55);
    v53 = a4[5];
  }
  if (!v53)
    return 0;
  v57 = *(void **)(a5 + 160);
  v58 = get_padded_len(a4[14] + a4[3], 8u);
  bzero(v57, 4 * v58);
  memcpy(*(void **)(a5 + 160), *(const void **)(a5 + 24), 4 * a4[3]);
  memcpy((void *)(*(_QWORD *)(a5 + 160) + 4 * a4[3]), *(const void **)(a5 + 80), 4 * a4[14]);
  v59 = *(void **)(a5 + 168);
  v60 = get_padded_len(1, 8u);
  bzero(v59, 4 * v60);
  v25 = (*(uint64_t (**)(_QWORD))(a2[13] + 128))(0);
  if ((_DWORD)v25)
  {
    v26 = "Tacotron forward attention trans agent dense forward failed!";
    goto LABEL_5;
  }
  return v25;
}

float *Stream_ComputeStats(float *result, int a2, uint64_t a3)
{
  float v3;
  uint64_t v4;
  float v5;
  uint64_t v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;

  *(_QWORD *)a3 = 0;
  *(float *)(a3 + 8) = (float)a2;
  v3 = 1.0 / (float)a2;
  if (a2 <= 0)
  {
    v10 = 0.0;
    *(float *)a3 = v3 * 0.0;
  }
  else
  {
    v4 = a2;
    v5 = 0.0;
    v6 = a2;
    v7 = result;
    do
    {
      v8 = *v7++;
      v5 = v8 + v5;
      *(float *)a3 = v5;
      --v6;
    }
    while (v6);
    v9 = v3 * v5;
    *(float *)a3 = v3 * v5;
    v10 = 0.0;
    do
    {
      v11 = *result++;
      v10 = v10 + (float)((float)(v11 - v9) * (float)(v11 - v9));
      *(float *)(a3 + 4) = v10;
      --v4;
    }
    while (v4);
  }
  *(float *)(a3 + 4) = v3 * v10;
  return result;
}

void mlpg_gv(uint64_t a1)
{
  uint64_t v2;
  float v3;

  v3 = *(float *)(a1 + 720);
  v2 = 10;
  MFS__mlpg2(a1, 0);
  if (v3 != 0.0 && *(int *)(a1 + 20) >= 2)
    mlpgGradHessian((uint64_t)&v2, (int *)a1, 0);
}

float *mlpgGradHessian(uint64_t a1, int *a2, int a3)
{
  float *result;
  float *v6;
  int *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t *v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  int *v17;
  float v18;
  int v19;
  float v20;
  float *v21;
  float **v22;
  float *v23;
  float v24;
  BOOL v25;
  char v26;
  float v27;
  float v28;
  float v29;
  int v30;
  float v31;
  float v32;
  unint64_t v33;
  uint64_t v34;
  float **v35;
  float *v36;
  float *v37;
  float v38;
  uint64_t v39;
  unint64_t i;
  float v41;
  _BYTE *v42;
  uint64_t v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  BOOL v54;
  float v55;
  float v56;
  float *v57;
  float *v58;
  float *v59;
  float **v60;
  unint64_t v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float *v68;
  unint64_t v69;
  float *v70;
  float v71;
  unint64_t v72;
  float *v73;
  float *v74;
  float v75;
  uint64_t *v76;
  unint64_t v77;
  float *v78;
  float v79;
  float v80;
  uint64_t v81;
  float v83;
  float v84;
  float v85;
  float v86;
  char v87;
  int v88;
  int *v89;
  float v90;
  uint64_t v91;
  int v92;

  result = (float *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a2 + 8), 4, (2 * a2[5]));
  if (result)
  {
    v6 = result;
    v7 = a2;
    if (a2[4] >= 1)
    {
      v8 = 0;
      LODWORD(v9) = a2[5];
      v10 = (int)v9;
      v11 = 1.0e10;
      v12 = 1.0;
      v89 = a2;
      do
      {
        if ((int)v9 >= 1)
        {
          v13 = (uint64_t *)*((_QWORD *)v7 + 5);
          v14 = v9;
          v15 = v6;
          do
          {
            v16 = *v13++;
            *v15++ = *(float *)(v16 + 4 * v8);
            --v14;
          }
          while (v14);
        }
        v17 = &v7[v8];
        v18 = *((float *)v17 + 80);
        v90 = *((float *)v17 + 30);
        VarianceNormalize(v6, v9, *(_DWORD *)(a1 + 4), v90);
        calc_R_and_r_opt(v89, v8);
        v7 = v89;
        v9 = v89[5];
        v88 = *(_DWORD *)a1;
        if (*(int *)a1 >= 1)
        {
          v19 = 0;
          v20 = 1.0 / (float)((int)v9 * **((_DWORD **)v89 + 4));
          v21 = (float *)*((_QWORD *)v89 + 11);
          v22 = (float **)*((_QWORD *)v89 + 12);
          v23 = (float *)*((_QWORD *)v89 + 13);
          v85 = v18 * -2.0;
          v83 = v18 + v18;
          v84 = v18 * (float)((int)v9 - 1);
          v24 = -v20;
          if (a3)
            v25 = (int)v9 < 1;
          else
            v25 = 1;
          v26 = v25;
          v87 = v26;
          v27 = v11;
          v86 = v18;
          do
          {
            v92 = 0;
            v91 = 0;
            Stream_ComputeStats(v6, v9, (uint64_t)&v91);
            v29 = v28;
            v30 = *(_DWORD *)(a1 + 4);
            v31 = *((float *)&v91 + 1);
            v32 = *((float *)&v91 + 1);
            if (v30)
              v32 = log(*((float *)&v91 + 1));
            v7 = v89;
            if ((int)v9 < 1)
            {
              v42 = (_BYTE *)*((_QWORD *)v89 + 14);
              v54 = v42 == 0;
              v47 = 0.0;
              v48 = v86;
            }
            else
            {
              v33 = 0;
              v34 = v89[6];
              v35 = v22;
              v36 = v6;
              do
              {
                v37 = v22[v33];
                v38 = *v37 * v6[v33];
                v21[v33] = v38;
                if ((int)v34 >= 2)
                {
                  v39 = -1;
                  for (i = 1; i != v34; ++i)
                  {
                    if (v33 + i < v9)
                    {
                      v38 = v38 + (float)(v37[i] * v36[i]);
                      v21[v33] = v38;
                    }
                    if (v33 >= i)
                    {
                      v38 = v38 + (float)(v35[v39][i] * v36[v39]);
                      v21[v33] = v38;
                    }
                    --v39;
                  }
                }
                ++v33;
                ++v36;
                ++v35;
              }
              while (v33 != v9);
              v41 = (float)(2.0 / (float)((int)v9 * (int)v9)) * (float)(v83 + (float)(v84 * (float)(v32 - v90)));
              v42 = (_BYTE *)*((_QWORD *)v89 + 14);
              if (v42)
              {
                v43 = 0;
                v44 = 1.0 / v31;
                if (v30 != 1)
                  v44 = 1.0;
                v45 = *(float *)&v91;
                v46 = -v41;
                v47 = 0.0;
                v48 = v86;
                do
                {
                  v49 = v6[v43];
                  v50 = v23[v43];
                  v51 = v21[v43];
                  v52 = *v22[v43];
                  v53 = v20 * (float)(v50 - v51);
                  v21[v43] = v53;
                  if (v42[v43])
                    v53 = v53
                        + (float)((float)((float)(v29 * (float)(v85 * (float)(v32 - v90))) * (float)(v6[v43] - v45))
                                * v44);
                  v47 = v47 + (float)((float)(v20 * v49) * (float)(v50 + (float)(v51 * -0.5)));
                  v21[v43++] = (float)(1.0
                                     / (float)((float)((float)((float)(v49 - v45) * (float)(v49 - v45)) * v46)
                                             + (float)(v24 * v52)))
                             * v53;
                }
                while (v9 != v43);
                v54 = 0;
              }
              else
              {
                v55 = *(float *)&v91;
                v56 = -v41;
                v57 = v6;
                v47 = 0.0;
                v58 = v23;
                v59 = v21;
                v60 = v22;
                v61 = v9;
                v48 = v86;
                do
                {
                  v62 = *v57++;
                  v63 = v62;
                  v64 = v20 * v62;
                  v65 = *v58++;
                  v66 = v65;
                  v67 = v65 + (float)(*v59 * -0.5);
                  v68 = *v60++;
                  v47 = v47 + (float)(v64 * v67);
                  *v59 = (float)(v20 * (float)(v66 - *v59))
                       / (float)((float)((float)((float)(v63 - v55) * (float)(v63 - v55)) * v56) + (float)(v24 * *v68));
                  ++v59;
                  --v61;
                }
                while (v61);
                v42 = 0;
                v54 = 1;
              }
            }
            if ((v87 & 1) == 0)
            {
              v69 = v9;
              v70 = v21;
              do
              {
                if (!v54 && *v42 == 1)
                  *v70 = 0.0;
                ++v70;
                ++v42;
                --v69;
              }
              while (v69);
            }
            v71 = v47 + (float)((float)(v32 + (float)(v90 * -2.0)) * (float)(v48 * (float)(v32 * -0.5)));
            v11 = -v71;
            if (v19)
            {
              if (fabsf(v27 + v71) < 0.000001)
              {
                v11 = v27;
                break;
              }
              if (v27 < v11)
                v12 = v12 * 0.5;
              if (v27 > v11)
                v12 = v12 * 1.2;
            }
            if ((int)v9 >= 1)
            {
              v72 = v9;
              v73 = v21;
              v74 = v6;
              do
              {
                *v74 = *v74 + (float)(v12 * *v73);
                v75 = *v73++;
                v74[v10] = v75;
                ++v74;
                --v72;
              }
              while (v72);
            }
            ++v19;
            v27 = -v71;
          }
          while (v19 != v88);
        }
        if ((int)v9 >= 1)
        {
          v76 = (uint64_t *)*((_QWORD *)v7 + 5);
          v77 = v9;
          v78 = v6;
          do
          {
            v79 = *v78++;
            v80 = v79;
            v81 = *v76++;
            *(float *)(v81 + 4 * v8) = *(float *)(v81 + 4 * v8)
                                     + (float)(*(float *)(a1 + 8) * (float)(v80 - *(float *)(v81 + 4 * v8)));
            --v77;
          }
          while (v77);
        }
        ++v8;
      }
      while (v8 < v7[4]);
    }
    return (float *)heap_Free(*(_QWORD **)(*(_QWORD *)v7 + 8), (uint64_t)v6);
  }
  return result;
}

void mlpg_gvc(uint64_t a1)
{
  uint64_t v2;
  float v3;

  v3 = *(float *)(a1 + 720);
  v2 = 10;
  mlpg_c(a1, 0);
  if (v3 != 0.0)
    mlpgGradHessian((uint64_t)&v2, (int *)a1, 1);
}

void mlpg_gvnorm(uint64_t a1)
{
  float v2;
  float *v3;
  uint64_t v4;
  int v5;
  float **v6;
  uint64_t v7;
  float *v8;
  float *v9;
  uint64_t v10;
  float **v11;
  float *v12;
  float v13;
  float v14;
  float *v15;

  v2 = *(float *)(a1 + 720);
  MFS__mlpg2(a1, 0);
  if (v2 != 0.0)
  {
    v3 = (float *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 4, *(unsigned int *)(a1 + 20));
    if (v3)
    {
      v4 = (uint64_t)v3;
      v5 = *(_DWORD *)(a1 + 20);
      if (v5 >= 1)
      {
        v6 = *(float ***)(a1 + 40);
        v7 = *(unsigned int *)(a1 + 20);
        v8 = v3;
        do
        {
          v9 = *v6++;
          *v8++ = *v9;
          --v7;
        }
        while (v7);
      }
      VarianceNormalize(v3, v5, 0, *(float *)(a1 + 120));
      v10 = *(unsigned int *)(a1 + 20);
      if ((int)v10 >= 1)
      {
        v11 = *(float ***)(a1 + 40);
        v12 = (float *)v4;
        do
        {
          v13 = *v12++;
          v14 = v13;
          v15 = *v11++;
          *v15 = *v15 + (float)(v2 * (float)(v14 - *v15));
          --v10;
        }
        while (v10);
      }
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v4);
    }
  }
}

void VarianceNormalize(float *a1, int a2, int a3, float a4)
{
  float *v7;
  float v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v7 = a1;
  v12 = 0;
  v11 = 0;
  Stream_ComputeStats(a1, a2, (uint64_t)&v11);
  if (a3 == 1)
    a4 = exp(a4);
  if (a2 >= 1)
  {
    v8 = *(float *)&v11;
    v9 = sqrtf(a4 / *((float *)&v11 + 1));
    v10 = a2;
    do
    {
      *v7 = v8 + (float)((float)(*v7 - v8) * v9);
      ++v7;
      --v10;
    }
    while (v10);
  }
}

uint64_t ForcedEEController_TimeGet(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4 && (v5 = heap_Calloc(*(_QWORD **)(v4 + 8), 1, 12)) != 0)
    {
      v6 = (_DWORD *)v5;
      if (((**(uint64_t (***)(_QWORD, uint64_t))(v4 + 384))(*(_QWORD *)(v4 + 392), v5) & 0x80000000) != 0)
      {
        v2 = 0;
      }
      else
      {
        *a2 = *v6;
        v2 = 1;
      }
      heap_Free(*(_QWORD **)(v4 + 8), (uint64_t)v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t ForcedEEController_Clear(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 32) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 40) = 0;
  }
  return result;
}

uint64_t ForcedEEController_SetProcessStart(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  char *v5;
  int v6;
  unsigned int *v7;
  char *__s1;

  result = 1;
  if (!a1 || !a2)
    return result;
  __s1 = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  if ((paramc_ParamGetStr(a1[5], (uint64_t)"bet4earlyemissionmode", &__s1) & 0x80000000) == 0)
  {
    v5 = __s1;
    if (!strcmp(__s1, "forced"))
    {
      v6 = 1;
    }
    else
    {
      if (strcmp(v5, "forced-deterministic"))
      {
LABEL_9:
        paramc_ParamRelease(a1[5]);
        goto LABEL_10;
      }
      v6 = 2;
    }
    *(_DWORD *)a2 = v6;
    goto LABEL_9;
  }
LABEL_10:
  if (!*(_DWORD *)a2)
    return 1;
  if (!a1[48] || !a1[49])
    return 0;
  if ((paramc_ParamGetUInt(a1[5], (uint64_t)"bet4earlyemissionforcedoutputlead", (unsigned int *)(a2 + 28)) & 0x80000000) != 0)
    *(_DWORD *)(a2 + 28) = 0;
  *(_QWORD *)(a2 + 16) = a1;
  result = ForcedEEController_TimeGet(a2, (_DWORD *)(a2 + 4));
  if ((_DWORD)result)
  {
    *(_QWORD *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 40) = 0;
    if (*(_DWORD *)a2 == 2)
    {
      *(_DWORD *)(a2 + 24) = 100;
      v7 = (unsigned int *)(a2 + 24);
      if ((paramc_ParamGetUInt(a1[5], (uint64_t)"bet4earlyemissionforceddeterministicrtf", v7) & 0x80000000) != 0)
        *v7 = 100;
    }
    return 1;
  }
  *(_DWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  return result;
}

uint64_t ForcedEEController_SetStartedPlayback(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 1;
  if (!*(_DWORD *)a1)
    return 1;
  result = ForcedEEController_TimeGet(a1, (_DWORD *)(a1 + 8));
  if ((_DWORD)result)
    return 1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

BOOL ForcedEEController_HasStartedPlayback(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 8) != 0;
  return result;
}

BOOL ForcedEEController_CheckRiskForBufferUnderrun(_BOOL8 result)
{
  _DWORD *v1;
  _DWORD *v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  if (result)
  {
    v1 = (_DWORD *)result;
    if (!*(_DWORD *)result || !*(_DWORD *)(result + 8))
      return 0;
    v2 = (_DWORD *)(result + 40);
    if ((paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(result + 16) + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", (unsigned int *)(result + 40)) & 0x80000000) != 0)*v2 = 0;
    if (*v1 == 1)
    {
      v8 = 0;
      if (ForcedEEController_TimeGet((uint64_t)v1, &v8))
      {
        v3 = v1[2];
        v4 = v8 >= v3;
        v5 = v8 - v3;
        if (v5 != 0 && v4)
        {
          v1[8] = v8 - v1[1];
          v1[9] = v5;
        }
      }
    }
    else
    {
      v6 = v1[10];
      v7 = v1[7];
      if (v6 >= v7 - 1)
      {
        if (-1431655765 * v6 <= 0x55555555)
          v6 = v6 - v7 + 1;
        else
          v6 += ~v7;
      }
      v1[9] = v6;
    }
    return *v2 && (v1[7] + v1[9]) >= *v2;
  }
  return result;
}

uint64_t mfs_symData_Init(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t result;
  uint64_t v27;
  float v28;
  float v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v46;
  float v47;
  uint64_t v48;
  float *v49;
  float **v50;
  uint64_t v51;
  uint64_t v52;
  float **v53;
  float *v54;
  int v55;
  uint64_t v56;
  uint64_t i;
  int *v58;
  int *v59;
  uint64_t j;
  uint64_t v61;
  float *v62;
  float v63;
  int *v64;
  uint64_t v65;
  int v66;
  int v67;

  v6 = a1 + 16432;
  v7 = *(_QWORD *)(a1 + 17144);
  *((_QWORD *)a2 + 306) = v7;
  *((_QWORD *)a2 + 307) = *(_QWORD *)(a1 + 16424);
  v8 = *(unsigned int *)(a1 + 16432);
  a2[610] = v8;
  v9 = *(unsigned __int8 **)(a1 + 16664);
  *((_QWORD *)a2 + 302) = v9;
  if (v9)
  {
    v10 = a2[606];
    if ((_DWORD)v8)
    {
      do
      {
        v11 = *v9++;
        v10 += v11;
        --v8;
      }
      while (v8);
    }
    a2[606] = v10;
  }
  if ((*(_DWORD *)(a1 + 8360) - 1) < 2)
  {
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Decompression compressed symdata.dat\n");
    v12 = *(_QWORD *)(a1 + 16904);
    v13 = bswap32(*(_DWORD *)(v12 + 8));
    v14 = *(_DWORD *)(v6 + 480);
    v15 = heap_Calloc(*(_QWORD **)(a3 + 8), (104 * v13 + 50) / 0x64 + 384, 1);
    if (!v15)
    {
      MFS__log_select_Error(a3, 1, (uint64_t)"%s, Error, out of memory!\n", v16, v17, v18, v19, v20);
      return 0;
    }
    v21 = v15;
    v22 = (unsigned __int8 *)(v12 + 12);
    v23 = *(_DWORD *)(a1 + 8360);
    if (v23 == 2)
    {
      LZ_Uncompress(v22, v21, v14 - 12);
      v24 = "After lz_77 decoding on symdata.dat, size: %d\n";
      v25 = "Before lz_77 decoding on symdata.dat, size: %d\n";
    }
    else
    {
      if (v23 != 1)
      {
LABEL_14:
        *(_QWORD *)(a1 + 16904) = v21;
        *(_DWORD *)(v6 + 480) = v13;
        *((_QWORD *)a2 + 1556) = v21;
        v7 = *((_QWORD *)a2 + 306);
        goto LABEL_15;
      }
      Huffman_Uncompress((uint64_t)v22);
      v24 = "After huffman decoding on symdata.dat, size: %d\n";
      v25 = "Before huffman decoding on symdata.dat, size: %d\n";
    }
    MFS__log_select_Diag(a3, 1, (uint64_t)v25);
    MFS__log_select_Diag(a3, 1, (uint64_t)v24);
    goto LABEL_14;
  }
  v21 = *(_QWORD *)(a1 + 16904);
LABEL_15:
  *((_QWORD *)a2 + 304) = v21;
  if (v7 && *((_QWORD *)a2 + 307) && v21)
  {
    v27 = 0;
    *((_QWORD *)a2 + 301) = a3;
    a2[619] = 0;
    do
    {
      v28 = *(float *)(a1 + 8040 + v27 * 4);
      *(float *)&a2[v27 + 616] = v28;
      v29 = v28 + *((float *)a2 + 619);
      *((float *)a2 + 619) = v29;
      ++v27;
    }
    while (v27 != 3);
    *((float *)a2 + 619) = BET3FLT__bet3_finv(v29);
  }
  else
  {
    *((_QWORD *)a2 + 301) = 0;
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Warning, has loaded no SYM data\n");
  }
  v30 = *(_DWORD *)(a1 + 8956);
  if (v30 < 1)
  {
    *((_QWORD *)a2 + 1516) = 0;
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Warning, has loaded no STYLE data\n");
LABEL_37:
    LODWORD(v48) = *a2;
    if (*a2 < 1)
    {
      v55 = v48 + 2;
    }
    else
    {
      v49 = (float *)(a2 + 622);
      v50 = (float **)(a2 + 660);
      v51 = 2;
      do
      {
        v52 = 0;
        v53 = v50;
        v54 = v49;
        do
        {
          mfs_symData_PreInstallStreamWeights((uint64_t)a2, v52++, *a2, v51, v54, v53);
          v54 += 9;
          v53 += 9;
        }
        while (v52 != 3);
        ++v51;
        v48 = *a2;
        v55 = v48 + 2;
        ++v49;
        ++v50;
      }
      while (v51 < v48 + 2);
    }
    if (*(_DWORD *)(a1 + 8328))
    {
      v56 = a2[610];
      if ((int)v56 >= 1)
      {
        for (i = 0; i != v56; ++i)
        {
          if (v55 >= 3)
          {
            v58 = a2 + 622;
            v59 = a2 + 660;
            for (j = 2; j != v55; ++j)
            {
              v61 = 0;
              v62 = (float *)&a2[256 * j + 728 + i];
              *v62 = 0.0;
              v63 = 0.0;
              v64 = v59;
              do
              {
                v65 = *(_QWORD *)v64;
                v64 += 18;
                v63 = v63 + (float)(*(float *)(v65 + 4 * i) * *(float *)&v58[v61]);
                *v62 = v63;
                v61 += 9;
              }
              while (v61 != 27);
              v59 += 2;
              ++v58;
            }
          }
        }
      }
    }
    if (*(_DWORD *)(*((_QWORD *)a2 + 134) + 8372))
      return 1;
    v66 = a2[610];
    a2[3108] = 0;
    result = 1;
    if (v66 > 47)
    {
      if (v66 == 48)
      {
        if ((_DWORD)v48 != 3)
          return result;
        v67 = 16;
      }
      else if (v66 == 51)
      {
        if ((_DWORD)v48 != 3)
          return result;
        v67 = 17;
      }
      else
      {
        if (v66 != 54 || (_DWORD)v48 != 3)
          return result;
        v67 = 18;
      }
LABEL_74:
      a2[3108] = v67;
      return result;
    }
    switch(v66)
    {
      case '$':
        if ((_DWORD)v48 == 3)
        {
          v67 = 12;
          goto LABEL_74;
        }
        break;
      case '\'':
        if ((_DWORD)v48 == 3)
        {
          v67 = 13;
          goto LABEL_74;
        }
        break;
      case '*':
        if ((_DWORD)v48 == 3)
        {
          v67 = 14;
          goto LABEL_74;
        }
        break;
      case '-':
        if ((_DWORD)v48 == 3)
        {
          v67 = 15;
          goto LABEL_74;
        }
        break;
      default:
        return result;
    }
  }
  else
  {
    v31 = 0;
    *((_QWORD *)a2 + 1518) = *(_QWORD *)(a1 + 17384);
    *((_BYTE *)a2 + 12136) = v30;
    *((_QWORD *)a2 + 1516) = a3;
    a2[3047] = 0;
    v32 = ((v30 - 1) * v30) >> 1;
    LODWORD(v33) = *a2;
    v34 = 4 * v32;
    while (1)
    {
      result = heap_Calloc(*(_QWORD **)(*((_QWORD *)a2 + 1516) + 8), (int)v33, 8);
      v35 = (uint64_t)&a2[2 * v31 + 3032];
      *(_QWORD *)(v35 + 24) = result;
      v36 = (uint64_t *)(v35 + 24);
      if (!result)
        break;
      *v36 = result - 16;
      LODWORD(v33) = *a2;
      if (*a2 >= 1)
      {
        v37 = *(_QWORD *)(a1 + 24 * v31 + 17624);
        v38 = *(_QWORD *)(a1 + 24 * v31 + 17864);
        v39 = 2;
        while (1)
        {
          *(_QWORD *)(*v36 + 8 * v39) = heap_Calloc(*(_QWORD **)(*((_QWORD *)a2 + 1516) + 8), *(unsigned int *)(v37 + 4 * (v39 - 2)), 8);
          v40 = *v36;
          v41 = *(_QWORD *)(*v36 + 8 * v39);
          if (!v41)
            break;
          *(_QWORD *)(v40 + 8 * v39) = v41 - 8;
          v42 = *(unsigned int *)(v37 + 4 * (v39 - 2));
          if ((int)v42 >= 1)
          {
            v43 = 8 * v42 + 8;
            v44 = 8;
            do
            {
              *(_QWORD *)(*(_QWORD *)(*v36 + 8 * v39) + v44) = v38;
              v44 += 8;
              v38 += v34;
            }
            while (v43 != v44);
          }
          v33 = *a2;
          if (v39++ > v33)
            goto LABEL_32;
        }
        heap_Free(*(_QWORD **)(*((_QWORD *)a2 + 1516) + 8), v40);
        result = 0;
        break;
      }
LABEL_32:
      v46 = *(float *)(a1 + 4 * v31 + 8080);
      *(float *)&a2[v31 + 3044] = v46;
      v47 = v46 + *((float *)a2 + 3047);
      *((float *)a2 + 3047) = v47;
      if (++v31 == 3)
      {
        *((float *)a2 + 3047) = BET3FLT__bet3_finv(v47);
        goto LABEL_37;
      }
    }
    *((_QWORD *)a2 + 1516) = 0;
  }
  return result;
}

float mfs_symData_PreInstallStreamWeights(uint64_t a1, unsigned int a2, int a3, int a4, float *a5, float **a6)
{
  uint64_t v7;
  float *v8;
  float v9;
  float v10;
  float result;

  v7 = *(unsigned int *)(a1 + 2440);
  v8 = (float *)(*(_QWORD *)(a1 + 2448) + 4 * v7 * (a4 + a3 * a2 - 2));
  *a6 = v8;
  *a5 = 0.0;
  v9 = 0.0;
  if ((_DWORD)v7)
  {
    do
    {
      v10 = *v8++;
      v9 = v10 + v9;
      *a5 = v9;
      --v7;
    }
    while (v7);
  }
  result = (float)(BET3FLT__bet3_finv(v9) * *(float *)(a1 + 4 * a2 + 2464)) * *(float *)(a1 + 2476);
  *a5 = result;
  return result;
}

_QWORD *mfs_symData_DeInit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t i;
  int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v1 = result;
  result[304] = 0;
  result[307] = 0;
  result[306] = 0;
  if (result[1516])
  {
    for (i = 0; i != 3; ++i)
    {
      v3 = *(_DWORD *)v1;
      if (*(int *)v1 < 1)
      {
        v7 = 2;
      }
      else
      {
        v4 = &v1[i + 1519];
        v5 = 2;
        do
        {
          *(_QWORD *)(*v4 + 8 * v5) += 8;
          v6 = *(_QWORD *)(*v4 + 8 * v5);
          if (v6)
          {
            result = heap_Free(*(_QWORD **)(v1[1516] + 8), v6);
            v3 = *(_DWORD *)v1;
          }
          v7 = v5 + 1;
        }
        while (v5++ <= v3);
      }
      v9 = &v1[i];
      v10 = v9[1519] + 16;
      v9[1519] = v10;
      v11 = *(_QWORD *)(v10 + 8 * v7);
      if (v11)
        result = heap_Free(*(_QWORD **)(v1[1516] + 8), v11);
    }
  }
  v1[1516] = 0;
  v1[301] = 0;
  return result;
}

uint64_t mfs_symData_GetTargetVector(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(unsigned int *)(result + 2440);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = a4 + 2;
    v7 = a4 + 1;
    while (2)
    {
      v8 = *(unsigned __int8 *)(*(_QWORD *)(result + 2456) + v5);
      switch(*(_BYTE *)(*(_QWORD *)(result + 2456) + v5))
      {
        case 0xFC:
          if (a4 < 2)
            goto LABEL_17;
          LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + (a4 - 2));
          goto LABEL_25;
        case 0xFD:
          if (a4 < 1)
            goto LABEL_17;
          LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + (a4 - 1));
          goto LABEL_25;
        case 0xFE:
          if ((int)v7 >= *(__int16 *)(a3 + 10))
            goto LABEL_17;
          LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + v7);
          goto LABEL_25;
        case 0xFF:
          if ((int)v6 >= *(__int16 *)(a3 + 10))
LABEL_17:
            LOBYTE(v9) = 0;
          else
            LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + v6);
          goto LABEL_25;
        default:
          if ((_DWORD)v8 == 22)
          {
            v9 = *(unsigned __int8 *)(*(_QWORD *)(a3 + 32) + a4);
            if (v9 != 1)
            {
              v9 = *(char *)(*(_QWORD *)(a3 + 192) + a4);
              if (v9 < 0)
                LOBYTE(v9) = -1;
              else
                LOBYTE(v9) = 2 * v9;
            }
          }
          else if ((_DWORD)v8 == 29)
          {
            v10 = *(_QWORD *)(a3 + 248);
            if (v10)
            {
              v9 = *(unsigned __int8 *)(v10 + a4);
              if (!v9)
                LOBYTE(v9) = -1;
            }
            else
            {
              LOBYTE(v9) = -1;
            }
          }
          else
          {
            v11 = *(_QWORD *)(a3 + 8 * v8 + 16);
            if (!v11)
              goto LABEL_26;
            LOBYTE(v9) = *(_BYTE *)(v11 + a4);
          }
LABEL_25:
          *(_BYTE *)(a2 + 4 + v5) = v9;
          v4 = *(unsigned int *)(result + 2440);
LABEL_26:
          if (++v5 >= v4)
            return result;
          continue;
      }
    }
  }
  return result;
}

uint64_t mfs_symData_GetCandVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, uint64_t *a7)
{
  int v7;
  unsigned int v8;

  v7 = *(_DWORD *)(a2 + 12432);
  if (v7)
    v8 = a5 - a6 + 2;
  else
    v8 = (a5 - a6 + 2) / a4;
  if (*(_DWORD *)(*(_QWORD *)(a2 + 1072) + 8372) == 1)
  {
    mfs_symData_recoverCompactFeatVect(a1, a2, a3, v8, a7);
  }
  else
  {
    if (!v7)
      v7 = *(_DWORD *)(a2 + 2440);
    *a7 = *(_QWORD *)(a2 + 2432) + v7 * v8;
  }
  return 0;
}

uint64_t mfs_symData_recoverCompactFeatVect(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;

  v5 = *(unsigned int *)(a2 + 2440);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = *a5;
    v8 = *(_DWORD *)(a2 + 2424) * a4;
    v9 = *(_QWORD *)(a2 + 2432) + (v8 >> 3);
    v10 = v8 & 7;
    do
    {
      v11 = v8 & 7;
      v12 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 2416) + v6);
      v13 = (unint64_t)v10 >> 3;
      if ((v11 + v12) < 9)
        v14 = 0;
      else
        v14 = *(unsigned __int8 *)(v9 + v13 + 1);
      *(_BYTE *)(v7 + v6) = (unsigned __int16)((v14 | (*(unsigned __int8 *)(v9 + v13) << 8)) << v11) >> (16 - v12);
      v8 = v10 + v12;
      ++v6;
      v10 = v8;
    }
    while (v5 != v6);
  }
  return 0;
}

uint64_t mfs_symData_DistanceOnUid_PreCalc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v14;
  uint64_t result;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  _OWORD v21[11];
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v14 = *(_QWORD *)(a2 + 2400);
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  v20 = v21;
  result = mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, a6, a7, (uint64_t *)&v20);
  v16 = *(_DWORD *)(a2 + 2440);
  if (v16)
  {
    v17 = 0;
    v18 = (uint64_t)v20;
    v19 = a4 + 4;
    do
    {
      *(_DWORD *)(a9 + 4 * v17) = 0;
      if (*(_DWORD *)(a10 + 4 * v17))
      {
        result = *(unsigned __int8 *)(v19 + v17);
        if ((_DWORD)result != *(unsigned __int8 *)(v18 + v17))
          *(_DWORD *)(a9 + 4 * v17) = 1065353216;
      }
      else if (v14
             && ((result = *(_QWORD *)(v14 + 8 * (v17 + (a7 - 1 - a8 + 8 * a8) * v16))) != 0
              || (result = *(_QWORD *)(v14 + 8 * (v17 + v16 * (a7 - 1)))) != 0
              || (result = *(_QWORD *)(v14 + 8 * v17)) != 0))
      {
        *(_DWORD *)(a9 + 4 * v17) = *(_DWORD *)(result
                                              + 4
                                              * (*(unsigned __int8 *)(v18 + v17)
                                               + ((unint64_t)*(unsigned __int8 *)(v19 + v17) << 7)));
      }
      else
      {
        result = *(unsigned __int8 *)(v19 + v17);
        if ((_DWORD)result != *(unsigned __int8 *)(v18 + v17))
        {
          *(_DWORD *)(a9 + 4 * v17) = 1065353216;
          *(_DWORD *)(a10 + 4 * v17) = 1;
          v16 = *(_DWORD *)(a2 + 2440);
        }
      }
      ++v17;
    }
    while (v17 < v16);
  }
  return result;
}

float mfs_symData_DistanceOnUid_Tahoe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float *a9)
{
  uint64_t v9;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;

  v9 = *(unsigned int *)(a2 + 2440);
  if ((_DWORD)v9)
  {
    v11 = *(float **)(a4 + 184);
    v12 = 0.0;
    do
    {
      v13 = *a9++;
      v14 = v13;
      v15 = *v11++;
      v12 = v12 + (float)(v14 * v15);
      --v9;
    }
    while (v9);
  }
  else
  {
    v12 = 0.0;
  }
  return v12 * *(float *)a4;
}

float mfs_symData_DistanceOnUid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  _OWORD *v19;
  _OWORD v20[11];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  v19 = v20;
  v12 = *(_QWORD *)(a2 + 2400);
  mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, a6, a7, (uint64_t *)&v19);
  if (!*(_QWORD *)(a2 + 2408))
    return 0.0;
  v13 = *(unsigned int *)(a2 + 2440);
  if ((_DWORD)v13)
  {
    v14 = 0;
    v15 = a4 + 4;
    v16 = 0.0;
    do
    {
      if (v12
        && ((v17 = *(_QWORD *)(v12 + 8 * (v13 * (a7 - 1 - a8 + 8 * a8) + v14))) != 0
         || (v17 = *(_QWORD *)(v12 + 8 * (v13 * (a7 - 1) + v14))) != 0
         || (v17 = *(_QWORD *)(v12 + 8 * v14)) != 0))
      {
        v16 = v16
            + (float)(*(float *)(v17
                               + 4
                               * (*((unsigned __int8 *)v19 + v14)
                                + ((unint64_t)*(unsigned __int8 *)(v15 + v14) << 7)))
                    * *(float *)(*(_QWORD *)(a4 + 184) + 4 * v14));
      }
      else if (*(unsigned __int8 *)(v15 + v14) != *((unsigned __int8 *)v19 + v14))
      {
        v16 = v16 + *(float *)(*(_QWORD *)(a4 + 184) + 4 * v14);
      }
      ++v14;
    }
    while (v13 != v14);
  }
  else
  {
    v16 = 0.0;
  }
  return v16 * *(float *)a4;
}

float mfs_symData_Distance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;

  if (!*(_QWORD *)(a1 + 2408))
    return 0.0;
  v3 = *(unsigned int *)(a1 + 2440);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = 0.0;
    do
    {
      if (*(unsigned __int8 *)(a2 + 4 + v4) != *(unsigned __int8 *)(a3 + v4))
        v5 = v5 + *(float *)(*(_QWORD *)(a2 + 184) + 4 * v4);
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    v5 = 0.0;
  }
  return v5 * *(float *)a2;
}

float mfs_symData_GenreDivergence(uint64_t a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6;
  float v7;
  unsigned int v8;

  if (!*(_QWORD *)(a1 + 12128))
    return 0.0;
  v6 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12144) + a6);
  v7 = 0.0;
  if (v6 != a5)
  {
    if (a5 <= v6)
      v8 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12144) + a6);
    else
      v8 = a5;
    if (a5 < v6)
      v6 = a5;
    v7 = *(float *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8 * a2 + 12152) + 8 * a3) + 8 * a4)
                  + 4 * (int)(v6 + ((int)((v8 - 1) * v8) >> 1)));
  }
  return (float)(v7 * *(float *)(a1 + 4 * a2 + 12176)) * *(float *)(a1 + 12188);
}

void mfs_InitParam(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  unint64_t v9;
  float *v10;
  uint64x2_t v11;
  int32x2_t v12;

  v2 = a1 + 24116;
  v3 = (_OWORD *)(a1 + 8292);
  bzero((void *)a1, 0x62D0uLL);
  *(_QWORD *)(v2 + 1064) = 20;
  *(_DWORD *)(v2 + 1080) = 40;
  *(_QWORD *)(v2 + 1072) = 0x2800000000;
  *(_QWORD *)(a1 + 25216) = 100000;
  *(_QWORD *)(a1 + 25208) = 0;
  *(_DWORD *)(v2 + 1024) = 0;
  *(_DWORD *)(a1 + 7624) = 0;
  *(_DWORD *)(a1 + 8388) = 0;
  *(_QWORD *)(a1 + 8224) = -4294965296;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 8232) = _D0;
  *(int32x2_t *)(a1 + 8240) = vdup_n_s32(0x7D0u);
  *(_QWORD *)(a1 + 8876) = 0x3C00000001;
  *(_QWORD *)(a1 + 8884) = 0x142480000;
  *(_QWORD *)(a1 + 8892) = 0;
  *(_OWORD *)(a1 + 8160) = xmmword_1DECE74F0;
  *(_DWORD *)(a1 + 8900) = 50;
  *(_DWORD *)(a1 + 8912) = -1;
  *(_QWORD *)(a1 + 8904) = 0xBF80000040600000;
  *(_DWORD *)(a1 + 8928) = 3;
  *(_QWORD *)(a1 + 8932) = 1056964608;
  *(_DWORD *)(a1 + 8248) = 1084227584;
  *(_OWORD *)(a1 + 8256) = xmmword_1DECE3F50;
  *(_QWORD *)(a1 + 8284) = 0x3F8000003F000000;
  *(_QWORD *)(a1 + 8272) = 0x100000001;
  *v3 = xmmword_1DECECB60;
  *(_QWORD *)(a1 + 8308) = 0x3F80000040000000;
  *(_OWORD *)((char *)v3 + 24) = xmmword_1DECECB70;
  *(_DWORD *)(a1 + 8332) = 0;
  *(_OWORD *)((char *)v3 + 52) = xmmword_1DECECB80;
  *(_QWORD *)(a1 + 8376) = 1148846080;
  *(_OWORD *)(a1 + 25144) = xmmword_1DECE7530;
  *(_DWORD *)(a1 + 8384) = 1092616192;
  *(int32x2_t *)(a1 + 25160) = vdup_n_s32(0xFA0u);
  *(_DWORD *)(v2 + 1052) = 2000;
  *(_DWORD *)(a1 + 8952) = 0;
  *(_OWORD *)(a1 + 8560) = xmmword_1DECECB90;
  *(_DWORD *)(a1 + 8576) = 12;
  MFS__InitVParam((_DWORD *)a1);
  v9 = 0;
  *(_DWORD *)(a1 + 7672) = 7562861;
  *(_DWORD *)(a1 + 8180) = 1056964608;
  *(_DWORD *)v2 = 1065353216;
  v10 = (float *)(a1 + 24124);
  v11.i64[0] = 255;
  v11.i64[1] = 255;
  do
  {
    v12 = vmovn_s64((int64x2_t)vcgtq_u64(v11, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v9), (int8x16_t)xmmword_1DEC3D320)));
    if ((v12.i8[0] & 1) != 0)
      *(v10 - 1) = 1.0 / (float)(v9 + 1);
    if ((v12.i8[4] & 1) != 0)
      *v10 = 1.0 / (float)(v9 + 2);
    v9 += 2;
    v10 += 2;
  }
  while (v9 != 256);
}

void mfs_DeInitParam(uint64_t a1, _DWORD *a2)
{
  int v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*((_QWORD *)a2 + 1453))
  {
    if (*((_QWORD *)a2 + 1483))
    {
      v4 = a2[33];
      if (v4 >= 1)
      {
        v5 = 0;
        v6 = (char *)(a2 + 2846);
        do
        {
          if (a2[v5 + 56] && *(_QWORD *)v6)
          {
            heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)v6);
            *(_QWORD *)v6 = 0;
            *((_DWORD *)v6 + 2) = 0;
            v4 = a2[33];
          }
          ++v5;
          v6 += 24;
        }
        while (v5 < v4);
      }
    }
  }
  MFS__DeInitVParam(a1, a2);
  v7 = *((_QWORD *)a2 + 999);
  if (v7)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v7);
    *((_QWORD *)a2 + 999) = 0;
  }
  v8 = *((_QWORD *)a2 + 3012);
  if (v8)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v8);
    *((_QWORD *)a2 + 3012) = 0;
  }
  v9 = *((_QWORD *)a2 + 3013);
  if (v9)
    heap_Free(*(_QWORD **)(a1 + 8), v9);
  bzero(a2, 0x62D0uLL);
}

uint64_t mfs_kld_lookup(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7, uint64_t a8)
{
  float v9;
  uint64_t result;
  int v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  float v33;
  float v34;
  unsigned int v35;
  float v36;
  float *v37;
  __int16 v38;
  __int16 v39;

  v9 = 0.0;
  if (a3 != (_DWORD)a4)
  {
    v12 = *(_DWORD *)(a1 + 12256);
    if (v12 == 2)
    {
      v39 = 0;
      v13 = *(unsigned __int8 **)(a1 + 12264);
      v14 = *(_DWORD *)&v13[8 * (int)a5 - 4];
      v15 = (v14 + a4);
      v16 = *(unsigned __int16 *)&v13[4 * v15 + 32];
      if ((_DWORD)v16 == 0xFFFF)
      {
        MFS__log_select_Error(a2, 0, (uint64_t)"Error in KLD partitioning - Target MCP index belongs to a removed partition", a4, a5, (uint64_t)a6, a7, a8);
        return 2229280783;
      }
      v24 = v14 + a3;
      v25 = *(unsigned __int16 *)&v13[4 * v24 + 32];
      if (v25 == 0xFFFF)
      {
        MFS__log_select_Diag(a2, 0, (uint64_t)"Warning: Suspicious KLD partitioning - Candidate MCP index belongs to a removed partition");
        v9 = 1.0e10;
      }
      else
      {
        if (v25 == (_DWORD)v16)
        {
          v28 = *v13;
          v27 = v13 + 32;
          v26 = v28;
          v29 = *(unsigned __int16 *)&v27[4 * v15 + 2];
          v30 = *(unsigned __int16 *)&v27[4 * v24 + 2];
          if (v29 >= v30)
            v31 = v30;
          else
            v31 = v29;
          if (v29 > v30)
            v30 = v29;
          v32 = *(_QWORD *)(a1 + 12272) + 16 * v16;
          mfs_calcKLDIdx(v26, *(_QWORD *)(a1 + 12280) + *(unsigned int *)(v32 + 12), v30 + ~*(_DWORD *)(v32 + 8) + *(_DWORD *)(v32 + 8) * v31 - ((v31 + v31 * v31) >> 1), &v39);
          v33 = *(float *)v32;
          v34 = *(float *)(v32 + 4);
          LOWORD(v35) = v39;
          v36 = (float)v35;
        }
        else
        {
          MFS__log_select_Diag(a2, 0, (uint64_t)"Warning: Suspicious KLD partitioning - Candidate and target MCP index do not belong to the same partition");
          v37 = (float *)(*(_QWORD *)(a1 + 12272) + 16 * v16);
          v33 = *v37;
          v34 = v37[1];
          v36 = (float)~(-1 << **(_DWORD **)(a1 + 12264));
        }
        v9 = v33 + (float)(v34 * v36);
      }
    }
    else
    {
      v17 = (int)a5;
      if (a3 >= a4)
        v19 = a4;
      else
        v19 = a3;
      if (a3 <= a4)
        v20 = a4;
      else
        v20 = a3;
      v18 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * (int)a5);
      v21 = v20 + ~v18 + v18 * v19 - ((v19 + v19 * v19) >> 1);
      if (v12 == 1)
      {
        v38 = 0;
        v22 = a1 + 12264;
        mfs_calcKLDIdx(*(unsigned __int8 *)(a1 + 12264), *(_QWORD *)(a1 + 12264 + 8 * (int)a5 + 8), v21, &v38);
        LOWORD(v23) = v38;
        v9 = *(float *)(v22 + 4 * v17 + 88) + (float)(*(float *)(v22 + 4 * v17 + 128) * (float)v23);
      }
      else
      {
        v9 = *(float *)(*(_QWORD *)(a1 + 8 * (int)a5 + 12264) + 4 * v21);
      }
    }
  }
  result = 0;
  if (a6)
    *a6 = v9;
  return result;
}

uint64_t mfs_calcKLDIdx(uint64_t result, uint64_t a2, unsigned int a3, _WORD *a4)
{
  unsigned int v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;

  if ((_DWORD)result)
  {
    if ((_DWORD)result == 16)
    {
      v4 = bswap32(*(unsigned __int16 *)(a2 + 2 * a3)) >> 16;
    }
    else if ((_DWORD)result == 8)
    {
      LOWORD(v4) = *(unsigned __int8 *)(a2 + a3);
    }
    else
    {
      v5 = 0;
      v4 = 0;
      v6 = (unint64_t)(result * a3) >> 3;
      v7 = *(unsigned __int8 *)(a2 + v6);
      v8 = ((_BYTE)result * (_BYTE)a3) & 7;
      do
      {
        if ((++v5 & 7) != 0)
        {
          v9 = v8 + 1;
          v10 = v7;
        }
        else
        {
          v9 = 0;
          LODWORD(v6) = v6 + 1;
          v10 = *(unsigned __int8 *)(a2 + v6);
        }
        v4 = (2 * v4) | ((_DWORD)v7 << v8 >> 7) & 1;
        v7 = v10;
        v8 = v9;
      }
      while ((_DWORD)result != v5);
    }
  }
  else
  {
    LOWORD(v4) = 0;
  }
  *a4 = v4;
  return result;
}

uint64_t mfs_GetLeafIndex(uint64_t a1, int a2, int a3)
{
  unsigned int *v3;

  if (a2)
    v3 = (unsigned int *)(*(_QWORD *)(a1 + 8 * a2 + 72) + 4 * a3);
  else
    v3 = (unsigned int *)(a1 + 8);
  return *v3;
}

BOOL mfs_IsPerceptualInvariantState(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;

  v6 = *a3;
  if (v6 + 1 < *(_DWORD *)(a2 + 608))
  {
    mfs_Ling_IsInvariantPhoneme(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(*(_QWORD *)(a2 + 600) + 528 * (v6 + 1)));
    v6 = *a3;
  }
  if (v6 >= 2)
  {
    mfs_Ling_IsInvariantPhoneme(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(*(_QWORD *)(a2 + 600) + 528 * (v6 - 1)));
    v6 = *a3;
  }
  return mfs_Ling_IsInvariantPhoneme(a1, *(_QWORD *)(a2 + 8), v6);
}

float mfs_ProbSynthNoDegradation(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  char *v4;
  int v5;
  int v6;
  char v7;
  char v8;

  if (a2 < 1)
  {
    v5 = 1;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 24);
    v3 = *(_DWORD *)(v2 + 3056);
    v4 = (char *)(*(_QWORD *)(a1 + 48) + *(int *)(v2 + 1528));
    v5 = 1;
    v6 = a2;
    do
    {
      v8 = *v4++;
      v7 = v8;
      if ((v8 & 4) != 0 && **(float **)(*(_QWORD *)(v2 + 3120) + 8 * v3) > 4.7)
        ++v5;
      v3 += (v7 & 4) >> 2;
      --v6;
    }
    while (v6);
  }
  return (float)(a2 - v5) / (float)a2;
}

float mfs_PhoneticContextCost(unsigned __int8 *a1, unsigned __int8 *a2, float a3)
{
  int v3;
  float v4;

  v3 = a2[1];
  v4 = 5000.5;
  if (v3 != 1)
    v4 = 0.5;
  if (a1[1] != v3)
    v4 = v4 + 100.0;
  if (*a1 != *a2)
    v4 = v4 + 20.0;
  if (a1[2] != a2[2])
    v4 = v4 + 20.0;
  return v4 * a3;
}

uint64_t mfs_CleanUpTgtVect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a3 + 24) = 0;
  return 0;
}

uint64_t mfs_loc_AddMainCandidates(uint64_t a1, uint64_t a2, _DWORD *a3, _QWORD *a4, int a5, _QWORD *a6, signed int a7, unsigned int a8, float a9, int a10, int a11, unsigned __int8 *a12, _QWORD *a13, uint64_t a14, int a15)
{
  uint64_t Ids;
  uint64_t v22;
  unsigned int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  int v28;

  UNICORN__mfs_S32Vect_Clear((_QWORD *)a14);
  if (a13)
  {
    Ids = mfs_Harch_GetIds(a13, (_QWORD *)a14);
    if ((Ids & 0x80000000) != 0)
      return Ids;
  }
  else
  {
    Ids = 0;
  }
  if (*(_DWORD *)(a14 + 16))
  {
    v22 = 0;
    while (1)
    {
      Ids = mfs_loc_AddCandidate(a2, a6, a7, *(_DWORD *)(*(_QWORD *)(a14 + 8) + 4 * v22), a12, a15, a9, 1.0);
      if ((Ids & 0x80000000) != 0)
        break;
      if (++v22 >= (unint64_t)*(unsigned int *)(a14 + 16))
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    UNICORN__mfs_S32Vect_Clear((_QWORD *)a14);
    v28 = *(_DWORD *)(a6[1] + 32 * a7 + 16);
    if (!a10
      || a3[2197]
      || (Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(a4[10] + 4 * a5), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15), (Ids & 0x80000000) == 0))
    {
      if (a3[2198]
        && ((v23 = *(_DWORD *)(a6[1] + 32 * a7 + 16) - v28, v23 <= 0xC7) ? (v24 = v23 >= a8) : (v24 = 1),
            !v24 && *(_DWORD *)(a4[45] + 4 * a5)))
      {
        v25 = 0;
        while (1)
        {
          Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(*(_QWORD *)(a4[44] + 8 * a5) + 4 * v25), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15);
          if ((Ids & 0x80000000) != 0)
            break;
          if (++v25 >= (unint64_t)*(unsigned int *)(a4[45] + 4 * a5))
            goto LABEL_21;
        }
      }
      else
      {
LABEL_21:
        if (!a11 && a5 >= 3)
        {
          if (a3[2196])
          {
            UNICORN__mfs_S32Vect_Clear((_QWORD *)a14);
            Ids = mfs_StateNGram_GetAlternatives(a2 + 2280, *(_DWORD *)(a4[10] + 4 * (a5 - 1)), -1, a5, (_QWORD *)a14);
            if ((Ids & 0x80000000) == 0)
            {
              if (*(_DWORD *)(a14 + 16))
              {
                v26 = 0;
                while (1)
                {
                  Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(*(_QWORD *)(a14 + 8) + 4 * v26), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15);
                  if ((Ids & 0x80000000) != 0)
                    break;
                  if (++v26 >= (unint64_t)*(unsigned int *)(a14 + 16))
                    goto LABEL_29;
                }
              }
              else
              {
LABEL_29:
                UNICORN__mfs_S32Vect_Clear((_QWORD *)a14);
              }
            }
          }
        }
      }
    }
  }
  return Ids;
}

uint64_t mfs_loc_AddCandidate(uint64_t a1, _QWORD *a2, signed int a3, unsigned int a4, unsigned __int8 *a5, int a6, float a7, float a8)
{
  uint64_t result;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  _QWORD v24[2];
  unsigned int v25;

  v25 = 0;
  v24[0] = 0;
  v24[1] = 0;
  v23 = (float *)v24;
  mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, a4, (uint64_t *)&v23);
  result = 0;
  v17 = a5[1];
  v18 = 5000.5;
  if (v17 != 1)
    v18 = 0.5;
  if (*((unsigned __int8 *)v23 + 13) != v17)
    v18 = v18 + 100.0;
  if (*((unsigned __int8 *)v23 + 12) != *a5)
    v18 = v18 + 20.0;
  if (*((unsigned __int8 *)v23 + 14) != a5[2])
    v18 = v18 + 20.0;
  v19 = v18 * 0.0071174;
  if ((float)(1.0 / (float)(v19 / 0.0071174)) > a7)
  {
    v20 = 1.0 - v19;
    result = mfs_CostList_Add(a1, a2, a3, a4, *(_QWORD *)(a1 + 2384), *(_DWORD *)(a1 + 2392), &v25, (float)((float)-(float)(*v23 * a8) * (float)(1.0 - v19)) + 1000.0);
    if ((result & 0x80001FFF) == 0x80000002)
    {
      v21 = *(float *)(*(_QWORD *)(a2[1] + 32 * a3) + 8 * v25 + 4);
      if (a6)
        v22 = v21 * 0.5;
      else
        v22 = v21 + (float)((float)-(float)(*v23 * a8) * v20);
      mfs_CostList_UpdateCost((uint64_t)a2, a3, v25, v22);
      return 0;
    }
  }
  return result;
}

uint64_t mfs_IbAddtoVect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, unsigned int a12, _QWORD *a13, signed int a14, unsigned __int8 *a15, int a16)
{
  unint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v29;
  uint64_t v30;
  int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t CandVector;
  float v37;
  unsigned int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  float *v48;
  _QWORD v49[2];
  _OWORD *v50;
  _OWORD v51[11];
  int v52;
  uint64_t v53;

  v20 = 0;
  v21 = 0;
  v53 = *MEMORY[0x1E0C80C00];
  v46 = a2 + 1552;
  v22 = (uint64_t *)(a2 + 1552 + 8 * a5);
  v24 = *v22;
  v23 = v22 + 10;
  v44 = *(_DWORD *)(*(_QWORD *)(v24 + 8 * a6) + 8 * a7);
  v43 = *(_DWORD *)(a2 + 1096) - 1;
  v52 = 0;
  v45 = a5;
  v25 = a6;
  v26 = a7;
  memset(v51, 0, sizeof(v51));
  v49[1] = 0;
  v50 = v51;
  v48 = (float *)v49;
  v49[0] = 0;
  do
  {
    v27 = *(_DWORD *)(a13[1] + 32 * a14 + 16);
    if (v20 >= *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v46 + 8 * v45) + 8 * v25) + 8 * v26 + 4) || v27 - a8 >= a12)
      break;
    v29 = *(_DWORD *)(*v23 + 4 * (v44 + v20));
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v29, (uint64_t *)&v48);
    if (v29 >= v43)
      goto LABEL_22;
    v30 = a3;
    if (*(_DWORD *)(a3 + 8888) && v27 >= 0xA && *v48 != -999.0 && *v48 <= *(float *)(a3 + 8884))
      goto LABEL_22;
    if (!a4 || (v32 = *(_DWORD *)(a3 + 8968)) == 0)
    {
      v21 = mfs_loc_AddCandidate(a2, a13, a14, v29, a15, a16, a9, a10);
      goto LABEL_22;
    }
    if (v32 == 2)
    {
      if (a15[1] != *((unsigned __int8 *)v48 + 13))
        goto LABEL_22;
      v33 = *(_DWORD *)a2;
      v34 = a1;
      v35 = a2;
      v30 = a3;
    }
    else
    {
      v33 = *(_DWORD *)a2;
      v34 = a1;
      v35 = a2;
    }
    CandVector = mfs_symData_GetCandVector(v34, v35, v30, v33, v29, a6, (uint64_t *)&v50);
    if ((CandVector & 0x80000000) != 0)
      return CandVector;
    v37 = mfs_symData_Distance(a2, a4, (uint64_t)v50);
    mfs_loc_AddCandidate_f2(a2, a13, a14, v29, v37, a11);
    v21 = 0;
LABEL_22:
    ++v20;
  }
  while ((v21 & 0x80000000) == 0);
  return v21;
}

uint64_t mfs_VennDiaGrams_Tahoe(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, int a7, int a8, float a9, unsigned int a10, _QWORD *a11, signed int a12, unsigned __int8 a13, int a14)
{
  unint64_t v17;
  uint64_t CandVector;
  uint64_t v19;
  uint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  unsigned int v25;
  _BOOL4 v26;
  BOOL v27;
  float v28;
  int v29;
  int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD *v41;
  float *v42;
  _QWORD v43[2];
  unsigned int v44;
  _OWORD v45[11];
  int v46;
  uint64_t v47;

  v17 = 0;
  CandVector = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v44 = 0;
  v36 = *(_DWORD *)(a2 + 1096) - 1;
  v19 = a2 + 1552;
  v20 = (uint64_t *)(a2 + 1552 + 8 * a4);
  v22 = *v20;
  v21 = v20 + 10;
  v39 = a4;
  v38 = a5;
  v37 = a7;
  v35 = *(_DWORD *)(*(_QWORD *)(v22 + 8 * a5) + 8 * a7);
  v43[0] = 0;
  v43[1] = 0;
  v41 = v45;
  v42 = (float *)v43;
  v46 = 0;
  memset(v45, 0, sizeof(v45));
  v23 = *(_DWORD *)(a11[1] + 32 * a12 + 16);
  do
  {
    if (v17 >= *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v19 + 8 * v39) + 8 * v38) + 8 * v37 + 4) || v23 - a8 >= a10)
      break;
    v25 = *(_DWORD *)(*v21 + 4 * (v35 + v17));
    if (*(_DWORD *)(a3 + 8356) == 1)
    {
      CandVector = mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, *(_DWORD *)(*v21 + 4 * (v35 + v17)), a5, (uint64_t *)&v41);
      v26 = *((unsigned __int8 *)v41 + a14) == a13;
    }
    else
    {
      v26 = 1;
    }
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v25, (uint64_t *)&v42);
    v27 = v25 >= v36 || !v26;
    if (v27 || *v42 != -999.0 && *(_DWORD *)(a3 + 8888) && *v42 <= *(float *)(a3 + 8884))
      goto LABEL_21;
    v44 = 0;
    v28 = a9;
    if (*((unsigned __int8 *)v42 + 13) == *(unsigned __int8 *)(a6 + 1))
      goto LABEL_18;
    if (a4 == 1)
    {
      v29 = *(_DWORD *)(a3 + 8260);
      if ((v29 & 0x80000000) == 0)
      {
        v28 = (float)v29 + a9;
LABEL_18:
        if ((mfs_CostList_Add(a2, a11, a12, v25, *(_QWORD *)(a2 + 2384), *(_DWORD *)(a2 + 2392), &v44, v28) & 0x80001FFF) == 0x80000002)
          mfs_CostList_UpdateCost((uint64_t)a11, a12, v44, *(float *)(*(_QWORD *)(a11[1] + 32 * a12) + 8 * v44 + 4) + -1.0);
      }
    }
    v23 = *(_DWORD *)(a11[1] + 32 * a12 + 16);
LABEL_21:
    ++v17;
  }
  while ((CandVector & 0x80000000) == 0);
  return CandVector;
}

uint64_t mfs_loc_AddCandidate_f2(uint64_t a1, _QWORD *a2, signed int a3, unsigned int a4, float a5, float a6)
{
  uint64_t result;
  unsigned int v11;

  v11 = 0;
  result = mfs_CostList_Add(a1, a2, a3, a4, *(_QWORD *)(a1 + 2384), *(_DWORD *)(a1 + 2392), &v11, a5);
  if ((result & 0x80001FFF) == 0x80000002)
    return mfs_CostList_UpdateCost((uint64_t)a2, a3, v11, (float)(*(float *)(*(_QWORD *)(a2[1] + 32 * a3) + 8 * v11 + 4) + a5) * a6);
  return result;
}

uint64_t mfs_IbAddtoVect_MCP(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, _QWORD *a9, signed int a10, uint64_t a11)
{
  uint64_t v11;
  int *v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  BOOL v24;
  BOOL v25;
  int v26;
  float v27;
  int v33;
  float *v34;
  _QWORD v35[2];
  int v36;

  v11 = 0;
  v36 = 0;
  v12 = (int *)(*(_QWORD *)(*((_QWORD *)a2 + 195) + 8 * a5) + 8 * a6);
  v13 = *v12;
  v14 = v12[1];
  v35[0] = 0;
  v35[1] = 0;
  v33 = v13;
  v34 = (float *)v35;
  v15 = *(_DWORD *)(a9[1] + 32 * a10 + 16);
  if ((_DWORD)v14)
    v16 = v15 - a7 >= a8;
  else
    v16 = 1;
  if (!v16)
  {
    v11 = 0;
    v20 = a2[274] - 1;
    v21 = *((_QWORD *)a2 + 205);
    v22 = 1;
    do
    {
      v23 = *(_DWORD *)(v21 + 4 * (v33 + v22 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v23, (uint64_t *)&v34);
      if (v23 < v20)
      {
        v24 = *(_DWORD *)(a3 + 8888) && v15 >= 0xA;
        if (!v24 || (*v34 != -999.0 ? (v25 = *v34 <= *(float *)(a3 + 8884)) : (v25 = 0), !v25))
        {
          v26 = *(unsigned __int8 *)(a11 + 1);
          if (v26 == *((unsigned __int8 *)v34 + 13))
          {
            v27 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v23, a5, v26);
            v11 = mfs_CostList_Pad((uint64_t)a2, a9, a10, v23, *((_QWORD *)a2 + 298), a2[598], &v36, v27);
          }
          v15 = *(_DWORD *)(a9[1] + 32 * a10 + 16);
        }
      }
      if ((v11 & 0x80000000) != 0)
        break;
      if (v22 >= v14)
        break;
      ++v22;
    }
    while (v15 - a7 < a8);
  }
  return v11;
}

uint64_t mfs_IbAddtoVect_LF0(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, uint64_t a9, signed int a10, uint64_t a11, _QWORD *a12, unsigned int a13)
{
  uint64_t v13;
  int *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  BOOL v26;
  BOOL v27;
  int IsNodeInList;
  float v29;
  uint64_t v31;
  int v35;
  int v37;
  unsigned int v38;
  float *v39;
  _QWORD v40[2];
  _DWORD v41[3];

  v13 = 0;
  v14 = (int *)(*(_QWORD *)(*((_QWORD *)a2 + 196) + 8 * a5) + 8 * a6);
  v15 = v14[1];
  v37 = *v14;
  v16 = *(_QWORD *)(a9 + 8) + 32 * a10;
  v31 = *(_QWORD *)v16;
  v41[0] = 0;
  v40[0] = 0;
  v40[1] = 0;
  v39 = (float *)v40;
  v17 = *(_DWORD *)(v16 + 16);
  if ((_DWORD)v15)
    v18 = v17 - a7 >= a8;
  else
    v18 = 1;
  if (!v18)
  {
    v13 = 0;
    v35 = 0;
    v22 = a2[274] - 1;
    v23 = *((_QWORD *)a2 + 206);
    v24 = 1;
    do
    {
      v25 = *(_DWORD *)(v23 + 4 * (v37 + v24 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v25, (uint64_t *)&v39);
      if (v25 < v22)
      {
        v26 = *(_DWORD *)(a3 + 8888) && v17 >= 0xA;
        if (!v26 || (*v39 != -999.0 ? (v27 = *v39 <= *(float *)(a3 + 8884)) : (v27 = 0), !v27))
        {
          if (*(unsigned __int8 *)(a11 + 1) == *((unsigned __int8 *)v39 + 13))
          {
            v38 = 0;
            IsNodeInList = mfs_CostList_IsNodeInList(a9, a10, v25, (uint64_t)a2, &v38);
            v29 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v25, a5, *(unsigned __int8 *)(a11 + 1));
            if (IsNodeInList)
            {
              *(float *)(v31 + 8 * v38 + 4) = (float)(v29 + *(float *)(v31 + 8 * v38 + 4)) * 0.025;
            }
            else
            {
              v13 = mfs_CostList_Pad((uint64_t)a2, a12, a13, v25, *((_QWORD *)a2 + 298), a2[598], v41, v29);
              ++v35;
            }
          }
          v17 = *(_DWORD *)(*(_QWORD *)(a9 + 8) + 32 * a10 + 16) + v35;
        }
      }
      if ((v13 & 0x80000000) != 0)
        break;
      if (v24 >= v15)
        break;
      ++v24;
    }
    while (v17 - a7 < a8);
  }
  mfs_CostList_UpdateCostEnd_inlined(a9, a10);
  return v13;
}

uint64_t mfs_IbAddtoVect_DUR(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, uint64_t a9, signed int a10, uint64_t a11, _QWORD *a12, signed int a13, unsigned int a14)
{
  uint64_t v14;
  int *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  unsigned int v29;
  _QWORD *v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int IsNodeInList;
  uint64_t v38;
  int v42;
  int v44;
  unsigned int v45;
  float *v46;
  _QWORD v47[2];
  _DWORD v48[3];

  v14 = 0;
  v15 = (int *)(*(_QWORD *)(*((_QWORD *)a2 + 194) + 8 * a5) + 8 * a6);
  v16 = v15[1];
  v44 = *v15;
  v17 = *(_QWORD *)(a9 + 8) + 32 * a10;
  v38 = *(_QWORD *)v17;
  v18 = a12[1] + 32 * a13;
  v36 = *(_QWORD *)v18;
  v46 = (float *)v47;
  v47[0] = 0;
  v19 = a2[274];
  v48[0] = 0;
  v47[1] = 0;
  v20 = *(_DWORD *)(v18 + 16) + *(_DWORD *)(v17 + 16);
  if ((_DWORD)v16)
    v21 = v20 - a7 >= a8;
  else
    v21 = 1;
  if (!v21)
  {
    v14 = 0;
    v42 = 0;
    v26 = v19 - 1;
    v27 = *((_QWORD *)a2 + 204);
    v28 = 1;
    while (1)
    {
      v29 = *(_DWORD *)(v27 + 4 * (v44 + v28 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v29, (uint64_t *)&v46);
      if (v29 >= v26)
        goto LABEL_25;
      if (*(_DWORD *)(a3 + 8888) && v20 >= 0xA && *v46 != -999.0 && *v46 <= *(float *)(a3 + 8884))
        goto LABEL_25;
      if (*(unsigned __int8 *)(a11 + 1) == *((unsigned __int8 *)v46 + 13))
      {
        v45 = 0;
        v32 = a12;
        if (mfs_CostList_IsNodeInList(a9, a10, v29, (uint64_t)a2, &v45))
        {
          v33 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v29, a5, *(unsigned __int8 *)(a11 + 1));
          v34 = v45;
          v35 = v38;
        }
        else
        {
          IsNodeInList = mfs_CostList_IsNodeInList((uint64_t)a12, a13, v29, (uint64_t)a2, &v45);
          v33 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v29, a5, *(unsigned __int8 *)(a11 + 1));
          if (!IsNodeInList)
          {
            v14 = mfs_CostList_Pad((uint64_t)a2, a12, a14, v29, *((_QWORD *)a2 + 298), a2[598], v48, v33);
            ++v42;
            goto LABEL_24;
          }
          v34 = v45;
          v35 = v36;
        }
        *(float *)(v35 + 8 * v34 + 4) = (float)(v33 + *(float *)(v35 + 8 * v34 + 4)) * 0.025;
      }
      else
      {
        v32 = a12;
      }
LABEL_24:
      v20 = *(_DWORD *)(*(_QWORD *)(a9 + 8) + 32 * a10 + 16) + v42 + *(_DWORD *)(v32[1] + 32 * a13 + 16);
LABEL_25:
      if ((v14 & 0x80000000) == 0 && v28 < v16)
      {
        ++v28;
        if (v20 - a7 < a8)
          continue;
      }
      break;
    }
  }
  mfs_CostList_UpdateCostEnd_inlined(a9, a10);
  return v14;
}

float mfs_JCostProb(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v12;
  unsigned int v13;
  float v14;
  unsigned int v15;
  float v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  BOOL v36;
  float v37;
  float v38;

  v8 = *(_QWORD *)(a1 + 2152);
  v9 = *(_QWORD *)(a1 + 2136);
  v10 = *(_DWORD *)(a2 + 2064);
  if (v10 == 1)
  {
    v18 = *(_QWORD *)(a2 + 2048);
    v19 = *(_QWORD *)(v18 + 8 * (int)a3);
    if (v19)
    {
      v20 = *(_QWORD *)(v18 + 8 * (int)a4);
      if (v20)
      {
        v14 = 0.0;
        if (!*(_BYTE *)(v19 + 1) && !*(_BYTE *)v20)
          v14 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 8)
              * *(float *)(v8
                         + ((4 * *(unsigned __int8 *)(v19 + 3)) | ((unint64_t)*(unsigned __int8 *)(v20 + 2) << 10)));
        v16 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 4);
        v17 = *(unsigned __int16 *)(v19 + 6) + ((unint64_t)*(unsigned __int16 *)(v20 + 4) << 9);
        return v14 + (float)(v16 * *(float *)(v9 + 4 * v17));
      }
      v28 = *(_QWORD *)(a2 + 1928);
    }
    else
    {
      v28 = *(_QWORD *)(a2 + 1928);
    }
    MFS__log_select_Diag(v28, 3, (uint64_t)"Unexpected NULL JoinElem for UID %d");
    return 0.0;
  }
  else
  {
    if (v10 == 2)
    {
      v12 = *(_QWORD *)(a1 + 12224);
      v13 = *(_DWORD *)(v12 + 12 * (int)a3);
      v14 = 0.0;
      if (v13 <= 0xFF)
      {
        v15 = *(unsigned __int16 *)(v12 + 12 * (int)a4 + 6);
        if (v15 <= 0xFF)
          v14 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 8)
              * *(float *)(v8 + 4 * (v13 + (v15 << 8)));
      }
      v16 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 4);
      v17 = *(unsigned __int16 *)(v12 + 12 * (int)a3 + 4)
          + ((unint64_t)*(unsigned __int16 *)(v12 + 12 * (int)a4 + 8) << 9);
      return v14 + (float)(v16 * *(float *)(v9 + 4 * v17));
    }
    v22 = *(_DWORD *)(a1 + 2164);
    v23 = *(_DWORD *)(a1 + 2148);
    v24 = *(_QWORD *)(a2 + 2032);
    v25 = *(_DWORD *)(a2 + 2060);
    v26 = *(_QWORD *)(v24 + 8 * (v25 & a3));
    if (v26)
    {
      while (*(_DWORD *)v26 != a3)
      {
        v26 = *(_QWORD *)(v26 + 16);
        if (!v26)
          goto LABEL_17;
      }
      v27 = *(_DWORD *)(v26 + 8);
    }
    else
    {
LABEL_17:
      MFS__log_select_Diag(*(_QWORD *)(a2 + 1928), 3, (uint64_t)"Unexpected NULL JoinElem returned for UID %d");
      v27 = 0;
      v24 = *(_QWORD *)(a2 + 2032);
      v25 = *(_DWORD *)(a2 + 2060);
    }
    v29 = *(_QWORD *)(v24 + 8 * (v25 & a4));
    if (v29)
    {
      while (*(_DWORD *)v29 != a4)
      {
        v29 = *(_QWORD *)(v29 + 16);
        if (!v29)
          goto LABEL_23;
      }
      v30 = *(_DWORD *)(v29 + 4);
    }
    else
    {
LABEL_23:
      MFS__log_select_Diag(*(_QWORD *)(a2 + 1928), 3, (uint64_t)"Unexpected NULL JoinElem returned for UID %d");
      v30 = 0;
    }
    v31 = *(_QWORD *)(a1 + 1072);
    if (!*(_DWORD *)(v31 + 8392) && ((v27 | v30) & 2) != 0)
    {
      v36 = *(_DWORD *)(v31 + 8892) == 0;
      v35 = 0.0;
    }
    else
    {
      v32 = *(float *)(v8 + 4 * (((v27 >> 14) & 0x1FF) + ((v30 >> 14) & 0x1FF) * v22));
      v33 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 8);
      v34 = v32 * v33;
      v35 = v32 + v33;
      v36 = *(_DWORD *)(v31 + 8892) == 0;
      if (v36)
        v35 = v34;
    }
    v37 = *(float *)(v9 + 4 * (((v27 >> 2) & 0xFFF) + ((v30 >> 2) & 0xFFF) * v23));
    v38 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 4);
    if (v36)
      return v35 + (float)(v38 * v37);
    else
      return v37 + (float)(v35 + v38);
  }
}

uint64_t mfs_BPESymData_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int *v11;
  int v12;

  if (*(_DWORD *)(a1 + 8344) != 4)
  {
    v10 = *(_DWORD *)(a2 + 2440);
LABEL_6:
    v9 = 0;
    *(_DWORD *)(a2 + 1928) = v10;
    *(_QWORD *)(a2 + 1904) = *(_QWORD *)(a1 + 23624);
    v11 = *(int **)(a1 + 23864);
    *(_QWORD *)(a2 + 1920) = *(_QWORD *)(a1 + 16904);
    v12 = *v11;
    *(_QWORD *)(a2 + 1912) = v11 + 1;
    *(_BYTE *)(a2 + 1932) = v12;
    *(_DWORD *)(a2 + 1936) = *(_DWORD *)(a1 + 23872);
    return v9;
  }
  v8 = *(_DWORD *)(a2 + 2424);
  if ((v8 & 7) == 0)
  {
    v10 = v8 >> 3;
    goto LABEL_6;
  }
  MFS__log_select_Error(*(_QWORD *)(a2 + 2408), 1, (uint64_t)"%s, only byte-aligned row are supported for BPE of bit-packed symdata", a4, a5, a6, a7, a8);
  return 2229281034;
}

uint64_t mfs_BPESymData_DeInit_Obersee(uint64_t result)
{
  *(_QWORD *)(result + 1904) = 0;
  return result;
}

uint64_t mfs_BPESymDataCache_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, int, unsigned int, uint64_t);

  v9 = *(_QWORD *)(a2 + 1072);
  if ((*(_DWORD *)(v9 + 8344) - 3) > 1)
  {
    MFS__log_select_Error(a3, 1, (uint64_t)"%s: compression mode %d not supported!", a4, a5, a6, a7, a8);
    return 2229280775;
  }
  else
  {
    v12 = heap_Alloc(*(_QWORD *)(a3 + 8), 24);
    if (v12)
    {
      if (*(_DWORD *)(v9 + 8344) == 3)
        v13 = mfs_symData_recoverFeatVectBPE_Obersee;
      else
        v13 = mfs_symData_recoverFeatVectBPEBitPack_Obersee;
      *(_QWORD *)(v12 + 8) = a2;
      *(_QWORD *)(v12 + 16) = v13;
      return mfs_DataCachePair_Init_Obersee(a1, 0x800u, 0x40u, (uint64_t)mfs_symdata_BPECache_callback, v12, a3);
    }
    else
    {
      return 2229280774;
    }
  }
}

uint64_t mfs_symData_recoverFeatVectBPE_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  return mfs_symdata_BPEUncompressRow((uint64_t *)(a1 + 1904), a2, a3, a4);
}

uint64_t mfs_symData_recoverFeatVectBPEBitPack_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  _BYTE v14[256];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned int *)(a1 + 2440);
  result = mfs_symdata_BPEUncompressRow((uint64_t *)(a1 + 1904), a2, a3, (uint64_t)v14);
  if ((result & 0x80000000) == 0 && (_DWORD)v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v8);
      v12 = (unint64_t)v9 >> 3;
      v13 = v14[v12] << 8;
      if ((v10 + v11) >= 9)
        v13 |= v14[v12 + 1];
      *(_BYTE *)(a4 + v8) = (unsigned __int16)(v13 << v10) >> (16 - v11);
      v9 += v11;
      v10 = v9 & 7;
      ++v8;
    }
    while (v6 != v8);
  }
  return result;
}

uint64_t mfs_symdata_BPECache_callback(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  (*((void (**)(_QWORD, _QWORD, _QWORD, uint64_t))a1 + 2))(*((_QWORD *)a1 + 1), *a1, a1[1], a3);
  return 0;
}

double mfs_BPESymDataCache_DeInit_Obersee(uint64_t a1, uint64_t a2)
{
  heap_Free(*(_QWORD **)(a2 + 8), *(_QWORD *)(a1 + 8));
  return mfs_DataCachePair_DeInit_Obersee(a1, a2);
}

uint64_t mfs_symData_recoverCompactFeatVect_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *__dst, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int *v9;
  char v10;
  unsigned int v11;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  unint64_t v20;
  int v21;

  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8344);
  if ((v8 - 3) >= 2)
  {
    if (v8 == 1)
    {
      v13 = *(unsigned int *)(a1 + 2440);
      if ((_DWORD)v13)
      {
        v14 = 0;
        v15 = *(_DWORD *)(a1 + 2424) * a4;
        v16 = *(_QWORD *)(a1 + 2432) + (v15 >> 3);
        v17 = v15 & 7;
        do
        {
          v18 = v15 & 7;
          v19 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v14);
          v20 = (unint64_t)v17 >> 3;
          v21 = *(unsigned __int8 *)(v16 + v20) << 8;
          if ((v18 + v19) >= 9)
            v21 |= *(unsigned __int8 *)(v16 + v20 + 1);
          __dst[v14] = (unsigned __int16)(v21 << v18) >> (16 - v19);
          v15 = v17 + v19;
          ++v14;
          v17 = v15;
        }
        while (v13 != v14);
      }
      return 0;
    }
    else
    {
      MFS__log_select_Error(a2, 1, (uint64_t)"%s: compression mode %d not supported!", a4, (uint64_t)__dst, a6, a7, a8);
      return 2229280775;
    }
  }
  else
  {
    v9 = *(unsigned int **)(a3 + 8);
    v10 = *(_BYTE *)(a1 + 1932);
    v11 = ((0xFFFFFFFF >> -v10) & a4) + *(_DWORD *)(*(_QWORD *)(a1 + 1912) + 4 * (a4 >> v10));
    *v9 = a4 >> v10;
    v9[1] = v11;
    return mfs_DataCachePair_ReadAndWrite_Obersee(a3, v11, __dst);
  }
}

uint64_t mfs_symData_recoverCompactNFeatVect_Obersee(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  uint64_t result;
  char v21;
  int v22;
  int v23;
  uint64_t *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned __int8 *v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  int v34;
  unint64_t v35;
  int v36;
  _BYTE v37[256];
  uint64_t v38;

  v9 = a4;
  v38 = *MEMORY[0x1E0C80C00];
  v11 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8344);
  switch(v11)
  {
    case 4:
      v21 = *(_BYTE *)(a1 + 1932);
      v22 = a3 >> v21;
      v23 = *(_DWORD *)(*(_QWORD *)(a1 + 1912) + 4 * (a3 >> v21));
      v24 = (uint64_t *)(a1 + 1904);
      v25 = ((0xFFFFFFFF >> -v21) & a3) + v23;
      v26 = 0;
      if ((_DWORD)a4)
      {
        v27 = *(unsigned __int8 **)(a1 + 2416);
        v28 = a4;
        do
        {
          v29 = *v27++;
          v26 += v29;
          --v28;
        }
        while (v28);
      }
      if ((v26 & 7) != 0)
        v30 = (v26 >> 3) + 1;
      else
        v30 = v26 >> 3;
      result = mfs_symdata_BPEUncompressNBytes(v24, v22, v25, v30, (uint64_t)v37);
      if (v9 && (result & 0x80000000) == 0)
      {
        v31 = 0;
        v32 = 0;
        v33 = 0;
        do
        {
          v34 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v31);
          v35 = (unint64_t)v32 >> 3;
          v36 = v37[v35] << 8;
          if ((v33 + v34) >= 9)
            v36 |= v37[v35 + 1];
          *(_BYTE *)(a5 + v31) = (unsigned __int16)(v36 << v33) >> (16 - v34);
          v32 += v34;
          v33 = v32 & 7;
          ++v31;
        }
        while (v9 != v31);
      }
      break;
    case 3:
      return mfs_symdata_BPEUncompressNBytes((uint64_t *)(a1 + 1904), a3 >> *(_BYTE *)(a1 + 1932), ((0xFFFFFFFF >> -*(_BYTE *)(a1 + 1932)) & a3)+ *(_DWORD *)(*(_QWORD *)(a1 + 1912) + 4 * (a3 >> *(_BYTE *)(a1 + 1932))), a4, a5);
    case 1:
      if ((_DWORD)a4)
      {
        v12 = 0;
        v13 = *(_DWORD *)(a1 + 2424) * a3;
        v14 = *(_QWORD *)(a1 + 2432) + (v13 >> 3);
        v15 = v13 & 7;
        do
        {
          v16 = v13 & 7;
          v17 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v12);
          v18 = (unint64_t)v15 >> 3;
          v19 = *(unsigned __int8 *)(v14 + v18) << 8;
          if ((v16 + v17) >= 9)
            v19 |= *(unsigned __int8 *)(v14 + v18 + 1);
          *(_BYTE *)(a5 + v12) = (unsigned __int16)(v19 << v16) >> (16 - v17);
          v13 = v15 + v17;
          ++v12;
          v15 = v13;
        }
        while (a4 != v12);
      }
      return 0;
    default:
      MFS__log_select_Error(a2, 1, (uint64_t)"%s, compression mode %d not supported!", a4, a5, a6, a7, a8);
      return 2229280775;
  }
  return result;
}

void mfs_symData_DistanceOnUid_PreCalcVitSymRulesForTargetVector_Obersee(uint64_t a1, int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5, _QWORD *a6)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;

  v6 = *(unsigned int *)(a1 + 2440);
  v7 = *(_QWORD *)(a1 + 2400);
  if (v7 && a5[v6] > a3)
  {
    if ((_DWORD)v6)
    {
      v8 = v6 * (a2 - 1);
      v9 = v6 * (a2 + 4 * a3 - 1);
      v10 = *(uint64_t **)(a1 + 2400);
      do
      {
        v11 = *(_QWORD *)(v7 + 8 * v9);
        if (v11 || (v11 = *(_QWORD *)(v7 + 8 * v8)) != 0 || (v11 = *v10) != 0)
        {
          if (*a4 >= *a5)
            v11 = 0;
          else
            v11 += 2 * *a5 * (unint64_t)*a4;
        }
        *a6++ = v11;
        ++v10;
        ++a4;
        ++a5;
        ++v8;
        ++v9;
        --v6;
      }
      while (v6);
    }
  }
  else if ((_DWORD)v6)
  {
    bzero(a6, 8 * v6);
  }
}

float mfs_symData_DistanceOnUid_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  float v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE __dst[256];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v11 = *(unsigned int *)(a1 + 2440);
  mfs_symData_recoverCompactFeatVect_Obersee(a1, a2, a7, a4, __dst, a6, a7, a8);
  if ((_DWORD)v11)
  {
    v13 = 0;
    v14 = 0.0;
    while (1)
    {
      v15 = __dst[v13];
      if (*(unsigned __int8 *)(a3 + 4 + v13) != (_DWORD)v15)
      {
        v16 = *(_QWORD *)(a6 + 8 * v13);
        if (!v16)
        {
          v17 = *(_QWORD *)(a3 + 184);
LABEL_8:
          v12 = *(float *)(v17 + 4 * v13);
          v14 = v14 + (float)(v12 * 10.0);
          goto LABEL_9;
        }
        v17 = *(_QWORD *)(a3 + 184);
        if (v15 >= *(unsigned __int8 *)(a5 + v13))
          goto LABEL_8;
        LOWORD(v12) = *(_WORD *)(v16 + 2 * v15);
        v12 = (float)LODWORD(v12);
        v14 = v14 + (float)(v12 * *(float *)(v17 + 4 * v13));
      }
LABEL_9:
      if (v11 == ++v13)
        return v14 / 10.0;
    }
  }
  v14 = 0.0;
  return v14 / 10.0;
}

uint64_t mfs_symdata_BPEUncompressRow(uint64_t *a1, int a2, unsigned int a3, uint64_t a4)
{
  _BYTE *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  char *v17;
  uint64_t result;
  _OWORD v19[16];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = (_BYTE *)(a1[2] + a3);
  v5 = *a1;
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  v6 = *((_DWORD *)a1 + 6);
  v7 = v6 - 1;
  if (v6 == 1)
  {
    result = 0;
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = v5 + (a2 << 9);
    do
    {
      v12 = v10 - 1;
      v13 = &v4[v9];
      if (v10)
      {
        v14 = (unsigned __int8 *)v19 + v12;
      }
      else
      {
        LODWORD(v12) = 0;
        ++v9;
        v14 = v13;
      }
      v15 = *v14;
      v16 = *(unsigned __int8 *)(v11 + v15);
      if ((_DWORD)v15 == v16)
      {
        *(_BYTE *)(a4 + v8++) = v15;
        v10 = v12;
      }
      else
      {
        v17 = (char *)v19 + v12;
        *v17 = *(_BYTE *)(v11 + 256 + v15);
        v10 = v12 + 2;
        v17[1] = v16;
      }
    }
    while (v10 <= 0xFF && v8 < v7);
    if (v10 >= 0x101)
      result = 2229281034;
    else
      result = 0;
    if (v10)
      v4 = (char *)v19 + v10 - 1;
    else
      v4 += v9;
  }
  *(_BYTE *)(a4 + v8) = *v4;
  return result;
}

uint64_t mfs_symdata_BPEUncompressNBytes(uint64_t *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  char *v17;
  _OWORD v19[16];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a1[2];
  v6 = *a1;
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  if (!a4)
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = v5 + a3;
  v11 = v6 + (a2 << 9);
  do
  {
    v12 = v9 - 1;
    v13 = (unsigned __int8 *)(v10 + v8);
    if (v9)
    {
      v14 = (unsigned __int8 *)v19 + v12;
    }
    else
    {
      LODWORD(v12) = 0;
      ++v8;
      v14 = v13;
    }
    v15 = *v14;
    v16 = *(unsigned __int8 *)(v11 + v15);
    if ((_DWORD)v15 == v16)
    {
      *(_BYTE *)(a5 + v7++) = v15;
      v9 = v12;
    }
    else
    {
      v17 = (char *)v19 + v12;
      *v17 = *(_BYTE *)(v11 + 256 + v15);
      v9 = v12 + 2;
      v17[1] = v16;
    }
  }
  while (v9 <= 0xFF && v7 < a4);
  if (v9 >= 0x100)
    return 2229281034;
  else
    return 0;
}

uint64_t mfs_CostList_QSelect(uint64_t a1, int a2, int a3, uint64_t (*a4)(char *, char *), unsigned int a5)
{
  unsigned int v6;
  unsigned int v9;
  char *v10;
  int v11;
  char *v12;
  char *v13;
  char v14;
  unsigned int v15;
  uint64_t v16;
  char *v17;
  char *v18;
  int v19;
  char v20;
  char *v21;
  int v22;
  char v23;
  uint64_t v25;
  char *v26;
  unsigned int v28;

  v25 = a5 * a3;
  v6 = a2 - 1;
  if (a2 != 1)
  {
    v9 = 0;
    v28 = 0;
    v26 = (char *)(a1 + v25);
    do
    {
      v10 = (char *)(a1 + v6 * a3);
      if (a3)
      {
        v11 = a3;
        v12 = (char *)(a1 + v6 * a3);
        v13 = v26;
        do
        {
          v14 = *v13;
          *v13++ = *v12;
          *v12++ = v14;
          --v11;
        }
        while (v11);
      }
      v15 = v9;
      if (v9 < v6)
      {
        v16 = v9;
        v15 = v9;
        do
        {
          v17 = (char *)(a1 + (v16 * a3));
          if ((a4(v17, v10) & 0x80000000) != 0)
          {
            if (a3)
            {
              v18 = (char *)(a1 + v15 * a3);
              v19 = a3;
              do
              {
                v20 = *v17;
                *v17++ = *v18;
                *v18++ = v20;
                --v19;
              }
              while (v19);
            }
            ++v15;
          }
          ++v16;
        }
        while (v16 != v6);
      }
      if (a3)
      {
        v21 = (char *)(a1 + v15 * a3);
        v22 = a3;
        do
        {
          v23 = *v10;
          *v10++ = *v21;
          *v21++ = v23;
          --v22;
        }
        while (v22);
      }
      if (v15 == a5)
        break;
      if (v15 >= a5)
        v6 = v15 - 1;
      else
        v9 = v15 + 1;
      ++v28;
    }
    while (v28 < v6);
  }
  return a1 + v25;
}

uint64_t mfs_Viterbi_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v10 = 2229280778;
  bzero((void *)a1, 0x308uLL);
  *(_QWORD *)(a1 + 712) = 0;
  *(_QWORD *)a1 = a2;
  fastallo_Init((_WORD *)(a1 + 24), *(_QWORD *)(a2 + 8), 4096);
  *(_QWORD *)(a1 + 8) = a4;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 760) = a5;
  *(_QWORD *)(a1 + 604) = 0;
  *(_QWORD *)(a1 + 612) = 0;
  *(_QWORD *)(a1 + 596) = 0;
  *(_DWORD *)(a1 + 720) = 1065353216;
  v11 = *(_QWORD *)(a3 + 1072);
  *(float *)(a1 + 724) = *(float *)(v11 + 8384) + 1.0;
  *(float *)(a1 + 728) = *(float *)(v11 + 8384) + 1.0;
  *(_DWORD *)(a1 + 732) = 0;
  *(_DWORD *)(a1 + 736) = *(_DWORD *)(v11 + 8384);
  *(_DWORD *)(a1 + 740) = *(_DWORD *)(v11 + 8384);
  *(_DWORD *)(a1 + 744) = 1065353216;
  *(float *)(a1 + 748) = *(float *)(v11 + 8384) + 1.0;
  *(float *)(a1 + 752) = *(float *)(v11 + 8384) + 1.0;
  v12 = *(unsigned int *)(v11 + 8240);
  v13 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 32 * v12);
  *(_QWORD *)(a1 + 624) = v13;
  if (v13)
  {
    v14 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 32 * v12);
    *(_QWORD *)(a1 + 632) = v14;
    if (v14)
    {
      *(_DWORD *)(a1 + 660) = v12;
      *(_DWORD *)(a1 + 680) = v12;
      v15 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * v12);
      *(_QWORD *)(a1 + 672) = v15;
      if (v15)
      {
        v16 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), *(unsigned int *)(a1 + 680));
        *(_QWORD *)(a1 + 704) = v16;
        if (v16)
        {
          v17 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * *(unsigned int *)(a1 + 680));
          *(_QWORD *)(a1 + 688) = v17;
          if (v17)
          {
            v18 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * *(unsigned int *)(a1 + 680));
            *(_QWORD *)(a1 + 696) = v18;
            if (v18)
            {
              v19 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 2 * *(unsigned int *)(a1 + 680));
              *(_QWORD *)(a1 + 640) = v19;
              if (v19)
              {
                *(_WORD *)(a1 + 592) = 200;
                v20 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 400);
                *(_QWORD *)(a1 + 584) = v20;
                if (v20)
                {
                  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"S8_X2B Viterbi Decoder Variant 2 has been selected\n");
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return v10;
}

uint64_t mfs_Viterbi_Reset_Obersee(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 596) = a2;
  *(_DWORD *)(a1 + 612) = a2;
  *(_DWORD *)(a1 + 616) = 0;
  *(_DWORD *)(a1 + 648) = 0;
  *(_QWORD *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 608) = 0;
  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi regular search and emission, from=%d to=?\n");
  return 0;
}

uint64_t mfs_Viterbi_DeInit_Obersee(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*(_QWORD *)(a1 + 8))
  {
    fastallo_Terminate((_QWORD *)(a1 + 24));
    v2 = *(_QWORD *)(a1 + 624);
    if (v2)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v2);
      *(_QWORD *)(a1 + 624) = 0;
    }
    v3 = *(_QWORD *)(a1 + 632);
    if (v3)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v3);
      *(_QWORD *)(a1 + 632) = 0;
    }
    *(_DWORD *)(a1 + 680) = 0;
    v4 = *(_QWORD *)(a1 + 672);
    if (v4)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v4);
      *(_QWORD *)(a1 + 672) = 0;
    }
    v5 = *(_QWORD *)(a1 + 704);
    if (v5)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v5);
      *(_QWORD *)(a1 + 704) = 0;
    }
    v6 = *(_QWORD *)(a1 + 688);
    if (v6)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v6);
      *(_QWORD *)(a1 + 688) = 0;
    }
    v7 = *(_QWORD *)(a1 + 696);
    if (v7)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v7);
      *(_QWORD *)(a1 + 696) = 0;
    }
    v8 = *(_QWORD *)(a1 + 640);
    if (v8)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v8);
      *(_QWORD *)(a1 + 640) = 0;
    }
    v9 = *(_QWORD *)(a1 + 584);
    if (v9)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v9);
      *(_QWORD *)(a1 + 584) = 0;
      *(_WORD *)(a1 + 592) = 0;
    }
    *(_QWORD *)(a1 + 8) = 0;
  }
  return 0;
}

uint64_t mfs_Viterbi_DumpHeapStats(uint64_t *a1)
{
  int v2;
  int UsedMemory;

  v2 = 79 * *(_DWORD *)(*(_QWORD *)(a1[2] + 1072) + 8240);
  MFS__log_select_Diag(*a1, 9, (uint64_t)"memstats:viterbi mem usage: %d bytes (prev&cur timeslice+unitid+bSLL+joinENDLF0+MCP)\n");
  UsedMemory = fastallo_GetUsedMemory((uint64_t)(a1 + 3));
  MFS__log_select_Diag(*a1, 9, (uint64_t)"memstats:viterbi backtrace mem usage: %d bytes from %d entries (%d states,%d bytes overhead)\n");
  return (UsedMemory + v2);
}

uint64_t mfs_Viterbi_FillPrevStateCacheTables(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_DWORD *)(result + 656))
  {
    v2 = 0;
    v3 = *(_QWORD *)(a2 + 32);
    do
    {
      v4 = v3 + 24 * *(unsigned __int16 *)(*(_QWORD *)(result + 640) + 2 * v2);
      *(_DWORD *)(*(_QWORD *)(result + 672) + 4 * v2) = *(_DWORD *)(v4 + 4);
      v5 = *(_QWORD *)(v4 + 16);
      *(_DWORD *)(*(_QWORD *)(result + 688) + 4 * v2) = *(_DWORD *)(v5 + 12);
      *(_DWORD *)(*(_QWORD *)(result + 696) + 4 * v2) = *(unsigned __int16 *)(v5 + 16);
      *(_BYTE *)(*(_QWORD *)(result + 704) + v2++) = *(_BYTE *)(v5 + 28);
    }
    while (v2 < *(unsigned int *)(result + 656));
  }
  return result;
}

uint64_t mfs_Viterbi_DecodeState_MCP_S9_LF0_S8_X2B_Obersee(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  unsigned __int8 *v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned __int16 v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  float v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned __int16 *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  uint64_t v36;
  float v37;
  float v38;
  float *v39;
  float v40;
  float v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  float v52;
  float v53;
  float v54;
  float v55;
  uint64_t v56;
  float v57;
  float v58;
  int *v59;
  int v60;
  unsigned int *v61;
  unsigned int *v62;
  int v63;
  unint64_t v64;
  uint64_t v65;
  float v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  float v70;
  unsigned int *v71;
  unsigned __int16 *v72;
  unsigned int *v73;
  uint64_t v74;
  _DWORD *v75;
  unsigned __int8 *v76;
  uint64_t v77;
  unsigned int v78;
  float v79;
  unsigned int v80;
  float v81;
  unsigned int v82;
  float v83;
  float v84;
  int v85;
  unsigned int v86;
  unsigned int *v87;
  unsigned __int16 *v88;
  unsigned int *v89;
  uint64_t v90;
  _DWORD *v91;
  unsigned __int8 *v92;
  uint64_t v93;
  unsigned int v94;
  float v95;
  unsigned int v96;
  float v97;
  unsigned int v98;
  float v99;
  float v100;
  float *v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  unsigned int v109;
  uint64_t v110;
  int v111;
  float v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  float v116;
  int v117;
  uint64_t v118;
  float v119;
  float v120;
  int v121;
  uint64_t v122;
  float v123;
  float v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  float v128;
  float v129;
  float v130;
  int v131;
  unsigned int *v132;
  unsigned __int16 *v133;
  unsigned int *v134;
  uint64_t v135;
  int *v136;
  unsigned __int8 *v137;
  unsigned int v138;
  unsigned int v139;
  float v140;
  unsigned int v141;
  float v142;
  unsigned int v143;
  float v144;
  unsigned int v145;
  float v146;
  int v147;
  float v148;
  unsigned int v149;
  uint64_t v150;
  uint64_t v151;
  float *v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float *v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float *v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  uint64_t v182;
  uint64_t v183;
  float v184;
  float v185;
  float v186;
  float *v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  unsigned __int16 *v195;
  float v196;
  uint64_t v197;
  _DWORD *v198;
  unsigned __int16 *v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  uint64_t v203;
  unsigned int v204;
  float v205;
  float v206;
  float v207;
  unsigned int v208;
  float v209;
  float v210;
  uint64_t v211;
  float v212;
  float v213;
  float v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t MemoryFromChunk;
  float v221;
  uint64_t v222;
  int v223;
  uint64_t v224;
  float v225;
  uint64_t v226;
  __int16 v227;
  BOOL v228;
  int v229;
  unint64_t v230;
  int v231;
  int v232;
  _QWORD *v233;
  uint64_t v234;
  __int16 v235;
  _DWORD *v236;
  unint64_t v237;
  uint64_t v238;
  int *v239;
  int v240;
  uint64_t v242;
  int v243;
  int v244;
  unsigned int v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  float v249;
  float v250;
  uint64_t v251;
  int v252;
  uint64_t v253;
  int v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  _QWORD v258[2];

  v2 = a2;
  v258[0] = 0;
  v4 = *(_QWORD **)(a1 + 16);
  v5 = v4[134];
  v6 = a1 + 24;
  v7 = *(_DWORD **)(a1 + 672);
  v8 = *(unsigned __int8 **)(a1 + 704);
  v9 = *(float *)(v5 + 8388);
  v10 = *(float *)(v5 + 8172);
  v255 = v4[267];
  v256 = v4[269];
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 2072);
  v12 = *(_QWORD *)(a2 + 32);
  v13 = -1431655765 * ((unint64_t)(*(_QWORD *)(a2 + 40) - v12) >> 3);
  v14 = *(_DWORD *)(a1 + 616);
  if (v14)
  {
    v15 = *(_DWORD *)(v5 + 8564);
    v16 = *(_DWORD *)(a1 + 612) + v14;
    v253 = *(_QWORD *)(a2 + 32);
    if (v15)
    {
      v17 = v16 + ~*(_DWORD *)(a1 + 596);
      v18 = *(unsigned __int16 *)(a1 + 592);
      if (v17 >= v18)
      {
        v19 = v18 + 100;
        *(_WORD *)(a1 + 592) = v19;
        v243 = v15;
        v21 = v11;
        v22 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 584), 2 * v19);
        v11 = v21;
        v2 = a2;
        v15 = v243;
        *(_QWORD *)(a1 + 584) = v22;
        if (!v22)
          return 10;
      }
    }
    else
    {
      v17 = 0;
    }
    *(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v17) = 0;
    v34 = 0.0;
    v35 = 0.0;
    if (*(_DWORD *)(v5 + 8264))
      v35 = *(float *)(v2 + 64);
    v246 = v6;
    v247 = v17;
    if (*(_DWORD *)(v5 + 8268))
    {
      v252 = *(_DWORD *)(v2 + 68);
      v34 = (float)*(int *)(v2 + 72);
    }
    else
    {
      v252 = 0;
    }
    v36 = *(_QWORD *)(a1 + 8);
    v37 = *(float *)(*(_QWORD *)(v36 + 2088) + 4 * v16);
    v38 = *(float *)(*(_QWORD *)(v36 + 2096) + 4 * v16);
    v39 = *(float **)(v11 + 8 * v16);
    v40 = v37 * *v39;
    v41 = v37 * v39[2];
    v42 = v37 * v39[1];
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Join cost %d\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized ADJ weight %f\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized LF0 weight %f\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized MCP weight %f\n");
    v43 = *(_QWORD *)(a1 + 624);
    v44 = *(_QWORD *)(a1 + 632);
    *(_QWORD *)(a1 + 624) = v44;
    *(_QWORD *)(a1 + 632) = v43;
    v45 = *(_DWORD *)(a1 + 656);
    *(_DWORD *)(a1 + 652) = v45;
    v46 = *(_DWORD *)(v2 + 60);
    if (v46 >= v13)
      v46 = v13;
    *(_DWORD *)(a1 + 656) = v46;
    if (v46)
    {
      v244 = v15;
      v242 = v2;
      v47 = 0;
      v254 = 0;
      v48 = 0;
      v49 = a1 + 744;
      v50 = v45 & 3;
      v51 = v252;
      v52 = v38;
      v53 = (float)v252;
      v245 = v16 % 3;
      v248 = 4 * ((v45 & 3) - 1) + 4;
      HIWORD(v54) = 19224;
      v55 = 10000000.0;
      v56 = v253;
      v251 = v43;
      v250 = v52;
      v249 = v35;
      do
      {
        LODWORD(v258[0]) = 0;
        v57 = 0.0;
        v257 = v47;
        if (v35 != 0.0)
        {
          v58 = v55;
          mfs_getBeginEndPitch_Obersee(*(_QWORD *)(a1 + 16), *(_QWORD *)(v56 + 24 * v47 + 16), (float *)v258, 0);
          v47 = v257;
          v55 = v58;
          v35 = v249;
          v50 = v45 & 3;
          v52 = v250;
          v51 = v252;
          v43 = v251;
          v56 = v253;
          HIWORD(v54) = WORD1(v258[0]);
          if (*(float *)v258 >= 0.0)
            v57 = *(float *)v258;
          else
            v57 = 0.0;
          *(float *)v258 = v57;
        }
        v59 = *(int **)(v56 + 24 * v47 + 16);
        if (*(_DWORD *)(v5 + 8268))
          v60 = *((unsigned __int8 *)v59 + 27);
        else
          v60 = 0;
        v61 = *(unsigned int **)(a1 + 688);
        v62 = *(unsigned int **)(a1 + 696);
        LOWORD(v54) = *(_WORD *)(v56 + 24 * v47 + 8);
        v63 = *v59;
        v64 = *((unsigned __int8 *)v59 + 28);
        if (v64 <= 2)
        {
          v65 = 4 * v64;
          do
          {
            *(float *)(v49 + v65) = (float)(v9 * *(float *)(v49 + v65 - 12)) + (float)(v40 * *(float *)(v49 + v65 - 24));
            v65 += 4;
          }
          while (v65 != 12);
        }
        v66 = (float)((float)(1.0 - v37) * (float)LODWORD(v54)) / 100.0;
        v67 = v49 + 4 * v64;
        v68 = v255 + ((unint64_t)*((unsigned __int16 *)v59 + 10) << 11);
        v69 = v256 + ((unint64_t)*((unsigned __int16 *)v59 + 9) << 10);
        v70 = 10000000.0 - v66;
        if (v51)
        {
          if ((_DWORD)v50)
          {
            v71 = (unsigned int *)((char *)v61 + v248);
            v72 = *(unsigned __int16 **)(a1 + 640);
            v73 = (unsigned int *)((char *)v62 + v248);
            v74 = v50;
            v75 = v7;
            v76 = v8;
            while (1)
            {
              v78 = *v72++;
              v77 = v78;
              v79 = *(float *)(v44 + 32 * v78);
              if (v79 > v70)
                break;
              v80 = *v61++;
              v81 = *(float *)(v67 + 4 * *v76) + (float)(v41 * *(float *)(v69 + 4 * v80));
              v82 = *v62++;
              v83 = v81 + (float)(v42 * *(float *)(v68 + 4 * v82));
              if (v63 == *v75)
                v83 = 0.0;
              v84 = v79 + v83;
              v85 = v60 - v51 + *(__int16 *)(v44 + 32 * v77 + 16);
              if (v85 < 0)
                v85 = -v85;
              if ((float)(*(float *)(v5 + 8308) * v34) <= (float)v85)
                v84 = v84 + (float)((float)(*(float *)(v5 + 8312) * (float)v85) / v53);
              if (v84 < v70)
              {
                v70 = v84;
                v48 = v77;
              }
              ++v76;
              ++v75;
              if (!--v74)
              {
                v62 = v73;
                v61 = v71;
                v86 = v50;
                goto LABEL_78;
              }
            }
          }
          else
          {
            v86 = 0;
LABEL_78:
            if (v86 < v45)
            {
              v110 = *(_QWORD *)(a1 + 640);
              v111 = v60 - v51;
              v112 = *(float *)(v5 + 8308) * v34;
              do
              {
                v113 = *(unsigned __int16 *)(v110 + 2 * v86);
                v114 = v44 + 32 * v113;
                v115 = (float)(*(float *)(v67 + 4 * v8[v86]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                     + (float)(v42 * *(float *)(v68 + 4 * *v62));
                if (v63 == v7[v86])
                  v115 = 0.0;
                v116 = *(float *)v114 + v115;
                v117 = v111 + *(__int16 *)(v114 + 16);
                if (v117 < 0)
                  v117 = -v117;
                if (v112 <= (float)v117)
                  v116 = v116 + (float)((float)(*(float *)(v5 + 8312) * (float)v117) / v53);
                if (v116 >= v70)
                  LODWORD(v113) = v48;
                else
                  v70 = v116;
                v118 = v44 + 32 * *(unsigned __int16 *)(v110 + 2 * (v86 + 1));
                v119 = (float)(*(float *)(v67 + 4 * v8[v86 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
                if (v63 == v7[v86 + 1])
                  v119 = 0.0;
                v120 = *(float *)v118 + v119;
                v121 = v111 + *(__int16 *)(v118 + 16);
                if (v121 < 0)
                  v121 = -v121;
                if (v112 <= (float)v121)
                  v120 = v120 + (float)((float)(*(float *)(v5 + 8312) * (float)v121) / v53);
                if (v120 < v70)
                {
                  v70 = v120;
                  LODWORD(v113) = *(unsigned __int16 *)(v110 + 2 * (v86 + 1));
                }
                v122 = v44 + 32 * *(unsigned __int16 *)(v110 + 2 * (v86 + 2));
                v123 = (float)(*(float *)(v67 + 4 * v8[v86 + 2]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
                if (v63 == v7[v86 + 2])
                  v123 = 0.0;
                v124 = *(float *)v122 + v123;
                v125 = v111 + *(__int16 *)(v122 + 16);
                if (v125 < 0)
                  v125 = -v125;
                if (v112 <= (float)v125)
                  v124 = v124 + (float)((float)(*(float *)(v5 + 8312) * (float)v125) / v53);
                if (v124 >= v70)
                {
                  v48 = v113;
                }
                else
                {
                  v70 = v124;
                  v48 = *(unsigned __int16 *)(v110 + 2 * (v86 + 2));
                }
                v126 = v86 + 3;
                v127 = *(unsigned __int16 *)(v110 + 2 * v126);
                v128 = *(float *)(v44 + 32 * v127);
                if (v128 > v70)
                  break;
                v129 = (float)(*(float *)(v67 + 4 * v8[v126]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
                if (v63 == v7[v126])
                  v129 = 0.0;
                v130 = v128 + v129;
                v131 = v111 + *(__int16 *)(v44 + 32 * v127 + 16);
                if (v131 < 0)
                  v131 = -v131;
                if (v112 <= (float)v131)
                  v130 = v130 + (float)((float)(*(float *)(v5 + 8312) * (float)v131) / v53);
                if (v130 < v70)
                {
                  v70 = v130;
                  v48 = v127;
                }
                v86 += 4;
                v61 += 4;
                v62 += 4;
              }
              while (v86 < v45);
            }
          }
        }
        else if (v57 == 0.0)
        {
          if (v245)
          {
            if ((_DWORD)v50)
            {
              v132 = (unsigned int *)((char *)v61 + v248);
              v133 = *(unsigned __int16 **)(a1 + 640);
              v134 = (unsigned int *)((char *)v62 + v248);
              v135 = v50;
              v136 = v7;
              v137 = v8;
              while (1)
              {
                v139 = *v133++;
                v138 = v139;
                v140 = *(float *)(v44 + 32 * v139);
                if (v140 > v70)
                  break;
                v141 = *v137++;
                v142 = *(float *)(v67 + 4 * v141);
                v143 = *v61++;
                v144 = v142 + (float)(v41 * *(float *)(v69 + 4 * v143));
                v145 = *v62++;
                v146 = v144 + (float)(v42 * *(float *)(v68 + 4 * v145));
                v147 = *v136++;
                if (v63 == v147)
                  v146 = 0.0;
                v148 = v140 + v146;
                if (v148 < v70)
                {
                  v70 = v148;
                  v48 = v138;
                }
                if (!--v135)
                {
                  v62 = v134;
                  v61 = v132;
                  v149 = v50;
                  goto LABEL_223;
                }
              }
            }
            else
            {
              v149 = 0;
LABEL_223:
              if (v149 < v45)
              {
                v203 = *(_QWORD *)(a1 + 640);
                do
                {
                  v204 = *(unsigned __int16 *)(v203 + 2 * v149);
                  v205 = (float)(*(float *)(v67 + 4 * v8[v149]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                       + (float)(v42 * *(float *)(v68 + 4 * *v62));
                  if (v63 == v7[v149])
                    v205 = 0.0;
                  if ((float)(*(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v149)) + v205) < v70)
                    v70 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v149)) + v205;
                  else
                    v204 = v48;
                  v206 = (float)(*(float *)(v67 + 4 * v8[v149 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
                  if (v63 == v7[v149 + 1])
                    v206 = 0.0;
                  v207 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * (v149 + 1))) + v206;
                  v208 = v149 + 2;
                  if (v207 < v70)
                  {
                    v70 = v207;
                    v204 = *(unsigned __int16 *)(v203 + 2 * (v149 + 1));
                  }
                  v209 = (float)(*(float *)(v67 + 4 * v8[v208]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
                  if (v63 == v7[v208])
                    v209 = 0.0;
                  v210 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * (v149 + 2))) + v209;
                  if (v210 >= v70)
                  {
                    v48 = v204;
                  }
                  else
                  {
                    v70 = v210;
                    v48 = *(unsigned __int16 *)(v203 + 2 * (v149 + 2));
                  }
                  v211 = v149 + 3;
                  v212 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v211));
                  if (v212 > v70)
                    break;
                  v213 = (float)(*(float *)(v67 + 4 * v8[v211]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
                  if (v63 == v7[v211])
                    v213 = 0.0;
                  v214 = v212 + v213;
                  if (v214 < v70)
                  {
                    v70 = v214;
                    v48 = *(unsigned __int16 *)(v203 + 2 * v211);
                  }
                  v149 += 4;
                  v61 += 4;
                  v62 += 4;
                }
                while (v149 < v45);
              }
            }
          }
          else
          {
            v195 = *(unsigned __int16 **)(a1 + 640);
            v48 = *v195;
            v196 = *(float *)(v44 + 32 * *v195) + 4.0;
            if ((_DWORD)v50)
            {
              v197 = v50;
              v198 = v7;
              v199 = *(unsigned __int16 **)(a1 + 640);
              while (1)
              {
                v201 = *v199++;
                v200 = v201;
                v70 = *(float *)(v44 + 32 * v201);
                if (v70 > v196)
                  break;
                if (v63 == *v198)
                {
                  v48 = v200;
                  goto LABEL_259;
                }
                ++v198;
                if (!--v197)
                {
                  v202 = v50;
                  goto LABEL_247;
                }
              }
            }
            else
            {
              v202 = 0;
LABEL_247:
              while (v202 < v45)
              {
                v215 = v202;
                if (v63 == v7[v202])
                  goto LABEL_257;
                v216 = v202 + 1;
                if (v63 == v7[v216] || (v216 = (v215 + 2), v63 == v7[v216]))
                {
                  v215 = v216;
LABEL_257:
                  v48 = v195[v215];
                  v70 = *(float *)(v44 + 32 * v195[v215]);
                  goto LABEL_259;
                }
                v217 = (v215 + 3);
                v70 = *(float *)(v44 + 32 * v195[v217]);
                if (v70 > v196)
                  break;
                if (v63 == v7[v217])
                {
                  v48 = v195[v217];
                  goto LABEL_259;
                }
                v202 = v215 + 4;
              }
            }
            v70 = *(float *)(v44 + 32 * *v195) + 4.0;
          }
        }
        else if ((_DWORD)v50)
        {
          v87 = (unsigned int *)((char *)v61 + v248);
          v88 = *(unsigned __int16 **)(a1 + 640);
          v89 = (unsigned int *)((char *)v62 + v248);
          v90 = v50;
          v91 = v7;
          v92 = v8;
          while (1)
          {
            v94 = *v88++;
            v93 = v94;
            v95 = *(float *)(v44 + 32 * v94);
            if (v95 > v70)
              break;
            v96 = *v61++;
            v97 = *(float *)(v67 + 4 * *v92) + (float)(v41 * *(float *)(v69 + 4 * v96));
            v98 = *v62++;
            v99 = v97 + (float)(v42 * *(float *)(v68 + 4 * v98));
            if (v63 == *v91)
              v99 = 0.0;
            v100 = v95 + v99;
            v101 = (float *)(v44 + 32 * v93);
            v102 = v101[2];
            if (v102 != 0.0)
            {
              v103 = v102 - v57;
              v104 = -v103;
              if (v103 >= 0.0)
                v104 = v103;
              v105 = v103 - (float)(v101[1] - v35);
              if (v105 < 0.0)
                v105 = -v105;
              v106 = v101[3];
              v107 = v106 - v57;
              if ((float)(v106 - v57) < 0.0)
                v107 = -(float)(v106 - v57);
              if (v106 == 0.0)
                v108 = 0.0;
              else
                v108 = v107;
              if (v104 > *(float *)(v5 + 8284))
                v100 = v100 + (float)(*(float *)(v5 + 8288) * v104);
              if (v108 > *(float *)(v5 + 8292))
                v100 = v100 + (float)(*(float *)(v5 + 8296) * v108);
              if (v105 > *(float *)(v5 + 8300))
                v100 = v100 + (float)(*(float *)(v5 + 8304) * v105);
            }
            if (v100 < v70)
            {
              v70 = v100;
              v48 = v93;
            }
            ++v92;
            ++v91;
            if (!--v90)
            {
              v62 = v89;
              v61 = v87;
              v109 = v50;
              goto LABEL_129;
            }
          }
        }
        else
        {
          v109 = 0;
LABEL_129:
          if (v109 < v45)
          {
            v150 = *(_QWORD *)(a1 + 640);
            do
            {
              v151 = *(unsigned __int16 *)(v150 + 2 * v109);
              v152 = (float *)(v44 + 32 * v151);
              v153 = (float)(*(float *)(v67 + 4 * v8[v109]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                   + (float)(v42 * *(float *)(v68 + 4 * *v62));
              if (v63 == v7[v109])
                v153 = 0.0;
              v154 = *v152 + v153;
              v155 = v152[2];
              if (v155 != 0.0)
              {
                v156 = v155 - v57;
                v157 = -v156;
                if (v156 >= 0.0)
                  v157 = v156;
                v158 = v156 - (float)(v152[1] - v35);
                if (v158 < 0.0)
                  v158 = -v158;
                v159 = v152[3];
                v160 = v159 - v57;
                if ((float)(v159 - v57) < 0.0)
                  v160 = -(float)(v159 - v57);
                if (v159 == 0.0)
                  v161 = 0.0;
                else
                  v161 = v160;
                if (v157 > *(float *)(v5 + 8284))
                  v154 = v154 + (float)(*(float *)(v5 + 8288) * v157);
                if (v161 > *(float *)(v5 + 8292))
                  v154 = v154 + (float)(*(float *)(v5 + 8296) * v161);
                if (v158 > *(float *)(v5 + 8300))
                  v154 = v154 + (float)(*(float *)(v5 + 8304) * v158);
              }
              if (v154 >= v70)
                LODWORD(v151) = v48;
              else
                v70 = v154;
              v162 = (float *)(v44 + 32 * *(unsigned __int16 *)(v150 + 2 * (v109 + 1)));
              v163 = (float)(*(float *)(v67 + 4 * v8[v109 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
              if (v63 == v7[v109 + 1])
                v163 = 0.0;
              v164 = *v162 + v163;
              v165 = v162[2];
              if (v165 != 0.0)
              {
                v166 = v165 - v57;
                v167 = -v166;
                if (v166 >= 0.0)
                  v167 = v166;
                v168 = v166 - (float)(v162[1] - v35);
                if (v168 < 0.0)
                  v168 = -v168;
                v169 = v162[3];
                v170 = v169 - v57;
                if ((float)(v169 - v57) < 0.0)
                  v170 = -(float)(v169 - v57);
                if (v169 == 0.0)
                  v171 = 0.0;
                else
                  v171 = v170;
                if (v167 > *(float *)(v5 + 8284))
                  v164 = v164 + (float)(*(float *)(v5 + 8288) * v167);
                if (v171 > *(float *)(v5 + 8292))
                  v164 = v164 + (float)(*(float *)(v5 + 8296) * v171);
                if (v168 > *(float *)(v5 + 8300))
                  v164 = v164 + (float)(*(float *)(v5 + 8304) * v168);
              }
              if (v164 < v70)
              {
                v70 = v164;
                LODWORD(v151) = *(unsigned __int16 *)(v150 + 2 * (v109 + 1));
              }
              v172 = (float *)(v44 + 32 * *(unsigned __int16 *)(v150 + 2 * (v109 + 2)));
              v173 = (float)(*(float *)(v67 + 4 * v8[v109 + 2]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
              if (v63 == v7[v109 + 2])
                v173 = 0.0;
              v174 = *v172 + v173;
              v175 = v172[2];
              if (v175 != 0.0)
              {
                v176 = v175 - v57;
                v177 = -v176;
                if (v176 >= 0.0)
                  v177 = v176;
                v178 = v176 - (float)(v172[1] - v35);
                if (v178 < 0.0)
                  v178 = -v178;
                v179 = v172[3];
                v180 = v179 - v57;
                if ((float)(v179 - v57) < 0.0)
                  v180 = -(float)(v179 - v57);
                if (v179 == 0.0)
                  v181 = 0.0;
                else
                  v181 = v180;
                if (v177 > *(float *)(v5 + 8284))
                  v174 = v174 + (float)(*(float *)(v5 + 8288) * v177);
                if (v181 > *(float *)(v5 + 8292))
                  v174 = v174 + (float)(*(float *)(v5 + 8296) * v181);
                if (v178 > *(float *)(v5 + 8300))
                  v174 = v174 + (float)(*(float *)(v5 + 8304) * v178);
              }
              if (v174 >= v70)
              {
                v48 = v151;
              }
              else
              {
                v70 = v174;
                v48 = *(unsigned __int16 *)(v150 + 2 * (v109 + 2));
              }
              v182 = v109 + 3;
              v183 = *(unsigned __int16 *)(v150 + 2 * v182);
              v184 = *(float *)(v44 + 32 * v183);
              if (v184 > v70)
                break;
              v185 = (float)(*(float *)(v67 + 4 * v8[v182]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
              if (v63 == v7[v182])
                v185 = 0.0;
              v186 = v184 + v185;
              v187 = (float *)(v44 + 32 * v183);
              v188 = v187[2];
              if (v188 != 0.0)
              {
                v189 = v188 - v57;
                v190 = -v189;
                if (v189 >= 0.0)
                  v190 = v189;
                v191 = v189 - (float)(v187[1] - v35);
                if (v191 < 0.0)
                  v191 = -v191;
                v192 = v187[3];
                v193 = v192 - v57;
                if ((float)(v192 - v57) < 0.0)
                  v193 = -(float)(v192 - v57);
                if (v192 == 0.0)
                  v194 = 0.0;
                else
                  v194 = v193;
                if (v190 > *(float *)(v5 + 8284))
                  v186 = v186 + (float)(*(float *)(v5 + 8288) * v190);
                if (v194 > *(float *)(v5 + 8292))
                  v186 = v186 + (float)(*(float *)(v5 + 8296) * v194);
                if (v191 > *(float *)(v5 + 8300))
                  v186 = v186 + (float)(*(float *)(v5 + 8304) * v191);
              }
              if (v186 < v70)
              {
                v70 = v186;
                v48 = v183;
              }
              v109 += 4;
              v61 += 4;
              v62 += 4;
            }
            while (v109 < v45);
          }
        }
LABEL_259:
        v54 = v66 + v70;
        v218 = v257;
        v219 = v43 + 32 * v257;
        if (v54 <= (float)(v52 + v55))
        {
          *(float *)v219 = v54;
          MemoryFromChunk = *(_QWORD *)(a1 + 80);
          if (MemoryFromChunk)
          {
            *(_QWORD *)(a1 + 80) = *(_QWORD *)MemoryFromChunk;
          }
          else
          {
            v221 = v55;
            MemoryFromChunk = fastallo_AllocateMemoryFromChunk(v246, 2u, (int *)v258 + 1);
            v218 = v257;
            v55 = v221;
            v35 = v249;
            v50 = v45 & 3;
            v52 = v250;
            v51 = v252;
            v43 = v251;
            v56 = v253;
          }
          v23 = HIDWORD(v258[0]);
          if ((v258[0] & 0x8000000000000000) != 0)
            return v23;
          ++*(_DWORD *)(a1 + 648);
          *(_DWORD *)MemoryFromChunk = *(_DWORD *)(v56 + 24 * v218 + 4);
          *(_WORD *)(MemoryFromChunk + 4) = 0;
          v222 = *(_QWORD *)(*(_QWORD *)(a1 + 624) + 32 * v48 + 24);
          v223 = *(unsigned __int16 *)(v222 + 4);
          *(_WORD *)(v222 + 4) = v223 + 1;
          if (!v223)
            ++*(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v247);
          *(_QWORD *)(MemoryFromChunk + 8) = v222;
          *(_QWORD *)(v43 + 32 * v218 + 24) = MemoryFromChunk;
          if (*(_DWORD *)(v5 + 8264))
          {
            if (*(float *)v258 == 0.0)
            {
              v226 = v44 + 32 * v48;
              *(_QWORD *)(v43 + 32 * v218 + 8) = *(_QWORD *)(v226 + 8);
              v225 = *(float *)(v226 + 4);
            }
            else
            {
              v224 = v43 + 32 * v218;
              *(_DWORD *)(v224 + 12) = *(_DWORD *)(v44 + 32 * v48 + 8);
              *(_DWORD *)(v224 + 8) = v258[0];
              v225 = v35;
            }
            *(float *)(v43 + 32 * v218 + 4) = v225;
          }
          if (*(_DWORD *)(v5 + 8268))
          {
            if (v51)
              v227 = 0;
            else
              v227 = *(_WORD *)(v44 + 32 * v48 + 16) + v60;
            *(_WORD *)(v43 + 32 * v218 + 16) = v227;
          }
          v54 = *(float *)v219;
          v228 = *(float *)v219 < v55;
          if (*(float *)v219 < v55)
            v55 = *(float *)v219;
          v229 = v254;
          if (v228)
            v229 = v218;
          v254 = v229;
        }
        else
        {
          *(_DWORD *)v219 = 1259902592;
          *(_QWORD *)(v219 + 24) = 0;
        }
        v47 = v218 + 1;
        v230 = *(unsigned int *)(a1 + 656);
      }
      while (v47 < v230);
      v231 = 0;
      if (v52 > 4.0)
      {
        v2 = v242;
        v232 = v254;
LABEL_311:
        mfs_Viterbi_sortCurrentStateByScore(a1);
        *(_DWORD *)(a1 + 656) -= v231;
        mfs_Viterbi_FillPrevStateCacheTables(a1, v2);
        *(_DWORD *)(a1 + 664) = v232;
        goto LABEL_312;
      }
      if ((_DWORD)v230)
      {
        v2 = v242;
        v15 = v244;
        v232 = v254;
        do
        {
          v233 = *(_QWORD **)(v43 + 24);
          if (*(float *)v43 <= (float)(v52 + v55))
          {
            v236 = (_DWORD *)v233[1];
            if (v236)
              *v236 |= 0x80000000;
          }
          else
          {
            *(_DWORD *)v43 = 1259902592;
            ++v231;
            if (v233)
            {
              v234 = v233[1];
              v235 = *(_WORD *)(v234 + 4) - 1;
              *(_WORD *)(v234 + 4) = v235;
              if (!v235)
                --*(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v247);
              *v233 = *(_QWORD *)(a1 + 80);
              *(_QWORD *)(a1 + 80) = v233;
              --*(_DWORD *)(a1 + 648);
              *(_QWORD *)(v43 + 24) = 0;
            }
          }
          v43 += 32;
          --v230;
        }
        while (v230);
      }
      else
      {
        v2 = v242;
        v15 = v244;
        v232 = v254;
      }
    }
    else
    {
      v232 = 0;
      v231 = 0;
      if (v38 > 4.0)
        goto LABEL_311;
    }
    v237 = *(unsigned int *)(a1 + 652);
    if (!(_DWORD)v237)
      goto LABEL_311;
    v238 = 0;
    while (1)
    {
      v239 = *(int **)(v44 + 32 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 640) + 2 * v238) + 24);
      if (v239)
      {
        v240 = *v239;
        if (v15)
        {
          if (*((_WORD *)v239 + 2) && v240 < 0)
          {
LABEL_309:
            *v239 = v240 & 0x7FFFFFFF;
            goto LABEL_310;
          }
          if ((_DWORD)v247)
          {
            mfs_Viterbi_DecrementRefCountCascade(a1, *((_QWORD *)v239 + 1), v247 - 1);
            v237 = *(unsigned int *)(a1 + 652);
          }
        }
        else if (v240 < 0)
        {
          goto LABEL_309;
        }
        *(_QWORD *)v239 = *(_QWORD *)(a1 + 80);
        *(_QWORD *)(a1 + 80) = v239;
        --*(_DWORD *)(a1 + 648);
      }
LABEL_310:
      if (++v238 >= v237)
        goto LABEL_311;
    }
  }
  v24 = *(_DWORD *)(a2 + 60);
  if (v24 >= v13)
    v24 = -1431655765 * ((unint64_t)(*(_QWORD *)(a2 + 40) - v12) >> 3);
  *(_DWORD *)(a1 + 656) = v24;
  if (!v24)
  {
LABEL_15:
    mfs_Viterbi_sortCurrentStateByScore(a1);
    mfs_Viterbi_FillPrevStateCacheTables(a1, v2);
LABEL_312:
    v23 = 0;
    ++*(_DWORD *)(a1 + 616);
    return v23;
  }
  v25 = 0;
  v26 = 0;
  v27 = 1.0 - v10;
  v28 = *(_QWORD *)(a1 + 632);
  v29 = (unsigned __int16 *)(v12 + 8);
  v30 = (unsigned __int16 *)(v12 + 8);
  while (1)
  {
    v31 = *v30;
    v30 += 12;
    v32 = v28 + v25;
    *(float *)v32 = v27 * (float)((float)v31 / 100.0);
    *(_QWORD *)(v32 + 4) = 0;
    *(_QWORD *)(v32 + 10) = 0;
    v33 = *(_QWORD *)(a1 + 80);
    if (v33)
      *(_QWORD *)(a1 + 80) = *(_QWORD *)v33;
    else
      v33 = fastallo_AllocateMemoryFromChunk(v6, 2u, (int *)v258 + 1);
    v23 = HIDWORD(v258[0]);
    if ((v258[0] & 0x8000000000000000) != 0)
      return v23;
    ++*(_DWORD *)(a1 + 648);
    *(_DWORD *)v33 = *((_DWORD *)v29 - 1);
    *(_WORD *)(v33 + 4) = 0;
    *(_QWORD *)(v33 + 8) = 0;
    v28 = *(_QWORD *)(a1 + 632);
    *(_QWORD *)(v28 + v25 + 24) = v33;
    ++v26;
    v25 += 32;
    v29 = v30;
    if (v26 >= *(unsigned int *)(a1 + 656))
      goto LABEL_15;
  }
}

uint64_t mfs_Viterbi_sortCurrentStateByScore(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;

  v2 = *(unsigned int *)(a1 + 656);
  v3 = *(_QWORD *)(a1 + 640);
  if ((_DWORD)v2)
  {
    for (i = 0; i != v2; ++i)
      *(_WORD *)(v3 + 2 * i) = i;
  }
  return qsortex(v3, v2, 2, (uint64_t (*)(char *, char *, uint64_t))mfs_SortIndex_By_PathScore_Obersee, a1);
}

uint64_t mfs_Viterbi_DecrementRefCountCascade(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  __int16 v4;
  uint64_t v5;

  v3 = a3;
  do
  {
    v4 = *(_WORD *)(a2 + 4) - 1;
    *(_WORD *)(a2 + 4) = v4;
    if (v4)
      break;
    --*(_WORD *)(*(_QWORD *)(result + 584) + 2 * v3);
    v5 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a2 = *(_QWORD *)(result + 80);
    *(_QWORD *)(result + 80) = a2;
    --*(_DWORD *)(result + 648);
    if (!(_DWORD)v3)
      break;
    --v3;
    a2 = v5;
  }
  while (v5);
  return result;
}

uint64_t mfs_Viterbi_SelectBestPath(uint64_t a1, int a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD **v19;
  int v20;
  _DWORD *v21;

  v4 = *(_DWORD *)(a1 + 612);
  v5 = *(_DWORD *)(a1 + 616);
  v6 = *(_DWORD *)(a1 + 596);
  if (a2)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 632) + 32 * *(unsigned int *)(a1 + 664) + 24);
    if (v7)
    {
      v8 = a2 - 1;
      do
      {
        *(_DWORD *)v7 |= 0x80000000;
        if (!v8)
          break;
        v7 = *(_QWORD *)(v7 + 8);
        --v8;
      }
      while (v7);
    }
  }
  if (!*(_DWORD *)(a1 + 656))
  {
    *(_DWORD *)(a1 + 656) = 0;
    return 1;
  }
  v9 = 0;
  v10 = 0;
  v11 = v4 + v5 + ~v6 - 1;
  do
  {
    v12 = *(_QWORD *)(a1 + 640);
    v13 = *(unsigned __int16 *)(v12 + 2 * v9);
    if (*(_DWORD *)(a1 + 664) == (_DWORD)v13)
      goto LABEL_11;
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 632) + 32 * v13 + 24);
    if (checkMarkBackTracesAlive(v14))
    {
      v12 = *(_QWORD *)(a1 + 640);
LABEL_11:
      *(_WORD *)(v12 + 2 * v10++) = v13;
      goto LABEL_12;
    }
    v15 = *(_QWORD *)(v14 + 8);
    if (v15)
      mfs_Viterbi_DecrementRefCountCascade(a1, v15, v11);
LABEL_12:
    ++v9;
  }
  while (v9 < *(unsigned int *)(a1 + 656));
  *(_DWORD *)(a1 + 656) = v10;
  if (v10)
  {
    v16 = 0;
    v17 = *(_QWORD *)(a1 + 640);
    v18 = *(_QWORD *)(a1 + 632);
    do
    {
      if (a2)
      {
        v19 = (_DWORD **)(v18 + 32 * *(unsigned __int16 *)(v17 + 2 * v16) + 24);
        v20 = a2;
        do
        {
          v21 = *v19;
          if (!v21)
            break;
          if ((*v21 & 0x80000000) == 0)
            break;
          *v21 &= ~0x80000000;
          v19 = (_DWORD **)(v21 + 2);
          --v20;
        }
        while (v20);
      }
      ++v16;
    }
    while (v16 != v10);
  }
  return 1;
}

uint64_t checkMarkBackTracesAlive(uint64_t result)
{
  _DWORD *v1;

  if (result)
  {
    v1 = (_DWORD *)result;
    if ((*(_DWORD *)result & 0x80000000) == 0)
    {
      result = checkMarkBackTracesAlive(*(_QWORD *)(result + 8));
      if (!(_DWORD)result)
        return result;
      *v1 |= 0x80000000;
    }
    return 1;
  }
  return result;
}

BOOL mfs_Viterbi_CheckRiskForBufferUnderrun(uint64_t *a1, _BOOL8 a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  uint64_t v10;
  const char *v11;

  if (!ForcedEEController_HasStartedPlayback(a2))
    return 0;
  v9 = ForcedEEController_CheckRiskForBufferUnderrun(a2);
  v10 = *a1;
  if (v9)
  {
    MFS__log_out_Event(v10, 27, (uint64_t)"%s%u%s%u%s%u%s%u", v4, v5, v6, v7, v8, "ETIME_PROCESS_START");
    v10 = *a1;
    v11 = "WARNING: RiskForBufferUnderrun at idx %d : %u | %u + %u >= %u (msec since ProcessStart | msec since StartedPla"
          "yback + msec lead >= msec audio)  \n";
  }
  else
  {
    v11 = "No RiskForBufferUnderrun at idx %d : %u | %u + %u < %u (msec since ProcessStart | msec since StartedPlayback +"
          " msec lead < msec audio)  \n";
  }
  MFS__log_select_Diag(v10, 1, (uint64_t)v11);
  return v9;
}

uint64_t mfs_Viterbi_ReadyForEarlyEmission_OnUniquePath(uint64_t a1, unsigned int a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 612);
  v3 = *(_DWORD *)(a1 + 616) + v2;
  v4 = *(_DWORD *)(a1 + 596);
  v5 = v3 + ~v4;
  v6 = v3 <= v4 || (_DWORD)v5 == 0;
  if (v6)
    return 0;
  v7 = *(_DWORD *)(a1 + 608);
  if (v7 >= v5)
    return 0;
  v8 = *(unsigned int *)(a1 + 608);
  while (*(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v8) == 1)
  {
    if (++v8 >= v5)
      goto LABEL_11;
  }
  LODWORD(v5) = v8;
LABEL_11:
  if (v5 <= v7)
    return 0;
  v9 = v5 + v4;
  v10 = 3 * ((v5 + v4) / 3);
  v11 = v10 - a2;
  if (v10 <= a2)
    return 0;
  v12 = 0;
  if (v10 < a2)
    v11 = 0;
  v6 = v4 == v2;
  v13 = 8576;
  if (v6)
    v13 = 8572;
  if (v11 >= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + v13))
  {
    *(_DWORD *)(a1 + 600) = v9;
    *(_DWORD *)(a1 + 604) = v10;
    *(_DWORD *)(a1 + 608) = v5;
    v12 = 1;
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"EarlyEmissionEval3:At utt.state %u we have %u known units (= +%d), %u full segment emittable (vit from %u) emitNow:%d\n");
  }
  return v12;
}

uint64_t mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v25;
  int v26;
  unsigned int v28;

  v3 = 0;
  v28 = 0;
  v4 = *(_DWORD *)(a1 + 612);
  v5 = *(_DWORD *)(a1 + 616);
  v6 = *(_DWORD *)(a1 + 596);
  v7 = v5 + v4 + ~v6;
  if (v5 + v4 > v6 && v7 != 0)
  {
    if ((a3 - 1) > 1
      || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8588) == -1
      || (paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", &v28) & 0x80000000) != 0|| v28 < 2 * *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8588))
    {
      if (a3 == 3)
      {
        v16 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612);
        v18 = v16 != 0;
        v15 = v16 - 1;
        if (!v18)
          v15 = 0;
        if (v15)
          goto LABEL_31;
      }
      else
      {
        if (a3 != 2)
        {
          if (a3 == 1)
          {
            v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8580);
            if (v12 != -1)
            {
              v13 = v5 + v4 - v6;
              while (1)
              {
                v14 = v13 - 2;
                if ((int)(v13 - 2) < 0)
                  break;
                --v13;
                if (v12 >= *(unsigned __int16 *)(*(_QWORD *)(a1 + 584) + 2 * v14))
                {
                  v15 = *(_DWORD *)(a1 + 596) + v13;
                  if (v15)
                    goto LABEL_31;
                  return 0;
                }
              }
            }
          }
          return 0;
        }
        v17 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8584);
        v18 = v17 != -1 && v7 >= v17;
        if (v18)
        {
          v19 = v5 + v4 - v6 - v17;
          do
          {
            v20 = v19;
            if (v19 >= v7)
              break;
            v21 = *(_QWORD *)(a1 + 584);
            v22 = *(unsigned __int16 *)(v21 + 2 * (v19 - 1));
            LODWORD(v21) = *(unsigned __int16 *)(v21 + 2 * v19++);
          }
          while (v22 == (_DWORD)v21);
          v15 = *(_DWORD *)(a1 + 596) + v20;
          if (v15)
          {
LABEL_31:
            v23 = 3 * (v15 / 3);
            if (v23 > a2 && v23 > *(_DWORD *)(a1 + 596))
            {
              v25 = *(_DWORD *)(a1 + 612);
              v26 = *(_DWORD *)(a1 + 616);
              if (v26 + v25 >= v23)
              {
                mfs_Viterbi_SelectBestPath(a1, v25 - v23 + v26);
                *(_DWORD *)(a1 + 600) = v23;
                *(_DWORD *)(a1 + 604) = v23;
                *(_DWORD *)(a1 + 608) = 0;
                v3 = 1;
                MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"WARNING: %s Early Emission at idx %u :  emit from %u to %u (%u states) \n");
                return v3;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return v3;
}

uint64_t mfs_Viterbi_IsEarlyEmissionPossible(uint64_t *a1, _BOOL8 a2, unsigned int a3)
{
  int v5;
  uint64_t v7;

  if (!*(_DWORD *)(*(_QWORD *)(a1[2] + 1072) + 8564))
    return 0;
  if (mfs_Viterbi_CheckRiskForBufferUnderrun(a1, a2))
  {
    v5 = 3;
    return mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, v5);
  }
  v7 = 1;
  if (!mfs_Viterbi_ReadyForEarlyEmission_OnUniquePath((uint64_t)a1, a3)
    && !mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, 1))
  {
    v5 = 2;
    return mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, v5);
  }
  return v7;
}

uint64_t mfs_Viterbi_ResultScore_Obersee(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  const char *v11;
  int v12;
  int v13;
  int v14;

  v4 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612) - 1;
  if (v4 >= *(_DWORD *)(a1 + 596))
  {
    v5 = (_QWORD *)(*(_QWORD *)(a1 + 632) + 32 * *(unsigned int *)(a1 + 664) + 24);
    v6 = *(_QWORD *)(a2 + 8);
    v7 = *(_QWORD *)(a3 + 8);
    do
    {
      v8 = (_DWORD *)*v5;
      v9 = *v8;
      v5 = v8 + 2;
      *(_DWORD *)(v6 + 4 * v4) = v9 & 0x7FFFFFFF;
      *(_DWORD *)(v7 + 4 * v4--) = 0;
    }
    while (v4 >= *(_DWORD *)(a1 + 596));
  }
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8564))
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 2580))
    {
      MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"EarlyEmissionEval1:Subsequent emission:At utt.state %u we can emit %u utt.states (%u more were determined)\n");
      v10 = *(_QWORD *)a1;
      v11 = "EarlyEmissionEval1:Subsequent emission:After first emission of %u, cumulSubseqEmit %u & cumulSubseqCalc %u a"
            "fter emit utt.state %u (deltaBuffer %d)\n";
    }
    else
    {
      *(_DWORD *)(a1 + 768) = *(_DWORD *)(a1 + 604);
      *(_DWORD *)(a1 + 772) = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612);
      v10 = *(_QWORD *)a1;
      v11 = "EarlyEmissionEval1:First emission:At utt.state %u we can emit %u utt.states (%u more were determined)\n";
    }
    MFS__log_select_Diag(v10, 1, (uint64_t)v11);
  }
  v12 = *(_DWORD *)(a1 + 600);
  if (v12)
  {
    v13 = *(_DWORD *)(a1 + 596);
    v14 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612) + ~v13;
    *(_DWORD *)(a1 + 596) = v12;
    *(_DWORD *)(a1 + 600) = 0;
    memmove(*(void **)(a1 + 584), (const void *)(*(_QWORD *)(a1 + 584) + 2 * (v12 - v13)), 2 * (v14 - (v12 - v13)));
    *(_DWORD *)(a1 + 608) = 0;
  }
  return 0;
}

uint64_t mfs_SortIndex_By_PathScore_Obersee(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;

  v3 = *(_QWORD *)(a3 + 632);
  v4 = *(_DWORD *)(v3 + 32 * *a1);
  LODWORD(v3) = *(_DWORD *)(v3 + 32 * *a2);
  v5 = v4 > v3;
  if (v4 >= v3)
    v6 = 0;
  else
    v6 = -1;
  if (v5)
    return 1;
  else
    return v6;
}

uint64_t mfs_SegmentList_Init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = a1;
  *(_QWORD *)(a3 + 8) = a2;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  return 0;
}

_QWORD *mfs_SegmentList_DeInit(_QWORD *result)
{
  _QWORD *v1;

  v1 = result;
  if (result[1])
  {
    result = heap_Free(*(_QWORD **)(*result + 8), result[2]);
    v1[2] = 0;
  }
  *((_DWORD *)v1 + 8) = 0;
  v1[3] = 0;
  return result;
}

uint64_t mfs_SegmentList_AddSeg(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  v4 = *(_DWORD *)(a1 + 24);
  if (v4 < *(_DWORD *)(a1 + 32))
  {
    v5 = *(_QWORD *)(a1 + 16);
LABEL_5:
    result = 0;
    v9 = v5 + 28 * v4;
    *(_DWORD *)v9 = *(_DWORD *)a2;
    *(_BYTE *)(v9 + 4) = *(_BYTE *)(a2 + 4);
    *(_QWORD *)(v9 + 8) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 24) = v4 + 1;
    return result;
  }
  v6 = v4 + 64;
  v7 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 28 * (v4 + 64));
  if (v7)
  {
    v5 = v7;
    *(_QWORD *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 32) = v6;
    v4 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return 2229280778;
}

uint64_t mfs_SegmentList_Add(uint64_t a1, int a2, char a3, int a4, int a5)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;

  v10 = *(_DWORD *)(a1 + 24);
  if (v10 < *(_DWORD *)(a1 + 32))
  {
    v11 = *(_QWORD *)(a1 + 16);
LABEL_5:
    result = 0;
    v15 = v11 + 28 * v10;
    *(_DWORD *)v15 = a2;
    *(_BYTE *)(v15 + 4) = a3;
    *(_DWORD *)(v15 + 8) = a4;
    *(_DWORD *)(v15 + 12) = a5;
    *(_DWORD *)(v15 + 16) = 1;
    *(_DWORD *)(a1 + 24) = v10 + 1;
    return result;
  }
  v12 = v10 + 64;
  v13 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 28 * (v10 + 64));
  if (v13)
  {
    v11 = v13;
    *(_QWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v12;
    v10 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return 2229280778;
}

uint64_t mfs_SegmentList_Merge(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  const float *v27;
  float32x2_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  _DWORD *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  _DWORD *v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  int v59;
  unsigned int v60;
  int v61;
  int v62;
  int *v63;
  _DWORD *v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD v72[2];
  _QWORD *v73;
  _QWORD v74[2];
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v70 = *(_QWORD *)(a4 + 1072);
  v75 = *(_OWORD *)a1;
  v77 = 0;
  v78 = 0;
  v76 = 0;
  if (*((_DWORD *)a1 + 7))
  {
    v9 = 0;
    v10 = 0;
    LODWORD(v11) = 0;
    do
    {
      v12 = a1[2] + v9;
      v13 = *(_DWORD *)(v12 + 16);
      result = mfs_SegmentList_AddSeg((uint64_t)&v75, v12);
      if ((result & 0x80000000) != 0)
        return result;
      v11 = (v13 + v11);
      ++v10;
      v9 += 28;
    }
    while (v10 < *((unsigned int *)a1 + 7));
    v15 = v77;
    v16 = a2;
  }
  else
  {
    v16 = a2;
    result = 2229280775;
    if (!a2)
      return result;
    v60 = *((_DWORD *)a1 + 6);
    if (!v60 || v60 > *(_DWORD *)(a2 + 24))
      return result;
    v15 = 0;
    LODWORD(v10) = 0;
    v11 = 0;
  }
  v17 = *((_DWORD *)a1 + 6);
  v18 = v17 - v10;
  if (v17 <= v10)
    goto LABEL_65;
  v68 = a3;
  v66 = a5;
  v67 = (unsigned __int8 *)a4;
  v19 = 0;
  v69 = 0;
  v20 = v10;
  v21 = 28 * v10;
  v22 = 28 * v11 + 12;
  v23 = -1;
  while (v11 < *(unsigned int *)(v16 + 24))
  {
    v24 = a1[2] + v21;
    if (*(_DWORD *)v24 == -1)
    {
      v26 = *(_QWORD *)(v16 + 16);
      v24 = v26 + 28 * v11;
      v25 = *(_DWORD *)(v26 + v22);
      HIDWORD(v69) += v25;
      LODWORD(v69) = v69 + 1;
    }
    else
    {
      v25 = *(_DWORD *)(v24 + 12);
    }
    if (v20 == *((_DWORD *)a1 + 7))
    {
      result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, *(_BYTE *)(v24 + 4), *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
      if ((result & 0x80000000) != 0)
        return result;
      v23 = *(_DWORD *)v24;
      v27 = (const float *)(v24 + 12);
      v28 = vld1_dup_f32(v27);
      *(float32x2_t *)(v76 + 28 * v15 + 20) = v28;
      v16 = a2;
      goto LABEL_59;
    }
    if (*(_BYTE *)(v24 + 4) != 1
      || (v29 = *(_DWORD *)a1[1], *(_DWORD *)(v70 + 8256)) && (v11 % v29 || *(_DWORD *)v24 != -1))
    {
      v74[0] = 0;
      v74[1] = 0;
      v73 = v74;
      if (*(_DWORD *)(v70 + 8328))
      {
        memset(v72, 0, sizeof(v72));
        v30 = *(_DWORD *)v24;
        if (v23 == -1)
        {
          if (v30 == -1)
            goto LABEL_35;
        }
        else if (v30 != -1)
        {
          result = mfs_getUnitData_Obersee((uint64_t)v67, v66, v23, (uint64_t)v72);
          if ((result & 0x80000000) != 0)
            return result;
          v16 = a2;
          if (DWORD1(v72[0]) == *(_DWORD *)v24)
          {
LABEL_35:
            v31 = v76;
            v32 = v15;
            v36 = *(_DWORD *)(v76 + 28 * v15 + 12);
LABEL_36:
            v47 = v31 + 28 * v32;
            v48 = v36 + *(_DWORD *)(v24 + 12);
            v51 = *(_DWORD *)(v47 + 16);
            v50 = (_DWORD *)(v47 + 16);
            v49 = v51;
            *(v50 - 1) = v48;
            if (v51 >= 1)
              *(_DWORD *)(v31 + 28 * v32 + 24) = *(_DWORD *)(v24 + 12);
            *v50 = v49 + 1;
            v23 = *(_DWORD *)v24;
            goto LABEL_59;
          }
        }
        goto LABEL_53;
      }
      if (!v68)
      {
        v31 = v76;
        v32 = v15;
        v33 = v76 + 28 * v15;
        v35 = *(_DWORD *)(v33 + 8);
        v34 = (_DWORD *)(v33 + 8);
        v36 = v34[1];
        v37 = v36 + v35;
        v38 = *(_DWORD *)(v24 + 8);
        if (v36 + v35 == v38)
        {
          v39 = *(_DWORD *)(v76 + 28 * v15);
          if (v39 != -1 && *(_DWORD *)v24 != -1)
          {
            v65 = v76;
            v63 = v34 + 1;
            v64 = v34;
            mfs_getUnitDataFromMfsData(v67, v39, (uint64_t *)&v73);
            v62 = *((unsigned __int16 *)v73 + 5);
            mfs_getUnitDataFromMfsData(v67, *(_DWORD *)v24, (uint64_t *)&v73);
            v40 = v62;
            v32 = v15;
            v31 = v65;
            v16 = a2;
            v41 = *((unsigned __int16 *)v73 + 5);
            v36 = *v63;
            v38 = *(_DWORD *)(v24 + 8);
            v37 = *v63 + *v64;
            goto LABEL_43;
          }
          v41 = 0;
          v40 = 0;
LABEL_49:
          v55 = *(_DWORD *)(v31 + 28 * v32);
          if (v55 == *(_DWORD *)v24 || v55 != -1 && *(_DWORD *)v24 != -1 && v40 == v41)
            goto LABEL_36;
        }
        else
        {
          v40 = 0;
          v41 = 0;
LABEL_43:
          if (v37 == v38)
            goto LABEL_49;
        }
      }
LABEL_53:
      result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, *(_BYTE *)(v24 + 4), *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
      if ((result & 0x80000000) != 0)
        return result;
      v23 = *(_DWORD *)v24;
      v56 = v15 + 1;
      v15 = v56;
      v57 = v76;
      v58 = *(_DWORD *)(v76 + 28 * v56 + 16);
      v16 = a2;
      if (v58 == 1)
      {
        v59 = *(_DWORD *)(v24 + 12);
        *(_DWORD *)(v76 + 28 * v56 + 20) = v59;
LABEL_58:
        *(_DWORD *)(v57 + 28 * v56 + 24) = v59;
        goto LABEL_59;
      }
      if (v58 >= 1)
      {
        v59 = *(_DWORD *)(v24 + 12);
        goto LABEL_58;
      }
      goto LABEL_59;
    }
    if (v11 % v29)
    {
      v42 = v76;
      v43 = v76 + 28 * v15;
      v46 = *(_DWORD *)(v43 + 16);
      v44 = (_DWORD *)(v43 + 16);
      v45 = v46;
      *(v44 - 1) += *(_DWORD *)(v24 + 12);
      if (v46 >= 1)
        *(_DWORD *)(v42 + 28 * v15 + 24) = *(_DWORD *)(v24 + 12);
      *v44 = v45 + 1;
      goto LABEL_59;
    }
    result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, 1, *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
    if ((result & 0x80000000) != 0)
      return result;
    v23 = *(_DWORD *)v24;
    ++v15;
    v52 = v76;
    v53 = *(_DWORD *)(v76 + 28 * v15 + 16);
    v16 = a2;
    if (v53 == 1)
    {
      v54 = *(_DWORD *)(v24 + 12);
      *(_DWORD *)(v76 + 28 * v15 + 20) = v54;
LABEL_47:
      *(_DWORD *)(v52 + 28 * v15 + 24) = v54;
      goto LABEL_59;
    }
    if (v53 >= 1)
    {
      v54 = *(_DWORD *)(v24 + 12);
      goto LABEL_47;
    }
LABEL_59:
    v19 += v25;
    ++v20;
    ++v11;
    v21 += 28;
    v22 += 28;
    if (!--v18)
      break;
  }
  v15 = v77;
LABEL_65:
  heap_Free(*(_QWORD **)(*a1 + 8), a1[2]);
  a1[2] = v76;
  v61 = v78;
  *((_DWORD *)a1 + 7) = v15;
  *((_DWORD *)a1 + 8) = v61;
  *((_DWORD *)a1 + 6) = v15;
  MFS__log_select_Diag(*a1, 1, (uint64_t)"hybrid at %1.0f %% parameteric states at %1.0f %% dur\n");
  return 0;
}

uint64_t mfs_SegmentList_Get(uint64_t a1, unsigned int a2, _DWORD *a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  uint64_t result;
  uint64_t v10;
  _DWORD *v11;

  if (a1 && *(_DWORD *)(a1 + 24) > a2)
  {
    result = 0;
    v10 = *(_QWORD *)(a1 + 16) + 28 * a2;
    *a3 = *(_DWORD *)v10;
    *a4 = *(_BYTE *)(v10 + 4);
    v11 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 28 * a2);
    *a5 = v11[2];
    *a6 = v11[3];
    *a7 = v11[5];
    *a8 = v11[6];
  }
  else
  {
    *a3 = 0;
    *a4 = 0;
    *a6 = 0;
    result = 2229280775;
    *a5 = 0;
  }
  return result;
}

uint64_t mfs_InitHashTable(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  unsigned int v10;
  uint64_t v11;
  int v12;
  void *v13;

  if (!a1 || !a2 || !a4)
  {
    MFS__log_select_Diag(a1, 1, (uint64_t)"\n");
    return 0;
  }
  v5 = *(_DWORD *)(a3 + 25140);
  if ((v5 & 0xFFFFFFFE) != 2)
  {
    if (v5 == 1 && a2[541] == 256 && a2[537] == 512)
    {
      v10 = 1;
      *(_DWORD *)(a4 + 2064) = 1;
      v11 = a2[274];
      v12 = 32;
      do
      {
        if (v11 <= v10)
          break;
        v10 *= 2;
        --v12;
      }
      while (v12);
      *(_DWORD *)(a4 + 2060) = v10 - 1;
      *(_DWORD *)(a4 + 2056) = v11;
      v13 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), v11, 8);
      *(_QWORD *)(a4 + 2048) = v13;
      if (v13)
        goto LABEL_21;
      return 2229280778;
    }
LABEL_20:
    *(_DWORD *)(a4 + 2064) = 0;
    *(_QWORD *)(a4 + 2056) = 0x1FFFF00020000;
    v13 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), 0x20000, 8);
    *(_QWORD *)(a4 + 2032) = v13;
    if (v13)
    {
LABEL_21:
      bzero(v13, 8 * *(unsigned int *)(a4 + 2056));
      return 0;
    }
    return 2229280778;
  }
  if (a2[541] != 256 || a2[537] != 512)
    goto LABEL_20;
  *(_DWORD *)(a4 + 2064) = 2;
  v6 = a2[274];
  v7 = 1;
  v8 = 32;
  do
  {
    if (v6 <= v7)
      break;
    v7 *= 2;
    --v8;
  }
  while (v8);
  result = 0;
  *(_DWORD *)(a4 + 2060) = v7 - 1;
  *(_DWORD *)(a4 + 2056) = v6;
  return result;
}

uint64_t mfs_DeInitHashTable(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  _QWORD *v5;

  v3 = *(_DWORD *)(a2 + 2064);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      v4 = *(_QWORD *)(a2 + 2048);
      if (v4)
      {
        v5 = (_QWORD *)(a2 + 2048);
LABEL_7:
        heap_Free(*(_QWORD **)(a1 + 8), v4);
        *v5 = 0;
      }
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 2032);
      if (v4)
      {
        v5 = (_QWORD *)(a2 + 2032);
        goto LABEL_7;
      }
    }
  }
  *(_DWORD *)(a2 + 2056) = 0;
  return 0;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  int v26;
  float v27;
  signed int v28;
  uint64_t v29;
  uint64_t AcousticVector;
  unsigned int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  _DWORD *v42;
  float v43;
  float v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  float v49;
  int LeafIndex;
  int v51;
  float v52;
  BOOL v53;
  float v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  int *v61;
  uint64_t v62;
  int v63;
  const char *v64;
  unsigned __int8 *v66;
  int v67;
  unsigned __int8 v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _DWORD *v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  _QWORD *v86;
  _QWORD v87[2];
  _OWORD v88[9];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  _QWORD v94[3];
  __int16 v95;
  char v96;
  _BYTE v97[80];
  float v98[4];
  _DWORD v99[44];
  __int128 v100;
  uint64_t v101;

  v4 = a2;
  v101 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a2 + 1928);
  v96 = 0;
  v95 = 0;
  memset(v94, 0, sizeof(v94));
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v89 = 0u;
  memset(v88, 0, sizeof(v88));
  v7 = *(float *)(a3 + 8972);
  v100 = 0u;
  memset(v99, 0, sizeof(v99));
  v87[0] = 0;
  v87[1] = 0;
  v86 = v87;
  *(_QWORD *)(a2 + 2192) = 0;
  UNICORN__mfs_S32Vect_Init(v6, v94);
  v84 = v6;
  mfs_TCost_Init(v6, a3, (uint64_t)v88);
  v8 = *(float *)(a3 + 8180);
  v83 = *((_QWORD *)a1 + 1516);
  v9 = a1[610];
  if ((int)v9 < 1)
  {
    v11 = 0;
  }
  else
  {
    v10 = 0;
    while (*(_BYTE *)(*((_QWORD *)a1 + 307) + v10) != 31)
    {
      if (v9 == ++v10)
        goto LABEL_9;
    }
    v11 = v10;
  }
  if (v11 == (_DWORD)v9)
  {
LABEL_9:
    MFS__log_select_Diag(v6, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
    v11 = 0;
  }
  v80 = a3;
  MFS__log_select_Diag(v6, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
  if (*(int *)(v4 + 608) < 1)
  {
    v14 = 0;
    v19 = a3;
LABEL_67:
    if (*(_DWORD *)(v19 + 8564) == 1)
    {
      v54 = *(float *)(v4 + 2616);
      if (v54 == 0.0)
      {
        v64 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(v4 + 2608) = (int)((double)*(int *)(v4 + 2604) / (v54 * 0.8 + 1.0));
        MFS__log_select_Diag(v84, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v55 = *(unsigned int *)(v4 + 608);
        v56 = *(_DWORD *)(v4 + 2596);
        if ((int)v55 >= 2)
        {
          v57 = 0;
          v58 = 1;
          v59 = *(_DWORD *)(v4 + 2596);
          do
          {
            if (v59)
              break;
            v60 = *a1;
            if ((int)*a1 >= 1)
            {
              v61 = (int *)(*(_QWORD *)(*(_QWORD *)(v4 + 600) + 528 * v58 + 16) + 8);
              v62 = *a1;
              do
              {
                v63 = *v61++;
                v57 += v63 * *(_DWORD *)(v19 + 24);
                --v62;
              }
              while (v62);
            }
            ++v58;
            if (v57 >= *(_DWORD *)(v4 + 2608))
            {
              v56 = v60 * v58;
              *(_DWORD *)(v4 + 2596) = v60 * v58;
              v59 = v60 * v58;
            }
            else
            {
              v59 = 0;
            }
          }
          while (v58 != v55);
        }
        if (!v56)
          goto LABEL_85;
        v64 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v64 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v84, 1, (uint64_t)v64);
LABEL_85:
    *(_DWORD *)(v4 + 2200) = 0;
    goto LABEL_86;
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = (_QWORD *)(v4 + 1944);
  v16 = v7 * 0.5;
  v17 = 1.0 - v8;
  v67 = v11;
  v18 = (unsigned __int8 *)&v99[1] + v11;
  v19 = a3;
  v75 = (_DWORD *)(a3 + 25288);
  v72 = v4 + 1944;
  v73 = v4;
  v66 = v18;
  while (1)
  {
    v70 = v12;
    v20 = *(_QWORD *)(v4 + 600);
    MFS__log_select_Diag(v84, 3, (uint64_t)"phoneme %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v99, *(_QWORD *)(v4 + 8), v12);
    MFS__log_select_Diag(v84, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
    v68 = *v18;
    UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(v4 + 8), v12, &v95);
    mfs_Ling_LogPhonCtxt(v84, v19, *(_QWORD *)(v4 + 8), v12);
    if ((int)*a1 >= 1)
      break;
LABEL_64:
    ++v12;
    v19 = v80;
    if (v12 >= *(int *)(v4 + 608))
      goto LABEL_67;
  }
  v82 = v20 + 528 * v12;
  v21 = (uint64_t *)(v82 + 16);
  v69 = (_QWORD *)(v82 + 312);
  v71 = (_QWORD *)(v82 + 80);
  v22 = v13;
  v78 = 2488;
  v77 = 2640;
  v23 = 2;
  v24 = (_DWORD *)v80;
  while (1)
  {
    v79 = v22;
    if (v12)
    {
      v25 = *v21;
      v26 = v67;
      if (v12 != *(_DWORD *)(v4 + 608) - 1)
        *(_DWORD *)(v4 + 2604) += *(_DWORD *)(v25 + 4 * v23) * v24[6];
    }
    else
    {
      v25 = *v21;
      v26 = v67;
    }
    v14 = mfs_FillTgtVect((uint64_t)v24, v4, (uint64_t)v88, *(_DWORD *)(v25 + 4 * v23));
    if ((v14 & 0x80000000) != 0)
      break;
    if ((*(_BYTE *)(*v69 + v23) & 4) != 0)
      v27 = 2.0;
    else
      v27 = 1.0;
    v28 = v24[2056];
    if (HIBYTE(v95) != 1
      || *(_DWORD *)(v80 + 8256) && (v12 && v23 == 2 || v23 == *a1 + 1 && v12 != *(_DWORD *)(v4 + 608) - 1))
    {
      v29 = mfs_VennDiaGrams_Tahoe(v84, (uint64_t)a1, v80, 1, v23, (uint64_t)&v95, *(_DWORD *)(*v71 + 4 * v23), *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16), v27, v28, v15, v79, v68, v26);
      if ((v29 & 0x80000000) != 0)
        return v29;
      if ((*(_BYTE *)(*v69 + v23) & 4) != 0)
      {
        AcousticVector = mfs_VennDiaGrams_Tahoe(v84, (uint64_t)a1, v80, 2, v23, (uint64_t)&v95, *(_DWORD *)(*(_QWORD *)(v82 + 88) + 4 * v23), *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16), v27, v28, v15, v79, v68, v26);
        if ((AcousticVector & 0x80000000) != 0)
          goto LABEL_81;
      }
      v14 = mfs_VennDiaGrams_Tahoe(v84, (uint64_t)a1, v80, 0, v23, (uint64_t)&v95, *(_DWORD *)(v82 + 8), *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16), v27, v28, v15, v79, v68, v26);
      if ((v14 & 0x80000000) != 0)
        break;
    }
    v31 = *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16);
    if (v31 < 0x33)
    {
      v76 = v14;
      v32 = v79;
      v24 = (_DWORD *)v80;
      if (v31)
        goto LABEL_41;
    }
    else
    {
      v32 = v79;
      v33 = (int)(float)(*(float *)(v80 + 8232) * (float)v31);
      if (v28 < v33)
        v33 = v28;
      v24 = (_DWORD *)v80;
      if (v33 <= 50)
        v34 = 50;
      else
        v34 = v33;
      if (v31 == v34)
        goto LABEL_41;
      MFS__log_select_Diag(v84, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
      v35 = mfs_CostList_Sort((uint64_t)v15, v79, 1);
      v14 = v35;
      if ((v35 & 0x80000000) != 0)
        break;
      v76 = v35;
      mfs_CostList_Prune(v15, v79, v34);
      v31 = *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16);
      v32 = v79;
      if (v31)
      {
LABEL_41:
        v36 = 0;
        v37 = v24[2240];
        v74 = v31;
        while (1)
        {
          v85 = 0;
          memset(v97, 0, sizeof(v97));
          v38 = 32 * v32;
          v81 = v36;
          v39 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v32) + 8 * v36);
          AcousticVector = mfs_ParamMap_GetAcousticVector(v84, (uint64_t)a1, v4, v39, (uint64_t)v97, &v85);
          if ((AcousticVector & 0x80000000) != 0)
            break;
          if ((int)v89 <= v85)
            v40 = v85;
          else
            v40 = v89;
          LODWORD(v91) = v40;
          v14 = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v90, v40);
          if ((v14 & 0x80000000) != 0)
            return v14;
          if (*v75)
          {
            v14 = mfs_TCost_CandidateCostStream_kld((uint64_t)v88, (uint64_t)a1, v80, v84, (uint64_t)v97, v85, v39, *(unsigned int *)(*v71 + 4 * v23), v23, (uint64_t)v98);
            if ((v14 & 0x80000000) != 0)
              goto LABEL_86;
          }
          else
          {
            mfs_TCost_CandidateCostStream_Faster((uint64_t)v88, v80, (uint64_t)v97, v85, (uint64_t)v98);
          }
          v76 = v14;
          v41 = *(_QWORD *)(*(_QWORD *)(v4 + 1952) + v38) + 8 * v81;
          v43 = *(float *)(v41 + 4);
          v42 = (_DWORD *)(v41 + 4);
          v44 = v43;
          if (v43 < 0.0)
          {
            *v42 = 0;
            v44 = 0.0;
          }
          v45 = 0;
          v46 = 0.0;
          v48 = v77;
          v47 = v78;
          v24 = (_DWORD *)v80;
          do
          {
            *((_QWORD *)&v100 + 1) = *(_QWORD *)((char *)a1 + v48);
            v99[0] = *(unsigned int *)((char *)a1 + v47);
            v49 = mfs_symData_DistanceOnUid(v84, (uint64_t)a1, v80, (uint64_t)v99, *a1, v39, v23, HIBYTE(v95));
            LeafIndex = mfs_GetLeafIndex(v82, v45, v23);
            if (v83)
            {
              v51 = LeafIndex;
              mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v39, (uint64_t *)&v86);
              v52 = (float)(v8 * v98[v45])
                  + (float)((float)(v17 * v49)
                          * (float)((float)(mfs_symData_GenreDivergence((uint64_t)a1, v45, v23, v51, v37, *((unsigned __int16 *)v86 + 5))* *(float *)(v80 + 8964))+ 1.0));
            }
            else
            {
              v52 = (float)(v8 * v98[v45]) + (float)(v17 * v49);
            }
            v46 = v46 + v52;
            ++v45;
            v48 += 72;
            v47 += 36;
          }
          while (v45 != 3);
          v4 = v73;
          mfs_ParamMap_UnMapSection(v73);
          v15 = (_QWORD *)v72;
          v32 = v79;
          mfs_CostList_UpdateCost(v72, v79, v81, (float)((float)(v44 * v16) + 1.0) * v46);
          v36 = v81 + 1;
          if (v81 + 1 == v74)
            goto LABEL_59;
        }
LABEL_81:
        v14 = AcousticVector;
        break;
      }
    }
LABEL_59:
    v22 = v32 + 1;
    v77 += 8;
    v78 += 4;
    v53 = v23++ <= (int)*a1;
    v12 = v70;
    v21 = (uint64_t *)(v82 + 16);
    if (!v53)
    {
      v13 = v22;
      v18 = v66;
      v14 = v76;
      goto LABEL_64;
    }
  }
LABEL_86:
  UNICORN__mfs_S32Vect_Clear(v94);
  mfs_TCost_Clear(v88);
  return v14;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_Tahoe(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v7;
  int v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t *v25;
  unsigned int v26;
  uint64_t v27;
  signed int v28;
  unsigned int AcousticVector;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unsigned int CandVector;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  int IsNodeInList;
  int v51;
  _DWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  signed int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  float v75;
  float v76;
  uint64_t v77;
  float v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  float v93;
  uint64_t v94;
  int v95;
  int v96;
  uint64_t v97;
  int v98;
  int v99;
  int *v100;
  uint64_t v101;
  int v102;
  const char *v103;
  uint64_t v105;
  unsigned __int8 *v106;
  uint64_t v107;
  int *v108;
  int v109;
  int *v110;
  _QWORD *v111;
  unsigned int v112;
  _QWORD *v113;
  _QWORD *v114;
  unsigned int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _DWORD *v119;
  int *v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  _QWORD *v128;
  int v129;
  unsigned __int8 v130;
  _QWORD *v131;
  int v132;
  uint64_t v133;
  unsigned int v134;
  int v135;
  signed int v136;
  _QWORD *v137;
  uint64_t v138;
  uint64_t v139;
  _OWORD v140[2];
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  _QWORD v153[3];
  __int16 v154;
  unsigned __int8 v155;
  uint64_t v156[2];
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  int v168;
  _DWORD v169[3];
  _BYTE v170[1024];
  float v171[256];
  _DWORD v172[44];
  __int128 v173;
  uint64_t v174;

  v174 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 1928);
  if (*a1 != 3)
  {
    MFS__log_select_Diag(*(_QWORD *)(a2 + 1928), 1, (uint64_t)"CONFIG ERROR : Search is implemented for 3 states only\n");
    return -2065686262;
  }
  v4 = a3;
  v5 = a2;
  v7 = *(float *)(a3 + 8972);
  v155 = 0;
  v154 = 0;
  memset(v153, 0, sizeof(v153));
  memset(v140, 0, sizeof(v140));
  v141 = 0u;
  v142 = 0u;
  v143 = 0u;
  v144 = 0u;
  v145 = 0u;
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  v151 = 0u;
  v152 = 0u;
  v173 = 0u;
  memset(v172, 0, sizeof(v172));
  bzero(v171, 0x400uLL);
  bzero(v170, 0x400uLL);
  *(_QWORD *)(v5 + 2192) = 0;
  UNICORN__mfs_S32Vect_Init(v3, v153);
  mfs_TCost_Init(v3, v4, (uint64_t)v140);
  v8 = 0;
  v9 = *(float *)(v4 + 8180);
  if (*(_DWORD *)(v4 + 8356) == 1)
  {
    v10 = a1[610];
    if ((int)v10 < 1)
    {
      v8 = 0;
    }
    else
    {
      v11 = 0;
      while (*(_BYTE *)(*((_QWORD *)a1 + 307) + v11) != 31)
      {
        if (v10 == ++v11)
          goto LABEL_12;
      }
      v8 = v11;
    }
    if (v8 == (_DWORD)v10)
    {
LABEL_12:
      MFS__log_select_Diag(v3, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
      v8 = 0;
    }
    MFS__log_select_Diag(v3, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
  }
  if (*(int *)(v5 + 608) < 1)
  {
    v134 = 0;
LABEL_166:
    if (*(_DWORD *)(v4 + 8564) == 1)
    {
      v93 = *(float *)(v5 + 2616);
      if (v93 == 0.0)
      {
        v103 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(v5 + 2608) = (int)((double)*(int *)(v5 + 2604) / (v93 * 0.8 + 1.0));
        MFS__log_select_Diag(v3, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v94 = *(unsigned int *)(v5 + 608);
        v95 = *(_DWORD *)(v5 + 2596);
        if ((int)v94 >= 2)
        {
          v96 = 0;
          v97 = 1;
          v98 = *(_DWORD *)(v5 + 2596);
          do
          {
            if (v98)
              break;
            v99 = *a1;
            if ((int)*a1 >= 1)
            {
              v100 = (int *)(*(_QWORD *)(*(_QWORD *)(v5 + 600) + 528 * v97 + 16) + 8);
              v101 = *a1;
              do
              {
                v102 = *v100++;
                v96 += v102 * *(_DWORD *)(v4 + 24);
                --v101;
              }
              while (v101);
            }
            ++v97;
            if (v96 >= *(_DWORD *)(v5 + 2608))
            {
              v95 = v99 * v97;
              *(_DWORD *)(v5 + 2596) = v99 * v97;
              v98 = v99 * v97;
            }
            else
            {
              v98 = 0;
            }
          }
          while (v97 != v94);
        }
        if (!v95)
          goto LABEL_185;
        v103 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v103 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v3, 1, (uint64_t)v103);
LABEL_185:
    *(_DWORD *)(v5 + 2200) = 0;
    goto LABEL_186;
  }
  v12 = 0;
  v134 = 0;
  v130 = 0;
  v109 = 0;
  v137 = (_QWORD *)(v5 + 1944);
  v13 = v7 * 0.5;
  v105 = 0;
  v106 = (unsigned __int8 *)&v172[1] + v8;
  v14 = (_QWORD *)(v5 + 1968);
  v119 = (_DWORD *)(v4 + 25288);
  v138 = v5;
  v128 = (_QWORD *)(v5 + 1968);
  v129 = v8;
  v117 = v4;
  v118 = v3;
  while (1)
  {
    v15 = *(_QWORD *)(v5 + 600);
    MFS__log_select_Diag(v3, 3, (uint64_t)"phoneme %d %d %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v172, *(_QWORD *)(v5 + 8), v12);
    if (*(_DWORD *)(v4 + 8356) == 1)
    {
      MFS__log_select_Diag(v3, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
      v130 = *v106;
      v14 = v128;
    }
    UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(v5 + 8), v12, &v154);
    mfs_Ling_LogPhonCtxt(v3, v4, *(_QWORD *)(v5 + 8), v12);
    LODWORD(v16) = *a1;
    if ((int)*a1 >= 1)
    {
      v17 = 0;
      v18 = v15 + 528 * v12;
      v131 = (_QWORD *)(v18 + 312);
      v111 = (_QWORD *)(v18 + 88);
      v114 = (_QWORD *)(v18 + 16);
      v120 = (int *)(v18 + 8);
      v123 = (_QWORD *)(v18 + 80);
      v19 = (32 * v109) | 0x10;
      while (1)
      {
        v20 = v17;
        if (v12 && v12 != *(_DWORD *)(v138 + 608) - 1)
          *(_DWORD *)(v138 + 2604) += *(_DWORD *)(*v114 + 4 * v17 + 8) * *(_DWORD *)(v4 + 24);
        if ((*(_BYTE *)(*v131 + v17 + 2) & 4) != 0)
          v21 = 2.0;
        else
          v21 = 1.0;
        v136 = *(_DWORD *)(v4 + 8224);
        v169[v17] = 0;
        if (HIBYTE(v154) != 1)
        {
LABEL_38:
          v23 = v12;
          v24 = *(_DWORD *)(*(_QWORD *)(v138 + 1952) + v19);
          v25 = *(uint64_t **)(v138 + 2640);
          if (!v25
            || (v26 = v109 + v20 + *((_DWORD *)v25 + 5), LODWORD(v157) = 0, v27 = *v25, *(_DWORD *)(v27 + 48 * v26))
            || (v30 = *(_DWORD *)(v27 + 48 * v26 + 24)) == 0
            || (v31 = *(_DWORD *)(*(_QWORD *)(v27 + 48 * v26 + 8) + 4 * (v30 - 1)), v31 >= a1[274] - 1)
            || (v32 = mfs_CostList_Add((uint64_t)a1, v137, v109 + (int)v20, v31, *((_QWORD *)a1 + 298), a1[598], (unsigned int *)&v157, v21), (v32 & 0x80000000) != 0))
          {
            v28 = v109 + v20;
            AcousticVector = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 1, (int)v20 + 2, (uint64_t)&v154, *(_DWORD *)(*v123 + 4 * v20 + 8), v24, v21, v136, v137, v109 + (int)v20, v130, v129);
            if ((AcousticVector & 0x80000000) != 0
              || (*(_BYTE *)(*v131 + v20 + 2) & 4) != 0
              && (AcousticVector = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 2, (int)v20 + 2, (uint64_t)&v154, *(_DWORD *)(*v111 + 4 * v20 + 8), *(_DWORD *)(*(_QWORD *)(v138 + 1952) + v19), v21, v136, v137, v28, v130, v129), (AcousticVector & 0x80000000) != 0))
            {
LABEL_180:
              v134 = AcousticVector;
              goto LABEL_186;
            }
            v12 = v23;
            v134 = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 0, (int)v20 + 2, (uint64_t)&v154, *v120, *(_DWORD *)(*(_QWORD *)(v138 + 1952) + v19), v21, v136, v137, v28, v130, v129);
            if ((v134 & 0x80000000) != 0)
              goto LABEL_186;
          }
          else
          {
            v134 = v32;
            v169[v20] = 1;
            v12 = v23;
          }
          goto LABEL_44;
        }
        if (v17 != 1 && *(_DWORD *)(v4 + 8256))
        {
          if (v17)
          {
            if (v17 + 2 != (_DWORD)v16 + 1)
              goto LABEL_38;
            if (v12 == *(_DWORD *)(v138 + 608) - 1 || v155 == 1)
              goto LABEL_44;
            v22 = v154;
          }
          else
          {
            if (!v12 || v154 == 1)
              goto LABEL_44;
            v22 = v155;
          }
          if (v22 != 1)
            goto LABEL_38;
        }
LABEL_44:
        v16 = (int)*a1;
        v19 += 32;
        v17 = v20 + 1;
        if (v20 + 2 > v16)
        {
          v109 += v17;
          v5 = v138;
          v14 = v128;
          goto LABEL_51;
        }
      }
    }
    v136 = *(_DWORD *)(v4 + 8224);
LABEL_51:
    v107 = v12;
    if (HIBYTE(v154) != 1)
    {
      if ((int)v16 >= -1)
        v33 = v16 + 1;
      else
        v33 = v16 + 2;
      v34 = (v109 - (v33 >> 1));
      v139 = 0;
      v35 = *(_QWORD *)(v5 + 1976);
      *(_DWORD *)(v35 + 208) = 0;
      *(_DWORD *)(v35 + 240) = 0;
      v36 = (v34 - 1);
      v37 = (v34 + 1);
      v38 = *(_QWORD *)(v5 + 1952);
      v39 = *(unsigned int *)(v38 + 32 * v34 + 16);
      v40 = v36;
      v121 = v34;
      v124 = v37;
      if ((_DWORD)v39)
      {
        v41 = 0;
        v135 = v169[0];
        v132 = v169[2];
        v115 = *(_DWORD *)(v38 + 32 * v37 + 16);
        v112 = *(_DWORD *)(v38 + 32 * v36 + 16);
        v126 = 8 * v39;
        while (1)
        {
          v168 = 0;
          v166 = 0u;
          v167 = 0u;
          v164 = 0u;
          v165 = 0u;
          v162 = 0u;
          v163 = 0u;
          v160 = 0u;
          v161 = 0u;
          v158 = 0u;
          v159 = 0u;
          v157 = 0u;
          v156[0] = (uint64_t)&v157;
          v42 = *(_QWORD *)(v5 + 1952);
          v43 = 32 * v34;
          v44 = *(_DWORD *)(*(_QWORD *)(v42 + 32 * v34) + v41);
          CandVector = mfs_symData_GetCandVector(v3, (uint64_t)a1, v4, *a1, v44, 3, v156);
          v46 = CandVector;
          if ((CandVector & 0x80000000) != 0)
          {
            v134 = CandVector;
            goto LABEL_186;
          }
          if (v135)
            goto LABEL_64;
          v47 = CandVector;
          if ((v112 < 0x64 || *(unsigned __int8 *)v156[0] == v154)
            && !mfs_CostList_IsNodeInList((uint64_t)v137, v36, v44 - 1, (uint64_t)a1, (unsigned int *)&v139))
          {
            if (!mfs_CostList_IsNodeInList((uint64_t)v128, 0, v44 - 1, (uint64_t)a1, (unsigned int *)&v139))
            {
              IsNodeInList = mfs_CostList_IsNodeInList((uint64_t)v128, 1u, v44 - 1, (uint64_t)a1, (unsigned int *)&v139);
              v46 = v47;
              v36 = v40;
              v34 = v121;
              if (!IsNodeInList)
                v46 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v44 - 1, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v138 + 1952) + v43) + v41 + 4));
              goto LABEL_64;
            }
            v46 = v47;
            v36 = v40;
          }
          else
          {
            v46 = v47;
          }
          v34 = v121;
LABEL_64:
          if (!v132)
          {
            v48 = v46;
            if ((v115 < 0x64 || *(unsigned __int8 *)(v156[0] + 2) == v155)
              && (v49 = v44 + 1,
                  !mfs_CostList_IsNodeInList((uint64_t)v137, v124, v49, (uint64_t)a1, (unsigned int *)&v139)))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 4u, v49, (uint64_t)a1, (unsigned int *)&v139))
              {
                v46 = v48;
                v36 = v40;
              }
              else
              {
                v51 = mfs_CostList_IsNodeInList((uint64_t)v128, 5u, v49, (uint64_t)a1, (unsigned int *)&v139);
                v46 = v48;
                v36 = v40;
                if (!v51)
                  v46 = mfs_CostList_Pad((uint64_t)a1, v128, 7u, v49, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v138 + 1952) + v43) + v41 + 4));
              }
            }
            else
            {
              v46 = v48;
            }
          }
          v41 += 8;
          v5 = v138;
          if (v126 == v41)
          {
            v134 = v46;
            v35 = *(_QWORD *)(v138 + 1976);
            if (*(_DWORD *)(v35 + 208))
            {
              v14 = v128;
              mfs_ConcatTwoLists(v128, 1u, (uint64_t)v128, 6u);
              v35 = *(_QWORD *)(v138 + 1976);
              v12 = v107;
            }
            else
            {
              v12 = v107;
              v14 = v128;
            }
            v37 = v124;
            break;
          }
        }
      }
      if (*(_DWORD *)(v35 + 240))
      {
        mfs_ConcatTwoLists(v14, 5u, (uint64_t)v14, 7u);
        v37 = v124;
        v35 = *(_QWORD *)(v5 + 1976);
      }
      LODWORD(v139) = 0;
      *(_DWORD *)(v35 + 208) = 0;
      v52 = (_DWORD *)(v35 + 208);
      if (v169[1])
      {
        *v52 = 0;
      }
      else
      {
        v82 = *(unsigned int *)(*(_QWORD *)(v5 + 1952) + 32 * v36 + 16);
        if ((_DWORD)v82)
        {
          v83 = 0;
          v84 = 8 * v82;
          do
          {
            v85 = 32 * v36;
            v86 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + v85) + v83) + 1;
            if (!mfs_CostList_IsNodeInList((uint64_t)v137, v34, v86, (uint64_t)a1, (unsigned int *)&v139))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 2u, v86, (uint64_t)a1, (unsigned int *)&v139))
              {
                LODWORD(v34) = v121;
              }
              else
              {
                LODWORD(v34) = v121;
                if (!mfs_CostList_IsNodeInList((uint64_t)v128, 3u, v86, (uint64_t)a1, (unsigned int *)&v139))v134 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v86, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + v85) + v83 + 4) * 20.0);
              }
            }
            v83 += 8;
            v36 = v40;
          }
          while (v84 != v83);
          v87 = *(_QWORD *)(v5 + 1976);
          if (*(_DWORD *)(v87 + 208))
          {
            v14 = v128;
            mfs_ConcatTwoLists(v128, 3u, (uint64_t)v128, 6u);
            v87 = *(_QWORD *)(v5 + 1976);
            v12 = v107;
          }
          else
          {
            v12 = v107;
            v14 = v128;
          }
          LODWORD(v139) = 0;
          v52 = (_DWORD *)(v87 + 208);
          v37 = v124;
        }
        *v52 = 0;
        v88 = *(unsigned int *)(*(_QWORD *)(v5 + 1952) + 32 * v37 + 16);
        if ((_DWORD)v88)
        {
          v89 = 0;
          v90 = 8 * v88;
          do
          {
            v91 = 32 * v37;
            v92 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v37) + v89) - 1;
            if (!mfs_CostList_IsNodeInList((uint64_t)v137, v34, v92, (uint64_t)a1, (unsigned int *)&v139))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 2u, v92, (uint64_t)a1, (unsigned int *)&v139))
              {
                LODWORD(v34) = v121;
              }
              else
              {
                LODWORD(v34) = v121;
                if (!mfs_CostList_IsNodeInList((uint64_t)v128, 3u, v92, (uint64_t)a1, (unsigned int *)&v139))v134 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v92, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + v91) + v89 + 4) * 20.0);
              }
            }
            v89 += 8;
            v37 = v124;
          }
          while (v90 != v89);
          if (!*(_DWORD *)(*(_QWORD *)(v5 + 1976) + 208))
          {
            v12 = v107;
            v53 = v137;
            v14 = v128;
LABEL_88:
            LODWORD(v16) = *a1;
            if ((int)*a1 >= 1)
            {
              v54 = v12;
              v55 = 0;
              v56 = 1;
              v57 = 1;
              do
              {
                v58 = *(_QWORD *)(v5 + 1976);
                if (*(_DWORD *)(v58 + (v55 >> 27) + 16))
                {
                  mfs_ConcatTwoLists(v53, v40 + v56 - 1, (uint64_t)v128, v57 - 1);
                  v58 = *(_QWORD *)(v5 + 1976);
                }
                if (*(_DWORD *)(v58 + 32 * v57 + 16))
                  mfs_ConcatTwoLists(v53, v40 + v56 - 1, (uint64_t)v128, v57);
                v16 = (int)*a1;
                ++v56;
                v57 += 2;
                v55 += 0x200000000;
              }
              while (v56 <= v16);
              v12 = v54;
              v14 = v128;
            }
            goto LABEL_96;
          }
          v14 = v128;
          mfs_ConcatTwoLists(v128, 3u, (uint64_t)v128, 6u);
          v12 = v107;
        }
      }
      v53 = v137;
      goto LABEL_88;
    }
LABEL_96:
    if ((int)v16 >= 1)
      break;
    v109 -= v16;
LABEL_140:
    if (++v12 >= *(int *)(v5 + 608))
      goto LABEL_166;
  }
  v59 = v109 - (int)v16;
  v127 = 2488;
  v125 = 2640;
  v60 = 2;
  while (1)
  {
    v61 = *(_QWORD *)(v5 + 600);
    v134 = mfs_FillTgtVect(v4, v5, (uint64_t)v140, *(_DWORD *)(*(_QWORD *)(v61 + 528 * v12 + 16) + 4 * v60));
    if ((v134 & 0x80000000) != 0)
      break;
    if ((_DWORD)v60 == 4)
    {
      if (!mfs_Ling_IsSilence(v4, *(_QWORD *)(v5 + 8), v12))
      {
        v64 = v61 + 528 * v12;
        v65 = v105;
        v66 = v5 + 4 * v105;
        *(_DWORD *)(v66 + 3468) = *(_DWORD *)(v64 + 24);
        v67 = *(_DWORD *)(v64 + 28);
        if (v105 < 0x190)
          v65 = v105 + 1;
        LODWORD(v105) = v65;
        if (!v67)
          v67 = 1;
        *(_DWORD *)(v66 + 5072) = v67;
      }
    }
    else if ((_DWORD)v60 == 3 && mfs_Ling_IsVowel(v4, *(_QWORD *)(v5 + 8), v12))
    {
      v62 = fmaxf(*(float *)v141, 0.0);
      v63 = HIDWORD(v105);
      if (HIDWORD(v105) < 0xC8)
        v63 = HIDWORD(v105) + 1;
      *(float *)(v5 + 4 * HIDWORD(v105) + 2664) = v62;
      HIDWORD(v105) = v63;
    }
    v68 = *(_DWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59 + 16);
    if (v68 >= 0x33)
    {
      v69 = (int)(float)(*(float *)(v4 + 8232) * (float)v68);
      if (v136 < v69)
        v69 = v136;
      if (v69 <= 50)
        v70 = 50;
      else
        v70 = v69;
      if (v68 == v70)
      {
LABEL_121:
        v71 = v61 + 528 * v107;
        v72 = 0;
        v113 = (_QWORD *)(v71 + 80);
        v108 = (int *)(v71 + 28);
        v110 = (int *)(v71 + 24);
        v116 = v68;
        v122 = v59;
        while (1)
        {
          HIDWORD(v139) = 0;
          v160 = 0u;
          v161 = 0u;
          v158 = 0u;
          v159 = 0u;
          v157 = 0u;
          v73 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59) + 8 * v72);
          AcousticVector = mfs_ParamMap_GetAcousticVector(v3, (uint64_t)a1, v5, v73, (uint64_t)&v157, (int *)&v139 + 1);
          if ((AcousticVector & 0x80000000) != 0)
            goto LABEL_180;
          if ((int)v148 <= SHIDWORD(v139))
            v74 = HIDWORD(v139);
          else
            v74 = v148;
          LODWORD(v150) = v74;
          v134 = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v149, v74);
          if ((v134 & 0x80000000) != 0)
            goto LABEL_186;
          if (*v119)
          {
            v134 = mfs_TCost_CandidateCostStream_kld((uint64_t)v140, (uint64_t)a1, v4, v3, (uint64_t)&v157, SHIDWORD(v139), v73, *(unsigned int *)(*v113 + 4 * v60), v60, (uint64_t)v156);
            if ((v134 & 0x80000000) != 0)
              goto LABEL_186;
          }
          else
          {
            mfs_TCost_CandidateCostStream_Faster((uint64_t)v140, v4, (uint64_t)&v157, SHIDWORD(v139), (uint64_t)v156);
          }
          v75 = *(float *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59) + 8 * v72 + 4);
          mfs_symData_DistanceOnUid_PreCalc(v3, (uint64_t)a1, v4, (uint64_t)v172, *a1, v73, v60, HIBYTE(v154), (uint64_t)v171, (uint64_t)v170);
          v76 = 0.0;
          v133 = v72;
          if (*(_DWORD *)(v4 + 8272) && HIBYTE(v154) != 1)
            v76 = (float)(int)CandidatePhonemeDurationDistance((uint64_t)a1, v73, v60, *v110, *v108) * 0.01 + 0.0;
          v77 = 0;
          v78 = (float)(v75 * v13) + 1.0;
          v80 = v125;
          v79 = v127;
          v4 = v117;
          v3 = v118;
          do
          {
            *((_QWORD *)&v173 + 1) = *(_QWORD *)((char *)a1 + v80);
            v172[0] = *(unsigned int *)((char *)a1 + v79);
            v76 = v76
                + (float)((float)(v9 * *(float *)((char *)v156 + v77))
                        + (float)((float)(1.0 - v9)
                                * mfs_symData_DistanceOnUid_Tahoe(v118, (uint64_t)a1, v117, (uint64_t)v172, *a1, v73, v60, HIBYTE(v154), v171)));
            v77 += 4;
            v80 += 72;
            v79 += 36;
          }
          while (v77 != 12);
          v5 = v138;
          mfs_ParamMap_UnMapSection(v138);
          v59 = v122;
          mfs_CostList_UpdateCost((uint64_t)v137, v122, v133, v78 * v76);
          v72 = v133 + 1;
          if (v133 + 1 == v116)
            goto LABEL_137;
        }
      }
      MFS__log_select_Diag(v3, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
      v134 = mfs_CostList_Sort((uint64_t)v137, v59, 1);
      if ((v134 & 0x80000000) != 0)
        break;
      mfs_CostList_Prune(v137, v59, v70);
      v68 = *(_DWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59 + 16);
    }
    if (v68)
      goto LABEL_121;
LABEL_137:
    ++v59;
    v125 += 8;
    v127 += 4;
    v81 = v60++ <= (int)*a1;
    v12 = v107;
    if (!v81)
    {
      v109 = v59;
      v14 = v128;
      goto LABEL_140;
    }
  }
LABEL_186:
  UNICORN__mfs_S32Vect_Clear(v153);
  mfs_TCost_Clear(v140);
  return v134;
}

uint64_t mfs_Search_FindNodeCandidates(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  _BOOL4 IsBoundary;
  uint64_t v11;
  _BOOL4 v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL4 v16;
  int v17;
  uint64_t v18;
  _BOOL4 IsPerceptualInvariantState;
  int v20;
  uint64_t AcousticVector;
  uint64_t v23;
  float v24;
  _QWORD *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  signed int v32;
  unsigned int v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  int v40;
  signed int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unsigned int v53;
  float v54;
  float v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  int *v62;
  uint64_t v63;
  int v64;
  const char *v65;
  _QWORD *v67;
  uint64_t *v68;
  uint64_t v69;
  unsigned int v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  int *v74;
  signed int v75;
  _QWORD *v76;
  int v77;
  int v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  _QWORD *v84;
  int v85;
  unsigned __int8 *v86;
  _QWORD v87[2];
  unsigned int v88;
  _OWORD v89[9];
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t *v95[20];
  _QWORD v96[3];
  __int16 v97;
  char v98;
  _BYTE v99[88];
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a2 + 1928);
  v98 = 0;
  v97 = 0;
  memset(v96, 0, sizeof(v96));
  v94 = 0u;
  memset(v95, 0, 152);
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  memset(v89, 0, sizeof(v89));
  v88 = 0;
  v87[0] = 0;
  v87[1] = 0;
  v86 = (unsigned __int8 *)v87;
  *(_QWORD *)(a2 + 2192) = 0;
  mfs_Harch_Init(v6, (uint64_t)v95);
  UNICORN__mfs_S32Vect_Init(v6, v96);
  mfs_TCost_Init(v6, a3, (uint64_t)v89);
  if (*(int *)(a2 + 608) < 1)
  {
    v11 = 0;
LABEL_94:
    if (*(_DWORD *)(a3 + 8564) == 1)
    {
      v55 = *(float *)(a2 + 2616);
      if (v55 == 0.0)
      {
        v65 = "Early emission configured in pipeline header, no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(a2 + 2608) = (int)((double)*(int *)(a2 + 2604) / (v55 * 0.8 + 1.0));
        MFS__log_select_Diag(v6, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v56 = *(unsigned int *)(a2 + 608);
        v57 = *(_DWORD *)(a2 + 2596);
        if ((int)v56 >= 2)
        {
          v58 = 0;
          v59 = 1;
          v60 = *(_DWORD *)(a2 + 2596);
          do
          {
            if (v60)
              break;
            v61 = *a1;
            if ((int)*a1 >= 1)
            {
              v62 = (int *)(*(_QWORD *)(*(_QWORD *)(a2 + 600) + 528 * v59 + 16) + 8);
              v63 = *a1;
              do
              {
                v64 = *v62++;
                v58 += v64 * *(_DWORD *)(a3 + 24);
                --v63;
              }
              while (v63);
            }
            ++v59;
            if (v58 >= *(_DWORD *)(a2 + 2608))
            {
              v57 = v61 * v59;
              *(_DWORD *)(a2 + 2596) = v61 * v59;
              v60 = v61 * v59;
            }
            else
            {
              v60 = 0;
            }
          }
          while (v59 != v56);
        }
        if (!v57)
          goto LABEL_112;
        v65 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v65 = "Early emission not configured in pipeline header\n";
    }
    MFS__log_select_Diag(v6, 1, (uint64_t)v65);
LABEL_112:
    if (*(int *)(a2 + 2192) < 5 || *(int *)(a2 + 2196) <= 4)
      *(_DWORD *)(a2 + 2200) = 0;
    goto LABEL_115;
  }
  v7 = 0;
  v82 = 0;
  v84 = (_QWORD *)(a2 + 1944);
  v8 = (uint64_t *)(a1 + 486);
  while (1)
  {
    v9 = *(_QWORD *)(a2 + 600);
    MFS__log_select_Diag(v6, 3, (uint64_t)"phoneme %d\n");
    UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a2 + 8), v7, &v97);
    mfs_Ling_LogPhonCtxt(v6, a3, *(_QWORD *)(a2 + 8), v7);
    IsBoundary = mfs_Harch_IsBoundary((uint64_t)v95, 1u);
    v11 = mfs_Harch_Search(v6, v8, v95, a2, v7);
    if ((v11 & 0x80000000) != 0)
      break;
    MFS__log_select_Diag(v6, 3, (uint64_t)"\n");
    v12 = IsBoundary && mfs_Ling_IsVowelVowelTrans(a3, *(_QWORD *)(a2 + 8), v7)
       || mfs_Harch_FewCands((int *)v95);
    mfs_Harch_FewCands((int *)v95);
    v78 = v12;
    MFS__log_select_Diag(v6, 3, (uint64_t)"wordbound(%d) breakwords(%d) few(%d)\n");
    v70 = mfs_Ling_IsVowel(a3, *(_QWORD *)(a2 + 8), v7);
    if ((int)*a1 >= 1)
    {
      v13 = (int *)(v9 + 528 * v7);
      v76 = v13 + 4;
      v79 = v13 + 78;
      v67 = v13 + 22;
      v68 = v8;
      v71 = v13 + 84;
      v72 = v13 + 86;
      v14 = v82;
      v15 = 2;
      v81 = v6;
      v73 = a3;
      v74 = v13;
      v69 = v7;
      while (1)
      {
        v83 = v14;
        if (v7 && v7 != *(_DWORD *)(a2 + 608) - 1)
          *(_DWORD *)(a2 + 2604) += *(_DWORD *)(*v76 + 4 * v15) * *(_DWORD *)(a3 + 24);
        v16 = (*(_BYTE *)(*v79 + v15) & 4) == 0;
        v17 = *(_DWORD *)(a3 + 8656);
        v18 = v15;
        IsPerceptualInvariantState = mfs_IsPerceptualInvariantState(a3, a2, v13);
        if (v17)
          v20 = IsPerceptualInvariantState || v16;
        else
          v20 = IsPerceptualInvariantState && v16;
        v80 = v18;
        if (v20)
        {
          if (mfs_ProbSynthNoDegradation(a2, *(_DWORD *)(*v76 + 4 * v18)) == 0.0 && HIBYTE(v97) != 1)
          {
            MFS__log_select_Diag(v6, 3, (uint64_t)"F0 low -> made made Variant !\n");
            v20 = 0;
          }
        }
        AcousticVector = mfs_FillTgtVect(a3, a2, (uint64_t)v89, *(_DWORD *)(*v76 + 4 * v18));
        if ((AcousticVector & 0x80000000) != 0)
        {
LABEL_108:
          v11 = AcousticVector;
          goto LABEL_115;
        }
        v23 = 8224;
        if (v20)
          v23 = 8228;
        v24 = 0.009901;
        v25 = (_QWORD *)(a2 + 1944);
        if (v78)
        {
          if (v20)
          {
            v24 = *(float *)(a3 + 8164);
          }
          else
          {
            v24 = 0.047619;
            if (!v70)
              v24 = *(float *)(a3 + 8168);
          }
        }
        v26 = *(_DWORD *)(a3 + v23);
        if ((*(_BYTE *)(*v79 + v80) & 4) != 0)
          ++*(_DWORD *)(a2 + 2192);
        else
          ++*(_DWORD *)(a2 + 2196);
        v75 = v26;
        mfs_loc_AddMainCandidates(v6, (uint64_t)a1, (_DWORD *)a3, v13, v80, v84, v83, v26, v24, v78, v20, (unsigned __int8 *)&v97, v95, (uint64_t)v96, 1);
        v27 = *(_QWORD *)(a2 + 1952);
        v77 = v20;
        if (v20)
          break;
        v28 = v80;
        if ((*(_BYTE *)(*v79 + v80) & 4) == 0)
          goto LABEL_55;
        v29 = *(_DWORD *)(v27 + 32 * v83 + 16);
        v30 = *(_DWORD *)(a3 + 8944);
        v31 = v78;
        v32 = v75;
        if (v29 < v30)
        {
          if ((int)v30 >= v75)
            v33 = v75;
          else
            v33 = *(_DWORD *)(a3 + 8944);
          v34 = v78 ^ 1;
          if (*(_DWORD *)(a3 + 8788))
            v34 = 1;
          if ((v34 & 1) == 0)
          {
            AcousticVector = mfs_IbAddtoVect(v6, (uint64_t)a1, a3, 0, 2, v80, *(_DWORD *)(*v67 + 4 * v80), v29, v24, 0.8, 0.25, v33, v84, v83, (unsigned __int8 *)&v97, 0);
            if ((AcousticVector & 0x80000000) != 0)
              goto LABEL_108;
            v27 = *(_QWORD *)(a2 + 1952);
            v25 = (_QWORD *)(a2 + 1944);
            v28 = v80;
            v32 = v75;
            v31 = v78;
          }
          if (*(_DWORD *)(a3 + 8792))
          {
            v35 = *(_DWORD *)(v27 + 32 * v83 + 16) - v29;
            if (v35 <= 0xC7 && v35 < v33)
            {
              if (*(int *)(*v72 + 4 * v28) >= 1)
              {
                v36 = 0;
                while (1)
                {
                  v37 = v28;
                  AcousticVector = mfs_IbAddtoVect(v6, (uint64_t)a1, a3, 0, 2, v28, *(_DWORD *)(*(_QWORD *)(*v71 + 8 * v28) + 4 * v36), v29, v24, 0.8, 0.25, v33, v25, v83, (unsigned __int8 *)&v97, 0);
                  if ((AcousticVector & 0x80000000) != 0)
                    goto LABEL_108;
                  ++v36;
                  v25 = (_QWORD *)(a2 + 1944);
                  v28 = v37;
                  if (v36 >= *(int *)(*v72 + 4 * v37))
                  {
                    v20 = v77;
                    break;
                  }
                }
              }
              MFS__log_select_Diag(v6, 3, (uint64_t)"@@@@@@@@@@@@ BACKOFF %lu\n");
              v27 = *(_QWORD *)(a2 + 1952);
              LODWORD(v28) = v80;
              goto LABEL_55;
            }
          }
        }
LABEL_56:
        v38 = (int)(float)(*(float *)(a3 + 8232) * (float)*(unsigned int *)(v27 + 32 * v83 + 16));
        if (v32 < v38)
          v38 = v32;
        if (v38 <= 1)
          v39 = 1;
        else
          v39 = v38;
        if (v39 < 0x28)
          v40 = v31;
        else
          v40 = 0;
        if (!v20 && v40)
        {
          v41 = v32;
          mfs_loc_AddMainCandidates(v6, (uint64_t)a1, (_DWORD *)a3, v74, v28, v25, v83, v32, 0.0, v31, 0, (unsigned __int8 *)&v97, 0, (uint64_t)v96, 0);
          v27 = *(_QWORD *)(a2 + 1952);
          v42 = (int)(float)(*(float *)(a3 + 8232) * (float)*(unsigned int *)(v27 + 32 * v83 + 16));
          if (v41 < v42)
            v42 = v41;
          if (v42 <= 1)
            v39 = 1;
          else
            v39 = v42;
        }
        if (*(_DWORD *)(a3 + 8948))
        {
          v43 = v83 - 1;
          if (*(_DWORD *)(v27 + 32 * (v83 - 1) + 16))
          {
            v44 = 0;
            v45 = 0;
            do
            {
              v46 = *(_DWORD *)(*(_QWORD *)(v27 + 32 * v43) + v44) + 1;
              mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v46, (uint64_t *)&v86);
              if (mfs_PhoneticContextCost(v86 + 12, (unsigned __int8 *)&v97, 1.0) <= 0.5)
              {
                v47 = mfs_CostList_Add((uint64_t)a1, v25, v83, v46, *((_QWORD *)a1 + 298), a1[598], &v88, (float)(1000.0 - *(float *)v86) + 100.0);
                if ((v47 & 0x80000000) != 0)
                {
                  v11 = v47;
                  if ((v47 & 0x1FFF) != 2)
                    goto LABEL_115;
                  v25 = (_QWORD *)(a2 + 1944);
                  mfs_CostList_UpdateCost((uint64_t)v84, v83, v88, *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 1952) + 32 * v83) + 8 * v88 + 4) - *(float *)v86);
                }
                else
                {
                  ++v39;
                  MFS__log_select_Diag(v81, 3, (uint64_t)"CostList %lu, backfilled tri-phone %lu\n");
                  v25 = (_QWORD *)(a2 + 1944);
                }
              }
              ++v45;
              v27 = *(_QWORD *)(a2 + 1952);
              v44 += 8;
            }
            while (v45 < *(unsigned int *)(v27 + 32 * v43 + 16));
          }
        }
        v6 = v81;
        MFS__log_select_Diag(v81, 3, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
        v48 = mfs_CostList_Sort((uint64_t)v25, v83, 1);
        v49 = v25;
        v11 = v48;
        if ((v48 & 0x80000000) != 0)
          goto LABEL_115;
        mfs_CostList_Prune(v49, v83, v39);
        v50 = *(_QWORD *)(a2 + 1952);
        a3 = v73;
        if (*(_DWORD *)(v50 + 32 * v83 + 16))
        {
          v51 = 0;
          v52 = 0;
          do
          {
            v85 = 0;
            memset(v99, 0, 80);
            AcousticVector = mfs_ParamMap_GetAcousticVector(v81, (uint64_t)a1, a2, *(unsigned int *)(*(_QWORD *)(v50 + 32 * v83) + v51), (uint64_t)v99, &v85);
            if ((AcousticVector & 0x80000000) != 0)
              goto LABEL_108;
            if ((int)v90 <= v85)
              v53 = v85;
            else
              v53 = v90;
            LODWORD(v92) = v53;
            v11 = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v91, v53);
            if ((v11 & 0x80000000) != 0)
              return v11;
            v54 = mfs_TCost_CandidateCost((uint64_t)v89, v73, (uint64_t)v99, v85);
            mfs_ParamMap_UnMapSection(a2);
            mfs_CostList_UpdateCost((uint64_t)v84, v83, v52++, v54);
            v50 = *(_QWORD *)(a2 + 1952);
            v51 += 8;
          }
          while (v52 < *(unsigned int *)(v50 + 32 * v83 + 16));
        }
        v14 = v83 + 1;
        v15 = v80 + 1;
        v8 = v68;
        v7 = v69;
        v13 = v74;
        if (v80 > (int)*a1)
        {
          v82 = v83 + 1;
          goto LABEL_91;
        }
      }
      LODWORD(v28) = v80;
LABEL_55:
      v32 = v75;
      v31 = v78;
      goto LABEL_56;
    }
LABEL_91:
    if (++v7 >= *(int *)(a2 + 608))
      goto LABEL_94;
  }
LABEL_115:
  mfs_Harch_DeInit((uint64_t)v95);
  UNICORN__mfs_S32Vect_Clear(v96);
  mfs_TCost_Clear(v89);
  return v11;
}

uint64_t mfs_Search_SparseDP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int LogLevel;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  float v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  int v47;
  int v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  _OWORD v55[5];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a2 + 1928);
  v9 = a2 + 2112;
  v10 = (_QWORD *)(a2 + 2168);
  v11 = *(_DWORD *)(a1 + 1096);
  if (*(_DWORD *)(a2 + 2592) == 1)
  {
    v12 = *(_QWORD *)(a2 + 2624);
    *(_QWORD *)(a2 + 2624) = 0;
    mfs_SegmentList_DeInit((_QWORD *)(a2 + 2248));
    v13 = mfs_SegmentList_Init(v8, a1, a2 + 2248);
    if ((v13 & 0x80000000) != 0)
      return v13;
    mfs_SegmentList_DeInit((_QWORD *)(a2 + 2208));
    v13 = mfs_SegmentList_Init(v8, a1, a2 + 2208);
    if ((v13 & 0x80000000) != 0)
      return v13;
    mfs_UnitSequence_DeInit(v9);
    v13 = mfs_UnitSequence_Init(v8, v9, a1);
    if ((v13 & 0x80000000) != 0)
      return v13;
  }
  else
  {
    v15 = heap_Calloc(*(_QWORD **)(v8 + 8), 1, 136);
    if (!v15)
    {
      UNICORN__mfs_S32Vect_Clear(v10);
      return 0;
    }
    v12 = v15;
    v16 = mfs_Viterbi_Init(a1, a2, a4, v15);
    if ((v16 & 0x80000000) != 0)
    {
      v14 = v16;
      UNICORN__mfs_S32Vect_Clear(v10);
      goto LABEL_89;
    }
  }
  v17 = UNICORN__mfs_S32Vect_Reserve(a2 + 2144, *(_DWORD *)(a2 + 1936));
  if ((v17 & 0x80000000) != 0)
    goto LABEL_87;
  v17 = UNICORN__mfs_F32Vect_Create((uint64_t)v10, *(_DWORD *)(a2 + 1936));
  if ((v17 & 0x80000000) != 0)
    goto LABEL_87;
  v53 = a3;
  v18 = v11 - 1;
  if (*(int *)(a2 + 1936) >= 1)
  {
    v19 = 0;
    do
    {
      v17 = UNICORN__mfs_F32Vect_Pad((uint64_t)v10, 0.0);
      if ((v17 & 0x80000000) != 0)
        goto LABEL_87;
      mfs_S32Vect_Add(a2 + 2144, v18);
    }
    while (++v19 < *(_DWORD *)(a2 + 1936));
  }
  v20 = *(_DWORD *)(a2 + 2592);
  if (v20)
    goto LABEL_15;
  MFS__log_select_Diag(v8, 3, (uint64_t)"path_len = %dL %d : %d\n");
  MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::begin_with_early_emission\n");
  v17 = mfs_Viterbi_Reset(v12, **(_DWORD **)(a2 + 2000), *(_DWORD *)(*(_QWORD *)(a2 + 2000) + 4));
  if ((v17 & 0x80000000) != 0)
    goto LABEL_87;
  v25 = *(_DWORD *)(a2 + 2064);
  if (v25 == 1)
  {
    v17 = mfs_Viterbi_Decode_MCP_S9_LF0_S8(v12);
    if ((v17 & 0x80000000) != 0)
      goto LABEL_87;
  }
  else if (v25 == 2)
  {
    v17 = mfs_Viterbi_Decode_MCP_S9_LF0_S8_X2B(v12);
    if ((v17 & 0x80000000) != 0)
      goto LABEL_87;
  }
  else
  {
    v17 = mfs_Viterbi_Decode(v12);
    if ((v17 & 0x80000000) != 0)
      goto LABEL_87;
  }
  if (*(_DWORD *)(a2 + 2592) == 2)
    goto LABEL_33;
  MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::end_for_early_emission\n");
  v17 = mfs_Viterbi_ResultScore(v12, a2 + 2144, (uint64_t)v10);
  if ((v17 & 0x80000000) != 0)
  {
LABEL_87:
    v14 = v17;
LABEL_88:
    UNICORN__mfs_S32Vect_Clear(v10);
    if (!v12)
      return v14;
LABEL_89:
    mfs_Viterbi_DeInit((_QWORD *)v12);
    return v14;
  }
  *(_QWORD *)(a2 + 2624) = v12;
  v20 = *(_DWORD *)(a2 + 2592);
  if (!v20)
    goto LABEL_48;
LABEL_15:
  if (v20 != 2)
  {
    v50 = v9;
    MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::resume_after_early_emission\n");
    v21 = *(unsigned int *)(v12 + 68);
    if ((int)v21 >= 1)
    {
      v22 = *(_QWORD *)(v12 + 56);
      v23 = (*(_DWORD *)(a2 + 2636) - *(_DWORD *)(v12 + 32));
      v24 = *(_DWORD *)(a2 + 2632);
      do
      {
        if (*(_DWORD *)(*(_QWORD *)(v22 + 24) + 4 * v23) != v24)
          *(_DWORD *)v22 = 1259902592;
        v22 += 32;
        --v21;
      }
      while (v21);
    }
    goto LABEL_34;
  }
LABEL_33:
  v50 = v9;
  MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::begin_regular_emission\n");
LABEL_34:
  if (*(int *)(a2 + 2008) >= 1)
  {
    v26 = 0;
    v27 = 0;
    do
    {
      if (v26 || *(_DWORD *)(a2 + 2592) != 1)
      {
        v17 = mfs_Viterbi_Reset(v12, *(_DWORD *)(*(_QWORD *)(a2 + 2000) + v26), *(_DWORD *)(*(_QWORD *)(a2 + 2000) + v26 + 4));
        if ((v17 & 0x80000000) != 0)
          goto LABEL_87;
      }
      MFS__log_select_Diag(v8, 3, (uint64_t)"path_len = %dL %d : %d\n");
      v28 = *(_DWORD *)(a2 + 2064);
      if (v28 == 1)
      {
        mfs_Viterbi_Decode_MCP_S9_LF0_S8(v12);
      }
      else if (v28 == 2)
      {
        v17 = mfs_Viterbi_Decode_MCP_S9_LF0_S8_X2B(v12);
        if ((v17 & 0x80000000) != 0)
          goto LABEL_87;
      }
      else
      {
        v17 = mfs_Viterbi_Decode(v12);
        if ((v17 & 0x80000000) != 0)
          goto LABEL_87;
      }
      MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::end\n");
      v17 = mfs_Viterbi_ResultScore(v12, a2 + 2144, (uint64_t)v10);
      if ((v17 & 0x80000000) != 0)
        goto LABEL_87;
      *(_DWORD *)(a2 + 2592) = 2;
      ++v27;
      v26 += 8;
    }
    while (v27 < *(int *)(a2 + 2008));
  }
  mfs_Viterbi_DeInit((_QWORD *)v12);
  v9 = v50;
LABEL_48:
  if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v8 + 32)) < 2)
    goto LABEL_75;
  LogLevel = BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v8 + 32));
  v30 = *(_DWORD *)(a2 + 2160);
  v31 = v30 - 1;
  if (LogLevel >= 3)
  {
    if (v31 < 1)
      goto LABEL_71;
    v51 = v9;
    v32 = 0;
    v33 = 0;
    v49 = 0;
    v52 = 0;
    do
    {
      v54 = 0;
      memset(v55, 0, sizeof(v55));
      mfs_ParamMap_GetAcousticVector(v8, a1, a2, *(unsigned int *)(*(_QWORD *)(a2 + 2152) + 4 * v32), (uint64_t)v55, &v54);
      v33 += v54;
      MFS__log_select_Diag(v8, 3, (uint64_t)"unit %d: %d %f\n");
      if (v32 % 3 == 2)
      {
        if (!mfs_Ling_IsSilence(a4, *(_QWORD *)(a2 + 8), v32 / 3))
        {
          MFS__log_select_Diag(v8, 1, (uint64_t)"model duration: %d %d\n");
          ++v49;
          MFS__log_select_Diag(v8, 1, (uint64_t)"candidate duration: %d\n");
          v33 = 0;
        }
      }
      else if (v32 % 3 == 1
             && mfs_Ling_IsVowel(a4, *(_QWORD *)(a2 + 8), v32 / 3))
      {
        if (v52 >= 0xC8)
          v34 = v52;
        else
          v34 = v52 + 1;
        MFS__log_select_Diag(v8, 1, (uint64_t)"model pitch: %f\n");
        MFS__log_select_Diag(v8, 1, (uint64_t)"candidate pitch: %f\n");
        v52 = v34;
      }
      ++v32;
      v30 = *(_DWORD *)(a2 + 2160);
      v31 = v30 - 1;
    }
    while (v32 < v30 - 1);
    v9 = v51;
  }
  if (v31 >= 1)
  {
    v35 = 0;
    v36 = 0;
    v37 = 0.0;
    do
    {
      v38 = *(_QWORD *)(a2 + 2152);
      v39 = *(_DWORD *)(v38 + 4 * v35);
      if (v39 == v18 || (v40 = *(_DWORD *)(v38 + 4 * v35 + 4), v40 == v18))
      {
        ++v36;
      }
      else
      {
        v37 = v37 + mfs_JCostProb(a1, a2, v39, v40, v35);
        v30 = *(_DWORD *)(a2 + 2160);
      }
      ++v35;
    }
    while (v35 < v30 - 1);
    goto LABEL_72;
  }
LABEL_71:
  v36 = 0;
  v37 = 0.0;
LABEL_72:
  v41 = v30 - v36;
  if (v41)
    exp((float)(v37 / (float)v41));
  MFS__log_select_Diag(v8, 2, (uint64_t)"ACC : %f\n");
LABEL_75:
  v14 = mfs_UnitSequence_Sequence(v9, v53);
  if ((v14 & 0x80000000) != 0)
    goto LABEL_88;
  if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v8 + 32)) >= 3)
    mfs_UnitSequence_Log(v9);
  if (*(_DWORD *)(a2 + 2592))
  {
    *(_DWORD *)(a2 + 2604) = 0;
    v42 = *(_DWORD *)(a2 + 2272);
    if (v42 >= 3)
    {
      v43 = 0;
      v44 = (v42 - 1);
      v45 = (int *)(*(_QWORD *)(a2 + 2264) + 40);
      v46 = v44 - 1;
      do
      {
        v47 = *v45;
        v45 += 7;
        v43 += v47;
        --v46;
      }
      while (v46);
      *(_DWORD *)(a2 + 2604) = v43;
    }
    mfs_Viterbi_DeInit((_QWORD *)v12);
    heap_Free(*(_QWORD **)(v8 + 8), v12);
    UNICORN__mfs_S32Vect_Clear(v10);
  }
  return v14;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_UltraLight(int *a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  float v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  signed int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  signed int v28;
  int LeafIndex;
  int v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  float v51;
  int v52;
  _QWORD *v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  signed int v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t AcousticVector;
  signed int v100;
  signed int v101;
  signed int v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  float v108;
  float v109;
  float v110;
  uint64_t v111;
  float v112;
  uint64_t v113;
  int v114;
  int v115;
  uint64_t v116;
  int v117;
  int v118;
  int *v119;
  uint64_t v120;
  int v121;
  const char *v122;
  int v123;
  int *v124;
  int *v125;
  signed int v126;
  int *v127;
  int *v128;
  _QWORD *v129;
  _QWORD *v130;
  int v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  _QWORD *v138;
  unsigned int v139;
  int *v140;
  uint64_t v141;
  _QWORD *v143;
  unsigned int v144;
  int *v145;
  _QWORD *v147;
  _QWORD *v148;
  unsigned int v149;
  _QWORD *v150;
  signed int v151;
  _DWORD *v152;
  _QWORD *v153;
  int v154;
  _OWORD v155[9];
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int16 v161;
  char v162;
  unsigned int v163[20];
  unsigned int v164[4];
  _DWORD v165[44];
  __int128 v166;
  unsigned int v167;
  uint64_t v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  uint64_t v173;

  v3 = (_DWORD *)a3;
  v4 = a2;
  v173 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a2 + 1928);
  v162 = 0;
  v161 = 0;
  v7 = (_QWORD *)(a2 + 1944);
  v171 = 0u;
  v172 = 0u;
  v169 = 0u;
  v170 = 0u;
  v159 = 0u;
  v160 = 0u;
  v157 = 0u;
  v158 = 0u;
  v156 = 0u;
  memset(v155, 0, sizeof(v155));
  v166 = 0u;
  memset(v165, 0, sizeof(v165));
  *(_QWORD *)(a2 + 2192) = 0;
  v8 = *(float *)(a3 + 8180);
  v141 = v6;
  if (*(int *)(a2 + 608) < 1)
  {
    v139 = 0;
LABEL_115:
    mfs_TCost_Init(v6, (uint64_t)v3, (uint64_t)v155);
    v90 = *(_DWORD *)(v4 + 608);
    if (v90 >= 1)
    {
      v91 = 0;
      LODWORD(v92) = 0;
      v152 = v3 + 6322;
      LODWORD(v93) = *a1;
      v94 = v139;
      v130 = v7;
      while ((int)v93 < 1)
      {
LABEL_146:
        if (++v91 >= v90)
          goto LABEL_149;
      }
      v95 = a2;
      v96 = *(_QWORD *)(a2 + 600) + 528 * v91;
      v97 = (_QWORD *)(v96 + 16);
      v133 = (_QWORD *)(v96 + 312);
      v136 = v91;
      v150 = (_QWORD *)(v96 + 80);
      v145 = (int *)(v96 + 24);
      v138 = (_QWORD *)(v96 + 16);
      v140 = (int *)(v96 + 28);
      v92 = (int)v92;
      v98 = 2;
      while (1)
      {
        AcousticVector = mfs_FillTgtVect((uint64_t)v3, v95, (uint64_t)v155, *(_DWORD *)(*v97 + 4 * v98));
        if ((AcousticVector & 0x80000000) != 0)
          break;
        UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(v95 + 8), v91, &v161);
        result = mfs_CostList_Sort((uint64_t)v130, v92, 1);
        if ((result & 0x80000000) != 0)
          return result;
        v100 = *(_DWORD *)(*(_QWORD *)(v95 + 1952) + 32 * v92 + 16);
        MFS__log_select_Diag(v6, 1, (uint64_t)"before prune %lu, ");
        v101 = v3[2064];
        if (!v101 || HIBYTE(v161) != 1)
        {
          if ((*(_BYTE *)(*v133 + v98) & 4) != 0)
            v101 = v3[2060];
          else
            v101 = v3[2061];
        }
        if (v100 >= v101)
          v102 = v101;
        else
          v102 = v100;
        MFS__log_select_Diag(v6, 1, (uint64_t)"after prune %lu\n");
        mfs_CostList_Prune(v130, v92, v102);
        v95 = a2;
        if (v102 >= 1)
        {
          v103 = 0;
          v104 = 0;
          v105 = 8 * v102;
          do
          {
            v154 = 0;
            memset(v163, 0, sizeof(v163));
            v106 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v95 + 1952) + 32 * v92) + v103);
            AcousticVector = mfs_ParamMap_GetAcousticVector(v141, (uint64_t)a1, v95, v106, (uint64_t)v163, &v154);
            if ((AcousticVector & 0x80000000) != 0)
              goto LABEL_163;
            if ((int)v156 <= v154)
              v107 = v154;
            else
              v107 = v156;
            LODWORD(v158) = v107;
            result = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v157, v107);
            if ((result & 0x80000000) != 0)
              return result;
            if (*v152)
            {
              AcousticVector = mfs_TCost_CandidateCostStream_kld((uint64_t)v155, (uint64_t)a1, a3, v141, (uint64_t)v163, v154, v106, *(unsigned int *)(*v150 + 4 * v98), v98, (uint64_t)v164);
              if ((AcousticVector & 0x80000000) != 0)
                goto LABEL_163;
            }
            else
            {
              mfs_TCost_CandidateCostStream_Faster((uint64_t)v155, a3, (uint64_t)v163, v154, (uint64_t)v164);
            }
            v108 = 0.0;
            if (HIBYTE(v161) != 1 && *(_DWORD *)(a3 + 8968) == 6)
            {
              v109 = (float)(*((float *)v155 + 1) * *((float *)&v156 + 3)) * 0.01;
              v108 = (float)(v109 * (float)(int)CandidatePhonemeDurationDistance((uint64_t)a1, v106, v98, *v145, *v140))
                   + 0.0;
            }
            v95 = a2;
            v110 = (float)(v8
                         * (float)(v108 + (float)((float)(*(float *)&v164[1] + *(float *)&v164[2]) + *(float *)v164)))
                 + (float)(*(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 1952) + 32 * v92) + v103 + 4) * (float)(1.0 - v8));
            mfs_ParamMap_UnMapSection(a2);
            mfs_CostList_UpdateCost_inlined((uint64_t)v130, v92, v104++, v110);
            v103 += 8;
          }
          while (v105 != v103);
        }
        mfs_CostList_UpdateCostEnd_inlined((uint64_t)v130, v92);
        v3 = (_DWORD *)a3;
        v94 = mfs_CleanUpTgtVect(a3, v95, (uint64_t)v155);
        ++v92;
        v93 = *a1;
        v32 = v98++ <= v93;
        v6 = v141;
        v91 = v136;
        v97 = v138;
        if (!v32)
        {
          v90 = *(_DWORD *)(v95 + 608);
          goto LABEL_146;
        }
      }
LABEL_163:
      v111 = AcousticVector;
      goto LABEL_167;
    }
    v94 = v139;
LABEL_149:
    *(_DWORD *)(a2 + 2200) = 0;
    v111 = v94;
    if (v3[2141] == 1)
    {
      v112 = *(float *)(a2 + 2616);
      if (v112 == 0.0)
      {
        v122 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(a2 + 2608) = (int)((double)*(int *)(a2 + 2604) / (v112 * 0.8 + 1.0));
        MFS__log_select_Diag(v6, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v113 = *(unsigned int *)(a2 + 608);
        v114 = *(_DWORD *)(a2 + 2596);
        if ((int)v113 >= 2)
        {
          v115 = 0;
          v116 = 1;
          v117 = *(_DWORD *)(a2 + 2596);
          do
          {
            if (v117)
              break;
            v118 = *a1;
            if (*a1 >= 1)
            {
              v119 = (int *)(*(_QWORD *)(*(_QWORD *)(a2 + 600) + 528 * v116 + 16) + 8);
              v120 = *a1;
              do
              {
                v121 = *v119++;
                v115 += v121 * v3[6];
                --v120;
              }
              while (v120);
            }
            ++v116;
            if (v115 >= *(_DWORD *)(a2 + 2608))
            {
              v114 = v118 * v116;
              *(_DWORD *)(a2 + 2596) = v118 * v116;
              v117 = v118 * v116;
            }
            else
            {
              v117 = 0;
            }
          }
          while (v116 != v113);
        }
        if (!v114)
          goto LABEL_167;
        v122 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v122 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v6, 1, (uint64_t)v122);
LABEL_167:
    mfs_TCost_Clear(v155);
    return v111;
  }
  v9 = 0;
  v139 = 0;
  v126 = 0;
  v137 = *(_DWORD *)(a3 + 8224);
  v127 = a1 + 620;
  v128 = a1 + 656;
  v10 = (_QWORD *)(a2 + 1968);
  v124 = a1 + 696;
  v125 = a1 + 640;
  v153 = (_QWORD *)(a2 + 1968);
  while (1)
  {
    v11 = *(_QWORD *)(v4 + 600);
    v12 = (uint64_t)v3;
    v13 = v6;
    v14 = v9;
    v15 = v11 + 528 * v9;
    MFS__log_select_Diag(v13, 3, (uint64_t)"phoneme %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v165, *(_QWORD *)(v4 + 8), v14);
    UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(v4 + 8), v14, &v161);
    v16 = v13;
    v17 = v13;
    v3 = (_DWORD *)v12;
    mfs_Ling_LogPhonCtxt(v17, v12, *(_QWORD *)(v4 + 8), v14);
    LODWORD(v18) = *a1;
    v132 = v14;
    if (*a1 == 3)
    {
      v21 = v11 + 528 * v14;
      v134 = (_QWORD *)(v21 + 16);
      v147 = (_QWORD *)(v21 + 312);
      v19 = v126;
      v20 = v126 - 1;
      LODWORD(v21) = 3;
      v22 = 2;
      LODWORD(result) = v139;
      v24 = v15;
      v25 = v14;
      while (1)
      {
        v151 = v19;
        if (v25 && v25 != *(_DWORD *)(v4 + 608) - 1)
          *(_DWORD *)(v4 + 2604) += *(_DWORD *)(*v134 + 4 * v22) * *(_DWORD *)(a3 + 24);
        v26 = 2 * v22;
        v27 = *(_QWORD *)(v4 + 1976);
        *(_DWORD *)(v27 + (((v22 << 33) - 0x400000000) >> 27) + 16) = 0;
        *(_DWORD *)(v27 + 32 * (2 * (int)v22 - 3) + 16) = 0;
        v28 = v19;
        if (HIBYTE(v161) != 1
          || *(_DWORD *)(a3 + 8256) && (v25 && v22 == 2 || v22 == (_DWORD)v21 + 1 && v25 != *(_DWORD *)(a2 + 608) - 1))
        {
          *((_QWORD *)&v166 + 1) = *(_QWORD *)&a1[2 * v22 + 674];
          v165[0] = a1[v22 + 629];
          LeafIndex = mfs_GetLeafIndex(v24, 1, v22);
          result = mfs_IbAddtoVect_MCP(v141, (unsigned int *)a1, a3, (uint64_t)v165, v22, LeafIndex, 0, v137, v7, v28, (uint64_t)&v161);
          if ((result & 0x80000000) != 0)
            return result;
          if ((*(_BYTE *)(*v147 + v22) & 4) != 0)
          {
            *((_QWORD *)&v166 + 1) = *(_QWORD *)&a1[2 * v22 + 692];
            v165[0] = a1[v22 + 638];
            v30 = mfs_GetLeafIndex(v24, 2, v22);
            result = mfs_IbAddtoVect_LF0(v141, (unsigned int *)a1, a3, (uint64_t)v165, v22, v30, 0, v137, (uint64_t)v7, v151, (uint64_t)&v161, v10, v26 - 4);
            if ((result & 0x80000000) != 0)
              return result;
            *((_QWORD *)&v166 + 1) = *(_QWORD *)&v128[2 * v22];
            v165[0] = v127[v22];
            v31 = mfs_GetLeafIndex(v24, 0, v22);
            result = mfs_IbAddtoVect_DUR(v141, (unsigned int *)a1, a3, (uint64_t)v165, v22, v31, 0, v137, (uint64_t)v7, v151, (uint64_t)&v161, v10, v26 - 4, v26 - 3);
            v25 = v14;
            v28 = v151;
            if ((result & 0x80000000) != 0)
              return result;
          }
        }
        v19 = v28 + 1;
        v21 = *a1;
        ++v20;
        v32 = v22++ <= v21;
        v4 = a2;
        if (!v32)
        {
          v139 = result;
          v126 = v19;
          if (HIBYTE(v161) == 1)
          {
            v6 = v141;
            v3 = (_DWORD *)a3;
          }
          else
          {
            v131 = v20;
            v57 = 0;
            v163[0] = 0;
            v58 = *(_QWORD *)(a2 + 1976);
            if ((int)v21 >= -1)
              v59 = v21 + 1;
            else
              v59 = v21 + 2;
            *(_DWORD *)(v58 + 208) = 0;
            v123 = -(v59 >> 1);
            *(_DWORD *)(v58 + 240) = 0;
            v164[0] = 0;
            v167 = v19 - (v59 >> 1);
            v60 = (uint64_t)v7;
            *(_QWORD *)&v169 = v7;
            *((_QWORD *)&v169 + 1) = v10;
            *(_QWORD *)&v170 = v10;
            v168 = 0x300000002;
            v149 = v151 - (v59 >> 1);
            v144 = v167;
            do
            {
              v61 = *((_QWORD *)&v169 + v57);
              v135 = v57;
              v62 = *(&v167 + v57);
              v63 = *(unsigned int *)(*(_QWORD *)(v61 + 8) + 32 * v62 + 16);
              if ((int)v63 >= 1)
              {
                v64 = 0;
                v65 = 8 * v63;
                do
                {
                  v66 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v61 + 8) + 32 * v62) + v64);
                  if (!mfs_CostList_IsNodeInList(v60, v149, v66 - 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 0, v66 - 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 1u, v66 - 1, (uint64_t)a1, v164))
                  {
                    v139 = mfs_CostList_Pad((uint64_t)a1, v153, 6u, v66 - 1, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v61 + 8) + 32 * v62) + v64 + 4) * 10.0);
                  }
                  if (!mfs_CostList_IsNodeInList(v60, v144 + 1, v66 + 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 4u, v66 + 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 5u, v66 + 1, (uint64_t)a1, v164))
                  {
                    v139 = mfs_CostList_Pad((uint64_t)a1, v153, 7u, v66 + 1, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v61 + 8) + 32 * v62) + v64 + 4) * 10.0);
                  }
                  v64 += 8;
                }
                while (v65 != v64);
              }
              v57 = v135 + 1;
            }
            while (v135 != 2);
            v4 = a2;
            v67 = *(_QWORD *)(a2 + 1976);
            if (*(_DWORD *)(v67 + 208))
            {
              v10 = v153;
              mfs_ConcatTwoLists(v153, 1u, (uint64_t)v153, 6u);
              v67 = *(_QWORD *)(a2 + 1976);
              v3 = (_DWORD *)a3;
            }
            else
            {
              v3 = (_DWORD *)a3;
              v10 = v153;
            }
            v68 = v20;
            v7 = (_QWORD *)v60;
            if (*(_DWORD *)(v67 + 240))
              mfs_ConcatTwoLists(v10, 5u, (uint64_t)v10, 7u);
            v69 = v144;
            if (v3[2242] == 6)
            {
              v70 = 0;
              v164[0] = 0;
              v167 = v149;
              *(_QWORD *)&v169 = v7;
              *((_QWORD *)&v169 + 1) = v10;
              *(_QWORD *)&v170 = v10;
              v168 = 0x100000000;
              *(_DWORD *)(*(_QWORD *)(a2 + 1976) + 208) = 0;
              do
              {
                v71 = *((_QWORD *)&v169 + v70);
                v72 = *(&v167 + v70);
                v73 = *(unsigned int *)(*(_QWORD *)(v71 + 8) + 32 * v72 + 16);
                if ((int)v73 >= 1)
                {
                  v74 = 0;
                  v75 = 8 * v73;
                  do
                  {
                    v76 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v71 + 8) + 32 * v72) + v74) + 1;
                    if (!mfs_CostList_IsNodeInList((uint64_t)v7, v69, v76, (uint64_t)a1, v164))
                    {
                      if (mfs_CostList_IsNodeInList((uint64_t)v153, 3u, v76, (uint64_t)a1, v164))
                      {
                        v69 = v144;
                      }
                      else
                      {
                        v69 = v144;
                        if (!mfs_CostList_IsNodeInList((uint64_t)v153, 4u, v76, (uint64_t)a1, v164))
                          v139 = mfs_CostList_Pad((uint64_t)a1, v153, 6u, v76, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v71 + 8) + 32 * v72) + v74 + 4) * 20.0);
                      }
                    }
                    v74 += 8;
                  }
                  while (v75 != v74);
                }
                ++v70;
              }
              while (v70 != 3);
              v77 = *(_QWORD *)(a2 + 1976);
              if (*(_DWORD *)(v77 + 208))
              {
                mfs_ConcatTwoLists(v153, 3u, (uint64_t)v153, 6u);
                v77 = *(_QWORD *)(a2 + 1976);
              }
              v78 = 0;
              v164[0] = 0;
              v167 = v144 + 1;
              *(_QWORD *)&v169 = v7;
              *((_QWORD *)&v169 + 1) = v153;
              *(_QWORD *)&v170 = v153;
              v168 = 0x500000004;
              *(_DWORD *)(v77 + 208) = 0;
              do
              {
                v79 = *((_QWORD *)&v169 + v78);
                v80 = *(&v167 + v78);
                v81 = *(unsigned int *)(*(_QWORD *)(v79 + 8) + 32 * v80 + 16);
                if ((int)v81 >= 1)
                {
                  v82 = 0;
                  v83 = 8 * v81;
                  do
                  {
                    v84 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v79 + 8) + 32 * v80) + v82) - 1;
                    if (!mfs_CostList_IsNodeInList((uint64_t)v7, v69, v84, (uint64_t)a1, v164))
                    {
                      if (mfs_CostList_IsNodeInList((uint64_t)v153, 3u, v84, (uint64_t)a1, v164))
                      {
                        v69 = v144;
                      }
                      else
                      {
                        v69 = v144;
                        if (!mfs_CostList_IsNodeInList((uint64_t)v153, 4u, v84, (uint64_t)a1, v164))
                          v139 = mfs_CostList_Pad((uint64_t)a1, v153, 6u, v84, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v79 + 8) + 32 * v80) + v82 + 4) * 20.0);
                      }
                    }
                    v82 += 8;
                  }
                  while (v83 != v82);
                }
                ++v78;
              }
              while (v78 != 3);
              v4 = a2;
              if (*(_DWORD *)(*(_QWORD *)(a2 + 1976) + 208))
              {
                v10 = v153;
                mfs_ConcatTwoLists(v153, 3u, (uint64_t)v153, 6u);
                v3 = (_DWORD *)a3;
                v25 = v132;
              }
              else
              {
                v3 = (_DWORD *)a3;
                v25 = v132;
                v10 = v153;
              }
              v68 = v131;
            }
            else
            {
              v25 = v132;
            }
            if (*a1 >= 1)
            {
              v85 = 0;
              v86 = v123 + v68;
              v87 = 1;
              v88 = 1;
              do
              {
                v89 = *(_QWORD *)(v4 + 1976);
                if (*(_DWORD *)(v89 + (v85 >> 27) + 16))
                {
                  mfs_ConcatTwoLists(v7, v86 + v87 - 1, (uint64_t)v10, v88 - 1);
                  v89 = *(_QWORD *)(v4 + 1976);
                }
                if (*(_DWORD *)(v89 + 32 * v88 + 16))
                  mfs_ConcatTwoLists(v7, v86 + v87 - 1, (uint64_t)v10, v88);
                ++v87;
                v88 += 2;
                v85 += 0x200000000;
              }
              while (v87 <= *a1);
            }
            v6 = v141;
          }
          goto LABEL_112;
        }
      }
    }
    LODWORD(result) = v139;
    if ((int)v18 >= 1)
      break;
    v25 = v14;
    v6 = v16;
LABEL_40:
    if (HIBYTE(v161) == 1)
    {
      v139 = result;
    }
    else
    {
      v43 = v18 + 2;
      if ((int)v18 >= -1)
        v43 = v18 + 1;
      v44 = v126 - (v43 >> 1);
      v45 = *(unsigned int *)(*(_QWORD *)(v4 + 1952) + 32 * v44 + 16);
      v163[0] = 0;
      if ((int)v45 >= 1)
      {
        v46 = 0;
        v47 = 0;
        v48 = 0;
        do
        {
          if ((int)v18 >= 3)
          {
            v49 = *(_QWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v44) + 8 * v46;
            v50 = *(_DWORD *)v49;
            v51 = *(float *)(v49 + 4) * 10.0;
            v52 = 1;
            v53 = v7;
            v54 = -1;
            do
            {
              v55 = v48
                  + ((int)mfs_CostList_Add((uint64_t)a1, v53, (int)v44 + v54, v50 + v54, *((_QWORD *)a1 + 298), a1[598], v163, v51) >= 0);
              LODWORD(result) = mfs_CostList_Add((uint64_t)a1, v53, (int)v44 + v52, v50 + v52, *((_QWORD *)a1 + 298), a1[598], v163, v51);
              v48 = v55 + ((int)result >= 0);
              v47 += 2;
              ++v52;
              LODWORD(v18) = *a1;
              v56 = *a1 + 2;
              if (*a1 >= -1)
                v56 = v18 + 1;
              --v54;
            }
            while (v52 < v56 >> 1);
            v4 = a2;
            v7 = v53;
            v25 = v132;
          }
          ++v46;
        }
        while (v46 != v45);
      }
      v139 = result;
      v6 = v141;
      MFS__log_select_Diag(v141, 1, (uint64_t)"MCP Phoneme filler added %lu states %lu\n");
      v3 = (_DWORD *)a3;
      v10 = v153;
    }
LABEL_112:
    v9 = v25 + 1;
    if (v9 >= *(int *)(v4 + 608))
      goto LABEL_115;
  }
  v33 = 0;
  v34 = v11 + 528 * v14;
  v143 = (_QWORD *)(v34 + 16);
  v148 = (_QWORD *)(v34 + 312);
  v35 = v124;
  v36 = v125;
  v37 = v15;
  v25 = v14;
  v129 = v7;
  while (1)
  {
    v38 = v33;
    if (v25 && v25 != *(_DWORD *)(v4 + 608) - 1)
      *(_DWORD *)(v4 + 2604) += *(_DWORD *)(*v143 + 4 * v33 + 8) * *(_DWORD *)(a3 + 24);
    if (HIBYTE(v161) != 1
      || *(_DWORD *)(a3 + 8256) && (v25 && !v33 || v33 + 2 == (_DWORD)v18 + 1 && v25 != *(_DWORD *)(a2 + 608) - 1))
    {
      v39 = v126 + v33;
      *((_QWORD *)&v166 + 1) = *((_QWORD *)v35 - 9);
      v165[0] = *(v36 - 9);
      v40 = mfs_GetLeafIndex(v37, 1, (int)v33 + 2);
      result = mfs_IbAddtoVect(v141, (uint64_t)a1, a3, (uint64_t)v165, 1, (int)v38 + 2, v40, 0, 1.0, 1.0, 0.025, v137, v7, v126 + (int)v38, (unsigned __int8 *)&v161, 0);
      if ((result & 0x80000000) != 0)
        return result;
      if ((*(_BYTE *)(*v148 + v38 + 2) & 4) != 0)
      {
        *((_QWORD *)&v166 + 1) = *(_QWORD *)v35;
        v165[0] = *v36;
        v41 = mfs_GetLeafIndex(v37, 2, (int)v38 + 2);
        result = mfs_IbAddtoVect(v141, (uint64_t)a1, a3, (uint64_t)v165, 2, (int)v38 + 2, v41, 0, 1.0, 1.0, 0.025, v137, v7, v39, (unsigned __int8 *)&v161, 1);
        if ((result & 0x80000000) != 0)
          return result;
        *((_QWORD *)&v166 + 1) = *((_QWORD *)v35 - 18);
        v165[0] = *(v36 - 18);
        v42 = mfs_GetLeafIndex(v37, 0, (int)v38 + 2);
        result = mfs_IbAddtoVect(v141, (uint64_t)a1, a3, (uint64_t)v165, 0, (int)v38 + 2, v42, 0, 1.0, 1.0, 0.025, v137, v129, v39, (unsigned __int8 *)&v161, 0);
        v7 = v129;
        v10 = v153;
        v25 = v132;
        if ((result & 0x80000000) != 0)
          return result;
      }
    }
    v18 = *a1;
    v33 = v38 + 1;
    ++v36;
    v35 += 2;
    v4 = a2;
    if (v38 + 2 > v18)
    {
      v126 += v33;
      v6 = v141;
      v3 = (_DWORD *)a3;
      goto LABEL_40;
    }
  }
}

uint64_t concat_applyBPF(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v6;
  _DWORD *v7;
  float32x4_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const float *v12;
  float32x4_t v13;
  _OWORD v15[2];
  int v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x1E0C80C00];
  v17[0] = 0xBF95F27700000000;
  v17[1] = 0x3FE0EBB200000000;
  v17[2] = 0xBF95F27700000000;
  v17[3] = 0x3E95F27700000000;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  v6 = a3;
  v7 = (_DWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), a3, 4);
  if (!v7)
    return 2229280778;
  v9 = (uint64_t)v7;
  if (a3)
  {
    v10 = 0;
    do
    {
      v11 = 0;
      v12 = (const float *)&a2[4 * v10];
      v8.f32[0] = *(float *)v15 + (float)(*v12 * 0.29287);
      v7[v10] = v8.i32[0];
      v13 = vld1q_dup_f32(v12);
      v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 0);
      do
      {
        v15[v11 / 2] = vmlsq_f32(vmlaq_f32(*(float32x4_t *)((char *)&v15[v11 / 2] + 4), v13, *(float32x4_t *)&v17[v11]), v8, *(float32x4_t *)((char *)&unk_1DECECBDC + v11 * 8 + 4));
        v11 += 2;
      }
      while (v11 != 4);
      ++v10;
    }
    while (v10 != v6);
  }
  memcpy(a2, v7, 4 * v6);
  heap_Free(*(_QWORD **)(a1 + 8), v9);
  return 0;
}

uint64_t ConnectedContextLength_TahoeVersion(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  float v18;
  float v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  __int16 v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE v52[60];
  _BYTE v53[180];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v50 = 0;
  v51 = 0;
  v49 = 0;
  v48 = 0;
  v4 = *(_DWORD *)(a3 + 608);
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v45 = a3 + 1944;
    v41 = -1;
    v43 = 1;
    v40 = 528;
    do
    {
      if ((v5 & 0xFFFFFFFE) != 0)
      {
        v7 = 0;
        v8 = v41;
        while (1)
        {
          v9 = v7;
          if (v7 >= *(int *)(a1 + 8880))
            break;
          UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + 528 * v8), &v48);
          if (HIBYTE(v48) == 1)
            break;
          v53[v9 + 120] = HIBYTE(v48);
          --v8;
          v7 = v9 + 1;
          if (v41 == v9 + 1)
          {
            v10 = v41;
            goto LABEL_10;
          }
        }
        v10 = v9;
LABEL_10:
        v4 = *(_DWORD *)(a3 + 608);
      }
      else
      {
        v10 = 0;
      }
      if (v4 <= (int)++v5)
      {
        v15 = 0;
      }
      else
      {
        v11 = v10;
        v12 = v6;
        v13 = 0;
        v14 = v40;
        while (v13 < *(int *)(a1 + 8880))
        {
          UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + v14), &v48);
          if (HIBYTE(v48) == 1)
            break;
          v53[v13 + 60] = HIBYTE(v48);
          v15 = v13 + 1;
          v14 += 528;
          v16 = v43 + ++v13;
          if (*(_DWORD *)(a3 + 608) <= v16)
            goto LABEL_20;
        }
        v15 = v13;
LABEL_20:
        v6 = v12;
        v10 = v11;
      }
      v17 = *(_DWORD *)a2;
      if (*(int *)a2 >= 1)
      {
        v18 = (float)v15;
        v19 = (float)v10;
        v20 = 2;
        v42 = v5;
        do
        {
          v21 = *(_DWORD *)(a1 + 8880);
          v22 = (int)v6 >= v21 && v21 + (int)v6 < *(_DWORD *)(a3 + 608) * v17;
          if (v22)
          {
            v23 = (int)v6;
            v24 = *(_QWORD *)(a3 + 1952);
            if (*(_DWORD *)(v24 + 32 * (int)v6 + 16))
            {
              v44 = v20;
              v25 = 0;
              do
              {
                v26 = *(_QWORD *)(v24 + 32 * v23);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v26 + 8 * v25), (uint64_t)v53, (_DWORD *)&v51 + 1, 1, v6, (_DWORD *)&v50 + 1);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v26 + 8 * v25), (uint64_t)v52, &v51, 0, v6, &v50);
                if (v15 >= (int)v51)
                  v27 = v51;
                else
                  v27 = v15;
                v28 = 0.0;
                if ((_DWORD)v27)
                {
                  if ((int)v27 < 1)
                  {
                    LODWORD(v27) = 0;
                  }
                  else
                  {
                    v29 = 0;
                    while (v53[v29 + 60] == v52[v29])
                    {
                      if (v27 == ++v29)
                        goto LABEL_41;
                    }
                    LODWORD(v27) = v29;
                  }
LABEL_41:
                  v28 = (float)(int)v27 / v18;
                }
                if (v15 >= (int)v50)
                  v30 = v50;
                else
                  v30 = v15;
                v31 = 0.0;
                if ((_DWORD)v30)
                {
                  if ((int)v30 < 1)
                  {
                    LODWORD(v30) = 0;
                  }
                  else
                  {
                    v32 = 0;
                    while (v53[v32 + 60] == v52[v32])
                    {
                      if (v30 == ++v32)
                        goto LABEL_53;
                    }
                    LODWORD(v30) = v32;
                  }
LABEL_53:
                  v31 = (float)(int)v30 / v18;
                }
                if (v10 >= SHIDWORD(v50))
                  v33 = HIDWORD(v50);
                else
                  v33 = v10;
                v34 = 0.0;
                v35 = 0.0;
                if ((_DWORD)v33)
                {
                  if ((int)v33 < 1)
                  {
                    LODWORD(v33) = 0;
                  }
                  else
                  {
                    v36 = 0;
                    while (v53[v36 + 120] == v53[v36])
                    {
                      if (v33 == ++v36)
                        goto LABEL_65;
                    }
                    LODWORD(v33) = v36;
                  }
LABEL_65:
                  v35 = (float)(int)v33 / v19;
                }
                if (v10 >= SHIDWORD(v51))
                  v37 = HIDWORD(v51);
                else
                  v37 = v10;
                if ((_DWORD)v37)
                {
                  if ((int)v37 < 1)
                  {
                    LODWORD(v37) = 0;
                  }
                  else
                  {
                    v38 = 0;
                    while (v53[v38 + 120] == v53[v38])
                    {
                      if (v37 == ++v38)
                        goto LABEL_77;
                    }
                    LODWORD(v37) = v38;
                  }
LABEL_77:
                  v34 = (float)(int)v37 / v19;
                }
                mfs_CostList_UpdateCost(v45, v6, v25, (float)(*(float *)(v26 + 8 * v25 + 4) * 0.1)+ (float)((float)((float)(1.0- (float)((float)((float)((float)((float)(v28 * 0.1) + 0.0) + (float)(v31 * 0.4))+ (float)(v35 * 0.4))+ (float)(v34 * 0.1)))* 0.9)* *(float *)(v26 + 8 * v25 + 4)));
                ++v25;
                v24 = *(_QWORD *)(a3 + 1952);
                v23 = (int)v6;
              }
              while (v25 < *(unsigned int *)(v24 + 32 * (int)v6 + 16));
              v17 = *(_DWORD *)a2;
              v5 = v42;
              v20 = v44;
            }
            v6 = (v6 + 1);
          }
          v22 = v20++ <= v17;
        }
        while (v22);
      }
      v4 = *(_DWORD *)(a3 + 608);
      ++v43;
      v40 += 528;
      ++v41;
    }
    while (v4 > (int)v5);
  }
  mfs_CostList_FreeUidIndex((_QWORD *)(a3 + 1944));
  return 0;
}

uint64_t CandGetContext(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6, int a7, signed int a8, _DWORD *a9)
{
  unsigned int v13;
  int v16;
  uint64_t result;
  int v18;
  int v19;
  signed int v20;
  uint64_t v21;
  int v22;
  signed int v23;
  unsigned int v24;
  int v25;
  _DWORD *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  int v32;
  _QWORD *v33;
  _QWORD v34[2];

  v13 = a4;
  v16 = *(_DWORD *)a2;
  v34[0] = 0;
  v34[1] = 0;
  v33 = v34;
  result = mfs_getUnitDataFromMfsData(a2, a4, (uint64_t *)&v33);
  if (a7 == 1)
    v18 = -v16;
  else
    v18 = v16;
  if (a7 == 1)
    v19 = -1;
  else
    v19 = 1;
  v30 = v18;
  v20 = v18 + v13;
  if ((int)(v18 + v13) < 0)
  {
    LODWORD(v21) = 0;
    v25 = 0;
  }
  else
  {
    v26 = a6;
    v21 = 0;
    v22 = *((unsigned __int16 *)v33 + 5);
    v32 = 1;
    v29 = a5;
    v27 = 0;
    v28 = v22;
    do
    {
      result = mfs_getUnitDataFromMfsData(a2, v20, (uint64_t *)&v33);
      if ((result & 0x80000000) != 0)
        break;
      if (v22 != *((unsigned __int16 *)v33 + 5))
        break;
      if (v21 >= *(int *)(a1 + 8880))
        break;
      if (v20 <= *(_DWORD *)a2)
        break;
      result = mfs_getUnitDataFromMfsData(a2, v20, (uint64_t *)&v33);
      if (*((_BYTE *)v33 + 13) == 1)
        break;
      if (v32)
      {
        while (1)
        {
          v23 = a8;
          a8 += v19;
          if (a8 < 0)
            break;
          v24 = v13 + v19;
          if (((v13 + v19) & 0x80000000) != 0
            || a8 == *(_DWORD *)(a3 + 1960)
            || !mfs_CostList_HasUnit((_QWORD *)(a3 + 1944), a8, v13 + v19))
          {
            break;
          }
          v13 += v19;
          if (v20 == v24)
          {
            ++v27;
            a8 = v19 + v23;
            v13 = v20;
            goto LABEL_22;
          }
        }
        v32 = 0;
        a8 = v19 + v23;
        v13 += v19;
LABEL_22:
        a5 = v29;
        v22 = v28;
      }
      else
      {
        v32 = 0;
      }
      result = mfs_getUnitDataFromMfsData(a2, v20, (uint64_t *)&v33);
      *(_BYTE *)(a5 + v21++) = *((_BYTE *)v33 + 13);
      v20 += v30;
    }
    while (v20 >= 0);
    a6 = v26;
    v25 = v27;
  }
  *a6 = v21;
  *a9 = v25;
  return result;
}

uint64_t ConnectedContextLength(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  float v19;
  float v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  __int16 v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE v54[60];
  _BYTE v55[180];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v52 = 0;
  v53 = 0;
  v51 = 0;
  v50 = 0;
  LODWORD(v4) = *(_DWORD *)(a3 + 608);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    LODWORD(v6) = 0;
    v7 = a3 + 1944;
    v44 = -1;
    v45 = 1;
    v43 = 528;
    do
    {
      v8 = *(_QWORD *)(a3 + 600);
      if (v5 < 2)
      {
        v13 = 0;
      }
      else
      {
        v9 = *(_QWORD *)(a3 + 600);
        v10 = 0;
        v11 = v44;
        while (1)
        {
          v12 = v10;
          if (v10 >= *(int *)(a1 + 8880))
            break;
          UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + 528 * v11), &v50);
          if (HIBYTE(v50) == 1)
            break;
          v55[v12 + 120] = HIBYTE(v50);
          --v11;
          v10 = v12 + 1;
          if (v44 == v12 + 1)
          {
            v13 = v44;
            goto LABEL_11;
          }
        }
        v13 = v12;
LABEL_11:
        LODWORD(v4) = *(_DWORD *)(a3 + 608);
        v8 = v9;
      }
      v42 = v5 + 1;
      if ((uint64_t)(v5 + 1) >= (int)v4)
      {
        v16 = 0;
      }
      else
      {
        v46 = v8;
        v14 = 0;
        v15 = v43;
        while (v14 < *(int *)(a1 + 8880))
        {
          UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + v15), &v50);
          if (HIBYTE(v50) == 1)
            break;
          v55[v14 + 60] = HIBYTE(v50);
          v16 = v14 + 1;
          v15 += 528;
          v17 = v45 + ++v14;
          if (*(_DWORD *)(a3 + 608) <= v17)
            goto LABEL_20;
        }
        v16 = v14;
LABEL_20:
        v8 = v46;
      }
      UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(v8 + 528 * v5), &v50);
      v18 = *(_DWORD *)a2;
      if (*(int *)a2 >= 1)
      {
        v19 = (float)v16;
        v20 = (float)v13;
        v6 = (int)v6;
        v21 = 2;
        do
        {
          v22 = v21 == v18 + 1 && v51 == 1;
          if (v22 && *(_DWORD *)(*(_QWORD *)(a3 + 1952) + 32 * v6 + 16))
          {
            v23 = 0;
            do
              mfs_CostList_UpdateCost(v7, v6, v23++, 0.0);
            while (v23 < *(_DWORD *)(*(_QWORD *)(a3 + 1952) + 32 * v6 + 16));
            v18 = *(_DWORD *)a2;
          }
          v24 = *(int *)(a1 + 8880);
          v25 = v6 >= v24 && (int)v24 + (int)v6 < v18 * *(_DWORD *)(a3 + 608);
          if (v25)
          {
            v26 = *(_QWORD *)(a3 + 1952);
            if (*(_DWORD *)(v26 + 32 * v6 + 16))
            {
              v47 = v21;
              v27 = 0;
              do
              {
                v28 = *(_QWORD *)(v26 + 32 * v6);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v28 + 8 * v27), (uint64_t)v55, (_DWORD *)&v53 + 1, 1, v6, (_DWORD *)&v52 + 1);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v28 + 8 * v27), (uint64_t)v54, &v53, 0, v6, &v52);
                if (v16 >= (int)v53)
                  v29 = v53;
                else
                  v29 = v16;
                v30 = 0.0;
                if ((_DWORD)v29)
                {
                  if ((int)v29 < 1)
                  {
                    LODWORD(v29) = 0;
                  }
                  else
                  {
                    v31 = 0;
                    while (v55[v31 + 60] == v54[v31])
                    {
                      if (v29 == ++v31)
                        goto LABEL_50;
                    }
                    LODWORD(v29) = v31;
                  }
LABEL_50:
                  v30 = (float)(int)v29 / v19;
                }
                if (v16 >= (int)v52)
                  v32 = v52;
                else
                  v32 = v16;
                v33 = 0.0;
                if ((_DWORD)v32)
                {
                  if ((int)v32 < 1)
                  {
                    LODWORD(v32) = 0;
                  }
                  else
                  {
                    v34 = 0;
                    while (v55[v34 + 60] == v54[v34])
                    {
                      if (v32 == ++v34)
                        goto LABEL_62;
                    }
                    LODWORD(v32) = v34;
                  }
LABEL_62:
                  v33 = (float)(int)v32 / v19;
                }
                if (v13 >= SHIDWORD(v52))
                  v35 = HIDWORD(v52);
                else
                  v35 = v13;
                v36 = 0.0;
                v37 = 0.0;
                if ((_DWORD)v35)
                {
                  if ((int)v35 < 1)
                  {
                    LODWORD(v35) = 0;
                  }
                  else
                  {
                    v38 = 0;
                    while (v55[v38 + 120] == v55[v38])
                    {
                      if (v35 == ++v38)
                        goto LABEL_74;
                    }
                    LODWORD(v35) = v38;
                  }
LABEL_74:
                  v37 = (float)(int)v35 / v20;
                }
                if (v13 >= SHIDWORD(v53))
                  v39 = HIDWORD(v53);
                else
                  v39 = v13;
                if ((_DWORD)v39)
                {
                  if ((int)v39 < 1)
                  {
                    LODWORD(v39) = 0;
                  }
                  else
                  {
                    v40 = 0;
                    while (v55[v40 + 120] == v55[v40])
                    {
                      if (v39 == ++v40)
                        goto LABEL_86;
                    }
                    LODWORD(v39) = v40;
                  }
LABEL_86:
                  v36 = (float)(int)v39 / v20;
                }
                mfs_CostList_UpdateCost(v7, v6, v27, *(float *)(v28 + 8 * v27 + 4)* (float)(1.0- (float)((float)((float)((float)((float)(v30 * 0.1) + 0.0) + (float)(v33 * 0.4))+ (float)(v37 * 0.4))+ (float)(v36 * 0.1))));
                ++v27;
                v26 = *(_QWORD *)(a3 + 1952);
              }
              while (v27 < *(unsigned int *)(v26 + 32 * v6 + 16));
              v18 = *(_DWORD *)a2;
              v21 = v47;
            }
          }
          ++v6;
          v25 = v21++ <= v18;
        }
        while (v25);
      }
      v4 = *(int *)(a3 + 608);
      ++v44;
      ++v45;
      v43 += 528;
      ++v5;
    }
    while (v42 < v4);
  }
  mfs_CostList_FreeUidIndex((_QWORD *)(a3 + 1944));
  return 0;
}

uint64_t PruneDPListOnContext(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  signed int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  float v26;
  float v27;
  uint64_t v28;
  signed int v29;
  signed int *v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v40;
  _QWORD v41[2];
  __int16 v42;
  char v43;

  v41[0] = 0;
  v41[1] = 0;
  v40 = v41;
  if (*(int *)(a3 + 608) >= 1)
  {
    v6 = a1;
    v36 = 0;
    v7 = 0;
    v8 = 0;
    v43 = 0;
    v42 = 0;
    v9 = (_QWORD *)(a3 + 1944);
    while (1)
    {
      v10 = *(_QWORD *)(a3 + 600);
      v11 = v36;
      UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), v36, &v42);
      v12 = *(_DWORD *)a2;
      if (HIBYTE(v42) == 1)
      {
        if (v12 >= 1)
        {
          v13 = 0;
          v14 = (32 * v7) | 0x10;
          while (!a4)
          {
            v16 = *(_DWORD *)(v6 + 8256);
            if (v16)
            {
              if (v16 >= *(_DWORD *)(v6 + 8240))
                v17 = *(_DWORD *)(v6 + 8240);
              else
                v17 = *(_DWORD *)(v6 + 8256);
            }
            else
            {
              v17 = 20;
            }
            *(_DWORD *)(*(_QWORD *)(a3 + 2016) + 4 * v7 + 4 * v13) = v17;
            if (*(_DWORD *)(*(_QWORD *)(a3 + 1952) + v14) > v17)
            {
              v15 = mfs_CostList_SelectAndPrune(v9, v7 + (int)v13, 1, v17);
LABEL_15:
              v8 = v15;
              if ((v15 & 0x80000000) != 0)
                return v8;
              goto LABEL_16;
            }
            v8 = 0;
LABEL_16:
            ++v13;
            v14 += 32;
            if ((int)v13 + 1 > *(_DWORD *)a2)
            {
              v7 += v13;
              goto LABEL_51;
            }
          }
          v15 = mfs_CostList_Sort((uint64_t)v9, v7 + (int)v13, 1);
          goto LABEL_15;
        }
      }
      else if (v12 >= 1)
      {
        v37 = (_QWORD *)(v10 + 528 * v36 + 312);
        v18 = v7;
        v19 = 2;
        v20 = a4;
        do
        {
          v21 = *(_QWORD *)(a3 + 1952);
          if (v20)
          {
            if (!*(_DWORD *)(v21 + 32 * v18 + 16))
              goto LABEL_34;
            v22 = 0;
            v23 = 0;
            v24 = 0;
            do
            {
              v25 = *(_QWORD *)(v21 + 32 * v18);
              mfs_getUnitDataFromMfsData(a2, *(_DWORD *)(v25 + v22), (uint64_t *)&v40);
              if (*((unsigned __int8 *)v40 + 13) == HIBYTE(v42))
              {
                if (v42 != *((unsigned __int8 *)v40 + 12))
                  mfs_CostList_UpdateCost((uint64_t)v9, v18, v23, *(float *)(v25 + v22 + 4) * 1.2);
                ++v24;
              }
              else
              {
                v26 = *(float *)(v25 + v22 + 4);
                if (v26 == 0.0)
                  v27 = 300.0;
                else
                  v27 = (float)(v26 * 1.2) * 300.0;
                mfs_CostList_UpdateCost((uint64_t)v9, v18, v23, v27);
              }
              ++v23;
              v21 = *(_QWORD *)(a3 + 1952);
              v22 += 8;
            }
            while (v23 < *(unsigned int *)(v21 + 32 * v18 + 16));
            v20 = a4;
            if (!v24)
            {
LABEL_34:
              MFS__log_select_Diag(*(_QWORD *)(a3 + 1928), 1, (uint64_t)"*** No CurMatch Candidates for (%d) (%d)\n");
              v21 = *(_QWORD *)(a3 + 1952);
            }
          }
          v28 = v21 + 32 * v18;
          v31 = *(_DWORD *)(v28 + 16);
          v30 = (signed int *)(v28 + 16);
          v29 = v31;
          v6 = a1;
          if (v31 >= 21)
          {
            if (*(_DWORD *)(a1 + 8240) >= (int)(float)(*(float *)(a1 + 8236) * (float)v29))
              v29 = (int)(float)(*(float *)(a1 + 8236) * (float)v29);
            else
              v29 = *(_DWORD *)(a1 + 8240);
          }
          v32 = *(_QWORD *)(a3 + 2016);
          *(_DWORD *)(v32 + 4 * v18) = v29;
          if (*(_DWORD *)(a1 + 8968) == 5 && (*(_BYTE *)(*v37 + v19) & 4) == 0)
          {
            v33 = *(_DWORD *)(a1 + 8244);
            if (v33 < *(_DWORD *)(a1 + 8240))
            {
              v29 = *v30;
              if (*v30 >= 21)
              {
                if (v33 >= (int)(float)(*(float *)(a1 + 8236) * (float)v29))
                  v29 = (int)(float)(*(float *)(a1 + 8236) * (float)v29);
                else
                  v29 = *(_DWORD *)(a1 + 8244);
              }
              *(_DWORD *)(v32 + 4 * v18) = v29;
            }
          }
          if (*v30 > v29)
          {
            v8 = mfs_CostList_SelectAndPrune(v9, v18, 1, v29);
            if ((v8 & 0x80000000) != 0)
              return v8;
          }
          ++v18;
        }
        while (v19++ <= *(int *)a2);
        v7 = v18;
LABEL_51:
        v11 = v36;
      }
      v36 = v11 + 1;
      if (v11 + 1 >= *(int *)(a3 + 608))
        return v8;
    }
  }
  return 0;
}

uint64_t mfs_StatisticalSelection_Obersee(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  uint64_t inited;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int **v26;
  uint64_t v27;
  int v28;
  int *v29;
  __int16 *v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  float v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  float v52;
  _QWORD *v53;
  int32x2_t v54;
  _QWORD *v55;
  uint64_t *v56;
  uint64_t v57;
  int v58;
  int *v59;
  int v60;
  int v61;
  uint64_t v62;
  float32x4_t **v63;
  float v64;
  float32x4_t *v65;
  float v66;
  float32x4_t *v67;
  int v68;
  float **v69;
  int v70;
  float v71;
  float *v72;
  float v73;
  float32x4_t *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t *v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int UsedMemory;
  uint64_t v87;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  _QWORD *v97;
  int v98;
  int v99;
  uint64_t *v100;
  int v101;
  uint64_t v102;
  int v104;
  float32x4_t v105;
  unsigned int v106;
  _QWORD v107[2];

  v6 = *(_QWORD *)(a1 + 1928);
  v7 = *(unsigned int *)(a1 + 620);
  v107[0] = 0;
  *(_DWORD *)(a1 + 2580) = *(_DWORD *)(a1 + 2584);
  v96 = v6;
  if (*(_DWORD *)(a1 + 2592) != 1)
  {
    v8 = 2229280778;
    MFS__log_select_Diag(v6, 1, (uint64_t)"HybridStatisticalSelection(emfs obersee:%s) {\n");
    MFS__log_select_Diag(v6, 2, (uint64_t)"Search mode: MFS_SEARCHMODE_DRAGON_TAHOE\n");
    v47 = (uint64_t *)heap_Calloc(*(_QWORD **)(v6 + 8), 1, 18240);
    *(_QWORD *)(a1 + 2568) = v47;
    if (!v47)
      return v8;
    v102 = (uint64_t)v47;
    inited = mfs_uselect_Init_Obersee(v47, a1, (uint64_t)a3, a4);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    *(_DWORD *)(a1 + 2064) = 2;
    *(_DWORD *)(a1 + 1936) = v7;
    v48 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), (2 * v7), 4);
    *(_QWORD *)(a1 + 2088) = v48;
    if (!v48)
      goto LABEL_95;
    v49 = v48 + 4 * v7;
    *(_QWORD *)(a1 + 2096) = v49;
    if ((_DWORD)v7)
    {
      v50 = 0;
      do
      {
        *(_DWORD *)(v49 + v50) = *(_DWORD *)(a4 + 8248);
        *(_DWORD *)(v48 + v50) = *(_DWORD *)(a4 + 8172);
        v50 += 4;
      }
      while (4 * v7 != v50);
    }
    inited = mfs_Search_InitPrefilter(v102);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    v99 = *a3;
    if (*a3 >= 0)
      v51 = *a3;
    else
      v51 = *a3 + 1;
    if ((*(_DWORD *)(a4 + 8968) - 7) >= 5)
      v52 = 1.0;
    else
      v52 = 2.0;
    v53 = BET3FLT__ddcalloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), v7, 4);
    if (v53)
    {
      v55 = v53;
      v54.i32[0] = 1.0;
      if ((*(_DWORD *)(a4 + 8968) - 7) >= 5)
        *(float *)v54.i32 = (float)(*(float *)(a4 + 8160) + *(float *)(a4 + 8124)) + *(float *)(a4 + 8128);
      v56 = (uint64_t *)v102;
      if (*(int *)(a1 + 608) >= 1)
      {
        v57 = 0;
        v58 = 0;
        v59 = 0;
        v60 = v51 >> 1;
        if (v60 <= 2)
          v61 = 2;
        else
          v61 = v60;
        v98 = v61;
        v95 = v61 - 1;
        v101 = v60;
        v105 = (float32x4_t)vdupq_lane_s32(v54, 0);
        do
        {
          v62 = *(_QWORD *)(a1 + 600);
          if (v59)
          {
            if (v60 < *a3)
            {
              v63 = (float32x4_t **)&v55[v58];
              do
              {
                (*v63)->f32[0] = UNICORN__mfs_Ling_TransWeightsDiphADJ(*(_QWORD **)(a1 + 8), *v59)
                               * *(float *)(a4 + 8160);
                (*v63)->f32[1] = UNICORN__mfs_Ling_TransWeightsDiphMCP(*(_QWORD **)(a1 + 8), *v59)
                               * *(float *)(a4 + 8124);
                v64 = UNICORN__mfs_Ling_TransWeightsDiphLF0(*(_QWORD **)(a1 + 8), *v59);
                v65 = *v63++;
                v65->f32[2] = v64 * *(float *)(a4 + 8128);
                v65->i32[3] = 0;
                *v65 = vdivq_f32(*v65, v105);
                ++v60;
                ++v58;
              }
              while (v60 < *a3);
            }
            *(float *)v55[v58] = v52
                               * (float)(UNICORN__mfs_Ling_TransWeightsPhonADJ(*(_QWORD **)(a1 + 8), *v59)
                                       * *(float *)(a4 + 8160));
            *(float *)(v55[v58] + 4) = v52
                                       * (float)(UNICORN__mfs_Ling_TransWeightsPhonMCP(*(_QWORD **)(a1 + 8), *v59)
                                               * *(float *)(a4 + 8124));
            v66 = UNICORN__mfs_Ling_TransWeightsPhonLF0(*(_QWORD **)(a1 + 8), *v59);
            v67 = (float32x4_t *)v55[v58];
            v67->f32[2] = v52 * (float)(v66 * *(float *)(a4 + 8128));
            v67->i32[3] = 0;
            *v67 = vdivq_f32(*v67, v105);
            v68 = v58 + 1;
            v56 = (uint64_t *)v102;
            v60 = v101;
            if (v99 >= 4)
            {
              v69 = (float **)&v55[v68];
              v68 = v98 + v58;
              v70 = v95;
              do
              {
                v71 = v52
                    * (float)(UNICORN__mfs_Ling_TransWeightsDiphADJ(*(_QWORD **)(a1 + 8), *v59) * *(float *)(a4 + 8160));
                v72 = *v69;
                **v69 = v71;
                if ((*(_DWORD *)(a4 + 8968) - 7) <= 4 && v59[6] == *a3)
                  *v72 = v71 + 1.0;
                (*v69)[1] = v52
                          * (float)(UNICORN__mfs_Ling_TransWeightsDiphMCP(*(_QWORD **)(a1 + 8), *v59)
                                  * *(float *)(a4 + 8124));
                v73 = UNICORN__mfs_Ling_TransWeightsDiphLF0(*(_QWORD **)(a1 + 8), *v59);
                v74 = (float32x4_t *)*v69++;
                v74->f32[2] = v52 * (float)(v73 * *(float *)(a4 + 8128));
                v74->i32[3] = 0;
                *v74 = vdivq_f32(*v74, v105);
                --v70;
              }
              while (v70);
              v56 = (uint64_t *)v102;
              v60 = v101;
            }
          }
          else
          {
            v68 = v58 + v60;
          }
          v59 = (int *)(v62 + 528 * v57++);
          v58 = v68;
        }
        while (v57 < *(int *)(a1 + 608));
      }
      *(_QWORD *)(a1 + 2072) = v55;
      v75 = v56[72];
      v76 = v56[73];
      v77 = *(_DWORD *)(v76 + 1096);
      v78 = v56;
      v79 = mfs_Viterbi_Init_Obersee((uint64_t)(v56 + 106), *v56, v76, v75, (uint64_t)(v56 + 203));
      if ((v79 & 0x80000000) == 0)
      {
        v80 = v75 + 2144;
        inited = UNICORN__mfs_S32Vect_Reserve(v75 + 2144, *(_DWORD *)(v78[72] + 1936));
        v6 = v96;
        if ((inited & 0x80000000) == 0)
        {
          v81 = v75 + 2168;
          v8 = UNICORN__mfs_F32Vect_Create(v81, *(_DWORD *)(v78[72] + 1936));
          if ((v8 & 0x80000000) != 0)
            goto LABEL_95;
          if (*(_DWORD *)(v78[72] + 1936))
          {
            v82 = 0;
            do
            {
              v8 = UNICORN__mfs_F32Vect_Pad(v81, 0.0);
              if ((v8 & 0x80000000) != 0)
                goto LABEL_100;
              mfs_S32Vect_Add(v80, v77 - 1);
              ++v82;
              v83 = (uint64_t *)v102;
            }
            while (v82 < *(_DWORD *)(*(_QWORD *)(v102 + 576) + 1936));
            v6 = v96;
          }
          else
          {
            v83 = v78;
          }
          MFS__log_select_Diag(*v83, 3, (uint64_t)"viterbi::init  SegsDp %d\n");
          v10 = v102;
          v9 = 0;
          goto LABEL_3;
        }
LABEL_94:
        v8 = inited;
        goto LABEL_95;
      }
      v8 = v79;
    }
LABEL_100:
    v6 = v96;
    goto LABEL_95;
  }
  v8 = 0;
  v9 = *(_DWORD *)(a1 + 2576);
  *(_DWORD *)(a1 + 2576) = 0;
  v10 = *(_QWORD *)(a1 + 2568);
LABEL_3:
  v102 = v10;
  if (v9 >= *(_DWORD *)(a1 + 608))
    goto LABEL_106;
  v11 = v10 + 600;
  v100 = (uint64_t *)(v10 + 848);
  v97 = (_QWORD *)(v10 + 8);
  v12 = v9;
  v93 = v10 + 600;
  while (2)
  {
    v13 = v12;
    v94 = v12;
    v14 = (uint64_t *)v10;
    MFS__log_select_Diag(v6, 3, (uint64_t)"phoneme %d %d %d\n");
    ForcedEEController_TimeGet(a2, (_DWORD *)v107 + 1);
    inited = mfs_Search_FindNodeCandidates_StatSelect_Obersee((uint64_t)v14, v13);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    inited = mfs_PruneDPListOnContext_Obersee(v14, v13);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    if (ForcedEEController_TimeGet(a2, v107))
      MFS__log_select_Diag(v6, 1, (uint64_t)"Timing phoneme %d Prefilter : elapsetime : %u msecs  (number of candidates : %u %u %u)\n");
    v16 = *(uint64_t **)(a1 + 2640);
    if (v16)
    {
      v17 = 0;
      v18 = *((_DWORD *)v16 + 5);
      v19 = *v16;
      do
      {
        v20 = v18 + v17 + 3 * v94;
        if (*(_DWORD *)(v19 + 48 * v20) == 1)
        {
          v21 = *(_QWORD *)(v11 + 80 * v17 + 32);
          v22 = -1431655765 * ((unint64_t)(*(_QWORD *)(v11 + 80 * v17 + 40) - v21) >> 3);
          if ((_DWORD)v22)
          {
            v23 = 0;
            v24 = v19 + 48 * v20;
            v25 = *(unsigned int *)(v24 + 24);
            v26 = (int **)(v24 + 8);
            do
            {
              if ((_DWORD)v25)
              {
                v27 = v21 + 24 * v23;
                v28 = *(_DWORD *)(v27 + 4);
                v29 = *v26;
                v30 = (__int16 *)(v27 + 8);
                v31 = v25;
                do
                {
                  v32 = *v29++;
                  if (v28 == v32)
                  {
                    v33 = (unsigned __int16)*v30;
                    if (v33 > 0xEC77)
                      v34 = -1;
                    else
                      v34 = v33 + 5000;
                    *v30 = v34;
                  }
                  --v31;
                }
                while (v31);
              }
              ++v23;
            }
            while (v23 != v22);
          }
        }
        ++v17;
      }
      while (v17 != 3);
      v104 = 3 * v94;
    }
    else
    {
      v104 = 3 * v94;
    }
    v35 = 0;
    v36 = (uint64_t)v97;
    do
    {
      ForcedEEController_TimeGet(a2, (_DWORD *)v107 + 1);
      v37 = -1431655765 * ((*(_QWORD *)(v11 + 40) - *(_QWORD *)(v11 + 32)) >> 3);
      if (v37 >= 21)
      {
        v38 = (float)v37;
        v39 = *(_QWORD *)(v102 + 592);
        v40 = (int)(float)(*(float *)(v39 + 8236) * v38);
        v37 = *(_DWORD *)(v39 + 8240);
        if (v37 >= v40)
          v37 = v40;
      }
      v41 = v104 + v35;
      v42 = *(_DWORD *)(v102 + 840);
      if (v37)
      {
        if (v42 != -1)
          goto LABEL_34;
        *(_DWORD *)(v102 + 840) = v41;
        v43 = mfs_Viterbi_Reset_Obersee((uint64_t)v100, v41);
        if ((v43 & 0x80000000) == 0)
        {
          MFS__log_select_Diag(*(_QWORD *)v102, 3, (uint64_t)"viterbi::start path %d\n");
          v36 = (uint64_t)v97;
LABEL_34:
          v8 = mfs_Viterbi_DecodeState_MCP_S9_LF0_S8_X2B_Obersee((uint64_t)v100, v11);
          goto LABEL_41;
        }
        v8 = v43;
        v36 = (uint64_t)v97;
      }
      else if (v42 == -1)
      {
        v8 = 0;
      }
      else
      {
        MFS__log_select_Diag(*(_QWORD *)v102, 3, (uint64_t)"Stopping viterbi at frame %u because of a dead part\n");
        v44 = *(_QWORD *)(v102 + 576);
        MFS__log_select_Diag(*(_QWORD *)v102, 3, (uint64_t)"viterbi::end path %d\n");
        v8 = mfs_Viterbi_ResultScore_Obersee((uint64_t)v100, v44 + 2144, v44 + 2168);
        if ((v8 & 0x80000000) == 0)
          *(_DWORD *)(v102 + 840) = -1;
        v6 = v96;
        v36 = (uint64_t)v97;
      }
LABEL_41:
      if (ForcedEEController_TimeGet(a2, v107))
        MFS__log_select_Diag(v6, 1, (uint64_t)"Timing phoneme %d Viterbi state %d  : elapsetime  %u msecs\n");
      if ((v8 & 0x80000000) != 0)
        goto LABEL_95;
      mfs_CandidateList_Reset_Obersee(v11, *(_QWORD *)(v6 + 8), v36);
      ++v35;
      v11 += 80;
    }
    while (v35 != 3);
    v12 = v94 + 1;
    v45 = *(_DWORD *)(a1 + 608);
    if (!*(_DWORD *)(a4 + 8564))
    {
      v11 = v93;
LABEL_50:
      v10 = v102;
      if (v12 >= v45)
        goto LABEL_106;
      continue;
    }
    break;
  }
  v11 = v93;
  if (v12 >= v45)
    goto LABEL_50;
  if (!mfs_Viterbi_IsEarlyEmissionPossible(v100, a2, *(_DWORD *)(a1 + 2584)))
  {
    v45 = *(_DWORD *)(a1 + 608);
    goto LABEL_50;
  }
  v85 = *(_DWORD *)(v102 + 1452);
  mfs_Search_StopViterbi((uint64_t *)v102, (3 * v12), 1);
  UsedMemory = fastallo_GetUsedMemory((uint64_t)v97);
  if (UsedMemory > *(_DWORD *)(v102 + 568))
    *(_DWORD *)(v102 + 568) = UsedMemory;
  fastallo_Terminate(v97);
  fastallo_Init(v97, *(_QWORD *)(*(_QWORD *)v102 + 8), 4096);
  *(_DWORD *)(a1 + 2592) = 0;
  *(_DWORD *)(a1 + 2576) = v12;
  *(_DWORD *)(a1 + 2584) = v85;
  mfs_Search_LogSelectedUnits((uint64_t *)v102, *(_DWORD *)(a1 + 2580), v85);
  MFS__log_select_Diag(v6, 3, (uint64_t)"previous units were emitted via early emission at phoneme %d\n");
  v87 = mfs_UnitSequence_SequenceEarlyEmission_Obersee((uint64_t *)v102, *(_DWORD *)(a1 + 2580), *(_DWORD *)(a1 + 2584));
  v10 = v102;
  v8 = v87;
  if ((v87 & 0x80000000) != 0)
  {
LABEL_95:
    v84 = mfs_uselect_Finalize_Obersee((uint64_t *)v102);
    if ((v84 & 0x80000000) != 0)
    {
      return v84;
    }
    else
    {
      *(_DWORD *)(a1 + 2592) = 2;
      if ((v8 & 0x80000000) == 0)
        goto LABEL_107;
    }
  }
  else
  {
LABEL_106:
    mfs_Search_EndPrefilterRun(v10);
    if (!*(_DWORD *)(a1 + 2576))
    {
      *(_DWORD *)(a1 + 2584) = 3 * *(_DWORD *)(a1 + 608);
      v8 = mfs_Search_FinishViterbi(v102);
      if ((v8 & 0x80000000) != 0)
        goto LABEL_95;
      if (!*(_DWORD *)(a1 + 2200) && !*(_DWORD *)(a4 + 8564))
      {
        FreeRemainingStreams(a1);
        v89 = *(_DWORD *)(a1 + 32);
        if (v89 >= 1)
        {
          v90 = 0;
          v91 = 12;
          do
          {
            v92 = *(_QWORD *)(a1 + 24);
            if (*(_DWORD *)(v92 + v91) != 2)
            {
              BET3FLT__FreePStreamParam((_QWORD *)(v92 + v91 + 12));
              v89 = *(_DWORD *)(a1 + 32);
            }
            ++v90;
            v91 += 1528;
          }
          while (v90 < v89);
        }
      }
      MFS__log_select_Diag(v6, 1, (uint64_t)"}\n");
      if (!*(_DWORD *)(a1 + 2576))
        goto LABEL_95;
    }
LABEL_107:
    if (!ForcedEEController_HasStartedPlayback(a2))
    {
      v106 = 0;
      if (*(_DWORD *)(a4 + 8588) == -1
        || (paramc_ParamGetUInt(*(_QWORD *)(v6 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", &v106) & 0x80000000) != 0|| v106 >= *(_DWORD *)(a4 + 8588))
      {
        ForcedEEController_SetStartedPlayback(a2);
      }
    }
  }
  return v8;
}

uint64_t mfs_Search_StopViterbi(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;

  v4 = a1[72];
  v5 = *a1;
  if (a3)
    v6 = "viterbi::early emission:at state index %d we have a fully determined path up to state index %d\n";
  else
    v6 = "viterbi::end path %d\n";
  MFS__log_select_Diag(v5, 3, (uint64_t)v6);
  return mfs_Viterbi_ResultScore_Obersee((uint64_t)(a1 + 106), v4 + 2144, v4 + 2168);
}

uint64_t *mfs_Search_LogSelectedUnits(uint64_t *result, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD v8[2];

  v3 = a3 - a2;
  if (a3 > a2)
  {
    v4 = result;
    v5 = *result;
    v6 = result[72];
    v7 = a2;
    do
    {
      memset(v8, 0, sizeof(v8));
      mfs_getUnitData_Obersee(v4[73], *v4, *(_DWORD *)(*(_QWORD *)(v6 + 2152) + 4 * v7), (uint64_t)v8);
      result = (uint64_t *)MFS__log_select_Diag(v5, 3, (uint64_t)"unit %d: %d %f\n");
      ++v7;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t mfs_Search_FinishViterbi(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t UnitData_Obersee;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  int v9;
  int v10;
  float v11;
  uint64_t v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  float v18;
  unsigned int v19;
  int v20;
  _DWORD *v21;
  int v22;
  uint64_t i;
  unsigned int UsedMemory;
  uint64_t v26;
  _OWORD v27[4];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(a1 + 576);
  v4 = (_QWORD *)(v3 + 2168);
  if (*(_DWORD *)(a1 + 840) == -1)
  {
    UnitData_Obersee = 0;
  }
  else
  {
    MFS__log_select_Diag(v2, 3, (uint64_t)"viterbi::end path %d\n");
    UnitData_Obersee = mfs_Viterbi_ResultScore_Obersee(a1 + 848, v3 + 2144, v3 + 2168);
    if ((UnitData_Obersee & 0x80000000) != 0)
      goto LABEL_30;
  }
  if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) < 2)
    goto LABEL_25;
  if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) >= 3)
    mfs_Search_LogSelectedUnits((uint64_t *)a1, *(_DWORD *)(*(_QWORD *)(a1 + 576) + 2580), *(_DWORD *)(v3 + 2160) - 1);
  LODWORD(v6) = *(_DWORD *)(v3 + 2160);
  if ((int)v6 < 1)
  {
    v9 = 0;
    v11 = 0.0;
LABEL_22:
    v20 = v6 - v9;
    if (v20 >= 1)
      exp((float)(v11 / (float)v20));
    MFS__log_select_Diag(v2, 2, (uint64_t)"ACC : %f\n");
LABEL_25:
    v21 = *(_DWORD **)(a1 + 576);
    if (v21[569])
    {
      mfs_UnitSequence_SequenceEarlyEmission_Obersee((uint64_t *)a1, v21[645], 3 * v21[152]);
    }
    else
    {
      UnitData_Obersee = mfs_UnitSequence_Sequence_Obersee((uint64_t)(v21 + 528), (uint64_t)(v21 + 562), *(_QWORD *)a1);
      if ((UnitData_Obersee & 0x80000000) != 0)
      {
LABEL_30:
        if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) >= 0x16)
        {
          v22 = 0;
          for (i = 600; i != 840; i += 80)
            v22 += mfs_CandidateList_GetUsedMemory((_DWORD *)(a1 + i));
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:%d candidate lists mem usage: %d bytes\n");
          UsedMemory = fastallo_GetUsedMemory(a1 + 8);
          if (UsedMemory > *(_DWORD *)(a1 + 568))
            *(_DWORD *)(a1 + 568) = UsedMemory;
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:candidatelist unit data cache: %d bytes (unit data size %d)\n");
          mfs_Viterbi_DumpHeapStats((uint64_t *)(a1 + 848));
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:Obersee huffman uncompress buffer: %d bytes\n");
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:Obersee uselect total mem usage: %d bytes\n");
        }
        mfs_Viterbi_DeInit_Obersee(a1 + 848);
        UNICORN__mfs_S32Vect_Clear(v4);
        MFS__log_select_Diag(v2, 3, (uint64_t)"viterbi::finish\n");
        return UnitData_Obersee;
      }
    }
    if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) >= 3)
      mfs_UnitSequence_Log(*(_QWORD *)(a1 + 576) + 2112);
    goto LABEL_30;
  }
  v26 = v2;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 584) + 1096) - 1;
  v11 = 0.0;
  while (1)
  {
    v12 = v7 & 1;
    v13 = &v27[2 * v12];
    UnitData_Obersee = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 584), *(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v3 + 2152) + 4 * v7), (uint64_t)v13);
    if ((UnitData_Obersee & 0x80000000) != 0)
      return UnitData_Obersee;
    if (v7)
    {
      v14 = *(_QWORD *)(v3 + 2152);
      if (*(_DWORD *)(v14 + 4 * (v7 - 1)) == v10 || *(_DWORD *)(v14 + 4 * v7) == v10)
      {
        ++v9;
      }
      else
      {
        v15 = *(_QWORD *)(a1 + 584);
        v16 = *(_QWORD *)(a1 + 576);
        v17 = *((_DWORD *)v8 + 3);
        v18 = 0.0;
        if (v17 <= 0xFF)
        {
          v19 = WORD1(v27[2 * v12 + 1]);
          if (v19 <= 0xFF)
            v18 = *(float *)(*(_QWORD *)(*(_QWORD *)(v16 + 2072) + 8 * v7) + 8)
                * *(float *)(*(_QWORD *)(v15 + 2152) + 4 * (v17 + (v19 << 8)));
        }
        v11 = v11
            + (float)(v18
                    + (float)(*(float *)(*(_QWORD *)(*(_QWORD *)(v16 + 2072) + 8 * v7) + 4)
                            * *(float *)(*(_QWORD *)(v15 + 2136)
                                       + 4
                                       * (*((unsigned __int16 *)v8 + 8)
                                        + ((unint64_t)WORD2(v27[2 * v12 + 1]) << 9)))));
      }
    }
    ++v7;
    v6 = *(int *)(v3 + 2160);
    v8 = v13;
    if (v7 >= v6)
    {
      v4 = (_QWORD *)(v3 + 2168);
      v2 = v26;
      goto LABEL_22;
    }
  }
}

uint64_t mfs_SwapItem_Obersee(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  int v4;

  if (a3)
  {
    v3 = 0;
    do
    {
      v4 = *(_DWORD *)(result + v3);
      *(_DWORD *)(result + v3) = *(_DWORD *)(a2 + v3);
      *(_DWORD *)(a2 + v3) = v4;
      v3 += 4;
    }
    while (v3 < a3);
  }
  return result;
}

uint64_t mfs_Array_QSelect_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t (*a4)(uint64_t, uint64_t), unsigned int a5)
{
  unsigned int v6;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v25;
  unsigned int v27;
  unsigned int v28;

  v25 = a5 * a3;
  v6 = a2 - 1;
  if (a2 != 1)
  {
    v9 = 0;
    v27 = 0;
    v10 = a1 + v25;
    do
    {
      v11 = a1 + v6 * a3;
      if (a3)
      {
        v12 = 0;
        do
        {
          v13 = *(_DWORD *)(v10 + v12);
          *(_DWORD *)(v10 + v12) = *(_DWORD *)(v11 + v12);
          *(_DWORD *)(v11 + v12) = v13;
          v12 += 4;
        }
        while (v12 < a3);
      }
      v14 = v9;
      v28 = v6;
      if (v9 < v6)
      {
        v15 = v9;
        v16 = a3 * v9;
        v14 = v9;
        do
        {
          if ((a4(a1 + v15 * a3, v11) & 0x80000000) != 0)
          {
            if (a3)
            {
              v17 = 0;
              v18 = a1 + v16;
              v19 = a1 + v14 * a3;
              do
              {
                v20 = *(_DWORD *)(v18 + v17);
                *(_DWORD *)(v18 + v17) = *(_DWORD *)(v19 + v17);
                *(_DWORD *)(v19 + v17) = v20;
                v17 += 4;
              }
              while (v17 < a3);
            }
            ++v14;
          }
          ++v15;
          v16 += a3;
        }
        while (v15 != v28);
      }
      if (a3)
      {
        v21 = 0;
        v22 = a1 + v14 * a3;
        do
        {
          v23 = *(_DWORD *)(v11 + v21);
          *(_DWORD *)(v11 + v21) = *(_DWORD *)(v22 + v21);
          *(_DWORD *)(v22 + v21) = v23;
          v21 += 4;
        }
        while (v21 < a3);
      }
      v6 = v28;
      if (v14 == a5)
        break;
      if (v14 >= a5)
        v6 = v14 - 1;
      else
        v9 = v14 + 1;
      ++v27;
    }
    while (v27 < v6);
  }
  return a1 + v25;
}

uint64_t qsortex(uint64_t result, unsigned int a2, uint64_t a3, uint64_t (*a4)(char *, char *, uint64_t), uint64_t a5)
{
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  int v15;
  BOOL v16;
  __int16 v17;
  int v18;
  char *v19;
  char v20;
  uint64_t v21;
  int v22;
  int v23;
  __int16 v24;
  int v25;
  char *v26;
  char *v27;
  char v28;
  uint64_t v29;
  int v30;
  __int16 v31;
  int v32;
  char *v33;
  char *v34;
  char v35;
  uint64_t v36;
  int v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  char *v43;
  char *v44;
  __int16 v45;
  uint64_t v46;
  int v47;
  char *v48;
  char v49;
  uint64_t v50;
  char *v51;
  int v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  __int16 v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  int v64;
  char *v65;
  unsigned int v66;
  char *v67;
  _OWORD v68[31];
  _OWORD v69[31];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  memset(v69, 0, sizeof(v69));
  memset(v68, 0, sizeof(v68));
  if (a2 >= 2)
  {
    v7 = a3;
    v8 = (char *)result;
    v64 = 0;
    v9 = (char *)(result + (a2 - 1) * a3);
    v10 = a3;
    v66 = a3 % 3;
    v11 = -(uint64_t)a3;
    while (2)
    {
      while (2)
      {
        v67 = v9;
        while (1)
        {
          v12 = (v9 - v8) / v10 + 1;
          if (v12 <= 8)
          {
            if (v9 > v8)
            {
              v54 = v8;
              v55 = &v8[v10];
              do
              {
                v56 = v54;
                if (v55 <= v9)
                {
                  v57 = v55;
                  do
                  {
                    result = a4(v57, v54, a5);
                    if ((int)result > 0)
                      v54 = v57;
                    v57 += v10;
                  }
                  while (v57 <= v9);
                }
                if (v54 != v9)
                {
                  if ((_DWORD)v7 == 2)
                  {
                    v58 = *(_WORD *)v54;
                    *(_WORD *)v54 = *(_WORD *)v9;
                    *(_WORD *)v9 = v58;
                  }
                  else if (v66)
                  {
                    if ((_DWORD)v7)
                    {
                      v59 = 0;
                      do
                      {
                        v60 = v54[v59];
                        v54[v59] = v9[v59];
                        v9[v59++] = v60;
                      }
                      while ((_DWORD)v10 != (_DWORD)v59);
                    }
                  }
                  else if ((_DWORD)v7)
                  {
                    v61 = 0;
                    do
                    {
                      v62 = *(_DWORD *)&v54[v61];
                      *(_DWORD *)&v54[v61] = *(_DWORD *)&v9[v61];
                      *(_DWORD *)&v9[v61] = v62;
                      v61 += 4;
                    }
                    while (v61 < v7);
                  }
                }
                v9 += v11;
                v54 = v56;
              }
              while (v9 > v56);
            }
            goto LABEL_107;
          }
          v13 = (v12 >> 1) * v7;
          v14 = &v8[v13];
          v15 = a4(v8, &v8[v13], a5);
          if ((_DWORD)v13)
            v16 = v15 < 1;
          else
            v16 = 1;
          if (!v16)
          {
            if ((_DWORD)v7 == 2)
            {
              v17 = *(_WORD *)v8;
              *(_WORD *)v8 = *(_WORD *)v14;
              *(_WORD *)v14 = v17;
            }
            else if (v66)
            {
              if ((_DWORD)v7)
              {
                v18 = v7;
                v19 = v8;
                do
                {
                  v20 = *v19;
                  *v19 = v19[v13];
                  v19[v13] = v20;
                  ++v19;
                  --v18;
                }
                while (v18);
              }
            }
            else if ((_DWORD)v7)
            {
              v21 = 0;
              do
              {
                v22 = *(_DWORD *)&v8[v21];
                *(_DWORD *)&v8[v21] = *(_DWORD *)&v14[v21];
                *(_DWORD *)&v14[v21] = v22;
                v21 += 4;
              }
              while (v21 < v7);
            }
          }
          v23 = a4(v8, v9, a5);
          if (v8 != v9 && v23 >= 1)
          {
            if ((_DWORD)v7 == 2)
            {
              v24 = *(_WORD *)v8;
              *(_WORD *)v8 = *(_WORD *)v9;
              *(_WORD *)v9 = v24;
            }
            else if (v66)
            {
              if ((_DWORD)v7)
              {
                v25 = v7;
                v26 = v9;
                v27 = v8;
                do
                {
                  v28 = *v27;
                  *v27++ = *v26;
                  *v26++ = v28;
                  --v25;
                }
                while (v25);
              }
            }
            else if ((_DWORD)v7)
            {
              v29 = 0;
              do
              {
                v30 = *(_DWORD *)&v8[v29];
                *(_DWORD *)&v8[v29] = *(_DWORD *)&v9[v29];
                *(_DWORD *)&v9[v29] = v30;
                v29 += 4;
              }
              while (v29 < v7);
            }
          }
          v65 = v8;
          result = a4(&v8[v13], v9, a5);
          if (v14 != v9 && (int)result >= 1)
          {
            if ((_DWORD)v7 == 2)
            {
              v31 = *(_WORD *)v14;
              *(_WORD *)v14 = *(_WORD *)v9;
              *(_WORD *)v9 = v31;
            }
            else if (v66)
            {
              if ((_DWORD)v7)
              {
                v32 = v7;
                v33 = v9;
                v34 = &v8[v13];
                do
                {
                  v35 = *v34;
                  *v34++ = *v33;
                  *v33++ = v35;
                  --v32;
                }
                while (v32);
              }
            }
            else if ((_DWORD)v7)
            {
              v36 = 0;
              do
              {
                v37 = *(_DWORD *)&v14[v36];
                *(_DWORD *)&v14[v36] = *(_DWORD *)&v9[v36];
                *(_DWORD *)&v9[v36] = v37;
                v36 += 4;
              }
              while (v36 < v7);
            }
          }
          v38 = v9;
          v39 = v65;
          while (1)
          {
            if (v14 > v39)
            {
              v40 = &v39[v10];
              do
              {
                v39 = v40;
                if (v40 >= v14)
                  break;
                result = a4(v40, v14, a5);
                v40 = &v39[v10];
              }
              while ((int)result < 1);
            }
            if (v14 <= v39)
            {
              v41 = &v39[v10];
              do
              {
                v39 = v41;
                if (v41 > v9)
                  break;
                result = a4(v41, v14, a5);
                v41 = &v39[v10];
              }
              while ((int)result < 1);
            }
            v42 = v7;
            v43 = &v38[v11];
            do
            {
              v9 = v38;
              v44 = v43;
              v38 += v11;
              if (v38 <= v14)
                break;
              result = a4(v38, v14, a5);
              v43 = &v44[v11];
            }
            while ((int)result > 0);
            if (v38 < v39)
              break;
            v7 = v42;
            if (v38 != v39)
            {
              if ((_DWORD)v42 == 2)
              {
                v45 = *(_WORD *)v39;
                *(_WORD *)v39 = *(_WORD *)v38;
                *(_WORD *)v38 = v45;
              }
              else if (v66)
              {
                if ((_DWORD)v42)
                {
                  v46 = v11;
                  v47 = v42;
                  v48 = v39;
                  do
                  {
                    v49 = *v48;
                    *v48++ = v9[v46];
                    v9[v46++] = v49;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if ((_DWORD)v42)
              {
                v50 = 0;
                v51 = &v9[v11];
                do
                {
                  v52 = *(_DWORD *)&v39[v50];
                  *(_DWORD *)&v39[v50] = *(_DWORD *)&v51[v50];
                  *(_DWORD *)&v51[v50] = v52;
                  v50 += 4;
                }
                while (v50 < v42);
              }
            }
            if (v38 == v14)
              v14 = v39;
            v9 = v67;
          }
          v8 = v65;
          if (v14 < v9)
          {
            do
            {
              v9 = v44;
              if (v44 <= v14)
                break;
              result = a4(v44, v14, a5);
              v44 += v11;
            }
            while (!(_DWORD)result);
          }
          if (v14 >= v9)
          {
            v53 = &v9[v11];
            v7 = v42;
            do
            {
              v9 = v53;
              if (v53 <= v65)
                break;
              result = a4(v53, v14, a5);
              v53 = &v9[v11];
            }
            while (!(_DWORD)result);
          }
          else
          {
            v7 = v42;
          }
          if (v9 - v65 < v67 - v39)
            break;
          if (v65 < v9)
          {
            *((_QWORD *)v69 + v64) = v65;
            *((_QWORD *)v68 + v64++) = v9;
          }
          v8 = v39;
          v9 = v67;
          if (v39 >= v67)
            goto LABEL_107;
        }
        if (v39 < v67)
        {
          *((_QWORD *)v69 + v64) = v39;
          *((_QWORD *)v68 + v64++) = v67;
        }
        if (v65 < v9)
          continue;
        break;
      }
LABEL_107:
      v63 = v64 - 1;
      if (v64 >= 1)
      {
        v8 = (char *)*((_QWORD *)v69 + v63);
        --v64;
        v9 = (char *)*((_QWORD *)v68 + v63);
        continue;
      }
      break;
    }
  }
  return result;
}

uint64_t mfs_HarchData_Load(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)a1 = a2;
  v2 = *(_DWORD *)(a2 + 13552);
  *(_DWORD *)(a1 + 28) = v2 / 0xC;
  if (v2 >= 0xC)
  {
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 13544);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 13064);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 13304);
  }
  v3 = *(_DWORD *)(a2 + 14272);
  *(_DWORD *)(a1 + 24) = v3 / 0xC;
  if (v3 >= 0xC)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 14264);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 13784);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 14024);
  }
  return 0;
}

double mfs_HarchData_DeInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t mfs_Harch_Init(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 144) = 0;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  UNICORN__mfs_S32Vect_Init(a1, (_QWORD *)(a2 + 96));
  return UNICORN__mfs_S32Vect_Init(a1, (_QWORD *)(a2 + 120));
}

_QWORD *mfs_Harch_DeInit(uint64_t a1)
{
  UNICORN__mfs_S32Vect_Clear((_QWORD *)(a1 + 96));
  return UNICORN__mfs_S32Vect_Clear((_QWORD *)(a1 + 120));
}

uint64_t mfs_Harch_Search(uint64_t a1, uint64_t *a2, uint64_t **a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  char v11;
  char v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _BYTE *v21;
  _BYTE *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t i;
  int v30;
  int v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  int v43;
  unsigned int v47;
  uint64_t *v48;
  char v49;
  char v50;
  char v51;
  _BYTE v53[41];
  uint64_t v54;

  v5 = a5;
  v8 = a2;
  v9 = 0;
  v47 = 0;
  v54 = *MEMORY[0x1E0C80C00];
  *a3 = a2;
  v10 = (uint64_t *)(a3 + 1);
  v11 = 1;
  v48 = (uint64_t *)(a3 + 1);
  do
  {
    v12 = v11;
    if (!*((_DWORD *)*a3 + v9 + 6))
      goto LABEL_46;
    v13 = (uint64_t)a3 + 4 * v9;
    v16 = *(_DWORD *)(v13 + 88);
    v15 = (_DWORD *)(v13 + 88);
    v14 = v16;
    if (v16)
    {
      *v15 = v14 - 1;
      goto LABEL_46;
    }
    if ((v12 & 1) != 0)
    {
      *((_DWORD *)a3 + 22) = 0;
      *((_BYTE *)a3 + 8) = 0;
      if (mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v5) != 1)
      {
        v49 = mfs_Ling_SylPos(*(_QWORD *)(a4 + 8), v5);
        v17 = 0;
        v18 = v5;
        do
        {
          v19 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v18);
          if (v19 != 1)
            *((_BYTE *)v10 + v17++) = v19;
          ++v18;
        }
        while (v18 < *(_DWORD *)(a4 + 608) && !mfs_Ling_IsSyllableBegin(*(_QWORD *)(a4 + 8), v18) && v17 < 39);
        v20 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v18);
        if (v20 != 1)
          *((_BYTE *)v10 + v17++) = v20;
        *((_DWORD *)a3 + 22) = v17 - 1;
        v21 = (char *)v10 + v17;
        *v21 = v49;
        v22 = v21 + 1;
LABEL_26:
        *v22 = 0;
      }
    }
    else
    {
      *((_DWORD *)a3 + 23) = 0;
      *((_BYTE *)a3 + 48) = 0;
      if (mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v5) != 1)
      {
        v50 = UNICORN__mfs_Ling_WrdPosInPhrs(*(_QWORD *)(a4 + 8), v5);
        v23 = 0;
        v24 = v5;
        do
        {
          v25 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v24);
          if (v25 != 1)
          {
            v26 = (uint64_t)a3 + v23++;
            *(_BYTE *)(v26 + 48) = v25;
          }
          ++v24;
        }
        while (v24 < *(_DWORD *)(a4 + 608) && !mfs_Ling_IsWordBegin(*(_QWORD *)(a4 + 8), v24) && v23 < 37);
        v27 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v24);
        if (v27 != 1)
          *((_BYTE *)a3 + v23++ + 48) = v27;
        *((_DWORD *)a3 + 23) = v23 - 1;
        v28 = (uint64_t)a3 + v23;
        *(_BYTE *)(v28 + 48) = v50;
        v22 = (_BYTE *)(v28 + 49);
        goto LABEL_26;
      }
    }
    if (!*v15)
      goto LABEL_46;
    v51 = v12;
    if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(a1 + 32)) >= 3)
    {
      for (i = 0; i != 40; ++i)
        v53[i] = mfs_Ling_HmmPhonemeToLhTts(*v8, *((unsigned __int8 *)&v48[5 * v9] + i));
      v53[40] = 0;
      MFS__log_select_Diag(a1, 3, (uint64_t)" -* (%s) ");
    }
    v30 = *((_DWORD *)*a3 + v9 + 6);
    UNICORN__mfs_S32Vect_Clear(&a3[3 * v9 + 12]);
    v31 = v30 - 1;
    if (v30 < 1)
    {
      v40 = 0;
      goto LABEL_43;
    }
    v32 = 0;
    v33 = *a3;
    v34 = (uint64_t)&(*a3)[v9];
    v35 = *(_QWORD *)(v34 + 32);
    v36 = *(_QWORD *)(v34 + 8);
    while (1)
    {
      v37 = v32 + v31;
      if (v32 + v31 < 0 != __OFADD__(v32, v31))
        ++v37;
      v38 = (uint64_t)v37 >> 1;
      v39 = strcmp((const char *)(v35 + *(unsigned int *)(v36 + 12 * (v37 >> 1))), (const char *)&a3[5 * v9 + 1]);
      if ((v39 & 0x80000000) == 0)
        break;
      v32 = v38 + 1;
LABEL_40:
      if (v32 > v31)
        goto LABEL_41;
    }
    if (v39)
    {
      v31 = v38 - 1;
      goto LABEL_40;
    }
    v41 = v36 + 12 * (int)v38;
    if (!*(_DWORD *)(v41 + 8))
    {
LABEL_41:
      v40 = 0;
      v5 = a5;
      goto LABEL_43;
    }
    v42 = 0;
    v43 = *(_DWORD *)(v41 + 4);
    v5 = a5;
    do
    {
      v40 = mfs_S32Vect_Add((uint64_t)&a3[3 * v9 + 12], *(_DWORD *)(v33[v9 + 6] + 4 * (v43 + v42)));
      if (v40 < 0)
        break;
      ++v42;
      v33 = *a3;
    }
    while (v42 < *(unsigned int *)((*a3)[v9 + 1] + 12 * (int)v38 + 8));
LABEL_43:
    v47 = v40 & ~(v40 >> 31);
    if (LODWORD(a3[3 * v9 + 14]))
    {
      MFS__log_select_Diag(a1, 3, (uint64_t)" found %d");
      *((_DWORD *)a3 + v9 + 36) = 0;
    }
    v8 = a2;
    v10 = v48;
    v12 = v51;
LABEL_46:
    v11 = 0;
    v9 = 1;
  }
  while ((v12 & 1) != 0);
  return v47;
}

BOOL mfs_Harch_IsBoundary(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 88) == 0;
}

uint64_t mfs_Harch_GetIds(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t result;
  char i;
  char v7;
  _QWORD *v8;
  unsigned int *v9;
  int v10;
  uint64_t v11;

  UNICORN__mfs_S32Vect_Clear(a2);
  v4 = 0;
  result = 0;
  for (i = 1; ; i = 0)
  {
    v7 = i;
    if (!*(_DWORD *)(*a1 + 4 * v4 + 24) || (*((_DWORD *)a1 + v4 + 22) & 0x80000000) != 0)
      goto LABEL_9;
    v8 = &a1[3 * v4];
    v10 = *((_DWORD *)v8 + 28);
    v9 = (unsigned int *)(v8 + 14);
    if (v10)
      break;
LABEL_8:
    ++*((_DWORD *)a1 + v4 + 36);
LABEL_9:
    v4 = 1;
    if ((v7 & 1) == 0)
      return result;
  }
  v11 = 0;
  while (1)
  {
    result = mfs_S32Vect_Add((uint64_t)a2, *((_DWORD *)a1 + v4 + 36) + *(_DWORD *)(a1[3 * v4 + 13] + 4 * v11));
    if ((result & 0x80000000) != 0)
      return result;
    if (++v11 >= (unint64_t)*v9)
      goto LABEL_8;
  }
}

BOOL mfs_Harch_FewCands(int *a1)
{
  uint64_t v1;
  unsigned int v2;
  char v3;
  char v4;

  v1 = 0;
  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    if (*(_DWORD *)(*(_QWORD *)a1 + 4 * v1 + 24) && a1[v1 + 36] >= 2)
      v2 += a1[6 * v1 + 28];
    v3 = 0;
    v1 = 1;
  }
  while ((v4 & 1) != 0);
  return v2 < 0x28;
}

uint64_t mfs_CostList_CompareNodesScore_Obersee(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(unsigned __int16 *)(a1 + 8);
  v3 = *(unsigned __int16 *)(a2 + 8);
  v4 = v2 > v3;
  if (v2 >= v3)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t mfs_CandidateList_Init_Obersee(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v4 = 2229280778;
  *(_QWORD *)a1 = 0x1FFFLL;
  v5 = heap_Alloc(a2, 32764);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
  {
    v6 = *(_QWORD *)a1;
    v7 = v5 + 4 * *(_QWORD *)a1;
    *(_QWORD *)(a1 + 16) = v7;
    if (v6 >= 1)
    {
      if (v7 <= v5 + 4)
        v7 = v5 + 4;
      memset((void *)v5, 255, ((v7 + ~v5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
    *(_QWORD *)(a1 + 24) = 2048;
    v8 = heap_Alloc(a2, 49152);
    *(_QWORD *)(a1 + 32) = v8;
    if (v8)
    {
      v4 = 0;
      *(_QWORD *)(a1 + 40) = v8;
      *(_DWORD *)(a1 + 48) = -1;
      *(_WORD *)(a1 + 56) = -1;
      *(_QWORD *)(a1 + 68) = 0;
      *(_QWORD *)(a1 + 60) = 0;
    }
  }
  return v4;
}

_QWORD *mfs_CandidateList_DeInit_Obersee(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result;
  v4 = result[1];
  if (v4)
    result = heap_Free(a2, v4);
  v5 = v3[4];
  if (v5)
    return heap_Free(a2, v5);
  return result;
}

uint64_t mfs_CandidateList_ReserveSpaceAtEndIfNotPresent_Obersee(uint64_t a1, uint64_t a2, unsigned int a3, char **a4, uint64_t *a5)
{
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  unsigned int v13;
  uint64_t result;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  unsigned int v24;
  _DWORD *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;

  v9 = a3;
  v10 = *(char **)(a1 + 8);
  v11 = *(_QWORD *)(a1 + 16) - (_QWORD)v10;
  v12 = &v10[4 * (a3 % (unint64_t)(v11 >> 2))];
  while (1)
  {
    v13 = *(_DWORD *)v12;
    if ((v13 & 0x80000000) != 0)
      break;
    v12 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v13);
    if (*((_DWORD *)v12 + 1) == a3)
    {
      result = 2229280770;
LABEL_34:
      *a4 = v12;
      return result;
    }
  }
  LODWORD(v15) = *(_DWORD *)(a1 + 48);
  if ((_DWORD)v15 != -1)
  {
    v16 = *(_DWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 32) + 24 * (int)v15;
    *(_DWORD *)(a1 + 48) = (*(_DWORD *)v17 & 0xBFFFFFFF) - 1;
    *(_DWORD *)v17 = 0;
    *(_DWORD *)(v17 + 4) = a3;
    *(_QWORD *)(v17 + 8) = 0;
    *(_QWORD *)(v17 + 16) = 0;
LABEL_33:
    result = 0;
    v35 = *(_QWORD *)(a1 + 8);
    v36 = v9 % ((*(_QWORD *)(a1 + 16) - v35) >> 2);
    v12 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v16);
    *(_DWORD *)v12 = *(_DWORD *)(v35 + 4 * v36);
    *(_DWORD *)(v35 + 4 * v36) = v15;
    goto LABEL_34;
  }
  v18 = *(_QWORD *)(a1 + 32);
  v19 = *(_QWORD *)(a1 + 40);
  v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 3);
  if (v15 > v11 >> 1)
  {
    v20 = (v11 >> 1) + 1;
    if (v20 <= *(_QWORD *)a1)
    {
      v22 = 4 * *(_QWORD *)a1;
    }
    else
    {
      if (v20 >= 9)
        v21 = (v11 >> 1) + 1;
      else
        v21 = 8;
      v22 = 4 * v21;
      v23 = heap_Realloc(a5, (uint64_t)v10, 4 * v21);
      *(_QWORD *)(a1 + 8) = v23;
      if (!v23)
        return 2229280778;
      v10 = (char *)v23;
      *(_QWORD *)a1 = v21;
    }
    *(_QWORD *)(a1 + 16) = &v10[4 * v20];
    memset(v10, 255, v22);
    v18 = *(_QWORD *)(a1 + 32);
    v19 = *(_QWORD *)(a1 + 40);
    if (v19 == v18)
    {
      v15 = 0;
      v18 = *(_QWORD *)(a1 + 40);
    }
    else
    {
      v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 3);
      v24 = 1;
      v25 = *(_DWORD **)(a1 + 32);
      do
      {
        if (((*v25 + 1) & 0x40000000) == 0)
        {
          v26 = v25[1] % v20;
          v27 = *(_QWORD *)(a1 + 8);
          *v25 = *(_DWORD *)(v27 + 4 * v26);
          *(_DWORD *)(v27 + 4 * v26) = v24 - 1;
        }
        v25 += 6;
      }
      while (v15 > v24++);
    }
  }
  v29 = v15 + 1;
  v30 = *(_QWORD *)(a1 + 24);
  if (v15 + 1 <= v30)
  {
LABEL_32:
    *(_QWORD *)(a1 + 40) = v19 + 24;
    *(_DWORD *)v19 = 0;
    *(_DWORD *)(v19 + 4) = a3;
    *(_OWORD *)(v19 + 8) = 0uLL;
    v16 = v15;
    goto LABEL_33;
  }
  v31 = 2 * v30;
  v32 = v30 + 1000000;
  if (v31 >= v32)
    v31 = v32;
  if (v31 > v29)
    v29 = v31;
  if (v29 <= 8)
    v33 = 8;
  else
    v33 = v29;
  v34 = heap_Realloc(a5, v18, 24 * v33);
  *(_QWORD *)(a1 + 32) = v34;
  if (v34)
  {
    *(_QWORD *)(a1 + 24) = v33;
    v19 = v34 + 24 * v15;
    goto LABEL_32;
  }
  return 2229280778;
}

uint64_t mfs_CandidateList_ReserveInsertSpaceSortedProbablyAppend_Obersee(uint64_t a1, unsigned int a2, char **a3, uint64_t *a4)
{
  unint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  uint64_t result;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  unsigned int v23;
  _DWORD *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;

  v8 = a2;
  v9 = *(char **)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16) - (_QWORD)v9;
  v11 = &v9[4 * (a2 % (unint64_t)(v10 >> 2))];
  while (1)
  {
    v12 = *(_DWORD *)v11;
    if ((v12 & 0x80000000) != 0)
      break;
    v11 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v12);
    if (*((_DWORD *)v11 + 1) == a2)
    {
      result = 2229280770;
LABEL_34:
      *a3 = v11;
      return result;
    }
  }
  LODWORD(v14) = *(_DWORD *)(a1 + 48);
  if ((_DWORD)v14 != -1)
  {
    v15 = *(_DWORD *)(a1 + 48);
    v16 = *(_QWORD *)(a1 + 32) + 24 * (int)v14;
    *(_DWORD *)(a1 + 48) = (*(_DWORD *)v16 & 0xBFFFFFFF) - 1;
    *(_DWORD *)v16 = 0;
    *(_DWORD *)(v16 + 4) = a2;
    *(_QWORD *)(v16 + 8) = 0;
    *(_QWORD *)(v16 + 16) = 0;
LABEL_33:
    result = 0;
    v34 = *(_QWORD *)(a1 + 8);
    v35 = v8 % ((*(_QWORD *)(a1 + 16) - v34) >> 2);
    v11 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v15);
    *(_DWORD *)v11 = *(_DWORD *)(v34 + 4 * v35);
    *(_DWORD *)(v34 + 4 * v35) = v14;
    goto LABEL_34;
  }
  v17 = *(_QWORD *)(a1 + 32);
  v18 = *(_QWORD *)(a1 + 40);
  v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - v17) >> 3);
  if (v14 > v10 >> 1)
  {
    v19 = (v10 >> 1) + 1;
    if (v19 <= *(_QWORD *)a1)
    {
      v21 = 4 * *(_QWORD *)a1;
    }
    else
    {
      if (v19 >= 9)
        v20 = (v10 >> 1) + 1;
      else
        v20 = 8;
      v21 = 4 * v20;
      v22 = heap_Realloc(a4, (uint64_t)v9, 4 * v20);
      *(_QWORD *)(a1 + 8) = v22;
      if (!v22)
        return 2229280778;
      v9 = (char *)v22;
      *(_QWORD *)a1 = v20;
    }
    *(_QWORD *)(a1 + 16) = &v9[4 * v19];
    memset(v9, 255, v21);
    v17 = *(_QWORD *)(a1 + 32);
    v18 = *(_QWORD *)(a1 + 40);
    if (v18 == v17)
    {
      v14 = 0;
      v17 = *(_QWORD *)(a1 + 40);
    }
    else
    {
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - v17) >> 3);
      v23 = 1;
      v24 = *(_DWORD **)(a1 + 32);
      do
      {
        if (((*v24 + 1) & 0x40000000) == 0)
        {
          v25 = v24[1] % v19;
          v26 = *(_QWORD *)(a1 + 8);
          *v24 = *(_DWORD *)(v26 + 4 * v25);
          *(_DWORD *)(v26 + 4 * v25) = v23 - 1;
        }
        v24 += 6;
      }
      while (v14 > v23++);
    }
  }
  v28 = v14 + 1;
  v29 = *(_QWORD *)(a1 + 24);
  if (v14 + 1 <= v29)
  {
LABEL_32:
    *(_QWORD *)(a1 + 40) = v18 + 24;
    *(_DWORD *)v18 = 0;
    *(_DWORD *)(v18 + 4) = a2;
    *(_OWORD *)(v18 + 8) = 0uLL;
    v15 = v14;
    goto LABEL_33;
  }
  v30 = 2 * v29;
  v31 = v29 + 1000000;
  if (v30 >= v31)
    v30 = v31;
  if (v30 > v28)
    v28 = v30;
  if (v28 <= 8)
    v32 = 8;
  else
    v32 = v28;
  v33 = heap_Realloc(a4, v17, 24 * v32);
  *(_QWORD *)(a1 + 32) = v33;
  if (v33)
  {
    *(_QWORD *)(a1 + 24) = v32;
    v18 = v33 + 24 * v14;
    goto LABEL_32;
  }
  return 2229280778;
}

uint64_t mfs_CandidateList_InsertSortedProbablyAppend_Obersee(uint64_t a1, unsigned int a2, __int16 a3, char **a4, uint64_t a5, uint64_t *a6)
{
  uint64_t result;
  char *v11;

  result = mfs_CandidateList_ReserveInsertSpaceSortedProbablyAppend_Obersee(a1, a2, a4, a6);
  if (!(_DWORD)result)
  {
    v11 = *a4;
    *((_DWORD *)v11 + 1) = a2;
    *((_WORD *)v11 + 4) = a3;
    *((_QWORD *)v11 + 2) = a5;
  }
  return result;
}

uint64_t mfs_CandidateList_Sort_Obersee(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 40) - v2) >> 3);
  if ((_DWORD)v3)
    ssft_qsort(v2, v3, 24, (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesScore_Obersee);
  return 0;
}

uint64_t mfs_CandidateList_SelectAndPrune_Obersee(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD **v13;
  _QWORD *v14;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = (unint64_t)(*(_QWORD *)(a1 + 40) - v5) >> 3;
  v7 = -1431655765 * v6;
  if (-1431655765 * (_DWORD)v6)
  {
    mfs_Array_QSelect_Obersee(v5, -1431655765 * v6, 0x18u, mfs_CostList_CompareNodesScore_Obersee, a2);
    if (v7 > a2)
    {
      v10 = *(_QWORD *)(a1 + 32);
      if (-1431655765 * ((*(_QWORD *)(a1 + 40) - v10) >> 3) > a2)
      {
        v11 = *(_QWORD **)(a4 + 72);
        v12 = -1431655765 * ((*(_QWORD *)(a1 + 40) - v10) >> 3) - (unint64_t)a2;
        v13 = (_QWORD **)(v10 + 24 * a2 + 16);
        do
        {
          v14 = *v13;
          v13 += 3;
          *v14 = v11;
          *(_QWORD *)(a4 + 72) = v14;
          v11 = v14;
          --v12;
        }
        while (v12);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32) + 24 * a2;
      }
    }
  }
  return 0;
}

uint64_t mfs_CandidateList_Prune_Obersee(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD **v7;
  unint64_t v8;
  _QWORD *v9;

  v4 = *(_QWORD *)(result + 32);
  v5 = -1431655765 * ((*(_QWORD *)(result + 40) - v4) >> 3);
  if (v5 > a2)
  {
    v6 = *(_QWORD **)(a4 + 72);
    v7 = (_QWORD **)(v4 + 24 * a2 + 16);
    v8 = v5 - (unint64_t)a2;
    do
    {
      v9 = *v7;
      v7 += 3;
      *v9 = v6;
      *(_QWORD *)(a4 + 72) = v9;
      v6 = v9;
      --v8;
    }
    while (v8);
    *(_QWORD *)(result + 40) = *(_QWORD *)(result + 32) + 24 * a2;
  }
  return result;
}

void *mfs_CandidateList_Reset_Obersee(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD **v7;
  _QWORD *v8;
  void *result;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 40) - v4) >> 3);
  if ((_DWORD)v5)
  {
    v6 = *(_QWORD **)(a3 + 72);
    v7 = (_QWORD **)(v4 + 16);
    do
    {
      v8 = *v7;
      v7 += 3;
      *v8 = v6;
      *(_QWORD *)(a3 + 72) = v8;
      v6 = v8;
      --v5;
    }
    while (v5);
  }
  *(_WORD *)(a1 + 56) = -1;
  result = memset(*(void **)(a1 + 8), 255, 4 * *(_QWORD *)a1);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 48) = -1;
  return result;
}

uint64_t mfs_CandidateList_Filter_Obersee(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 40) - v2) >> 3);
  v4 = v3 - 1;
  if (v3 < 1)
    return 0;
  v6 = 0;
  do
  {
    v7 = v2 + 24 * (int)v6;
    if (*(unsigned __int16 *)(v7 + 8) >= a2)
    {
      if (*(unsigned __int16 *)(v2 + 24 * v4 + 8) < a2)
      {
        mfs_SwapItem_Obersee(v7, v2 + 24 * v4, 0x18u);
        v6 = (v6 + 1);
      }
      --v4;
    }
    else
    {
      v6 = (v6 + 1);
    }
  }
  while (v4 >= (int)v6);
  return v6;
}

uint64_t mfs_CandidateList_UpdateCost_Obersee(uint64_t result, unsigned int a2, __int16 a3)
{
  *(_WORD *)(*(_QWORD *)(result + 32) + 24 * a2 + 8) = a3;
  return result;
}

uint64_t mfs_CandidateListNode_UpdateCost_Obersee(uint64_t result, int a2)
{
  *(_WORD *)(result + 8) = (*(_WORD *)(result + 8) + a2) & ~(unsigned __int16)((*(unsigned __int16 *)(result + 8) + a2) >> 31);
  return result;
}

uint64_t mfs_CandidateList_GetUsedMemory(_DWORD *a1)
{
  return (24 * a1[6] + 4 * *a1);
}

uint64_t mfs_Search_InitPrefilter(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 584);
  if (*(_DWORD *)v2 == 3)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 592) + 8356) == 1)
    {
      v3 = *(unsigned int *)(v2 + 2440);
      if ((int)v3 < 1)
      {
        LODWORD(v4) = 0;
      }
      else
      {
        v4 = 0;
        v5 = *(_QWORD *)(v2 + 2456);
        while (*(_BYTE *)(v5 + v4) != 31)
        {
          if (v3 == ++v4)
            goto LABEL_12;
        }
      }
      if ((_DWORD)v4 == (_DWORD)v3)
      {
LABEL_12:
        MFS__log_select_Diag(*(_QWORD *)a1, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
        LODWORD(v4) = 0;
      }
      MFS__log_select_Diag(*(_QWORD *)a1, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
    }
    else
    {
      LODWORD(v4) = 0;
    }
    result = 0;
    *(_DWORD *)(a1 + 18016) = v4;
  }
  else
  {
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"CONFIG ERROR : Search is implemented for 3 states only\n");
    return 2229281034;
  }
  return result;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_Obersee(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  int *v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  uint64_t *v18;
  int *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t UnitData_Obersee;
  uint64_t v23;
  _DWORD *v24;
  int v25;
  _QWORD *MemoryFromChunk;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  unsigned int **v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t i;
  unsigned int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float v54;
  float v55;
  uint64_t v56;
  int v57;
  float v58;
  unsigned int v59;
  float v60;
  _WORD *v61;
  uint64_t v62;
  unsigned int v63;
  float v64;
  uint64_t v65;
  float v66;
  float v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  __int16 v75;
  _QWORD *v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  unsigned int **v80;
  unsigned int v81;
  unsigned int v82;
  __int16 v83;
  int v85;
  uint64_t v86;
  uint64_t v87;
  int *v88;
  uint64_t v89;
  _DWORD *v90;
  int v91[2];
  uint64_t v92;
  _QWORD *v93;
  _QWORD *v94;
  int v95[2];
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  unsigned __int8 v99;
  uint64_t v100;
  int *v102;
  uint64_t v103;
  int v104;
  unsigned __int8 *v105;
  _QWORD *v106;
  uint64_t v107;
  __int16 v108;
  unsigned __int8 v109;
  unsigned int inserted;
  _OWORD v111[2];
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  _DWORD v124[3];
  unsigned __int8 v125[176];
  __int128 v126;
  _BYTE v127[16];
  char *v128[260];

  v128[257] = *(char **)MEMORY[0x1E0C80C00];
  inserted = 0;
  v3 = *(_QWORD *)(a1 + 584);
  v4 = *(_QWORD *)(a1 + 592);
  v5 = *(_QWORD *)a1;
  v6 = *(_QWORD *)(a1 + 576);
  v109 = 0;
  v108 = 0;
  v126 = 0u;
  memset(v125, 0, sizeof(v125));
  v7 = *(_QWORD *)(v6 + 600);
  v98 = v6;
  *(_QWORD *)v91 = v3;
  mfs_symData_GetTargetVector(v3, (uint64_t)v125, *(_QWORD *)(v6 + 8), a2);
  v99 = 0;
  v107 = v4;
  if (*(_DWORD *)(v4 + 8356) == 1)
  {
    MFS__log_select_Diag(v5, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
    v99 = v125[*(int *)(a1 + 18016) + 4];
  }
  UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(v98 + 8), a2, &v108);
  v87 = v5;
  mfs_Ling_LogPhonCtxt(v5, v4, *(_QWORD *)(v98 + 8), a2);
  v9 = 0;
  v10 = a1 + 600;
  v85 = a2;
  v86 = v7;
  v11 = v7 + 528 * a2;
  v12 = *(_DWORD *)(v4 + 8224);
  v13 = (_QWORD *)(v11 + 312);
  *(_QWORD *)v95 = v11 + 312;
  v89 = a1 + 8;
  v106 = (_QWORD *)(v11 + 80);
  v14 = (int *)(a1 + 18016);
  v92 = a1 + 600;
  v93 = (_QWORD *)(v11 + 88);
  v102 = (int *)(v11 + 8);
  v104 = *(_DWORD *)(v107 + 8224);
  v15 = v99;
  do
  {
    if ((*(_BYTE *)(*v13 + v9 + 2) & 4) != 0)
      v16 = 200;
    else
      v16 = 100;
    v124[v9] = 0;
    if (HIBYTE(v108) == 1)
    {
      if (v9 == 1 || !*(_DWORD *)(v107 + 8256))
        goto LABEL_27;
      if ((_DWORD)v9 == 2)
      {
        if (*(_DWORD *)(v98 + 608) - 1 == a2 || v109 == 1)
          goto LABEL_27;
        v17 = v108;
        goto LABEL_18;
      }
      if (!(_DWORD)v9)
      {
        if (!a2 || v108 == 1)
          goto LABEL_27;
        v17 = v109;
LABEL_18:
        if (v17 == 1)
          goto LABEL_27;
      }
    }
    v18 = *(uint64_t **)(*(_QWORD *)(a1 + 576) + 2640);
    if (v18)
    {
      v19 = v14;
      v20 = 3 * a2 + v9 + *((_DWORD *)v18 + 5);
      v21 = *v18;
      v128[0] = 0;
      if (!*(_DWORD *)(v21 + 48 * v20))
      {
        v23 = v21 + 48 * v20;
        v25 = *(_DWORD *)(v23 + 24);
        v24 = (_DWORD *)(v23 + 24);
        if (v25)
        {
          MemoryFromChunk = *(_QWORD **)(a1 + 80);
          if (MemoryFromChunk)
            *(_QWORD *)(a1 + 80) = *MemoryFromChunk;
          else
            MemoryFromChunk = (_QWORD *)fastallo_AllocateMemoryFromChunk(v89, 4u, (int *)&inserted);
          v27 = inserted;
          if ((inserted & 0x80000000) != 0)
            return v27;
          v28 = *(_DWORD *)(*(_QWORD *)(v21 + 48 * v20 + 8) + 4 * (*v24 - 1));
          if (v28 < *(_DWORD *)(*(_QWORD *)v91 + 1096) - 1)
          {
            UnitData_Obersee = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 584), *(_QWORD *)a1, v28, (uint64_t)MemoryFromChunk);
            inserted = UnitData_Obersee;
            if ((UnitData_Obersee & 0x80000000) != 0)
              return UnitData_Obersee;
            inserted = mfs_CandidateList_InsertSortedProbablyAppend_Obersee(v10, v28, v16, v128, (uint64_t)MemoryFromChunk, *(uint64_t **)(*(_QWORD *)a1 + 8));
            if ((inserted & 0x80000000) == 0)
            {
              v124[v9] = 1;
              v12 = v104;
              v15 = v99;
              v14 = v19;
              v13 = *(_QWORD **)v95;
              goto LABEL_27;
            }
          }
        }
      }
      v12 = v104;
      v15 = v99;
      v14 = v19;
      v13 = *(_QWORD **)v95;
    }
    UnitData_Obersee = mfs_VennDiaGrams_Obersee((uint64_t *)a1, 1u, (int)v9 + 2, (unsigned __int8 *)&v108, *(_DWORD *)(*v106 + 4 * v9 + 8), v12, v10, v16, v15, *v14);
    inserted = UnitData_Obersee;
    if ((UnitData_Obersee & 0x80000000) != 0)
      return UnitData_Obersee;
    if ((*(_BYTE *)(*v13 + v9 + 2) & 4) != 0 && mfs_Ling_IsVoiced(v107, *(_QWORD *)(v98 + 8), a2))
    {
      UnitData_Obersee = mfs_VennDiaGrams_Obersee((uint64_t *)a1, 2u, (int)v9 + 2, (unsigned __int8 *)&v108, *(_DWORD *)(*v93 + 4 * v9 + 8), v12, v10, v16, v15, *v14);
      inserted = UnitData_Obersee;
      if ((UnitData_Obersee & 0x80000000) != 0)
        return UnitData_Obersee;
    }
    UnitData_Obersee = mfs_VennDiaGrams_Obersee((uint64_t *)a1, 0, (int)v9 + 2, (unsigned __int8 *)&v108, *v102, v12, v10, v16, v15, *v14);
    inserted = UnitData_Obersee;
    if ((UnitData_Obersee & 0x80000000) != 0)
      return UnitData_Obersee;
LABEL_27:
    ++v9;
    v10 += 80;
  }
  while (v9 != 3);
  if (HIBYTE(v108) != 1)
  {
    v29 = -1431655765 * ((*(_QWORD *)(a1 + 640) - *(_QWORD *)(a1 + 632)) >> 3);
    v30 = -1431655765 * ((*(_QWORD *)(a1 + 800) - *(_QWORD *)(a1 + 792)) >> 3);
    v31 = *(_QWORD *)(a1 + 712);
    v32 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 720) - v31) >> 3);
    if (v32)
    {
      v33 = v124[0];
      v34 = v124[2];
      v35 = (unsigned int **)(v31 + 16);
      do
      {
        if (!v33)
        {
          v36 = **v35;
          if (v36 != -1 && (v29 < 0x64 || *((unsigned __int8 *)*v35 + 24) == v108))
          {
            UnitData_Obersee = mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee((uint64_t *)a1, v92, v29, v36, *((_WORD *)v35 - 4));
            inserted = UnitData_Obersee;
            if ((UnitData_Obersee & 0x1FFF) == 0xA)
              return UnitData_Obersee;
          }
        }
        if (!v34)
        {
          v37 = (*v35)[1];
          if (v37 != -1 && (v30 < 0x64 || *((unsigned __int8 *)*v35 + 26) == v109))
          {
            UnitData_Obersee = mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee((uint64_t *)a1, a1 + 760, v30, v37, *((_WORD *)v35 - 4));
            inserted = UnitData_Obersee;
            if ((UnitData_Obersee & 0x1FFF) == 0xA)
              return UnitData_Obersee;
          }
        }
        v35 += 3;
      }
      while (--v32);
    }
    if (!v124[1])
    {
      if (!(_DWORD)v29)
      {
LABEL_112:
        if ((_DWORD)v30)
        {
          v79 = -1431655765 * ((*(_QWORD *)(a1 + 720) - *(_QWORD *)(a1 + 712)) >> 3);
          v80 = (unsigned int **)(*(_QWORD *)(a1 + 792) + 16);
          while (1)
          {
            v81 = **v80;
            if (v81 != -1)
            {
              v82 = *((unsigned __int16 *)v80 - 4);
              if (*(_DWORD *)(v107 + 8324) > (signed int)v82)
              {
                v83 = v82 > 0xCCC ? -1 : 20 * v82;
                UnitData_Obersee = mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee((uint64_t *)a1, a1 + 680, v79, v81, v83);
                inserted = UnitData_Obersee;
                if ((UnitData_Obersee & 0x1FFF) == 0xA)
                  return UnitData_Obersee;
              }
            }
            v80 += 3;
            LODWORD(v30) = v30 - 1;
            if (!(_DWORD)v30)
              goto LABEL_53;
          }
        }
        goto LABEL_53;
      }
      v72 = *(_QWORD *)(a1 + 632) + 16;
      while (1)
      {
        v73 = *(_DWORD *)(*(_QWORD *)v72 + 4);
        if (v73 != -1)
        {
          v74 = *(unsigned __int16 *)(v72 - 8);
          if (*(_DWORD *)(v107 + 8324) > (signed int)v74)
            break;
        }
LABEL_111:
        v72 += 24;
        LODWORD(v29) = v29 - 1;
        if (!(_DWORD)v29)
          goto LABEL_112;
      }
      if (v74 > 0xCCC)
        v75 = -1;
      else
        v75 = 20 * v74;
      v128[0] = 0;
      v27 = mfs_CandidateList_ReserveInsertSpaceSortedProbablyAppend_Obersee(a1 + 680, v73, v128, *(uint64_t **)(*(_QWORD *)a1 + 8));
      LODWORD(v111[0]) = v27;
      if (!(_DWORD)v27)
      {
        v76 = *(_QWORD **)(a1 + 80);
        if (v76)
        {
          *(_QWORD *)(a1 + 80) = *v76;
        }
        else
        {
          v77 = fastallo_AllocateMemoryFromChunk(v89, 4u, (int *)v111);
          v27 = LODWORD(v111[0]);
          if ((v111[0] & 0x80000000) != 0)
            goto LABEL_110;
          v76 = (_QWORD *)v77;
        }
        v27 = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 584), *(_QWORD *)a1, v73, (uint64_t)v76);
        if ((v27 & 0x80000000) == 0)
        {
          v78 = v128[0];
          *((_DWORD *)v128[0] + 1) = v73;
          *((_WORD *)v78 + 4) = v75;
          *((_QWORD *)v78 + 2) = v76;
        }
      }
LABEL_110:
      inserted = v27;
      if ((v27 & 0x1FFF) == 0xA)
        return v27;
      goto LABEL_111;
    }
  }
LABEL_53:
  for (i = 0; i != 240; i += 80)
  {
    v39 = -1431655765 * ((*(_QWORD *)(a1 + i + 640) - *(_QWORD *)(a1 + i + 632)) >> 3);
    if (v39 >= 0x33)
    {
      v40 = (int)(float)(*(float *)(v107 + 8232) * (float)v39);
      if (v104 < v40)
        v40 = v104;
      v41 = v40 <= 50 ? 50 : v40;
      if (v41 != v39)
      {
        MFS__log_select_Diag(v87, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
        UnitData_Obersee = mfs_CandidateList_Sort_Obersee(a1 + i + 600);
        inserted = UnitData_Obersee;
        if ((UnitData_Obersee & 0x80000000) != 0)
          return UnitData_Obersee;
        mfs_CandidateList_Prune_Obersee(a1 + i + 600, v41, *(_QWORD *)(*(_QWORD *)a1 + 8), v89);
      }
    }
  }
  v42 = 0;
  v103 = a1 + 18024;
  v43 = v86 + 528 * v85;
  v94 = (_QWORD *)(v43 + 16);
  v90 = (_DWORD *)(v43 + 24);
  v88 = (int *)(v43 + 28);
  while (2)
  {
    switch((_DWORD)v42)
    {
      case 2:
        mfs_DataCachePair_SwapCaches_Obersee(v103);
        break;
      case 1:
        v44 = a1 + 18024;
        v45 = 1;
LABEL_71:
        mfs_DataCachePair_SetMode_Obersee(v44, v45);
        break;
      case 0:
        v44 = a1 + 18024;
        v45 = 0;
        goto LABEL_71;
    }
    v46 = v124[v42];
    v96 = HIBYTE(v108);
    v47 = v92 + 80 * v42;
    v122 = 0u;
    v123 = 0u;
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v116 = 0u;
    v117 = 0u;
    v114 = 0u;
    v115 = 0u;
    v112 = 0u;
    v113 = 0u;
    memset(v111, 0, sizeof(v111));
    v49 = *(_QWORD *)(v47 + 32);
    v48 = *(_QWORD *)(v47 + 40);
    v100 = v47;
    v50 = *(_QWORD *)(a1 + 584);
    v51 = *(_QWORD *)(a1 + 592);
    v52 = *(_QWORD *)a1;
    v53 = *(_QWORD *)(a1 + 576);
    v54 = *(float *)(v51 + 8972);
    memset(v128, 0, 512);
    v105 = *(unsigned __int8 **)(v51 + 23144);
    v55 = *(float *)(v51 + 8180);
    mfs_TCost_Init(v52, v51, (uint64_t)v111);
    if (v46 == 1)
      BYTE8(v123) = 0;
    v97 = v42;
    v56 = v42 + 2;
    v27 = mfs_FillTgtVect(v51, v53, (uint64_t)v111, *(_DWORD *)(*v94 + 4 * (v42 + 2)));
    if ((v27 & 0x80000000) != 0)
      goto LABEL_95;
    v57 = -1431655765 * ((unint64_t)(v48 - v49) >> 3);
    v58 = *(float *)v112;
    mfs_symData_DistanceOnUid_PreCalcVitSymRulesForTargetVector_Obersee(v50, v42 + 2, v96, &v125[4], v105, v128);
    *((_QWORD *)&v126 + 1) = v50 + (v56 << 10) + 2912;
    if (!v57)
    {
LABEL_85:
      mfs_TCost_Clear(v111);
      inserted = v27;
      v69 = v92 + 80 * v97;
      *(_DWORD *)(v69 + 64) = 0;
      v70 = v69 + 64;
      *(_DWORD *)(v70 + 4) = 0;
      *(_DWORD *)(v70 + 8) = 0;
      if ((_DWORD)v97 == 2)
      {
        if (!mfs_Ling_IsSilence(v107, *(_QWORD *)(v98 + 8), a2))
        {
          *(_DWORD *)(v70 + 4) = *v90;
          v71 = *v88;
          if (*v88 <= 1)
            v71 = 1;
          *(_DWORD *)(v70 + 8) = v71;
        }
      }
      else if ((_DWORD)v97 == 1 && mfs_Ling_IsVowel(v107, *(_QWORD *)(v98 + 8), a2))
      {
        *(float *)v70 = fmaxf(v58, 0.0);
      }
      v42 = v97 + 1;
      if (v97 == 2)
        return inserted;
      continue;
    }
    break;
  }
  v59 = 0;
  v60 = v54 * 0.5;
  v61 = (_WORD *)(v92 + 80 * v42 + 56);
  while (1)
  {
    v27 = mfs_TCost_CandidateCostStream_kld_Obersee((uint64_t)v111, v50, *(_QWORD *)a1, *(_QWORD *)(v49 + 16), *(unsigned int *)(*v106 + 4 * v56), v56, (uint64_t)v127);
    if ((v27 & 0x80000000) != 0)
      break;
    v63 = *(unsigned __int16 *)(v49 + 8);
    v64 = mfs_symData_DistanceOnUid_Obersee(v50, *(_QWORD *)a1, (uint64_t)v125, *(unsigned int *)(*(_QWORD *)(v49 + 16) + 8), (uint64_t)v105, (uint64_t)v128, v103, v62);
    v65 = 0;
    v66 = (float)(1.0 - v55) * v64;
    do
    {
      v66 = v66 + (float)(v55 * *(float *)&v127[v65]);
      v65 += 4;
    }
    while (v65 != 12);
    v67 = (float)((float)((float)v63 * v60) + 100.0) * v66;
    if (v67 >= 65535.0)
      v67 = 65535.0;
    mfs_CandidateList_UpdateCost_Obersee(v100, v59, (int)v67);
    v68 = *(unsigned __int16 *)(v49 + 8);
    if (v68 < (unsigned __int16)*v61)
      *v61 = v68;
    v49 += 24;
    if (++v59 == v57)
      goto LABEL_85;
  }
LABEL_95:
  mfs_TCost_Clear(v111);
  return v27;
}

