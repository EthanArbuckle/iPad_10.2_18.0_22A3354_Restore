uint64_t edct_Open_RWDCT(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = OOCAllocator_Calloc(a1, 1, 72, &v8);
  result = v8;
  if (!v8)
  {
    *(_DWORD *)(v6 + 32) = 0;
    *(_DWORD *)(v6 + 20) = 0;
    *(_DWORD *)(v6 + 24) = 0;
    *(_QWORD *)v6 = 0;
    *(_QWORD *)(v6 + 8) = 0;
    *(_QWORD *)(v6 + 56) = 0;
    *(_QWORD *)(v6 + 64) = 0;
    *(_QWORD *)(v6 + 48) = a1;
    if (!a2 || (result = DctFromArchive((char **)v6, a2), !(_DWORD)result))
    {
      result = 0;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t GetNbrSubDct(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 56);
  if (!v1)
    return 0;
  LODWORD(result) = 0;
  do
  {
    result = (result + 1);
    v1 = *(_QWORD *)(v1 + 136);
  }
  while (v1);
  return result;
}

uint64_t edct_EntryLookup_In_RODCT(char *__s1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int *a5)
{
  int **v5;
  uint64_t v6;
  unsigned int v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  int *v13;
  int *v14;
  int *v15;
  int v16;
  const char *v17;
  unsigned int *v18;
  int *v19;
  int v20;
  const char *v21;
  const char *v22;
  const void *v23;
  int *v24;
  int v25;
  int *v26;
  int *v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  _DWORD *v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  uint64_t result;
  int *v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  void *v42;
  int *v43;
  char *v44;
  unint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  void *v49;
  uint64_t *v50;
  unsigned int *v51;
  int v52;
  uint64_t v53;
  int v55;
  int v56;
  int *v57;
  char *__s2;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;

  v60 = 0;
  v5 = *(int ***)(a3 + 56);
  if (!v5)
  {
    result = 0;
    v8 = 0;
    v9 = 0;
    goto LABEL_68;
  }
  v6 = a2;
  v50 = a4;
  v51 = a5;
  v8 = 0;
  v9 = 0;
  v53 = *(_QWORD *)(a3 + 48);
  do
  {
    v61 = 0;
    v10 = *v5;
    v59 = v8;
    if (*v5)
    {
      v11 = v10 + 2;
      v12 = v10 + 3;
      v13 = v10 + 4;
      v14 = v10 + 8;
    }
    else
    {
      v15 = v5[1];
      v11 = v15 + 2;
      v12 = v15 + 3;
      v13 = v15 + 4;
      v14 = v15 + 9;
    }
    v16 = *v11;
    v55 = *v13;
    v56 = *v12;
    v17 = (const char *)v5[2];
    v18 = (unsigned int *)v5[6];
    v57 = v5[4];
    __s2 = (char *)v5[5];
    v19 = v5[7];
    v20 = *v14;
    if (v6)
    {
      v21 = *(const char **)(v6 + 8);
      if (v21)
      {
        if (!v17 || strcmp(v21, v17))
          goto LABEL_38;
      }
      v22 = *(const char **)(v6 + 32);
      if (v22)
      {
        if (__s2 && strcmp(v22, __s2))
          goto LABEL_38;
      }
      v23 = *(const void **)(v6 + 24);
      if (v23)
      {
        if (v57 && memcmp(v23, v57, 0x80uLL))
          goto LABEL_38;
      }
      if (*(_DWORD *)v6 != -1)
      {
        v24 = v10 ? v10 + 2 : v5[1] + 2;
        if (*(_DWORD *)v6 != *v24)
          goto LABEL_38;
      }
      v25 = *(_DWORD *)(v6 + 4);
      if (v25 != -1)
      {
        v26 = v10 ? v10 + 4 : v5[1] + 4;
        if (v25 != *v26)
          goto LABEL_38;
      }
    }
    v27 = v10 ? v10 + 8 : v5[1] + 9;
    if (!*v27)
      goto LABEL_38;
    v52 = v16;
    v28 = v20 - 1;
    v29 = strcmp(__s1, (const char *)v19 + *v18);
    v30 = strcmp(__s1, (const char *)v19 + v18[v20 - 1]);
    LODWORD(v31) = 0;
    v32 = 0;
    if ((v29 & 0x80000000) == 0 && v30 <= 0)
    {
      v33 = 0;
      while (1)
      {
        v34 = (v33 + v28) >> 1;
        v35 = strcmp(__s1, (const char *)v19 + v18[v34]);
        if (!v35)
          break;
        if (v35 <= 0)
          v28 = v34 - 1;
        else
          v33 = v34 + 1;
        if (v33 > v28)
          goto LABEL_38;
      }
      v37 = v5[8];
      v38 = v37[v34];
      v39 = v37[(v34 + 1)];
      if (v39 >= 0)
        v40 = v39;
      else
        v40 = -v39;
      if ((v38 & 0x80000000) != 0)
      {
        v43 = v5[9];
        v44 = (char *)v43 + (((unint64_t)v43 - v38) & 1) - v38;
        v45 = (unint64_t)v43 + v40;
        v46 = v44 + 2;
        if ((unint64_t)(v44 + 2) < v45)
        {
          LODWORD(v31) = 0;
          v32 = 0;
          while (1)
          {
            v31 = (v31 + 1);
            v32 = (_DWORD *)OOCAllocator_Realloc(v53, (uint64_t)v32, (unint64_t)v31 << 6, &v61);
            result = v61;
            if (v61)
              break;
            v47 = (char *)&v32[16 * v31];
            *((_DWORD *)v47 - 16) = v52;
            *((_DWORD *)v47 - 15) = v56;
            *((_DWORD *)v47 - 14) = v55;
            *((_QWORD *)v47 - 6) = v17;
            *((_QWORD *)v47 - 4) = v57;
            *((_QWORD *)v47 - 3) = __s2;
            v48 = *(unsigned __int16 *)v44;
            *((_DWORD *)v47 - 2) = v48;
            if ((*v32 | 2) == 3)
            {
              v49 = (void *)OOCAllocator_Malloc(v53, v48, &v61);
              result = v61;
              if (v61)
                break;
              *((_QWORD *)v47 - 2) = v49;
              memcpy(v49, v46, *((_DWORD *)v47 - 2) & 0xFFFFFFFE);
              v48 = *(unsigned __int16 *)v44;
            }
            else
            {
              *((_QWORD *)v47 - 2) = v46;
            }
            v44 = &v46[v48 + ((unint64_t)&v46[v48] & 1)];
            v46 = v44 + 2;
            if ((unint64_t)(v44 + 2) >= v45)
              goto LABEL_39;
          }
LABEL_66:
          a4 = v50;
          a5 = v51;
          v8 = v59;
          goto LABEL_68;
        }
LABEL_38:
        v32 = 0;
        LODWORD(v31) = 0;
        goto LABEL_39;
      }
      v32 = (_DWORD *)OOCAllocator_Malloc(v53, 64, &v61);
      result = v61;
      if (v61)
        goto LABEL_66;
      *v32 = v52;
      v32[1] = v56;
      v32[2] = v55;
      *((_QWORD *)v32 + 2) = v17;
      *((_QWORD *)v32 + 4) = v57;
      *((_QWORD *)v32 + 5) = __s2;
      v41 = v40 - v38;
      v32[14] = v41;
      if ((v52 | 2) == 3)
      {
        v42 = (void *)OOCAllocator_Malloc(v53, v41, &v61);
        result = v61;
        if (v61)
          goto LABEL_66;
        *((_QWORD *)v32 + 6) = v42;
        memcpy(v42, (char *)v5[9] + v38, v32[14] & 0xFFFFFFFE);
      }
      else
      {
        *((_QWORD *)v32 + 6) = (char *)v5[9] + v38;
      }
      LODWORD(v31) = 1;
    }
LABEL_39:
    result = v61;
    v60 = v61;
    if (v61)
      goto LABEL_66;
    if ((_DWORD)v31)
    {
      v8 = v59;
      v9 = OOCAllocator_Realloc(v53, v9, (unint64_t)(v31 + v59) << 6, &v60);
      result = v60;
      if (v60)
        goto LABEL_67;
      memcpy((void *)(v9 + ((unint64_t)v59 << 6)), v32, (unint64_t)v31 << 6);
      OOCAllocator_Free(v53, (uint64_t)v32);
      v8 = v31 + v59;
    }
    else
    {
      v8 = v59;
    }
    v5 = (int **)v5[10];
    v6 = a2;
  }
  while (v5);
  result = v60;
LABEL_67:
  a4 = v50;
  a5 = v51;
LABEL_68:
  *a4 = v9;
  *a5 = v8;
  return result;
}

uint64_t edct_EntryLookup_In_RWDCT(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int *a6)
{
  uint64_t v7;
  unsigned int v11;
  uint64_t v12;
  int v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const void *v18;
  const void *v19;
  uint64_t result;
  _QWORD v22[2];
  uint64_t v23;
  int v24;
  unsigned int v25;

  v7 = *(_QWORD *)(a4 + 56);
  v24 = -1;
  v25 = 0;
  if (v7)
  {
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v22[0] = 0;
      v22[1] = 0;
      v23 = 0;
      if (!a3)
        break;
      if (*(_DWORD *)a3 == -1 || *(_DWORD *)a3 == *(_DWORD *)(v7 + 8))
      {
        v13 = *(_DWORD *)(a3 + 4);
        if (v13 == -1 || v13 == *(_DWORD *)(v7 + 16))
        {
          v14 = *(const char **)(a3 + 8);
          if (!v14 || (v15 = *(const char **)(v7 + 24)) != 0 && !strcmp(v14, v15))
          {
            v16 = *(const char **)(a3 + 32);
            if (!v16 || (v17 = *(const char **)(v7 + 48)) == 0 || !strcmp(v16, v17))
            {
              v18 = *(const void **)(a3 + 24);
              if (!v18)
                break;
              v19 = *(const void **)(v7 + 40);
              if (!v19 || !memcmp(v18, v19, 0x80uLL))
                break;
            }
          }
        }
      }
LABEL_24:
      v7 = *(_QWORD *)(v7 + 136);
      if (!v7)
        goto LABEL_27;
    }
    *(_DWORD *)(v7 + 120) = -1;
    while (1)
    {
      result = DICT_Find(v7 + 56, a2, (uint64_t)v22, &v24);
      v25 = result;
      if ((_DWORD)result)
        break;
      if (!v24)
      {
        v12 = OOCAllocator_Realloc(a1, v12, (unint64_t)(v11 + 1) << 6, &v25);
        result = v25;
        if (v25)
          return result;
        result = edct_CopyFoundMatch(a1, v12 + ((unint64_t)v11 << 6), v7, (uint64_t)v22);
        v25 = result;
        if ((_DWORD)result)
          return result;
        ++v11;
      }
      if (HIDWORD(v23) != 1)
        goto LABEL_24;
    }
  }
  else
  {
    v12 = 0;
    v11 = 0;
LABEL_27:
    result = 0;
    *a5 = v12;
    *a6 = v11;
  }
  return result;
}

uint64_t edct_CopyFoundMatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char *v8;
  unsigned int v9;
  const char *v10;
  const char *v11;
  char *v12;
  uint64_t result;
  const char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  const char *v19;
  char *v20;
  __int128 *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  const char *v28;
  void *v29;
  unsigned int v30;

  v30 = 0;
  v8 = *(const char **)(a3 + 24);
  if (v8)
    v9 = strlen(v8) + 1;
  else
    v9 = 0;
  v10 = *(const char **)(a3 + 32);
  if (v10)
    v9 += strlen(v10) + 1;
  v11 = *(const char **)(a3 + 48);
  if (*(_QWORD *)(a3 + 40))
    v9 += 128;
  if (v11)
    v9 += strlen(v11) + 1;
  if (!v9)
  {
    v12 = 0;
    v16 = 0;
    v17 = 0;
LABEL_15:
    v18 = 0;
    goto LABEL_25;
  }
  v12 = (char *)OOCAllocator_Malloc(a1, v9, &v30);
  result = v30;
  if (v30)
    return result;
  v14 = *(const char **)(a3 + 24);
  if (v14)
  {
    v15 = strcpy(v12, v14);
    v16 = &v12[strlen(v15) + 1];
  }
  else
  {
    v16 = v12;
    v12 = 0;
  }
  v19 = *(const char **)(a3 + 32);
  if (v19)
  {
    v20 = strcpy(v16, v19);
    v17 = &v16[strlen(v20) + 1];
  }
  else
  {
    v17 = v16;
    v16 = 0;
  }
  v21 = *(__int128 **)(a3 + 40);
  if (v21)
  {
    v22 = *v21;
    v23 = v21[1];
    v24 = v21[3];
    *((_OWORD *)v17 + 2) = v21[2];
    *((_OWORD *)v17 + 3) = v24;
    *(_OWORD *)v17 = v22;
    *((_OWORD *)v17 + 1) = v23;
    v25 = v21[4];
    v26 = v21[5];
    v27 = v21[7];
    *((_OWORD *)v17 + 6) = v21[6];
    *((_OWORD *)v17 + 7) = v27;
    *((_OWORD *)v17 + 4) = v25;
    *((_OWORD *)v17 + 5) = v26;
    v18 = v17 + 128;
  }
  else
  {
    v18 = v17;
    v17 = 0;
  }
  v28 = *(const char **)(a3 + 48);
  if (!v28)
    goto LABEL_15;
  strcpy(v18, v28);
LABEL_25:
  v29 = (void *)OOCAllocator_Malloc(a1, *(unsigned int *)(a4 + 16), &v30);
  result = v30;
  if (!v30)
  {
    memcpy(v29, *(const void **)(a4 + 8), *(unsigned int *)(a4 + 16));
    *(_QWORD *)a2 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a2 + 16) = v12;
    *(_QWORD *)(a2 + 24) = v16;
    *(_QWORD *)(a2 + 32) = v17;
    *(_QWORD *)(a2 + 40) = v18;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 16);
    *(_QWORD *)(a2 + 48) = v29;
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(a4 + 16);
    return v30;
  }
  return result;
}

uint64_t srvspi_MemblockInit(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pBlock");
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  *(_QWORD *)(a1 + 8) = a3;
  return 0;
}

uint64_t srvspi_MemblockAlign(int *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;

  if (!a1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pBlock");
  v2 = *a1;
  v3 = *a1 % a2;
  v4 = v3 ? a2 - v3 : 0;
  if (*((_QWORD *)a1 + 1) && a1[1] < (v4 + v2))
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pBlock");
  if (v4)
    *a1 = v4 + v2;
  return 0;
}

uint64_t srvspi_MemblockAlloc(unsigned int *a1, int a2, _QWORD *a3)
{
  uint64_t v3;
  unsigned int v4;

  if (!a1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pBlock");
  if (a3)
  {
    v3 = *((_QWORD *)a1 + 1);
    if (v3)
      v3 += *a1;
    *a3 = v3;
  }
  v4 = *a1 + a2;
  *a1 = v4;
  if (!*((_QWORD *)a1 + 1) || a1[1] >= v4)
    return 0;
  else
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pBlock");
}

uint64_t srvspi_MemblockGetUsed(_DWORD *a1, _DWORD *a2)
{
  if (!a1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pBlock");
  if (!a2)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pulUsed");
  *a2 = *a1;
  return 0;
}

uint64_t edct_DctArchive(uint64_t a1, char *a2, int *a3, int a4)
{
  if (!a4 && *(_DWORD *)(a1 + 44) == 1 || *(_DWORD *)(a1 + 32) == 1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDct");
  else
    return DctArchive(a1, a2, a3, a4);
}

uint64_t edct_DctFreeAllEntryDataSpec(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
    return edct_FreeEntryDataSpec_In_RWDCT(*(_QWORD *)(a1 + 48), a1, a2);
  else
    return 0;
}

uint64_t edct_DctAddEntry(uint64_t a1, char *a2, int *a3, unsigned int a4)
{
  uint64_t result;
  int *v5;
  unint64_t v8;
  int v9;

  if (*(_DWORD *)(a1 + 32) == 1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDct");
  if (!a4)
    return 0;
  v5 = a3;
  v8 = (unint64_t)&a3[16 * (unint64_t)a4];
  while (1)
  {
    v9 = 0;
    result = edct_CheckEntryDataHealth((uint64_t)v5);
    if ((_DWORD)result)
      break;
    result = edct_AddEntry_RWDCT(a1, a2, v5, &v9);
    if ((_DWORD)result)
      break;
    v5 += 16;
    if ((unint64_t)v5 >= v8)
      return 0;
  }
  return result;
}

uint64_t edct_DctOpen(uint64_t a1, int *a2, int a3, uint64_t *a4)
{
  uint64_t result;
  int *v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  int *v12;

  v12 = a2;
  v11 = 0;
  if (!a2)
    goto LABEL_7;
  result = DctDecryptArchive(&v12, &v11);
  if ((_DWORD)result)
    return result;
  v8 = v12;
  if (!v12)
  {
LABEL_7:
    if (a3 == 1)
    {
      result = kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"bReadOnly");
      if ((_DWORD)result)
        return result;
      goto LABEL_12;
    }
    v9 = a1;
    v8 = 0;
LABEL_11:
    result = edct_Open_RWDCT(v9, (uint64_t)v8, a4);
    if ((_DWORD)result)
      return result;
    goto LABEL_12;
  }
  v9 = a1;
  if (a3 != 1)
    goto LABEL_11;
  result = edct_Open_RODCT(a1, v12, a4);
  if ((_DWORD)result)
    return result;
LABEL_12:
  result = 0;
  v10 = (_DWORD *)*a4;
  v10[9] = 0;
  v10[10] = 0;
  v10[11] = v11;
  return result;
}

uint64_t edct_DctGetEntryData(uint64_t a1, char *__s1, uint64_t a3, uint64_t *a4, unsigned int *a5)
{
  *a4 = 0;
  *a5 = 0;
  if (*(_DWORD *)(a1 + 32) == 1)
    return edct_EntryLookup_In_RODCT(__s1, a3, a1, a4, a5);
  else
    return edct_EntryLookup_In_RWDCT(*(_QWORD *)(a1 + 48), (uint64_t)__s1, a3, a1, a4, a5);
}

uint64_t edct_DctRemoveEntry(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 32) == 1)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDct");
  else
    return edct_RemoveEntry_RWDCT(a1, a2);
}

uint64_t edct_DctFreeEntryData(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  int v6;
  uint64_t v7;

  if (!a3)
    return 0;
  v6 = *(_DWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 48);
  if (v6 == 1)
  {
    edct_EntryFree_In_RODCT(v7, a2, a3);
    return 0;
  }
  return edct_EntryFree_In_RWDCT(v7, a1, (uint64_t)a2, a3);
}

uint64_t edct_DctGetInfo(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  size_t v9;
  char *v10;
  size_t v11;
  char *v12;
  unsigned int v13;

  v13 = 0;
  v4 = *(const char **)a1;
  v5 = *(const char **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 20);
  if (*(_DWORD *)(a1 + 32))
  {
    *(_QWORD *)a2 = v4;
    *(_QWORD *)(a2 + 8) = v5;
LABEL_3:
    *(_QWORD *)(a2 + 20) = v6;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 44);
    return v13;
  }
  v8 = *(_QWORD *)(a1 + 48);
  if (v5)
  {
    v9 = strlen(*(const char **)(a1 + 8));
    v10 = (char *)OOCAllocator_Malloc(v8, v9 + 1, &v13);
    *(_QWORD *)(a2 + 8) = v10;
    result = v13;
    if (v13)
      return result;
    strcpy(v10, v5);
    if (!v4)
    {
LABEL_8:
      *(_QWORD *)a2 = 0;
      goto LABEL_3;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    if (!v4)
      goto LABEL_8;
  }
  v11 = strlen(v4);
  v12 = (char *)OOCAllocator_Malloc(v8, v11 + 1, &v13);
  *(_QWORD *)a2 = v12;
  result = v13;
  if (!v13)
  {
    strcpy(v12, v4);
    goto LABEL_3;
  }
  return result;
}

uint64_t edct_DctFreeInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;

  if (!*(_DWORD *)(a1 + 32))
  {
    v4 = a2[1];
    if (v4)
      OOCAllocator_Free(*(_QWORD *)(a1 + 48), v4);
    if (*a2)
      OOCAllocator_Free(*(_QWORD *)(a1 + 48), *a2);
  }
  return 0;
}

uint64_t edct_DctGetAllEntryDataSpec(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  *a2 = 0;
  *a3 = 0;
  if (*(_DWORD *)(a1 + 32) == 1)
    return edct_GetEntryDataSpec_In_RODCT(a1, a2, a3);
  else
    return edct_GetEntryDataSpec_In_RWDCT(*(_QWORD *)(a1 + 48), a1, a2, a3);
}

uint64_t edct_DctClose(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36))
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDct");
  if (*(_DWORD *)(a1 + 32) == 1)
    return edct_Close_RODCT(a1);
  return edct_Close_RWDCT((uint64_t *)a1);
}

uint64_t edct_DctInitSubDctFromTransSpec(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  result = CreateSubDct(a1, &v5);
  if (!(_DWORD)result)
    return InitSubDct(v5, *(_QWORD *)(a1 + 48), a2);
  return result;
}

uint64_t DctIt_RO_Open(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t result;
  unsigned int v7;

  v7 = 0;
  v5 = OOCAllocator_Calloc(a1, 1, 80, &v7);
  result = v7;
  if (!v7)
  {
    *(_QWORD *)(v5 + 64) = *(_QWORD *)(a2 + 56);
    *(_DWORD *)(v5 + 72) = 0;
    *a3 = v5;
  }
  return result;
}

uint64_t DctIt_RO_HasEnded(uint64_t a1)
{
  _QWORD *v1;
  int v2;
  _DWORD *v3;

  v1 = *(_QWORD **)(a1 + 64);
  if (v1)
  {
    v2 = *(_DWORD *)(a1 + 72);
    while (1)
    {
      v3 = (_DWORD *)(*v1 ? *v1 + 32 : v1[1] + 36);
      if (v2 != *v3)
        break;
      v2 = 0;
      v1 = (_QWORD *)v1[10];
      *(_QWORD *)(a1 + 64) = v1;
      *(_DWORD *)(a1 + 72) = 0;
      if (!v1)
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    *(_DWORD *)(a1 + 40) = 1;
  }
  return 0;
}

uint64_t DctIt_RO_Increment(uint64_t a1)
{
  int v1;
  _QWORD *v2;
  _DWORD *v3;

  v1 = *(_DWORD *)(a1 + 72) + 1;
  *(_DWORD *)(a1 + 72) = v1;
  v2 = *(_QWORD **)(a1 + 64);
  do
  {
    if (*v2)
      v3 = (_DWORD *)(*v2 + 32);
    else
      v3 = (_DWORD *)(v2[1] + 36);
    if (v1 != *v3)
      break;
    v1 = 0;
    v2 = (_QWORD *)v2[10];
    *(_QWORD *)(a1 + 64) = v2;
    *(_DWORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 48) = 1;
  }
  while (v2);
  return 0;
}

uint64_t DctIt_RO_Current(uint64_t a1)
{
  _QWORD *v2;
  _DWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  unint64_t v18;
  unsigned __int16 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;

  v29 = 0;
  v28 = *(_QWORD *)a1;
  v2 = *(_QWORD **)(a1 + 64);
  v3 = (_DWORD *)*v2;
  if (!*v2)
    v3 = (_DWORD *)v2[1];
  v26 = v3[3];
  v27 = v3[2];
  v4 = v3[4];
  v5 = v2[2];
  v6 = v2[3];
  v7 = v2[4];
  v8 = v2[5];
  *(_DWORD *)(a1 + 24) = 0;
  v9 = v2[8];
  v10 = *(unsigned int *)(a1 + 72);
  v11 = *(unsigned int *)(v9 + 4 * v10);
  *(_QWORD *)(a1 + 16) = 0;
  v12 = *(_DWORD *)(v9 + 4 * (v10 + 1));
  if (v12 >= 0)
    v13 = v12;
  else
    v13 = -v12;
  if ((v11 & 0x80000000) != 0)
  {
    v16 = v2[9];
    v17 = (unsigned __int16 *)(((v16 + -(int)v11) & 1) + v16 + -(int)v11);
    v18 = v16 + v13;
    v19 = v17 + 1;
    if ((unint64_t)(v17 + 1) < v18)
    {
      LODWORD(v20) = 0;
      v21 = 0;
      do
      {
        if (*(_DWORD *)(a1 + 56))
        {
          v22 = OOCAllocator_Realloc(v28, v21, (unint64_t)(v20 + 1) << 6, &v29);
          *(_QWORD *)(a1 + 16) = v22;
          v15 = v29;
          if (v29)
            return v15;
          v21 = v22;
          v20 = *(unsigned int *)(a1 + 24);
          v23 = v22 + (v20 << 6);
          *(_DWORD *)v23 = v27;
          *(_DWORD *)(v23 + 4) = v26;
          *(_DWORD *)(v23 + 8) = v4;
          *(_QWORD *)(v23 + 16) = v5;
          *(_QWORD *)(v23 + 24) = v6;
          *(_QWORD *)(v23 + 32) = v7;
          *(_QWORD *)(v23 + 40) = v8;
          v24 = *v17;
          *(_DWORD *)(v23 + 56) = v24;
          *(_QWORD *)(v23 + 48) = v19;
        }
        else
        {
          v24 = *v17;
        }
        v17 = (unsigned __int16 *)((char *)v19 + v24 + (((unint64_t)v19 + v24) & 1));
        LODWORD(v20) = v20 + 1;
        *(_DWORD *)(a1 + 24) = v20;
        v19 = v17 + 1;
      }
      while ((unint64_t)(v17 + 1) < v18);
    }
    goto LABEL_18;
  }
  if (!*(_DWORD *)(a1 + 56))
  {
LABEL_10:
    *(_DWORD *)(a1 + 24) = 1;
LABEL_18:
    *(_QWORD *)(a1 + 32) = v2[7] + *(unsigned int *)(v2[6] + 4 * *(unsigned int *)(a1 + 72));
    return v29;
  }
  v14 = OOCAllocator_Malloc(v28, 64, &v29);
  *(_QWORD *)(a1 + 16) = v14;
  v15 = v29;
  if (!v29)
  {
    *(_DWORD *)v14 = v27;
    *(_DWORD *)(v14 + 4) = v26;
    *(_DWORD *)(v14 + 8) = v4;
    *(_QWORD *)(v14 + 16) = v5;
    *(_QWORD *)(v14 + 24) = v6;
    *(_QWORD *)(v14 + 32) = v7;
    *(_QWORD *)(v14 + 40) = v8;
    *(_QWORD *)(v14 + 48) = v2[9] + v11;
    *(_DWORD *)(v14 + 56) = v13 - v11;
    goto LABEL_10;
  }
  return v15;
}

uint64_t DctIt_RO_FreeLastItem(uint64_t *a1)
{
  uint64_t v1;

  v1 = a1[2];
  if (v1)
  {
    OOCAllocator_Free(*a1, v1);
    a1[2] = 0;
  }
  return 0;
}

uint64_t DctIt_RW_Open(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;

  v8 = 0;
  v5 = OOCAllocator_Calloc(a1, 1, 144, &v8);
  result = v8;
  if (!v8)
  {
    v7 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(v5 + 64) = v7;
    if (!v7 || (result = DICTITT_Init(v5 + 72, (uint64_t *)(v7 + 56)), !(_DWORD)result))
    {
      result = 0;
      *a3 = v5;
    }
  }
  return result;
}

uint64_t DctIt_RW_Close(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 64))
    return ARRAY_Flush(a1 + 96);
  else
    return 0;
}

uint64_t DctIt_RW_HasEnded(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (*(_QWORD *)(a1 + 64))
  {
    while (!*(_DWORD *)(a1 + 80) && *(_DWORD *)(a1 + 136) == -1)
    {
      result = ARRAY_Flush(a1 + 96);
      if ((_DWORD)result)
        return result;
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 136);
      *(_QWORD *)(a1 + 64) = v3;
      if (!v3)
        goto LABEL_8;
      result = DICTITT_Init(a1 + 72, (uint64_t *)(v3 + 56));
      if ((_DWORD)result)
        return result;
    }
    return 0;
  }
  else
  {
LABEL_8:
    result = 0;
    *(_DWORD *)(a1 + 40) = 1;
  }
  return result;
}

uint64_t DctIt_RW_Increment(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (*(_DWORD *)(a1 + 136) != -1 || (result = BINTREEITT_Inc((unsigned int *)(a1 + 80)), !(_DWORD)result))
  {
    for (; !*(_DWORD *)(a1 + 80); *(_DWORD *)(a1 + 48) = 1)
    {
      if (*(_DWORD *)(a1 + 136) != -1)
        break;
      result = ARRAY_Flush(a1 + 96);
      if ((_DWORD)result)
        return result;
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 136);
      *(_QWORD *)(a1 + 64) = v3;
      if (!v3)
        break;
      result = DICTITT_Init(a1 + 72, (uint64_t *)(v3 + 56));
      if ((_DWORD)result)
        return result;
    }
    return 0;
  }
  return result;
}

uint64_t DctIt_RW_Current(uint64_t a1)
{
  unsigned int *v2;
  uint64_t v3;
  size_t v4;
  char *v5;
  __int128 v7;
  uint64_t v8;
  char *__s[2];
  uint64_t v10;
  unsigned int found;

  found = 0;
  __s[0] = 0;
  __s[1] = 0;
  v10 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v2 = (unsigned int *)(a1 + 72);
  *(_DWORD *)(a1 + 24) = 0;
  while (1)
  {
    DICTITT_Current(v2, (uint64_t)&v7);
    *(_OWORD *)__s = v7;
    v10 = v8;
    if (*(_DWORD *)(a1 + 56))
    {
      v3 = OOCAllocator_Realloc(*(_QWORD *)a1, *(_QWORD *)(a1 + 16), (unint64_t)(*(_DWORD *)(a1 + 24) + 1) << 6, &found);
      *(_QWORD *)(a1 + 16) = v3;
      if (found)
        break;
      found = edct_CopyFoundMatch(*(_QWORD *)a1, v3 + ((unint64_t)*(unsigned int *)(a1 + 24) << 6), *(_QWORD *)(a1 + 64), (uint64_t)__s);
      if (found)
        break;
    }
    ++*(_DWORD *)(a1 + 24);
    if (HIDWORD(v10) != 1)
    {
      if (*(_DWORD *)(a1 + 52))
      {
        v4 = strlen(__s[0]);
        v5 = (char *)OOCAllocator_Malloc(*(_QWORD *)a1, v4 + 1, &found);
        *(_QWORD *)(a1 + 32) = v5;
        if (!found)
          strcpy(v5, __s[0]);
      }
      return found;
    }
  }
  return found;
}

uint64_t DctIt_RW_FreeLastItem(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    OOCAllocator_Free(*(_QWORD *)a1, v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    result = edct_EntryFree_In_RWDCT(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), v3, *(_DWORD *)(a1 + 24));
    if ((_DWORD)result)
      return result;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

double edct_DctItOpen(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  double result;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  if (a2[11] == 1)
  {
    kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDct");
    return result;
  }
  if (a2[8])
  {
    if (!DctIt_RO_Open(a1, (uint64_t)a2, a3))
    {
      v7 = (_QWORD *)*a3;
      *((_DWORD *)v7 + 10) = 0;
      if (!DctIt_RO_HasEnded((uint64_t)v7))
      {
LABEL_9:
        *(_QWORD *)*a3 = a1;
        *(_QWORD *)(*a3 + 8) = a2;
        *(_QWORD *)(*a3 + 32) = 0;
        *(_QWORD *)(*a3 + 16) = 0;
        v9 = *a3;
        *(_DWORD *)(v9 + 24) = 0;
        *(_QWORD *)&result = 0x100000000;
        *(_QWORD *)(v9 + 44) = 0x100000000;
      }
    }
  }
  else
  {
    ++a2[10];
    if (!DctIt_RW_Open(a1, (uint64_t)a2, a3))
    {
      v8 = *a3;
      *(_DWORD *)(v8 + 40) = 0;
      if (!DctIt_RW_HasEnded(v8))
        goto LABEL_9;
    }
  }
  return result;
}

uint64_t edct_DctItClose(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[1];
  if (*(_DWORD *)(v2 + 32))
  {
    result = DctIt_RO_FreeLastItem(a1);
    if ((_DWORD)result)
      return result;
    goto LABEL_6;
  }
  --*(_DWORD *)(v2 + 40);
  result = DctIt_RW_FreeLastItem((uint64_t)a1);
  if (!(_DWORD)result)
  {
    result = DctIt_RW_Close((uint64_t)a1);
    if (!(_DWORD)result)
    {
LABEL_6:
      OOCAllocator_Free(*a1, (uint64_t)a1);
      return 0;
    }
  }
  return result;
}

uint64_t edct_DctItHasEnded(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 40);
  return 0;
}

uint64_t edct_DctItCurrent(uint64_t a1, _QWORD *a2, _QWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;

  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  if (a2)
    *(_DWORD *)(a1 + 52) = 1;
  if (a3)
    *(_DWORD *)(a1 + 56) = 1;
  if (*(_DWORD *)(a1 + 40))
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDctIt");
  if (!*(_DWORD *)(a1 + 44))
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 32))
    {
      result = DctIt_RO_Current(a1);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      result = DctIt_RW_Current(a1);
      if ((_DWORD)result)
        return result;
    }
  }
  if (a2)
    *a2 = *(_QWORD *)(a1 + 32);
  if (a3)
    *a3 = *(_QWORD *)(a1 + 16);
  if (a4)
    *a4 = *(_DWORD *)(a1 + 24);
  if (a5)
    *a5 = *(_DWORD *)(a1 + 48);
  result = 0;
  *(_QWORD *)(a1 + 44) = 1;
  return result;
}

uint64_t edct_DctItIncrement(uint64_t a1)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 40))
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDctIt");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 32))
  {
    result = DctIt_RO_FreeLastItem((uint64_t *)a1);
    if (!(_DWORD)result)
    {
      result = DctIt_RO_Increment(a1);
      if (!(_DWORD)result)
      {
        result = DctIt_RO_HasEnded(a1);
        if (!(_DWORD)result)
        {
LABEL_11:
          result = 0;
          *(_DWORD *)(a1 + 44) = 0;
        }
      }
    }
  }
  else
  {
    result = DctIt_RW_FreeLastItem(a1);
    if (!(_DWORD)result)
    {
      result = DctIt_RW_Increment(a1);
      if (!(_DWORD)result)
      {
        result = DctIt_RW_HasEnded(a1);
        if (!(_DWORD)result)
          goto LABEL_11;
      }
    }
  }
  return result;
}

uint64_t CDSObject_Con(_QWORD *a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result;

  result = CDSBase_Con(a1, a2, a3, a4, a5);
  if (!(_DWORD)result)
  {
    *a1 = &__CDSObject;
    a1[19] = &unk_1EA937208;
    a1[20] = &unk_1EA937240;
    a1[21] = &unk_1EA937268;
    a1[22] = &unk_1EA937280;
    a1[3] = &unk_1EA9371C0;
    return __CDSObject_Init((uint64_t)a1, a2);
  }
  return result;
}

uint64_t __CDSObject_Init(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned int v7;

  v7 = 0;
  *(_DWORD *)(a1 + 200) = 0;
  v4 = (_QWORD *)OOCAllocator_Calloc(a2, 1, 40, &v7);
  *(_QWORD *)(a1 + 184) = v4;
  v5 = v7;
  if (!v7)
  {
    *v4 = a1 + 144;
    return PNEW_TranscriptionTokenizer_Con(a2, a2, (_QWORD *)(a1 + 192));
  }
  return v5;
}

uint64_t CDSObject_Des(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = a1[13];
  result = OOC_PlacementDeleteObject(v2, a1[24]);
  if (!(_DWORD)result)
  {
    v4 = a1[23];
    if (v4)
      OOCAllocator_Free(v2, v4);
    return CDSBase_Des(a1);
  }
  return result;
}

uint64_t CDSObject_BorrowTranscriptionSpec(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 184);
  return 0;
}

uint64_t CDSObject_CastToIVoConObject(uint64_t a1)
{
  return a1 + 24;
}

uint64_t CDSObject_FetchInfo(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned int v7;

  v7 = 0;
  v4 = (_QWORD *)OOCAllocator_Calloc(*(_QWORD *)(a1 + 104), 1, 24, &v7);
  *(_QWORD *)a2 = v4;
  v5 = v7;
  if (!v7)
  {
    *v4 = a1 + 144;
    *(_QWORD *)(*(_QWORD *)a2 + 8) = CDSHash_GetNbrKeyEntries(a1);
    *(_QWORD *)(*(_QWORD *)a2 + 16) = CDSBase_GetNbrValueEntries(a1);
    return v7;
  }
  return v5;
}

uint64_t CDSObject_FetchKeys(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v6;
  unsigned int NbrKeyEntries;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  uint64_t result;
  unint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unsigned int v23;

  v23 = 0;
  v21 = 0;
  v6 = *(_QWORD *)(a1 + 104);
  NbrKeyEntries = CDSHash_GetNbrKeyEntries(a1);
  v8 = NbrKeyEntries;
  *a3 = NbrKeyEntries;
  v9 = 8 * NbrKeyEntries;
  v10 = 0;
  if (NbrKeyEntries)
  {
    v11 = 0;
    while (1)
    {
      v12 = CDSHash_UnhashKey(a1) + 1;
      v13 = (unsigned __int16 *)OOCAllocator_Calloc(v6, 2, v12, &v23);
      result = v23;
      if (v23)
        break;
      CDSHash_UnhashKey(a1);
      CDSHash_DecodeKey(a1, v12, (uint64_t)v13);
      v21 = v13;
      v15 = utf16_utf8_byte_count(&v21);
      if (v15 == -1)
        return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pUcs2Key");
      v9 += v15 + 1;
      if (v15 >= v10)
        v10 = v15 + 1;
      OOCAllocator_Free(v6, (uint64_t)v13);
      if ((_DWORD)v8 == ++v11)
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v16 = OOCAllocator_Calloc(v6, 1, v9, &v23);
    *a2 = v16;
    result = v23;
    if (!v23)
    {
      v22 = v16 + 8 * v8;
      v17 = (unsigned __int16 *)OOCAllocator_Calloc(v6, 2, v10, &v23);
      result = v23;
      if (!v23)
      {
        if ((_DWORD)v8)
        {
          v18 = 0;
          v19 = v16 + v9;
          while (1)
          {
            v20 = CDSHash_UnhashKey(a1);
            CDSHash_DecodeKey(a1, v20 + 1, (uint64_t)v17);
            *(_QWORD *)(v16 + 8 * v18) = v22;
            v21 = v17;
            if (utf16_to_utf8(&v21, &v17[v20 + 1], &v22, v19))
              return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pUcs2Key");
            if ((_DWORD)v8 == (_DWORD)++v18)
              goto LABEL_14;
          }
        }
        else
        {
LABEL_14:
          OOCAllocator_Free(v6, (uint64_t)v17);
          return v23;
        }
      }
    }
  }
  return result;
}

uint64_t CDSObject_FetchTranscriptionSpec(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 184);
  return 0;
}

uint64_t CDSObject_FetchTranscriptions(uint64_t a1, char *a2, uint64_t *a3, uint64_t *a4)
{
  char FieldSeparator;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  _BOOL8 v21;
  _BYTE *v22;
  BOOL v23;
  uint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;

  v27 = 0;
  v31 = 0;
  v32 = 0;
  v29 = 0;
  v30 = 0;
  FieldSeparator = CDSBase_GetFieldSeparator(a1);
  v9 = *(_QWORD *)(a1 + 104);
  result = utf8_str_to_utf16(v9, a2, &v30, &v29);
  if (!(_DWORD)result)
  {
    v28 = 0;
    result = CDSBase_GetOutputString(a1, v30, 0, &v27, &v31, (int *)&v28, &v32);
    v33 = result;
    if (!(_DWORD)result)
    {
      OOCAllocator_Free(v9, v30);
      v11 = v28;
      if (v28)
      {
        v12 = v27;
        v13 = OOCAllocator_Calloc(v9, v28, 24, &v33);
        result = v33;
        if (v33)
          return result;
        v25 = a4;
        v26 = v11;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = v31;
        do
        {
          if (v16 == v17 || FieldSeparator == *(char *)(v12 + v16))
          {
            v19 = v16 - v15;
            if (v16 > v15)
            {
              if (v14 >= v26)
              {
                result = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Inconsitent CDS output");
                a4 = v25;
                v11 = v26;
                if ((_DWORD)result)
                  return result;
                goto LABEL_25;
              }
              *(_DWORD *)(v13 + 24 * v14) = CDSBase_GetTranscriptionType(a1);
              v20 = (_BYTE *)(v12 + v15);
              if (*(_DWORD *)(a1 + 200))
              {
                v21 = *v20 == 35;
                if (*v20 == 35)
                  v22 = v20 + 1;
                else
                  v22 = (_BYTE *)(v12 + v15);
                *(_QWORD *)(v13 + 24 * v14 + 8) = v22;
                v19 = v19 - v21 - (v20[v19 - v21] == 35);
                v20 = v22;
              }
              else
              {
                *(_QWORD *)(v13 + 24 * v14 + 8) = v20;
              }
              v20[v19] = 0;
              *(_QWORD *)(v13 + 24 * v14++ + 16) = v19 + 1;
              v17 = v31;
            }
            v18 = v16 + 1;
            v15 = v16 + 1;
          }
          else
          {
            v18 = v16 + 1;
          }
          v23 = v16 >= v17;
          v16 = v18;
        }
        while (!v23);
        v11 = v26;
        if (v14 == v26)
          result = v33;
        else
          result = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Inconsitent CDS output");
        a4 = v25;
        if ((_DWORD)result)
          return result;
      }
      else
      {
        v13 = 0;
      }
LABEL_25:
      result = TranscriptionTokenizer_FetchTranscriptions(*(_QWORD *)(a1 + 192), v13, v11, a3, a4);
      if (!(_DWORD)result)
      {
        if (v13)
        {
          v24 = *(_QWORD *)(a1 + 104);
          OOCAllocator_Free(v24, v27);
          OOCAllocator_Free(v24, v13);
        }
        return lhi_LogPhoneticTranscriptions(*(_QWORD *)(a1 + 40), (const char *)0x3E62B2CD, a2, *a3, *a4);
      }
    }
  }
  return result;
}

uint64_t CDSObject_QueryInterface(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;

  if (a2 > 1210932135)
  {
    if (a2 == 1210932136)
    {
      v3 = a1 + 168;
      goto LABEL_11;
    }
    if (a2 == 3420193956)
    {
      v3 = a1 + 176;
      goto LABEL_11;
    }
    return VoConObject_QueryInterface(a1, a2, a3);
  }
  if (a2 == 414531107)
  {
    v3 = a1 + 160;
    goto LABEL_11;
  }
  if (a2 != 414531721)
    return VoConObject_QueryInterface(a1, a2, a3);
  v3 = a1 + 152;
LABEL_11:
  *a3 = v3;
  return 0;
}

uint64_t CDSObject_ReturnInfo(uint64_t a1, uint64_t a2)
{
  if (a2)
    OOCAllocator_Free(*(_QWORD *)(a1 + 104), a2);
  return 0;
}

uint64_t CDSObject_ReturnKeys(uint64_t a1, uint64_t a2)
{
  if (a2)
    OOCAllocator_Free(*(_QWORD *)(a1 + 104), a2);
  return 0;
}

uint64_t CDSObject_ReturnTranscriptionSpec()
{
  return 0;
}

uint64_t CDSObject_ReturnTranscriptions(uint64_t a1, uint64_t a2)
{
  return TranscriptionTokenizer_ReturnTranscriptions(*(_QWORD *)(a1 + 192), a2);
}

uint64_t CDSObject_SetSilenceRemoveMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 200) = a2;
  return result;
}

uint64_t PNEW_CDSObject_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, _QWORD *a6)
{
  _QWORD *v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = (_QWORD *)OOCAllocator_Malloc(a1, 208, &v14);
  result = v14;
  if (!v14)
  {
    result = CDSObject_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      v12[2] = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t DctArchive(uint64_t a1, char *__b, int *a3, int a4)
{
  int v8;
  uint64_t result;
  int v10;
  const char *v11;
  int v12;
  int NbrSubDct;
  uint64_t v14;
  int v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char v22;
  int v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  char *__dst;
  _DWORD *v28;
  _QWORD v29[2];

  v8 = *a3;
  if (__b)
    memset(__b, 170, *a3);
  v29[0] = 0;
  v29[1] = 0;
  __dst = 0;
  v28 = 0;
  v25 = 0;
  v26 = 0;
  v24 = 0;
  result = srvspi_MemblockInit((uint64_t)v29, v8, (uint64_t)__b);
  if ((_DWORD)result)
    return result;
  if (a4)
  {
    result = srvspi_MemblockAlign((int *)v29, 4u);
    if ((_DWORD)result)
      return result;
    result = srvspi_MemblockAlloc((unsigned int *)v29, 8, &v24);
    if ((_DWORD)result)
      return result;
    if (v24)
      *v24 = 1397247071;
  }
  result = srvspi_MemblockAlign((int *)v29, 4u);
  if ((_DWORD)result)
    return result;
  result = srvspi_MemblockAlloc((unsigned int *)v29, 24, &v28);
  if ((_DWORD)result)
    return result;
  if (*(_QWORD *)a1)
  {
    v10 = strlen(*(const char **)a1) + 1;
    HIDWORD(v26) = v10;
    result = srvspi_MemblockAlign((int *)v29, 1u);
    if ((_DWORD)result)
      return result;
    result = srvspi_MemblockAlloc((unsigned int *)v29, v10, &__dst);
    if ((_DWORD)result)
      return result;
    if (__dst)
      strcpy(__dst, *(const char **)a1);
  }
  else
  {
    result = srvspi_MemblockAlign((int *)v29, 1u);
    if ((_DWORD)result)
      return result;
    result = srvspi_MemblockAlloc((unsigned int *)v29, 1, &__dst);
    if ((_DWORD)result)
      return result;
    if (__dst)
      *__dst = 0;
  }
  v11 = *(const char **)(a1 + 8);
  if (v11)
  {
    v12 = strlen(v11);
    result = srvspi_MemblockAlign((int *)v29, 1u);
    if ((_DWORD)result)
      return result;
    result = srvspi_MemblockAlloc((unsigned int *)v29, v12 + 1, &__dst);
    if ((_DWORD)result)
      return result;
    if (__dst)
      strcpy(__dst, *(const char **)(a1 + 8));
  }
  else
  {
    result = srvspi_MemblockAlign((int *)v29, 1u);
    if ((_DWORD)result)
      return result;
    result = srvspi_MemblockAlloc((unsigned int *)v29, 1, &__dst);
    if ((_DWORD)result)
      return result;
    if (__dst)
      *__dst = 0;
  }
  NbrSubDct = GetNbrSubDct(a1);
  HIDWORD(v26) = 4 * NbrSubDct;
  result = srvspi_MemblockAlign((int *)v29, 4u);
  if ((_DWORD)result)
    return result;
  result = srvspi_MemblockAlloc((unsigned int *)v29, 4 * NbrSubDct, &v25);
  if ((_DWORD)result)
    return result;
  v23 = 0;
  result = DctGetBufferType(a1, &v23);
  if ((_DWORD)result)
    return result;
  v14 = *(_QWORD *)(a1 + 56);
  result = srvspi_MemblockGetUsed(v29, &v26);
  if ((_DWORD)result)
    return result;
  if (!v14)
  {
LABEL_42:
    result = srvspi_MemblockGetUsed(v29, (_DWORD *)&v26 + 1);
    if ((_DWORD)result)
      return result;
    v17 = v28;
    if (v28)
    {
      result = 0;
      *v28 = v23;
      v18 = HIDWORD(v26);
      *(_QWORD *)(v17 + 1) = HIDWORD(v26);
      *(_QWORD *)(v17 + 3) = *(_QWORD *)(a1 + 20);
      v17[5] = NbrSubDct;
      *a3 = v18;
      if (a4 != 1)
        return result;
      v17[1] = v18 - 8;
    }
    else
    {
      v18 = HIDWORD(v26);
      *a3 = HIDWORD(v26);
      if (a4 != 1)
        return 0;
    }
    if (__b)
    {
      *((_DWORD *)__b + 1) = v18;
      v19 = (v18 - 8);
      if ((_DWORD)v19)
      {
        v20 = &__b[v19 + 8];
        v21 = __b + 8;
        v22 = -21;
        do
        {
          result = 0;
          *v21++ += v22;
          v22 += 111;
        }
        while (v21 < v20);
        return result;
      }
    }
    return 0;
  }
  v15 = v23;
  while (1)
  {
    result = srvspi_MemblockAlign((int *)v29, 4u);
    if ((_DWORD)result)
      return result;
    result = srvspi_MemblockGetUsed(v29, (_DWORD *)&v26 + 1);
    if ((_DWORD)result)
      return result;
    v16 = v25;
    if (v25)
    {
      *v25 = HIDWORD(v26) - v26;
      v25 = v16 + 1;
    }
    result = SubDctArchive(v14, v15, (int *)v29);
    if ((_DWORD)result)
      return result;
    v14 = *(_QWORD *)(v14 + 136);
    if (!v14)
      goto LABEL_42;
  }
}

uint64_t DctGetBufferType(uint64_t a1, int *a2)
{
  uint64_t v2;
  int v3;

  *a2 = 0;
  v2 = *(_QWORD *)(a1 + 56);
  if (v2)
  {
    v3 = 0;
    while (1)
    {
      if (*(_QWORD *)(v2 + 32))
      {
        if (!v3)
        {
          v3 = 7;
LABEL_12:
          *a2 = v3;
          goto LABEL_13;
        }
        if (v3 != 7)
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Unexpected: sub dictionaries should have the same type.");
      }
      else
      {
        if (!v3)
        {
          v3 = 6;
          goto LABEL_12;
        }
        if (v3 != 6)
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Unexpected: sub dictionaries should have the same type.");
      }
LABEL_13:
      v2 = *(_QWORD *)(v2 + 136);
      if (!v2)
        return 0;
    }
  }
  *a2 = 6;
  return 0;
}

uint64_t SubDctArchive(uint64_t a1, int a2, int *a3)
{
  uint64_t result;
  int v7;
  _QWORD *v8;
  const char *v9;
  int v10;
  const char *v11;
  int v12;
  int v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int v22;
  const char *v23;
  int v24;
  int v25;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  _DWORD *v33;
  int v34;
  int v35;
  int v36;
  char v37;
  const char *v38;
  _DWORD *v39;
  char *v40;
  BOOL v41;
  size_t v43;
  _DWORD *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  char *__src;
  char *v51;
  int v52;
  int v53;
  void *v54;
  char *__dst[2];
  int v56;
  int v57;
  char *v58;
  _BYTE *v59;
  _DWORD *v60;
  _DWORD *v61;
  _OWORD v62[4];
  uint64_t v63;
  _DWORD *v64;
  _DWORD *v65;
  uint64_t v66;
  _QWORD v67[2];

  v66 = 0;
  v67[0] = 0;
  v64 = 0;
  v65 = 0;
  v63 = 0;
  memset(v62, 0, sizeof(v62));
  v60 = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  result = srvspi_MemblockGetUsed(a3, v67);
  if (!(_DWORD)result)
  {
    if (a2 == 7)
    {
      HIDWORD(v67[0]) = 52;
      result = srvspi_MemblockAlign(a3, 4u);
      if ((_DWORD)result)
        return result;
      v7 = HIDWORD(v67[0]);
      v8 = &v65;
    }
    else
    {
      HIDWORD(v67[0]) = 48;
      result = srvspi_MemblockAlign(a3, 4u);
      if ((_DWORD)result)
        return result;
      v7 = HIDWORD(v67[0]);
      v8 = &v64;
    }
    result = srvspi_MemblockAlloc((unsigned int *)a3, v7, v8);
    if (!(_DWORD)result)
    {
      v9 = *(const char **)(a1 + 24);
      if (v9)
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = strlen(v9) + 1;
        result = srvspi_MemblockAlign(a3, 1u);
        if ((_DWORD)result)
          return result;
        result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if ((_DWORD)result)
          return result;
        if (__dst[0])
          strcpy(__dst[0], *(const char **)(a1 + 24));
        v10 = 1;
      }
      else
      {
        v10 = 0;
      }
      v11 = *(const char **)(a1 + 32);
      if (v11)
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = strlen(v11) + 1;
        result = srvspi_MemblockAlign(a3, 1u);
        if ((_DWORD)result)
          return result;
        result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if ((_DWORD)result)
          return result;
        if (__dst[0])
          strcpy(__dst[0], *(const char **)(a1 + 32));
        v12 = 1;
        v13 = 6;
      }
      else
      {
        v12 = 0;
        v13 = 7;
      }
      if (v13 == a2)
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Unexpected");
      if (*(_QWORD *)(a1 + 40))
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = 129;
        result = srvspi_MemblockAlign(a3, 1u);
        if ((_DWORD)result)
          return result;
        result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if ((_DWORD)result)
          return result;
        v14 = __dst[0];
        if (__dst[0])
        {
          v15 = *(_QWORD *)(a1 + 40);
          *(_OWORD *)__dst[0] = *(_OWORD *)v15;
          v16 = *(_OWORD *)(v15 + 16);
          v17 = *(_OWORD *)(v15 + 32);
          v18 = *(_OWORD *)(v15 + 64);
          *((_OWORD *)v14 + 3) = *(_OWORD *)(v15 + 48);
          *((_OWORD *)v14 + 4) = v18;
          *((_OWORD *)v14 + 1) = v16;
          *((_OWORD *)v14 + 2) = v17;
          v19 = *(_OWORD *)(v15 + 80);
          v20 = *(_OWORD *)(v15 + 96);
          v21 = *(_OWORD *)(v15 + 112);
          v14[128] = *(_BYTE *)(v15 + 128);
          *((_OWORD *)v14 + 6) = v20;
          *((_OWORD *)v14 + 7) = v21;
          *((_OWORD *)v14 + 5) = v19;
        }
        v22 = 1;
      }
      else
      {
        v22 = 0;
      }
      v23 = *(const char **)(a1 + 48);
      if (v23)
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = strlen(v23) + 1;
        result = srvspi_MemblockAlign(a3, 1u);
        if ((_DWORD)result)
          return result;
        result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if ((_DWORD)result)
          return result;
        if (__dst[0])
          strcpy(__dst[0], *(const char **)(a1 + 48));
        v24 = 1;
      }
      else
      {
        v24 = 0;
      }
      HIDWORD(v67[0]) = 4 * *(_DWORD *)a1 + 4;
      result = srvspi_MemblockAlign(a3, 4u);
      if (!(_DWORD)result)
      {
        result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), &v61);
        if (!(_DWORD)result)
        {
          result = srvspi_MemblockGetUsed(a3, (_DWORD *)&v66 + 1);
          if (!(_DWORD)result)
          {
            result = DICTITT_Init((uint64_t)v62, (uint64_t *)(a1 + 56));
            if (!(_DWORD)result)
            {
              v25 = 0;
              while (DWORD2(v62[0]) || (_DWORD)v63 != -1)
              {
                do
                  DICTITT_Current((unsigned int *)v62, (uint64_t)__dst);
                while (v57 == 1);
                v27 = strlen(__dst[0]);
                if ((_DWORD)v63 == -1)
                  result = BINTREEITT_Inc((unsigned int *)v62 + 2);
                else
                  result = 0;
                v25 += v27 + 1;
                if ((_DWORD)result)
                  return result;
              }
              result = ARRAY_Flush((uint64_t)&v62[1] + 8);
              if (!(_DWORD)result)
              {
                HIDWORD(v67[0]) = 1;
                result = srvspi_MemblockAlign(a3, 1u);
                if (!(_DWORD)result)
                {
                  result = srvspi_MemblockAlloc((unsigned int *)a3, v25, &v58);
                  if (!(_DWORD)result)
                  {
                    result = srvspi_MemblockGetUsed(a3, (_DWORD *)v67 + 1);
                    if (!(_DWORD)result)
                    {
                      v53 = HIDWORD(v67[0]);
                      v28 = HIDWORD(v66);
                      HIDWORD(v67[0]) = 4 * *(_DWORD *)a1 + 4;
                      result = srvspi_MemblockAlign(a3, 4u);
                      if (!(_DWORD)result)
                      {
                        result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), &v60);
                        if (!(_DWORD)result)
                        {
                          result = srvspi_MemblockGetUsed(a3, &v66);
                          if (!(_DWORD)result)
                          {
                            result = srvspi_MemblockAlign(a3, 1u);
                            if (!(_DWORD)result)
                            {
                              result = srvspi_MemblockAlloc((unsigned int *)a3, 1, &v59);
                              if (!(_DWORD)result)
                              {
                                v48 = v22;
                                v49 = v24;
                                v46 = v12;
                                v47 = v10;
                                if (v59)
                                  *v59 = -86;
                                v51 = v58;
                                result = DICTITT_Init((uint64_t)v62, (uint64_t *)(a1 + 56));
                                if (!(_DWORD)result)
                                {
                                  if (!DWORD2(v62[0]) && (_DWORD)v63 == -1)
                                  {
LABEL_68:
                                    result = ARRAY_Flush((uint64_t)&v62[1] + 8);
                                    if (!(_DWORD)result)
                                    {
                                      result = srvspi_MemblockGetUsed(a3, (_DWORD *)v67 + 1);
                                      if (!(_DWORD)result)
                                      {
                                        if (v60)
                                          *v60 = HIDWORD(v67[0]) - v66;
                                        v29 = HIDWORD(v67[0]);
                                        v30 = v66;
                                        if (v61 && v51 && v58)
                                          *v61 = (_DWORD)v51 - (_DWORD)v58;
                                        v31 = v53 - v28;
                                        v32 = v29 - v30;
                                        v33 = v65;
                                        if (v65)
                                        {
                                          result = 0;
                                          *v65 = HIDWORD(v67[0]) - LODWORD(v67[0]);
                                          *((_QWORD *)v33 + 1) = *(_QWORD *)(a1 + 8);
                                          v33[4] = *(_DWORD *)(a1 + 16);
                                          v33[5] = v47;
                                          v33[6] = v46;
                                          v33[7] = v48;
                                          v33[8] = v49;
                                          *(_QWORD *)(v33 + 9) = *(_QWORD *)a1;
                                          v33[11] = v31;
                                          v33[12] = v32;
                                        }
                                        else
                                        {
                                          v33 = v64;
                                          if (!v64)
                                            return 0;
                                          result = 0;
                                          *v64 = HIDWORD(v67[0]) - LODWORD(v67[0]);
                                          *((_QWORD *)v33 + 1) = *(_QWORD *)(a1 + 8);
                                          v33[4] = *(_DWORD *)(a1 + 16);
                                          v33[5] = v47;
                                          v33[6] = v48;
                                          v33[7] = v49;
                                          *((_QWORD *)v33 + 4) = *(_QWORD *)a1;
                                          v33[10] = v31;
                                          v33[11] = v32;
                                        }
                                        v33[1] = 0;
                                        return result;
                                      }
                                    }
                                    return result;
                                  }
                                  v34 = 0;
                                  while (1)
                                  {
                                    v54 = 0;
                                    DICTITT_Current((unsigned int *)v62, (uint64_t)__dst);
                                    __src = __dst[1];
                                    v35 = v56;
                                    v52 = v57;
                                    if (!v34)
                                    {
                                      v38 = __dst[0];
                                      v39 = v61;
                                      v40 = v58;
                                      if (v61)
                                        v41 = v51 == 0;
                                      else
                                        v41 = 1;
                                      if (!v41 && v58 != 0)
                                      {
                                        *v61 = (_DWORD)v51 - (_DWORD)v58;
                                        v61 = v39 + 1;
                                      }
                                      if (v40 && v51)
                                      {
                                        v43 = strlen(v38) + 1;
                                        memcpy(v51, v38, v43);
                                        v51 += v43;
                                      }
                                      result = srvspi_MemblockGetUsed(a3, (_DWORD *)v67 + 1);
                                      if ((_DWORD)result)
                                        return result;
                                      v44 = v60;
                                      if (v60)
                                      {
                                        if (v52 == 1)
                                        {
                                          *v60 = v66 - HIDWORD(v67[0]);
                                          v60 = v44 + 1;
                                          HIDWORD(v67[0]) = v35;
                                          v36 = 1;
LABEL_84:
                                          __dst[0] = 0;
                                          result = srvspi_MemblockAlign(a3, 2u);
                                          if ((_DWORD)result)
                                            return result;
                                          result = srvspi_MemblockAlloc((unsigned int *)a3, 2, __dst);
                                          if ((_DWORD)result)
                                            return result;
                                          if (__dst[0])
                                            *(_WORD *)__dst[0] = WORD2(v67[0]);
                                          v37 = 0;
                                          goto LABEL_105;
                                        }
                                        *v60 = HIDWORD(v67[0]) - v66;
                                        v60 = v44 + 1;
                                      }
                                    }
                                    if (v52 == 1)
                                      v36 = 1;
                                    else
                                      v36 = v34;
                                    HIDWORD(v67[0]) = v35;
                                    if (v36)
                                      goto LABEL_84;
                                    v37 = 1;
LABEL_105:
                                    result = srvspi_MemblockAlign(a3, 1u);
                                    if ((_DWORD)result)
                                      return result;
                                    result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), &v54);
                                    if ((_DWORD)result)
                                      return result;
                                    if (v54)
                                      memcpy(v54, __src, HIDWORD(v67[0]));
                                    if ((v37 & 1) == 0)
                                    {
                                      result = srvspi_MemblockAlign(a3, 2u);
                                      if ((_DWORD)result)
                                        return result;
                                    }
                                    if (v52)
                                      v34 = v36;
                                    else
                                      v34 = 0;
                                    v45 = v63;
                                    if ((_DWORD)v63 == -1)
                                    {
                                      result = BINTREEITT_Inc((unsigned int *)v62 + 2);
                                      if ((_DWORD)result)
                                        return result;
                                      v45 = v63;
                                    }
                                    if (!DWORD2(v62[0]) && v45 == -1)
                                      goto LABEL_68;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t DctFromArchive(char **a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  char *v5;
  size_t v6;
  char *v7;
  size_t v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *__src;
  char *__s;
  _QWORD v16[2];
  uint64_t v17;
  unsigned int v18;

  v16[0] = 0;
  v16[1] = 0;
  __src = 0;
  __s = 0;
  v12 = 0;
  v13 = 0;
  v17 = a2;
  result = srvspi_MemblockInit((uint64_t)v16, *(_DWORD *)(a2 + 4), a2);
  if (!(_DWORD)result)
  {
    result = srvspi_MemblockAlign((int *)v16, 4u);
    if (!(_DWORD)result)
    {
      result = srvspi_MemblockRead(v16, 24, &v17);
      if (!(_DWORD)result)
      {
        v4 = *(_DWORD *)v17;
        if ((*(_DWORD *)v17 & 0xFFFFFE) != 6)
        {
          v5 = "Wrong buffer type!";
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v5);
        }
        if (*(_DWORD *)(v17 + 8))
        {
          v5 = "Corrupted buffer!";
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v5);
        }
        *(char **)((char *)a1 + 20) = *(char **)(v17 + 12);
        result = srvspi_MemblockAlign((int *)v16, 1u);
        if (!(_DWORD)result)
        {
          result = srvspi_MemblockRead(v16, 0, &__s);
          if (!(_DWORD)result)
          {
            v6 = strlen(__s);
            result = srvspi_MemblockRead(v16, v6 + 1, &__s);
            v18 = result;
            if (!(_DWORD)result)
            {
              if (v6)
              {
                v7 = (char *)OOCAllocator_Malloc((uint64_t)a1[6], v6 + 1, &v18);
                *a1 = v7;
                result = v18;
                if (v18)
                  return result;
                strcpy(v7, __s);
              }
              else
              {
                *a1 = 0;
              }
              result = srvspi_MemblockAlign((int *)v16, 1u);
              v18 = result;
              if (!(_DWORD)result)
              {
                result = srvspi_MemblockRead(v16, 0, &__src);
                v18 = result;
                if (!(_DWORD)result)
                {
                  v8 = strlen(__src);
                  result = srvspi_MemblockRead(v16, v8 + 1, &__src);
                  v18 = result;
                  if (!(_DWORD)result)
                  {
                    if (v8)
                    {
                      v9 = (char *)OOCAllocator_Malloc((uint64_t)a1[6], v8 + 1, &v18);
                      a1[1] = v9;
                      result = v18;
                      if (v18)
                        return result;
                      strcpy(v9, __src);
                    }
                    else
                    {
                      a1[1] = 0;
                    }
                    result = srvspi_MemblockAlign((int *)v16, 4u);
                    v18 = result;
                    if (!(_DWORD)result)
                    {
                      result = srvspi_MemblockRead(v16, (4 * *(_DWORD *)(v17 + 20)), &v13);
                      v18 = result;
                      if (!(_DWORD)result)
                      {
                        result = srvspi_MemblockAlign((int *)v16, 4u);
                        v18 = result;
                        if (!(_DWORD)result)
                        {
                          result = srvspi_MemblockRead(v16, 0, &v12);
                          v18 = result;
                          if (!(_DWORD)result)
                          {
                            if (*(_DWORD *)(v17 + 20))
                            {
                              v10 = 0;
                              do
                              {
                                v11 = 0;
                                result = CreateSubDct((uint64_t)a1, &v11);
                                v18 = result;
                                if ((_DWORD)result)
                                  break;
                                result = srvspi_MemblockAlign((int *)v16, 4u);
                                v18 = result;
                                if ((_DWORD)result)
                                  break;
                                result = SubDctFromArchive(v11, v4 & 0xFFFFFF, (int *)v16, (uint64_t)a1[6]);
                                v18 = result;
                                if ((_DWORD)result)
                                  break;
                                v13 += 4;
                                ++v10;
                              }
                              while (v10 < *(_DWORD *)(v17 + 20));
                            }
                            else
                            {
                              return 0;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t SubDctFromArchive(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  uint64_t result;
  _DWORD *v9;
  _DWORD *v10;
  _DWORD *v11;
  int v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  _DWORD *v20;
  _OWORD *v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char *v30;
  unsigned int v31;
  unsigned int *v32;
  int v33;
  unsigned int i;
  size_t v35;
  char *v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unsigned __int16 *v42;
  int v43;
  char *__s;
  char *v45;
  uint64_t v46;
  _DWORD *v47;
  unsigned int *v48;
  int v49;
  _DWORD *v50;
  _DWORD *v51;
  unsigned int v52;

  v50 = 0;
  v51 = 0;
  v45 = 0;
  result = srvspi_MemblockAlign(a3, 4u);
  v52 = result;
  if (!(_DWORD)result)
  {
    v49 = 0;
    v47 = 0;
    v48 = 0;
    v46 = 0;
    if (a2 == 6)
    {
      result = srvspi_MemblockRead(a3, 48, &v51);
      v52 = result;
      if ((_DWORD)result)
        return result;
      v9 = 0;
      v10 = v51;
    }
    else
    {
      result = srvspi_MemblockRead(a3, 52, &v50);
      v52 = result;
      if ((_DWORD)result)
        return result;
      v10 = 0;
      v9 = v50;
    }
    if (v10)
      v11 = v10;
    else
      v11 = v9;
    v12 = v11[1];
    *(_DWORD *)(a1 + 8) = v11[2];
    *(_DWORD *)(a1 + 16) = v11[4];
    *(_DWORD *)(a1 + 12) = v11[3];
    v13 = v10 + 8;
    if (!v10)
      v13 = v9 + 9;
    *(_DWORD *)a1 = *v13;
    v14 = v10 + 9;
    if (!v10)
      v14 = v9 + 10;
    *(_DWORD *)(a1 + 4) = *v14;
    *(_QWORD *)(a1 + 24) = 0;
    result = srvspi_MemblockAlign(a3, 1u);
    v52 = result;
    if (!(_DWORD)result)
    {
      if (v10)
        v15 = v10;
      else
        v15 = v9;
      if (v15[5] == 1)
      {
        __s = 0;
        result = srvspi_MemblockRead(a3, 0, &__s);
        v52 = result;
        if ((_DWORD)result)
          return result;
        v16 = strlen(__s) + 1;
        result = srvspi_MemblockRead(a3, v16, &__s);
        v52 = result;
        if ((_DWORD)result)
          return result;
        v17 = (char *)OOCAllocator_Malloc(a4, v16, &v52);
        *(_QWORD *)(a1 + 24) = v17;
        result = v52;
        if (v52)
          return result;
        strcpy(v17, __s);
      }
      *(_QWORD *)(a1 + 32) = 0;
      result = srvspi_MemblockAlign(a3, 1u);
      v52 = result;
      if ((_DWORD)result)
        return result;
      if (!v10 && v9[6] == 1)
      {
        __s = 0;
        result = srvspi_MemblockRead(a3, 0, &__s);
        v52 = result;
        if ((_DWORD)result)
          return result;
        v18 = strlen(__s) + 1;
        result = srvspi_MemblockRead(a3, v18, &__s);
        v52 = result;
        if ((_DWORD)result)
          return result;
        v19 = (char *)OOCAllocator_Malloc(a4, v18, &v52);
        *(_QWORD *)(a1 + 32) = v19;
        result = v52;
        if (v52)
          return result;
        strcpy(v19, __s);
      }
      *(_QWORD *)(a1 + 40) = 0;
      result = srvspi_MemblockAlign(a3, 1u);
      v52 = result;
      if ((_DWORD)result)
        return result;
      v20 = v10 + 6;
      if (!v10)
        v20 = v9 + 7;
      if (*v20 == 1)
      {
        __s = 0;
        result = srvspi_MemblockRead(a3, 0, &__s);
        v52 = result;
        if ((_DWORD)result)
          return result;
        result = srvspi_MemblockRead(a3, 129, &__s);
        v52 = result;
        if ((_DWORD)result)
          return result;
        v21 = (_OWORD *)OOCAllocator_Malloc(a4, 129, &v52);
        *(_QWORD *)(a1 + 40) = v21;
        result = v52;
        if (v52)
          return result;
        v22 = __s;
        v23 = *((_OWORD *)__s + 3);
        v25 = *(_OWORD *)__s;
        v24 = *((_OWORD *)__s + 1);
        v21[2] = *((_OWORD *)__s + 2);
        v21[3] = v23;
        *v21 = v25;
        v21[1] = v24;
        v26 = *((_OWORD *)v22 + 7);
        v28 = *((_OWORD *)v22 + 4);
        v27 = *((_OWORD *)v22 + 5);
        v21[6] = *((_OWORD *)v22 + 6);
        v21[7] = v26;
        v21[4] = v28;
        v21[5] = v27;
        *(_BYTE *)(*(_QWORD *)(a1 + 40) + 128) = 0;
      }
      *(_QWORD *)(a1 + 48) = 0;
      v52 = srvspi_MemblockAlign(a3, 1u);
      if (v10)
      {
        if (!v10[7])
          goto LABEL_47;
      }
      else if (!v9[8])
      {
LABEL_47:
        result = DICT_Init(a1 + 56, a4, 10000, 50000);
        v52 = result;
        if (!(_DWORD)result)
        {
          result = srvspi_MemblockAlign(a3, 4u);
          v52 = result;
          if (!(_DWORD)result)
          {
            result = srvspi_MemblockRead(a3, (4 * *(_DWORD *)a1 + 4), &v48);
            v52 = result;
            if (!(_DWORD)result)
            {
              v31 = v12 ? 2 : 1;
              result = srvspi_MemblockAlign(a3, v31);
              v52 = result;
              if (!(_DWORD)result)
              {
                v32 = v10 + 10;
                if (!v10)
                  v32 = v9 + 11;
                result = srvspi_MemblockRead(a3, *v32, &v46);
                v52 = result;
                if (!(_DWORD)result)
                {
                  result = srvspi_MemblockAlign(a3, 4u);
                  v52 = result;
                  if (!(_DWORD)result)
                  {
                    result = srvspi_MemblockRead(a3, (4 * *(_DWORD *)a1 + 4), &v47);
                    v52 = result;
                    if (!(_DWORD)result)
                    {
                      result = srvspi_MemblockGetUsed(a3, &v49);
                      v52 = result;
                      if (!(_DWORD)result)
                      {
                        result = srvspi_MemblockAlign(a3, 1u);
                        v52 = result;
                        if (!(_DWORD)result)
                        {
                          result = srvspi_MemblockRead(a3, 1, 0);
                          v52 = result;
                          if (!(_DWORD)result)
                          {
                            if (*(_DWORD *)a1)
                            {
                              v33 = v12;
                              for (i = 0; i < *(_DWORD *)a1; ++i)
                              {
                                __s = 0;
                                v43 = -1;
                                if (v33)
                                {
                                  v42 = 0;
                                  result = utf16_str_to_utf8(a4, (unsigned __int16 *)(v46 + *v48), (uint64_t *)&v45, (unint64_t *)&v42);
                                  v52 = result;
                                  if ((_DWORD)result)
                                    return result;
                                }
                                else
                                {
                                  v35 = strlen((const char *)(v46 + *v48));
                                  v36 = (char *)OOCAllocator_Realloc(a4, (uint64_t)v45, v35 + 1, &v52);
                                  v45 = v36;
                                  result = v52;
                                  if (v52)
                                    return result;
                                  strcpy(v36, (const char *)(v46 + *v48));
                                }
                                v37 = v47[1];
                                if (v37 >= 0)
                                  v38 = v47[1];
                                else
                                  v38 = -v37;
                                if ((*v47 & 0x80000000) != 0)
                                {
                                  v41 = 0;
                                  v41 = -*v47;
                                  result = srvspi_MemblockAlign(a3, 2u);
                                  v52 = result;
                                  if ((_DWORD)result)
                                    return result;
                                  v40 = v41;
                                  while (v40 < v38)
                                  {
                                    v42 = 0;
                                    result = srvspi_MemblockRead(a3, 2, &v42);
                                    v52 = result;
                                    if ((_DWORD)result)
                                      return result;
                                    result = srvspi_MemblockAlign(a3, 1u);
                                    v52 = result;
                                    if ((_DWORD)result)
                                      return result;
                                    result = srvspi_MemblockRead(a3, *v42, &__s);
                                    v52 = result;
                                    if ((_DWORD)result)
                                      return result;
                                    result = DICT_Add(a1 + 56, v45, __s, *v42, &v43);
                                    v52 = result;
                                    if ((_DWORD)result)
                                      return result;
                                    result = srvspi_MemblockAlign(a3, 2u);
                                    v52 = result;
                                    if ((_DWORD)result)
                                      return result;
                                    result = srvspi_MemblockGetUsed(a3, &v41);
                                    v52 = result;
                                    if ((_DWORD)result)
                                      return result;
                                    v40 = v41 - v49;
                                    v41 -= v49;
                                  }
                                }
                                else
                                {
                                  LODWORD(v42) = 0;
                                  result = srvspi_MemblockAlign(a3, 1u);
                                  v52 = result;
                                  if ((_DWORD)result)
                                    return result;
                                  result = srvspi_MemblockGetUsed(a3, &v42);
                                  v52 = result;
                                  if ((_DWORD)result)
                                    return result;
                                  LODWORD(v42) = (_DWORD)v42 - v49;
                                  v39 = v38 - v42;
                                  result = srvspi_MemblockRead(a3, v39, &__s);
                                  v52 = result;
                                  if ((_DWORD)result)
                                    return result;
                                  result = DICT_Add(a1 + 56, v45, __s, v39, &v43);
                                  v52 = result;
                                  if ((_DWORD)result)
                                    return result;
                                }
                                ++v47;
                                ++v48;
                              }
                            }
                            OOCAllocator_Free(a4, (uint64_t)v45);
                            return v52;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result;
      }
      __s = 0;
      result = srvspi_MemblockRead(a3, 0, &__s);
      v52 = result;
      if ((_DWORD)result)
        return result;
      v29 = strlen(__s) + 1;
      result = srvspi_MemblockRead(a3, v29, &__s);
      v52 = result;
      if ((_DWORD)result)
        return result;
      v30 = (char *)OOCAllocator_Malloc(a4, v29, &v52);
      *(_QWORD *)(a1 + 48) = v30;
      result = v52;
      if (v52)
        return result;
      strcpy(v30, __s);
      goto LABEL_47;
    }
  }
  return result;
}

uint64_t DctDecryptArchive(_DWORD **a1, int *a2)
{
  _DWORD *v2;
  int v3;
  _BYTE *v4;
  unint64_t v5;
  char v6;
  _BYTE *v7;

  v2 = *a1;
  if (**a1 == 1397247071)
  {
    v4 = v2 + 2;
    if (v2[1] != 8)
    {
      v5 = (unint64_t)&v4[v2[1] - 8];
      v6 = -21;
      v7 = v4;
      do
      {
        *v7++ -= v6;
        v6 += 111;
      }
      while ((unint64_t)v7 < v5);
      v2 = *a1;
    }
    *v2 = 1397247021;
    goto LABEL_10;
  }
  if (*v2 == 1397247021)
  {
    v4 = v2 + 2;
LABEL_10:
    *a1 = v4;
    v3 = 1;
    goto LABEL_11;
  }
  v3 = 0;
LABEL_11:
  *a2 = v3;
  return 0;
}

uint64_t _DTQuestion_Con(_QWORD *a1, uint64_t a2)
{
  *a1 = &__DTQuestion;
  a1[1] = a2;
  return 0;
}

void *GetDTQuestionClass()
{
  return &__DTQuestion;
}

uint64_t PNEW_DTHypothesisList_Con(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 48, &v10);
  result = v10;
  if (!v10)
  {
    result = PtrList_Con((uint64_t)v8, a2, 1u, 1);
    if ((_DWORD)result)
    {
      v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *v8 = &__DTHypothesisList;
      v8[5] = a3;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTGraphemeBuffer_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__DTGraphemeBuffer;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 16) = a3;
    *(_BYTE *)(a1 + 40) = 0;
    return _DTGraphemeBuffer_CreateGPTable(a1);
  }
  return result;
}

uint64_t _DTGraphemeBuffer_CreateGPTable(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _DWORD *v4;
  _BYTE *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unsigned __int8 v9;
  int v10;
  uint64_t v13;
  _QWORD *v15;
  uint64_t v16;
  unsigned int v17;
  unsigned __int8 v18;
  unsigned __int8 i;
  unsigned __int8 *v20;
  uint64_t v21;
  unsigned int v22;

  v22 = 0;
  v2 = (_QWORD *)OOCAllocator_Realloc(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 24), 8 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 4) + 8, &v22);
  *(_QWORD *)(a1 + 24) = v2;
  v3 = v22;
  if (!v22)
  {
    v4 = *(_DWORD **)(a1 + 16);
    v6 = *v4;
    v5 = (char *)v4 + 6;
    v7 = *(_QWORD *)(a1 + 16) + v6;
    *v2 = v5;
    v8 = 1;
    *(_BYTE *)(a1 + 40) = 1;
    if (*(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 4) >= 2u)
    {
      v8 = 1;
      v9 = 1;
      v10 = 1;
      while (!*v5)
      {
LABEL_7:
        *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v8) = ++v5;
        if (**(unsigned __int8 **)(*(_QWORD *)(a1 + 24) + 8 * v8) != **(unsigned __int8 **)(*(_QWORD *)(a1 + 24)
                                                                                           + 8 * v8
                                                                                           - 8))
          *(_BYTE *)(a1 + 40) = ++v9;
        v8 = ++v10;
        if (*(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 4) <= v10)
          goto LABEL_12;
      }
      while ((unint64_t)v5 < v7)
      {
        if (!*++v5)
          goto LABEL_7;
      }
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Grapheme block is corrupt");
    }
    v9 = 1;
LABEL_12:
    if (*v5)
    {
      while ((unint64_t)v5 < v7)
      {
        if (!*++v5)
          goto LABEL_15;
      }
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Grapheme block is corrupt");
    }
LABEL_15:
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v8) = v5 + 1;
    v13 = OOCAllocator_Realloc(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 32), 16 * v9, &v22);
    *(_QWORD *)(a1 + 32) = v13;
    v3 = v22;
    if (v22)
    {
      *(_BYTE *)(a1 + 40) = 0;
    }
    else
    {
      v16 = *(_QWORD *)(a1 + 16);
      v15 = *(_QWORD **)(a1 + 24);
      *(_QWORD *)v13 = *v15;
      *(_BYTE *)(v13 + 8) = 0;
      v17 = *(unsigned __int16 *)(v16 + 4);
      if (v17 >= 2)
      {
        v18 = 0;
        for (i = 1; i < v17; ++i)
        {
          v20 = (unsigned __int8 *)v15[i];
          if (*v20 != **(unsigned __int8 **)(v13 + 16 * v18))
          {
            v21 = v13 + 16 * ++v18;
            *(_QWORD *)v21 = v20;
            *(_BYTE *)(v21 + 8) = i;
          }
        }
      }
      lhstdlib_qsort(v13, *(unsigned __int8 *)(a1 + 40), 0x10u, (uint64_t (*)(_BYTE *, _BYTE *))__DTGraphemeBuffer_Compare);
      return v22;
    }
  }
  return v3;
}

uint64_t DTGraphemeBuffer_Des(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)(a1 + 16) = 0;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    OOCAllocator_Free(*(_QWORD *)(a1 + 8), v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    OOCAllocator_Free(*(_QWORD *)(a1 + 8), v3);
    *(_QWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 40) = 0;
  }
  return Object_Des();
}

uint64_t DTGraphemeBuffer_FirstGraphemeID(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  int v4;
  _QWORD v5[2];

  v4 = -1;
  v5[0] = a2;
  v5[1] = 0;
  v2 = lhstdlib_bsearch((uint64_t)v5, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 0x10uLL, (uint64_t (*)(uint64_t, unint64_t))__DTGraphemeBuffer_Compare, &v4);
  if (v2)
    return *(unsigned __int8 *)(v2 + 8);
  else
    return 255;
}

uint64_t __DTGraphemeBuffer_Compare(char **a1, char **a2)
{
  int v2;
  int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = **a1;
  v3 = **a2;
  v4 = v2 < v3;
  v5 = v2 > v3;
  if (v4)
    return 0xFFFFFFFFLL;
  else
    return v5;
}

uint64_t PNEW_DTGraphemeBuffer_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 48, &v10);
  result = v10;
  if (!v10)
  {
    result = DTGraphemeBuffer_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTQuestionGPBin_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(char *)(v4 + 1) + a2;
  if (v5 < 0)
    return 0;
  result = 0;
  if (a3 && v5 < a4)
  {
    v7 = *(unsigned __int8 *)(v4 + 2);
    if (*(_BYTE *)(v4 + 2))
    {
      v8 = 0;
      v9 = *(unsigned __int8 *)(a3 + v5);
      v10 = v4 + 3;
      v11 = v7 - 1;
      while (1)
      {
        v12 = (v11 + v8) >> 1;
        v13 = *(unsigned __int8 *)(v10 + v12);
        if (v9 >= v13)
        {
          if (v9 <= v13)
            return 1;
          v8 = v12 + 1;
        }
        else
        {
          v11 = v12 - 1;
        }
        if (v8 > v11)
          return 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t PNEW_DTQuestionGPBin_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionGPBin;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t DTQuestionPP_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  int v13;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(char *)(v6 + 1);
  v8 = v7 + a6;
  if (v7 + a6 < 0)
    return 0;
  result = 0;
  if (!a5 || (v7 & 0x80000000) == 0)
    return result;
  v10 = *(unsigned __int8 *)(v6 + 2);
  if (!*(_BYTE *)(v6 + 2))
    return 0;
  v11 = *(unsigned __int16 *)(a5 + 2 * v8);
  v12 = (unsigned __int16 *)(v6 + 3);
  while (1)
  {
    v13 = *v12++;
    if (v13 == v11)
      break;
    if (!--v10)
      return 0;
  }
  return 1;
}

uint64_t PNEW_DTQuestionPP_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionPP;
      *a3 = v6;
    }
  }
  return result;
}

BOOL DTQuestionSG_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  _BOOL8 result;
  int v6;

  v4 = *(_QWORD *)(a1 + 8);
  result = 0;
  v6 = *(char *)(v4 + 1) + a2;
  if (v6 >= 0 && a3 && v6 < a4)
    return *(unsigned __int8 *)(a3 + v6) == *(unsigned __int8 *)(v4 + 2);
  return result;
}

uint64_t PNEW_DTQuestionSG_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionSG;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t PNEW_DTNodeBuffer_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t result;
  unsigned int v7;

  v7 = 0;
  v5 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v7);
  result = v7;
  if (!v7)
  {
    *v5 = a2;
    v5[1] = a2 + 4;
    *a3 = v5;
  }
  return result;
}

uint64_t PDELETE_DTNodeBuffer(uint64_t a1, uint64_t a2)
{
  OOCAllocator_Free(a1, a2);
  return 0;
}

uint64_t DTQuestionGP_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  unsigned __int8 *v9;
  int v10;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(char *)(v4 + 1) + a2;
  if (v5 < 0)
    return 0;
  result = 0;
  if (!a3 || v5 >= a4)
    return result;
  v7 = *(unsigned __int8 *)(v4 + 2);
  if (!*(_BYTE *)(v4 + 2))
    return 0;
  v8 = *(unsigned __int8 *)(a3 + v5);
  v9 = (unsigned __int8 *)(v4 + 3);
  while (1)
  {
    v10 = *v9++;
    if (v10 == v8)
      break;
    if (!--v7)
      return 0;
  }
  return 1;
}

uint64_t PNEW_DTQuestionGP_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionGP;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t addExpScore(int a1, int a2)
{
  __int16 v2;
  int v3;
  int v4;
  BOOL v5;
  int v6;

  v2 = a1 - a2;
  v3 = (a1 - a2) << 16;
  if (((a1 - a2) & 0x8000) != 0)
    v4 = a1;
  else
    v4 = a2;
  if ((((_WORD)a1 - (_WORD)a2) & 0x8000) != 0)
    v2 = a2 - a1;
  v5 = v3 <= 16646144;
  if (v3 <= 16646144)
    v6 = v4;
  else
    v6 = a2;
  if (!v5)
    v2 = 254;
  return (v6 + sc_logAddTable[v2]);
}

uint64_t PNEW_DTPhonemeBuffer_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t result;
  unsigned int v7;

  v7 = 0;
  v5 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v7);
  result = v7;
  if (!v7)
  {
    *v5 = a2;
    v5[1] = a2 + 2;
    *a3 = v5;
  }
  return result;
}

uint64_t PNEW_DTNode_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t result;
  unsigned int v7;

  v7 = 0;
  v5 = (_QWORD *)OOCAllocator_Malloc(a1, 8, &v7);
  result = v7;
  if (!v7)
  {
    *v5 = a2;
    *a3 = v5;
  }
  return result;
}

uint64_t DTTree_Con(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    *a1 = (uint64_t)&__DTTree;
    a1[1] = a2;
    result = PNEW_DTBuffer_Con(a2, a3, a1 + 2);
    if (!(_DWORD)result)
    {
      result = PNEW_DTNodeBuffer_Con(a2, *(_QWORD *)a1[2] + *(unsigned int *)(*(_QWORD *)a1[2] + 32), a1 + 3);
      if (!(_DWORD)result)
      {
        result = PNEW_DTNode_Con(a2, *(_QWORD *)a1[2] + *(unsigned int *)(*(_QWORD *)a1[2] + 36), a1 + 4);
        if (!(_DWORD)result)
        {
          result = PNEW_DTPhonemeBuffer_Con(a2, *(_QWORD *)a1[2] + *(unsigned int *)(*(_QWORD *)a1[2] + 44), a1 + 5);
          if (!(_DWORD)result)
          {
            result = PNEW_DTPhonemeBuffer_Con(a2, *(_QWORD *)a1[2] + *(unsigned int *)(*(_QWORD *)a1[2] + 48), a1 + 6);
            if (!(_DWORD)result)
            {
              result = PNEW_DTGraphemeBuffer_Con(a2, a2, *(_QWORD *)a1[2] + *(unsigned int *)(*(_QWORD *)a1[2] + 40), a1 + 7);
              if (!(_DWORD)result)
              {
                result = PNEW_DTQuestionBuffer_Con(a2, a2, *(_QWORD *)a1[2] + *(unsigned int *)(*(_QWORD *)a1[2] + 52), a1 + 8);
                if (!(_DWORD)result)
                {
                  v7 = *(_QWORD *)a1[2];
                  a1[9] = v7 + *(unsigned int *)(v7 + 28);
                  v8 = *(unsigned int *)(v7 + 56);
                  if ((_DWORD)v8)
                  {
                    result = PNEW_DTNode_Con(a2, v7 + v8, a1 + 10);
                    if ((_DWORD)result)
                      return result;
                  }
                  else
                  {
                    a1[10] = 0;
                  }
                  result = PNEW_DTNode_Con(a2, 0, a1 + 11);
                  if (!(_DWORD)result)
                  {
                    a1[12] = 0;
                    return _DTTree_CreateStartNodeIdTable(a1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _DTTree_CreateStartNodeIdTable(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  unsigned __int16 v12;
  uint64_t v13;
  unsigned __int8 v15;
  unsigned int v16;

  v16 = 0;
  v2 = *(unsigned __int16 *)(*(_QWORD *)(a1[7] + 16) + 4);
  v3 = OOCAllocator_Realloc(a1[1], a1[12], 2 * v2, &v16);
  a1[12] = v3;
  v4 = v16;
  if (!v16)
  {
    v15 = 0;
    if ((_DWORD)v2)
    {
      v5 = 0;
      v6 = a1[3];
      v7 = a1[11];
      do
      {
        *(_WORD *)(v3 + 2 * v5) = 0;
        v8 = *(unsigned __int16 **)(v6 + 8);
        *(_QWORD *)v7 = v8;
        v9 = *v8;
        if (v9 != 0xFFFF)
        {
          for (i = a1[8]; *(_BYTE *)(*(_QWORD *)(i + 32) + v9) == 4; i = a1[8])
          {
            v11 = DTQuestionBuffer_BorrowQuestion(i, (unsigned __int16)v9);
            if ((*(unsigned int (**)(uint64_t, _QWORD, unsigned __int8 *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v11 + 24))(v11, 0, &v15, 1, 0, 0))
            {
              v7 = a1[11];
              v3 = a1[12];
              v12 = *(_WORD *)(*(_QWORD *)v7 + 2);
              v5 = v15;
            }
            else
            {
              v5 = v15;
              v7 = a1[11];
              v3 = a1[12];
              v12 = *(_WORD *)(v3 + 2 * v15) + 1;
            }
            *(_WORD *)(v3 + 2 * v15) = v12;
            v6 = a1[3];
            v13 = *(_QWORD *)(v6 + 8);
            *(_QWORD *)v7 = v13 + 4 * v12;
            v9 = *(unsigned __int16 *)(v13 + 4 * v12);
            if (v9 == 0xFFFF)
              break;
          }
        }
        v15 = ++v5;
      }
      while (v2 > v5);
      return v16;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t DTTree_Des(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = OOC_PlacementDeleteObject(a1[1], a1[8]);
  if (!(_DWORD)result)
  {
    result = OOC_PlacementDeleteObject(a1[1], a1[7]);
    if (!(_DWORD)result)
    {
      result = PDELETE_DTNodeBuffer(a1[1], a1[6]);
      if (!(_DWORD)result)
      {
        result = PDELETE_DTNodeBuffer(a1[1], a1[5]);
        if (!(_DWORD)result)
        {
          result = PDELETE_DTNodeBuffer(a1[1], a1[4]);
          if (!(_DWORD)result)
          {
            result = PDELETE_DTNodeBuffer(a1[1], a1[3]);
            if (!(_DWORD)result)
            {
              result = PDELETE_DTNodeBuffer(a1[1], a1[2]);
              if (!(_DWORD)result)
              {
                result = PDELETE_DTNodeBuffer(a1[1], a1[11]);
                if (!(_DWORD)result)
                {
                  v3 = a1[10];
                  if (!v3 || (result = PDELETE_DTNodeBuffer(a1[1], v3), !(_DWORD)result))
                  {
                    v4 = a1[12];
                    if (v4)
                      OOCAllocator_Free(a1[1], v4);
                    return Object_Des();
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

unint64_t DTTree_Traverse(uint64_t a1, uint64_t a2, _BYTE *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v14;
  unsigned __int16 *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t PLeaf;

  v14 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 96) + 2 * a3[a2]);
  v15 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) + 4 * v14);
  **(_QWORD **)(a1 + 88) = v15;
  v16 = *v15;
  if (v16 != 0xFFFF)
  {
    do
    {
      v17 = DTQuestionBuffer_BorrowQuestion(*(_QWORD *)(a1 + 64), (unsigned __int16)v16);
      if ((*(unsigned int (**)(uint64_t, uint64_t, _BYTE *, size_t, uint64_t, uint64_t))(*(_QWORD *)v17 + 24))(v17, a2, a3, a4, a5, a6))
      {
        v18 = *(_QWORD *)(a1 + 88);
        LOWORD(v14) = *(_WORD *)(*(_QWORD *)v18 + 2);
      }
      else
      {
        LOWORD(v14) = v14 + 1;
        v18 = *(_QWORD *)(a1 + 88);
      }
      v19 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
      v20 = 4 * (unsigned __int16)v14;
      *(_QWORD *)v18 = v19 + v20;
      v16 = *(unsigned __int16 *)(v19 + v20);
    }
    while (v16 != 0xFFFF);
    v15 = (unsigned __int16 *)(v19 + v20);
  }
  PLeaf = DTLeafBuffer_GetPLeaf(*(_QWORD **)(a1 + 32), v15[1]);
  *a7 = PLeaf;
  if ((*(_BYTE *)(PLeaf + 1) & 2) != 0 && *(_QWORD *)(a1 + 80)
    || (*(_BYTE *)(PLeaf + 1) & 1) != 0
    && (*(_BYTE *)(PLeaf + 1) & 0xFC | (*(unsigned __int8 *)(PLeaf + 2) << 8)) == 4
    && *(_QWORD *)(a1 + 80))
  {
    return _DTTree_GraphemeFallbackTraverse(a1, a2, a3, a4, a5, a6, (uint64_t)a7);
  }
  else
  {
    return 0;
  }
}

unint64_t _DTTree_GraphemeFallbackTraverse(uint64_t a1, uint64_t a2, _BYTE *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t result;
  void *v15;
  char v16;
  unsigned int v17;

  v16 = a3[a2];
  result = DTGraphemeFallback_GetFallback(*(_QWORD **)(a1 + 80), v16, &v16);
  v17 = result;
  if (!(_DWORD)result)
  {
    v15 = (void *)OOCAllocator_Malloc(*(_QWORD *)(a1 + 8), a4, &v17);
    result = v17;
    if (!v17)
    {
      memcpy(v15, a3, a4);
      *((_BYTE *)v15 + a2) = v16;
      result = DTTree_Traverse(a1, a2, v15, a4, a5, a6, a7);
      v17 = result;
      if (!(_DWORD)result)
      {
        OOCAllocator_Free(*(_QWORD *)(a1 + 8), (uint64_t)v15);
        return v17;
      }
    }
  }
  return result;
}

uint64_t PNEW_DTTree_Con(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t **a4)
{
  uint64_t *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (uint64_t *)OOCAllocator_Malloc(a1, 104, &v10);
  result = v10;
  if (!v10)
  {
    result = DTTree_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

unint64_t DTGraphemeFallback_GetFallback(_QWORD *a1, char a2, _BYTE *a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t result;
  int v7;
  _BYTE v8[2];

  v7 = 0;
  v5 = *a1 + 2;
  v4 = *(unsigned __int16 *)*a1;
  v8[0] = a2;
  v8[1] = 0;
  result = lhstdlib_bsearch((uint64_t)v8, v5, v4, 2uLL, (uint64_t (*)(uint64_t, unint64_t))compareFallback, &v7);
  if (result)
  {
    *a3 = *(_BYTE *)(result + 1);
    return 1;
  }
  return result;
}

uint64_t compareFallback(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

uint64_t DTBuffer_Con(_QWORD *a1, _DWORD *a2)
{
  unsigned int v2;

  *a1 = a2;
  if (a2[2] == 4)
  {
    if (a2[3] == 21586)
    {
      v2 = a2[1];
      if (a2[8] <= v2)
      {
        if (a2[9] <= v2)
        {
          if (a2[11] <= v2 && a2[10] <= v2)
          {
            if (a2[13] <= v2)
            {
              return 0;
            }
            else
            {
              *a1 = 0;
              return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Questions block offset out of range");
            }
          }
          else
          {
            *a1 = 0;
            return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Pseudo-phonemes block offset out of range");
          }
        }
        else
        {
          *a1 = 0;
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Leafs block offset out of range");
        }
      }
      else
      {
        *a1 = 0;
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Nodes block offset out of range");
      }
    }
    else
    {
      *a1 = 0;
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Invalid build ID");
    }
  }
  else
  {
    *a1 = 0;
    return err_GenerateErrorVersion();
  }
}

uint64_t PNEW_DTBuffer_Con(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 8, &v8);
  result = v8;
  if (!v8)
  {
    result = DTBuffer_Con(v6, a2);
    v8 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

int8x16_t DTPostProcessor_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t result;
  uint64_t v7;

  if (!Object_Con((_QWORD *)a1))
  {
    *(_QWORD *)a1 = &__DTPostProcessor;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    v7 = *(_QWORD *)(a3 + 72);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(v7 + 16);
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a3 + 40);
    result = vextq_s8(*(int8x16_t *)(v7 + 28), *(int8x16_t *)(v7 + 28), 8uLL);
    *(int8x16_t *)(a1 + 80) = result;
  }
  return result;
}

uint64_t DTPostProcessor_Des(uint64_t a1)
{
  _DTPostProcessor_Clear(a1);
  return Object_Des();
}

uint64_t _DTPostProcessor_Clear(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t i;
  uint64_t v5;
  uint64_t v6;

  v1 = result;
  v2 = *(_QWORD *)(result + 32);
  if (v2)
  {
    v3 = *(_QWORD *)(result + 40);
    if (v3)
    {
      for (i = 0; i < v3; ++i)
      {
        v5 = *(_QWORD *)(*(_QWORD *)(v1 + 32) + 8 * i);
        if (v5)
        {
          OOCAllocator_Free(*(_QWORD *)(v1 + 8), v5);
          v3 = *(_QWORD *)(v1 + 40);
        }
      }
      v2 = *(_QWORD *)(v1 + 32);
    }
    result = OOCAllocator_Free(*(_QWORD *)(v1 + 8), v2);
    *(_QWORD *)(v1 + 32) = 0;
  }
  v6 = *(_QWORD *)(v1 + 48);
  if (v6)
  {
    result = OOCAllocator_Free(*(_QWORD *)(v1 + 8), v6);
    *(_QWORD *)(v1 + 48) = 0;
  }
  *(_QWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 96) = 0;
  *(_WORD *)(v1 + 100) = -1;
  *(_DWORD *)(v1 + 104) = 1;
  return result;
}

uint64_t DTPostProcessor_CreateNBest(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  unsigned int v13;
  _BOOL4 v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *__s2;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned int PhonemeSeq;

  PhonemeSeq = 0;
  v20 = 0;
  v21 = 0;
  __s2 = 0;
  _DTPostProcessor_Clear(a1);
  *(_QWORD *)(a1 + 40) = 0;
  if (kaldi::MatrixBase<float>::Stride(a2) < a3)
    a3 = kaldi::MatrixBase<float>::Stride(a2);
  if (a3)
  {
    *(_QWORD *)(a1 + 32) = OOCAllocator_Calloc(*(_QWORD *)(a1 + 8), a3, 8, &PhonemeSeq);
    if (!PhonemeSeq)
    {
      *(_QWORD *)(a1 + 48) = OOCAllocator_Calloc(*(_QWORD *)(a1 + 8), a3, 4, &PhonemeSeq);
      if (!PhonemeSeq && *(_QWORD *)(a1 + 40) < (unint64_t)a3)
      {
        v6 = 0;
        do
        {
          if (v6 >= kaldi::MatrixBase<float>::Stride(a2))
            break;
          v7 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 16);
          if (*(__int16 *)(v7 + PtrList_ItemN(a2, v6) * *(_QWORD *)(*(_QWORD *)(a2 + 40) + 24) + 4) == -1)
            break;
          v8 = PtrList_ItemN(a2, v6);
          v9 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 24) * v8);
          PhonemeSeq = _DTPostProcessor_GetPhonemeSeq(a1, (uint64_t)v9 + 6, *v9, (uint64_t *)&v21, &v20);
          if (PhonemeSeq)
            return PhonemeSeq;
          if (v20)
          {
            v10 = v21;
            PhonemeSeq = _DTPostProcessor_GetTransFromPhnId(a1, v21, v20, &__s2);
            if (PhonemeSeq)
              return PhonemeSeq;
            if (*(_DWORD *)(a1 + 60) || (v16 = __s2, !_DTPostProcessor_IsDoubleTranscription(a1, __s2)))
            {
              v11 = *(_DWORD *)(a1 + 80);
              v12 = *(_DWORD *)(a1 + 84);
              v13 = (v12
                   + v11
                   * *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                                       + *(_QWORD *)(*(_QWORD *)(a2 + 40) + 24) * v8
                                                       + 4))
                  / 0x3E8;
              if (*(_DWORD *)(a1 + 88))
              {
                v14 = _DTPostProcessor_KeepVariant(a1, (v12+ v11* *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)+ *(_QWORD *)(*(_QWORD *)(a2 + 40) + 24) * v8+ 4))/ 0x3E8);
                v15 = __s2;
                if (!v14)
                {
                  OOCAllocator_Free(*(_QWORD *)(a1 + 8), (uint64_t)__s2);
                  if (!v10)
                    return PhonemeSeq;
LABEL_23:
                  OOCAllocator_Free(*(_QWORD *)(a1 + 8), (uint64_t)v10);
                  return PhonemeSeq;
                }
              }
              else
              {
                v15 = __s2;
              }
              v17 = *(_QWORD *)(a1 + 40);
              *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v17) = v15;
              *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v17) = v13;
              *(_QWORD *)(a1 + 40) = v17 + 1;
            }
            else
            {
              OOCAllocator_Free(*(_QWORD *)(a1 + 8), (uint64_t)v16);
              __s2 = 0;
            }
          }
          ++v6;
        }
        while (*(_QWORD *)(a1 + 40) < (unint64_t)a3);
        v10 = v21;
        if (!v21)
          return PhonemeSeq;
        goto LABEL_23;
      }
    }
  }
  return PhonemeSeq;
}

uint64_t _DTPostProcessor_GetPhonemeSeq(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;

  v22 = 0;
  if (a3)
  {
    v10 = 0;
    v11 = 0;
    do
      v10 += *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) + *(unsigned __int16 *)(a2 + 2 * v11++));
    while (a3 != v11);
    if (v10)
    {
      *a4 = OOCAllocator_Realloc(*(_QWORD *)(a1 + 8), *a4, v10, &v22);
      result = v22;
      if (v22)
        return result;
      v13 = 0;
      v14 = 0;
      *a5 = 0;
      v15 = *(_QWORD *)(a1 + 16);
      while (1)
      {
        v16 = *(unsigned __int16 *)(a2 + 2 * v14);
        v17 = (unsigned __int8 *)(*(_QWORD *)(v15 + 8) + v16);
        v19 = *v17;
        v18 = v17 + 1;
        if (v19)
          break;
LABEL_17:
        if (++v14 == a3)
          return v22;
      }
      v20 = 0;
      while (1)
      {
        if (*(_DWORD *)(a1 + 56))
        {
          v21 = *a4;
        }
        else
        {
          v21 = *a4;
          if (v13 && *(unsigned __int8 *)(v13 + v21 - 1) == v18[v20])
            goto LABEL_12;
        }
        *(_BYTE *)(v21 + v13) = v18[v20];
        v13 = *a5 + 1;
        *a5 = v13;
        v15 = *(_QWORD *)(a1 + 16);
        v16 = *(unsigned __int16 *)(a2 + 2 * v14);
LABEL_12:
        if (++v20 >= (unint64_t)*(unsigned __int8 *)(*(_QWORD *)(v15 + 8) + v16))
          goto LABEL_17;
      }
    }
  }
  result = 0;
  *a5 = 0;
  return result;
}

uint64_t _DTPostProcessor_GetTransFromPhnId(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  unsigned int v12;
  _BYTE *v13;
  uint64_t result;
  unsigned int v15;
  size_t v16;
  unsigned int v17;

  v17 = 0;
  if (!a3)
    goto LABEL_8;
  v5 = a3;
  v6 = a2;
  v8 = 0;
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
  v10 = a2;
  v11 = a3;
  do
  {
    v12 = *v10++;
    v8 += strlen((const char *)(v9 + v12));
    --v11;
  }
  while (v11);
  if (v8)
  {
    v13 = (_BYTE *)OOCAllocator_Malloc(*(_QWORD *)(a1 + 8), v8 + 1, &v17);
    *a4 = v13;
    result = v17;
    if (!v17)
    {
      do
      {
        v15 = *v6++;
        v16 = strlen((const char *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) + v15));
        memcpy(v13, (const void *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) + v15), v16);
        v13 += v16;
        --v5;
      }
      while (v5);
      *v13 = 0;
      return v17;
    }
  }
  else
  {
LABEL_8:
    result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t _DTPostProcessor_IsDoubleTranscription(uint64_t a1, char *__s2)
{
  uint64_t v2;
  const char **i;

  if (!__s2)
    return 0;
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    return 0;
  for (i = *(const char ***)(a1 + 32); strcmp(*i, __s2); ++i)
  {
    if (!--v2)
      return 0;
  }
  return 1;
}

BOOL _DTPostProcessor_KeepVariant(uint64_t a1, int a2)
{
  int v4;
  _BOOL8 result;

  if (*(_DWORD *)(a1 + 104))
  {
    *(_DWORD *)(a1 + 96) = a2;
  }
  else
  {
    v4 = addExpScore(a2, *(_DWORD *)(a1 + 96));
    *(_DWORD *)(a1 + 96) = v4;
    if (v4 <= *(_DWORD *)(a1 + 88))
    {
      result = *(_DWORD *)(a1 + 92) + *(unsigned __int16 *)(a1 + 100) > a2;
      goto LABEL_6;
    }
  }
  result = 1;
LABEL_6:
  *(_WORD *)(a1 + 100) = a2;
  *(_DWORD *)(a1 + 104) = 0;
  return result;
}

size_t DTPostProcessor_GetTranscriptionSize(uint64_t a1, uint64_t a2)
{
  return strlen(*(const char **)(*(_QWORD *)(a1 + 32) + 8 * a2));
}

void PNEW_DTPostProcessor_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  int v9;
  int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 112, &v10);
  if (!v10)
  {
    DTPostProcessor_Con(v8, a2, a3);
    v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *a4 = v8;
    }
  }
}

uint64_t DTHypothesisPool_Compare(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t result;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v5 = (unsigned int *)(v3 + v4 * *a2);
  v6 = *((unsigned __int16 *)v5 + 2);
  v7 = v3 + v4 * *a3;
  v8 = *(unsigned __int16 *)(v7 + 4);
  if (v6 < v8)
    return 0xFFFFFFFFLL;
  if (v6 > v8)
    return 1;
  v10 = *v5;
  if (v10 < *(_DWORD *)v7)
    return 0xFFFFFFFFLL;
  if (v10 > *(_DWORD *)v7)
    return 1;
  if ((_DWORD)v10)
  {
    v11 = (unsigned __int16 *)v5 + 3;
    v12 = (unsigned __int16 *)(v7 + 6);
    while (1)
    {
      v14 = *v11++;
      v13 = v14;
      v15 = *v12++;
      v16 = v13 > v15;
      if (v13 < v15)
        break;
      if (v16)
        return 1;
      result = 0;
      if (!--v10)
        return result;
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t DTHypothesisPool_Con(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = ((2 - 2 * (_BYTE)a3) & 2) + 2 * a3 + 6;
    *(_DWORD *)(a1 + 32) = 0;
    *(_QWORD *)a1 = &__DTHypothesisPool;
    *(_QWORD *)(a1 + 8) = a2;
    return PNEW_PtrStack_Con(a2, a2, 1, (uint64_t *)(a1 + 40));
  }
  return result;
}

uint64_t DTHypothesisPool_Des(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[2];
  if (v2)
    OOCAllocator_Free(a1[1], v2);
  result = OOC_PlacementDeleteObject(a1[1], a1[5]);
  if (!(_DWORD)result)
    return Object_Des();
  return result;
}

uint64_t DTHypothesisPool_FetchHypoID(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;

  v14 = 0;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_DWORD *)(v4 + 24);
  if (v5)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(v4 + 32) + 8 * (v5 - 1));
    result = PtrStack_Remove(v4);
    if ((_DWORD)result)
      return result;
    v8 = (v6 - 1);
    v9 = *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 24) * v8;
    *(_DWORD *)v9 = 0;
    *(_WORD *)(v9 + 4) = 0;
    goto LABEL_10;
  }
  v8 = *(unsigned int *)(a1 + 32);
  v10 = (v8 + 1);
  v11 = OOCAllocator_Realloc(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24) * v10, &v14);
  result = v14;
  if (v14)
    return result;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = (*(_DWORD *)(a1 + 32) + 1);
  *(_DWORD *)(a1 + 32) = v12;
  if (v12 <= v10)
  {
LABEL_9:
    v13 = v11 + *(_QWORD *)(a1 + 24) * v8;
    *(_DWORD *)v13 = 0;
    *(_WORD *)(v13 + 4) = 0;
    result = v14;
LABEL_10:
    *a2 = v8;
    return result;
  }
  while (1)
  {
    result = PtrStack_Put(*(_QWORD *)(a1 + 40), v12);
    v14 = result;
    if ((_DWORD)result)
      return result;
    if (v10 >= --v12)
    {
      v11 = *(_QWORD *)(a1 + 16);
      goto LABEL_9;
    }
  }
}

uint64_t DTHypothesisPool_Resize(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(a1 + 24) = ((2 - 2 * (_BYTE)a2) & 2) + 2 * a2 + 6;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
    OOCAllocator_Free(*(_QWORD *)(a1 + 8), v3);
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  v4 = *(_QWORD *)(a1 + 40);
  if (!*(_DWORD *)(v4 + 24))
    return 0;
  do
  {
    v5 = PtrStack_Remove(v4);
    v4 = *(_QWORD *)(a1 + 40);
  }
  while (*(_DWORD *)(v4 + 24));
  return v5;
}

uint64_t DTHypothesisPool_ReturnHypoID(_QWORD *a1, unsigned int a2)
{
  *(_DWORD *)(a1[2] + a1[3] * a2) = -1;
  return PtrStack_Put(a1[5], a2 + 1);
}

uint64_t PNEW_DTHypothesisPool_Con(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 48, &v10);
  result = v10;
  if (!v10)
  {
    result = DTHypothesisPool_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTQuestionBuffer_Con(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  v14 = 0;
  v12 = 0;
  v13 = 0;
  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  v7 = 0;
  result = Object_Con(a1);
  v15 = result;
  if (!(_DWORD)result)
  {
    *a1 = &__DTQuestionBuffer;
    a1[1] = a2;
    a1[2] = a3;
    a1[4] = a3 + 4;
    a1[3] = OOCAllocator_Calloc(a2, 9, 8, &v15);
    result = v15;
    if (!v15)
    {
      result = PNEW_DTQuestionPP_Con(a2, 0, &v14);
      v15 = result;
      if (!(_DWORD)result)
      {
        *(_QWORD *)(a1[3] + 8) = v14;
        result = PNEW_DTQuestionWB_Con(a2, 0, &v12);
        v15 = result;
        if (!(_DWORD)result)
        {
          *(_QWORD *)(a1[3] + 16) = v12;
          result = PNEW_DTQuestionGP_Con(a2, 0, &v13);
          v15 = result;
          if (!(_DWORD)result)
          {
            *(_QWORD *)(a1[3] + 24) = v13;
            result = PNEW_DTQuestionTG_Con(a2, 0, &v11);
            v15 = result;
            if (!(_DWORD)result)
            {
              *(_QWORD *)(a1[3] + 32) = v11;
              result = PNEW_DTQuestionSG_Con(a2, 0, &v10);
              v15 = result;
              if (!(_DWORD)result)
              {
                *(_QWORD *)(a1[3] + 40) = v10;
                result = PNEW_DTQuestionSP_Con(a2, 0, &v9);
                v15 = result;
                if (!(_DWORD)result)
                {
                  *(_QWORD *)(a1[3] + 48) = v9;
                  result = PNEW_DTQuestionPPBin_Con(a2, 0, &v8);
                  v15 = result;
                  if (!(_DWORD)result)
                  {
                    *(_QWORD *)(a1[3] + 56) = v8;
                    result = PNEW_DTQuestionGPBin_Con(a2, 0, &v7);
                    if (!(_DWORD)result)
                      *(_QWORD *)(a1[3] + 64) = v7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t DTQuestionBuffer_Des(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = 0;
  a1[2] = 0;
  while (1)
  {
    v3 = *(_QWORD *)(a1[3] + v2);
    if (v3)
    {
      result = OOC_PlacementDeleteObject(a1[1], v3);
      if ((_DWORD)result)
        break;
    }
    v2 += 8;
    if (v2 == 72)
    {
      OOCAllocator_Free(a1[1], a1[3]);
      return Object_Des();
    }
  }
  return result;
}

uint64_t DTQuestionBuffer_BorrowQuestion(uint64_t a1, unsigned int a2)
{
  unsigned __int8 *v2;
  uint64_t result;

  v2 = (unsigned __int8 *)(*(_QWORD *)(a1 + 32) + a2);
  result = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * *v2);
  *(_QWORD *)(result + 8) = v2;
  return result;
}

uint64_t PNEW_DTQuestionBuffer_Con(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 40, &v10);
  result = v10;
  if (!v10)
  {
    result = DTQuestionBuffer_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTSearch_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  __int16 *v7;
  __int16 v8;
  uint64_t v9;
  unsigned int v10;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__DTSearch;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = a3;
    result = PNEW_DTHypothesisPool_Con(a2, a2, 0, (uint64_t *)(a1 + 24));
    if (!(_DWORD)result)
    {
      result = PNEW_DTHypothesisList_Con(a2, a2, *(_QWORD *)(a1 + 24), (_QWORD *)(a1 + 32));
      if (!(_DWORD)result)
      {
        result = PNEW_DTHypothesisList_Con(a2, a2, *(_QWORD *)(a1 + 24), (_QWORD *)(a1 + 40));
        v10 = result;
        if (!(_DWORD)result)
        {
          *(_QWORD *)(a1 + 64) = 0;
          *(_QWORD *)(a1 + 72) = 0;
          v7 = *(__int16 **)(*(_QWORD *)(a1 + 16) + 72);
          v8 = *v7;
          *(_WORD *)(a1 + 48) = *v7;
          *(_WORD *)(a1 + 50) = v8;
          v9 = *((unsigned int *)v7 + 2);
          *(_DWORD *)(a1 + 52) = *((_DWORD *)v7 + 1);
          *(_DWORD *)(a1 + 56) = v9;
          LOWORD(v7) = v7[6];
          *(_WORD *)(a1 + 60) = (_WORD)v7;
          *(_WORD *)(a1 + 62) = (_WORD)v7;
          *(_QWORD *)(a1 + 80) = 0;
          if ((_DWORD)v9)
          {
            *(_QWORD *)(a1 + 80) = OOCAllocator_Realloc(a2, 0, 4 * v9, &v10);
            return v10;
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DTSearch_Des(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;

  result = _DTSearch_ClearHypothesis((uint64_t)a1, a1[5]);
  if (!(_DWORD)result)
  {
    result = _DTSearch_ClearHypothesis((uint64_t)a1, a1[4]);
    if (!(_DWORD)result)
    {
      result = OOC_PlacementDeleteObject(a1[1], a1[4]);
      if (!(_DWORD)result)
      {
        result = OOC_PlacementDeleteObject(a1[1], a1[5]);
        if (!(_DWORD)result)
        {
          result = OOC_PlacementDeleteObject(a1[1], a1[3]);
          if (!(_DWORD)result)
          {
            result = __DTSearch_LeafPoolClear(a1);
            if (!(_DWORD)result)
            {
              a1[2] = 0;
              a1[4] = 0;
              a1[5] = 0;
              v3 = a1[10];
              if (v3)
                OOCAllocator_Free(a1[1], v3);
              return Object_Des();
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _DTSearch_ClearHypothesis(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t result;

  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    v4 = 0;
    while (1)
    {
      v5 = PtrList_ItemN(a2, v4);
      result = DTHypothesisPool_ReturnHypoID(*(_QWORD **)(a1 + 24), v5);
      if ((_DWORD)result)
        break;
      if (++v4 >= kaldi::MatrixBase<float>::Stride(a2))
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    PtrList_RemoveAll(a2);
    return 0;
  }
  return result;
}

uint64_t __DTSearch_LeafPoolClear(uint64_t *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v4;
  unint64_t v5;
  uint64_t result;

  v2 = a1 + 8;
  v1 = a1[8];
  if (!v1)
    return 0;
  if (a1[9])
  {
    v4 = 0;
    v5 = 0;
    while (1)
    {
      result = DTLeaf_Con((_QWORD *)(*v2 + v4), 0);
      if ((_DWORD)result)
        break;
      ++v5;
      v4 += 8;
      if (v5 >= a1[9])
      {
        v1 = *v2;
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    OOCAllocator_Free(a1[1], v1);
    result = 0;
    *v2 = 0;
    v2[1] = 0;
  }
  return result;
}

unint64_t DTSearch_BeamSearch(uint64_t a1, _BYTE *a2, size_t a3, _QWORD *a4)
{
  unint64_t result;
  int v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int *v33;
  uint64_t v34;
  char v35;
  unsigned int v36;

  v36 = 0;
  result = _DTSearch_LeafPoolResize((uint64_t *)a1, 1uLL);
  if ((_DWORD)result)
    return result;
  result = _DTSearch_ClearHypothesis(a1, *(_QWORD *)(a1 + 32));
  if ((_DWORD)result)
    return result;
  if (!a3)
  {
    v15 = 0;
    goto LABEL_19;
  }
  result = DTHypothesisPool_Resize(*(_QWORD *)(a1 + 24), a3);
  if ((_DWORD)result)
    return result;
  v9 = *(unsigned __int16 *)(a1 + 48);
  *(_WORD *)(a1 + 50) = v9;
  if (!v9)
    LOWORD(v9) = *(_WORD *)(a1 + 60);
  *(_WORD *)(a1 + 62) = v9;
  result = DTTree_Traverse(*(_QWORD *)(a1 + 16), 0, a2, a3, 0, 0, *(uint64_t **)(a1 + 64));
  if ((_DWORD)result)
    return result;
  if ((*(_BYTE *)(**(_QWORD **)(a1 + 64) + 1) & 2) != 0)
  {
LABEL_20:
    if (a3 >= 2)
    {
      v16 = 1;
      do
      {
        v18 = *(_QWORD *)(a1 + 32);
        v17 = *(_QWORD *)(a1 + 40);
        *(_QWORD *)(a1 + 32) = v17;
        *(_QWORD *)(a1 + 40) = v18;
        result = _DTSearch_ClearHypothesis(a1, v17);
        if ((_DWORD)result)
          return result;
        v19 = kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 40));
        result = _DTSearch_LeafPoolResize((uint64_t *)a1, v19);
        if ((_DWORD)result)
          return result;
        if (kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 40)))
        {
          v23 = 0;
          v24 = 0;
          do
          {
            v25 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 16)
                                 + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24)
                                 * PtrList_ItemN(*(_QWORD *)(a1 + 40), v24));
            result = DTTree_Traverse(*(_QWORD *)(a1 + 16), v16, a2, a3, (uint64_t)v25 + 6, *v25, (uint64_t *)(*(_QWORD *)(a1 + 64) + v23));
            if ((_DWORD)result)
              return result;
            ++v24;
            v23 += 8;
          }
          while (v24 < kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 40)));
        }
        if (*(_DWORD *)(a1 + 52))
          _DTSearch_GetHistogramPruningThreshold(a1, *(_QWORD *)(a1 + 40), v20, v21, v22, (_WORD *)(a1 + 50));
        if (kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 40)))
        {
          v26 = 0;
LABEL_32:
          v27 = 0;
          v28 = PtrList_ItemN(*(_QWORD *)(a1 + 40), v26);
          v29 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v26);
          while (1)
          {
            v30 = *(unsigned __int8 *)(v29 + v27);
            if (!_DTSearch_HypoWillBePruned(a1, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(v29 + v27)))
            {
              result = DTHypothesisPool_FetchHypoID(*(_QWORD *)(a1 + 24), &v36);
              if ((_DWORD)result)
                return result;
              v31 = *(_QWORD *)(a1 + 24);
              memcpy((void *)(*(_QWORD *)(v31 + 16) + *(_QWORD *)(v31 + 24) * v36), (const void *)(*(_QWORD *)(v31 + 16) + *(_QWORD *)(v31 + 24) * v28), *(_QWORD *)(v31 + 24));
              v32 = v36;
              v33 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 16)
                                   + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24) * v36);
              *((_WORD *)v33 + 2) += v30;
              if (*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v26) + v27 + 1) >= 4u)
              {
                v34 = *v33;
                *((_WORD *)v33 + v34 + 3) = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v26) + v27 + 1) >> 2;
                *v33 = v34 + 1;
                v32 = v36;
              }
              result = _DTSearch_AddHypothesis(a1, *(_QWORD *)(a1 + 32), v32);
              if ((_DWORD)result)
                return result;
            }
            v29 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v26);
            v35 = *(_BYTE *)(v29 + v27 + 1);
            v27 += 3;
            if ((v35 & 1) != 0)
            {
              if (++v26 < (unint64_t)kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 40)))
                goto LABEL_32;
              break;
            }
          }
        }
      }
      while (++v16 != a3);
    }
    result = _DTSearch_ClearHypothesis(a1, *(_QWORD *)(a1 + 40));
    if ((_DWORD)result)
      return result;
    PtrList_UdSort(*(_QWORD *)(a1 + 32), (uint64_t (*)(char *, char *, uint64_t))__DTSearch_HypoCompare, *(_QWORD *)(a1 + 24));
    v15 = kaldi::MatrixBase<float>::Stride(*(_QWORD *)(a1 + 32));
LABEL_19:
    result = 0;
    *a4 = v15;
    return result;
  }
  result = DTHypothesisPool_FetchHypoID(*(_QWORD *)(a1 + 24), &v36);
  if (!(_DWORD)result)
  {
    v10 = 0;
    do
    {
      v11 = (unsigned __int8 *)(**(_QWORD **)(a1 + 64) + v10);
      v12 = v36;
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24) * v36;
      *(_WORD *)(v13 + 4) = *v11;
      v14 = *(unsigned __int16 *)(v11 + 1);
      if (v14 >= 4)
      {
        *(_WORD *)(v13 + 6) = v14 >> 2;
        *(_DWORD *)v13 = 1;
        v12 = v36;
      }
      result = _DTSearch_AddHypothesis(a1, *(_QWORD *)(a1 + 32), v12);
      if ((_DWORD)result)
        break;
      if ((*(_BYTE *)(**(_QWORD **)(a1 + 64) + v10 + 1) & 1) != 0)
        goto LABEL_20;
      result = DTHypothesisPool_FetchHypoID(*(_QWORD *)(a1 + 24), &v36);
      v10 += 3;
    }
    while (!(_DWORD)result);
  }
  return result;
}

uint64_t _DTSearch_LeafPoolResize(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;

  result = 0;
  v8 = 0;
  if (a1[9] < a2)
  {
    a1[8] = OOCAllocator_Realloc(a1[1], a1[8], 8 * a2, &v8);
    result = v8;
    if (!v8)
    {
      v5 = a1[9];
      v6 = a2 - v5;
      if (a2 <= v5)
      {
LABEL_7:
        result = 0;
        a1[9] = a2;
      }
      else
      {
        v7 = 8 * v5;
        while (1)
        {
          result = DTLeaf_Con((_QWORD *)(a1[8] + v7), 0);
          v8 = result;
          if ((_DWORD)result)
            break;
          v7 += 8;
          if (!--v6)
            goto LABEL_7;
        }
      }
    }
  }
  return result;
}

uint64_t _DTSearch_AddHypothesis(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  unsigned int v11;
  uint64_t v13;
  uint64_t v14;

  if (!kaldi::MatrixBase<float>::Stride(a2))
  {
    v13 = a3;
    v14 = a2;
    return PtrList_Prepend(v14, v13);
  }
  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(_QWORD *)(v6 + 16);
  v8 = *(unsigned __int16 *)(v7 + *(_QWORD *)(v6 + 24) * a3 + 4);
  v9 = PtrList_ItemN(a2, 0);
  v10 = *(_QWORD **)(a1 + 24);
  if (v8 == 0xFFFF)
    return DTHypothesisPool_ReturnHypoID(v10, a3);
  v11 = *(unsigned __int16 *)(v7 + v9 * v10[3] + 4);
  if (*(_WORD *)(a1 + 50))
  {
    if (*(unsigned __int16 *)(a1 + 50) + v11 < v8)
      return DTHypothesisPool_ReturnHypoID(v10, a3);
  }
  v14 = a2;
  v13 = a3;
  if (v8 < v11)
    return PtrList_Prepend(v14, v13);
  return PtrList_Append(a2, a3);
}

uint64_t _DTSearch_GetHistogramPruningThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _WORD *a6)
{
  char *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char *v13;
  char v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  unsigned __int8 **v23;
  unsigned __int8 *v24;
  char *v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  char v29;
  unint64_t v30;
  unsigned int v31;

  v9 = *(char **)(a1 + 80);
  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v10);
      v14 = *(_BYTE *)(v12 + 1);
      v13 = (char *)(v12 + 1);
      if ((v14 & 2) == 0)
      {
        do
        {
          ++v11;
          v15 = *v13;
          v13 += 3;
        }
        while ((v15 & 1) == 0);
      }
      ++v10;
    }
    while (v10 < kaldi::MatrixBase<float>::Stride(a2));
  }
  else
  {
    v11 = 0;
  }
  v16 = *(unsigned int *)(a1 + 56);
  if (v11 < *(_DWORD *)(a1 + 52))
  {
    LOWORD(v17) = 0;
    v18 = 0;
    v19 = 0;
    LODWORD(v20) = *(_DWORD *)(a1 + 56);
LABEL_31:
    if ((_DWORD)v20)
      v17 = v16 * (unint64_t)*(unsigned __int16 *)(a1 + 62) / v20;
    goto LABEL_33;
  }
  bzero(v9, 4 * v16);
  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    v21 = 0;
    v19 = 0;
    v18 = 0;
    LOWORD(v17) = 0;
    while (1)
    {
      v22 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 16)
                     + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24) * PtrList_ItemN(a2, v21)
                     + 4);
      v23 = *(unsigned __int8 ***)(a1 + 64);
      if (!v21)
      {
        v18 = v22 + **v23;
        v19 = v18;
      }
      v24 = v23[v21];
      if ((v24[1] & 2) == 0)
        break;
LABEL_23:
      if (++v21 >= (unint64_t)kaldi::MatrixBase<float>::Stride(a2))
        goto LABEL_26;
    }
    v25 = (char *)(v24 + 1);
    while (1)
    {
      LOWORD(v17) = v22 + *(v25 - 1);
      v26 = v9;
      if ((unsigned __int16)v17 < v18)
        goto LABEL_19;
      v27 = *(_DWORD *)(a1 + 56);
      v28 = v27 * ((unsigned __int16)v17 - v18) / *(unsigned __int16 *)(a1 + 62);
      if (v28 < v27)
        break;
LABEL_20:
      if ((unsigned __int16)v17 < v19)
        v19 = v17;
      v29 = *v25;
      v25 += 3;
      if ((v29 & 1) != 0)
        goto LABEL_23;
    }
    v26 = &v9[4 * v28];
LABEL_19:
    ++*(_DWORD *)v26;
    goto LABEL_20;
  }
  LOWORD(v17) = 0;
  v18 = 0;
  v19 = 0;
LABEL_26:
  v20 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v20)
  {
    v30 = 0;
    v16 = 0;
    while (v30 < *(unsigned int *)(a1 + 52))
    {
      v30 += *(unsigned int *)&v9[4 * v16++];
      if (v20 == v16)
      {
        v16 = *(unsigned int *)(a1 + 56);
        goto LABEL_31;
      }
    }
    goto LABEL_31;
  }
LABEL_33:
  *a6 = v17 - v19 + v18;
  if (*(_WORD *)(a1 + 48))
  {
    v31 = (unsigned __int16)(v17 - v19 + v18);
    if (v31 >= *(unsigned __int16 *)(a1 + 48))
      LOWORD(v31) = *(_WORD *)(a1 + 48);
    *a6 = v31;
  }
  return 0;
}

uint64_t _DTSearch_HypoWillBePruned(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  unsigned int v7;

  result = kaldi::MatrixBase<float>::Stride(a2);
  if ((_DWORD)result)
  {
    v7 = PtrList_ItemN(a2, 0);
    return *(_WORD *)(a1 + 50)
        && *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 16)
                               + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24) * v7
                               + 4)
         + *(unsigned __int16 *)(a1 + 50) < a3;
  }
  return result;
}

uint64_t __DTSearch_HypoCompare(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  return DTHypothesisPool_Compare(a3, a1, a2);
}

uint64_t DTSearch_SetHistogramBins(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  v3 = 0;
  *(_DWORD *)(a1 + 56) = a2;
  if (!a2)
    return 0;
  *(_QWORD *)(a1 + 80) = OOCAllocator_Realloc(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 80), 4 * a2, &v3);
  return v3;
}

uint64_t DTSearch_SetHistogramDiff(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 60) = a2;
  return result;
}

uint64_t DTSearch_SetHistogramPruning(uint64_t result, int a2)
{
  *(_DWORD *)(result + 52) = a2;
  return result;
}

uint64_t DTSearch_SetPruning(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 48) = a2;
  return result;
}

uint64_t PNEW_DTSearch_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 88, &v10);
  result = v10;
  if (!v10)
  {
    result = DTSearch_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

BOOL DTQuestionSP_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  int v7;
  _BOOL8 result;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(char *)(v6 + 1);
  result = 0;
  if (v7 + a6 >= 0 && a5 && v7 < 0)
    return *(unsigned __int16 *)(a5 + 2 * (v7 + a6)) == *(unsigned __int16 *)(v6 + 2);
  return result;
}

uint64_t PNEW_DTQuestionSP_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionSP;
      *a3 = v6;
    }
  }
  return result;
}

BOOL DTQuestionTG_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned __int8 *)(a3 + a2) == *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 2);
}

uint64_t PNEW_DTQuestionTG_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionTG;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t DTGraphemeParser_Des(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    OOCAllocator_Free(*(_QWORD *)(a1 + 8), v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  return Object_Des();
}

uint64_t DTGraphemeParser_Parse(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  size_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  unsigned int v11;
  unsigned int GraphemeID;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  unsigned int v18;

  v18 = 0;
  v4 = strlen(__s);
  if (v4)
  {
    v5 = v4;
    v6 = a1[4];
    if (v4 >= v6)
    {
      v7 = (void *)OOCAllocator_Realloc(a1[1], a1[3], v4, &v18);
      a1[3] = v7;
      v9 = v18;
      if (v18)
        return v9;
      a1[4] = v5;
      v6 = v5;
    }
    else
    {
      v7 = (void *)a1[3];
    }
    a1[5] = 0;
    bzero(v7, v6);
    v10 = 0;
    v11 = *(unsigned __int16 *)(*(_QWORD *)(a1[2] + 16) + 4);
    while (1)
    {
      GraphemeID = DTGraphemeBuffer_FirstGraphemeID(a1[2], (uint64_t)&__s[v10]);
      if (v11 <= GraphemeID)
        break;
      v13 = GraphemeID;
      v14 = *(_QWORD *)(a1[2] + 24);
      while (1)
      {
        v15 = v14 + 8 * v13;
        v16 = *(_QWORD *)(v15 + 8) + ~*(_QWORD *)v15;
        if (!strncmp(*(const char **)v15, &__s[v10], v16))
          break;
        if (v11 <= ++v13)
          goto LABEL_17;
      }
      *(_BYTE *)(a1[3] + a1[5]++) = v13;
      v10 += v16;
      if (v10 >= v5)
        return v18;
    }
LABEL_17:
    a1[5] = 0;
    bzero((void *)a1[3], a1[4]);
    return 4;
  }
  else
  {
    a1[5] = 0;
    v8 = (void *)a1[3];
    if (v8)
      bzero(v8, a1[4]);
    return 0;
  }
}

uint64_t PNEW_DTGraphemeParser_Con(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t result;
  uint64_t v10;
  unsigned int v11;

  v11 = 0;
  v8 = (_QWORD *)OOCAllocator_Malloc(a1, 48, &v11);
  result = v11;
  if (!v11)
  {
    result = Object_Con(v8);
    if ((_DWORD)result)
    {
      v11 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v11;
    }
    else
    {
      *v8 = &__DTGraphemeParser;
      v8[1] = a2;
      v10 = *(_QWORD *)(a3 + 56);
      v8[4] = 0;
      v8[5] = 0;
      v8[2] = v10;
      v8[3] = 0;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTQuestionPPBin_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t result;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(char *)(v6 + 1);
  v8 = v7 + a6;
  if (v7 + a6 < 0)
    return 0;
  result = 0;
  if (a5 && v7 < 0)
  {
    v10 = *(unsigned __int8 *)(v6 + 2);
    if (*(_BYTE *)(v6 + 2))
    {
      v11 = 0;
      v12 = *(unsigned __int16 *)(a5 + 2 * v8);
      v13 = v6 + 3;
      v14 = v10 - 1;
      while (1)
      {
        v15 = (v14 + v11) >> 1;
        v16 = *(unsigned __int16 *)(v13 + 2 * v15);
        if (v12 >= v16)
        {
          if (v12 <= v16)
            return 1;
          v11 = v15 + 1;
        }
        else
        {
          v14 = v15 - 1;
        }
        if (v11 > v14)
          return 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t PNEW_DTQuestionPPBin_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionPPBin;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t DTLeaf_Con(_QWORD *a1, uint64_t a2)
{
  *a1 = a2;
  return 0;
}

double LexDT_Con(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  double result;
  int v10;

  if (!_LexChain_Con((_QWORD *)a1, a2, a3))
  {
    *(_QWORD *)a1 = &__LexDT;
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 80) = 0;
    if (a4)
    {
      *(_QWORD *)(a1 + 72) = a4;
      *(_QWORD *)(a1 + 80) = a5;
      if (!PNEW_DTTree_Con(a2, a2, a4, (uint64_t **)(a1 + 56))
        && !PNEW_DTGraphemeParser_Con(a2, a2, *(_QWORD *)(a1 + 56), (_QWORD *)(a1 + 32))
        && !PNEW_DTSearch_Con(a2, a2, *(_QWORD *)(a1 + 56), (uint64_t *)(a1 + 40)))
      {
        PNEW_DTPostProcessor_Con(a2, a2, *(_QWORD *)(a1 + 56), (uint64_t *)(a1 + 48));
        if (!v10)
          *(_DWORD *)(a1 + 64) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 72) + 24);
      }
    }
    else
    {
      result = 0.0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
    }
  }
  return result;
}

uint64_t LexDT_Des(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = a1[2];
  v3 = a1[6];
  if (!v3 || (result = OOC_PlacementDeleteObject(a1[2], v3), !(_DWORD)result))
  {
    v5 = a1[5];
    if (!v5 || (result = OOC_PlacementDeleteObject(v2, v5), !(_DWORD)result))
    {
      v6 = a1[4];
      if (!v6 || (result = OOC_PlacementDeleteObject(v2, v6), !(_DWORD)result))
      {
        v7 = a1[7];
        if (!v7 || (result = OOC_PlacementDeleteObject(v2, v7), !(_DWORD)result))
        {
          v8 = a1[10];
          if (v8)
            OOCAllocator_Free(v8, a1[9]);
          return LexChain_Des((uint64_t)a1);
        }
      }
    }
  }
  return result;
}

uint64_t LexDT_GetParamList(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;

  if (!a3)
    return 0;
  result = 0;
  v5 = a3;
  v6 = (_DWORD *)(a2 + 4);
  do
  {
    switch(*(v6 - 1))
    {
      case 0:
        v7 = *(_DWORD *)(a1 + 64);
        goto LABEL_15;
      case 1:
        v7 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 40) + 48);
        goto LABEL_15;
      case 2:
        v7 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 52);
        goto LABEL_15;
      case 3:
        v8 = *(_QWORD *)(a1 + 40);
        goto LABEL_13;
      case 4:
        v7 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 40) + 60);
        goto LABEL_15;
      case 5:
        v7 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 88);
        goto LABEL_15;
      case 6:
        v7 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 92);
        goto LABEL_15;
      case 7:
        v8 = *(_QWORD *)(a1 + 48);
LABEL_13:
        v7 = *(_DWORD *)(v8 + 56);
        goto LABEL_15;
      case 8:
        v7 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 60);
LABEL_15:
        *v6 = v7;
        break;
      default:
        result = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Param list contains parameter with invalid ID");
        break;
    }
    v6 += 2;
    --v5;
  }
  while (v5);
  return result;
}

uint64_t LexDT_HasParam(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = 0;
  while (dword_1DEC6503C[v2] != a2)
  {
    if (++v2 == 9)
      return 0;
  }
  return 1;
}

uint64_t LexDT_SetParamList(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;

  if (!a3)
    return 0;
  v4 = 0;
  v5 = a3;
  v6 = (__int16 *)(a2 + 4);
  do
  {
    switch(*((_DWORD *)v6 - 1))
    {
      case 0:
        *(_DWORD *)(a1 + 64) = *(_DWORD *)v6;
        break;
      case 1:
        DTSearch_SetPruning(*(_QWORD *)(a1 + 40), *v6);
        break;
      case 2:
        DTSearch_SetHistogramPruning(*(_QWORD *)(a1 + 40), *(_DWORD *)v6);
        break;
      case 3:
        v7 = DTSearch_SetHistogramBins(*(_QWORD *)(a1 + 40), *(_DWORD *)v6);
        goto LABEL_9;
      case 4:
        DTSearch_SetHistogramDiff(*(_QWORD *)(a1 + 40), *v6);
        break;
      case 5:
        *(_DWORD *)(*(_QWORD *)(a1 + 48) + 88) = *(_DWORD *)v6;
        break;
      case 6:
        *(_DWORD *)(*(_QWORD *)(a1 + 48) + 92) = *(_DWORD *)v6;
        break;
      case 7:
        *(_DWORD *)(*(_QWORD *)(a1 + 48) + 56) = *(_DWORD *)v6;
        break;
      case 8:
        *(_DWORD *)(*(_QWORD *)(a1 + 48) + 60) = *(_DWORD *)v6;
        break;
      default:
        v7 = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Param list contains parameter with invalid ID");
LABEL_9:
        v4 = v7;
        break;
    }
    v6 += 4;
    --v5;
  }
  while (v5);
  return v4;
}

BOOL _LexDT_AcceptWordType(uint64_t a1, int a2)
{
  return a2 == 4;
}

unint64_t _LexDT_FindWord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t result;
  uint64_t v7;
  size_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  _BYTE *v13;
  unsigned int TranscriptionSize;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v5 = *(_QWORD *)(a1 + 16);
  result = DTGraphemeParser_Parse(*(_QWORD **)(a1 + 32), *(char **)(a2 + 8));
  if (!(_DWORD)result)
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(unsigned int *)(v7 + 40);
    if (!*(_DWORD *)(v7 + 40))
      return 0;
    v9 = *(_BYTE **)(v7 + 24);
    v17 = 0;
    result = DTSearch_BeamSearch(*(_QWORD *)(a1 + 40), v9, v8, &v17);
    if ((_DWORD)result)
      return result;
    result = DTPostProcessor_CreateNBest(*(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), *(_DWORD *)(a1 + 64));
    if ((_DWORD)result)
      return result;
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40);
    if (!v10)
      return 0;
    for (i = 0; i != v10; ++i)
    {
      v16 = 0;
      v12 = *(_QWORD *)(a1 + 48);
      v13 = *(_BYTE **)(*(_QWORD *)(v12 + 32) + 8 * i);
      TranscriptionSize = DTPostProcessor_GetTranscriptionSize(v12, i);
      result = PNEW_Transcription_Con(v5, v5, v13, TranscriptionSize, 1, 1, &v16);
      if ((_DWORD)result)
        break;
      v15 = v16;
      *(_DWORD *)(v16 + 28) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 48) + 4 * i);
      result = PtrQueue_Put(a3, v15);
      if ((_DWORD)result)
        break;
    }
  }
  return result;
}

void PNEW_LexDT_Con(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  int v13;
  int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 88, &v14);
  if (!v14)
  {
    LexDT_Con(v12, a2, a3, a4, a5);
    v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
    }
    else
    {
      *a6 = v12;
    }
  }
}

uint64_t DTLeafBuffer_GetPLeaf(_QWORD *a1, unsigned int a2)
{
  return *a1 + a2 + 4;
}

uint64_t DTQuestionWB_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v4;
  unsigned int v5;
  uint64_t result;

  v4 = *(char *)(*(_QWORD *)(a1 + 8) + 1);
  v5 = v4 + a2;
  if (v4 < 0)
  {
    if ((int)v5 < a4)
    {
      if ((v5 & 0x80000000) != 0)
        return 1;
      if (!*(_BYTE *)(a3 + v5))
      {
        result = 1;
        if (v5 == a4 - 1)
          return result;
        return *(unsigned __int8 *)(a3 + v5 + result) != 0;
      }
    }
    return 0;
  }
  if ((v5 & 0x80000000) != 0)
    return 0;
  if ((int)v5 >= a4)
    return 1;
  if (*(_BYTE *)(a3 + v5))
    return 0;
  if (!v5)
    return 1;
  LODWORD(result) = -1;
  return *(unsigned __int8 *)(a3 + v5 + result) != 0;
}

uint64_t PNEW_DTQuestionWB_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 16, &v8);
  result = v8;
  if (!v8)
  {
    result = _DTQuestion_Con(v6, a2);
    if ((_DWORD)result)
    {
      v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *v6 = &__DTQuestionWB;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _LexChain_Con(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    *a1 = &__LexChain;
    a1[1] = a3;
    a1[2] = a2;
    a1[3] = 0;
  }
  return result;
}

uint64_t LexChain_Des(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    result = OOC_PlacementDeleteObject(*(_QWORD *)(a1 + 16), v2);
    if ((_DWORD)result)
      return result;
    *(_QWORD *)(a1 + 24) = 0;
  }
  return Object_Des();
}

uint64_t LexChain_AddPostProcessor(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t result;

  v5 = (uint64_t *)(a1 + 24);
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    return PtrList_Append(v4, a2);
  result = PNEW_PtrList_Con(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 16), 8u, 8, v5);
  if (!(_DWORD)result)
  {
    v4 = *v5;
    return PtrList_Append(v4, a2);
  }
  return result;
}

uint64_t LexChain_FetchTranscription(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  _OWORD v16[2];

  if ((*(unsigned int (**)(_QWORD *, _QWORD))(*a1 + 72))(a1, *(unsigned int *)(a2 + 20)))
  {
    memset(v16, 0, sizeof(v16));
    result = PtrQueue_Con((uint64_t)v16, a1[2], 5u, 5);
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(_QWORD *, uint64_t, _OWORD *))(*a1 + 64))(a1, a2, v16);
      if (!(_DWORD)result)
      {
        if (PtrQueue_IsEmpty((uint64_t)v16))
        {
          v9 = a1[1];
          if (v9)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 24))(v9, a2, a3, a4);
            if ((_DWORD)result)
              return result;
          }
        }
        else
        {
          while (!PtrQueue_IsEmpty((uint64_t)v16))
          {
            v10 = PtrQueue_Item((uint64_t)v16);
            v11 = v10;
            if ((_DWORD)a3 && (*(_DWORD *)(v10 + 20) & a3) == 0)
            {
              v12 = a1[1];
              if (v12)
              {
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 24))(v12, v11, a3, a4);
                if ((_DWORD)result)
                  return result;
              }
              result = PDELETE_Transcription(a1[2], v11);
              if ((_DWORD)result)
                return result;
            }
            else
            {
              result = PtrQueue_Put(a4, v10);
              if ((_DWORD)result)
                return result;
            }
            result = PtrQueue_Remove((uint64_t)v16);
            if ((_DWORD)result)
              return result;
          }
        }
        v13 = a1[3];
        if (v13 && kaldi::MatrixBase<float>::Stride(v13))
        {
          v14 = 0;
          while (1)
          {
            v15 = PtrList_ItemN(a1[3], v14);
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15 + 80))(v15, a2, a3, a4);
            if ((_DWORD)result)
              break;
            if (++v14 >= kaldi::MatrixBase<float>::Stride(a1[3]))
              return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)&v16[0] + 16))(v16);
          }
        }
        else
        {
          return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)&v16[0] + 16))(v16);
        }
      }
    }
  }
  else
  {
    result = a1[1];
    if (result)
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 24))(result, a2, a3, a4);
  }
  return result;
}

uint64_t LexChain_GetParamList()
{
  return err_GenerateErrorNotSupported();
}

uint64_t LexChain_HasParam()
{
  return 0;
}

uint64_t LexChain_SetParamList()
{
  return err_GenerateErrorNotSupported();
}

uint64_t _LexChain_PostProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[2];

  memset(v13, 0, sizeof(v13));
  v7 = PtrQueue_NrItems(a4);
  result = PtrQueue_Con((uint64_t)v13, a1[2], 5u, 5);
  if (!(_DWORD)result)
  {
    if (v7)
    {
      v9 = 0;
      while (1)
      {
        v10 = PtrQueue_Item(a4);
        result = PtrQueue_Remove(a4);
        if ((_DWORD)result)
          break;
        if ((*(unsigned int (**)(uint64_t *, _QWORD))(*a1 + 72))(a1, *(unsigned int *)(v10 + 20)))
        {
          result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _OWORD *))(*a1 + 24))(a1, v10, a3, v13);
          if ((_DWORD)result)
            return result;
          while (!PtrQueue_IsEmpty((uint64_t)v13))
          {
            v11 = PtrQueue_Item((uint64_t)v13);
            result = PtrQueue_Put(a4, v11);
            if (!(_DWORD)result)
            {
              result = PtrQueue_Remove((uint64_t)v13);
              if (!(_DWORD)result)
                continue;
            }
            return result;
          }
          result = PDELETE_Transcription(a1[2], v10);
          if ((_DWORD)result)
            return result;
        }
        else
        {
          result = PtrQueue_Put(a4, v10);
          if ((_DWORD)result)
            return result;
          while (!PtrQueue_IsEmpty((uint64_t)v13))
          {
            v12 = PtrQueue_Item((uint64_t)v13);
            result = PDELETE_Transcription(a1[2], v12);
            if (!(_DWORD)result)
            {
              result = PtrQueue_Remove((uint64_t)v13);
              if (!(_DWORD)result)
                continue;
            }
            return result;
          }
        }
        if (++v9 == v7)
          return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)&v13[0] + 16))(v13);
      }
    }
    else
    {
      return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)&v13[0] + 16))(v13);
    }
  }
  return result;
}

void *GetLexChainClass()
{
  return &__LexChain;
}

uint64_t Transcription_Con(uint64_t a1, uint64_t a2, _BYTE *a3, unsigned int a4, int a5, int a6)
{
  unsigned int v12;
  void *v13;
  uint64_t v14;
  unsigned int v16;

  v16 = 0;
  if (a5 == 1)
  {
    if (a3[a4 - 1])
      v12 = a4 + 1;
    else
      v12 = a4;
  }
  else
  {
    v12 = a4;
    if (a5 == 4)
    {
      if (!a4 || (v12 = a4, a3[a4 - 1]))
        v12 = a4 + 1;
    }
  }
  v13 = (void *)OOCAllocator_Calloc(a2, 1, v12, &v16);
  *(_QWORD *)(a1 + 8) = v13;
  v14 = v16;
  if (!v16)
  {
    memcpy(v13, a3, a4);
    *(_DWORD *)(a1 + 16) = v12;
    *(_DWORD *)(a1 + 20) = a5;
    *(_DWORD *)(a1 + 24) = a6;
    *(_DWORD *)(a1 + 28) = 0;
    *(_QWORD *)a1 = a2;
    return v16;
  }
  return v14;
}

uint64_t Transcription_Des(uint64_t a1)
{
  if (*(int *)(a1 + 16) >= 1)
    OOCAllocator_Free(*(_QWORD *)a1, *(_QWORD *)(a1 + 8));
  return 0;
}

uint64_t PNEW_Transcription_Con(uint64_t a1, uint64_t a2, _BYTE *a3, unsigned int a4, int a5, int a6, uint64_t *a7)
{
  uint64_t v14;
  uint64_t result;
  unsigned int v16;

  v16 = 0;
  v14 = OOCAllocator_Malloc(a1, 32, &v16);
  result = v16;
  if (!v16)
  {
    result = Transcription_Con(v14, a2, a3, a4, a5, a6);
    v16 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
      return v16;
    }
    else
    {
      *a7 = v14;
    }
  }
  return result;
}

uint64_t PDELETE_Transcription(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 16) >= 1)
    OOCAllocator_Free(*(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  OOCAllocator_Free(a1, a2);
  return 0;
}

uint64_t StringTokenizer_Con(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v5;

  result = Object_Con(a1);
  v5 = result;
  if (!(_DWORD)result)
  {
    *a1 = &__StringTokenizer;
    a1[1] = a2;
    a1[3] = 50;
    a1[5] = 50;
    a1[2] = OOCAllocator_Malloc(a2, 50, &v5);
    result = v5;
    if (!v5)
    {
      a1[4] = OOCAllocator_Malloc(a1[1], a1[5], &v5);
      result = v5;
      if (!v5)
        a1[6] = 0;
    }
  }
  return result;
}

uint64_t StringTokenizer_Des(uint64_t *a1)
{
  OOCAllocator_Free(a1[1], a1[2]);
  OOCAllocator_Free(a1[1], a1[4]);
  return Object_Des();
}

uint64_t StringTokenizer_ExpandPhoneticMultiples(uint64_t a1, uint64_t a2, char *a3, uint64_t *a4, _QWORD *a5)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  unsigned int v16;

  v15 = 0;
  v16 = 0;
  *a4 = 0;
  v8 = __StringTokenizer_ExpandMultiple(a2, a3, &v15, &v16);
  if (!(_DWORD)v8)
  {
    v9 = v16;
    v10 = v15;
    if (v16 >= 0x11)
    {
      v11 = (uint64_t *)(v15 + 128);
      v12 = v16 - 16;
      do
      {
        v13 = *v11++;
        OOCAllocator_Free(a2, v13);
        --v12;
      }
      while (v12);
      v9 = 16;
    }
    *a4 = v10;
    *a5 = v9;
  }
  return v8;
}

uint64_t __StringTokenizer_ExpandMultiple(uint64_t a1, char *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  size_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *i;
  char *v17;
  char *v18;
  char *j;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *k;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  unsigned int v33;
  const char *v34;
  char *v35;
  char *v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  int64_t v41;
  char *v42;
  int v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *m;
  char *v51;
  char *v52;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t n;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  char *v78;
  uint64_t v79;
  const char *v81;
  unsigned int v82;
  uint64_t v83;
  char *__src;
  size_t __n;
  int v86;
  int v87;
  unsigned int v88;
  uint64_t *v89;
  char *v90;
  int v91;
  char *__dst;
  uint64_t v93;
  unsigned int v96;
  uint64_t *v97;
  unsigned int v98;

  v4 = a3;
  v5 = a2;
  v98 = 0;
  *a4 = 0;
  *a3 = 0;
  v6 = strchr(a2, 40);
  if (v6)
  {
    v7 = v6;
    v8 = v6 + 1;
    v9 = strchr(v6 + 2, 37);
    v10 = strchr(v8, 41);
    if (v10)
    {
      v11 = v10;
      while (*(v11 - 1) == 37)
      {
        v11 = strchr(v11 + 1, 41);
        if (!v11)
          return v98;
      }
      if (!v9 || v9 >= v11)
        goto LABEL_24;
      do
      {
        v13 = v9 + 1;
        if (v9[1] == 34)
        {
          v14 = strchr(v9 + 2, 34);
          if (!v14)
            return v98;
          v15 = v14;
          if (v14 > v11)
          {
            for (i = v14 + 1; ; i = v17 + 1)
            {
              v17 = strchr(i, 41);
              v11 = v17;
              if (!v17 || *(v17 - 1) != 37)
                break;
            }
          }
          v13 = v15 + 1;
        }
        v18 = strchr(v13, 37);
        if (!v18)
          break;
        v9 = v18;
      }
      while (v18 < v11);
      if (v11)
      {
LABEL_24:
        for (j = v8; ; j = v21)
        {
          v20 = strchr(j, 40);
          if (!v20 || v20 >= v11)
            break;
          v21 = v20 + 1;
          v22 = strchr(v20 + 1, 37);
          v23 = strchr(v11 + 1, 41);
          if (!v23)
            return v98;
          v11 = v23;
          while (*(v11 - 1) == 37)
          {
            v11 = strchr(v11 + 1, 41);
            if (!v11)
              return v98;
          }
          if (v22 && v22 < v11)
          {
            do
            {
              v24 = v22 + 1;
              if (v22[1] == 34)
              {
                v25 = strchr(v22 + 2, 34);
                if (!v25)
                  return v98;
                v26 = v25;
                if (v25 > v11)
                {
                  for (k = v25 + 1; ; k = v28 + 1)
                  {
                    v28 = strchr(k, 41);
                    v11 = v28;
                    if (!v28 || *(v28 - 1) != 37)
                      break;
                  }
                }
                v24 = v26 + 1;
              }
              v29 = strchr(v24, 37);
              if (!v29)
                break;
              v22 = v29;
            }
            while (v29 < v11);
            if (!v11)
              return v98;
          }
        }
        v91 = strlen(v11);
        __dst = (char *)OOCAllocator_Malloc(a1, v11 - v7, &v98);
        if (!v98)
        {
          v30 = strncpy(__dst, v8, v11 - v7 - 1);
          __dst[v11 - v7 - 1] = 0;
          LODWORD(v97) = 0;
          v31 = strchr(v30, 124);
          if (!v31)
          {
            v83 = 0;
            v82 = 1;
            v81 = __dst;
            goto LABEL_124;
          }
          v32 = v31;
          v93 = 0;
          v33 = 0;
          v34 = __dst;
          v35 = __dst;
          v89 = v4;
          v90 = v5;
          do
          {
            v36 = strchr(v35, 40);
            if (!v36 || v32 <= v36)
              goto LABEL_55;
            v37 = 1;
            do
            {
              v36 = strchr(v36 + 1, 40);
              --v37;
            }
            while (v36 && v32 > v36);
            if (v37 == 1)
              goto LABEL_55;
            v43 = 0;
            v87 = -v37;
            do
            {
              v44 = v35 + 1;
              v45 = strchr(v44, 37);
              v46 = strchr(v44, 41);
              if (!v46)
                goto LABEL_83;
              v35 = v46;
              while (*(v35 - 1) == 37)
              {
                v35 = strchr(v35 + 1, 41);
                if (!v35)
                  goto LABEL_83;
              }
              if (v45 && v45 < v35)
              {
                do
                {
                  v47 = v45 + 1;
                  if (v45[1] == 34)
                  {
                    v48 = strchr(v45 + 2, 34);
                    if (!v48)
                      goto LABEL_83;
                    v49 = v48;
                    if (v48 > v35)
                    {
                      for (m = v48 + 1; ; m = v51 + 1)
                      {
                        v51 = strchr(m, 41);
                        v35 = v51;
                        if (!v51 || *(v51 - 1) != 37)
                          break;
                      }
                    }
                    v47 = v49 + 1;
                  }
                  v52 = strchr(v47, 37);
                  if (!v52)
                    break;
                  v45 = v52;
                }
                while (v52 < v35);
                if (!v35)
                {
LABEL_83:
                  v88 = 0;
                  goto LABEL_84;
                }
              }
            }
            while (v87 != v43++);
            if (v32 > v35)
            {
LABEL_55:
              v38 = OOCAllocator_Realloc(a1, v93, 8 * (v33 + 1), &v97);
              v39 = v97;
              if (!(_DWORD)v97)
              {
                v40 = v38;
                v41 = v32 - v34;
                v42 = (char *)OOCAllocator_Malloc(a1, v32 - v34 + 2, &v97);
                *(_QWORD *)(v40 + 8 * v33) = v42;
                v39 = v97;
                if (!(_DWORD)v97)
                {
                  strncpy(v42, v34, v32 - v34);
                  *(_BYTE *)(*(_QWORD *)(v40 + 8 * v33) + v41) = 0;
                  v93 = v40;
                  v4 = v89;
                  v5 = v90;
                  *(_BYTE *)(v41 + *(_QWORD *)(v40 + 8 * v33) + 1) = 0;
                  v35 = v32 + 1;
                  ++v33;
                  v34 = v32 + 1;
                  goto LABEL_58;
                }
              }
              return v39;
            }
            ++v35;
LABEL_58:
            v32 = strchr(v35, 124);
          }
          while (v32);
          v81 = v34;
          v82 = v33 + 1;
          v83 = v93;
LABEL_124:
          v75 = OOCAllocator_Realloc(a1, v83, 8 * v82, &v97);
          v39 = v97;
          if ((_DWORD)v97)
            return v39;
          v76 = v75;
          v77 = strlen(v81);
          v78 = (char *)OOCAllocator_Malloc(a1, (v77 + 2), &v97);
          v79 = v82 - 1;
          *(_QWORD *)(v76 + 8 * v79) = v78;
          v39 = v97;
          if ((_DWORD)v97)
            return v39;
          v88 = v82;
          strcpy(v78, v81);
          v93 = v76;
          *(_BYTE *)(*(_QWORD *)(v76 + 8 * v79) + (v77 + 1)) = 0;
LABEL_84:
          v98 = v97;
          if (!(_DWORD)v97)
          {
            *v4 = OOCAllocator_Malloc(a1, 8 * v88, &v98);
            if (!v98)
            {
              v54 = v88;
              *a4 = v88;
              if (v88)
              {
                v55 = 0;
                v56 = 0;
                v86 = (_DWORD)v7 - (_DWORD)v5;
                __src = v11 + 1;
                __n = ((_DWORD)v7 - (_DWORD)v5);
                while (1)
                {
                  v57 = strlen(*(const char **)(v93 + 8 * v55));
                  v58 = (char *)OOCAllocator_Malloc(a1, (v91 + 1 + v57 + v86), &v98);
                  if (v98)
                    return v98;
                  v59 = v58;
                  v60 = strncpy(v58, v5, __n);
                  v61 = strcpy(&v60[__n], *(const char **)(v93 + 8 * v55));
                  strcpy(&v61[v57], __src);
                  v59[v57 + v86 + v91] = 0;
                  if (strchr(v59, 40))
                    break;
                  *(_QWORD *)(*v4 + 8 * v56++) = v59;
LABEL_115:
                  if (++v55 == v54)
                    goto LABEL_116;
                }
                v62 = v54;
                v97 = 0;
                v96 = 0;
                v98 = __StringTokenizer_ExpandMultiple(a1, v59, &v97, &v96);
                if (v98)
                  return v98;
                v63 = v96;
                v64 = *a4 + v96 - 1;
                if (v64 > 0x10)
                {
                  if (*a4 < 0x10)
                  {
                    *v4 = OOCAllocator_Realloc(a1, *v4, 128, &v98);
                    if (v98)
                      return v98;
                    v65 = (uint64_t)v97;
                    if ((_DWORD)v63)
                    {
                      v71 = v97;
                      do
                      {
                        v72 = *v71;
                        if (v56 > 0xF)
                        {
                          if (v72)
                          {
                            OOCAllocator_Free(a1, v72);
                            *v71 = 0;
                          }
                        }
                        else
                        {
                          *(_QWORD *)(*v4 + 8 * v56++) = v72;
                        }
                        ++v71;
                        --v63;
                      }
                      while (v63);
                    }
                    v66 = v55;
                    *a4 = 16;
                    goto LABEL_114;
                  }
                  v65 = (uint64_t)v97;
                  if (v96)
                  {
                    v68 = 0;
                    v69 = 8 * v96;
                    do
                    {
                      v70 = *(_QWORD *)(v65 + v68);
                      if (v70)
                      {
                        OOCAllocator_Free(a1, v70);
                        *(_QWORD *)(v65 + v68) = 0;
                      }
                      v68 += 8;
                    }
                    while (v69 != v68);
                  }
                }
                else
                {
                  *a4 = v64;
                  *v4 = OOCAllocator_Realloc(a1, *v4, 8 * v64, &v98);
                  if (v98)
                    return v98;
                  v65 = (uint64_t)v97;
                  if ((_DWORD)v63)
                  {
                    v66 = v55;
                    for (n = 0; n != v63; ++n)
                      *(_QWORD *)(*v4 + 8 * (v56 + n)) = *(_QWORD *)(v65 + 8 * n);
                    v56 += n;
                    goto LABEL_114;
                  }
                }
                v66 = v55;
LABEL_114:
                OOCAllocator_Free(a1, v65);
                OOCAllocator_Free(a1, (uint64_t)v59);
                v54 = v62;
                v55 = v66;
                goto LABEL_115;
              }
LABEL_116:
              if (__dst)
                OOCAllocator_Free(a1, (uint64_t)__dst);
              if (v93)
              {
                if (v88)
                {
                  v73 = (uint64_t *)v93;
                  do
                  {
                    v74 = *v73++;
                    OOCAllocator_Free(a1, v74);
                    --v54;
                  }
                  while (v54);
                }
                OOCAllocator_Free(a1, v93);
              }
            }
          }
        }
      }
    }
  }
  else if (!strchr(v5, 124))
  {
    *v4 = OOCAllocator_Malloc(a1, 8, &v98);
    if (!v98)
    {
      v12 = strlen(v5);
      *(_QWORD *)*v4 = OOCAllocator_Malloc(a1, v12 + 2, &v98);
      if (!v98)
      {
        strcpy(*(char **)*v4, v5);
        *(_BYTE *)(strlen(v5) + *(_QWORD *)*v4 + 1) = 0;
        *a4 = 1;
      }
    }
  }
  return v98;
}

uint64_t PNEW_StringTokenizer_Con(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  v6 = (_QWORD *)OOCAllocator_Malloc(a1, 56, &v8);
  result = v8;
  if (!v8)
  {
    result = StringTokenizer_Con(v6, a2);
    v8 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t abbrtn_checkIfBisectedbyTokenType(uint64_t a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t **v10;
  unint64_t v11;
  int U32Attribute;
  unsigned int AbsoluteFrom;
  unsigned int AbsoluteTo;
  BOOL v16;
  __n128 v18;
  unint64_t v19;
  int v20;

  v20 = 0;
  *a5 = 0;
  LDO_GetLabels(*(_QWORD *)(a1 + 192), &v18);
  v9 = 0;
  v10 = (uint64_t **)v18.n128_u64[1];
  v11 = v19;
  if (v18.n128_u64[1] < v19)
  {
    do
    {
      v18.n128_u32[0] = 0;
      U32Attribute = LDOObject_GetU32Attribute(*v10, "_TTYPE", &v18, &v20);
      v9 = LH_ERROR_to_VERROR(U32Attribute);
      if ((v9 & 0x80000000) != 0)
        break;
      AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)*v10);
      AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)*v10);
      if (v18.n128_u32[0] == 1 && v20 == a4)
      {
        v16 = AbsoluteFrom < a2 || AbsoluteFrom >= a3;
        if (!v16 || AbsoluteTo > a2 && AbsoluteTo <= a3)
        {
          *a5 = 1;
          return v9;
        }
      }
      ++v10;
    }
    while ((unint64_t)v10 < v11);
  }
  return v9;
}

uint64_t abbrtn_checkIfSubsumedbyOtherToken(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  int U32Attribute;
  unsigned int AbsoluteFrom;
  unsigned int AbsoluteTo;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  __n128 v22;
  unint64_t v23;
  int v24;

  v24 = 0;
  *a6 = 0;
  LDO_GetLabels(*(_QWORD *)(a1 + 192), &v22);
  v10 = 0;
  v12 = (uint64_t **)v22.n128_u64[1];
  v11 = v23;
  if (v22.n128_u64[1] < v23)
  {
    do
    {
      v13 = *v12;
      v22.n128_u32[0] = 0;
      U32Attribute = LDOObject_GetU32Attribute(v13, "_TTYPE", &v22, &v24);
      v10 = LH_ERROR_to_VERROR(U32Attribute);
      if ((v10 & 0x80000000) != 0)
        break;
      AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)v13);
      AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v13);
      if (v22.n128_u32[0] == 1)
      {
        v17 = AbsoluteFrom == a2 && AbsoluteTo == a3;
        v18 = v17;
        v19 = v24 == a4 && v18;
        if (v24 == a5 && !v19 && AbsoluteFrom <= a2 && AbsoluteTo >= a3 && !v18)
        {
          *a6 = 1;
          return v10;
        }
      }
      ++v12;
    }
    while ((unint64_t)v12 < v11);
  }
  return v10;
}

uint64_t abbrtn_TnLookup(_QWORD *a1, const char *a2, unsigned __int16 a3, __int16 a4, char *a5, uint64_t a6)
{
  unsigned __int16 v8;
  __int16 v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t *v15;
  int v16;
  uint64_t **v17;
  unint64_t v18;
  uint64_t *v19;
  int U32Attribute;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unsigned __int16 v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  uint64_t *v34;
  int v35;
  int v36;
  const char *v37;
  int v38;
  uint64_t v39;
  unsigned __int16 v40;
  unsigned int v41;
  BOOL v42;
  unsigned __int8 v43;
  unint64_t v44;
  unsigned int v45;
  unint64_t v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  unsigned __int16 v54;
  uint64_t v55;
  BOOL v56;
  unsigned int v57;
  int v58;
  BOOL v59;
  uint64_t v60;
  unsigned int v62;
  BOOL v63;
  int v64;
  unsigned int v65;
  size_t v66;
  int v67;
  int v68;
  unint64_t v69;
  __int16 v70;
  int v71;
  unsigned int v72;
  int v74;
  unsigned int v75;
  unsigned __int16 v76;
  int v77;
  unsigned __int16 v78;
  char *v79;
  __int16 v80;
  int v81;
  const char *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  __n128 v90;
  unint64_t v91;
  __int16 v92;
  __n128 v93;
  unint64_t v94;
  int v95;
  int v96;
  _OWORD v97[4];
  char v98[128];
  char v99[256];
  char __s2[128];
  char v101[128];
  char __s[256];
  char __s1[128];
  uint64_t v104;

  v8 = a3;
  v104 = *MEMORY[0x1E0C80C00];
  v11 = a3 - 1;
  v92 = a3 - 1;
  v90 = 0uLL;
  v91 = 0;
  v88 = 0;
  v89 = 0;
  v86 = 0;
  v87 = 0;
  v84 = 0;
  v85 = 0;
  __s1[0] = 0;
  __s[0] = 0;
  v101[0] = 0;
  __s2[0] = 0;
  v99[0] = 0;
  v98[0] = 0;
  v12 = LDO_ComputeNodesCoveredByLabel(a1[24], a6, (uint64_t)&v90);
  v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) == 0)
  {
    v83 = (v91 - v90.n128_u64[1]) >> 3;
    if ((_DWORD)v83)
    {
      v82 = a2;
      if (a4 >= 1)
      {
        v14 = 0;
        v80 = a4;
        v81 = 3;
        v79 = a5;
        while (1)
        {
          v15 = *(uint64_t **)(v90.n128_u64[1] + 8 * v14);
          v16 = abbrtn_checkForTokens((uint64_t)a1, (uint64_t)v15, v8, (_WORD *)&v86 + 1, &v86, (_DWORD *)&v85 + 1, (_DWORD *)&v84 + 1);
          if (v16 < 0)
          {
LABEL_141:
            LODWORD(v13) = v16;
            goto LABEL_137;
          }
          v95 = 0;
          LODWORD(v85) = 0;
          LDO_GetLabels(a1[24], &v93);
          LODWORD(v13) = 0;
          v17 = (uint64_t **)v93.n128_u64[1];
          v18 = v94;
          while ((unint64_t)v17 < v18)
          {
            v19 = *v17;
            v96 = 0;
            U32Attribute = LDOObject_GetU32Attribute(v19, "_TTYPE", &v96, &v95);
            LODWORD(v13) = LH_ERROR_to_VERROR(U32Attribute);
            if ((v13 & 0x80000000) != 0)
              goto LABEL_137;
            if (v96 == 1 && v95 == 4)
            {
              v22 = LDOLabel_ContainsNode((uint64_t)v19, (uint64_t)v15, &v85);
              LODWORD(v13) = LH_ERROR_to_VERROR(v22);
              if ((v13 & 0x80000000) != 0)
                goto LABEL_137;
              if ((_DWORD)v85 == 1)
                break;
            }
            ++v17;
          }
          v23 = v14;
          if (HIDWORD(v85) == 1)
          {
            if (HIDWORD(v84) == 1)
            {
              LOWORD(v24) = HIWORD(v86);
              v25 = 6;
              v26 = v86;
              goto LABEL_27;
            }
LABEL_21:
            ++v14;
            if ((int)v23 + 1 >= v83)
              goto LABEL_137;
          }
          else
          {
            if ((_DWORD)v85 == 1)
              goto LABEL_21;
            v27 = LDOTreeNode_ComputeAbsoluteFrom((uint64_t)v15, &v88);
            v16 = LH_ERROR_to_VERROR(v27);
            if (v16 < 0)
              goto LABEL_141;
            LOWORD(v24) = v88;
            v28 = LDOTreeNode_ComputeAbsoluteTo((size_t)v15, &v87);
            v16 = LH_ERROR_to_VERROR(v28);
            if (v16 < 0)
              goto LABEL_141;
            v26 = v87;
            v29 = LDOObject_GetU32Attribute(v15, "_TTYPE", &v89, (_DWORD *)&v89 + 1);
            v16 = LH_ERROR_to_VERROR(v29);
            if (v16 < 0)
              goto LABEL_141;
            v25 = HIDWORD(v89);
LABEL_27:
            v13 = abbrtn_checkForTokens((uint64_t)a1, (uint64_t)v15, v26, (_WORD *)&v86 + 1, &v86, &v84, (_DWORD *)&v84 + 1);
            if ((v13 & 0x80000000) != 0)
              goto LABEL_137;
            v30 = v23 + 1;
            v78 = v26;
            if ((int)v23 + 1 >= v83)
            {
              v32 = 9999;
              v31 = 3;
            }
            else if ((_DWORD)v84 == 1)
            {
              v31 = 1;
              v32 = v23 + 1;
            }
            else
            {
              v33 = v25;
              v32 = v23 + 1;
              v34 = *(uint64_t **)(v90.n128_u64[1] + 8 * v30);
              v35 = LDOObject_GetU32Attribute(v34, "_TTYPE", &v89, (_DWORD *)&v89 + 1);
              v16 = LH_ERROR_to_VERROR(v35);
              if (v16 < 0)
                goto LABEL_141;
              v31 = HIDWORD(v89);
              v36 = LDOTreeNode_ComputeAbsoluteTo((size_t)v34, (_DWORD *)&v88 + 1);
              v13 = LH_ERROR_to_VERROR(v36);
              if ((v13 & 0x80000000) != 0)
                goto LABEL_137;
              v30 = v23 + 1;
              v25 = v33;
            }
            if ((__int16)v24 <= v11)
            {
LABEL_124:
              v64 = v25;
              goto LABEL_125;
            }
            v77 = v31;
            if (v81 != 3)
            {
              v38 = (__int16)v24;
              goto LABEL_113;
            }
            v37 = v82;
            v38 = (__int16)v24;
            if (v25 == 3)
              goto LABEL_113;
            v39 = 0;
            v40 = v24;
            while (1)
            {
              v41 = v82[v40];
              v42 = v41 > 0x20 || ((1 << v41) & 0x100002601) == 0;
              if (!v42 || v41 == 95)
                break;
              ++v40;
              __s1[v39++] = v41;
              if (v39 == 128)
                goto LABEL_113;
            }
            v75 = v30;
            __s1[v39] = 0;
            __strcpy_chk();
            v93.n128_u64[0] = 0;
            LOWORD(v96) = 0;
            memset(v97, 0, sizeof(v97));
            v13 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t, const char *, char *, __n128 *, int *))(a1[8] + 120))(a1[6], a1[7], __s, 255, "femwtn", v79, &v93, &v96);
            if ((v13 & 0x80000000) != 0)
              goto LABEL_137;
            if ((_WORD)v96)
            {
              v76 = v24;
              v43 = 0;
              v44 = 0;
              do
              {
                v45 = LH_atou(*(const char **)(v93.n128_u64[0] + 8 * v44));
                if (v45 <= 0x3F)
                  *((_BYTE *)v97 + v43++) = v45;
                ++v44;
              }
              while (v44 < (unsigned __int16)v96);
              ssft_qsort((uint64_t)v97, v43, 1, (uint64_t (*)(unint64_t, unint64_t))compare);
              v37 = v82;
              if (v43)
              {
                v74 = v25;
                v46 = 0;
                do
                {
                  if (v32 == 9999)
                  {
LABEL_56:
                    v32 = 9999;
                  }
                  else if (*((_BYTE *)v97 + v46))
                  {
                    while (1)
                    {
                      v47 = LDOObject_GetU32Attribute(*(uint64_t **)(v90.n128_u64[1] + 8 * v32), "_TTYPE", &v89, (_DWORD *)&v89 + 1);
                      v13 = LH_ERROR_to_VERROR(v47);
                      if ((v13 & 0x80000000) != 0)
                        goto LABEL_137;
                      v48 = v32 + 1;
                      if (v32 + 1 >= v83 || v32 == 9998)
                      {
                        v77 = 0;
                        goto LABEL_56;
                      }
                      ++v32;
                      if (!*((_BYTE *)v97 + v46))
                      {
                        v77 = 0;
                        v32 = v48;
                        break;
                      }
                    }
                  }
                  v49 = *((unsigned __int8 *)v97 + v46);
                  if (*((_BYTE *)v97 + v46))
                  {
                    v50 = 0;
                    v51 = 0;
                    v52 = 0;
                    v53 = v82[v76];
                    v54 = v76;
                    while (v53)
                    {
                      __s[v50] = v53;
                      if (v50 == 255)
                        goto LABEL_98;
                      v55 = ++v54;
                      v53 = v82[v54];
                      v56 = v53 > 0x20 || ((1 << v53) & 0x100002600) == 0;
                      if (!v56 || v53 == 95)
                      {
                        v57 = v82[v54 - 1];
                        v58 = v57 == 95 ? v51 : v51 + 1;
                        v59 = v57 > 0x20;
                        v60 = (1 << v57) & 0x100002600;
                        if (v59 || v60 == 0)
                          v51 = v58;
                      }
                      ++v50;
                      ++v52;
                      if (v49 <= v51)
                        goto LABEL_86;
                    }
                    v52 = (unsigned __int16)v50;
                    v55 = v54;
                  }
                  else
                  {
                    v52 = 0;
                    LOBYTE(v51) = 0;
                    v55 = v76;
                  }
LABEL_86:
                  __s[v52] = 0;
                  if (!v82[v55])
                  {
                    v62 = v82[v55 - 1];
                    v63 = v62 > 0x20 || ((1 << v62) & 0x100002600) == 0;
                    if (v63 && v62 != 95)
                      LOBYTE(v51) = v51 + 1;
                  }
                  if (v49 == v51)
                  {
                    __strcpy_chk();
                    v16 = (*(uint64_t (**)(_QWORD, _QWORD, char *, char *, uint64_t))(a1[8] + 112))(a1[6], a1[7], v79, v99, 256);
                    if (v16 < 0)
                      goto LABEL_141;
                    v93 = v90;
                    v94 = v91;
                    v13 = abbrtn_Lookup((uint64_t)a1, v99, __s, v79, v82, v76, v23, &v92, (uint64_t)&v93);
                    if ((v13 & 0x80000000) != 0)
                      goto LABEL_137;
                    v11 = v92;
                  }
LABEL_98:
                  ++v46;
                }
                while (v46 < v43 && v38 > v11);
                LOWORD(v24) = v76;
                v25 = v74;
                if (v38 > v11)
                  goto LABEL_105;
                goto LABEL_107;
              }
              LOWORD(v24) = v76;
            }
            else
            {
              ssft_qsort((uint64_t)v97, 0, 1, (uint64_t (*)(unint64_t, unint64_t))compare);
            }
LABEL_105:
            v93 = v90;
            v94 = v91;
            v13 = abbrtn_Lookup((uint64_t)a1, __s1, __s1, v79, v37, (unsigned __int16)v24, v23, &v92, (uint64_t)&v93);
            if ((v13 & 0x80000000) != 0)
              goto LABEL_137;
            v11 = v92;
LABEL_107:
            if (v38 > v11)
            {
              __strcpy_chk();
              v13 = (*(uint64_t (**)(_QWORD, _QWORD, char *, char *, uint64_t))(a1[8] + 112))(a1[6], a1[7], v79, __s2, 128);
              if ((v13 & 0x80000000) != 0)
                goto LABEL_137;
              if (strcmp(__s1, __s2))
              {
                v93 = v90;
                v94 = v91;
                v13 = abbrtn_Lookup((uint64_t)a1, __s2, __s1, v79, v37, (unsigned __int16)v24, v23, &v92, (uint64_t)&v93);
                if ((v13 & 0x80000000) != 0)
                  goto LABEL_137;
                v11 = v92;
              }
            }
            v30 = v75;
LABEL_113:
            if (v38 <= v11)
              goto LABEL_124;
            v64 = v25;
            if (!v25 && (v81 != 3 || v77 != 3))
            {
              v65 = v30;
              v66 = *(_QWORD *)(v90.n128_u64[1] + 8 * v23);
              v67 = LDOTreeNode_ComputeAbsoluteFrom(v66, &v88);
              v16 = LH_ERROR_to_VERROR(v67);
              if (v16 < 0)
                goto LABEL_141;
              v24 = (unsigned __int16)v88;
              v68 = LDOTreeNode_ComputeAbsoluteTo(v66, (_DWORD *)&v88 + 1);
              v13 = LH_ERROR_to_VERROR(v68);
              if ((v13 & 0x80000000) != 0)
                goto LABEL_137;
              v69 = WORD2(v88) - (unint64_t)v24;
              v30 = v65;
              if ((int)v69 <= 127)
              {
                __strncpy_chk();
                v101[v69] = 0;
                __strcpy_chk();
                v13 = (*(uint64_t (**)(_QWORD, _QWORD, char *, char *, uint64_t))(a1[8] + 104))(a1[6], a1[7], v79, v98, 128);
                if ((v13 & 0x80000000) != 0)
                  goto LABEL_137;
                if (!strcmp(__s2, v98))
                {
                  v30 = v65;
                }
                else
                {
                  v93 = v90;
                  v94 = v91;
                  v13 = abbrtn_Lookup((uint64_t)a1, v98, v101, v79, v82, v24, v23, &v92, (uint64_t)&v93);
                  v30 = v65;
                  if ((v13 & 0x80000000) != 0)
                    goto LABEL_137;
                }
              }
            }
LABEL_125:
            v70 = v92;
            if (v92 < (__int16)v24)
              v70 = v78;
            if (HIDWORD(v85) == 1)
              v14 = v23;
            else
              v14 = v30;
            v11 = v70 - 1;
            v92 = v70 - 1;
            if (v14 >= v83)
              break;
            v8 = v70;
            v81 = v64;
            if (v70 >= v80)
              break;
          }
        }
      }
    }
    if ((_DWORD)v83)
    {
LABEL_137:
      v71 = LDO_FreeLDOTreeNodeVector(a1[24], (uint64_t)&v90);
      v72 = LH_ERROR_to_VERROR(v71);
      if ((int)v13 >= 0)
        return v72;
      else
        return v13;
    }
  }
  return v13;
}

uint64_t abbrtn_checkForTokens(uint64_t a1, uint64_t a2, int a3, _WORD *a4, _WORD *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t **v14;
  uint64_t *v15;
  int U32Attribute;
  int v18;
  int AbsoluteFrom;
  __int16 AbsoluteTo;
  __n128 v23;
  unint64_t v24;
  int v25;

  v25 = 0;
  *a6 = 0;
  *a7 = 0;
  LDO_GetLabels(*(_QWORD *)(a1 + 192), &v23);
  v12 = 0;
  v14 = (uint64_t **)v23.n128_u64[1];
  v13 = v24;
  if (v23.n128_u64[1] < v24)
  {
    do
    {
      v15 = *v14;
      v23.n128_u32[0] = 0;
      U32Attribute = LDOObject_GetU32Attribute(v15, "_TTYPE", &v23, &v25);
      v12 = LH_ERROR_to_VERROR(U32Attribute);
      if ((v12 & 0x80000000) != 0)
        break;
      if (v23.n128_u32[0] == 1 && v25 == 6)
      {
        v18 = LDOLabel_ContainsNode((uint64_t)v15, a2, a6);
        v12 = LH_ERROR_to_VERROR(v18);
        if ((v12 & 0x80000000) != 0)
          return v12;
        if (*a6 == 1)
        {
          AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)v15);
          AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v15);
          if (AbsoluteFrom == a3)
          {
            *a4 = a3;
            *a5 = AbsoluteTo;
            *a7 = 1;
          }
          return v12;
        }
      }
      ++v14;
    }
    while ((unint64_t)v14 < v13);
  }
  return v12;
}

uint64_t abbrtn_Lookup(uint64_t a1, const char *a2, char *__s, char *a4, const char *a5, uint64_t a6, unsigned int a7, _WORD *a8, uint64_t a9)
{
  uint64_t v10;
  int v16;
  char *v17;
  int v18;
  uint64_t v19;
  uint64_t PreviousUtf8Offset;
  const char *v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  size_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  const char *v48;
  char *v49;
  const char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  char *v54;
  char *v55;
  size_t v56;
  uint64_t v57;
  const char *v58;
  __int16 v59;
  unint64_t v60;
  char *v61;
  unsigned int v62;
  int64_t v63;
  char *v64;
  int v65;
  char *v66;
  unsigned __int8 v67;
  char *v68;
  BOOL v69;
  _BOOL4 v70;
  unsigned int v71;
  int v72;
  char *v73;
  char *v74;
  int v75;
  char *i;
  int v77;
  unsigned int v78;
  int v79;
  BOOL v80;
  int64_t v81;
  __int16 v82;
  char *v83;
  int v84;
  const char *v85;
  unsigned __int16 v86;
  unsigned int NextUtf8Offset;
  uint64_t v88;
  int v89;
  unsigned __int16 v90;
  int v91;
  int64_t v92;
  int64_t v93;
  char *v94;
  int v95;
  const char *v96;
  int64_t v97;
  const char *v98;
  int v99;
  int64_t v100;
  __int16 v101;
  const char *v102;
  int v103;
  uint64_t v104;
  const char *v105;
  __int16 v106;
  unsigned __int16 v107;
  int v108;
  const char *v109;
  unsigned int v110;
  BOOL v111;
  unsigned int v112;
  int v113;
  uint64_t v114;
  unsigned int v116;
  int v117;
  unsigned int v118;
  int v119;
  int v120;
  int v121;
  _BYTE *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  _BYTE *v128;
  __int16 v129;
  char *v130;
  unsigned int v131;
  unsigned __int16 v132;
  unsigned int v133;
  unsigned __int8 *v134;
  int v135;
  int v136;
  __int16 v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unsigned __int16 v141;
  unsigned __int16 v142;
  const char *v143;
  uint64_t v144;
  unsigned int v145;
  BOOL v146;
  BOOL v148;
  unsigned int v149;
  int v150;
  unsigned __int16 v151;
  int v152;
  size_t v153;
  size_t v154;
  int v155;
  unint64_t v156;
  unsigned int v157;
  int v158;
  int v159;
  uint64_t v160;
  unint64_t v161;
  int v163;
  unsigned int v164;
  BOOL v165;
  unsigned int v166;
  int v167;
  uint64_t v168;
  unsigned __int16 v170;
  unsigned int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unsigned __int16 v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  char *v179;
  char *v180;
  int v181;
  char *v182;
  char *v183;
  int v184;
  char *v185;
  int j;
  uint64_t v187;
  unsigned int k;
  unsigned int v189;
  int v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unsigned __int16 v195;
  unsigned int v196;
  int v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  int v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  int v206;
  uint64_t v207;
  unsigned int *v208;
  unsigned int *v209;
  int v210;
  int v211;
  int v212;
  char *v214;
  uint64_t v215;
  uint64_t v216;
  unsigned int v217;
  uint64_t v218;
  unsigned int v219;
  unsigned __int16 v220;
  unsigned __int16 v221;
  unsigned int v222;
  char *v223;
  char *v224;
  unsigned int NextTOKEN_INT_TNPos;
  unsigned int v226;
  unsigned int v227;
  unsigned __int16 v228;
  __int16 v229;
  const char *v230;
  char *v231;
  _WORD *v232;
  const char *v233;
  unsigned __int16 v234;
  unint64_t v235;
  char *__s2;
  char *v237;
  uint64_t v238;
  unsigned int v239;
  unsigned int v240;
  unsigned int v241;
  unsigned int v242;
  char *v243;
  char *__s1;
  uint64_t v245;
  unsigned __int8 v246;
  unsigned __int16 v247;
  uint64_t v248;
  char __sa[128];
  uint64_t v250;

  v10 = a6;
  v250 = *MEMORY[0x1E0C80C00];
  v247 = 0;
  v245 = 0;
  if (a2)
  {
    if (!*a2)
      return 0;
    v232 = a8;
    v16 = strlen(__s) + a6;
    *(_DWORD *)__sa = 0;
    v233 = a2;
    __s2 = a4;
    if (strcmp(a2, __s))
    {
      v17 = (char *)&a5[v10];
      LOWORD(v18) = v10;
      if ((*(unsigned int (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v17))
      {
        v18 = v10;
        do
        {
          v18 += utf8_determineUTF8CharLength(*v17);
          v17 = (char *)&a5[(unsigned __int16)v18];
        }
        while ((*(unsigned int (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v17));
      }
      v19 = v10;
      PreviousUtf8Offset = (unsigned __int16)utf8_GetPreviousUtf8Offset((uint64_t)a5, (unsigned __int16)v16);
      v21 = &a5[PreviousUtf8Offset];
      v22 = (*(uint64_t (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), &a5[PreviousUtf8Offset]);
      if ((_DWORD)PreviousUtf8Offset && v22)
      {
        do
        {
          PreviousUtf8Offset = (unsigned __int16)utf8_GetPreviousUtf8Offset((uint64_t)a5, PreviousUtf8Offset);
          v21 = &a5[PreviousUtf8Offset];
          v23 = (*(uint64_t (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), &a5[PreviousUtf8Offset]);
        }
        while ((_DWORD)PreviousUtf8Offset && v23);
      }
      utf8_determineUTF8CharLength(*(unsigned __int8 *)v21);
      v10 = v19;
      goto LABEL_14;
    }
  }
  else
  {
    __s2 = a4;
    v232 = a8;
    v233 = 0;
    v16 = strlen(__s) + a6;
    *(_DWORD *)__sa = 0;
  }
  LOWORD(v18) = v10;
LABEL_14:
  v248 = 0;
  v246 = 0;
  v27 = abbrtn_checkIfSubsumedbyOtherToken(a1, (unsigned __int16)v18, (unsigned __int16)v16, 4, 6, __sa);
  if ((v27 & 0x80000000) != 0)
    return v27;
  if (*(_DWORD *)__sa == 1)
  {
    v28 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    v29 = "BLOCK Creating TN DCT token record for %s %d,%d bSubsumed=%d";
    v214 = __s;
LABEL_17:
    log_OutText(v28, (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)v29, v24, v25, v26, (uint64_t)v214);
    return v27;
  }
  v30 = *(_QWORD *)(*(_QWORD *)(a9 + 8) + 8 * a7);
  v31 = LDOTreeNode_ComputeAbsoluteFrom(v30, (_DWORD *)&v245 + 1);
  v32 = LH_ERROR_to_VERROR(v31);
  if ((v32 & 0x80000000) != 0)
    return v32;
  v33 = LDOTreeNode_ComputeAbsoluteTo(v30, &v245);
  v32 = LH_ERROR_to_VERROR(v33);
  if ((v32 & 0x80000000) != 0)
    return v32;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"TN look up %s", v34, v35, v36, (uint64_t)v233);
  LODWORD(v214) = 0;
  v37 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, uint64_t *, unsigned __int16 *, unsigned __int8 *, _QWORD))(*(_QWORD *)(a1 + 64) + 240))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), "tn", v233, &v248, &v247, &v246, *(unsigned __int8 *)(a1 + 112));
  v27 = v37;
  if ((v37 & 0x80000000) != 0 || !v247)
    return v27;
  NextTOKEN_INT_TNPos = v37;
  v217 = (unsigned __int16)v16;
  v234 = 0;
  v38 = 0;
  v223 = &byte_1DEBD87CE;
  v224 = __s - 1;
  v227 = 1;
  v222 = v10;
  v229 = v16;
  do
  {
    v39 = *(char **)(v248 + 8 * v38);
    v40 = strchr(v39, v246);
    v235 = v38;
    if (!v40)
    {
      v230 = 0;
      v46 = 0;
LABEL_31:
      v48 = 0;
      v50 = 0;
      v231 = 0;
      goto LABEL_34;
    }
    *v40 = 0;
    v230 = v40 + 1;
    v45 = strchr(v40 + 1, v246);
    v46 = v45;
    if (!v45)
      goto LABEL_31;
    *v45 = 0;
    v46 = v45 + 1;
    v47 = strchr(v45 + 1, v246);
    v48 = v47;
    if (!v47)
    {
      v50 = 0;
LABEL_33:
      v231 = 0;
      goto LABEL_34;
    }
    *v47 = 0;
    v48 = v47 + 1;
    v49 = strchr(v47 + 1, v246);
    v50 = v49;
    if (!v49)
      goto LABEL_33;
    *v49 = 0;
    v50 = v49 + 1;
    v51 = strchr(v49 + 1, v246);
    if (!v51)
      goto LABEL_33;
    *v51 = 0;
    v231 = v51 + 1;
    v52 = strchr(v51 + 1, v246);
    if (v52)
      *v52 = 0;
LABEL_34:
    v53 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    if (!v39)
    {
      v27 = 2310021127;
      log_OutPublic(v53, (uint64_t)"FE_ABBRTN", 32001, 0, v41, v42, v43, v44, v214);
      return v27;
    }
    v237 = v39;
    log_OutText(v53, (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"TN Validating %s", v42, v43, v44, (uint64_t)v39);
    if (v46 && *v46)
    {
      if ((v54 = strstr(v46, __s2)) == 0
        || (v55 = v54, v56 = strlen(__s2), v55 != v46) && *(v55 - 1) != 44
        || v55[v56] && v55[v56] != 44)
      {
        v57 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
        v58 = "TN Domain validation not OK";
LABEL_151:
        log_OutText(v57, (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)v58, v24, v25, v26, (uint64_t)v214);
        v59 = v229;
        v60 = v235;
        goto LABEL_152;
      }
    }
    if (!v50)
    {
      v59 = v229;
      v60 = v235;
      goto LABEL_51;
    }
    if (!strcmp(v50, "8"))
    {
      v57 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v58 = "TN expansion only valid within regexps";
      goto LABEL_151;
    }
    if (strcmp(v50, "1") && strcmp(v50, "4") && strcmp(v50, "5") && strcmp(v50, "7"))
      goto LABEL_77;
    if (v48 && *v48)
    {
      v63 = strlen(__s);
      if (v63 < 1)
      {
        v66 = &__s[v63];
      }
      else
      {
        v64 = &v224[v63];
        while (v64 > __s)
        {
          v65 = *v64--;
          if (v65 >= -64)
          {
            v66 = v64 + 1;
            goto LABEL_86;
          }
        }
        v66 = __s;
      }
LABEL_86:
      v72 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v66);
      if (v66)
      {
        do
        {
          v73 = v66;
          if (!v72)
            break;
          if (v66 > __s)
          {
            v74 = v66 - 1;
            while (v74 > __s)
            {
              v75 = *v74--;
              if (v75 >= -64)
              {
                v66 = v74 + 1;
                goto LABEL_94;
              }
            }
            v66 = __s;
          }
LABEL_94:
          v72 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v66);
        }
        while (v66 != v73);
      }
      for (i = __s;
            (*(unsigned int (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), i);
      while ((*(unsigned int (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v48))v48 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v48);
      if (i <= v66)
      {
        do
        {
          v77 = abbrtn_compareUtf8Char((uint64_t)i, (uint64_t)v48);
          v78 = utf8_determineUTF8CharLength(*i);
          v48 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v48);
          if (v77)
            break;
          i += v78;
        }
        while (i <= v66);
        v70 = v77 == 0;
      }
      else
      {
        v70 = 1;
      }
      v61 = v237;
      if (v70 && *v48)
      {
        do
        {
          v79 = (*(uint64_t (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v48);
          v48 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v48);
          if (v79)
            v80 = *v48 == 0;
          else
            v80 = 1;
        }
        while (!v80);
        v70 = v79 != 0;
      }
LABEL_113:
      if (!v70)
      {
        v57 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
        v58 = "TN Case validation not OK";
        goto LABEL_151;
      }
      goto LABEL_114;
    }
    v67 = *__s;
    if (*__s)
    {
      v68 = __s;
      do
      {
        v70 = 0;
        if ((v67 - 97) >= 0x1Au)
        {
          if (v67 != 195
            || (v68[1] - 133 <= 0x37
              ? (v69 = ((1 << (v68[1] + 123)) & 0x82101780000001) == 0)
              : (v69 = 1),
                v69))
          {
            v70 = 1;
          }
        }
        v71 = utf8_determineUTF8CharLength(v67);
        if (!v70)
          break;
        v68 += v71;
        v67 = *v68;
      }
      while (*v68);
      v61 = v237;
      goto LABEL_113;
    }
LABEL_77:
    v61 = v237;
LABEL_114:
    if (!strcmp(v50, "3") || !strcmp(v50, "5") || !strcmp(v50, "6") || !strcmp(v50, "7"))
    {
      v81 = strlen(__s);
      v82 = v81;
      if (v81 < 1)
      {
        v85 = &__s[v81];
      }
      else
      {
        v83 = &v224[v81];
        while (v83 > __s)
        {
          v84 = *v83--;
          if (v84 >= -64)
          {
            v85 = v83 + 1;
            goto LABEL_126;
          }
        }
        v85 = __s;
      }
LABEL_126:
      v86 = v82 - strlen(v85);
      NextUtf8Offset = v86;
      v88 = v86;
      v89 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), &__s[v86]);
      if (NextUtf8Offset && v89)
      {
        do
        {
          v90 = utf8_GetPreviousUtf8Offset((uint64_t)__s, NextUtf8Offset);
          v88 = v90;
          NextUtf8Offset = v90;
          v91 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), &__s[v90]);
        }
        while ((_DWORD)v88 && v91);
      }
      v92 = strlen(__s);
      v93 = v92;
      if (v92 < 1)
      {
        v96 = &__s[v92];
      }
      else
      {
        v94 = &v224[v92];
        while (v94 > __s)
        {
          v95 = *v94--;
          if (v95 >= -64)
          {
            v96 = v94 + 1;
            goto LABEL_137;
          }
        }
        v96 = __s;
      }
LABEL_137:
      if (v93 - strlen(v96) != v88)
        NextUtf8Offset = (unsigned __int16)utf8_GetNextUtf8Offset(__s, NextUtf8Offset);
      v61 = v237;
      if (v48 && *v48)
      {
        v97 = strlen(v48);
        if (v97 < 1)
        {
          v48 += v97;
        }
        else
        {
          v98 = &v48[v97 - 1];
          while (v98 > v48)
          {
            v99 = *v98--;
            if (v99 >= -64)
            {
              v48 = v98 + 1;
              break;
            }
          }
        }
        if (abbrtn_compareUtf8Char((uint64_t)&__s[NextUtf8Offset], (uint64_t)v48))
        {
          v57 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
          v58 = "Punctuation validation not OK";
          goto LABEL_151;
        }
      }
      else if (__s[NextUtf8Offset] != 46)
      {
        v57 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
        v58 = "TN Punctuation validation not OK";
        goto LABEL_151;
      }
    }
    if (strcmp(v50, "2") && strcmp(v50, "4") && strcmp(v50, "6") && strcmp(v50, "7"))
    {
      v59 = v229;
      v60 = v235;
      goto LABEL_52;
    }
    __s1 = 0;
    LOWORD(v241) = 0;
    v100 = strlen(a5);
    v101 = v100;
    if (v100 < 1)
    {
      v104 = v10;
      v105 = &a5[v100];
    }
    else
    {
      v102 = &a5[v100 - 1];
      while (v102 > a5)
      {
        v103 = *v102--;
        if (v103 >= -64)
        {
          v104 = v10;
          v105 = v102 + 1;
          goto LABEL_167;
        }
      }
      v104 = v10;
      v105 = a5;
    }
LABEL_167:
    v106 = strlen(v105);
    v243 = 0;
    BYTE4(v238) = 0;
    LOWORD(v240) = 0;
    LOWORD(v239) = 0;
    v242 = 0;
    strcpy(__sa, "disambiguate_abbreviations");
    v220 = strlen(__sa);
    v107 = v222;
    if (!(_WORD)v222)
      goto LABEL_188;
    v108 = 0;
    v109 = &a5[(unsigned __int16)v222];
    do
    {
      v110 = a5[--v107];
      v111 = v110 > 0x20 || ((1 << v110) & 0x100002600) == 0;
      if (!v111 || v110 == 95)
      {
        v112 = *(unsigned __int8 *)v109;
        v113 = v112 == 95 ? v108 : v108 + 1;
        v148 = v112 > 0x20;
        v114 = (1 << v112) & 0x100002600;
        if (v148 || v114 == 0)
          v108 = v113;
      }
      if (v108 > 3u)
        break;
      --v109;
    }
    while (v107);
    if (v107)
      v226 = v107 + utf8_determineUTF8CharLength(a5[v107]);
    else
LABEL_188:
      v226 = 0;
    v116 = (unsigned __int16)(v101 - v106);
    if (v116 >= (unsigned __int16)v222)
    {
      v163 = 0;
      LOBYTE(v164) = a5[(unsigned __int16)v222];
      v118 = v222;
      do
      {
        v118 += utf8_determineUTF8CharLength(v164);
        v164 = a5[(unsigned __int16)v118];
        v165 = v164 > 0x20 || ((1 << v164) & 0x100002600) == 0;
        if (!v165 || v164 == 95)
        {
          v166 = a5[(unsigned __int16)v118 - 1];
          v167 = v166 == 95 ? v163 : v163 + 1;
          v148 = v166 > 0x20;
          v168 = (1 << v166) & 0x100002600;
          if (v148 || v168 == 0)
            v163 = v167;
        }
        v117 = (unsigned __int16)v118;
      }
      while (v163 <= 3u && v116 >= (unsigned __int16)v118);
    }
    else
    {
      v117 = (unsigned __int16)v222;
      LOWORD(v118) = v222;
    }
    v119 = v117 - (unsigned __int16)v226;
    v120 = strlen(v237);
    v121 = v119 + 25;
    v122 = (_BYTE *)heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 16) + 8), *(_QWORD *)(a1 + 96), (v121 + v120));
    if (!v122
      || (*(_QWORD *)(a1 + 96) = v122,
          *v122 = 0,
          v127 = strlen(v237),
          (v128 = (_BYTE *)heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 16) + 8), *(_QWORD *)(a1 + 104), (v121 + v127))) == 0))
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 32000, 0, v123, v124, v125, v126, v214);
      return -1984946166;
    }
    *(_QWORD *)(a1 + 104) = v128;
    *v128 = 0;
    v129 = strlen(__s);
    v130 = (char *)&a5[(unsigned __int16)v222];
    LOWORD(v131) = v222;
    if ((*(unsigned int (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v130))
    {
      v131 = v222;
      do
      {
        v131 += utf8_determineUTF8CharLength(*v130);
        v130 = (char *)&a5[(unsigned __int16)v131];
      }
      while ((*(unsigned int (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v130));
    }
    v132 = utf8_GetPreviousUtf8Offset((uint64_t)a5, (unsigned __int16)(v222 + v129));
    v133 = v132;
    v134 = (unsigned __int8 *)&a5[v132];
    v135 = (*(uint64_t (**)(_QWORD, _QWORD, unsigned __int8 *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v134);
    if (v132 && v135)
    {
      do
      {
        v132 = utf8_GetPreviousUtf8Offset((uint64_t)a5, v133);
        v133 = v132;
        v134 = (unsigned __int8 *)&a5[v132];
        v136 = (*(uint64_t (**)(_QWORD, _QWORD, unsigned __int8 *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v134);
      }
      while (v132 && v136);
    }
    v137 = utf8_determineUTF8CharLength(*v134);
    NextTOKEN_INT_TNPos = getNextTOKEN_INT_TNPos(a1, &v240, &v239, (uint64_t *)&v243, (unsigned __int16)v226, (unsigned __int16)v118, &v242);
    if ((NextTOKEN_INT_TNPos & 0x80000000) != 0)
      return NextTOKEN_INT_TNPos;
    if ((unsigned __int16)v226 >= (unsigned __int16)v118)
    {
      v10 = v104;
      v59 = v229;
      v60 = v235;
LABEL_277:
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"%s L1: %s", v138, v139, v140, (uint64_t)__sa);
      v170 = strlen(*(const char **)(a1 + 96));
      v171 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 88) + 120))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), 0, *(_QWORD *)(a1 + 96), v170);
      if ((v171 & 0x80000000) != 0)
        return v171;
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"%s L2: %s", v172, v173, v174, (uint64_t)__sa);
      v175 = strlen(*(const char **)(a1 + 104));
      v171 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 88) + 120))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), 1, *(_QWORD *)(a1 + 104), v175);
      if ((v171 & 0x80000000) != 0)
        return v171;
      if (strcmp(__s2, "normal") && strlen(__s2) + v220 + 2 <= 0x7F)
      {
        __strcat_chk();
        __strcat_chk();
      }
      if (((*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 88) + 80))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), __sa) & 0x80000000) != 0&& (__sa[v220] = 0, v171 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 88) + 80))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), __sa), (v171 & 0x80000000) != 0))
      {
        return v171;
      }
      else
      {
        NextTOKEN_INT_TNPos = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, unsigned int *))(*(_QWORD *)(a1 + 88) + 128))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), 0, &__s1, &v241);
        if ((NextTOKEN_INT_TNPos & 0x80000000) == 0)
        {
          __s1[(unsigned __int16)v241] = 0;
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"%s O1: %s", v176, v177, v178, (uint64_t)__sa);
          v179 = strstr(__s1, "§");
          if (v179)
          {
            v180 = v179;
            while (1)
            {
              v181 = utf8_determineUTF8CharLength(*v180);
              v182 = strstr(&v180[v181], "§");
              if (!v182)
                break;
              v183 = v182;
              v184 = v180[utf8_determineUTF8CharLength(*v180)];
              v180 = v183;
              if (v184 != 32)
                goto LABEL_298;
            }
          }
LABEL_51:
          v61 = v237;
          if (!v231 || !*v231)
            goto LABEL_82;
LABEL_52:
          v62 = (unsigned __int16)atoi(v231);
          if (v62 < v227)
          {
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Lower priority than previous valid normalizations", v24, v25, v26, (uint64_t)v214);
            goto LABEL_152;
          }
          if (v62 > v227)
          {
            if (v234)
              log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Higher priority than previous valid normalizations", v24, v25, v26, (uint64_t)v214);
            v234 = 0;
          }
          else
          {
LABEL_82:
            v62 = v227;
          }
          ++v234;
          v223 = v61;
          v227 = v62;
          goto LABEL_152;
        }
      }
      return NextTOKEN_INT_TNPos;
    }
    v141 = v137 + v132;
    v219 = v141;
    v142 = v226;
    v10 = v104;
    v143 = v230;
    v218 = v104;
    v221 = v141;
    while (1)
    {
      v144 = (unsigned __int16)v240;
      v145 = (unsigned __int16)v239;
      if (v242 == 1
        && (unsigned __int16)v240 == (unsigned __int16)v226
        && (unsigned __int16)v239 == (unsigned __int16)v118)
      {
        break;
      }
      if (v242 != 1)
      {
        if (v142 > (unsigned __int16)v131 || v242)
          goto LABEL_294;
LABEL_225:
        addToLayer(a1, (uint64_t)a5, v142, (unsigned __int16)v131, 0, 0, (unsigned __int8 *)&v238 + 4);
        if (BYTE4(v238) > 0x13u)
          goto LABEL_297;
        addToLayer(a1, (uint64_t)a5, (unsigned __int16)v131, v221, v237, v143, (unsigned __int8 *)&v238 + 4);
        if (BYTE4(v238) > 0x13u)
          goto LABEL_297;
        v142 = v221;
        if ((_DWORD)v144 == (unsigned __int16)v131)
        {
          v142 = v221;
          NextTOKEN_INT_TNPos = getNextTOKEN_INT_TNPos(a1, &v240, &v239, (uint64_t *)&v243, v221, (unsigned __int16)v118, &v242);
          if ((NextTOKEN_INT_TNPos & 0x80000000) != 0)
            return NextTOKEN_INT_TNPos;
        }
        goto LABEL_255;
      }
      if ((unsigned __int16)v240 >= (unsigned __int16)v131
        && v142 <= (unsigned __int16)v131
        && v142 <= (unsigned __int16)v240)
      {
        goto LABEL_225;
      }
      v146 = v142 > (unsigned __int16)v240;
      if (v219 > v142)
        v146 = 1;
      v148 = v142 <= (unsigned __int16)v240
          && v142 < (unsigned __int16)v131
          && (unsigned __int16)v131 > (unsigned __int16)v240;
      if (!v148 && v146)
      {
LABEL_294:
        addToLayer(a1, (uint64_t)a5, v142, (unsigned __int16)v118, 0, 0, (unsigned __int8 *)&v238 + 4);
        v59 = v229;
        v60 = v235;
        if (BYTE4(v238) <= 0x13u)
          goto LABEL_277;
        goto LABEL_298;
      }
      addToLayer(a1, (uint64_t)a5, v142, (unsigned __int16)v240, 0, 0, (unsigned __int8 *)&v238 + 4);
      v149 = BYTE4(v238);
      if (BYTE4(v238) > 0x13u)
        goto LABEL_297;
      if (v145 > (unsigned __int16)v118)
      {
        LOWORD(v239) = v118;
        v228 = v118;
LABEL_231:
        LOWORD(v145) = 0;
        v150 = 0;
        do
        {
          if (!a5[(unsigned __int16)v150])
            break;
          v150 += utf8_determineUTF8CharLength(a5[(unsigned __int16)v150]);
          LOWORD(v145) = v145 + 1;
        }
        while ((unsigned __int16)v150 < v228);
        goto LABEL_236;
      }
      v228 = v145;
      if (v145)
        goto LABEL_231;
      v228 = 0;
LABEL_236:
      v151 = 0;
      if ((_DWORD)v144)
      {
        v152 = 0;
        do
        {
          if (!a5[(unsigned __int16)v152])
            break;
          v152 += utf8_determineUTF8CharLength(a5[(unsigned __int16)v152]);
          ++v151;
        }
        while (v144 > (unsigned __int16)v152);
      }
      strncat(*(char **)(a1 + 96), &a5[v144], v228 - v144);
      v153 = strlen(v243);
      strncat(*(char **)(a1 + 104), v243 + 1, v153 - 2);
      v154 = strlen(v243);
      v155 = (unsigned __int16)v145 - v151;
      if (((_DWORD)v154 << 16) - 0x20000 <= v155 << 16)
      {
        v158 = v155 + 2;
        if (v154 != v158)
        {
          v159 = 0;
          v160 = v158;
          do
          {
            *(_WORD *)(*(_QWORD *)(a1 + 104) + strlen(*(const char **)(a1 + 104))) = 126;
            ++v159;
          }
          while (v160 - strlen(v243) > (unsigned __int16)v159);
        }
      }
      else
      {
        v156 = v151 - (unint64_t)(unsigned __int16)v145 - 2;
        if (v156 + v154)
        {
          v161 = 1;
          do
          {
            *(_WORD *)(*(_QWORD *)(a1 + 96) + strlen(*(const char **)(a1 + 96))) = 126;
            v157 = v149 + 1;
            v148 = v156 + strlen(v243) > v161++;
          }
          while (v148 && v149++ < 0x13);
        }
        else
        {
          v157 = v149;
        }
        BYTE4(v238) = v157;
        if (v157 > 0x13)
        {
          v10 = v218;
LABEL_297:
          v59 = v229;
          v60 = v235;
          goto LABEL_298;
        }
      }
      v142 = v228;
      v10 = v218;
      NextTOKEN_INT_TNPos = getNextTOKEN_INT_TNPos(a1, &v240, &v239, (uint64_t *)&v243, v228, (unsigned __int16)v118, &v242);
      v143 = v230;
      if ((NextTOKEN_INT_TNPos & 0x80000000) != 0)
        return NextTOKEN_INT_TNPos;
LABEL_255:
      if (v142 >= (unsigned __int16)v118)
        goto LABEL_292;
    }
    addToLayer(a1, (uint64_t)a5, (unsigned __int16)v226, (unsigned __int16)v118, v237, v143, (unsigned __int8 *)&v238 + 4);
    v242 = 0;
    v222 = v226;
LABEL_292:
    v59 = v229;
    v60 = v235;
    if (BYTE4(v238) <= 0x13u)
      goto LABEL_277;
LABEL_298:
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Context validation not OK", v138, v139, v140, (uint64_t)v214);
LABEL_152:
    v38 = v60 + 1;
  }
  while (v38 < v247 && v234 < 2u);
  v27 = NextTOKEN_INT_TNPos;
  if (!v234)
    return v27;
  if (v234 != 1)
  {
    v28 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    v29 = "Multiple valid lookups => no normalization";
    goto LABEL_17;
  }
  *v232 = v59;
  v242 = v217;
  LODWORD(v243) = 0;
  v241 = v217;
  if (v233 && strcmp(v233, __s))
  {
    v185 = (char *)&a5[v10];
    for (j = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v185);
          j;
          j = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v185))
    {
      LODWORD(v10) = v10 + utf8_determineUTF8CharLength(*v185);
      v185 = (char *)&a5[(unsigned __int16)v10];
    }
    v187 = (uint64_t)a5;
    for (k = v217; ; k = v189)
    {
      v189 = utf8_GetPreviousUtf8Offset(v187, k);
      if (!(*(unsigned int (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 64) + 128))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), &a5[v189])|| v189 == 0)
      {
        break;
      }
      v187 = (uint64_t)a5;
    }
    v242 = v189 + utf8_determineUTF8CharLength(a5[v189]);
  }
  v191 = LDO_CountLeafNodesOnRange(*(_QWORD *)(a1 + 192), &v242, &v241, &v243, &v242);
  v32 = LH_ERROR_to_VERROR(v191);
  if ((v32 & 0x80000000) != 0)
    return v32;
  v195 = (_DWORD)v243 ? v242 : v59;
  v196 = v195;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Creating TN DCT token record for %s %d,%d %s", v192, v193, v194, (uint64_t)__s);
  *(_QWORD *)__sa = 0;
  __s1 = 0;
  v239 = v196;
  v240 = (unsigned __int16)v10;
  v238 = 0;
  LODWORD(v243) = 0;
  v197 = LDO_CountLeafNodesOnRange(*(_QWORD *)(a1 + 192), &v240, &v239, &v243, 0);
  v32 = LH_ERROR_to_VERROR(v197);
  if ((v32 & 0x80000000) != 0)
    return v32;
  if (v239 <= v240 || (_DWORD)v243)
  {
    v207 = *(_QWORD *)(a1 + 192);
    v208 = &v240;
    v209 = &v239;
LABEL_332:
    v210 = LDO_AddLabelOnSubstring(v207, "TOKEN", "TOKEN", v208, v209, __sa);
    v27 = LH_ERROR_to_VERROR(v210);
    if ((v27 & 0x80000000) != 0)
      return v27;
    goto LABEL_335;
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"No node in the given range => attempting to find a containing node", v198, v199, v200, v215);
  v201 = LDO_ComputeLeafNodeContainingRange(*(_QWORD *)(a1 + 192), &v240, &v239, (size_t *)&__s1);
  v27 = LH_ERROR_to_VERROR(v201);
  if ((v27 & 0x80000000) != 0)
    return v27;
  if (!__s1)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"No containing node found => no label created", v202, v203, v204, v216);
LABEL_335:
    if (*(_QWORD *)__sa)
    {
      LDOObject_SetU32Attribute(*(uint64_t *)__sa, "_TTYPE", 4);
      v32 = LH_ERROR_to_VERROR(v211);
      if ((v32 & 0x80000000) == 0)
      {
        v212 = LDOObject_SetStringAttribute(*(uint64_t *)__sa, "NORM", v223);
        return LH_ERROR_to_VERROR(v212);
      }
      return v32;
    }
    return v27;
  }
  v205 = LDOTreeNode_ComputeAbsoluteFrom((uint64_t)__s1, (_DWORD *)&v238 + 1);
  v32 = LH_ERROR_to_VERROR(v205);
  if ((v32 & 0x80000000) == 0)
  {
    v206 = LDOTreeNode_ComputeAbsoluteTo((size_t)__s1, &v238);
    v32 = LH_ERROR_to_VERROR(v206);
    if ((v32 & 0x80000000) == 0)
    {
      v207 = *(_QWORD *)(a1 + 192);
      v208 = (unsigned int *)&v238 + 1;
      v209 = (unsigned int *)&v238;
      goto LABEL_332;
    }
  }
  return v32;
}

uint64_t abbrtn_sanitizeTokenDCTAndIntTN(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t *v24;
  int v25;
  int v27;
  uint64_t v28;
  uint64_t v29;

  v2 = 0;
  v27 = 0;
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 192) + 32);
  v4 = *(uint64_t **)(v3 + 24);
  if ((unint64_t)v4 >= *(_QWORD *)(v3 + 32))
  {
LABEL_29:
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 192) + 32);
    v16 = *(uint64_t **)(v15 + 24);
    if ((unint64_t)v16 >= *(_QWORD *)(v15 + 32))
    {
      v6 = 0;
    }
    else
    {
      v17 = 0;
      v6 = 0;
      v18 = 0;
      do
      {
        v19 = *v16;
        v28 = 0;
        v29 = 0;
        v20 = abbrtn_filterLabelByTokenType(v19, 6, (_DWORD *)&v28 + 1, (_DWORD *)&v29 + 1, &v29);
        v2 = v20;
        if ((v20 & 0x80000000) != 0 || !HIDWORD(v28))
        {
          if ((v20 & 0x80000000) != 0)
            goto LABEL_56;
        }
        else
        {
          v2 = abbrtn_checkIfBisectedbyTokenType(a1, HIDWORD(v29), v29, 4, &v28);
          if ((v2 & 0x80000000) != 0)
            goto LABEL_56;
          if ((_DWORD)v28 == 1)
          {
            v21 = (unint64_t)v17 - v6;
            v22 = (((unint64_t)v17 - v6) >> 3) + 1;
            if (v22 > v18)
            {
              v23 = 2 * v18;
              if (2 * v18 >= v18 + 1000000)
                v23 = v18 + 1000000;
              if (v23 > v22)
                v22 = v23;
              if (v22 <= 8)
                v18 = 8;
              else
                v18 = v22;
              v6 = OOCAllocator_Realloc(a1 + 152, v6, 8 * v18, &v27);
              v12 = v27;
              if (v27)
                goto LABEL_55;
              v17 = (uint64_t *)(v6 + (v21 & 0x7FFFFFFF8));
            }
            *v17++ = v19;
          }
        }
        ++v16;
      }
      while ((unint64_t)v16 < *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 32) + 32));
      if (v6 < (unint64_t)v17)
      {
        v24 = (uint64_t *)v6;
        do
        {
          v25 = LDO_RemoveLabel(*(_QWORD *)(a1 + 192), *v24);
          v2 = LH_ERROR_to_VERROR(v25);
          if ((v2 & 0x80000000) != 0)
            goto LABEL_56;
          ++v24;
        }
        while (v24 < v17);
      }
    }
    v12 = v27;
    if (v27)
LABEL_55:
      v2 = LH_ERROR_to_VERROR(v12);
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    while (1)
    {
      v8 = *v4;
      HIDWORD(v29) = 0;
      v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 4, 6, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0)
        break;
      if (HIDWORD(v29) == 1)
        goto LABEL_11;
      v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 4, 4, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0)
        break;
      if (HIDWORD(v29) == 1)
        goto LABEL_11;
      v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 6, 4, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0)
        break;
      if (HIDWORD(v29) == 1)
        goto LABEL_11;
      v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 6, 6, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0)
        break;
      if (HIDWORD(v29) == 1)
      {
LABEL_11:
        v9 = (unint64_t)v5 - v6;
        v10 = (((unint64_t)v5 - v6) >> 3) + 1;
        if (v10 > v7)
        {
          v11 = 2 * v7;
          if (2 * v7 >= v7 + 1000000)
            v11 = v7 + 1000000;
          if (v11 > v10)
            v10 = v11;
          if (v10 <= 8)
            v7 = 8;
          else
            v7 = v10;
          v6 = OOCAllocator_Realloc(a1 + 152, v6, 8 * v7, &v27);
          v12 = v27;
          if (v27)
            goto LABEL_55;
          v5 = (uint64_t *)(v6 + (v9 & 0x7FFFFFFF8));
        }
        *v5++ = v8;
      }
      if ((unint64_t)++v4 >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 32) + 32))
      {
        if (v6 >= (unint64_t)v5)
        {
LABEL_27:
          if (v6)
            OOCAllocator_Free(a1 + 152, v6);
          goto LABEL_29;
        }
        v13 = (uint64_t *)v6;
        while (1)
        {
          v14 = LDO_RemoveLabel(*(_QWORD *)(a1 + 192), *v13);
          v2 = LH_ERROR_to_VERROR(v14);
          if ((v2 & 0x80000000) != 0)
            goto LABEL_56;
          if (++v13 >= v5)
            goto LABEL_27;
        }
      }
    }
  }
LABEL_56:
  if (v6)
    OOCAllocator_Free(a1 + 152, v6);
  return v2;
}

BOOL compare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

uint64_t abbrtn_compareUtf8Char(uint64_t a1, uint64_t a2)
{
  char __s2[10];
  char __s1[10];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  utf8_getUTF8Char(a1, 0, __s1);
  utf8_getUTF8Char(a2, 0, __s2);
  return strcmp(__s1, __s2);
}

uint64_t getNextTOKEN_INT_TNPos(uint64_t a1, _WORD *a2, _WORD *a3, uint64_t *a4, unsigned int a5, unsigned int a6, _DWORD *a7)
{
  uint64_t v11;
  uint64_t *v12;
  unsigned __int16 AbsoluteFrom;
  unsigned __int16 AbsoluteTo;
  int Category;
  int U32Attribute;
  int StringAttribute;
  __int16 v18;
  uint64_t v22;
  char *__s1;
  int v24;
  __n128 v25;
  unint64_t v26;

  v25 = 0uLL;
  v26 = 0;
  LDO_GetLabels(*(_QWORD *)(a1 + 192), &v25);
  v11 = 0;
  __s1 = 0;
  *a7 = 0;
  v12 = (uint64_t *)v25.n128_u64[1];
  if (v25.n128_u64[1] < v26)
  {
    v24 = 0;
    while (1)
    {
      v22 = 0;
      AbsoluteFrom = LDOLabel_GetAbsoluteFrom(*v12);
      AbsoluteTo = LDOLabel_GetAbsoluteTo(*v12);
      Category = LDOObject_GetCategory(*v12, (uint64_t *)&__s1);
      v11 = LH_ERROR_to_VERROR(Category);
      if ((v11 & 0x80000000) != 0)
        return v11;
      if (!strcmp(__s1, "TOKEN"))
        break;
LABEL_5:
      if ((unint64_t)++v12 >= v26)
        return v11;
    }
    if (AbsoluteFrom >= a5)
    {
      if (AbsoluteTo > a6)
        goto LABEL_12;
    }
    else if (AbsoluteTo <= a5 || AbsoluteTo >= a6)
    {
LABEL_12:
      if (AbsoluteFrom <= a5 || AbsoluteFrom >= a6 || AbsoluteTo <= a6)
        goto LABEL_5;
    }
    U32Attribute = LDOObject_GetU32Attribute((uint64_t *)*v12, "_TTYPE", (_DWORD *)&v22 + 1, &v24);
    v11 = LH_ERROR_to_VERROR(U32Attribute);
    if ((v11 & 0x80000000) != 0)
      return v11;
    if (v24 == 6)
    {
      StringAttribute = LDOObject_GetStringAttribute((uint64_t *)*v12, "TNTAG", &v22, a4);
      v11 = LH_ERROR_to_VERROR(StringAttribute);
      if ((v11 & 0x80000000) != 0)
        return v11;
      if ((_DWORD)v22 == 1)
      {
        if (AbsoluteFrom >= a5 || AbsoluteTo <= a5 || (v18 = a5, AbsoluteTo >= a6))
          v18 = AbsoluteFrom;
        *a2 = v18;
        if (AbsoluteFrom <= a5 || AbsoluteFrom >= a6 || AbsoluteTo <= a6)
          LOWORD(a6) = AbsoluteTo;
        *a3 = a6;
        *a7 = 1;
        return v11;
      }
    }
    goto LABEL_5;
  }
  return v11;
}

size_t addToLayer(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, const char *a5, const char *a6, unsigned __int8 *a7)
{
  size_t v11;
  int v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  int v16;
  int v17;
  unsigned __int8 v18;
  size_t v19;
  size_t v20;
  int v21;
  unsigned __int16 v22;
  int v23;
  unsigned __int16 v24;
  int v25;
  int v26;
  const char *v27;
  size_t result;
  char *v29;
  int v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;

  if (a5)
  {
    v11 = *(_QWORD *)(a1 + 96) + strlen(*(const char **)(a1 + 96));
    *(_WORD *)v11 = -22590;
    *(_BYTE *)(v11 + 2) = 0;
    strcat(*(char **)(a1 + 96), a5);
    v12 = strlen(a6);
    v13 = Utf8_LengthInUtf8chars((unint64_t)a6, v12);
    v14 = strlen(a5);
    v15 = Utf8_LengthInUtf8chars((unint64_t)a5, v14);
    if (v13 > v15)
    {
      v16 = v13 - v15;
      if (v16 >= 1)
      {
        v17 = 0;
        v18 = *a7;
        do
        {
          if (v18 > 0x13u)
            break;
          *(_WORD *)(*(_QWORD *)(a1 + 96) + strlen(*(const char **)(a1 + 96))) = 126;
          ++v17;
          v18 = *a7 + 1;
          *a7 = v18;
        }
        while (v16 > (unsigned __int16)v17);
      }
    }
    v19 = *(_QWORD *)(a1 + 96) + strlen(*(const char **)(a1 + 96));
    *(_WORD *)v19 = -22590;
    *(_BYTE *)(v19 + 2) = 0;
    v20 = *(_QWORD *)(a1 + 104) + strlen(*(const char **)(a1 + 104));
    *(_WORD *)v20 = -22590;
    *(_BYTE *)(v20 + 2) = 0;
    strcat(*(char **)(a1 + 104), a6);
    v21 = strlen(a5);
    v22 = Utf8_LengthInUtf8chars((unint64_t)a5, v21);
    v23 = strlen(a6);
    v24 = Utf8_LengthInUtf8chars((unint64_t)a6, v23);
    if (v22 > v24)
    {
      v25 = v22 - v24;
      if (v25 >= 1)
      {
        v26 = 0;
        do
        {
          *(_WORD *)(*(_QWORD *)(a1 + 104) + strlen(*(const char **)(a1 + 104))) = 126;
          ++v26;
        }
        while (v25 > (unsigned __int16)v26);
      }
    }
    v27 = *(const char **)(a1 + 104);
    result = strlen(v27);
    v29 = (char *)&v27[result];
    *(_WORD *)v29 = -22590;
    v29[2] = 0;
  }
  else
  {
    result = (size_t)strncat(*(char **)(a1 + 96), (const char *)(a2 + a3), a4 - (unint64_t)a3);
    v33 = 0;
    if (a3)
    {
      v34 = 0;
      do
      {
        result = *(unsigned __int8 *)(a2 + v34);
        if (!*(_BYTE *)(a2 + v34))
          break;
        result = utf8_determineUTF8CharLength(result);
        v34 += result;
        ++v33;
      }
      while (a3 > v34);
    }
    v35 = 0;
    if (a4)
    {
      v36 = 0;
      do
      {
        result = *(unsigned __int8 *)(a2 + v36);
        if (!*(_BYTE *)(a2 + v36))
          break;
        result = utf8_determineUTF8CharLength(result);
        v36 += result;
        ++v35;
      }
      while (a4 > v36);
    }
    for (; (unsigned __int16)v33 < v35; ++v33)
    {
      result = strlen(*(const char **)(a1 + 104));
      *(_WORD *)(*(_QWORD *)(a1 + 104) + result) = 32;
    }
  }
  return result;
}

uint64_t abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(uint64_t a1, uint64_t a2, int a3, int a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  unsigned int v12;
  BOOL v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  v16 = 0;
  v14 = 0;
  *a5 = 0;
  result = abbrtn_filterLabelByTokenType(a2, a3, (_DWORD *)&v16 + 1, &v16, (_DWORD *)&v15 + 1);
  if ((result & 0x80000000) == 0)
  {
    if (HIDWORD(v16))
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 192) + 32);
      v10 = *(uint64_t **)(v9 + 24);
      if ((unint64_t)v10 < *(_QWORD *)(v9 + 32))
      {
        v12 = HIDWORD(v15);
        v11 = v16;
        do
        {
          result = abbrtn_filterLabelByTokenType(*v10, a4, (_DWORD *)&v16 + 1, &v15, &v14);
          if ((result & 0x80000000) != 0)
            break;
          if (HIDWORD(v16) == 1)
          {
            v13 = v11 < v15 || v12 >= v14;
            if (!v13 || v11 > v15 && v12 <= v14)
            {
              *a5 = 1;
              return result;
            }
          }
          ++v10;
        }
        while ((unint64_t)v10 < *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 32) + 32));
      }
    }
  }
  return result;
}

uint64_t abbrtn_filterLabelByTokenType(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int U32Attribute;
  uint64_t v11;
  uint64_t v13;

  v13 = 0;
  *a3 = 0;
  if (!*(_DWORD *)(a1 + 104))
    return 0;
  U32Attribute = LDOObject_GetU32Attribute((uint64_t *)a1, "_TTYPE", (_DWORD *)&v13 + 1, &v13);
  v11 = LH_ERROR_to_VERROR(U32Attribute);
  if ((v11 & 0x80000000) == 0 && HIDWORD(v13) && (_DWORD)v13 == a2)
  {
    *a3 = 1;
    *a4 = LDOLabel_GetAbsoluteFrom(a1);
    *a5 = LDOLabel_GetAbsoluteTo(a1);
  }
  return v11;
}

uint64_t abbrtn_load_lua_code(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int IsLuaCodeAvailable;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int ScriptFromRIFF;
  int IsLuaFunctionAvailable;
  int v16;

  v16 = 0;
  if (*a4)
  {
    OOC_PlacementDeleteObject(a3, *a4);
    *a4 = 0;
  }
  IsLuaCodeAvailable = LuaVMLDO_IsLuaCodeAvailable(a1, a2, 0, &v16);
  v9 = LH_ERROR_to_VERROR(IsLuaCodeAvailable);
  v10 = v16;
  if ((v9 & 0x80000000) != 0 || v16 != 1)
  {
LABEL_8:
    if ((v9 & 0x80000000) == 0 && v10)
      return v9;
    goto LABEL_12;
  }
  v16 = 0;
  v11 = PNEW_LuaVMLDO_Con(a3, a3, (uint64_t)a1, a2, (uint64_t)abbrtn_hlp_lua_log_callback, (uint64_t **)a4);
  v12 = LH_ERROR_to_VERROR(v11);
  if ((v12 & 0x80000000) == 0)
  {
    ScriptFromRIFF = LuaVMLDO_LoadScriptFromRIFF(*a4, 0);
    v12 = LH_ERROR_to_VERROR(ScriptFromRIFF);
    if ((v12 & 0x80000000) == 0)
    {
      IsLuaFunctionAvailable = LuaVMLDO_IsLuaFunctionAvailable(*a4, (uint64_t)"runAbbrtn", &v16);
      v9 = LH_ERROR_to_VERROR(IsLuaFunctionAvailable);
      v10 = v16;
      goto LABEL_8;
    }
  }
  v9 = v12;
LABEL_12:
  if (*a4)
  {
    OOC_PlacementDeleteObject(a3, *a4);
    *a4 = 0;
  }
  return v9;
}

uint64_t abbrtn_hlp_lua_log_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_ABBRTN", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t abbrtn_dumpNodes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int U32Attribute;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v31 = 0;
  v29 = 0;
  log_OutText(*(_QWORD *)(a1 + 32), a2, 4, 0, (uint64_t)"abbrtn_dumpNodes : %s : Start", a6, a7, a8, a5);
  v12 = LDO_ComputeText(a3, &v29);
  v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) == 0)
  {
    v14 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v29);
    log_OutText(*(_QWORD *)(a1 + 32), a2, 4, 0, (uint64_t)"LDO text |%s|", v15, v16, v17, v14);
    v21 = *(_QWORD *)(a3 + 16);
    v22 = *(uint64_t **)(v21 + 80);
    if ((unint64_t)v22 >= *(_QWORD *)(v21 + 88))
    {
LABEL_13:
      log_OutText(*(_QWORD *)(a1 + 32), a2, 4, 0, (uint64_t)"abbrtn_dumpNodes : End", v18, v19, v20, 0);
    }
    else
    {
      v23 = 0;
      while (1)
      {
        v24 = LDOTreeNode_ComputeAbsoluteFrom(*v22, &v31);
        v25 = LH_ERROR_to_VERROR(v24);
        if ((v25 & 0x80000000) != 0)
          break;
        v26 = LDOTreeNode_ComputeAbsoluteTo(*v22, (_DWORD *)&v30 + 1);
        v25 = LH_ERROR_to_VERROR(v26);
        if ((v25 & 0x80000000) != 0)
          break;
        U32Attribute = LDOObject_GetU32Attribute((uint64_t *)*v22, "_TTYPE", (_DWORD *)&v31 + 1, &v30);
        v13 = LH_ERROR_to_VERROR(U32Attribute);
        if ((v13 & 0x80000000) != 0)
          goto LABEL_15;
        if (HIDWORD(v31) == 1)
        {
          if ((HIDWORD(v30) - v31) < 0x80)
          {
            __strncpy_chk();
            v32[(HIDWORD(v30) - v31)] = 0;
          }
          else
          {
            strcpy(v32, "(TOKEN TOO LONG)");
          }
          log_OutText(*(_QWORD *)(a1 + 32), a2, 4, 0, (uint64_t)"[%d] %s %d,%d |%s|", v18, v19, v20, (unsigned __int16)v23++);
        }
        if ((unint64_t)++v22 >= *(_QWORD *)(v21 + 88))
          goto LABEL_13;
      }
      v13 = v25;
    }
  }
LABEL_15:
  if (v29)
    OOC_PlacementDeleteObject(a4, v29);
  return v13;
}

uint64_t abbrtn_dumpLabels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  unsigned __int16 v22;
  char *v23;
  uint64_t *v24;
  int AbsoluteFrom;
  int AbsoluteTo;
  int U32Attribute;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  int v34;
  unsigned int v35;
  int v36;
  int StringAttribute;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60[128];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v58 = 0;
  v59 = 0;
  v56 = 0;
  v57 = 0;
  log_OutText(*(_QWORD *)(a1 + 32), a2, 4, 0, (uint64_t)"abbrtn_dumpLabels : %s : Start", a6, a7, a8, a5);
  v12 = LDO_ComputeText(a3, &v58);
  v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) == 0)
  {
    v54 = a4;
    v53 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v58);
    v55 = a2;
    log_OutText(*(_QWORD *)(a1 + 32), a2, 4, 0, (uint64_t)"LDO text |%s|", v14, v15, v16, v53);
    v20 = *(_QWORD *)(a3 + 32);
    v21 = *(uint64_t **)(v20 + 24);
    if ((unint64_t)v21 >= *(_QWORD *)(v20 + 32))
    {
LABEL_29:
      log_OutText(*(_QWORD *)(a1 + 32), v55, 4, 0, (uint64_t)"abbrtn_dumpLabels : End", v17, v18, v19, 0);
    }
    else
    {
      v22 = 0;
      v23 = "_TTYPE";
      while (1)
      {
        v24 = (uint64_t *)*v21;
        AbsoluteFrom = LDOLabel_GetAbsoluteFrom(*v21);
        AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v24);
        U32Attribute = LDOObject_GetU32Attribute(v24, v23, &v59, (_DWORD *)&v59 + 1);
        v28 = LH_ERROR_to_VERROR(U32Attribute);
        if ((v28 & 0x80000000) != 0)
          break;
        if ((_DWORD)v59 == 1)
        {
          v32 = a3;
          v33 = v23;
          v34 = HIDWORD(v59);
          v35 = AbsoluteTo - AbsoluteFrom;
          if (AbsoluteTo == AbsoluteFrom)
          {
            strcpy(v60, "NULL");
          }
          else if (v35 < 0x80)
          {
            __strncpy_chk();
            v60[v35] = 0;
          }
          else
          {
            strcpy(v60, "(TOKEN TOO LONG)");
          }
          v36 = v34 - 4;
          v23 = v33;
          switch(v36)
          {
            case 0:
              log_OutText(*(_QWORD *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN_DCT %d,%d |%s|", v29, v30, v31, v22);
              goto LABEL_22;
            case 1:
              StringAttribute = LDOObject_GetStringAttribute(v24, "TNTAG", &v59, &v57);
              v28 = LH_ERROR_to_VERROR(StringAttribute);
              if ((v28 & 0x80000000) != 0)
                goto LABEL_30;
              a3 = v32;
              v41 = *(_QWORD *)(a1 + 32);
              if ((_DWORD)v59 == 1)
                log_OutText(v41, v55, 4, 0, (uint64_t)"[%d] TOKEN_USER_TN %d,%d |%s| (%s)", v38, v39, v40, v22);
              else
                log_OutText(v41, v55, 4, 0, (uint64_t)"[%d] TOKEN_USER_TN %d,%d |%s| (no TNTAG)", v38, v39, v40, v22);
              break;
            case 2:
              v42 = LDOObject_GetStringAttribute(v24, "LANGMAP", &v59, &v56);
              v28 = LH_ERROR_to_VERROR(v42);
              if ((v28 & 0x80000000) != 0)
                goto LABEL_30;
              a3 = v32;
              v46 = *(_QWORD *)(a1 + 32);
              if ((_DWORD)v59 == 1)
                log_OutText(v46, v55, 4, 0, (uint64_t)"[%d] TOKEN_INT_TN %d,%d |%s| LANGMAP=\"%s\"", v43, v44, v45, v22);
              else
                log_OutText(v46, v55, 4, 0, (uint64_t)"[%d] TOKEN_INT_TN %d,%d |%s|", v43, v44, v45, v22);
              break;
            case 3:
              log_OutText(*(_QWORD *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN_CASEGENDER %d,%d |%s|", v29, v30, v31, v22);
              goto LABEL_22;
            case 4:
              log_OutText(*(_QWORD *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN_DEPES %d,%d |%s|", v29, v30, v31, v22);
              goto LABEL_22;
            default:
              log_OutText(*(_QWORD *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN type=%d %d,%d |%s|", v29, v30, v31, v22);
              v23 = v33;
LABEL_22:
              a3 = v32;
              break;
          }
        }
        v47 = LDOObject_GetU32Attribute(v24, "_MTYPE", &v59, (_DWORD *)&v59 + 1);
        v13 = LH_ERROR_to_VERROR(v47);
        if ((v13 & 0x80000000) != 0)
          goto LABEL_31;
        if ((_DWORD)v59 == 1)
        {
          v48 = *(_QWORD *)(a1 + 32);
          marker_getString(SHIDWORD(v59));
          log_OutText(v48, v55, 4, 0, (uint64_t)"[%d] MARKER %s %d,%d", v49, v50, v51, v22);
        }
        ++v22;
        if ((unint64_t)++v21 >= *(_QWORD *)(*(_QWORD *)(a3 + 32) + 32))
          goto LABEL_29;
      }
LABEL_30:
      v13 = v28;
    }
LABEL_31:
    a4 = v54;
  }
  if (v58)
    OOC_PlacementDeleteObject(a4, v58);
  return v13;
}

uint64_t abbrtn_process_ldo_with_lua(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v33;
  uint64_t v34;

  v34 = 0;
  v10 = LDO_ComputeText(a3, &v34);
  v11 = LH_ERROR_to_VERROR(v10);
  if ((v11 & 0x80000000) == 0)
  {
    v12 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v34);
    if (v12)
    {
      log_OutText(*(_QWORD *)(a1 + 32), a2, 5, 0, (uint64_t)"LDO sentence: %s", v13, v14, v15, v12);
      v19 = abbrtn_dumpNodes(a1, a2, a3, a4, (uint64_t)"abbrtn: before Lua", v16, v17, v18);
      if ((v19 & 0x80000000) != 0
        || (v19 = abbrtn_dumpLabels(a1, a2, a3, a4, (uint64_t)"abbrtn: before Lua", v20, v21, v22),
            (v19 & 0x80000000) != 0))
      {
LABEL_8:
        v11 = v19;
        goto LABEL_9;
      }
      v23 = LuaVMLDO_RunFunction(a5, (uint64_t)"runAbbrtn", a3);
      v24 = LH_ERROR_to_VERROR(v23);
      if ((v24 & 0x80000000) == 0)
      {
        v19 = abbrtn_dumpNodes(a1, a2, a3, a4, (uint64_t)"abbrtn: after Lua", v26, v27, v28);
        if ((v19 & 0x80000000) == 0)
          v19 = abbrtn_dumpLabels(a1, a2, a3, a4, (uint64_t)"abbrtn: after Lua", v29, v30, v31);
        goto LABEL_8;
      }
      v11 = v24;
      log_OutPublic(*(_QWORD *)(a1 + 32), a2, 32004, 0, v25, v26, v27, v28, v33);
    }
  }
LABEL_9:
  if (v34)
    OOC_PlacementDeleteObject(a4, v34);
  return v11;
}

uint64_t fe_abbrtn_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2310021121;
  result = 0;
  *a2 = &IFeAbbrtn;
  return result;
}

uint64_t fe_abbrtn_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2310021127;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_abbrtn_ClassClose()
{
  return 0;
}

uint64_t fe_abbrtn_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t Object;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;

  v36 = 0;
  v37 = 0;
  v5 = 2310021127;
  v34 = 0;
  v35 = 0;
  if (!a5)
    return v5;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v37);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = objc_GetObject(v37[6], (uint64_t)"LINGDB", &v36);
  if ((inited & 0x80000000) != 0)
    return inited;
  Object = objc_GetObject(v37[6], (uint64_t)"FE_DCTLKP", &v35);
  v13 = v37[6];
  if ((Object & 0x80000000) != 0)
  {
    v32 = "LINGDB";
LABEL_13:
    objc_ReleaseObject(v13, (uint64_t)v32);
    return Object;
  }
  v14 = objc_GetObject(v13, (uint64_t)"FE_DEPES", &v34);
  if ((v14 & 0x80000000) != 0)
  {
    Object = v14;
    objc_ReleaseObject(v37[6], (uint64_t)"LINGDB");
    v13 = v37[6];
    v32 = "FE_DCTLKP";
    goto LABEL_13;
  }
  v15 = heap_Alloc(v37[1], 216);
  if (v15)
  {
    v20 = v15;
    *(_QWORD *)v15 = a1;
    *(_QWORD *)(v15 + 8) = a2;
    v22 = v36;
    v21 = v37;
    *(_QWORD *)(v15 + 16) = v37;
    *(_QWORD *)(v15 + 24) = a3;
    *(_QWORD *)(v15 + 32) = a4;
    *(_QWORD *)(v15 + 40) = *(_QWORD *)(v22 + 8);
    v23 = v35;
    *(_QWORD *)(v15 + 64) = *(_QWORD *)(v35 + 8);
    *(_OWORD *)(v15 + 48) = *(_OWORD *)(v23 + 16);
    v24 = v34;
    *(_QWORD *)(v15 + 88) = *(_QWORD *)(v34 + 8);
    v25 = *(_OWORD *)(v24 + 16);
    *(_QWORD *)(v15 + 120) = heap_Alloc;
    *(_OWORD *)(v15 + 72) = v25;
    *(_QWORD *)(v15 + 96) = 0;
    *(_QWORD *)(v15 + 104) = 0;
    *(_QWORD *)(v15 + 192) = 0;
    *(_QWORD *)(v15 + 200) = 0;
    *(_QWORD *)(v15 + 208) = "FE_ABBRTN";
    *(_QWORD *)(v15 + 128) = heap_Calloc;
    *(_QWORD *)(v15 + 136) = heap_Realloc;
    *(_QWORD *)(v15 + 144) = heap_Free;
    v26 = OOCAllocator_Con(v15 + 152, (_OWORD *)(v15 + 120), v21[1]);
    v27 = LH_ERROR_to_VERROR(v26);
    if ((v27 & 0x80000000) != 0)
    {
      v5 = v27;
      log_OutPublic(v37[4], (uint64_t)"FE_ABBRTN", 32003, 0, v28, v29, v30, v31, v34);
LABEL_17:
      fe_abbrtn_ObjClose(*(_QWORD **)a5, *(_QWORD *)(a5 + 8));
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      return v5;
    }
    *(_QWORD *)a5 = v20;
    *(_DWORD *)(a5 + 8) = 62338;
    v5 = fe_abbrtn_ObjReopen(v20, *(_QWORD *)(a5 + 8));
    if ((v5 & 0x80000000) != 0)
      goto LABEL_17;
  }
  else
  {
    log_OutPublic(v37[4], (uint64_t)"FE_ABBRTN", 32000, 0, v16, v17, v18, v19, v34);
    objc_ReleaseObject(v37[6], (uint64_t)"LINGDB");
    objc_ReleaseObject(v37[6], (uint64_t)"FE_DCTLKP");
    objc_ReleaseObject(v37[6], (uint64_t)"FE_DEPES");
    return 2310021130;
  }
  return v5;
}

uint64_t fe_abbrtn_ObjClose(_QWORD *a1, int a2)
{
  uint64_t result;

  result = safeh_HandleCheck((uint64_t)a1, a2, 62338, 216);
  if ((result & 0x80000000) != 0)
    return 2310021128;
  if (a1)
  {
    luavmldoutil_destroy_lua_vm((uint64_t)(a1 + 19), a1 + 25);
    kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 19));
    objc_ReleaseObject(*(_QWORD *)(a1[2] + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(_QWORD *)(a1[2] + 48), (uint64_t)"FE_DCTLKP");
    objc_ReleaseObject(*(_QWORD *)(a1[2] + 48), (uint64_t)"FE_DEPES");
    heap_Free(*(_QWORD **)(a1[2] + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_abbrtn_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result;
  const char *v4;
  char *v5;
  _BYTE __c[11];

  result = safeh_HandleCheck(a1, a2, 62338, 216);
  if ((result & 0x80000000) != 0)
    return 2310021128;
  if (!a1)
    return result;
  *(_BYTE *)(a1 + 112) = 1;
  *(_QWORD *)&__c[3] = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 64) + 96))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), "fecfg", "nrpart_tn", &__c[3], &__c[1], __c);
  if ((result & 0x80000000) != 0 || !*(_WORD *)&__c[1])
  {
    if ((result & 0x80000000) != 0)
      return result;
  }
  else
  {
    v4 = **(const char ***)&__c[3];
    v5 = strchr(**(char ***)&__c[3], __c[0]);
    if (v5)
    {
      *v5 = 0;
      v4 = **(const char ***)&__c[3];
    }
    *(_BYTE *)(a1 + 112) = atoi(v4);
  }
  luavmldoutil_destroy_lua_vm(a1 + 152, (uint64_t *)(a1 + 200));
  return abbrtn_load_lua_code(*(_WORD **)(a1 + 24), *(_QWORD *)(a1 + 32), a1 + 152, (uint64_t *)(a1 + 200));
}

uint64_t fe_abbrtn_ProcessStart(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62338, 216);
  if ((int)result >= 0)
    return result;
  else
    return 2310021128;
}

uint64_t fe_abbrtn_Process(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t inited;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t **v17;
  uint64_t **v18;
  unsigned int v19;
  uint64_t *v20;
  int U32Attribute;
  uint64_t **v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t **v28;
  unint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  unsigned __int16 AbsoluteFrom;
  __int16 AbsoluteTo;
  int StringAttribute;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  char *__s1;
  int v47;

  v47 = 0;
  __s1 = 0;
  v45 = 0;
  v43 = 0;
  v44 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62338, 216) & 0x80000000) != 0)
    return 2310021128;
  *a5 = 1;
  v9 = LingDBHasSentence(a1[5], a3, a4, &v45);
  v10 = 0;
  if ((v9 & 0x80000000) != 0 || v45 != 1)
  {
LABEL_48:
    if ((v9 & 0x80000000) != 0)
      goto LABEL_52;
    goto LABEL_49;
  }
  v11 = (uint64_t)(a1 + 19);
  v12 = a1 + 24;
  inited = initLDO((uint64_t)(a1 + 19), a1 + 24);
  if ((inited & 0x80000000) != 0)
  {
LABEL_45:
    v9 = inited;
    goto LABEL_46;
  }
  v9 = importFromLingDB(a1[2], a1[5], a3, a4, a1 + 24);
  if ((v9 & 0x80000000) != 0)
  {
LABEL_46:
    v10 = 0;
    goto LABEL_52;
  }
  if (!*v12)
  {
    v10 = 0;
    goto LABEL_48;
  }
  v14 = LDO_ComputeText(*v12, &v44);
  inited = LH_ERROR_to_VERROR(v14);
  if ((inited & 0x80000000) != 0)
    goto LABEL_45;
  v15 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v44);
  v16 = *(_QWORD *)(*v12 + 32);
  v17 = *(uint64_t ***)(v16 + 24);
  if ((unint64_t)v17 >= *(_QWORD *)(v16 + 32))
  {
    v10 = 0;
  }
  else
  {
    v42 = (const char *)v15;
    v18 = 0;
    v10 = 0;
    v19 = 0;
    do
    {
      v20 = *v17;
      if (*((_DWORD *)*v17 + 26))
      {
        LODWORD(v43) = 0;
        U32Attribute = LDOObject_GetU32Attribute(v20, "_TTYPE", &v43, (_DWORD *)&v43 + 1);
        v9 = LH_ERROR_to_VERROR(U32Attribute);
        if ((v9 & 0x80000000) != 0)
          goto LABEL_52;
        if ((_DWORD)v43 == 1 && HIDWORD(v43) == 5)
        {
          v23 = v18;
          v24 = (unint64_t)v18 - v10;
          v25 = (v24 >> 3) + 1;
          if (v25 <= v19)
          {
            v28 = v23;
          }
          else
          {
            v26 = 2 * v19;
            if (2 * v19 >= v19 + 1000000)
              v26 = v19 + 1000000;
            if (v26 > v25)
              v25 = v26;
            if (v25 <= 8)
              v19 = 8;
            else
              v19 = v25;
            v27 = OOCAllocator_Realloc((uint64_t)(a1 + 19), v10, 8 * v19, &v47);
            v10 = v27;
            if (v47)
              goto LABEL_48;
            v28 = (uint64_t **)(v27 + (v24 & 0x7FFFFFFF8));
          }
          *v28 = v20;
          v18 = v28 + 1;
        }
      }
      ++v17;
    }
    while ((unint64_t)v17 < *(_QWORD *)(*(_QWORD *)(*v12 + 32) + 32));
    if (v10 < (unint64_t)v18)
    {
      v29 = (unint64_t)v18;
      v30 = (uint64_t *)v10;
      do
      {
        v31 = (uint64_t *)*v30;
        if (*(_DWORD *)(*v30 + 104))
        {
          AbsoluteFrom = LDOLabel_GetAbsoluteFrom(*v30);
          AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v31);
          StringAttribute = LDOObject_GetStringAttribute(v31, "TNTAG", &v43, (uint64_t *)&__s1);
          v35 = LH_ERROR_to_VERROR(StringAttribute);
          if ((v35 & 0x80000000) != 0)
            goto LABEL_51;
          v36 = __s1;
          if (!strstr(__s1, "spell"))
          {
            if (strcmp(v36, "phon"))
            {
              if (!strstr(v36, "prompt")
                && !strstr(v36, "raw")
                && !strstr(v36, "RAW")
                && !strstr(v36, "internal-nuance-system-norm"))
              {
                v35 = abbrtn_TnLookup(a1, v42, AbsoluteFrom, AbsoluteTo, v36, (uint64_t)v31);
                if ((v35 & 0x80000000) != 0)
                  goto LABEL_51;
              }
            }
          }
        }
        ++v30;
      }
      while ((unint64_t)v30 < v29);
    }
    v11 = (uint64_t)(a1 + 19);
  }
  v35 = abbrtn_sanitizeTokenDCTAndIntTN((uint64_t)a1);
  if ((v35 & 0x80000000) != 0
    || (v41 = a1[25]) != 0
    && (v35 = abbrtn_process_ldo_with_lua(a1[2], a1[26], a1[24], v11, v41), (v35 & 0x80000000) != 0))
  {
LABEL_51:
    v9 = v35;
    goto LABEL_52;
  }
  v9 = exportToLingDB(a1[2], a1[5], a3, a4, v11, a1[24], 1, 0);
  if ((v9 & 0x80000000) != 0)
    goto LABEL_52;
LABEL_49:
  if (v47)
  {
    v35 = LH_ERROR_to_VERROR(v47);
    goto LABEL_51;
  }
LABEL_52:
  v37 = a1[12];
  if (v37)
  {
    heap_Free(*(_QWORD **)(a1[2] + 8), v37);
    a1[12] = 0;
  }
  v38 = a1[13];
  if (v38)
  {
    heap_Free(*(_QWORD **)(a1[2] + 8), v38);
    a1[13] = 0;
  }
  if (v44)
  {
    OOC_PlacementDeleteObject((uint64_t)(a1 + 19), v44);
    v44 = 0;
  }
  if (v10)
    OOCAllocator_Free((uint64_t)(a1 + 19), v10);
  v39 = a1[24];
  if (v39)
  {
    deinitLDO((uint64_t)(a1 + 19), v39);
    a1[24] = 0;
  }
  return v9;
}

uint64_t fe_abbrtn_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62338, 216);
  if ((int)result >= 0)
    return result;
  else
    return 2310021128;
}

uint64_t fe_dctlkp_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t CanonMap;
  uint64_t inited;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t *v18;
  uint64_t BrokerString;
  _DWORD *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  const char *v35;
  char *v36;
  int v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v47;
  uint64_t v48;
  _BYTE *v49;
  _BYTE __c[11];
  uint64_t v51;
  uint64_t *v52;

  v51 = 0;
  v52 = 0;
  CanonMap = 2306875402;
  v49 = 0;
  if (!a5)
    return 2306875399;
  memset(__c, 0, sizeof(__c));
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v52);
  if ((inited & 0x80000000) != 0)
    return inited;
  log_OutText(v52[4], (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ObjOpen", v8, v9, v10, v47);
  inited = objc_GetObject(v52[6], (uint64_t)"LINGDB", &v51);
  if ((inited & 0x80000000) != 0)
    return inited;
  v11 = heap_Calloc((_QWORD *)v52[1], 1, 3696);
  if (v11)
  {
    v16 = v11;
    *(_QWORD *)a5 = v11;
    *(_DWORD *)(a5 + 8) = 62335;
    *(_QWORD *)(v11 + 568) = *(_QWORD *)(v51 + 8);
    *(_QWORD *)v11 = v52;
    *(_WORD *)(v11 + 1632) = 1;
    *(_DWORD *)(v11 + 2660) = 1;
    *(_QWORD *)(v11 + 496) = 0;
    *(_DWORD *)(v11 + 488) = 0;
    v17 = (_DWORD *)(v11 + 8);
    *(_WORD *)(v11 + 80) = 0;
    *(_WORD *)(v11 + 160) = 0;
    *(_WORD *)(v11 + 240) = 0;
    *(_WORD *)(v11 + 320) = 0;
    *(_WORD *)(v11 + 400) = 0;
    *(_WORD *)(v11 + 480) = 0;
    v18 = (uint64_t *)(v11 + 16);
    set_DctBrk(v11 + 16, v52[3]);
    set_DctBrk(v16 + 96, v52[3]);
    set_DctBrk(v16 + 176, v52[3]);
    set_DctBrk(v16 + 256, v52[3]);
    set_DctBrk(v16 + 336, v52[3]);
    set_DctBrk(v16 + 416, v52[3]);
    *(_QWORD *)(v16 + 64) = 0;
    *(_QWORD *)(v16 + 144) = 0;
    *(_QWORD *)(v16 + 224) = 0;
    *(_QWORD *)(v16 + 304) = 0;
    *(_QWORD *)(v16 + 384) = 0;
    *(_QWORD *)(v16 + 464) = 0;
    *(_DWORD *)(v16 + 152) = 0;
    *(_DWORD *)(v16 + 232) = 0;
    *(_DWORD *)(v16 + 72) = 0;
    *(_DWORD *)(v16 + 312) = 0;
    *(_DWORD *)(v16 + 392) = 0;
    *(_DWORD *)(v16 + 472) = 0;
    if ((hlp_CreateBrokerString((uint64_t)v52, (char *)(v16 + 1634), 0) & 0x80000000) != 0
      || (open_DctRom(v18, v16 + 1634, v17) & 0x80000000) != 0)
    {
      BrokerString = hlp_CreateBrokerString((uint64_t)v52, (char *)(v16 + 1634), 1);
      if ((BrokerString & 0x80000000) != 0)
        goto LABEL_48;
      BrokerString = open_DctRom(v18, v16 + 1634, v17);
      if ((BrokerString & 0x80000000) != 0)
        goto LABEL_48;
    }
    if ((hlp_CreateVoiceBrokerString((uint64_t)v52, (char *)(v16 + 1890), 1) & 0x80000000) != 0
      || (open_DctRom((uint64_t *)(v16 + 336), v16 + 1890, (_DWORD *)(v16 + 328)) & 0x80000000) != 0)
    {
      BrokerString = hlp_CreateVoiceBrokerString((uint64_t)v52, (char *)(v16 + 1890), 0);
      if ((BrokerString & 0x80000000) != 0)
        goto LABEL_48;
      if ((open_DctRom((uint64_t *)(v16 + 336), v16 + 1890, (_DWORD *)(v16 + 328)) & 0x80000000) != 0)
        *(_DWORD *)(v16 + 328) = 0;
    }
    v20 = (_DWORD *)(v16 + 88);
    v21 = 0;
    if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)v16 + 40), (uint64_t)"clcpppipelinemode", &v49) & 0x80000000) == 0
      && v49)
    {
      v21 = *v49 != 0;
    }
    v22 = open_DctRom((uint64_t *)(v16 + 96), (uint64_t)"sysdct", (_DWORD *)(v16 + 88));
    CanonMap = v22;
    if (!v21 && (v22 & 0x80000000) != 0)
    {
      *(_DWORD *)(v16 + 168) = 0;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)v16 + 32), (uint64_t)"FE_DCTLKP", 41005, "%s", v23, v24, v25, v26, "sysdct.dat not found");
      goto LABEL_50;
    }
    v27 = !v21;
    if ((int)v22 >= 0)
      v27 = 1;
    if ((v27 & 1) == 0)
      *v20 = 0;
    v28 = open_DctRom((uint64_t *)(v16 + 176), (uint64_t)"lid", (_DWORD *)(v16 + 168));
    v33 = (int)v28 >= 0 || v21;
    if ((v33 & 1) == 0)
    {
      CanonMap = v28;
      *(_DWORD *)(v16 + 168) = 0;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)v16 + 32), (uint64_t)"FE_DCTLKP", 41007, "%s", v29, v30, v31, v32, "lid.dat not found");
      goto LABEL_50;
    }
    v34 = !v21;
    if ((int)v28 >= 0)
      v34 = 1;
    if ((v34 & 1) == 0)
      *v20 = 0;
    if ((open_DctRom((uint64_t *)(v16 + 416), (uint64_t)"clmnn:clmnndic", (_DWORD *)(v16 + 408)) & 0x80000000) != 0)
      *(_DWORD *)(v16 + 408) = 0;
    hlp_OpenMl2Dct((uint64_t)v52, v16);
    *(_WORD *)&__c[1] = -1;
    BrokerString = loc_fe_dctlkp_LookupUtf(*(_QWORD *)a5, *(_QWORD *)(a5 + 8), "fecfg", "punc", &__c[3], &__c[1], __c, 0);
    if ((BrokerString & 0x80000000) == 0)
    {
      if (*(_QWORD *)&__c[3])
      {
        v35 = **(const char ***)&__c[3];
        v36 = strchr(**(char ***)&__c[3], __c[0]);
        if (v36)
        {
          *v36 = 0;
          v35 = **(const char ***)&__c[3];
        }
        v37 = strlen(v35);
        v38 = (char *)heap_Alloc(v52[1], (v37 + 1));
        *(_QWORD *)(v16 + 504) = v38;
        if (v38)
        {
          strcpy(v38, **(const char ***)&__c[3]);
          *(_WORD *)&__c[1] = -1;
          BrokerString = loc_fe_dctlkp_LookupUtf(*(_QWORD *)a5, *(_QWORD *)(a5 + 8), "fecfg", "canonmapdomain", &__c[3], &__c[1], __c, 0);
          if ((BrokerString & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
              *(_DWORD *)(v16 + 2660) = 0;
            BrokerString = loc_fe_dctlkp_getDomainTokenDefs(*(_QWORD *)a5, *(_QWORD *)(a5 + 8), v16);
            if ((BrokerString & 0x80000000) == 0)
            {
              strcpy((char *)(v16 + 2402), "normal");
              *(_QWORD *)(v16 + 584) = 0;
              *(_QWORD *)(v16 + 2664) = 0;
              CanonMap = LoadCanonMap(*(_QWORD *)a5, *(_QWORD *)(a5 + 8));
              if ((CanonMap & 0x80000000) == 0)
              {
LABEL_51:
                log_OutText(v52[4], (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ObjOpen", v43, v44, v45, v48);
                return CanonMap;
              }
LABEL_50:
              fe_dctlkp_ObjClose(*(unsigned __int16 **)a5, *(_QWORD *)(a5 + 8));
              *(_QWORD *)a5 = 0;
              *(_DWORD *)(a5 + 8) = 0;
              goto LABEL_51;
            }
          }
          goto LABEL_48;
        }
        log_OutPublic(*(_QWORD *)(*(_QWORD *)v16 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v39, v40, v41, v42, v48);
      }
      CanonMap = 2306875402;
      goto LABEL_50;
    }
LABEL_48:
    CanonMap = BrokerString;
    goto LABEL_50;
  }
  log_OutPublic(v52[4], (uint64_t)"FE_DCTLKP", 41000, 0, v12, v13, v14, v15, v48);
  objc_ReleaseObject(v52[6], (uint64_t)"LINGDB");
  return CanonMap;
}

uint64_t hlp_CreateBrokerString(uint64_t a1, char *a2, int a3)
{
  uint64_t result;
  char *v7;
  int v8[2];
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v7 = &byte_1DEBD87CE;
  *(_QWORD *)v8 = 0;
  v17 = 0;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    v9 = 0x2F746364737973;
    __strcat_chk();
    if (!a3)
    {
      result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v7);
      if ((result & 0x80000000) != 0)
        return result;
      __strcat_chk();
      __strcat_chk();
    }
    return brokeraux_ComposeBrokerString(a1, (const char *)&v9, 1, 1, *(char **)v8, 0, 0, a2, 0x100uLL);
  }
  return result;
}

uint64_t hlp_CreateVoiceBrokerString(uint64_t a1, char *a2, int a3)
{
  uint64_t result;
  char *v7;
  char *v8;
  const char *v9;
  char *v10;
  char v11[9];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[23];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = 0;
  v8 = 0;
  memset(v18, 0, sizeof(v18));
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", &v10);
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voice", &v9);
    if ((result & 0x80000000) == 0)
    {
      if (a3)
      {
        if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voicemodel", &v8) & 0x80000000) != 0)
        {
          v7 = 0;
          v8 = 0;
        }
        else
        {
          v7 = v8;
        }
      }
      else
      {
        v7 = 0;
      }
      strcpy(v11, "voicedct");
      return brokeraux_ComposeBrokerString(a1, v11, 1, 1, v10, v9, v7, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t hlp_OpenMl2Dct(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char *v5;
  _DWORD *v6;
  uint64_t *v7;
  int v8[2];
  char v9[7];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[25];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(v16, 0, sizeof(v16));
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  *(_QWORD *)v8 = 0;
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    v5 = (char *)(a2 + 2146);
    strcpy(v9, "ml2dct");
    __strcat_chk();
    result = brokeraux_ComposeBrokerString(a1, v9, 1, 0, *(char **)v8, 0, 0, (char *)(a2 + 2146), 0x100uLL);
    if ((result & 0x80000000) == 0)
    {
      v6 = (_DWORD *)(a2 + 248);
      v7 = (uint64_t *)(a2 + 256);
      result = open_DctRom(v7, (uint64_t)v5, v6);
      if ((result & 0x80000000) != 0)
      {
        memset(v16, 0, sizeof(v16));
        v15 = 0u;
        v14 = 0u;
        v13 = 0u;
        v12 = 0u;
        v11 = 0u;
        v10 = 0u;
        *(_QWORD *)v8 = 0;
        result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v8);
        if ((result & 0x80000000) == 0)
        {
          strcpy(v9, "ml2dct");
          result = brokeraux_ComposeBrokerString(a1, v9, 1, 0, *(char **)v8, 0, 0, v5, 0x100uLL);
          if ((result & 0x80000000) == 0)
          {
            result = open_DctRom(v7, (uint64_t)v5, v6);
            if ((result & 0x80000000) != 0)
              *v6 = 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t fe_dctlkp_LookupUtf(uint64_t a1, int a2, char *a3, const char *a4, _QWORD *a5, _WORD *a6, _BYTE *a7)
{
  return loc_fe_dctlkp_LookupUtf(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t loc_fe_dctlkp_getDomainTokenDefs(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 i;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  int v19;
  char *v20;
  uint64_t v21;
  uint64_t TokenDef;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v31;
  _BYTE __c[11];
  char __s[256];
  char __src[256];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&__c[3] = 0;
  __c[0] = 0;
  *(_WORD *)(a3 + 1616) = 0;
  *(_WORD *)&__c[1] = -1;
  v6 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "domdef", &__c[3], &__c[1], __c, 0);
  if ((v6 & 0x80000000) != 0 || *(unsigned __int16 *)&__c[1] != 1)
    return v6;
  __strcpy_chk();
  v7 = strchr(__s, __c[0]);
  if (v7)
    *v7 = 0;
  if (strlen(**(const char ***)&__c[3]) <= 0xFF)
  {
    if (!__s[0])
      return v6;
    v12 = 0;
    while (1)
    {
      for (i = v12; ; i = v14 + 1)
      {
        v14 = i;
        v15 = __s[i];
        if (!v15 || v15 == 44)
          break;
      }
      if ((_DWORD)v14 != v12)
      {
        v16 = v14 - v12;
        __strncpy_chk();
        __src[v16] = 0;
        if (*(_WORD *)(a3 + 1616))
        {
          v17 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a3 + 8), *(_QWORD *)(a3 + 1624), 32 * *(unsigned __int16 *)(a3 + 1616) + 32);
          if (!v17)
            return 2306875402;
          *(_QWORD *)(a3 + 1624) = v17;
        }
        else
        {
          v17 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a3 + 8), 32, 1);
          *(_QWORD *)(a3 + 1624) = v17;
          if (!v17)
            return 2306875402;
        }
        v18 = (_OWORD *)(v17 + 32 * *(unsigned __int16 *)(a3 + 1616));
        *v18 = 0u;
        v18[1] = 0u;
        v19 = strlen(__src);
        v20 = (char *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a3 + 8), (v19 + 1), 1);
        v21 = *(unsigned __int16 *)(a3 + 1616);
        *(_QWORD *)(*(_QWORD *)(a3 + 1624) + 32 * v21) = v20;
        if (!v20)
        {
          *(_WORD *)(a3 + 1616) = v21 + 1;
          return 2306875402;
        }
        strcpy(v20, __src);
        TokenDef = loc_fe_dctlkp_getTokenDef(a1, a2, (uint64_t *)a3, (uint64_t)__src, (uint64_t)"_alpha", (char **)(*(_QWORD *)(a3 + 1624) + 32 * *(unsigned __int16 *)(a3 + 1616) + 8));
        if ((TokenDef & 0x80000000) != 0
          || (TokenDef = loc_fe_dctlkp_getTokenDef(a1, a2, (uint64_t *)a3, (uint64_t)__src, (uint64_t)"_digit", (char **)(*(_QWORD *)(a3 + 1624) + 32 * *(unsigned __int16 *)(a3 + 1616) + 16)), (TokenDef & 0x80000000) != 0))
        {
          v6 = TokenDef;
LABEL_30:
          ++*(_WORD *)(a3 + 1616);
          return v6;
        }
        v6 = loc_fe_dctlkp_getTokenDef(a1, a2, (uint64_t *)a3, (uint64_t)__src, (uint64_t)"_punc", (char **)(*(_QWORD *)(a3 + 1624) + 32 * *(unsigned __int16 *)(a3 + 1616) + 24));
        if ((v6 & 0x80000000) != 0)
          goto LABEL_30;
        v27 = *(_QWORD *)(a3 + 1624);
        v28 = *(unsigned __int16 *)(a3 + 1616);
        v29 = v27 + 32 * v28;
        if (!*(_QWORD *)(v29 + 8) && !*(_QWORD *)(v29 + 16) && !*(_QWORD *)(v27 + 32 * v28 + 24))
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)a3 + 32), (uint64_t)"FE_DCTLKP", 41004, "%s%s", v23, v24, v25, v26, __src);
          ++*(_WORD *)(a3 + 1616);
          return 2306875392;
        }
        *(_WORD *)(a3 + 1616) = v28 + 1;
        v12 = v14 + 1;
      }
      if (!__s[v12])
        return v6;
    }
  }
  log_OutPublic(*(_QWORD *)(*(_QWORD *)a3 + 32), (uint64_t)"FE_DCTLKP", 41003, 0, v8, v9, v10, v11, v31);
  return 2306875392;
}

uint64_t LoadCanonMap(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unsigned __int8 *v8;
  const char *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unsigned int v18;
  unint64_t v19;
  unsigned __int8 *v20;
  const char *v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  char *v25;
  int v26;
  const char *v27;
  char *v28;
  uint64_t v29;
  uint64_t i;
  uint64_t v31;
  uint64_t j;
  unsigned int v34;
  _BYTE __c[11];
  char v36[264];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v2 = 2306875402;
  if (!a1)
    return 2306875400;
  memset(__c, 0, sizeof(__c));
  bzero((void *)(a1 + 592), 0x400uLL);
  bzero((void *)(a1 + 2672), 0x400uLL);
  strcpy(v36, "canonmap_");
  __strcat_chk();
  v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0)
    return v5;
  v6 = *(unsigned __int16 *)&__c[1];
  if (*(_WORD *)&__c[1])
    goto LABEL_53;
  *(_WORD *)&__c[1] = 0;
  strcpy(v36, "canonmap");
  v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0)
    return v5;
  v6 = *(unsigned __int16 *)&__c[1];
  if (*(_WORD *)&__c[1])
  {
LABEL_53:
    if (*(_QWORD *)(a1 + 584))
      goto LABEL_5;
    v29 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 2048);
    *(_QWORD *)(a1 + 584) = v29;
    if (!v29)
      goto LABEL_49;
    for (i = 0; i != 2048; i += 8)
      *(_QWORD *)(*(_QWORD *)(a1 + 584) + i) = 0;
    v6 = *(unsigned __int16 *)&__c[1];
    if (*(_WORD *)&__c[1])
    {
LABEL_5:
      v7 = 0;
      do
      {
        v8 = *(unsigned __int8 **)(*(_QWORD *)&__c[3] + 8 * v7);
        v11 = *v8;
        v9 = (const char *)(v8 + 2);
        v10 = v11;
        *(_DWORD *)(a1 + 4 * v11 + 592) = 1;
        if (!*(_QWORD *)(*(_QWORD *)(a1 + 584) + 8 * v11))
        {
          v12 = strlen(v9);
          *(_QWORD *)(*(_QWORD *)(a1 + 584) + 8 * v10) = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v12 + 1));
          v17 = *(char **)(*(_QWORD *)(a1 + 584) + 8 * v10);
          if (!v17)
            goto LABEL_49;
          strcpy(v17, v9);
          v6 = *(unsigned __int16 *)&__c[1];
        }
        ++v7;
      }
      while (v7 < v6);
    }
  }
  *(_WORD *)&__c[1] = 0;
  strcpy(v36, "canonmapg2pdct_");
  __strcat_chk();
  v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0)
    return v5;
  v18 = *(unsigned __int16 *)&__c[1];
  if (*(_WORD *)&__c[1])
    goto LABEL_12;
  *(_WORD *)&__c[1] = 0;
  strcpy(v36, "canonmapg2pdct");
  v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0)
    return v5;
  v18 = *(unsigned __int16 *)&__c[1];
  if (!*(_WORD *)&__c[1])
    goto LABEL_18;
LABEL_12:
  if (!*(_QWORD *)(a1 + 2664))
  {
    v31 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 2048);
    *(_QWORD *)(a1 + 2664) = v31;
    if (v31)
    {
      for (j = 0; j != 2048; j += 8)
        *(_QWORD *)(*(_QWORD *)(a1 + 2664) + j) = 0;
      v18 = *(unsigned __int16 *)&__c[1];
      if (!*(_WORD *)&__c[1])
        goto LABEL_18;
      goto LABEL_13;
    }
LABEL_49:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v13, v14, v15, v16, v34);
    return v2;
  }
LABEL_13:
  v19 = 0;
  do
  {
    v20 = *(unsigned __int8 **)(*(_QWORD *)&__c[3] + 8 * v19);
    v23 = *v20;
    v21 = (const char *)(v20 + 2);
    v22 = v23;
    *(_DWORD *)(a1 + 4 * v23 + 2672) = 1;
    if (!*(_QWORD *)(*(_QWORD *)(a1 + 2664) + 8 * v23))
    {
      v24 = strlen(v21);
      *(_QWORD *)(*(_QWORD *)(a1 + 2664) + 8 * v22) = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v24 + 1));
      v25 = *(char **)(*(_QWORD *)(a1 + 2664) + 8 * v22);
      if (!v25)
        goto LABEL_49;
      strcpy(v25, v21);
      v18 = *(unsigned __int16 *)&__c[1];
    }
    ++v19;
  }
  while (v19 < v18);
LABEL_18:
  *(_WORD *)&__c[1] = -1;
  strcpy(v36, "canonmapusage_");
  __strcat_chk();
  v2 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v2 & 0x80000000) == 0)
  {
    v26 = *(unsigned __int16 *)&__c[1];
    if (!*(_WORD *)&__c[1])
    {
      *(_WORD *)&__c[1] = -1;
      strcpy(v36, "canonmapusage");
      v2 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
      if ((v2 & 0x80000000) != 0)
        return v2;
      v26 = *(unsigned __int16 *)&__c[1];
    }
    if (v26 == 1)
    {
      v27 = **(const char ***)&__c[3];
      v28 = strchr(**(char ***)&__c[3], __c[0]);
      if (v28)
      {
        *v28 = 0;
        v27 = **(const char ***)&__c[3];
      }
      if (!strcmp(v27, "all"))
        *(_WORD *)(a1 + 1632) = 0;
      if (!strcmp(v27, "nocaseconv"))
        *(_WORD *)(a1 + 1632) = 2;
      if (!strcmp(v27, "g2pdct"))
        *(_WORD *)(a1 + 1632) = 1;
    }
  }
  return v2;
}

uint64_t fe_dctlkp_ObjClose(unsigned __int16 *a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  uint64_t j;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  result = safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696);
  if ((result & 0x80000000) != 0)
    return 2306875400;
  if (a1)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ObjClose", v4, v5, v6, v20);
    if (a1[244])
    {
      v7 = 0;
      do
      {
        v8 = *(_QWORD *)(*((_QWORD *)a1 + 62) + 8 * v7);
        v9 = *(_QWORD *)(v8 + 624);
        if (v9)
        {
          v10 = *(_QWORD *)(v8 + 56);
          if (v10)
          {
            brk_DataUnmap(*(_QWORD *)(*(_QWORD *)a1 + 24), v9, v10);
            v9 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 62) + 8 * v7) + 624);
          }
          brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v9);
          v8 = *(_QWORD *)(*((_QWORD *)a1 + 62) + 8 * v7);
        }
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v8);
        ++v7;
      }
      while (v7 < a1[244]);
    }
    objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"LINGDB");
    hlp_LookupFree(a1);
    close_DctRom((uint64_t)(a1 + 8));
    close_DctRom((uint64_t)(a1 + 48));
    close_DctRom((uint64_t)(a1 + 88));
    close_DctRom((uint64_t)(a1 + 128));
    close_DctRom((uint64_t)(a1 + 168));
    close_DctRom((uint64_t)(a1 + 208));
    v11 = *((_QWORD *)a1 + 63);
    if (v11)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v11);
    v12 = *((_QWORD *)a1 + 62);
    if (v12)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v12);
    hlp_domainToksFree(a1);
    if (*((_QWORD *)a1 + 73))
    {
      for (i = 0; i != 2048; i += 8)
      {
        v17 = *(_QWORD *)(*((_QWORD *)a1 + 73) + i);
        if (v17)
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v17);
      }
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *((_QWORD *)a1 + 73));
    }
    if (*((_QWORD *)a1 + 333))
    {
      for (j = 0; j != 2048; j += 8)
      {
        v19 = *(_QWORD *)(*((_QWORD *)a1 + 333) + j);
        if (v19)
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v19);
      }
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *((_QWORD *)a1 + 333));
    }
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ObjClose", v13, v14, v15, v21);
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_dctlkp_ObjReopen(uint64_t a1, int a2)
{
  uint64_t CanonMap;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t j;
  uint64_t v12;
  uint64_t BrokerString;
  const char *v14;
  char *v15;
  int v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  char **__c_3;

  CanonMap = 2306875400;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0 || !a1)
    return CanonMap;
  __c_3 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ObjReopen", v5, v6, v7, v27);
  hlp_LookupFree((_QWORD *)a1);
  close_DctRom(a1 + 16);
  close_DctRom(a1 + 256);
  close_DctRom(a1 + 336);
  v8 = *(_QWORD *)(a1 + 504);
  if (v8)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v8);
  hlp_domainToksFree((_QWORD *)a1);
  if (*(_QWORD *)(a1 + 584))
  {
    for (i = 0; i != 2048; i += 8)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 584) + i);
      if (v10)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v10);
        *(_QWORD *)(*(_QWORD *)(a1 + 584) + i) = 0;
      }
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 584));
    *(_QWORD *)(a1 + 584) = 0;
  }
  if (*(_QWORD *)(a1 + 2664))
  {
    for (j = 0; j != 2048; j += 8)
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 2664) + j);
      if (v12)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v12);
        *(_QWORD *)(*(_QWORD *)(a1 + 2664) + j) = 0;
      }
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 2664));
    *(_QWORD *)(a1 + 2664) = 0;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_QWORD *)(a1 + 576) = 0;
  *(_DWORD *)(a1 + 2660) = 1;
  *(_WORD *)(a1 + 1632) = 1;
  if ((hlp_CreateBrokerString(*(_QWORD *)a1, (char *)(a1 + 1634), 0) & 0x80000000) != 0
    || (open_DctRom((uint64_t *)(a1 + 16), a1 + 1634, (_DWORD *)(a1 + 8)) & 0x80000000) != 0)
  {
    BrokerString = hlp_CreateBrokerString(*(_QWORD *)a1, (char *)(a1 + 1634), 1);
    if ((BrokerString & 0x80000000) != 0)
      return BrokerString;
    BrokerString = open_DctRom((uint64_t *)(a1 + 16), a1 + 1634, (_DWORD *)(a1 + 8));
    if ((BrokerString & 0x80000000) != 0)
      return BrokerString;
  }
  if ((hlp_CreateVoiceBrokerString(*(_QWORD *)a1, (char *)(a1 + 1890), 1) & 0x80000000) != 0
    || (open_DctRom((uint64_t *)(a1 + 336), a1 + 1890, (_DWORD *)(a1 + 328)) & 0x80000000) != 0)
  {
    BrokerString = hlp_CreateVoiceBrokerString(*(_QWORD *)a1, (char *)(a1 + 1890), 0);
    if ((BrokerString & 0x80000000) == 0)
    {
      if ((open_DctRom((uint64_t *)(a1 + 336), a1 + 1890, (_DWORD *)(a1 + 328)) & 0x80000000) != 0)
        *(_DWORD *)(a1 + 328) = 0;
      goto LABEL_26;
    }
    return BrokerString;
  }
LABEL_26:
  BYTE5(v27) = 0;
  hlp_OpenMl2Dct(*(_QWORD *)a1, a1);
  HIWORD(v27) = -1;
  BrokerString = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "punc", &__c_3, (_WORD *)&v27 + 3, (_BYTE *)&v27 + 5, 0);
  if ((BrokerString & 0x80000000) != 0)
    return BrokerString;
  v14 = *__c_3;
  v15 = strchr(*__c_3, BYTE5(v27));
  if (v15)
  {
    *v15 = 0;
    v14 = *__c_3;
  }
  v16 = strlen(v14);
  v17 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v16 + 1));
  *(_QWORD *)(a1 + 504) = v17;
  if (!v17)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v18, v19, v20, v21, v27);
    return 2306875402;
  }
  strcpy(v17, *__c_3);
  HIWORD(v27) = -1;
  BrokerString = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "canonmapdomain", &__c_3, (_WORD *)&v27 + 3, (_BYTE *)&v27 + 5, 0);
  if ((BrokerString & 0x80000000) != 0)
    return BrokerString;
  if (HIWORD(v27))
    *(_DWORD *)(a1 + 2660) = 0;
  BrokerString = loc_fe_dctlkp_getDomainTokenDefs(a1, a2, a1);
  if ((BrokerString & 0x80000000) != 0)
    return BrokerString;
  strcpy((char *)(a1 + 2402), "normal");
  *(_QWORD *)(a1 + 584) = 0;
  *(_QWORD *)(a1 + 2664) = 0;
  CanonMap = LoadCanonMap(a1, a2);
  if ((CanonMap & 0x80000000) == 0)
  {
    if (*(_WORD *)(a1 + 488))
    {
      v25 = 0;
      while (1)
      {
        CanonMap = hlp_EnableAddon(a1, a2, *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v25));
        if ((CanonMap & 0x80000000) != 0)
          break;
        if (++v25 >= (unint64_t)*(unsigned __int16 *)(a1 + 488))
          goto LABEL_39;
      }
    }
    else
    {
LABEL_39:
      log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ObjReopen", v22, v23, v24, v27);
    }
  }
  return CanonMap;
}

_QWORD *hlp_LookupFree(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v1 = result;
  v2 = result[67];
  if (v2)
  {
    result = heap_Free(*(_QWORD **)(*result + 8), v2);
    v1[67] = 0;
  }
  v3 = v1[7];
  if (v3)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v3);
    v1[7] = 0;
  }
  v4 = (uint64_t *)v1[66];
  if (v4)
  {
    v5 = *v4;
    if (*v4)
    {
      v6 = 0;
      v7 = 0;
      do
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v5);
        *(_QWORD *)(v1[66] + 8 * v6) = 0;
        ++v7;
        v4 = (uint64_t *)v1[66];
        v6 = v7;
        v5 = v4[v7];
      }
      while (v5);
    }
    else
    {
      v7 = 0;
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), (uint64_t)v4);
    v1[66] = 0;
  }
  else
  {
    v7 = 0;
  }
  v8 = (uint64_t *)v1[64];
  if (v8)
  {
    v9 = *v8;
    if (*v8)
    {
      v10 = 0;
      v7 = 0;
      do
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v9);
        *(_QWORD *)(v1[64] + 8 * v10) = 0;
        ++v7;
        v8 = (uint64_t *)v1[64];
        v10 = v7;
        v9 = v8[v7];
      }
      while (v9);
    }
    else
    {
      v7 = 0;
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), (uint64_t)v8);
    v1[64] = 0;
  }
  v11 = (uint64_t *)v1[65];
  if (v11)
  {
    v12 = *v11;
    if (*v11)
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v1[4] = v12;
        exit_DctRom((uint64_t)(v1 + 2), *(_QWORD *)(v1[68] + 8 * v13));
        heap_Free(*(_QWORD **)(*v1 + 8), *(_QWORD *)(v1[65] + 8 * v13));
        *(_QWORD *)(v1[65] + 8 * v13) = 0;
        ++v14;
        v11 = (uint64_t *)v1[65];
        v13 = v14;
        v12 = v11[v14];
      }
      while (v12);
    }
    else
    {
      v14 = 0;
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), (uint64_t)v11);
    v1[65] = 0;
    v7 = v14;
  }
  v15 = v1[68];
  if (v15)
  {
    if (v7)
    {
      v16 = 0;
      v17 = 8 * v7;
      do
      {
        v18 = *(_QWORD *)(v1[68] + v16);
        if (v18)
        {
          brk_DataClose(*(_QWORD *)(*v1 + 24), v18);
          *(_QWORD *)(v1[68] + v16) = 0;
        }
        v16 += 8;
      }
      while (v17 != v16);
      v15 = v1[68];
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), v15);
    v1[68] = 0;
  }
  v19 = v1[69];
  if (v19)
  {
    v20 = v1[70];
    if (v20)
    {
      brk_DataUnmap(*(_QWORD *)(*v1 + 24), v19, v20);
      v1[70] = 0;
      v19 = v1[69];
    }
    result = (_QWORD *)brk_DataClose(*(_QWORD *)(*v1 + 24), v19);
    v1[69] = 0;
  }
  v1[72] = 0;
  return result;
}

_QWORD *hlp_domainToksFree(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (*((_WORD *)result + 808))
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    v4 = result[203];
    do
    {
      if (*(_QWORD *)(v4 + v2))
      {
        heap_Free(*(_QWORD **)(*v1 + 8), *(_QWORD *)(v4 + v2));
        v4 = v1[203];
        *(_QWORD *)(v4 + v2) = 0;
      }
      if (*(_QWORD *)(v4 + v2 + 8))
      {
        heap_Free(*(_QWORD **)(*v1 + 8), *(_QWORD *)(v4 + v2 + 8));
        v4 = v1[203];
        *(_QWORD *)(v4 + v2 + 8) = 0;
      }
      if (*(_QWORD *)(v4 + v2 + 16))
      {
        heap_Free(*(_QWORD **)(*v1 + 8), *(_QWORD *)(v4 + v2 + 16));
        v4 = v1[203];
        *(_QWORD *)(v4 + v2 + 16) = 0;
      }
      if (*(_QWORD *)(v4 + v2 + 24))
      {
        heap_Free(*(_QWORD **)(*v1 + 8), *(_QWORD *)(v4 + v2 + 24));
        v4 = v1[203];
        *(_QWORD *)(v4 + v2 + 24) = 0;
      }
      ++v3;
      v2 += 32;
    }
    while (v3 < *((unsigned __int16 *)v1 + 808));
    result = heap_Free(*(_QWORD **)(*v1 + 8), v4);
    v1[203] = 0;
    *((_WORD *)v1 + 808) = 0;
  }
  return result;
}

uint64_t hlp_EnableAddon(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t Str;
  const char *v7;
  char *v8;
  int v9;
  char __s2[4];
  char __s1[4];
  _BYTE __c[11];
  char *v14;
  char *__s;

  v14 = &byte_1DEBD87CE;
  __s = 0;
  *(_WORD *)&__c[1] = -1;
  if (!a1)
    return 2306875400;
  *(_QWORD *)&__c[3] = 0;
  __c[0] = 0;
  *(_DWORD *)(a3 + 620) = 0;
  Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"langcode", &__s);
  if ((Str & 0x80000000) == 0)
  {
    lowercase(__s, (uint64_t)__s1);
    lowercase((const char *)(a3 + 80), (uint64_t)__s2);
    if (!strcmp(__s1, __s2))
    {
      Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"fecfg", &v14);
      if ((Str & 0x80000000) == 0 && !strcmp(v14, (const char *)(a3 + 84)))
      {
        Str = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "addoncomp", &__c[3], &__c[1], __c, 0);
        if (*(_WORD *)&__c[1])
        {
          v7 = **(const char ***)&__c[3];
          v8 = strchr(**(char ***)&__c[3], __c[0]);
          if (v8)
          {
            *v8 = 0;
            v7 = **(const char ***)&__c[3];
          }
          v9 = atoi(v7);
        }
        else
        {
          v9 = 1;
        }
        if (v9 == *(unsigned __int8 *)(a3 + 105) && *(_BYTE *)(a3 + 104) == 1)
          *(_DWORD *)(a3 + 620) = 1;
      }
    }
  }
  return Str;
}

uint64_t fe_dctlkp_CheckVersion(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  int v18;
  unsigned int v20;
  char *__endptr;
  char *v22;
  _BYTE __c[15];
  __int16 v24;

  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  *(_QWORD *)&__c[1] = 0;
  __c[0] = 0;
  *a4 = 0;
  *a3 = 0;
  v24 = -1;
  v8 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "versioninfo", &__c[1], &v24, __c, 0);
  if ((v8 & 0x80001FFF) != 0x8000000A && v24)
  {
    __endptr = 0;
    v9 = **(char ***)&__c[1];
    v10 = strchr(**(char ***)&__c[1], __c[0]);
    if (v10)
    {
      *v10 = 0;
      v9 = **(char ***)&__c[1];
    }
    v22 = v9;
    *a4 = 1;
    v15 = strtol(v9, &__endptr, 10);
    v16 = v15 < 1 || __endptr == 0;
    if (v16
      || *__endptr != 46
      || (v17 = strtol(__endptr + 1, &v22, 10), (v17 & 0x80000000) != 0)
      || !v22
      || *v22 != 46
      || (v18 = strtol(v22 + 1, &__endptr, 10), v18 < 0)
      || !__endptr
      || *__endptr != 46 && *__endptr)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41006, 0, v11, v12, v13, v14, v20);
      return 2306875392;
    }
    if (v15 > 7)
      goto LABEL_19;
    if (v15 == 7)
    {
      if (v17 > 4 || v17 == 4 && v18)
      {
LABEL_19:
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 5, 0, (uint64_t)"productVersion %d.%d.%d dctVersion %s", v12, v13, v14, 7);
        return v8;
      }
    }
    else if (v15 == 1 && !(v18 | v17))
    {
      *a3 = 0;
      return v8;
    }
    *a3 = 1;
  }
  return v8;
}

uint64_t fe_dctlkp_GetDataBlock(uint64_t a1, int a2, char *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v24;
  char *v25;

  v25 = 0;
  v7 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  v12 = *(_QWORD *)a1;
  if (a3)
  {
    v13 = brk_DataOpen(*(_QWORD *)(v12 + 24));
    if ((v13 & 0x80000000) != 0)
    {
      return v13;
    }
    else
    {
      v14 = brk_DataMap(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552), 40, *(unsigned int *)(a1 + 8), (uint64_t)&v25);
      if ((_DWORD)v14)
      {
        v15 = v14;
        brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552));
        *(_QWORD *)(a1 + 552) = 0;
        return v15;
      }
      else
      {
        if (LH_stricmp(v25, a3))
        {
          v16 = 0;
          v17 = 0;
          while (v17 < *(_DWORD *)(a1 + 8))
          {
            v18 = strlen(&v25[v16]);
            v16 = v18 + v17 + ((~(_BYTE)v18 - (_BYTE)v17) & 3) + 5;
            v17 = v16;
            v19 = v16;
            if (!LH_stricmp(&v25[v16], a3))
              goto LABEL_16;
          }
          v19 = v17;
        }
        else
        {
          v19 = 0;
          v16 = 0;
        }
LABEL_16:
        if (v19 >= *(_DWORD *)(a1 + 8))
        {
          brk_DataUnmap(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552), (uint64_t)v25);
          return 2306875412;
        }
        else
        {
          v20 = strlen(&v25[v16]);
          v21 = *(unsigned int *)&v25[v19 + 1 + v20 + ((~(_BYTE)v20 - (_BYTE)v19) & 3)];
          brk_DataUnmap(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552), (uint64_t)v25);
          v7 = brk_DataMap(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552), v21, 4, (uint64_t)&v25);
          if (!(_DWORD)v7)
          {
            v22 = *(unsigned int *)v25;
            brk_DataUnmap(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552), (uint64_t)v25);
            v7 = brk_DataMap(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(a1 + 552), (v21 + 4), v22, (uint64_t)a4);
            if ((v7 & 0x80000000) == 0)
              *(_QWORD *)(a1 + 560) = *a4;
          }
        }
      }
    }
  }
  else
  {
    log_OutPublic(*(_QWORD *)(v12 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v8, v9, v10, v11, v24);
  }
  return v7;
}

uint64_t fe_dctlkp_QueryDictExists(_DWORD *a1, int a2, char *a3, _DWORD *a4)
{
  uint64_t optional_brk_resource;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;

  optional_brk_resource = 2306875399;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  v12 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  if (!a3)
  {
    log_OutPublic(v12, (uint64_t)"FE_DCTLKP", 41001, 0, v8, v9, v10, v11, v16);
    return optional_brk_resource;
  }
  log_OutText(v12, (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_QueryDictExists : %s?", v9, v10, v11, (uint64_t)a3);
  *a4 = 0;
  if ((hlp_SearchDctName((uint64_t)a1, a3, &byte_1DEBD87CE) & 0x80000000) == 0)
  {
    optional_brk_resource = 0;
    *a4 = 1;
    return optional_brk_resource;
  }
  v14 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)"sysdct", a1 + 22, a3, a4);
  if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
  {
    *a4 = 0;
    if (!a1[2])
      goto LABEL_14;
    v15 = brk_DataOpen(v14);
    if ((v15 & 0x80000000) != 0)
      return v15;
    optional_brk_resource = query_DctRom((uint64_t)(a1 + 4), a3, a1[2], 0, a4);
    if ((optional_brk_resource & 0x80000000) == 0)
    {
      brk_DataClose(v14, 0);
      if (!*a4)
      {
LABEL_14:
        optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)"lid", a1 + 42, a3, a4);
        if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
        {
          optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)a1 + 2146, a1 + 62, a3, a4);
          if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
          {
            optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)a1 + 1890, a1 + 82, a3, a4);
            if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
              return loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)"clmnn:clmnndic", a1 + 102, a3, a4);
          }
        }
      }
    }
  }
  return optional_brk_resource;
}

uint64_t loc_fe_dctlkp_query_optional_brk_resource(uint64_t a1, uint64_t a2, _DWORD *a3, char *a4, _DWORD *a5)
{
  uint64_t DctRom;
  uint64_t v11;

  v11 = 0;
  *a5 = 0;
  if (!*a3 || (brk_DataOpenEx(a1, a2, 1, (uint64_t)&v11) & 0x80000000) != 0)
    return 0;
  DctRom = query_DctRom((uint64_t)(a3 + 2), a4, *a3, v11, a5);
  if ((DctRom & 0x80000000) == 0)
    brk_DataClose(a1, v11);
  return DctRom;
}

uint64_t fe_dctlkp_QueryLidDictExists(unsigned int *a1, int a2, char *a3, int a4, _DWORD *a5)
{
  uint64_t DctRom;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v20;
  uint64_t v21;

  DctRom = 2306875399;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  v21 = 0;
  *a5 = 0;
  v14 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  if (a3)
  {
    log_OutText(v14, (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_QueryLidDictExists : %s?", v11, v12, v13, (uint64_t)a3);
    v15 = *(_QWORD *)(*(_QWORD *)a1 + 24);
    if (a4)
    {
      if ((brk_DataOpenEx(v15, (uint64_t)"lid", 1, (uint64_t)&v21) & 0x80000000) != 0)
        return 0;
      v16 = (uint64_t)(a1 + 44);
      v17 = a1[42];
    }
    else
    {
      v18 = brk_DataOpen(v15);
      if ((v18 & 0x80000000) != 0)
        return v18;
      v16 = (uint64_t)(a1 + 4);
      v17 = a1[2];
    }
    DctRom = query_DctRom(v16, a3, v17, v21, a5);
    if ((DctRom & 0x80000000) == 0)
      brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v21);
  }
  else
  {
    log_OutPublic(v14, (uint64_t)"FE_DCTLKP", 41001, 0, v10, v11, v12, v13, v20);
  }
  return DctRom;
}

uint64_t fe_dctlkp_LangAndDomCheck(uint64_t result, _WORD *a2, __int16 *a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6;
  uint64_t v8;
  int v9;
  unsigned __int16 v10;
  int *v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;

  v6 = (unsigned __int16)*a2;
  if (v6 < a6)
  {
    v8 = result;
    v9 = *(_DWORD *)(a5 + 12);
    v10 = a6;
    v11 = (int *)(a5 + 32 * v6);
    do
    {
      if (v11[3] - v9 > a4)
        break;
      v12 = *v11;
      v11 += 8;
      if (v12 == 36)
        v10 = v6;
      *a2 = ++v6;
    }
    while (a6 != v6);
    if (a6 > v10)
    {
      v13 = *(unsigned __int16 *)(result + 1616);
      if (*(_WORD *)(result + 1616))
      {
        v14 = 0;
        v15 = 0;
        v16 = *(const char **)(a5 + 32 * v10 + 24);
        do
        {
          if (v16)
          {
            result = strcmp(v16, *(const char **)(*(_QWORD *)(v8 + 1624) + v14));
            if ((_DWORD)result)
              v17 = 999;
            else
              v17 = v15;
          }
          else
          {
            v17 = 999;
          }
          if (++v15 >= v13)
            break;
          v14 += 32;
        }
        while (v17 == 999);
      }
      else
      {
        v17 = 999;
      }
      *a3 = v17;
    }
  }
  return result;
}

uint64_t fe_dctlkp_Tokenize(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v28;
  int v29;
  unsigned __int8 *v30;
  unsigned int v31;
  _BOOL4 v32;
  unsigned __int8 *v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  char *v37;
  _BOOL4 v39;
  unsigned __int8 *v40;
  __int16 v41;
  unsigned int v42;
  __int16 v43;
  char *v44;
  __int16 v46;
  char *v47;
  unsigned __int16 v48;
  unsigned int v49;
  BOOL v50;
  unsigned int v51;
  unsigned int v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  unsigned __int16 v73;
  char *__s;
  int v75;
  int v76;
  unsigned __int16 v77;
  __int16 v78;
  unsigned __int16 v79;
  int v80;

  v80 = 0;
  v79 = 0;
  v77 = 0;
  v75 = 0;
  v76 = 0;
  __s = 0;
  v73 = 999;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_Tokenize", v11, v12, v13, v67);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a1[71] + 104))(a3, a4, 1, 0, (char *)&v80 + 2);
  if ((v14 & 0x80000000) != 0)
  {
LABEL_61:
    v18 = v14;
    goto LABEL_64;
  }
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char **, char *))(a1[71] + 176))(a3, a4, HIWORD(v80), 0, &__s, (char *)&v75 + 2);
  if ((v18 & 0x80000000) == 0)
  {
    LOWORD(v80) = 0;
    v78 = 0;
    v19 = __s;
    if ((unsigned __int16)strlen(__s))
    {
      v20 = 0;
      v69 = a6;
      v70 = a3;
      v72 = a6;
      v71 = a4;
      do
      {
        v79 = v20;
        v21 = strlen(v19);
        if (a6)
        {
          v22 = v69;
          v23 = (unsigned int *)a5;
          v24 = (unsigned int *)a5;
          while (1)
          {
            v25 = *v24;
            v24 += 8;
            v26 = (1 << v25) & 0x3C8010124021140;
            if (v25 <= 0x39 && v26 != 0)
            {
              v28 = v23[3];
              v29 = *(_DWORD *)(a5 + 12);
              if (v28 > v29 + v20)
                break;
            }
            v23 = v24;
            if (!--v22)
              goto LABEL_16;
          }
          v21 = v28 - v29;
        }
LABEL_16:
        fe_dctlkp_LangAndDomCheck((uint64_t)a1, &v78, (__int16 *)&v73, (unsigned __int16)v20, a5, a6);
        v30 = (unsigned __int8 *)&v19[(unsigned __int16)v20];
        v31 = v73;
        v32 = IsAlphaUtf((uint64_t)a1, v30, v73);
        v33 = (unsigned __int8 *)&__s[(unsigned __int16)v80];
        if (v32)
        {
          v34 = utf8_determineUTF8CharLength(*v33);
          v35 = 0;
          v76 = 0;
          v36 = v80;
          v37 = __s;
          do
          {
            LOWORD(v80) = v36 + v34;
            v34 = utf8_determineUTF8CharLength(v37[(unsigned __int16)(v36 + v34)]);
            if (!IsAlphaUtf((uint64_t)a1, (unsigned __int8 *)&__s[(unsigned __int16)v80], v31) || v35 > 0x7E)
              break;
            ++v35;
            v36 = v80;
            v37 = __s;
          }
          while ((unsigned __int16)v80 < (unsigned __int16)strlen(__s) && v21 > (unsigned __int16)v80);
        }
        else
        {
          v39 = IsDigitUtf((uint64_t)a1, v33, v31);
          v40 = (unsigned __int8 *)&__s[(unsigned __int16)v80];
          if (v39)
          {
            v41 = utf8_determineUTF8CharLength(*v40);
            v42 = 0;
            v76 = 1;
            v43 = v80;
            v44 = __s;
            do
            {
              LOWORD(v80) = v43 + v41;
              v41 = utf8_determineUTF8CharLength(v44[(unsigned __int16)(v43 + v41)]);
              if (!IsDigitUtf((uint64_t)a1, (unsigned __int8 *)&__s[(unsigned __int16)v80], v31) || v42 > 0x7E)
                break;
              ++v42;
              v43 = v80;
              v44 = __s;
            }
            while ((unsigned __int16)v80 < (unsigned __int16)strlen(__s) && v21 > (unsigned __int16)v80);
          }
          else
          {
            if (IsPuncUtf((uint64_t)a1, v40, v31))
            {
              v76 = 2;
              v46 = v80 + 1;
LABEL_36:
              LOWORD(v80) = v46;
              goto LABEL_49;
            }
            v47 = __s;
            v48 = v80;
            v49 = __s[(unsigned __int16)v80];
            v50 = v49 > 0x20 || ((1 << v49) & 0x100002600) == 0;
            if (v50 && v49 != 95)
            {
              v62 = utf8_determineUTF8CharLength(v49);
              log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Warning - character \"%c\" marked as alpha by default. Assign to domain definitions.", v63, v64, v65, __s[(unsigned __int16)v80]);
              v76 = 0;
              v46 = v80 + v62;
              goto LABEL_36;
            }
            v76 = 3;
            v51 = v79;
            do
            {
              LOWORD(v80) = ++v48;
              fe_dctlkp_LangAndDomCheck((uint64_t)a1, &v78, (__int16 *)&v73, v51, a5, v72);
              v52 = v47[v48];
              v53 = v52 > 0x20 || ((1 << v52) & 0x100002600) == 0;
            }
            while ((!v53 || v52 == 95) && (unsigned __int16)strlen(v47) > v48);
          }
        }
LABEL_49:
        v54 = a1[71];
        if (v79)
        {
          v56 = v70;
          v55 = v71;
          v14 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned __int16 *))(v54 + 80))(v70, v71, v77, &v77);
          if ((v14 & 0x80000000) != 0)
            goto LABEL_61;
        }
        else
        {
          v56 = v70;
          v55 = v71;
          v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(v54 + 72))(v70, v71, 3, HIWORD(v80), &v77);
          if ((v14 & 0x80000000) != 0)
            goto LABEL_61;
        }
        v57 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, int *))(a1[71] + 160))(v56, v55, v77, 0, 1, &v76, &v75);
        if ((v57 & 0x80000000) != 0
          || (v57 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(a1[71] + 160))(v56, v55, v77, 1, 1, &v79, &v75), (v57 & 0x80000000) != 0))
        {
          v18 = v57;
LABEL_63:
          log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 41002, 0, v58, v59, v60, v61, v68);
          break;
        }
        v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(a1[71] + 160))(v56, v55, v77, 2, 1, &v80, &v75);
        if ((v18 & 0x80000000) != 0)
          goto LABEL_63;
        v20 = (unsigned __int16)v80;
        v19 = __s;
        a6 = v72;
      }
      while ((unsigned __int16)v80 < (unsigned __int16)strlen(__s));
    }
  }
LABEL_64:
  log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_Tokenize", v15, v16, v17, v68);
  return v18;
}

BOOL IsAlphaUtf(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  char *v6;
  _BOOL8 result;
  unsigned int v8;
  BOOL v9;

  if (a3 != 999)
  {
    v6 = *(char **)(*(_QWORD *)(a1 + 1624) + 32 * a3 + 8);
    if (v6)
    {
      if (a2)
        return utf8_strchr(v6, a2) != 0;
      return 0;
    }
  }
  result = 0;
  v8 = *a2;
  v9 = v8 > 0x20 || ((1 << v8) & 0x100002600) == 0;
  if (v9 && v8 != 95)
  {
    if (!IsPuncUtf(a1, a2, a3))
      return !IsDigitUtf(a1, a2, a3);
    return 0;
  }
  return result;
}

BOOL IsDigitUtf(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  char *v3;

  if (a3 == 999)
    return *a2 - 48 < 0xA;
  v3 = *(char **)(*(_QWORD *)(a1 + 1624) + 32 * a3 + 16);
  if (!v3)
    return *a2 - 48 < 0xA;
  if (a2)
    return utf8_strchr(v3, a2) != 0;
  return 0;
}

BOOL IsPuncUtf(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (a3 == 999 || !*(_QWORD *)(*(_QWORD *)(a1 + 1624) + 32 * a3 + 24))
    return loc_fe_dctlkp_IsPunctUtf(a1, a2);
  if (a2)
    return utf8_strchr(*(char **)(*(_QWORD *)(a1 + 1624) + 32 * a3 + 24), a2) != 0;
  return 0;
}

uint64_t fe_dctlkp_PartLookupUtf(uint64_t a1, int a2, char *a3, const char *a4, _QWORD *a5, __int16 *a6, _BYTE *a7, uint64_t a8)
{
  int v14;
  unsigned int v16;
  __int16 v17;
  char v19[3];
  char v20[256];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a8)
  {
    v14 = a8 - 1;
    if ((_DWORD)a8 == 1)
      return loc_fe_dctlkp_LookupUtf(a1, a2, a3, a4, a5, a6, a7, 0);
    v16 = 0;
    v17 = *a6;
    do
    {
      __strcpy_chk();
      LH_itoa(v16, v19, 0xAu);
      __strcat_chk();
      *a6 = v17;
      a8 = loc_fe_dctlkp_LookupUtf(a1, a2, v20, a4, a5, a6, a7, 0);
      if ((a8 & 0x80000000) != 0)
        break;
      if (*a6)
        break;
    }
    while (v14 != v16++);
  }
  return a8;
}

uint64_t fe_dctlkp_PartLookupAddonDct(uint64_t a1, int a2, char *a3, const char *a4, _QWORD *a5, unsigned __int16 *a6, _BYTE *a7, uint64_t a8, _DWORD *a9)
{
  int v14;
  unsigned int v16;
  unsigned __int16 v17;
  char v20[3];
  char v21[256];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a8)
  {
    v14 = a8 - 1;
    if ((_DWORD)a8 == 1)
      return fe_dctlkp_LookupAddonDct(a1, a2, a3, a4, a5, a6, a7, a9);
    v16 = 0;
    v17 = *a6;
    do
    {
      __strcpy_chk();
      LH_itoa(v16, v20, 0xAu);
      __strcat_chk();
      *a6 = v17;
      a8 = fe_dctlkp_LookupAddonDct(a1, a2, v21, a4, a5, a6, a7, a9);
      if ((a8 & 0x80000000) != 0)
        break;
      if (*a6)
        break;
    }
    while (v14 != v16++);
  }
  return a8;
}

uint64_t fe_dctlkp_LookupAddonDct(uint64_t a1, int a2, char *a3, const char *a4, _QWORD *a5, unsigned __int16 *a6, _BYTE *a7, _DWORD *a8)
{
  uint64_t v13;
  unsigned int Str;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  char *v26;
  int v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  char v49;
  unsigned __int8 *v50;
  int v51;
  unsigned __int16 v52;
  char v53;
  char v54;
  uint64_t v55;
  unsigned int v56;
  unint64_t v57;
  _BYTE *v58;
  char v59;
  unsigned __int8 *v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  unsigned int v68;
  char v69;
  _DWORD *v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  unsigned __int16 v74;
  int v75;
  char *v76;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  const char *v82;

  v13 = a1;
  v82 = 0;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)v13 + 40), (uint64_t)"addondct_extended_lookup", &v82);
  if ((Str & 0x80000000) == 0 && !strcmp(v82, "yes"))
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)v13 + 32), (uint64_t)"FE_DCTLKP", 5, 0, (uint64_t)"<%s> enables extended lookup (both DDU and system dct)", v15, v16, v17, (uint64_t)"addondct_extended_lookup");
    v18 = 1;
  }
  else
  {
    v18 = 0;
  }
  v74 = *a6;
  v20 = *(unsigned __int16 *)(v13 + 488);
  v81 = a5;
  if (!*(_WORD *)(v13 + 488))
  {
    v52 = 0;
    v23 = 0;
    v54 = 1;
    goto LABEL_54;
  }
  v69 = v18;
  v72 = Str;
  v73 = 0;
  v70 = a8;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v80 = v13;
  while (1)
  {
    v79 = v21;
    v24 = *(_QWORD *)(*(_QWORD *)(v13 + 496) + 8 * v21);
    if (!*(_DWORD *)(v24 + 620))
      goto LABEL_46;
    if (strstr(a3, "femwg2p"))
    {
      v25 = 0;
      v26 = "addonmwg2p";
      goto LABEL_20;
    }
    if (strstr(a3, "femwtn"))
    {
      v25 = 0;
      v26 = "addonmwtn";
      goto LABEL_20;
    }
    if (!strstr(a3, "g2p"))
      break;
    v27 = *(unsigned __int8 *)(v24 + 106);
    v26 = (char *)(v24 + 106);
    if (v27)
      goto LABEL_19;
LABEL_46:
    v21 = v79 + 1;
    if (v79 + 1 >= (unint64_t)v20)
    {
      v52 = v22;
      if (v73)
      {
        a8 = v70;
        v53 = v69 ^ 1;
        if (!v70)
          v53 = 1;
        if ((v53 & 1) != 0)
        {
          if (v70)
            *v70 = 1;
          *a6 = 0;
          v55 = v72;
          goto LABEL_68;
        }
        v54 = 0;
      }
      else
      {
        v54 = 1;
        a8 = v70;
      }
LABEL_54:
      *a6 = v74;
      v55 = loc_fe_dctlkp_LookupUtf(v13, a2, a3, a4, v81, a6, a7, 0);
      if ((v55 & 0x80000000) != 0)
      {
        v19 = v55;
        goto LABEL_82;
      }
      if (a8)
      {
        if ((v54 & 1) == 0 && !*a6)
        {
          *a8 = 1;
          *a7 = 14;
          goto LABEL_69;
        }
        *a8 = 0;
      }
      v56 = *a6;
      if (*a6)
      {
        v57 = 0;
        do
        {
          v58 = *(_BYTE **)(*v81 + 8 * v57);
          v59 = *v58;
          if (*v58)
          {
            v60 = v58 + 1;
            do
            {
              if (*a7 == v59)
                *(v60 - 1) = 14;
              v61 = *v60++;
              v59 = v61;
            }
            while (v61);
            v56 = *a6;
          }
          ++v57;
        }
        while (v57 < v56);
      }
LABEL_68:
      *a7 = 14;
      v19 = v55;
      if (!a8)
      {
LABEL_70:
        if (v52)
        {
          v62 = 0;
          while (1)
          {
            v63 = *a6;
            if ((int)v62 + (int)v63 >= 20 * *(unsigned __int16 *)(v13 + 578))
              break;
            if (v23)
              strcpy(*(char **)(*(_QWORD *)(v13 + 528) + 8 * (v62 + v63)), *(const char **)(v23 + 8 * v62));
            if (v52 == ++v62)
            {
              LOWORD(v62) = v52;
              break;
            }
          }
        }
        else
        {
          LOWORD(v62) = 0;
        }
        *a6 += v62;
LABEL_82:
        LOWORD(v41) = v52;
        v34 = v23;
        if (v23)
          goto LABEL_83;
        return v19;
      }
LABEL_69:
      v19 = v55;
      if (!*a8)
        goto LABEL_82;
      goto LABEL_70;
    }
  }
  if (!*(_BYTE *)(v24 + 362))
    goto LABEL_46;
  v26 = (char *)(v24 + 362);
LABEL_19:
  v25 = (unsigned __int16)atoi(v26 + 6);
LABEL_20:
  if (v25 < v73)
    goto LABEL_46;
  v71 = v25;
  if (!*v26)
    goto LABEL_46;
  while (1)
  {
    v28 = strchr(v26, 124);
    v76 = v28;
    if (v28)
    {
      v75 = *v28;
      *v28 = 0;
    }
    else
    {
      v75 = 0;
    }
    *a6 = v74;
    v72 = loc_fe_dctlkp_LookupUtf(v13, a2, v26, a4, a5, a6, a7, *(unsigned int **)(*(_QWORD *)(v13 + 496) + 8 * v79));
    if ((v72 & 0x80000000) != 0)
    {
      v52 = v22;
      v19 = v72;
      goto LABEL_82;
    }
    if (*a6)
      break;
LABEL_40:
    if (v76 && v75)
    {
      *v76 = v75;
      a5 = v81;
    }
    else
    {
      a5 = v81;
      if (!v76)
        goto LABEL_45;
    }
    v26 = v76 + 1;
    if (!v76[1])
    {
LABEL_45:
      v20 = *(unsigned __int16 *)(v13 + 488);
      goto LABEL_46;
    }
  }
  v29 = heap_Realloc(*(uint64_t **)(*(_QWORD *)v13 + 8), v23, 8 * (*a6 + (unint64_t)(unsigned __int16)v22));
  if (!v29)
  {
    v52 = v22;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)v13 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v30, v31, v32, v33, v68);
    v19 = 2306875402;
    goto LABEL_82;
  }
  v34 = v29;
  bzero((void *)(v29 + 8 * (unsigned __int16)v22), 8 * *a6);
  if (!*a6)
  {
    v41 = v22;
LABEL_39:
    v13 = v80;
    log_OutEvent(*(uint64_t ***)(*(_QWORD *)v80 + 32), 28, "%s%s", v35, v36, v37, v38, v39, "ADDON_NAME");
    v23 = v34;
    v22 = v41;
    v73 = v71;
    goto LABEL_40;
  }
  v40 = 0;
  LODWORD(v41) = v22;
  while (1)
  {
    v42 = strlen(*(const char **)(*v81 + 8 * v40));
    v43 = (char *)heap_Realloc(*(uint64_t **)(*(_QWORD *)v80 + 8), *(_QWORD *)(v34 + 8 * (unsigned __int16)v41), (v42 + 1));
    if (!v43)
      break;
    *(_QWORD *)(v34 + 8 * (unsigned __int16)v41) = v43;
    strcpy(v43, *(const char **)(*v81 + 8 * v40));
    v48 = *(_BYTE **)(v34 + 8 * (unsigned __int16)v41);
    v49 = *v48;
    if (*v48)
    {
      v50 = v48 + 1;
      do
      {
        if (*a7 == v49)
          *(v50 - 1) = 14;
        v51 = *v50++;
        v49 = v51;
      }
      while (v51);
    }
    v41 = (v41 + 1);
    if (++v40 >= (unint64_t)*a6)
      goto LABEL_39;
  }
  v13 = v80;
  log_OutPublic(*(_QWORD *)(*(_QWORD *)v80 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v44, v45, v46, v47, v68);
  v19 = 2306875402;
LABEL_83:
  if ((_WORD)v41)
  {
    v64 = (unsigned __int16)v41;
    v65 = (uint64_t *)v34;
    do
    {
      v66 = *v65++;
      heap_Free(*(_QWORD **)(*(_QWORD *)v13 + 8), v66);
      --v64;
    }
    while (v64);
  }
  heap_Free(*(_QWORD **)(*(_QWORD *)v13 + 8), v34);
  return v19;
}

uint64_t fe_dctlkp_InitStatus(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 2306875399;
  result = 0;
  *(_QWORD *)a1 = 0;
  *(_WORD *)(a1 + 8) = 0;
  return result;
}

BOOL fe_dctlkp_IsValidStatus(_DWORD *a1)
{
  return *a1 != 0;
}

uint64_t fe_dctlkp_InitEntry(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 2306875399;
  result = 0;
  *(_DWORD *)a1 = -1;
  *(_WORD *)(a1 + 4) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 16) = 0;
  return result;
}

BOOL fe_dctlkp_IsValidEntry(_DWORD *a1)
{
  return *a1 >= 0;
}

uint64_t fe_dctlkp_DoLookupStep(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;

  v13 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_DoLookupStep (%d byte(s) of '%s')", v14, v15, v16, a7);
  if (a5)
  {
    *(_DWORD *)a5 = -1;
    *(_WORD *)(a5 + 4) = 0;
    *(_QWORD *)(a5 + 8) = 0;
    *(_WORD *)(a5 + 16) = 0;
    v17 = WordToHashOpt(a3 + 8, a6, 0, (unsigned __int16)a7 - 1, 0, a4);
    *(_DWORD *)a5 = v17;
    if (v17 == -2)
      v13 = 10;
    else
      v13 = 0;
    v18 = *(_DWORD *)(a4 + 8);
    *(_QWORD *)(a5 + 8) = *(_QWORD *)a4;
    *(_DWORD *)(a5 + 16) = v18;
  }
  return v13;
}

uint64_t fe_dctlkp_GetEntryContents(uint64_t a1, uint64_t a2, _QWORD *a3, int *a4, unsigned __int8 **a5, _WORD *a6, _BYTE *a7, _BYTE *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;

  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_GetEntryContents", v16, v17, v18, v21);
  v19 = fe_dctlkp_LookupFromStateAddress(a1, a2, a3, *a4, a5, a6, a8);
  *a7 = GetFieldSeparator((uint64_t)(a3 + 1));
  return v19;
}

uint64_t fe_dctlkp_LookupFromStateAddress(uint64_t a1, uint64_t a2, _QWORD *a3, int a4, unsigned __int8 **a5, _WORD *a6, _BYTE *a7)
{
  unsigned __int8 *v9;
  int v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  unsigned __int8 **v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  int v30;
  unsigned __int8 *v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned __int8 v35;
  uint64_t v37;
  int v38;
  unsigned __int8 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  unsigned __int8 *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _QWORD v50[8];

  v50[7] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2306875400;
  v50[0] = a3[2];
  v9 = *a5;
  *a7 = 1;
  if (a4 < 0)
    goto LABEL_8;
  v11 = DecoAddr(a3 + 1, a4);
  if (v11 == -2)
    return 10;
  if (v11 < 0
    || brk_DataMap(a3[4], a3[5], (*(_DWORD *)(a3[3] + 132) + v11), *(unsigned __int16 *)(*(_QWORD *)a3[3] + 52), (uint64_t)v50))
  {
LABEL_8:
    result = 0;
    *a7 = 0;
  }
  else
  {
    v13 = 0;
    LOWORD(v14) = 0;
    v15 = 0;
    LOBYTE(v16) = *(_BYTE *)v50[0];
    do
    {
      v9[(__int16)v15++] = v16;
      v17 = (unsigned __int8 **)a3[3];
      v18 = *v17;
      do
      {
        v14 = (__int16)v14;
        v19 = v9[(__int16)v14];
        v20 = 2 * (v19 - v18[6]);
        v21 = v17[2][v20];
        if (v17[2][v20])
        {
          v22 = v15 - 1;
          do
          {
            if ((int)v14 < (__int16)(v15 - 1))
            {
              v23 = v22;
              do
              {
                v9[v23 + 1] = v9[v23];
                --v23;
              }
              while (v23 > v14);
              v17 = (unsigned __int8 **)a3[3];
              LODWORD(v19) = v9[v14];
              v18 = *v17;
            }
            ++v15;
            v9[v14 + 1] = v17[2][2 * (v19 - (unint64_t)v18[6]) + 1];
            v9[v14] = v21;
            v17 = (unsigned __int8 **)a3[3];
            v18 = *v17;
            ++v22;
            LODWORD(v19) = v21;
            v21 = v17[2][2 * (v21 - (unint64_t)(*v17)[6])];
          }
          while (v21);
        }
        LODWORD(v14) = (__int16)(v14 + 1);
      }
      while ((int)v14 < (__int16)v15);
      ++v13;
      v24 = v50[0];
      v16 = *(unsigned __int8 *)(v50[0] + v13);
      v25 = v18[10];
    }
    while (v16 != v18[8] && (v16 < v25 || v16 > v18[11]));
    v26 = *v9;
    if (v26 >= v25)
    {
      while (1)
      {
        v27 = v26;
        v28 = v18[11];
        v24 = v50[0];
        if (v26 > v28)
          break;
        v29 = v18[8];
        v30 = *(unsigned __int8 *)(v50[0] + (int)v13);
        if (v30 == v29)
        {
LABEL_29:
          v33 = 1;
        }
        else
        {
          v31 = (unsigned __int8 *)(v50[0] + (int)v13 + 1);
          while (v30 < v25 || v28 < v30)
          {
            LODWORD(v13) = v13 + 1;
            v32 = *v31++;
            LOBYTE(v30) = v32;
            if (v32 == v29)
              goto LABEL_29;
          }
          v33 = 0;
          LOBYTE(v29) = v30;
        }
        LODWORD(v13) = v13 + v33;
        v34 = v25;
        v35 = v25 - 1;
        if (v29 <= v28 && v29 >= v34)
          v35 = v29;
        if (v35 >= v26)
        {
          LODWORD(v13) = v13 + 1;
        }
        else
        {
          LOWORD(v37) = 0;
          v38 = 0;
          v39 = v17[2];
          v40 = v18[6];
          v13 = (int)v13;
          do
          {
            v41 = (__int16)v38++;
            *((_BYTE *)&v50[1] + v41 + 7) = *(_BYTE *)(v24 + v13);
            do
            {
              v37 = (__int16)v37;
              v42 = *((unsigned __int8 *)&v50[1] + (__int16)v37 + 7);
              if (v39[2 * (v42 - v40)])
              {
                v43 = v38 - 1;
                do
                {
                  if ((int)v37 < (__int16)(v38 - 1))
                  {
                    v44 = v43;
                    do
                    {
                      *((_BYTE *)&v50[2] + v44) = *((_BYTE *)&v50[1] + v44 + 7);
                      --v44;
                    }
                    while (v44 > v37);
                    v42 = *((unsigned __int8 *)&v50[1] + v37 + 7);
                  }
                  v45 = &v39[2 * (v42 - v40)];
                  *((_BYTE *)&v50[2] + v37) = v45[1];
                  v42 = *v45;
                  *((_BYTE *)&v50[1] + v37 + 7) = v42;
                  ++v38;
                  ++v43;
                }
                while (v39[2 * (v42 - v40)]);
              }
              LODWORD(v37) = (__int16)(v37 + 1);
              LOBYTE(v26) = v26 - 1;
            }
            while ((int)v37 < (__int16)v38 && v26 >= v35);
            ++v13;
          }
          while (v26 >= v35);
          v46 = v27 - v35;
          if ((__int16)v15 >= 2)
          {
            v47 = (unsigned __int16)v15 - 1;
            v48 = (__int16)(v15 + v27 - v35) - 1;
            do
              v9[v48--] = v9[v47--];
            while (v47);
          }
          if ((v46 & 0x80000000) == 0)
          {
            v49 = 0;
            do
            {
              v9[(__int16)v49] = *((_BYTE *)&v50[1] + (__int16)v49 + 7);
              ++v49;
            }
            while (v46 >= (__int16)v49);
          }
          LOWORD(v15) = v15 + v46;
          LOBYTE(v26) = v35;
        }
        v17 = (unsigned __int8 **)a3[3];
        v18 = *v17;
        v25 = (*v17)[10];
        if (v25 > v26)
        {
          v24 = v50[0];
          break;
        }
      }
    }
    brk_DataUnmap(a3[4], a3[5], v24);
    result = 0;
    *a6 = v15;
  }
  return result;
}

uint64_t fe_dctlkp_GetNextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int16 v4;
  int v5;
  uint64_t v7;
  int v8;
  int v9;
  char v10;
  char __s[8];
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v9 = 0;
  v12 = 0;
  *(_QWORD *)__s = 0;
  v3 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 8);
  v8 = *(_DWORD *)(a2 + 16);
  ++*(_WORD *)(a2 + 4);
  __strcat_chk();
  LH_itoa(*(unsigned __int16 *)(a2 + 4), (char *)&v9, 0xAu);
  __strcat_chk();
  v4 = strlen(__s);
  v5 = WordToHashOpt(v3, (uint64_t)__s, 0, v4 - 1, 0, (uint64_t)&v7);
  *(_DWORD *)a2 = v5;
  if (v5 == -2)
    return 10;
  else
    return 0;
}

uint64_t loc_fe_dctlkp_LookupUtf(uint64_t a1, int a2, char *a3, const char *a4, _QWORD *a5, _WORD *a6, _BYTE *a7, unsigned int *a8)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v11;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  int v29;
  int v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  _BOOL4 v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  const char *v54;
  unsigned int v55;
  uint64_t v56;
  __int16 v57;
  unsigned __int16 v58;
  unsigned int v59;
  unint64_t v60;
  __int16 v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t inited;
  uint64_t v79;
  uint64_t v80;
  unsigned __int16 v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  unsigned int MaxOutLen;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  _BOOL4 v108;
  const char *__src;
  uint64_t v110;
  int v111;
  uint64_t v112;
  int v113;
  char __s2[4];
  char v115;
  __int16 v116;
  int v117;
  char __s[8];
  __int16 v119;
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  v116 = 0;
  v115 = 0;
  *(_DWORD *)__s2 = 0;
  v8 = 2306875402;
  v119 = 0;
  *(_QWORD *)__s = 0;
  v9 = 2306875399;
  if (a3)
  {
    if (a4)
    {
      v11 = a5;
      if (a5)
      {
        if (a6 && a7)
        {
          if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) == 0)
          {
            v117 = 0;
            v113 = 0;
            log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 5, 0, (uint64_t)"Entering fe_dctlkp_Lookup: searching %s in %s", v17, v18, v19, (uint64_t)a4);
            v112 = 0;
            v110 = 0;
            v111 = 0;
            if (a8)
            {
              v23 = heap_strdup(*(_QWORD *)(*(_QWORD *)a1 + 8), a3);
              if (v23)
              {
                __src = v23;
                LH_itoa(*((unsigned __int16 *)a8 + 36), __s, 0xAu);
                v28 = a8;
LABEL_28:
                v35 = (unsigned __int16)*a6;
                if ((v35 - 1) < 2 || v35 == 0xFFFF)
                {
                  v108 = strncmp(a3, "ml2mw", 5uLL) == 0;
                  *a6 = 0;
                }
                else
                {
                  v108 = 1;
                }
                v36 = hlp_SearchDctName(a1, __src, __s);
                if ((v36 & 0x80000000) == 0)
                {
                  v37 = 0;
                  v38 = 0;
                  *((_QWORD *)v28 + 3) = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * (unsigned __int16)v36);
                  v39 = v108;
LABEL_34:
                  *a7 = GetFieldSeparator((uint64_t)(v28 + 2));
                  v40 = (__int16)(strlen(a4) + 5);
                  if (v40 > *(__int16 *)(a1 + 582))
                  {
                    v41 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 536), (unsigned __int16)v40);
                    if (!v41)
                      goto LABEL_75;
                    *(_WORD *)(a1 + 582) = v40;
                    *(_QWORD *)(a1 + 536) = v41;
                  }
                  *a6 = 0;
                  *v11 = *(_QWORD *)(a1 + 528);
                  v107 = v11;
                  if (v38 > *(unsigned __int16 *)(a1 + 580))
                  {
                    if (*(_WORD *)(a1 + 578))
                    {
                      v46 = 0;
                      do
                      {
                        v47 = v46;
                        v48 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 528) + 8 * v46), v38 + 1);
                        if (!v48)
                        {
                          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v49, v50, v51, v52, v106);
                          v37 = 2306875402;
                          v11 = v107;
                          goto LABEL_84;
                        }
                        *(_QWORD *)(*(_QWORD *)(a1 + 528) + 8 * v47) = v48;
                        v46 = v47 + 1;
                      }
                      while (20 * *(unsigned __int16 *)(a1 + 578) - 1 > (unsigned __int16)(v47 + 1));
                    }
                    *(_WORD *)(a1 + 580) = v38;
                    v11 = v107;
                    v39 = v108;
                  }
                  LOWORD(v53) = *a6;
                  if (v39 || !*a6)
                  {
                    while (1)
                    {
                      HIWORD(v117) = 0;
                      if ((unsigned __int16)v53 == 1)
                      {
                        v110 = v112;
                        v111 = v113;
                      }
                      else
                      {
                        if (!(_WORD)v53)
                        {
                          strcpy(*(char **)(a1 + 536), a4);
                          goto LABEL_51;
                        }
                        v112 = v110;
                        v113 = v111;
                      }
                      **(_WORD **)(a1 + 536) = 23;
                      LH_itoa((unsigned __int16)*a6, __s2, 0xAu);
                      strcat(*(char **)(a1 + 536), __s2);
LABEL_51:
                      v54 = *(const char **)(a1 + 536);
                      LOWORD(v117) = strlen(v54) - 1;
                      v55 = DctLookup((uint64_t)(v28 + 2), (uint64_t)v54, (unsigned __int16 *)&v117 + 1, (__int16 *)&v117, 0, &v116, (uint64_t)&v112);
                      if (v55)
                      {
                        if ((v55 & 0x1FFF) == 0x14)
                          v70 = 0;
                        else
                          v70 = v55;
                        if ((v55 & 0x1FFF) == 0xA)
                          v37 = 2306875402;
                        else
                          v37 = v70;
                        break;
                      }
                      if ((unsigned __int16)*a6 + 2 > 20 * *(unsigned __int16 *)(a1 + 578))
                      {
                        v56 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 528), 160 * *(unsigned __int16 *)(a1 + 578) + 160);
                        if (!v56)
                          goto LABEL_75;
                        *(_QWORD *)(a1 + 528) = v56;
                        v57 = 20 * *(_WORD *)(a1 + 578);
                        if (*(_WORD *)(a1 + 578))
                          v58 = v57 - 1;
                        else
                          v58 = 0;
                        v59 = v58;
                        v60 = v58;
                        bzero((void *)(v56 + 8 * v58), 8 * (((unsigned __int16)(v57 + 20) & 0xFFFC) - (unint64_t)v58));
                        v61 = *(_WORD *)(a1 + 578);
                        if (v59 < (unsigned __int16)(20 * v61 + 19))
                        {
                          v11 = v107;
                          while (1)
                          {
                            v62 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), *(unsigned __int16 *)(a1 + 580) + 1);
                            if (!v62)
                              break;
                            *(_QWORD *)(*(_QWORD *)(a1 + 528) + 8 * v60++) = v62;
                            v61 = *(_WORD *)(a1 + 578);
                            if (v60 >= (unsigned __int16)(20 * v61 + 19))
                            {
                              v60 = (unsigned __int16)v60;
                              goto LABEL_63;
                            }
                          }
LABEL_75:
                          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v42, v43, v44, v45, v106);
                          v37 = 2306875402;
                          break;
                        }
                        v11 = v107;
LABEL_63:
                        *(_QWORD *)(*(_QWORD *)(a1 + 528) + 8 * v60) = 0;
                        *(_WORD *)(a1 + 578) = v61 + 1;
                      }
                      if (v116 < 1)
                      {
                        LOWORD(v63) = 0;
                      }
                      else
                      {
                        v63 = 0;
                        do
                        {
                          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 528) + 8 * (unsigned __int16)*a6) + v63) = *(_BYTE *)(*((_QWORD *)v28 + 6) + v63);
                          ++v63;
                        }
                        while (v63 < v116);
                      }
                      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 528) + 8 * (unsigned __int16)*a6) + (unsigned __int16)v63) = 0;
                      v53 = (unsigned __int16)(*a6)++ + 1;
                      if (!v39 && (v53 & 0x10000) == 0)
                      {
                        v37 = 0;
                        break;
                      }
                    }
                  }
LABEL_84:
                  v71 = (uint64_t)__src;
                  v72 = 1;
                  v8 = v37;
                  goto LABEL_109;
                }
                v64 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 544), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
                if (!v64)
                  goto LABEL_107;
                *(_QWORD *)(a1 + 544) = v64;
                v69 = *(unsigned __int16 *)(a1 + 576);
                *(_QWORD *)(v64 + 8 * v69) = 0;
                *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v69 + 8) = 0;
                if (!a8)
                {
                  v73 = brk_DataOpen(*(_QWORD *)(*(_QWORD *)a1 + 24));
                  if ((v73 & 0x80000000) != 0)
                  {
                    v72 = 0;
                    v8 = v73;
                    goto LABEL_108;
                  }
                  v69 = *(unsigned __int16 *)(a1 + 576);
                }
                v74 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 520), 8 * v69 + 16);
                if (!v74)
                  goto LABEL_107;
                *(_QWORD *)(a1 + 520) = v74;
                v75 = *(unsigned __int16 *)(a1 + 576);
                *(_QWORD *)(v74 + 8 * v75) = 0;
                *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v75 + 8) = 0;
                v76 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 1, 144);
                if (!v76)
                  goto LABEL_107;
                v77 = *(unsigned __int16 *)(a1 + 576);
                *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v77) = v76;
                *((_QWORD *)v28 + 3) = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v77);
                inited = init_DctRom((uint64_t)(v28 + 2), a3, *v28, *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v77));
                v37 = inited;
                if ((inited & 0x80000000) != 0)
                {
                  if ((inited & 0x1FFF) == 0x14)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * *(unsigned __int16 *)(a1 + 576)));
                    v105 = *(unsigned __int16 *)(a1 + 576);
                    *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v105) = 0;
                    brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v105));
                    v72 = 0;
                    v8 = 0;
                    *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                  }
                  else
                  {
                    v72 = 0;
                    v8 = inited;
                  }
                  goto LABEL_108;
                }
                v79 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 512), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
                if (!v79)
                  goto LABEL_107;
                *(_QWORD *)(a1 + 512) = v79;
                v80 = *(unsigned __int16 *)(a1 + 576);
                *(_QWORD *)(v79 + 8 * v80) = 0;
                *(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * v80 + 8) = 0;
                v81 = strlen(__s);
                v82 = strlen(__src);
                v83 = v81 ? v81 + 1 : 0;
                v84 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v82 + v83 + 1));
                if (!v84)
                  goto LABEL_107;
                v85 = *(unsigned __int16 *)(a1 + 576);
                *(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * v85) = v84;
                v86 = *(void **)(*(_QWORD *)(a1 + 512) + 8 * v85);
                if (v81)
                {
                  memcpy(v86, __s, v81);
                  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * *(unsigned __int16 *)(a1 + 576)) + v81) = 95;
                  v86 = (void *)(*(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * *(unsigned __int16 *)(a1 + 576)) + v81 + 1);
                }
                strcpy((char *)v86, __src);
                MaxOutLen = GetMaxOutLen((uint64_t)(v28 + 2));
                if (MaxOutLen)
                {
                  v38 = MaxOutLen;
                  v39 = v108;
                  if (MaxOutLen <= *(unsigned __int16 *)(a1 + 580))
                  {
LABEL_106:
                    ++*(_WORD *)(a1 + 576);
                    goto LABEL_34;
                  }
                  v92 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *((_QWORD *)v28 + 6), MaxOutLen + 1);
                  if (v92)
                  {
                    *(_QWORD *)(a1 + 56) = v92;
                    *(_QWORD *)(a1 + 136) = v92;
                    *(_QWORD *)(a1 + 216) = v92;
                    *(_QWORD *)(a1 + 296) = v92;
                    *(_QWORD *)(a1 + 376) = v92;
                    *(_QWORD *)(a1 + 456) = v92;
                    v93 = *(unsigned __int16 *)(a1 + 488);
                    if (*(_WORD *)(a1 + 488))
                    {
                      v94 = *(uint64_t **)(a1 + 496);
                      do
                      {
                        v95 = *v94++;
                        *(_QWORD *)(v95 + 48) = v92;
                        --v93;
                      }
                      while (v93);
                    }
                    goto LABEL_106;
                  }
LABEL_107:
                  log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v65, v66, v67, v68, v106);
                  v72 = 0;
                  goto LABEL_108;
                }
                log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v88, v89, v90, v91, v106);
                v72 = 0;
LABEL_87:
                v8 = 2306875399;
LABEL_108:
                v71 = (uint64_t)__src;
LABEL_109:
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v71);
                if ((v8 & 0x80000000) != 0)
                {
                  if ((v72 & 1) == 0)
                  {
                    v96 = *(_QWORD *)(a1 + 512);
                    if (v96)
                    {
                      v97 = *(_QWORD *)(v96 + 8 * *(unsigned __int16 *)(a1 + 576));
                      if (v97)
                      {
                        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v97);
                        *(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                      }
                    }
                    v98 = *(_QWORD *)(a1 + 520);
                    if (v98)
                    {
                      v99 = *(unsigned __int16 *)(a1 + 576);
                      v100 = *(_QWORD *)(v98 + 8 * v99);
                      if (v100)
                      {
                        if (v28)
                        {
                          v101 = *(_QWORD *)(a1 + 544);
                          if (v101)
                          {
                            if (*(_QWORD *)(v101 + 8 * v99))
                            {
                              *((_QWORD *)v28 + 3) = v100;
                              exit_DctRom((uint64_t)(v28 + 2), *(_QWORD *)(v101 + 8 * v99));
                              v100 = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * *(unsigned __int16 *)(a1 + 576));
                            }
                          }
                        }
                        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v100);
                        *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                      }
                    }
                    v102 = *(_QWORD *)(a1 + 544);
                    if (v102)
                    {
                      v103 = *(_QWORD *)(v102 + 8 * *(unsigned __int16 *)(a1 + 576));
                      if (v103)
                      {
                        brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v103);
                        *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                      }
                    }
                  }
                  v34 = v8;
                }
                else
                {
                  v34 = v8;
                  if (*a6)
                    *v11 = *(_QWORD *)(a1 + 528);
                }
                goto LABEL_127;
              }
            }
            else
            {
              v29 = (unsigned __int16)*a6;
              if (v29 == 2)
              {
                if (!*(_DWORD *)(a1 + 328))
                {
                  v34 = 2306875399;
                  goto LABEL_127;
                }
                v28 = (unsigned int *)(a1 + 328);
              }
              else
              {
                if (v29 == 1)
                {
                  v30 = strlen(a3);
                  v31 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v30 + 2));
                  if (v31)
                  {
                    v32 = v31;
                    v33 = strcpy(v31, a3);
                    __src = v32;
                    *(_WORD *)&v32[strlen(v33)] = 67;
                    if (!strcmp(a3, "lidcfg") || !strncmp(a3, "mertfrq", 7uLL) || !strncmp(a3, "merwfrq", 7uLL))
                    {
                      v28 = (unsigned int *)(a1 + 168);
                      if (*(_DWORD *)(a1 + 168))
                        goto LABEL_28;
                    }
                    else if (!strncmp(a3, "ml2", 3uLL) || !strncmp(a3, "lid", 3uLL))
                    {
                      v28 = (unsigned int *)(a1 + 248);
                      if (*(_DWORD *)(a1 + 248))
                        goto LABEL_28;
                    }
                    else if (!strncmp(a3, "clm", 3uLL))
                    {
                      if (*(_DWORD *)(a1 + 408))
                      {
                        v28 = (unsigned int *)(a1 + 408);
                        goto LABEL_28;
                      }
                    }
                    else
                    {
                      v28 = (unsigned int *)(a1 + 88);
                      if (*(_DWORD *)(a1 + 88))
                        goto LABEL_28;
                    }
                    v28 = 0;
                    v72 = 1;
                    goto LABEL_87;
                  }
                  goto LABEL_26;
                }
                v28 = (unsigned int *)(a1 + 8);
              }
              __src = heap_strdup(*(_QWORD *)(*(_QWORD *)a1 + 8), a3);
              if (__src)
                goto LABEL_28;
            }
LABEL_26:
            log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v24, v25, v26, v27, v106);
            v34 = 2306875402;
LABEL_127:
            log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_Lookup", v20, v21, v22, v106);
            return v34;
          }
          return 2306875400;
        }
      }
    }
  }
  return v9;
}

uint64_t fe_dctlkp_ConvertToCanonicalTokenUtf(size_t a1, int a2, const char *a3, const char *a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t CanonMap;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v21;
  uint64_t v22;

  v10 = safeh_HandleCheck(a1, a2, 62335, 3696);
  if ((v10 & 0x80000000) != 0)
    return 2306875400;
  CanonMap = v10;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ConvertToCanonicalToken", v11, v12, v13, v21);
  if (!a4)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v15, v16, v17, v18, v22);
    return 2306875399;
  }
  if (*(_DWORD *)(a1 + 2660) && strcmp(a3, (const char *)(a1 + 2402)))
  {
    CanonMap = LoadCanonMap(a1, a2);
    if ((CanonMap & 0x80000000) != 0)
      return CanonMap;
    __strcpy_chk();
  }
  if (*(_WORD *)(a1 + 1632) != 2)
  {
    if (*(_WORD *)(a1 + 1632))
    {
      if ((unsigned __int16)Utf8_Utf8NbrOfSymbols(a4) - 3 <= 0xFFFFFFFD && (unsigned __int16)strlen(a4))
      {
        v19 = 0;
        do
          v19 += hlp_tolower_char((unsigned __int8 *)&a4[(unsigned __int16)v19]);
        while ((unsigned __int16)strlen(a4) > (unsigned __int16)v19);
      }
    }
    else
    {
      hlp_ConvertToCanonicalTokenUtf(a1, a2, a1, *(_QWORD *)(a1 + 584), a4, a5);
      CanonMap = 0;
    }
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ConvertToCanonicalToken", v16, v17, v18, v22);
  return CanonMap;
}

size_t hlp_ConvertToCanonicalTokenUtf(size_t result, int a2, uint64_t a3, uint64_t a4, const char *a5, unsigned int a6)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  int v11;
  unsigned __int16 v12;
  int v13;
  const char *v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  size_t v18;
  char v21[22];
  char __s[10];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*(_WORD *)(a3 + 1632) != 2)
  {
    v8 = result;
    strcpy(v21, "canonmap");
    if (*(_QWORD *)(a3 + 2664) == a4)
    {
      __strcat_chk();
      v9 = a3 + 2672;
    }
    else
    {
      v9 = a3 + 592;
    }
    result = Utf8_Utf8NbrOfSymbols(a5);
    if ((unsigned __int16)result - 3 <= 0xFFFFFFFD)
    {
      result = strlen(a5);
      v10 = result;
      if ((_WORD)result)
      {
        v11 = 0;
        v12 = 0;
        v13 = (unsigned __int16)result;
        do
        {
          v14 = &a5[v12];
          v15 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v14);
          if (hlp_getUtf8CanMap(v8, a2, (uint64_t)v21, v9, v14, __s))
          {
            v16 = strlen(__s);
            v17 = v13 - v15 + v16;
            if (a6 > v17)
            {
              v18 = v16;
              memmove((void *)&v14[v16], &v14[v15], v13 - (v11 + v15) + 1);
              strncpy((char *)&a5[v12], __s, v18);
              v10 = v17;
            }
          }
          else
          {
            hlp_tolower_char((unsigned __int8 *)&a5[v12]);
          }
          result = utf8_determineUTF8CharLength(*(unsigned __int8 *)v14);
          v12 += result;
          v11 = v12;
          v13 = v10;
        }
        while (v12 < v10);
      }
    }
  }
  return result;
}

unsigned __int8 *hlp_tolower_char(unsigned __int8 *result)
{
  _BYTE *v1;
  int v2;
  char v3;

  v1 = result;
  LODWORD(result) = *result;
  if (((_DWORD)result - 65) > 0x19)
  {
    if ((_DWORD)result == 195)
    {
      v2 = v1[1];
      LOWORD(result) = 2;
      switch(v1[1])
      {
        case 0x84:
          v3 = -92;
          goto LABEL_16;
        case 0x85:
          v3 = -91;
          goto LABEL_16;
        case 0x86:
          v3 = -90;
          goto LABEL_16;
        case 0x87:
          v3 = -89;
          goto LABEL_16;
        case 0x88:
        case 0x8A:
        case 0x8B:
        case 0x8C:
        case 0x8D:
        case 0x8E:
        case 0x8F:
        case 0x90:
          return (unsigned __int8 *)(unsigned __int16)result;
        case 0x89:
          v3 = -87;
          goto LABEL_16;
        case 0x91:
          v3 = -79;
          goto LABEL_16;
        default:
          if (v2 == 150)
          {
            v3 = -74;
          }
          else
          {
            if (v2 != 156)
              return (unsigned __int8 *)(unsigned __int16)result;
            v3 = -68;
          }
LABEL_16:
          v1[1] = v3;
          break;
      }
    }
    else
    {
      LOWORD(result) = utf8_determineUTF8CharLength(result);
    }
  }
  else
  {
    *v1 = (_BYTE)result + 32;
    LOWORD(result) = 1;
  }
  return (unsigned __int8 *)(unsigned __int16)result;
}

uint64_t fe_dctlkp_G2PConvertToCanonicalTokenUtf(size_t a1, int a2, const char *a3, const char *a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t CanonMap;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;

  v10 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_G2PConvertToCanonicalToken", v11, v12, v13, v24);
  if (a4)
  {
    if (*(_DWORD *)(a1 + 2660) && strcmp(a3, (const char *)(a1 + 2402)))
    {
      CanonMap = LoadCanonMap(a1, a2);
      if ((CanonMap & 0x80000000) != 0)
        return CanonMap;
      __strcpy_chk();
    }
    v19 = *(_QWORD *)(a1 + 2664);
    if (!v19)
      v19 = *(_QWORD *)(a1 + 584);
    hlp_ConvertToCanonicalTokenUtf(a1, a2, a1, v19, a4, a5);
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_G2PConvertToCanonicalToken", v20, v21, v22, v25);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v14, v15, v16, v17, v25);
  }
  return v10;
}

uint64_t fe_dctlkp_ConvertToCanonicalWordUtf(uint64_t a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t CanonMap;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  int v27;
  char *v28;
  unsigned __int8 *v29;
  __int16 v30;
  uint64_t v31;
  const char *v32;
  size_t v33;
  uint64_t v35;
  uint64_t v36;

  v10 = safeh_HandleCheck(a1, a2, 62335, 3696);
  if ((v10 & 0x80000000) != 0)
    return 2306875400;
  CanonMap = v10;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ConvertToCanonicalWord", v11, v12, v13, v35);
  if (a4)
  {
    if (*a4)
    {
      if (!*(_DWORD *)(a1 + 2660) || !strcmp(a3, (const char *)(a1 + 2402)))
      {
LABEL_8:
        if (*(_WORD *)(a1 + 1632))
        {
          if ((unsigned __int16)strlen(a4))
          {
            v19 = 0;
            do
            {
              v20 = *(char **)(a1 + 504);
              if (!v20)
                break;
              v21 = &a4[(unsigned __int16)v19];
              if (!*v21)
                break;
              if (!utf8_strchr(v20, (unsigned __int8 *)&a4[(unsigned __int16)v19]))
                break;
              v19 += utf8_determineUTF8CharLength(*v21);
            }
            while ((unsigned __int16)strlen(a4) > (unsigned __int16)v19);
          }
          else
          {
            v19 = 0;
          }
          v25 = strlen(a4);
          v26 = (__int16)(v25 - 1) & ((__int16)(v25 - 1) >> 31);
          LOWORD(v27) = v25;
          do
          {
            v27 = (__int16)(v27 - 1);
            if (v27 < 1)
              goto LABEL_35;
          }
          while (a4[(unsigned __int16)v27] < -64);
          v28 = *(char **)(a1 + 504);
          if (v28)
          {
            while (2)
            {
              v29 = (unsigned __int8 *)&a4[(unsigned __int16)v27];
              if (*v29 && utf8_strchr(v28, v29))
              {
                LOWORD(v26) = v27;
                do
                {
                  v26 = (__int16)(v26 - 1);
                  if (v26 < 1)
                  {
                    v30 = v27;
                    if ((__int16)v27 >= 1)
                      v30 = 1;
                    LOWORD(v26) = v30 - 1;
                    goto LABEL_35;
                  }
                }
                while (a4[(unsigned __int16)v26] < -64);
                v28 = *(char **)(a1 + 504);
                LOWORD(v27) = v26;
                if (v28)
                  continue;
LABEL_35:
                a4[(unsigned __int16)(v26 + utf8_determineUTF8CharLength(a4[(unsigned __int16)v26]))] = 0;
                v31 = (unsigned __int16)v19;
                if (*(_WORD *)(a1 + 1632) != 2
                  && (unsigned __int16)Utf8_Utf8NbrOfSymbols(&a4[(unsigned __int16)v19]) - 3 <= 0xFFFFFFFD
                  && (unsigned __int16)strlen(a4) > (unsigned __int16)v19)
                {
                  do
                    v19 += hlp_tolower_char((unsigned __int8 *)&a4[(unsigned __int16)v19]);
                  while ((unsigned __int16)strlen(a4) > (unsigned __int16)v19);
                }
                v32 = &a4[v31];
                v33 = strlen(v32);
                memmove(a4, v32, v33 + 1);
                goto LABEL_40;
              }
              break;
            }
          }
          LOWORD(v26) = v27;
          goto LABEL_35;
        }
        hlp_ConvertToCanonicalWordUtf(a1, a2, a1, *(_QWORD *)(a1 + 584), a4, a5);
        CanonMap = 0;
LABEL_40:
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ConvertToCanonicalWord", v22, v23, v24, v36);
        return CanonMap;
      }
      CanonMap = LoadCanonMap(a1, a2);
      if ((CanonMap & 0x80000000) == 0)
      {
        __strcpy_chk();
        goto LABEL_8;
      }
    }
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v15, v16, v17, v18, v36);
    return 2306875399;
  }
  return CanonMap;
}

void *hlp_ConvertToCanonicalWordUtf(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char *__s, unsigned int a6)
{
  uint64_t v9;
  int v10;
  size_t v11;
  __int16 v12;
  __int16 v13;
  int v14;
  int v15;
  __int16 v16;
  unsigned int v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  int v20;
  int v21;
  int v22;
  const char *v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  size_t v27;
  size_t v28;
  uint64_t v30;
  char v33[22];
  char __sa[10];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  strcpy(v33, "canonmap");
  if (*(_QWORD *)(a3 + 2664) == a4)
  {
    __strcat_chk();
    v9 = a3 + 2672;
  }
  else
  {
    v9 = a3 + 592;
  }
  if ((unsigned __int16)strlen(__s))
  {
    v10 = 0;
    do
    {
      if (!loc_fe_dctlkp_IsPunctUtf(a3, (unsigned __int8 *)&__s[(unsigned __int16)v10]))
        break;
      v10 += utf8_determineUTF8CharLength(__s[(unsigned __int16)v10]);
    }
    while ((unsigned __int16)strlen(__s) > (unsigned __int16)v10);
  }
  else
  {
    LOWORD(v10) = 0;
  }
  v11 = strlen(__s);
  v12 = v11 - 1;
  if (v11)
    v13 = v11 - 1;
  else
    v13 = 0;
  LOWORD(v14) = v13;
  if (v13 >= 1)
  {
    while (__s[(unsigned __int16)v12] < -64)
    {
      v15 = v12--;
      if (v15 <= 1)
      {
        LOWORD(v14) = 0;
        goto LABEL_27;
      }
    }
    if (loc_fe_dctlkp_IsPunctUtf(a3, (unsigned __int8 *)&__s[(unsigned __int16)v12]))
    {
      while (2)
      {
        LOWORD(v14) = v12;
        do
        {
          v14 = (__int16)(v14 - 1);
          if (v14 < 1)
          {
            v16 = v12;
            if (v12 >= 1)
              v16 = 1;
            LOWORD(v14) = v16 - 1;
            goto LABEL_27;
          }
        }
        while (__s[(unsigned __int16)v14] < -64);
        v12 = v14;
        if (loc_fe_dctlkp_IsPunctUtf(a3, (unsigned __int8 *)&__s[(unsigned __int16)v14]))
          continue;
        break;
      }
    }
    else
    {
      LOWORD(v14) = v12;
    }
  }
LABEL_27:
  v17 = (unsigned __int16)utf8_determineUTF8CharLength(__s[(unsigned __int16)v14])
      + (unsigned __int16)v14;
  if (v17 >= a6)
    LOWORD(v17) = a6 - 1;
  __s[(unsigned __int16)v17] = 0;
  v30 = (unsigned __int16)v10;
  if (*(_WORD *)(a3 + 1632) != 2
    && (unsigned __int16)Utf8_Utf8NbrOfSymbols(&__s[(unsigned __int16)v10]) - 3 <= 0xFFFFFFFD)
  {
    v18 = strlen(__s);
    v19 = v18;
    if (v18)
    {
      v20 = 0;
      v21 = 0;
      v22 = v18;
      do
      {
        v23 = &__s[(unsigned __int16)v21];
        v24 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v23);
        if (hlp_getUtf8CanMap(a1, a2, (uint64_t)v33, v9, v23, __sa))
        {
          v25 = strlen(__sa);
          v26 = v22 - v24 + v25;
          if (a6 > v26)
          {
            v27 = v25;
            memmove((void *)&v23[v25], &v23[v24], v22 - (v20 + v24) + 1);
            strncpy(&__s[(unsigned __int16)v21], __sa, v27);
            v19 = v26;
          }
        }
        else
        {
          hlp_tolower_char((unsigned __int8 *)&__s[(unsigned __int16)v21]);
        }
        v21 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v23);
        v20 = (unsigned __int16)v21;
        v22 = v19;
      }
      while ((unsigned __int16)v21 < v19);
    }
  }
  v28 = strlen(&__s[v30]);
  return memmove(__s, &__s[v30], v28 + 1);
}

BOOL loc_fe_dctlkp_IsPunctUtf(_BOOL8 result, unsigned __int8 *a2)
{
  uint64_t v2;
  char *v3;

  if (result)
  {
    v2 = result;
    result = 0;
    if (a2)
    {
      v3 = *(char **)(v2 + 504);
      if (v3)
        return *a2 && utf8_strchr(v3, a2) != 0;
    }
  }
  return result;
}

uint64_t fe_dctlkp_G2PConvertToCanonicalWordUtf(uint64_t a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t CanonMap;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;

  v10 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_G2PConvertToCanonicalWord", v11, v12, v13, v24);
  if (a4)
  {
    if (*(_DWORD *)(a1 + 2660) && strcmp(a3, (const char *)(a1 + 2402)))
    {
      CanonMap = LoadCanonMap(a1, a2);
      if ((CanonMap & 0x80000000) != 0)
        return CanonMap;
      __strcpy_chk();
    }
    v19 = *(_QWORD *)(a1 + 2664);
    if (!v19)
      v19 = *(_QWORD *)(a1 + 584);
    hlp_ConvertToCanonicalWordUtf(a1, a2, a1, v19, a4, a5);
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_G2PConvertToCanonicalWord", v20, v21, v22, v25);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v14, v15, v16, v17, v25);
  }
  return v10;
}

uint64_t fe_dctlkp_LookupMultiwordUtf(uint64_t a1, int a2, char *a3, unsigned int a4, char *a5, const char *a6, _QWORD *a7, unsigned __int16 *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t CanonMap;
  int v25;
  int v26;
  int v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  uint64_t v34;
  char v35;

  v35 = 0;
  v16 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0)
    return 2306875400;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_LookupMultiword", v17, v18, v19, v33);
  if (!a3 || !a7 || !a8)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v20, v21, v22, v23, v34);
    return v16;
  }
  if (*(_DWORD *)(a1 + 2660) && strcmp(a6, (const char *)(a1 + 2402)))
  {
    CanonMap = LoadCanonMap(a1, a2);
    if ((CanonMap & 0x80000000) != 0)
      return CanonMap;
    __strcpy_chk();
  }
  if ((unsigned __int16)strlen(a3))
  {
    v25 = 0;
    do
    {
      if (!loc_fe_dctlkp_IsPunctUtf(a1, (unsigned __int8 *)&a3[(unsigned __int16)v25]))
        break;
      v25 += utf8_determineUTF8CharLength(a3[(unsigned __int16)v25]);
    }
    while ((unsigned __int16)strlen(a3) > (unsigned __int16)v25);
  }
  else
  {
    v25 = 0;
  }
  v26 = *(unsigned __int16 *)(a1 + 1632);
  if (*(_WORD *)(a1 + 1632))
    goto LABEL_22;
  if ((unsigned __int16)Utf8_Utf8NbrOfSymbols(a3) - 3 > 0xFFFFFFFD)
  {
    v26 = *(unsigned __int16 *)(a1 + 1632);
LABEL_22:
    if (v26 != 2 && (unsigned __int16)strlen(a3) > (unsigned __int16)v25)
    {
      v27 = v25;
      do
        v27 += hlp_tolower_char((unsigned __int8 *)&a3[(unsigned __int16)v27]);
      while ((unsigned __int16)strlen(a3) > (unsigned __int16)v27);
    }
    goto LABEL_26;
  }
  hlp_ConvertToCanonicalWordUtf(a1, a2, a1, *(_QWORD *)(a1 + 584), a3, a4);
LABEL_26:
  v28 = strlen(&a3[(unsigned __int16)v25]);
  memmove(a3, &a3[(unsigned __int16)v25], v28 + 1);
  *a8 = 0;
  v16 = fe_dctlkp_LookupAddonDct(a1, a2, a5, a3, a7, a8, &v35, 0);
  if ((v16 & 0x80000000) == 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_LookupMultiword", v29, v30, v31, v34);
  return v16;
}

BOOL fe_dctlkp_IsPunctUtf(uint64_t a1, int a2, unsigned __int8 *a3)
{
  return (safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) == 0 && loc_fe_dctlkp_IsPunctUtf(a1, a3);
}

unsigned int *fe_GetDct(unsigned int *a1, int a2, char *__s, _WORD *a4)
{
  int v7;
  uint64_t v8;
  int v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  char *v16;
  unsigned int *v17;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int inited;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  unsigned int v38;

  if (!a1)
    return 0;
  v7 = (unsigned __int16)*a4;
  if (v7 == 2)
  {
    v17 = a1 + 82;
    v15 = __s;
LABEL_13:
    *a4 = 0;
    goto LABEL_14;
  }
  if (v7 == 1)
  {
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8);
    v9 = strlen(__s);
    v10 = (char *)heap_Alloc(v8, (v9 + 2));
    if (!v10)
    {
LABEL_24:
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v11, v12, v13, v14, v38);
      return 0;
    }
    v15 = v10;
    v16 = strcpy(v10, __s);
    *(_WORD *)&v15[strlen(v16)] = 67;
    v17 = a1 + 22;
    v7 = (unsigned __int16)*a4;
  }
  else
  {
    v17 = a1 + 2;
    v15 = __s;
  }
  if ((v7 - 1) < 2 || v7 == 0xFFFF)
    goto LABEL_13;
LABEL_14:
  v19 = hlp_SearchDctName((uint64_t)a1, v15, &byte_1DEBD87CE);
  if ((v19 & 0x80000000) == 0)
  {
    *((_QWORD *)v17 + 3) = *(_QWORD *)(*((_QWORD *)a1 + 65) + 8 * (unsigned __int16)v19);
    return v17;
  }
  v20 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *((_QWORD *)a1 + 68), 8 * *((unsigned __int16 *)a1 + 288) + 16);
  if (!v20)
    goto LABEL_24;
  *((_QWORD *)a1 + 68) = v20;
  v21 = *((unsigned __int16 *)a1 + 288);
  *(_QWORD *)(v20 + 8 * v21) = 0;
  *(_QWORD *)(*((_QWORD *)a1 + 68) + 8 * v21 + 8) = 0;
  if ((brk_DataOpen(*(_QWORD *)(*(_QWORD *)a1 + 24)) & 0x80000000) != 0)
    return v17;
  v22 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *((_QWORD *)a1 + 65), 8 * *((unsigned __int16 *)a1 + 288) + 16);
  if (!v22)
    goto LABEL_24;
  *((_QWORD *)a1 + 65) = v22;
  v23 = *((unsigned __int16 *)a1 + 288);
  *(_QWORD *)(v22 + 8 * v23) = 0;
  *(_QWORD *)(*((_QWORD *)a1 + 65) + 8 * v23 + 8) = 0;
  v24 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 1, 144);
  if (!v24)
    goto LABEL_24;
  v25 = *((unsigned __int16 *)a1 + 288);
  *(_QWORD *)(*((_QWORD *)a1 + 65) + 8 * v25) = v24;
  *((_QWORD *)v17 + 3) = *(_QWORD *)(*((_QWORD *)a1 + 65) + 8 * v25);
  inited = init_DctRom((uint64_t)(v17 + 2), __s, *v17, *(_QWORD *)(*((_QWORD *)a1 + 68) + 8 * v25));
  if (inited < 0)
  {
    if ((inited & 0x1FFF) == 0x14)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_QWORD *)(*((_QWORD *)a1 + 65) + 8 * *((unsigned __int16 *)a1 + 288)));
      v37 = *((unsigned __int16 *)a1 + 288);
      *(_QWORD *)(*((_QWORD *)a1 + 65) + 8 * v37) = 0;
      brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), *(_QWORD *)(*((_QWORD *)a1 + 68) + 8 * v37));
      *(_QWORD *)(*((_QWORD *)a1 + 68) + 8 * *((unsigned __int16 *)a1 + 288)) = 0;
    }
  }
  else
  {
    v27 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *((_QWORD *)a1 + 64), 8 * *((unsigned __int16 *)a1 + 288) + 16);
    if (v27
      && (*((_QWORD *)a1 + 64) = v27,
          v32 = *((unsigned __int16 *)a1 + 288),
          *(_QWORD *)(v27 + 8 * v32) = 0,
          *(_QWORD *)(*((_QWORD *)a1 + 64) + 8 * v32 + 8) = 0,
          v33 = strlen(v15),
          (v34 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v33 + 1))) != 0))
    {
      v35 = *((unsigned __int16 *)a1 + 288);
      *(_QWORD *)(*((_QWORD *)a1 + 64) + 8 * v35) = v34;
      strcpy(*(char **)(*((_QWORD *)a1 + 64) + 8 * v35), v15);
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v28, v29, v30, v31, v38);
    }
  }
  return v17;
}

uint64_t hlp_SearchDctName(uint64_t a1, const char *a2, char *__s)
{
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;

  v6 = strlen(__s);
  v7 = *(unsigned __int16 *)(a1 + 576);
  if (*(_WORD *)(a1 + 576))
  {
    v8 = 0;
    v9 = v6;
    v10 = *(_QWORD *)(a1 + 512);
    do
    {
      v11 = *(_QWORD *)(v10 + 8 * v8);
      if (v9)
      {
        if (!strncmp(*(const char **)(v10 + 8 * v8), __s, v9) && *(_BYTE *)(v11 + v9) == 95)
        {
          v12 = strlen(a2);
          if (!strncmp((const char *)(v11 + v9 + 1), a2, v12))
            return (__int16)v8;
        }
      }
      else if (!strcmp(*(const char **)(v10 + 8 * v8), a2))
      {
        return (__int16)v8;
      }
      ++v8;
    }
    while (v7 != v8);
  }
  LOWORD(v8) = -1;
  return (__int16)v8;
}

const char *lowercase(const char *__s, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  int v5;
  int v6;

  if (*__s)
  {
    v3 = __s;
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = v3[v4];
      if ((v6 - 65) < 0x1A)
        LOBYTE(v6) = v6 + 32;
      *(_BYTE *)(a2 + v4) = v6;
      v4 = (unsigned __int16)++v5;
      __s = (const char *)strlen(v3);
    }
    while ((unint64_t)__s > (unsigned __int16)v5);
  }
  else
  {
    v4 = 0;
  }
  *(_BYTE *)(a2 + v4) = 0;
  return __s;
}

uint64_t fe_dctlkp_LoadAddonDct(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, const char *a7)
{
  uint64_t v7;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  const char *v37;
  char *v38;
  char v39;
  uint64_t v40;
  const char *v41;
  char *v42;
  char v43;
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  unsigned int v49;
  _BYTE __c[11];

  *(_WORD *)&__c[1] = -1;
  v7 = 2306875402;
  if (!a1)
    return 2306875400;
  *(_QWORD *)&__c[3] = 0;
  v15 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 496), 8 * *(unsigned __int16 *)(a1 + 488) + 8);
  if (!v15)
    goto LABEL_6;
  *(_QWORD *)(a1 + 496) = v15;
  v20 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 640);
  v21 = *(unsigned __int16 *)(a1 + 488);
  *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v21) = v20;
  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v21);
  if (!v22)
    goto LABEL_6;
  if (a7)
  {
    v23 = strlen(a7);
    v24 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (v23 + 1));
    v25 = *(_QWORD *)(a1 + 496);
    v26 = *(unsigned __int16 *)(a1 + 488);
    *(_QWORD *)(*(_QWORD *)(v25 + 8 * v26) + 632) = v24;
    v27 = *(char **)(*(_QWORD *)(v25 + 8 * v26) + 632);
    if (!v27)
    {
LABEL_6:
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v16, v17, v18, v19, v49);
      return v7;
    }
  }
  else
  {
    v27 = *(char **)(v22 + 632);
  }
  strcpy(v27, a7);
  v28 = *(_QWORD *)(a1 + 496);
  v29 = *(unsigned __int16 *)(a1 + 488);
  *(_QWORD *)(*(_QWORD *)(v28 + 8 * v29) + 624) = a5;
  v30 = *(_QWORD *)(v28 + 8 * v29);
  *(_WORD *)(v30 + 72) = *(_WORD *)(a1 + 490);
  *(_QWORD *)(v30 + 56) = a3;
  v31 = *(_QWORD *)(v28 + 8 * v29);
  *(_DWORD *)(v31 + 64) = a4;
  v32 = open_DctRom((uint64_t *)(v31 + 8), 0, (_DWORD *)v31);
  if ((v32 & 0x80000000) != 0)
    return v32;
  __c[0] = 0;
  v33 = *(_QWORD *)(a1 + 496);
  v34 = *(unsigned __int16 *)(a1 + 488);
  *(_QWORD *)(*(_QWORD *)(v33 + 8 * v34) + 48) = *(_QWORD *)(a1 + 56);
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "lang", &__c[3], &__c[1], __c, *(unsigned int **)(v33 + 8 * v34));
  if (*(_WORD *)&__c[1])
  {
    v35 = strchr(**(char ***)&__c[3], __c[0]);
    if (v35)
      *v35 = 0;
    __strcpy_chk();
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "cfg", &__c[3], &__c[1], __c, *(unsigned int **)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  if (*(_WORD *)&__c[1])
  {
    v36 = strchr(**(char ***)&__c[3], __c[0]);
    if (v36)
      *v36 = 0;
    __strcpy_chk();
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "codecomp", &__c[3], &__c[1], __c, *(unsigned int **)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  if (*(_WORD *)&__c[1])
  {
    v37 = **(const char ***)&__c[3];
    v38 = strchr(**(char ***)&__c[3], __c[0]);
    if (v38)
    {
      *v38 = 0;
      v37 = **(const char ***)&__c[3];
    }
    v39 = atoi(v37);
    v40 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
    *(_BYTE *)(v40 + 104) = v39;
  }
  else
  {
    v40 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "datacomp", &__c[3], &__c[1], __c, (unsigned int *)v40);
  if (*(_WORD *)&__c[1])
  {
    v41 = **(const char ***)&__c[3];
    v42 = strchr(**(char ***)&__c[3], __c[0]);
    if (v42)
    {
      *v42 = 0;
      v41 = **(const char ***)&__c[3];
    }
    v43 = atoi(v41);
    v44 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
    *(_BYTE *)(v44 + 105) = v43;
  }
  else
  {
    v44 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "g2pdcts", &__c[3], &__c[1], __c, (unsigned int *)v44);
  if (*(_WORD *)&__c[1])
  {
    v45 = strchr(**(char ***)&__c[3], __c[0]);
    if (v45)
      *v45 = 0;
    __strcpy_chk();
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)) + 106) = 0;
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "tndcts", &__c[3], &__c[1], __c, *(unsigned int **)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  if (*(_WORD *)&__c[1])
  {
    v46 = strchr(**(char ***)&__c[3], __c[0]);
    if (v46)
      *v46 = 0;
    __strcpy_chk();
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)) + 362) = 0;
  }
  v7 = hlp_EnableAddon(a1, a2, *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  v47 = *(unsigned __int16 *)(a1 + 488);
  *(_QWORD *)a6 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v47);
  *(_DWORD *)(a6 + 8) = 62335;
  *(_WORD *)(a1 + 488) = v47 + 1;
  ++*(_WORD *)(a1 + 490);
  return v7;
}

uint64_t fe_dctlkp_UnLoadAddonDct(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v12;
  unint64_t v13;
  unsigned __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  const char *v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char __s[8];
  __int16 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  result = 2306875400;
  if (a1)
  {
    LOWORD(v5) = *(_WORD *)(a1 + 488);
    if ((_WORD)v5)
    {
      v6 = a3;
      v7 = 0;
      v8 = 8;
      do
      {
        if (*(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v7) == v6)
        {
          v9 = *(_QWORD *)(v6 + 632);
          if (v9)
          {
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v9);
            v10 = *(_QWORD *)(a1 + 496);
            *(_QWORD *)(*(_QWORD *)(v10 + 8 * v7) + 632) = 0;
            v11 = *(_QWORD *)(v10 + 8 * v7);
            v34 = 0;
            *(_QWORD *)__s = 0;
            if (!v11)
              return 2306875400;
          }
          else
          {
            v34 = 0;
            *(_QWORD *)__s = 0;
            v11 = v6;
          }
          LH_itoa(*(unsigned __int16 *)(v11 + 72), __s, 0xAu);
          v12 = *(_WORD *)(a1 + 576);
          if (v12)
          {
            v13 = 0;
            v14 = 0;
            v15 = 0;
            v16 = 0;
            do
            {
              v17 = *(_QWORD *)(a1 + 512);
              v18 = *(const char **)(v17 + 8 * v13);
              v19 = strlen(__s);
              if (!strncmp(v18, __s, v19))
              {
                v20 = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v13);
                if (v20)
                {
                  heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v20);
                  *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v13) = 0;
                  v18 = *(const char **)(*(_QWORD *)(a1 + 512) + 8 * v13);
                }
                if (v18)
                {
                  heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v18);
                  *(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * v13) = 0;
                }
                v21 = *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v13);
                if (v21)
                {
                  brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v21);
                  *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v13) = 0;
                }
                ++v16;
                v12 = *(_WORD *)(a1 + 576);
                v15 = 1;
              }
              else
              {
                if (v15)
                {
                  *(_QWORD *)(v17 + 8 * v14) = v18;
                  *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v14) = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v13);
                  *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v14) = *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v13);
                }
                ++v14;
              }
              ++v13;
            }
            while (v13 < v12);
            v6 = a3;
            if (v16)
            {
              *(_WORD *)(a1 + 576) = v12 - v16;
              v22 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 512), 8 * (unsigned __int16)(v12 - v16) + 16);
              if (!v22)
                return 2306875402;
              *(_QWORD *)(a1 + 512) = v22;
              v23 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 520), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
              if (!v23)
                return 2306875402;
              *(_QWORD *)(a1 + 520) = v23;
              v24 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 544), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
              if (!v24)
                return 2306875402;
              *(_QWORD *)(a1 + 544) = v24;
              v25 = *(unsigned __int16 *)(a1 + 576);
              *(_QWORD *)(*(_QWORD *)(a1 + 512) + 8 * v25) = 0;
              v26 = 8 * v25 + 8;
              *(_QWORD *)(*(_QWORD *)(a1 + 512) + v26) = 0;
              *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * v25) = 0;
              *(_QWORD *)(*(_QWORD *)(a1 + 520) + v26) = 0;
              *(_QWORD *)(*(_QWORD *)(a1 + 544) + 8 * v25) = 0;
              *(_QWORD *)(*(_QWORD *)(a1 + 544) + v26) = 0;
            }
          }
          v27 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v7);
          v28 = *(_QWORD *)(v27 + 624);
          if (v28)
          {
            v29 = *(_QWORD *)(v27 + 56);
            if (v29)
            {
              brk_DataUnmap(*(_QWORD *)(*(_QWORD *)a1 + 24), v28, v29);
              v28 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v7) + 624);
            }
            brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v28);
            v27 = *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v7);
          }
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v27);
          v5 = *(unsigned __int16 *)(a1 + 488) - 1;
          if (v5 > (int)v7)
          {
            v30 = (unsigned __int16)v7;
            v31 = v8;
            do
            {
              *(_QWORD *)(*(_QWORD *)(a1 + 496) + 8 * v30++) = *(_QWORD *)(*(_QWORD *)(a1 + 496) + v31);
              v31 += 8;
            }
            while (v5 > (unsigned __int16)v30);
          }
          *(_WORD *)(a1 + 488) = v5;
        }
        ++v7;
        v8 += 8;
      }
      while (v7 < (unsigned __int16)v5);
    }
    return 0;
  }
  return result;
}

uint64_t fe_dctlkp_GetCfgParamVal(uint64_t a1, int a2, const char *a3, char *a4, char **a5)
{
  uint64_t v6;
  char *v7;
  char *v8;
  char **v10;
  unsigned __int8 __c;
  __int16 __c_1;

  *a5 = a4;
  __c_1 = -1;
  __c = 0;
  v10 = 0;
  v6 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", a3, &v10, &__c_1, &__c, 0);
  if ((v6 & 0x80000000) == 0 && __c_1)
  {
    v7 = *v10;
    v8 = strchr(*v10, __c);
    if (v8)
    {
      *v8 = 0;
      v7 = *v10;
    }
    *a5 = v7;
  }
  return v6;
}

uint64_t fe_dctlkp_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2306875393;
  result = 0;
  *a2 = &IFeDctLkp;
  return result;
}

uint64_t loc_fe_dctlkp_getTokenDef(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, char **a6)
{
  uint64_t v10;
  const char *v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unsigned int v21;
  _BYTE __c[11];
  char v23[256];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  memset(__c, 0, sizeof(__c));
  __strcpy_chk();
  __strcat_chk();
  v10 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v23, &__c[3], &__c[1], __c, 0);
  if ((v10 & 0x80000000) == 0 && *(unsigned __int16 *)&__c[1] == 1)
  {
    v11 = **(const char ***)&__c[3];
    v12 = strchr(**(char ***)&__c[3], __c[0]);
    if (v12)
    {
      *v12 = 0;
      v11 = **(const char ***)&__c[3];
    }
    v13 = strlen(v11);
    v18 = *a3;
    if (v13 < 0x100)
    {
      v19 = (char *)heap_Calloc(*(_QWORD **)(v18 + 8), v13 + 1, 1);
      *a6 = v19;
      if (v19)
        strcpy(v19, **(const char ***)&__c[3]);
      else
        return 2306875402;
    }
    else
    {
      v10 = 2306875392;
      log_OutPublic(*(_QWORD *)(v18 + 32), (uint64_t)"FE_DCTLKP", 41003, 0, v14, v15, v16, v17, v21);
    }
  }
  return v10;
}

char *heap_strdup(uint64_t a1, char *__s)
{
  int v4;
  char *result;

  v4 = strlen(__s);
  result = (char *)heap_Alloc(a1, (v4 + 1));
  if (result)
    return strcpy(result, __s);
  return result;
}

BOOL hlp_getUtf8CanMap(uint64_t a1, int a2, uint64_t a3, uint64_t a4, const char *a5, char *a6)
{
  unint64_t i;
  const char *v11;
  int v12;
  size_t v13;
  char v15;
  unsigned __int16 v16;
  uint64_t v17;
  char v18[256];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  if (!*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)a5))
    return 0;
  v17 = 0;
  v15 = 0;
  *a6 = 0;
  __strcpy_chk();
  __strcat_chk();
  __strcat_chk();
  if ((loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v18, &v17, &v16, &v15, 0) & 0x80000000) != 0)
    return 0;
  if (!v16)
  {
    v16 = 0;
    __strcpy_chk();
    if ((loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v18, &v17, &v16, &v15, 0) & 0x80000000) != 0 || !v16)
      return 0;
  }
  if (*a6)
    return 1;
  for (i = 0; i < v16; ++i)
  {
    v11 = *(const char **)(v17 + 8 * i);
    v12 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v11);
    v11[utf8_determineUTF8CharLength(*(unsigned __int8 *)v11)] = 0;
    v13 = strlen(v11);
    if (!strncmp(v11, a5, v13))
      strcpy(a6, &v11[v12 + 1]);
    if (*a6)
      break;
  }
  return *a6 != 0;
}

uint64_t fe_nn_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2706382849;
  result = 0;
  *a2 = &IFeNn;
  return result;
}

uint64_t WordScanner_ResetFrom(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned int PreviousUtf8OffsetLimit;
  unsigned int v7;

  v2 = *(unsigned __int16 *)(a1 + 16);
  if (v2 <= a2)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"u16From");
  v3 = a2;
  if (utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), a2, v2))
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"u16From");
  PreviousUtf8OffsetLimit = (unsigned __int16)utf8_GetPreviousUtf8OffsetLimit(*(_QWORD *)(a1 + 8), v3, *(unsigned __int16 *)(a1 + 16));
  v7 = *(unsigned __int16 *)(a1 + 16);
  if (PreviousUtf8OffsetLimit < v7)
  {
    if (!utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), PreviousUtf8OffsetLimit, v7))
      return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"u16From");
    v7 = *(unsigned __int16 *)(a1 + 16);
  }
  for (*(_WORD *)(a1 + 18) = v3; v7 > v3; v7 = *(unsigned __int16 *)(a1 + 16))
  {
    if (utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), v3, v7))
      break;
    LODWORD(v3) = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(*(_BYTE **)(a1 + 8), v3, *(unsigned __int16 *)(a1 + 16));
  }
  *(_WORD *)(a1 + 20) = v3;
  return 0;
}

uint64_t WordScanner_ConFrom(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__WordScanner;
    if (a2)
    {
      *(_QWORD *)(a1 + 8) = a2;
      *(_WORD *)(a1 + 16) = strlen(a2);
      return WordScanner_ResetFrom(a1, a3);
    }
    else
    {
      return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"szString");
    }
  }
  return result;
}

uint64_t WordScanner_NextWord(uint64_t a1)
{
  uint64_t NextUtf8OffsetLimit;
  unsigned int i;
  int v4;

  NextUtf8OffsetLimit = *(unsigned __int16 *)(a1 + 20);
  for (i = *(unsigned __int16 *)(a1 + 16); i > NextUtf8OffsetLimit; i = *(unsigned __int16 *)(a1 + 16))
  {
    v4 = utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), NextUtf8OffsetLimit, i);
    i = *(unsigned __int16 *)(a1 + 16);
    if (!v4)
      break;
    NextUtf8OffsetLimit = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(*(_BYTE **)(a1 + 8), NextUtf8OffsetLimit, *(unsigned __int16 *)(a1 + 16));
  }
  if (NextUtf8OffsetLimit >= i)
    return 0;
  *(_WORD *)(a1 + 18) = NextUtf8OffsetLimit;
  do
  {
    if (utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), NextUtf8OffsetLimit, i))
      break;
    LODWORD(NextUtf8OffsetLimit) = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(*(_BYTE **)(a1 + 8), NextUtf8OffsetLimit, *(unsigned __int16 *)(a1 + 16));
    i = *(unsigned __int16 *)(a1 + 16);
  }
  while (i > NextUtf8OffsetLimit);
  *(_WORD *)(a1 + 20) = NextUtf8OffsetLimit;
  return 1;
}

uint64_t WordScanner_PrevWord(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int PreviousUtf8OffsetLimit;
  unsigned int v7;
  int v8;
  unsigned __int16 v9;

  v2 = *(unsigned __int16 *)(a1 + 18);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(unsigned __int16 *)(a1 + 16);
  v5 = v2;
  while (1)
  {
    PreviousUtf8OffsetLimit = (unsigned __int16)utf8_GetPreviousUtf8OffsetLimit(v3, v5, v4);
    v7 = *(unsigned __int16 *)(a1 + 16);
    if (PreviousUtf8OffsetLimit >= v7)
      break;
    v8 = utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), PreviousUtf8OffsetLimit, v7);
    v7 = *(unsigned __int16 *)(a1 + 16);
    if (!v8)
      break;
    LOWORD(v2) = PreviousUtf8OffsetLimit;
    v3 = *(_QWORD *)(a1 + 8);
    v5 = PreviousUtf8OffsetLimit;
    v4 = *(unsigned __int16 *)(a1 + 16);
  }
  if (PreviousUtf8OffsetLimit >= v7)
    return 0;
  *(_WORD *)(a1 + 20) = v2;
  while (!utf8_BelongsToSet(1u, *(_BYTE **)(a1 + 8), PreviousUtf8OffsetLimit, v7))
  {
    LOWORD(v2) = PreviousUtf8OffsetLimit;
    v9 = utf8_GetPreviousUtf8OffsetLimit(*(_QWORD *)(a1 + 8), PreviousUtf8OffsetLimit, *(unsigned __int16 *)(a1 + 16));
    v7 = *(unsigned __int16 *)(a1 + 16);
    if (v7 <= v9)
      break;
    PreviousUtf8OffsetLimit = v9;
  }
  *(_WORD *)(a1 + 18) = v2;
  return 1;
}

uint64_t WordScanner_WordLen(uint64_t a1)
{
  return (unsigned __int16)(*(_WORD *)(a1 + 20) - *(_WORD *)(a1 + 18));
}

uint64_t PNEW_WordScanner_ConFrom(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 24, &v10);
  result = v10;
  if (!v10)
  {
    result = WordScanner_ConFrom(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t ooc_utils_createAllocator(uint64_t a1, _WORD *a2, int a3)
{
  __int128 v5;
  uint64_t (*v6)(uint64_t *, uint64_t, uint64_t);
  _QWORD *(*v7)(_QWORD *, uint64_t);
  uint64_t v8;

  v8 = 0;
  *(_QWORD *)&v5 = heap_Alloc;
  *((_QWORD *)&v5 + 1) = heap_Calloc;
  v6 = heap_Realloc;
  v7 = heap_Free;
  if ((InitRsrcFunction(a2, a3, &v8) & 0x80000000) == 0)
    return OOCAllocator_Con(a1, &v5, *(_QWORD *)(v8 + 8));
  err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
  return 9;
}

uint64_t err_GenerateErrorInternalMsg(uint64_t a1)
{
  uint64_t v3;
  void (*v4)(uint64_t, uint64_t, const char *, uint64_t);

  v3 = 0;
  v4 = 0;
  err_ErrorGetCallback(&v4, &v3);
  if (v4)
    v4(v3, 9, "Internal Error.", a1);
  return 9;
}

uint64_t Params_Con(_QWORD *a1, _WORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    *a1 = &__Params;
    a1[1] = a2;
    a1[2] = a3;
    a1[3] = 0;
    if ((InitRsrcFunction(a2, a3, a1 + 3) & 0x80000000) != 0)
    {
      return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
    }
    else
    {
      result = ooc_utils_createAllocator((uint64_t)(a1 + 4), (_WORD *)a1[1], a1[2]);
      if (!(_DWORD)result)
        a1[9] = a4;
    }
  }
  return result;
}

uint64_t Params_Des(uint64_t a1)
{
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 32));
  return Object_Des();
}

uint64_t Params_GetCfgParamValueFloat(uint64_t a1, _BYTE *a2, float *a3, float a4)
{
  uint64_t CfgParamValueString;
  char *v7;
  float v8;
  char *v10;

  v10 = 0;
  if (!a3)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pVal");
  *a3 = a4;
  CfgParamValueString = Params_GetCfgParamValueString(a1, a2, &v10);
  v7 = v10;
  if (!(_DWORD)CfgParamValueString && v10)
  {
    CfgParamValueString = 0;
    if (*v10)
    {
      v8 = atof(v10);
      *a3 = v8;
    }
    goto LABEL_8;
  }
  if (v10)
LABEL_8:
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v7);
  return CfgParamValueString;
}

uint64_t Params_GetCfgParamValueString(uint64_t a1, _BYTE *a2, char **a3)
{
  const char *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  int v10;
  char *v11;
  char *v12;
  uint64_t ErrorInternalMsg;
  const char *v15;
  _BYTE __c[7];
  __int16 v17;
  char **v18;
  _QWORD *v19;

  v18 = 0;
  v19 = 0;
  v17 = -1;
  *(_DWORD *)&__c[1] = 0;
  __c[0] = 0;
  if (!a2 || !*a2)
  {
    v12 = "szParamName";
LABEL_17:
    ErrorInternalMsg = kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)v12);
LABEL_18:
    v7 = ErrorInternalMsg;
    goto LABEL_19;
  }
  if (!a3)
  {
    v12 = "pszParamValue";
    goto LABEL_17;
  }
  *a3 = 0;
  if ((objc_GetObject(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48), (uint64_t)"FE_DCTLKP", &v19) & 0x80000000) != 0)
  {
    v15 = "objc_GetObject";
LABEL_26:
    ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v15);
    goto LABEL_18;
  }
  v6 = *(const char **)(a1 + 72);
  if (!strcmp(v6, "fecfg"))
    goto LABEL_9;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, _BYTE *))(v19[1] + 72))(v19[2], v19[3], v6, &__c[1]) & 0x80000000) != 0)
  {
    v15 = "pIDctlkp->pfQueryDictExists";
    goto LABEL_26;
  }
  if (!*(_DWORD *)&__c[1])
  {
    v7 = 0;
    v17 = 0;
    goto LABEL_19;
  }
  v17 = 1;
  v6 = *(const char **)(a1 + 72);
LABEL_9:
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, _BYTE *, char ***, __int16 *, _BYTE *))(v19[1] + 96))(v19[2], v19[3], v6, a2, &v18, &v17, __c) & 0x80000000) != 0)
  {
    v15 = "pIDctlkp->pfLookupUtf";
    goto LABEL_26;
  }
  v7 = 0;
  if (v17 == 1 && v18)
  {
    v8 = *v18;
    v9 = strchr(*v18, __c[0]);
    if (v9)
    {
      *v9 = 0;
      v8 = *v18;
    }
    v10 = strlen(v8);
    v11 = (char *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), 1, (v10 + 1));
    *a3 = v11;
    if (v11)
    {
      strcpy(v11, *v18);
      v7 = 0;
      goto LABEL_19;
    }
    ErrorInternalMsg = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_18;
  }
LABEL_19:
  if (v19)
    objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48), (uint64_t)"FE_DCTLKP");
  return v7;
}

uint64_t Params_GetCfgParamValueInteger(uint64_t a1, _BYTE *a2, int a3, int *a4)
{
  uint64_t CfgParamValueString;
  char *v7;
  char *v9;

  v9 = 0;
  if (!a4)
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pVal");
  *a4 = a3;
  CfgParamValueString = Params_GetCfgParamValueString(a1, a2, &v9);
  v7 = v9;
  if (!(_DWORD)CfgParamValueString && v9)
  {
    CfgParamValueString = 0;
    if (*v9)
      *a4 = atoi(v9);
    goto LABEL_8;
  }
  if (v9)
LABEL_8:
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v7);
  return CfgParamValueString;
}

uint64_t Params_GetCfgParamValueListOfStrings(uint64_t a1, _BYTE *a2, unsigned __int8 a3, uint64_t *a4)
{
  uint64_t CfgParamValueString;
  char *v9;
  char *v11;

  v11 = 0;
  if (*a4
    || (CfgParamValueString = PNEW_StringList_Con(a1 + 32, *(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), a4),
        !(_DWORD)CfgParamValueString))
  {
    CfgParamValueString = Params_GetCfgParamValueString(a1, a2, &v11);
    v9 = v11;
    if (!(_DWORD)CfgParamValueString && v11)
    {
      CfgParamValueString = StringList_FromSplitString(*a4, v11, a3);
      v9 = v11;
    }
    if (v9)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v9);
  }
  return CfgParamValueString;
}

uint64_t PNEW_Params_Con(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  _QWORD *v10;
  uint64_t result;
  unsigned int v12;

  v12 = 0;
  v10 = (_QWORD *)OOCAllocator_Malloc(a1, 80, &v12);
  result = v12;
  if (!v12)
  {
    result = Params_Con(v10, a2, a3, a4);
    v12 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t StringList_Con(uint64_t a1, _WORD *a2, uint64_t a3)
{
  uint64_t result;
  int inited;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)a1 = &__StringList;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = a3;
    *(_WORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_WORD *)(a1 + 64) = -1;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    inited = InitRsrcFunction(a2, a3, (_QWORD *)(a1 + 24));
    result = 0;
    if (inited < 0)
      return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
  }
  return result;
}

uint64_t StringList_Des(_QWORD *a1)
{
  StringList_Reset(a1);
  return Object_Des();
}

_QWORD *StringList_Reset(_QWORD *result)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v1 = result;
  v2 = (uint64_t *)result[4];
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      v5 = 0;
      do
      {
        heap_Free(*(_QWORD **)(v1[3] + 8), v3);
        *(_QWORD *)(v1[4] + 8 * v4) = 0;
        ++v5;
        v2 = (uint64_t *)v1[4];
        v4 = (unsigned __int16)v5;
        v3 = v2[(unsigned __int16)v5];
      }
      while (v3);
    }
    result = heap_Free(*(_QWORD **)(v1[3] + 8), (uint64_t)v2);
    v1[4] = 0;
    *((_WORD *)v1 + 20) = 0;
  }
  v1[6] = 0;
  v1[7] = 0;
  *((_WORD *)v1 + 32) = -1;
  return result;
}

uint64_t StringList_Append(uint64_t a1, char *__s)
{
  uint64_t v2;
  int v3;
  unsigned __int16 v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = 0;
    do
      v4 = v3;
    while (*(_QWORD *)(v2 + 8 * (unsigned __int16)v3++));
  }
  else
  {
    v4 = 0;
  }
  return StringList_InsertAt(a1, v4, __s);
}

uint64_t StringList_InsertAt(uint64_t a1, unsigned int a2, char *__s)
{
  uint64_t v6;
  int v7;
  unsigned __int16 v8;
  unsigned int v10;
  uint64_t result;
  unsigned int v12;
  unsigned __int16 v13;
  kaldi::nnet1::UpdatableComponent *v14;
  kaldi::nnet1::UpdatableComponent *v15;
  size_t v16;
  kaldi::nnet1::UpdatableComponent *v17;
  uint64_t v18;

  v6 = *(_QWORD *)(a1 + 32);
  if (v6)
  {
    v7 = 0;
    do
      v8 = v7;
    while (*(_QWORD *)(v6 + 8 * (unsigned __int16)v7++));
  }
  else
  {
    v8 = 0;
  }
  v10 = v8;
  if (v8 < a2)
    return 3;
  v12 = *(unsigned __int16 *)(a1 + 40);
  if (v8 + 2 > v12)
  {
    v13 = v12 + 20;
    v14 = (kaldi::nnet1::UpdatableComponent *)heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 24) + 8), v6, 8 * (unsigned __int16)(v12 + 20));
    if (!v14)
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v14);
    v15 = v14;
    if (v10 < v13)
      bzero((char *)v14 + 8 * v10, 8 * (unsigned __int16)(v12 - v10 + 19) + 8);
    *(_QWORD *)(a1 + 32) = v15;
    *(_WORD *)(a1 + 40) = v13;
  }
  v16 = strlen(__s);
  v14 = (kaldi::nnet1::UpdatableComponent *)__StringList_hlpDuplicateSubString(a1, (uint64_t)__s, 0, v16);
  if (v14)
  {
    v17 = v14;
    v18 = *(_QWORD *)(a1 + 32) + 8 * a2;
    memmove((void *)(v18 + 8), (const void *)v18, 8 * (int)(v10 - a2));
    result = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * a2) = v17;
    return result;
  }
  return kaldi::nnet1::UpdatableComponent::IsUpdatable(v14);
}

uint64_t StringList_GetCountStrings(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unsigned __int16 v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    v2 = 0;
    do
      v3 = v2;
    while (*(_QWORD *)(v1 + 8 * (unsigned __int16)v2++));
  }
  else
  {
    return 0;
  }
  return v3;
}

uint64_t StringList_FromSplitString(uint64_t a1, const char *a2, unsigned __int8 a3)
{
  int v5;
  size_t v6;
  size_t v7;
  uint64_t v8;
  unsigned __int16 v9;
  uint64_t v10;
  int v11;
  int v13;
  kaldi::nnet1::UpdatableComponent *v14;
  uint64_t v15;
  unint64_t v16;
  unsigned __int16 v17;
  int v18;
  uint64_t IsUpdatable;

  v5 = a3;
  StringList_Reset((_QWORD *)a1);
  v6 = strlen(a2);
  v7 = v6;
  v8 = 0;
  v9 = 0;
  v10 = 1;
  if (v6 + 1 > 1)
    v10 = v6 + 1;
  do
  {
    v11 = a2[v8];
    if (v11 == v5 || v11 == 0)
      ++v9;
    ++v8;
  }
  while (v10 != v8);
  v13 = v9 + 1;
  v14 = (kaldi::nnet1::UpdatableComponent *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), 1, (8 * v13));
  *(_QWORD *)(a1 + 32) = v14;
  if (v14)
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    *(_WORD *)(a1 + 40) = v13;
    do
    {
      v18 = a2[v16];
      if (v18 == v5 || v18 == 0)
      {
        v14 = (kaldi::nnet1::UpdatableComponent *)__StringList_hlpDuplicateSubString(a1, (uint64_t)a2, v15, v16);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v17) = v14;
        if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v17))
          goto LABEL_20;
        ++v16;
        ++v17;
        v15 = v16;
      }
      else
      {
        ++v16;
      }
    }
    while (v16 <= v7);
    return 0;
  }
  else
  {
LABEL_20:
    IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(v14);
    if ((_DWORD)IsUpdatable)
      StringList_Reset((_QWORD *)a1);
  }
  return IsUpdatable;
}

char *__StringList_hlpDuplicateSubString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v6;
  char *result;

  v6 = a4 - a3;
  result = (char *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), 1, a4 - a3 + 1);
  if (result)
    return strncpy(result, (const char *)(a2 + a3), v6);
  return result;
}

uint64_t StringList_FromSplitStringInUtf8(uint64_t a1, char *__s, int a3, char *__src, const char *a5, _WORD *a6)
{
  uint64_t v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  int v15;
  int v17;
  uint64_t *v18;
  uint64_t v19;
  kaldi::nnet1::UpdatableComponent *v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned __int16 v25;
  const char *v26;
  unsigned __int16 v27;
  char *v28;
  _WORD *v30;

  v11 = *(_QWORD *)(a1 + 32);
  if (v11
    && ((v12 = *(unsigned __int16 *)(a1 + 64), v12 >= 7) ? (v13 = v12 == 0xFFFF) : (v13 = 1),
        !v13 || (StringList_Reset((_QWORD *)a1), (v11 = *(_QWORD *)(a1 + 32)) != 0)))
  {
    v14 = 0;
    do
      v15 = v14;
    while (*(_QWORD *)(v11 + 8 * (unsigned __int16)v14++));
    v17 = 0;
  }
  else
  {
    v15 = 0;
    v17 = 1;
  }
  if (a3 == 0xFFFF)
    LOWORD(a3) = strlen(__s);
  if ((unsigned __int16)v15 < (unsigned __int16)a3)
  {
    v18 = *(uint64_t **)(*(_QWORD *)(a1 + 24) + 8);
    v19 = 8 * (unsigned __int16)a3;
    if (v17)
    {
      v20 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc((uint64_t)v18, v19 + 8);
      if (!v20)
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v20);
    }
    else
    {
      v20 = (kaldi::nnet1::UpdatableComponent *)heap_Realloc(v18, v11, v19 + 8);
      if (!v20)
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v20);
    }
    v21 = v15;
    do
      *((_QWORD *)v20 + (unsigned __int16)v21++) = 0;
    while ((unsigned __int16)v21 <= (unsigned __int16)a3);
    *(_QWORD *)(a1 + 32) = v20;
    *(_WORD *)(a1 + 40) = a3 + 1;
    v22 = (unsigned __int16)v15;
    while (1)
    {
      v20 = (kaldi::nnet1::UpdatableComponent *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), 1, 7);
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v22) = v20;
      if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v22))
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v20);
      if ((unsigned __int16)a3 == ++v22)
      {
        *(_WORD *)(a1 + 64) = 7;
        break;
      }
    }
  }
  LOWORD(v23) = 0;
  if (*__s && (_WORD)a3)
  {
    v30 = a6;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    do
    {
      v26 = &__s[v24];
      v27 = Utf8_LengthInBytes((unsigned __int8 *)&__s[v24], 1);
      if (a5 && !strncmp(v26, " ", v27))
      {
        strcpy(*(char **)(*(_QWORD *)(a1 + 32) + 8 * v23), a5);
      }
      else
      {
        strncpy(*(char **)(*(_QWORD *)(a1 + 32) + 8 * v23), v26, v27);
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v23) + v27) = 0;
      }
      ++v23;
      v25 += v27;
      if (strlen(__s) <= v25)
        break;
      v24 = v25;
    }
    while (v23 < (unsigned __int16)a3);
    a6 = v30;
  }
  *a6 = v23;
  if ((unsigned __int16)v23 < (unsigned __int16)a3)
  {
    v23 = (unsigned __int16)v23;
    do
    {
      v28 = *(char **)(*(_QWORD *)(a1 + 32) + 8 * v23);
      if (__src)
        strcpy(v28, __src);
      else
        *v28 = 0;
      ++v23;
    }
    while ((unsigned __int16)a3 != (unsigned __int16)v23);
  }
  return 0;
}

uint64_t StringList_GetAt(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    return 0;
  v3 = 0;
  do
    v4 = v3;
  while (*(_QWORD *)(v2 + 8 * (unsigned __int16)v3++));
  if (a2 < v4)
    return *(_QWORD *)(v2 + 8 * a2);
  else
    return 0;
}

uint64_t StringList_GetIndex(uint64_t a1, char *__s2)
{
  const char **v2;
  const char *v3;
  unsigned __int16 v5;

  if (__s2 && (v2 = *(const char ***)(a1 + 32), (v3 = *v2) != 0))
  {
    v5 = 0;
    while (strcmp(v3, __s2))
    {
      v3 = v2[++v5];
      if (!v3)
        return (unsigned __int16)-1;
    }
  }
  else
  {
    return (unsigned __int16)-1;
  }
  return v5;
}

uint64_t StringList_RemoveAt(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  int v5;
  unsigned __int16 v6;
  uint64_t v8;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    return 3;
  v5 = 0;
  do
    v6 = v5;
  while (*(_QWORD *)(v2 + 8 * (unsigned __int16)v5++));
  if (a2 >= v6)
    return 3;
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), *(_QWORD *)(v2 + 8 * a2));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * a2) = 0;
  v8 = *(_QWORD *)(a1 + 32) + 8 * a2;
  memmove((void *)v8, (const void *)(v8 + 8), 8 * (int)(~a2 + v6));
  result = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (v6 - 1)) = 0;
  return result;
}

uint64_t PNEW_StringList_Con(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = 0;
  v8 = OOCAllocator_Malloc(a1, 72, &v10);
  result = v10;
  if (!v10)
  {
    result = StringList_Con(v8, a2, a3);
    v10 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t NN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t result;

  result = Object_Con((_QWORD *)a1);
  if (!(_DWORD)result)
  {
    *(_WORD *)(a1 + 136) = 0;
    *(_WORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = 0;
    *(_QWORD *)(a1 + 160) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_WORD *)(a1 + 120) = 0;
    *(_QWORD *)a1 = &__NN;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = a3;
    *(_QWORD *)(a1 + 32) = a4;
    *(_QWORD *)(a1 + 40) = a5;
    *(_QWORD *)(a1 + 96) = 0;
    if ((InitRsrcFunction(a4, a5, (_QWORD *)(a1 + 48)) & 0x80000000) != 0
      || (InitRsrcFunction(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), (_QWORD *)(a1 + 24)) & 0x80000000) != 0)
    {
      return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
    }
    else
    {
      return ooc_utils_createAllocator(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
    }
  }
  return result;
}

uint64_t NN_Des(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v1 = (_QWORD *)result;
    v2 = *(_QWORD *)(result + 96);
    if (v2)
    {
      OOCAllocator_Free(result + 56, v2);
      v1[12] = 0;
    }
    v3 = v1[13];
    if (v3)
    {
      OOC_PlacementDeleteObject((uint64_t)(v1 + 7), v3);
      v1[13] = 0;
    }
    v4 = v1[14];
    if (v4)
    {
      OOC_PlacementDeleteObject((uint64_t)(v1 + 7), v4);
      v1[14] = 0;
    }
    __NN_CGN_Deinitialize((uint64_t)v1);
    __NN_TN_Deinitialize((uint64_t)v1);
    __NN_CLM_Deinitialize((uint64_t)v1);
    kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v1 + 7));
    return Object_Des();
  }
  return result;
}

uint64_t __NN_CGN_Deinitialize(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *(unsigned __int16 *)(result + 120);
  if (*(_WORD *)(result + 120))
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*(_QWORD *)(v1 + 128) + 8 * v3);
      if (v4)
      {
        result = OOC_PlacementDeleteObject(v1 + 56, v4);
        *(_QWORD *)(*(_QWORD *)(v1 + 128) + 8 * v3) = 0;
        v2 = *(unsigned __int16 *)(v1 + 120);
      }
      ++v3;
    }
    while (v3 < v2);
    if (v2)
    {
      result = OOCAllocator_Free(v1 + 56, *(_QWORD *)(v1 + 128));
      *(_QWORD *)(v1 + 128) = 0;
    }
  }
  *(_WORD *)(v1 + 120) = 0;
  return result;
}

uint64_t __NN_TN_Deinitialize(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *(unsigned __int16 *)(result + 136);
  if (*(_WORD *)(result + 136))
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*(_QWORD *)(v1 + 144) + 8 * v3);
      if (v4)
      {
        result = OOC_PlacementDeleteObject(v1 + 56, v4);
        *(_QWORD *)(*(_QWORD *)(v1 + 144) + 8 * v3) = 0;
        v2 = *(unsigned __int16 *)(v1 + 136);
      }
      ++v3;
    }
    while (v3 < v2);
    if (v2)
    {
      result = OOCAllocator_Free(v1 + 56, *(_QWORD *)(v1 + 144));
      *(_QWORD *)(v1 + 144) = 0;
    }
  }
  *(_WORD *)(v1 + 136) = 0;
  return result;
}

uint64_t __NN_CLM_Deinitialize(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *(unsigned __int16 *)(result + 152);
  if (*(_WORD *)(result + 152))
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*(_QWORD *)(v1 + 160) + 8 * v3);
      if (v4)
      {
        result = OOC_PlacementDeleteObject(v1 + 56, v4);
        *(_QWORD *)(*(_QWORD *)(v1 + 160) + 8 * v3) = 0;
        v2 = *(unsigned __int16 *)(v1 + 152);
      }
      ++v3;
    }
    while (v3 < v2);
    if (v2)
    {
      result = OOCAllocator_Free(v1 + 56, *(_QWORD *)(v1 + 160));
      *(_QWORD *)(v1 + 160) = 0;
    }
  }
  *(_WORD *)(v1 + 152) = 0;
  return result;
}

uint64_t NN_CGN_Predict(uint64_t a1, int a2, const char *a3, const char *a4, uint64_t a5, _QWORD *a6, int *a7)
{
  int v13;
  uint64_t result;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;

  v13 = safeh_HandleCheck(a1, a2, 1067, 8);
  result = 2706382856;
  if ((v13 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      v15 = *(unsigned __int16 *)(a1 + 120);
      if (!*(_WORD *)(a1 + 120))
        goto LABEL_9;
      v16 = *(uint64_t **)(a1 + 128);
      while (1)
      {
        v17 = *v16;
        if (*v16)
        {
          if (!strcmp(a3, *(const char **)(v17 + 120)))
            break;
        }
        ++v16;
        if (!--v15)
          goto LABEL_9;
      }
      result = CGN_Predict(v17, a4, a5, a6, a7);
      if ((_DWORD)result)
      {
        result = LH_ERROR_to_VERROR(result);
        if ((result & 0x1FFF) == 7)
        {
LABEL_9:
          result = 0;
          *a7 = 0;
        }
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_IsInitializedForCurrent(uint64_t a1)
{
  const char *v3;
  char __s1[256];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (__NN_GetIdentificationForCurrent(a1, __s1))
    return 0;
  v3 = *(const char **)(a1 + 96);
  return v3 && strcmp(__s1, v3) == 0;
}

BOOL NN_CGN_QueryModelExists(uint64_t a1, int a2, const char *a3)
{
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;

  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0)
    return 0;
  if (!a1)
    return 0;
  if (!NN_IsInitializedForCurrent(a1))
    return 0;
  v5 = *(unsigned __int16 *)(a1 + 120);
  if (!*(_WORD *)(a1 + 120))
    return 0;
  for (i = *(uint64_t **)(a1 + 128); ; ++i)
  {
    v7 = *i;
    if (*i)
    {
      if (!strcmp(a3, *(const char **)(v7 + 120)))
        break;
    }
    if (!--v5)
      return 0;
  }
  return Model_QueryExists(v7);
}

uint64_t NN_CLM_Predict(uint64_t a1, int a2, const char *a3, char **a4, char **a5, char **a6, unsigned int *a7, uint64_t a8, uint64_t a9)
{
  int v16;
  uint64_t result;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;

  v16 = safeh_HandleCheck(a1, a2, 1067, 8);
  result = 2706382856;
  if ((v16 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      v18 = *(unsigned __int16 *)(a1 + 152);
      if (!*(_WORD *)(a1 + 152))
        goto LABEL_9;
      v19 = *(uint64_t **)(a1 + 160);
      while (1)
      {
        v20 = *v19;
        if (*v19)
        {
          if (!strcmp(a3, *(const char **)(v20 + 120)))
            break;
        }
        ++v19;
        if (!--v18)
          goto LABEL_9;
      }
      result = CLM_Predict(v20, a4, a5, a6, *a7, a8, a9);
      if ((_DWORD)result)
      {
        result = LH_ERROR_to_VERROR(result);
        if ((result & 0x1FFF) == 7)
        {
LABEL_9:
          result = 0;
          *a7 = 0;
        }
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_CLM_QueryModelExists(uint64_t a1, int a2, const char *a3)
{
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;

  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0)
    return 0;
  if (!a1)
    return 0;
  if (!NN_IsInitializedForCurrent(a1))
    return 0;
  v5 = *(unsigned __int16 *)(a1 + 152);
  if (!*(_WORD *)(a1 + 152))
    return 0;
  for (i = *(uint64_t **)(a1 + 160); ; ++i)
  {
    v7 = *i;
    if (*i)
    {
      if (!strcmp(a3, *(const char **)(v7 + 120)))
        break;
    }
    if (!--v5)
      return 0;
  }
  return Model_QueryExists(v7);
}

uint64_t NN_ClassClose()
{
  return 0;
}

uint64_t NN_ClassOpen(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2706382855;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t NN_G2POneWord_Predict(uint64_t a1, int a2, char *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  int v10;

  v7 = safeh_HandleCheck(a1, a2, 1067, 8);
  result = 2706382856;
  if ((v7 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      v9 = *(_QWORD *)(a1 + 112);
      if (v9)
      {
        v10 = G2POneWord_Predict(v9, a3, a4);
        result = v7;
        if (v10)
          return LH_ERROR_to_VERROR(v10);
      }
      else
      {
        return v7;
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_G2POneWord_QueryModelExists(uint64_t a1, int a2)
{
  uint64_t v3;

  return (safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) == 0
      && a1
      && NN_IsInitializedForCurrent(a1)
      && (v3 = *(_QWORD *)(a1 + 112)) != 0
      && Model_QueryExists(v3);
}

uint64_t NN_InitializeForCurrent(uint64_t a1)
{
  uint64_t IdentificationForCurrent;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  size_t v7;
  char *v8;
  uint64_t v9;
  unsigned int v11;
  int v12;
  char __s[256];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (NN_IsInitializedForCurrent(a1))
    return 0;
  v3 = *(_QWORD *)(a1 + 96);
  if (v3)
  {
    OOCAllocator_Free(a1 + 56, v3);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v5 = (uint64_t *)(a1 + 104);
  v4 = *(_QWORD *)(a1 + 104);
  if (v4)
  {
    OOC_PlacementDeleteObject(a1 + 56, v4);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v6 = *(_QWORD *)(a1 + 112);
  if (v6)
  {
    OOC_PlacementDeleteObject(a1 + 56, v6);
    *(_QWORD *)(a1 + 112) = 0;
  }
  __NN_CGN_Deinitialize(a1);
  __NN_TN_Deinitialize(a1);
  __NN_CLM_Deinitialize(a1);
  IdentificationForCurrent = __NN_GetIdentificationForCurrent(a1, __s);
  v11 = IdentificationForCurrent;
  if (!(_DWORD)IdentificationForCurrent)
  {
    v7 = strlen(__s);
    v8 = (char *)OOCAllocator_Malloc(a1 + 56, v7 + 1, &v11);
    *(_QWORD *)(a1 + 96) = v8;
    IdentificationForCurrent = v11;
    if (!v11)
    {
      strcpy(v8, __s);
      v12 = 0;
      v9 = PNEW_ToBeSpelled_Con(a1 + 56, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(a1 + 104));
      if ((_DWORD)v9)
        return v9;
      IdentificationForCurrent = ToBeSpelled_LoadModel(*v5, &v12);
      if ((_DWORD)IdentificationForCurrent || !v12)
      {
        OOC_PlacementDeleteObject(a1 + 56, *v5);
        *v5 = 0;
        v11 = IdentificationForCurrent;
        if ((_DWORD)IdentificationForCurrent)
          return IdentificationForCurrent;
      }
      else
      {
        v11 = 0;
      }
      IdentificationForCurrent = __NN_G2POneWord_Initialize(a1);
      v11 = IdentificationForCurrent;
      if (!(_DWORD)IdentificationForCurrent)
      {
        IdentificationForCurrent = __NN_CGN_Initialize(a1);
        v11 = IdentificationForCurrent;
        if (!(_DWORD)IdentificationForCurrent)
        {
          IdentificationForCurrent = __NN_TN_Initialize(a1);
          v11 = IdentificationForCurrent;
          if (!(_DWORD)IdentificationForCurrent)
            return __NN_CLM_Initialize(a1);
        }
      }
    }
  }
  return IdentificationForCurrent;
}

uint64_t __NN_GetIdentificationForCurrent(uint64_t a1, char *a2)
{
  char *v4;
  size_t v5;
  char *v7;
  char *__s2;
  char *__src;

  __s2 = 0;
  __src = 0;
  v7 = 0;
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40), (uint64_t)"langcode", &__src) & 0x80000000) != 0
    || (paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40), (uint64_t)"fecfg", &__s2) & 0x80000000) != 0)
  {
    return err_GenerateErrorInternalMsg((uint64_t)"paramc_ParamGetStr");
  }
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40), (uint64_t)"voice", &v7) & 0x80000000) != 0)
    v7 = 0;
  v4 = strcpy(a2, __src);
  *(_WORD *)&a2[strlen(v4)] = 95;
  strcat(a2, __s2);
  if (v7)
  {
    *(_WORD *)&a2[strlen(a2)] = 95;
    strcat(a2, v7);
  }
  if (*a2)
  {
    v5 = 0;
    do
    {
      a2[v5] = __tolower(a2[v5]);
      ++v5;
    }
    while (v5 < strlen(a2));
  }
  return 0;
}

uint64_t __NN_G2POneWord_Initialize(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  int v7;

  v7 = 0;
  v1 = a1 + 56;
  v2 = (uint64_t *)(a1 + 112);
  v3 = PNEW_G2POneWord_Con(a1 + 56, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(a1 + 112));
  if (!(_DWORD)v3)
  {
    v4 = G2POneWord_LoadModel(*v2, &v7);
    if ((_DWORD)v4)
      v5 = 1;
    else
      v5 = v7 == 0;
    if (v5)
    {
      v3 = v4;
      OOC_PlacementDeleteObject(v1, *v2);
      *v2 = 0;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t __NN_CGN_Initialize(uint64_t a1)
{
  uint64_t v2;
  unsigned int CountStrings;
  unint64_t i;
  uint64_t v6;
  char *v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  unsigned int ErrorInternalMsg;

  v11 = 0;
  v10 = 0;
  v2 = a1 + 56;
  ErrorInternalMsg = PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), &v11);
  if (!ErrorInternalMsg)
  {
    ErrorInternalMsg = CGN_Models(*(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), v11);
    if (!ErrorInternalMsg)
    {
      CountStrings = StringList_GetCountStrings(v11);
      *(_WORD *)(a1 + 120) = CountStrings;
      if (CountStrings)
      {
        *(_QWORD *)(a1 + 128) = OOCAllocator_Malloc(v2, 8 * CountStrings, &ErrorInternalMsg);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 120))
          {
            for (i = 0; i < *(unsigned __int16 *)(a1 + 120); ++i)
            {
              ErrorInternalMsg = PNEW_CGN_Con(v2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(*(_QWORD *)(a1 + 128) + 8 * i));
              if (ErrorInternalMsg)
                break;
              v6 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * i);
              v7 = (char *)StringList_GetAt(v11, (unsigned __int16)i);
              v8 = CGN_LoadModel(v6, v7, &v10);
              ErrorInternalMsg = v8;
              if (v8)
                v9 = 1;
              else
                v9 = v10 == 0;
              if (v9)
              {
                if (!v8)
                  ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)"not loaded");
                OOC_PlacementDeleteObject(v2, *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * i));
                *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * i) = 0;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (v11)
    OOC_PlacementDeleteObject(v2, v11);
  return ErrorInternalMsg;
}

uint64_t __NN_TN_Initialize(uint64_t a1)
{
  uint64_t v2;
  unsigned int CountStrings;
  unint64_t i;
  uint64_t v6;
  char *v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  unsigned int ErrorInternalMsg;

  v11 = 0;
  v10 = 0;
  v2 = a1 + 56;
  ErrorInternalMsg = PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), &v11);
  if (!ErrorInternalMsg)
  {
    ErrorInternalMsg = TN_Models(*(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), v11);
    if (!ErrorInternalMsg)
    {
      CountStrings = StringList_GetCountStrings(v11);
      *(_WORD *)(a1 + 136) = CountStrings;
      if (CountStrings)
      {
        *(_QWORD *)(a1 + 144) = OOCAllocator_Malloc(v2, 8 * CountStrings, &ErrorInternalMsg);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 136))
          {
            for (i = 0; i < *(unsigned __int16 *)(a1 + 136); ++i)
            {
              ErrorInternalMsg = PNEW_TN_Con(v2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(*(_QWORD *)(a1 + 144) + 8 * i));
              if (ErrorInternalMsg)
                break;
              v6 = *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * i);
              v7 = (char *)StringList_GetAt(v11, (unsigned __int16)i);
              v8 = TN_LoadModel(v6, v7, &v10);
              ErrorInternalMsg = v8;
              if (v8)
                v9 = 1;
              else
                v9 = v10 == 0;
              if (v9)
              {
                if (!v8)
                  ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)"not loaded");
                OOC_PlacementDeleteObject(v2, *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * i));
                *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * i) = 0;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (v11)
    OOC_PlacementDeleteObject(v2, v11);
  return ErrorInternalMsg;
}

uint64_t __NN_CLM_Initialize(uint64_t a1)
{
  uint64_t v2;
  unsigned int CountStrings;
  unint64_t i;
  uint64_t v6;
  char *v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  unsigned int ErrorInternalMsg;

  v11 = 0;
  v10 = 0;
  v2 = a1 + 56;
  ErrorInternalMsg = PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), &v11);
  if (!ErrorInternalMsg)
  {
    ErrorInternalMsg = CLM_Models(*(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), v11);
    if (!ErrorInternalMsg)
    {
      CountStrings = StringList_GetCountStrings(v11);
      *(_WORD *)(a1 + 152) = CountStrings;
      if (CountStrings)
      {
        *(_QWORD *)(a1 + 160) = OOCAllocator_Malloc(v2, 8 * CountStrings, &ErrorInternalMsg);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 152))
          {
            for (i = 0; i < *(unsigned __int16 *)(a1 + 152); ++i)
            {
              ErrorInternalMsg = PNEW_CLM_Con(v2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(*(_QWORD *)(a1 + 160) + 8 * i));
              if (ErrorInternalMsg)
                break;
              v6 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * i);
              v7 = (char *)StringList_GetAt(v11, (unsigned __int16)i);
              v8 = CLM_LoadModel(v6, v7, &v10);
              ErrorInternalMsg = v8;
              if (v8)
                v9 = 1;
              else
                v9 = v10 == 0;
              if (v9)
              {
                if (!v8)
                  ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)"not loaded");
                OOC_PlacementDeleteObject(v2, *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * i));
                *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * i) = 0;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (v11)
    OOC_PlacementDeleteObject(v2, v11);
  return ErrorInternalMsg;
}

uint64_t NN_ObjClose(uint64_t a1, int a2)
{
  int Allocator;
  _OWORD v5[2];
  uint64_t v6;

  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) == 0)
  {
    if (a1)
    {
      v6 = 0;
      memset(v5, 0, sizeof(v5));
      Allocator = ooc_utils_createAllocator((uint64_t)v5, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
      if (Allocator || (Allocator = OOC_PlacementDeleteObject((uint64_t)v5, a1)) != 0)
        LH_ERROR_to_VERROR(Allocator);
    }
  }
  return 0;
}

uint64_t NN_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  int Allocator;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD v16[2];
  uint64_t v17;
  uint64_t v18;

  v18 = 0;
  if (!a5)
    return 2706382855;
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  Allocator = ooc_utils_createAllocator((uint64_t)v16, a3, a4);
  if (Allocator)
    return LH_ERROR_to_VERROR(Allocator);
  v12 = PNEW_NN_Con((uint64_t)v16, a1, a2, a3, a4, &v18);
  if (v12)
  {
    v13 = LH_ERROR_to_VERROR(v12);
  }
  else
  {
    v14 = v18;
    *(_QWORD *)a5 = v18;
    *(_DWORD *)(a5 + 8) = 1067;
    v13 = NN_ObjReopen(v14, *(_QWORD *)(a5 + 8));
  }
  v11 = v13;
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v16);
  return v11;
}

uint64_t PNEW_NN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 168, &v14);
  result = v14;
  if (!v14)
  {
    result = NN_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t NN_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t result;
  int v5;

  v3 = safeh_HandleCheck(a1, a2, 1067, 8);
  result = 2706382856;
  if ((v3 & 0x80000000) == 0 && a1)
  {
    v5 = NN_InitializeForCurrent(a1);
    if (v5)
      return LH_ERROR_to_VERROR(v5);
    else
      return v3;
  }
  return result;
}

uint64_t NN_TN_Predict(uint64_t a1, int a2, const char *a3, unsigned int a4, char *a5, unsigned int a6, unsigned int a7, _QWORD *a8, int *a9)
{
  int v16;
  uint64_t result;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;

  v16 = safeh_HandleCheck(a1, a2, 1067, 8);
  result = 2706382856;
  if ((v16 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      v18 = *(unsigned __int16 *)(a1 + 136);
      if (!*(_WORD *)(a1 + 136))
        goto LABEL_9;
      v19 = *(uint64_t **)(a1 + 144);
      while (1)
      {
        v20 = *v19;
        if (*v19)
        {
          if (!strcmp(a3, *(const char **)(v20 + 120)))
            break;
        }
        ++v19;
        if (!--v18)
          goto LABEL_9;
      }
      result = TN_Predict(v20, a4, a5, a6, a7, a8, a9);
      if ((_DWORD)result)
      {
        result = LH_ERROR_to_VERROR(result);
        if ((result & 0x1FFF) == 7)
        {
LABEL_9:
          result = 0;
          *a9 = 0;
        }
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_TN_QueryModelExists(uint64_t a1, int a2, const char *a3)
{
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;

  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0)
    return 0;
  if (!a1)
    return 0;
  if (!NN_IsInitializedForCurrent(a1))
    return 0;
  v5 = *(unsigned __int16 *)(a1 + 136);
  if (!*(_WORD *)(a1 + 136))
    return 0;
  for (i = *(uint64_t **)(a1 + 144); ; ++i)
  {
    v7 = *i;
    if (*i)
    {
      if (!strcmp(a3, *(const char **)(v7 + 120)))
        break;
    }
    if (!--v5)
      return 0;
  }
  return Model_QueryExists(v7);
}

uint64_t NN_ToBeSpelled_Predict(uint64_t a1, int a2, char *a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  int v10;

  v7 = safeh_HandleCheck(a1, a2, 1067, 8);
  result = 2706382856;
  if ((v7 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      v9 = *(_QWORD *)(a1 + 104);
      if (v9)
      {
        v10 = ToBeSpelled_Predict(v9, a3, a4);
        result = v7;
        if (v10)
          return LH_ERROR_to_VERROR(v10);
      }
      else
      {
        return v7;
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_ToBeSpelled_QueryModelExists(uint64_t a1, int a2)
{
  uint64_t v3;

  return (safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) == 0
      && a1
      && NN_IsInitializedForCurrent(a1)
      && (v3 = *(_QWORD *)(a1 + 104)) != 0
      && Model_QueryExists(v3);
}

uint64_t _Model_Con(_QWORD *a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t result;

  result = Object_Con(a1);
  if (!(_DWORD)result)
  {
    a1[12] = 0;
    a1[13] = 0;
    a1[14] = -1;
    *a1 = &__Model;
    a1[1] = a2;
    a1[2] = a3;
    a1[4] = a4;
    a1[5] = a5;
    a1[3] = 0;
    a1[6] = 0;
    if ((InitRsrcFunction(a4, a5, a1 + 6) & 0x80000000) == 0)
    {
      result = ooc_utils_createAllocator((uint64_t)(a1 + 7), (_WORD *)a1[4], a1[5]);
      if ((_DWORD)result)
        return result;
      if ((InitRsrcFunction((_WORD *)a1[1], a1[2], a1 + 3) & 0x80000000) == 0)
        return 0;
    }
    return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
  }
  return result;
}

uint64_t Model_Des(uint64_t a1)
{
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 56));
  return Object_Des();
}

BOOL Model_QueryExists(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 104) != 0;
  return result;
}

uint64_t _Model_Load(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  char *v8;
  const char *v9;
  _DWORD *v10;
  char *v11;
  int v12[2];
  _OWORD v13[8];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)a1 + 24))(a1, a3);
  if ((_DWORD)result)
    return result;
  if (!*a3)
    return 0;
  v11 = &byte_1DEBD87CE;
  *(_QWORD *)v12 = 0;
  memset(v13, 0, sizeof(v13));
  v7 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), 1, 1024);
  *(_QWORD *)(a1 + 96) = v7;
  if (!v7)
  {
    kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_14;
  }
  v8 = (char *)v7;
  if (strchr(a2, 58))
  {
    strcpy(v8, a2);
    goto LABEL_14;
  }
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40), (uint64_t)"langcode", v12) & 0x80000000) != 0
    || (paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40), (uint64_t)"fecfg", &v11) & 0x80000000) != 0)
  {
    v9 = "paramc_ParamGetStr";
  }
  else
  {
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    if ((brokeraux_ComposeBrokerString(*(_QWORD *)(a1 + 48), (const char *)v13, 1, 1, *(char **)v12, 0, 0, *(char **)(a1 + 96), 0x400uLL) & 0x80000000) == 0)goto LABEL_14;
    v9 = "brokeraux_ComposeBrokerString";
  }
  err_GenerateErrorInternalMsg((uint64_t)v9);
LABEL_14:
  if ((fi_init(*(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), *(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), (_QWORD *)(a1 + 104), 0, *(_QWORD *)(a1 + 96), (uint64_t)"FINN", 1, 0) & 0x80000000) != 0)return err_GenerateErrorInternalMsg((uint64_t)"fi_init");
  v10 = **(_DWORD ***)(a1 + 104);
  *(_DWORD *)(a1 + 112) = v10[14];
  if (v10[13] >= 2u)
    *(_DWORD *)(a1 + 116) = v10[15];
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
}

uint64_t _Model_Unload(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;

  result = (*(uint64_t (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(_DWORD)result)
  {
    v3 = a1[12];
    if (v3)
    {
      heap_Free(*(_QWORD **)(a1[6] + 8), v3);
      a1[12] = 0;
    }
    v4 = (uint64_t *)a1[13];
    if (!v4)
      return (*(uint64_t (**)(uint64_t *))(*a1 + 48))(a1);
    if ((fi_deinit(a1[6], a1[3], v4) & 0x80000000) == 0)
    {
      a1[13] = 0;
      a1[14] = -1;
      return (*(uint64_t (**)(uint64_t *))(*a1 + 48))(a1);
    }
    return err_GenerateErrorInternalMsg((uint64_t)"fi_deinit");
  }
  return result;
}

void *GetModelClass()
{
  return &__Model;
}

uint64_t ToBeSpelled_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;

  v6 = _Model_Con((_QWORD *)a1, a2, a3, a4, a5);
  if ((_DWORD)v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  }
  else
  {
    *(_QWORD *)a1 = &__ToBeSpelled;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 144) = v7;
    *(_DWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 160) = 0;
    *(_WORD *)(a1 + 168) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    *(_WORD *)(a1 + 184) = 0;
    *(_DWORD *)(a1 + 188) = 0;
    *(_QWORD *)(a1 + 192) = 0;
  }
  return v6;
}

uint64_t ToBeSpelled_Des(uint64_t *a1)
{
  uint64_t result;

  result = _Model_Unload(a1);
  if (!(_DWORD)result)
    return Model_Des((uint64_t)a1);
  return result;
}

uint64_t ToBeSpelled_LoadModel(uint64_t a1, _DWORD *a2)
{
  return _Model_Load(a1, "nn_tobespelled", a2);
}

uint64_t ToBeSpelled_Predict(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  int v23;
  unsigned int v24;
  uint64_t (*v25)(_QWORD, _QWORD, uint64_t, _QWORD);
  uint64_t v26;
  int v27;
  uint64_t ErrorInternalMsg;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  float v36;
  const char *v37;
  uint64_t v39;
  unsigned __int16 i;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int16 v59;

  v57 = 0;
  v58 = 0;
  v56 = 0;
  *a3 = 0;
  v59 = 0;
  v5 = StringList_FromSplitStringInUtf8(*(_QWORD *)(a1 + 192), a2, *(unsigned __int16 *)(a1 + 120), "\v", "<sp>", &v59);
  if ((_DWORD)v5)
    goto LABEL_34;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32), (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"char lookup:", v6, v7, v8, 0);
  v9 = *(_DWORD *)(a1 + 120);
  if (v9)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32);
      StringList_GetAt(*(_QWORD *)(a1 + 192), (unsigned __int16)v11);
      log_OutText(v12, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"[%d] \"%s\"", v13, v14, v15, v10);
      v10 = (unsigned __int16)++v11;
      v9 = *(_DWORD *)(a1 + 120);
    }
    while (v9 > (unsigned __int16)v11);
  }
  v16 = *(_DWORD *)(a1 + 152) * v9;
  v17 = (_DWORD *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * v16);
  v58 = (uint64_t)v17;
  if (v17)
  {
    v22 = v17;
    if (v16)
    {
      v23 = 0;
      do
        v17[(unsigned __int16)v23++] = 0;
      while (v16 > (unsigned __int16)v23);
    }
    if (!v59)
      goto LABEL_21;
    v24 = 0;
    while (1)
    {
      v25 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 128) + 56);
      v26 = StringList_GetAt(*(_QWORD *)(a1 + 192), (unsigned __int16)v24);
      v27 = v25(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), v26, *(_QWORD *)(a1 + 160));
      if ((v27 & 0x1FFF) == 0x14)
      {
        v27 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), "$MEANW2V$", *(_QWORD *)(a1 + 160));
        if ((v27 & 0x1FFF) == 0x14)
          break;
      }
      if (v27 < 0)
      {
        v29 = "__pIWordLkp->pfWord2fVector";
        goto LABEL_19;
      }
      memcpy(&v22[*(_DWORD *)(a1 + 152) * v24++], *(const void **)(a1 + 160), 4 * *(unsigned int *)(a1 + 152));
      if (v24 >= v59)
        goto LABEL_21;
    }
    v29 = "mean vector $MEANW2V$ not found";
LABEL_19:
    ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v29);
  }
  else
  {
    ErrorInternalMsg = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
  v30 = ErrorInternalMsg;
  if ((_DWORD)ErrorInternalMsg)
    goto LABEL_35;
LABEL_21:
  if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v58, *(unsigned int *)(a1 + 120), &v57, v18, v19, v20, v21) & 0x80000000) != 0)
  {
    v37 = "fi_predict";
LABEL_33:
    v5 = err_GenerateErrorInternalMsg((uint64_t)v37);
LABEL_34:
    v30 = v5;
    goto LABEL_35;
  }
  if ((fi_shape_get_size((int *)(**(_QWORD **)(a1 + 104) + 92), (int *)&v56) & 0x80000000) != 0)
  {
    v37 = "fi_shape_get_size";
    goto LABEL_33;
  }
  if (v56 != *(unsigned __int16 *)(a1 + 184))
  {
    v37 = "Unexpected";
    goto LABEL_33;
  }
  v55 = a3;
  v34 = 0;
  if (v56)
  {
    v35 = 0;
    v36 = 0.0;
    do
    {
      if (v36 < *(float *)(v57 + 4 * v35))
      {
        v36 = *(float *)(v57 + 4 * v35);
        v34 = v35;
      }
      ++v35;
    }
    while (v56 > v35);
  }
  else
  {
    v36 = 0.0;
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32), (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"results (threshold=%1.5lf)", v31, v32, v33, COERCE__INT64(*(float *)(a1 + 188)));
  if (v56)
  {
    v39 = 0;
    for (i = 0; i < v56; v39 = ++i)
    {
      v41 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32);
      StringList_GetAt(*(_QWORD *)(a1 + 176), i);
      log_OutText(v41, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"[%3d] %1.5lf : %s %s", v42, v43, v44, v39);
    }
  }
  if (*(unsigned __int16 *)(a1 + 168) != v34)
  {
    v50 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32);
    v51 = StringList_GetAt(*(_QWORD *)(a1 + 176), v34);
    StringList_GetAt(*(_QWORD *)(a1 + 176), *(unsigned __int16 *)(a1 + 168));
    log_OutText(v50, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"blocked selected prediction \"%s\"; not target label \"%s\"",
      v52,
      v53,
      v54,
      v51);
    goto LABEL_46;
  }
  if (v36 < *(float *)(a1 + 188))
  {
    v45 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32);
    v46 = StringList_GetAt(*(_QWORD *)(a1 + 176), v34);
    log_OutText(v45, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"blocked selected prediction \"%s\"; value %1.5lf below pattern threshold %1.5lf",
      v47,
      v48,
      v49,
      v46);
LABEL_46:
    v30 = 0;
    goto LABEL_35;
  }
  v30 = 0;
  *v55 = 1;
LABEL_35:
  if (v58)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v58);
  return v30;
}

uint64_t _ToBeSpelled_PostFIDeinit(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 176);
  if (v1)
  {
    OOC_PlacementDeleteObject(a1 + 56, v1);
    *(_QWORD *)(a1 + 176) = 0;
    *(_WORD *)(a1 + 184) = 0;
  }
  return 0;
}

uint64_t _ToBeSpelled_PostFIInit(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t NullHandle;
  unsigned int v4;
  uint64_t v5;
  const char *v7;

  if ((nn_word_lkp_GetInterface(1u, (_QWORD *)(a1 + 128)) & 0x80000000) != 0
    || (v2 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16),
        NullHandle = safeh_GetNullHandle(),
        (v2(NullHandle) & 0x80000000) != 0))
  {
    v7 = "nn_word_lkp_GetInterface";
    return err_GenerateErrorInternalMsg((uint64_t)v7);
  }
  if (((*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), a1 + 152) & 0x80000000) != 0)
  {
    v7 = "__pIWordLkp->pfGetVectorLength";
    return err_GenerateErrorInternalMsg((uint64_t)v7);
  }
  v4 = *(_DWORD *)(a1 + 152);
  if (v4 != *(_DWORD *)(a1 + 116))
  {
    err_GenerateErrorInternalMsg((uint64_t)"Mismatch between __word2vecVecLength and __inshape_dim2");
    v4 = *(_DWORD *)(a1 + 152);
  }
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 112);
  v5 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * v4);
  *(_QWORD *)(a1 + 160) = v5;
  if (v5)
    return PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(a1 + 192));
  else
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
}

uint64_t _ToBeSpelled_PreFIDeinit(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t NullHandle;
  int v5;
  uint64_t v6;

  v2 = a1[20];
  if (v2)
  {
    heap_Free(*(_QWORD **)(a1[6] + 8), v2);
    a1[20] = 0;
  }
  v3 = a1[24];
  if (v3)
  {
    OOC_PlacementDeleteObject((uint64_t)(a1 + 7), v3);
    a1[24] = 0;
  }
  if (a1[16])
  {
    NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(a1[17], a1[18], NullHandle, v5))
    {
      (*(void (**)(_QWORD, _QWORD))(a1[16] + 24))(a1[17], a1[18]);
      a1[17] = safeh_GetNullHandle();
      a1[18] = v6;
    }
    a1[16] = 0;
  }
  return 0;
}

uint64_t _ToBeSpelled_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t CfgParamValueString;
  uint64_t *v7;
  int CountStrings;
  unsigned __int16 v9;
  const char *v10;
  const char *v11;
  char *__s2;
  uint64_t v14;

  __s2 = 0;
  v14 = 0;
  *a2 = 0;
  v4 = a1 + 56;
  CfgParamValueString = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v14);
  if ((_DWORD)CfgParamValueString)
    goto LABEL_17;
  CfgParamValueString = Params_GetCfgParamValueString(v14, "nntobespelled_prediction", &__s2);
  if ((_DWORD)CfgParamValueString || __s2 == 0)
    goto LABEL_17;
  v7 = (uint64_t *)(a1 + 176);
  CfgParamValueString = Params_GetCfgParamValueListOfStrings(v14, "nntobespelled_labels", 0x3Bu, (uint64_t *)(a1 + 176));
  if ((_DWORD)CfgParamValueString)
    goto LABEL_17;
  if (!*v7)
  {
    *(_WORD *)(a1 + 184) = 0;
LABEL_15:
    v11 = "Unexpected";
LABEL_16:
    CfgParamValueString = err_GenerateErrorInternalMsg((uint64_t)v11);
    goto LABEL_17;
  }
  CountStrings = StringList_GetCountStrings(*v7);
  *(_WORD *)(a1 + 184) = CountStrings;
  if (!CountStrings)
    goto LABEL_15;
  v9 = 0;
  *a2 = 0;
  while (1)
  {
    if (*(unsigned __int16 *)(a1 + 184) <= v9)
    {
      v11 = "Prediction does not exists";
      goto LABEL_16;
    }
    v10 = (const char *)StringList_GetAt(*v7, v9);
    if (!strcmp(v10, __s2))
      break;
    ++v9;
    if (*a2)
      goto LABEL_24;
  }
  *(_WORD *)(a1 + 168) = v9;
  *a2 = 1;
LABEL_24:
  CfgParamValueString = Params_GetCfgParamValueFloat(v14, "nntobespelled_patternThreshold", (float *)(a1 + 188), 0.6);
  if ((_DWORD)CfgParamValueString)
    *a2 = 0;
LABEL_17:
  if (v14)
    OOC_PlacementDeleteObject(v4, v14);
  if (__s2)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)__s2);
  return CfgParamValueString;
}

uint64_t PNEW_ToBeSpelled_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 200, &v14);
  result = v14;
  if (!v14)
  {
    result = ToBeSpelled_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t G2POneWord_Des(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;

  result = _Model_Unload(a1);
  if (!(_DWORD)result)
  {
    v3 = a1[18];
    if (v3)
    {
      heap_Free(*(_QWORD **)(a1[6] + 8), v3);
      a1[18] = 0;
    }
    return Model_Des((uint64_t)a1);
  }
  return result;
}

uint64_t G2POneWord_LoadModel(uint64_t a1, _DWORD *a2)
{
  return _Model_Load(a1, "nn_g2poneword", a2);
}

uint64_t G2POneWord_Predict(uint64_t a1, char *a2, _QWORD *a3)
{
  uint64_t IsUpdatable;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v12;
  kaldi::nnet1::UpdatableComponent *v13;
  float v14;
  kaldi::nnet1::UpdatableComponent *v15;
  unsigned int v16;
  int v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  char *v20;
  unsigned int Index;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  const char *v27;
  const char *v28;
  uint64_t ErrorInternalMsg;
  kaldi::nnet1::UpdatableComponent *v30;
  unint64_t i;
  unsigned int v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD v42[4];
  uint64_t v43;
  unsigned __int16 v44;

  v40 = 0;
  v41 = 0;
  v39 = 0;
  if (!a2 || !*a2)
  {
    v10 = 0;
LABEL_8:
    IsUpdatable = 0;
    *a3 = &byte_1DEBD87CE;
    goto LABEL_9;
  }
  v44 = 0;
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  IsUpdatable = StringList_Con((uint64_t)v42, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
  if ((_DWORD)IsUpdatable
    || (IsUpdatable = StringList_FromSplitStringInUtf8((uint64_t)v42, a2, 0xFFFF, 0, 0, &v44), (_DWORD)IsUpdatable))
  {
    StringList_Des(v42);
    v10 = 0;
LABEL_6:
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32), (uint64_t)"NN_G2PONEWORD", 0, 0, (uint64_t)"%s : Error extracting features", v7, v8, v9, (uint64_t)a2);
    goto LABEL_9;
  }
  v12 = strlen(a2);
  v13 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v12 + 1);
  v10 = (char *)v13;
  if (v13
    && (*(_BYTE *)v13 = 0,
        v13 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * *(unsigned int *)(a1 + 132)), (v41 = (uint64_t)v13) != 0))
  {
    v15 = v13;
    v16 = *(_DWORD *)(a1 + 132);
    if (v16)
    {
      v17 = 0;
      LOWORD(v14) = *(_WORD *)(a1 + 136);
      v14 = (float)LODWORD(v14);
      do
        *((float *)v13 + (unsigned __int16)v17++) = v14;
      while (v16 > (unsigned __int16)v17);
    }
    if (v44)
    {
      v18 = 0;
      v19 = 0;
      do
      {
        v20 = (char *)StringList_GetAt((uint64_t)v42, v19);
        Index = StringList_GetIndex(*(_QWORD *)(a1 + 120), v20);
        if (Index != 0xFFFF)
        {
          v22 = Index;
          strcat(v10, v20);
          v14 = (float)v22;
          *((float *)v15 + v18++) = (float)v22;
          if (*(_DWORD *)(a1 + 132) - 1 == v18)
            break;
        }
        ++v19;
      }
      while (v44 > v19);
    }
    else
    {
      v18 = 0;
    }
    LOWORD(v14) = *(_WORD *)(a1 + 138);
    *((float *)v15 + v18) = (float)LODWORD(v14);
    StringList_Des(v42);
  }
  else
  {
    IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
    StringList_Des(v42);
    if ((_DWORD)IsUpdatable)
      goto LABEL_6;
  }
  if (!*v10)
    goto LABEL_8;
  if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v41, 1, &v40, v23, v7, v8, v9) & 0x80000000) != 0)
  {
    v28 = "nn_g2poneword:fi_predict";
LABEL_41:
    ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v28);
LABEL_42:
    IsUpdatable = ErrorInternalMsg;
    goto LABEL_9;
  }
  if ((fi_shape_get_size((int *)(**(_QWORD **)(a1 + 104) + 92), (int *)&v39) & 0x80000000) != 0)
  {
    v28 = "nn_g2poneword:fi_shape_get_size";
    goto LABEL_41;
  }
  if (v39)
  {
    v24 = 0;
    v25 = 0;
    do
    {
      v26 = (int)*(float *)(v40 + 4 * v24);
      if (*(unsigned __int16 *)(a1 + 138) == v26)
        break;
      v27 = (const char *)StringList_GetAt(*(_QWORD *)(a1 + 120), v26);
      if (v27)
        v25 += strlen(v27);
      ++v24;
    }
    while (v24 < v39);
  }
  else
  {
    v25 = 0;
  }
  v30 = (kaldi::nnet1::UpdatableComponent *)heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 48) + 8), *(_QWORD *)(a1 + 144), v25 + 1);
  *(_QWORD *)(a1 + 144) = v30;
  if (!a3)
  {
    ErrorInternalMsg = kaldi::nnet1::UpdatableComponent::IsUpdatable(v30);
    goto LABEL_42;
  }
  *(_BYTE *)v30 = 0;
  if (v39)
  {
    for (i = 0; i < v39; ++i)
    {
      v32 = (int)*(float *)(v40 + 4 * i);
      if (*(unsigned __int16 *)(a1 + 138) == v32)
        break;
      v33 = (const char *)StringList_GetAt(*(_QWORD *)(a1 + 120), v32);
      if (v33)
        strcat(*(char **)(a1 + 144), v33);
    }
  }
  *a3 = *(_QWORD *)(a1 + 144);
  v37 = strcmp(a2, v10);
  v38 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32);
  if (v37)
    log_OutText(v38, (uint64_t)"NN_G2PONEWORD", 4, 0, (uint64_t)"(warning: word was [%s]) [%s]  --> [%s]", v34, v35, v36, (uint64_t)a2);
  else
    log_OutText(v38, (uint64_t)"NN_G2PONEWORD", 4, 0, (uint64_t)"[%s] --> [%s]", v34, v35, v36, (uint64_t)v10);
  IsUpdatable = 0;
LABEL_9:
  if (v41)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v41);
    v41 = 0;
  }
  if (v10)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v10);
  return IsUpdatable;
}

uint64_t _G2POneWord_PostFIDeinit(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 120);
  if (v1)
  {
    OOC_PlacementDeleteObject(a1 + 56, v1);
    *(_QWORD *)(a1 + 120) = 0;
    *(_WORD *)(a1 + 128) = 0;
  }
  return 0;
}

uint64_t _G2POneWord_PostFIInit(_DWORD *a1)
{
  int v1;

  v1 = a1[29];
  a1[33] = a1[28];
  if (v1 == -1)
    return 0;
  else
    return err_GenerateErrorInternalMsg((uint64_t)"nn_g2poneword:only supports 1D inshape");
}

uint64_t _G2POneWord_PreFIDeinit()
{
  return 0;
}

uint64_t _G2POneWord_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t CfgParamValueString;
  unsigned __int8 v6;
  uint64_t *v7;
  int CountStrings;
  int Index;
  int v10;
  const char *v11;
  uint64_t v13;
  char *__s;

  v13 = 0;
  __s = 0;
  *a2 = 0;
  v4 = a1 + 56;
  CfgParamValueString = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v13);
  if (!(_DWORD)CfgParamValueString)
  {
    CfgParamValueString = Params_GetCfgParamValueString(v13, "nn_g2poneword_vocab_separator", &__s);
    if (!(_DWORD)CfgParamValueString)
    {
      v6 = __s && strlen(__s) == 1 ? *__s : 124;
      v7 = (uint64_t *)(a1 + 120);
      CfgParamValueString = Params_GetCfgParamValueListOfStrings(v13, "nn_g2poneword_vocab", v6, (uint64_t *)(a1 + 120));
      if (!(_DWORD)CfgParamValueString)
      {
        if (*v7 && (CountStrings = StringList_GetCountStrings(*v7), *(_WORD *)(a1 + 128) = CountStrings, CountStrings))
        {
          Index = StringList_GetIndex(*(_QWORD *)(a1 + 120), "<pad>");
          *(_WORD *)(a1 + 136) = Index;
          if (Index == 0xFFFF)
          {
            v11 = "nn_g2poneword:missing <pad> in vocab";
          }
          else
          {
            v10 = StringList_GetIndex(*(_QWORD *)(a1 + 120), "<EOS>");
            *(_WORD *)(a1 + 138) = v10;
            if (v10 != 0xFFFF)
            {
              CfgParamValueString = 0;
              *a2 = 1;
              goto LABEL_17;
            }
            v11 = "nn_g2poneword:missing <EOS> in vocab";
          }
          CfgParamValueString = err_GenerateErrorInternalMsg((uint64_t)v11);
        }
        else
        {
          CfgParamValueString = 0;
        }
      }
    }
  }
LABEL_17:
  if (__s)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)__s);
    __s = 0;
  }
  if (v13)
    OOC_PlacementDeleteObject(v4, v13);
  return CfgParamValueString;
}

uint64_t PNEW_G2POneWord_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 152, &v14);
  result = v14;
  if (!v14)
  {
    result = _Model_Con((_QWORD *)v12, a2, a3, a4, a5);
    if ((_DWORD)result)
    {
      v14 = result;
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(_QWORD *)v12 = &__G2POneWord;
      *(_QWORD *)(v12 + 120) = 0;
      *(_WORD *)(v12 + 128) = 0;
      *(_QWORD *)(v12 + 132) = 0xFFFFFFFF00000000;
      *(_QWORD *)(v12 + 144) = 0;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t CGN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = _Model_Con((_QWORD *)a1, a2, a3, a4, a5);
  if (!(_DWORD)v6)
  {
    *(_QWORD *)a1 = &__CGN;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 144) = v7;
    *(_QWORD *)(a1 + 152) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 160) = v8;
    *(_QWORD *)(a1 + 208) = 0;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_DWORD *)(a1 + 200) = 0;
  }
  return v6;
}

uint64_t CGN_Des(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[15];
  if (v2)
  {
    heap_Free(*(_QWORD **)(a1[6] + 8), v2);
    a1[15] = 0;
  }
  result = _Model_Unload(a1);
  if (!(_DWORD)result)
    return Model_Des((uint64_t)a1);
  return result;
}

uint64_t CGN_LoadModel(uint64_t a1, char *__s, _DWORD *a3)
{
  uint64_t v6;
  size_t v7;
  kaldi::nnet1::UpdatableComponent *v8;
  size_t v9;
  char *v10;
  uint64_t v11;

  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v7 = strlen(__s);
  v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(v6, v7 + 1);
  *(_QWORD *)(a1 + 120) = v8;
  if (!v8)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  strcpy((char *)v8, __s);
  v9 = strlen(__s);
  v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v9 + 8);
  if (!v8)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  v10 = (char *)v8;
  *(_QWORD *)v8 = 0x5F6E67635F6E6ELL;
  strcat((char *)v8, __s);
  v11 = _Model_Load(a1, v10, a3);
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v10);
  return v11;
}

uint64_t CGN_Models(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Allocator;
  uint64_t v6;
  uint64_t v7;
  _OWORD v9[2];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  v11 = 0;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  Allocator = ooc_utils_createAllocator((uint64_t)v9, a1, a2);
  if (!(_DWORD)Allocator)
  {
    v6 = PNEW_Params_Con((uint64_t)v9, a1, a2, (uint64_t)"fecfg", &v11);
    v7 = v11;
    if (!(_DWORD)v6)
    {
      Allocator = Params_GetCfgParamValueListOfStrings(v11, "nn_cgn_models", 0x3Bu, &v12);
      v7 = v11;
      if (!v11)
        goto LABEL_5;
      goto LABEL_4;
    }
    Allocator = v6;
    if (v11)
LABEL_4:
      OOC_PlacementDeleteObject((uint64_t)v9, v7);
  }
LABEL_5:
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v9);
  return Allocator;
}

uint64_t CGN_Predict(uint64_t a1, const char *a2, uint64_t a3, _QWORD *a4, int *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t ErrorInternalMsg;
  unsigned int v17;
  unsigned int v18;
  char *v19;
  unsigned int v20;
  uint64_t IsUpdatable;
  unsigned int v22;
  const char *v23;
  unsigned int v25;
  int v26;
  char *v27;
  uint64_t v28;
  char *__s;
  uint64_t v30;

  __s = 0;
  v30 = 0;
  v10 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 184) * (unint64_t)*(unsigned __int16 *)(a1 + 186));
  v28 = v10;
  if (v10)
  {
    v11 = v10;
    ErrorInternalMsg = PNEW_WordScanner_ConFrom(a1 + 56, a2, a3, &v30);
    if (!(_DWORD)ErrorInternalMsg)
    {
      v17 = *(unsigned __int16 *)(a1 + 194);
      v18 = *(unsigned __int16 *)(a1 + 186);
      ErrorInternalMsg = __CGN_CloneWord(a1, v30, (uint64_t *)&__s);
      if (!(_DWORD)ErrorInternalMsg)
      {
        v19 = (char *)(v11 + 4 * v18 * (unint64_t)v17);
        ErrorInternalMsg = __CGN_FeaturesCurrent(a1, __s, v19);
        if (!(_DWORD)ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 194))
          {
            v20 = 0;
            do
            {
              v19 += 4 * *(unsigned __int16 *)(a1 + 186);
              if (WordScanner_NextWord(v30))
              {
                IsUpdatable = __CGN_CloneWord(a1, v30, (uint64_t *)&__s);
                if ((_DWORD)IsUpdatable)
                  goto LABEL_16;
                IsUpdatable = __CGN_FeaturesCurrent(a1, __s, v19);
                if ((_DWORD)IsUpdatable)
                  goto LABEL_16;
              }
              else if (*(_WORD *)(a1 + 186))
              {
                memset_pattern16(v19, &unk_1DEC65190, 4 * *(unsigned __int16 *)(a1 + 186));
              }
              ++v20;
              v22 = *(unsigned __int16 *)(a1 + 194);
            }
            while (v20 < v22);
            v11 = v28;
          }
          else
          {
            v22 = 0;
          }
          v25 = *(unsigned __int16 *)(a1 + 186);
          ErrorInternalMsg = WordScanner_ResetFrom(v30, a3);
          if (!(_DWORD)ErrorInternalMsg)
          {
            if (*(_WORD *)(a1 + 194))
            {
              v26 = 0;
              v27 = (char *)(v11 + 4 * v22 * (unint64_t)v25);
              while (1)
              {
                v27 -= 4 * *(unsigned __int16 *)(a1 + 186);
                if (WordScanner_PrevWord(v30))
                {
                  IsUpdatable = __CGN_CloneWord(a1, v30, (uint64_t *)&__s);
                  if ((_DWORD)IsUpdatable)
                    goto LABEL_16;
                  IsUpdatable = __CGN_FeaturesCurrent(a1, __s, v27);
                  if ((_DWORD)IsUpdatable)
                    goto LABEL_16;
                }
                else if (*(_WORD *)(a1 + 186))
                {
                  memset_pattern16(v27, &unk_1DEC65190, 4 * *(unsigned __int16 *)(a1 + 186));
                }
                ErrorInternalMsg = 0;
                if (++v26 >= *(unsigned __int16 *)(a1 + 194))
                  goto LABEL_17;
              }
            }
            ErrorInternalMsg = 0;
          }
        }
      }
    }
  }
  else
  {
    IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
LABEL_16:
    ErrorInternalMsg = IsUpdatable;
  }
LABEL_17:
  if (v30)
    OOC_PlacementDeleteObject(a1 + 56, v30);
  if (__s)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)__s);
  if (!(_DWORD)ErrorInternalMsg)
  {
    if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v28, *(unsigned __int16 *)(a1 + 184), a4, v12, v13, v14, v15) & 0x80000000) != 0)
    {
      v23 = "fi_predict";
    }
    else
    {
      if ((fi_shape_get_size((int *)(**(_QWORD **)(a1 + 104) + 92), a5) & 0x80000000) == 0)
      {
        ErrorInternalMsg = 0;
        goto LABEL_28;
      }
      v23 = "fi_shape_get_size";
    }
    ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v23);
  }
LABEL_28:
  if (v28)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v28);
  return ErrorInternalMsg;
}

uint64_t _CGN_PostFIDeinit(_QWORD *a1)
{
  uint64_t v2;

  *(_QWORD *)((char *)a1 + 196) = 0;
  *(_QWORD *)((char *)a1 + 190) = 0;
  v2 = a1[26];
  if (v2)
    heap_Free(*(_QWORD **)(a1[6] + 8), v2);
  a1[26] = 0;
  return 0;
}

uint64_t _CGN_PostFIInit(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t NullHandle;
  uint64_t (*v4)(uint64_t);
  uint64_t v5;
  kaldi::nnet1::UpdatableComponent *v6;
  unsigned __int16 v7;
  __int16 v8;
  unsigned __int16 v9;
  const char *v11;
  int v12;

  if ((nn_word_lkp_GetInterface(1u, (_QWORD *)(a1 + 128)) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"nn_word_lkp_GetInterface");
  v2 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16);
  NullHandle = safeh_GetNullHandle();
  if ((v2(NullHandle) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"__pIWordLkp->pfObjOpen");
  v4 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16);
  v5 = safeh_GetNullHandle();
  if ((v4(v5) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"__pIWordLkp->pfObjOpen");
  v12 = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), &v12) & 0x80000000) == 0)
  {
    if (v12 != *(unsigned __int16 *)(a1 + 196))
    {
      v11 = "word embedding dimension";
      return err_GenerateErrorInternalMsg((uint64_t)v11);
    }
    if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), &v12) & 0x80000000) == 0)
    {
      if (v12 == *(unsigned __int16 *)(a1 + 198))
      {
        v6 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 196));
        *(_QWORD *)(a1 + 168) = v6;
        if (!v6)
          return kaldi::nnet1::UpdatableComponent::IsUpdatable(v6);
        v6 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 198));
        *(_QWORD *)(a1 + 176) = v6;
        if (!v6)
          return kaldi::nnet1::UpdatableComponent::IsUpdatable(v6);
        v7 = (2 * *(_WORD *)(a1 + 194)) | 1;
        *(_WORD *)(a1 + 184) = v7;
        if (*(_DWORD *)(a1 + 112) == v7)
        {
          v8 = strlen(*(const char **)(a1 + 208));
          *(_WORD *)(a1 + 188) = v8;
          v9 = *(_WORD *)(a1 + 196) + (*(_WORD *)(a1 + 192) + *(_WORD *)(a1 + 190)) * *(_WORD *)(a1 + 198);
          *(_WORD *)(a1 + 186) = v9;
          if (*(_DWORD *)(a1 + 200))
          {
            v9 += v8 + 2;
            *(_WORD *)(a1 + 186) = v9;
          }
          if (*(_DWORD *)(a1 + 116) == v9)
            return 0;
          v11 = "inshape dimension 2";
        }
        else
        {
          v11 = "inshape dimension 1";
        }
      }
      else
      {
        v11 = "char embedding dimension";
      }
      return err_GenerateErrorInternalMsg((uint64_t)v11);
    }
  }
  v11 = "__pIWordLkp->pfGetVectorLength";
  return err_GenerateErrorInternalMsg((uint64_t)v11);
}

uint64_t _CGN_PreFIDeinit(_QWORD *a1)
{
  uint64_t NullHandle;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1[16])
  {
    NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(a1[17], a1[18], NullHandle, v3))
    {
      (*(void (**)(_QWORD, _QWORD))(a1[16] + 24))(a1[17], a1[18]);
      a1[17] = safeh_GetNullHandle();
      a1[18] = v4;
    }
    v5 = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(a1[19], a1[20], v5, v6))
    {
      (*(void (**)(_QWORD, _QWORD))(a1[16] + 24))(a1[19], a1[20]);
      a1[19] = safeh_GetNullHandle();
      a1[20] = v7;
    }
    a1[16] = 0;
  }
  v8 = a1[21];
  if (v8)
    heap_Free(*(_QWORD **)(a1[6] + 8), v8);
  v9 = a1[22];
  a1[21] = 0;
  if (v9)
    heap_Free(*(_QWORD **)(a1[6] + 8), v9);
  *(_QWORD *)((char *)a1 + 182) = 0;
  a1[22] = 0;
  return 0;
}

uint64_t _CGN_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t ParamValueUnsignedShort;
  char *v6;
  char *v7;
  char *v8;
  char *__s1;
  _BYTE *v11;
  int v12[2];

  v11 = 0;
  *(_QWORD *)v12 = 0;
  __s1 = 0;
  *a2 = 0;
  v4 = a1 + 56;
  ParamValueUnsignedShort = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)"fecfg", v12);
  if (!(_DWORD)ParamValueUnsignedShort)
  {
    ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "concatenatedLeftChars", 0, (_WORD *)(a1 + 190), (uint64_t *)&v11);
    if (!(_DWORD)ParamValueUnsignedShort)
    {
      ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "concatenatedRightChars", 3, (_WORD *)(a1 + 192), (uint64_t *)&v11);
      if (!(_DWORD)ParamValueUnsignedShort)
      {
        ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "wordContextWindow", 5, (_WORD *)(a1 + 194), (uint64_t *)&v11);
        if (!(_DWORD)ParamValueUnsignedShort)
        {
          ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "wordEmbeddingDimension", 0, (_WORD *)(a1 + 196), (uint64_t *)&v11);
          if (!(_DWORD)ParamValueUnsignedShort)
          {
            ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "charEmbeddingDimension", 0, (_WORD *)(a1 + 198), (uint64_t *)&v11);
            if (!(_DWORD)ParamValueUnsignedShort)
            {
              ParamValueUnsignedShort = __CGN_FullParamName(a1, "wordPUNCTFeatureEnabled", (uint64_t *)&v11);
              if (!(_DWORD)ParamValueUnsignedShort)
              {
                ParamValueUnsignedShort = Params_GetCfgParamValueString(*(uint64_t *)v12, v11, &__s1);
                if (!(_DWORD)ParamValueUnsignedShort)
                {
                  *(_DWORD *)(a1 + 200) = 1;
                  v6 = __s1;
                  if (__s1)
                  {
                    if (!strcmp(__s1, "False"))
                      *(_DWORD *)(a1 + 200) = 0;
                    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v6);
                  }
                  ParamValueUnsignedShort = __CGN_FullParamName(a1, "wordPUNCTLoadList", (uint64_t *)&v11);
                  if (!(_DWORD)ParamValueUnsignedShort)
                  {
                    ParamValueUnsignedShort = Params_GetCfgParamValueString(*(uint64_t *)v12, v11, &__s1);
                    if (!(_DWORD)ParamValueUnsignedShort)
                    {
                      v7 = __s1;
                      if (__s1)
                      {
LABEL_18:
                        ParamValueUnsignedShort = 0;
                        *(_QWORD *)(a1 + 208) = v7;
                        *a2 = 1;
                        goto LABEL_19;
                      }
                      v8 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 1);
                      __s1 = v8;
                      if (v8)
                      {
                        *v8 = 0;
                        v7 = __s1;
                        goto LABEL_18;
                      }
                      ParamValueUnsignedShort = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_19:
  if (*(_QWORD *)v12)
    OOC_PlacementDeleteObject(v4, *(uint64_t *)v12);
  if (v11)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v11);
  return ParamValueUnsignedShort;
}

uint64_t __CGN_GetParamValueUnsignedShort(uint64_t a1, uint64_t a2, char *__s, int a4, _WORD *a5, uint64_t *a6)
{
  uint64_t result;
  int v11;

  result = __CGN_FullParamName(a1, __s, a6);
  if (!(_DWORD)result)
  {
    v11 = 0;
    result = Params_GetCfgParamValueInteger(a2, (_BYTE *)*a6, a4, &v11);
    if (!(_DWORD)result)
      *a5 = v11;
  }
  return result;
}

uint64_t __CGN_FullParamName(uint64_t a1, char *__s, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  char *v10;
  char *v11;
  char *v12;

  v6 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 8);
  v7 = *a3;
  v8 = strlen(__s);
  v9 = strlen(*(const char **)(a1 + 120));
  v10 = (char *)heap_Realloc(v6, v7, v8 + v9 + 9);
  if (!v10)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  v11 = v10;
  *(_QWORD *)v10 = 0x5F6E67635F6E6ELL;
  v12 = strcat(v10, *(const char **)(a1 + 120));
  *(_WORD *)&v11[strlen(v12)] = 95;
  strcat(v11, __s);
  *a3 = (uint64_t)v11;
  return 0;
}

uint64_t PNEW_CGN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 216, &v14);
  result = v14;
  if (!v14)
  {
    result = CGN_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t __CGN_CloneWord(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v6;
  uint64_t *v7;
  size_t v8;
  char *v9;
  char *v10;

  v6 = WordScanner_WordLen(a2);
  v7 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 8);
  v8 = v6;
  v9 = (char *)heap_Realloc(v7, *a3, v6 + 1);
  if (!v9)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  v10 = strncpy(v9, (const char *)(*(_QWORD *)(a2 + 8) + *(unsigned __int16 *)(a2 + 18)), v8);
  v10[v8] = 0;
  *a3 = (uint64_t)v10;
  return 0;
}

uint64_t __CGN_FeaturesCurrent(uint64_t a1, char *__s, char *a3)
{
  char *v6;
  unsigned __int16 v8;
  unsigned __int16 PreviousUtf8Offset;
  unsigned __int16 v10;
  unsigned int v11;
  char *v12;
  const char *v13;
  unsigned int v14;
  uint64_t v15;
  const char *v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  const char *v22;
  unsigned __int16 v23;
  const char *v24;
  uint64_t v25;
  uint64_t NextUtf8OffsetLimit;
  int v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t, const char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t IsUpdatable;
  const char *v33;
  char *v34;
  unsigned __int16 v35;
  int v36;
  unsigned __int16 v37;
  int v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 v42;
  unsigned int v43;
  unsigned int v44;
  char *v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int i;
  _BYTE v50[7];

  v6 = __s;
  while (__CGN_IsPunct(v6))
  {
    v6 += utf8_determineUTF8CharLength(*v6);
    if (!*v6)
      return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"szWord");
  }
  v8 = strlen(__s);
  PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)__s, v8);
  v10 = v8;
  if (__CGN_IsPunct(&__s[PreviousUtf8Offset]))
  {
    v11 = PreviousUtf8Offset;
    do
    {
      v10 = PreviousUtf8Offset;
      PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)__s, v11);
      v11 = PreviousUtf8Offset;
    }
    while (__CGN_IsPunct(&__s[PreviousUtf8Offset]));
  }
  i = 0;
  if (*(_DWORD *)(a1 + 200))
  {
    v12 = &a3[4 * *(unsigned __int16 *)(a1 + 186) + -4 * (unsigned __int16)(*(_WORD *)(a1 + 188) + 2)];
    bzero(v12, 4 * (unsigned __int16)(*(_WORD *)(a1 + 188) + 2));
    i = 1;
    if (v6 > __s)
    {
      v13 = __s;
      do
      {
        __CGN_InPunctList(a1, v13, (uint64_t)v12, &i);
        v14 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v13);
        if (i)
          *(_DWORD *)&v12[4 * *(unsigned __int16 *)(a1 + 188)] = 1065353216;
        v13 += v14;
      }
      while (v13 < v6);
    }
    v15 = v10;
    v16 = &__s[v10];
    for (i = 1; *v16; v16 += v17)
    {
      __CGN_InPunctList(a1, v16, (uint64_t)v12, &i);
      v17 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v16);
      if (i)
        *(_DWORD *)&v12[4 * *(unsigned __int16 *)(a1 + 188) + 4] = 1065353216;
    }
  }
  else
  {
    v15 = v10;
  }
  __s[v15] = 0;
  v18 = (*(uint64_t (**)(_QWORD, _QWORD, char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), v6, *(_QWORD *)(a1 + 168));
  if ((v18 & 0x1FFF) == 0x14)
  {
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v20 = Utf8_Utf8NbrOfSymbols(v6);
    v21 = heap_Alloc(v19, (6 * v20) | 1);
    if (!v21)
    {
      IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
      goto LABEL_39;
    }
    v22 = (const char *)v21;
    v23 = strlen(v6);
    v24 = v22;
    v25 = v23;
    if (v23)
    {
      NextUtf8OffsetLimit = 0;
      v24 = v22;
      do
      {
        utf8_ToLower(v6, NextUtf8OffsetLimit, (uint64_t)v24);
        v24 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v24);
        NextUtf8OffsetLimit = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(v6, NextUtf8OffsetLimit, v25);
      }
      while (NextUtf8OffsetLimit < v25);
    }
    *v24 = 0;
    v27 = strcmp(v22, v6);
    v28 = *(_QWORD *)(a1 + 136);
    v29 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(*(_QWORD *)(a1 + 128) + 56);
    v30 = *(_QWORD *)(a1 + 168);
    v31 = *(_QWORD *)(a1 + 144);
    if (v27)
    {
      v18 = v29(v28, v31, v22, v30);
      if ((v18 & 0x1FFF) != 0x14)
        goto LABEL_29;
      v18 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), "$MEANW2V$", *(_QWORD *)(a1 + 168));
    }
    else
    {
      v18 = v29(v28, v31, "$MEANW2V$", v30);
    }
    if ((v18 & 0x1FFF) == 0x14)
    {
      v33 = "mean vector";
LABEL_37:
      IsUpdatable = err_GenerateErrorInternalMsg((uint64_t)v33);
      if (!v22)
        goto LABEL_39;
      goto LABEL_38;
    }
  }
  else
  {
    v22 = 0;
  }
LABEL_29:
  if (v18 < 0)
  {
    v33 = "__pIWordLkp->pfWord2fVector";
    goto LABEL_37;
  }
  IsUpdatable = 0;
  if (v22)
LABEL_38:
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v22);
LABEL_39:
  if (!(_DWORD)IsUpdatable)
  {
    memcpy(a3, *(const void **)(a1 + 168), 4 * *(unsigned __int16 *)(a1 + 196));
    v34 = &a3[4 * *(unsigned __int16 *)(a1 + 196)];
    v35 = Utf8_Utf8NbrOfSymbols(v6);
    v36 = *(unsigned __int16 *)(a1 + 192);
    v37 = v36 + *(_WORD *)(a1 + 190);
    if (v37 + 1 >= v35)
    {
      if ((_WORD)v36 + *(_WORD *)(a1 + 190))
      {
        v47 = 0;
        do
        {
          if (*v6)
          {
            v48 = (unsigned __int16)utf8_determineUTF8CharLength(*v6);
            __strncpy_chk();
            v50[v48] = 0;
            v41 = __CGN_CharLookup((_QWORD *)a1, (uint64_t)v50);
            if ((_DWORD)v41)
              return v41;
            v6 += v48;
            memcpy(v34, *(const void **)(a1 + 176), 4 * *(unsigned __int16 *)(a1 + 198));
          }
          else
          {
            bzero(v34, 4 * *(unsigned __int16 *)(a1 + 198));
          }
          v34 += 4 * *(unsigned __int16 *)(a1 + 198);
          ++v47;
        }
        while ((unsigned __int16)v47 < v37);
      }
    }
    else
    {
      if (*(_WORD *)(a1 + 190))
      {
        v38 = 0;
        v39 = v6;
        while (1)
        {
          v40 = (unsigned __int16)utf8_determineUTF8CharLength(*v39);
          __strncpy_chk();
          v50[v40] = 0;
          v41 = __CGN_CharLookup((_QWORD *)a1, (uint64_t)v50);
          if ((_DWORD)v41)
            return v41;
          v39 += v40;
          memcpy(v34, *(const void **)(a1 + 176), 4 * *(unsigned __int16 *)(a1 + 198));
          v34 += 4 * *(unsigned __int16 *)(a1 + 198);
          if (++v38 >= *(unsigned __int16 *)(a1 + 190))
          {
            v36 = *(unsigned __int16 *)(a1 + 192);
            break;
          }
        }
      }
      if (v36)
      {
        v42 = strlen(v6);
        v43 = 0;
        do
        {
          v42 = utf8_GetPreviousUtf8Offset((uint64_t)v6, v42);
          ++v43;
        }
        while (v43 < *(unsigned __int16 *)(a1 + 192));
        if (*(_WORD *)(a1 + 192))
        {
          v44 = 0;
          v45 = &v6[v42];
          do
          {
            v46 = (unsigned __int16)utf8_determineUTF8CharLength(*v45);
            __strncpy_chk();
            v50[v46] = 0;
            IsUpdatable = __CGN_CharLookup((_QWORD *)a1, (uint64_t)v50);
            if ((_DWORD)IsUpdatable)
              break;
            v45 += v46;
            memcpy(v34, *(const void **)(a1 + 176), 4 * *(unsigned __int16 *)(a1 + 198));
            v34 += 4 * *(unsigned __int16 *)(a1 + 198);
            ++v44;
          }
          while (v44 < *(unsigned __int16 *)(a1 + 192));
          return IsUpdatable;
        }
      }
    }
    return 0;
  }
  return IsUpdatable;
}

BOOL __CGN_IsPunct(char *__s)
{
  _BOOL8 result;
  unsigned int v3;

  result = 0;
  if (*__s)
  {
    if (*__s != 35)
    {
      v3 = strlen(__s);
      return utf8_BelongsToSet(9u, __s, 0, v3) == 0;
    }
  }
  return result;
}

uint64_t __CGN_InPunctList(uint64_t result, const char *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  uint64_t v10;
  unsigned __int16 v11;

  if (*(_WORD *)(result + 188))
  {
    v7 = result;
    v8 = 0;
    v9 = 0;
    v10 = *(_QWORD *)(result + 208);
    while (1)
    {
      v11 = utf8_determineUTF8CharLength(*(unsigned __int8 *)(v10 + v9));
      v10 = *(_QWORD *)(v7 + 208);
      result = strncmp(a2, (const char *)(v10 + v9), v11);
      if (!(_DWORD)result)
        break;
      v9 += v11;
      ++v8;
      if (*(unsigned __int16 *)(v7 + 188) <= v9)
        return result;
    }
    *(_DWORD *)(a3 + 4 * v8) = 1065353216;
    *a4 = 0;
  }
  return result;
}

uint64_t __CGN_CharLookup(_QWORD *a1, uint64_t a2)
{
  int v3;
  const char *v4;

  v3 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(a1[16] + 56))(a1[19], a1[20], a2, a1[22]);
  if ((v3 & 0x1FFF) == 0x14
    && (v3 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD))(a1[16] + 56))(a1[19], a1[20], "$MEANW2V$", a1[22]), (v3 & 0x1FFF) == 0x14))
  {
    v4 = "mean vector";
  }
  else
  {
    if ((v3 & 0x80000000) == 0)
      return 0;
    v4 = "__pIWordLkp->pfWord2fVector";
  }
  return err_GenerateErrorInternalMsg((uint64_t)v4);
}

uint64_t TN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;

  v6 = _Model_Con((_QWORD *)a1, a2, a3, a4, a5);
  if (!(_DWORD)v6)
  {
    *(_QWORD *)a1 = &__TN;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 144) = v7;
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 160) = 0;
    *(_WORD *)(a1 + 168) = 0;
  }
  return v6;
}

uint64_t TN_Des(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[15];
  if (v2)
  {
    heap_Free(*(_QWORD **)(a1[6] + 8), v2);
    a1[15] = 0;
  }
  result = _Model_Unload(a1);
  if (!(_DWORD)result)
    return Model_Des((uint64_t)a1);
  return result;
}

uint64_t TN_LoadModel(uint64_t a1, char *__s, _DWORD *a3)
{
  uint64_t v6;
  size_t v7;
  kaldi::nnet1::UpdatableComponent *v8;
  size_t v9;
  char *v10;
  _BYTE *v11;
  unsigned __int16 v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;

  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v7 = strlen(__s);
  v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(v6, v7 + 1);
  *(_QWORD *)(a1 + 120) = v8;
  if (!v8)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  strcpy((char *)v8, __s);
  v9 = strlen(__s);
  v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v9 + 8);
  if (!v8)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  v10 = (char *)v8;
  *(_QWORD *)v8 = 0x5F326E745F6E6ELL;
  v11 = (char *)v8 + 7;
  v12 = strlen(__s);
  v13 = v12;
  if (v12)
  {
    v14 = 0;
    do
    {
      utf8_ToLower(__s, v14, (uint64_t)v11);
      v15 = *v11;
      if (v15 != 95)
        v11 += utf8_determineUTF8CharLength(v15);
      LODWORD(v14) = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(__s, v14, v13);
    }
    while (v14 < v13);
  }
  *v11 = 0;
  v16 = _Model_Load(a1, v10, a3);
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v10);
  return v16;
}

uint64_t TN_Models(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Allocator;
  uint64_t v6;
  uint64_t v7;
  _OWORD v9[2];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  v11 = 0;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  Allocator = ooc_utils_createAllocator((uint64_t)v9, a1, a2);
  if (!(_DWORD)Allocator)
  {
    v6 = PNEW_Params_Con((uint64_t)v9, a1, a2, (uint64_t)"fecfg", &v11);
    v7 = v11;
    if (!(_DWORD)v6)
    {
      Allocator = Params_GetCfgParamValueListOfStrings(v11, "nn_tn2_models", 0x3Bu, &v12);
      v7 = v11;
      if (!v11)
        goto LABEL_5;
      goto LABEL_4;
    }
    Allocator = v6;
    if (v11)
LABEL_4:
      OOC_PlacementDeleteObject((uint64_t)v9, v7);
  }
LABEL_5:
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v9);
  return Allocator;
}

uint64_t TN_Predict(uint64_t a1, unsigned int a2, char *__s, unsigned int a4, unsigned int a5, _QWORD *a6, int *a7)
{
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  const char *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t ErrorInternalMsg;
  uint64_t IsUpdatable;
  const char *v29;
  uint64_t v30;
  unint64_t v31;
  const char *v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;

  v33 = 0;
  if (*(unsigned __int16 *)(a1 + 166) <= a2)
  {
    v14 = "u16Pattern";
    goto LABEL_24;
  }
  if (!__s)
  {
    v14 = "szSentence";
    goto LABEL_24;
  }
  if (a5 > (unsigned __int16)strlen(__s))
  {
    v14 = "u16To";
LABEL_24:
    ErrorInternalMsg = kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)v14);
    goto LABEL_25;
  }
  if (a4 >= a5)
  {
    v14 = "u16From";
    goto LABEL_24;
  }
  v36 = 0;
  v34 = 0;
  v35 = 0;
  v15 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 168) * (unint64_t)*(unsigned __int16 *)(a1 + 160));
  v33 = (uint64_t)v15;
  if (!v15)
  {
    IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_34;
  }
  v16 = v15;
  if ((nn_tn_getCharContextString(*(_QWORD *)(a1 + 48), (uint64_t)"NN_TN", __s, a4, a5, &v36, (unsigned __int16 *)&v35 + 1, *(unsigned __int16 *)(a1 + 162), 2, "*", *(_WORD *)(a1 + 168), (unsigned __int16 *)&v35, (_WORD *)&v34 + 1, &v34) & 0x80000000) != 0)
  {
    v29 = "nn_tn_getCharContextString";
    goto LABEL_33;
  }
  bzero(v16, 4 * *(unsigned __int16 *)(a1 + 168) * (unint64_t)*(unsigned __int16 *)(a1 + 160));
  if (!(_WORD)v35)
  {
LABEL_22:
    v25 = 0;
    goto LABEL_35;
  }
  v21 = 0;
  while (1)
  {
    v22 = *(const char **)(v36 + 8 * v21);
    if (!strcmp(v22, "*"))
    {
      if (*(_WORD *)(a1 + 160))
        memset_pattern16(v16, &unk_1DEC65190, 4 * *(unsigned __int16 *)(a1 + 160));
      goto LABEL_21;
    }
    v23 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), v22, *(_QWORD *)(a1 + 152));
    if ((v23 & 0x1FFF) == 0x14)
    {
      v23 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), "$MEANW2V$", *(_QWORD *)(a1 + 152));
      if ((v23 & 0x1FFF) == 0x14)
        break;
    }
    if (v23 < 0)
    {
      v29 = "__pIWordLkp->pfWord2fVector";
      goto LABEL_33;
    }
    memcpy(v16, *(const void **)(a1 + 152), 4 * *(unsigned __int16 *)(a1 + 164));
    v24 = *(unsigned __int16 *)(a1 + 164);
    *(_DWORD *)&v16[4 * v24 + 4 * a2] = 1065353216;
    if (v21 >= HIWORD(v34) && v21 < (unsigned __int16)v34)
      *(_DWORD *)&v16[4 * *(unsigned __int16 *)(a1 + 166) + 4 * v24] = 1065353216;
LABEL_21:
    v16 += 4 * *(unsigned __int16 *)(a1 + 160);
    if (++v21 >= (unsigned __int16)v35)
      goto LABEL_22;
  }
  v29 = "mean vector";
LABEL_33:
  IsUpdatable = err_GenerateErrorInternalMsg((uint64_t)v29);
LABEL_34:
  v25 = IsUpdatable;
LABEL_35:
  v30 = v36;
  if (v36)
  {
    if (HIWORD(v35))
    {
      v31 = 0;
      do
        heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), *(_QWORD *)(v36 + 8 * v31++));
      while (v31 < HIWORD(v35));
      v30 = v36;
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v30);
  }
  if (!(_DWORD)v25)
  {
    if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v33, *(unsigned __int16 *)(a1 + 168), a6, v17, v18, v19, v20) & 0x80000000) != 0)
    {
      v32 = "fi_predict";
    }
    else
    {
      if ((fi_shape_get_size((int *)(**(_QWORD **)(a1 + 104) + 92), a7) & 0x80000000) == 0)
      {
        v25 = 0;
        goto LABEL_26;
      }
      v32 = "fi_shape_get_size";
    }
    ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v32);
LABEL_25:
    v25 = ErrorInternalMsg;
  }
LABEL_26:
  if (v33)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v33);
  return v25;
}

uint64_t _TN_PostFIDeinit(uint64_t a1)
{
  *(_QWORD *)(a1 + 162) = 0;
  return 0;
}

uint64_t _TN_PostFIInit(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t NullHandle;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  const char *v8;
  int v9;

  if ((nn_word_lkp_GetInterface(1u, (_QWORD *)(a1 + 128)) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"nn_word_lkp_GetInterface");
  v2 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16);
  NullHandle = safeh_GetNullHandle();
  if ((v2(NullHandle) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"__pIWordLkp->pfObjOpen");
  v9 = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), &v9) & 0x80000000) != 0)
  {
    v8 = "__pIWordLkp->pfGetVectorLength";
  }
  else
  {
    v4 = *(unsigned __int16 *)(a1 + 164);
    if (v9 == (_DWORD)v4)
    {
      v5 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * v4);
      *(_QWORD *)(a1 + 152) = v5;
      if (!v5)
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
      if (*(_DWORD *)(a1 + 112) == *(unsigned __int16 *)(a1 + 168))
      {
        v6 = *(_WORD *)(a1 + 164) + *(_WORD *)(a1 + 166) + 1;
        *(_WORD *)(a1 + 160) = v6;
        if (*(_DWORD *)(a1 + 116) == v6)
          return 0;
        v8 = "inshape dimension 2";
      }
      else
      {
        v8 = "inshape dimension 1";
      }
    }
    else
    {
      v8 = "char embedding dimension";
    }
  }
  return err_GenerateErrorInternalMsg((uint64_t)v8);
}

uint64_t _TN_PreFIDeinit(uint64_t a1)
{
  uint64_t NullHandle;
  int v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_QWORD *)(a1 + 128))
  {
    NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), NullHandle, v3))
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 128) + 24))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
      *(_QWORD *)(a1 + 136) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 144) = v4;
    }
    *(_QWORD *)(a1 + 128) = 0;
  }
  v5 = *(_QWORD *)(a1 + 152);
  if (v5)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v5);
  *(_QWORD *)(a1 + 152) = 0;
  *(_WORD *)(a1 + 160) = 0;
  return 0;
}

uint64_t _TN_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t CfgParamValueInteger;
  int v7;
  _BYTE *v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  v7 = 0;
  *a2 = 0;
  v4 = a1 + 56;
  CfgParamValueInteger = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v9);
  if (!(_DWORD)CfgParamValueInteger)
  {
    CfgParamValueInteger = __TN_FullParamName(a1, "charContextWindow", (uint64_t *)&v8);
    if (!(_DWORD)CfgParamValueInteger)
    {
      CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 40, &v7);
      if (!(_DWORD)CfgParamValueInteger)
      {
        *(_WORD *)(a1 + 162) = v7;
        CfgParamValueInteger = __TN_FullParamName(a1, "charEmbeddingDimension", (uint64_t *)&v8);
        if (!(_DWORD)CfgParamValueInteger)
        {
          CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 0, &v7);
          if (!(_DWORD)CfgParamValueInteger)
          {
            *(_WORD *)(a1 + 164) = v7;
            CfgParamValueInteger = __TN_FullParamName(a1, "numPatterns", (uint64_t *)&v8);
            if (!(_DWORD)CfgParamValueInteger)
            {
              CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 1, &v7);
              if (!(_DWORD)CfgParamValueInteger)
              {
                *(_WORD *)(a1 + 166) = v7;
                CfgParamValueInteger = __TN_FullParamName(a1, "max_x_len", (uint64_t *)&v8);
                if (!(_DWORD)CfgParamValueInteger)
                {
                  CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 0, &v7);
                  if (!(_DWORD)CfgParamValueInteger)
                  {
                    *(_WORD *)(a1 + 168) = v7;
                    *a2 = 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (v9)
    OOC_PlacementDeleteObject(v4, v9);
  if (v8)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v8);
  return CfgParamValueInteger;
}

uint64_t __TN_FullParamName(uint64_t a1, char *__s, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  char *v10;
  char *v11;
  char *v12;

  v6 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 8);
  v7 = *a3;
  v8 = strlen(__s);
  v9 = strlen(*(const char **)(a1 + 120));
  v10 = (char *)heap_Realloc(v6, v7, v8 + v9 + 9);
  if (!v10)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  v11 = v10;
  *(_QWORD *)v10 = 0x5F326E745F6E6ELL;
  v12 = strcat(v10, *(const char **)(a1 + 120));
  *(_WORD *)&v11[strlen(v12)] = 95;
  strcat(v11, __s);
  *a3 = (uint64_t)v11;
  return 0;
}

uint64_t PNEW_TN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 176, &v14);
  result = v14;
  if (!v14)
  {
    result = TN_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t CLM_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = _Model_Con((_QWORD *)a1, a2, a3, a4, a5);
  if (!(_DWORD)v6)
  {
    *(_QWORD *)a1 = &__CLM;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 144) = v7;
    *(_QWORD *)(a1 + 152) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 160) = v8;
    *(_QWORD *)(a1 + 168) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 176) = v9;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    *(_QWORD *)(a1 + 214) = 0;
  }
  return v6;
}

uint64_t CLM_Des(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[15];
  if (v2)
  {
    heap_Free(*(_QWORD **)(a1[6] + 8), v2);
    a1[15] = 0;
  }
  result = _Model_Unload(a1);
  if (!(_DWORD)result)
    return Model_Des((uint64_t)a1);
  return result;
}

uint64_t CLM_LoadModel(uint64_t a1, char *__s, _DWORD *a3)
{
  uint64_t v6;
  size_t v7;
  kaldi::nnet1::UpdatableComponent *v8;
  size_t v9;
  char *v10;
  uint64_t v11;

  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v7 = strlen(__s);
  v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(v6, v7 + 1);
  *(_QWORD *)(a1 + 120) = v8;
  if (!v8)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  strcpy((char *)v8, __s);
  v9 = strlen(__s);
  v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v9 + 14);
  if (!v8)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  v10 = (char *)v8;
  strcpy((char *)v8, "clmnn:nn_clm_");
  strcat((char *)v8, __s);
  v11 = _Model_Load(a1, v10, a3);
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v10);
  return v11;
}

uint64_t CLM_Models(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Allocator;
  uint64_t v6;
  uint64_t v7;
  _OWORD v9[2];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  v11 = 0;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  Allocator = ooc_utils_createAllocator((uint64_t)v9, a1, a2);
  if (!(_DWORD)Allocator)
  {
    v6 = PNEW_Params_Con((uint64_t)v9, a1, a2, (uint64_t)"clmnncfg", &v11);
    v7 = v11;
    if (!(_DWORD)v6)
    {
      Allocator = Params_GetCfgParamValueListOfStrings(v11, "nn_clm_models", 0x3Bu, &v12);
      v7 = v11;
      if (!v11)
        goto LABEL_5;
      goto LABEL_4;
    }
    Allocator = v6;
    if (v11)
LABEL_4:
      OOC_PlacementDeleteObject((uint64_t)v9, v7);
  }
LABEL_5:
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v9);
  return Allocator;
}

uint64_t CLM_Predict(uint64_t a1, char **a2, char **a3, char **a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  char *v14;
  char *v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t IsUpdatable;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  BOOL v24;
  int v25;
  int v26;
  float v27;
  char *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;

  v14 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 12* *(unsigned __int16 *)(a1 + 220)* (2 * *(unsigned __int16 *)(a1 + 218) + (unsigned __int16)a5));
  v40 = (uint64_t)v14;
  if (v14)
  {
    v15 = v14;
    v39 = a7;
    v16 = (unsigned __int16)a5;
    v17 = 3 * *(_WORD *)(a1 + 218) * *(_WORD *)(a1 + 220);
    if (v17)
    {
      v18 = (unsigned __int16)(3 * *(_WORD *)(a1 + 218) * *(_WORD *)(a1 + 220));
      memset_pattern16(v14, &unk_1DEC65190, 4 * v18);
    }
    else
    {
      v18 = 0;
    }
    v38 = v18;
    v20 = &v15[4 * v18];
    if ((_WORD)a5)
    {
      while (1)
      {
        v21 = __CLM_FeaturesLookups(a1, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), *a2, v20);
        if ((_DWORD)v21)
          break;
        v22 = &v20[4 * *(unsigned __int16 *)(a1 + 220)];
        v21 = __CLM_FeaturesLookups(a1, *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), *a3, v22);
        if ((_DWORD)v21)
          break;
        v23 = &v22[4 * *(unsigned __int16 *)(a1 + 220)];
        v21 = __CLM_FeaturesLookups(a1, *(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176), *a4, v23);
        if ((_DWORD)v21)
          break;
        v20 = &v23[4 * *(unsigned __int16 *)(a1 + 220)];
        ++a4;
        ++a3;
        ++a2;
        if (!--v16)
          goto LABEL_12;
      }
      IsUpdatable = v21;
      goto LABEL_39;
    }
LABEL_12:
    v24 = v17 == 0;
    a7 = v39;
    if (!v24)
      memset_pattern16(v20, &unk_1DEC65190, 4 * v38);
  }
  else
  {
    IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    if ((_DWORD)IsUpdatable)
      return IsUpdatable;
  }
  if (a5)
  {
    v25 = 0;
    v26 = 0;
    v27 = 0.0;
    v28 = (char *)v40;
    while (1)
    {
      v42 = 0;
      v43 = 0;
      v41 = 0;
      if (!v28)
        break;
      v29 = 4 * ((*(_WORD *)(a1 + 216) * *(_WORD *)(a1 + 220)) & 0x3FFF);
      v30 = (void *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v29);
      v43 = (uint64_t)v30;
      if (v30)
      {
        memcpy(v30, v28, v29);
        if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v43, *(unsigned __int16 *)(a1 + 216), &v42, v31, v32, v33, v34) & 0x80000000) != 0)
        {
          v36 = "fi_predict";
        }
        else
        {
          if ((fi_shape_get_size((int *)(**(_QWORD **)(a1 + 104) + 92), (int *)&v41) & 0x80000000) == 0)
          {
            if (v41)
            {
              v35 = 0;
              v26 = 0;
              v27 = 0.0;
              do
              {
                if (v27 < *(float *)(v42 + 4 * v35))
                {
                  v27 = *(float *)(v42 + 4 * v35);
                  v26 = v35;
                }
                ++v35;
              }
              while (v41 > (unsigned __int16)v35);
              IsUpdatable = 0;
            }
            else
            {
              v26 = 0;
              IsUpdatable = 0;
              v27 = 0.0;
            }
            goto LABEL_31;
          }
          v36 = "fi_shape_get_size";
        }
LABEL_30:
        IsUpdatable = err_GenerateErrorInternalMsg((uint64_t)v36);
LABEL_31:
        if (v43)
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v43);
        goto LABEL_33;
      }
      IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
LABEL_33:
      if ((_DWORD)IsUpdatable)
        goto LABEL_39;
      *(float *)(a7 + 4 * (unsigned __int16)v25) = v27;
      *(_DWORD *)(a6 + 4 * (unsigned __int16)v25) = v26;
      v28 += 12 * *(unsigned __int16 *)(a1 + 220);
      if (a5 <= (unsigned __int16)++v25)
        goto LABEL_37;
    }
    v36 = "pElemFeatures == NULL";
    goto LABEL_30;
  }
LABEL_37:
  IsUpdatable = 0;
LABEL_39:
  if (v40)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v40);
  return IsUpdatable;
}

uint64_t _CLM_PostFIDeinit(uint64_t a1)
{
  *(_DWORD *)(a1 + 218) = 0;
  return 0;
}

uint64_t _CLM_PostFIInit(uint64_t a1)
{
  size_t v2;
  kaldi::nnet1::UpdatableComponent *v3;
  uint64_t (*v4)(uint64_t);
  uint64_t NullHandle;
  size_t v6;
  uint64_t (*v7)(uint64_t);
  uint64_t v8;
  size_t v9;
  uint64_t (*v10)(uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 v14;
  const char *v16;
  int v17;

  if ((nn_word_lkp_GetInterface(1u, (_QWORD *)(a1 + 128)) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"nn_word_lkp_GetInterface");
  v2 = strlen(*(const char **)(a1 + 120));
  v3 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v2 + 16);
  *(_QWORD *)(a1 + 184) = v3;
  if (!v3)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v3);
  strcpy((char *)v3, "clmorthforeign_");
  strcat(*(char **)(a1 + 184), *(const char **)(a1 + 120));
  v4 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16);
  NullHandle = safeh_GetNullHandle();
  if ((v4(NullHandle) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"__pIWordLkp->pfObjOpen");
  v6 = strlen(*(const char **)(a1 + 120));
  v3 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v6 + 16);
  *(_QWORD *)(a1 + 192) = v3;
  if (!v3)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v3);
  strcpy((char *)v3, "clmphonforeign_");
  strcat(*(char **)(a1 + 192), *(const char **)(a1 + 120));
  v7 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16);
  v8 = safeh_GetNullHandle();
  if ((v7(v8) & 0x80000000) != 0)
    return err_GenerateErrorInternalMsg((uint64_t)"__pIWordLkp->pfObjOpen");
  v9 = strlen(*(const char **)(a1 + 120));
  v3 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), v9 + 13);
  *(_QWORD *)(a1 + 200) = v3;
  if (!v3)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v3);
  strcpy((char *)v3, "clmphonmain_");
  strcat(*(char **)(a1 + 200), *(const char **)(a1 + 120));
  v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 128) + 16);
  v11 = safeh_GetNullHandle();
  if ((v10(v11) & 0x80000000) == 0)
  {
    v17 = 0;
    if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), &v17) & 0x80000000) == 0)
    {
      if (v17 != *(unsigned __int16 *)(a1 + 220))
      {
        v16 = "orth embedding dimension";
        return err_GenerateErrorInternalMsg((uint64_t)v16);
      }
      if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), &v17) & 0x80000000) == 0)
      {
        if (v17 != *(unsigned __int16 *)(a1 + 220))
        {
          v16 = "phon embedding dimension";
          return err_GenerateErrorInternalMsg((uint64_t)v16);
        }
        if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(*(_QWORD *)(a1 + 128) + 40))(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176), &v17) & 0x80000000) == 0)
        {
          v12 = *(unsigned __int16 *)(a1 + 220);
          if (v17 == (_DWORD)v12)
          {
            v13 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8), 4 * v12);
            *(_QWORD *)(a1 + 208) = v13;
            if (!v13)
              return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
            v14 = 6 * *(_WORD *)(a1 + 218) + 3;
            *(_WORD *)(a1 + 216) = v14;
            if (*(_DWORD *)(a1 + 112) == v14)
            {
              if (*(_DWORD *)(a1 + 116) == *(unsigned __int16 *)(a1 + 220))
                return 0;
              v16 = "inshape dimension 2";
            }
            else
            {
              v16 = "inshape dimension 1";
            }
          }
          else
          {
            v16 = "main embedding dimension";
          }
          return err_GenerateErrorInternalMsg((uint64_t)v16);
        }
      }
    }
    v16 = "__pIWordLkp->pfGetVectorLength";
    return err_GenerateErrorInternalMsg((uint64_t)v16);
  }
  return err_GenerateErrorInternalMsg((uint64_t)"__pIWordLkp->pfObjOpen");
}

uint64_t _CLM_PreFIDeinit(uint64_t a1)
{
  uint64_t NullHandle;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_QWORD *)(a1 + 128))
  {
    NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), NullHandle, v3))
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 128) + 24))(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
      *(_QWORD *)(a1 + 136) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 144) = v4;
    }
    v5 = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), v5, v6))
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 128) + 24))(*(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160));
      *(_QWORD *)(a1 + 152) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 160) = v7;
    }
    v8 = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176), v8, v9))
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 128) + 24))(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176));
      *(_QWORD *)(a1 + 168) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 176) = v10;
    }
    *(_QWORD *)(a1 + 128) = 0;
  }
  v11 = *(_QWORD *)(a1 + 184);
  if (v11)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v11);
  *(_QWORD *)(a1 + 184) = 0;
  v12 = *(_QWORD *)(a1 + 192);
  if (v12)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v12);
  *(_QWORD *)(a1 + 192) = 0;
  v13 = *(_QWORD *)(a1 + 200);
  if (v13)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v13);
  *(_QWORD *)(a1 + 200) = 0;
  v14 = *(_QWORD *)(a1 + 208);
  if (v14)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v14);
  *(_QWORD *)(a1 + 208) = 0;
  *(_WORD *)(a1 + 216) = 0;
  return 0;
}

uint64_t _CLM_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t CfgParamValueInteger;
  int v7;
  _BYTE *v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  v7 = 0;
  *a2 = 0;
  v4 = a1 + 56;
  CfgParamValueInteger = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)"clmnncfg", &v9);
  if (!(_DWORD)CfgParamValueInteger)
  {
    CfgParamValueInteger = __CLM_FullParamName(a1, "charContextWindow", (uint64_t *)&v8);
    if (!(_DWORD)CfgParamValueInteger)
    {
      CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 3, &v7);
      if (!(_DWORD)CfgParamValueInteger)
      {
        *(_WORD *)(a1 + 218) = v7;
        CfgParamValueInteger = __CLM_FullParamName(a1, "embxEmbeddingDimension", (uint64_t *)&v8);
        if (!(_DWORD)CfgParamValueInteger)
        {
          CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 0, &v7);
          if (!(_DWORD)CfgParamValueInteger)
          {
            *(_WORD *)(a1 + 220) = v7;
            *a2 = 1;
          }
        }
      }
    }
  }
  if (v9)
    OOC_PlacementDeleteObject(v4, v9);
  if (v8)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (uint64_t)v8);
  return CfgParamValueInteger;
}

uint64_t __CLM_FullParamName(uint64_t a1, char *__s, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  char *v10;
  char *v11;
  char *v12;

  v6 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 8);
  v7 = *a3;
  v8 = strlen(__s);
  v9 = strlen(*(const char **)(a1 + 120));
  v10 = (char *)heap_Realloc(v6, v7, v8 + v9 + 9);
  if (!v10)
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  v11 = v10;
  *(_QWORD *)v10 = 0x5F6D6C635F6E6ELL;
  v12 = strcat(v10, *(const char **)(a1 + 120));
  *(_WORD *)&v11[strlen(v12)] = 95;
  strcat(v11, __s);
  *a3 = (uint64_t)v11;
  return 0;
}

uint64_t PNEW_CLM_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v12 = OOCAllocator_Malloc(a1, 224, &v14);
  result = v14;
  if (!v14)
  {
    result = CLM_Con(v12, a2, a3, a4, a5);
    v14 = result;
    if ((_DWORD)result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t __CLM_FeaturesLookups(uint64_t a1, uint64_t a2, uint64_t a3, char *__s1, void *a5)
{
  int v10;
  const char *v11;

  if (!strcmp(__s1, "#"))
  {
    if (*(_WORD *)(a1 + 220))
      memset_pattern16(a5, &unk_1DEC651F0, 4 * *(unsigned __int16 *)(a1 + 220));
    return 0;
  }
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(a2, a3, __s1, *(_QWORD *)(a1 + 208));
  if ((v10 & 0x1FFF) != 0x14
    || (v10 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, _QWORD))(*(_QWORD *)(a1 + 128) + 56))(a2, a3, "$MEANW2V$", *(_QWORD *)(a1 + 208)), (v10 & 0x1FFF) != 0x14))
  {
    if (v10 < 0)
    {
      v11 = "__pIWordLkp->pfWord2fVector";
      return err_GenerateErrorInternalMsg((uint64_t)v11);
    }
    memcpy(a5, *(const void **)(a1 + 208), 4 * *(unsigned __int16 *)(a1 + 220));
    return 0;
  }
  v11 = "mean vector";
  return err_GenerateErrorInternalMsg((uint64_t)v11);
}

uint64_t fe_nn_g2p_component_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2707431425;
  result = 0;
  *a2 = &IFeNng2p;
  return result;
}

uint64_t fe_nng2p_ClassOpen(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2707431431;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t fe_nng2p_ClassClose()
{
  return 0;
}

uint64_t fe_nng2p_ObjOpen(_WORD *a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int Allocator;
  uint64_t v18;
  uint64_t v19;

  v18 = 0;
  v19 = 0;
  v5 = 2707431431;
  if (a5)
  {
    inited = InitRsrcFunction(a1, a2, &v19);
    if ((inited & 0x80000000) == 0)
    {
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      inited = InitRsrcFunction(a3, a4, &v18);
      if ((inited & 0x80000000) == 0)
      {
        v10 = (_QWORD *)heap_Calloc(*(_QWORD **)(v18 + 8), 1, 64);
        if (!v10)
        {
          log_OutPublic(*(_QWORD *)(v18 + 32), (uint64_t)"FE_NN_G2P", 78000, 0, v11, v12, v13, v14, v18);
          return 2707431434;
        }
        v15 = (uint64_t)v10;
        *v10 = a3;
        v10[1] = a4;
        Allocator = ooc_utils_createAllocator((uint64_t)(v10 + 2), a3, a4);
        inited = LH_ERROR_to_VERROR(Allocator);
        if ((inited & 0x80000000) == 0)
        {
          *(_QWORD *)a5 = v15;
          *(_DWORD *)(a5 + 8) = 1069;
          return fe_nng2p_ObjReopen(v15, *(_QWORD *)(a5 + 8));
        }
      }
    }
    return inited;
  }
  return v5;
}

uint64_t fe_nng2p_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t inited;
  uint64_t v6;

  v6 = 0;
  v3 = 2707431432;
  if ((safeh_HandleCheck(a1, a2, 1069, 64) & 0x80000000) == 0 && a1)
  {
    inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v6);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      v3 = LH_ERROR_to_VERROR(0);
      if ((v3 & 0x80000000) == 0)
      {
        luavmldoutil_destroy_lua_vm(a1 + 16, (uint64_t *)(a1 + 56));
        kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 16));
        heap_Free(*(_QWORD **)(v6 + 8), a1);
      }
    }
  }
  return v3;
}

uint64_t fe_nng2p_ObjReopen(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 1069, 64) & 0x80000000) != 0 || !a1)
    return 2707431432;
  else
    return luavmldoutil_initialize_lua_vm(*(_WORD **)a1, *(_QWORD *)(a1 + 8), a1 + 16, (uint64_t)"runG2P", (uint64_t)hlp_lua_log_callback, (uint64_t *)(a1 + 56), 0);
}

uint64_t fe_nng2p_ProcessStart()
{
  return 0;
}

uint64_t fe_nng2p_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t inited;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t Interface;
  uint64_t v17;
  int v18;
  uint64_t v19;
  const char *v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v25 = 0;
  v26 = 0;
  v23 = 0;
  v24 = 0;
  if ((safeh_HandleCheck(a1, a2, 1069, 64) & 0x80000000) != 0)
    return 2707431432;
  inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v25);
  if ((inited & 0x80000000) == 0)
  {
    *a5 = 1;
    log_OutText(*(_QWORD *)(v25 + 32), (uint64_t)"FE_NN_G2P", 4, 0, (uint64_t)"Entering fe_nng2p_Process", v9, v10, v11, v22);
    if (*(_QWORD *)(a1 + 56))
    {
      Interface = lingdb_GetInterface(1u, &v24);
      if ((Interface & 0x80000000) != 0)
        return Interface;
      inited = LingDBIsValid(v24, a3, a4, &v26);
      if ((inited & 0x80000000) != 0)
        goto LABEL_22;
      if ((_DWORD)v26 == 1)
      {
        inited = LingDBHasSentence(v24, a3, a4, (_DWORD *)&v26 + 1);
        if ((inited & 0x80000000) != 0)
          goto LABEL_22;
        if (HIDWORD(v26) == 1)
        {
          v17 = auxTouchLingdbInstance(v24, a3, a4);
          if ((v17 & 0x80000000) != 0)
          {
LABEL_15:
            inited = v17;
            goto LABEL_22;
          }
          inited = initLDO(a1 + 16, &v23);
          if ((inited & 0x80000000) != 0)
            goto LABEL_22;
          if (v23)
          {
            v17 = importFromLingDBWordRecord(v25, v24, a3, a4, &v23, 0);
            if ((v17 & 0x80000000) == 0)
            {
              v18 = LuaVMLDO_RunFunction(*(_QWORD *)(a1 + 56), (uint64_t)"runG2P", v23);
              v17 = LH_ERROR_to_VERROR(v18);
              if ((v17 & 0x80000000) == 0)
                v17 = exportToLingDBWordRecord(v25, v24, a3, a4, a1 + 16, v23, 0);
            }
            goto LABEL_15;
          }
          v19 = *(_QWORD *)(v25 + 32);
          v20 = "Init LDO is NULL, returning";
        }
        else
        {
          v19 = *(_QWORD *)(v25 + 32);
          v20 = "LingDB has no sentence, returning";
        }
      }
      else
      {
        v19 = *(_QWORD *)(v25 + 32);
        v20 = "Empty or Invalid LingDB, returning";
      }
    }
    else
    {
      v19 = *(_QWORD *)(v25 + 32);
      v20 = "No NNG2P Lua script available, returning";
    }
    log_OutText(v19, (uint64_t)"FE_NN_G2P", 5, 0, (uint64_t)v20, v13, v14, v15, 0);
LABEL_22:
    if (v23)
      deinitLDO(a1 + 16, v23);
  }
  return inited;
}

uint64_t fe_nng2p_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 1069, 64);
  if ((int)result >= 0)
    return result;
  else
    return 2707431432;
}

uint64_t hlp_lua_log_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_NN_G2P", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t auxTouchLingdbInstance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v7;

  v7 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a1 + 104))(a2, a3, 1, 0, (char *)&v7 + 2);
  if ((result & 0x80000000) == 0)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a1 + 160))(a2, a3, HIWORD(v7), 2, 1, &byte_1DEBD87CE, &v7);
  return result;
}

uint64_t fe_clm_component_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2346721281;
  result = 0;
  *a2 = &IFeClm;
  return result;
}

uint64_t fe_clm_ClassOpen(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2346721287;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t fe_clm_ClassClose()
{
  return 0;
}

uint64_t fe_clm_ObjOpen(_WORD *a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int Allocator;
  _QWORD v19[3];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v21 = 0;
  v22 = 0;
  v5 = 2346721287;
  v20 = 0;
  if (a5)
  {
    inited = InitRsrcFunction(a1, a2, &v22);
    if ((inited & 0x80000000) == 0)
    {
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      inited = InitRsrcFunction(a3, a4, &v21);
      if ((inited & 0x80000000) == 0)
      {
        v10 = (uint64_t *)heap_Calloc(*(_QWORD **)(v21 + 8), 1, 72);
        if (!v10)
        {
          log_OutPublic(*(_QWORD *)(v21 + 32), (uint64_t)"FE_CLM", 78000, 0, v11, v12, v13, v14, v19[0]);
          return 2346721290;
        }
        v15 = v10;
        *v10 = (uint64_t)a3;
        v10[1] = a4;
        if ((paramc_ParamGetStr(*(_QWORD *)(v21 + 40), (uint64_t)"shortfragmentforceclm", &v20) & 0x80000000) != 0
          || !v20
          || (v16 = *(_QWORD *)(v21 + 40),
              v19[0] = v15,
              v19[1] = fe_clm_CheckParamChange,
              v19[2] = fe_clm_LearnParamChange,
              inited = paramc_ListenerAdd(v16, "shortfragmentforceclm", v19),
              (inited & 0x80000000) == 0))
        {
          Allocator = ooc_utils_createAllocator((uint64_t)(v15 + 2), (_WORD *)*v15, v15[1]);
          inited = LH_ERROR_to_VERROR(Allocator);
          if ((inited & 0x80000000) == 0)
          {
            *(_QWORD *)a5 = v15;
            *(_DWORD *)(a5 + 8) = 381;
            return fe_clm_ObjReopen(v15, *(_QWORD *)(a5 + 8));
          }
        }
      }
    }
    return inited;
  }
  return v5;
}

uint64_t fe_clm_ObjClose(uint64_t a1, int a2)
{
  uint64_t inited;
  uint64_t v4;
  __int128 v6;
  uint64_t (*v7)();
  uint64_t v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  inited = 2346721288;
  if ((safeh_HandleCheck(a1, a2, 381, 72) & 0x80000000) == 0)
  {
    if (a1)
    {
      inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v9);
      if ((inited & 0x80000000) == 0)
      {
        if ((paramc_ParamGetStr(*(_QWORD *)(v9 + 40), (uint64_t)"shortfragmentforceclm", &v8) & 0x80000000) == 0 && v8)
        {
          v4 = *(_QWORD *)(v9 + 40);
          *(_QWORD *)&v6 = a1;
          *((_QWORD *)&v6 + 1) = fe_clm_CheckParamChange;
          v7 = fe_clm_LearnParamChange;
          paramc_ListenerRemove(v4, "shortfragmentforceclm", &v6);
        }
        luavmldoutil_destroy_lua_vm(a1 + 16, (uint64_t *)(a1 + 56));
        kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 16));
        heap_Free(*(_QWORD **)(v9 + 8), a1);
      }
    }
  }
  return inited;
}

uint64_t fe_clm_ObjReopen(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t inited;
  uint64_t Object;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t v19;

  v18 = 0;
  v19 = 0;
  v17 = 0;
  v3 = 2346721288;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 381, 72) & 0x80000000) != 0 || !a1)
    return v3;
  inited = InitRsrcFunction((_WORD *)*a1, a1[1], &v18);
  if ((inited & 0x80000000) != 0)
    return inited;
  luavmldoutil_destroy_lua_vm((uint64_t)(a1 + 2), a1 + 7);
  Object = paramc_ParamGet(v18[5], (uint64_t)"langcode", &v19, 0);
  if ((Object & 0x80000000) == 0)
  {
    Object = objc_GetObject(v18[6], (uint64_t)"CLMOBJECT", &v17);
    if ((Object & 0x80000000) == 0)
    {
      v3 = (*(uint64_t (**)(_QWORD, _QWORD, _WORD **))(v17[1] + 96))(v17[2], v17[3], (_WORD **)a1 + 8);
      if ((v3 & 0x80000000) != 0)
      {
LABEL_10:
        log_OutText(v18[4], (uint64_t)"FE_CLM", 5, 0, (uint64_t)"CLM Lua script for main language [%s] is not available, no CLM to main language in \"fe/fe_clm\" component (CLM done in upstream components).", v6, v7, v8, v19);
        goto LABEL_12;
      }
      v9 = *((_DWORD *)a1 + 16);
      switch(v9)
      {
        case 2:
          v11 = v18[4];
          v12 = v19;
          v13 = "CLM to main language [%s]  will be done in  \"fe/fe_clm\" component (after fe_global).";
          break;
        case 1:
          v11 = v18[4];
          v12 = v19;
          v13 = "CLM to main language [%s]  will be done in  \"fe/fe_clm\" component (before fe_global).";
          break;
        case 0:
          goto LABEL_10;
        default:
LABEL_19:
          v3 = luavmldoutil_initialize_lua_vm((_WORD *)*a1, a1[1], (uint64_t)(a1 + 2), (uint64_t)"runCLM", (uint64_t)hlp_lua_log_callback_0, a1 + 7, "clm");
          if ((v3 & 0x80000000) != 0)
          {
            log_OutText(v18[4], (uint64_t)"FE_CLM", 5, 0, (uint64_t)"CLM Lua function [%s] is not available, no CLM to main language in \"fe/fe_clm\" component (CLM done in upstream components).", v14, v15, v16, (uint64_t)"runCLM");
            v3 = 0;
          }
          goto LABEL_12;
      }
      log_OutText(v11, (uint64_t)"FE_CLM", 5, 0, (uint64_t)v13, v6, v7, v8, v12);
      goto LABEL_19;
    }
  }
  v3 = Object;
LABEL_12:
  if (v17)
    objc_ReleaseObject(v18[6], (uint64_t)"CLMOBJECT");
  return v3;
}

uint64_t fe_clm_ProcessStart()
{
  return 0;
}

uint64_t fe_clm_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t Interface;
  uint64_t v17;
  _BOOL4 v18;
  int v19;
  uint64_t v20;
  const char *v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  inited = 2346721288;
  if ((safeh_HandleCheck(a1, a2, 381, 72) & 0x80000000) != 0)
    return inited;
  if (!a1)
    return inited;
  inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v27);
  if ((inited & 0x80000000) != 0)
    return inited;
  *a5 = 1;
  log_OutText(*(_QWORD *)(v27 + 32), (uint64_t)"FE_CLM", 4, 0, (uint64_t)"Entering fe_clm_Process", v10, v11, v12, v23);
  if (*(_QWORD *)(a1 + 56))
  {
    Interface = lingdb_GetInterface(1u, &v25);
    if ((Interface & 0x80000000) != 0)
      return Interface;
    inited = LingDBIsValid(v25, a3, a4, &v24);
    if ((inited & 0x80000000) != 0)
      goto LABEL_22;
    if ((_DWORD)v24 == 1)
    {
      inited = LingDBHasSentence(v25, a3, a4, (_DWORD *)&v24 + 1);
      if ((inited & 0x80000000) != 0)
        goto LABEL_22;
      if (HIDWORD(v24) == 1)
      {
        v17 = auxTouchLingdbInstance(v25, a3, a4);
        if ((v17 & 0x80000000) != 0)
        {
LABEL_16:
          inited = v17;
          goto LABEL_22;
        }
        inited = initLDO(a1 + 16, &v26);
        if ((inited & 0x80000000) != 0)
          goto LABEL_22;
        if (v26)
        {
          v18 = *(_DWORD *)(a1 + 64) != 1;
          v17 = importFromLingDBWordRecord(v27, v25, a3, a4, &v26, v18);
          if ((v17 & 0x80000000) == 0)
          {
            v19 = LuaVMLDO_RunFunction(*(_QWORD *)(a1 + 56), (uint64_t)"runCLM", v26);
            v17 = LH_ERROR_to_VERROR(v19);
            if ((v17 & 0x80000000) == 0)
              v17 = exportToLingDBWordRecord(v27, v25, a3, a4, a1 + 16, v26, v18);
          }
          goto LABEL_16;
        }
        v20 = *(_QWORD *)(v27 + 32);
        v21 = "Init LDO is NULL, returning";
      }
      else
      {
        v20 = *(_QWORD *)(v27 + 32);
        v21 = "LingDB has no sentence, returning";
      }
    }
    else
    {
      v20 = *(_QWORD *)(v27 + 32);
      v21 = "Empty or Invalid LingDB, returning";
    }
  }
  else
  {
    v20 = *(_QWORD *)(v27 + 32);
    v21 = "No CLM Lua script available, returning";
  }
  log_OutText(v20, (uint64_t)"FE_CLM", 5, 0, (uint64_t)v21, v13, v14, v15, 0);
LABEL_22:
  if (v26)
    deinitLDO(a1 + 16, v26);
  return inited;
}

uint64_t fe_clm_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 381, 72);
  if ((int)result >= 0)
    return result;
  else
    return 2346721288;
}

uint64_t fe_clm_CheckParamChange(uint64_t a1, char *__s1, _BYTE *a3, _DWORD *a4)
{
  int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  int v13;
  int v14;
  BOOL v15;
  unsigned __int8 *v16;
  char v17;
  char v18;
  int v19;
  uint64_t v20;

  v20 = 0;
  if (a1 && (v7 = strcmp(__s1, "shortfragmentforceclm"), a3) && !v7 && *a3)
  {
    result = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v20);
    if ((result & 0x80000000) == 0)
    {
      if (LH_strnicmp((uint64_t)a3, (uint64_t)"phrase:", 7uLL))
      {
        v12 = a3 + 1;
        v13 = 1;
        while (1)
        {
          v14 = *(v12 - 1);
          if (!*(v12 - 1))
            goto LABEL_28;
          if (v14 == 58)
            break;
          if ((v14 - 58) < 0xFFFFFFF6)
            goto LABEL_28;
          if (v13)
            v15 = v14 == 48;
          else
            v15 = 0;
          v13 = v15;
          ++v12;
        }
        if (v13)
        {
LABEL_28:
          *a4 = 0;
          goto LABEL_29;
        }
        *a4 = 1;
      }
      else
      {
        *a4 = 1;
        v12 = a3 + 7;
      }
      v18 = *v12;
      v16 = v12 + 1;
      v17 = v18;
      while (v17 > 89 || v17 == 44)
      {
        v19 = *v16++;
        v17 = v19;
        if (!v19)
          goto LABEL_23;
      }
      *a4 = v17 == 0;
      if (v17)
LABEL_29:
        log_OutText(*(_QWORD *)(v20 + 32), (uint64_t)"FE_CLM", 5, 0, (uint64_t)"%s=%s : IGNORED (invalid)", v9, v10, v11, (uint64_t)"shortfragmentforceclm");
      return 0;
    }
  }
  else
  {
LABEL_23:
    result = 0;
    *a4 = 1;
  }
  return result;
}

uint64_t fe_clm_LearnParamChange()
{
  return 0;
}

uint64_t hlp_lua_log_callback_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_CLM", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t com_depes_InitLayers(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return 0;
}

uint64_t com_depes_FreeLayers(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _WORD *v5;
  uint64_t v6;

  v3 = 0;
  v4 = a2 + 16;
  v5 = (_WORD *)(a2 + 112);
  do
  {
    v6 = *(_QWORD *)(v4 + v3);
    if (v6)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v6);
      *(_QWORD *)(v4 + v3) = 0;
    }
    *(v5 - 16) = 0;
    *(v5 - 8) = 0;
    *v5++ = 0;
    v3 += 8;
  }
  while (v3 != 64);
  return 0;
}

uint64_t com_depes_PrepareLayersForLen(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v10;
  unsigned __int16 *v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  __int16 v17;
  unsigned int v18;
  unsigned __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v27;

  if (a2 == 0xFFFF)
  {
    v25 = 2305826825;
    v21 = *a1;
    goto LABEL_28;
  }
  v9 = *((unsigned __int16 *)a1 + 40);
  v10 = *((unsigned __int16 *)a1 + 5);
  if (v10 >= 2)
  {
    v11 = (unsigned __int16 *)a1 + 41;
    v12 = v10 - 1;
    do
    {
      v14 = *v11++;
      v13 = v14;
      if (v14 >= (unsigned __int16)v9)
        v9 = (unsigned __int16)v9;
      else
        v9 = v13;
      --v12;
    }
    while (v12);
  }
  v15 = a2 + 1;
  if (v9 >= (unsigned __int16)(a2 + 1))
    return 0;
  v16 = v9 ? v9 : 200;
  do
  {
    v17 = v16;
    v18 = v16;
    if (v16 >= v15)
      break;
    v16 *= 2;
  }
  while ((v17 & 0x8000) == 0);
  v19 = v18 < v15 ? -1 : v17;
  if (!*((_WORD *)a1 + 5))
    return 0;
  v20 = 0;
  v21 = *a1;
  v22 = a1 + 10;
  while (*((unsigned __int16 *)v22 + v20) >= v19)
  {
LABEL_25:
    if (++v20 >= (unint64_t)v10)
      return 0;
  }
  v23 = *(uint64_t **)(v21 + 8);
  if (*((_WORD *)v22 + v20))
  {
    v24 = heap_Realloc(v23, v22[v20 - 8], v19);
    if (!v24)
      goto LABEL_30;
    goto LABEL_24;
  }
  v24 = heap_Alloc((uint64_t)v23, v19);
  if (v24)
  {
LABEL_24:
    v22[v20 - 8] = v24;
    *((_WORD *)v22 + v20) = v19;
    LODWORD(v10) = *((unsigned __int16 *)a1 + 5);
    goto LABEL_25;
  }
LABEL_30:
  v25 = 2305826826;
LABEL_28:
  log_OutPublic(*(_QWORD *)(v21 + 32), (uint64_t)"COM_DEPES", 38000, 0, a5, a6, a7, a8, v27);
  return v25;
}

uint64_t com_depes_StartWritingToLayers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unint64_t v10;

  result = com_depes_PrepareLayersForLen((uint64_t *)a1, 1, a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) == 0 && *(_WORD *)(a1 + 10))
  {
    v10 = 0;
    do
      **(_BYTE **)(a1 + 16 + 8 * v10++) = 0;
    while (v10 < *(unsigned __int16 *)(a1 + 10));
  }
  return result;
}

uint64_t com_depes_AddToLayerGen(uint64_t *a1, unsigned int a2, char *__s, int a4, int a5)
{
  char *v6;
  unsigned int v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  __int16 v20;
  int v21;
  char *v22;
  int v23;
  __int16 v25;
  char *v26;
  _WORD *v27;
  __int16 v28;
  uint64_t result;
  _BYTE *v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  char v34;

  v6 = __s;
  v9 = a4 & ~(a4 >> 31);
  v10 = strlen(__s);
  if (v9 >= v10)
    v11 = v10;
  else
    v11 = v9;
  v12 = v11;
  v19 = Utf8_LengthInUtf8chars((unint64_t)v6, v11);
  v20 = 0;
  if (v12)
  {
    v21 = v12;
    v22 = v6;
    do
    {
      v23 = *v22++;
      if (v23 != 126 || a5 == 0)
        v25 = 1;
      else
        v25 = 2;
      v20 += v25;
      --v21;
    }
    while (v21);
  }
  v26 = (char *)a1 + 2 * a2;
  v28 = *((_WORD *)v26 + 48);
  v27 = v26 + 96;
  result = com_depes_PrepareLayersForLen(a1, (unsigned __int16)(v28 + v20), v13, v14, v15, v16, v17, v18);
  if ((result & 0x80000000) == 0)
  {
    v30 = (_BYTE *)(a1[a2 + 2] + (unsigned __int16)*v27);
    if (v12)
    {
      v31 = 0;
      v32 = 0;
      do
      {
        LODWORD(v33) = *v6;
        if (a5 && (_DWORD)v33 == 126)
        {
          v33 = 0;
          v34 = -62;
          do
          {
            v30[v33] = v34;
            v34 = asc_1DEBFC210[++v33];
          }
          while (v33 != 2);
          v30 += 2;
        }
        else
        {
          *v30++ = v33;
          LOWORD(v33) = 1;
        }
        v32 += v33;
        ++v6;
        ++v31;
      }
      while (v31 != v12);
    }
    else
    {
      v32 = 0;
    }
    *v30 = 0;
    *v27 += v32;
    *((_WORD *)a1 + a2 + 56) += v19;
  }
  return result;
}

uint64_t com_depes_AddToLayerN(uint64_t *a1, unsigned int a2, char *a3, int a4)
{
  return com_depes_AddToLayerGen(a1, a2, a3, a4, 1);
}

uint64_t com_depes_AddToLayer(uint64_t *a1, unsigned int a2, char *__s)
{
  int v6;

  v6 = (unsigned __int16)strlen(__s);
  return com_depes_AddToLayerGen(a1, a2, __s, v6, 1);
}

uint64_t com_depes_FillToMaxLayerSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v12;
  unsigned __int16 v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  __int16 v17;
  uint64_t result;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  unsigned __int16 v23;

  v8 = *(unsigned __int16 *)(a1 + 10);
  if (*(_WORD *)(a1 + 10))
  {
    v12 = 0;
    v13 = 0;
    do
    {
      if (*(_DWORD *)(a2 + 4 * v12) == 1 && *(unsigned __int16 *)(a1 + 2 * v12 + 112) > v13)
        v13 = *(_WORD *)(a1 + 2 * v12 + 112);
      ++v12;
    }
    while (v8 != v12);
    v14 = 0;
    do
    {
      if (*(_DWORD *)(a2 + 4 * v14) == 1)
      {
        v15 = a1 + 2 * v14;
        v16 = *(unsigned __int16 *)(v15 + 112);
        v17 = v13 - v16;
        result = com_depes_PrepareLayersForLen((uint64_t *)a1, (unsigned __int16)(*(_WORD *)(v15 + 96) + v13 - v16), a3, a4, a5, a6, a7, a8);
        if ((result & 0x80000000) != 0)
          return result;
        v19 = *(unsigned __int8 *)(a3 + v14);
        v20 = *(unsigned __int16 *)(v15 + 96);
        if (!*(_BYTE *)(a3 + v14))
        {
          if (*(_WORD *)(v15 + 96))
            v19 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 8 * v14 + 16) + (v20 - 1));
          else
            v19 = 126;
        }
        v21 = *(_QWORD *)(a1 + 8 * v14 + 16);
        v22 = (_BYTE *)(v21 + v20);
        if (v16 != v13)
        {
          v23 = v13 + ~(_WORD)v16;
          memset(v22, v19, v23 + 1);
          v22 = (_BYTE *)(v21 + v20 + v23 + 1);
        }
        *v22 = 0;
        *(_WORD *)(v15 + 96) += v17;
        *(_WORD *)(v15 + 112) += v17;
        LODWORD(v8) = *(unsigned __int16 *)(a1 + 10);
      }
      ++v14;
    }
    while (v14 < v8);
  }
  return 0;
}

uint64_t com_depes_FillToMaxLayerRange(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v12;
  _DWORD v14[8];
  uint64_t v15;

  v10 = a2;
  v15 = *MEMORY[0x1E0C80C00];
  if (!a2 || (bzero(v14, 4 * a2), v10 <= a3))
  {
    do
    {
      v14[(unsigned __int16)v10] = 1;
      LOWORD(v10) = v10 + 1;
    }
    while (a3 >= (unsigned __int16)v10);
  }
  v12 = *(unsigned __int16 *)(a1 + 10);
  if (v12 > (unsigned __int16)v10)
    bzero(&v14[(unsigned __int16)v10], 4 * (unsigned __int16)(v12 + ~(_WORD)v10) + 4);
  return com_depes_FillToMaxLayerSet(a1, (uint64_t)v14, a4, a4, a5, a6, a7, a8);
}

uint64_t com_depes_FillToMaxAllLayers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return com_depes_FillToMaxLayerRange(a1, 0, (unsigned __int16)(*(_WORD *)(a1 + 10) - 1), a2, a5, a6, a7, a8);
}

uint64_t com_depes_InsertBeforeEnd(uint64_t *a1, unsigned int a2, char *__s, int a4)
{
  char *v5;
  char *v8;
  _WORD *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  size_t v23;
  uint64_t *v24;
  _QWORD *v25;
  uint64_t v26;
  _BYTE *v27;
  char v28;
  unsigned __int16 v29;

  v5 = __s;
  v8 = (char *)a1 + 2 * a2;
  v11 = *((unsigned __int16 *)v8 + 48);
  v9 = v8 + 96;
  v10 = v11;
  v12 = strlen(__s);
  v13 = v12;
  v14 = Utf8_LengthInUtf8chars((unint64_t)v5, v12);
  v21 = com_depes_PrepareLayersForLen(a1, (unsigned __int16)(*v9 + v12), v15, v16, v17, v18, v19, v20);
  if ((v21 & 0x80000000) == 0)
  {
    v22 = a4 & ~(a4 >> 31);
    if (v22 >= v10)
      v23 = v10;
    else
      v23 = v22;
    v24 = &a1[a2];
    v26 = v24[2];
    v25 = v24 + 2;
    v27 = (_BYTE *)(v26 + (unsigned __int16)*v9 - v23);
    memmove(&v27[v12], v27, v23);
    if (v12)
    {
      do
      {
        v28 = *v5++;
        *v27++ = v28;
        --v13;
      }
      while (v13);
    }
    v29 = *v9 + v12;
    *v9 = v29;
    *((_WORD *)a1 + a2 + 56) += v14;
    *(_BYTE *)(*v25 + v29) = 0;
  }
  return v21;
}

size_t GetContextLenInNrChars(size_t result, int a2, int a3, int a4, int a5, _WORD *a6, _WORD *a7)
{
  size_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  char __s[5];

  v13 = result;
  v14 = 0;
  *a6 = 0;
  LOWORD(v15) = a2;
  *a7 = 0;
  if (a2 <= a3)
  {
    Utf32SymToUtf8Sym(*(_DWORD *)(result + 4 * a2), __s, 5u);
    result = strlen(__s);
    v14 = (__int16)result;
  }
  if (a2 < a3 && v14 <= a4)
  {
    v15 = a2;
    do
    {
      v16 = *(_DWORD *)(v13 + 4 + 4 * v15++);
      Utf32SymToUtf8Sym(v16, __s, 5u);
      result = strlen(__s);
      if (v15 >= a3)
        break;
      v14 = (__int16)(v14 + result);
    }
    while (v14 <= a4);
  }
  *a6 = v15 - a2;
  if (a2 <= a3)
  {
    Utf32SymToUtf8Sym(*(_DWORD *)(v13 + 4 * a3), __s, 5u);
    result = strlen(__s);
    v17 = (__int16)result;
  }
  else
  {
    v17 = 0;
  }
  LOWORD(v18) = a3;
  if (a2 < a3 && v17 <= a5)
  {
    v18 = a3;
    do
    {
      v19 = *(_DWORD *)(v13 - 4 + 4 * v18--);
      Utf32SymToUtf8Sym(v19, __s, 5u);
      result = strlen(__s);
      if (v18 <= a2)
        break;
      v17 = (__int16)(v17 + result);
    }
    while (v17 <= a5);
  }
  *a7 = a3 - v18;
  return result;
}

uint64_t INFERENCE(uint64_t a1, uint64_t a2, int a3, __int16 *a4)
{
  _WORD *v5;
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int16 v45;
  __int16 v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int16 v70;
  uint64_t v71;
  __int16 i;
  uint64_t v73;
  __int16 j;
  uint64_t v75;
  __int16 v76;
  int v77;
  uint64_t v78;
  __int16 v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  __int16 v83;
  __int16 v84;
  int v85;
  __int16 v86;
  __int16 v87;
  uint64_t v88;
  int v89;
  int v90;
  __int16 v91;
  int v92;
  __int16 v93;
  __int16 v94;
  uint64_t v95;
  int v96;
  __int16 v97;
  __int16 v98;
  __int16 v99;
  int v100;
  uint64_t v101;
  int v102;
  __int16 v103;
  __int16 v104;
  uint64_t *v105;
  uint64_t v106;
  __int16 v107;
  __int16 v108;
  int v109;
  uint64_t v110;
  int v111;
  BOOL v112;
  int v113;
  int v114;
  __int16 v115;
  __int16 v116;
  int v117;
  __int16 v118;
  int v119;
  int v120;
  uint64_t v121;
  __int16 v122;
  uint64_t *v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  int v127;
  __int16 v128;
  int v129;
  int v130;
  uint64_t v131;
  __int16 v132;
  int v133;
  __int16 v134;
  int v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  __int16 v145;
  _BYTE v147[5];
  _BYTE v148[548];
  unsigned __int16 v149;
  uint64_t v150;
  unsigned __int8 v151;
  __int16 v152;

  if (*(_BYTE *)(a1 + 1428))
    return 0;
  v5 = a4;
  v7 = a2;
  memset(v148, 0, 512);
  v9 = *a4;
  if (*(__int16 *)(a1 + 24) <= 0)
  {
    v12 = a3;
    v13 = a3 - 1;
    v14 = (unsigned __int16)(v9 - a3 + 1);
    v15 = v9 + 1;
  }
  else
  {
    v11 = 0;
    v12 = a3;
    v13 = a3 - 1;
    v14 = (unsigned __int16)(v9 - a3 + 1);
    v15 = v9 + 1;
    v16 = *(_QWORD *)(a1 + 1504);
    do
    {
      memmove((void *)(*(_QWORD *)(v16 + 8 * v11) + 4 * a3), (const void *)(*(_QWORD *)(v16 + 8 * v11) + 4 * v13), 4 * v14);
      v16 = *(_QWORD *)(a1 + 1504);
      v17 = *(_QWORD *)(v16 + 8 * v11);
      *(_DWORD *)(v17 + 4 * v15) = 31;
      *(_DWORD *)(v17 + 4 * v13) = 31;
      ++v11;
    }
    while (v11 < *(__int16 *)(a1 + 24));
    v5 = a4;
    v7 = a2;
  }
  memmove((void *)(*(_QWORD *)(a1 + 1560) + v12), (const void *)(*(_QWORD *)(a1 + 1560) + v13), v14);
  *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v15) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v13) = 0;
  v21 = *v5 + 1;
  *v5 = v21;
  *(_WORD *)&v148[34] = v21;
  v22 = **(_QWORD **)(a1 + 1504);
  *(_QWORD *)(a1 + 1448) = v22;
  *(_QWORD *)(a1 + 1440) = v22;
  *(_QWORD *)&v148[8] = v22;
  *(_QWORD *)&v148[16] = v22;
  *(_WORD *)(a1 + 1410) = 0;
  v152 = 0;
  v150 = 0;
  *(_OWORD *)(a1 + 2096) = 0u;
  memset(&v148[36], 0, 512);
  if (a3 < v21)
  {
    v23 = a3;
    do
    {
      Utf32SymToUtf8Sym(*(_DWORD *)(**(_QWORD **)(a1 + 1504) + 4 * v23), v147, 5u);
      v24 = v147[0];
      if (v147[0])
      {
        v25 = 0;
        do
        {
          ++*(_WORD *)&v148[2 * v24 + 36];
          v24 = v147[(__int16)++v25];
        }
        while (v147[(__int16)v25]);
      }
      ++v23;
    }
    while (v23 < *(__int16 *)&v148[34]);
  }
  *(_WORD *)&v148[98] = 2;
  *(_WORD *)&v148[30] = *(_WORD *)(*(_QWORD *)(a1 + 64) + 2 * ((int)v7 - 1)) - 1;
  if ((*(_WORD *)&v148[30] & 0x8000) != 0)
    return 0;
  v26 = (int)v7 - 1;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"Start gram number %d", v18, v19, v20, v7);
  *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1430) + 1568) = a3;
  v27 = *(__int16 *)&v148[30];
  *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1430) + 1824) = *(_WORD *)&v148[30];
  if (v27 < *(__int16 *)(*(_QWORD *)(a1 + 72) + 2 * v26))
  {
    v28 = (uint64_t *)(a1 + 152);
    do
    {
      v29 = *(_QWORD *)(a1 + 120);
      *(_DWORD *)v148 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * (__int16)v27);
      GetContextLenInNrChars(*(size_t *)&v148[8], a3, *(__int16 *)&v148[34], *(unsigned __int8 *)(v29 + (__int16)v27), *(unsigned __int8 *)(*(_QWORD *)(a1 + 128) + (__int16)v27), &v148[24], &v148[26]);
      v34 = *(unsigned __int16 *)&v148[30] + 1;
      ++*(_WORD *)&v148[30];
      v35 = *(_QWORD *)(a1 + 176);
      v36 = *(unsigned int *)v148;
      v37 = *(unsigned __int8 *)(v35 + (*(_DWORD *)v148 - 1));
      v38 = v37 - 100;
      if (v37 <= 0x64)
        v38 = *(unsigned __int8 *)(v35 + (*(_DWORD *)v148 - 1));
      *(_WORD *)(a1 + 1408) = v38;
      switch(v38)
      {
        case 1u:
          v39 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v39) + 36])
          {
            if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v39) + 36])
            {
              v151 = *(_BYTE *)(v35 + v36);
              LOWORD(v40) = *(_WORD *)&v148[24] + a3;
              *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
              if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] >= (__int16)(*(_WORD *)&v148[24] + a3))
              {
                v40 = (__int16)v40;
                do
                {
                  if (*(_BYTE *)(a1 + 1428))
                    break;
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * (v40 - 1)), v147, 5u);
                  if (v147[0] == v151)
                  {
                    v149 = 0;
                    *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + (*(_DWORD *)v148 + 1);
                    *(_WORD *)(a1 + 1470) = 1;
                    EXEC_RULE(a1, *(__int16 *)&v148[30], (__int16)(*(_WORD *)&v148[32] + 1), (uint64_t)v148, v41, v42, v43, v44);
                    v45 = v149 + 1;
                    v46 = *(_WORD *)&v148[32];
                  }
                  else
                  {
                    v46 = 1;
                    v45 = *(_WORD *)&v148[32];
                  }
                  *(_WORD *)&v148[32] = v45 + v46;
                  v40 = (__int16)(v45 + v46);
                }
                while (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] >= *(__int16 *)&v148[32]);
              }
            }
          }
          goto LABEL_219;
        case 2u:
          v49 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v49) + 36])
          {
            if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v49) + 36])
            {
              LOWORD(v50) = *(_WORD *)&v148[34] - *(_WORD *)&v148[26] + 1;
              *(_WORD *)&v148[32] = v50;
              v151 = *(_BYTE *)(v35 + v36);
              if (*(__int16 *)&v148[24] + a3 <= (__int16)v50)
              {
                v50 = (__int16)v50;
                do
                {
                  if (*(_BYTE *)(a1 + 1428))
                    break;
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * (v50 - 1)), v147, 5u);
                  if (v147[0] == v151)
                  {
                    *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + (*(_DWORD *)v148 + 1);
                    *(_WORD *)(a1 + 1470) = 1;
                    EXEC_RULE(a1, *(__int16 *)&v148[30], (__int16)(*(_WORD *)&v148[32] + 1), (uint64_t)v148, v51, v52, v53, v54);
                  }
                  --*(_WORD *)&v148[32];
                  v50 = *(__int16 *)&v148[32];
                }
                while (*(__int16 *)&v148[24] + a3 <= *(__int16 *)&v148[32]);
              }
            }
          }
          goto LABEL_219;
        case 3u:
          v55 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v55) + 36])
          {
            if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v55) + 36])
            {
              v56 = *(_WORD *)&v148[24] + a3;
              *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
              v151 = *(_BYTE *)(v35 + v36);
              *(_DWORD *)(a1 + 1384) = 0;
              if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] >= v56)
              {
                v57 = v56;
                do
                {
                  if (*(_BYTE *)(a1 + 1428))
                    goto LABEL_62;
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * (v57 - 1)), v147, 5u);
                  if (v147[0] == v151)
                  {
                    *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + (*(_DWORD *)v148 + 1);
                    *(_WORD *)(a1 + 1470) = 1;
                    EXEC_RULE(a1, *(__int16 *)&v148[30], (__int16)(*(_WORD *)&v148[32] + 1), (uint64_t)v148, v58, v59, v60, v61);
                    v62 = ++*(_WORD *)&v148[32];
                    if (*(_DWORD *)(a1 + 1384) == 1)
                      goto LABEL_91;
                  }
                  else
                  {
                    v62 = ++*(_WORD *)&v148[32];
                  }
                  v57 = v62;
                }
                while (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] >= v62);
                goto LABEL_62;
              }
            }
          }
          goto LABEL_219;
        case 4u:
          v63 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v63) + 36])
          {
            if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v63) + 36])
            {
              v64 = *(_WORD *)&v148[34] - *(_WORD *)&v148[26] + 1;
              *(_WORD *)&v148[32] = v64;
              v151 = *(_BYTE *)(v35 + v36);
              *(_DWORD *)(a1 + 1384) = 0;
              if (*(__int16 *)&v148[24] + a3 <= v64)
              {
                v65 = v64;
                do
                {
                  if (*(_BYTE *)(a1 + 1428))
                    break;
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * (v65 - 1)), v147, 5u);
                  if (v147[0] == v151)
                  {
                    *(_WORD *)(a1 + 1470) = 1;
                    *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + (*(_DWORD *)v148 + 1);
                    EXEC_RULE(a1, *(__int16 *)&v148[30], (__int16)(*(_WORD *)&v148[32] + 1), (uint64_t)v148, v66, v67, v68, v69);
                    v70 = --*(_WORD *)&v148[32];
                    if (*(_DWORD *)(a1 + 1384) == 1)
                      goto LABEL_91;
                  }
                  else
                  {
                    v70 = --*(_WORD *)&v148[32];
                  }
                  v65 = v70;
                }
                while (*(__int16 *)&v148[24] + a3 <= v70);
LABEL_62:
                if (*(_DWORD *)(a1 + 1384) == 1)
                  goto LABEL_91;
              }
            }
          }
          goto LABEL_219;
        case 5u:
          v71 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v71) + 36]
            && *(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v71) + 36])
          {
            for (i = *(_WORD *)&v148[24] + a3; ; i = v149 + *(_WORD *)&v148[32] + 1)
            {
              *(_WORD *)&v148[32] = i;
              if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < i || *(_BYTE *)(a1 + 1428))
                break;
              v149 = 0;
              *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)v148;
              *(_WORD *)(a1 + 1470) = 0;
              EXEC_RULE(a1, *(__int16 *)&v148[30], i, (uint64_t)v148, v30, v31, v32, v33);
            }
          }
          goto LABEL_219;
        case 6u:
          v73 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v73) + 36]
            && *(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v73) + 36])
          {
            for (j = *(_WORD *)&v148[34] - *(_WORD *)&v148[26]; ; j = *(_WORD *)&v148[32] - 1)
            {
              *(_WORD *)&v148[32] = j;
              if (*(__int16 *)&v148[24] + a3 > j || *(_BYTE *)(a1 + 1428))
                break;
              *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)v148;
              *(_WORD *)(a1 + 1470) = 0;
              EXEC_RULE(a1, *(__int16 *)&v148[30], j, (uint64_t)v148, v30, v31, v32, v33);
            }
          }
          goto LABEL_219;
        case 7u:
          v75 = (__int16)v34 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v75) + 36])
          {
            if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v75) + 36])
            {
              v76 = *(_WORD *)&v148[24] + a3;
              *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
              *(_DWORD *)(a1 + 1384) = 0;
              if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] >= v76)
              {
                while (1)
                {
                  v77 = *(_DWORD *)(a1 + 1384);
                  if (v77)
                    goto LABEL_90;
                  if (*(_BYTE *)(a1 + 1428))
                    break;
                  *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)v148;
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, *(__int16 *)&v148[30], v76, (uint64_t)v148, v30, v31, v32, v33);
                  v76 = *(_WORD *)&v148[32] + 1;
                  *(_WORD *)&v148[32] = v76;
                  if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < v76)
                    goto LABEL_89;
                }
              }
            }
          }
          goto LABEL_219;
        case 8u:
          v78 = (__int16)v34 - 1;
          if (!*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v78) + 36])
            goto LABEL_219;
          if (!*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 168) + v78) + 36])
            goto LABEL_219;
          v79 = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          *(_WORD *)&v148[32] = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          *(_DWORD *)(a1 + 1384) = 0;
          if (*(__int16 *)&v148[24] + a3 > v79)
            goto LABEL_219;
          while (1)
          {
            v77 = *(_DWORD *)(a1 + 1384);
            if (v77)
              break;
            if (*(_BYTE *)(a1 + 1428))
              goto LABEL_219;
            *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)v148;
            *(_WORD *)(a1 + 1470) = 0;
            EXEC_RULE(a1, *(__int16 *)&v148[30], v79, (uint64_t)v148, v30, v31, v32, v33);
            v79 = *(_WORD *)&v148[32] - 1;
            *(_WORD *)&v148[32] = v79;
            if (*(__int16 *)&v148[24] + a3 > v79)
            {
LABEL_89:
              v77 = *(_DWORD *)(a1 + 1384);
              break;
            }
          }
LABEL_90:
          if (v77 == 1)
          {
LABEL_91:
            v80 = *(_QWORD *)(a1 + 144);
            v81 = *(__int16 *)&v148[30];
            goto LABEL_131;
          }
          goto LABEL_219;
        case 9u:
          LODWORD(v150) = 1;
          v82 = *(unsigned __int16 *)&v148[24] + a3;
          *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
          v83 = *(_WORD *)&v148[26];
          if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < (__int16)(*(_WORD *)&v148[24] + a3))
            goto LABEL_217;
          v84 = *(_WORD *)&v148[34];
          while (1)
          {
            LOWORD(v85) = *(_WORD *)&v148[30];
            if (*(_BYTE *)(a1 + 1428))
              break;
            v149 = -2;
            v86 = *(_WORD *)&v148[30] + *(unsigned __int8 *)(*(__int16 *)&v148[30] + *v28 - 1);
            *(_WORD *)&v148[28] = v86;
            if (*(__int16 *)&v148[30] > v86)
              goto LABEL_101;
            v87 = v86;
            do
            {
              v88 = (__int16)v85 - 1;
              if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v88) + 36])
              {
                *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v88);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)v85, *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                v87 = *(_WORD *)&v148[28];
              }
              v85 = (__int16)(v85 + 1);
            }
            while (v85 <= v87);
            v82 = *(unsigned __int16 *)&v148[32];
            v84 = *(_WORD *)&v148[34];
            v83 = *(_WORD *)&v148[26];
            if (v149 == 65534)
LABEL_101:
              v89 = 1;
            else
              v89 = v149 + 1;
            v82 += v89;
            *(_WORD *)&v148[32] = v82;
            if (v84 - v83 < (__int16)v82)
            {
              LOWORD(v34) = *(_WORD *)&v148[30];
              goto LABEL_217;
            }
          }
          LOWORD(v34) = *(_WORD *)&v148[30];
          goto LABEL_217;
        case 0xAu:
          v90 = *(unsigned __int16 *)&v148[34] - *(unsigned __int16 *)&v148[26];
          *(_WORD *)&v148[32] = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          if (*(__int16 *)&v148[24] + a3 > (__int16)(*(_WORD *)&v148[34] - *(_WORD *)&v148[26]))
            goto LABEL_222;
          v91 = *(_WORD *)&v148[24];
          while (1)
          {
            LOWORD(v92) = *(_WORD *)&v148[30];
            if (*(_BYTE *)(a1 + 1428))
              break;
            v93 = *(_WORD *)&v148[30] + *(unsigned __int8 *)(*(__int16 *)&v148[30] + *v28 - 1);
            *(_WORD *)&v148[28] = v93;
            if (*(__int16 *)&v148[30] <= v93)
            {
              v94 = v93;
              do
              {
                if (*(_BYTE *)(a1 + 1428))
                  break;
                v95 = (__int16)v92 - 1;
                if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v95) + 36])
                {
                  *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v95);
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, (__int16)v92, *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                  v94 = *(_WORD *)&v148[28];
                }
                v92 = (__int16)(v92 + 1);
              }
              while (v92 <= v94);
              v90 = *(unsigned __int16 *)&v148[32];
              v91 = *(_WORD *)&v148[24];
            }
            *(_WORD *)&v148[32] = --v90;
            if (a3 + v91 > (__int16)v90)
            {
              LOWORD(v34) = *(_WORD *)&v148[30];
              goto LABEL_222;
            }
          }
          LOWORD(v34) = *(_WORD *)&v148[30];
LABEL_222:
          v132 = v34 + *(unsigned __int8 *)(*v28 + (__int16)v34 - 1);
          goto LABEL_199;
        case 0xBu:
          v96 = *(unsigned __int16 *)&v148[24] + a3;
          *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
          *(_DWORD *)(a1 + 1384) = 0;
          v97 = v34 + *(unsigned __int8 *)(*(_QWORD *)(a1 + 152) + (__int16)v34 - 1);
          *(_WORD *)&v148[28] = v97;
          v98 = *(_WORD *)&v148[34];
          v99 = *(_WORD *)&v148[26];
          if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < (__int16)v96)
            goto LABEL_129;
          while (!*(_DWORD *)(a1 + 1384))
          {
            if (*(_BYTE *)(a1 + 1428))
              goto LABEL_129;
            LOWORD(v100) = *(_WORD *)&v148[30];
            if (*(__int16 *)&v148[30] <= v97)
            {
              do
              {
                if (*(_BYTE *)(a1 + 1428))
                  break;
                v101 = (__int16)v100 - 1;
                if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v101) + 36])
                {
                  *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v101);
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, (__int16)v100, *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                  v97 = *(_WORD *)&v148[28];
                }
                v100 = (__int16)(v100 + 1);
              }
              while (v100 <= v97);
              v96 = *(unsigned __int16 *)&v148[32];
              v98 = *(_WORD *)&v148[34];
              v99 = *(_WORD *)&v148[26];
            }
            *(_WORD *)&v148[32] = ++v96;
            if (v98 - v99 < (__int16)v96)
              goto LABEL_182;
          }
          goto LABEL_214;
        case 0xCu:
          v102 = *(unsigned __int16 *)&v148[34] - *(unsigned __int16 *)&v148[26];
          *(_WORD *)&v148[32] = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          *(_DWORD *)(a1 + 1384) = 0;
          v103 = v34 + *(unsigned __int8 *)(*(_QWORD *)(a1 + 152) + (__int16)v34 - 1);
          *(_WORD *)&v148[28] = v103;
          v104 = *(_WORD *)&v148[24];
          if (*(__int16 *)&v148[24] + a3 > (__int16)v102)
            goto LABEL_129;
          do
          {
            if (*(_DWORD *)(a1 + 1384))
            {
LABEL_214:
              v105 = (uint64_t *)(a1 + 144);
              goto LABEL_130;
            }
            if (*(_BYTE *)(a1 + 1428))
              goto LABEL_129;
            LOWORD(v125) = *(_WORD *)&v148[30];
            if (*(__int16 *)&v148[30] <= v103)
            {
              do
              {
                if (*(_BYTE *)(a1 + 1428))
                  break;
                v126 = (__int16)v125 - 1;
                if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v126) + 36])
                {
                  *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v126);
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, (__int16)v125, *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                  v103 = *(_WORD *)&v148[28];
                }
                v125 = (__int16)(v125 + 1);
              }
              while (v125 <= v103);
              v102 = *(unsigned __int16 *)&v148[32];
              v104 = *(_WORD *)&v148[24];
            }
            *(_WORD *)&v148[32] = --v102;
          }
          while (a3 + v104 <= (__int16)v102);
LABEL_182:
          v105 = (uint64_t *)(a1 + 144);
          if (!*(_DWORD *)(a1 + 1384))
LABEL_129:
            v105 = (uint64_t *)(a1 + 152);
LABEL_130:
          v81 = *(__int16 *)&v148[30];
          v80 = *v105;
LABEL_131:
          v106 = v81 + v80;
          goto LABEL_198;
        case 0xDu:
          LODWORD(v150) = 1;
          v107 = *(_WORD *)&v148[24] + a3;
          *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
          do
          {
            if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < v107 || *(_BYTE *)(a1 + 1428))
              break;
            v108 = 0;
            v149 = -2;
            *(_DWORD *)(a1 + 1384) = 0;
            while (1)
            {
              v109 = v108;
              v110 = (__int16)v34 - 1;
              v111 = *(_DWORD *)(a1 + 1384);
              v112 = v109 <= *(unsigned __int8 *)(*(_QWORD *)(a1 + 152) + v110) && v111 == 0;
              if (!v112 || *(_BYTE *)(a1 + 1428))
                break;
              v113 = v110 + v109;
              if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v113) + 36])
              {
                *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v113);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)(v34 + v109), *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                LOWORD(v34) = *(_WORD *)&v148[30];
              }
              v108 = v109 + 1;
              v114 = *(__int16 *)(a1 + 44);
              if (v114 < (__int16)v34)
              {
                v111 = *(_DWORD *)(a1 + 1384);
                goto LABEL_147;
              }
            }
            LOWORD(v114) = *(_WORD *)(a1 + 44);
LABEL_147:
            v115 = v111 ? v149 + 1 : 1;
            v107 = v115 + *(_WORD *)&v148[32];
            *(_WORD *)&v148[32] = v107;
          }
          while ((__int16)v34 <= (__int16)v114);
          if (*(__int16 *)(a1 + 44) > (__int16)v34)
LABEL_217:
            *(_WORD *)&v148[30] = v34 + *(unsigned __int8 *)(*v28 + (__int16)v34 - 1);
          LODWORD(v150) = 0;
          goto LABEL_219;
        case 0xEu:
          *(_WORD *)&v148[32] = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          if (*(__int16 *)&v148[24] + a3 > (__int16)(*(_WORD *)&v148[34] - *(_WORD *)&v148[26]))
          {
            LOWORD(v81) = v34;
            goto LABEL_196;
          }
          v81 = v34;
          do
          {
            v127 = *(unsigned __int8 *)(a1 + 1428);
            if (*(_BYTE *)(a1 + 1428))
              break;
            v128 = 0;
            *(_DWORD *)(a1 + 1384) = 0;
            v129 = (__int16)v34;
            while (1)
            {
              if (*(_BYTE *)(a1 + 1428))
              {
                v131 = v34;
                goto LABEL_195;
              }
              v130 = v129 + v127 - 1;
              if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v130) + 36])
              {
                *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v130);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)(v34 + v128), *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                v81 = *(unsigned __int16 *)&v148[30];
              }
              v127 = ++v128;
              if (v128 > (int)*(unsigned __int8 *)(*v28 + (__int16)v81 - 1))
                break;
              v129 = (__int16)v81;
              v34 = v81;
              v131 = v81;
              if (*(_DWORD *)(a1 + 1384))
                goto LABEL_195;
            }
            v131 = v81;
LABEL_195:
            --*(_WORD *)&v148[32];
            v34 = v131;
          }
          while (*(__int16 *)&v148[24] + a3 <= *(__int16 *)&v148[32]);
LABEL_196:
          v124 = *v28;
          goto LABEL_197;
        case 0xFu:
          v116 = *(_WORD *)&v148[24] + a3;
          *(_WORD *)&v148[32] = *(_WORD *)&v148[24] + a3;
          *(_DWORD *)(a1 + 1384) = 0;
          if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < v116)
            goto LABEL_170;
          v81 = v34;
          while (!*(_DWORD *)(a1 + 1384))
          {
            v117 = *(unsigned __int8 *)(a1 + 1428);
            if (*(_BYTE *)(a1 + 1428))
              goto LABEL_171;
            v118 = 0;
            v119 = (__int16)v34;
            while (!*(_DWORD *)(a1 + 1384) && !*(_BYTE *)(a1 + 1428))
            {
              v120 = v119 + v117 - 1;
              if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v120) + 36])
              {
                *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v120);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)(v34 + v118), *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
                v81 = *(unsigned __int16 *)&v148[30];
              }
              v117 = ++v118;
              v119 = (__int16)v81;
              v34 = v81;
              v121 = v81;
              if (v118 > (int)*(unsigned __int8 *)(*v28 + (__int16)v81 - 1))
                goto LABEL_167;
            }
            v121 = v34;
LABEL_167:
            ++*(_WORD *)&v148[32];
            v34 = v121;
            if (*(__int16 *)&v148[34] - *(__int16 *)&v148[26] < *(__int16 *)&v148[32])
              goto LABEL_212;
          }
          goto LABEL_215;
        case 0x10u:
          v122 = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          *(_WORD *)&v148[32] = *(_WORD *)&v148[34] - *(_WORD *)&v148[26];
          *(_DWORD *)(a1 + 1384) = 0;
          if (*(__int16 *)&v148[24] + a3 > v122)
          {
LABEL_170:
            LOWORD(v81) = v34;
            goto LABEL_171;
          }
          v81 = v34;
          break;
        default:
          if (v38 == 99)
          {
            v47 = *(_QWORD *)(a1 + 1504);
            *(_QWORD *)&v148[8] = *(_QWORD *)(v47 + 8 * *(unsigned __int8 *)(v35 + v36) - 8);
            *(_QWORD *)(a1 + 1440) = *(_QWORD *)&v148[8];
            v48 = v36 + 1;
            *(_QWORD *)&v148[16] = *(_QWORD *)(v47 + 8 * *(unsigned __int8 *)(v35 + v48) - 8);
            *(_QWORD *)(a1 + 1448) = *(_QWORD *)&v148[16];
            LOWORD(v47) = *(unsigned __int8 *)(v35 + v48) - 1;
            *(_WORD *)(a1 + 1410) = v47;
            v152 = v47;
          }
          goto LABEL_219;
      }
      do
      {
        if (*(_DWORD *)(a1 + 1384))
        {
LABEL_215:
          v123 = (uint64_t *)(a1 + 144);
          goto LABEL_172;
        }
        v133 = *(unsigned __int8 *)(a1 + 1428);
        if (*(_BYTE *)(a1 + 1428))
          goto LABEL_171;
        v134 = 0;
        v135 = (__int16)v34;
        while (!*(_DWORD *)(a1 + 1384) && !*(_BYTE *)(a1 + 1428))
        {
          v136 = v135 + v133 - 1;
          if (*(_WORD *)&v148[2 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 160) + v136) + 36])
          {
            *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 176) + *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v136);
            *(_WORD *)(a1 + 1470) = 0;
            EXEC_RULE(a1, (__int16)(v34 + v134), *(__int16 *)&v148[32], (uint64_t)v148, v30, v31, v32, v33);
            v81 = *(unsigned __int16 *)&v148[30];
          }
          v133 = ++v134;
          v135 = (__int16)v81;
          v34 = v81;
          v137 = v81;
          if (v134 > (int)*(unsigned __int8 *)(*v28 + (__int16)v81 - 1))
            goto LABEL_211;
        }
        v137 = v34;
LABEL_211:
        --*(_WORD *)&v148[32];
        v34 = v137;
      }
      while (*(__int16 *)&v148[24] + a3 <= *(__int16 *)&v148[32]);
LABEL_212:
      v123 = (uint64_t *)(a1 + 144);
      if (!*(_DWORD *)(a1 + 1384))
LABEL_171:
        v123 = (uint64_t *)(a1 + 152);
LABEL_172:
      v124 = *v123;
LABEL_197:
      v106 = v124 + (__int16)v81;
LABEL_198:
      v132 = v81 + *(unsigned __int8 *)(v106 - 1);
LABEL_199:
      *(_WORD *)&v148[30] = v132;
LABEL_219:
      LOWORD(v27) = *(_WORD *)&v148[30];
    }
    while (*(__int16 *)&v148[30] < *(__int16 *)(*(_QWORD *)(a1 + 72) + 2 * v26));
  }
  v138 = *(__int16 *)&v148[34];
  *v5 = *(_WORD *)&v148[34];
  v139 = a3 - 1;
  if (*(__int16 *)(a1 + 24) >= 1)
  {
    v140 = 0;
    do
    {
      v141 = *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v140);
      memmove((void *)(v141 + 4 * v139), (const void *)(v141 + 4 * a3), 4 * (unsigned __int16)(v138 - a3 + 1));
      ++v140;
    }
    while (v140 < *(__int16 *)(a1 + 24));
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 1560) + a3) += *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v139);
  *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v138 - 1) += *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v138);
  memmove((void *)(*(_QWORD *)(a1 + 1560) + v139), (const void *)(*(_QWORD *)(a1 + 1560) + a3), (unsigned __int16)(v138 - a3));
  *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v138 - 1) = 0;
  v145 = *v5 - 1;
  *v5 = v145;
  if (!*(_WORD *)(a1 + 1430) && v145)
    *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v145 - 1) += *(_BYTE *)(*(_QWORD *)(a1 + 1560) + v145);
  *(_DWORD *)(a1 + 1432) = 1;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"End gram number %d", v142, v143, v144, a2);
  if (*(_BYTE *)(a1 + 1428))
    *v5 = a3 - 1;
  return HIDWORD(v150);
}

uint64_t EXEC_RULE(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned __int8 *v13;
  char *i;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  int v73;
  unsigned int *v74;
  _DWORD *v75;
  int v76;
  uint64_t v77;
  int v78;
  unsigned int *v79;
  _DWORD *v80;
  int v81;
  BOOL v82;
  uint64_t v83;
  unsigned __int8 *v84;
  _BYTE *v85;
  uint64_t v86;
  int v87;
  unsigned int *v88;
  _DWORD *v89;
  BOOL v90;
  uint64_t v91;
  unsigned int *v92;
  _DWORD *v93;
  BOOL v94;
  uint64_t v95;
  unsigned int *v96;
  _DWORD *v97;
  BOOL v98;
  uint64_t v99;
  unsigned int *v100;
  _DWORD *v101;
  BOOL v102;
  unsigned int *v103;
  _DWORD *v104;
  BOOL v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unsigned __int8 *v110;
  unsigned int *v111;
  _DWORD *v112;
  unsigned int *v113;
  _DWORD *v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  unsigned int *v119;
  _DWORD *v120;
  int v121;
  BOOL v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  unsigned int *v126;
  _DWORD *v127;
  int v128;
  BOOL v129;
  uint64_t v130;
  int v131;
  uint64_t v132;
  char *v133;
  int v134;
  unsigned int *v135;
  _DWORD *v136;
  int v137;
  int v138;
  BOOL v139;
  uint64_t v140;
  unsigned __int8 *v141;
  uint64_t v142;
  _BYTE *v143;
  uint64_t v144;
  int v145;
  int v146;
  uint64_t v147;
  unsigned int v148;
  unsigned int *v149;
  _DWORD *v150;
  unsigned int *v151;
  _DWORD *v152;
  int v153;
  BOOL v154;
  uint64_t v155;
  uint64_t v156;
  _BYTE *v157;
  uint64_t v158;
  int v159;
  unsigned int v160;
  BOOL v161;
  int v162;
  unsigned int v164;
  int v165;
  BOOL v167;
  uint64_t v168;
  BOOL v169;
  uint64_t v170;
  BOOL v171;
  BOOL v172;
  uint64_t v173;
  int v174;
  BOOL v175;
  uint64_t v176;
  int v177;
  int v178;
  BOOL v179;
  uint64_t v180;
  int v181;
  int v182;
  BOOL v183;
  _BYTE *v184;
  uint64_t v185;
  int v186;
  uint64_t v187;
  int v188;
  __int16 v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  __int16 v202;
  int v203;
  unsigned __int16 v204;
  uint64_t v205;
  uint64_t v206;
  int v207;
  int v208;
  __int16 v209;
  int v210;
  int v211;
  uint64_t v212;
  unsigned int v213;
  int v214;
  uint64_t v215;
  int v216;
  uint64_t v217;
  int v218;
  unsigned __int8 *v219;
  __int16 v220;
  uint64_t v221;
  __int16 v222;
  uint64_t v223;
  int v224;
  int v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  int v229;
  int v230;
  uint64_t v231;
  unsigned __int8 *v232;
  __int16 v233;
  uint64_t v234;
  __int16 v235;
  uint64_t v236;
  uint64_t v237;
  __int16 v238;
  uint64_t v239;
  int v240;
  uint64_t v241;
  int v242;
  uint64_t v243;
  int v244;
  uint64_t v245;
  unsigned int v246;
  int v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  unsigned __int16 v251;
  uint64_t v252;
  __int16 v253;
  uint64_t v254;
  uint64_t v255;
  __int16 v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  unsigned int v260;
  int v261;
  uint64_t v262;
  __int16 *v263;
  __int16 v264;
  int v265;
  uint64_t v266;
  uint64_t v267;
  unsigned int v268;
  int v269;
  int v270;
  uint64_t v271;
  int v272;
  int v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  unsigned __int8 *v278;
  uint64_t v279;
  unsigned __int8 *v280;
  unsigned __int8 v281;
  unsigned __int8 *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  unsigned __int8 *v286;
  int v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  unsigned int v291;
  int v292;
  int v293;
  int v294;
  __int16 *v295;
  char *__s;
  unsigned int v297;
  uint64_t v298;
  unsigned int **v300;
  int v301;
  _BYTE v302[5];

  v8 = a3;
  v294 = a2;
  v9 = result;
  LOWORD(v10) = 0;
  v12 = *(unsigned __int16 *)(a4 + 34);
  v11 = a4 + 34;
  v297 = v12;
  *(_WORD *)(result + 1476) = 0;
  v300 = (unsigned int **)(result + 2096);
  v13 = (unsigned __int8 *)(result + 1400);
  v295 = (__int16 *)v11;
  __s = (char *)(result + 1484);
  i = *(char **)(result + 1456);
  while (2)
  {
    switch(*i)
    {
      case 0:
        if (!(_WORD)v8)
          goto LABEL_431;
        v189 = *(_WORD *)(a4 + 32);
        *(_WORD *)(v9 + 1474) = v8 - v189;
        *(_WORD *)(v9 + 1468) = -1;
        *(_WORD *)(v9 + 1466) = v189 - 1;
        result = CTXT(v9, a2, a3, v11, a5, a6, a7, a8);
        if (!(_DWORD)result)
          goto LABEL_431;
        *(_WORD *)(v9 + 1468) = 1;
        *(_WORD *)(v9 + 1466) = v8;
        result = CTXT(v9, v190, v191, v192, v193, v194, v195, v196);
        if (!(_DWORD)result)
          goto LABEL_431;
        v301 = 0;
        v200 = a4;
        v201 = *(__int16 *)(a4 + 32);
        v202 = *(_WORD *)(v9 + 1474);
        v203 = (__int16)(v202 + v201);
        *(_QWORD *)(v9 + 1448) = *(_QWORD *)(a4 + 16);
        *(_DWORD *)(v9 + 1384) = 1;
        *(_WORD *)(v9 + 1410) = *(_WORD *)(a4 + 562);
        v204 = *(_WORD *)(a4 + 34);
        v205 = v204;
        v206 = *(_QWORD *)(v9 + 1456);
        result = v206 + 1;
        *(_QWORD *)(v9 + 1456) = v206 + 1;
        v207 = *(unsigned __int8 *)(v206 + 1);
        if (v207 == 22)
        {
          v210 = *(unsigned __int8 *)(*(_QWORD *)(v9 + 136) + v294 - 1);
          if (v203 - (int)v201 <= v210)
            v211 = 0;
          else
            v211 = v203 - v201 - v210;
          result = v206 + 2;
          *(_QWORD *)(v9 + 1456) = v206 + 2;
        }
        else
        {
          if (v207 == 1)
          {
            *(_QWORD *)(v9 + 1456) = v206 + 2;
            v208 = *(unsigned __int8 *)(v206 + 2);
            if (v208 == 1)
            {
              v209 = v202 - 1;
            }
            else if (v208 == 2)
            {
              v209 = v202 - 1;
              *(_WORD *)(a4 + 32) = **(_WORD **)(v9 + 184);
              *(_WORD *)(a4 + 30) = *(_WORD *)(v9 + 44);
            }
            else
            {
              v244 = (__int16)(v202 + v201);
              if ((int)v201 < v203)
              {
                v245 = v201;
                do
                {
                  Utf32SymToUtf8Sym(*(_DWORD *)(**(_QWORD **)(v9 + 1504) + 4 * v245), v302, 5u);
                  v246 = v302[0];
                  if (v302[0])
                  {
                    v247 = 0;
                    do
                    {
                      --*(_WORD *)(a4 + 2 * v246 + 36);
                      v246 = v302[(__int16)++v247];
                    }
                    while (v302[(__int16)v247]);
                  }
                  ++v245;
                }
                while (v245 != v244);
              }
              v248 = *(__int16 *)(v9 + 24);
              v249 = v244;
              if (v248 <= 0)
              {
                v251 = v204 - v244 + 1;
              }
              else
              {
                v250 = 0;
                v251 = v204 - v244 + 1;
                do
                {
                  v252 = *(_QWORD *)(v9 + 1416);
                  v253 = *(_WORD *)(v252 + 2 * v250) - v251;
                  *(_WORD *)(v252 + 2 * v250) = v253;
                  v254 = *(_QWORD *)(*(_QWORD *)(v9 + 1504) + 8 * v250);
                  memmove((void *)(v254 + 4 * v253), (const void *)(v254 + 4 * v244), 4 * v251);
                  ++v250;
                  v248 = *(__int16 *)(v9 + 24);
                }
                while (v250 < v248);
              }
              v255 = *(_QWORD *)(v9 + 1416);
              *(_WORD *)(v255 + 2 * v248) -= v251;
              memmove((void *)(*(_QWORD *)(v9 + 1560) + *(__int16 *)(v255 + 2 * *(__int16 *)(v9 + 24))), (const void *)(*(_QWORD *)(v9 + 1560) + v244), v251);
              bzero((void *)(*(_QWORD *)(v9 + 1560) + v244), v251);
              *v295 = v244;
              *(_DWORD *)(v9 + 1432) = 0;
              ++*(_WORD *)(v9 + 1430);
              v256 = *(_WORD *)(v9 + 1476);
              v257 = **(unsigned __int8 **)(v9 + 1456) - 1;
              switch(*(_BYTE *)(*(_QWORD *)(v9 + 56) + v257))
              {
                case 0:
                  v258 = v201;
                  INFERENCE(v9);
                  result = 1;
                  break;
                case 1:
                  v258 = v201;
                  INFERENCE(v9);
                  result = 0;
                  break;
                case 2:
                  v258 = v201;
                  result = INFERENCE(v9);
                  break;
                case 3:
                  v258 = v201;
                  result = DCT_LKP(v9, *(_QWORD *)(*(_QWORD *)(v9 + 1520) + 8 * v257), v201, v295);
                  break;
                default:
                  v258 = v201;
                  result = pfExt[*(unsigned __int8 *)(*(_QWORD *)(v9 + 56) + v257)](v9, v201, v295);
                  break;
              }
              *(_DWORD *)(v9 + 1384) = result;
              *(_WORD *)(v9 + 1476) = v256;
              --*(_WORD *)(v9 + 1430);
              if (*(unsigned __int8 *)(v9 + 1428) == 156)
              {
LABEL_421:
                if (*(unsigned __int8 *)(v9 + 1428) == 156)
                {
                  *(_DWORD *)(v9 + 1384) = 1;
                  *(_WORD *)(v200 + 548) = *(_WORD *)(v200 + 34) - *(_WORD *)(v200 + 32);
                  *(_WORD *)(v200 + 32) = **(_WORD **)(v9 + 184);
                  *(_WORD *)(v200 + 30) = *(_WORD *)(v9 + 44);
                  *v300 = 0;
                  v300[1] = 0;
                }
                else
                {
                  v270 = *(_DWORD *)(v9 + 1384);
                  *v300 = 0;
                  v300[1] = 0;
                  if (!v270)
                  {
LABEL_425:
                    v271 = *(_QWORD *)(v200 + 8);
                    if (*(_QWORD *)(v9 + 1440) != v271)
                      *(_QWORD *)(v9 + 1440) = v271;
                    if (*(__int16 *)(v9 + 2088) >= 6)
                    {
                      v272 = *(__int16 *)(v9 + 2 * *(__int16 *)(v9 + 1430) + 1568);
                      v273 = *v295;
                      Utf32LayersToUtf8Layers(v9, *v295);
                      result = log_OutText(*(_QWORD *)(*(_QWORD *)(v9 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"Rule number %d", v274, v275, v276, (v294 - *(__int16 *)(v9 + 2 * *(__int16 *)(v9 + 1430) + 1824)));
                      if (*(__int16 *)(v9 + 24) >= 1)
                      {
                        v277 = 0;
                        do
                        {
                          v278 = *(unsigned __int8 **)(*(_QWORD *)(v9 + 1496) + 8 * v277);
                          v279 = (uint64_t)&v278[(int)Utf8_LengthInBytes(v278, v272)];
                          v280 = *(unsigned __int8 **)(*(_QWORD *)(v9 + 1496) + 8 * v277);
                          v281 = v280[(int)Utf8_LengthInBytes(v280, v273)];
                          v282 = *(unsigned __int8 **)(*(_QWORD *)(v9 + 1496) + 8 * v277);
                          v282[(int)Utf8_LengthInBytes(v282, v273)] = 0;
                          log_OutText(*(_QWORD *)(*(_QWORD *)(v9 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"%s", v283, v284, v285, v279);
                          v286 = *(unsigned __int8 **)(*(_QWORD *)(v9 + 1496) + 8 * v277);
                          result = Utf8_LengthInBytes(v286, v273);
                          v286[(int)result] = v281;
                          ++v277;
                        }
                        while (v277 < *(__int16 *)(v9 + 24));
                      }
                    }
                    goto LABEL_431;
                  }
                }
                *(_DWORD *)(v200 + 556) = 1;
                goto LABEL_425;
              }
              v262 = *v295;
              if (!*(_DWORD *)(v9 + 1432))
              {
                if (v244 >= (int)v262)
                {
                  v264 = *v295;
                  LOWORD(v265) = v244;
                  v263 = v295;
                  do
                  {
                    v266 = *(_QWORD *)(v9 + 1560);
                    if (*(_BYTE *)(v266 + (__int16)v265))
                    {
                      *(_BYTE *)(v262 + v266 - 1) += *(_BYTE *)(v266 + (__int16)v265);
                      v264 = *v295;
                    }
                    v265 = (__int16)(v265 - 1);
                    v262 = v264;
                  }
                  while (v265 >= v264);
                }
                else
                {
                  v263 = v295;
                }
                *(_BYTE *)(*(_QWORD *)(v9 + 1560) + v262) = 0;
                LODWORD(v262) = *v263;
                v200 = a4;
                if (v244 < (int)v262)
                {
                  do
                  {
                    *(_BYTE *)(*(_QWORD *)(v9 + 1560) + v249++) = 0;
                    v262 = *v295;
                  }
                  while (v249 < v262);
                  v200 = a4;
                }
              }
              if ((int)v258 < (__int16)v262)
              {
                v267 = (__int16)v262;
                do
                {
                  Utf32SymToUtf8Sym(*(_DWORD *)(**(_QWORD **)(v9 + 1504) + 4 * v258), v302, 5u);
                  v268 = v302[0];
                  if (v302[0])
                  {
                    v269 = 0;
                    do
                    {
                      ++*(_WORD *)(v200 + 2 * v268 + 36);
                      v268 = v302[(__int16)++v269];
                    }
                    while (v302[(__int16)v269]);
                  }
                  ++v258;
                }
                while (v258 != v267);
                LOWORD(v262) = *v295;
              }
              if (*(_DWORD *)(v9 + 1384))
                v209 = v262 + *(_WORD *)(v9 + 1476) + ~*(_WORD *)(v200 + 32);
              else
                v209 = 0;
              result = RESTORE_SUBSTITUTION(v9, (__int16)v262);
              *v295 = result;
            }
LABEL_418:
            if (!*(_DWORD *)(v200 + 552) || *(__int16 *)(v200 + 548) < v209)
              *(_WORD *)(v200 + 548) = v209;
            goto LABEL_421;
          }
          v211 = 0;
        }
        if ((int)v201 < v203)
        {
          v212 = v201;
          do
          {
            Utf32SymToUtf8Sym(*(_DWORD *)(**(_QWORD **)(v9 + 1504) + 4 * v212), v302, 5u);
            v213 = v302[0];
            if (v302[0])
            {
              v214 = 0;
              do
              {
                --*(_WORD *)(a4 + 2 * v213 + 36);
                v213 = v302[(__int16)++v214];
              }
              while (v302[(__int16)v214]);
            }
            ++v212;
          }
          while (v212 != v203);
          result = *(_QWORD *)(v9 + 1456);
        }
        v292 = v211 << 16;
        v293 = (__int16)v211;
        v215 = v201;
        v216 = v201;
        v217 = v205;
        v290 = v201;
        while (1)
        {
          LOBYTE(v218) = *(_BYTE *)result;
          switch(*(_BYTE *)result)
          {
            case 0:
              if ((__int16)v216 < (__int16)v203)
                memmove((void *)(*(_QWORD *)(v9 + 1448) + 4 * (__int16)v216), (const void *)(*(_QWORD *)(v9 + 1448) + 4 * (__int16)v203), 4 * (unsigned __int16)(v217 - v203 + 1));
              result = MOVE_FOR_SUBSTITUTION(v9, (__int16)v203, (__int16)v205, (__int16)(v215 - v203));
              if ((_DWORD)result)
              {
                *(_WORD *)(v200 + 34) = v215 + v205 - v203;
                v209 = v215 + ~*(_WORD *)(v200 + 32);
                if ((int)v290 >= (__int16)v215)
                {
                  v200 = a4;
                }
                else
                {
                  v259 = v290;
                  v200 = a4;
                  do
                  {
                    result = Utf32SymToUtf8Sym(*(_DWORD *)(**(_QWORD **)(v9 + 1504) + 4 * v259), v302, 5u);
                    v260 = v302[0];
                    if (v302[0])
                    {
                      v261 = 0;
                      do
                      {
                        ++*(_WORD *)(a4 + 2 * v260 + 36);
                        v260 = v302[(__int16)++v261];
                      }
                      while (v302[(__int16)v261]);
                    }
                    ++v259;
                  }
                  while (v259 != (__int16)v215);
                }
                goto LABEL_418;
              }
              goto LABEL_421;
            case 2:
              v223 = v215;
              *(_QWORD *)(v9 + 1456) = result + 1;
              v224 = *(unsigned __int8 *)(result + 1);
              v225 = *(__int16 *)(v9 + 46);
              v298 = v201;
              if (v224 > v225)
              {
                result = log_OutText(*(_QWORD *)(*(_QWORD *)(v9 + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: pActRule > nr_vars (3)", v197, v198, v199, v289);
                v224 = **(unsigned __int8 **)(v9 + 1456);
                v225 = *(__int16 *)(v9 + 46);
              }
              v291 = v205;
              if (v224 > v225)
                goto LABEL_366;
              v226 = v217;
              v227 = *(_QWORD *)(v9 + 1512);
              v228 = (5 * v224);
              result = strlen((const char *)(v227 + v228));
              if ((int)((_DWORD)result << 16) < 1)
                goto LABEL_346;
              v229 = 0;
              v230 = 0;
              while (2)
              {
                if ((__int16)v216 < (__int16)v203)
                  goto LABEL_342;
                if ((__int16)v226 + 1 < *(__int16 *)(*(_QWORD *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1)
                {
                  if (*(char *)(v227 + (int)v228 + (uint64_t)v229) >= -64)
                  {
                    v231 = *(_QWORD *)(v9 + 1448) + 4 * (__int16)v216;
                    memmove((void *)(v231 + 4), (const void *)v231, 4 * (unsigned __int16)(v226 - v216 + 1));
                    v226 = (v226 + 1);
                    v227 = *(_QWORD *)(v9 + 1512);
                    v224 = **(unsigned __int8 **)(v9 + 1456);
                  }
LABEL_342:
                  v228 = 5 * v224;
                  v232 = (unsigned __int8 *)(v227 + v228 + v229);
                  if ((char)*v232 >= -64)
                  {
                    v223 = (v223 + 1);
                    v298 = (v298 + 1);
                    FirstUtf8SymToUtf32(v232, &v301);
                    v233 = v216++;
                    *(_DWORD *)(*(_QWORD *)(v9 + 1448) + 4 * v233) = v301;
                    v227 = *(_QWORD *)(v9 + 1512);
                    v224 = **(unsigned __int8 **)(v9 + 1456);
                    LODWORD(v228) = 5 * v224;
                  }
                  v229 = (__int16)++v230;
                  result = strlen((const char *)(v227 + v228));
                  if ((__int16)v230 >= (__int16)result)
                  {
                    v200 = a4;
LABEL_346:
                    v205 = v291;
                    v215 = v223;
                    v217 = v226;
                    v201 = v298;
                    goto LABEL_326;
                  }
                  continue;
                }
                break;
              }
              *(_BYTE *)(v9 + 1428) = -100;
              v200 = a4;
              goto LABEL_421;
            case 7:
              *(_QWORD *)(v9 + 1456) = result + 1;
              result = strlen(__s);
              if ((int)((_DWORD)result << 16) < 1)
                goto LABEL_326;
              v234 = v217;
              v235 = 0;
              do
              {
                if ((__int16)v216 >= (__int16)v203)
                {
                  if ((__int16)v234 + 1 >= *(__int16 *)(*(_QWORD *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1)
                    goto LABEL_366;
                  v236 = v235;
                  if (*(char *)(v9 + v235 + 1484) >= -64)
                  {
                    v237 = *(_QWORD *)(v9 + 1448) + 4 * (__int16)v216;
                    memmove((void *)(v237 + 4), (const void *)v237, 4 * (unsigned __int16)(v234 - v216 + 1));
                    v234 = (v234 + 1);
                  }
                }
                else
                {
                  v236 = v235;
                }
                if (*(char *)(v9 + v236 + 1484) >= -64)
                {
                  v215 = (v215 + 1);
                  v201 = (v201 + 1);
                  FirstUtf8SymToUtf32((unsigned __int8 *)(v9 + v236 + 1484), &v301);
                  v238 = v216++;
                  *(_DWORD *)(*(_QWORD *)(v9 + 1448) + 4 * v238) = v301;
                }
                ++v235;
                result = strlen(__s);
              }
              while ((__int16)result > v235);
              v217 = v234;
              goto LABEL_326;
            case 0xE:
            case 0x10:
              *(_QWORD *)(v9 + 1456) = result + 1;
              if ((__int16)v216 < (__int16)v201)
                memmove((void *)(*(_QWORD *)(v9 + 1448) + 4 * (__int16)v216), (const void *)(*(_QWORD *)(v9 + 1448) + 4 * (__int16)v201), 4 * (unsigned __int16)(v217 - v201 + 1));
              if ((__int16)v215 <= (__int16)v203)
                goto LABEL_318;
              result = MOVE_FOR_SUBSTITUTION(v9, (__int16)v203, (__int16)v205, (__int16)(v215 - v203));
              if (!(_DWORD)result)
                goto LABEL_421;
              v205 = (v215 + v205 - v203);
              v203 = v215;
LABEL_318:
              v219 = *(unsigned __int8 **)(v9 + 1456);
              *(_QWORD *)(v9 + 1448) = *(_QWORD *)(*(_QWORD *)(v9 + 1504) + 8 * *v219 - 8);
              v220 = *v219 - 1;
              goto LABEL_325;
            case 0xF:
            case 0x11:
              *(_QWORD *)(v9 + 1456) = result + 1;
              if ((__int16)v216 < (__int16)v201)
                memmove((void *)(*(_QWORD *)(v9 + 1448) + 4 * (__int16)v216), (const void *)(*(_QWORD *)(v9 + 1448) + 4 * (__int16)v201), 4 * (unsigned __int16)(v217 - v201 + 1));
              if ((__int16)v215 <= (__int16)v203)
                goto LABEL_324;
              result = MOVE_FOR_SUBSTITUTION(v9, (__int16)v203, (__int16)v205, (__int16)(v215 - v203));
              if (!(_DWORD)result)
                goto LABEL_421;
              v205 = (v215 + v205 - v203);
              *v295 = v205;
              v203 = v215;
LABEL_324:
              *(_QWORD *)(v9 + 1448) = *(_QWORD *)(v200 + 16);
              v220 = *(_WORD *)(v200 + 562);
LABEL_325:
              *(_WORD *)(v9 + 1410) = v220;
              v216 = v215;
              v217 = v205;
              v201 = v215;
              goto LABEL_326;
            case 0x13:
              if (v292 < 1)
                goto LABEL_326;
              v239 = v217;
              v240 = 0;
              break;
            default:
              v218 = (char)v218;
              if ((__int16)v216 < (__int16)v203)
                goto LABEL_331;
              if ((__int16)v217 + 1 >= *(__int16 *)(*(_QWORD *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1)
                goto LABEL_366;
              if (v218 >= -64)
              {
                v221 = *(_QWORD *)(v9 + 1448) + 4 * (__int16)v216;
                memmove((void *)(v221 + 4), (const void *)v221, 4 * (unsigned __int16)(v217 - v216 + 1));
                v217 = (v217 + 1);
                result = *(_QWORD *)(v9 + 1456);
                LOBYTE(v218) = *(_BYTE *)result;
LABEL_331:
                if ((char)v218 >= -64)
                {
                  v215 = (v215 + 1);
                  v201 = (v201 + 1);
                  FirstUtf8SymToUtf32((unsigned __int8 *)result, &v301);
                  v222 = v216++;
                  *(_DWORD *)(*(_QWORD *)(v9 + 1448) + 4 * v222) = v301;
                }
              }
              goto LABEL_326;
          }
          do
          {
            if ((__int16)v216 >= (__int16)v203)
            {
              v242 = v239;
              if ((__int16)v239 + 1 >= *(__int16 *)(*(_QWORD *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1)
              {
LABEL_366:
                *(_BYTE *)(v9 + 1428) = -100;
                goto LABEL_421;
              }
              v241 = (__int16)v216;
              v243 = *(_QWORD *)(v9 + 1448) + 4 * (__int16)v216;
              result = (uint64_t)memmove((void *)(v243 + 4), (const void *)v243, 4 * (unsigned __int16)(v239 - v216 + 1));
              v239 = (v242 + 1);
            }
            else
            {
              v241 = (__int16)v216;
            }
            v215 = (v215 + 1);
            v201 = (v201 + 1);
            ++v216;
            *(_DWORD *)(*(_QWORD *)(v9 + 1448) + 4 * v241) = 126;
            ++v240;
          }
          while (v293 > (__int16)v240);
          v217 = v239;
LABEL_326:
          result = *(_QWORD *)(v9 + 1456) + 1;
          *(_QWORD *)(v9 + 1456) = result;
        }
      case 2:
        v22 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          v23 = v8;
          do
          {
            LODWORD(v8) = v23;
            v24 = (__int16)v23;
            v25 = *(_DWORD *)(v22 + 4 * (__int16)v23);
            v23 += *(unsigned __int16 *)(v9 + 1470);
          }
          while (v25 == 126);
        }
        else
        {
          v24 = (__int16)v8;
        }
        v79 = (unsigned int *)(v22 + 4 * v24);
        if (*v300 != v79)
        {
          result = Utf32SymToUtf8Sym(*v79, v13, 5u);
          v80 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v24);
          *(_BYTE *)(v9 + 1405) = *v80 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v80;
        }
        v81 = *v13;
        if (*v13)
          v82 = v81 == 31;
        else
          v82 = 1;
        if (v82)
          goto LABEL_431;
        v83 = *(_QWORD *)(v9 + 1512);
        v84 = (unsigned __int8 *)(*(_QWORD *)(v9 + 1456) + 1);
        *(_QWORD *)(v9 + 1456) = v84;
        a2 = *v84;
        v85 = (_BYTE *)(v83 + 5 * a2);
        if (!*v85)
        {
          result = VAR_APPEARENCE(v9, a2);
          if (!(_DWORD)result)
            goto LABEL_431;
          *(_DWORD *)(v9 + 1480) = 1;
          result = SETUTF8CHAR((uint64_t)v85, v13);
          v84 = *(unsigned __int8 **)(v9 + 1456);
LABEL_219:
          *(_WORD *)(v9 + 1470) = 1;
          v8 = (v8 + 1);
LABEL_220:
          i = (char *)(v84 + 1);
          *(_QWORD *)(v9 + 1456) = v84 + 1;
          continue;
        }
        v86 = 0;
        v87 = 0;
        while (v81 == v85[v86])
        {
          v86 = (__int16)++v87;
          v81 = v13[(__int16)v87];
          if (!v13[(__int16)v87])
            goto LABEL_219;
        }
LABEL_431:
        if (*(_DWORD *)(v9 + 1480))
        {
          if ((*(__int16 *)(v9 + 46) & 0x80000000) == 0)
          {
            v287 = 0;
            do
            {
              *(_BYTE *)(*(_QWORD *)(v9 + 1512) + (__int16)v287) = 0;
              v287 += 5;
            }
            while (5 * *(__int16 *)(v9 + 46) + 5 > (__int16)v287);
          }
          *(_DWORD *)(v9 + 1480) = 0;
        }
        v288 = *(_QWORD *)(a4 + 8);
        if (*(_QWORD *)(v9 + 1440) != v288)
          *(_QWORD *)(v9 + 1440) = v288;
        return result;
      case 3:
        v26 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v27 = v8;
            v28 = (__int16)v8;
            v29 = *(_DWORD *)(v26 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v29 == 126);
          LODWORD(v8) = v27;
        }
        else
        {
          v28 = (__int16)v8;
        }
        v88 = (unsigned int *)(v26 + 4 * v28);
        if (*v300 != v88)
        {
          result = Utf32SymToUtf8Sym(*v88, v13, 5u);
          v89 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v28);
          *(_BYTE *)(v9 + 1405) = *v89 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v89;
        }
        if (*v13)
          v90 = *v13 == 31;
        else
          v90 = 1;
        if (v90)
          goto LABEL_431;
        v91 = *(_QWORD *)(v9 + 2120);
        goto LABEL_97;
      case 4:
        v30 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v31 = v8;
            v32 = (__int16)v8;
            v33 = *(_DWORD *)(v30 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v33 == 126);
          LODWORD(v8) = v31;
        }
        else
        {
          v32 = (__int16)v8;
        }
        v92 = (unsigned int *)(v30 + 4 * v32);
        if (*v300 != v92)
        {
          result = Utf32SymToUtf8Sym(*v92, v13, 5u);
          v93 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v32);
          *(_BYTE *)(v9 + 1405) = *v93 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v93;
        }
        if (*v13)
          v94 = *v13 == 31;
        else
          v94 = 1;
        if (v94)
          goto LABEL_431;
        v95 = *(_QWORD *)(v9 + 2120);
        goto LABEL_107;
      case 5:
        v34 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v35 = v8;
            v36 = (__int16)v8;
            v37 = *(_DWORD *)(v34 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v37 == 126);
          LODWORD(v8) = v35;
        }
        else
        {
          v36 = (__int16)v8;
        }
        v96 = (unsigned int *)(v34 + 4 * v36);
        if (*v300 != v96)
        {
          result = Utf32SymToUtf8Sym(*v96, v13, 5u);
          v97 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v36);
          *(_BYTE *)(v9 + 1405) = *v97 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v97;
        }
        if (*v13)
          v98 = *v13 == 31;
        else
          v98 = 1;
        if (v98)
          goto LABEL_431;
        v91 = *(_QWORD *)(v9 + 2128);
LABEL_97:
        v99 = *(_QWORD *)(v9 + 1456);
        *(_QWORD *)(v9 + 1456) = v99 + 1;
        result = (uint64_t)strstr(*(char **)(*(_QWORD *)(v91 + 8 * (*(_BYTE *)(v99 + 1) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13);
        if (!result)
          goto LABEL_431;
        goto LABEL_108;
      case 6:
        v38 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v39 = v8;
            v40 = (__int16)v8;
            v41 = *(_DWORD *)(v38 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v41 == 126);
          LODWORD(v8) = v39;
        }
        else
        {
          v40 = (__int16)v8;
        }
        v100 = (unsigned int *)(v38 + 4 * v40);
        if (*v300 != v100)
        {
          result = Utf32SymToUtf8Sym(*v100, v13, 5u);
          v101 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v40);
          *(_BYTE *)(v9 + 1405) = *v101 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v101;
        }
        if (*v13)
          v102 = *v13 == 31;
        else
          v102 = 1;
        if (v102)
          goto LABEL_431;
        v95 = *(_QWORD *)(v9 + 2128);
LABEL_107:
        v99 = *(_QWORD *)(v9 + 1456);
        *(_QWORD *)(v9 + 1456) = v99 + 1;
        result = (uint64_t)strstr(*(char **)(*(_QWORD *)(v95 + 8 * (*(_BYTE *)(v99 + 1) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13);
        if (result)
          goto LABEL_431;
LABEL_108:
        *(_WORD *)(v9 + 1470) = 1;
        v8 = (v8 + 1);
        i = (char *)(v99 + 2);
        *(_QWORD *)(v9 + 1456) = v99 + 2;
        continue;
      case 7:
        v42 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v43 = v8;
            v44 = (__int16)v8;
            v45 = *(_DWORD *)(v42 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v45 == 126);
          LODWORD(v8) = v43;
        }
        else
        {
          v44 = (__int16)v8;
        }
        v103 = (unsigned int *)(v42 + 4 * v44);
        if (*v300 != v103)
        {
          result = Utf32SymToUtf8Sym(*v103, v13, 5u);
          v104 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v44);
          *(_BYTE *)(v9 + 1405) = *v104 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v104;
        }
        if (*v13)
          v105 = *v13 == 31;
        else
          v105 = 1;
        if (v105)
          goto LABEL_431;
        v106 = *(_QWORD *)(v9 + 1456);
        *(_QWORD *)(v9 + 1456) = v106 + 1;
        v107 = *(unsigned __int8 *)(v106 + 1);
        v108 = v107 - 1;
        result = (uint64_t)strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(v9 + 2128) + 8 * (v107 - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13);
        if (!result)
          goto LABEL_431;
        v109 = *(_QWORD *)(v9 + 88);
        result = (uint64_t)strstr((char *)(v109 + (v108 << 8)), (const char *)v13);
        if (!result)
          goto LABEL_431;
        if ((v108 & 1) != 0)
        {
          v107 -= 2;
          v110 = (unsigned __int8 *)(*(_QWORD *)(v9 + 96) + (v108 << 8) + result - (v109 + (v108 << 8)));
        }
        else
        {
          v110 = (unsigned __int8 *)(*(_QWORD *)(v9 + 96)
                                   + ((unint64_t)v108 << 8)
                                   + result
                                   - (v109
                                    + ((unint64_t)v108 << 8)));
        }
        result = SETUTF8CHAR((uint64_t)__s, (unsigned __int8 *)(v109 + (v107 << 8) + *v110));
LABEL_126:
        *(_WORD *)(v9 + 1470) = 1;
        v8 = (v8 + 1);
        v84 = *(unsigned __int8 **)(v9 + 1456);
        goto LABEL_220;
      case 8:
        v46 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v47 = v8;
            v48 = (__int16)v8;
            v49 = *(_DWORD *)(v46 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v49 == 126);
          LODWORD(v8) = v47;
        }
        else
        {
          v48 = (__int16)v8;
        }
        v111 = (unsigned int *)(v46 + 4 * v48);
        if (*v300 != v111)
        {
          Utf32SymToUtf8Sym(*v111, v13, 5u);
          v112 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v48);
          *(_BYTE *)(v9 + 1405) = *v112 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v112;
          i = *(char **)(v9 + 1456);
        }
        *(_QWORD *)(v9 + 1456) = i + 1;
        result = CHECK_OF_LIST(v9, 8u, (__int16)v8, v11, a5, a6, a7, a8);
        if ((_DWORD)result)
          goto LABEL_126;
        goto LABEL_431;
      case 11:
        *(_WORD *)(v9 + 1472) = v8;
        v50 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v51 = v8;
            v52 = (__int16)v8;
            v53 = *(_DWORD *)(v50 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v53 == 126);
          LOWORD(v8) = v51;
        }
        else
        {
          v52 = (__int16)v8;
        }
        v113 = (unsigned int *)(v50 + 4 * v52);
        if (*v300 != v113)
        {
          Utf32SymToUtf8Sym(*v113, v13, 5u);
          v114 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v52);
          *(_BYTE *)(v9 + 1405) = *v114 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v114;
          i = *(char **)(v9 + 1456);
        }
        v115 = i[2];
        if (v115 == 220)
          v115 = 5000;
        *(_WORD *)(v9 + 1406) = v115;
        if (v115
          && (*(_QWORD *)(v9 + 1456) = i + 3, CHECK_OF_LIST(v9, 0xBu, (__int16)v8, v11, a5, a6, a7, a8)))
        {
          LOWORD(v10) = 0;
          do
          {
            v117 = *(_QWORD *)(v9 + 1456);
            *(_WORD *)(v9 + 1472) = v8 + 1;
            v118 = TOKEN1(v9, (__int16)(v8 + 1), v116, v11, a5, a6, a7, a8);
            v10 = (__int16)(v10 + 1);
            if (v10 >= *(__int16 *)(v9 + 1406))
              break;
            LOWORD(v8) = v118;
            *(_QWORD *)(v9 + 1456) = i + 3;
          }
          while (CHECK_OF_LIST(v9, 0xBu, v118, v11, a5, a6, a7, a8));
        }
        else
        {
          v10 = 0;
          v117 = 0;
        }
        result = LOG_WARNING_ON_MAX_NUMBER(v9, v10, 1u, v11, a5, a6, a7, a8);
        if (v10 < i[1])
          goto LABEL_431;
        if (v117)
          *(_QWORD *)(v9 + 1456) = v117;
        else
          v117 = *(_QWORD *)(v9 + 1456);
        v8 = *(unsigned __int16 *)(v9 + 1472);
        for (i = (char *)(v117 + 1); ; ++i)
        {
          if (*(i - 1) == 11)
          {
            v160 = *(i - 2);
            v161 = v160 > 0x15;
            v162 = (1 << v160) & 0x20067C;
            if (v161 || v162 == 0)
              break;
            v164 = *(i - 3);
            v161 = v164 > 0x15;
            v165 = (1 << v164) & 0x20C67C;
            if (!v161 && v165 != 0)
              break;
          }
          *(_QWORD *)(v9 + 1456) = i;
        }
        goto LABEL_290;
      case 12:
        v54 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v55 = v8;
            v56 = (__int16)v8;
            v57 = *(_DWORD *)(v54 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v57 == 126);
          LODWORD(v8) = v55;
        }
        else
        {
          v56 = (__int16)v8;
        }
        v119 = (unsigned int *)(v54 + 4 * v56);
        if (*v300 != v119)
        {
          result = Utf32SymToUtf8Sym(*v119, v13, 5u);
          v120 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v56);
          *(_BYTE *)(v9 + 1405) = *v120 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v120;
        }
        v121 = *v13;
        if (*v13)
          v122 = v121 == 31;
        else
          v122 = 1;
        if (v122)
          goto LABEL_431;
        v123 = 0;
        v124 = 0;
        v125 = *(_QWORD *)(v9 + 1456) + 1;
        *(_QWORD *)(v9 + 1456) = v125;
        do
        {
          if (v121 != *(unsigned __int8 *)(v125 + v123))
            goto LABEL_431;
          v123 = (__int16)++v124;
          v121 = v13[(__int16)v124];
        }
        while (v13[(__int16)v124]);
        *(_WORD *)(v9 + 1470) = 1;
        v8 = (v8 + 1);
        result = strlen((const char *)v13);
        i = (char *)(v125 + result);
        *(_QWORD *)(v9 + 1456) = v125 + result;
        continue;
      case 13:
        v58 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v59 = v8;
            v60 = (__int16)v8;
            v61 = *(_DWORD *)(v58 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v61 == 126);
          LODWORD(v8) = v59;
        }
        else
        {
          v60 = (__int16)v8;
        }
        v126 = (unsigned int *)(v58 + 4 * v60);
        if (*v300 != v126)
        {
          result = Utf32SymToUtf8Sym(*v126, v13, 5u);
          v127 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v60);
          *(_BYTE *)(v9 + 1405) = *v127 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v127;
        }
        v128 = *v13;
        if (*v13)
          v129 = v128 == 31;
        else
          v129 = 1;
        if (v129)
          goto LABEL_431;
        v130 = 0;
        v131 = 0;
        v132 = *(_QWORD *)(v9 + 1456);
        *(_QWORD *)(v9 + 1456) = v132 + 1;
        while (v128 == *(unsigned __int8 *)(v132 + 1 + v130))
        {
          v130 = (__int16)++v131;
          v128 = v13[(__int16)v131];
          if (!v13[(__int16)v131])
            goto LABEL_431;
        }
        v133 = (char *)(v132 + 2);
        do
        {
          *(_QWORD *)(v9 + 1456) = v133;
          v134 = *v133++;
        }
        while (v134 < -64);
        *(_WORD *)(v9 + 1470) = 1;
        v8 = (v8 + 1);
        i = v133 - 1;
        continue;
      case 14:
      case 16:
        v15 = *(_QWORD *)(v9 + 1440);
        *(_QWORD *)(v9 + 1368) = v15;
        v16 = v15 + 4 * (__int16)v8;
        if (*(_QWORD *)(v9 + 2104) == v16)
        {
          v8 = *(unsigned __int16 *)(v9 + 2112);
        }
        else
        {
          *(_QWORD *)(v9 + 2104) = v16;
          *(_WORD *)(v9 + 2112) = v8;
        }
        v17 = *(_QWORD *)(*(_QWORD *)(v9 + 1504) + 8 * i[1] - 8);
        goto LABEL_52;
      case 15:
      case 17:
        v17 = *(_QWORD *)(v9 + 1368);
LABEL_52:
        *(_QWORD *)(v9 + 1440) = v17;
        *(_WORD *)(v9 + 1470) = 0;
        i += 2;
        *(_QWORD *)(v9 + 1456) = i;
        continue;
      case 18:
        *(_WORD *)(v9 + 1472) = v8;
        v62 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v63 = v8;
            v64 = (__int16)v8;
            v65 = *(_DWORD *)(v62 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v65 == 126);
          LOWORD(v8) = v63;
        }
        else
        {
          v64 = (__int16)v8;
        }
        v135 = (unsigned int *)(v62 + 4 * v64);
        if (*v300 != v135)
        {
          result = Utf32SymToUtf8Sym(*v135, v13, 5u);
          v136 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v64);
          *(_BYTE *)(v9 + 1405) = *v136 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v136;
          i = *(char **)(v9 + 1456);
        }
        v137 = i[2];
        if (v137 == 220)
          v137 = 5000;
        *(_WORD *)(v9 + 1406) = v137;
        *(_QWORD *)(v9 + 1392) = i + 4;
        switch(i[3])
        {
          case 2:
            LOWORD(v10) = 0;
            if (!v137)
              goto LABEL_186;
            while (1)
            {
              v138 = *v13;
              if (*v13)
                v139 = v138 == 31;
              else
                v139 = 1;
              if (v139)
                goto LABEL_186;
              v140 = *(_QWORD *)(v9 + 1512);
              v141 = *(unsigned __int8 **)(v9 + 1392);
              v142 = *v141;
              v143 = (_BYTE *)(v140 + 5 * v142);
              if (*v143)
                break;
              if (VAR_APPEARENCE(v9, v142))
              {
                *(_DWORD *)(v9 + 1480) = 1;
                SETUTF8CHAR(v140 + 5 * *v141, v13);
LABEL_185:
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
                v10 = (__int16)(v10 + 1);
                if (v10 < *(__int16 *)(v9 + 1406))
                  continue;
              }
              goto LABEL_186;
            }
            v144 = 0;
            v145 = 0;
            while (v138 == v143[v144])
            {
              v144 = (__int16)++v145;
              v138 = v13[(__int16)v145];
              if (!v13[(__int16)v145])
                goto LABEL_185;
            }
LABEL_186:
            v146 = (__int16)v10;
            v147 = v9;
            v148 = 7;
            goto LABEL_286;
          case 3:
            LOWORD(v10) = 0;
            if (v137)
            {
              do
              {
                if (*v13)
                  v167 = *v13 == 31;
                else
                  v167 = 1;
                if (v167)
                  break;
                if (!strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(v9 + 2120)+ 8 * (**(_BYTE **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13))break;
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), v168, v11, a5, a6, a7, a8);
                v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            v146 = (__int16)v10;
            v147 = v9;
            v148 = 2;
            goto LABEL_286;
          case 4:
            LOWORD(v10) = 0;
            if (v137)
            {
              do
              {
                if (*v13)
                  v169 = *v13 == 31;
                else
                  v169 = 1;
                if (v169)
                  break;
                if (strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(v9 + 2120)+ 8 * (**(_BYTE **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13))
                {
                  break;
                }
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), v170, v11, a5, a6, a7, a8);
                v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            v146 = (__int16)v10;
            v147 = v9;
            v148 = 3;
            goto LABEL_286;
          case 5:
            LOWORD(v10) = 0;
            if (v137)
            {
              do
              {
                if (*v13)
                  v171 = *v13 == 31;
                else
                  v171 = 1;
                if (v171)
                  break;
                result = (uint64_t)strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(v9 + 2128)+ 8 * (**(_BYTE **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13);
                if (!result)
                  break;
                *(_WORD *)(v9 + 1472) = v8 + 1;
                result = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
                LOWORD(v8) = result;
                v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            goto LABEL_287;
          case 6:
            LOWORD(v10) = 0;
            if (v137)
            {
              do
              {
                if (*v13)
                  v172 = *v13 == 31;
                else
                  v172 = 1;
                if (v172)
                  break;
                if (strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(v9 + 2128)+ 8 * (**(_BYTE **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v13))
                {
                  break;
                }
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), v173, v11, a5, a6, a7, a8);
                v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            v146 = (__int16)v10;
            v147 = v9;
            v148 = 4;
            goto LABEL_286;
          case 12:
            LOWORD(v10) = 0;
            if (!v137)
              goto LABEL_262;
LABEL_254:
            v174 = *v13;
            if (*v13)
              v175 = v174 == 31;
            else
              v175 = 1;
            if (v175)
              goto LABEL_262;
            v176 = 0;
            v177 = 0;
            while (v174 == *(unsigned __int8 *)(*(_QWORD *)(v9 + 1392) + v176))
            {
              v176 = (__int16)++v177;
              v174 = v13[(__int16)v177];
              if (!v13[(__int16)v177])
              {
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
                v10 = (__int16)(v10 + 1);
                if (v10 < *(__int16 *)(v9 + 1406))
                  goto LABEL_254;
                break;
              }
            }
LABEL_262:
            v146 = (__int16)v10;
            v147 = v9;
            v148 = 5;
            goto LABEL_286;
          case 13:
            LOWORD(v10) = 0;
            if (!v137)
              goto LABEL_273;
            do
            {
              v178 = *v13;
              if (*v13)
                v179 = v178 == 31;
              else
                v179 = 1;
              if (v179)
                break;
              v180 = 0;
              v181 = 0;
              while (v178 == *(unsigned __int8 *)(*(_QWORD *)(v9 + 1392) + v180))
              {
                v180 = (__int16)++v181;
                v178 = v13[(__int16)v181];
                if (!v13[(__int16)v181])
                  goto LABEL_273;
              }
              *(_WORD *)(v9 + 1472) = v8 + 1;
              LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
              v10 = (__int16)(v10 + 1);
            }
            while (v10 < *(__int16 *)(v9 + 1406));
LABEL_273:
            v146 = (__int16)v10;
            v147 = v9;
            v148 = 6;
            goto LABEL_286;
          case 21:
            LOWORD(v10) = 0;
            if (!v137)
              goto LABEL_285;
            break;
          default:
            goto LABEL_287;
        }
        do
        {
          v182 = *v13;
          if (*v13)
            v183 = v182 == 31;
          else
            v183 = 1;
          if (v183)
            break;
          v184 = (_BYTE *)(*(_QWORD *)(v9 + 1512) + 5 * **(unsigned __int8 **)(v9 + 1392));
          if (*v184)
          {
            v185 = 0;
            v186 = 0;
            while (v182 == v184[v185])
            {
              v185 = (__int16)++v186;
              v182 = v13[(__int16)v186];
              if (!v13[(__int16)v186])
                goto LABEL_285;
            }
          }
          *(_WORD *)(v9 + 1472) = v8 + 1;
          LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
          v10 = (__int16)(v10 + 1);
        }
        while (v10 < *(__int16 *)(v9 + 1406));
LABEL_285:
        v146 = (__int16)v10;
        v147 = v9;
        v148 = 8;
LABEL_286:
        result = LOG_WARNING_ON_MAX_NUMBER(v147, v146, v148, v11, a5, a6, a7, a8);
LABEL_287:
        v187 = *(_QWORD *)(v9 + 1456);
        if (*(unsigned __int8 *)(v187 + 1) > (unsigned __int16)v10)
          goto LABEL_431;
        v8 = *(unsigned __int16 *)(v9 + 1472);
        i = (char *)(v187 + 5);
        do
        {
          *(_QWORD *)(v9 + 1456) = i;
          v188 = *i++;
        }
        while (v188 < -64);
LABEL_290:
        *(_WORD *)(v9 + 1470) = 1;
        *(_QWORD *)(v9 + 1456) = i;
        continue;
      case 19:
        v66 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v67 = v8;
            v68 = (__int16)v8;
            v69 = *(_DWORD *)(v66 + 4 * (__int16)v8);
            v8 = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v69 == 126);
          v8 = v67;
        }
        else
        {
          v68 = (__int16)v8;
        }
        v149 = (unsigned int *)(v66 + 4 * v68);
        if (*v300 != v149)
        {
          result = Utf32SymToUtf8Sym(*v149, v13, 5u);
          v150 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v68);
          *(_BYTE *)(v9 + 1405) = *v150 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v150;
          i = *(char **)(v9 + 1456);
        }
        *(_WORD *)(v9 + 1470) = 1;
        *(_QWORD *)(v9 + 1456) = ++i;
        continue;
      case 20:
        *(_WORD *)(v9 + 1476) = 1;
        *(_WORD *)(v9 + 1470) = 1;
        *(_QWORD *)(v9 + 1456) = ++i;
        v8 = v297;
        continue;
      case 21:
        v70 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v71 = v8;
            v72 = (__int16)v8;
            v73 = *(_DWORD *)(v70 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v73 == 126);
          LODWORD(v8) = v71;
        }
        else
        {
          v72 = (__int16)v8;
        }
        v151 = (unsigned int *)(v70 + 4 * v72);
        if (*v300 != v151)
        {
          result = Utf32SymToUtf8Sym(*v151, v13, 5u);
          v152 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v72);
          *(_BYTE *)(v9 + 1405) = *v152 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v152;
        }
        v153 = *v13;
        if (*v13)
          v154 = v153 == 31;
        else
          v154 = 1;
        if (v154)
          goto LABEL_431;
        v155 = *(_QWORD *)(v9 + 1512);
        v156 = *(_QWORD *)(v9 + 1456);
        *(_QWORD *)(v9 + 1456) = v156 + 1;
        v157 = (_BYTE *)(v155 + 5 * *(unsigned __int8 *)(v156 + 1));
        if (!*v157)
          goto LABEL_203;
        v158 = 0;
        v159 = 0;
        while (v153 == v157[v158])
        {
          v158 = (__int16)++v159;
          v153 = v13[(__int16)v159];
          if (!v13[(__int16)v159])
            goto LABEL_431;
        }
LABEL_203:
        *(_WORD *)(v9 + 1470) = 1;
        v8 = (v8 + 1);
        i = (char *)(v156 + 2);
        *(_QWORD *)(v9 + 1456) = v156 + 2;
        continue;
      default:
        v18 = *(_QWORD *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            v19 = v8;
            v20 = (__int16)v8;
            v21 = *(_DWORD *)(v18 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v21 == 126);
          LODWORD(v8) = v19;
        }
        else
        {
          v20 = (__int16)v8;
        }
        v74 = (unsigned int *)(v18 + 4 * v20);
        if (*v300 != v74)
        {
          result = Utf32SymToUtf8Sym(*v74, v13, 5u);
          v75 = (_DWORD *)(*(_QWORD *)(v9 + 1440) + 4 * v20);
          *(_BYTE *)(v9 + 1405) = *v75 & 0x3F;
          *(_QWORD *)(v9 + 2096) = v75;
          i = *(char **)(v9 + 1456);
        }
        v76 = *v13;
        if (!*v13)
          goto LABEL_431;
        v77 = 0;
        v78 = 0;
        do
        {
          if (v76 != i[v77])
            goto LABEL_431;
          v77 = (__int16)++v78;
          v76 = v13[(__int16)v78];
        }
        while (v13[(__int16)v78]);
        *(_WORD *)(v9 + 1470) = 1;
        result = strlen((const char *)v13);
        i += result;
        *(_QWORD *)(v9 + 1456) = i;
        v8 = (v8 + 1);
        continue;
    }
  }
}

uint64_t INFERENCE_MAIN(uint64_t a1, uint64_t a2, int a3, __int16 *a4)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v21;
  int v22;

  if (*(__int16 *)(a1 + 24) >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = *a4;
    v22 = 0;
    v11 = v10 + 1;
    while (1)
    {
      v12 = (unsigned __int16)Utf8_LengthInBytes(*(unsigned __int8 **)(*(_QWORD *)(a1 + 1496) + 8 * v8), v11);
      v13 = utf8_CheckValid(*(_QWORD *)(*(_QWORD *)(a1 + 1496) + 8 * v8), v12);
      v14 = utf8_Utf8ToUtf32_Tolerant(*(_QWORD *)(*(_QWORD *)(a1 + 1496) + 8 * v8), v12, *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v8), **(unsigned __int16 **)(a1 + 184), &v22);
      if ((v14 & 0x80000000) != 0)
        return v14;
      if (!v13)
        v9 = 1;
      if (++v8 >= *(__int16 *)(a1 + 24))
      {
        if (v9)
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 1, 0, (uint64_t)"Invalid utf8 layer string found", v15, v16, v17, v21);
        break;
      }
    }
  }
  v18 = 2305826816;
  INFERENCE(a1, a2, a3, a4);
  v19 = *(unsigned __int8 *)(a1 + 1428);
  if (v19 == 155)
    return 2305826826;
  if (v19 != 156)
    return Utf32LayersToUtf8Layers(a1, *a4);
  return v18;
}

uint64_t Utf32LayersToUtf8Layers(uint64_t a1, __int16 a2)
{
  uint64_t v3;
  int v4;
  uint64_t result;
  int v6;

  if (*(__int16 *)(a1 + 24) < 1)
    return 0;
  v3 = 0;
  v6 = 0;
  v4 = (unsigned __int16)(a2 + 1);
  do
  {
    result = utf8_Utf32ToUtf8(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v3), v4, *(_QWORD *)(*(_QWORD *)(a1 + 1496) + 8 * v3), **(unsigned __int16 **)(a1 + 184), &v6);
    if ((result & 0x80000000) != 0)
      break;
    ++v3;
  }
  while (*(__int16 *)(a1 + 24) > (__int16)v3);
  return result;
}

uint64_t CTXT(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  int v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  _BYTE *v19;
  int v20;
  BOOL v21;
  BOOL v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  _BYTE *v26;
  BOOL v27;

  v9 = *(_QWORD *)(a1 + 1456);
  *(_QWORD *)(a1 + 1456) = v9 + 1;
  *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
  *(_WORD *)(a1 + 1464) = 0;
  result = 1;
  *(_DWORD *)(a1 + 1352) = 1;
  if (*(_BYTE *)(v9 + 1))
  {
    do
    {
      v11 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
      if (**(_BYTE **)(a1 + 1456))
        v12 = v11 == 0;
      else
        v12 = 1;
    }
    while (!v12);
    if (v11)
      return 1;
    while (1)
    {
      if (*(__int16 *)(a1 + 1464) < 1)
        return 0;
      v13 = *(unsigned __int16 *)(a1 + 1464);
      *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 8 * v13 + 248);
      *(_WORD *)(a1 + 1466) = *(_WORD *)(a1 + 2 * v13 + 648);
      ++*(_BYTE *)(a1 + v13 + 192);
      v14 = *(__int16 *)(a1 + 1464);
      v15 = *(_WORD *)(a1 + 1464);
      v16 = a1 + 2 * v14;
      *(_WORD *)(a1 + 1470) = *(_WORD *)(v16 + 748);
      *(_QWORD *)(a1 + 1440) = *(_QWORD *)(a1 + 8 * v14 + 952);
      v17 = *(__int16 *)(v16 + 848);
      if (v17 == 10)
      {
        *(_WORD *)(a1 + 1464) = v15 - 1;
        if (!**(_BYTE **)(a1 + 1456))
          return 1;
        do
        {
          v20 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
          if (**(_BYTE **)(a1 + 1456))
            v22 = v20 == 0;
          else
            v22 = 1;
        }
        while (!v22);
        goto LABEL_42;
      }
      if (v17 == 9)
        break;
      if (v17 == 8)
      {
        v18 = *(unsigned __int8 *)(a1 + v14 + 192);
        v19 = *(_BYTE **)(a1 + 1456);
        if (v18 <= v19[2])
        {
          *(_DWORD *)(a1 + 1352) = 0;
          if (!*v19)
            return 1;
          do
          {
            v20 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
            if (**(_BYTE **)(a1 + 1456))
              v21 = v20 == 0;
            else
              v21 = 1;
          }
          while (!v21);
          goto LABEL_42;
        }
LABEL_45:
        *(_WORD *)(a1 + 1464) = v15 - 1;
      }
      else
      {
        v20 = 0;
LABEL_42:
        if (v20)
          return 1;
      }
    }
    v23 = *(_BYTE **)(a1 + 1456);
    if (*v23 == 9
      && v23[1] != 1
      && (*(v23 - 2) != 9 || *(unsigned __int8 *)(a1 + v14 + 192) - 1 != *(v23 - 1)))
    {
      *(_QWORD *)(a1 + 1456) = v23 + 2;
    }
    v24 = SKIP_DATA(a1, 9, *(unsigned __int8 *)(a1 + v14 + 192));
    v25 = *(_QWORD *)(a1 + 1456);
    if (v24)
    {
      *(_QWORD *)(a1 + 8 * *(__int16 *)(a1 + 1464) + 248) = v25;
      v26 = (_BYTE *)(*(_QWORD *)(a1 + 1456) + 2);
      *(_QWORD *)(a1 + 1456) = v26;
      if (!*v26)
        return 1;
      do
      {
        v20 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
        if (**(_BYTE **)(a1 + 1456))
          v27 = v20 == 0;
        else
          v27 = 1;
      }
      while (!v27);
      goto LABEL_42;
    }
    *(_QWORD *)(a1 + 1456) = v25 + 2;
    v15 = *(_WORD *)(a1 + 1464);
    goto LABEL_45;
  }
  return result;
}

uint64_t VAR_APPEARENCE(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 104);
  v3 = a2 - 1;
  v4 = *(unsigned __int8 *)(v2 + 2 * v3);
  if (v4 == 5)
  {
    v5 = *(_QWORD *)(a1 + 2128);
LABEL_5:
    result = (uint64_t)strstr(*(char **)(*(_QWORD *)(v5 + 8 * *(unsigned __int8 *)(v2 + 2 * v3 + 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400));
    if (!result)
      return result;
    return 1;
  }
  if (v4 == 4)
  {
    v5 = *(_QWORD *)(a1 + 2120);
    goto LABEL_5;
  }
  return 1;
}

uint64_t SETUTF8CHAR(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = result;
  if ((char)*a2 < -64 || (result = utf8_determineUTF8CharLength(*a2), (int)((_DWORD)result << 16) < 1))
  {
    v4 = 0;
  }
  else
  {
    LOWORD(v4) = 0;
    do
    {
      *(_BYTE *)(v2 + (__int16)v4) = a2[(__int16)v4];
      LOWORD(v4) = v4 + 1;
    }
    while ((__int16)result > (__int16)v4);
    v4 = (__int16)v4;
  }
  *(_BYTE *)(v2 + v4) = 0;
  return result;
}

uint64_t CHECK_OF_LIST(uint64_t a1, unsigned __int16 a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char *v10;
  int v11;
  uint64_t result;
  int v13;
  _BYTE *v14;
  uint64_t v15;
  const char *v16;
  _BYTE *v17;
  uint64_t v18;
  unsigned int *v19;
  _DWORD *v20;
  signed int v21;
  int v22;
  uint64_t v23;
  _BYTE *v24;
  int v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  BOOL v32;
  BOOL v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  unsigned __int8 *v40;
  int v41;
  BOOL v42;
  uint64_t v43;
  int v44;
  int v45;
  BOOL v46;
  uint64_t v47;
  int v48;
  signed int v49;
  int v50;
  _BYTE *v51;
  int v52;
  uint64_t v53;
  int v54;
  char *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;

  *(_QWORD *)(a1 + 1360) = 0;
  v10 = *(char **)(a1 + 1456);
  v11 = *v10;
  result = 1;
  if (v11 != a2)
  {
    v13 = a2;
    v14 = (_BYTE *)(a1 + 1400);
    v15 = a3;
    v16 = "FE_DEPES";
LABEL_3:
    v17 = v10 + 1;
    *(_QWORD *)(a1 + 1456) = v10 + 1;
    switch((char)v11)
    {
      case 2:
        v21 = *v17;
        v22 = *(__int16 *)(a1 + 46);
        if (v21 > v22)
        {
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)v16, 3, 0, (uint64_t)"warning: pActRule > nr_vars (1)", a6, a7, a8, v58);
          v17 = *(_BYTE **)(a1 + 1456);
          v21 = *v17;
          v22 = *(__int16 *)(a1 + 46);
        }
        if (v21 > v22)
          return 0;
        v23 = *(_QWORD *)(a1 + 1512);
        v24 = (_BYTE *)(v23 + 5 * v21);
        if (*v24)
        {
          v25 = *v14;
          if (!*v14)
            goto LABEL_87;
          v26 = 0;
          v27 = 0;
          do
          {
            if (v25 != v24[v26])
              goto LABEL_87;
            v26 = (__int16)++v27;
            v25 = v14[(__int16)v27];
          }
          while (v14[(__int16)v27]);
        }
        else
        {
          if (!VAR_APPEARENCE(a1, v21))
            goto LABEL_87;
          *(_DWORD *)(a1 + 1480) = 1;
          SETUTF8CHAR(v23 + 5 * *v17, (unsigned __int8 *)(a1 + 1400));
        }
        goto LABEL_83;
      case 3:
        if (*v14)
          v28 = *v14 == 31;
        else
          v28 = 1;
        if (v28)
          goto LABEL_87;
        v29 = *(_QWORD *)(a1 + 2120);
        goto LABEL_36;
      case 4:
        if (*v14)
          v30 = *v14 == 31;
        else
          v30 = 1;
        if (v30)
          goto LABEL_87;
        v31 = *(_QWORD *)(a1 + 2120);
        goto LABEL_43;
      case 5:
        if (*v14)
          v32 = *v14 == 31;
        else
          v32 = 1;
        if (v32)
          goto LABEL_87;
        v29 = *(_QWORD *)(a1 + 2128);
LABEL_36:
        if (!strstr(*(char **)(*(_QWORD *)(v29 + 8 * (*v17 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))goto LABEL_87;
        goto LABEL_83;
      case 6:
        if (*v14)
          v33 = *v14 == 31;
        else
          v33 = 1;
        if (v33)
          goto LABEL_87;
        v31 = *(_QWORD *)(a1 + 2128);
LABEL_43:
        if (strstr(*(char **)(*(_QWORD *)(v31 + 8 * (*v17 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
        {
          goto LABEL_87;
        }
        goto LABEL_83;
      case 7:
        v59 = v13;
        v34 = v8;
        v35 = v16;
        v36 = *v17;
        v37 = v36 - 1;
        if (!strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(a1 + 2128) + 8 * (v36 - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))goto LABEL_87;
        v38 = *(_QWORD *)(a1 + 88);
        v39 = strstr((char *)(v38 + (v37 << 8)), (const char *)(a1 + 1400));
        if (!v39 || !*v14 || *v14 == 31)
          goto LABEL_87;
        if ((v37 & 1) != 0)
          v40 = (unsigned __int8 *)(v38
                                  + (v36 << 8)
                                  + v39[256 * v37 + *(_QWORD *)(a1 + 96) - v38 + -256 * v37]
                                  - 512);
        else
          v40 = (unsigned __int8 *)(v38
                                  + (v36 << 8)
                                  + v39[256 * (unint64_t)v37
                                                       + *(_QWORD *)(a1 + 96)
                                                       - v38
                                                       + -256 * (unint64_t)v37]);
        SETUTF8CHAR(a1 + 1484, v40);
        v16 = v35;
        v8 = v34;
        v13 = v59;
        goto LABEL_83;
      case 12:
        v41 = *v14;
        if (*v14)
          v42 = v41 == 31;
        else
          v42 = 1;
        if (v42)
          goto LABEL_87;
        v43 = 0;
        v44 = 0;
        do
        {
          if (v41 != v17[v43])
            goto LABEL_87;
          v43 = (__int16)++v44;
          v41 = v14[(__int16)v44];
        }
        while (v14[(__int16)v44]);
        v10 = &v17[strlen((const char *)(a1 + 1400))];
        goto LABEL_84;
      case 13:
        v45 = *v14;
        if (*v14)
          v46 = v45 == 31;
        else
          v46 = 1;
        if (v46)
          goto LABEL_87;
        v47 = 0;
        v48 = 0;
        while (v45 == v17[v47])
        {
          v47 = (__int16)++v48;
          v45 = v14[(__int16)v48];
          if (!v14[(__int16)v48])
            goto LABEL_87;
        }
        v55 = v10 + 2;
        do
        {
          *(_QWORD *)(a1 + 1456) = v55;
          v56 = *v55++;
        }
        while (v56 <= -65);
        v10 = v55 - 1;
        goto LABEL_85;
      case 14:
      case 16:
        *(_QWORD *)(a1 + 1360) = *(_QWORD *)(a1 + 1440);
        v18 = *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * *v17 - 8);
        *(_QWORD *)(a1 + 1440) = v18;
        goto LABEL_7;
      case 15:
      case 17:
        v18 = *(_QWORD *)(a1 + 1360);
        if (!v18)
          return 0;
        *(_QWORD *)(a1 + 1440) = v18;
        *(_QWORD *)(a1 + 1360) = 0;
LABEL_7:
        v19 = (unsigned int *)(v18 + 4 * v15);
        if (*(unsigned int **)(a1 + 2096) != v19)
        {
          Utf32SymToUtf8Sym(*v19, (_BYTE *)(a1 + 1400), 5u);
          v20 = (_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * v15);
          *(_BYTE *)(a1 + 1405) = *v20 & 0x3F;
          *(_QWORD *)(a1 + 2096) = v20;
        }
        result = 0;
        if (!*v14 || *v14 == 31)
          return result;
        goto LABEL_83;
      case 21:
        v49 = *v17;
        v50 = *(__int16 *)(a1 + 46);
        if (v49 > v50)
        {
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)v16, 3, 0, (uint64_t)"warning: pActRule > nr_vars (2)", a6, a7, a8, v58);
          v49 = **(unsigned __int8 **)(a1 + 1456);
          v50 = *(__int16 *)(a1 + 46);
        }
        if (v49 > v50)
          return 0;
        v51 = (_BYTE *)(*(_QWORD *)(a1 + 1512) + 5 * v49);
        if (!*v51)
          goto LABEL_83;
        v52 = *v14;
        if (!*v14)
          goto LABEL_83;
        v53 = 0;
        v54 = 0;
        break;
      default:
        goto LABEL_83;
    }
    do
    {
      if (v52 != v51[v53])
      {
LABEL_83:
        v10 = (char *)(*(_QWORD *)(a1 + 1456) + 1);
LABEL_84:
        *(_QWORD *)(a1 + 1456) = v10;
LABEL_85:
        v11 = *v10;
        if (v11 == v13)
          return 1;
        goto LABEL_3;
      }
      v53 = (__int16)++v54;
      v52 = v14[(__int16)v54];
    }
    while (v14[(__int16)v54]);
LABEL_87:
    v57 = *(_QWORD *)(a1 + 1360);
    if (v57)
    {
      result = 0;
      *(_QWORD *)(a1 + 1440) = v57;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t TOKEN1(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _DWORD *v13;
  uint64_t v15;

  v8 = a2;
  if (a2 < 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: nr < 0 (2)", a6, a7, a8, v15);
  v10 = *(_QWORD *)(a1 + 1440);
  do
  {
    v11 = (__int16)v8;
    v12 = *(_DWORD *)(v10 + 4 * (__int16)v8++);
  }
  while (v12 == 126);
  if (*(_QWORD *)(a1 + 2096) != v10 + 4 * v11)
  {
    Utf32SymToUtf8Sym(v12, (_BYTE *)(a1 + 1400), 5u);
    v13 = (_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * v11);
    *(_BYTE *)(a1 + 1405) = *v13 & 0x3F;
    *(_QWORD *)(a1 + 2096) = v13;
  }
  return v11;
}

uint64_t LOG_WARNING_ON_MAX_NUMBER(uint64_t result, int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 5000 && *(__int16 *)(result + 2088) >= 3)
    return log_OutText(*(_QWORD *)(*(_QWORD *)(result + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: number of iterations >= MAX_NUMBER_UPPER_BOUND, output might be incorrect (%u)", a6, a7, a8, a3);
  return result;
}

uint64_t CONTEXT_CHOICE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  int v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  char v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  char v33;
  __int16 v34;
  const char *v35;
  uint64_t v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  int v45;
  __int16 v46;
  __int16 v47;
  const char *v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  __int16 v63;
  BOOL v64;
  uint64_t v66;
  int v67;
  __int16 v68;
  uint64_t v69;
  __int16 v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  __int16 v84;
  __int16 v85;
  int v86;
  int v87;
  __int16 v88;
  uint64_t v89;
  __int16 v90;
  int v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  int v95;
  _BOOL4 v96;
  int v97;
  __int16 v98;
  uint64_t v99;
  __int16 v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  int v104;
  _BOOL4 v105;
  int v106;
  __int16 v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  int v115;
  __int16 v116;
  _BYTE *v117;
  uint64_t v118;
  unsigned __int8 *v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  int v123;
  __int16 v124;
  int v125;
  uint64_t v126;
  unsigned int v127;
  int v128;
  int v129;
  __int16 v130;
  uint64_t v131;
  uint64_t v132;
  __int16 v133;
  int v134;
  _BYTE *v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  int v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  __int16 v146;
  __int16 v147;
  uint64_t v148;
  _BYTE *v149;
  unsigned __int8 *v150;
  int v151;
  char *v152;
  int v153;
  unsigned int v154;
  char *v155;
  int v156;
  uint64_t i;
  unsigned int v158;
  BOOL v159;
  int v160;
  unsigned int v162;
  int v163;
  _BYTE *v165;
  BOOL v166;
  __int16 v167;
  _BYTE *v168;
  BOOL v169;
  __int16 v170;
  _BYTE *v171;
  BOOL v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  __int16 v178;
  _BYTE *v179;
  BOOL v180;
  __int16 v181;
  _BYTE *v182;
  int v183;
  BOOL v184;
  uint64_t v185;
  int v186;
  __int16 v187;
  _BYTE *v188;
  int v189;
  BOOL v190;
  uint64_t v191;
  int v192;
  __int16 v193;
  _BYTE *v194;
  int v195;
  BOOL v196;
  _BYTE *v197;
  uint64_t v198;
  int v199;
  __int16 v200;
  uint64_t v201;
  char *v202;
  int v203;

  v9 = *(_BYTE **)(a1 + 1456);
  switch(*v9)
  {
    case 2:
      v12 = *(__int16 *)(a1 + 1466);
      if (v12 < 0)
        return 0;
      v13 = TOKEN(a1, v12, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v14 = 0;
      *(_WORD *)(a1 + 1466) = v13;
      v15 = *(_QWORD *)(a1 + 1456);
      *(_QWORD *)(a1 + 1456) = v15 + 1;
      v16 = *(unsigned __int8 *)(v15 + 1);
      v17 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v17;
      *(_QWORD *)(a1 + 1456) = v15 + 2;
      *(_WORD *)(a1 + 1466) = v17 + v13;
      v18 = *(unsigned __int8 *)(a1 + 1400);
      if (!*(_BYTE *)(a1 + 1400) || v18 == 31)
        return v14;
      v19 = a1 + 1400;
      v20 = (_BYTE *)(*(_QWORD *)(a1 + 1512) + 5 * v16);
      if (*v20)
      {
        v21 = 0;
        v22 = 0;
        v14 = 1;
        do
        {
          if (v18 != v20[v21])
            return 0;
          v21 = (__int16)++v22;
          v18 = *(unsigned __int8 *)(v19 + (__int16)v22);
        }
        while (*(_BYTE *)(v19 + (__int16)v22));
      }
      else
      {
        if (!VAR_APPEARENCE(a1, v16))
          return 0;
        v14 = 1;
        *(_DWORD *)(a1 + 1480) = 1;
        SETUTF8CHAR((uint64_t)v20, (unsigned __int8 *)(a1 + 1400));
      }
      return v14;
    case 3:
      v23 = *(__int16 *)(a1 + 1466);
      if (v23 < 0)
        return 0;
      v24 = TOKEN(a1, v23, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v14 = 0;
      *(_WORD *)(a1 + 1466) = v24;
      v25 = *(_QWORD *)(a1 + 1456);
      *(_QWORD *)(a1 + 1456) = v25 + 1;
      v26 = *(_BYTE *)(v25 + 1);
      v27 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v27;
      *(_QWORD *)(a1 + 1456) = v25 + 2;
      *(_WORD *)(a1 + 1466) = v27 + v24;
      if (!*(_BYTE *)(a1 + 1400) || *(_BYTE *)(a1 + 1400) == 31)
        return v14;
      v28 = (const char *)(a1 + 1400);
      v29 = *(_QWORD *)(a1 + 2120);
      return strstr(*(char **)(*(_QWORD *)(v29 + 8 * (v26 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v28) != 0;
    case 4:
      v30 = *(__int16 *)(a1 + 1466);
      if (v30 < 0)
        return 0;
      v31 = TOKEN(a1, v30, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v14 = 0;
      *(_WORD *)(a1 + 1466) = v31;
      v32 = *(_QWORD *)(a1 + 1456);
      *(_QWORD *)(a1 + 1456) = v32 + 1;
      v33 = *(_BYTE *)(v32 + 1);
      v34 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v34;
      *(_QWORD *)(a1 + 1456) = v32 + 2;
      *(_WORD *)(a1 + 1466) = v34 + v31;
      if (!*(_BYTE *)(a1 + 1400) || *(_BYTE *)(a1 + 1400) == 31)
        return v14;
      v35 = (const char *)(a1 + 1400);
      v36 = *(_QWORD *)(a1 + 2120);
      return strstr(*(char **)(*(_QWORD *)(v36 + 8 * (v33 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v35) == 0;
    case 5:
      v37 = *(__int16 *)(a1 + 1466);
      if (v37 < 0)
        return 0;
      v38 = TOKEN(a1, v37, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v14 = 0;
      *(_WORD *)(a1 + 1466) = v38;
      v39 = *(_QWORD *)(a1 + 1456);
      *(_QWORD *)(a1 + 1456) = v39 + 1;
      v26 = *(_BYTE *)(v39 + 1);
      v40 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v40;
      *(_QWORD *)(a1 + 1456) = v39 + 2;
      *(_WORD *)(a1 + 1466) = v40 + v38;
      if (!*(_BYTE *)(a1 + 1400) || *(_BYTE *)(a1 + 1400) == 31)
        return v14;
      v28 = (const char *)(a1 + 1400);
      v29 = *(_QWORD *)(a1 + 2128);
      return strstr(*(char **)(*(_QWORD *)(v29 + 8 * (v26 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v28) != 0;
    case 6:
      v41 = *(__int16 *)(a1 + 1466);
      if (v41 < 0)
        return 0;
      v42 = TOKEN(a1, v41, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v14 = 0;
      *(_WORD *)(a1 + 1466) = v42;
      v43 = *(_QWORD *)(a1 + 1456);
      *(_QWORD *)(a1 + 1456) = v43 + 1;
      v33 = *(_BYTE *)(v43 + 1);
      v44 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v44;
      *(_QWORD *)(a1 + 1456) = v43 + 2;
      *(_WORD *)(a1 + 1466) = v44 + v42;
      if (!*(_BYTE *)(a1 + 1400) || *(_BYTE *)(a1 + 1400) == 31)
        return v14;
      v35 = (const char *)(a1 + 1400);
      v36 = *(_QWORD *)(a1 + 2128);
      return strstr(*(char **)(*(_QWORD *)(v36 + 8 * (v33 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v35) == 0;
    case 8:
      *(_QWORD *)(a1 + 1456) = v9 + 3;
      if (*(_DWORD *)(a1 + 1352))
      {
        v53 = *(_WORD *)(a1 + 1464) + 1;
        *(_WORD *)(a1 + 1464) = v53;
        *(_WORD *)(a1 + 2 * v53 + 848) = 8;
        v54 = *(__int16 *)(a1 + 1464);
        *(_QWORD *)(a1 + 8 * v54 + 952) = *(_QWORD *)(a1 + 1440);
        *(_QWORD *)(a1 + 248 + 8 * v54) = *(_QWORD *)(a1 + 1456) - 3;
        *(_BYTE *)(a1 + 192 + v54) = 0;
        v55 = *(__int16 *)(a1 + 1464);
        if (*(unsigned __int8 *)(a1 + 192 + v55) >= *(unsigned __int8 *)(*(_QWORD *)(a1 + 248 + 8 * v55)
                                                                                      + 1))
        {
          v63 = *(_WORD *)(a1 + 1470);
          v14 = 1;
          v64 = 1;
        }
        else
        {
          v56 = *(_WORD *)(a1 + 1466);
          do
          {
            if (v56 < 0)
              return 0;
            *(_WORD *)(a1 + 1466) = TOKEN(a1, v56, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
            ++*(_BYTE *)(a1 + 192 + *(__int16 *)(a1 + 1464));
            *(_QWORD *)(a1 + 1456) = *(_QWORD *)(a1 + 248 + 8 * *(__int16 *)(a1 + 1464)) + 3;
            v62 = CHECK_OF_LIST(a1, 8u, *(__int16 *)(a1 + 1466), v57, v58, v59, v60, v61);
            v63 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1470) = v63;
            v56 = *(_WORD *)(a1 + 1466) + v63;
            *(_WORD *)(a1 + 1466) = v56;
            v55 = *(__int16 *)(a1 + 1464);
            v64 = (_DWORD)v62 != 0;
          }
          while (*(unsigned __int8 *)(a1 + 192 + v55) < *(unsigned __int8 *)(*(_QWORD *)(a1 + 248 + 8 * v55)
                                                                                          + 1)
               && (_DWORD)v62 != 0);
          v14 = v62;
        }
        *(_WORD *)(a1 + 2 * v55 + 748) = v63;
        v148 = *(__int16 *)(a1 + 1464);
        if (!*(_BYTE *)(a1 + v148 + 192))
        {
          v149 = *(_BYTE **)(a1 + 1456);
          if (*v149 != 8)
          {
            v150 = v149 + 1;
            do
            {
              *(_QWORD *)(a1 + 1456) = v150;
              v151 = *v150++;
            }
            while (v151 != 8);
          }
        }
        *(_WORD *)(a1 + 2 * v148 + 648) = *(_WORD *)(a1 + 1466);
        if (!v64)
LABEL_117:
          --*(_WORD *)(a1 + 1464);
      }
      else
      {
        v139 = *(__int16 *)(a1 + 1466);
        if (v139 < 0)
          return 0;
        v140 = TOKEN(a1, v139, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
        *(_WORD *)(a1 + 1466) = v140;
        *(_DWORD *)(a1 + 1352) = 1;
        v14 = CHECK_OF_LIST(a1, 8u, v140, v141, v142, v143, v144, v145);
        *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 748) = *(_WORD *)(a1 + 1468);
        v146 = *(_WORD *)(a1 + 1468);
        *(_WORD *)(a1 + 1470) = v146;
        v147 = *(_WORD *)(a1 + 1466) + v146;
        *(_WORD *)(a1 + 1466) = v147;
        *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 648) = v147;
        if (!(_DWORD)v14)
          goto LABEL_117;
      }
      ++*(_QWORD *)(a1 + 1456);
      return v14;
    case 9:
      v66 = (uint64_t)(v9 + 1);
      *(_QWORD *)(a1 + 1456) = v9 + 1;
      v67 = v9[1];
      if (v67)
      {
        if (v67 == 1)
        {
          v68 = *(_WORD *)(a1 + 1464) + 1;
          *(_WORD *)(a1 + 1464) = v68;
          *(_WORD *)(a1 + 2 * v68 + 748) = *(_WORD *)(a1 + 1470);
          v69 = *(__int16 *)(a1 + 1464);
          *(_QWORD *)(a1 + 8 * v69 + 952) = *(_QWORD *)(a1 + 1440);
          *(_WORD *)(a1 + 2 * v69 + 848) = 9;
          *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 648) = *(_WORD *)(a1 + 1466);
          *(_BYTE *)(a1 + *(__int16 *)(a1 + 1464) + 192) = **(_BYTE **)(a1 + 1456);
          *(_QWORD *)(a1 + 8 * *(__int16 *)(a1 + 1464) + 248) = *(_QWORD *)(a1 + 1456) + 1;
          v66 = *(_QWORD *)(a1 + 1456);
        }
        else
        {
          SKIP_DATA(a1, 9, 0);
          v66 = *(_QWORD *)(a1 + 1456) + 1;
        }
      }
      goto LABEL_237;
    case 0xA:
      *(_QWORD *)(a1 + 1456) = v9 + 1;
      if (v9[1])
      {
        v70 = *(_WORD *)(a1 + 1464) + 1;
        *(_WORD *)(a1 + 1464) = v70;
        *(_WORD *)(a1 + 2 * v70 + 748) = *(_WORD *)(a1 + 1470);
        v71 = *(__int16 *)(a1 + 1464);
        *(_QWORD *)(a1 + 8 * v71 + 952) = *(_QWORD *)(a1 + 1440);
        *(_WORD *)(a1 + 2 * v71 + 848) = 10;
        *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 648) = *(_WORD *)(a1 + 1466);
        v72 = *(__int16 *)(a1 + 1464);
        *(_QWORD *)(a1 + 8 * v72 + 248) = *(_QWORD *)(a1 + 1456) + 1;
        *(_BYTE *)(a1 + v72 + 192) = 0;
        SKIP_DATA(a1, 10, 0);
        v9 = *(_BYTE **)(a1 + 1456);
      }
      goto LABEL_5;
    case 0xB:
      v73 = *(__int16 *)(a1 + 1466);
      *(_WORD *)(a1 + 1472) = *(_WORD *)(a1 + 1466);
      if (v73 < 0)
        return 0;
      v74 = TOKEN(a1, v73, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      *(_WORD *)(a1 + 1466) = v74;
      v80 = *(_QWORD *)(a1 + 1456);
      v81 = *(unsigned __int8 *)(v80 + 2);
      if (v81 == 220)
        v81 = 5000;
      *(_WORD *)(a1 + 1406) = v81;
      if (v81
        && (*(_QWORD *)(a1 + 1456) = v80 + 3, CHECK_OF_LIST(a1, 0xBu, v74, v75, v76, v77, v78, v79)))
      {
        LOWORD(v82) = 0;
        do
        {
          v83 = *(_QWORD *)(a1 + 1456);
          v84 = *(_WORD *)(a1 + 1468);
          v85 = v84 + *(_WORD *)(a1 + 1466);
          *(_WORD *)(a1 + 1466) = v85;
          *(_WORD *)(a1 + 1472) = v85;
          if (v85 < 0)
            return 0;
          v86 = TOKEN(a1, v85, v84, v75, v76, v77, v78, v79);
          *(_WORD *)(a1 + 1466) = v86;
          v82 = (__int16)(v82 + 1);
          if (v82 >= *(__int16 *)(a1 + 1406))
            break;
          *(_QWORD *)(a1 + 1456) = v80 + 3;
        }
        while (CHECK_OF_LIST(a1, 0xBu, v86, v75, v76, v77, v78, v79));
      }
      else
      {
        v82 = 0;
        v83 = 0;
      }
      LOG_WARNING_ON_MAX_NUMBER(a1, v82, 9u, v75, v76, v77, v78, v79);
      *(_WORD *)(a1 + 1466) = *(_WORD *)(a1 + 1472);
      if (v83)
        *(_QWORD *)(a1 + 1456) = v83;
      else
        v83 = *(_QWORD *)(a1 + 1456);
      for (i = v83 + 1; ; ++i)
      {
        if (*(_BYTE *)(i - 1) == 11)
        {
          v158 = *(unsigned __int8 *)(i - 2);
          v159 = v158 > 0x15;
          v160 = (1 << v158) & 0x20067C;
          if (v159 || v160 == 0)
            break;
          v162 = *(unsigned __int8 *)(i - 3);
          v159 = v162 > 0x15;
          v163 = (1 << v162) & 0x20C67C;
          if (!v159 && v163 != 0)
            break;
        }
        *(_QWORD *)(a1 + 1456) = i;
      }
      *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
      *(_QWORD *)(a1 + 1456) = i;
      return v82 >= *(unsigned __int8 *)(v80 + 1);
    case 0xC:
      v87 = *(__int16 *)(a1 + 1466);
      if (v87 < 0)
        return 0;
      v88 = TOKEN(a1, v87, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v89 = *(_QWORD *)(a1 + 1456);
      v90 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v90;
      *(_WORD *)(a1 + 1466) = v90 + v88;
      *(_QWORD *)(a1 + 1456) = v89 + 2;
      v91 = *(unsigned __int8 *)(a1 + 1400);
      if (*(_BYTE *)(a1 + 1400))
      {
        v92 = 0;
        v93 = 0;
        v94 = a1 + 1400;
        v95 = *(unsigned __int8 *)(a1 + 1400);
        do
        {
          v96 = v95 == *(unsigned __int8 *)(v89 + 1 + v92);
          if (v95 != *(unsigned __int8 *)(v89 + 1 + v92))
            break;
          v92 = (__int16)++v93;
          v95 = *(unsigned __int8 *)(v94 + (__int16)v93);
        }
        while (*(_BYTE *)(v94 + (__int16)v93));
      }
      else
      {
        v96 = 0;
      }
      if (*(char *)(v89 + 2) <= -65)
      {
        v152 = (char *)(v89 + 3);
        do
        {
          *(_QWORD *)(a1 + 1456) = v152;
          v153 = *v152++;
        }
        while (v153 < -64);
      }
      if (v91)
        v154 = v96;
      else
        v154 = 0;
      goto LABEL_132;
    case 0xD:
      v97 = *(__int16 *)(a1 + 1466);
      if (v97 < 0)
        return 0;
      v98 = TOKEN(a1, v97, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v99 = *(_QWORD *)(a1 + 1456);
      v100 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v100;
      *(_WORD *)(a1 + 1466) = v100 + v98;
      *(_QWORD *)(a1 + 1456) = v99 + 2;
      v91 = *(unsigned __int8 *)(a1 + 1400);
      if (*(_BYTE *)(a1 + 1400))
      {
        v101 = 0;
        v102 = 0;
        v103 = a1 + 1400;
        v104 = *(unsigned __int8 *)(a1 + 1400);
        do
        {
          v105 = v104 == *(unsigned __int8 *)(v99 + 1 + v101);
          if (v104 != *(unsigned __int8 *)(v99 + 1 + v101))
            break;
          v101 = (__int16)++v102;
          v104 = *(unsigned __int8 *)(v103 + (__int16)v102);
        }
        while (*(_BYTE *)(v103 + (__int16)v102));
      }
      else
      {
        v105 = 0;
      }
      if (*(char *)(v99 + 2) <= -65)
      {
        v155 = (char *)(v99 + 3);
        do
        {
          *(_QWORD *)(a1 + 1456) = v155;
          v156 = *v155++;
        }
        while (v156 < -64);
      }
      v154 = !v105;
      if (!v91)
        v154 = 0;
LABEL_132:
      if (v91 == 31)
        return 0;
      else
        return v154;
    case 0xE:
    case 0x10:
      *(_QWORD *)(a1 + 1456) = v9 + 1;
      *(_QWORD *)(a1 + 1376) = *(_QWORD *)(a1 + 1440);
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v9[1] - 8);
      goto LABEL_4;
    case 0xF:
    case 0x11:
      v10 = *(_QWORD *)(a1 + 1376);
LABEL_4:
      *(_QWORD *)(a1 + 1440) = v10;
      *(_WORD *)(a1 + 1470) = 0;
LABEL_5:
      v11 = (uint64_t)(v9 + 2);
      goto LABEL_238;
    case 0x12:
      v106 = *(__int16 *)(a1 + 1466);
      *(_WORD *)(a1 + 1472) = *(_WORD *)(a1 + 1466);
      if (v106 < 0)
        return 0;
      v107 = TOKEN(a1, v106, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      LOWORD(v113) = 0;
      *(_WORD *)(a1 + 1466) = v107;
      v114 = *(_QWORD *)(a1 + 1456);
      v115 = *(unsigned __int8 *)(v114 + 2);
      if (v115 == 220)
        v115 = 5000;
      *(_WORD *)(a1 + 1406) = v115;
      *(_QWORD *)(a1 + 1392) = v114 + 4;
      v116 = v107;
      switch(*(_BYTE *)(v114 + 3))
      {
        case 2:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_91;
          v117 = (_BYTE *)(a1 + 1400);
          while (1)
          {
            v118 = *(_QWORD *)(a1 + 1512);
            v119 = *(unsigned __int8 **)(a1 + 1392);
            v120 = 5 * *v119;
            if (*(_BYTE *)(v118 + v120))
              break;
            if (VAR_APPEARENCE(a1, v120))
            {
              *(_DWORD *)(a1 + 1480) = 1;
              SETUTF8CHAR(v118 + 5 * *v119, (unsigned __int8 *)(a1 + 1400));
              v116 = *(_WORD *)(a1 + 1466);
LABEL_89:
              v124 = *(_WORD *)(a1 + 1468);
              *(_WORD *)(a1 + 1466) = v124 + v116;
              *(_WORD *)(a1 + 1472) = v124 + v116;
              if (((v124 + v116) & 0x8000) != 0)
                return 0;
              v116 = TOKEN(a1, (__int16)(v124 + v116), v124, v108, v109, v110, v111, v112);
              *(_WORD *)(a1 + 1466) = v116;
              v113 = (__int16)(v113 + 1);
              if (v113 < *(__int16 *)(a1 + 1406))
                continue;
            }
            goto LABEL_91;
          }
          v121 = *v117;
          if (*v117)
          {
            v122 = 0;
            v123 = 0;
            while (v121 == *(unsigned __int8 *)(v118 + v120 + v122))
            {
              v122 = (__int16)++v123;
              v121 = v117[(__int16)v123];
              if (!v117[(__int16)v123])
                goto LABEL_89;
            }
          }
LABEL_91:
          v125 = (__int16)v113;
          v126 = a1;
          v127 = 15;
          goto LABEL_230;
        case 3:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_160;
          v165 = (_BYTE *)(a1 + 1400);
          do
          {
            if (*v165)
              v166 = *v165 == 31;
            else
              v166 = 1;
            if (v166
              || !strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(a1 + 2120) + 8 * (**(_BYTE **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            v167 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v167 + v116;
            *(_WORD *)(a1 + 1472) = v167 + v116;
            if (((v167 + v116) & 0x8000) != 0)
              return 0;
            v116 = TOKEN(a1, (__int16)(v167 + v116), v167, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_160:
          v125 = (__int16)v113;
          v126 = a1;
          v127 = 10;
          goto LABEL_230;
        case 4:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_170;
          v168 = (_BYTE *)(a1 + 1400);
          do
          {
            if (*v168)
              v169 = *v168 == 31;
            else
              v169 = 1;
            if (v169
              || strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(a1 + 2120) + 8 * (**(_BYTE **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            v170 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v170 + v116;
            *(_WORD *)(a1 + 1472) = v170 + v116;
            if (((v170 + v116) & 0x8000) != 0)
              return 0;
            v116 = TOKEN(a1, (__int16)(v170 + v116), v170, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_170:
          v125 = (__int16)v113;
          v126 = a1;
          v127 = 11;
          goto LABEL_230;
        case 5:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_231;
          v171 = (_BYTE *)(a1 + 1400);
          do
          {
            if (*v171)
              v172 = *v171 == 31;
            else
              v172 = 1;
            if (v172
              || !strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(a1 + 2128) + 8 * (**(_BYTE **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            v178 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v178 + v116;
            *(_WORD *)(a1 + 1472) = v178 + v116;
            if (((v178 + v116) & 0x8000) != 0)
              return 0;
            v116 = TOKEN(a1, (__int16)(v178 + v116), v178, v173, v174, v175, v176, v177);
            *(_WORD *)(a1 + 1466) = v116;
            v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
          goto LABEL_231;
        case 6:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_190;
          v179 = (_BYTE *)(a1 + 1400);
          do
          {
            if (*v179)
              v180 = *v179 == 31;
            else
              v180 = 1;
            if (v180
              || strstr(*(char **)(*(_QWORD *)(*(_QWORD *)(a1 + 2128) + 8 * (**(_BYTE **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            v181 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v181 + v116;
            *(_WORD *)(a1 + 1472) = v181 + v116;
            if (((v181 + v116) & 0x8000) != 0)
              return 0;
            v116 = TOKEN(a1, (__int16)(v181 + v116), v181, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_190:
          v125 = (__int16)v113;
          v126 = a1;
          v127 = 12;
          goto LABEL_230;
        case 0xC:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_202;
          v182 = (_BYTE *)(a1 + 1400);
LABEL_193:
          v183 = *v182;
          if (*v182)
            v184 = v183 == 31;
          else
            v184 = 1;
          if (v184)
            goto LABEL_202;
          v185 = 0;
          v186 = 0;
          while (v183 == *(unsigned __int8 *)(*(_QWORD *)(a1 + 1392) + v185))
          {
            v185 = (__int16)++v186;
            v183 = v182[(__int16)v186];
            if (!v182[(__int16)v186])
            {
              v187 = *(_WORD *)(a1 + 1468);
              *(_WORD *)(a1 + 1466) = v187 + v116;
              *(_WORD *)(a1 + 1472) = v187 + v116;
              if (((v187 + v116) & 0x8000) != 0)
                return 0;
              v116 = TOKEN(a1, (__int16)(v187 + v116), v187, v108, v109, v110, v111, v112);
              *(_WORD *)(a1 + 1466) = v116;
              v113 = (__int16)(v113 + 1);
              if (v113 < *(__int16 *)(a1 + 1406))
                goto LABEL_193;
              break;
            }
          }
LABEL_202:
          v125 = (__int16)v113;
          v126 = a1;
          v127 = 13;
          goto LABEL_230;
        case 0xD:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_215;
          v188 = (_BYTE *)(a1 + 1400);
          do
          {
            v189 = *v188;
            if (*v188)
              v190 = v189 == 31;
            else
              v190 = 1;
            if (v190)
              break;
            v191 = 0;
            v192 = 0;
            while (v189 == *(unsigned __int8 *)(*(_QWORD *)(a1 + 1392) + v191))
            {
              v191 = (__int16)++v192;
              v189 = v188[(__int16)v192];
              if (!v188[(__int16)v192])
                goto LABEL_215;
            }
            v193 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v193 + v116;
            *(_WORD *)(a1 + 1472) = v193 + v116;
            if (((v193 + v116) & 0x8000) != 0)
              return 0;
            v116 = TOKEN(a1, (__int16)(v193 + v116), v193, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_215:
          v125 = (__int16)v113;
          v126 = a1;
          v127 = 14;
          goto LABEL_230;
        case 0x15:
          LOWORD(v113) = 0;
          if (!v115)
            goto LABEL_229;
          v194 = (_BYTE *)(a1 + 1400);
          break;
        default:
          goto LABEL_231;
      }
      while (2)
      {
        v195 = *v194;
        if (*v194)
          v196 = v195 == 31;
        else
          v196 = 1;
        if (!v196)
        {
          v197 = (_BYTE *)(*(_QWORD *)(a1 + 1512) + 5 * **(unsigned __int8 **)(a1 + 1392));
          if (*v197)
          {
            v198 = 0;
            v199 = 0;
            while (v195 == v197[v198])
            {
              v198 = (__int16)++v199;
              v195 = v194[(__int16)v199];
              if (!v194[(__int16)v199])
                goto LABEL_229;
            }
          }
          v200 = *(_WORD *)(a1 + 1468);
          *(_WORD *)(a1 + 1466) = v200 + v116;
          *(_WORD *)(a1 + 1472) = v200 + v116;
          if (((v200 + v116) & 0x8000) == 0)
          {
            v116 = TOKEN(a1, (__int16)(v200 + v116), v200, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            v113 = (__int16)(v113 + 1);
            if (v113 >= *(__int16 *)(a1 + 1406))
              break;
            continue;
          }
          return 0;
        }
        break;
      }
LABEL_229:
      v125 = (__int16)v113;
      v126 = a1;
      v127 = 16;
LABEL_230:
      LOG_WARNING_ON_MAX_NUMBER(v126, v125, v127, v108, v109, v110, v111, v112);
LABEL_231:
      v201 = *(_QWORD *)(a1 + 1456);
      if (*(unsigned __int8 *)(v201 + 1) > (unsigned __int16)v113)
        return 0;
      *(_WORD *)(a1 + 1466) = *(_WORD *)(a1 + 1472);
      v66 = v201 + 5;
      *(_QWORD *)(a1 + 1456) = v201 + 5;
      *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
      if (*(char *)(v201 + 5) <= -65)
      {
        v202 = (char *)(v201 + 6);
        do
        {
          *(_QWORD *)(a1 + 1456) = v202;
          v203 = *v202++;
        }
        while (v203 < -64);
        v66 = (uint64_t)(v202 - 1);
      }
LABEL_237:
      v11 = v66 + 1;
LABEL_238:
      *(_QWORD *)(a1 + 1456) = v11;
      return 1;
    case 0x13:
      v128 = *(__int16 *)(a1 + 1466);
      if (v128 < 0)
        return 0;
      *(_WORD *)(a1 + 1466) = TOKEN(a1, v128, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
      v11 = *(_QWORD *)(a1 + 1456) + 1;
      goto LABEL_238;
    case 0x15:
      v129 = *(__int16 *)(a1 + 1466);
      if (v129 < 0)
        return 0;
      v130 = TOKEN(a1, v129, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      v14 = 0;
      *(_WORD *)(a1 + 1466) = v130;
      v131 = *(_QWORD *)(a1 + 1456);
      *(_QWORD *)(a1 + 1456) = v131 + 1;
      v132 = *(unsigned __int8 *)(v131 + 1);
      v133 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v133;
      *(_QWORD *)(a1 + 1456) = v131 + 2;
      *(_WORD *)(a1 + 1466) = v133 + v130;
      v134 = *(unsigned __int8 *)(a1 + 1400);
      if (!*(_BYTE *)(a1 + 1400) || v134 == 31)
        return v14;
      v135 = (_BYTE *)(*(_QWORD *)(a1 + 1512) + 5 * v132);
      if (!*v135)
        return 1;
      v136 = 0;
      v137 = 0;
      v138 = a1 + 1400;
      while (v134 == v135[v136])
      {
        v14 = 0;
        v136 = (__int16)++v137;
        v134 = *(unsigned __int8 *)(v138 + (__int16)v137);
        if (!*(_BYTE *)(v138 + (__int16)v137))
          return v14;
      }
      return 1;
    default:
      v45 = *(__int16 *)(a1 + 1466);
      if (v45 < 0)
        return 0;
      v46 = TOKEN(a1, v45, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      *(_WORD *)(a1 + 1466) = v46;
      v47 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v47;
      v48 = (const char *)(a1 + 1400);
      v49 = *(_QWORD *)(a1 + 1456);
      v50 = *(unsigned __int8 *)(a1 + 1400);
      if (!*(_BYTE *)(a1 + 1400))
        goto LABEL_102;
      v51 = 0;
      v52 = 0;
      while (v50 == *(unsigned __int8 *)(v49 + v51))
      {
        v51 = (__int16)++v52;
        v50 = v48[(__int16)v52];
        if (!v48[(__int16)v52])
        {
          v14 = 1;
          goto LABEL_103;
        }
      }
LABEL_102:
      v14 = 0;
LABEL_103:
      *(_QWORD *)(a1 + 1456) = v49 + strlen(v48);
      *(_WORD *)(a1 + 1466) = v47 + v46;
      return v14;
  }
}

uint64_t SKIP_DATA(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  _BYTE *v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  unsigned int v13;
  unsigned int v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  uint64_t v18;

  v6 = 0;
  v7 = *(_BYTE **)(a1 + 1456);
  LOBYTE(v8) = *v7;
  while (1)
  {
    if ((_DWORD)a2 != v8)
    {
LABEL_11:
      if ((_DWORD)a2 != 10 || v8 != 10 || !v6)
        goto LABEL_21;
      goto LABEL_14;
    }
    v6 = v7[1];
    if (v6 == a3)
    {
      v9 = *(v7 - 1);
      v10 = v9 > 0x15;
      v11 = (1 << v9) & 0x20067C;
      if (v10 || v11 == 0)
        return 1;
      v13 = *(v7 - 2) - 2;
      if (v13 < 0x14 && ((0x8319Fu >> v13) & 1) != 0)
        return 1;
    }
    if (v6 != 1)
      goto LABEL_11;
LABEL_14:
    v14 = *(v7 - 1);
    v10 = v14 > 0x15;
    v15 = (1 << v14) & 0x20067C;
    v16 = v10 || v15 == 0;
    if (v16 || (v17 = *(v7 - 2), v17 <= 0x15) && ((1 << v17) & 0x20C67C) != 0)
    {
      *(_QWORD *)(a1 + 1456) = v7 + 1;
      SKIP_DATA(a1, a2, 0);
      v18 = *(_QWORD *)(a1 + 1456) + 1;
      goto LABEL_22;
    }
LABEL_21:
    v18 = (uint64_t)v7;
LABEL_22:
    v7 = (_BYTE *)(v18 + 1);
    *(_QWORD *)(a1 + 1456) = v18 + 1;
    v8 = *(unsigned __int8 *)(v18 + 1);
    if (v8 == (_DWORD)a2 && !*(_BYTE *)(v18 + 2))
      return 0;
  }
}

uint64_t TOKEN(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;
  unsigned int *v15;
  _DWORD *v16;
  uint64_t v18;

  v9 = a2;
  if (a2 < 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: nr < 0 (1)", a6, a7, a8, v18);
  v11 = *(_QWORD *)(a1 + 1440);
  if (a3)
  {
    do
    {
      v12 = v9;
      v13 = *(_DWORD *)(v11 + 4 * (__int16)v9);
      v9 += a3;
    }
    while (v13 == 126);
  }
  else
  {
    v12 = v9;
  }
  v14 = v12;
  v15 = (unsigned int *)(v11 + 4 * v12);
  if (*(unsigned int **)(a1 + 2096) != v15)
  {
    Utf32SymToUtf8Sym(*v15, (_BYTE *)(a1 + 1400), 5u);
    v16 = (_DWORD *)(*(_QWORD *)(a1 + 1440) + 4 * v14);
    *(_BYTE *)(a1 + 1405) = *v16 & 0x3F;
    *(_QWORD *)(a1 + 2096) = v16;
  }
  return v14;
}

uint64_t DCT_LKP(uint64_t a1, uint64_t a2, int a3, __int16 *a4)
{
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  char *v18;
  char *v19;
  size_t v20;
  unsigned int v21;
  __int16 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  unsigned int v30;
  _BYTE __c[11];

  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  v8 = 5 * (*a4 - a3) + 1;
  v9 = heap_Alloc(*(_QWORD *)(a1 + 1528), v8);
  if (!v9)
  {
    v27 = 0;
    *(_BYTE *)(a1 + 1428) = -101;
    return v27;
  }
  v10 = v9;
  *(_QWORD *)&__c[3] = 0;
  v30 = 0;
  utf8_Utf32ToUtf8(**(_QWORD **)(a1 + 1504) + 4 * a3, (unsigned __int16)(*a4 - a3), v9, v8, &v30);
  *(_BYTE *)(v10 + v30) = 0;
  (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 1552) + 96))(*(_QWORD *)(a1 + 1536), *(_QWORD *)(a1 + 1544), a2, v10, &__c[3], &__c[1], __c);
  if (*(unsigned __int16 *)&__c[1] != 1)
  {
LABEL_30:
    heap_Free(*(_QWORD **)(a1 + 1528), v10);
    return 0;
  }
  v11 = heap_Alloc(*(_QWORD *)(a1 + 1528), 2 * *(unsigned __int16 *)(a1 + 24));
  if (!v11)
  {
    *(_BYTE *)(a1 + 1428) = -101;
    goto LABEL_30;
  }
  v12 = v11;
  if (*(__int16 *)(a1 + 24) < 1)
    goto LABEL_26;
  v13 = 0;
  v14 = **(char ***)&__c[3];
  do
  {
    *(_WORD *)(v11 + 2 * v13++) = *a4;
    v15 = *(__int16 *)(a1 + 24);
  }
  while (v13 < v15);
  if ((int)v15 < 1)
  {
LABEL_26:
    v17 = 0;
  }
  else
  {
    v29 = v10;
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = strchr(v14, __c[0]);
      v19 = v18;
      if (v18)
        *v18 = 0;
      v20 = strlen(v14);
      if (v20)
      {
        v21 = (unsigned __int16)v20;
        v22 = Utf8_LengthInUtf8chars((unint64_t)v14, (unsigned __int16)v20);
        v23 = a3 + v22;
        if (v23 >= *(__int16 *)(*(_QWORD *)(a1 + 1416) + 2 * v16) - 1)
        {
          v27 = 0;
          *(_BYTE *)(a1 + 1428) = -100;
          v10 = v29;
          goto LABEL_28;
        }
        utf8_Utf8ToUtf32((uint64_t)v14, v21, 0, *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v16) + 4 * a3, (unsigned __int16)(v22 + a3), &v30, 0);
        *(_WORD *)(v12 + 2 * v16) = v23;
      }
      else
      {
        LOWORD(v23) = *(_WORD *)(v12 + 2 * v16);
      }
      if (v17 <= (__int16)v23)
        v17 = v23;
      v24 = *(__int16 *)(a1 + 24);
      if (!v19)
        break;
      v14 = v19 + 1;
      ++v16;
    }
    while (v16 < v24);
    v25 = *(unsigned __int16 *)(a1 + 24);
    if ((__int16)v24 < 1)
    {
      v10 = v29;
    }
    else
    {
      v26 = 0;
      v10 = v29;
      do
      {
        if (*(__int16 *)(v12 + 2 * v26) < v17)
          memset_pattern16((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v26) + 4 * *(__int16 *)(v12 + 2 * v26)), &unk_1DEC653D0, 4 * (unsigned __int16)(v17 + ~*(_WORD *)(v12 + 2 * v26)) + 4);
        ++v26;
      }
      while (v25 != v26);
    }
  }
  *a4 = v17;
  v27 = 1;
LABEL_28:
  heap_Free(*(_QWORD **)(a1 + 1528), v10);
  heap_Free(*(_QWORD **)(a1 + 1528), v12);
  return v27;
}

uint64_t RESTORE_SUBSTITUTION(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  __int16 i;
  int v12;
  unsigned __int16 v13;

  v4 = *(__int16 *)(a1 + 24);
  if (v4 <= 0)
  {
    v6 = 0;
    v8 = *(_QWORD *)(a1 + 1416);
    v7 = a2;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v7 = a2;
    v8 = *(_QWORD *)(a1 + 1416);
    do
    {
      v9 = *(_WORD *)(v8 + 2 * v5);
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v5);
      for (i = v9; ; ++i)
      {
        v12 = *(_DWORD *)(v10 + 4 * i);
        if (!v12)
          break;
        if (v12 == 31)
        {
          v6 = i - v9;
          v13 = i - v9 + 1;
          memmove((void *)(v10 + 4 * a2), (const void *)(v10 + 4 * *(__int16 *)(v8 + 2 * v5)), 4 * v13);
          v8 = *(_QWORD *)(a1 + 1416);
          *(_WORD *)(v8 + 2 * v5) += v13;
          LOWORD(v4) = *(_WORD *)(a1 + 24);
          break;
        }
      }
      ++v5;
    }
    while (v5 < (__int16)v4);
    v4 = (__int16)v4;
  }
  memmove((void *)(*(_QWORD *)(a1 + 1560) + v7), (const void *)(*(_QWORD *)(a1 + 1560) + *(__int16 *)(v8 + 2 * v4)), (unsigned __int16)(v6 + 1));
  *(_WORD *)(*(_QWORD *)(a1 + 1416) + 2 * *(__int16 *)(a1 + 24)) += v6 + 1;
  return (__int16)(v6 + a2);
}

uint64_t FirstUtf8SymToUtf32(unsigned __int8 *a1, _DWORD *a2)
{
  unsigned int v4;
  uint64_t result;
  int v6;

  v6 = 0;
  *a2 = 0;
  v4 = utf8_determineUTF8CharLength(*a1);
  result = utf8_Utf8ToUtf32((uint64_t)a1, v4, 0, (uint64_t)a2, 1u, &v6, 0);
  if ((result & 0x80000000) == 0 && v6 != 1)
    *a2 = 0;
  return result;
}

uint64_t MOVE_FOR_SUBSTITUTION(uint64_t a1, int a2, int a3, int a4)
{
  int v5;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char v17;
  __int16 v18;
  int v19;
  uint64_t v20;
  __int16 i;
  int v23;

  if (a4)
  {
    v5 = a2;
    LODWORD(v7) = *(__int16 *)(a1 + 24);
    if ((int)v7 > 0)
    {
      v8 = 0;
      v9 = a4 + a3 + 1;
      v10 = (__int16)(a4 + a2);
      v23 = a4;
      v11 = 4 * (unsigned __int16)a4;
      do
      {
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v8);
        if (v12 != *(_QWORD *)(a1 + 1448))
        {
          if (v9 >= *(__int16 *)(*(_QWORD *)(a1 + 1416) + 2 * v8))
            goto LABEL_24;
          memmove((void *)(v12 + 4 * v10), (const void *)(v12 + 4 * v5), 4 * (unsigned __int16)(a3 - v5 + 1));
          if ((int)v10 > v5)
            memset_pattern16((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8 * v8) + 4 * v5), &unk_1DEC653D0, v11);
        }
        ++v8;
        v7 = *(__int16 *)(a1 + 24);
      }
      while (v8 < v7);
      a4 = v23;
    }
    if (a4 < 0)
    {
      v7 = *(_QWORD *)(a1 + 1560);
      if ((__int16)(a4 + v5) >= v5)
      {
        v13 = 0;
        v14 = v5;
      }
      else
      {
        v13 = 0;
        v14 = v5;
        v15 = (char *)(v7 + (__int16)(a4 + v5));
        v16 = v5 - (uint64_t)(__int16)(a4 + v5);
        do
        {
          v17 = *v15++;
          v13 += v17;
          --v16;
        }
        while (v16);
      }
      *(_BYTE *)(v7 + v14) += v13;
      LOWORD(v7) = *(_WORD *)(a1 + 24);
    }
    v18 = a4 + a3;
    if (a4 + a3 >= *(__int16 *)(*(_QWORD *)(a1 + 1416) + 2 * (__int16)v7) - 1)
    {
LABEL_24:
      v18 = 0;
      *(_BYTE *)(a1 + 1428) = -100;
    }
    else
    {
      v19 = a4;
      v20 = a4 + (uint64_t)v5;
      memmove((void *)(*(_QWORD *)(a1 + 1560) + v20), (const void *)(*(_QWORD *)(a1 + 1560) + v5), (unsigned __int16)(a3 - v5 + 1));
      if (v19 >= 1)
      {
        do
          *(_BYTE *)(*(_QWORD *)(a1 + 1560) + (__int16)v5++) = 0;
        while ((int)v20 > (__int16)v5);
      }
      for (i = v18 + 1; i <= a3; ++i)
        *(_BYTE *)(*(_QWORD *)(a1 + 1560) + i) = 0;
    }
  }
  else
  {
    return (__int16)a3;
  }
  return v18;
}

uint64_t COUNTSYL(uint64_t a1, int a2, _WORD *a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  __int16 v6;

  LODWORD(v3) = (__int16)(*a3 - 1);
  if ((int)v3 >= a2)
  {
    v4 = *(uint64_t **)(a1 + 1504);
    v5 = *v4;
    v6 = 1;
    do
    {
      v3 = (__int16)v3;
      if (*(_DWORD *)(v5 + 4 * (__int16)v3) == 45)
      {
        if (v6 <= 9)
          *(_DWORD *)(v4[3] + 4 * v3) = (unsigned __int16)(v6 + 48);
        ++v6;
      }
      LODWORD(v3) = (__int16)(v3 - 1);
    }
    while ((int)v3 >= a2);
  }
  return 1;
}

uint64_t COPY_L1_TO_L2(uint64_t a1, int a2, __int16 *a3)
{
  int v3;
  uint64_t v4;

  v3 = *a3;
  if (*(__int16 *)(*(_QWORD *)(a1 + 1416) + 2) - 1 <= v3)
  {
    v4 = 0;
    *(_BYTE *)(a1 + 1428) = -100;
  }
  else
  {
    memmove((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8) + 4 * a2), (const void *)(**(_QWORD **)(a1 + 1504) + 4 * a2), 4 * (unsigned __int16)(v3 - a2));
    return 1;
  }
  return v4;
}

uint64_t TAGTQ(uint64_t a1, int a2, __int16 *a3)
{
  int v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  int v22;
  int v23;
  int v24;
  __int16 v25;
  int v26;

  v5 = *a3;
  v6 = (__int16)(*a3 - 1);
  v7 = *(uint64_t **)(a1 + 1504);
  v8 = v7[1];
  if (v6 >= a2)
  {
    LOWORD(v22) = *a3 - 1;
    do
    {
      v23 = *(_DWORD *)(v8 + 4 * (__int16)v22);
      if (v23 != 126 && v23 != 32)
        break;
      v22 = (__int16)(v22 - 1);
    }
    while (v22 >= a2);
    if (*(_DWORD *)(v8 + 4 * (__int16)v22) == 63)
    {
      v9 = *v7;
      while (v6 >= a2)
      {
        v24 = *(_DWORD *)(v9 + 4 * (__int16)v6);
        if (v24 != 20 && v24 != 126 && v24 != 32)
          break;
        v6 = (__int16)(v6 - 1);
      }
      goto LABEL_4;
    }
    return 1;
  }
  if (*(_DWORD *)(v8 + 4 * (__int16)(*a3 - 1)) != 63)
    return 1;
  v9 = *v7;
LABEL_4:
  if (a2 <= (__int16)v6)
  {
    v25 = 0;
    v10 = v6;
    do
    {
      v26 = *(_DWORD *)(v9 + 4 * (__int16)v10);
      if (v26 == 45 || v26 == 32)
        ++v25;
      if (v26 == 35)
        break;
      v10 = (__int16)(v10 - 1);
      if (v10 < a2)
        break;
    }
    while (v25 < 3);
  }
  else
  {
    v10 = v6;
  }
  do
  {
    v11 = *(_DWORD *)(v9 + 4 * (__int16)++v10);
    v12 = v11 > 0x23 || ((1 << v11) & 0x900100000) == 0;
  }
  while (!v12 || v11 == 126);
  if (v5 + 4 >= **(__int16 **)(a1 + 1416) - 1
    || (v13 = (__int16)v10 + 4,
        memmove((void *)(v9 + 4 * v13), (const void *)(v9 + 4 * (__int16)v10), 4 * (unsigned __int16)(v5 - v10)),
        v14 = *a3,
        v14 + 4 >= *(__int16 *)(*(_QWORD *)(a1 + 1416) + 2) - 1)
    || (memmove((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8) + 4 * v13), (const void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 8) + 4 * (__int16)v10), 4 * (unsigned __int16)(v14 - v10)), v15 = *a3, v15 + 4 >= *(__int16 *)(*(_QWORD *)(a1 + 1416) + 4) - 1)|| (memmove((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 16) + 4 * v13), (const void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 16) + 4 * (__int16)v10), 4 * (unsigned __int16)(v15 - v10)), v16 = *a3, v16 + 4 >= *(__int16 *)(*(_QWORD *)(a1 + 1416) + 6) - 1))
  {
    result = 0;
    *(_BYTE *)(a1 + 1428) = -100;
  }
  else
  {
    memmove((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 24) + 4 * v13), (const void *)(*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 24) + 4 * (__int16)v10), 4 * (unsigned __int16)(v16 - v10));
    *a3 += 4;
    v17 = *(_QWORD **)(a1 + 1504);
    v18 = v17[1];
    *(_OWORD *)(*v17 + 4 * (__int16)v10) = xmmword_1DEC653E0;
    v19 = v17[2];
    v20 = v17[3];
    result = 1;
    do
    {
      *(_DWORD *)(v18 + 4 * (__int16)v10) = 126;
      *(_DWORD *)(v19 + 4 * (__int16)v10) = 126;
      *(_DWORD *)(v20 + 4 * (__int16)v10++) = 126;
    }
    while ((int)v13 > (__int16)v10);
  }
  return result;
}

uint64_t fe_depes_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  _QWORD *v24;
  uint64_t LngBrokerString;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char __src[256];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  v43 = 0;
  v5 = 2305826826;
  HIWORD(v41) = 0;
  __src[0] = 0;
  if (!a5)
    return 2305826823;
  *a5 = 0;
  *((_DWORD *)a5 + 2) = 0;
  inited = InitRsrcFunction(a3, a4, &v43);
  if ((inited & 0x80000000) != 0)
    return inited;
  log_OutText(*(_QWORD *)(v43 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ObjOpen", v12, v13, v14, v41);
  inited = objc_GetObject(*(_QWORD *)(v43 + 48), (uint64_t)"FE_DCTLKP", &v42);
  if ((inited & 0x80000000) != 0)
    return inited;
  v15 = heap_Calloc(*(_QWORD **)(v43 + 8), 1, 712);
  if (v15)
  {
    v20 = v15;
    *a5 = v15;
    *((_DWORD *)a5 + 2) = 62334;
    v21 = v43;
    *(_QWORD *)(v20 + 16) = a3;
    *(_QWORD *)(v20 + 24) = a4;
    *(_QWORD *)(v20 + 32) = a1;
    *(_QWORD *)(v20 + 40) = a2;
    *(_QWORD *)v20 = v21;
    *(_QWORD *)(v20 + 8) = a1;
    v22 = v42;
    *(_QWORD *)(v20 + 64) = *(_QWORD *)(v42 + 8);
    v23 = *(_OWORD *)(v22 + 16);
    *(_OWORD *)(v20 + 144) = 0u;
    *(_OWORD *)(v20 + 48) = v23;
    *(_OWORD *)(v20 + 170) = 0u;
    *(_OWORD *)(v20 + 160) = 0u;
    *(_QWORD *)(v20 + 72) = 0;
    *(_DWORD *)(v20 + 186) = 3172;
    *(_QWORD *)(v20 + 80) = 0;
    v24 = (_QWORD *)(v20 + 80);
    *(_QWORD *)(v20 + 192) = 0;
    if (((hlp_CreateLngBrokerString(v21, __src, 0) & 0x80000000) != 0
       || (hlp_OpenData(*(_QWORD *)v20, (uint64_t)__src, (uint64_t *)(v20 + 72), (_DWORD *)(v20 + 136)) & 0x80000000) != 0
       || !*(_QWORD *)(v20 + 72))
      && ((LngBrokerString = hlp_CreateLngBrokerString(*(_QWORD *)v20, __src, 1), (LngBrokerString & 0x80000000) != 0)
       || (LngBrokerString = hlp_OpenData(*(_QWORD *)v20, (uint64_t)__src, (uint64_t *)(v20 + 72), (_DWORD *)(v20 + 136)),
           (LngBrokerString & 0x80000000) != 0))
      || ((__strcpy_chk(), (hlp_CreateVoiceBrokerString_0(*(_QWORD *)v20, __src, 0, 0) & 0x80000000) != 0)
       || (hlp_OpenData(*(_QWORD *)v20, (uint64_t)__src, (uint64_t *)(v20 + 80), (_DWORD *)(v20 + 140)) & 0x80000000) != 0
       || !*v24)
      && ((hlp_CreateVoiceBrokerString_0(*(_QWORD *)v20, __src, 1, 1) & 0x80000000) != 0
       || (hlp_OpenData(*(_QWORD *)v20, (uint64_t)__src, (uint64_t *)(v20 + 80), (_DWORD *)(v20 + 140)) & 0x80000000) != 0
       || !*v24)
      && ((LngBrokerString = hlp_CreateVoiceBrokerString_0(*(_QWORD *)v20, __src, 1, 0),
           (LngBrokerString & 0x80000000) != 0)
       || (LngBrokerString = hlp_OpenData(*(_QWORD *)v20, (uint64_t)__src, (uint64_t *)(v20 + 80), (_DWORD *)(v20 + 140)),
           (LngBrokerString & 0x80000000) != 0)))
    {
      v5 = LngBrokerString;
      goto LABEL_34;
    }
    strcpy((char *)(v20 + 456), __src);
    if (*(_QWORD *)(v20 + 72))
    {
      v30 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v20 + 8), 1, 2136);
      *(_QWORD *)(v20 + 144) = v30;
      if (!v30)
      {
LABEL_31:
        v39 = 42000;
LABEL_33:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)v20 + 32), (uint64_t)"FE_DEPES", v39, 0, v26, v27, v28, v29, v41);
        goto LABEL_34;
      }
      *(_QWORD *)(v30 + 1560) = 0;
      *(_OWORD *)(v30 + 1496) = 0u;
      *(_OWORD *)(v30 + 1512) = 0u;
      *(_QWORD *)(v30 + 1528) = *(_QWORD *)(v43 + 8);
      v31 = v42;
      *(_OWORD *)(v30 + 1536) = *(_OWORD *)(v42 + 16);
      v32 = *(_QWORD *)(v20 + 144);
      *(_QWORD *)(v32 + 1552) = *(_QWORD *)(v31 + 8);
      *(_QWORD *)v32 = 0;
      *(_OWORD *)(v32 + 2120) = 0u;
      if (!*v24)
      {
LABEL_29:
        v5 = fe_depes_InitModule((uint64_t **)*a5, a5[1], "fe_depes", (_WORD *)&v41 + 3);
        if ((v5 & 0x80000000) == 0)
        {
LABEL_35:
          log_OutText(*(_QWORD *)(v43 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ObjOpen", v36, v37, v38, v41);
          return v5;
        }
LABEL_34:
        fe_depes_ObjClose((_QWORD *)*a5, a5[1]);
        *a5 = 0;
        *((_DWORD *)a5 + 2) = 0;
        goto LABEL_35;
      }
    }
    else if (!*v24)
    {
      v5 = 2305826819;
      v39 = 42002;
      goto LABEL_33;
    }
    v33 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v20 + 8), 1, 2136);
    *(_QWORD *)(v20 + 152) = v33;
    if (v33)
    {
      *(_QWORD *)(v33 + 1560) = 0;
      *(_OWORD *)(v33 + 1496) = 0u;
      *(_OWORD *)(v33 + 1512) = 0u;
      *(_QWORD *)(v33 + 1528) = *(_QWORD *)(v43 + 8);
      v34 = v42;
      *(_OWORD *)(v33 + 1536) = *(_OWORD *)(v42 + 16);
      v35 = *(_QWORD *)(v20 + 152);
      *(_QWORD *)(v35 + 1552) = *(_QWORD *)(v34 + 8);
      *(_QWORD *)v35 = 0;
      *(_OWORD *)(v35 + 2120) = 0u;
      goto LABEL_29;
    }
    goto LABEL_31;
  }
  log_OutPublic(*(_QWORD *)(v43 + 32), (uint64_t)"FE_DEPES", 42000, 0, v16, v17, v18, v19, v41);
  objc_ReleaseObject(*(_QWORD *)(v43 + 48), (uint64_t)"FE_DCTLKP");
  return v5;
}

uint64_t hlp_CreateLngBrokerString(uint64_t a1, char *a2, int a3)
{
  uint64_t result;
  char *v7;
  int v8[2];
  char v9[7];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[25];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v7 = &byte_1DEBD87CE;
  *(_QWORD *)v8 = 0;
  memset(v16, 0, sizeof(v16));
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    strcpy(v9, "depes/");
    __strcat_chk();
    if (!a3)
    {
      result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v7);
      if ((result & 0x80000000) != 0)
        return result;
      __strcat_chk();
      __strcat_chk();
    }
    return brokeraux_ComposeBrokerString(a1, v9, 1, 1, *(char **)v8, 0, 0, a2, 0x100uLL);
  }
  return result;
}

uint64_t hlp_OpenData(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  unsigned int v14;
  uint64_t v15;

  v15 = 0;
  if ((brk_DataOpenEx(*(_QWORD *)(a1 + 24), a2, 1, (uint64_t)a3) & 0x80000000) != 0)
  {
    v11 = 0;
LABEL_10:
    *a3 = 0;
    return v11;
  }
  v11 = brk_DataMap(*(_QWORD *)(a1 + 24), *a3, 0, 72, (uint64_t)&v15);
  if ((v11 & 0x80000000) != 0)
  {
    brk_DataClose(*(_QWORD *)(a1 + 24), *a3);
    goto LABEL_10;
  }
  if ((v15 & 3) != 0
    || *(_DWORD *)v15 != 65279
    || LH_strnicmp(v15 + 4, (uint64_t)"SCANSOFT", 8uLL)
    || LH_strnicmp(v15 + 12, (uint64_t)"depes", 5uLL))
  {
    v11 = 2305826841;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_DEPES", 42006, 0, v7, v8, v9, v10, v14);
  }
  else
  {
    v13 = *(_DWORD *)(v15 + 20);
    brk_DataUnmap(*(_QWORD *)(a1 + 24), *a3, v15);
    *a4 = v13 - 72;
  }
  return v11;
}

uint64_t hlp_CreateVoiceBrokerString_0(uint64_t a1, char *a2, int a3, int a4)
{
  uint64_t result;
  char *v9;
  char *v10;
  char *v11;
  const char *v12;
  char *v13;
  char v14[7];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[25];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 0;
  v10 = 0;
  v11 = &byte_1DEBD87CE;
  memset(v21, 0, sizeof(v21));
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", &v13);
  if ((result & 0x80000000) == 0)
  {
    if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fevoice", &v12) & 0x80000000) == 0
      || (result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voice", &v12), (result & 0x80000000) == 0))
    {
      strcpy(v14, "depes/");
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      if (a3)
      {
        if (a4)
        {
LABEL_6:
          if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voicemodel", &v10) & 0x80000000) != 0)
          {
            v9 = 0;
            v10 = 0;
          }
          else
          {
            v9 = v10;
          }
          return brokeraux_ComposeBrokerString(a1, v14, 1, 1, v13, v12, v9, a2, 0x100uLL);
        }
      }
      else
      {
        result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v11);
        if ((result & 0x80000000) != 0)
          return result;
        __strcat_chk();
        __strcat_chk();
        if (a4)
          goto LABEL_6;
      }
      v9 = 0;
      return brokeraux_ComposeBrokerString(a1, v14, 1, 1, v13, v12, v9, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t fe_depes_InitModule(uint64_t **a1, int a2, char *a3, _WORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t inited;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;

  v8 = 2305826826;
  v9 = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((v9 & 0x80000000) == 0)
  {
    inited = v9;
    log_OutText((*a1)[4], (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_InitModule", v10, v11, v12, v37);
    *a4 = 0;
    v14 = (uint64_t)a1[9];
    if (v14)
    {
      v15 = (uint64_t)a1[18];
      if (!v15)
        goto LABEL_18;
      inited = hlp_InitData((uint64_t)a1, *a1, a3, 1, (uint64_t)(a1 + 25), v14, *((unsigned int *)a1 + 34), v15);
      if ((inited & 0x80000000) != 0)
        goto LABEL_45;
      v20 = a1[18];
      if (*a4)
      {
        if ((unsigned __int16)*a4 != *((__int16 *)v20 + 12))
          goto LABEL_19;
        v21 = *((unsigned __int16 *)v20 + 12);
      }
      else
      {
        v21 = *((unsigned __int16 *)v20 + 12);
      }
      *a4 = v21;
      v20[23] = (uint64_t)a1 + 186;
    }
    else
    {
      v21 = 0;
    }
    v22 = (uint64_t)a1[10];
    if (!v22)
    {
LABEL_22:
      v26 = heap_Calloc((_QWORD *)(*a1)[1], v21, 8);
      a1[20] = (uint64_t *)v26;
      v27 = *a1;
      if (!v26)
      {
        v25 = 42000;
LABEL_44:
        log_OutPublic(v27[4], (uint64_t)"FE_DEPES", v25, 0, v16, v17, v18, v19, v38);
        inited = v8;
        goto LABEL_45;
      }
      v28 = heap_Calloc((_QWORD *)v27[1], (unsigned __int16)*a4, 8);
      a1[21] = (uint64_t *)v28;
      if (v28)
      {
        v29 = (__int16)*a4;
        *((_WORD *)a1 + 92) = *a4;
        if (v29 >= 1)
        {
          v30 = 0;
          do
          {
            a1[20][v30] = 0;
            a1[20][v30] = heap_Alloc((*a1)[1], 3172);
            if (!a1[20][v30])
              goto LABEL_41;
            a1[21][v30] = 0;
            a1[21][v30] = heap_Alloc((*a1)[1], 12688);
            if (!a1[21][v30])
              goto LABEL_41;
            if (a1[9])
            {
              *(_QWORD *)(a1[18][187] + 8 * v30) = a1[20][v30];
              *(_QWORD *)(a1[18][188] + 8 * v30) = a1[21][v30];
            }
            if (a1[10])
            {
              *(_QWORD *)(a1[19][187] + 8 * v30) = a1[20][v30];
              *(_QWORD *)(a1[19][188] + 8 * v30) = a1[21][v30];
            }
          }
          while (++v30 < *((__int16 *)a1 + 92));
        }
        v35 = heap_Calloc((_QWORD *)(*a1)[1], 3172, 1);
        a1[22] = (uint64_t *)v35;
        if (!v35)
        {
LABEL_41:
          log_OutPublic((*a1)[4], (uint64_t)"FE_DEPES", 42000, 0, v31, v32, v33, v34, v38);
          return v8;
        }
        if (a1[9])
          a1[18][195] = v35;
        if (a1[10])
          a1[19][195] = v35;
        if ((inited & 0x80000000) == 0)
        {
LABEL_46:
          log_OutText((*a1)[4], (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_InitModule", v32, v33, v34, v38);
          return inited;
        }
LABEL_45:
        fe_depes_ExitModule(a1, a2);
        goto LABEL_46;
      }
      v25 = 42000;
LABEL_43:
      v27 = *a1;
      goto LABEL_44;
    }
    v23 = (uint64_t)a1[19];
    if (v23)
    {
      inited = hlp_InitData((uint64_t)a1, *a1, a3, 0, (uint64_t)(a1 + 57), v22, *((unsigned int *)a1 + 35), v23);
      if ((inited & 0x80000000) != 0)
        goto LABEL_45;
      v24 = a1[19];
      if (!*a4)
      {
        v21 = *((unsigned __int16 *)v24 + 12);
        goto LABEL_21;
      }
      if ((unsigned __int16)*a4 == *((__int16 *)v24 + 12))
      {
        v21 = *((unsigned __int16 *)v24 + 12);
LABEL_21:
        *a4 = v21;
        v24[23] = (uint64_t)a1 + 186;
        goto LABEL_22;
      }
LABEL_19:
      v8 = 2305826841;
      v25 = 42003;
      goto LABEL_43;
    }
LABEL_18:
    inited = 2305826823;
    goto LABEL_45;
  }
  return 2305826824;
}

uint64_t fe_depes_ObjClose(_QWORD *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  result = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((result & 0x80000000) != 0)
    return 2305826824;
  if (a1)
  {
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ObjClose", v5, v6, v7, v15);
    objc_ReleaseObject(*(_QWORD *)(*a1 + 48), (uint64_t)"FE_DCTLKP");
    fe_depes_ExitModule(a1, a2);
    v11 = a1[18];
    if (v11)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v11);
      a1[18] = 0;
    }
    v12 = a1[19];
    if (v12)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v12);
      a1[19] = 0;
    }
    v13 = a1[9];
    if (v13)
    {
      brk_DataClose(*(_QWORD *)(*a1 + 24), v13);
      a1[9] = 0;
    }
    v14 = a1[10];
    if (v14)
    {
      brk_DataClose(*(_QWORD *)(*a1 + 24), v14);
      a1[10] = 0;
    }
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ObjClose", v8, v9, v10, v16);
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_depes_ObjReopen(uint64_t a1, int a2)
{
  uint64_t inited;
  uint64_t LngBrokerString;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char __src[256];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  inited = 2305826826;
  HIWORD(v31) = 0;
  __src[0] = 0;
  LngBrokerString = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((LngBrokerString & 0x80000000) != 0)
    return 2305826824;
  if (!a1)
    return LngBrokerString;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ObjReopen", v6, v7, v8, v31);
  fe_depes_ExitModule((_QWORD *)a1, a2);
  v9 = *(_QWORD *)(a1 + 144);
  if (v9)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v9);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v10 = *(_QWORD *)(a1 + 152);
  if (v10)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v10);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v12 = (_QWORD *)(a1 + 72);
  v11 = *(_QWORD *)(a1 + 72);
  if (v11)
  {
    brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v11);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v14 = (_QWORD *)(a1 + 80);
  v13 = *(_QWORD *)(a1 + 80);
  if (v13)
    brk_DataClose(*(_QWORD *)(*(_QWORD *)a1 + 24), v13);
  *(_WORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 186) = 3172;
  *(_QWORD *)(a1 + 192) = 0;
  *v12 = 0;
  *(_QWORD *)(a1 + 80) = 0;
  if ((hlp_CreateLngBrokerString(*(_QWORD *)a1, __src, 0) & 0x80000000) != 0
    || (hlp_OpenData(*(_QWORD *)a1, (uint64_t)__src, (uint64_t *)(a1 + 72), (_DWORD *)(a1 + 136)) & 0x80000000) != 0
    || !*v12)
  {
    LngBrokerString = hlp_CreateLngBrokerString(*(_QWORD *)a1, __src, 1);
    if ((LngBrokerString & 0x80000000) != 0)
      return LngBrokerString;
    LngBrokerString = hlp_OpenData(*(_QWORD *)a1, (uint64_t)__src, (uint64_t *)(a1 + 72), (_DWORD *)(a1 + 136));
    if ((LngBrokerString & 0x80000000) != 0)
      return LngBrokerString;
  }
  __strcpy_chk();
  if ((hlp_CreateVoiceBrokerString_0(*(_QWORD *)a1, __src, 0, 0) & 0x80000000) != 0
    || (hlp_OpenData(*(_QWORD *)a1, (uint64_t)__src, (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 140)) & 0x80000000) != 0
    || !*v14)
  {
    LngBrokerString = hlp_CreateVoiceBrokerString_0(*(_QWORD *)a1, __src, 1, 1);
    if ((LngBrokerString & 0x80000000) != 0)
      return LngBrokerString;
    if ((hlp_OpenData(*(_QWORD *)a1, (uint64_t)__src, (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 140)) & 0x80000000) != 0
      || !*v14)
    {
      LngBrokerString = hlp_CreateVoiceBrokerString_0(*(_QWORD *)a1, __src, 1, 0);
      if ((LngBrokerString & 0x80000000) != 0)
        return LngBrokerString;
      LngBrokerString = hlp_OpenData(*(_QWORD *)a1, (uint64_t)__src, (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 140));
      if ((LngBrokerString & 0x80000000) != 0)
        return LngBrokerString;
    }
  }
  strcpy((char *)(a1 + 456), __src);
  if (!*(_QWORD *)(a1 + 72))
  {
    if (!*v14)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42002, 0, v15, v16, v17, v18, v31);
      return 2305826819;
    }
    goto LABEL_32;
  }
  v19 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 1, 2136);
  *(_QWORD *)(a1 + 144) = v19;
  if (!v19)
    goto LABEL_36;
  *(_QWORD *)(v19 + 1560) = 0;
  *(_OWORD *)(v19 + 1496) = 0u;
  *(_OWORD *)(v19 + 1512) = 0u;
  *(_QWORD *)(v19 + 1528) = *(_QWORD *)(*(_QWORD *)a1 + 8);
  *(_OWORD *)(v19 + 1536) = *(_OWORD *)(a1 + 48);
  v24 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(v24 + 1552) = *(_QWORD *)(a1 + 64);
  *(_QWORD *)v24 = 0;
  *(_OWORD *)(v24 + 2120) = 0u;
  if (*(_QWORD *)(a1 + 80))
  {
LABEL_32:
    v26 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 1, 2136);
    *(_QWORD *)(a1 + 152) = v26;
    if (v26)
    {
      *(_QWORD *)(v26 + 1560) = 0;
      *(_OWORD *)(v26 + 1496) = 0u;
      *(_OWORD *)(v26 + 1512) = 0u;
      *(_QWORD *)(v26 + 1528) = *(_QWORD *)(*(_QWORD *)a1 + 8);
      *(_OWORD *)(v26 + 1536) = *(_OWORD *)(a1 + 48);
      v27 = *(_QWORD *)(a1 + 152);
      *(_QWORD *)(v27 + 1552) = *(_QWORD *)(a1 + 64);
      *(_QWORD *)v27 = 0;
      *(_OWORD *)(v27 + 2120) = 0u;
      goto LABEL_34;
    }
LABEL_36:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42000, 0, v20, v21, v22, v23, v31);
    return inited;
  }
LABEL_34:
  inited = fe_depes_InitModule((uint64_t **)a1, a2, "fe_depes", (_WORD *)&v31 + 3);
  if ((inited & 0x80000000) == 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ObjReopen", v28, v29, v30, v31);
  return inited;
}

uint64_t fe_depes_ExitModule(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v19;
  uint64_t v20;

  if ((safeh_HandleCheck((uint64_t)a1, a2, 62334, 712) & 0x80000000) != 0)
    return 2305826824;
  log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ExitModule", v3, v4, v5, v19);
  v9 = a1[20];
  if (v9)
  {
    if (*((__int16 *)a1 + 92) >= 1)
    {
      v10 = 0;
      do
      {
        v11 = *(_QWORD *)(a1[20] + 8 * v10);
        if (v11)
        {
          heap_Free(*(_QWORD **)(*a1 + 8), v11);
          *(_QWORD *)(a1[20] + 8 * v10) = 0;
        }
        if (a1[9])
          *(_QWORD *)(*(_QWORD *)(a1[18] + 1496) + 8 * v10) = 0;
        if (a1[10])
          *(_QWORD *)(*(_QWORD *)(a1[19] + 1496) + 8 * v10) = 0;
        ++v10;
      }
      while (v10 < *((__int16 *)a1 + 92));
      v9 = a1[20];
    }
    heap_Free(*(_QWORD **)(*a1 + 8), v9);
    a1[20] = 0;
  }
  v12 = a1[21];
  if (v12)
  {
    if (*((__int16 *)a1 + 92) >= 1)
    {
      v13 = 0;
      do
      {
        v14 = *(_QWORD *)(a1[21] + 8 * v13);
        if (v14)
        {
          heap_Free(*(_QWORD **)(*a1 + 8), v14);
          *(_QWORD *)(a1[21] + 8 * v13) = 0;
        }
        if (a1[9])
          *(_QWORD *)(*(_QWORD *)(a1[18] + 1504) + 8 * v13) = 0;
        if (a1[10])
          *(_QWORD *)(*(_QWORD *)(a1[19] + 1504) + 8 * v13) = 0;
        ++v13;
      }
      while (v13 < *((__int16 *)a1 + 92));
      v12 = a1[21];
    }
    heap_Free(*(_QWORD **)(*a1 + 8), v12);
    a1[21] = 0;
  }
  v15 = a1[22];
  if (v15)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v15);
    a1[22] = 0;
  }
  if (a1[9])
  {
    hlp_ExitData((_WORD *)a1[2], a1[3], (_WORD *)a1[4], a1[5], a1[18], a1[11], a1[14], a1[13]);
    v16 = (_QWORD *)a1[18];
    if (v16)
      *v16 = 0;
    a1[13] = 0;
    a1[14] = 0;
  }
  if (a1[10])
  {
    hlp_ExitData((_WORD *)a1[2], a1[3], (_WORD *)a1[4], a1[5], a1[19], a1[12], a1[16], a1[15]);
    v17 = (_QWORD *)a1[19];
    if (v17)
      *v17 = 0;
    a1[15] = 0;
    a1[16] = 0;
  }
  log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ExitModule", v6, v7, v8, v20);
  return 0;
}

uint64_t hlp_InitData(uint64_t a1, uint64_t *a2, char *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t U32;
  int v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  int v21;
  int v22;
  int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  int v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  __int16 v78;
  char *v79;
  uint64_t v80;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  char *v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unsigned int v99;
  char *v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unsigned int v105;
  char *v106;
  __int16 v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unsigned int v120;
  char *v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unsigned int v126;
  char *v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unsigned int v132;
  char *v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unsigned int v138;
  char *v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned int v144;
  char *v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unsigned int v150;
  char *v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  unsigned int v156;
  char *v157;
  unsigned int v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unsigned int v168;
  uint64_t v169;
  int v170;
  int v171;
  unsigned int v172;
  uint64_t v173;
  uint64_t v174;
  char *v175;
  _BYTE v176[256];
  uint64_t v177;

  v9 = a7;
  v177 = *MEMORY[0x1E0C80C00];
  v174 = 0;
  v175 = 0;
  v173 = 0;
  v171 = 0;
  *(_QWORD *)(a8 + 2080) = a2;
  U32 = brk_DataMap(a2[3], a6, 72, a7, (uint64_t)&v175);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v170 = a4;
  v17 = LH_stricmp(v175, a3);
  v18 = 0;
  v19 = 0;
  v20 = v9 != 0;
  if (v9 && v17)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      v21 = strlen(&v175[v18]);
      v19 += v21 + ((~(_BYTE)v21 - (_BYTE)v19) & 3) + 9;
      v18 = v19;
      v22 = LH_stricmp(&v175[v19], a3);
      v20 = v19 < v9;
    }
    while (v19 < v9 && v22 != 0);
  }
  if (!v20)
  {
    brk_DataUnmap(a2[3], a6, (uint64_t)v175);
    return 2305826820;
  }
  v24 = strlen(&v175[v18]);
  v25 = (v19 + v24 + ((~(_BYTE)v24 - (_BYTE)v19) & 3) + 1) >> 2;
  v171 = *(_DWORD *)&v175[4 * v25];
  v26 = *(_DWORD *)&v175[4 * v25 + 4];
  brk_DataUnmap(a2[3], a6, (uint64_t)v175);
  U32 = brk_DataMapRefCnt(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), a5, v171, v26, &v174);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v30 = v174;
  v31 = 88;
  if (!v170)
    v31 = 96;
  *(_QWORD *)(a1 + v31) = v174;
  v32 = *(char **)(v30 + 264);
  v175 = v32;
  *(_QWORD *)a8 = v32;
  v172 = 0;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v32, v26, &v172, (_DWORD *)(a8 + 8), v27, v28, v29);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v36 = 2305826825;
  v37 = v175;
  v38 = *(_DWORD *)(a8 + 8);
  v39 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v33, v34, v35, v38);
  if (v39 + v38 > v26)
    return v36;
  *(_QWORD *)(a8 + 16) = &v37[v39];
  v172 = v39 + v38;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, &v171, v40, v41, v42);
  if ((U32 & 0x80000000) != 0)
    return U32;
  *(_WORD *)(a8 + 24) = v171;
  v46 = (unsigned int *)(a8 + 28);
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 28), v43, v44, v45);
  if ((U32 & 0x80000000) != 0)
    return U32;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 32), v47, v48, v49);
  if ((U32 & 0x80000000) != 0)
    return U32;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 36), v50, v51, v52);
  if ((U32 & 0x80000000) != 0)
    return U32;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 40), v53, v54, v55);
  if ((U32 & 0x80000000) != 0)
    return U32;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, &v171, v56, v57, v58);
  if ((U32 & 0x80000000) != 0)
    return U32;
  *(_WORD *)(a8 + 46) = v171;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, &v171, v59, v60, v61);
  if ((U32 & 0x80000000) != 0)
    return U32;
  *(_WORD *)(a8 + 44) = v171;
  U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 48), v62, v63, v64);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v68 = v175;
  v69 = *v46;
  v70 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v65, v66, v67, *v46);
  v71 = v70 + v69;
  if (v71 > v26)
    return v36;
  *(_QWORD *)(a8 + 56) = &v68[v70];
  v72 = heap_Alloc(a2[1], 8 * *(unsigned int *)(a8 + 28));
  *(_QWORD *)(a8 + 1520) = v72;
  if (!v72)
  {
LABEL_61:
    v163 = a2[4];
    goto LABEL_62;
  }
  v77 = *v46;
  if ((int)(*v46 << 16) >= 1)
  {
    v78 = 0;
    do
    {
      v169 = v72;
      v79 = v175;
      v80 = v78;
      log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v74, v75, v76, 1);
      if (v71 + 1 <= v26)
        *(_QWORD *)(v169 + 8 * v80) = &v79[v71++];
      v72 = *(_QWORD *)(a8 + 1520);
      if (**(_BYTE **)(v72 + 8 * v80))
      {
        while (v175[v71++])
          ;
      }
      v78 = v80 + 1;
      v77 = *v46;
    }
    while ((__int16)*v46 > (__int16)(v80 + 1));
  }
  v172 = v71;
  U32 = hlp_GetU16Ptr((uint64_t)a2, (uint64_t)v175, v26, &v172, (2 * v77), (_QWORD *)(a8 + 64), v75, v76);
  if ((U32 & 0x80000000) != 0)
    return U32;
  U32 = hlp_GetU16Ptr((uint64_t)a2, (uint64_t)v175, v26, &v172, (2 * *(_DWORD *)(a8 + 28)), (_QWORD *)(a8 + 72), v82, v83);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v87 = v175;
  v88 = *(_DWORD *)(a8 + 32);
  v89 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v84, v85, v86, (v88 << 8));
  v93 = v89 + (v88 << 8);
  if (v93 > v26)
    return v36;
  *(_QWORD *)(a8 + 80) = &v87[v89];
  v94 = v175;
  v95 = *(_DWORD *)(a8 + 36);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v90, v91, v92, (v95 << 8));
  v99 = v93 + (v95 << 8);
  if (v99 > v26)
    return v36;
  *(_QWORD *)(a8 + 88) = &v94[v93];
  v100 = v175;
  v101 = *(_DWORD *)(a8 + 36);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v96, v97, v98, (v101 << 8));
  v105 = v99 + (v101 << 8);
  if (v105 > v26)
    return v36;
  *(_QWORD *)(a8 + 96) = &v100[v99];
  v106 = v175;
  v107 = *(_WORD *)(a8 + 46);
  v108 = 2 * (v107 & 0x7FFF);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v102, v103, v104, 2 * (v107 & 0x7FFF));
  if (v105 + v108 > v26)
    return v36;
  *(_QWORD *)(a8 + 104) = &v106[v105];
  v172 = v105 + v108;
  U32 = hlp_GetU32Ptr((uint64_t)a2, (uint64_t)v175, v26, &v172, 4 * (*(_WORD *)(a8 + 44) & 0x3FFFu), (_QWORD *)(a8 + 112), v109, v110);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v114 = v175;
  v115 = *(unsigned __int16 *)(a8 + 44);
  v116 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v111, v112, v113, *(unsigned __int16 *)(a8 + 44));
  v120 = v116 + v115;
  if (v120 > v26)
    return v36;
  *(_QWORD *)(a8 + 120) = &v114[v116];
  v121 = v175;
  v122 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v117, v118, v119, *(unsigned __int16 *)(a8 + 44));
  v126 = v120 + v122;
  if (v126 > v26)
    return v36;
  *(_QWORD *)(a8 + 128) = &v121[v120];
  v127 = v175;
  v128 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v123, v124, v125, *(unsigned __int16 *)(a8 + 44));
  v132 = v126 + v128;
  if (v132 > v26)
    return v36;
  *(_QWORD *)(a8 + 136) = &v127[v126];
  v133 = v175;
  v134 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v129, v130, v131, *(unsigned __int16 *)(a8 + 44));
  v138 = v132 + v134;
  if (v138 > v26)
    return v36;
  *(_QWORD *)(a8 + 144) = &v133[v132];
  v139 = v175;
  v140 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v135, v136, v137, *(unsigned __int16 *)(a8 + 44));
  v144 = v138 + v140;
  if (v144 > v26)
    return v36;
  *(_QWORD *)(a8 + 152) = &v139[v138];
  v145 = v175;
  v146 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v141, v142, v143, *(unsigned __int16 *)(a8 + 44));
  v150 = v144 + v146;
  if (v150 > v26)
    return v36;
  *(_QWORD *)(a8 + 160) = &v145[v144];
  v151 = v175;
  v152 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v147, v148, v149, *(unsigned __int16 *)(a8 + 44));
  v156 = v150 + v152;
  if (v156 > v26)
    return v36;
  *(_QWORD *)(a8 + 168) = &v151[v150];
  v157 = v175;
  v158 = *(_DWORD *)(a8 + 48);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v153, v154, v155, v158);
  if (v158 + v156 > v26)
    return v36;
  *(_QWORD *)(a8 + 176) = &v157[v156];
  v159 = heap_Calloc((_QWORD *)a2[1], *(__int16 *)(a8 + 24), 8);
  *(_QWORD *)(a8 + 1496) = v159;
  if (!v159)
    goto LABEL_61;
  v160 = heap_Calloc((_QWORD *)a2[1], *(__int16 *)(a8 + 24), 8);
  *(_QWORD *)(a8 + 1504) = v160;
  if (!v160)
    goto LABEL_61;
  v161 = heap_Calloc((_QWORD *)a2[1], (*(__int16 *)(a8 + 24) + 1), 2);
  *(_QWORD *)(a8 + 1416) = v161;
  if (!v161)
    goto LABEL_61;
  v162 = heap_Alloc(a2[1], 5 * (unsigned __int16)(*(_WORD *)(a8 + 46) + 1));
  *(_QWORD *)(a8 + 1512) = v162;
  v163 = a2[4];
  if (!v162)
  {
LABEL_62:
    log_OutPublic(v163, (uint64_t)"FE_DEPES", 42000, 0, v73, v74, v75, v76, v168);
    return 2305826826;
  }
  *(_WORD *)(a8 + 2088) = log_GetLogLevel(v163);
  __strcpy_chk();
  __strcat_chk();
  U32 = hlp_SetupNewFeatRefCnt(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)v176, *(_QWORD *)(a8 + 80), *(_DWORD *)(a8 + 32), &v173);
  if ((U32 & 0x80000000) != 0)
    return U32;
  v164 = v173;
  *(_QWORD *)(a8 + 2120) = *(_QWORD *)(v173 + 272);
  v165 = 112;
  if (!v170)
    v165 = 128;
  *(_QWORD *)(a1 + v165) = v164;
  __strcpy_chk();
  __strcat_chk();
  v36 = hlp_SetupNewFeatRefCnt(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)v176, *(_QWORD *)(a8 + 88), *(_DWORD *)(a8 + 36), &v173);
  if ((v36 & 0x80000000) == 0)
  {
    v166 = v173;
    *(_QWORD *)(a8 + 2128) = *(_QWORD *)(v173 + 272);
    if (v170)
      *(_QWORD *)(a1 + 104) = v166;
    else
      *(_QWORD *)(a1 + 120) = v166;
  }
  return v36;
}

uint64_t fe_depes_SetLayerUtf8(__int16 *a1, int a2, signed int a3, const void *a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;

  v10 = 2305826823;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62334, 712) & 0x80000000) != 0)
    return 2305826824;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_SetLayer", v11, v12, v13, v22);
  if (a4 && a3 < a1[92])
  {
    v10 = fe_depes_SetLayerExUtf8(a1, a2, a3, a4, a5);
    if ((v10 & 0x80000000) == 0)
      log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_SetLayer", v18, v19, v20, v23);
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v14, v15, v16, v17, v23);
  }
  return v10;
}

uint64_t fe_depes_SetLayerExUtf8(__int16 *a1, int a2, unsigned int a3, const void *a4, int a5)
{
  size_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v36;
  uint64_t v37;

  LODWORD(v5) = a5;
  v9 = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((v9 & 0x80000000) != 0)
    return 2305826824;
  v13 = v9;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_SetLayerEx", v10, v11, v12, v36);
  if (a4)
  {
    v17 = a1[92];
    if ((int)a3 < v17)
    {
      if (v5 >= 0x2710)
        v5 = 10000;
      else
        v5 = v5;
      v18 = (3 * v5);
      if ((int)v18 > a1[93])
      {
        if (v17 > 0)
        {
          v19 = 0;
          do
          {
            v20 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(*((_QWORD *)a1 + 20) + 8 * v19), (3 * v5));
            if (!v20)
              goto LABEL_40;
            *(_QWORD *)(*((_QWORD *)a1 + 20) + 8 * v19) = v20;
            if (*((_QWORD *)a1 + 9))
              *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 18) + 1496) + 8 * v19) = *(_QWORD *)(*((_QWORD *)a1 + 20)
                                                                                            + 8 * v19);
            if (*((_QWORD *)a1 + 10))
              *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 19) + 1496) + 8 * v19) = *(_QWORD *)(*((_QWORD *)a1 + 20)
                                                                                            + 8 * v19);
            if ((int)v18 > a1[93])
            {
              v25 = a1[93];
              do
                *(_BYTE *)(*(_QWORD *)(*((_QWORD *)a1 + 20) + 8 * v19) + v25++) = 32;
              while (v18 != v25);
            }
            v26 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(*((_QWORD *)a1 + 21) + 8 * v19), 4 * (3 * v5));
            if (!v26)
              goto LABEL_40;
            *(_QWORD *)(*((_QWORD *)a1 + 21) + 8 * v19) = v26;
            if (*((_QWORD *)a1 + 9))
              *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 18) + 1504) + 8 * v19) = *(_QWORD *)(*((_QWORD *)a1 + 21)
                                                                                            + 8 * v19);
            if (*((_QWORD *)a1 + 10))
              *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 19) + 1504) + 8 * v19) = *(_QWORD *)(*((_QWORD *)a1 + 21)
                                                                                            + 8 * v19);
            if ((int)v18 > a1[93])
              memset_pattern16((void *)(*(_QWORD *)(*((_QWORD *)a1 + 21) + 8 * v19) + 4 * a1[93]), &unk_1DEC65440, 4 * (v18 + ~a1[93]) + 4);
          }
          while (++v19 < a1[92]);
        }
        v27 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *((_QWORD *)a1 + 22), (3 * v5));
        if (!v27)
        {
LABEL_40:
          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42000, 0, v21, v22, v23, v24, v37);
          return 2305826826;
        }
        *((_QWORD *)a1 + 22) = v27;
        if (*((_QWORD *)a1 + 9))
          *(_QWORD *)(*((_QWORD *)a1 + 18) + 1560) = v27;
        if (*((_QWORD *)a1 + 10))
          *(_QWORD *)(*((_QWORD *)a1 + 19) + 1560) = v27;
        if ((int)v18 > a1[93])
        {
          v28 = a1[93];
          do
            *(_BYTE *)(*((_QWORD *)a1 + 22) + v28++) = 0;
          while (v18 != v28);
        }
        a1[93] = 3 * v5;
      }
      v29 = a3;
      memcpy(*(void **)(*((_QWORD *)a1 + 20) + 8 * a3), a4, v5);
      memset((void *)(*(_QWORD *)(*((_QWORD *)a1 + 20) + 8 * a3) + v5), 32, (unsigned __int16)a1[93] - (unint64_t)v5);
      if (a3)
      {
        v30 = a1[94];
        if (v30 >= (__int16)Utf8_LengthInUtf8chars(*(_QWORD *)(*((_QWORD *)a1 + 20) + 8 * v29), v5))
          goto LABEL_45;
      }
      else if ((unsigned __int16)a1[92] >= 2u)
      {
        v34 = 1;
        do
          memset(*(void **)(*((_QWORD *)a1 + 20) + 8 * v34++), 32, (unsigned __int16)a1[93]);
        while (v34 < (unsigned __int16)a1[92]);
      }
      a1[94] = Utf8_LengthInUtf8chars(*(_QWORD *)(*((_QWORD *)a1 + 20) + 8 * v29), v5);
LABEL_45:
      log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_SetLayerEx", v31, v32, v33, v37);
      return v13;
    }
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Layer %d not defined in depes grammar", v14, v15, v16, a3 + 1);
  return v13;
}

uint64_t fe_depes_SetMarker(uint64_t a1, int a2, const void *a3, int a4)
{
  size_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;

  LODWORD(v4) = a4;
  v7 = 2305826823;
  v8 = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((v8 & 0x80000000) != 0)
    return 2305826824;
  v12 = v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_SetMarker", v9, v10, v11, v21);
  if (v4 >= 0x2710)
    v4 = 10000;
  else
    v4 = v4;
  if (a3 && *(__int16 *)(a1 + 188) >= (__int16)v4)
  {
    memcpy(*(void **)(a1 + 176), a3, v4);
    bzero((void *)(*(_QWORD *)(a1 + 176) + v4), *(unsigned __int16 *)(a1 + 186) - (unint64_t)v4);
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_SetMarker", v17, v18, v19, v22);
    return v12;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v13, v14, v15, v16, v22);
  }
  return v7;
}

uint64_t fe_depes_GetLayerUtf8(uint64_t a1, int a2, unsigned int a3, _QWORD *a4, _WORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;

  v9 = 2305826823;
  v10 = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((v10 & 0x80000000) != 0)
    return 2305826824;
  v14 = v10;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_GetLayer", v11, v12, v13, v23);
  if (a4 && (int)a3 < *(__int16 *)(a1 + 184))
  {
    *a5 = Utf8_LengthInBytes(*(unsigned __int8 **)(*(_QWORD *)(a1 + 160) + 8 * a3), *(__int16 *)(a1 + 188));
    *a4 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * a3);
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_GetLayer", v19, v20, v21, v24);
    return v14;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v15, v16, v17, v18, v24);
  }
  return v9;
}

uint64_t fe_depes_GetNrLayers(_WORD *a1, int a2, _WORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;

  v5 = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((v5 & 0x80000000) != 0)
    return 2305826824;
  v9 = v5;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_GetNrLayers", v6, v7, v8, v14);
  *a3 = a1[92];
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_GetNrLayers", v10, v11, v12, v15);
  return v9;
}

uint64_t fe_depes_GetMarker(uint64_t a1, int a2, _QWORD *a3, _WORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;

  v7 = 2305826823;
  v8 = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((v8 & 0x80000000) != 0)
    return 2305826824;
  v12 = v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_GetMarker", v9, v10, v11, v18);
  if (a3)
  {
    *a4 = *(_WORD *)(a1 + 188);
    *a3 = *(_QWORD *)(a1 + 176);
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_GetMarker", v14, v15, v16, v19);
    return v12;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v13, v14, v15, v16, v19);
  }
  return v7;
}

double hlp_ExitData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v22 = 0;
  v23 = 0;
  if (a5 && (InitRsrcFunction(a1, a2, &v23) & 0x80000000) == 0 && (InitRsrcFunction(a3, a4, &v22) & 0x80000000) == 0)
  {
    if (*(_QWORD *)a5)
      brk_DataMapDeRefCnt(a1, a2, a3, a4, a6);
    v17 = *(_QWORD *)(a5 + 1496);
    if (v17)
    {
      heap_Free(*(_QWORD **)(v23 + 8), v17);
      *(_QWORD *)(a5 + 1496) = 0;
    }
    v18 = *(_QWORD *)(a5 + 1504);
    if (v18)
    {
      heap_Free(*(_QWORD **)(v23 + 8), v18);
      *(_QWORD *)(a5 + 1504) = 0;
    }
    v19 = *(_QWORD *)(a5 + 1416);
    if (v19)
    {
      heap_Free(*(_QWORD **)(v23 + 8), v19);
      *(_QWORD *)(a5 + 1416) = 0;
    }
    v20 = *(_QWORD *)(a5 + 1512);
    if (v20)
    {
      heap_Free(*(_QWORD **)(v23 + 8), v20);
      *(_QWORD *)(a5 + 1512) = 0;
    }
    v21 = *(_QWORD *)(a5 + 1520);
    if (v21)
    {
      heap_Free(*(_QWORD **)(v23 + 8), v21);
      *(_QWORD *)(a5 + 1520) = 0;
    }
    hlp_SetupNewFeatDeRefCnt(a1, a2, a3, a4, a7);
    hlp_SetupNewFeatDeRefCnt(a1, a2, a3, a4, a8);
    result = 0.0;
    *(_OWORD *)(a5 + 2120) = 0u;
  }
  return result;
}

uint64_t fe_depes_ExistModule(_QWORD *a1, int a2, char *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 exist;
  uint64_t v12;
  uint64_t v14;
  unsigned int v15;

  v15 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62334, 712) & 0x80000000) == 0)
  {
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ExistModule for %s", v5, v6, v7, (uint64_t)a3);
    if (a1[10])
    {
      exist = hlp_ExistModule(a3, a1[19], &v15);
      if (exist || !a1[9])
      {
        if (exist)
        {
          v12 = 1;
LABEL_12:
          log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ExistModule", v8, v9, v10, v14);
          return v12;
        }
        goto LABEL_11;
      }
    }
    else if (!a1[9])
    {
      goto LABEL_11;
    }
    if (hlp_ExistModule(a3, a1[18], &v15))
    {
      v12 = 2;
      goto LABEL_12;
    }
LABEL_11:
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Module sequence not found", v8, v9, v10, v14);
    v12 = 0;
    goto LABEL_12;
  }
  return 0;
}

BOOL hlp_ExistModule(char *a1, uint64_t a2, unsigned int *a3)
{
  char *i;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;

  *a3 = 0;
  for (i = *(char **)(a2 + 16); LH_stricmp(i, a1); i = (char *)(v8 + v11))
  {
    v7 = *a3;
    if (v7 >= *(_DWORD *)(a2 + 8))
      break;
    v8 = *(_QWORD *)(a2 + 16);
    v9 = strlen((const char *)(v8 + v7));
    v10 = v7 + v9 + ((~(_BYTE)v9 - (_BYTE)v7) & 3) + 1;
    *a3 = v10;
    v11 = v10 + *(_DWORD *)(v8 + v10) + 4;
    *a3 = v11;
  }
  return *a3 < *(_DWORD *)(a2 + 8);
}

uint64_t fe_depes_ExecModule(uint64_t a1, int a2, char *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  v5 = 2305826820;
  if ((safeh_HandleCheck(a1, a2, 62334, 712) & 0x80000000) != 0)
    return 2305826824;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ExecModule for %s", v6, v7, v8, (uint64_t)a3);
  if (*(_QWORD *)(a1 + 80))
    v5 = hlp_ExecModule(a3, *(_QWORD *)(a1 + 152), (__int16 *)(a1 + 188));
  if (*(_QWORD *)(a1 + 72) && (v5 & 0x1FFF) == 4)
    v5 = hlp_ExecModule(a3, *(_QWORD *)(a1 + 144), (__int16 *)(a1 + 188));
  if ((v5 & 0x80000000) != 0)
  {
    if ((v5 & 0x1FFF) == 4)
    {
      log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Module sequence not found", v10, v11, v12, v15);
    }
    else
    {
      if ((v5 & 0x1FFF) == 0xA)
        v13 = 42000;
      else
        v13 = 42005;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", v13, 0, v9, v10, v11, v12, v15);
    }
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ExecModule", v10, v11, v12, v15);
  return v5;
}

uint64_t hlp_ExecModule(char *a1, uint64_t a2, __int16 *a3)
{
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  uint64_t v11;
  _WORD *v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t result;
  unsigned int v20;
  _BYTE v21[100];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  if (!hlp_ExistModule(a1, a2, &v20))
    return 2305826820;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = strlen((const char *)(v5 + v20));
  v7 = v20 + v6 + ((~(_BYTE)v6 - (_BYTE)v20) & 3);
  v8 = *(unsigned int *)(v5 + v7 + 1);
  if ((_DWORD)v8)
  {
    v9 = v7 + 5;
    v10 = v21;
    v11 = v8;
    do
    {
      *v10++ = *(_BYTE *)(v5 + v9++);
      --v11;
    }
    while (v11);
  }
  *(_WORD *)(a2 + 1430) = 0;
  *(_BYTE *)(a2 + 1428) = 0;
  v12 = *(_WORD **)(a2 + 184);
  *(_WORD *)(a2 + 1410) = *v12;
  if ((*(__int16 *)(a2 + 24) & 0x80000000) == 0)
  {
    v13 = 0;
    v14 = *(_QWORD *)(a2 + 1416);
    do
      *(_WORD *)(v14 + 2 * v13++) = *v12;
    while (*(__int16 *)(a2 + 24) >= v13);
  }
  bzero(*(void **)(a2 + 1512), (5 * *(__int16 *)(a2 + 46) + 5));
  *(_DWORD *)(a2 + 1480) = 1;
  if (!(_DWORD)v8)
    return 0;
  v15 = v8 - 1;
  v16 = v21;
  do
  {
    v17 = v15;
    v18 = *v16++;
    result = INFERENCE_MAIN(a2, v18, 1, a3);
    if ((result & 0x80000000) != 0)
      break;
    v15 = v17 - 1;
  }
  while (v17);
  return result;
}

uint64_t fe_depes_SetcbInsMrk(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t result;

  result = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((result & 0x80000000) != 0)
    return 2305826824;
  if (a4 == 1)
    *(_DWORD *)(a1 + 192) = a3;
  else
    *(_DWORD *)(a1 + 196) = a3;
  return result;
}

uint64_t fe_depes_GetcbInsMrk(uint64_t a1, int a2, _DWORD *a3, int a4)
{
  uint64_t result;
  uint64_t v8;

  result = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((result & 0x80000000) != 0)
    return 2305826824;
  v8 = 196;
  if (a4 == 1)
    v8 = 192;
  *a3 = *(_DWORD *)(a1 + v8);
  return result;
}

uint64_t hlp_Utf8HashCode(const char *a1, _WORD *a2)
{
  unsigned int v4;
  uint64_t result;
  uint64_t v6;

  v6 = 0;
  v4 = strlen(a1);
  result = utf8_Utf8ToUtf32((uint64_t)a1, v4, 0, (uint64_t)&v6 + 4, 1u, &v6, 0);
  if ((result & 0x80000000) == 0)
    *a2 = BYTE4(v6) & 0x3F;
  return result;
}

uint64_t hlp_SetupNewFeatDeRefCnt(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t result;
  uint64_t ObjcForThisApi;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = 0;
  result = InitRsrcFunction(a1, a2, &v11);
  if ((result & 0x80000000) == 0)
  {
    result = InitRsrcFunction(a3, a4, &v10);
    if (a5)
    {
      if ((result & 0x80000000) == 0)
      {
        ObjcForThisApi = getObjcForThisApi(v11, v10);
        return objc_ReleaseObject(ObjcForThisApi, a5);
      }
    }
  }
  return result;
}

uint64_t fe_depes_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2305826817;
  result = 0;
  *a2 = &IFeDepes;
  return result;
}

uint64_t hlp_GetU32(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;

  v13 = hlp_AlignOffset(a1, *a4, 4, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  *a4 = v13;
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U32 at offset %u", v14, v15, v16, v13);
  v17 = *a4;
  if ((int)v17 + 4 > a3)
    return 2305826825;
  result = 0;
  *a5 = *(_DWORD *)(a2 + v17);
  *a4 += 4;
  return result;
}

uint64_t hlp_GetU16Ptr(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;

  *a4 = hlp_AlignOffset(a1, *a4, 2, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U16 buffer of size %u at offset %u", v14, v15, v16, a5);
  v17 = *a4;
  if ((int)v17 + (int)a5 > a3)
    return 2305826825;
  result = 0;
  *a6 = a2 + v17;
  *a4 = v17 + a5;
  return result;
}

uint64_t hlp_GetU32Ptr(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;

  *a4 = hlp_AlignOffset(a1, *a4, 4, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U32 buffer of size %u at offset %u", v14, v15, v16, a5);
  v17 = *a4;
  if ((int)v17 + (int)a5 > a3)
    return 2305826825;
  result = 0;
  *a6 = a2 + v17;
  *a4 = v17 + a5;
  return result;
}

uint64_t hlp_SetupNewFeatRefCnt(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, _QWORD *a8)
{
  uint64_t result;
  uint64_t ObjcForThisApi;
  uint64_t v18;
  _QWORD v19[6];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v21 = 0;
  v22 = 0;
  v20 = 0;
  result = InitRsrcFunction(a1, a2, &v22);
  if ((result & 0x80000000) == 0)
  {
    result = InitRsrcFunction(a3, a4, &v21);
    if ((result & 0x80000000) == 0)
    {
      v19[0] = a1;
      v19[1] = a2;
      v19[2] = a3;
      v19[3] = a4;
      v19[4] = a6;
      v19[5] = a7;
      ObjcForThisApi = getObjcForThisApi(v22, v21);
      result = objc_GetAddRefCountedObject(ObjcForThisApi, a5, (uint64_t (*)(_QWORD, _QWORD, uint64_t, __int128 *, uint64_t))hlp_SetupNewFeat_ObjcLoad, (void (*)(_QWORD, _QWORD, __int128 *))hlp_SetupNewFeat_ObjcClose, (uint64_t)v19, &v20);
      if ((result & 0x80000000) != 0)
        v18 = 0;
      else
        v18 = *(_QWORD *)(v20 + 32);
      *a8 = v18;
    }
  }
  return result;
}

uint64_t hlp_AlignOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v9 = a2;
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Offset before alignment is %u", a6, a7, a8, a2);
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Offset after alignment to %u bytes is %u", v11, v12, v13, a3);
  return (v9 + (_DWORD)a3 - 1) & -(int)a3;
}

uint64_t hlp_SetupNewFeat_ObjcLoad(_WORD *a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 v18;
  uint64_t v19;
  char *v20;
  unsigned __int16 v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  _BYTE *v25;
  unsigned int Utf8Symbol;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  _BYTE *v30;
  _BYTE *v31;
  uint64_t v32;
  int v33;
  char *v34;
  const char *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char __s2[6];
  unsigned __int16 v48;
  _OWORD v49[32];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v45 = 0;
  v46 = 0;
  inited = InitRsrcFunction(a1, a2, &v45);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(*(_WORD **)(a5 + 16), *(_QWORD *)(a5 + 24), &v46);
  if ((inited & 0x80000000) != 0)
    return inited;
  v9 = v45;
  v10 = *(_QWORD *)(a5 + 32);
  v11 = *(unsigned int *)(a5 + 40);
  v12 = heap_Calloc(*(_QWORD **)(v45 + 8), 1, 280);
  *(_QWORD *)(a4 + 32) = v12;
  if (!v12
    || (*(_QWORD *)(*(_QWORD *)(a4 + 32) + 272) = heap_Alloc(*(_QWORD *)(v9 + 8), 8 * v11),
        v17 = *(_QWORD *)(a4 + 32),
        !*(_QWORD *)(v17 + 272)))
  {
LABEL_27:
    v29 = 2305826826;
    log_OutPublic(*(_QWORD *)(v9 + 32), (uint64_t)"FE_DEPES", 42000, 0, v13, v14, v15, v16, v40);
    return v29;
  }
  if ((_DWORD)v11)
  {
    v40 = a3;
    v18 = 0;
    v43 = v11;
LABEL_7:
    v19 = heap_Alloc(*(_QWORD *)(v9 + 8), 512);
    if (v19)
    {
      v11 = v19;
      v44 = v18;
      v20 = (char *)(v10 + ((unint64_t)v18 << 8));
      memset(v49, 0, sizeof(v49));
      v21 = strlen(v20);
      v22 = 0;
      v23 = v21;
      v24 = (unsigned __int16)(v21 + 65);
      while (1)
      {
        v25 = (_BYTE *)heap_Alloc(*(_QWORD *)(v9 + 8), v24);
        *(_QWORD *)((char *)v49 + v22) = v25;
        if (!v25)
          break;
        *v25 = 0;
        v22 += 8;
        if (v22 == 512)
        {
          v41 = v10;
          v42 = a4;
          v48 = 64;
          Utf8Symbol = utf8_GetUtf8Symbol(v20, 0, v23, __s2);
          if (Utf8Symbol)
          {
            v27 = Utf8Symbol;
            v28 = 0;
            while (1)
            {
              v29 = hlp_Utf8HashCode(__s2, &v48);
              if ((v29 & 0x80000000) != 0)
                return v29;
              strcat(*((char **)v49 + v48), __s2);
              v28 += v27;
              v27 = utf8_GetUtf8Symbol(v20, v28, v23, __s2);
              if (!v27)
                goto LABEL_17;
            }
          }
          v29 = 0;
LABEL_17:
          v30 = (_BYTE *)heap_Alloc(*(_QWORD *)(v9 + 8), v24);
          a4 = v42;
          if (v30)
          {
            v31 = v30;
            v32 = 0;
            v33 = 0;
            *v30 = 0;
            do
            {
              v34 = &v31[(unsigned __int16)v33];
              *(_QWORD *)(v11 + v32) = v34;
              v35 = *(const char **)((char *)v49 + v32);
              strcpy(v34, v35);
              v36 = strlen(v35);
              v31[(unsigned __int16)(v33 + v36)] = 0;
              v33 += v36 + 1;
              v32 += 8;
            }
            while (v32 != 512);
            v37 = 0;
            v10 = v41;
            do
            {
              v38 = *(_QWORD *)((char *)v49 + v37);
              if (v38)
              {
                heap_Free(*(_QWORD **)(v9 + 8), v38);
                *(_QWORD *)((char *)v49 + v37) = 0;
              }
              v37 += 8;
            }
            while (v37 != 512);
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v42 + 32) + 272) + 8 * v44) = v11;
            v18 = v44 + 1;
            LODWORD(v11) = v43;
            if (v43 <= (unsigned __int16)(v44 + 1))
            {
              v17 = *(_QWORD *)(v42 + 32);
              goto LABEL_30;
            }
            goto LABEL_7;
          }
          goto LABEL_27;
        }
      }
    }
    goto LABEL_27;
  }
  v29 = 0;
LABEL_30:
  *(_QWORD *)(v17 + 256) = v10;
  *(_DWORD *)(*(_QWORD *)(a4 + 32) + 264) = v11;
  __strcpy_chk();
  return v29;
}

uint64_t hlp_SetupNewFeat_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int16 i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  v14 = 0;
  inited = InitRsrcFunction(a1, a2, &v14);
  if ((inited & 0x80000000) == 0)
  {
    v5 = *(_QWORD *)(a3 + 32);
    v6 = v14;
    v7 = *(_QWORD *)(v5 + 272);
    if (v7)
    {
      v8 = *(_DWORD *)(v5 + 264);
      if (v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(v7 + 8 * i);
          if (v10)
          {
            v11 = 0;
            while (1)
            {
              v12 = *(_QWORD *)(v10 + v11);
              if (v12)
                break;
              v11 += 8;
              if (v11 == 512)
                goto LABEL_11;
            }
            heap_Free(*(_QWORD **)(v6 + 8), v12);
            *(_QWORD *)(v10 + v11) = 0;
LABEL_11:
            heap_Free(*(_QWORD **)(v6 + 8), v10);
          }
        }
      }
      heap_Free(*(_QWORD **)(v6 + 8), v7);
      v6 = v14;
    }
    heap_Free(*(_QWORD **)(v6 + 8), v5);
  }
  return inited;
}

uint64_t fe_depes_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2305826823;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_depes_ClassClose()
{
  return 0;
}

unsigned __int8 **m2__fix__carray__len(unsigned __int8 **result, int *a2)
{
  unsigned __int8 *v2;
  int v3;
  int v4;

  if (*a2 <= 0)
  {
    v2 = *result;
    v3 = -1;
    do
    {
      v4 = *v2++;
      ++v3;
    }
    while (v4);
    *a2 = v3;
  }
  return result;
}

unsigned __int8 *m2__cp__str(unsigned __int8 *result, _BYTE *a2, int a3)
{
  uint64_t v3;
  char v4;
  int v5;

  if (a3 >= 1)
  {
    v3 = a3;
    while (1)
    {
      v5 = *result++;
      v4 = v5;
      if (!v5)
        break;
      *a2++ = v4;
      if (!--v3)
        return result;
    }
    *a2 = 0;
  }
  return result;
}

char *m2__cp__arr(char *result, _BYTE *a2, int a3)
{
  uint64_t v3;
  char v4;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      v4 = *result++;
      *a2++ = v4;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t mosyntkbsymtab_KnownGraphId(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  return kbsymtab_KnownGraphId(a2, a3);
}

uint64_t mosyntkbsymtab_KnownPhonId(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return kbsymtab_KnownPhonId(a2, a3);
}

uint64_t mosyntkbsymtab_KnownAtomId(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return kbsymtab_KnownAtomId(a2, a3);
}

uint64_t mosyntkbsymtab_KnownConsId(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return kbsymtab_KnownConsId(a2, a3);
}

uint64_t mosyntkbsymtab_GraphSymString(int a1, uint64_t a2, signed int a3, char *__dst, int a5)
{
  kbsymtab_GraphSymString(a2, a3, __dst, a5);
  return 0;
}

uint64_t mosyntkbsymtab_AtomSymString(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4, int a5)
{
  kbsymtab_AtomSymString(a2, a3, a4, a5);
  return 0;
}

uint64_t mosyntkbsymtab_ConsToString(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4, int a5)
{
  kbsymtab_ConsSymString(a2, a3, a4, a5);
  return 0;
}

uint64_t mosyntkbsymtab_PhonSymString(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4, int a5)
{
  kbsymtab_PhonSymString(a2, a3, a4, a5);
  return 0;
}

uint64_t mosyntkbsymtab_WriteGraphSym(uint64_t a1, uint64_t a2, signed int a3)
{
  _OWORD v5[12];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  kbsymtab_GraphSymString(a2, a3, (char *)v5, 0xC8uLL);
  return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
}

uint64_t mosyntkbsymtab_WritePhonSym(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  _OWORD v5[12];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  kbsymtab_PhonSymString(a2, a3, (char *)v5, 200);
  return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
}

uint64_t mosyntkbsymtab_WriteCons(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  _OWORD v5[12];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  kbsymtab_ConsSymString(a2, a3, (char *)v5, 200);
  return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
}

uint64_t mosyntkbsymtab_ConsFeatToComprConsFeatStr(uint64_t a1, int a2)
{
  uint64_t i;
  int v3;
  uint64_t v4;

  if (a2 >= 1)
  {
    for (i = 0; i != a2; ++i)
    {
      v3 = *(unsigned __int8 *)(a1 + i);
      if ((v3 - 40) < 2 || v3 == 44)
      {
        *(_BYTE *)(a1 + i) = 58;
      }
      else if (!*(_BYTE *)(a1 + i))
      {
        goto LABEL_10;
      }
    }
    LODWORD(i) = a2;
LABEL_10:
    v4 = (i - 2);
    if (i >= 2 && *(_BYTE *)(a1 + v4) == 40 && *(_BYTE *)(a1 + (i - 1)) == 41)
      *(_BYTE *)(a1 + v4) = 0;
  }
  return 0;
}

uint64_t mosyntkbsymtab_ComprConsFeatToConsFeatStr(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  char v6;
  char v7;

  if (a2 >= 1)
  {
    v2 = 0;
    v3 = 1;
    v4 = -1;
    LODWORD(v5) = a2;
    while (1)
    {
      if (*(_BYTE *)(a1 + v2) == 58)
      {
        if (v3)
          v6 = 40;
        else
          v6 = 44;
        *(_BYTE *)(a1 + v2) = v6;
        v4 = v2;
        v3 = 0;
      }
      else if (!*(_BYTE *)(a1 + v2))
      {
        LODWORD(v5) = v2;
        if ((v4 & 0x80000000) != 0)
          goto LABEL_16;
LABEL_15:
        v5 = v4;
        v7 = 41;
LABEL_20:
        *(_BYTE *)(a1 + v5) = v7;
        return 0;
      }
      if (a2 == ++v2)
      {
        if ((v4 & 0x80000000) != 0)
          goto LABEL_16;
        goto LABEL_15;
      }
    }
  }
  LODWORD(v5) = 0;
LABEL_16:
  if ((int)v5 + 2 < a2)
  {
    *(_WORD *)(a1 + v5) = 10536;
    LODWORD(v5) = v5 + 2;
  }
  if ((int)v5 < a2)
  {
    v7 = 0;
    v5 = (int)v5;
    goto LABEL_20;
  }
  return 0;
}

uint64_t mosyntkbsymtab_AppDecomprConsToString(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4, int a5, int *a6)
{
  BOOL v10;
  _OWORD v11[12];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  kbsymtab_ConsSymString(a2, a3, (char *)v11, 200);
  mosyntkbsymtab_ComprConsFeatToConsFeatStr((uint64_t)v11, 200);
  return mosyntbase_App(a4, a5, a6, (uint64_t)v11, 200, &v10);
}

uint64_t mosyntkbsymtab_AppConsFeatToString(uint64_t a1, uint64_t *a2, unsigned int a3, __int16 *a4, uint64_t a5, int a6, int *a7)
{
  uint64_t result;
  BOOL v13;
  _OWORD v14[12];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  kbsymtab_ConsSymString(a2, a3, (char *)v14, 200);
  result = mosyntbase_App(a5, a6, a7, (uint64_t)v14, 200, &v13);
  if ((result & 0x80000000) == 0)
    return AppFeatListToString(a2, a4, a5, a6, a7);
  return result;
}

uint64_t AppFeatListToString(uint64_t *a1, __int16 *a2, uint64_t a3, int a4, int *a5)
{
  uint64_t result;
  uint64_t v11;
  __int16 *v12;
  int v13;
  BOOL v14;
  _OWORD v15[12];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  result = mosyntbase_CApp(a3, a4, a5, "(", 0, &v14);
  if ((result & 0x80000000) == 0)
  {
    if (*a2 < 1)
    {
      return mosyntbase_CApp(a3, a4, a5, ")", 0, &v14);
    }
    else
    {
      v11 = 0;
      while (1)
      {
        if (v11)
        {
          result = mosyntbase_CApp(a3, a4, a5, ",", 0, &v14);
          if ((result & 0x80000000) != 0)
            break;
        }
        v12 = &a2[v11];
        v13 = v12[1];
        if (v13 < 0)
        {
          kbsymtab_AtomSymString(a1, -v13, (char *)v15, 200);
        }
        else
        {
          result = mosyntbase_CApp(a3, a4, a5, "?", 0, &v14);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntpal_IntToString(v12[1], 0, v15, 200);
          if ((result & 0x80000000) != 0)
            return result;
        }
        result = mosyntbase_App(a3, a4, a5, (uint64_t)v15, 200, &v14);
        if ((result & 0x80000000) != 0)
          return result;
        if (++v11 >= *a2)
          return mosyntbase_CApp(a3, a4, a5, ")", 0, &v14);
      }
    }
  }
  return result;
}

uint64_t mosyntkbsymtab_WriteFeatList(uint64_t a1, uint64_t *a2, __int16 *a3)
{
  uint64_t result;
  int v5;
  _OWORD v6[12];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v5 = 0;
  result = AppFeatListToString(a2, a3, (uint64_t)v6, 200, &v5);
  if ((result & 0x80000000) == 0)
    return mosyntbase_WString(a1, (unsigned __int8 *)v6, 200);
  return result;
}

uint64_t mosyntkbsymtab_WriteConsAndFeat(uint64_t a1, uint64_t *a2, unsigned int a3, __int16 *a4)
{
  uint64_t result;
  _OWORD v8[12];
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  kbsymtab_ConsSymString(a2, a3, (char *)v8, 200);
  result = mosyntbase_WString(a1, (unsigned __int8 *)v8, 200);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) == 0)
      return mosyntkbsymtab_WriteFeatList(a1, a2, a4);
  }
  return result;
}

uint64_t mosyntkbsymtab_GetConsFeatFromString(uint64_t a1, uint64_t *a2, int a3, unsigned __int8 *a4, int a5, signed int *a6, _DWORD *a7, __int16 *a8)
{
  uint64_t result;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  signed int v24;
  _OWORD v25[6];
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  v24 = 0;
  result = mosyntutils_GetIdentFromString(a1, a4, a5, a6, v25, 100);
  if ((result & 0x80000000) == 0)
  {
    v17 = kbsymtab_KnownConsId(a2, (uint64_t)v25);
    *a7 = v17;
    if (v17 < 0)
    {
      result = mosyntbase_WString3Ln(a1, "*** error: unknown constituent symbol '", 0, (unsigned __int8 *)v25, 100, "'", 0);
      if ((result & 0x80000000) != 0)
        return result;
      *a7 = 0;
    }
    result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
    if ((result & 0x80000000) == 0)
    {
      *a8 = 0;
      v18 = *a6;
      if ((int)v18 >= a5 || a4[v18] != 40)
        return mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
      result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x28u);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
        if ((result & 0x80000000) == 0)
        {
          v19 = *a6;
          if ((int)v19 >= a5 || a4[v19] == 41)
          {
LABEL_12:
            result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x29u);
            if ((result & 0x80000000) != 0)
              return result;
            return mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
          }
          while (1)
          {
            result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
            if ((result & 0x80000000) != 0)
              return result;
            if (a4[*a6] != 63)
            {
              result = mosyntutils_GetIdentFromString(a1, a4, a5, a6, v25, 100);
              if ((result & 0x80000000) != 0)
                return result;
              v21 = kbsymtab_KnownAtomId(a2, (uint64_t)v25);
              if ((v21 & 0x80000000) == 0)
              {
                v20 = -v21;
                goto LABEL_28;
              }
              result = mosyntbase_WString3Ln(a1, "*** error: unknown feature value '", 0, (unsigned __int8 *)v25, 100, "'", 0);
              goto LABEL_27;
            }
            if (!a3)
              break;
            result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x3Fu);
            if ((result & 0x80000000) != 0)
              return result;
            result = mosyntutils_GetCardFromString(a1, a4, a5, a6, &v24);
            if ((result & 0x80000000) != 0)
              return result;
            LOWORD(v20) = v24;
            if (v24 >= 50)
            {
              result = mosyntbase_WInt3Ln(a1, "*** error: illegal variable number '", 0, v24, "'", 0);
              goto LABEL_27;
            }
LABEL_28:
            result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
            if ((result & 0x80000000) != 0)
              return result;
            v22 = *a8;
            if (v22 > 8)
            {
              result = mosyntbase_WString3Ln(a1, "*** error: too many features in '", 0, a4, a5, "'", 0);
              if ((result & 0x80000000) != 0)
                return result;
            }
            else
            {
              a8[v22 + 1] = v20;
              ++*a8;
            }
            v23 = *a6;
            if ((int)v23 >= a5 || a4[v23] != 44)
              goto LABEL_12;
            result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x2Cu);
            if ((result & 0x80000000) != 0)
              return result;
          }
          result = mosyntbase_WStringLn(a1, "*** error: variables are not allowed as features'", 0);
LABEL_27:
          LOWORD(v20) = 0;
          if ((result & 0x80000000) != 0)
            return result;
          goto LABEL_28;
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbsymtab_DecompressCons(uint64_t a1, uint64_t *a2, unsigned int a3, _DWORD *a4, __int16 *a5)
{
  uint64_t IdentFromString;
  int v10;
  uint64_t v11;
  int v12;
  signed int v14;
  _OWORD v15[12];
  uint64_t v16;
  unsigned __int8 v17[96];
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  kbsymtab_ConsSymString(a2, a3, (char *)v15, 200);
  v14 = 0;
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  IdentFromString = mosyntutils_GetIdentFromString(a1, (unsigned __int8 *)v15, 200, &v14, v17, 100);
  if ((IdentFromString & 0x80000000) == 0)
  {
    v10 = kbsymtab_KnownConsId(a2, (uint64_t)v17);
    *a4 = v10;
    if (v10 < 0)
    {
      IdentFromString = mosyntbase_WString3Ln(a1, "*** error: unknown constituent symbol '", 0, v17, 100, "'", 0);
      if ((IdentFromString & 0x80000000) != 0)
        return IdentFromString;
      *a4 = 0;
    }
    *a5 = 0;
    if (v14 <= 199 && *((_BYTE *)v15 + v14) == 58)
    {
      IdentFromString = mosyntutils_CheckSkipCharInString(a1, (unsigned __int8 *)v15, 200, &v14, 0x3Au);
      if ((IdentFromString & 0x80000000) == 0 && v14 <= 199 && *((_BYTE *)v15 + v14))
      {
        while (1)
        {
          v11 = mosyntutils_GetIdentFromString(a1, (unsigned __int8 *)v15, 200, &v14, v17, 100);
          if ((v11 & 0x80000000) != 0)
            break;
          IdentFromString = mosyntutils_CheckSkipCharInString(a1, (unsigned __int8 *)v15, 200, &v14, 0x3Au);
          if ((IdentFromString & 0x80000000) != 0)
            return IdentFromString;
          if (*a5 > 8)
          {
            IdentFromString = mosyntbase_WString3Ln(a1, "*** error: too many features in '", 0, (unsigned __int8 *)v15, 200, "'", 0);
            if ((IdentFromString & 0x80000000) != 0)
              return IdentFromString;
          }
          else
          {
            v12 = kbsymtab_KnownAtomId(a2, (uint64_t)v17);
            if (v12 < 0)
            {
              IdentFromString = mosyntbase_WString3Ln(a1, "*** error: unknown feature value '", 0, v17, 100, "'", 0);
              LOWORD(v12) = 0;
              if ((IdentFromString & 0x80000000) != 0)
                return IdentFromString;
            }
            a5[++*a5] = -(__int16)v12;
          }
          if (v14 >= 200 || !*((_BYTE *)v15 + v14))
            return IdentFromString;
        }
        return v11;
      }
    }
  }
  return IdentFromString;
}

BOOL mosyntkbsymtab_PropTabAvailable(uint64_t a1)
{
  return kbsymtab_PropTabAvailable(a1);
}

uint64_t mosyntkbsymtab_IntPropValue(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4)
{
  return kbsymtab_IntPropValue(a2, a3, a4);
}

BOOL mosyntkbsymtab_HasIntPropValue(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, int a5)
{
  return kbsymtab_HasIntPropValue(a2, a3, a4, a5);
}

uint64_t mosyntkbsymtab_GetFirstAccPatVal(uint64_t a1, uint64_t **a2, int a3, int a4, uint64_t a5, _QWORD *a6)
{
  kbsymtab_GetFirstAccPatVal(a2, a3, a4, a5, a6);
  return 0;
}

uint64_t mosyntkbsymtab_GetNextAccPatVal(uint64_t **a1, _QWORD *a2)
{
  kbsymtab_GetNextAccPatVal(a1, a2);
  return 0;
}

uint64_t mosyntkbsymtab_DisposeAccPat(_QWORD *a1, _QWORD **a2)
{
  kbsymtab_DisposeAccPat(a1, a2);
  return 0;
}

uint64_t mosyntkbsymtab_GetFeatMatchedFirstIntPropVal(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int *a7)
{
  kbsymtab_GetFeatMatchedFirstIntPropVal(a2, a3, a4, a5, a6, a7);
  return 0;
}

uint64_t mosyntkbsymtab_GetFeatMatchedNextIntPropVal(uint64_t a1, uint64_t a2, int *a3)
{
  kbsymtab_GetFeatMatchedNextIntPropVal(a1, a2, a3);
  return 0;
}

uint64_t mosyntkbsymtab_GetLhPlusPhone(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int *a5, char *a6, int a7, _BYTE *a8)
{
  kbsymtab_GetLhPlusPhone(a2, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t mosyntwordana_ParseWord(uint64_t a1, int a2, uint64_t a3, int a4, char *a5, int a6, char *a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, char a14, char a15, char a16, BOOL *a17, _QWORD *a18)
{
  uint64_t v25;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t i;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  _WORD *v47;
  uint64_t j;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t *v52;
  int v53;
  __int128 v54;
  int v55;
  int64_t v56;
  uint64_t v57;
  unsigned int v58;
  unint64_t v59;
  int v60;
  unsigned int v61;
  _QWORD *v62;
  unsigned int v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t k;
  signed int v72;
  uint64_t v73;
  uint64_t m;
  BOOL v75;
  unint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t *v79;
  int v80;
  uint64_t *v81;
  uint64_t v83;
  int v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t *v87;
  int v88;
  _QWORD *v89;
  unint64_t v90;
  uint64_t v91;
  __int128 v92;
  unint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  uint64_t v100;
  _QWORD *v101;
  _QWORD *v102;
  uint64_t *v103;
  uint64_t v104;
  _QWORD *v105;
  unint64_t v106;
  int v107;
  int v108;
  uint64_t *v109;
  _QWORD *v110;
  void *__src;
  uint64_t v112;
  uint64_t v113;
  uint64_t v115;
  __int128 v116;
  __int128 v117;
  uint64_t v118;
  _WORD *v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  __int128 v123;
  uint64_t v124;
  _QWORD *v125;
  _WORD v126[504];
  _OWORD __dst[11];
  uint64_t v128;
  __int128 v129;
  uint64_t v130;
  uint64_t v131;

  v131 = *MEMORY[0x1E0C80C00];
  v115 = 0;
  memset(v126, 0, 512);
  v25 = *(_QWORD *)(a9 + 8);
  result = mosyntpal_ALLOCATE(a1, &v115, 0x8A8u);
  if ((result & 0x80000000) != 0)
    return result;
  v27 = 0;
  v28 = v115;
  *(_DWORD *)v115 = a2;
  *(_QWORD *)(v28 + 8) = a3;
  do
  {
    *(_QWORD *)(v115 + 8 * v27 + 16) = mosyntkblex_NilLexicon();
    *(_BYTE *)(v115 + v27 + 104) = 0;
    *(_QWORD *)(v115 + 8 * v27 + 120) = mosyntkblex_NilLexicon();
    *(_BYTE *)(v115 + v27++ + 208) = 0;
  }
  while (v27 != 11);
  v29 = v115;
  *(_DWORD *)(v115 + 220) = 0;
  *(_DWORD *)(v29 + 224) = a4;
  m2__cp__arr(a5, (_BYTE *)(v29 + 232), 80);
  v30 = v115;
  *(_DWORD *)(v115 + 312) = a6;
  m2__cp__arr(a7, (_BYTE *)(v30 + 320), 80);
  v32 = a1;
  v31 = (_QWORD *)v115;
  *(_QWORD *)(v115 + 400) = a8;
  v31[51] = v25;
  v31[52] = a10;
  result = mosyntdata_StartPhonList(a1, v31 + 62, v31 + 63);
  if ((result & 0x80000000) != 0)
    return result;
  v33 = v115;
  LODWORD(v120) = 0;
  if (a13 < 1)
  {
    v35 = 0;
  }
  else
  {
    v34 = 0;
    v35 = 0;
    LODWORD(v116) = 0;
    LODWORD(__dst[0]) = 0;
    BYTE4(__dst[0]) = 0;
    LOBYTE(v129) = 0;
    do
    {
      if (!*(_BYTE *)(a12 + v34))
        break;
      result = mosyntutils_GetUTF8Char(a1, a12, a13, (int *)&v120, &v116);
      if ((result & 0x80000000) != 0)
        return result;
      if ((_BYTE)v116)
      {
        result = mosyntbase_Copy((uint64_t)&v116, 4, (uint64_t)__dst, 5, (BOOL *)&v129);
        if ((result & 0x80000000) != 0)
          return result;
        v36 = mosyntkbsymtab_KnownGraphId(a1, *(_QWORD *)(v33 + 8), (unsigned __int8 *)__dst);
        if (v35 < 499)
        {
          v126[v35++] = v36;
        }
        else
        {
          result = mosyntbase_WStringLn(a1, "*** token too long; character ignored", 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
      }
      v34 = v120;
    }
    while ((int)v120 < a13);
    if (v35 > 499)
      goto LABEL_20;
  }
  v126[v35] = 0;
LABEL_20:
  v37 = v115;
  v38 = (_QWORD *)(v115 + 424);
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)(v115 + 424), 0x9C48u);
  if ((result & 0x80000000) != 0)
    return result;
  v118 = 0;
  v119 = 0;
  v116 = 0u;
  v117 = 0u;
  *(_QWORD *)&__dst[0] = 0;
  *(_DWORD *)(v37 + 432) = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)__dst, 0x80u);
  if ((result & 0x80000000) != 0)
    return result;
  v39 = *(_QWORD *)&__dst[0];
  **(_WORD **)&__dst[0] = 0;
  *(_DWORD *)(v39 + 4) = 3;
  *(_QWORD *)(v39 + 8) = 0;
  for (i = 16; i != 120; i += 8)
    *(_QWORD *)(*(_QWORD *)&__dst[0] + i) = 0;
  v41 = 0;
  v42 = *(_QWORD *)&__dst[0];
  *(_QWORD *)(*(_QWORD *)&__dst[0] + 120) = 0;
  **(_QWORD **)(v37 + 424) = v42;
  *(_QWORD *)(v37 + 440) = 0;
  *(_DWORD *)(v37 + 448) = 0;
  *(_QWORD *)(v37 + 456) = 0;
  *(_QWORD *)(v37 + 464) = 0;
  do
  {
    if (!v126[v41])
      break;
    ++v41;
  }
  while (v41 != 500);
  LODWORD(v43) = *(_DWORD *)(v37 + 432);
  if ((int)v43 + (int)v41 >= 5001)
  {
    result = mosyntbase_WriteDevelMessage(a1, "token too long; truncated",
               0,
               (unsigned __int8 *)&byte_1DEBD87CE,
               0,
               (unsigned __int8 *)&byte_1DEBD87CE,
               0,
               (unsigned __int8 *)&byte_1DEBD87CE,
               0,
               0,
               0,
               0);
    if ((result & 0x80000000) != 0)
      return result;
    LODWORD(v43) = *(_DWORD *)(v37 + 432);
    LODWORD(v41) = 5000 - v43;
  }
  if ((int)v41 <= 0)
  {
    v49 = (int)v43;
  }
  else
  {
    v44 = 0;
    v45 = v41;
    do
    {
      **(_WORD **)(*(_QWORD *)(v37 + 424) + 8 * (int)v43) = v126[v44];
      v46 = *(_DWORD *)(v37 + 220);
      result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v119, 0x80u);
      if ((result & 0x80000000) != 0)
        return result;
      v47 = v119;
      *v119 = 0;
      *((_DWORD *)v47 + 1) = v46 == 1;
      *((_QWORD *)v47 + 1) = 0;
      for (j = 8; j != 60; j += 4)
        *(_QWORD *)&v119[j] = 0;
      v43 = *(int *)(v37 + 432) + 1;
      *(_DWORD *)(v37 + 432) = v43;
      *(_QWORD *)(*(_QWORD *)(v37 + 424) + 8 * v43) = v119;
      ++v44;
    }
    while (v44 != v45);
    v49 = v43;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v37 + 424) + 8 * v49) + 4) = 3;
  *(_DWORD *)(v37 + 436) = 0;
  if ((int)v43 < 1)
  {
LABEL_157:
    DWORD2(v116) = 0;
    *(_QWORD *)&v117 = -1;
    DWORD2(v117) = -1;
    v118 = 0;
    result = mosyntdata_AddOutItem(v32, (_QWORD *)(v37 + 496), (uint64_t *)(v37 + 504), (uint64_t)&v116);
    if ((result & 0x80000000) == 0)
    {
      v96 = v115;
      *a17 = *(_DWORD *)(v115 + 488) > 0;
      *a18 = *(_QWORD *)(v96 + 496);
      if (a11 && *(int *)v96 >= 1)
      {
        v97 = (_QWORD *)(v96 + 496);
        while (1)
        {
          v97 = (_QWORD *)*v97;
          v96 = v115;
          if (!v97)
            break;
          result = mosyntdata_WriteReadingList(v32, *(uint64_t **)(v115 + 8), (uint64_t)(v97 + 2));
          if ((result & 0x80000000) != 0)
            return result;
        }
      }
      v98 = *(_QWORD **)(v96 + 440);
      if (v98)
      {
        while (1)
        {
          *(_QWORD *)&__dst[0] = v98;
          v98 = (_QWORD *)*v98;
          result = mosyntpal_DEALLOCATE(v32, (uint64_t *)__dst);
          if ((result & 0x80000000) != 0)
            break;
          if (!v98)
            goto LABEL_167;
        }
      }
      else
      {
LABEL_167:
        *(_QWORD *)(v96 + 440) = 0;
        *(_DWORD *)(v96 + 448) = 0;
        *(_QWORD *)(v96 + 456) = 0;
        if ((*(_DWORD *)(v96 + 432) & 0x80000000) != 0)
        {
LABEL_177:
          result = mosyntpal_DEALLOCATE(v32, (uint64_t *)(v96 + 424));
          if ((result & 0x80000000) == 0)
          {
            v102 = *(_QWORD **)(v96 + 464);
            if (v102)
            {
              while (1)
              {
                *(_QWORD *)&__dst[0] = v102;
                v102 = (_QWORD *)*v102;
                result = mosyntpal_DEALLOCATE(v32, (uint64_t *)__dst);
                if ((result & 0x80000000) != 0)
                  break;
                if (!v102)
                  goto LABEL_181;
              }
            }
            else
            {
LABEL_181:
              *(_QWORD *)(v96 + 464) = 0;
              return mosyntpal_DEALLOCATE(v32, &v115);
            }
          }
        }
        else
        {
          v99 = 0;
          while (1)
          {
            v100 = *(_QWORD *)(*(_QWORD *)(v96 + 424) + 8 * v99);
            result = mosyntdata_SetLexEleRefCounts(v32, *(_QWORD **)(v100 + 120));
            if ((result & 0x80000000) != 0)
              break;
            v101 = *(_QWORD **)(v100 + 120);
            if (v101)
            {
              *(_QWORD *)&__dst[0] = 0;
              do
              {
                result = mosyntdata_PruneLexEleBranch(v32, v101 + 2);
                if ((result & 0x80000000) != 0)
                  return result;
                *(_QWORD *)&__dst[0] = v101;
                v101 = (_QWORD *)*v101;
                result = mosyntpal_DEALLOCATE(v32, (uint64_t *)__dst);
                if ((result & 0x80000000) != 0)
                  return result;
              }
              while (v101);
            }
            *(_QWORD *)(v100 + 120) = 0;
            result = mosyntpal_DEALLOCATE(v32, (uint64_t *)(*(_QWORD *)(v96 + 424) + 8 * v99));
            if ((result & 0x80000000) != 0)
              return result;
            v75 = v99++ < *(int *)(v96 + 432);
            if (!v75)
              goto LABEL_177;
          }
        }
      }
    }
    return result;
  }
  v50 = 0;
  v51 = 0;
  v52 = (uint64_t *)(v37 + 480);
  v110 = (_QWORD *)(v37 + 496);
  __src = (void *)(v37 + 320);
  v109 = (uint64_t *)(v37 + 504);
  v53 = 2;
  v54 = 0uLL;
  v55 = 1;
  while (*(_DWORD *)(*(_QWORD *)(*v38 + 8 * v51) + 4) < 2u)
  {
LABEL_156:
    ++v51;
    ++v55;
    --v53;
    v50 += 8;
    if ((uint64_t)v51 >= (int)v43)
      goto LABEL_157;
  }
  v56 = (int)v43;
  if ((int)v43 <= v55)
    LODWORD(v57) = v55;
  else
    LODWORD(v57) = v43;
  v58 = v57 - 1;
  v59 = v51;
  while (1)
  {
    v60 = v59 + 1;
    if ((uint64_t)(v59 + 1) >= v56)
      break;
    v61 = *(_DWORD *)(*(_QWORD *)(*v38 + 8 + 8 * v59++) + 4);
    if (v61 >= 3)
    {
      v58 = v60 - 1;
      LODWORD(v57) = v60;
      break;
    }
  }
  *(_DWORD *)(v37 + 2212) = v51;
  v128 = 0;
  __dst[10] = v54;
  __dst[9] = v54;
  __dst[8] = v54;
  __dst[7] = v54;
  __dst[6] = v54;
  __dst[5] = v54;
  __dst[4] = v54;
  __dst[3] = v54;
  __dst[2] = v54;
  __dst[0] = v54;
  __dst[1] = v54;
  result = mosyntpal_ALLOCATE(a1, v52, 0x18u);
  if ((result & 0x80000000) != 0)
    return result;
  v122 = 0;
  v120 = 0u;
  v121 = 0u;
  v62 = (_QWORD *)*v52;
  v62[1] = 0;
  v62[2] = 0;
  *v62 = 0;
  if (v51 <= v57)
  {
    v63 = v58 + v53;
    v64 = (uint64_t *)(*v38 + v50);
    do
    {
      v65 = *v64++;
      *(_QWORD *)(v65 + 120) = 0;
      --v63;
    }
    while (v63);
  }
  *(_DWORD *)(v37 + 488) = 0;
  if (!a14)
    goto LABEL_61;
  if (*(int *)v37 > 1)
  {
    result = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WInt3Ln(a1, "analyzing as internal full-form starting at position ", 0, v51, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    if ((result & 0x80000000) != 0)
      return result;
  }
  if (*(int *)(v37 + 224) < 1)
  {
LABEL_61:
    v68 = *(_DWORD *)(v37 + 488);
    if (a15 && !v68)
    {
      if (*(int *)v37 > 1)
      {
        result = mosyntknowl_WriteTraceHeader(a1, 1u);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WInt3Ln(a1, "analyzing as morpheme sequence starting at position ", 0, v51, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        if ((result & 0x80000000) != 0)
          return result;
      }
      v69 = v50;
      v70 = *(unsigned int *)(v37 + 312);
      if ((int)v70 < 1)
        LODWORD(v70) = 0;
      else
        memcpy(__dst, __src, 8 * v70);
      for (k = 0; k != 11; ++k)
      {
        if (*(_BYTE *)(v37 + k + 208))
        {
          *((_QWORD *)__dst + (int)v70) = *(_QWORD *)(v37 + 8 * k + 120);
          LODWORD(v70) = v70 + 1;
        }
      }
      result = AnalyzeInParts(a1, v37, v51, v57, __dst, v70);
      if ((result & 0x80000000) != 0)
        return result;
      v68 = *(_DWORD *)(v37 + 488);
      v50 = v69;
    }
    v113 = v50;
    if (a16)
    {
      v52 = (uint64_t *)(v37 + 480);
      if (v68)
        goto LABEL_94;
      if ((int)v57 <= (int)v51)
        v72 = v51;
      else
        v72 = v57;
      if (v51 > v58)
        goto LABEL_149;
      if (*(int *)v37 > 1)
      {
        result = mosyntknowl_WriteTraceHeader(a1, 1u);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WInt3Ln(a1, "analyzing as submorpheme sequence starting at position ", 0, v51, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        if ((result & 0x80000000) != 0)
          return result;
      }
      v73 = *(unsigned int *)(v37 + 312);
      if ((int)v73 < 1)
        LODWORD(v73) = 0;
      else
        memcpy(__dst, __src, 8 * v73);
      for (m = 0; m != 11; ++m)
      {
        if (*(_BYTE *)(v37 + m + 208))
        {
          *((_QWORD *)__dst + (int)v73) = *(_QWORD *)(v37 + 8 * m + 120);
          LODWORD(v73) = v73 + 1;
        }
      }
      *((_QWORD *)__dst + (int)v73) = *(_QWORD *)(v37 + 400);
      result = AnalyzeInParts(a1, v37, v51, v72, __dst, (int)v73 + 1);
      if ((result & 0x80000000) != 0)
        return result;
      v68 = *(_DWORD *)(v37 + 488);
    }
    v52 = (uint64_t *)(v37 + 480);
LABEL_94:
    if (v68)
    {
      if (*(_QWORD *)(*(_QWORD *)(*v38 + 8 * v51) + 120))
      {
        result = mosyntbase_WriteDevelMessage(a1, "*** error: empty reading detected; check word grammar\\n",
                   0,
                   (unsigned __int8 *)&byte_1DEBD87CE,
                   0,
                   (unsigned __int8 *)&byte_1DEBD87CE,
                   0,
                   (unsigned __int8 *)&byte_1DEBD87CE,
                   0,
                   0,
                   0,
                   0);
        if ((result & 0x80000000) != 0)
          return result;
      }
      v75 = v51 > v58;
      v32 = a1;
      v50 = v113;
      if (!v75)
      {
        v57 = v57;
        v76 = v51;
        v104 = v57;
        v105 = v38;
        while (1)
        {
          ++v76;
          v77 = *(_QWORD *)(*v38 + 8 * v76);
          v78 = *(_QWORD **)(v77 + 120);
          if (v78)
          {
            v106 = v76;
            result = mosyntdata_SetLexEleRefCounts(v32, v78);
            if ((result & 0x80000000) != 0)
              return result;
            v79 = *(uint64_t **)(v77 + 120);
            if (v79)
            {
              v80 = -1;
              v81 = *(uint64_t **)(v77 + 120);
              do
              {
                if (*((_DWORD *)v81 + 3) < v80 || v80 == -1)
                  v80 = *((_DWORD *)v81 + 3);
                v81 = (uint64_t *)*v81;
              }
              while (v81);
              v83 = 0;
              *(_QWORD *)&v129 = *(_QWORD *)(v77 + 120);
              v84 = v80 + 20;
              do
              {
                v85 = (uint64_t *)*v79;
                if (*((_DWORD *)v79 + 3) <= v84)
                {
                  *v79 = v83;
                  v83 = v129;
                }
                else
                {
                  result = mosyntdata_PruneLexEleBranch(v32, v79 + 2);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntpal_DEALLOCATE(v32, (uint64_t *)&v129);
                  if ((result & 0x80000000) != 0)
                    return result;
                }
                *(_QWORD *)&v129 = v85;
                v79 = v85;
              }
              while (v85);
              *(_QWORD *)(v77 + 120) = v83;
              v57 = v104;
              v38 = v105;
              v50 = v113;
              v76 = v106;
              if ((result & 0x80000000) != 0)
                return result;
            }
            else
            {
              *(_QWORD *)(v77 + 120) = 0;
              v76 = v106;
            }
            if (*(int *)(v37 + 220) <= 1)
            {
              DWORD2(v120) = 0;
              v122 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v37 + 424) + 8 * v76) + 120);
              LODWORD(v121) = *(_DWORD *)(v37 + 2212);
              *(_QWORD *)((char *)&v121 + 4) = __PAIR64__(v76, v51);
              result = mosyntdata_AddOutItem(v32, v110, v109, (uint64_t)&v120);
              goto LABEL_121;
            }
            v86 = *(_QWORD *)(*(_QWORD *)(*v38 + 8 * v76) + 120);
            v125 = 0;
            if (v86)
            {
              *(_QWORD *)&v123 = 0;
              *(_QWORD *)&v129 = 0;
              WORD4(v129) = 0;
              do
              {
                v107 = *(_DWORD *)(v86 + 12);
                v108 = *(_DWORD *)(v86 + 8);
                v87 = *(uint64_t **)(v86 + 16);
                v103 = (uint64_t *)v86;
                if (v87)
                {
                  v88 = 0;
                  v112 = 0;
                  v89 = 0;
                  v90 = v76;
                  while (1)
                  {
                    result = mosyntkblex_GetEntryPhon(a1, v87 + 1, &v129, 10);
                    if ((result & 0x80000000) != 0)
                      return result;
                    if ((_BYTE)v129)
                    {
                      result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v123, 0x38u);
                      if ((result & 0x80000000) != 0)
                        return result;
                      *(_QWORD *)v123 = 0;
                      v91 = v123;
                      v92 = *(_OWORD *)(v87 + 3);
                      *(_OWORD *)(v123 + 8) = *(_OWORD *)(v87 + 1);
                      *(_OWORD *)(v91 + 24) = v92;
                      *(_WORD *)(v91 + 40) = *((_WORD *)v87 + 20);
                      v88 += *((__int16 *)v87 + 20);
                      if (v89)
                      {
                        *v89 = v91;
                        v91 = v123;
                      }
                      else
                      {
                        v112 = v91;
                      }
                      v93 = v90;
                    }
                    else
                    {
                      v93 = (v90 - v88);
                      if (v112)
                      {
                        if (v88 >= 1)
                        {
                          result = PutOutReadingItem(a1, v37, v108, v107, (int)v90 - v88, v90, v112, &v125);
                          if ((result & 0x80000000) != 0)
                            return result;
                        }
                      }
                      v91 = 0;
                      v112 = 0;
                      v88 = 0;
                      v107 = 0;
                      v108 = *((_DWORD *)v87 + 8);
                    }
                    v87 = (uint64_t *)*v87;
                    v90 = v93;
                    v89 = (_QWORD *)v91;
                    if (!v87)
                      goto LABEL_141;
                  }
                }
                v112 = 0;
                v88 = 0;
                LODWORD(v93) = v76;
LABEL_141:
                result = PutOutReadingItem(a1, v37, v108, v107, (int)v93 - v88, v93, v112, &v125);
                v38 = v105;
                v50 = v113;
                if ((result & 0x80000000) != 0)
                  return result;
                v86 = *v103;
                v76 = v106;
              }
              while (*v103);
              v94 = v125;
              v32 = a1;
              v57 = v104;
              if (!v125)
                goto LABEL_147;
              do
              {
                v95 = v94;
                v94 = (_QWORD *)*v94;
                *v95 = 0;
                result = mosyntdata_AppendItem(a1, v110, (_QWORD **)v109, v95);
              }
              while ((result & 0x80000000) == 0 && v94);
LABEL_121:
              v76 = v106;
              if ((result & 0x80000000) != 0)
                return result;
            }
          }
LABEL_147:
          v52 = (uint64_t *)(v37 + 480);
          if (v76 == v57)
            goto LABEL_154;
        }
      }
      goto LABEL_154;
    }
LABEL_149:
    v32 = a1;
    v50 = v113;
    if ((uint64_t)v51 >= *(int *)(v37 + 436)
      && !kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result)
      && (a16 || *(int *)v37 >= 1))
    {
      result = mosyntbase_WriteDevelMessage(a1, "*** no word analysis found starting at token position %d\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, v51, 0, 0);
      if ((result & 0x80000000) != 0)
        return result;
    }
LABEL_154:
    result = DisposeLexEleTreeList(v32, v52);
    if ((result & 0x80000000) != 0)
      return result;
    LODWORD(v43) = *(_DWORD *)(v37 + 432);
    v54 = 0uLL;
    goto LABEL_156;
  }
  v66 = 0;
  while (1)
  {
    v67 = *(_QWORD *)(v37 + 8 * v66 + 232);
    v129 = 0uLL;
    v130 = 0;
    result = mosyntkblex_StartLookup(v67, &v129);
    if ((result & 0x80000000) != 0)
      return result;
    v123 = v129;
    v124 = v130;
    result = GetAndTreatEntries(a1, v37, 1, 1, v51, v51, v57, 1, 1u, &v123, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int))GenFullFormReading);
    if ((result & 0x80000000) != 0)
      return result;
    if (++v66 >= *(int *)(v37 + 224))
      goto LABEL_61;
  }
}

uint64_t AnalyzeInParts(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4, _QWORD *a5, int a6)
{
  uint64_t v9;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *i;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  int v30;
  unsigned int v31;
  uint64_t **v32;
  _QWORD *v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36[2];
  int v37;
  __int128 v38;
  __int128 v39;

  v9 = a3;
  v34 = 0uLL;
  v35 = 0;
  v38 = 0u;
  v39 = 0u;
  if ((int)a3 <= a4)
  {
    v12 = a4 - a3 + 1;
    v13 = 8 * (int)a3;
    do
    {
      v14 = *(_QWORD *)(*(_QWORD *)(a2 + 424) + v13);
      *(_OWORD *)(v14 + 104) = 0uLL;
      *(_OWORD *)(v14 + 88) = 0uLL;
      *(_OWORD *)(v14 + 72) = 0uLL;
      *(_OWORD *)(v14 + 56) = 0uLL;
      *(_OWORD *)(v14 + 40) = 0uLL;
      *(_OWORD *)(v14 + 24) = 0uLL;
      *(_OWORD *)(v14 + 8) = 0uLL;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  v37 = 0;
  result = mosyntdata_GetNilLexItem((uint64_t)&v38);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntkbwgram_GetNFAStartState(*(_QWORD *)(a2 + 416), &v37);
    if ((result & 0x80000000) == 0)
    {
      v36[0] = v38;
      v36[1] = v39;
      result = InsertEntry(a1, a2, v9, v9, 1, v37, 1, 0, 0, v36);
      if ((result & 0x80000000) == 0 && (int)v9 <= a4)
      {
        v16 = (uint64_t *)(a2 + 464);
        v9 = (int)v9;
        v17 = a4 + 1;
LABEL_9:
        if (*(int *)a2 < 2
          || (result = mosyntknowl_WriteTraceHeader(a1, 1u), (result & 0x80000000) == 0)
          && (result = mosyntbase_WInt3Ln(a1, "parsing at position ", 0, v9, (unsigned __int8 *)&byte_1DEBD87CE, 0),
              (result & 0x80000000) == 0))
        {
          v30 = v17;
          v18 = *(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * v9);
          v19 = *(_QWORD *)(a2 + 464);
          if (!v19)
          {
            result = mosyntpal_ALLOCATE(a1, v16, 0x10u);
            if ((result & 0x80000000) != 0)
              return result;
            v19 = *v16;
            *(_QWORD *)*v16 = 0;
          }
          *(_QWORD *)(a2 + 472) = v19;
          while (1)
          {
            v18 = *(_QWORD *)(v18 + 8);
            if (!v18)
              break;
            result = AddTwolState(a1, a2, *(__int16 *)(v18 + 36));
            if ((result & 0x80000000) != 0)
              return result;
          }
          v29 = v16;
          v33 = a5;
          v31 = 1;
          while (2)
          {
            if (*(int *)a2 < 3
              || (result = mosyntknowl_WriteTraceHeader(a1, 1u), (result & 0x80000000) == 0)
              && (result = mosyntbase_WInt3Ln(a1, "epsilon closure run number ", 0, v31, (unsigned __int8 *)&byte_1DEBD87CE, 0), (result & 0x80000000) == 0))
            {
              *(_BYTE *)(a2 + 492) = 0;
              v21 = *(uint64_t **)(a2 + 464);
              v20 = *(uint64_t **)(a2 + 472);
              if (v21 != v20)
              {
                do
                {
                  v22 = v33;
                  v23 = a6;
                  if (a6 >= 1)
                  {
                    while (1)
                    {
                      result = mosyntkblex_StartLookup(*v22, &v34);
                      if ((result & 0x80000000) != 0)
                        return result;
                      v24 = *((__int16 *)v21 + 4);
                      v38 = v34;
                      *(_QWORD *)&v39 = v35;
                      result = GetAndTreatEntries(a1, a2, 1, 0, v9, v9, a4, v24, v24, &v38, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int))TreatLexEntryList);
                      if ((result & 0x80000000) != 0)
                        return result;
                      ++v22;
                      if (!--v23)
                      {
                        v20 = *(uint64_t **)(a2 + 472);
                        break;
                      }
                    }
                  }
                  v21 = (uint64_t *)*v21;
                }
                while (v21 != v20);
                ++v31;
                v21 = v20;
                if (*(_BYTE *)(a2 + 492))
                  continue;
              }
              if (*(int *)a2 >= 3)
              {
                result = mosyntknowl_WriteTraceHeader(a1, 1u);
                if ((result & 0x80000000) != 0)
                  return result;
                result = mosyntbase_WInt3Ln(a1, "non-empty search run in position ", 0, v9, (unsigned __int8 *)&byte_1DEBD87CE, 0);
                if ((result & 0x80000000) != 0)
                  return result;
                v21 = *(uint64_t **)(a2 + 472);
              }
              *(_BYTE *)(a2 + 492) = 0;
              for (i = *(uint64_t **)(a2 + 464); ; i = *v32)
              {
                v32 = (uint64_t **)i;
                if (i == v21)
                  break;
                v26 = v33;
                v27 = a6;
                if (a6 >= 1)
                {
                  while (1)
                  {
                    result = mosyntkblex_StartLookup(*v26, &v34);
                    if ((result & 0x80000000) != 0)
                      return result;
                    v28 = *((__int16 *)v32 + 4);
                    v38 = v34;
                    *(_QWORD *)&v39 = v35;
                    result = GetAndTreatEntries(a1, a2, 0, 1, v9, v9, a4, v28, v28, &v38, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int))TreatLexEntryList);
                    if ((result & 0x80000000) != 0)
                      return result;
                    ++v26;
                    if (!--v27)
                    {
                      v21 = *(uint64_t **)(a2 + 472);
                      break;
                    }
                  }
                }
              }
              if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * v9) + 4)
                || (result = FindReadings(a1, a2, v9), (result & 0x80000000) == 0))
              {
                RemoveUnreferenced(a2, v9);
                result = 0;
                ++v9;
                v17 = v30;
                a5 = v33;
                v16 = v29;
                if (v30 != (_DWORD)v9)
                  goto LABEL_9;
              }
            }
            break;
          }
        }
      }
    }
  }
  return result;
}

uint64_t GetAndTreatEntries(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, unsigned int a9, __int128 *a10, uint64_t (*a11)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int))
{
  uint64_t FirstSameInSymPair;
  uint64_t v19;
  int v20;
  uint64_t i;
  uint64_t v22;
  uint64_t v23;
  __int128 v26;
  uint64_t v27;
  BOOL v28;
  __int128 v29;
  uint64_t v30;
  int v31;
  char v32;
  uint64_t v33[2];

  v33[0] = 0;
  v29 = 0uLL;
  v30 = 0;
  v28 = 0;
  FirstSameInSymPair = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), 0, (uint64_t)v33, &v28);
  if ((FirstSameInSymPair & 0x80000000) == 0)
  {
    v32 = 0;
    v31 = 0;
    while (v28)
    {
      v19 = ApplyChar(a1, a2, a3, a4, a5, a6, v33[0], a8, a9, a10, a11, &v31, (uint64_t)&v29, &v32);
      if ((v19 & 0x80000000) != 0)
        return v19;
      if (v32)
      {
        v26 = v29;
        v27 = v30;
        v19 = GetAndTreatEntries(a1, a2, a3, a4, a5, a6, a7, a8, v31, &v26, a11);
        if ((v19 & 0x80000000) != 0)
          return v19;
      }
      FirstSameInSymPair = mosyntkbfst_GetNextSameInSymPair(*(_QWORD *)(a2 + 408), (int *)v33, &v28);
      if ((FirstSameInSymPair & 0x80000000) != 0)
        return FirstSameInSymPair;
    }
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * (int)a6) + 4))
    {
      v20 = mosyntkbsymtab_GraphTermId(*(_QWORD *)(a2 + 8));
      for (i = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), v20, (uint64_t)v33, &v28);
            ;
            i = mosyntkbfst_GetNextSameInSymPair(*(_QWORD *)(a2 + 408), (int *)v33, &v28))
      {
        FirstSameInSymPair = i;
        if ((i & 0x80000000) != 0)
          break;
        if (!v28)
          goto LABEL_18;
        if (mosyntkbfst_OutSym(*(_QWORD *)(a2 + 408), v33) == v20)
        {
          if (!v28)
            goto LABEL_18;
          v22 = ApplyChar(a1, a2, a3, a4, a5, a6, v33[0], a8, a9, a10, a11, &v31, (uint64_t)&v29, &v32);
          FirstSameInSymPair = v22;
          if ((_DWORD)a4 && (v22 & 0x80000000) == 0)
            goto LABEL_19;
          return FirstSameInSymPair;
        }
      }
    }
    else
    {
LABEL_18:
      if ((_DWORD)a4)
      {
LABEL_19:
        if ((int)a6 < (int)a7)
        {
          FirstSameInSymPair = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), **(_WORD **)(*(_QWORD *)(a2 + 424) + 8 * (int)a6), (uint64_t)v33, &v28);
          if ((FirstSameInSymPair & 0x80000000) == 0 && v28)
          {
            v23 = (a6 + 1);
            while (1)
            {
              v19 = ApplyChar(a1, a2, a3, a4, a5, v23, v33[0], a8, a9, a10, a11, &v31, (uint64_t)&v29, &v32);
              if ((v19 & 0x80000000) != 0)
                break;
              if (v32)
              {
                v26 = v29;
                v27 = v30;
                v19 = GetAndTreatEntries(a1, a2, a3, a4, a5, v23, a7, a8, v31, &v26, a11);
                if ((v19 & 0x80000000) != 0)
                  break;
              }
              FirstSameInSymPair = mosyntkbfst_GetNextSameInSymPair(*(_QWORD *)(a2 + 408), (int *)v33, &v28);
              if ((FirstSameInSymPair & 0x80000000) != 0 || !v28)
                return FirstSameInSymPair;
            }
            return v19;
          }
        }
      }
    }
  }
  return FirstSameInSymPair;
}

uint64_t GenFullFormReading(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, int a8, unsigned int a9)
{
  uint64_t result;
  __int16 v15;
  int v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  __int128 v22;
  int v23;
  int v24;
  char v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char v30;
  _QWORD *v31;
  uint64_t v32;
  _OWORD v33[31];
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v28 = 0uLL;
  v29 = 0;
  v26 = 0u;
  v27 = 0u;
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * a8) + 4))
    return 0;
  result = IsAcceptingFSTState(a1, a2, a9);
  if ((_DWORD)result)
  {
    v30 = 0;
    v25 = 0;
    v23 = 0;
    v24 = 0;
    result = mosyntkblex_GetFirstEntry(a5, &v30, &v28);
    if ((result & 0x80000000) == 0)
    {
      v15 = a8 - a6;
      while (v30)
      {
        result = mosyntkblex_GetEntryCostAndConsList(a1, &v28, &v23, v33, 500);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntdata_GetFirstLexItem(a1, *(uint64_t **)(a2 + 8), &v28, (uint64_t)v33, 500, &v24, &v25, (uint64_t)&v26);
          if ((result & 0x80000000) == 0)
          {
            while (v25)
            {
              v16 = v23;
              v17 = v27;
              v22 = v26;
              v31 = 0;
              v32 = 0;
              result = mosyntpal_ALLOCATE(a1, &v32, 0x38u);
              if ((result & 0x80000000) == 0)
              {
                *(_QWORD *)v32 = 0;
                v18 = v32;
                *(_OWORD *)(v32 + 8) = v22;
                *(_OWORD *)(v18 + 24) = v17;
                *(_WORD *)(v18 + 40) = v15;
                *(_DWORD *)(v18 + 48) = 1;
                result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v31, 0x18u);
                if ((result & 0x80000000) == 0)
                {
                  v19 = *(_QWORD *)(a2 + 424);
                  *v31 = *(_QWORD *)(*(_QWORD *)(v19 + 8 * a8) + 120);
                  v20 = v31;
                  *(_QWORD *)(*(_QWORD *)(v19 + 8 * a8) + 120) = v31;
                  *((_DWORD *)v20 + 2) = DWORD2(v17);
                  *((_DWORD *)v20 + 3) = v16;
                  v20[2] = v32;
                  if (*(_DWORD *)(a2 + 436) < a8)
                    *(_DWORD *)(a2 + 436) = a8;
                  ++*(_DWORD *)(a2 + 488);
                  result = mosyntdata_GetNextLexItem(a1, *(uint64_t **)(a2 + 8), &v28, (uint64_t)v33, 500, &v24, &v25, (uint64_t)&v26);
                  if ((result & 0x80000000) == 0)
                    continue;
                }
              }
              return result;
            }
            result = mosyntkblex_GetNextEntry(&v30, &v28);
            if ((result & 0x80000000) == 0)
              continue;
          }
        }
        return result;
      }
      result = mosyntkblex_FinishEntrySearch(&v28);
      if ((result & 0x80000000) == 0)
      {
        v21 = *(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * a8);
        if (*(_DWORD *)(v21 + 4) <= 1u)
        {
          result = 0;
          *(_DWORD *)(v21 + 4) = 2;
          return result;
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t ApplyChar(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, __int128 *a10, uint64_t (*a11)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int), int *a12, uint64_t a13, _BYTE *a14)
{
  uint64_t v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  uint64_t v24;
  signed int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  BOOL v30;
  unsigned int v32;
  unsigned int v33;
  char v35;
  uint64_t v36;

  v20 = 0;
  v36 = a7;
  *a14 = 0;
  if (*(int *)a2 >= 3)
  {
    v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntbase_WString(a1, "trying pair ", 0);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntkbfst_WriteGraphPair(a1, *(uint64_t **)(a2 + 8), *(_QWORD *)(a2 + 408), &v36, 2);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v20 = mosyntbase_WLn(a1);
    if ((v20 & 0x80000000) != 0)
      return v20;
  }
  v22 = mosyntkbfst_FSTTrans(*(_QWORD *)(a2 + 408), a9, &v36);
  *a12 = v22;
  if (v22 < 1)
    return v20;
  v23 = *a10;
  *(_QWORD *)(a13 + 16) = *((_QWORD *)a10 + 2);
  *(_OWORD *)a13 = v23;
  if (*(int *)a2 >= 3)
  {
    v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntbase_WString(a1, "looking up ", 0);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntkbfst_WriteGraphPair(a1, *(uint64_t **)(a2 + 8), *(_QWORD *)(a2 + 408), &v36, 1);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntbase_WLn(a1);
    if ((v21 & 0x80000000) != 0)
      return v21;
  }
  if (!mosyntkbfst_OutSym(*(_QWORD *)(a2 + 408), &v36))
  {
    if (*(int *)a2 >= 3)
    {
      v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
      if ((v21 & 0x80000000) != 0)
        return v21;
      v21 = mosyntbase_WString(a1, "looking up emtpy lex char", 0);
      if ((v21 & 0x80000000) != 0)
        return v21;
      v21 = mosyntbase_WLn(a1);
      if ((v21 & 0x80000000) != 0)
        return v21;
    }
    v35 = 1;
LABEL_34:
    *a14 = 1;
    return a11(a1, a2, a3, a4, a13, a5, a8, a6, *a12);
  }
  v33 = a6;
  v24 = *(_QWORD *)(a2 + 8);
  v25 = mosyntkbfst_OutSym(*(_QWORD *)(a2 + 408), &v36);
  v21 = mosyntkbsymtab_GraphSymString(a1, v24, v25, (char *)(a2 + 512), 500);
  if ((v21 & 0x80000000) != 0)
    return v21;
  if (*(int *)a2 >= 3)
  {
    v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntbase_WString(a1, "looking up ", 0);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntbase_WString(a1, (unsigned __int8 *)(a2 + 512), 500);
    if ((v21 & 0x80000000) != 0)
      return v21;
    v21 = mosyntbase_WLn(a1);
    if ((v21 & 0x80000000) != 0)
      return v21;
  }
  v26 = mosyntbase_Length(a2 + 512, 500);
  v35 = 1;
  a6 = a6;
  if (v26 < 1)
    goto LABEL_34;
  v32 = a8;
  v27 = v26;
  v28 = 512;
  while (1)
  {
    v20 = mosyntkblex_LookupChar(*(char *)(a2 + v28), a13, &v35);
    if ((v20 & 0x80000000) != 0)
      return v20;
    v29 = v28 - 511;
    ++v28;
    if (v35)
      v30 = v29 >= v27;
    else
      v30 = 1;
    if (v30)
    {
      a8 = v32;
      a6 = v33;
      if (v35)
        goto LABEL_34;
      return v20;
    }
  }
}

BOOL IsAcceptingFSTState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  BOOL v8;
  uint64_t v9;

  v9 = 0;
  v8 = 0;
  v6 = mosyntkbsymtab_GraphTermId(*(_QWORD *)(a2 + 8));
  mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), v6, (uint64_t)&v9, &v8);
  while (v8)
  {
    if (mosyntkbfst_OutSym(*(_QWORD *)(a2 + 408), &v9) == v6)
    {
      if (v8)
        return mosyntkbfst_FSTTrans(*(_QWORD *)(a2 + 408), a3, &v9) == 1;
      break;
    }
    mosyntkbfst_GetNextSameInSymPair(*(_QWORD *)(a2 + 408), (int *)&v9, &v8);
  }
  mosyntbase_WString(a1, "*** error: termination pair not found in FST alphabet", 0);
  mosyntbase_WLn(a1);
  return 0;
}

uint64_t AddTwolState(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;

  v4 = (_QWORD *)(a2 + 464);
  v5 = *(_QWORD *)(a2 + 472);
  while (1)
  {
    v4 = (_QWORD *)*v4;
    v8 = v4;
    if (v4 == (_QWORD *)v5)
      break;
    if (*((__int16 *)v4 + 4) == a3)
      return 0;
  }
  *(_WORD *)(v5 + 8) = a3;
  v7 = *(_QWORD **)v5;
  if (v7)
  {
    result = 0;
  }
  else
  {
    result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v8, 0x10u);
    if ((result & 0x80000000) != 0)
      return result;
    *v8 = 0;
    v7 = v8;
    **(_QWORD **)(a2 + 472) = v8;
  }
  *(_QWORD *)(a2 + 472) = v7;
  return result;
}

uint64_t TreatLexEntryList(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, signed int a6, unsigned int a7, uint64_t a8, unsigned int a9)
{
  uint64_t result;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t i;
  int v19;
  unsigned __int8 *v20;
  __int128 v21;
  __int128 v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  char v32;
  unsigned int v33;
  _OWORD v34[31];
  int v35;
  _QWORD v36[2];
  _QWORD v37[4];

  v37[2] = *MEMORY[0x1E0C80C00];
  if (a3 && (_DWORD)a8 == a6 || (result = 0, a4) && (int)a8 > a6)
  {
    v32 = 0;
    v31 = 0;
    v30 = 0uLL;
    v28 = 0u;
    v29 = 0u;
    v26 = 0;
    v27 = 0;
    v25 = 0;
    v36[1] = 0;
    v37[0] = 0;
    v36[0] = 0;
    *(_QWORD *)((char *)v37 + 6) = 0;
    v24 = 0;
    v23 = 0;
    v35 = 0;
    memset(v34, 0, sizeof(v34));
    result = mosyntkblex_GetFirstEntry(a5, &v32, &v30);
    if ((result & 0x80000000) == 0)
    {
      v15 = (unsigned __int8 *)(a2 + 1012);
      v16 = "found lex item";
      while (1)
      {
        if (!v32)
          return mosyntkblex_FinishEntrySearch(&v30);
        result = mosyntkblex_GetEntryCostAndConsList(a1, &v30, (char *)&v25 + 4, v34, 500);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntdata_GetFirstLexItem(a1, *(uint64_t **)(a2 + 8), &v30, (uint64_t)v34, 500, &v23, &v24, (uint64_t)&v28);
        if ((result & 0x80000000) != 0)
          return result;
LABEL_10:
        if (v24 && !kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result))
          break;
        result = mosyntkblex_GetNextEntry(&v32, &v30);
        if ((result & 0x80000000) != 0)
          return result;
      }
      if (*(int *)a2 < 2)
        goto LABEL_53;
      result = mosyntknowl_WriteTraceHeader(a1, 1u);
      if ((result & 0x80000000) == 0)
      {
        m2__cp__str(v16, v36, 30);
        v21 = v28;
        v22 = v29;
        result = mosyntkblex_GetEntryGraph(a1, &v21, v15, 1000);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WString(a1, (unsigned __int8 *)v36, 30);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WString(a1, " ", 0);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_WString(a1, v15, 1000);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntkblex_GetEntryPhon(a1, &v21, v15, 1000);
                if ((result & 0x80000000) == 0)
                {
                  result = mosyntbase_WString(a1, " [", 0);
                  if ((result & 0x80000000) == 0)
                  {
                    result = mosyntbase_WString(a1, v15, 1000);
                    if ((result & 0x80000000) == 0)
                    {
                      v33 = 0;
                      result = mosyntkblex_GetEntryCost(a1, &v21, &v33);
                      if ((result & 0x80000000) == 0)
                      {
                        result = mosyntbase_WString(a1, "] cons ", 0);
                        if ((result & 0x80000000) == 0)
                        {
                          result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), DWORD2(v22));
                          if ((result & 0x80000000) == 0)
                          {
                            if (v33 == 1
                              || (result = mosyntbase_WString(a1, "(cost ", 0), (result & 0x80000000) == 0)
                              && (result = mosyntbase_WInt(a1, v33, 0), (result & 0x80000000) == 0)
                              && (result = mosyntbase_WString(a1, ") ", 0), (result & 0x80000000) == 0))
                            {
                              result = mosyntbase_WString(a1, " from pos ", 0);
                              if ((result & 0x80000000) == 0)
                              {
                                result = mosyntbase_WInt(a1, a6, 0);
                                if ((result & 0x80000000) == 0)
                                {
                                  result = mosyntbase_WString(a1, " / FST state ", 0);
                                  if ((result & 0x80000000) == 0)
                                  {
                                    result = mosyntbase_WInt(a1, a7, 0);
                                    if ((result & 0x80000000) == 0)
                                    {
                                      result = mosyntbase_WString(a1, " to pos ", 0);
                                      if ((result & 0x80000000) == 0)
                                      {
                                        result = mosyntbase_WInt(a1, a8, 0);
                                        if ((result & 0x80000000) == 0)
                                        {
                                          result = mosyntbase_WString(a1, " / FST state ", 0);
                                          if ((result & 0x80000000) == 0)
                                          {
                                            result = mosyntbase_WInt(a1, a9, 0);
                                            if ((result & 0x80000000) == 0)
                                            {
                                              result = mosyntbase_WLn(a1);
                                              if ((result & 0x80000000) == 0)
                                              {
LABEL_53:
                                                result = mosyntkbwgram_GetFirstNFATrans(*(_QWORD *)(a2 + 416), DWORD2(v29), &v27, (char *)&v26 + 4, &v26, &v25);
                                                if ((result & 0x80000000) == 0)
                                                {
                                                  v20 = v15;
                                                  v17 = v16;
                                                  while ((v26 & 0x8000000000000000) == 0)
                                                  {
                                                    for (i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * a6)
                                                                        + 8 * ((int)(HIDWORD(v26) + a7) % 13)
                                                                        + 16); i; i = *(_QWORD *)(i + 16))
                                                    {
                                                      if (__PAIR64__(*(__int16 *)(i + 36), *(_DWORD *)(i + 32)) == __PAIR64__(a7, HIDWORD(v26)))
                                                      {
                                                        v19 = v25 + *(_DWORD *)(i + 40) + HIDWORD(v25);
                                                        v21 = v28;
                                                        v22 = v29;
                                                        result = InsertEntry(a1, a2, a6, a8, 0, v26, a9, v19, i, &v21);
                                                        if ((result & 0x80000000) != 0)
                                                          return result;
                                                      }
                                                    }
                                                    result = mosyntkbwgram_GetNextNFATrans(*(_QWORD *)(a2 + 416), DWORD2(v29), &v27, (char *)&v26 + 4, &v26, &v25);
                                                    if ((result & 0x80000000) != 0)
                                                      return result;
                                                  }
                                                  result = mosyntdata_GetNextLexItem(a1, *(uint64_t **)(a2 + 8), &v30, (uint64_t)v34, 500, &v23, &v24, (uint64_t)&v28);
                                                  v16 = v17;
                                                  v15 = v20;
                                                  if ((result & 0x80000000) == 0)
                                                    goto LABEL_10;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FindReadings(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *i;
  uint64_t v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;

  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 424) + 8 * a3) + 8);
  if (!v3)
    return 0;
  v25 = a3;
  while (!*(_BYTE *)(v3 + 38) || !IsAcceptingFSTState(a1, a2, *(__int16 *)(v3 + 36)))
  {
LABEL_30:
    v3 = *(_QWORD *)(v3 + 8);
    if (!v3)
      return 0;
  }
  v7 = 0;
  v26 = 0;
  v8 = v3;
  do
  {
    v9 = v8;
    *(_QWORD *)(v8 + 88) = v7;
    v8 = *(_QWORD *)(v8 + 48);
    v7 = v9;
  }
  while (v8);
  v10 = 0;
  v11 = 0;
  v27 = 0;
  v28 = 0;
  v12 = *(_QWORD **)(a2 + 480);
  while (1)
  {
    v13 = *(_QWORD *)(v9 + 48);
    if (v13)
    {
      if (*(unsigned __int16 *)(v13 + 30) != *(unsigned __int16 *)(v9 + 28))
      {
        v11 = mosyntbase_WriteDevelMessage(a1, "***** inconsistent word analysis reading\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
        if ((v11 & 0x80000000) != 0)
          return v11;
      }
    }
    if (mosyntdata_IsValidLexItem(v9 + 56))
    {
      for (i = (_QWORD *)*v12; ; i = (_QWORD *)i[1])
      {
        v28 = i;
        if (!i)
          break;
        v15 = i[2];
        if (v15)
        {
          v16 = mosyntdata_IdenticalLexItems(v15 + 8, v9 + 56);
          i = v28;
          if (v16)
          {
            if (v28)
            {
              v10 = v28[2];
              goto LABEL_23;
            }
            break;
          }
        }
      }
      v17 = mosyntpal_ALLOCATE(a1, &v27, 0x38u);
      if ((v17 & 0x80000000) != 0)
        return v17;
      *(_QWORD *)v27 = v12[2];
      v18 = v27;
      v19 = *(_OWORD *)(v9 + 72);
      *(_OWORD *)(v27 + 8) = *(_OWORD *)(v9 + 56);
      *(_OWORD *)(v18 + 24) = v19;
      *(_WORD *)(v18 + 40) = *(_WORD *)(v9 + 30) - *(_WORD *)(v9 + 28);
      v11 = mosyntpal_ALLOCATE(a1, (uint64_t *)&v28, 0x18u);
      if ((v11 & 0x80000000) != 0)
        return v11;
      v20 = v28;
      v28[1] = *v12;
      *v12 = v20;
      *v28 = 0;
      v10 = v27;
      i = v28;
      v28[2] = v27;
    }
    else
    {
      i = v12;
    }
LABEL_23:
    v9 = *(_QWORD *)(v9 + 88);
    v12 = i;
    if (!v9)
    {
      if ((v11 & 0x80000000) != 0)
        return v11;
      v17 = mosyntpal_ALLOCATE(a1, (uint64_t *)&v26, 0x18u);
      if ((v17 & 0x80000000) != 0)
        return v17;
      v21 = *(_QWORD *)(a2 + 424);
      *v26 = *(_QWORD *)(*(_QWORD *)(v21 + 8 * v25) + 120);
      v22 = v26;
      *(_QWORD *)(*(_QWORD *)(v21 + 8 * v25) + 120) = v26;
      *((_DWORD *)v22 + 2) = *(_DWORD *)(v3 + 32);
      *((_DWORD *)v22 + 3) = *(_DWORD *)(v3 + 40);
      v22[2] = v10;
      if (*(_DWORD *)(a2 + 436) < a3)
        *(_DWORD *)(a2 + 436) = a3;
      ++*(_DWORD *)(a2 + 488);
      v23 = *(_QWORD *)(v21 + 8 * v25);
      if (*(_DWORD *)(v23 + 4) <= 1u)
        *(_DWORD *)(v23 + 4) = 2;
      goto LABEL_30;
    }
  }
}

uint64_t RemoveUnreferenced(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;

  v2 = *(_QWORD *)(result + 424);
  v3 = *(_QWORD *)(v2 + 8 * a2);
  v4 = *(_QWORD *)(v3 + 8);
  if (v4)
  {
    do
    {
      v5 = v4;
      do
      {
        if (*(_DWORD *)(v5 + 24))
          break;
        v6 = *(_QWORD *)(v5 + 48);
        if (v6)
          --*(_DWORD *)(v6 + 24);
        *(_QWORD *)(v5 + 48) = 0;
        if (*(__int16 *)(v5 + 30) < a2)
        {
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(result + 456);
          *(_QWORD *)(result + 456) = v5;
        }
        v5 = v6;
      }
      while (v6);
      v4 = *(_QWORD *)(v4 + 8);
    }
    while (v4);
    v3 = *(_QWORD *)(v2 + 8 * a2);
    v7 = *(_QWORD *)(v3 + 8);
    if (v7)
    {
      do
      {
        v8 = *(_QWORD *)(v7 + 8);
        if (!*(_DWORD *)(v7 + 24))
        {
          *(_QWORD *)(v7 + 8) = *(_QWORD *)(result + 456);
          *(_QWORD *)(result + 456) = v7;
        }
        v7 = v8;
      }
      while (v8);
      v3 = *(_QWORD *)(v2 + 8 * a2);
    }
  }
  *(_QWORD *)(v3 + 8) = 0;
  for (i = 16; i != 120; i += 8)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 424) + 8 * a2) + i) = 0;
  return result;
}

uint64_t InsertEntry(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, int a6, int a7, int a8, uint64_t a9, __int128 *a10)
{
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  __int128 v30;
  int v31;
  uint64_t v32;
  _QWORD v33[5];

  v33[4] = *MEMORY[0x1E0C80C00];
  memset(v33, 0, 30);
  v16 = (a7 + a6) % 13;
  v17 = *(_QWORD *)(a2 + 424);
  v18 = *(_QWORD *)(*(_QWORD *)(v17 + 8 * (int)a4) + 8 * v16 + 16);
  v32 = v18;
  if (v18)
  {
    while (*(_DWORD *)(v18 + 32) != a6 || *(__int16 *)(v18 + 36) != a7)
    {
      v18 = *(_QWORD *)(v18 + 16);
      if (!v18)
      {
        v32 = 0;
        goto LABEL_6;
      }
    }
    if (*(_DWORD *)(v18 + 40) <= a8)
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(v18 + 40) = a8;
      v28 = *(_QWORD *)(v18 + 48);
      if (v28)
        --*(_DWORD *)(v28 + 24);
      *(_QWORD *)(v18 + 48) = a9;
      if (a9)
        ++*(_DWORD *)(a9 + 24);
      v29 = a3;
      *(_WORD *)(v18 + 28) = a3;
      v30 = *a10;
      *(_OWORD *)(v18 + 72) = a10[1];
      *(_OWORD *)(v18 + 56) = v30;
      result = TreatEmptyTrans(a1, a2, a4, v18);
      if ((result & 0x80000000) == 0)
      {
        if (*(int *)a2 < 2
          || (result = mosyntknowl_WriteTraceHeader(a1, 1u), (result & 0x80000000) == 0)
          && (m2__cp__str("modified edge", v33, 30),
              result = WriteParseEntry(a1, a2, (unsigned __int8 *)v33, v18, v29, a4),
              (result & 0x80000000) == 0))
        {
          *(_BYTE *)(a2 + 492) = 1;
        }
      }
    }
  }
  else
  {
LABEL_6:
    v19 = *(_QWORD *)(a2 + 456);
    if (v19)
    {
      v32 = *(_QWORD *)(a2 + 456);
      *(_QWORD *)(a2 + 456) = *(_QWORD *)(v19 + 8);
    }
    else
    {
      v31 = a5;
      v20 = a3;
      result = mosyntpal_ALLOCATE(a1, &v32, 0x60u);
      if ((result & 0x80000000) != 0)
        return result;
      *(_QWORD *)v32 = *(_QWORD *)(a2 + 440);
      v19 = v32;
      *(_QWORD *)(a2 + 440) = v32;
      ++*(_DWORD *)(a2 + 448);
      v17 = *(_QWORD *)(a2 + 424);
      a3 = v20;
      a5 = v31;
    }
    v22 = *(_QWORD *)(v17 + 8 * (int)a4);
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(v22 + 8);
    *(_QWORD *)(v22 + 8) = v19;
    v23 = v22 + 8 * v16;
    *(_QWORD *)(v19 + 16) = *(_QWORD *)(v23 + 16);
    *(_QWORD *)(v23 + 16) = v19;
    v24 = v32;
    *(_DWORD *)(v32 + 24) = 0;
    *(_WORD *)(v24 + 28) = a3;
    *(_WORD *)(v24 + 30) = a4;
    *(_DWORD *)(v24 + 32) = a6;
    *(_WORD *)(v24 + 36) = a7;
    *(_BYTE *)(v24 + 38) = 0;
    *(_DWORD *)(v24 + 40) = a8;
    *(_QWORD *)(v24 + 48) = a9;
    if (a9)
      ++*(_DWORD *)(a9 + 24);
    v25 = *a10;
    *(_OWORD *)(v24 + 72) = a10[1];
    *(_OWORD *)(v24 + 56) = v25;
    if ((_DWORD)a4 != a3 || a5 || (v26 = a3, result = AddTwolState(a1, a2, a7), a3 = v26, (result & 0x80000000) == 0))
    {
      if (*(int *)a2 < 2
        || (v27 = a3, result = mosyntknowl_WriteTraceHeader(a1, 1u), (result & 0x80000000) == 0)
        && (m2__cp__str("inserted edge", v33, 30),
            result = WriteParseEntry(a1, a2, (unsigned __int8 *)v33, v32, v27, a4),
            (result & 0x80000000) == 0))
      {
        *(_BYTE *)(a2 + 492) = 1;
        return TreatEmptyTrans(a1, a2, a4, v32);
      }
    }
  }
  return result;
}

uint64_t WriteParseEntry(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  uint64_t result;

  result = mosyntbase_WString(a1, a3, 30);
  if ((result & 0x80000000) == 0)
  {
    if (*(_QWORD *)(a4 + 48))
    {
      result = mosyntbase_WString(a1, " from position ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WInt(a1, a5, 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, " / state ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(_DWORD *)(*(_QWORD *)(a4 + 48) + 32));
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, " / FST state ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WInt(a1, *(__int16 *)(*(_QWORD *)(a4 + 48) + 36), 0);
      if ((result & 0x80000000) != 0)
        return result;
    }
    else
    {
      result = mosyntbase_WString(a1, " from inexistent predecessor", 0);
      if ((result & 0x80000000) != 0)
        return result;
    }
    result = mosyntbase_WString(a1, " to position ", 0);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WInt(a1, a6, 0);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, " / state ", 0);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(_DWORD *)(a4 + 32));
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WString(a1, " / FST state ", 0);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_WInt(a1, *(__int16 *)(a4 + 36), 0);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntbase_WString(a1, " cost ", 0);
                if ((result & 0x80000000) == 0)
                {
                  result = mosyntbase_WInt(a1, *(_DWORD *)(a4 + 40), 0);
                  if ((result & 0x80000000) == 0)
                    return mosyntbase_WLn(a1);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t TreatEmptyTrans(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  _OWORD v9[2];
  int v10;
  char v11;
  int v12;
  uint64_t v13;

  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  result = mosyntdata_GetNilLexItem((uint64_t)v9);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntkbwgram_GetFirstEpsTrans(*(_QWORD *)(a2 + 416), *(_DWORD *)(a4 + 32), &v13, &v12, &v11, &v10);
    if ((result & 0x80000000) == 0 && (v12 & 0x80000000) == 0)
    {
      do
      {
        if (v11)
          *(_BYTE *)(a4 + 38) = 1;
        result = InsertEntry(a1, a2, a3, a3, 1);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntkbwgram_GetNextEpsTrans(*(_QWORD *)(a2 + 416), *(_DWORD *)(a4 + 32), (unsigned int *)&v13, &v12, &v11, &v10);
        if ((result & 0x80000000) != 0)
          break;
      }
      while ((v12 & 0x80000000) == 0);
    }
  }
  return result;
}

uint64_t PutOutReadingItem(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, int a6, uint64_t a7, _QWORD *a8)
{
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v19 = 0;
  v20 = 0;
  result = mosyntpal_ALLOCATE(a1, &v19, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)v19 = 0;
    v17 = v19;
    *(_DWORD *)(v19 + 8) = a3;
    *(_DWORD *)(v17 + 12) = a4;
    *(_QWORD *)(v17 + 16) = a7;
    result = mosyntpal_ALLOCATE(a1, &v20, 0x28u);
    if ((result & 0x80000000) == 0)
    {
      v18 = v20;
      *(_DWORD *)(v20 + 8) = 0;
      *(_DWORD *)(v18 + 16) = *(_DWORD *)(a2 + 2212);
      *(_DWORD *)(v18 + 20) = a5;
      *(_DWORD *)(v18 + 24) = a6;
      *(_QWORD *)(v18 + 32) = v19;
      if ((a5 & 0x80000000) != 0)
      {
        result = mosyntbase_WriteDevelMessage(a1, "***** erroneous reading start position %d; reading ignored\\n",
                   0,
                   (unsigned __int8 *)&byte_1DEBD87CE,
                   0,
                   (unsigned __int8 *)&byte_1DEBD87CE,
                   0,
                   (unsigned __int8 *)&byte_1DEBD87CE,
                   0,
                   a5,
                   0,
                   0);
        if ((result & 0x80000000) == 0)
          return mosyntdata_DisposeItem(a1, &v20);
      }
      else
      {
        *(_QWORD *)v18 = *a8;
        *a8 = v20;
      }
    }
  }
  return result;
}

uint64_t DisposeLexEleTreeList(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v6;

  v3 = *a2;
  if (*a2)
  {
    v6 = 0;
    while (1)
    {
      result = DisposeLexEleTreeList(a1, v3);
      if ((result & 0x80000000) != 0)
        break;
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
      result = mosyntpal_DEALLOCATE(a1, &v6);
      if ((result & 0x80000000) != 0)
        break;
      if (!v3)
        goto LABEL_8;
    }
  }
  else
  {
    result = 0;
LABEL_8:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntknowl_GetPhraseBoundFromString(uint64_t a1, unsigned __int8 *a2, int a3, int *a4, _DWORD *a5)
{
  uint64_t result;

  *a5 = -1;
  result = mosyntutils_SkipBlanksInString((uint64_t)a2, a3, a4);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x23u);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x7Bu);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntutils_GetCardFromString(a1, a2, a3, a4, a5);
        if ((result & 0x80000000) == 0)
          return mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x7Du);
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_GetPhraseTypeFromString(uint64_t a1, unsigned __int8 *a2, int a3, int *a4, int *a5)
{
  uint64_t result;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *a5 = 0;
  result = mosyntutils_SkipBlanksInString((uint64_t)a2, a3, a4);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x28u);
    if ((result & 0x80000000) == 0)
    {
      v12 = 0;
      v11 = 0;
      result = mosyntutils_GetIdent1FromString(a1, a2, a3, a4, &v11, 10);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x29u);
        if ((result & 0x80000000) == 0)
          return mosyntkbaccphr_StringToPhraseType(a1, (unsigned __int8 *)&v11, 10, a5);
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_GetAccentFromString(uint64_t a1, unsigned __int8 *a2, int a3, int *a4, _DWORD *a5)
{
  uint64_t result;

  *a5 = -1;
  result = mosyntutils_SkipBlanksInString((uint64_t)a2, a3, a4);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x5Bu);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntutils_GetCardFromString(a1, a2, a3, a4, a5);
      if ((result & 0x80000000) == 0)
        return mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x5Du);
    }
  }
  return result;
}

uint64_t mosyntknowl_GetPhoneFromString(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, int a4, int *a5, int *a6)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t LhPlusPhone;
  int v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v12 = mosyntkbsymtab_LHPlusMode(a2);
  v13 = 0;
  *a6 = 0;
  v14 = *a5;
  if ((int)v14 < a4)
  {
    if (!a3[v14])
      return 0;
    v15 = v12;
    v13 = mosyntutils_SkipBlanksInString((uint64_t)a3, a4, a5);
    if ((v13 & 0x80000000) == 0)
    {
      v16 = *a5;
      if ((int)v16 < a4)
      {
        v17 = a3[v16];
        if (v17)
        {
          v25 = 0;
          memset(v28, 0, 15);
          v26 = 0;
          v27 = 0;
          if (v17 > 0x1F)
          {
            if (v15 == 1)
              LhPlusPhone = mosyntkbsymtab_GetLhPlusPhone(a1, a2, (uint64_t)a3, a4, a5, (char *)v28, 15, (_BYTE *)&v25 + 1);
            else
              LhPlusPhone = GetSVOXPAPhone(a1, (uint64_t)a3, a4, a5, v28, (char *)&v25 + 1);
            v13 = LhPlusPhone;
            if ((LhPlusPhone & 0x80000000) != 0)
              return v13;
            if (!HIBYTE(v25))
            {
              v20 = mosyntbase_WriteDevelMessage(a1, "***** unknown phone at pos %d in '%s'\\n", 0, a3, a4, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, *a5, 0, 0);
LABEL_23:
              v13 = v20;
              if ((v20 & 0x80000000) == 0)
                goto LABEL_24;
              return v13;
            }
            BYTE6(v28[1]) = 0;
            v23 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)v28);
            *a6 = v23;
            if (v23 > 0)
              return v13;
            return mosyntbase_WriteDevelMessage(a1, "***** unknown phone '%s'\\n", 0, (unsigned __int8 *)v28, 15, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
          }
          else
          {
            m2__cp__str("{c", v28, 15);
            v18 = mosyntpal_IntToString(a3[*a5], 0, &v26, 10);
            if ((v18 & 0x80000000) == 0)
            {
              v18 = mosyntbase_AppendTo((uint64_t)v28, 15, (uint64_t)&v26, 10, (BOOL *)&v25);
              if ((v18 & 0x80000000) == 0)
              {
                m2__cp__str("}", &v26, 10);
                v13 = mosyntbase_AppendTo((uint64_t)v28, 15, (uint64_t)&v26, 10, (BOOL *)&v25);
                if ((v13 & 0x80000000) != 0)
                  return v13;
                BYTE6(v28[1]) = 0;
                v19 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)v28);
                *a6 = v19;
                if (v19 > 0)
                {
LABEL_24:
                  ++*a5;
                  return v13;
                }
                v24 = a3[*a5];
                v20 = mosyntbase_WriteDevelMessage(a1, "***** error in conversion of control character %d to symbol\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, v24, HIDWORD(v24), 0);
                goto LABEL_23;
              }
            }
          }
          return v18;
        }
      }
    }
  }
  return v13;
}

uint64_t GetSVOXPAPhone(uint64_t a1, uint64_t a2, int a3, int *a4, _BYTE *a5, char *a6)
{
  int v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  unsigned int v16;
  BOOL v17;
  char v18;
  int v19;
  int v20;
  BOOL v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x1E0C80C00];
  memset(v22, 0, 14);
  v21 = 0;
  v19 = 0;
  v20 = 0;
  v12 = *a4;
  *a5 = 0;
  *a6 = 1;
  v13 = *a4;
  if ((int)v13 < a3 && *(_BYTE *)(a2 + v13) == 123)
  {
    result = mosyntutils_AppChar((uint64_t)a5, 15, &v20, 123);
    if ((result & 0x80000000) != 0)
      return result;
    v15 = *a4 + 1;
    *a4 = v15;
    if ((int)v15 < a3)
    {
      v16 = *(unsigned __int8 *)(a2 + v15);
      if (v16 >= 0x21)
      {
        while (v16 != 125)
        {
          result = mosyntutils_GetUTF8Char(a1, a2, a3, a4, &v19);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_App((uint64_t)a5, 15, &v20, (uint64_t)&v19, 4, &v21);
          if ((result & 0x80000000) != 0)
            return result;
          LODWORD(v15) = *a4;
          if (*a4 < a3)
          {
            v16 = *(unsigned __int8 *)(a2 + (int)v15);
            if (v16 >= 0x21)
              continue;
          }
          break;
        }
      }
    }
    if ((int)v15 >= a3 - 1 || *(_BYTE *)(a2 + (int)v15) != 125)
    {
      *a6 = 0;
LABEL_31:
      *a4 = v12;
      *a5 = 0;
      return result;
    }
    result = mosyntutils_AppChar((uint64_t)a5, 15, &v20, 125);
    if ((result & 0x80000000) == 0)
    {
      ++*a4;
      if (!*a6)
        goto LABEL_31;
    }
  }
  else
  {
    while (1)
    {
      result = GetSVOXPADiacPhone(a1, a2, a3, a4, v22, a6);
      if ((result & 0x80000000) != 0)
        break;
      result = mosyntbase_App((uint64_t)a5, 15, &v20, (uint64_t)v22, 14, &v21);
      if ((result & 0x80000000) != 0)
        break;
      if (*a6)
        v17 = !v21;
      else
        v17 = 1;
      v18 = !v17;
      *a6 = v18;
      if (v17)
        goto LABEL_31;
      if (*a4 >= a3)
        return result;
      if (*(_BYTE *)(a2 + *a4) != 95)
        return result;
      result = mosyntutils_AppChar((uint64_t)a5, 15, &v20, 95);
      if ((result & 0x80000000) != 0)
        return result;
      ++*a4;
    }
  }
  return result;
}

BOOL mosyntknowl_IsSentFinalPunct(uint64_t a1, unsigned int a2)
{
  return a2 > 8;
}

BOOL mosyntknowl_IsIntraSentPunct(uint64_t a1, int a2)
{
  return (a2 - 1) < 8;
}

uint64_t mosyntknowl_OrthPunctType(uint64_t a1, int a2)
{
  uint64_t result;

  result = 1;
  if (a2 > 57)
  {
    if ((a2 - 58) >= 2)
    {
      if (a2 == 63)
        return 10;
      return 0;
    }
  }
  else
  {
    if (a2 == 33)
      return 11;
    if (a2 != 44)
    {
      if (a2 == 46)
        return 9;
      return 0;
    }
  }
  return result;
}

uint64_t mosyntknowl_CopyFeatList(__int16 *a1, _WORD *a2)
{
  uint64_t v2;

  *a2 = *a1;
  if (*a1 >= 1)
  {
    v2 = 1;
    do
      a2[v2] = a1[v2];
    while (v2++ < *a1);
  }
  return 0;
}

uint64_t mosyntknowl_NewBindingDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  result = mosyntpal_ALLOCATE(a1, a2, 0x4B4u);
  if ((result & 0x80000000) == 0)
  {
    v4 = 0;
    v5 = *a2;
    do
    {
      *(_DWORD *)(v5 + 4 * v4) = v4;
      ++v4;
    }
    while (v4 != 150);
    *(_DWORD *)(v5 + 600) = 0;
  }
  return result;
}

uint64_t mosyntknowl_DisposeBindingDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  if (!*a2)
  {
    result = 0;
    goto LABEL_5;
  }
  result = mosyntpal_DEALLOCATE(a1, a2);
  if ((result & 0x80000000) == 0)
LABEL_5:
    *a2 = 0;
  return result;
}

BOOL mosyntknowl_DiffFeat(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  v3 = *a2;
  if (v3 != *a3)
    return 1;
  if (!(_WORD)v3 || (__int16)v3 < 1)
    return 0;
  if (a2[1] != a3[1])
    return 1;
  v4 = 0;
  do
  {
    v5 = v4;
    if ((__int16)v3 - 1 == v4)
      break;
    v6 = a2[v4 + 2];
    v7 = a3[v4++ + 2];
  }
  while (v6 == v7);
  return v5 + 1 < (unint64_t)(unsigned __int16)v3;
}

uint64_t mosyntknowl_Unif (uint64_t a1, uint64_t *a2, int a3, uint64_t a4, unsigned __int16 *a5, unsigned __int16 *a6, __int16 *a7, __int16 *a8, char *a9)
{
  uint64_t result;
  _DWORD *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  char v21;

  v21 = 0;
  if (a3 < 3)
  {
    Unify(a4, a5, a6, 50, &v21);
    if (v21)
    {
      result = GenRetFeat(a1, a4, a7, a8);
      if ((result & 0x80000000) != 0)
        return result;
LABEL_17:
      if (!a4)
      {
        v19 = 1;
LABEL_32:
        result = 0;
        *a9 = v19;
        return result;
      }
      v17 = (_DWORD *)(a4 + 600);
      if (*(int *)(a4 + 600) >= 1)
      {
        v18 = 0;
        do
        {
          *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v18)) = *(_DWORD *)(a4 + 604 + 4 * v18);
          ++v18;
        }
        while (v18 < *(int *)(a4 + 600));
      }
      v19 = 1;
LABEL_30:
      *v17 = 0;
      goto LABEL_32;
    }
LABEL_25:
    if (!a4)
    {
      v19 = 0;
      goto LABEL_32;
    }
    v17 = (_DWORD *)(a4 + 600);
    if (*(int *)(a4 + 600) >= 1)
    {
      v20 = 0;
      do
      {
        *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v20)) = *(_DWORD *)(a4 + 604 + 4 * v20);
        ++v20;
      }
      while (v20 < *(int *)(a4 + 600));
    }
    v19 = 0;
    goto LABEL_30;
  }
  result = mosyntbase_WString(a1, "      unifying sc1A", 0);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntkbsymtab_WriteFeatList(a1, a2, (__int16 *)a5);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WString(a1, "/sc1B", 0);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntkbsymtab_WriteFeatList(a1, a2, (__int16 *)a6);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WLn(a1);
          if ((result & 0x80000000) == 0)
          {
            Unify(a4, a5, a6, 50, &v21);
            if (v21)
            {
              result = GenRetFeat(a1, a4, a7, a8);
              if ((result & 0x80000000) != 0)
                return result;
              result = mosyntbase_WString(a1, "      returning ", 0);
              if ((result & 0x80000000) != 0)
                return result;
              result = mosyntkbsymtab_WriteFeatList(a1, a2, a7);
              if ((result & 0x80000000) != 0)
                return result;
              result = mosyntbase_WString(a1, " as ", 0);
              if ((result & 0x80000000) != 0)
                return result;
              result = mosyntkbsymtab_WriteFeatList(a1, a2, a8);
              if ((result & 0x80000000) != 0)
                return result;
              result = mosyntbase_WLn(a1);
              if ((result & 0x80000000) != 0)
                return result;
              goto LABEL_17;
            }
            result = mosyntbase_WString(a1, "      failed", 0);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_WLn(a1);
              if ((result & 0x80000000) == 0)
                goto LABEL_25;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t Unify(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, int a4, char *a5)
{
  unint64_t v5;
  unint64_t v6;
  char v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  *a5 = 0;
  v5 = *a2;
  if ((_DWORD)v5 == *a3)
  {
    if ((__int16)v5 < 1)
    {
      v7 = 1;
    }
    else
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = (__int16)a2[v6 + 1];
        if ((v8 & 0x80000000) == 0)
        {
          v9 = *(_DWORD *)(result + 4 * v8);
          do
          {
            v8 = v9;
            if ((v9 & 0x80000000) != 0)
              break;
            v9 = *(_DWORD *)(result + 4 * v9);
          }
          while (v9 != v8);
        }
        v10 = (__int16)a3[v6 + 1];
        if ((v10 & 0x80000000) == 0)
        {
          v11 = *(_DWORD *)(result + 4 * (v10 + a4));
          while (1)
          {
            v10 = v11;
            if ((v11 & 0x80000000) != 0)
              break;
            v11 = *(_DWORD *)(result + 4 * v11);
            if (v11 == v10)
            {
              *(_DWORD *)(result + 4 * v10) = v8;
              *(_DWORD *)(result + 4 * *(int *)(result + 600) + 604) = v10;
              goto LABEL_15;
            }
          }
        }
        if ((v8 & 0x80000000) != 0)
        {
          if (v8 != v10)
            v7 = 0;
        }
        else
        {
          *(_DWORD *)(result + 4 * v8) = v10;
          *(_DWORD *)(result + 4 * *(int *)(result + 600) + 604) = v8;
LABEL_15:
          ++*(_DWORD *)(result + 600);
        }
        ++v6;
      }
      while (v6 < v5 && v7);
    }
    *a5 = v7;
  }
  return result;
}

uint64_t GenRetFeat(uint64_t a1, uint64_t a2, __int16 *a3, _WORD *a4)
{
  uint64_t v8;
  uint64_t result;
  int v10;
  unsigned int v11;

  *a4 = *a3;
  if (*a3 >= 1)
  {
    v8 = 0;
    result = 0;
    while (1)
    {
      v10 = a3[v8 + 1];
      if (v10 < 0)
      {
LABEL_7:
        if (v10 >= 50)
        {
          result = mosyntbase_WStringLn(a1, "***** internal error: returned variable exceeds scope", 0);
          LOWORD(v10) = 0;
          if ((result & 0x80000000) != 0)
            return result;
        }
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 4 * v10);
        while (1)
        {
          v10 = v11;
          if ((v11 & 0x80000000) != 0)
            break;
          v11 = *(_DWORD *)(a2 + 4 * v11);
          if (v11 == v10)
            goto LABEL_7;
        }
      }
      a4[++v8] = v10;
      if (v8 >= *a3)
        return result;
    }
  }
  return 0;
}

uint64_t mosyntknowl_Unif2(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, __int16 *a5, __int16 *a6, __int16 *a7, __int16 *a8, __int16 *a9, __int16 *a10, char *a11)
{
  uint64_t result;
  _DWORD *v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  char v24;
  char v25;

  v24 = 0;
  if (a3 < 3)
    goto LABEL_11;
  result = mosyntbase_WString(a1, "      unifying sc1A", 0);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntkbsymtab_WriteFeatList(a1, a2, a5);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WString(a1, "/sc1B", 0);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntkbsymtab_WriteFeatList(a1, a2, a6);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WString(a1, " and sc2A", 0);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntkbsymtab_WriteFeatList(a1, a2, a7);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_WString(a1, "/sc2B", 0);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntkbsymtab_WriteFeatList(a1, a2, a8);
                if ((result & 0x80000000) == 0)
                {
                  result = mosyntbase_WLn(a1);
                  if ((result & 0x80000000) == 0)
                  {
LABEL_11:
                    v25 = 0;
                    Unify(a4, (unsigned __int16 *)a5, (unsigned __int16 *)a6, 50, &v25);
                    if (v25 && (Unify(a4, (unsigned __int16 *)a7, (unsigned __int16 *)a8, 100, &v24), v24))
                    {
                      result = GenRetFeat(a1, a4, a9, a10);
                      if ((result & 0x80000000) == 0)
                      {
                        if (a3 < 3
                          || (result = mosyntbase_WString(a1, "      returning ", 0), (result & 0x80000000) == 0)
                          && (result = mosyntkbsymtab_WriteFeatList(a1, a2, a9), (result & 0x80000000) == 0)
                          && (result = mosyntbase_WString(a1, " as ", 0), (result & 0x80000000) == 0)
                          && (result = mosyntkbsymtab_WriteFeatList(a1, a2, a10), (result & 0x80000000) == 0)
                          && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
                        {
                          if (!a4)
                          {
                            v22 = 1;
                            goto LABEL_36;
                          }
                          v20 = (_DWORD *)(a4 + 600);
                          if (*(int *)(a4 + 600) >= 1)
                          {
                            v21 = 0;
                            do
                            {
                              *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v21)) = *(_DWORD *)(a4 + 604 + 4 * v21);
                              ++v21;
                            }
                            while (v21 < *(int *)(a4 + 600));
                          }
                          v22 = 1;
                          goto LABEL_33;
                        }
                      }
                    }
                    else if (a3 < 3
                           || (result = mosyntbase_WString(a1, "      failed", 0), (result & 0x80000000) == 0)
                           && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
                    {
                      if (!a4)
                      {
                        v22 = 0;
                        goto LABEL_36;
                      }
                      v20 = (_DWORD *)(a4 + 600);
                      if (*(int *)(a4 + 600) >= 1)
                      {
                        v23 = 0;
                        do
                        {
                          *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v23)) = *(_DWORD *)(a4 + 604 + 4 * v23);
                          ++v23;
                        }
                        while (v23 < *(int *)(a4 + 600));
                      }
                      v22 = 0;
LABEL_33:
                      *v20 = 0;
LABEL_36:
                      result = 0;
                      *a11 = v22;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_CheckUnifiable(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, char *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = 0;
  *a4 = 0;
  result = mosyntpal_ALLOCATE(a1, &v11, 0x4B4u);
  if ((result & 0x80000000) == 0)
  {
    v9 = 0;
    v10 = v11;
    do
    {
      *(_DWORD *)(v10 + 4 * v9) = v9;
      ++v9;
    }
    while (v9 != 150);
    *(_DWORD *)(v10 + 600) = 0;
    if (v11)
    {
      Unify(v11, a2, a3, 50, a4);
      if (v11)
        return mosyntpal_DEALLOCATE(a1, &v11);
      else
        return 0;
    }
  }
  return result;
}

uint64_t mosyntknowl_WriteTraceHeader(uint64_t a1, unsigned int a2)
{
  if (a2 > 7)
    return 0;
  else
    return mosyntbase_WString(a1, (unsigned __int8 *)off_1EA93EC48[a2], 0);
}

uint64_t GetSVOXPADiacPhone(uint64_t a1, uint64_t a2, int a3, int *a4, _BYTE *a5, char *a6)
{
  uint64_t v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  char v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  BOOL v20;
  uint64_t v21;
  _WORD v22[7];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  *(_QWORD *)&v22[3] = 0;
  *(_QWORD *)((char *)v22 + 1) = 0;
  *a5 = 0;
  v18 = 0;
  v12 = *a4;
  v13 = *(unsigned __int8 *)(a2 + v12);
  if ((int)v12 < a3 && v13 == 94 || v13 == 126 || v13 == 61)
  {
    result = mosyntutils_AppChar((uint64_t)a5, 14, &v18, v13);
    if ((result & 0x80000000) != 0)
      return result;
    v15 = *a4 + 1;
    *a4 = v15;
    v13 = *(unsigned __int8 *)(a2 + v15);
  }
  LOBYTE(v22[0]) = 0;
  if (!v13)
    goto LABEL_15;
  v21 = 0;
  v20 = 0;
  result = mosyntutils_GetUTF8Char(a1, a2, a3, a4, (_BYTE *)&v21 + 4);
  if ((result & 0x80000000) != 0)
    return result;
  result = mosyntbase_App((uint64_t)v22, 14, (int *)&v21, (uint64_t)&v21 + 4, 4, &v20);
  if ((result & 0x80000000) != 0)
    return result;
  if (LOBYTE(v22[0]) < 0x21u
    || LOBYTE(v22[0]) - 58 <= 0x25 && ((1 << (LOBYTE(v22[0]) - 58)) & 0x3000000009) != 0
    || (v16 = 1, LOBYTE(v22[0]) - 123 <= 3) && LOBYTE(v22[0]) != 124)
  {
LABEL_15:
    v16 = 0;
    v22[0] = 33;
  }
  *a6 = v16;
  result = mosyntbase_App((uint64_t)a5, 14, &v18, (uint64_t)v22, 14, &v19);
  if ((result & 0x80000000) == 0)
  {
    v17 = *a4;
    if ((int)v17 < a3 && *(_BYTE *)(a2 + v17) == 58)
    {
      result = mosyntutils_AppChar((uint64_t)a5, 14, &v18, 58);
      if ((result & 0x80000000) == 0)
        ++*a4;
    }
  }
  return result;
}

uint64_t auxkbcommondef_RecallString(uint64_t a1, uint64_t a2, signed int a3, uint64_t a4, int a5)
{
  int v5;
  int v6;
  signed int v9;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  char v16;
  _BOOL4 v17;
  BOOL v18;
  uint64_t v19;
  uint64_t result;
  unint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  int v26;
  uint64_t v27;

  v9 = a3;
  v27 = *MEMORY[0x1E0C80C00];
  if ((a3 & 0x80000000) == 0 && *(_DWORD *)(a2 + 8) > a3
    || (result = mosyntbase_WString(a1, "*** error in dynamic array reading position: start ", 0),
        (result & 0x80000000) == 0)
    && (result = mosyntbase_WInt(a1, v9, 0), (result & 0x80000000) == 0)
    && (result = mosyntbase_WString(a1, ", length ", 0), (result & 0x80000000) == 0)
    && (result = mosyntbase_WInt(a1, 1u, 0), (result & 0x80000000) == 0)
    && (result = mosyntbase_WString(a1, ", actual data length: ", 0), (result & 0x80000000) == 0)
    && (result = mosyntbase_WInt(a1, *(_DWORD *)(a2 + 8), 0), (result & 0x80000000) == 0)
    && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
  {
    v12 = 0;
    v26 = 0;
    v25 = 0;
    v13 = v9 / 512;
    do
    {
      *(_DWORD *)((char *)&v25 + v12) = v13 - (v5 & 0xFFFFFFC0);
      v12 += 4;
      v13 /= 64;
    }
    while (v12 != 12);
    v14 = v9 % 512;
    v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v26 + 8) + 8 * SHIDWORD(v25) + 8)
                    + 8 * (int)v25
                    + 8);
    v16 = *(_BYTE *)(v15 + v9 % 512);
    v17 = a5 > 0;
    if (v16)
      v18 = a5 < 1;
    else
      v18 = 1;
    if (v18)
    {
      v19 = 0;
      if (*(_BYTE *)(v15 + v14))
        goto LABEL_31;
    }
    else
    {
      v21 = 0;
      do
      {
        *(_BYTE *)(a4 + v21) = v16;
        ++v9;
        if (v14 < 511)
        {
          ++v14;
        }
        else
        {
          v22 = 0;
          v26 = 0;
          v25 = 0;
          v23 = v9 / 512;
          do
          {
            *(_DWORD *)((char *)&v25 + v22) = v23 - (v6 & 0xFFFFFFC0);
            v22 += 4;
            v23 /= 64;
          }
          while (v22 != 12);
          v14 = v9 % 512;
          v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v26 + 8) + 8 * SHIDWORD(v25) + 8)
                          + 8 * (int)v25
                          + 8);
        }
        ++v21;
        v16 = *(_BYTE *)(v15 + v14);
        v17 = v21 < a5;
        if (v16)
          v24 = v21 >= a5;
        else
          v24 = 1;
      }
      while (!v24);
      v19 = v21;
      if (*(_BYTE *)(v15 + v14))
      {
LABEL_31:
        result = mosyntbase_WStringLn(a1, "*** RecallString: output array too small", 0);
        if ((result & 0x80000000) != 0)
          return result;
        goto LABEL_32;
      }
    }
    result = 0;
LABEL_32:
    if (v17)
      *(_BYTE *)(a4 + v19) = 0;
  }
  return result;
}

uint64_t accphr_LoadData(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  int v18;
  _OWORD *v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  int v25;
  _DWORD *v26;
  int v27;
  uint64_t v28;
  int *v29;
  int v30;
  uint64_t v31;
  int *v32;
  int v33;
  uint64_t v34;
  int *v35;
  int v36;
  uint64_t v37;
  int *v38;
  int v39;
  uint64_t v40;
  int *v41;
  int v42;
  uint64_t v43;
  int *v44;
  int v45;
  uint64_t v46;
  int *v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  int v51;
  unsigned __int8 v52;
  _DWORD *v53;
  unsigned int v54;
  _OWORD v55[16];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = 0;
  v49 = 0;
  memset(v55, 0, sizeof(v55));
  *a3 = 0;
  result = InitRsrcFunction(a1, a2, &v49);
  if ((result & 0x80000000) == 0)
  {
    result = kbaux_BuildBrokerString(v49, "accphr", (char *)v55, 0x100uLL);
    if ((result & 0x80000000) == 0)
    {
      v7 = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v55, "ACPH", 1031, (uint64_t *)&v48);
      if (v7 < 0)
      {
        v17 = v7;
      }
      else
      {
        v15 = v48;
        v16 = v49;
        v54 = 0;
        v53 = 0;
        v52 = 0;
        v51 = 0;
        v17 = ssftriff_reader_OpenChunk((uint64_t)v48, &v51, &v54, &v53, v11, v12, v13, v14);
        if ((v17 & 0x80000000) == 0 && !(v51 ^ 0x48504341 | v52))
        {
          v50 = 0;
          v17 = ssftriff_reader_DetachChunkData((uint64_t)v15, (uint64_t *)&v50, &v53, v10, v11, v12, v13, v14);
          if ((v17 & 0x80000000) == 0)
          {
            v18 = -1923080192;
            v19 = (_OWORD *)heap_Alloc(*(_QWORD *)(v16 + 8), 176);
            *a3 = (uint64_t)v19;
            if (v19)
            {
              v19[9] = 0u;
              v19[10] = 0u;
              v19[7] = 0u;
              v19[8] = 0u;
              v19[5] = 0u;
              v19[6] = 0u;
              v19[3] = 0u;
              v19[4] = 0u;
              v19[1] = 0u;
              v19[2] = 0u;
              *v19 = 0u;
              v20 = *a3;
              *(_DWORD *)v20 = v54;
              *(_QWORD *)(v20 + 16) = v50;
              v21 = v53;
              *(_QWORD *)(*a3 + 8) = v53;
              v22 = *a3;
              *(_DWORD *)(v22 + 24) = *v21;
              *(_DWORD *)(v22 + 28) = v21[1];
              v21 += 2;
              *(_QWORD *)(v22 + 64) = v21;
              v23 = &v21[*(int *)(*a3 + 28)];
              *(_QWORD *)(*a3 + 72) = v23;
              v24 = *a3;
              v25 = *(_DWORD *)(*a3 + 28);
              if (v25 >= 1)
              {
                do
                {
                  v23 += *v23 + 1;
                  --v25;
                }
                while (v25);
              }
              v27 = *v23;
              v26 = v23 + 1;
              *(_DWORD *)(v24 + 32) = v27;
              *(_QWORD *)(v24 + 80) = v26;
              v28 = *a3;
              v29 = &v26[3 * *(int *)(*a3 + 32)];
              v30 = *v29++;
              *(_DWORD *)(v28 + 36) = v30;
              *(_QWORD *)(v28 + 88) = v29;
              v31 = *a3;
              v32 = &v29[7 * *(int *)(*a3 + 36)];
              v33 = *v32++;
              *(_DWORD *)(v31 + 40) = v33;
              *(_QWORD *)(v31 + 96) = v32;
              v34 = *a3;
              v35 = &v32[3 * *(int *)(*a3 + 40)];
              v36 = *v35++;
              *(_DWORD *)(v34 + 44) = v36;
              *(_QWORD *)(v34 + 104) = v35;
              v37 = *a3;
              v38 = &v35[7 * *(int *)(*a3 + 44)];
              v39 = *v38++;
              *(_DWORD *)(v37 + 48) = v39;
              *(_QWORD *)(v37 + 112) = v38;
              v40 = *a3;
              v41 = &v38[16 * (uint64_t)*(int *)(*a3 + 48)];
              v42 = *v41++;
              *(_DWORD *)(v40 + 52) = v42;
              *(_QWORD *)(v40 + 120) = v41;
              v43 = *a3;
              v44 = &v41[4 * *(int *)(*a3 + 52)];
              v45 = *v44++;
              *(_DWORD *)(v43 + 56) = v45;
              *(_QWORD *)(v43 + 128) = v44;
              v46 = *a3;
              v47 = &v44[16 * (uint64_t)*(int *)(*a3 + 56)];
              *(_DWORD *)(v46 + 136) = *v47;
              *(_DWORD *)(v46 + 140) = v47[1];
              *(_DWORD *)(v46 + 144) = v47[2];
              *(_DWORD *)(v46 + 148) = v47[3];
              *(_DWORD *)(v46 + 152) = v47[4];
              *(_DWORD *)(v46 + 156) = v47[5];
              *(_DWORD *)(v46 + 160) = v47[6];
              v47 += 7;
              *(_QWORD *)(v46 + 168) = v47;
              if (v47[*(int *)(*a3 + 160)] == 1234567890)
                goto LABEL_13;
            }
            else
            {
              v18 = -1923080182;
            }
            ssftriff_reader_ReleaseChunkData(v50, v8, v9, v10, v11, v12, v13, v14);
            v8 = *a3;
            if (*a3)
            {
              heap_Free(*(_QWORD **)(v16 + 8), v8);
              *a3 = 0;
            }
            v17 = v18;
          }
        }
      }
LABEL_13:
      LODWORD(result) = ssftriff_reader_ObjClose(v48, v8, v9, v10, v11, v12, v13, v14);
      if (v17 >= 0)
        return result;
      else
        return v17;
    }
  }
  return result;
}

uint64_t accphr_UnloadData(_WORD *a1, int a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t inited;
  uint64_t v13;

  v13 = 0;
  if (!a3)
    return 2371887111;
  inited = InitRsrcFunction(a1, a2, &v13);
  if ((inited & 0x80000000) == 0)
  {
    if (*a3)
    {
      ssftriff_reader_ReleaseChunkData(*(_QWORD **)(*a3 + 16), v4, v5, v6, v7, v8, v9, v10);
      if (*a3)
      {
        heap_Free(*(_QWORD **)(v13 + 8), *a3);
        *a3 = 0;
      }
    }
  }
  return inited;
}

uint64_t accphr_Nil()
{
  return 0xFFFFFFFFLL;
}

uint64_t accphr_getAccPhrType(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 24);
  return result;
}

uint64_t accphr_getFunctionWords(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 144);
  else
    return 0xFFFFFFFFLL;
}

uint64_t accphr_getHierarchy(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 148);
  else
    return 0xFFFFFFFFLL;
}

uint64_t accphr_getDefaultEmph(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 140);
  else
    return 0xFFFFFFFFLL;
}

uint64_t accphr_getScenarios(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 156);
  else
    return 0xFFFFFFFFLL;
}

uint64_t accphr_getDomains(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 152);
  else
    return 0xFFFFFFFFLL;
}

uint64_t accphr_getFeatList(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  _DWORD *v9;
  int v10;

  result = 2371887111;
  if (a1 && (a2 & 0x80000000) == 0 && *(_DWORD *)(a1 + 28) > (signed int)a2)
  {
    v5 = *(_QWORD *)(a1 + 72);
    v6 = *(int *)(*(_QWORD *)(a1 + 64) + 4 * a2);
    v7 = *(unsigned int *)(v5 + 4 * v6);
    *a3 = v7;
    if ((int)v7 >= 1)
    {
      v8 = (int *)(v5 + 4 * v6 + 4);
      v9 = a3 + 1;
      do
      {
        v10 = *v8++;
        *v9++ = v10;
        --v7;
      }
      while (v7);
    }
    return 0;
  }
  return result;
}

uint64_t accphr_getConsList(int a1, uint64_t a2, int a3)
{
  uint64_t result;
  int v5;
  BOOL v6;
  int v7;
  char v8;
  int v9;
  char v10;

  result = 0;
  if (a1)
    v5 = -1;
  else
    v5 = 0;
  v6 = a1 == 1 || a1 == 0;
  if (a1 == 1)
    v7 = 1;
  else
    v7 = v5;
  v8 = a1 == 2 || v6;
  if (a1 == 2)
    v9 = 2;
  else
    v9 = v7;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v10 = v8 ^ 1;
    if (*(_DWORD *)(a2 + 32) <= a3)
      v10 = 1;
    if ((v10 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 80) + 4 * (v9 + 3 * a3));
  }
  return result;
}

uint64_t accphr_getNode(int a1, uint64_t a2, int a3)
{
  char v3;
  uint64_t v4;
  char v5;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      goto LABEL_6;
    case 5:
    case 7:
      a1 = 4;
      goto LABEL_6;
    case 6:
      a1 = 5;
      goto LABEL_6;
    case 8:
      a1 = 6;
LABEL_6:
      v3 = 1;
      break;
    default:
      v3 = 0;
      a1 = -1;
      break;
  }
  v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 36) <= a3)
      v5 = 1;
    if ((v5 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 88) + 4 * (a1 + 7 * a3));
  }
  return v4;
}

uint64_t accphr_getNodeMatchOp(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 36) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 88) + 4 * (7 * a2 + 1));
  }
  return result;
}

uint64_t accphr_getNodeNegated(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 36) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 88) + 28 * a2);
  }
  return result;
}

uint64_t accphr_getChildren(int a1, uint64_t a2, int a3)
{
  uint64_t result;
  int v5;
  BOOL v6;
  int v7;
  char v8;
  int v9;
  char v10;

  result = 0;
  if (a1)
    v5 = -1;
  else
    v5 = 0;
  v6 = a1 == 1 || a1 == 0;
  if (a1 == 1)
    v7 = 1;
  else
    v7 = v5;
  v8 = a1 == 2 || v6;
  if (a1 == 2)
    v9 = 2;
  else
    v9 = v7;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v10 = v8 ^ 1;
    if (*(_DWORD *)(a2 + 40) <= a3)
      v10 = 1;
    if ((v10 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 96) + 4 * (v9 + 3 * a3));
  }
  return result;
}

uint64_t accphr_getChildrenOpType(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 40) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 96) + 12 * a2);
  }
  return result;
}

uint64_t accphr_getInstr(int a1, uint64_t a2, int a3)
{
  char v3;
  uint64_t v4;
  char v5;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      v3 = 1;
      break;
    default:
      v3 = 0;
      a1 = -1;
      break;
  }
  v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 44) <= a3)
      v5 = 1;
    if ((v5 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 104) + 4 * (a1 + 7 * a3));
  }
  return v4;
}

uint64_t accphr_getInstrType(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 44) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 104) + 4 * (7 * a2 + 1));
  }
  return result;
}

uint64_t accphr_getInstrRight(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 44) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 104) + 4 * (7 * a2 + 4));
  }
  return result;
}

uint64_t accphr_getInstrTargetRange(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 44) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 104) + 4 * (7 * a2 + 3));
  }
  return result;
}

uint64_t accphr_getRule(int a1, uint64_t a2, int a3)
{
  char v3;
  uint64_t v4;
  char v5;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      v3 = 1;
      break;
    default:
      v3 = 0;
      a1 = -1;
      break;
  }
  v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 52) <= a3)
      v5 = 1;
    if ((v5 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 112) + 4 * (a1 + 16 * a3));
  }
  return v4;
}

uint64_t accphr_getFirstRule(uint64_t a1, int a2)
{
  if (a1)
    return *(unsigned int *)(*(_QWORD *)(a1 + 168) + 4 * (a2 % *(_DWORD *)(a1 + 160)));
  else
    return 0xFFFFFFFFLL;
}

uint64_t accphr_getRuleSet(int a1, uint64_t a2, int a3)
{
  char v3;
  uint64_t v4;
  char v5;

  switch(a1)
  {
    case 0:
    case 1:
      goto LABEL_6;
    case 2:
      v3 = 1;
      a1 = 1;
      break;
    case 3:
      a1 = 2;
      goto LABEL_6;
    case 4:
      a1 = 3;
LABEL_6:
      v3 = 1;
      break;
    default:
      v3 = 0;
      a1 = -1;
      break;
  }
  v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 52) <= a3)
      v5 = 1;
    if ((v5 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 120) + 4 * (a1 + 4 * a3));
  }
  return v4;
}

uint64_t accphr_getRuleSetIsSubset(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 52) <= a2)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a1 + 120) + 16 * a2);
  }
  return result;
}

uint64_t accphr_getScenario(int a1, uint64_t a2, int a3)
{
  int v3;
  char v4;
  uint64_t result;
  char v6;

  switch(a1)
  {
    case 0:
      v3 = 0;
      goto LABEL_7;
    case 1:
      v3 = 13;
      goto LABEL_7;
    case 2:
      v3 = 14;
      goto LABEL_7;
    case 3:
      v3 = 15;
LABEL_7:
      v4 = 1;
      break;
    default:
      v4 = 0;
      v3 = -1;
      break;
  }
  result = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    v6 = v4 ^ 1;
    if (*(_DWORD *)(a2 + 56) <= a3)
      v6 = 1;
    if ((v6 & 1) != 0)
      return 0;
    else
      return *(unsigned int *)(*(_QWORD *)(a2 + 128) + 4 * (v3 + 16 * a3));
  }
  return result;
}

uint64_t accphr_getScenarioNamePtr(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 56) <= a2)
      return 0;
    else
      return *(_QWORD *)(a1 + 128) + 64 * a2;
  }
  return result;
}

uint64_t mosyntutils_DetUTF8Length(uint64_t a1, unsigned int a2)
{
  if ((int)a2 > -9)
    return 1;
  if (a2 > 0xFFFFFFEF)
    return 4;
  if (a2 > 0xFFFFFFDF)
    return 3;
  if (a2 > 0xFFFFFFBF)
    return 2;
  mosyntbase_WriteDevelMessage(a1, "DetUTF8Length: malformed UTF8 string starting with %d", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, a2, 0, 0);
  return 1;
}

uint64_t mosyntutils_GetUTF8Char(uint64_t a1, uint64_t a2, int a3, int *a4, _BYTE *a5)
{
  uint64_t v5;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;

  *a5 = 0;
  v5 = *a4;
  if ((int)v5 < a3)
  {
    v10 = mosyntutils_DetUTF8Length(a1, *(char *)(a2 + v5));
    v11 = 0;
    v12 = v10;
    v13 = *a4;
    do
    {
      v14 = v11;
      if (v13 >= a3)
      {
        v12 = v11;
        goto LABEL_8;
      }
      a5[v11] = *(_BYTE *)(a2 + v13);
      v13 = *a4 + 1;
      *a4 = v13;
      ++v11;
    }
    while (v10 != v14 + 1);
    if (v14 > 2)
      return 0;
LABEL_8:
    a5[v12] = 0;
  }
  return 0;
}

uint64_t mosyntutils_AppChar(uint64_t a1, int a2, int *a3, char a4)
{
  BOOL v5;
  _BYTE v6[2];

  v5 = 0;
  v6[0] = a4;
  v6[1] = 0;
  return mosyntbase_App(a1, a2, a3, (uint64_t)v6, 2, &v5);
}

uint64_t mosyntutils_SkipBlanksInString(uint64_t a1, int a2, int *a3)
{
  int v3;
  unsigned __int8 *v4;
  int v5;

  v3 = *a3;
  if (*a3 < a2)
  {
    v4 = (unsigned __int8 *)(a1 + v3);
    do
    {
      v5 = *v4++;
      if (v5 != 32)
        break;
      *a3 = ++v3;
    }
    while (a2 != v3);
  }
  return 0;
}

uint64_t mosyntutils_CheckSkipCharInString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, unsigned __int8 a5)
{
  signed int v8;
  uint64_t result;
  unsigned __int8 v10[2];

  v8 = *a4;
  if (*a4 >= a3 || a2[v8] == a5)
  {
    result = 0;
  }
  else
  {
    v10[0] = a5;
    v10[1] = 0;
    result = mosyntbase_WriteDevelMessage(a1, "***** error getting character '%s' at position %d in string '%s'\\n", 0, v10, 2, a2, a3, (unsigned __int8 *)&byte_1DEBD87CE, 0, v8, 0, 0);
    if ((result & 0x80000000) != 0)
      return result;
    v8 = *a4;
  }
  if (v8 < a3)
  {
    if (a2[v8])
      *a4 = v8 + 1;
  }
  return result;
}

uint64_t mosyntutils_GetCardFromString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, _DWORD *a5)
{
  signed int v9;
  unsigned __int8 *v10;
  signed int v11;
  int v12;
  uint64_t result;
  int i;
  int v15;

  v9 = *a4;
  if (*a4 < a3 && a2[v9] == 32)
  {
    v10 = &a2[v9 + 1];
    v11 = v9 + 1;
    while (1)
    {
      *a4 = v11;
      if (a3 == v11)
        break;
      v12 = *v10++;
      ++v11;
      if (v12 != 32)
      {
        v9 = v11 - 1;
        goto LABEL_8;
      }
    }
    v9 = a3;
  }
LABEL_8:
  if (a2[v9] - 58 > 0xFFFFFFF5)
  {
    result = 0;
  }
  else
  {
    result = mosyntbase_WriteDevelMessage(a1, "***** error in getting cardinal from string '%s' at position %d\\n", 0, a2, a3, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, v9, 0, 0);
    if ((result & 0x80000000) != 0)
      return result;
  }
  *a5 = 0;
  for (i = *a4; i < a3; *a4 = i)
  {
    v15 = a2[i];
    if ((v15 - 48) > 9)
      break;
    *a5 = v15 + 10 * *a5 - 48;
    i = *a4 + 1;
  }
  return result;
}

uint64_t mosyntutils_GetIdentFromString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, _BYTE *a5, int a6)
{
  signed int v11;
  unsigned __int8 *v12;
  signed int v13;
  int v14;
  uint64_t result;
  unsigned __int8 v16;
  int v17;
  uint64_t v18;
  int v19;
  int v21;
  BOOL v22;
  _BYTE v23[3];
  BOOL v24;
  _BYTE v25[2];

  v11 = *a4;
  if (*a4 < a3 && a2[v11] == 32)
  {
    v12 = &a2[v11 + 1];
    v13 = v11 + 1;
    while (1)
    {
      *a4 = v13;
      if (a3 == v13)
        break;
      v14 = *v12++;
      ++v13;
      if (v14 != 32)
      {
        v11 = v13 - 1;
        goto LABEL_8;
      }
    }
    v11 = a3;
  }
LABEL_8:
  if ((a2[v11] & 0xDFu) - 91 > 0xFFFFFFE5
    || (result = mosyntbase_WriteDevelMessage(a1, "***** error in getting identifier from string '%s' at position %d\\n", 0, a2, a3, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, v11, 0, 0), (result & 0x80000000) == 0))
  {
    *a5 = 0;
    v21 = 0;
    v16 = a2[*a4];
    v22 = 0;
    v23[0] = v16;
    v23[1] = 0;
    result = mosyntbase_App((uint64_t)a5, a6, &v21, (uint64_t)v23, 2, &v22);
    if ((result & 0x80000000) == 0)
    {
      v17 = a3 - 1;
      do
      {
        v18 = *a4;
        *a4 = v18 + 1;
        v19 = a2[v18 + 1];
        if ((int)v18 >= v17)
        {
          if ((v19 - 48) < 0xA)
            goto LABEL_21;
        }
        else if ((v19 & 0xFFFFFFDF) - 65 < 0x1A || (v19 - 48) < 0xA)
        {
          goto LABEL_21;
        }
        if (v19 != 95 && v19 != 45)
          return mosyntbase_UpperCase(a5, a6);
LABEL_21:
        v24 = 0;
        v25[0] = v19;
        v25[1] = 0;
        result = mosyntbase_App((uint64_t)a5, a6, &v21, (uint64_t)v25, 2, &v24);
      }
      while ((result & 0x80000000) == 0);
    }
  }
  return result;
}

uint64_t mosyntutils_GetIdent1FromString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, _BYTE *a5, int a6)
{
  signed int v11;
  unsigned __int8 *v12;
  signed int v13;
  int v14;
  uint64_t result;
  unsigned __int8 v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  BOOL v21;
  _BYTE v22[3];
  BOOL v23;
  _BYTE v24[2];

  v11 = *a4;
  if (*a4 < a3 && a2[v11] == 32)
  {
    v12 = &a2[v11 + 1];
    v13 = v11 + 1;
    while (1)
    {
      *a4 = v13;
      if (a3 == v13)
        break;
      v14 = *v12++;
      ++v13;
      if (v14 != 32)
      {
        v11 = v13 - 1;
        goto LABEL_8;
      }
    }
    v11 = a3;
  }
LABEL_8:
  if ((a2[v11] & 0xDFu) - 91 > 0xFFFFFFE5
    || (result = mosyntbase_WriteDevelMessage(a1, "***** error in getting identifier from string '%s' at position %d\\n", 0, a2, a3, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, v11, 0, 0), (result & 0x80000000) == 0))
  {
    *a5 = 0;
    v20 = 0;
    v16 = a2[*a4];
    v21 = 0;
    v22[0] = v16;
    v22[1] = 0;
    result = mosyntbase_App((uint64_t)a5, a6, &v20, (uint64_t)v22, 2, &v21);
    if ((result & 0x80000000) == 0)
    {
      v17 = a3 - 1;
      while (1)
      {
        v18 = *a4;
        *a4 = v18 + 1;
        if ((int)v18 >= v17)
          break;
        v19 = a2[v18 + 1];
        if ((v19 & 0xFFFFFFDF) - 65 > 0x19)
          break;
        v23 = 0;
        v24[0] = v19;
        v24[1] = 0;
        result = mosyntbase_App((uint64_t)a5, a6, &v20, (uint64_t)v24, 2, &v23);
        if ((result & 0x80000000) != 0)
          return result;
      }
      return mosyntbase_UpperCase(a5, a6);
    }
  }
  return result;
}

uint64_t mosynttrans_InitTransDesc(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v8;

  result = mosyntpal_ALLOCATE(a1, a4, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)(*a4 + 8) = a3;
    v8 = *a4;
    *(_DWORD *)v8 = a2;
    *(_QWORD *)(v8 + 16) = 0;
  }
  return result;
}

uint64_t mosynttrans_FinishTransDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t *v4;
  _QWORD *v5;
  uint64_t result;

  v4 = (uint64_t *)(*a2 + 16);
  v5 = (_QWORD *)*v4;
  if (!*v4)
    return mosyntpal_DEALLOCATE(a1, a2);
  while (1)
  {
    v5 = (_QWORD *)*v5;
    result = mosyntpal_DEALLOCATE(a1, v4);
    if ((result & 0x80000000) != 0)
      break;
    *v4 = (uint64_t)v5;
    if (!v5)
      return mosyntpal_DEALLOCATE(a1, a2);
  }
  return result;
}

uint64_t mosynttrans_NewTransState(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, char a7, int a8, uint64_t *a9)
{
  uint64_t TransductionMode;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t started;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  uint64_t j;
  __int16 v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t i;

  TransductionMode = mosyntpal_ALLOCATE(a1, a9, 0xA0u);
  if ((TransductionMode & 0x80000000) != 0)
    return TransductionMode;
  *(_QWORD *)*a9 = 0;
  *(_QWORD *)(*a9 + 8) = 0;
  v18 = *a9;
  *(_DWORD *)(v18 + 16) = a3;
  *(_DWORD *)(v18 + 20) = a5;
  *(_BYTE *)(v18 + 24) = 0;
  *(_QWORD *)(v18 + 32) = a4;
  v19 = *a9;
  *(_DWORD *)(v19 + 40) = a6;
  *(_BYTE *)(v19 + 44) = a7;
  TransductionMode = mosyntkbfst_GetTransductionMode(*(_QWORD *)(v19 + 32), (_DWORD *)(v19 + 128));
  if ((TransductionMode & 0x80000000) != 0)
    return TransductionMode;
  TransductionMode = mosyntdata_StartPhonList(a1, (_QWORD *)(*a9 + 48), (_QWORD *)(*a9 + 56));
  if ((TransductionMode & 0x80000000) != 0)
    return TransductionMode;
  v20 = *a9;
  if (a8 >= 0x3E8)
    v21 = 1000;
  else
    v21 = a8;
  if (a8 < 0)
    v21 = 50;
  *(_DWORD *)(v20 + 64) = 0;
  *(_DWORD *)(v20 + 68) = v21;
  *(_DWORD *)(v20 + 72) = 0;
  started = mosyntdata_StartPhonList(a1, (_QWORD *)(v20 + 80), (_QWORD *)(v20 + 88));
  if ((started & 0x80000000) == 0)
  {
    v23 = *a9;
    *(_BYTE *)(v23 + 96) = 0;
    *(_DWORD *)(v23 + 100) = -1;
    *(_QWORD *)(v23 + 112) = 0;
    *(_QWORD *)(*a9 + 120) = 0;
    *(_QWORD *)(*a9 + 104) = 0;
    if ((a6 - 1) > 1)
    {
      *(_WORD *)(*a9 + 132) = mosyntkbsymtab_PhonStartId(*(_QWORD *)(a2 + 8));
      *(_WORD *)(*a9 + 134) = mosyntkbsymtab_PhonTermId(*(_QWORD *)(a2 + 8));
      *(_WORD *)(*a9 + 136) = mosyntkbsymtab_FSTDefaultId(*(_QWORD *)(a2 + 8));
      v28 = mosyntkbsymtab_SyllSepId(*(_QWORD *)(a2 + 8));
      v29 = *a9;
      *(_WORD *)(v29 + 138) = v28;
      v30 = *(_DWORD *)(v29 + 128);
      if (!v30)
        goto LABEL_26;
      if (v30 == 1)
      {
        *(_WORD *)(*a9 + 140) = mosyntkbsymtab_WordSep2Id(*(_QWORD *)(a2 + 8));
        *(_WORD *)(*a9 + 142) = mosyntkbsymtab_PhrSepPause2Id(*(_QWORD *)(a2 + 8));
        v31 = 0;
        *(_WORD *)(*a9 + 144) = mosyntkbsymtab_PhrSepNoPause2Id(*(_QWORD *)(a2 + 8));
        do
        {
          *(_WORD *)(*a9 + 2 * v31 + 146) = mosyntkbsymtab_AccId(*(_QWORD *)(a2 + 8), v31);
          ++v31;
        }
        while (v31 != 5);
        return started;
      }
      if (*(int *)a2 < 1
        || (started = TraceUnknownTransductionMode(a1, (unsigned int *)v29), (started & 0x80000000) == 0))
      {
LABEL_26:
        *(_WORD *)(*a9 + 140) = mosyntkbsymtab_WordSepId(*(_QWORD *)(a2 + 8));
        *(_WORD *)(*a9 + 142) = mosyntkbsymtab_PhrSepPauseId(*(_QWORD *)(a2 + 8));
        *(_WORD *)(*a9 + 144) = mosyntkbsymtab_PhrSepNoPauseId(*(_QWORD *)(a2 + 8));
        for (i = 146; i != 156; i += 2)
          *(_WORD *)(*a9 + i) = mosyntkbsymtab_PrimAccId(*(_QWORD *)(a2 + 8));
      }
    }
    else if (!*(_DWORD *)(*a9 + 128)
           || *(int *)a2 < 1
           || (started = TraceUnknownTransductionMode(a1, (unsigned int *)*a9), (started & 0x80000000) == 0))
    {
      *(_WORD *)(*a9 + 132) = mosyntkbsymtab_IPABeginId(*(_QWORD *)(a2 + 8));
      *(_WORD *)(*a9 + 134) = mosyntkbsymtab_IPAEndId(*(_QWORD *)(a2 + 8));
      *(_WORD *)(*a9 + 136) = mosyntkbsymtab_FSTDefaultId(*(_QWORD *)(a2 + 8));
      *(_WORD *)(*a9 + 138) = mosyntkbsymtab_IPASyllSepId(*(_QWORD *)(a2 + 8));
      v24 = mosyntkbsymtab_IPAWordSepId(*(_QWORD *)(a2 + 8));
      v25 = *a9;
      *(_WORD *)(v25 + 140) = v24;
      *(_DWORD *)(v25 + 142) = 0;
      for (j = 146; j != 156; j += 2)
        *(_WORD *)(*a9 + j) = mosyntkbsymtab_IPAPrimAccId(*(_QWORD *)(a2 + 8));
    }
  }
  return started;
}

uint64_t TraceUnknownTransductionMode(uint64_t a1, unsigned int *a2)
{
  uint64_t result;

  result = mosyntknowl_WriteTraceHeader(a1, a2[4]);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntbase_WString(a1, "fst: ", 0);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WInt(a1, a2[5], 1);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, " ***** unknown transduction mode: ", 0);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WInt(a1, a2[32], 0);
          if ((result & 0x80000000) == 0)
            return mosyntbase_WStringLn(a1, "; using default instead", 0);
        }
      }
    }
  }
  return result;
}

uint64_t mosynttrans_NewTransStateSeq(uint64_t a1, uint64_t a2, int a3, int *a4, int a5, int a6, unsigned int a7, int a8, uint64_t *a9)
{
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t inited;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v26;

  *a9 = 0;
  LODWORD(v13) = *a4;
  if (*a4 <= a6 || a6 <= -1)
    v13 = v13;
  else
    v13 = a6;
  do
  {
    if ((int)v13 < 1)
    {
      v20 = 0;
      goto LABEL_18;
    }
    v15 = v13 - 1;
    v16 = *(_QWORD *)&a4[2 * v13];
    inited = fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher();
    v13 = v15;
  }
  while (v16 == inited);
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = a4 + 2;
  v22 = v15 + 1;
  v23 = a7;
  do
  {
    v24 = *(_QWORD *)&v21[2 * v18];
    if (v24 != fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher())
    {
      v20 = mosynttrans_NewTransState(a1, a2, a3, *(_QWORD *)&v21[2 * v18], v18, a5, v18 < v23, a8, a9);
      if ((v20 & 0x80000000) != 0)
        return v20;
      *(_QWORD *)*a9 = v19;
      if (v19)
        *(_QWORD *)(v19 + 8) = *a9;
      v19 = *a9;
    }
    ++v18;
  }
  while (v22 != v18);
LABEL_18:
  if (*a9)
    return v20;
  v26 = fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher();
  return mosynttrans_NewTransState(a1, a2, a3, v26, -1, a5, 1, a8, a9);
}

uint64_t mosynttrans_PutPhonList(uint64_t a1, uint64_t a2, _QWORD *a3, char a4, uint64_t *a5)
{
  _QWORD *v6;
  uint64_t result;
  _QWORD *PhonEle;
  uint64_t *v9;

  v9 = a5;
  if (!a3)
    return 0;
  do
  {
    v6 = a3;
    a3 = (_QWORD *)*a3;
  }
  while (a3);
  *((_BYTE *)v6 + 24) = a4;
  result = mosyntdata_CopyPhonList(a1, &v9);
  if ((result & 0x80000000) == 0)
  {
    PhonEle = mosyntdata_LastPhonEle(a1, v9);
    return mosyntdata_AppendPhonList(a1, v6 + 6, v6 + 7, (uint64_t)v9, (uint64_t)PhonEle);
  }
  return result;
}

uint64_t mosynttrans_GetPhonList(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  result = mosyntdata_StartPhonList(a1, a4, a5);
  if (a3)
  {
    if ((result & 0x80000000) == 0)
    {
      v12 = 0;
      v13 = 0;
      for (result = SingleTransducerGet(a1, a2, (uint64_t)a3, &v13, &v12); (result & 0x80000000) == 0; a3 = (uint64_t *)v11)
      {
        v11 = a3[1];
        if (v13)
        {
          if (!v11)
            return mosyntdata_AppendPhonList(a1, a4, a5, v13, v12);
          result = mosyntdata_AppendPhonList(a1, (_QWORD *)(v11 + 48), (_QWORD *)(v11 + 56), v13, v12);
          if ((result & 0x80000000) != 0)
            return result;
        }
        else if (!v11 || !*(_BYTE *)(v11 + 24))
        {
          v11 = *a3;
          if (!*a3)
            return result;
        }
        result = SingleTransducerGet(a1, a2, v11, &v13, &v12);
      }
    }
  }
  return result;
}

uint64_t SingleTransducerGet(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t result;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  int v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  int v28;
  signed int v29;
  signed int v30;
  char v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;

  result = mosyntdata_StartPhonList(a1, a4, a5);
  if ((result & 0x80000000) == 0)
  {
    v33 = 0;
    v11 = *(_QWORD *)(a3 + 32);
    if (v11 == fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher())
    {
      v23 = *(_DWORD *)(a3 + 100);
      v24 = (_QWORD *)(a3 + 48);
      if (v23 < 0)
      {
        v27 = *(_QWORD *)(a3 + 56);
        v26 = (_QWORD *)(a3 + 56);
        result = mosyntdata_AppendPhonList(a1, a4, a5, *(v26 - 1), v27);
        if ((result & 0x80000000) == 0)
          return mosyntdata_StartPhonList(a1, v24, v26);
      }
      else
      {
        v25 = (_QWORD *)(a3 + 56);
        do
        {
          result = mosyntdata_PopPhonEle(a1, (_QWORD **)v24, v25, &v33);
          if ((result & 0x80000000) != 0)
            break;
          if (!v33)
            break;
          result = mosyntdata_AppendPhonList(a1, a4, a5, (uint64_t)v33, (uint64_t)v33);
          if ((result & 0x80000000) != 0)
            break;
          --v23;
        }
        while (v23);
      }
    }
    else
    {
      if (!*(_QWORD *)(a3 + 80) && *(_DWORD *)(a3 + 64) < *(_DWORD *)(a3 + 68))
      {
        while (1)
        {
          result = mosyntdata_PopPhonEle(a1, (_QWORD **)(a3 + 48), (_QWORD *)(a3 + 56), &v33);
          if ((result & 0x80000000) != 0)
            return result;
          v12 = v33;
          if (!v33)
            goto LABEL_53;
          v34 = 0;
          v35 = v33;
          if (*v33)
          {
            *v33 = 0;
            result = mosyntbase_WriteDevelMessage(a1, "*** SVOXTrans.DoTransduction() expects isolated phone\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
            if ((result & 0x80000000) != 0)
              return result;
          }
          if (!*(_BYTE *)(a3 + 96))
          {
            result = StartTransduction(a1, a2, a3);
            if ((result & 0x80000000) != 0)
              return result;
          }
          if (*((_BYTE *)v12 + 20))
            break;
          v16 = *((unsigned __int16 *)v12 + 12);
          if (v16 != *(unsigned __int16 *)(a3 + 134))
          {
            v17 = (__int16)v16;
            v18 = (uint64_t *)&v35;
            v19 = a1;
            v20 = a2;
            v21 = a3;
            v22 = 0;
            goto LABEL_32;
          }
LABEL_33:
          if (v35)
          {
            result = mosyntdata_DisposePhonEleList(a1, &v35);
            if ((result & 0x80000000) != 0)
              return result;
          }
          if (*(_QWORD *)(a3 + 104))
          {
            result = GetTransduction(a1, a2, a3);
            if ((result & 0x80000000) != 0)
              return result;
          }
          if (*(_QWORD *)(a3 + 80) || *(_DWORD *)(a3 + 64) >= *(_DWORD *)(a3 + 68))
          {
            v33 = 0;
            goto LABEL_53;
          }
        }
        v13 = *((unsigned __int16 *)v12 + 18);
        v14 = *((_DWORD *)v12 + 6);
        switch(v14)
        {
          case 3:
            if (!*(_DWORD *)(a3 + 40))
            {
              if (*((__int16 *)v12 + 14) > 1)
                v15 = *(__int16 *)(a3 + 144);
              else
                v15 = *(__int16 *)(a3 + 142);
              goto LABEL_20;
            }
            break;
          case 2:
            break;
          case 1:
            v15 = *(__int16 *)(a3 + 138);
LABEL_20:
            result = TransduceSymbol(a1, a2, a3, v15, 0, (uint64_t *)&v35);
            if ((result & 0x80000000) != 0)
              return result;
LABEL_23:
            if (*(_DWORD *)(a3 + 128) == 1)
            {
              if ((__int16)v13 <= 4)
              {
                if ((v13 & 0x8000) != 0)
                {
                  result = mosyntbase_WriteDevelMessage(a1, "fst: %d ***** negative accent %d; using 0 instead\\n",
                             0,
                             (unsigned __int8 *)&byte_1DEBD87CE,
                             0,
                             (unsigned __int8 *)&byte_1DEBD87CE,
                             0,
                             (unsigned __int8 *)&byte_1DEBD87CE,
                             0,
                             *(_DWORD *)(a3 + 20),
                             0,
                             0);
                  v13 = 0;
                  if ((result & 0x80000000) != 0)
                    return result;
                }
              }
              else
              {
                v13 = 4;
              }
              v17 = *(__int16 *)(a3 + 2 * v13 + 146);
LABEL_31:
              v18 = &v34;
              v19 = a1;
              v20 = a2;
              v21 = a3;
              v22 = 1;
LABEL_32:
              result = TransduceSymbol(v19, v20, v21, v17, v22, v18);
              if ((result & 0x80000000) != 0)
                return result;
              goto LABEL_33;
            }
            if ((__int16)v13 >= 1)
            {
              v17 = *(__int16 *)(a3 + 146);
              goto LABEL_31;
            }
            goto LABEL_33;
          default:
            result = mosyntbase_WriteDevelMessage(a1, "*** unexpected NILBOUNDARY boundary phone\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
            if ((result & 0x80000000) != 0)
              return result;
            goto LABEL_23;
        }
        v15 = *(__int16 *)(a3 + 140);
        goto LABEL_20;
      }
LABEL_53:
      v28 = *(_DWORD *)(a3 + 100);
      if (v28 < 0)
      {
        result = mosyntdata_AppendPhonList(a1, a4, a5, *(_QWORD *)(a3 + 80), *(_QWORD *)(a3 + 88));
        if ((result & 0x80000000) == 0)
        {
          result = mosyntdata_StartPhonList(a1, (_QWORD *)(a3 + 80), (_QWORD *)(a3 + 88));
          if ((result & 0x80000000) == 0)
          {
LABEL_61:
            v29 = *(_DWORD *)(a3 + 64);
            v30 = *(_DWORD *)(a3 + 68);
            if (v29 >= v30)
            {
              result = mosyntbase_WriteDevelMessage(a1, "---- forced emission %d >= %d\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, v29, v30, 0);
              if ((result & 0x80000000) != 0)
                return result;
              v31 = 1;
              *(_BYTE *)(a3 + 24) = 1;
            }
            else
            {
              if (!*(_BYTE *)(a3 + 24))
                return result;
              v31 = 0;
            }
            if (!*a4)
            {
              result = TerminateTransduction(a1, a2, a3);
              if ((result & 0x80000000) == 0)
              {
                *(_BYTE *)(a3 + 24) = v31;
                v32 = *(_QWORD *)(a3 + 8);
                if (v32)
                  *(_BYTE *)(v32 + 24) = v29 < v30;
                return SingleTransducerGet(a1, a2, a3, a4, a5);
              }
            }
          }
        }
      }
      else
      {
        while (1)
        {
          result = mosyntdata_PopPhonEle(a1, (_QWORD **)(a3 + 80), (_QWORD *)(a3 + 88), &v33);
          if ((result & 0x80000000) != 0)
            break;
          if (!v33)
            goto LABEL_61;
          result = mosyntdata_AppendPhonList(a1, a4, a5, (uint64_t)v33, (uint64_t)v33);
          if ((result & 0x80000000) != 0)
            break;
          if (!--v28)
          {
            v33 = 0;
            goto LABEL_61;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosynttrans_TransducePhonList(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t *a6, int a7, char a8, _QWORD *a9, _QWORD *a10)
{
  uint64_t result;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  result = mosyntdata_StartPhonList(a1, a9, a10);
  if ((result & 0x80000000) == 0)
  {
    v23 = 0;
    v24 = 0;
    v22 = 0;
    result = mosynttrans_NewTransState(a1, a2, a3, a4, a5, a7, a8, 1000, (uint64_t *)&v22);
    if ((result & 0x80000000) == 0)
    {
      v20 = v22;
      *((_DWORD *)v22 + 25) = -1;
      for (result = mosynttrans_PutPhonList(a1, v19, v20, 1, a6);
            (result & 0x80000000) == 0;
            result = mosyntdata_AppendPhonList(a1, a9, a10, v24, v23))
      {
        result = mosynttrans_GetPhonList(a1, a2, v22, &v24, &v23);
        if ((result & 0x80000000) != 0)
          break;
        if (!v24)
        {
          v21 = v22;
          if (!v22)
            return 0;
          do
          {
            v21 = (uint64_t *)*v21;
            result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v22);
            if ((result & 0x80000000) != 0)
              break;
            v22 = v21;
          }
          while (v21);
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t mosynttrans_SeqTransducePhonList(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t **a5, uint64_t a6, int a7, int a8, unsigned int a9, unsigned __int8 *a10, int a11)
{
  uint64_t result;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t *v23;
  _OWORD v24[5];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v28 = 0;
  v29 = 0;
  v26 = 0;
  v27 = 0;
  result = mosyntdata_StartPhonList(a1, a5, &v29);
  if ((result & 0x80000000) == 0)
  {
    v20 = *(_OWORD *)(a6 + 48);
    v24[2] = *(_OWORD *)(a6 + 32);
    v24[3] = v20;
    v24[4] = *(_OWORD *)(a6 + 64);
    v25 = *(_QWORD *)(a6 + 80);
    v21 = *(_OWORD *)(a6 + 16);
    v24[0] = *(_OWORD *)a6;
    v24[1] = v21;
    result = mosynttrans_NewTransStateSeq(a1, a2, a3, (int *)v24, a7, a8, a9, 1000, (uint64_t *)&v26);
    if ((result & 0x80000000) == 0)
    {
      if (*(int *)a2 < 2
        || (result = mosyntknowl_WriteTraceHeader(a1, a3), (result & 0x80000000) == 0)
        && (result = mosyntbase_WString(a1, "before ", 0), (result & 0x80000000) == 0)
        && (result = mosyntbase_WString(a1, a10, a11), (result & 0x80000000) == 0)
        && (result = mosyntbase_WString(a1, " ", 0), (result & 0x80000000) == 0)
        && (result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), a4), (result & 0x80000000) == 0)
        && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
      {
        if (v26)
        {
          for (result = mosynttrans_PutPhonList(a1, v22, v26, 1, a4);
                (result & 0x80000000) == 0;
                result = mosyntdata_AppendPhonList(a1, a5, &v29, v28, v27))
          {
            result = mosynttrans_GetPhonList(a1, a2, v26, &v28, &v27);
            if ((result & 0x80000000) != 0)
              break;
            if (!v28)
              goto LABEL_17;
          }
        }
        else
        {
          *a5 = a4;
          result = mosyntdata_CopyPhonList(a1, a5);
          if ((result & 0x80000000) == 0)
          {
LABEL_17:
            if (*(int *)a2 < 2
              || (result = mosyntknowl_WriteTraceHeader(a1, a3), (result & 0x80000000) == 0)
              && (result = mosyntbase_WString(a1, "after ", 0), (result & 0x80000000) == 0)
              && (result = mosyntbase_WString(a1, a10, a11), (result & 0x80000000) == 0)
              && (result = mosyntbase_WString(a1, " ", 0), (result & 0x80000000) == 0)
              && (result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), *a5), (result & 0x80000000) == 0)
              && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0)
              && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
            {
              v23 = v26;
              if (v26)
              {
                do
                {
                  v23 = (uint64_t *)*v23;
                  result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v26);
                  if ((result & 0x80000000) != 0)
                    break;
                  v26 = v23;
                }
                while (v23);
              }
              else
              {
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t TerminateTransduction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;

  v9 = 0;
  if (*(_BYTE *)(a3 + 96) || (result = StartTransduction(a1, a2, a3), (result & 0x80000000) == 0))
  {
    result = TransduceSymbol(a1, a2, a3, *(__int16 *)(a3 + 134), 0, &v9);
    if ((result & 0x80000000) == 0)
    {
      *(_BYTE *)(a3 + 96) = 0;
      v7 = *(_QWORD *)(a3 + 120);
      if (!v7)
        return DisposePositionList(a1, a2, a3);
      v8 = (uint64_t *)(v7 + 32);
      do
        v8 = (uint64_t *)*v8;
      while (v8 && *((_WORD *)v8 + 8) != 1);
      *(_QWORD *)(a3 + 104) = v8;
      result = GetTransduction(a1, a2, a3);
      if ((result & 0x80000000) == 0)
        return DisposePositionList(a1, a2, a3);
    }
  }
  return result;
}

uint64_t StartTransduction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!*(_QWORD *)(a3 + 112)
    || (result = mosyntbase_WriteDevelMessage(a1, "*** position list not empty at transduction start\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0), (result & 0x80000000) == 0)&& (result = DisposePositionList(a1, a2, a3), (result & 0x80000000) == 0))
  {
    result = AddPosition(a1, a3, 0);
    if ((result & 0x80000000) == 0)
    {
      result = AddPosState(a1, a2, a3, *(_QWORD *)(a3 + 112), 1, 0, 0, 0, 0, 0);
      if ((result & 0x80000000) == 0)
      {
        result = TransduceSymbol(a1, a2, a3, *(__int16 *)(a3 + 132), 0, &v7);
        if ((result & 0x80000000) == 0)
          *(_BYTE *)(a3 + 96) = 1;
      }
    }
  }
  return result;
}

uint64_t TransduceSymbol(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, char a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  __int16 v18;
  int v19;
  int v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;

  if (*(int *)a2 < 3
    || (result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16)), (result & 0x80000000) == 0)
    && (result = mosyntbase_WString(a1, "fst: ", 0), (result & 0x80000000) == 0)
    && (result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1), (result & 0x80000000) == 0)
    && (result = mosyntbase_WString(a1, " --- treating input symbol ", 0), (result & 0x80000000) == 0)
    && (result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), a4), (result & 0x80000000) == 0)
    && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
  {
    v13 = *(_QWORD *)(a3 + 120);
    v14 = *a6;
    result = AddPosition(a1, a3, *a6);
    if ((result & 0x80000000) == 0)
    {
      v26 = 0;
      v27 = 0;
      v25 = 0;
      *a6 = 0;
      result = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a3 + 32), *(_WORD *)(a3 + 136), (uint64_t)&v26, &v25);
      if ((result & 0x80000000) == 0)
      {
        v15 = *(_QWORD *)(v13 + 32);
        if (v15)
        {
          while (1)
          {
            result = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a3 + 32), 0, (uint64_t)&v27, &v25);
            if ((result & 0x80000000) != 0)
              break;
            while (v25)
            {
              if (*(int *)a2 < 3)
                goto LABEL_67;
              result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
              if ((result & 0x80000000) == 0)
              {
                result = mosyntbase_WString(a1, "trying pos/state ", 0);
                if ((result & 0x80000000) == 0)
                {
                  result = mosyntbase_WInt(a1, *(__int16 *)(v13 + 16), 0);
                  if ((result & 0x80000000) == 0)
                  {
                    result = mosyntbase_WString(a1, "/", 0);
                    if ((result & 0x80000000) == 0)
                    {
                      result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
                      if ((result & 0x80000000) == 0)
                      {
                        result = mosyntbase_WString(a1, " and pair ", 0);
                        if ((result & 0x80000000) == 0)
                        {
                          result = mosyntkbfst_WritePhonPair(a1, *(uint64_t **)(a2 + 8), *(_QWORD *)(a3 + 32), &v27, 2);
                          if ((result & 0x80000000) == 0)
                          {
                            result = mosyntbase_WLn(a1);
                            if ((result & 0x80000000) == 0)
                            {
LABEL_67:
                              v16 = mosyntkbfst_FSTTrans(*(_QWORD *)(a3 + 32), *(__int16 *)(v15 + 16), &v27);
                              if (v16 < 1
                                || (v17 = v16,
                                    v18 = mosyntkbfst_OutSym(*(_QWORD *)(a3 + 32), &v27),
                                    result = AddPosState(a1, a2, a3, v13, v17, v15, 0, v18, a5, 0),
                                    (result & 0x80000000) == 0))
                              {
                                result = mosyntkbfst_GetNextSameInSymPair(*(_QWORD *)(a3 + 32), (int *)&v27, &v25);
                                if ((result & 0x80000000) == 0)
                                  continue;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return result;
            }
            result = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a3 + 32), a4, (uint64_t)&v27, &v25);
            if ((result & 0x80000000) != 0)
              break;
            v19 = 0;
            while (v25)
            {
              if (*(int *)a2 < 3)
                goto LABEL_68;
              result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
              if ((result & 0x80000000) == 0)
              {
                result = mosyntbase_WString(a1, "trying pos/state ", 0);
                if ((result & 0x80000000) == 0)
                {
                  result = mosyntbase_WInt(a1, *(__int16 *)(v13 + 16), 0);
                  if ((result & 0x80000000) == 0)
                  {
                    result = mosyntbase_WString(a1, "/", 0);
                    if ((result & 0x80000000) == 0)
                    {
                      result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
                      if ((result & 0x80000000) == 0)
                      {
                        result = mosyntbase_WString(a1, " and pair ", 0);
                        if ((result & 0x80000000) == 0)
                        {
                          result = mosyntkbfst_WritePhonPair(a1, *(uint64_t **)(a2 + 8), *(_QWORD *)(a3 + 32), &v27, 2);
                          if ((result & 0x80000000) == 0)
                          {
                            result = mosyntbase_WLn(a1);
                            if ((result & 0x80000000) == 0)
                            {
LABEL_68:
                              v20 = mosyntkbfst_FSTTrans(*(_QWORD *)(a3 + 32), *(__int16 *)(v15 + 16), &v27);
                              if (v20 < 1
                                || (v21 = v20,
                                    v24 = *(_QWORD *)(v13 + 8),
                                    v22 = mosyntkbfst_OutSym(*(_QWORD *)(a3 + 32), &v27),
                                    result = AddPosState(a1, a2, a3, v24, v21, v15, a4, v22, a5, v14),
                                    (result & 0x80000000) == 0))
                              {
                                result = mosyntkbfst_GetNextSameInSymPair(*(_QWORD *)(a3 + 32), (int *)&v27, &v25);
                                --v19;
                                if ((result & 0x80000000) == 0)
                                  continue;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return result;
            }
            if (!v19)
            {
              if (mosyntkbfst_IsValidPair(&v26))
              {
                v27 = v26;
                if (*(int *)a2 >= 3)
                {
                  result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntbase_WString(a1, "trying pos/state ", 0);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntbase_WInt(a1, *(__int16 *)(v13 + 16), 0);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntbase_WString(a1, "/", 0);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntbase_WString(a1, " and pair ", 0);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntkbfst_WritePhonPair(a1, *(uint64_t **)(a2 + 8), *(_QWORD *)(a3 + 32), &v27, 2);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = mosyntbase_WLn(a1);
                  if ((result & 0x80000000) != 0)
                    return result;
                }
                v23 = mosyntkbfst_FSTTrans(*(_QWORD *)(a3 + 32), *(__int16 *)(v15 + 16), &v27);
                if (v23 >= 1)
                {
                  result = AddPosState(a1, a2, a3, *(_QWORD *)(v13 + 8), v23, v15, a4, a4, a5, v14);
                  if ((result & 0x80000000) != 0)
                    return result;
                }
              }
              else if (*(int *)a2 >= 1)
              {
                result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
                if ((result & 0x80000000) != 0)
                  return result;
                result = mosyntbase_WString(a1, "*** no pair found with input symbol '", 0);
                if ((result & 0x80000000) != 0)
                  return result;
                result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), a4);
                if ((result & 0x80000000) != 0)
                  return result;
                result = mosyntbase_WStringLn(a1, "' and no default pair found", 0);
                if ((result & 0x80000000) != 0)
                  return result;
              }
            }
            v15 = *(_QWORD *)v15;
            if (!v15)
              return FindEmissionState(a1, a2, a3);
          }
        }
        else
        {
          return FindEmissionState(a1, a2, a3);
        }
      }
    }
  }
  return result;
}

uint64_t GetTransduction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  int v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  int v33;
  unint64_t v34;
  int v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  int v40;
  _QWORD *v41;
  uint64_t *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD v45[2];
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v43 = 0;
  v45[0] = 0;
  v45[1] = 0;
  v46 = 0;
  v6 = *(_DWORD *)(a3 + 64);
  if (v6 > *(_DWORD *)(a3 + 72))
  {
    *(_DWORD *)(a3 + 72) = v6;
    if (*(int *)a2 >= 2)
    {
      result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, "fst: ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WInt3Ln(a1, " max transduction path length:  ", 0, *(_DWORD *)(a3 + 72), (unsigned __int8 *)&byte_1DEBD87CE, 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0)
        return result;
    }
  }
  v8 = *(_QWORD *)(a3 + 104);
  v9 = *(_DWORD *)a2;
  if (!v8)
  {
    if (v9 < 2)
    {
      result = mosyntbase_WriteDevelMessage(a1, "*** no transduction found (use tracing to get more info)\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
      if ((result & 0x80000000) != 0)
        return result;
    }
    else
    {
      result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, "fst: ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WStringLn(a1, " ***** no transduction found for input ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0)
        return result;
    }
    v10 = *(_QWORD *)(a3 + 120);
    result = GetInPhonList(a1, a3, v10, (_QWORD *)(a3 + 80));
    if ((result & 0x80000000) != 0)
      return result;
    *(_QWORD *)(a3 + 88) = mosyntdata_LastPhonEle(a1, *(_QWORD **)(a3 + 80));
    m2__cp__str("output", v45, 20);
    result = TraceTransductionIO(a1, a2, (unsigned int *)a3, (unsigned __int8 *)v45, *(_QWORD **)(a3 + 80));
    if ((result & 0x80000000) != 0)
      return result;
LABEL_125:
    v36 = *(_QWORD **)(v10 + 8);
    v37 = *(_QWORD *)(a3 + 112);
    if (v36)
      *v36 = v37;
    if (v37)
      *(_QWORD *)(v37 + 8) = v36;
    if (!v36)
      goto LABEL_136;
    v38 = *(_QWORD *)(v37 + 32);
    *(_WORD *)(v38 + 20) = 0;
    v39 = (uint64_t *)v36[4];
    if (!v39)
      goto LABEL_136;
    v40 = 0;
    do
    {
      if (v39[1] != *(_QWORD *)(v39[3] + 8))
      {
        *((_WORD *)v39 + 9) = 1;
        v39[3] = v38;
        *(_WORD *)(v38 + 20) = ++v40;
      }
      v39 = (uint64_t *)*v39;
    }
    while (v39);
    if (!v10)
    {
      result = 0;
    }
    else
    {
LABEL_136:
      v44 = (_QWORD *)v10;
      if (v37 != v10)
      {
        v41 = (_QWORD *)v10;
        while (1)
        {
          v41 = (_QWORD *)*v41;
          result = DisposePosition(a1, a2, a3, (uint64_t *)&v44);
          if ((result & 0x80000000) != 0)
            return result;
          v44 = v41;
          if (v41 == *(_QWORD **)(a3 + 112))
            goto LABEL_142;
        }
      }
      result = 0;
      v41 = (_QWORD *)v10;
LABEL_142:
      if (!v36)
        *(_QWORD *)(a3 + 120) = v41;
    }
    *(_QWORD *)(a3 + 104) = 0;
    return result;
  }
  if (v9 < 3)
  {
    result = 0;
LABEL_29:
    v11 = 0;
    v12 = a3 + 80;
    v42 = (uint64_t *)(a3 + 88);
    v13 = a3 + 146;
    while (1)
    {
      v14 = *(__int16 *)(v8 + 34);
      if (!*(_DWORD *)(v8 + 32))
        goto LABEL_14;
      if (*(int *)a2 >= 3)
      {
        result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WString(a1, "fst: ", 0);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WString(a1, " treating output symbol '", 0);
        if ((result & 0x80000000) != 0)
          return result;
        if (v14)
        {
          result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), v14);
          if ((result & 0x80000000) != 0)
            return result;
        }
        else
        {
          result = mosyntbase_WString(a1, "@", 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        result = mosyntbase_WString(a1, "' with input element ", 0);
        if ((result & 0x80000000) != 0)
          return result;
        v15 = *(_QWORD *)(v8 + 40);
        if (v15)
        {
          result = mosyntdata_WritePhonEle(a1, *(uint64_t **)(a2 + 8), v15, 0, 0, v8 == *(_QWORD *)(a3 + 104), *(_QWORD *)v8 == 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        else
        {
          result = mosyntbase_WString(a1, "NIL", 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) != 0)
          return result;
      }
      v16 = *(unsigned __int16 *)(a3 + 134);
      if (!v14 || v16 == (unsigned __int16)v14 || *(unsigned __int16 *)(a3 + 132) == (unsigned __int16)v14)
      {
        if (v16 == (unsigned __int16)v14)
        {
          v17 = *(_QWORD *)(v8 + 40);
          if (v17)
          {
            if (*(_BYTE *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3)
            {
              result = mosyntdata_AddBound(a1, (uint64_t *)(a3 + 80), v42, 0, 3, *(_WORD *)(v17 + 28), *(_DWORD *)(v17 + 32), *(_WORD *)(v17 + 36));
              if ((result & 0x80000000) != 0)
                return result;
              v18 = *(_WORD *)(v17 + 8);
              goto LABEL_89;
            }
          }
        }
      }
      else
      {
        v19 = *(_QWORD *)(v8 + 40);
        if (v19 && *(_BYTE *)(v19 + 20))
        {
          v20 = *(unsigned __int16 *)(a3 + 138);
          if (v20 == (unsigned __int16)v14
            || *(unsigned __int16 *)(a3 + 140) == (unsigned __int16)v14
            || *(unsigned __int16 *)(a3 + 142) == (unsigned __int16)v14
            || *(unsigned __int16 *)(a3 + 144) == (unsigned __int16)v14)
          {
            if (!v11 || *(_DWORD *)(a3 + 128) != 1)
              goto LABEL_69;
            v21 = 0;
            v22 = -1;
            do
            {
              if (*(unsigned __int16 *)(v13 + 2 * v21) == *(unsigned __int16 *)(v11 + 34))
                v22 = v21;
              if (v21 > 3)
                break;
              ++v21;
            }
            while (v22 < 0);
            if (v22 < 0)
LABEL_69:
              LOWORD(v22) = *(_WORD *)(v19 + 36);
            v23 = *(_DWORD *)(v19 + 24);
            if (*(unsigned __int16 *)(v8 + 32) == (unsigned __int16)v14)
            {
              LOWORD(v24) = *(_WORD *)(v19 + 28);
              goto LABEL_72;
            }
            if (v23 == 3)
            {
              v24 = *(__int16 *)(v19 + 28);
              if (v24 < 1)
              {
                v23 = 3;
LABEL_72:
                v25 = v24;
                v26 = *(_DWORD *)(v19 + 32);
                v27 = a1;
                v28 = (uint64_t *)(a3 + 80);
                v29 = (uint64_t *)(a3 + 88);
                goto LABEL_87;
              }
            }
            if (v20 == (unsigned __int16)v14)
            {
              v27 = a1;
              v28 = (uint64_t *)(a3 + 80);
              v29 = (uint64_t *)(a3 + 88);
              v23 = 1;
              goto LABEL_86;
            }
            if (*(unsigned __int16 *)(a3 + 140) == (unsigned __int16)v14)
            {
              v27 = a1;
              v28 = (uint64_t *)(a3 + 80);
              v29 = (uint64_t *)(a3 + 88);
              v23 = 2;
LABEL_86:
              v25 = -1;
              v26 = 0;
LABEL_87:
              result = mosyntdata_AddBound(v27, v28, v29, 0, v23, v25, v26, v22);
              if ((result & 0x80000000) != 0)
                return result;
            }
            else if (*(unsigned __int16 *)(a3 + 144) == (unsigned __int16)v14)
            {
              v26 = *(_DWORD *)(v19 + 32);
              v27 = a1;
              v28 = (uint64_t *)(a3 + 80);
              v29 = (uint64_t *)(a3 + 88);
              v23 = 3;
              v25 = 2;
              goto LABEL_87;
            }
            v18 = *(_WORD *)(v19 + 8);
LABEL_89:
            *(_WORD *)(*(_QWORD *)v12 + 8) = v18;
            goto LABEL_90;
          }
          v34 = 0;
          do
          {
            v35 = *(unsigned __int16 *)(v13 + 2 * v34);
            if (v34 > 3)
              break;
            ++v34;
          }
          while (v35 != (unsigned __int16)v14);
          if (v35 != (unsigned __int16)v14 && *(int *)a2 >= 1)
          {
            result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
            if ((result & 0x80000000) != 0)
              return result;
            result = mosyntbase_WString(a1, "*** transduction error: illegal attempt to change a boundary element to phone \"", 0);
            if ((result & 0x80000000) != 0)
              return result;
            result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), v14);
            if ((result & 0x80000000) != 0)
              return result;
            result = mosyntbase_WStringLn(a1, "\"; phone ignored", 0);
            if ((result & 0x80000000) != 0)
              return result;
          }
        }
        else if (!*(_BYTE *)(v8 + 36))
        {
          v30 = *(_DWORD *)(a3 + 40);
          if (v30 > 5 || ((1 << v30) & 0x34) == 0 || v19)
            goto LABEL_77;
          v32 = 0;
          v33 = -1;
          do
          {
            if (*(unsigned __int16 *)(v13 + 2 * v32) == (unsigned __int16)v14)
              v33 = v32;
            if (v32 > 3)
              break;
            ++v32;
          }
          while (v33 < 0);
          if (v33 < 0)
          {
LABEL_77:
            result = mosyntdata_AddPhonEle(a1, (_QWORD *)(a3 + 80), v42, 0, v14);
            if ((result & 0x80000000) != 0)
              return result;
            v31 = *(_QWORD *)(v8 + 40);
            if (v31)
            {
              *(_WORD *)(*(_QWORD *)v12 + 26) = *(_WORD *)(v31 + 26);
              v18 = *(_WORD *)(*(_QWORD *)(v8 + 40) + 8);
            }
            else
            {
              v18 = -1;
              *(_WORD *)(*(_QWORD *)v12 + 26) = -1;
            }
            goto LABEL_89;
          }
        }
      }
LABEL_90:
      if (*(__int16 *)(v8 + 18) > 1)
      {
        if (*(int *)a2 < 2)
        {
          result = mosyntbase_WriteDevelMessage(a1, "*** ambiguous transducer solution (use tracing to get more info)\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        else
        {
          result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, "fst: ", 0);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WStringLn(a1, " ***** ambiguous transducer solution", 0);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WLn(a1);
          if ((result & 0x80000000) != 0)
            return result;
        }
      }
      v11 = v8;
      v8 = *(_QWORD *)(v8 + 24);
      if (!v8)
        goto LABEL_14;
    }
  }
  result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
  if ((result & 0x80000000) != 0)
    return result;
  result = mosyntbase_WStringLn(a1, "getting transduction path", 0);
  if ((result & 0x80000000) != 0)
    return result;
  v8 = *(_QWORD *)(a3 + 104);
  if (v8)
    goto LABEL_29;
  result = mosyntbase_WriteDevelMessage(a1, "***SVOXTrans.CollectTransductionPath() must not be called with emissionState = NIL\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
LABEL_14:
  if ((result & 0x80000000) == 0)
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a3 + 104) + 8);
    if (*(int *)a2 < 2)
      goto LABEL_125;
    result = GetInPhonList(a1, a3, *(_QWORD *)(*(_QWORD *)(a3 + 104) + 8), &v43);
    if ((result & 0x80000000) == 0)
    {
      m2__cp__str("input ", v45, 20);
      result = TraceTransductionIO(a1, a2, (unsigned int *)a3, (unsigned __int8 *)v45, v43);
      if ((result & 0x80000000) == 0)
      {
        m2__cp__str("output", v45, 20);
        result = TraceTransductionIO(a1, a2, (unsigned int *)a3, (unsigned __int8 *)v45, *(_QWORD **)(a3 + 80));
        if ((result & 0x80000000) == 0)
        {
          result = mosyntdata_DisposePhonEleList(a1, &v43);
          if ((result & 0x80000000) == 0)
            goto LABEL_125;
        }
      }
    }
  }
  return result;
}

uint64_t DisposePositionList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v9;

  v3 = (_QWORD *)(a3 + 112);
  v4 = *(_QWORD *)(a3 + 112);
  v9 = v4;
  if (v4)
  {
    while (1)
    {
      v4 = *(_QWORD *)(v4 + 8);
      result = DisposePosition(a1, a2, a3, &v9);
      if ((result & 0x80000000) != 0)
        break;
      v9 = v4;
      if (!v4)
        goto LABEL_6;
    }
  }
  else
  {
    result = 0;
LABEL_6:
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t AddPosition(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = 0;
  result = mosyntpal_ALLOCATE(a1, &v10, 0x30u);
  if ((result & 0x80000000) == 0)
  {
    v6 = *(_QWORD *)(a2 + 120);
    if (v6)
    {
      v7 = (_QWORD *)v10;
      *(_WORD *)(v10 + 16) = *(_WORD *)(v6 + 16) + 1;
      *v7 = v6;
      v8 = (_QWORD *)v10;
      *(_QWORD *)(v6 + 8) = v10;
    }
    else
    {
      v9 = (_QWORD *)v10;
      *(_WORD *)(v10 + 16) = 0;
      *v9 = 0;
      v8 = (_QWORD *)v10;
      *(_QWORD *)(a2 + 112) = v10;
    }
    *(_QWORD *)(a2 + 120) = v8;
    v8[1] = 0;
    v8[4] = 0;
    v8[5] = 0;
    v8[3] = a3;
    ++*(_DWORD *)(a2 + 64);
  }
  return result;
}

uint64_t AddPosState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, __int16 a7, __int16 a8, char a9, uint64_t a10)
{
  __int16 v11;
  _QWORD *v14;
  uint64_t v15;
  uint64_t result;
  _QWORD *v17;
  uint64_t v18;
  __int16 v19;
  __int16 v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v25;

  v11 = a5;
  v14 = (_QWORD *)(a4 + 32);
  v15 = a4 + 32;
  while (1)
  {
    v15 = *(_QWORD *)v15;
    v25 = v15;
    if (!v15)
      break;
    if (*(__int16 *)(v15 + 16) == a5)
    {
      ++*(_WORD *)(v15 + 18);
      if (*(int *)a2 < 3)
        return 0;
      result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, "added transition to pos/state element ", 0);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WInt(a1, *(__int16 *)(*(_QWORD *)(v15 + 8) + 16), 0);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WString(a1, "/", 0);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
              if ((result & 0x80000000) == 0)
                return mosyntbase_WLn(a1);
            }
          }
        }
      }
      return result;
    }
  }
  v17 = *(_QWORD **)(a2 + 16);
  if (v17)
  {
    result = 0;
    v25 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = *v17;
  }
  else
  {
    v18 = a3;
    v19 = a8;
    v20 = a7;
    result = mosyntpal_ALLOCATE(a1, &v25, 0x30u);
    a7 = v20;
    a8 = v19;
    a3 = v18;
    if ((result & 0x80000000) != 0)
      return result;
  }
  v21 = *(_QWORD **)(a4 + 40);
  v22 = (_QWORD *)v25;
  if (v21)
  {
    *v21 = v25;
    v22 = (_QWORD *)v25;
  }
  else
  {
    *v14 = v25;
  }
  *(_QWORD *)(a4 + 40) = v22;
  *v22 = 0;
  v23 = v25;
  *(_QWORD *)(v25 + 8) = a4;
  *(_WORD *)(v23 + 16) = v11;
  *(_DWORD *)(v23 + 18) = 1;
  *(_QWORD *)(v23 + 24) = a6;
  if (a6)
    ++*(_WORD *)(a6 + 20);
  *(_WORD *)(v23 + 32) = a7;
  *(_WORD *)(v23 + 34) = a8;
  *(_BYTE *)(v23 + 36) = a9;
  *(_QWORD *)(v23 + 40) = a10;
  if (*(int *)a2 >= 3)
  {
    result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WString(a1, "inserted pos/state element ", 0);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WInt(a1, *(__int16 *)(*(_QWORD *)(v25 + 8) + 16), 0);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WString(a1, "/", 0);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WInt(a1, *(__int16 *)(v25 + 16), 0);
            if ((result & 0x80000000) == 0)
              return mosyntbase_WLn(a1);
          }
        }
      }
    }
  }
  return result;
}

uint64_t DisposePosition(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t result;

  v7 = *a4;
  v8 = *(_QWORD *)(*a4 + 32);
  if (v8)
  {
    v9 = *(_QWORD **)(*a4 + 32);
    do
    {
      v10 = v9;
      v9 = (_QWORD *)*v9;
    }
    while (v9);
    *v10 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v8;
    v7 = *a4;
  }
  result = mosyntdata_DisposePhonEleList(a1, (_QWORD **)(v7 + 24));
  if ((result & 0x80000000) == 0)
  {
    result = mosyntpal_DEALLOCATE(a1, a4);
    if ((result & 0x80000000) == 0)
      --*(_DWORD *)(a3 + 64);
  }
  return result;
}

uint64_t FindEmissionState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v8;
  uint64_t *v9;
  __int16 v10;
  uint64_t result;
  _QWORD *v12;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;

  v3 = **(_QWORD ***)(a3 + 120);
  if (v3)
  {
    v4 = (uint64_t *)v3[4];
    if (v4)
    {
      do
      {
        if (!*((_WORD *)v4 + 10))
        {
          v8 = v4;
          while (1)
          {
            v9 = (uint64_t *)v8[3];
            if (!v9)
              break;
            v10 = *((_WORD *)v9 + 10) - 1;
            *((_WORD *)v9 + 10) = v10;
            v8[3] = 0;
            v8 = v9;
            if (v10)
              goto LABEL_9;
          }
          v8[3] = 0;
        }
LABEL_9:
        v4 = (uint64_t *)*v4;
      }
      while (v4);
      result = 0;
      *(_QWORD *)(a3 + 104) = 0;
      while (1)
      {
        v12 = (_QWORD *)v3[4];
        if (!v12)
          break;
        v13 = 0;
        v14 = 0;
        v15 = (_QWORD *)v3[4];
        do
        {
          v16 = (_QWORD *)*v15;
          if (*((_WORD *)v15 + 10))
          {
            v14 = v15;
          }
          else
          {
            *v15 = *(_QWORD *)(a2 + 16);
            *(_QWORD *)(a2 + 16) = v15;
            if (v14)
              v17 = v14;
            else
              v17 = v3 + 4;
            if (!v14)
              v12 = v16;
            *v17 = v16;
            v13 = 1;
          }
          v15 = v16;
        }
        while (v16);
        v3[5] = v14;
        if (!v12)
          goto LABEL_26;
        if (*v12 || *(_DWORD *)(a3 + 128) == 1 && (v18 = v3[3]) != 0 && *(_BYTE *)(v18 + 20))
        {
          v12 = 0;
          goto LABEL_29;
        }
LABEL_28:
        *(_QWORD *)(a3 + 104) = v12;
LABEL_29:
        v3 = (_QWORD *)*v3;
        if (!v3 || !v13 || v12)
          return result;
      }
      v13 = 0;
      v3[5] = 0;
LABEL_26:
      result = mosyntbase_WriteDevelMessage(a1, "*** no state left\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
      if ((result & 0x80000000) != 0)
        return result;
      v12 = 0;
      goto LABEL_28;
    }
  }
  return 0;
}

uint64_t GetInPhonList(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;

  v12 = 0;
  result = mosyntdata_StartPhonList(a1, a4, &v12);
  if (a3)
  {
    if ((result & 0x80000000) == 0)
    {
      v9 = *(_QWORD *)(a2 + 112);
      if (v9)
      {
        v10 = *(_QWORD *)(a3 + 8);
        while (v9 != v10)
        {
          if (*(_QWORD *)(v9 + 24))
          {
            v11 = *(uint64_t **)(v9 + 24);
            result = mosyntdata_CopyPhonList(a1, &v11);
            if ((result & 0x80000000) != 0)
              return result;
            result = mosyntdata_AppendPhonList(a1, a4, &v12, (uint64_t)v11, (uint64_t)v11);
            if ((result & 0x80000000) != 0)
              return result;
            v10 = *(_QWORD *)(a3 + 8);
          }
          v9 = *(_QWORD *)(v9 + 8);
        }
      }
    }
  }
  return result;
}

uint64_t TraceTransductionIO(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, _QWORD *a5)
{
  uint64_t result;
  unsigned int v11;

  result = mosyntknowl_WriteTraceHeader(a1, a3[4]);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntbase_WString(a1, "fst: ", 0);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WInt(a1, a3[5], 1);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, " transduction ", 0);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WString(a1, a4, 20);
          if ((result & 0x80000000) == 0)
          {
            if (a3[10] - 1 > 1 || (result = mosyntbase_WString(a1, " (IPA)", 0), (result & 0x80000000) == 0))
            {
              result = mosyntbase_WString(a1, ": ", 0);
              if ((result & 0x80000000) == 0)
              {
                if (a3[32] == 1)
                  v11 = 5;
                else
                  v11 = 4;
                result = mosyntdata_WriteFormattedPhonList(a1, *(uint64_t **)(a2 + 8), a5, v11, 0);
                if ((result & 0x80000000) == 0)
                  return mosyntbase_WLn(a1);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fst_LoadData(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;
  _OWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  _DWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int *v49;
  int v50;
  uint64_t v51;
  _DWORD *v52;
  _DWORD *v53;
  int *v54;
  int *v55;
  int v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  int v60;
  unsigned __int8 v61;
  int *v62;
  unsigned int v63;
  _OWORD v64[16];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  v58 = 0;
  memset(v64, 0, sizeof(v64));
  *a3 = 0;
  result = InitRsrcFunction(a1, a2, &v58);
  if ((result & 0x80000000) == 0)
  {
    result = kbaux_BuildBrokerString((uint64_t)v58, "fsts", (char *)v64, 0x100uLL);
    if ((result & 0x80000000) == 0)
    {
      v7 = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v64, "FSTS", 1031, (uint64_t *)&v57);
      if (v7 < 0)
      {
        v17 = v7;
      }
      else
      {
        v16 = v57;
        v15 = v58;
        v63 = 0;
        v62 = 0;
        v61 = 0;
        v60 = 0;
        v17 = ssftriff_reader_OpenChunk((uint64_t)v57, &v60, &v63, &v62, v11, v12, v13, v14);
        if ((v17 & 0x80000000) == 0 && !(v60 ^ 0x53545346 | v61))
        {
          v59 = 0;
          v17 = ssftriff_reader_DetachChunkData((uint64_t)v16, (uint64_t *)&v59, &v62, v10, v11, v12, v13, v14);
          if ((v17 & 0x80000000) == 0)
          {
            v18 = (_OWORD *)heap_Alloc(v15[1], 48);
            *a3 = (uint64_t)v18;
            if (!v18)
              goto LABEL_23;
            v18[1] = 0u;
            v18[2] = 0u;
            *v18 = 0u;
            v26 = *a3;
            *(_DWORD *)v26 = v63;
            *(_QWORD *)(v26 + 16) = v59;
            v27 = v62;
            *(_QWORD *)(*a3 + 8) = v62;
            v29 = *v27;
            v28 = v27 + 1;
            v30 = *a3;
            *(_DWORD *)(v30 + 24) = v29;
            *(_QWORD *)(v30 + 32) = v28;
            v31 = *(int *)(*a3 + 24);
            *(_QWORD *)(*a3 + 40) = heap_Alloc(v15[1], (16 * v31));
            v32 = *(void **)(*a3 + 40);
            if (v32)
            {
              bzero(v32, (16 * *(_DWORD *)(*a3 + 24)));
              v33 = *a3;
              if (*(int *)(*a3 + 24) >= 1)
              {
                v34 = 0;
                v35 = &v28[v31];
                do
                {
                  v36 = *v35++;
                  v37 = *(_QWORD *)(v33 + 40) + 16 * v34;
                  *(_DWORD *)v37 = v36;
                  *(_QWORD *)(v37 + 8) = 0;
                  v33 = *a3;
                  v38 = *(_DWORD *)(*(_QWORD *)(*a3 + 40) + 16 * v34);
                  if (v38 >= 1)
                  {
                    *(_QWORD *)(*(_QWORD *)(*a3 + 40) + 16 * v34 + 8) = heap_Alloc(v15[1], (v38 << 6));
                    v39 = *(_QWORD *)(*a3 + 40);
                    v40 = *(void **)(v39 + 16 * v34 + 8);
                    if (!v40)
                      goto LABEL_23;
                    bzero(v40, (*(_DWORD *)(v39 + 16 * v34) << 6));
                    v33 = *a3;
                    v41 = *(_QWORD *)(*a3 + 40);
                    if (*(int *)(v41 + 16 * v34) >= 1)
                    {
                      v42 = 0;
                      v43 = *(_QWORD *)(v41 + 16 * v34 + 8);
                      v44 = 56;
                      do
                      {
                        v46 = *v35;
                        v45 = v35 + 1;
                        v47 = v43 + v44;
                        *(_DWORD *)(v47 - 56) = v46;
                        *(_QWORD *)(v47 - 48) = v45;
                        v48 = *(_QWORD *)(*(_QWORD *)(*a3 + 40) + 16 * v34 + 8) + v44;
                        v49 = &v45[*(_DWORD *)(v48 - 56) + 1];
                        v50 = *v49++;
                        *(_DWORD *)(v48 - 40) = v50;
                        *(_QWORD *)(v48 - 32) = v49;
                        v51 = *(_QWORD *)(*(_QWORD *)(*a3 + 40) + 16 * v34 + 8) + v44;
                        v52 = (int *)((char *)v49 + 6 * *(int *)(v51 - 40) + 2 * (*(_DWORD *)(v51 - 40) & 1));
                        *(_DWORD *)(v51 - 24) = *v52;
                        *(_DWORD *)(v51 - 16) = v52[1];
                        v53 = v52 + 2;
                        *(_QWORD *)(v51 - 8) = v52 + 2;
                        v33 = *a3;
                        v54 = (int *)(*(_QWORD *)(*a3 + 40) + 16 * v34);
                        v43 = *((_QWORD *)v54 + 1);
                        v55 = (_DWORD *)((char *)v53
                                       + 2 * *(_DWORD *)(v43 + v44 - 16)
                                       + 2 * (*(_DWORD *)(v43 + v44 - 16) & 1));
                        v56 = *v55;
                        v35 = v55 + 1;
                        *(_DWORD *)(v43 + v44) = v56;
                        ++v42;
                        v44 += 64;
                      }
                      while (v42 < *v54);
                    }
                  }
                  ++v34;
                }
                while (v34 < *(int *)(v33 + 24));
              }
            }
            else
            {
LABEL_23:
              ssftriff_reader_ReleaseChunkData(v59, v19, v20, v21, v22, v23, v24, v25);
              free_FSTS(v15, a3);
              v17 = -1923080182;
            }
          }
        }
      }
      LODWORD(result) = ssftriff_reader_ObjClose(v57, v8, v9, v10, v11, v12, v13, v14);
      if (v17 >= 0)
        return result;
      else
        return v17;
    }
  }
  return result;
}

uint64_t fst_UnloadData(_WORD *a1, int a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t inited;
  _QWORD *v13;

  v13 = 0;
  if (!a3)
    return 2371887111;
  inited = InitRsrcFunction(a1, a2, &v13);
  if ((inited & 0x80000000) == 0)
  {
    if (*a3)
      ssftriff_reader_ReleaseChunkData(*(_QWORD **)(*a3 + 16), v4, v5, v6, v7, v8, v9, v10);
    free_FSTS(v13, a3);
  }
  return inited;
}

_QWORD *free_FSTS(_QWORD *result, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *a2;
  if (v3)
  {
    v4 = result;
    v5 = *(_QWORD *)(v3 + 40);
    if (v5)
    {
      if (*(int *)(v3 + 24) >= 1)
      {
        v6 = 0;
        v7 = 8;
        do
        {
          if (*(_QWORD *)(*(_QWORD *)(v3 + 40) + v7))
          {
            heap_Free((_QWORD *)v4[1], *(_QWORD *)(*(_QWORD *)(v3 + 40) + v7));
            v3 = *a2;
          }
          ++v6;
          v7 += 16;
        }
        while (v6 < *(int *)(v3 + 24));
        v5 = *(_QWORD *)(v3 + 40);
      }
      heap_Free((_QWORD *)v4[1], v5);
      v3 = *a2;
    }
    result = heap_Free((_QWORD *)v4[1], v3);
    *a2 = 0;
  }
  return result;
}

uint64_t fst_getFSTSeq(uint64_t a1, int a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = 2371887111;
  *a4 = 0;
  *a3 = 0;
  if (a1)
  {
    v6 = *(unsigned int *)(a1 + 24);
    v7 = 16 * v6;
    while ((int)v6 >= 1)
    {
      v8 = *(_QWORD *)(a1 + 32) + 4 * v6--;
      v7 -= 16;
      if (*(_DWORD *)(v8 - 4) == a2)
      {
        result = 0;
        *a3 = *(_QWORD *)(a1 + 40) + v7;
        *a4 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + v7);
        return result;
      }
    }
  }
  return result;
}

uint64_t fst_getFST(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t result;

  result = 2371887111;
  *a3 = 0;
  if (a1)
  {
    if (*(_DWORD *)a1 > a2)
    {
      result = 0;
      *a3 = *(_QWORD *)(a1 + 8) + ((uint64_t)a2 << 6);
    }
  }
  return result;
}

uint64_t fst_Trans(uint64_t result, int a2, int *a3)
{
  int v3;

  if (result)
  {
    v3 = *(__int16 *)(*(_QWORD *)(result + 24) + 6 * *a3 + 4) + *(_DWORD *)(result + 32) * (a2 - 1) - 1;
    if (v3 < 0 || v3 >= *(_DWORD *)(result + 40))
      return 0;
    else
      return *(__int16 *)(*(_QWORD *)(result + 48) + 2 * v3);
  }
  return result;
}

BOOL fst_validPair(_DWORD *a1)
{
  int v1;

  v1 = a1[1];
  return (v1 & 0x80000000) == 0 && *a1 < v1;
}

double fst_firstSamePair(__int16 *a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  uint64_t i;
  int v12;
  double result;

  if (!a1
    || (v3 = *((_QWORD *)a1 + 1),
        v4 = a2 % *a1,
        v5 = *(_DWORD *)(v3 + 4 * v4),
        v6 = v4 + 1,
        v5 >= *(_DWORD *)(v3 + 4 * v6))
    || (*(_DWORD *)a3 = v5, v7 = *(unsigned int *)(v3 + 4 * v6), *(_DWORD *)(a3 + 4) = v7, (v7 & 0x80000000) != 0)
    || v5 >= (int)v7)
  {
LABEL_10:
    result = NAN;
    *(_QWORD *)a3 = -1;
    return result;
  }
  v8 = *((_QWORD *)a1 + 3);
  if (*(unsigned __int16 *)(v8 + 6 * v5) != (unsigned __int16)a2)
  {
    v9 = v5;
    v10 = (unsigned __int16 *)(v8 + 6 * v5 + 6);
    for (i = v9 + 1; i < v7; ++i)
    {
      *(_DWORD *)a3 = i;
      v12 = *v10;
      v10 += 3;
      if (v12 == (unsigned __int16)a2)
        return result;
    }
    goto LABEL_10;
  }
  return result;
}

uint64_t fst_nextSamePair(uint64_t a1, int *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  unsigned __int16 *v7;
  int v8;
  uint64_t result;

  if (!a1 || (v2 = a2[1], v2 < 0) || (v3 = *a2, v4 = *a2 + 1, v4 >= v2))
  {
LABEL_7:
    result = 0;
    *(_QWORD *)a2 = -1;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 24);
    v6 = *(unsigned __int16 *)(v5 + 6 * v3);
    v7 = (unsigned __int16 *)(v5 + 6 * v3 + 6);
    while (1)
    {
      v8 = *v7;
      v7 += 3;
      if (v6 == v8)
        break;
      if (v2 == ++v4)
        goto LABEL_7;
    }
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t fst_getPair(uint64_t a1, _DWORD *a2, _WORD *a3, _WORD *a4, _WORD *a5)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;

  result = 2371887111;
  if (a1)
  {
    v7 = a2[1];
    if ((v7 & 0x80000000) == 0 && *a2 < v7)
    {
      result = 0;
      v8 = *(_QWORD *)(a1 + 24);
      v9 = 3 * *a2;
      *a3 = *(_WORD *)(v8 + 2 * v9);
      *a4 = *(_WORD *)(v8 + 2 * (v9 + 1));
      *a5 = *(_WORD *)(v8 + 2 * (v9 + 2));
    }
  }
  return result;
}

uint64_t fst_getTransductionMode(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  if (!a1)
    return 2371887111;
  result = 0;
  *a2 = *(_DWORD *)(a1 + 56);
  return result;
}

uint64_t kblex_LoadOneLex(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  int v6;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int16 *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  char *v30;
  BOOL v31;
  int v32;
  int v33;
  char *v34;
  int v35;
  unsigned int v36;
  _QWORD *v38;
  unsigned int v39;
  _QWORD *v40;
  unsigned __int16 *v41;
  char __s1[4];
  char v43;
  char __s2[4];
  char v45;
  int v46;
  char v47;

  v5 = 2371887104;
  v40 = 0;
  *a5 = 0;
  v6 = *(unsigned __int16 *)(a4 + 264);
  switch(*(_WORD *)(a4 + 264))
  {
    case 0:
      v47 = 0;
      v9 = 19526;
      goto LABEL_4;
    case 1:
      v47 = 0;
      v9 = 19533;
LABEL_4:
      v10 = v9 | 0x58450000;
      goto LABEL_12;
    case 2:
      v47 = 0;
      v11 = 19795;
      goto LABEL_11;
    case 3:
      v47 = 0;
      v11 = 21584;
      goto LABEL_11;
    case 4:
      v47 = 0;
      v11 = 21571;
      goto LABEL_11;
    case 5:
      v47 = 0;
      v11 = 21569;
      goto LABEL_11;
    case 6:
      v47 = 0;
      v11 = 21575;
      goto LABEL_11;
    case 7:
      v47 = 0;
      v11 = 21072;
LABEL_11:
      v10 = v11 | 0x584C0000;
LABEL_12:
      v46 = v10;
      *(_DWORD *)__s2 = v10;
      v45 = 0;
      v43 = 0;
      *(_DWORD *)__s1 = 0;
      v41 = 0;
      v39 = 0;
      v12 = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)(a4 + 8), (char *)&v46, 1031, (uint64_t *)&v40);
      if (v12 < 0)
      {
        v20 = v12;
        goto LABEL_28;
      }
      v20 = ssftriff_reader_OpenChunk((uint64_t)v40, __s1, &v39, &v41, v16, v17, v18, v19);
      if (v20 < 0)
        goto LABEL_28;
      if (strcmp(__s1, __s2))
        goto LABEL_28;
      v38 = 0;
      v20 = ssftriff_reader_DetachChunkData((uint64_t)v40, (uint64_t *)&v38, &v41, v15, v16, v17, v18, v19);
      if (v20 < 0)
        goto LABEL_28;
      v21 = v41;
      if (v6 != *v41)
        goto LABEL_35;
      v22 = *((_DWORD *)v41 + 1);
      v23 = heap_Calloc(*(_QWORD **)(a3 + 8), 1, 296 * v22);
      if (v23)
      {
        v24 = v23;
        if (v22 <= 0)
        {
          __strcpy_chk();
        }
        else
        {
          v25 = 0;
          v26 = v21 + 4;
          do
          {
            v27 = v23 + v25;
            *(_BYTE *)(v27 + 260) = v26[1];
            *(_BYTE *)(v27 + 264) = v26[2];
            v28 = (int)v26[3];
            *(_DWORD *)(v27 + 268) = v28;
            v29 = v26 + 4;
            *(_QWORD *)(v27 + 272) = v29;
            v30 = (char *)v29 + v28;
            *(_DWORD *)(v27 + 280) = -1;
            *(_QWORD *)(v27 + 288) = v38;
            v31 = -(int)v28 < 0;
            v32 = -(int)v28 & 3;
            v33 = v28 & 3;
            if (!v31)
              v33 = -v32;
            v34 = &v30[-v33];
            v35 = *((_DWORD *)v34 + 1);
            v26 = v34 + 4;
            if (v35 != 1234567890)
              v20 = -1923080192;
            v25 += 296;
          }
          while (296 * v22 != v25);
          __strcpy_chk();
          if (v20 < 0)
          {
            ssftriff_reader_ReleaseChunkData(v38, v13, v14, v15, v16, v17, v18, v19);
            heap_Free(*(_QWORD **)(a3 + 8), v24);
LABEL_28:
            v24 = 0;
          }
        }
      }
      else
      {
        LODWORD(v5) = -1923080182;
LABEL_35:
        ssftriff_reader_ReleaseChunkData(v38, v13, v14, v15, v16, v17, v18, v19);
        v24 = 0;
        v20 = v5;
      }
      v36 = ssftriff_reader_ObjClose(v40, v13, v14, v15, v16, v17, v18, v19);
      if (v20 >= 0)
        v5 = v36;
      else
        v5 = v20;
      *a5 = v24;
      return v5;
    default:
      return v5;
  }
}

uint64_t kblex_loadLex(_WORD *a1, int a2, _WORD *a3, int a4, int a5, _QWORD *a6)
{
  __int16 v7;
  unsigned __int16 v10;
  uint64_t result;
  int v12;
  const char *v13;
  uint64_t ObjcForThisApi;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  char v36[256];
  _QWORD v37[4];

  v37[3] = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17 = 0;
  v15 = 0;
  memset(v36, 0, sizeof(v36));
  v7 = a5;
  switch(a5)
  {
    case 0:
      BYTE4(v37[0]) = 0;
      v10 = 27750;
      goto LABEL_5;
    case 1:
      BYTE4(v37[0]) = 0;
      v10 = 27757;
LABEL_5:
      v12 = v10 | 0x78650000;
      goto LABEL_7;
    case 2:
      strcpy((char *)v37 + 4, "x");
      v12 = 1701604723;
LABEL_7:
      LODWORD(v37[0]) = v12;
      goto LABEL_14;
    case 3:
      strcpy((char *)v37 + 7, "lex");
      v13 = "phontablex";
      goto LABEL_13;
    case 4:
      strcpy((char *)v37 + 7, "lex");
      v13 = "constablex";
      goto LABEL_13;
    case 5:
      strcpy((char *)v37 + 7, "lex");
      v13 = "atomtablex";
      goto LABEL_13;
    case 6:
      strcpy((char *)&v37[1], "lex");
      v13 = "graphtablex";
      goto LABEL_13;
    case 7:
      strcpy((char *)v37 + 7, "lex");
      v13 = "proptablex";
LABEL_13:
      v37[0] = *(_QWORD *)v13;
LABEL_14:
      result = InitRsrcFunction(a1, a2, &v17);
      if ((result & 0x80000000) != 0)
        goto LABEL_19;
      result = InitRsrcFunction(a3, a4, &v16);
      if ((result & 0x80000000) != 0)
        goto LABEL_19;
      result = kbaux_BuildBrokerString(v17, (const char *)v37, v36, 0x100uLL);
      if ((result & 0x80000000) != 0)
        goto LABEL_19;
      v35 = 0;
      v34 = 0u;
      v33 = 0u;
      v32 = 0u;
      v31 = 0u;
      v30 = 0u;
      v29 = 0u;
      v28 = 0u;
      v27 = 0u;
      v26 = 0u;
      v25 = 0u;
      v24 = 0u;
      v23 = 0u;
      v22 = 0u;
      v21 = 0u;
      v20 = 0u;
      v19 = 0u;
      v18 = v17;
      __strcpy_chk();
      LOWORD(v35) = v7;
      ObjcForThisApi = getObjcForThisApi(v17, v16);
      result = objc_GetAddRefCountedObject(ObjcForThisApi, (uint64_t)v36, (uint64_t (*)(_QWORD, _QWORD, uint64_t, __int128 *, uint64_t))kblex_loc_ObjcLoadLex, (void (*)(_QWORD, _QWORD, __int128 *))kblex_loc_ObjcUnloadLex, (uint64_t)&v18, &v15);
      if ((result & 0x80000000) != 0)
LABEL_19:
        *a6 = 0;
      else
        *a6 = *(_QWORD *)(v15 + 32);
      break;
    default:
      result = 2371887104;
      break;
  }
  return result;
}

uint64_t kblex_loc_ObjcLoadLex(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9;
  uint64_t result;
  _BYTE v11[408];
  const void *v12;

  v9 = *a5;
  v12 = 0;
  result = InitRsrcFunction(a1, a2, &v12);
  if ((result & 0x80000000) == 0)
  {
    memcpy(v11, v12, sizeof(v11));
    *(_OWORD *)&v11[32] = *(_OWORD *)(v9 + 32);
    return kblex_LoadOneLex(a1, a2, (uint64_t)v11, (uint64_t)a5, (uint64_t *)(a4 + 32));
  }
  return result;
}

uint64_t kblex_loc_ObjcUnloadLex(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = 0;
  result = InitRsrcFunction(a1, a2, &v14);
  if ((result & 0x80000000) == 0)
  {
    v12 = *(_QWORD *)(a3 + 32);
    if (v12)
    {
      v13 = v14;
      ssftriff_reader_ReleaseChunkData(*(_QWORD **)(v12 + 288), v5, v6, v7, v8, v9, v10, v11);
      heap_Free(*(_QWORD **)(v13 + 8), v12);
      return 0;
    }
    else
    {
      return 2371887111;
    }
  }
  return result;
}

uint64_t kblex_InitLex(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int16 a9, _QWORD *a10)
{
  uint64_t result;

  LODWORD(result) = kblex_loadLex(a1, a2, a3, a4, a9, a10);
  if ((int)result < 0 && a9 == 0)
    return 0;
  else
    return result;
}

uint64_t kblex_FinishLex(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t result;
  uint64_t ObjcForThisApi;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = 0;
  result = InitRsrcFunction(a3, a4, &v10);
  if ((result & 0x80000000) == 0)
  {
    result = InitRsrcFunction(a1, a2, &v11);
    if ((result & 0x80000000) == 0)
    {
      ObjcForThisApi = getObjcForThisApi(v11, v10);
      return objc_ReleaseObject(ObjcForThisApi, a5);
    }
  }
  return result;
}

uint64_t mosyntsentana_InsertTerminalEdge(uint64_t a1, int *a2, signed int a3, signed int a4, signed int a5, uint64_t a6, uint64_t a7, int a8)
{
  __int16 v8;
  signed int v10;
  char *v11;
  __int16 v12;
  signed int v17;
  BOOL v18;
  int *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t result;
  _OWORD *v24;
  int *v25;
  uint64_t *v26;
  uint64_t v27;
  _OWORD *v28;
  __int16 *v29;
  uint64_t v30;
  __int16 *v31;
  uint64_t v32;
  uint64_t v33;
  __int16 *v34;
  uint64_t v35;
  uint64_t v36;
  __int16 *v37;
  _OWORD v38[6];
  int v39;
  uint64_t v40;

  v8 = a3;
  v40 = *MEMORY[0x1E0C80C00];
  if (a3 < 0)
  {
    v11 = "tried to insert terminal sentence edge starting at position ";
    a4 = a3;
    return mosyntbase_WInt3Ln(a1, (unsigned __int8 *)v11, 0, a4, (unsigned __int8 *)&byte_1DEBD87CE, 0);
  }
  v10 = a4;
  if (a4 >= 5001)
  {
    v11 = "impossible to insert terminal sentence edge ending at position ";
    return mosyntbase_WInt3Ln(a1, (unsigned __int8 *)v11, 0, a4, (unsigned __int8 *)&byte_1DEBD87CE, 0);
  }
  v12 = a5;
  if (a5 < 0)
  {
    v11 = "tried to insert terminal sentence edge with constituent id < 0: ";
    a4 = a5;
    return mosyntbase_WInt3Ln(a1, (unsigned __int8 *)v11, 0, a4, (unsigned __int8 *)&byte_1DEBD87CE, 0);
  }
  v17 = a2[10010];
  v18 = v17 < a3;
  if (v17 <= a3)
    v17 = a3;
  if (v18 || v17 < a4)
  {
    if (v17 <= a4)
      v17 = a4;
    a2[10010] = v17;
  }
  v20 = &a2[2 * a3];
  v22 = *((_QWORD *)v20 + 4);
  v21 = (uint64_t *)(v20 + 8);
  if (!v22)
  {
    result = mosyntpal_ALLOCATE(a1, v21, 0x130u);
    if ((result & 0x80000000) != 0)
      return result;
    v24 = (_OWORD *)*v21;
    v24[17] = 0u;
    v24[18] = 0u;
    v24[15] = 0u;
    v24[16] = 0u;
    v24[13] = 0u;
    v24[14] = 0u;
    v24[11] = 0u;
    v24[12] = 0u;
    v24[9] = 0u;
    v24[10] = 0u;
    v24[7] = 0u;
    v24[8] = 0u;
    v24[5] = 0u;
    v24[6] = 0u;
    v24[3] = 0u;
    v24[4] = 0u;
    v24[1] = 0u;
    v24[2] = 0u;
    *v24 = 0u;
  }
  v25 = &a2[2 * v10];
  v27 = *((_QWORD *)v25 + 4);
  v26 = (uint64_t *)(v25 + 8);
  if (!v27)
  {
    result = mosyntpal_ALLOCATE(a1, v26, 0x130u);
    if ((result & 0x80000000) != 0)
      return result;
    v28 = (_OWORD *)*v26;
    v28[17] = 0u;
    v28[18] = 0u;
    v28[15] = 0u;
    v28[16] = 0u;
    v28[13] = 0u;
    v28[14] = 0u;
    v28[11] = 0u;
    v28[12] = 0u;
    v28[9] = 0u;
    v28[10] = 0u;
    v28[7] = 0u;
    v28[8] = 0u;
    v28[5] = 0u;
    v28[6] = 0u;
    v28[3] = 0u;
    v28[4] = 0u;
    v28[1] = 0u;
    v28[2] = 0u;
    *v28 = 0u;
  }
  v37 = 0;
  memset(v38, 0, sizeof(v38));
  v39 = 0;
  ++a2[25026];
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v37, 0x78u);
  if ((result & 0x80000000) == 0)
  {
    v29 = v37;
    v37[12] = v8;
    v29[13] = v10;
    v29[14] = v12;
    v30 = *(_QWORD *)(a6 + 16);
    *((_OWORD *)v29 + 2) = *(_OWORD *)a6;
    *((_QWORD *)v29 + 6) = v30;
    *((_BYTE *)v29 + 58) = 1;
    *((_QWORD *)v29 + 8) = a7;
    result = mosyntkbsgram_NilIter((_QWORD *)v29 + 10);
    if ((result & 0x80000000) == 0)
    {
      v31 = v37;
      *((_DWORD *)v37 + 24) = a8;
      *((_BYTE *)v31 + 57) = 0;
      *((_QWORD *)v31 + 13) = 0;
      *((_BYTE *)v31 + 112) = 0;
      v32 = *v26;
      v33 = (__int16)(v31[14]
                    - 37
                    * ((((7085 * v31[14]) >> 16) >> 2)
                     + ((unsigned __int16)((7085 * v31[14]) >> 16) >> 15)));
      *(_QWORD *)v31 = *(_QWORD *)(*v26 + 8 * v33);
      *(_QWORD *)(v32 + 8 * v33) = v37;
      v34 = v37;
      *((_QWORD *)v37 + 2) = 0;
      *((_BYTE *)v34 + 56) = 0;
      v35 = *(_QWORD *)(*v21 + 296);
      if (v35)
      {
        v36 = *(_QWORD *)(*v21 + 296);
        while (*(unsigned __int16 *)(v36 + 28) != (unsigned __int16)v34[14])
        {
          v36 = *(_QWORD *)(v36 + 8);
          if (!v36)
            goto LABEL_28;
        }
      }
      else
      {
LABEL_28:
        *((_QWORD *)v34 + 1) = v35;
        *(_QWORD *)(*v21 + 296) = v34;
      }
      if (*a2 >= 3)
      {
        m2__cp__str("inserted terminal edge", v38, 100);
        return WriteEdge(a1, (uint64_t)a2, (unsigned __int8 *)v38, 100, v37);
      }
    }
  }
  return result;
}

uint64_t WriteEdge(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, __int16 *a5)
{
  uint64_t result;

  result = mosyntbase_WString(a1, a3, a4);
  if (a5)
  {
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntkbsymtab_WriteConsAndFeat(a1, *(uint64_t **)(a2 + 8), a5[14], a5 + 16);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WString(a1, " from pos ", 0);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WInt(a1, a5[12], 0);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WString(a1, " to pos ", 0);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WInt(a1, a5[13], 0);
    if ((result & 0x80000000) != 0)
      return result;
    return mosyntbase_WLn(a1);
  }
  if ((result & 0x80000000) == 0)
  {
    result = mosyntbase_WString(a1, " NIL", 0);
    if ((result & 0x80000000) == 0)
      return mosyntbase_WLn(a1);
  }
  return result;
}

uint64_t mosyntsentana_CreateAndInitParseDesc(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD **v18;
  _OWORD *v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  result = mosyntpal_ALLOCATE(a1, a6, 0x18728u);
  if ((result & 0x80000000) == 0)
  {
    v13 = *a6;
    *(_DWORD *)v13 = a2;
    *(_QWORD *)(v13 + 8) = a3;
    *(_QWORD *)(*a6 + 16) = a4;
    v14 = *a6;
    *(_DWORD *)(v14 + 24) = a5;
    *(_QWORD *)(v14 + 100112) = 0;
    *(_QWORD *)(v14 + 100120) = 0;
    *(_QWORD *)(v14 + 100104) = 0;
    result = mosyntknowl_NewBindingDesc(a1, (uint64_t *)(v14 + 100128));
    if ((result & 0x80000000) == 0)
    {
      v15 = 0;
      v16 = *a6;
      v17 = 80056;
      do
      {
        *(_QWORD *)(v16 + v15 + 32) = 0;
        *(_QWORD *)(*a6 + v15 + 40048) = 0;
        v16 = *a6;
        *(_DWORD *)(*a6 + v17) = 0;
        v15 += 8;
        v17 += 4;
      }
      while (v15 != 40008);
      v18 = (_OWORD **)(v16 + 32);
      result = mosyntpal_ALLOCATE(a1, (uint64_t *)(v16 + 32), 0x130u);
      if ((result & 0x80000000) == 0)
      {
        v19 = *v18;
        v19[17] = 0u;
        v19[18] = 0u;
        v19[15] = 0u;
        v19[16] = 0u;
        v19[13] = 0u;
        v19[14] = 0u;
        v19[11] = 0u;
        v19[12] = 0u;
        v19[9] = 0u;
        v19[10] = 0u;
        v19[7] = 0u;
        v19[8] = 0u;
        v19[5] = 0u;
        v19[6] = 0u;
        v19[3] = 0u;
        v19[4] = 0u;
        v19[1] = 0u;
        v19[2] = 0u;
        *v19 = 0u;
        v20 = *a6;
        v22 = 0u;
        v23 = 0u;
        v21 = 0;
        v28 = 0;
        v27 = 0u;
        v26 = 0;
        v25 = 0u;
        v24 = 0;
        *(_OWORD *)(v20 + 100064) = 0u;
        result = mosyntkbsgram_GetFirstEmptyRule(*(_QWORD *)(v20 + 16), (uint64_t)&v22, &v21);
        if ((result & 0x80000000) == 0)
        {
          while (v21 >= 1)
          {
            result = mosyntkbsgram_GetRuleFeatLists((uint64_t *)&v22, &v27, &v25, &v23);
            if ((result & 0x80000000) == 0)
            {
              result = InsertRuleEdge(a1, v20, v21, (uint64_t)&v27, 0, 0, 0, 0, &v22);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntkbsgram_GetNextEmptyRule(*(_QWORD *)(v20 + 16), &v22, &v21);
                if ((result & 0x80000000) == 0)
                  continue;
              }
            }
            return result;
          }
          result = ParseAndOptimizePosition(a1, v20, 0, 0);
          if ((result & 0x80000000) == 0)
            *(_DWORD *)(*a6 + 40040) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t mosyntsentana_DisposeParseDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  _QWORD *v8;
  _QWORD *v10;

  if (!*a2)
    return 0;
  result = mosyntknowl_DisposeBindingDesc(a1, (uint64_t *)(*a2 + 100128));
  if ((result & 0x80000000) == 0)
  {
    v10 = 0;
    v5 = *a2;
    if ((*(_DWORD *)(*a2 + 40040) & 0x80000000) == 0)
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)(v5 + 8 * v6 + 32))
        {
          for (i = 0; i != 37; ++i)
          {
            v8 = *(_QWORD **)(*(_QWORD *)(*a2 + 8 * v6 + 32) + 8 * i);
            while (1)
            {
              v10 = v8;
              if (!v8)
                break;
              v8 = (_QWORD *)*v8;
              result = DisposeEdge(a1, (uint64_t *)&v10);
              if ((result & 0x80000000) != 0)
                return result;
            }
          }
          result = mosyntpal_DEALLOCATE(a1, (uint64_t *)(*a2 + 8 * v6 + 32));
          if ((result & 0x80000000) != 0)
            return result;
          v5 = *a2;
        }
      }
      while (v6++ < *(int *)(v5 + 40040));
    }
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  return result;
}

uint64_t DisposeEdge(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;
  _QWORD *v6;
  _QWORD *v7;

  v4 = *a2;
  if (*(_BYTE *)(*a2 + 58) && *(_QWORD *)(v4 + 64))
  {
    result = mosyntdata_DisposeTermInfo(a1, (uint64_t *)(v4 + 64));
    if ((result & 0x80000000) != 0)
      return result;
    v4 = *a2;
  }
  v6 = *(_QWORD **)(v4 + 104);
  while (1)
  {
    v7 = v6;
    if (!v6)
      break;
    v6 = (_QWORD *)*v6;
    result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v7);
    if ((result & 0x80000000) != 0)
      return result;
  }
  return mosyntpal_DEALLOCATE(a1, a2);
}

uint64_t mosyntsentana_DoParse(uint64_t a1, uint64_t a2)
{
  int *v2;
  int v3;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = (int *)(a2 + 40040);
  v3 = *(_DWORD *)(a2 + 40040);
  if (v3 < 1)
    return 0;
  v6 = 0;
  result = 0;
  v8 = a2 + 80056;
  v9 = a2 + 80060;
  do
  {
    v10 = v6 + 1;
    *(_DWORD *)(v9 + 4 * v6) = *(_DWORD *)(v8 + 4 * v6) + 1000;
    if (*(_QWORD *)(a2 + 8 * v6 + 40))
    {
      result = ParseAndOptimizePosition(a1, a2, (int)v6 + 1, v10 == v3);
      if ((result & 0x80000000) != 0)
        return result;
      v3 = *v2;
    }
    v6 = v10;
  }
  while (v10 < v3);
  return result;
}

uint64_t ParseAndOptimizePosition(uint64_t a1, uint64_t a2, signed int a3, int a4)
{
  int v5;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t FirstRuleSameLast;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t i;
  int v28;
  int v29;
  uint64_t j;
  int v31;
  uint64_t RuleVisAndCost;
  uint64_t v33;
  int v34;
  uint64_t *v35;
  unsigned int v36;
  int v37;
  _QWORD *v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  BOOL v42;
  uint64_t *v44;
  BOOL v45;
  uint64_t k;
  uint64_t m;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v56;
  uint64_t v57;
  int v58;
  _QWORD *v59;
  uint64_t *v60;
  int v61;
  _QWORD *v62;
  uint64_t v63;
  int v64;
  char v65;
  uint64_t v66[2];
  _QWORD v67[3];
  _QWORD v68[3];
  _QWORD v69[3];
  uint64_t v70;
  uint64_t v71;
  _QWORD v72[2];
  _QWORD v73[5];

  v5 = a3;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v73[3] = *MEMORY[0x1E0C80C00];
  v11 = a2 + 100080;
  v12 = a2 + 80056;
  v59 = (_QWORD *)(a2 + 40048);
  v13 = (uint64_t *)(a2 + 100064);
  *(_QWORD *)(a2 + 100096) = 0;
  *(_OWORD *)(a2 + 100064) = 0u;
  *(_OWORD *)(a2 + 100080) = 0u;
  do
  {
    v14 = *(uint64_t **)(*(_QWORD *)(a2 + 8 * a3 + 32) + 8 * v10);
    if (v14)
    {
      do
      {
        v15 = v14;
        v14[2] = 0;
        if (v9)
          v16 = v9 + 2;
        else
          v16 = (_QWORD *)(a2 + 100064);
        *v16 = v14;
        *(_QWORD *)(a2 + 100072) = v14;
        *((_BYTE *)v14 + 56) = 1;
        ++v8;
        v14 = (uint64_t *)*v14;
        v9 = v15;
      }
      while (*v15);
      *(_DWORD *)v11 = v8;
      v9 = v15;
    }
    ++v10;
  }
  while (v10 != 37);
  v66[0] = 0;
  v66[1] = 0;
  v65 = 0;
  v64 = 0;
  v63 = 0;
  if (*(int *)a2 >= 3)
  {
    FirstRuleSameLast = mosyntbase_WInt3Ln(a1, "treating agenda in position ", 0, a3, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    if ((FirstRuleSameLast & 0x80000000) != 0)
      return FirstRuleSameLast;
  }
  v58 = a4;
  v18 = *v13;
  if (*v13)
  {
    v19 = 0;
    memset(v73, 0, 24);
    v71 = 0;
    v72[0] = 0;
    v70 = 0;
    *(_QWORD *)((char *)v72 + 6) = 0;
    memset(v69, 0, sizeof(v69));
    memset(v68, 0, sizeof(v68));
    memset(v67, 0, sizeof(v67));
    v61 = v5;
    do
    {
      v20 = *(_QWORD *)(v18 + 16);
      *v13 = v20;
      if (!v20)
        *(_QWORD *)(v12 + 20016) = 0;
      *(_BYTE *)(v18 + 56) = 0;
      *(_QWORD *)(v18 + 16) = 0;
      if (*(int *)a2 >= 3)
      {
        m2__cp__str("  treating agenda edge", &v70, 30);
        FirstRuleSameLast = WriteEdge(a1, a2, (unsigned __int8 *)&v70, 30, (__int16 *)v18);
        if ((FirstRuleSameLast & 0x80000000) != 0)
          return FirstRuleSameLast;
      }
      FirstRuleSameLast = mosyntkbsgram_GetFirstRuleSameLast(*(_QWORD *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (char *)&v63 + 4, &v63);
      if ((FirstRuleSameLast & 0x80000000) != 0)
        return FirstRuleSameLast;
      while (v64 >= 1)
      {
        FirstRuleSameLast = mosyntkbsgram_GetRuleFeatLists(v66, v69, v68, v67);
        if ((FirstRuleSameLast & 0x80000000) != 0)
          return FirstRuleSameLast;
        if (v19 < 0)
        {
          FirstRuleSameLast = kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)FirstRuleSameLast);
          if ((FirstRuleSameLast & 0x80000000) != 0)
            return FirstRuleSameLast;
          v19 = 1000;
        }
        else
        {
          --v19;
        }
        v21 = *(_DWORD *)a2;
        if ((_DWORD)v63)
        {
          if (v21 >= 3)
          {
            FirstRuleSameLast = mosyntbase_WString(a1, "    looking for left edge ", 0);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), HIDWORD(v63));
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            FirstRuleSameLast = mosyntbase_WString(a1, " to complete ", 0);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v64);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            FirstRuleSameLast = mosyntbase_WLn(a1);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
          }
          v22 = HIDWORD(v63);
          FirstRuleSameLast = mosyntkbsgram_GetRuleFeatLists(v66, v69, v68, v67);
          if ((FirstRuleSameLast & 0x80000000) != 0)
            return FirstRuleSameLast;
          v23 = v22 % 37;
          if (*(__int16 *)(v18 + 24) <= 0)
          {
            v24 = v23;
          }
          else
          {
            v24 = v23;
            v25 = *(_QWORD *)(*(_QWORD *)(a2 + 8 * *(unsigned __int16 *)(v18 + 24) + 32) + 8 * v23);
            if (v25)
            {
              v56 = v23;
              while (1)
              {
                if (HIDWORD(v63) == *(__int16 *)(v25 + 28))
                {
                  v26 = *(_DWORD *)a2;
                  if (*(int *)a2 >= 3)
                  {
                    FirstRuleSameLast = mosyntbase_WStringLn(a1, "      found left edge; trying unification", 0);
                    if ((FirstRuleSameLast & 0x80000000) != 0)
                      return FirstRuleSameLast;
                    v26 = *(_DWORD *)a2;
                  }
                  FirstRuleSameLast = mosyntknowl_Unif2(a1, *(uint64_t **)(a2 + 8), v26, *(_QWORD *)(v11 + 48), (__int16 *)v68, (__int16 *)(v25 + 32), (__int16 *)v67, (__int16 *)(v18 + 32), (__int16 *)v69, (__int16 *)v73, &v65);
                  if ((FirstRuleSameLast & 0x80000000) != 0)
                    return FirstRuleSameLast;
                  if (v65)
                  {
                    FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v25 + 24), v61, v25, v18, v66);
                    if ((FirstRuleSameLast & 0x80000000) != 0)
                      return FirstRuleSameLast;
                  }
                }
                v25 = *(_QWORD *)v25;
                if (!v25)
                {
                  v24 = v56;
                  break;
                }
              }
            }
          }
          for (i = *(_QWORD *)(*(_QWORD *)(a2 + 32) + 8 * v24); i; i = *(_QWORD *)i)
          {
            if (HIDWORD(v63) == *(__int16 *)(i + 28))
            {
              v28 = *(_DWORD *)a2;
              if (*(int *)a2 >= 3)
              {
                FirstRuleSameLast = mosyntbase_WStringLn(a1, "      found left edge; trying unification", 0);
                if ((FirstRuleSameLast & 0x80000000) != 0)
                  return FirstRuleSameLast;
                v28 = *(_DWORD *)a2;
              }
              FirstRuleSameLast = mosyntknowl_Unif2(a1, *(uint64_t **)(a2 + 8), v28, *(_QWORD *)(v11 + 48), (__int16 *)v68, (__int16 *)(i + 32), (__int16 *)v67, (__int16 *)(v18 + 32), (__int16 *)v69, (__int16 *)v73, &v65);
              if ((FirstRuleSameLast & 0x80000000) != 0)
                return FirstRuleSameLast;
              if (v65)
              {
                FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v18 + 24), v61, i, v18, v66);
                if ((FirstRuleSameLast & 0x80000000) != 0)
                  return FirstRuleSameLast;
              }
            }
          }
        }
        else
        {
          if (v21 >= 3)
          {
            FirstRuleSameLast = mosyntbase_WString(a1, "    trying to directly complete ", 0);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v64);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            FirstRuleSameLast = mosyntbase_WLn(a1);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
            v21 = *(_DWORD *)a2;
          }
          FirstRuleSameLast = mosyntknowl_Unif (a1, *(uint64_t **)(a2 + 8), v21, *(_QWORD *)(v11 + 48), (unsigned __int16 *)v68, (unsigned __int16 *)(v18 + 32), (__int16 *)v69, (__int16 *)v73, &v65);
          if ((FirstRuleSameLast & 0x80000000) != 0)
            return FirstRuleSameLast;
          if (v65)
          {
            FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v18 + 24), v61, v18, 0, v66);
            if ((FirstRuleSameLast & 0x80000000) != 0)
              return FirstRuleSameLast;
          }
        }
        FirstRuleSameLast = mosyntkbsgram_GetNextRuleSameLast(*(_QWORD *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (_DWORD *)&v63 + 1, &v63);
        if ((FirstRuleSameLast & 0x80000000) != 0)
          return FirstRuleSameLast;
      }
      if (mosyntkbsgram_HasEmptyRules(*(_QWORD *)(a2 + 16)))
      {
        FirstRuleSameLast = mosyntkbsgram_GetFirstRuleSameFirst(*(_QWORD *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (char *)&v63 + 4, &v63);
        if ((FirstRuleSameLast & 0x80000000) != 0)
          return FirstRuleSameLast;
        while (v64 >= 1)
        {
          FirstRuleSameLast = mosyntkbsgram_GetRuleFeatLists(v66, v69, v68, v67);
          if ((FirstRuleSameLast & 0x80000000) != 0)
            return FirstRuleSameLast;
          v29 = v63;
          if ((int)v63 >= 1)
          {
            if (*(int *)a2 >= 3)
            {
              FirstRuleSameLast = mosyntbase_WString(a1, "    looking for empty right edge ", 0);
              if ((FirstRuleSameLast & 0x80000000) != 0)
                return FirstRuleSameLast;
              FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v63);
              if ((FirstRuleSameLast & 0x80000000) != 0)
                return FirstRuleSameLast;
              FirstRuleSameLast = mosyntbase_WString(a1, " to complete ", 0);
              if ((FirstRuleSameLast & 0x80000000) != 0)
                return FirstRuleSameLast;
              FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v64);
              if ((FirstRuleSameLast & 0x80000000) != 0)
                return FirstRuleSameLast;
              FirstRuleSameLast = mosyntbase_WLn(a1);
              if ((FirstRuleSameLast & 0x80000000) != 0)
                return FirstRuleSameLast;
              v29 = v63;
            }
            for (j = *(_QWORD *)(*(_QWORD *)(a2 + 32) + 8 * (v29 % 37)); j; j = *(_QWORD *)j)
            {
              if (v19 < 0)
              {
                FirstRuleSameLast = kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)FirstRuleSameLast);
                if ((FirstRuleSameLast & 0x80000000) != 0)
                  return FirstRuleSameLast;
                v19 = 1000;
              }
              else
              {
                --v19;
              }
              if ((_DWORD)v63 == *(__int16 *)(j + 28))
              {
                v31 = *(_DWORD *)a2;
                if (*(int *)a2 >= 3)
                {
                  FirstRuleSameLast = mosyntbase_WStringLn(a1, "      found empty right edge; trying unification ", 0);
                  if ((FirstRuleSameLast & 0x80000000) != 0)
                    return FirstRuleSameLast;
                  v31 = *(_DWORD *)a2;
                }
                FirstRuleSameLast = mosyntknowl_Unif2(a1, *(uint64_t **)(a2 + 8), v31, *(_QWORD *)(v11 + 48), (__int16 *)v68, (__int16 *)(v18 + 32), (__int16 *)v67, (__int16 *)(j + 32), (__int16 *)v69, (__int16 *)v73, &v65);
                if ((FirstRuleSameLast & 0x80000000) != 0)
                  return FirstRuleSameLast;
                if (v65)
                {
                  FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v18 + 24), v61, v18, j, v66);
                  if ((FirstRuleSameLast & 0x80000000) != 0)
                    return FirstRuleSameLast;
                }
              }
            }
          }
          FirstRuleSameLast = mosyntkbsgram_GetNextRuleSameFirst(*(_QWORD *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (_DWORD *)&v63 + 1, &v63);
          if ((FirstRuleSameLast & 0x80000000) != 0)
            return FirstRuleSameLast;
        }
      }
      v18 = *v13;
      v5 = v61;
    }
    while (*v13);
  }
  v70 = 0;
  v71 = 0;
  LOBYTE(v69[0]) = 0;
  LODWORD(v73[0]) = 0;
  RuleVisAndCost = mosyntkbsgram_NilIter(&v70);
  if ((RuleVisAndCost & 0x80000000) == 0)
  {
    if (v5)
    {
      if (v5 >= 1)
      {
        v33 = 0;
        v34 = 0;
        v35 = 0;
        v36 = v5;
        v37 = 0;
        v57 = v36;
        v38 = (_QWORD *)(a2 + 8 * v36 + 32);
        v60 = 0;
        v62 = v38;
        while (1)
        {
          v39 = *(uint64_t **)(*v38 + 8 * v33);
          if (v39)
            break;
LABEL_122:
          ++v33;
          v38 = v62;
          if (v33 == 37)
          {
            if (v35 || (v35 = v60, v37 = v34, v60))
            {
              *(_QWORD *)(a2 + 8 * v57 + 40048) = v35;
              *(_DWORD *)(a2 + 4 * v57 + 80056) = v37;
            }
            if (!v58 && (RuleVisAndCost & 0x80000000) == 0 && mosyntkbsgram_HasSimpleFollowRel(*(_QWORD *)(a2 + 16)))
            {
              FixEdgeAndSubEdges(*(_QWORD *)(a2 + 8 * v57 + 40048));
              for (k = 0; k != 37; ++k)
              {
                for (m = *(_QWORD *)(*v62 + 8 * k); m; m = *(_QWORD *)m)
                {
                  if (!*(_BYTE *)(m + 57))
                  {
                    v49 = *(_QWORD *)(*v62 + 296);
                    if (v49)
                    {
                      while (!mosyntkbsgram_IsFollowerCons(*(_QWORD *)(a2 + 16), *(__int16 *)(v49 + 28), *(__int16 *)(m + 28)))
                      {
                        v49 = *(_QWORD *)(v49 + 8);
                        if (!v49)
                          goto LABEL_132;
                      }
                      FixEdgeAndSubEdges(m);
                    }
                  }
LABEL_132:
                  ;
                }
              }
              v50 = 0;
              RuleVisAndCost = 0;
              v70 = 0;
              do
              {
                v51 = *v62;
                v52 = *(_QWORD *)(*v62 + 8 * v50);
                v70 = v52;
                v53 = 0;
                if (v52)
                {
                  do
                  {
                    v54 = *(_QWORD *)v52;
                    if (*(_BYTE *)(v52 + 57))
                    {
                      *(_QWORD *)v52 = v53;
                      v53 = v70;
                    }
                    else
                    {
                      ++*(_DWORD *)(v11 + 20);
                      ++*(_DWORD *)(v11 + 44);
                      if (*(_BYTE *)(v52 + 58))
                        --*(_DWORD *)(v11 + 24);
                      else
                        --*(_DWORD *)(v11 + 28);
                      RuleVisAndCost = DisposeEdge(a1, &v70);
                      if ((RuleVisAndCost & 0x80000000) != 0)
                        return RuleVisAndCost;
                    }
                    v70 = v54;
                    v52 = v54;
                  }
                  while (v54);
                  v51 = *v62;
                }
                *(_QWORD *)(v51 + 8 * v50++) = v53;
              }
              while (v50 != 37);
            }
            return RuleVisAndCost;
          }
        }
        while (1)
        {
          RuleVisAndCost = mosyntkbsgram_GetRuleVisAndCost((_DWORD *)v39 + 20, v69, v73);
          if ((RuleVisAndCost & 0x80000000) != 0)
            break;
          if (mosyntkbsgram_IsNilIter(v39 + 10) || !LOBYTE(v69[0]))
          {
            v40 = *((__int16 *)v39 + 12);
            v41 = *(_DWORD *)(a2 + 4 * v40 + 80056) + *((_DWORD *)v39 + 24) + 1000;
            if (*((_WORD *)v39 + 12) && !*(_QWORD *)(a2 + 8 * v40 + 40048))
            {
              v44 = v60;
              if (v60)
                v45 = v41 < v34;
              else
                v45 = 1;
              if (v45)
              {
                v34 = v41;
                v44 = v39;
              }
              v60 = v44;
            }
            else
            {
              if (v35)
                v42 = v41 < v37;
              else
                v42 = 1;
              if (v42)
              {
                v37 = v41;
                v35 = v39;
              }
            }
          }
          v39 = (uint64_t *)*v39;
          if (!v39)
            goto LABEL_122;
        }
      }
    }
    else
    {
      *v59 = 0;
      *(_DWORD *)v12 = 0;
    }
  }
  return RuleVisAndCost;
}

void mosyntsentana_GetOptimalTree(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  int started;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  uint64_t *v17;
  int v18;
  _QWORD *v19;
  __n128 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v6 = a2 + 40040;
  v7 = *(unsigned int *)(a2 + 40040);
  v19 = 0;
  v20 = 0uLL;
  v21 = 0;
  started = mosyntkbsgram_StartCons(*(_DWORD **)(a2 + 16));
  v9 = started;
  v10 = *(_QWORD *)(*(_QWORD *)(a2 + 8 * (int)v7 + 32) + 8 * (started % 37));
  if (!v10)
    goto LABEL_13;
  v11 = 0;
  do
  {
    if (started == *(__int16 *)(v10 + 28)
      && !*(_WORD *)(v10 + 24)
      && (!v11 || *(_DWORD *)(v10 + 96) < *(_DWORD *)(v11 + 96)))
    {
      v11 = v10;
    }
    v10 = *(_QWORD *)v10;
  }
  while (v10);
  if (v11)
  {
    if ((mosyntdata_StartPhonList(a1, a3, &v19) & 0x80000000) == 0)
      AppendTree(a1, v11, a3, (uint64_t *)&v19);
  }
  else
  {
LABEL_13:
    if (*(int *)a2 < 1
      || (mosyntbase_WStringLn(a1, "no syntactic analysis found; creating artificial tree", 0) & 0x80000000) == 0)
    {
      if ((int)v7 >= 1)
      {
        v12 = (int)v7;
        v13 = v7;
        do
        {
          v14 = *(_QWORD *)(a2 + 8 * v12 + 40048);
          if (v14)
          {
            v12 = *(__int16 *)(v14 + 24);
            if ((int)v12 + 1 < v13)
              bzero((void *)(a2 + 40056 + 8 * v12), 8 * (v13 - v12 - 2) + 8);
          }
          else
          {
            *(_QWORD *)(a2 + 8 * v13 + 40048) = 0;
            v12 = (v13 - 1);
          }
          v13 = v12;
        }
        while ((int)v12 > 0);
      }
      if ((mosyntdata_StartPhonList(a1, a3, &v19) & 0x80000000) == 0)
      {
        v20.n128_u16[0] = 0;
        mosyntdata_AddNode(a1, a3, &v19, 1, v9, &v20);
        if ((v15 & 0x80000000) == 0)
        {
          v16 = v19;
          v19[6] = *(unsigned int *)(a2 + 4 * (int)v7 + 80056);
          *((_DWORD *)v16 + 14) = v7;
          v19 = 0;
          if ((int)v7 >= 1)
          {
            v17 = (uint64_t *)(v6 + 16);
            do
            {
              if (*v17)
              {
                AppendTree(a1, *v17, (_QWORD *)(*a3 + 8), (uint64_t *)&v19);
                if (v18 < 0)
                  break;
              }
              ++v17;
              --v7;
            }
            while (v7);
          }
        }
      }
    }
  }
}

uint64_t mosyntsentana_DisplayTree(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;

  result = mosyntdata_WriteTree(a1, *(uint64_t **)(a2 + 8), 2, a3);
  if ((result & 0x80000000) == 0)
    return mosyntbase_WLn(a1);
  return result;
}

uint64_t mosyntsentana_DisposeTree(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mosyntdata_DisposeSyntTree(a1, a3);
}

uint64_t InsertRuleEdge(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  uint64_t v9;
  uint64_t RuleVisAndCost;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t i;
  _BOOL4 v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  __int16 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t *v38;
  int v39;
  __int16 *v40;
  __int16 *v41;
  int v42;
  char v43;
  int v44;
  uint64_t v45;
  _OWORD v46[3];
  __int16 v47;
  _QWORD v48[2];
  _QWORD v49[4];

  v49[2] = *MEMORY[0x1E0C80C00];
  v9 = a2 + 100064;
  if (*(_DWORD *)(a2 + 100084) > *(_DWORD *)(a2 + 24))
    return 0;
  v44 = 0;
  v48[1] = 0;
  v49[0] = 0;
  v48[0] = 0;
  *(_QWORD *)((char *)v49 + 6) = 0;
  v43 = 0;
  v42 = 0;
  memset(v46, 0, sizeof(v46));
  v47 = 0;
  RuleVisAndCost = mosyntkbsgram_GetRuleVisAndCost(a9, &v43, &v44);
  if ((RuleVisAndCost & 0x80000000) != 0)
    return RuleVisAndCost;
  if (a7)
  {
    v44 += *(_DWORD *)(a7 + 96);
    *(_BYTE *)(a7 + 112) = 1;
  }
  v41 = (__int16 *)a7;
  if (a8)
  {
    v44 += *(_DWORD *)(a8 + 96);
    *(_BYTE *)(a8 + 112) = 1;
  }
  v40 = (__int16 *)a8;
  v19 = a2 + 8 * a6;
  v21 = *(_QWORD *)(v19 + 32);
  v20 = (uint64_t *)(v19 + 32);
  v39 = a3 % 37;
  for (i = *(_QWORD *)(v21 + 8 * (a3 % 37)); ; i = *(_QWORD *)i)
  {
    v45 = i;
    if (!i)
      goto LABEL_20;
    if (*(__int16 *)(i + 28) == a3 && *(__int16 *)(i + 24) == a5)
    {
      v23 = mosyntknowl_DiffFeat(a1, (unsigned __int16 *)(i + 32), (unsigned __int16 *)a4);
      i = v45;
      if (!v23)
        break;
    }
  }
  if (v45)
  {
    v24 = v44;
    if (v44 >= *(_DWORD *)(v45 + 96))
      return RuleVisAndCost;
    if (*(_BYTE *)(v45 + 58) && *(int *)a2 >= 1)
    {
      v42 = 0;
      v25 = mosyntkbsymtab_AppConsFeatToString(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(v45 + 28), (__int16 *)(v45 + 32), (uint64_t)v46, 50, &v42);
      if ((v25 & 0x80000000) == 0)
        return mosyntbase_WString3Ln(a1, "***** illegal attempt to replace terminal constituent '", 0, (unsigned __int8 *)v46, 50, "' by rule-generated identical constituent", 0);
      return v25;
    }
    ++*(_DWORD *)(v9 + 32);
    ++*(_DWORD *)(v9 + 56);
    *(_OWORD *)(i + 80) = *(_OWORD *)a9;
    *(_DWORD *)(i + 96) = v24;
    *(_QWORD *)(i + 64) = v41;
    *(_QWORD *)(i + 72) = v40;
    if (!*(_BYTE *)(i + 56))
    {
      *(_QWORD *)(i + 16) = 0;
      v37 = *(_QWORD *)(v9 + 8);
      if (v37)
        v38 = (uint64_t *)(v37 + 16);
      else
        v38 = (uint64_t *)v9;
      *v38 = i;
      *(_QWORD *)(v9 + 8) = i;
      *(_BYTE *)(i + 56) = 1;
    }
    if (*(int *)a2 >= 3)
    {
      m2__cp__str("noted reparsing of edge ", v48, 30);
      v34 = a1;
      v35 = a2;
      v33 = (__int16 *)i;
      goto LABEL_31;
    }
  }
  else
  {
LABEL_20:
    ++*(_DWORD *)(v9 + 20);
    ++*(_DWORD *)(v9 + 44);
    if (v41)
    {
      if (v40)
      {
        v26 = v40[12];
        if (v41[12] < v26 && v26 < a6)
        {
          ++*(_DWORD *)(v9 + 24);
          ++*(_DWORD *)(v9 + 48);
        }
      }
    }
    RuleVisAndCost = mosyntpal_ALLOCATE(a1, &v45, 0x78u);
    if ((RuleVisAndCost & 0x80000000) == 0)
    {
      v27 = v45;
      *(_WORD *)(v45 + 24) = a5;
      *(_WORD *)(v27 + 26) = a6;
      *(_WORD *)(v27 + 28) = a3;
      v28 = *(_QWORD *)(a4 + 16);
      *(_OWORD *)(v27 + 32) = *(_OWORD *)a4;
      *(_QWORD *)(v27 + 48) = v28;
      *(_BYTE *)(v27 + 58) = 0;
      *(_QWORD *)(v27 + 64) = v41;
      *(_QWORD *)(v27 + 72) = v40;
      *(_OWORD *)(v27 + 80) = *(_OWORD *)a9;
      *(_DWORD *)(v27 + 96) = v44;
      *(_QWORD *)(v27 + 104) = 0;
      *(_BYTE *)(v27 + 112) = 0;
      *(_BYTE *)(v27 + 57) = a6 == 0;
      v29 = *v20;
      *(_QWORD *)v27 = *(_QWORD *)(*v20 + 8 * v39);
      *(_QWORD *)(v29 + 8 * v39) = v45;
      v30 = v45;
      *(_QWORD *)(v45 + 16) = 0;
      v31 = *(_QWORD *)(v9 + 8);
      v32 = (uint64_t *)(v31 ? v31 + 16 : v9);
      *v32 = v30;
      *(_QWORD *)(v9 + 8) = v30;
      *(_BYTE *)(v30 + 56) = 1;
      if (*(int *)a2 >= 3)
      {
        m2__cp__str("inserted edge", v48, 30);
        v33 = (__int16 *)v45;
        v34 = a1;
        v35 = a2;
LABEL_31:
        v25 = WriteEdge(v34, v35, (unsigned __int8 *)v48, 30, v33);
        if ((v25 & 0x80000000) == 0)
        {
          m2__cp__str("subedge1", v48, 30);
          v25 = WriteEdge(a1, a2, (unsigned __int8 *)v48, 30, v41);
          if ((v25 & 0x80000000) == 0)
          {
            m2__cp__str("subedge2", v48, 30);
            return WriteEdge(a1, a2, (unsigned __int8 *)v48, 30, v40);
          }
        }
        return v25;
      }
    }
  }
  return RuleVisAndCost;
}

uint64_t FixEdgeAndSubEdges(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    do
    {
      if (*(_BYTE *)(v1 + 57))
        break;
      *(_BYTE *)(v1 + 57) = 1;
      if (*(_BYTE *)(v1 + 58))
        break;
      result = FixEdgeAndSubEdges(*(_QWORD *)(v1 + 64));
      v1 = *(_QWORD *)(v1 + 72);
    }
    while (v1);
  }
  return result;
}

void AppendTree(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  int v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t *v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  char v19;
  uint64_t v20;

  if (a2)
  {
    if (!*(_BYTE *)(a2 + 58))
    {
      v19 = 0;
      v18 = 0;
      if ((mosyntkbsgram_GetRuleVisAndCost((_DWORD *)(a2 + 80), &v19, &v18) & 0x80000000) != 0)
        return;
      if (mosyntkbsgram_IsNilIter((_QWORD *)(a2 + 80)) || !v19)
      {
        AppendNode(a1, (__n128 *)a2, a3, (_QWORD **)a4);
        if (v15 < 0)
          return;
        v16 = (_QWORD *)*a4;
        *((_BYTE *)v16 + 60) = 0;
        v16[8] = 0;
        v20 = 0;
        v17 = v16 + 1;
        if ((AppendTree(a1, *(_QWORD *)(a2 + 64), v16 + 1, &v20) & 0x80000000) != 0)
          return;
        v11 = *(_QWORD *)(a2 + 72);
        v14 = &v20;
        v12 = a1;
        v13 = v17;
      }
      else
      {
        if ((AppendTree(a1, *(_QWORD *)(a2 + 64), a3, a4) & 0x80000000) != 0)
          return;
        v11 = *(_QWORD *)(a2 + 72);
        v12 = a1;
        v13 = a3;
        v14 = a4;
      }
      AppendTree(v12, v11, v13, v14);
      return;
    }
    AppendNode(a1, (__n128 *)a2, a3, (_QWORD **)a4);
    if ((v8 & 0x80000000) == 0)
    {
      v9 = (_QWORD *)*a4;
      *((_BYTE *)v9 + 60) = 1;
      mosyntdata_CopyTermInfo(a1, *(uint64_t **)(a2 + 64), v9 + 8);
      if ((v10 & 0x80000000) == 0)
        v9[1] = 0;
    }
  }
}

void AppendNode(uint64_t a1, __n128 *a2, _QWORD *a3, _QWORD **a4)
{
  int v6;
  _DWORD *v7;
  int v8;

  mosyntdata_AddNode(a1, a3, a4, 1, a2[1].n128_i16[6], a2 + 2);
  if ((v6 & 0x80000000) == 0)
  {
    v7 = *a4;
    v8 = a2[1].n128_i16[4];
    v7[12] = a2[6].n128_u32[0];
    v7[13] = v8;
    v7[14] = a2[1].n128_i16[5];
  }
}

uint64_t com_mosynt_GetCfgParamVal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, char **a6)
{
  uint64_t v7;
  char *v8;
  char *v9;
  char **v11;
  unsigned __int8 __c;
  __int16 __c_1;

  *a6 = a5;
  __c_1 = -1;
  __c = 0;
  v11 = 0;
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, char ***, __int16 *, unsigned __int8 *))(a3 + 96))(a1, a2, "fecfg", a4, &v11, &__c_1, &__c);
  if ((v7 & 0x80000000) == 0 && __c_1)
  {
    v8 = *v11;
    v9 = strchr(*v11, __c);
    if (v9)
    {
      *v9 = 0;
      v8 = *v11;
    }
    *a6 = v8;
  }
  return v7;
}

uint64_t com_mosynt_GetBacktransPOS(uint64_t a1, uint64_t a2, uint64_t a3, char *__s, _WORD *a5)
{
  char *v10;
  uint64_t result;
  char *v12;
  char __sa[256];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  strcpy(__sa, "backtrans_");
  if (strlen(__s) < 0x81)
    __strcat_chk();
  else
    __strncat_chk();
  v10 = strchr(__sa, 40);
  if (v10)
    *v10 = 0;
  v12 = 0;
  result = com_mosynt_GetCfgParamVal(a1, a2, a3, (uint64_t)__sa, __s, &v12);
  if ((result & 0x80000000) == 0)
    *a5 = *v12;
  return result;
}

uint64_t com_mosynt_GetBacktrans2POS(uint64_t a1, uint64_t a2, uint64_t a3, char *__s, unsigned int a5, char *a6)
{
  char *v7;
  unsigned __int16 v11;
  uint64_t CfgParamVal;
  uint64_t v13;
  char v14;
  int v15;
  unsigned __int16 v16;
  char *v17;
  int v18;
  unsigned __int16 v19;
  char *v22;
  char __sa[256];
  uint64_t v24;

  v7 = __s;
  v24 = *MEMORY[0x1E0C80C00];
  v11 = strlen(__s);
  *a6 = 0;
  CfgParamVal = 0;
  v13 = v11;
  if (v11)
  {
    v22 = 0;
    do
    {
      v15 = *v7++;
      v14 = v15;
      if (v15 != 92)
      {
        strcpy(__sa, "backtrans2_");
        v16 = strlen(__sa);
        __sa[v16] = v14;
        __sa[(unsigned __int16)(v16 + 1)] = 0;
        CfgParamVal = com_mosynt_GetCfgParamVal(a1, a2, a3, (uint64_t)__sa, a6, &v22);
        if ((CfgParamVal & 0x80000000) != 0)
          return CfgParamVal;
        v17 = v22;
        v18 = (unsigned __int16)strlen(v22);
        if (v18)
        {
          v19 = strlen(a6);
          if (v22 != a6 && v18 + v19 + 1 < a5)
          {
            if (v19)
              *(_WORD *)&a6[strlen(a6)] = 92;
            strcat(a6, v17);
          }
        }
      }
      --v13;
    }
    while (v13);
  }
  return CfgParamVal;
}

uint64_t com_mosynt_UseMosynt(uint64_t a1, uint64_t a2, uint64_t a3, _BOOL4 *a4)
{
  uint64_t CfgParamVal;
  char *v6;
  _BOOL4 v7;
  char *__s1;

  __s1 = 0;
  CfgParamVal = com_mosynt_GetCfgParamVal(a1, a2, a3, (uint64_t)"mosynt_usemosynt", "NO", &__s1);
  if ((CfgParamVal & 0x80000000) != 0)
  {
    v7 = 0;
  }
  else
  {
    v6 = __s1;
    v7 = !strcmp(__s1, "YES") || strcmp(v6, "yes") == 0;
  }
  *a4 = v7;
  return CfgParamVal;
}

uint64_t mosyntbase_WInt3Ln(uint64_t a1, unsigned __int8 *a2, int a3, unsigned int a4, unsigned __int8 *a5, int a6)
{
  uint64_t result;
  int v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;

  v12 = a2;
  v11 = a3;
  v10 = a5;
  v9 = a6;
  m2__fix__carray__len(&v12, &v11);
  m2__fix__carray__len(&v10, &v9);
  result = mosyntpal_WriteString(a1, v12, v11);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntbase_WInt(a1, a4, 0);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntpal_WriteString(a1, v10, v9);
      if ((result & 0x80000000) == 0)
        return mosyntpal_WriteLn(a1);
    }
  }
  return result;
}

uint64_t mosyntbase_WString(uint64_t a1, unsigned __int8 *a2, int a3)
{
  int v5;
  unsigned __int8 *v6;

  v6 = a2;
  v5 = a3;
  m2__fix__carray__len(&v6, &v5);
  return mosyntpal_WriteString(a1, v6, v5);
}

uint64_t mosyntbase_WInt(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t result;
  _OWORD v5[6];
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = mosyntpal_IntToString(a2, a3, v5, 100);
  if ((result & 0x80000000) == 0)
    return mosyntpal_WriteString(a1, (unsigned __int8 *)v5, 100);
  return result;
}

uint64_t mosyntbase_WStringLn(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t result;
  int v5;
  unsigned __int8 *v6;

  v6 = a2;
  v5 = a3;
  m2__fix__carray__len(&v6, &v5);
  result = mosyntpal_WriteString(a1, v6, v5);
  if ((result & 0x80000000) == 0)
    return mosyntpal_WriteLn(a1);
  return result;
}

uint64_t mosyntbase_WString3Ln(uint64_t a1, unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, unsigned __int8 *a6, int a7)
{
  uint64_t result;
  int v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  unsigned __int8 *v14;

  v14 = a2;
  v13 = a3;
  v12 = a4;
  v11 = a5;
  v10 = a6;
  v9 = a7;
  m2__fix__carray__len(&v14, &v13);
  m2__fix__carray__len(&v12, &v11);
  m2__fix__carray__len(&v10, &v9);
  result = mosyntpal_WriteString(a1, v14, v13);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntpal_WriteString(a1, v12, v11);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntpal_WriteString(a1, v10, v9);
      if ((result & 0x80000000) == 0)
        return mosyntpal_WriteLn(a1);
    }
  }
  return result;
}

uint64_t mosyntbase_WriteDevelMessage(uint64_t a1, unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, unsigned __int8 *a6, int a7, unsigned __int8 *a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t result;
  __int128 v17;
  unsigned __int8 *v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  unsigned __int8 *v24;

  v13 = a10;
  v14 = a11;
  v15 = a12;
  v24 = a2;
  v23 = a3;
  v22 = a4;
  v21 = a5;
  v20 = a6;
  v19 = a7;
  v18 = a8;
  m2__fix__carray__len(&v24, &v23);
  m2__fix__carray__len(&v22, &v21);
  m2__fix__carray__len(&v20, &v19);
  m2__fix__carray__len(&v18, (int *)&a9);
  *((_QWORD *)&v17 + 1) = __PAIR64__(v15, v14);
  *(_QWORD *)&v17 = __PAIR64__(v13, a9);
  result = mosyntbase_WriteMessage(a1, v24, v23, v22, v21, v20, v19, v18, v17);
  if ((result & 0x80000000) == 0)
    return kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result);
  return result;
}

uint64_t mosyntbase_WriteMessage(uint64_t a1, unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, unsigned __int8 *a6, int a7, unsigned __int8 *a8, __int128 a9)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t result;
  unsigned __int8 *v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 *v17;
  int v18;
  unsigned __int8 *v19;
  _OWORD v20[62];
  uint64_t v21;

  v10 = *(_QWORD *)((char *)&a9 + 4);
  v11 = HIDWORD(a9);
  v21 = *MEMORY[0x1E0C80C00];
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v14 = a7;
  v13 = a8;
  memset(v20, 0, 512);
  m2__fix__carray__len(&v19, &v18);
  m2__fix__carray__len(&v17, &v16);
  m2__fix__carray__len(&v15, &v14);
  m2__fix__carray__len(&v13, (int *)&a9);
  result = mosyntbase_ComposeMessage(v19, v18, v17, v16, v15, v14, v13, a9, v10, HIDWORD(v10), v11, v20, 1000);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntpal_WriteString(a1, (unsigned __int8 *)v20, 1000);
    if ((result & 0x80000000) == 0)
      return kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result);
  }
  return result;
}

uint64_t mosyntbase_ComposeMessage(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, unsigned __int8 *a5, int a6, unsigned __int8 *a7, int a8, unsigned int a9, unsigned int a10, unsigned int a11, _BYTE *a12, int a13)
{
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t result;
  int v19;
  unsigned __int8 *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  BOOL v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  int v34;
  const char *v35;
  _QWORD v36[2];
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v33 = a1;
  v32 = a2;
  v31 = a3;
  v30 = a4;
  v29 = a5;
  v28 = a6;
  v27 = a7;
  v26 = a8;
  v36[0] = 0;
  v36[1] = 0;
  v37 = 0;
  m2__fix__carray__len(&v33, &v32);
  m2__fix__carray__len(&v31, &v30);
  m2__fix__carray__len(&v29, &v28);
  m2__fix__carray__len(&v27, &v26);
  v25 = 0;
  *a12 = 0;
  v13 = v32;
  if (v32 >= 1)
  {
    v14 = 0;
    v15 = 1;
    v16 = 1;
    do
    {
      v17 = v13 - 1;
      result = v33[v14];
      if ((_DWORD)result == 37)
      {
        if ((int)v14 < v17)
        {
          v19 = v33[v14 + 1];
          if (v19 == 100 || v19 == 105)
          {
            switch(v15)
            {
              case 3:
                v23 = a11;
                goto LABEL_25;
              case 2:
                v23 = a10;
                goto LABEL_25;
              case 1:
                v23 = a9;
LABEL_25:
                result = mosyntpal_IntToString(v23, 0, v36, 20);
                if ((result & 0x80000000) != 0)
                  return result;
                break;
              default:
                mosyntbase_CCopy("%d", 0, (uint64_t)v36, 20, &v24);
                break;
            }
            mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v36, 20, &v24);
            ++v15;
LABEL_33:
            v22 = 2;
            goto LABEL_34;
          }
          if (v19 == 115)
          {
            switch(v16)
            {
              case 3:
                v20 = v27;
                v21 = v26;
                break;
              case 2:
                v20 = v29;
                v21 = v28;
                break;
              case 1:
                v20 = v31;
                v21 = v30;
                break;
              default:
                v35 = "%s";
                v34 = 0;
                m2__fix__carray__len((unsigned __int8 **)&v35, &v34);
                v20 = (unsigned __int8 *)v35;
                v21 = v34;
                break;
            }
            mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v20, v21, &v24);
            ++v16;
            goto LABEL_33;
          }
        }
      }
      else if ((_DWORD)result == 92)
      {
        if ((int)v14 < v17 && v33[v14 + 1] == 110)
        {
          LOWORD(v36[0]) = mosyntpal_EOL();
          mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v36, 20, &v24);
          goto LABEL_33;
        }
      }
      else if (!v33[v14])
      {
        return result;
      }
      LOWORD(v36[0]) = result;
      mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v36, 20, &v24);
      v22 = 1;
LABEL_34:
      v14 += v22;
      v13 = v32;
    }
    while ((int)v14 < v32);
  }
  return 0;
}

uint64_t mosyntbase_Length(uint64_t a1, int a2)
{
  uint64_t result;

  if (a2 < 1)
    return 0;
  result = 0;
  while (*(_BYTE *)(a1 + result))
  {
    if (a2 == ++result)
      return a2;
  }
  return result;
}

uint64_t mosyntbase_Copy(uint64_t a1, int a2, uint64_t a3, int a4, BOOL *a5)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v8;

  if (a2 < 1)
  {
    v6 = 0;
LABEL_11:
    *(_BYTE *)(a3 + v6) = 0;
    v8 = 1;
  }
  else
  {
    v5 = 0;
    v6 = a2;
    while (*(_BYTE *)(a1 + v5) && v5 < a4 - 1)
    {
      *(_BYTE *)(a3 + v5) = *(_BYTE *)(a1 + v5);
      if (a2 == ++v5)
        goto LABEL_11;
    }
    *(_BYTE *)(a3 + v5) = 0;
    v8 = *(_BYTE *)(a1 + v5) == 0;
  }
  *a5 = v8;
  return 0;
}

uint64_t mosyntbase_CCopy(unsigned __int8 *a1, unsigned int a2, uint64_t a3, int a4, BOOL *a5)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  BOOL v12;
  unsigned int v14;
  unsigned __int8 *v15;

  v15 = a1;
  v14 = a2;
  m2__fix__carray__len(&v15, (int *)&v14);
  v8 = v14;
  if ((int)v14 < 1)
  {
    v8 = 0;
LABEL_11:
    *(_BYTE *)(a3 + v8) = 0;
    v12 = 1;
  }
  else
  {
    v9 = 0;
    v10 = v15;
    while (v10[v9] && v9 < a4 - 1)
    {
      *(_BYTE *)(a3 + v9) = v10[v9];
      if (v8 == ++v9)
        goto LABEL_11;
    }
    *(_BYTE *)(a3 + v9) = 0;
    v12 = v10[v9] == 0;
  }
  *a5 = v12;
  return 0;
}

uint64_t mosyntbase_AppendTo(uint64_t a1, int a2, uint64_t a3, int a4, BOOL *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  BOOL v11;

  v5 = (a2 - 1);
  if (a2 <= 1)
  {
    LODWORD(v6) = 0;
  }
  else
  {
    v6 = 0;
    while (*(_BYTE *)(a1 + v6))
    {
      if (v5 == ++v6)
      {
        LODWORD(v6) = a2 - 1;
        break;
      }
    }
  }
  if (a4 < 1)
  {
LABEL_15:
    *(_BYTE *)(a1 + v6) = 0;
    v11 = 1;
  }
  else
  {
    v7 = 0;
    v8 = v6;
    v9 = a1 + v6;
    while (*(_BYTE *)(a3 + v7) && (int)v5 > v8 + (int)v7)
    {
      *(_BYTE *)(v9 + v7) = *(_BYTE *)(a3 + v7);
      if (a4 == ++v7)
      {
        LODWORD(v6) = v8 + v7;
        goto LABEL_15;
      }
    }
    *(_BYTE *)(a1 + (v8 + v7)) = 0;
    v11 = *(_BYTE *)(a3 + v7) == 0;
  }
  *a5 = v11;
  return 0;
}

uint64_t mosyntbase_App(uint64_t a1, int a2, int *a3, uint64_t a4, int a5, BOOL *a6)
{
  int v6;
  int v7;
  _BOOL4 v8;
  unint64_t v10;
  BOOL v12;

  v6 = a2 - 1;
  v7 = *a3;
  v8 = a5 > 0;
  if (*a3 >= a2 - 1 || a5 < 1)
  {
    LODWORD(v10) = 0;
  }
  else
  {
    v10 = 0;
    while (*(_BYTE *)(a4 + v10))
    {
      *(_BYTE *)(a1 + v7) = *(_BYTE *)(a4 + v10);
      v7 = *a3 + 1;
      *a3 = v7;
      v8 = ++v10 < a5;
      if (v7 >= v6 || v10 >= a5)
        goto LABEL_15;
    }
    v8 = 1;
  }
LABEL_15:
  if (v7 < a2)
    v6 = v7;
  *(_BYTE *)(a1 + v6) = 0;
  v12 = !v8 || *(_BYTE *)(a4 + v10) == 0;
  *a6 = v12;
  return 0;
}

uint64_t mosyntbase_CApp(uint64_t a1, int a2, int *a3, unsigned __int8 *a4, int a5, BOOL *a6)
{
  int v11;
  unsigned __int8 *v12;

  v12 = a4;
  v11 = a5;
  m2__fix__carray__len(&v12, &v11);
  mosyntbase_App(a1, a2, a3, (uint64_t)v12, v11, a6);
  return 0;
}

uint64_t mosyntbase_GetSepPartStr(uint64_t a1, int a2, int *a3, unsigned __int8 a4, _BYTE *a5, int a6, char *a7)
{
  int v7;
  int v8;
  char v9;
  int v10;
  int v12;

  v7 = *a3;
  if ((*a3 & 0x80000000) == 0)
  {
    if (v7 >= a2)
    {
      v8 = 0;
      v9 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = *(unsigned __int8 *)(a1 + v7);
        if (v10 == a4 || v10 == 0)
          break;
        if (v8 >= a6)
        {
          v9 = 0;
        }
        else
        {
          a5[v8++] = v10;
          v7 = *a3;
        }
        *a3 = ++v7;
      }
      while (v7 < a2);
    }
    if (v8 < a6)
    {
      a5[v8] = 0;
      v7 = *a3;
    }
    if (v7 >= a2)
      goto LABEL_23;
    if (*(unsigned __int8 *)(a1 + v7) == a4)
    {
      v12 = v7 + 1;
    }
    else
    {
      if (*(_BYTE *)(a1 + v7))
      {
LABEL_23:
        *a7 = v9;
        return 0;
      }
      v12 = -1;
    }
    *a3 = v12;
    goto LABEL_23;
  }
  *a7 = 0;
  *a5 = 0;
  return 0;
}

BOOL mosyntbase_Equal(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;

  if (a2 < 1)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    v4 = 0;
    while (v4 < a4 && *(_BYTE *)(a1 + v4))
    {
      if (!*(_BYTE *)(a3 + v4) || *(unsigned __int8 *)(a1 + v4) != *(unsigned __int8 *)(a3 + v4))
        break;
      if (a2 == ++v4)
      {
        LODWORD(v4) = a2;
        return (int)v4 >= a4 || *(_BYTE *)(a3 + v4) == 0;
      }
    }
    if (*(_BYTE *)(a1 + v4))
      return 0;
  }
  return (int)v4 >= a4 || *(_BYTE *)(a3 + v4) == 0;
}

BOOL mosyntbase_CEqual(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4)
{
  int v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5 = a4;
  m2__fix__carray__len(&v8, &v7);
  m2__fix__carray__len(&v6, &v5);
  return mosyntbase_Equal((uint64_t)v8, v7, (uint64_t)v6, v5);
}

uint64_t mosyntbase_UpperCase(_BYTE *a1, int a2)
{
  uint64_t v2;
  int v3;

  if (a2 >= 1)
  {
    v2 = a2;
    do
    {
      v3 = *a1;
      if (!*a1)
        break;
      if ((v3 - 97) <= 0x19)
        *a1 = v3 - 32;
      ++a1;
      --v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t mosyntbase_FindSubstring(uint64_t a1, int a2, uint64_t a3, int a4, int a5, int *a6)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  BOOL v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;

  v6 = a5 & ~(a5 >> 31);
  if (a5 >= 1)
  {
    if (a4 < 1)
      goto LABEL_27;
    v7 = 0;
    while (*(_BYTE *)(a3 + v7))
    {
      if (a4 == ++v7)
      {
        LODWORD(v7) = a4;
        break;
      }
    }
    if (v6 >= (int)v7)
      goto LABEL_27;
  }
  if (v6 >= a4)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      v9 = *(unsigned __int8 *)(a3 + v6);
      if (*(_BYTE *)(a3 + v6))
        v10 = v8 < a2;
      else
        v10 = 0;
      if (!v10)
        break;
      v11 = *(unsigned __int8 *)(a1 + v8);
      if (!*(_BYTE *)(a1 + v8))
        break;
      v12 = v11 == v9;
      v13 = v11 == v9 ? 0 : v8;
      if (v12)
        ++v8;
      else
        v8 = 0;
      v6 = v6 - v13 + 1;
    }
    while (v6 < a4);
  }
  if (v8 < a2 && *(_BYTE *)(a1 + v8))
LABEL_27:
    v14 = -1;
  else
    v14 = v6 - v8;
  *a6 = v14;
  return 0;
}

uint64_t mosyntbase_RemoveSubstring(int a1, int a2, uint64_t a3, int a4, _BYTE *a5)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  char *v8;
  int v9;
  char v10;

  *a5 = 1;
  if (a4 < 1)
  {
    LODWORD(v5) = 0;
  }
  else
  {
    v5 = 0;
    while (*(_BYTE *)(a3 + v5))
    {
      if (a4 == ++v5)
      {
        LODWORD(v5) = a4;
        break;
      }
    }
  }
  if ((int)v5 > a1)
  {
    v6 = a2 + (uint64_t)a1;
    if ((int)v6 <= (int)v5)
    {
      if ((int)v6 < (int)v5)
      {
        v7 = (_BYTE *)(a3 + a1);
        v8 = (char *)(a3 + v6);
        v9 = v5 - a2;
        do
        {
          v10 = *v8++;
          *v7++ = v10;
          ++a1;
        }
        while (v9 != a1);
      }
    }
    else
    {
      *a5 = 0;
    }
    if (a1 < a4)
      a5 = (_BYTE *)(a3 + a1);
    else
      a5 = (_BYTE *)(a3 + a4 - 1);
  }
  *a5 = 0;
  return 0;
}

uint64_t mosyntaccphr_TreatSyntTree(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t SentTermCommList;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  int v23;
  int *v24;
  uint64_t DomainById;
  int v26;
  int v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t inited;
  uint64_t BestScenarioPathSuffix;
  int *v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t DomainByName;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t *v49;
  unsigned int *v50;
  uint64_t *v51;
  _QWORD *m;
  uint64_t *v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  __int16 v58;
  uint64_t *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  char v64;
  uint64_t *v65;
  uint64_t v66;
  _QWORD *v67;
  int v68;
  _QWORD *v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t *v73;
  int v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t *v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  unsigned int v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  int i;
  uint64_t v86;
  __int16 *v87;
  __int16 *v88;
  __int16 *v89;
  __int16 *v90;
  int v91;
  int v92;
  __int16 v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  unsigned __int8 *v99;
  uint64_t *v100;
  uint64_t *v101;
  uint64_t v102;
  _QWORD *v103;
  uint64_t v104;
  uint64_t *v105;
  int Rule;
  int v107;
  uint64_t v108;
  uint64_t n;
  uint64_t v110;
  uint64_t Scenario;
  uint64_t RuleSet;
  _BOOL4 v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t Children;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  uint64_t Instr;
  uint64_t v125;
  int v126;
  _QWORD *v127;
  int v128;
  uint64_t v129;
  uint64_t InstrRight;
  _QWORD *v131;
  _QWORD *v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  int InstrType;
  uint64_t v137;
  uint64_t v138;
  uint64_t *v139;
  __int128 *v140;
  char v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  uint64_t v150;
  _QWORD *v151;
  uint64_t v152;
  int v153;
  uint64_t v154;
  _QWORD **v155;
  uint64_t v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t Node;
  BOOL v163;
  int v164;
  uint64_t v165;
  uint64_t *v166;
  uint64_t *v167;
  uint64_t *v168;
  int v169;
  uint64_t *v170;
  int v171;
  int v172;
  int v173;
  int v174;
  uint64_t *v175;
  int v176;
  int v177;
  int v178;
  uint64_t v179;
  uint64_t *v180;
  uint64_t *v181;
  uint64_t *v182;
  int v183;
  _QWORD *v184;
  _QWORD *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  int v189;
  uint64_t v190;
  int v191;
  unsigned __int16 *v192;
  int ConsList;
  unsigned int v194;
  uint64_t v195;
  int v196;
  BOOL v197;
  int v198;
  BOOL v199;
  uint64_t v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  uint64_t *v209;
  int v210;
  uint64_t *v211;
  uint64_t *v212;
  uint64_t *ii;
  uint64_t v214;
  uint64_t *v215;
  uint64_t *v216;
  uint64_t *v217;
  uint64_t v218;
  unsigned int v220;
  uint64_t *v221;
  int v222;
  uint64_t *v223;
  uint64_t v224;
  uint64_t *v225;
  uint64_t j;
  uint64_t k;
  uint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  int v234;
  int v235;
  int v236;
  int v237;
  BOOL v238;
  int v239;
  BOOL v240;
  uint64_t *v241;
  _BOOL4 v242;
  _BOOL4 v243;
  BOOL v244;
  uint64_t *v245;
  uint64_t *v246;
  int v247;
  unsigned int v248;
  int v249;
  BOOL v250;
  uint64_t v252;
  uint64_t v253;
  uint64_t *v254;
  uint64_t *v255;
  uint64_t v256;
  int v257;
  uint64_t v258;
  int v259;
  int v260;
  int v261;
  uint64_t *v262;
  uint64_t v263;
  uint64_t *v264;
  BOOL v265;
  uint64_t *v266;
  uint64_t v267;
  uint64_t *v268;
  unsigned int *v269;
  _QWORD **v270;
  uint64_t *v271;
  uint64_t v272;
  uint64_t *v273;
  uint64_t v274;
  int v275;
  uint64_t *v276;
  uint64_t v277;
  uint64_t *v278;
  uint64_t *v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t *v282;
  uint64_t *v283;
  uint64_t v284;
  int v285;
  uint64_t v286;
  _OWORD v287[6];
  int v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  int v295;
  uint64_t v296;

  v296 = *MEMORY[0x1E0C80C00];
  v280 = 0;
  SentTermCommList = mosyntpal_ALLOCATE(a1, &v280, 0x60u);
  if ((SentTermCommList & 0x80000000) != 0)
    return SentTermCommList;
  v17 = v280;
  *(_DWORD *)v280 = a2;
  *(_QWORD *)(v17 + 8) = a3;
  *(_QWORD *)(v17 + 16) = a4;
  *(_DWORD *)(v17 + 24) = a5;
  *(_DWORD *)(v17 + 28) = a6;
  *(_QWORD *)(v17 + 32) = 0;
  *(_QWORD *)(v17 + 40) = a7;
  *(_DWORD *)(v280 + 48) = ((uint64_t (*)(void))mosyntkbaccphr_Nil)();
  *(_DWORD *)(v280 + 52) = ((uint64_t (*)(void))mosyntkbaccphr_Nil)();
  v18 = ((uint64_t (*)(void))mosyntkbaccphr_Nil)();
  v19 = v280;
  v20 = v280;
  *(_DWORD *)(v280 + 56) = v18;
  v21 = (int *)(v20 + 56);
  if (!a8)
    goto LABEL_557;
  v22 = *(_QWORD *)(v19 + 16);
  if (v22 != fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher())
  {
    v24 = (int *)(v19 + 48);
    v23 = *(_DWORD *)(v19 + 48);
    if (v23 == ((uint64_t (*)(void))mosyntkbaccphr_Nil)())
    {
      DomainById = FindDomainById(v19, *(_DWORD *)(v19 + 28), (_DWORD *)(v19 + 48));
      v26 = *(_DWORD *)(v19 + 48);
      if (v26 == mosyntkbaccphr_Nil(DomainById))
      {
        v27 = mosyntkbaccphr_AccPhrDomains(*(_QWORD *)(v19 + 16));
        *(_DWORD *)(v19 + 48) = v27;
      }
      else
      {
        v27 = *v24;
      }
      *(_DWORD *)(v19 + 52) = v27;
      *(_DWORD *)(v19 + 56) = v27;
    }
    *(_QWORD *)&v289 = 0;
    SentTermCommList = mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(v19 + 40), *(_DWORD *)(a8 + 52), &v289);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    v28 = (uint64_t *)v289;
    v29 = *(_QWORD *)(v19 + 16);
    inited = fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher();
    if (v29 == inited)
    {
      v44 = mosyntkbaccphr_Nil(inited);
      *(_DWORD *)(v19 + 48) = v44;
      v45 = mosyntkbaccphr_Nil(v44);
      *(_DWORD *)(v19 + 52) = v45;
      *(_DWORD *)(v19 + 56) = mosyntkbaccphr_Nil(v45);
      goto LABEL_65;
    }
    if (!v28)
      goto LABEL_65;
    BestScenarioPathSuffix = 0;
    v32 = (int *)(v19 + 52);
    while (1)
    {
      while (*((_DWORD *)v28 + 2) != 5)
      {
LABEL_61:
        v28 = (uint64_t *)*v28;
        if (!v28)
        {
          if ((BestScenarioPathSuffix & 0x80000000) != 0)
            return BestScenarioPathSuffix;
          goto LABEL_65;
        }
      }
      if (*((_DWORD *)v28 + 3))
      {
        v33 = *v24;
      }
      else
      {
        inited = mosyntkbaccphr_Nil(inited);
        v33 = inited;
        *v24 = inited;
      }
      inited = mosyntkbaccphr_Nil(inited);
      if (v33 == (_DWORD)inited)
      {
        v34 = FindDomainById(v19, *(_DWORD *)(v19 + 28), (_DWORD *)(v19 + 48));
        v35 = *(_DWORD *)(v19 + 48);
        if (v35 == mosyntkbaccphr_Nil(v34))
        {
          inited = mosyntkbaccphr_AccPhrDomains(*(_QWORD *)(v19 + 16));
          *(_DWORD *)(v19 + 48) = inited;
        }
        else
        {
          inited = *v24;
        }
        BestScenarioPathSuffix = 0;
        *v32 = inited;
        *v21 = inited;
      }
      v36 = *((_DWORD *)v28 + 3);
      if (v36 != 2)
        break;
      v37 = *(_DWORD *)v19;
      if (!*((_BYTE *)v28 + 36))
      {
        if (v37 >= 1)
        {
          SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          inited = mosyntbase_WriteMessage(a1, "Resetting sentence domain\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
          goto LABEL_49;
        }
LABEL_50:
        v43 = *v32;
LABEL_60:
        *v21 = v43;
        goto LABEL_61;
      }
      if (v37 >= 1)
      {
        SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        SentTermCommList = mosyntbase_WriteMessage(a1, "Setting sentence domain to '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
      }
      DomainByName = FindDomainByName(v19, (unsigned __int8 *)v28 + 36, v21);
      v39 = *(_DWORD *)(v19 + 56);
      inited = mosyntkbaccphr_Nil(DomainByName);
      if (v39 == (_DWORD)inited)
      {
        if (*(int *)v19 >= 1)
        {
          SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          inited = mosyntbase_WriteMessage(a1, "Didn't find sentence domain '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
LABEL_49:
          BestScenarioPathSuffix = inited;
          if ((inited & 0x80000000) != 0)
            return BestScenarioPathSuffix;
          goto LABEL_50;
        }
LABEL_45:
        BestScenarioPathSuffix = 0;
        goto LABEL_50;
      }
      BestScenarioPathSuffix = 0;
      v28 = (uint64_t *)*v28;
      if (!v28)
        goto LABEL_65;
    }
    if (v36 != 1)
    {
      if (!v36 && *(int *)v19 >= 1)
      {
        SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        inited = mosyntbase_WriteMessage(a1, "Resetting default domain\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        BestScenarioPathSuffix = inited;
        if ((inited & 0x80000000) != 0)
          return BestScenarioPathSuffix;
      }
      goto LABEL_61;
    }
    v40 = *(_DWORD *)v19;
    if (*((_BYTE *)v28 + 36))
    {
      if (v40 >= 1)
      {
        SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        SentTermCommList = mosyntbase_WriteMessage(a1, "Setting paragraph domain to '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
      }
      v41 = FindDomainByName(v19, (unsigned __int8 *)v28 + 36, (int *)(v19 + 52));
      v42 = *(_DWORD *)(v19 + 52);
      inited = mosyntkbaccphr_Nil(v41);
      if (v42 != (_DWORD)inited)
        goto LABEL_45;
      if (*(int *)v19 >= 1)
      {
        SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        inited = mosyntbase_WriteMessage(a1, "Didn't find paragraph domain '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        goto LABEL_54;
      }
      BestScenarioPathSuffix = 0;
    }
    else if (v40 >= 1)
    {
      SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      inited = mosyntbase_WriteMessage(a1, "Resetting paragraph domain\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
LABEL_54:
      BestScenarioPathSuffix = inited;
      if ((inited & 0x80000000) != 0)
        return BestScenarioPathSuffix;
    }
    v43 = *v24;
    *v32 = *v24;
    goto LABEL_60;
  }
LABEL_65:
  v46 = v280;
  *(_DWORD *)(v280 + 60) = *(_DWORD *)(v280 + 56);
  v47 = mosyntkbaccphr_AccPhrType(*(_QWORD *)(v46 + 16));
  v48 = v280;
  if (!v47)
  {
    v284 = 0;
    v55 = mosyntkbsymtab_WildConsId(*(_QWORD *)(v280 + 8));
    SentTermCommList = GenAccTree(a1, v48, (uint64_t *)a8, &v284);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    v56 = v284;
    LODWORD(v289) = 0;
    SentTermCommList = Accentuation1(a1, v48, v284, (int *)&v289);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    *(_QWORD *)&v287[0] = 0;
    v283 = 0;
    *(_QWORD *)&v289 = 0;
    SentTermCommList = GetInitPhrasing1(a1, v48, v56, 3, 0, &v283, (uint64_t *)&v289);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    v57 = (_QWORD)v289 ? *(_DWORD *)(v289 + 24) : 0;
    SentTermCommList = mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(v48 + 40), v57, v287);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    v58 = FinalBoundaryIndex(a1, *(uint64_t **)&v287[0]);
    SentTermCommList = AppendInitBound(a1, v48, &v283, (uint64_t *)&v289, v58, 0);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    *(_DWORD *)(v289 + 16) = v57;
    if (*(int *)v48 <= 0)
    {
      v60 = v283;
    }
    else
    {
      SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      SentTermCommList = mosyntbase_WString(a1, "initial phrasing: ", 0);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      v59 = v283;
      SentTermCommList = WriteBoundList(a1, v48, v283, 0);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      SentTermCommList = mosyntbase_WLn(a1);
      v60 = v59;
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
    }
    v80 = *(_DWORD *)(v48 + 24);
    v289 = 0u;
    v290 = 0u;
    v291 = 0u;
    v292 = 0u;
    v293 = 0u;
    v294 = 0u;
    v295 = 0;
    v279 = v60;
    if (v60)
    {
      v81 = 0;
      BestScenarioPathSuffix = 0;
      v82 = v60;
      do
      {
        v83 = *((__int16 *)v82 + 4);
        if (v83 < 100)
        {
          *((_BYTE *)&v289 + v83) = 1;
        }
        else
        {
          SentTermCommList = mosyntbase_WString(a1, "*** maximum nr of phrase boundary index levels exceeded", 0);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          BestScenarioPathSuffix = mosyntbase_WLn(a1);
          if ((BestScenarioPathSuffix & 0x80000000) != 0)
            return BestScenarioPathSuffix;
          LOWORD(v83) = *((_WORD *)v82 + 4);
          v60 = v279;
        }
        if ((int)v81 <= (__int16)v83)
          v81 = (__int16)v83;
        v82 = (uint64_t *)*v82;
      }
      while (v82);
    }
    else
    {
      BestScenarioPathSuffix = 0;
      v81 = 0;
    }
    v84 = v81;
    for (i = 1; i != 3; ++i)
    {
      if ((int)v84 >= 2)
      {
        v86 = v84;
        do
        {
          if ((unint64_t)v86 > 0x63 || *((_BYTE *)&v289 + v86))
          {
            if (v60)
            {
              v87 = 0;
              v88 = 0;
              v89 = 0;
              v90 = (__int16 *)v60;
              while (1)
              {
                v91 = v90[4];
                if ((v91 & 0x80000000) == 0)
                  break;
LABEL_234:
                v90 = *(__int16 **)v90;
                if (!v90)
                  goto LABEL_235;
              }
              if (!v88 || (v88[4] & 0x80000000) == 0)
                v89 = v88;
              if (v87)
              {
                v92 = v87[4];
                if (v86 == v92 && v89)
                {
                  if (i == 1)
                  {
                    v93 = v89[5];
                    if (v93 || v92 < v89[4])
                    {
                      if (v92 <= v91 || v87[5])
                        goto LABEL_232;
                    }
                    else
                    {
                      v93 = 0;
                    }
LABEL_231:
                    v87[4] = -1;
                    v89[5] = v87[5] + v93;
                    v89[6] += v87[6];
                    goto LABEL_232;
                  }
                  if (v80 > 1 || v92 >= 3)
                  {
                    v94 = v89[6];
                    if (v94 >= 5)
                      v95 = v80 - 1;
                    else
                      v95 = v80;
                    if (v94 < 3)
                      v95 = v80 + 1;
                    v96 = v87[6];
                    v97 = v96 >= 5 ? v80 - 1 : v80;
                    v98 = v96 >= 3 ? v97 : v80 + 1;
                    if (v92 >= v89[4])
                    {
                      if (v92 >= v91 && v95 >= v89[5])
                      {
                        v93 = v89[5];
                        goto LABEL_231;
                      }
                      if (v92 > v91 && v98 >= v87[5])
                      {
                        v93 = v89[5];
                        goto LABEL_231;
                      }
                    }
                  }
                }
LABEL_232:
                v88 = v87;
              }
              else
              {
                v88 = 0;
              }
              v87 = v90;
              goto LABEL_234;
            }
LABEL_235:
            if (*(int *)v48 >= 1)
            {
              SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              v99 = (unsigned __int8 *)(i == 1 ? "after clitic melting" : "after rhythmic melting");
              SentTermCommList = mosyntbase_WString(a1, v99, 0);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              SentTermCommList = mosyntbase_WString(a1, ", index ", 0);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              SentTermCommList = mosyntbase_WInt(a1, v86, 0);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              SentTermCommList = mosyntbase_WString(a1, ": ", 0);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              SentTermCommList = WriteBoundList(a1, v48, v279, 0);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              BestScenarioPathSuffix = mosyntbase_WLn(a1);
              v60 = v279;
              if ((BestScenarioPathSuffix & 0x80000000) != 0)
                return BestScenarioPathSuffix;
            }
          }
          v197 = v86-- <= 2;
        }
        while (!v197);
      }
    }
    if ((BestScenarioPathSuffix & 0x80000000) != 0)
      return BestScenarioPathSuffix;
    if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8))
      && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), v55, 8u, 1))
    {
      goto LABEL_252;
    }
    if (v279)
    {
      v164 = 0;
      v165 = 0;
      v166 = 0;
      v167 = v279;
      while (1)
      {
        if (*((unsigned __int16 *)v167 + 4) > 1u)
        {
          v168 = (uint64_t *)v165;
          goto LABEL_421;
        }
        v164 = 0;
        v168 = 0;
        if (!v166 || !v165)
          goto LABEL_419;
        v166 = v167;
        if ((uint64_t *)v165 != v167)
          break;
LABEL_421:
        if (*((__int16 *)v167 + 15) <= 0)
        {
          v167 = (uint64_t *)*v167;
        }
        else
        {
          v169 = *((unsigned __int16 *)v167 + 15);
          v167 = (uint64_t *)*v167;
          if (v164 == 0 || v164 >= v169)
          {
            v168 = v167;
            v164 = v169;
          }
        }
        v165 = (uint64_t)v168;
        if (!v167)
          goto LABEL_427;
      }
      do
      {
        if ((*(__int16 *)(v165 + 8) & 0x80000000) == 0)
          *(_WORD *)(v165 + 8) = -1;
        v165 = *(_QWORD *)v165;
      }
      while ((uint64_t *)v165 != v167);
      v168 = 0;
      v164 = 0;
LABEL_419:
      v166 = v167;
      goto LABEL_421;
    }
LABEL_427:
    if (*(int *)v48 < 1)
      goto LABEL_436;
    SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = mosyntbase_WString(a1, "after postcyclic deletion: ", 0);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = WriteBoundList(a1, v48, v279, 0);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = mosyntbase_WLn(a1);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
LABEL_252:
    if (*(int *)v48 < 1)
    {
LABEL_436:
      BestScenarioPathSuffix = 0;
    }
    else
    {
      SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      SentTermCommList = mosyntbase_WStringLn(a1, "before setting phrase types: ", 0);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      SentTermCommList = WriteBoundList(a1, v48, v279, 1);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
      BestScenarioPathSuffix = mosyntbase_WLn(a1);
      if ((BestScenarioPathSuffix & 0x80000000) != 0)
        return BestScenarioPathSuffix;
    }
    if (v279)
    {
      v171 = 0;
      v172 = 0;
      v173 = 0;
      v174 = 0;
      LODWORD(v282) = 0;
      *(_QWORD *)&v289 = 0;
      *(_QWORD *)&v287[0] = 0;
      v175 = v279;
      v176 = 1;
      do
      {
        mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(v48 + 40), *((_DWORD *)v175 + 4), &v289);
        mosyntdata_GetPunctFromCommandList(a1, (uint64_t *)v289, &v282, v287);
        if ((_DWORD)v282 == 11)
          v177 = 1;
        else
          v177 = v171;
        if ((_DWORD)v282 == 10)
          v172 = 1;
        else
          v171 = v177;
        if (*((__int16 *)v175 + 14) >= 1)
        {
          if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8))
            && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), *((__int16 *)v175 + 14), 6u, 2))
          {
            v176 = 0;
            v174 = 1;
          }
          else if (v176 || !mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8)))
          {
            v176 = 0;
          }
          else
          {
            v176 = 0;
            if (mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), *((__int16 *)v175 + 14), 6u, 3))
              v173 = 1;
          }
        }
        v175 = (uint64_t *)*v175;
      }
      while (v175);
      if (v172)
      {
        if (v174)
        {
          v178 = 5;
        }
        else
        {
          if (v173)
          {
            v262 = v279;
            do
            {
              if (*((__int16 *)v262 + 14) >= 1
                && mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8))
                && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), *((__int16 *)v262 + 14), 6u, 3))
              {
                *((_WORD *)v262 + 4) = 2;
              }
              v262 = (uint64_t *)*v262;
            }
            while (v262);
            v178 = 8;
            v208 = 1;
            goto LABEL_533;
          }
          v178 = 4;
        }
LABEL_532:
        v208 = 0;
LABEL_533:
        if (!v279)
          goto LABEL_572;
        v209 = 0;
        v210 = 1;
        v211 = v279;
        while (1)
        {
          if ((__int16)v211[1] < 0)
          {
            v212 = (uint64_t *)*v211;
          }
          else
          {
            v212 = (uint64_t *)*v211;
            if (v209)
            {
              if (!v212)
              {
                *((_DWORD *)v209 + 8) = v178;
LABEL_572:
                if (*(int *)v48 >= 1)
                {
                  SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = mosyntbase_WStringLn(a1, "after setting phrase types: ", 0);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = WriteBoundList(a1, v48, v279, 1);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  BestScenarioPathSuffix = mosyntbase_WLn(a1);
                }
                if ((BestScenarioPathSuffix & 0x80000000) != 0)
                  return BestScenarioPathSuffix;
                v220 = mosyntkbsymtab_WildConsId(*(_QWORD *)(v48 + 8));
                if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8))
                  && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), v220, 9u, 1))
                {
                  if (v279)
                  {
                    v221 = v279;
                    do
                    {
                      if (*((_WORD *)v221 + 15))
                        ++*((_WORD *)v221 + 15);
                      v221 = (uint64_t *)*v221;
                    }
                    while (v221);
                    goto LABEL_585;
                  }
LABEL_646:
                  BestScenarioPathSuffix = 0;
                }
                else
                {
LABEL_585:
                  if (!v279)
                    goto LABEL_646;
                  v222 = 0;
                  v223 = 0;
                  v224 = 0;
                  BestScenarioPathSuffix = 0;
                  v225 = v279;
                  do
                  {
                    if (((__int16)v225[1] & 0x80000000) == 0)
                    {
                      if (v223)
                        *((_WORD *)v223 + 15) = 1;
                      *(_QWORD *)&v289 = 0;
                      SentTermCommList = mosyntpal_ALLOCATE(a1, (uint64_t *)&v289, 0x12Au);
                      if ((SentTermCommList & 0x80000000) != 0)
                        return SentTermCommList;
                      if (v224)
                      {
                        for (j = 0; j != 99; ++j)
                          *(_BYTE *)(v289 + j) = 0;
                        for (k = v224; (uint64_t *)k != v225; k = *(_QWORD *)k)
                        {
                          v228 = *(__int16 *)(k + 30);
                          if (v228 <= 98)
                            *(_BYTE *)(v289 + v228) = 1;
                        }
                        v229 = 0;
                        v230 = 1;
                        v231 = v289;
                        do
                        {
                          if (*(_BYTE *)(v231 + v229))
                            *(_WORD *)(v231 + 2 * v229 + 100) = v230++;
                          ++v229;
                        }
                        while (v229 != 99);
                        while ((uint64_t *)v224 != v225)
                        {
                          v232 = *(__int16 *)(v224 + 30);
                          if (v232 <= 98)
                          {
                            v233 = v289;
                            if (*(int *)v48 >= 2
                              && *(unsigned __int16 *)(v289 + 2 * v232 + 100) != (unsigned __int16)v232)
                            {
                              SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                              if ((SentTermCommList & 0x80000000) != 0)
                                return SentTermCommList;
                              SentTermCommList = mosyntbase_WString(a1, "accent normalization: ", 0);
                              if ((SentTermCommList & 0x80000000) != 0)
                                return SentTermCommList;
                              SentTermCommList = mosyntbase_WInt(a1, *(__int16 *)(v224 + 30), 0);
                              if ((SentTermCommList & 0x80000000) != 0)
                                return SentTermCommList;
                              SentTermCommList = mosyntbase_WString(a1, " changed to ", 0);
                              if ((SentTermCommList & 0x80000000) != 0)
                                return SentTermCommList;
                              SentTermCommList = mosyntbase_WInt(a1, *(__int16 *)(v289 + 2 * *(__int16 *)(v224 + 30) + 100), 0);
                              if ((SentTermCommList & 0x80000000) != 0)
                                return SentTermCommList;
                              SentTermCommList = mosyntbase_WLn(a1);
                              if ((SentTermCommList & 0x80000000) != 0)
                                return SentTermCommList;
                              v233 = v289;
                              LOWORD(v232) = *(_WORD *)(v224 + 30);
                            }
                            *(_WORD *)(v224 + 30) = *(_WORD *)(v233 + 2 * (__int16)v232 + 100);
                            if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8)))
                              v234 = mosyntkbsymtab_IntPropValue(a1, *(uint64_t **)(v48 + 8), *(__int16 *)(v224 + 28), 2u);
                            else
                              v234 = 1;
                            v235 = *(__int16 *)(v224 + 30);
                            if (v235 >= 2 && v234 > v235)
                              *(_WORD *)(v224 + 30) = v234;
                          }
                          v224 = *(_QWORD *)v224;
                        }
                      }
                      BestScenarioPathSuffix = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v289);
                      if ((BestScenarioPathSuffix & 0x80000000) != 0)
                        return BestScenarioPathSuffix;
                      v223 = 0;
                      v222 = 0;
                      v224 = (uint64_t)v225;
                    }
                    if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(v48 + 8))
                      && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), v220, 7u, 1))
                    {
                      v236 = *((__int16 *)v225 + 15);
                      v237 = *((unsigned __int16 *)v225 + 15);
                      if (v222)
                        v238 = v222 <= v237;
                      else
                        v238 = 0;
                      v239 = !v238;
                      v240 = v239 == 0;
                      if (v239)
                        v241 = v225;
                      else
                        v241 = v223;
                      if (v240)
                        v237 = v222;
                    }
                    else
                    {
                      v236 = *((__int16 *)v225 + 15);
                      v237 = *((unsigned __int16 *)v225 + 15);
                      v242 = v222 != 0;
                      v243 = v222 < v237;
                      v244 = !v242 || !v243;
                      if (v242 && v243)
                        v241 = v223;
                      else
                        v241 = v225;
                      if (!v244)
                        v237 = v222;
                    }
                    if (v236 >= 1)
                    {
                      v223 = v241;
                      v222 = v237;
                    }
                    v225 = (uint64_t *)*v225;
                  }
                  while (v225);
                }
                if (*(int *)v48 >= 1)
                {
                  SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = mosyntbase_WString(a1, "accent normalization and accent limitation: ", 0);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = WriteBoundList(a1, v48, v279, 0);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  BestScenarioPathSuffix = mosyntbase_WLn(a1);
                }
                if ((BestScenarioPathSuffix & 0x80000000) != 0)
                  return BestScenarioPathSuffix;
                if (v279)
                {
                  v245 = 0;
                  v246 = v279;
                  do
                  {
                    v247 = *((__int16 *)v246 + 4);
                    if ((v247 & 0x80000000) == 0)
                    {
                      if (v245)
                      {
                        v248 = *((_DWORD *)v246 + 8);
                        v197 = v248 > 8;
                        v249 = (1 << v248) & 0x1D0;
                        v250 = v197 || v249 == 0;
                        if (!v250 && v245 != v246)
                        {
                          v252 = (uint64_t)v245;
                          do
                          {
                            if (*(_WORD *)(v252 + 30) == 2)
                              *(_WORD *)(v252 + 30) = 3;
                            v252 = *(_QWORD *)v252;
                          }
                          while ((uint64_t *)v252 != v246);
                        }
                      }
                      if ((unsigned __int16)v247 < 2u)
                        v245 = v246;
                    }
                    v246 = (uint64_t *)*v246;
                  }
                  while (v246);
                }
                if (*(int *)v48 >= 1)
                {
                  SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = mosyntbase_WString(a1, "reduction of pitch accents: ", 0);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = WriteBoundList(a1, v48, v279, 0);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                  SentTermCommList = mosyntbase_WLn(a1);
                  if ((SentTermCommList & 0x80000000) != 0)
                    return SentTermCommList;
                }
                if (v279)
                {
                  v253 = *(_QWORD *)(v48 + 40);
                  if (v253)
                  {
                    v254 = v279;
                    while (1)
                    {
                      v255 = v254;
                      v256 = *(_QWORD *)(v253 + 16 * *((int *)v254 + 4) + 8);
                      if (v256)
                      {
                        v257 = *((__int16 *)v255 + 4);
                        if (v257 >= 2)
                          v257 = 2;
                        *(_DWORD *)(v256 + 8) = v257;
                        *(_DWORD *)(v256 + 12) = *((_DWORD *)v255 + 8);
                      }
                      v254 = (uint64_t *)*v255;
                      if (!*v255)
                        break;
                      v258 = *(_QWORD *)(v253 + 16 * *((int *)v255 + 5));
                      if (v258)
                      {
                        v259 = *((__int16 *)v255 + 15);
                        if (v259 >= 3)
                          v260 = 3;
                        else
                          v260 = v259;
                        if (v259 <= 98)
                          v261 = v260;
                        else
                          v261 = 0;
                        *(_DWORD *)(v258 + 16) = v261;
                      }
                    }
                  }
                }
                if (v279)
                {
                  do
                  {
                    *(_QWORD *)&v289 = v279;
                    v279 = (uint64_t *)*v279;
                    v263 = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v289);
                    BestScenarioPathSuffix = v263;
                  }
                  while ((v263 & 0x80000000) == 0 && v279);
                  if ((v263 & 0x80000000) != 0)
                    return BestScenarioPathSuffix;
                }
LABEL_557:
                v214 = v280;
                v215 = *(uint64_t **)(v280 + 32);
                *(_QWORD *)&v289 = v215;
                if (v215)
                {
                  while (2)
                  {
                    v216 = (uint64_t *)*v215;
                    switch(*((_DWORD *)v215 + 2))
                    {
                      case 1:
                      case 4:
                        v217 = v215 + 2;
                        v218 = a1;
                        goto LABEL_565;
                      case 2:
                        v217 = v215 + 2;
                        v218 = a1;
                        goto LABEL_565;
                      case 3:
                        v217 = v215 + 2;
                        v218 = a1;
                        goto LABEL_565;
                      case 5:
                        v217 = v215 + 2;
                        v218 = a1;
                        goto LABEL_565;
                      case 6:
                      case 8:
                        v217 = v215 + 2;
                        v218 = a1;
                        goto LABEL_565;
                      case 7:
                        v217 = v215 + 2;
                        v218 = a1;
LABEL_565:
                        SentTermCommList = mosyntpal_DEALLOCATE(v218, v217);
                        if ((SentTermCommList & 0x80000000) == 0)
                          goto LABEL_566;
                        return SentTermCommList;
                      default:
LABEL_566:
                        SentTermCommList = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v289);
                        if ((SentTermCommList & 0x80000000) != 0)
                          return SentTermCommList;
                        *(_QWORD *)&v289 = v216;
                        v215 = v216;
                        if (!v216)
                          break;
                        continue;
                    }
                    break;
                  }
                }
                *(_QWORD *)(v214 + 32) = 0;
                return mosyntpal_DEALLOCATE(a1, &v280);
              }
              if (v208)
              {
                if (v210)
                {
                  v210 = 0;
                  *((_DWORD *)v209 + 8) = 6;
                }
                else
                {
                  *((_DWORD *)v209 + 8) = 7;
                }
              }
              else
              {
                *((_DWORD *)v209 + 8) = 1;
              }
            }
            v209 = v211;
          }
          v211 = v212;
          if (!v212)
            goto LABEL_572;
        }
      }
      if (v171)
      {
        v178 = 9;
        goto LABEL_532;
      }
    }
    v178 = 2;
    goto LABEL_532;
  }
  v283 = 0;
  *(_QWORD *)(v280 + 80) = 0;
  *(_QWORD *)(v48 + 88) = 0;
  *(_DWORD *)(v48 + 72) = 0;
  NewAPVertex(a1, v48, *(_DWORD *)(a8 + 52), (uint64_t *)&v283);
  if ((SentTermCommList & 0x80000000) != 0)
    return SentTermCommList;
  *(_QWORD *)&v289 = 0;
  TreeToChart(a1, v48, a8, (uint64_t)v283, 0, (uint64_t *)&v289);
  if ((SentTermCommList & 0x80000000) != 0)
    return SentTermCommList;
  v49 = (uint64_t *)&v283;
  if ((_QWORD)v289)
    v49 = (uint64_t *)(v289 + 24);
  v50 = (unsigned int *)*v49;
  if (v283 == (uint64_t *)*v49)
    goto LABEL_557;
  SentTermCommList = SetFunctionWords(a1, v48, (uint64_t)v283, *v49);
  if ((SentTermCommList & 0x80000000) != 0)
    return SentTermCommList;
  v281 = 0;
  v51 = v283;
  if (*(int *)v48 >= 1)
  {
    SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = mosyntbase_WriteMessage(a1, "[AccPhr] Sentence PoS and phonetic string:\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = mosyntbase_WString(a1, "[AccPhr] ", 0);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = WriteCoverage(a1, v48, (unsigned int *)v51, v50);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = mosyntbase_WLn(a1);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
  }
  v282 = 0;
  if (v51 == (uint64_t *)v50)
  {
    v278 = (uint64_t *)(v48 + 16);
    goto LABEL_108;
  }
  do
  {
    SentTermCommList = MatchEdge(a1, v48, v51[4], &v282, &v281);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    for (m = (_QWORD *)v51[6]; m; m = (_QWORD *)*m)
    {
      SentTermCommList = MatchEdge(a1, v48, (uint64_t)m, &v282, &v281);
      if ((SentTermCommList & 0x80000000) != 0)
        return SentTermCommList;
    }
    v51 = (uint64_t *)v51[2];
  }
  while (v51 != (uint64_t *)v50);
  v53 = v282;
  v54 = *(_QWORD *)(v48 + 16);
  v278 = (uint64_t *)(v48 + 16);
  if (v282)
  {
    BestScenarioPathSuffix = 0;
    do
    {
      if (IsMatchingRule(a1, v48, *((unsigned int *)v53 + 2), (_QWORD **)v53[3], v53[2]))
      {
        BestScenarioPathSuffix = AddEdgeRule(a1, v48, *((_DWORD *)v53 + 2), v53[3]);
        if ((BestScenarioPathSuffix & 0x80000000) != 0)
          return BestScenarioPathSuffix;
        if ((int)mosyntkbaccphr_GetRule(0, v54, *((unsigned int *)v53 + 2)) >= 1)
        {
          BestScenarioPathSuffix = AddRuleScenarios(a1, v48, *((unsigned int *)v53 + 2), (uint64_t *)(v53[2] + 40), &v281);
          if ((BestScenarioPathSuffix & 0x80000000) != 0)
            return BestScenarioPathSuffix;
        }
      }
      v53 = (uint64_t *)*v53;
    }
    while (v53);
    if ((BestScenarioPathSuffix & 0x80000000) != 0)
      return BestScenarioPathSuffix;
  }
LABEL_108:
  v61 = v281;
  v62 = v283;
  if (v281)
  {
    v63 = 0;
    v295 = 0;
    v293 = 0u;
    v294 = 0u;
    v291 = 0u;
    v292 = 0u;
    v289 = 0u;
    v290 = 0u;
    do
    {
      BestScenarioPathSuffix = mosyntkbsymtab_AtomSymString(a1, *(uint64_t **)(v48 + 8), *(_DWORD *)(v61 + 8), (char *)&v289, 100);
      if ((BestScenarioPathSuffix & 0x80000000) != 0)
        return BestScenarioPathSuffix;
      if (v62 != (uint64_t *)v50)
      {
        v64 = 1;
        v65 = v62;
        do
        {
          v66 = (uint64_t)v65;
          while (1)
          {
            v67 = *(_QWORD **)(v66 + 48);
            v68 = *(_DWORD *)(v61 + 8);
            if (v67)
            {
              do
              {
                v69 = v67;
                v70 = v67[5];
                if (v70)
                {
                  while (1)
                  {
                    v71 = *(_DWORD *)(v70 + 8);
                    if (v71 >= v68)
                      break;
                    v70 = *(_QWORD *)v70;
                    if (!v70)
                      goto LABEL_120;
                  }
                  LOBYTE(v70) = v71 == v68;
                }
LABEL_120:
                if ((v70 & 1) != 0)
                  break;
                v67 = (_QWORD *)*v69;
              }
              while (*v69);
              if ((v70 & 1) != 0)
                break;
            }
            v72 = *(_QWORD *)(v66 + 32);
            v73 = *(uint64_t **)(v72 + 40);
            if (v73)
            {
              v65 = *(uint64_t **)(v72 + 24);
              while (1)
              {
                v74 = *((_DWORD *)v73 + 2);
                if (v74 >= v68)
                  break;
                v73 = (uint64_t *)*v73;
                if (!v73)
                  goto LABEL_129;
              }
              if (v74 == v68)
                goto LABEL_134;
            }
LABEL_129:
            if ((v64 & 1) == 0)
            {
              BestScenarioPathSuffix = AddSegment(a1, v48, v68, v63, (_DWORD *)v66);
              if ((BestScenarioPathSuffix & 0x80000000) != 0)
                return BestScenarioPathSuffix;
            }
            v66 = *(_QWORD *)(v66 + 16);
            v64 = 1;
            if ((unsigned int *)v66 == v50)
              goto LABEL_138;
          }
          v65 = (uint64_t *)v69[3];
LABEL_134:
          v163 = (v64 & 1) == 0;
          v64 = 0;
          if (!v163)
            v63 = v66;
        }
        while (v65 != (uint64_t *)v50);
        BestScenarioPathSuffix = AddSegment(a1, v48, v68, v63, v50);
        if ((BestScenarioPathSuffix & 0x80000000) != 0)
          return BestScenarioPathSuffix;
      }
LABEL_138:
      v61 = *(_QWORD *)v61;
    }
    while (v61);
    if ((BestScenarioPathSuffix & 0x80000000) != 0)
      return BestScenarioPathSuffix;
    v62 = v283;
  }
  v284 = 0;
  v286 = 0;
  v285 = 0;
  v288 = 0;
  memset(v287, 0, sizeof(v287));
  BestScenarioPathSuffix = GetBestScenarioPathSuffix(a1, (_QWORD *)v48, 0, (uint64_t)v62, (uint64_t)v50, (int *)&v286 + 1, &v286, &v285, &v284);
  if ((BestScenarioPathSuffix & 0x80000000) != 0)
    return BestScenarioPathSuffix;
  v269 = v50;
  v75 = (_QWORD *)v284;
  if (*(int *)v48 >= 1)
  {
    SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) == 0)
    {
      BestScenarioPathSuffix = mosyntbase_WriteMessage(a1, "[AccPhr] Optimal Scenario Combination:\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
      if ((BestScenarioPathSuffix & 0x80000000) != 0)
        return BestScenarioPathSuffix;
      goto LABEL_145;
    }
    return SentTermCommList;
  }
LABEL_145:
  if (v75)
  {
    while (1)
    {
      if (*(int *)v48 >= 1 && v62 != *(uint64_t **)(v75[1] + 8))
      {
        SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        SentTermCommList = mosyntbase_WString(a1, "[AccPhr] No scenario covering: ", 0);
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        SentTermCommList = WriteCoverage(a1, v48, (unsigned int *)v62, *(unsigned int **)(v75[1] + 8));
        if ((SentTermCommList & 0x80000000) != 0)
          return SentTermCommList;
        BestScenarioPathSuffix = mosyntbase_WLn(a1);
        if ((BestScenarioPathSuffix & 0x80000000) != 0)
          return BestScenarioPathSuffix;
      }
      v76 = v75[1];
      v77 = *(uint64_t **)(v76 + 8);
      if (v62 != v77)
      {
        do
        {
          *((_DWORD *)v62 + 20) = 0;
          v62 = (uint64_t *)v62[2];
        }
        while (v62 != v77);
        v62 = v77;
      }
      if (*(int *)v48 >= 1)
        break;
      while (v62 != *(uint64_t **)(v76 + 16))
      {
        v79 = *(_DWORD *)(v76 + 24);
        *((_DWORD *)v62 + 20) = v79;
        BestScenarioPathSuffix = mosyntkbsymtab_AtomSymString(a1, *(uint64_t **)(v48 + 8), v79, (char *)v287, 100);
        if ((BestScenarioPathSuffix & 0x80000000) != 0)
          return BestScenarioPathSuffix;
        v62 = (uint64_t *)v62[2];
LABEL_163:
        v76 = v75[1];
      }
      v75 = (_QWORD *)*v75;
      if (!v75)
        goto LABEL_168;
    }
    SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) == 0)
    {
      SentTermCommList = mosyntbase_WString(a1, "[AccPhr] Scenario '", 0);
      if ((SentTermCommList & 0x80000000) == 0)
      {
        v78 = *(_DWORD *)(v75[1] + 24);
        v295 = 0;
        v293 = 0u;
        v294 = 0u;
        v291 = 0u;
        v292 = 0u;
        v289 = 0u;
        v290 = 0u;
        SentTermCommList = mosyntkbsymtab_AtomSymString(a1, *(uint64_t **)(v48 + 8), v78, (char *)&v289, 100);
        if ((SentTermCommList & 0x80000000) == 0)
        {
          SentTermCommList = mosyntbase_WString(a1, (unsigned __int8 *)&v289, 100);
          if ((SentTermCommList & 0x80000000) == 0)
          {
            SentTermCommList = mosyntbase_WString(a1, "' covers: ", 0);
            if ((SentTermCommList & 0x80000000) == 0)
            {
              SentTermCommList = WriteCoverage(a1, v48, *(unsigned int **)(v75[1] + 8), *(unsigned int **)(v75[1] + 16));
              if ((SentTermCommList & 0x80000000) == 0)
              {
                BestScenarioPathSuffix = mosyntbase_WLn(a1);
                if ((BestScenarioPathSuffix & 0x80000000) != 0)
                  return BestScenarioPathSuffix;
                goto LABEL_163;
              }
            }
          }
        }
      }
    }
    return SentTermCommList;
  }
LABEL_168:
  if (v62 != (uint64_t *)v269 && *(int *)v48 >= 1)
  {
    SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = mosyntbase_WString(a1, "[AccPhr] No scenario covering: ", 0);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    SentTermCommList = WriteCoverage(a1, v48, (unsigned int *)v62, v269);
    if ((SentTermCommList & 0x80000000) != 0)
      return SentTermCommList;
    BestScenarioPathSuffix = mosyntbase_WLn(a1);
    if ((BestScenarioPathSuffix & 0x80000000) != 0)
      return BestScenarioPathSuffix;
  }
  while (v62 != (uint64_t *)v269)
  {
    *((_DWORD *)v62 + 20) = 0;
    v62 = (uint64_t *)v62[2];
  }
  if ((BestScenarioPathSuffix & 0x80000000) != 0)
    return BestScenarioPathSuffix;
  v100 = v283;
  if (v283 == (uint64_t *)v269)
  {
    BestScenarioPathSuffix = 0;
    goto LABEL_434;
  }
  BestScenarioPathSuffix = 0;
  v272 = *v278;
  v101 = v283;
  v264 = v283;
  do
  {
    v102 = v101[6];
    v265 = v102 == 0;
    v276 = v101;
    if (!v102)
    {
      v102 = v101[4];
      if (!v102)
        goto LABEL_407;
    }
    do
    {
      v103 = *(_QWORD **)(v102 + 32);
      v104 = v272;
      if (!v103)
        goto LABEL_400;
      do
      {
        v270 = (_QWORD **)v103;
        v105 = (uint64_t *)v103[2];
        if (!v105)
          goto LABEL_399;
        do
        {
          if ((int)mosyntkbaccphr_GetRule(0, v104, *((unsigned int *)v105 + 2)) < 1)
            goto LABEL_398;
          Rule = mosyntkbaccphr_GetRule(0, v104, *((unsigned int *)v105 + 2));
          v107 = *((_DWORD *)v276 + 20);
          v108 = *v278;
          for (n = mosyntkbaccphr_AccPhrScenarios(*v278); ; n = mosyntkbaccphr_GetScenario(3, v108, v110))
          {
            v110 = n;
            Scenario = mosyntkbaccphr_Nil(n);
            if ((_DWORD)v110 == (_DWORD)Scenario)
              break;
            Scenario = mosyntkbaccphr_GetScenario(1, v108, v110);
            if ((_DWORD)Scenario == v107)
              break;
          }
          if ((_DWORD)v110 == mosyntkbaccphr_Nil(Scenario))
            goto LABEL_398;
          RuleSet = mosyntkbaccphr_GetScenario(2, v108, v110);
          if ((_DWORD)RuleSet == mosyntkbaccphr_Nil(RuleSet))
            goto LABEL_398;
          do
          {
            if (mosyntkbaccphr_GetRuleSetIsSubset(v108, RuleSet))
              v113 = 0;
            else
              v113 = mosyntkbaccphr_GetRuleSet(1, v108, RuleSet) == Rule;
            RuleSet = mosyntkbaccphr_GetRuleSet(4, v108, RuleSet);
          }
          while ((_DWORD)RuleSet != mosyntkbaccphr_Nil(RuleSet) && !v113);
          if (!v113)
            goto LABEL_398;
          if (*(int *)v48 >= 1)
          {
            SentTermCommList = mosyntbase_WriteMessage(a1, "[AccPhr]\\n[AccPhr] <<<< Applying rule:\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = mosyntbase_WString(a1, "[AccPhr] ", 0);
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = mosyntkbaccphr_WriteRuleHeadline(a1, *(uint64_t **)(v48 + 8), v272, *((_DWORD *)v105 + 2));
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = mosyntbase_WLn(a1);
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = mosyntbase_WriteMessage(a1, "[AccPhr] Node Covers:\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = mosyntbase_WString(a1, "[AccPhr] ", 0);
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = WriteCoverage(a1, v48, *(unsigned int **)(v102 + 16), *(unsigned int **)(v102 + 24));
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
            SentTermCommList = mosyntbase_WLn(a1);
            v104 = v272;
            if ((SentTermCommList & 0x80000000) != 0)
              return SentTermCommList;
          }
          v114 = mosyntkbaccphr_GetRule(12, v104, *((unsigned int *)v105 + 2));
          *(_QWORD *)&v289 = 0;
          v285 = 0;
          LODWORD(v286) = 0;
          *(_QWORD *)&v287[0] = 0;
          v284 = 0;
          v115 = *v278;
          if (mosyntkbaccphr_Nil(v114) == (_DWORD)v114)
            goto LABEL_288;
          v267 = 0;
          BestScenarioPathSuffix = 0;
          v274 = v115;
          do
          {
            mosyntkbaccphr_GetInstrType(v115, v114);
            if (mosyntkbaccphr_GetInstrType(v115, v114) > 6)
              goto LABEL_379;
            *(_QWORD *)&v289 = v102;
            Instr = mosyntkbaccphr_GetInstr(0, v115, v114);
            if (!mosyntkbaccphr_GetNode(3, v115, Instr))
              goto LABEL_319;
            v125 = mosyntkbaccphr_GetInstr(0, v115, v114);
            if ((mosyntkbaccphr_GetNodeMatchOp(v115, v125) & 1) != 0)
            {
              v126 = mosyntkbaccphr_GetInstr(0, v115, v114);
              v127 = *v270;
              HIDWORD(v286) = v126;
              if (v127)
              {
                do
                {
                  v128 = IsMatchingNode(a1, v48, (unsigned int *)&v286 + 1, (uint64_t)v127);
                  if (v128)
                    break;
                  v127 = (_QWORD *)*v127;
                }
                while (v127);
                v115 = v274;
                if (v128)
                  goto LABEL_319;
              }
              else
              {
                v115 = v274;
              }
            }
            v129 = mosyntkbaccphr_GetInstr(0, v115, v114);
            if ((mosyntkbaccphr_GetNodeMatchOp(v115, v129) & 2) == 0 || !*(_QWORD *)(v102 + 72))
            {
LABEL_375:
              v115 = v274;
              goto LABEL_379;
            }
            InstrRight = mosyntkbaccphr_GetInstrRight(v274, v114);
            if ((_DWORD)InstrRight)
            {
              v131 = *(_QWORD **)(v102 + 72);
              do
              {
                v132 = v131;
                v131 = (_QWORD *)v131[7];
              }
              while (v131);
              v133 = mosyntkbaccphr_GetInstr(0, v274, v114);
              v134 = IsRightMatchingTarget(a1, v48, v133, v132, &v289);
            }
            else
            {
              v135 = mosyntkbaccphr_GetInstr(InstrRight, v274, v114);
              v134 = IsLeftMatchingTarget(a1, v48, v135, *(_QWORD **)(v102 + 72), &v289);
            }
            v115 = v274;
            if (v134)
            {
LABEL_319:
              if (*(int *)v48 >= 1)
              {
                SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                if ((SentTermCommList & 0x80000000) != 0)
                  return SentTermCommList;
                SentTermCommList = mosyntbase_WStringLn(a1, "[AccPhr]", 0);
                if ((SentTermCommList & 0x80000000) != 0)
                  return SentTermCommList;
                SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                if ((SentTermCommList & 0x80000000) != 0)
                  return SentTermCommList;
                SentTermCommList = mosyntbase_WString(a1, "[AccPhr] --> Instruction ", 0);
                if ((SentTermCommList & 0x80000000) != 0)
                  return SentTermCommList;
                v115 = v274;
                BestScenarioPathSuffix = mosyntkbaccphr_WriteInstruction(a1, *(uint64_t **)(v48 + 8), v274, v114);
                if ((BestScenarioPathSuffix & 0x80000000) != 0)
                  return BestScenarioPathSuffix;
              }
              InstrType = mosyntkbaccphr_GetInstrType(v115, v114);
              if ((InstrType - 3) >= 3)
              {
                if (InstrType == 2)
                {
                  if (mosyntkbaccphr_GetInstrRight(v274, v114))
                    v140 = (__int128 *)(*(_QWORD *)(v289 + 24) + 24);
                  else
                    v140 = &v289;
                  v141 = 0;
                  v143 = *(_QWORD *)(*(_QWORD *)v140 + 16);
                  v267 = *(_QWORD *)(v143 + 32);
                  *(_DWORD *)(v143 + 84) = 1;
                }
                else if (InstrType)
                {
                  v141 = 1;
                }
                else
                {
                  if (mosyntkbaccphr_GetInstrRight(v274, v114))
                  {
                    v138 = *(_QWORD *)(v289 + 24);
                    v139 = (uint64_t *)(v138 + 24);
                  }
                  else
                  {
                    v138 = *(_QWORD *)(v289 + 16);
                    v139 = (uint64_t *)(v138 + 32);
                  }
                  v267 = *v139;
                  if (mosyntkbaccphr_GetInstr(2, v274, v114))
                  {
                    if (mosyntkbaccphr_GetInstr(2, v274, v114) == 1)
                      v142 = 5;
                    else
                      v142 = mosyntkbaccphr_GetInstr(2, v274, v114);
                    LODWORD(v286) = v142;
                    if (*(unsigned __int16 *)(v138 + 68) < 2u)
                      goto LABEL_370;
                    *(_WORD *)(v138 + 68) = 1;
                    if (v142 <= *(_DWORD *)(v138 + 72))
                      goto LABEL_370;
                    v141 = 0;
                    *(_DWORD *)(v138 + 72) = v142;
                  }
                  else
                  {
                    if ((*(__int16 *)(v138 + 68) & 0x80000000) == 0)
                      goto LABEL_370;
                    v141 = 0;
                    *(_WORD *)(v138 + 68) = 2;
                  }
                }
              }
              else
              {
                if (mosyntkbaccphr_GetInstrTargetRange(v115, v114)
                  && mosyntkbaccphr_GetInstrTargetRange(v115, v114) == 1)
                {
                  if (mosyntkbaccphr_GetInstrRight(v115, v114))
                    v137 = *(_QWORD *)(*(_QWORD *)(v289 + 24) + 24);
                  else
                    v137 = *(_QWORD *)(*(_QWORD *)(v289 + 16) + 32);
                  *(_QWORD *)&v289 = v137;
                  v115 = v274;
                }
                v267 = v289;
                v144 = *(_QWORD *)(v289 + 16);
                v145 = mosyntkbaccphr_GetInstrType(v115, v114);
                if (v145 == 4)
                  v146 = 2;
                else
                  v146 = 1;
                if (v145 == 5)
                  v147 = 3;
                else
                  v147 = v146;
                v148 = mosyntkbaccphr_GetInstr(2, v115, v114);
                SentTermCommList = mosyntdata_EncodeSymbolicValue(a1, v148, 0, &v286);
                if ((SentTermCommList & 0x80000000) != 0)
                  return SentTermCommList;
                v149 = mosyntkbaccphr_GetInstr(2, v274, v114);
                BestScenarioPathSuffix = mosyntdata_EncodeSymbolicValue(a1, v149, 1, &v285);
                if ((BestScenarioPathSuffix & 0x80000000) != 0)
                  return BestScenarioPathSuffix;
                do
                {
                  v150 = mosyntdata_SentTermBoundData(a1, *(_QWORD *)(v48 + 40), *(_DWORD *)(*(_QWORD *)(v144 + 32) + 84));
                  if (v150)
                  {
                    v151 = (_QWORD *)v150;
                    SentTermCommList = mosyntdata_NewCommand(a1, &v284);
                    if ((SentTermCommList & 0x80000000) != 0)
                      return SentTermCommList;
                    v152 = v284;
                    v153 = v286;
                    *(_DWORD *)(v284 + 8) = v147;
                    *(_DWORD *)(v152 + 12) = v153;
                    *(_QWORD *)&v287[0] = mosyntdata_LastPhonEle(a1, (_QWORD *)*v151);
                    BestScenarioPathSuffix = mosyntdata_AppendPhonList(a1, v151, v287, v284, v284);
                    if ((BestScenarioPathSuffix & 0x80000000) != 0)
                      return BestScenarioPathSuffix;
                  }
                  v144 = *(_QWORD *)(v144 + 16);
                  v154 = mosyntdata_SentTermBoundData(a1, *(_QWORD *)(v48 + 40), *(_DWORD *)(v144 + 64));
                  if (v154)
                  {
                    v155 = (_QWORD **)v154;
                    SentTermCommList = mosyntdata_NewCommand(a1, &v284);
                    if ((SentTermCommList & 0x80000000) != 0)
                      return SentTermCommList;
                    v156 = v284;
                    v157 = v285;
                    *(_DWORD *)(v284 + 8) = v147;
                    *(_DWORD *)(v156 + 12) = v157;
                    *(_QWORD *)&v287[0] = mosyntdata_LastPhonEle(a1, *v155);
                    v158 = v284;
                    if (v284 && (*(_QWORD *)v284 = *v155, *v155 = (_QWORD *)v158, !*(_QWORD *)&v287[0]))
                    {
                      BestScenarioPathSuffix = 0;
                      *(_QWORD *)&v287[0] = v158;
                    }
                    else
                    {
                      BestScenarioPathSuffix = 0;
                    }
                  }
                }
                while (v144 != *(_QWORD *)(v289 + 24));
LABEL_370:
                v141 = 0;
              }
              if (*(int *)v48 < 1)
                goto LABEL_375;
              SentTermCommList = mosyntbase_WString(a1, " : ", 0);
              if ((SentTermCommList & 0x80000000) != 0)
                return SentTermCommList;
              if ((v141 & 1) != 0)
              {
                v159 = mosyntbase_WStringLn(a1, " not implemented yet!", 0);
              }
              else
              {
                SentTermCommList = WriteCoverage(a1, v48, *(unsigned int **)(v267 + 16), *(unsigned int **)(v267 + 24));
                if ((SentTermCommList & 0x80000000) != 0)
                  return SentTermCommList;
                v159 = mosyntbase_WLn(a1);
              }
              BestScenarioPathSuffix = v159;
              v115 = v274;
              if ((v159 & 0x80000000) != 0)
                return BestScenarioPathSuffix;
            }
LABEL_379:
            v114 = mosyntkbaccphr_GetInstr(6, v115, v114);
          }
          while ((_DWORD)v114 != mosyntkbaccphr_Nil(v114));
          v104 = v272;
          if ((BestScenarioPathSuffix & 0x80000000) != 0)
            return BestScenarioPathSuffix;
LABEL_288:
          v116 = mosyntkbaccphr_GetRule(13, v104, *((unsigned int *)v105 + 2));
          v117 = *v278;
          Children = mosyntkbaccphr_Nil(v116);
          LODWORD(v119) = v116;
          if ((_DWORD)v116 != (_DWORD)Children)
          {
            v119 = v116;
            do
            {
              v120 = *(_QWORD *)(v102 + 16);
              Children = mosyntkbaccphr_GetChildren(1, v117, v116);
              LODWORD(v289) = Children;
              if (v120 == *(_QWORD *)(v102 + 24))
                break;
              v121 = Children;
              do
              {
                Children = mosyntkbaccphr_Nil(Children);
                if ((_DWORD)v121 == (_DWORD)Children)
                  break;
                v122 = *(_QWORD **)(*(_QWORD *)(v120 + 32) + 32);
                do
                {
                  v123 = (uint64_t)v122;
                  v122 = (_QWORD *)*v122;
                }
                while (v122);
                Children = IsMatchingNode(a1, v48, (unsigned int *)&v289, v123);
                if (!(_DWORD)Children)
                  break;
                v120 = *(_QWORD *)(v120 + 16);
                Children = mosyntkbaccphr_GetNode(8, v117, v121);
                v121 = Children;
                LODWORD(v289) = Children;
              }
              while (v120 != *(_QWORD *)(v102 + 24));
              if (v120 == *(_QWORD *)(v102 + 24))
                break;
              v119 = mosyntkbaccphr_GetChildren(2, v117, v119);
              Children = mosyntkbaccphr_Nil(v119);
            }
            while ((_DWORD)v119 != (_DWORD)Children);
          }
          if ((_DWORD)v119 == mosyntkbaccphr_Nil(Children))
          {
            BestScenarioPathSuffix = 0;
            goto LABEL_395;
          }
          if (*(int *)v48 < 1)
          {
            BestScenarioPathSuffix = 0;
            goto LABEL_390;
          }
          SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          SentTermCommList = mosyntbase_WStringLn(a1, "[AccPhr]", 0);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          SentTermCommList = mosyntbase_WString(a1, "[AccPhr] --> Template ", 0);
          if ((SentTermCommList & 0x80000000) != 0)
            return SentTermCommList;
          BestScenarioPathSuffix = mosyntkbaccphr_WritePromTemplate(a1, *(uint64_t **)(v48 + 8), v117, v119);
          if ((BestScenarioPathSuffix & 0x80000000) != 0)
            return BestScenarioPathSuffix;
LABEL_390:
          v160 = *(_QWORD *)(v102 + 16);
          v161 = mosyntkbaccphr_GetChildren(1, v117, v116);
          if (v160 == *(_QWORD *)(v102 + 24))
          {
LABEL_395:
            v104 = v272;
          }
          else
          {
            Node = v161;
            do
            {
              *(_DWORD *)(v160 + 84) = mosyntkbaccphr_GetNode(2, v117, Node);
              v160 = *(_QWORD *)(v160 + 16);
              Node = mosyntkbaccphr_GetNode(8, v117, Node);
            }
            while (v160 != *(_QWORD *)(v102 + 24));
            v104 = v272;
            if ((BestScenarioPathSuffix & 0x80000000) != 0)
              return BestScenarioPathSuffix;
          }
          if (*(int *)v48 >= 1)
          {
            BestScenarioPathSuffix = mosyntbase_WriteMessage(a1, "[AccPhr] End rule.>>>>>\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
            if ((BestScenarioPathSuffix & 0x80000000) != 0)
              return BestScenarioPathSuffix;
          }
LABEL_398:
          v105 = (uint64_t *)*v105;
        }
        while (v105);
LABEL_399:
        v103 = *v270;
      }
      while (*v270);
LABEL_400:
      v102 = *(_QWORD *)v102;
      if (v102)
        v163 = 0;
      else
        v163 = !v265;
      if (v163)
      {
        v102 = v276[4];
        v265 = 1;
      }
    }
    while (v102);
LABEL_407:
    v101 = (uint64_t *)v276[2];
    v100 = v264;
  }
  while (v101 != (uint64_t *)v269);
LABEL_434:
  *((_WORD *)v100 + 34) = 0;
  *(_QWORD *)&v289 = 0;
  if (v269)
  {
    mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(v48 + 40), v269[16], &v289);
    v170 = (uint64_t *)v289;
  }
  else
  {
    v170 = 0;
  }
  *((_WORD *)v269 + 34) = FinalBoundaryIndex(a1, v170);
  if ((BestScenarioPathSuffix & 0x80000000) != 0)
    return BestScenarioPathSuffix;
  v266 = v283;
  if (!v283)
  {
    BestScenarioPathSuffix = 0;
    goto LABEL_548;
  }
  v179 = 0;
  v180 = 0;
  v181 = 0;
  BestScenarioPathSuffix = 0;
  LODWORD(v284) = 0;
  *(_QWORD *)&v289 = 0;
  *(_QWORD *)&v287[0] = 0;
  v182 = v283;
  while (2)
  {
    v271 = v182;
    if ((*((__int16 *)v182 + 34) & 0x80000000) == 0)
    {
      if (!v180 || v179)
      {
LABEL_498:
        if (v179)
          goto LABEL_505;
        v181 = v180;
        v180 = v182;
      }
      else
      {
        if (v180 == v182)
          goto LABEL_495;
        v179 = 0;
        v183 = -1;
        v268 = v180;
        do
        {
          v275 = v183;
          v277 = v179;
          v273 = v180;
          v184 = *(_QWORD **)(v180[4] + 32);
          do
          {
            v185 = v184;
            v184 = (_QWORD *)*v184;
          }
          while (v184);
          v186 = *v278;
          v187 = mosyntkbaccphr_AccPhrHierarchy(*v278);
          BYTE4(v286) = 0;
          v188 = mosyntkbaccphr_Nil(v187);
          if ((_DWORD)v187 == (_DWORD)v188)
          {
            v189 = 0;
          }
          else
          {
            v189 = 0;
            do
            {
              v190 = v185[1];
              v191 = *(__int16 *)(v190 + 16);
              v192 = (unsigned __int16 *)(v190 + 24);
              ConsList = mosyntkbaccphr_GetConsList(0, v186, v187);
              v194 = mosyntkbaccphr_GetConsList(1, v186, v187);
              v195 = mosyntkbaccphr_CheckMatchingConsFeat3(a1, v186, v191, v192, ConsList, v194, (char *)&v286 + 4);
              if (!BYTE4(v286))
              {
                ++v189;
                v195 = mosyntkbaccphr_GetConsList(2, v186, v187);
                v187 = v195;
              }
              v188 = mosyntkbaccphr_Nil(v195);
            }
            while ((_DWORD)v187 != (_DWORD)v188 && !BYTE4(v286));
          }
          if ((_DWORD)v187 == mosyntkbaccphr_Nil(v188))
            v196 = -1;
          else
            v196 = v189;
          v183 = v275;
          v197 = v275 < 0 || v196 < v275;
          v198 = v197;
          v199 = v198 == 0;
          v182 = v271;
          v179 = v277;
          if (v198)
            v200 = (uint64_t)v271;
          else
            v200 = v277;
          if (v199)
            v201 = v275;
          else
            v201 = v196;
          if (v196 >= 0)
          {
            v179 = v200;
            v183 = v201;
          }
          v180 = (uint64_t *)v273[2];
        }
        while (v180 != v271);
        v180 = v268;
        if (!v179)
        {
LABEL_495:
          v179 = (uint64_t)v180;
          if (mosyntkbaccphr_AccPhrDefaultEmph(*v278) == 1)
            goto LABEL_498;
          if (mosyntkbaccphr_AccPhrDefaultEmph(*v278) == 2)
          {
            v182 = v271;
            v179 = v271[1];
            goto LABEL_498;
          }
          v202 = *(_DWORD *)v180;
          v182 = v271;
          v203 = *(_DWORD *)v271 + *(_DWORD *)v180;
          if (*(_DWORD *)v271 + v202 < 0 != __OFADD__(*(_DWORD *)v271, v202))
            ++v203;
          v179 = (uint64_t)v180;
          if (v202 != v203 >> 1)
          {
            v204 = v203 >> 1;
            v179 = (uint64_t)v180;
            do
              v179 = *(_QWORD *)(v179 + 16);
            while (*(_DWORD *)v179 != v204);
          }
        }
LABEL_505:
        *(_DWORD *)(v179 + 84) = 1;
        v181 = v180;
        v180 = v182;
        v179 = 0;
      }
    }
    if (*((_DWORD *)v182 + 21) == 1)
    {
      if (v179)
      {
        if (mosyntkbaccphr_AccPhrDefaultEmph(*v278) == 1)
        {
          v205 = 3;
        }
        else
        {
          *(_DWORD *)(v179 + 84) = -1;
          BestScenarioPathSuffix = SetFunctionWords(a1, v48, v179, *(_QWORD *)(v179 + 16));
          if ((BestScenarioPathSuffix & 0x80000000) != 0)
            return BestScenarioPathSuffix;
          if (*(_DWORD *)(v179 + 84) == -1)
            *(_DWORD *)(v179 + 84) = 3;
          v205 = 1;
          v182 = v271;
          v179 = (uint64_t)v271;
        }
        *((_DWORD *)v182 + 21) = v205;
      }
      else
      {
        v179 = (uint64_t)v182;
      }
    }
    v182 = (uint64_t *)v182[2];
    if (v182)
      continue;
    break;
  }
  if (!v180)
    goto LABEL_548;
  *((_DWORD *)v180 + 19) = 0;
  if (!v181 || *((_DWORD *)v181 + 19))
    goto LABEL_548;
  SentTermCommList = mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(v48 + 40), *((_DWORD *)v180 + 16), v287);
  if ((SentTermCommList & 0x80000000) != 0)
    return SentTermCommList;
  BestScenarioPathSuffix = mosyntdata_GetPunctFromCommandList(a1, *(uint64_t **)&v287[0], &v284, &v289);
  if ((BestScenarioPathSuffix & 0x80000000) == 0)
  {
    v206 = (_DWORD)v284 == 11 ? 9 : 2;
    v207 = (_DWORD)v284 == 10 ? 4 : v206;
    *((_DWORD *)v181 + 19) = v207;
LABEL_548:
    for (ii = v266; ii != (uint64_t *)v269; ii = (uint64_t *)ii[2])
    {
      if (*((_DWORD *)ii + 21) == -1)
        *((_DWORD *)ii + 21) = 3;
      if ((*((__int16 *)ii + 34) & 0x80000000) == 0 && !*((_DWORD *)ii + 19))
        *((_DWORD *)ii + 19) = 1;
    }
    if ((BestScenarioPathSuffix & 0x80000000) == 0)
    {
      ChartToSentTermData(v48, (uint64_t)v283);
      goto LABEL_557;
    }
  }
  return BestScenarioPathSuffix;
}

uint64_t FindDomainById(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v5;
  int i;
  int v7;
  uint64_t result;

  v5 = *(_QWORD *)(a1 + 16);
  for (i = mosyntkbaccphr_AccPhrDomains(v5); ; i = mosyntkbaccphr_GetScenario(3, v5, *a3))
  {
    v7 = i;
    *a3 = i;
    result = mosyntkbaccphr_Nil();
    if (v7 == (_DWORD)result)
      break;
    result = mosyntkbaccphr_GetScenario(1, v5, *a3);
    if ((_DWORD)result == a2)
      break;
  }
  return result;
}

uint64_t FindDomainByName(uint64_t a1, unsigned __int8 *a2, int *a3)
{
  uint64_t v5;
  uint64_t i;
  unsigned __int8 *ScenarioNamePtr;
  int v8;
  uint64_t result;

  v5 = *(_QWORD *)(a1 + 16);
  for (i = mosyntkbaccphr_AccPhrDomains(v5); ; i = mosyntkbaccphr_GetScenario(3, v5, *a3))
  {
    *a3 = i;
    ScenarioNamePtr = (unsigned __int8 *)mosyntkbaccphr_GetScenarioNamePtr(v5, i);
    v8 = *a3;
    result = mosyntkbaccphr_Nil();
    if (v8 == (_DWORD)result)
      break;
    result = mosyntbase_CEqual(ScenarioNamePtr, 50, a2, 100);
    if ((_DWORD)result)
      break;
  }
  return result;
}

uint64_t GenAccTree(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *v5;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  __int16 v12;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;

  *a4 = 0;
  v16 = 0;
  if (!a3)
    return 0;
  v5 = a3;
  while (1)
  {
    v8 = AddAccNode(a1, a2, a4, &v16);
    if ((v8 & 0x80000000) != 0)
      break;
    v9 = v16;
    v16[2] = *(uint64_t *)((char *)v5 + 52);
    *((_BYTE *)v9 + 24) = 0;
    *((_WORD *)v9 + 13) = *((_WORD *)v5 + 8);
    if (*((_BYTE *)v5 + 60))
    {
      v14 = 0;
      v15 = 0;
      v10 = AddAccNode(a1, a2, &v15, &v14);
      if ((v10 & 0x80000000) != 0)
        return v10;
      v9[1] = v15;
      v11 = v14;
      v14[2] = *(uint64_t *)((char *)v5 + 52);
      v12 = 1;
      *((_BYTE *)v11 + 24) = 1;
      if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8)))
      {
        if ((int)mosyntkbsymtab_IntPropValue(a1, *(uint64_t **)(a2 + 8), *((__int16 *)v5 + 8), 2u) >= 1)
          v12 = 1;
        else
          v12 = 99;
      }
      *((_WORD *)v11 + 13) = v12;
    }
    else
    {
      v10 = GenAccTree(a1, a2, v5[1], v9 + 1);
      if ((v10 & 0x80000000) != 0)
        return v10;
    }
    v5 = (uint64_t *)*v5;
    if (!v5)
      return v10;
  }
  return v8;
}

uint64_t AddAccNode(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD **a4)
{
  uint64_t result;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  v12 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x20u);
  if ((result & 0x80000000) == 0)
  {
    v9 = v12;
    v13 = 0;
    result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v13, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      *v13 = *(_QWORD *)(a2 + 32);
      v10 = v13;
      *(_QWORD *)(a2 + 32) = v13;
      *((_DWORD *)v10 + 2) = 1;
      v10[2] = v9;
      *v12 = 0;
      v11 = v12;
      if (*a4)
      {
        **a4 = v12;
        v11 = v12;
      }
      else
      {
        *a3 = v12;
      }
      *a4 = v11;
      v11[1] = 0;
    }
  }
  return result;
}

uint64_t Accentuation1(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v8;
  uint64_t FirstAccPatVal;
  _QWORD *v10;
  int v11;
  int v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  _QWORD *v17;
  int matched;
  int v19;
  _QWORD *v20;
  _OWORD v21[2];

  v8 = mosyntkbsymtab_WildConsId(*(_QWORD *)(a2 + 8));
  *a4 = 0;
  if (!a3)
    return 0;
  if (*(_BYTE *)(a3 + 24))
  {
    if (*(_WORD *)(a3 + 26) == 1)
    {
      FirstAccPatVal = 0;
      *a4 = 1;
      return FirstAccPatVal;
    }
    return 0;
  }
  v10 = *(_QWORD **)(a3 + 8);
  if (!v10)
    return 0;
  v11 = v8;
  memset(v21, 0, sizeof(v21));
  v20 = 0;
  v19 = 0;
  do
  {
    FirstAccPatVal = Accentuation1(a1, a2, v10, &v19);
    if ((FirstAccPatVal & 0x80000000) != 0)
      return FirstAccPatVal;
    v12 = v19 + *a4;
    *a4 = v12;
    v10 = (_QWORD *)*v10;
  }
  while (v10);
  if (v12 < 2)
    return FirstAccPatVal;
  if (!mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8)))
  {
    v20 = 0;
    goto LABEL_30;
  }
  FirstAccPatVal = mosyntkbsymtab_GetFirstAccPatVal(a1, *(uint64_t ***)(a2 + 8), *(__int16 *)(a3 + 26), 3, (uint64_t)v21, &v20);
  if ((FirstAccPatVal & 0x80000000) != 0)
    return FirstAccPatVal;
  v13 = v20;
  if (!v20)
  {
LABEL_30:
    if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8)))
    {
      FirstAccPatVal = mosyntkbsymtab_GetFirstAccPatVal(a1, *(uint64_t ***)(a2 + 8), v11, 3, (uint64_t)v21, &v20);
      if ((FirstAccPatVal & 0x80000000) != 0)
        return FirstAccPatVal;
      v17 = v20;
      if (v20)
      {
        while (1)
        {
          *(_QWORD *)(a2 + 64) = 0;
          if (*(int *)a2 >= 2)
          {
            v14 = mosyntknowl_WriteTraceHeader(a1, 4u);
            if ((v14 & 0x80000000) != 0)
              return v14;
            v14 = mosyntbase_WString(a1, "applying default pattern", 0);
            if ((v14 & 0x80000000) != 0)
              return v14;
            v14 = mosyntbase_WLn(a1);
            if ((v14 & 0x80000000) != 0)
              return v14;
            v17 = v20;
          }
          matched = SingleTreeMatchFound(a1, a2, (uint64_t *)a3, v17);
          v14 = mosyntkbsymtab_DisposeAccPat(*(_QWORD **)(a2 + 8), &v20);
          if ((v14 & 0x80000000) != 0)
            return v14;
          FirstAccPatVal = mosyntkbsymtab_GetNextAccPatVal((uint64_t **)v21, &v20);
          if ((FirstAccPatVal & 0x80000000) != 0)
            return FirstAccPatVal;
          v17 = v20;
          if (!v20 || matched)
          {
            if (v20)
            {
              FirstAccPatVal = mosyntkbsymtab_DisposeAccPat(*(_QWORD **)(a2 + 8), &v20);
              if ((FirstAccPatVal & 0x80000000) != 0)
                return FirstAccPatVal;
            }
            if (!matched)
              break;
            goto LABEL_45;
          }
        }
      }
    }
    else
    {
      v20 = 0;
    }
LABEL_47:
    *a4 = 1;
    if (*(int *)a2 >= 1)
    {
      v14 = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntbase_WString(a1, "after accentuation of ", 0);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(a3 + 26));
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntbase_WString(a1, ": ", 0);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = WriteAccList(a1, a2, a3);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntbase_WLn(a1);
      if ((v14 & 0x80000000) != 0)
        return v14;
      FirstAccPatVal = mosyntbase_WLn(a1);
      if ((FirstAccPatVal & 0x80000000) != 0)
        return FirstAccPatVal;
    }
    if (mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8))
      && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(a3 + 26), 4u, 1))
    {
      return FirstAccPatVal;
    }
    return RhythmicAccShift(a1, (int *)a2, a3);
  }
  while (1)
  {
    *(_QWORD *)(a2 + 64) = 0;
    if (*(int *)a2 >= 2)
    {
      v14 = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntbase_WString(a1, "applying pattern for constituent ", 0);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(a3 + 26));
      if ((v14 & 0x80000000) != 0)
        return v14;
      v14 = mosyntbase_WLn(a1);
      if ((v14 & 0x80000000) != 0)
        return v14;
      v13 = v20;
    }
    v15 = SingleTreeMatchFound(a1, a2, (uint64_t *)a3, v13);
    v14 = mosyntkbsymtab_DisposeAccPat(*(_QWORD **)(a2 + 8), &v20);
    if ((v14 & 0x80000000) != 0)
      return v14;
    FirstAccPatVal = mosyntkbsymtab_GetNextAccPatVal((uint64_t **)v21, &v20);
    if ((FirstAccPatVal & 0x80000000) != 0)
      return FirstAccPatVal;
    v13 = v20;
    if (!v20 || v15)
    {
      if (v20)
      {
        FirstAccPatVal = mosyntkbsymtab_DisposeAccPat(*(_QWORD **)(a2 + 8), &v20);
        if ((FirstAccPatVal & 0x80000000) != 0)
          return FirstAccPatVal;
      }
      if (!v15)
        goto LABEL_30;
LABEL_45:
      ReduceAccents(a2, a3);
      FirstAccPatVal = 0;
      goto LABEL_47;
    }
  }
}

uint64_t SingleTreeMatchFound(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t result;

  v8 = mosyntkbsymtab_WildConsId(*(_QWORD *)(a2 + 8));
  if (!mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8))
    || !mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), v8, 9u, 1))
  {
    return MatchFound(a1, a2, a3, a4);
  }
  v9 = *a3;
  *a3 = 0;
  result = MatchFound(a1, a2, a3, a4);
  *a3 = v9;
  return result;
}

uint64_t ReduceAccents(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *i;

  v2 = result;
  if (*(_BYTE *)(a2 + 24))
  {
    if (*(_QWORD *)(result + 64) != a2)
      ++*(_WORD *)(a2 + 26);
  }
  else
  {
    for (i = *(_QWORD **)(a2 + 8); i; i = (_QWORD *)*i)
      result = ReduceAccents(v2, i);
  }
  return result;
}

uint64_t WriteAccList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v7;
  uint64_t *v8;
  _QWORD *v9;

  v8 = 0;
  v9 = 0;
  if (*(_BYTE *)(a3 + 24))
  {
    result = mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(a2 + 40), *(_DWORD *)(a3 + 16), &v8);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntdata_WriteCommandList(a1, v8);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, "[", 0);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WInt(a1, *(__int16 *)(a3 + 26), 0);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WString(a1, "]", 0);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntdata_GetSentTermWordPhonList(a1, *(_QWORD *)(a2 + 40), *(_DWORD *)(a3 + 16), &v9);
              if ((result & 0x80000000) == 0)
                return mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), v9);
            }
          }
        }
      }
    }
  }
  else
  {
    result = mosyntbase_WString(a1, "( ", 0);
    if ((result & 0x80000000) == 0)
    {
      v7 = (_QWORD *)(a3 + 8);
      while (1)
      {
        v7 = (_QWORD *)*v7;
        if (!v7)
          break;
        result = WriteAccList(a1, a2, v7);
        if ((result & 0x80000000) != 0)
          return result;
      }
      return mosyntbase_WString(a1, ")", 0);
    }
  }
  return result;
}

uint64_t RhythmicAccShift(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result;
  char v7;
  uint64_t v8[4];

  v8[3] = *MEMORY[0x1E0C80C00];
  v7 = 0;
  memset(v8, 0, 24);
  AccShift(a3, v8, &v7);
  if (!v7 || *a2 < 1)
    return 0;
  result = mosyntknowl_WriteTraceHeader(a1, 4u);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntbase_WString(a1, "accentuation after rhythmic shift: ", 0);
    if ((result & 0x80000000) == 0)
    {
      result = WriteAccList(a1, (uint64_t)a2, a3);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) == 0)
          return mosyntbase_WLn(a1);
      }
    }
  }
  return result;
}

uint64_t MatchFound(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;
  int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;

  if (*(int *)a2 >= 2)
  {
    mosyntknowl_WriteTraceHeader(a1, 4u);
    mosyntbase_WString(a1, "trying to match ", 0);
    if (a3)
    {
      if (*((_BYTE *)a3 + 24))
        mosyntbase_WInt(a1, *((__int16 *)a3 + 13), 0);
      else
        mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *((__int16 *)a3 + 13));
    }
    else
    {
      mosyntbase_WString(a1, "NIL", 0);
    }
    mosyntbase_WString(a1, "/", 0);
    if (a4)
    {
      if (*((__int16 *)a4 + 8) < 1)
        mosyntbase_WInt(a1, *((__int16 *)a4 + 9), 0);
      else
        mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *((unsigned __int16 *)a4 + 8));
    }
    else
    {
      mosyntbase_WString(a1, "NIL", 0);
    }
    mosyntbase_WLn(a1);
  }
  result = a3 == 0;
  if (!a4)
    return result;
  if (!a3)
  {
    if (!*a4)
    {
      v14 = *((__int16 *)a4 + 8);
      if (mosyntkbsymtab_Star2ConsId(*(_QWORD *)(a2 + 8)) != v14)
      {
        v15 = *((__int16 *)a4 + 8);
        return mosyntkbsymtab_StarConsId(*(_QWORD *)(a2 + 8)) == v15;
      }
      return 1;
    }
    return 0;
  }
  if (!*((_WORD *)a4 + 8))
  {
    if (*((_BYTE *)a3 + 24))
    {
      v16 = *((unsigned __int16 *)a3 + 13);
      if (v16 == *((unsigned __int16 *)a4 + 9))
      {
        if (v16 == 1)
        {
          if (*(int *)a2 >= 2)
          {
            mosyntknowl_WriteTraceHeader(a1, 4u);
            mosyntbase_WString(a1, "=== node marked", 0);
            mosyntbase_WLn(a1);
          }
          *(_QWORD *)(a2 + 64) = a3;
        }
        return 1;
      }
    }
    return 0;
  }
  v9 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_Star2ConsId(*(_QWORD *)(a2 + 8)) == v9)
  {
    if (!MatchFound(a1, a2, *a3, a4) && !MatchFound(a1, a2, *a3, *a4))
    {
      v10 = (_QWORD *)*a4;
      v11 = a1;
      v12 = a2;
      v13 = (uint64_t)a3;
      return MatchFound(v11, v12, v13, v10) != 0;
    }
    return 1;
  }
  v17 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_StarConsId(*(_QWORD *)(a2 + 8)) == v17)
  {
    if (!MatchFound(a1, a2, a3, *a4) && !MatchFound(a1, a2, *a3, *a4))
    {
      v13 = *a3;
      v11 = a1;
      v12 = a2;
      v10 = a4;
      return MatchFound(v11, v12, v13, v10) != 0;
    }
    return 1;
  }
  v18 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_Wild2ConsId(*(_QWORD *)(a2 + 8)) == v18)
  {
    result = DownMatchFound(a1, a2, a3, a4[1]);
    if (!(_DWORD)result)
      return result;
LABEL_38:
    v13 = *a3;
    v10 = (_QWORD *)*a4;
    v11 = a1;
    v12 = a2;
    return MatchFound(v11, v12, v13, v10) != 0;
  }
  v19 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_WildConsId(*(_QWORD *)(a2 + 8)) != v19
    && (*((_BYTE *)a3 + 24) || *((unsigned __int16 *)a3 + 13) != *((unsigned __int16 *)a4 + 8)))
  {
    return 0;
  }
  result = MatchFound(a1, a2, a3[1], a4[1]);
  if ((_DWORD)result)
    goto LABEL_38;
  return result;
}

uint64_t DownMatchFound(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  BOOL v11;

  v8 = *a3;
  *a3 = 0;
  if (MatchFound())
  {
    result = 1;
  }
  else
  {
    v10 = (_QWORD *)a3[1];
    if (v10)
    {
      do
      {
        result = DownMatchFound(a1, a2, v10, a4);
        v10 = (_QWORD *)*v10;
        if (v10)
          v11 = (_DWORD)result == 0;
        else
          v11 = 0;
      }
      while (v11);
    }
    else
    {
      result = 0;
    }
  }
  *a3 = v8;
  return result;
}

uint64_t AccShift(uint64_t result, uint64_t *a2, _BYTE *a3)
{
  uint64_t *i;
  uint64_t v6;
  uint64_t v7;
  int v9;
  uint64_t v10;

  for (i = *(uint64_t **)(result + 8); i; i = (uint64_t *)*i)
  {
    if (*((_BYTE *)i + 24))
    {
      if (*((unsigned __int16 *)i + 13) - 1 > 0x61)
        continue;
      v7 = a2[1];
      v6 = a2[2];
      *a2 = v7;
      a2[1] = v6;
      a2[2] = (uint64_t)i;
      if (!v7 || v6 == 0)
        continue;
      v9 = *((unsigned __int16 *)i + 13);
      if (v9 == 1 && *(_WORD *)(v6 + 26) == 2 && (*(_WORD *)(v7 + 26) & 0xFFFE) == 2)
      {
        *(_WORD *)(v6 + 26) = 3;
        v10 = *a2;
      }
      else
      {
        if (*(_WORD *)(v7 + 26) != 1 || (v9 & 0xFFFE) != 2 || *(_WORD *)(v6 + 26) != 2)
          continue;
        *(_WORD *)(v6 + 26) = 3;
        v10 = a2[2];
      }
      *(_WORD *)(v10 + 26) = 2;
      *a3 = 1;
    }
    else
    {
      result = AccShift(i, a2, a3);
    }
  }
  return result;
}

uint64_t GetInitPhrasing1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t *a7)
{
  _BYTE *v7;
  uint64_t InitPhrasing1;
  uint64_t v16;
  _BOOL4 v17;
  _BOOL4 HasIntPropValue;

  v7 = *(_BYTE **)(a3 + 8);
  if (!v7)
    return 0;
  if (v7[24])
    return AppendInitBound(a1, a2, a6, a7, a5, a3);
  v16 = (a4 + 1);
  do
  {
    InitPhrasing1 = GetInitPhrasing1(a1, a2, v7, v16, a5, a6, a7);
    if ((InitPhrasing1 & 0x80000000) != 0 || !*(_QWORD *)v7)
      break;
    if (!mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8))
      || !mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(*(_QWORD *)v7 + 26), 5u, 0))
    {
      v17 = mosyntkbsymtab_PropTabAvailable(*(_QWORD *)(a2 + 8));
      a5 = a4;
      if (!v17)
        continue;
      HasIntPropValue = mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(*(_QWORD *)v7 + 26), 5u, *(__int16 *)(a3 + 26));
      a5 = a4;
      if (!HasIntPropValue)
        continue;
    }
    a5 = 2;
    v7 = *(_BYTE **)v7;
  }
  while (v7);
  return InitPhrasing1;
}

uint64_t AppendInitBound(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4, __int16 a5, uint64_t a6)
{
  uint64_t PunctFromCommandList;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t SentTermWordPhonList;
  uint64_t v17;
  __int16 v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  uint64_t **v23;
  uint64_t v24;

  v23 = 0;
  v24 = 0;
  v22 = 0;
  v20 = 0;
  v21 = 0;
  PunctFromCommandList = mosyntpal_ALLOCATE(a1, &v24, 0x28u);
  if ((PunctFromCommandList & 0x80000000) == 0)
  {
    *(_QWORD *)v24 = 0;
    v13 = v24;
    if (*a3)
    {
      *(_QWORD *)*a4 = v24;
      v13 = v24;
    }
    else
    {
      *a3 = v24;
    }
    *a4 = v13;
    *(_WORD *)(v13 + 8) = a5;
    if (a6)
    {
      v14 = *(_QWORD *)(a6 + 8);
      *(_WORD *)(v13 + 10) = *(unsigned __int16 *)(v14 + 26) - 1 < 0x62;
      v15 = *(_DWORD *)(v14 + 16);
      *(_DWORD *)(v13 + 16) = v15;
      SentTermWordPhonList = mosyntdata_GetSentTermWordPhonList(a1, *(_QWORD *)(a2 + 40), v15, &v23);
      if ((SentTermWordPhonList & 0x80000000) != 0)
        return SentTermWordPhonList;
      v19 = 0;
      CountSyllsAndAccs(a2, v23, (_WORD *)(v24 + 12), &v19);
      v17 = v24;
      *(_QWORD *)(v24 + 20) = *(_QWORD *)(v14 + 16);
      *(_WORD *)(v17 + 28) = *(_WORD *)(a6 + 26);
      *(_WORD *)(v17 + 30) = *(_WORD *)(v14 + 26);
      *(_DWORD *)(v17 + 32) = 0;
      SentTermWordPhonList = mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(a2 + 40), *(_DWORD *)(v17 + 16), &v20);
      if ((SentTermWordPhonList & 0x80000000) != 0)
      {
        return SentTermWordPhonList;
      }
      else
      {
        PunctFromCommandList = mosyntdata_GetPunctFromCommandList(a1, v20, &v22, &v21);
        if ((PunctFromCommandList & 0x80000000) == 0
          && *(__int16 *)(v24 + 8) >= 2
          && mosyntknowl_IsIntraSentPunct(a1, v22))
        {
          *(_WORD *)(v24 + 8) = 1;
        }
      }
    }
    else
    {
      *(_DWORD *)(v13 + 10) = 0;
      *(_QWORD *)(v13 + 16) = 0;
      *(_QWORD *)(v13 + 24) = 0;
      *(_DWORD *)(v13 + 32) = 0;
    }
  }
  return PunctFromCommandList;
}

uint64_t FinalBoundaryIndex(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  unsigned int v4;

  if (!a2)
    return 2;
  v2 = 0;
  v3 = 0;
  do
  {
    if (!*((_DWORD *)a2 + 2))
    {
      v2 = a2;
      v3 = a2;
    }
    a2 = (uint64_t *)*a2;
  }
  while (a2);
  if (v3)
  {
    v4 = *((_DWORD *)v3 + 3);
    if (v2)
      return !mosyntknowl_IsSentFinalPunct(a1, v4);
  }
  else
  {
    v4 = 0;
    if (v2)
      return !mosyntknowl_IsSentFinalPunct(a1, v4);
  }
  return 2;
}

uint64_t WriteBoundList(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  uint64_t *v6;
  uint64_t result;
  uint64_t v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = 0;
  v13 = 0;
  if (a3)
  {
    v6 = a3;
    do
    {
      if ((__int16)v6[1] < 0)
      {
        v9 = a1;
        v10 = " $";
      }
      else
      {
        result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WString(a1, " #{", 0);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WInt(a1, *((__int16 *)v6 + 4), 0);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WString(a1, "}", 0);
        if ((result & 0x80000000) != 0)
          return result;
        if (a4)
        {
          result = mosyntbase_WString(a1, " (", 0);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntkbaccphr_PhraseTypeToString(*((_DWORD *)v6 + 8), (uint64_t)&v12, 10);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, (unsigned __int8 *)&v12, 10);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, ")", 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        result = mosyntbase_WString(a1, " <", 0);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WInt(a1, *((__int16 *)v6 + 5), 0);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WString(a1, ",", 0);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_WInt(a1, *((__int16 *)v6 + 6), 0);
        if ((result & 0x80000000) != 0)
          return result;
        v9 = a1;
        v10 = ">";
      }
      result = mosyntbase_WString(v9, (unsigned __int8 *)v10, 0);
      if ((result & 0x80000000) != 0)
        return result;
      if (!*v6)
        break;
      result = mosyntbase_WString(a1, " [", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WInt(a1, *((__int16 *)v6 + 15), 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, "]", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntdata_GetSentTermWordPhonList(a1, *(_QWORD *)(a2 + 40), *((_DWORD *)v6 + 5), &v11);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), v11);
      if ((result & 0x80000000) != 0)
        return result;
      v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  return mosyntbase_WLn(a1);
}

uint64_t CountSyllsAndAccs(uint64_t result, uint64_t **a2, _WORD *a3, _WORD *a4)
{
  uint64_t **v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  int v10;
  int v11;

  *a3 = 1;
  *a4 = 0;
  if (a2)
  {
    v6 = a2;
    v7 = result;
    v8 = 0;
    do
    {
      v9 = *((__int16 *)v6 + 12);
      result = mosyntkbsymtab_SyllSepId(*(_QWORD *)(v7 + 8));
      if ((_DWORD)result == v9)
      {
        ++*a3;
        if (v8 >= 1)
        {
          v8 = 0;
          ++*a4;
        }
      }
      else
      {
        v10 = *((__int16 *)v6 + 12);
        result = mosyntkbsymtab_PrimAccId(*(_QWORD *)(v7 + 8));
        if ((_DWORD)result == v10
          || (v11 = *((__int16 *)v6 + 12), result = mosyntkbsymtab_SecAccId(*(_QWORD *)(v7 + 8)), (_DWORD)result == v11))
        {
          ++v8;
        }
      }
      v6 = (uint64_t **)*v6;
    }
    while (v6);
    if (v8 >= 1)
      ++*a4;
  }
  return result;
}

uint64_t SetFunctionWords(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int ConsList;
  unsigned int v15;
  char v17;

  v17 = 0;
  if (a3 == a4)
    return 0;
  v5 = a3;
  v8 = 0;
  while (1)
  {
    v9 = *(_QWORD **)(*(_QWORD *)(v5 + 32) + 32);
    do
    {
      v10 = v9;
      v9 = (_QWORD *)*v9;
    }
    while (v9);
    v11 = *(_QWORD *)(a2 + 16);
    v12 = mosyntkbaccphr_AccPhrFunctionWords(v11);
    v17 = 0;
    if ((_DWORD)v12 != mosyntkbaccphr_Nil() && v17 == 0)
      break;
LABEL_9:
    if ((_DWORD)v12 != mosyntkbaccphr_Nil())
      *(_DWORD *)(v5 + 84) = 0;
    v5 = *(_QWORD *)(v5 + 16);
    if (v5 == a4)
      return v8;
  }
  while (1)
  {
    ConsList = mosyntkbaccphr_GetConsList(0, v11, v12);
    v15 = mosyntkbaccphr_GetConsList(1, v11, v12);
    v8 = mosyntkbaccphr_CheckMatchingConsFeat2(a1, v11, ConsList, v15, *(__int16 *)(v10[1] + 16), (unsigned __int16 *)(v10[1] + 24), &v17);
    if ((v8 & 0x80000000) != 0)
      return v8;
    if (!v17)
      v12 = mosyntkbaccphr_GetConsList(2, v11, v12);
    if ((_DWORD)v12 == mosyntkbaccphr_Nil() || v17)
      goto LABEL_9;
  }
}

uint64_t ChartToSentTermData(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  v2 = *(_QWORD *)(result + 40);
  if (v2)
    v3 = a2 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    do
    {
      v4 = *(_QWORD *)(a2 + 32);
      if (v4)
      {
        v7 = (uint64_t *)(v2 + 16 * *(int *)(v4 + 84));
        v5 = *v7;
        v6 = v7[1];
        if (v6)
        {
          v8 = *(__int16 *)(a2 + 68);
          if (v8 >= 2)
            v8 = 2;
          v9 = *(_DWORD *)(a2 + 76);
          *(_DWORD *)(v6 + 8) = v8;
          *(_DWORD *)(v6 + 12) = v9;
        }
        if (v5)
        {
          v10 = *(_DWORD *)(a2 + 84);
          if (v10 >= 3)
            v11 = 3;
          else
            v11 = *(_DWORD *)(a2 + 84);
          if (v10 <= 98)
            v12 = v11;
          else
            v12 = 0;
          *(_DWORD *)(v5 + 16) = v12;
        }
      }
      a2 = *(_QWORD *)(a2 + 16);
    }
    while (a2);
  }
  return result;
}

double NewAPVertex(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  double result;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;

  ++*(_DWORD *)(a2 + 72);
  if ((mosyntpal_ALLOCATE(a1, a4, 0x58u) & 0x80000000) == 0)
  {
    v9 = *a4;
    v12 = 0;
    if ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x18u) & 0x80000000) == 0)
    {
      *v12 = *(_QWORD *)(a2 + 32);
      v10 = v12;
      *(_QWORD *)(a2 + 32) = v12;
      *((_DWORD *)v10 + 2) = 2;
      v10[2] = v9;
      v11 = *a4;
      *(_DWORD *)v11 = *(_DWORD *)(a2 + 72);
      result = 0.0;
      *(_OWORD *)(v11 + 8) = 0u;
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + 40) = 0u;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = a3;
      *(_WORD *)(v11 + 68) = -1;
      *(_DWORD *)(v11 + 84) = -1;
      *(_QWORD *)(v11 + 72) = 0;
    }
  }
  return result;
}

void TreeToChart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t *v6;
  uint64_t v7;
  unsigned int v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  __int16 v15;
  __int16 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t **v27;
  uint64_t *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;

  v6 = a6;
  v7 = a4;
  v31 = 0;
  v30 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  *a6 = 0;
  v11 = *(_DWORD *)(a3 + 52);
  *(_DWORD *)(a4 + 64) = v11;
  if (*(_BYTE *)(a3 + 60))
  {
    if ((mosyntdata_GetSentTermCommList(a1, *(_QWORD *)(a2 + 40), v11, &v28) & 0x80000000) == 0
      && (mosyntdata_GetPunctFromCommandList(a1, v28, &v30, &v29) & 0x80000000) == 0)
    {
      if (mosyntknowl_IsIntraSentPunct(a1, v30))
        *(_WORD *)(v7 + 68) = 1;
      if ((mosyntdata_GetSentTermWordPhonList(a1, *(_QWORD *)(a2 + 40), *(_DWORD *)(a3 + 52), &v27) & 0x80000000) == 0
        && (NewAPEdge(a1, a2, a3, v6) & 0x80000000) == 0)
      {
        v12 = *v6;
        *(_DWORD *)(v12 + 92) = 0;
        *(_QWORD *)(v12 + 16) = v7;
        NewAPVertex(a1, a2, *(_DWORD *)(a3 + 56), (uint64_t *)(*v6 + 24));
        if ((v13 & 0x80000000) == 0)
        {
          CountSyllsAndAccs(a2, v27, (_WORD *)(*v6 + 82), (_WORD *)(*v6 + 80));
          *(_QWORD *)(v7 + 16) = *(_QWORD *)(*v6 + 24);
          *(_QWORD *)(*(_QWORD *)(*v6 + 24) + 8) = v7;
          *(_QWORD *)(v7 + 32) = *v6;
          *(_QWORD *)(*(_QWORD *)(*v6 + 24) + 24) = *v6;
          *(_QWORD *)*v6 = 0;
          *(_QWORD *)(*v6 + 8) = 0;
        }
      }
    }
  }
  else
  {
    v14 = *(_QWORD **)(a3 + 8);
    if (v14)
    {
      v24 = a3;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = (a5 + 1);
      while ((TreeToChart(a1, a2, v14, v7, v20, &v31) & 0x80000000) == 0)
      {
        v21 = v31;
        if (v31)
        {
          *(_QWORD *)(v31 + 64) = v19;
          if (!v18)
            v18 = v21;
          if (v19)
            *(_QWORD *)(v19 + 56) = v21;
          ++v17;
          v7 = *(_QWORD *)(v21 + 24);
          v16 += *(_WORD *)(v21 + 82);
          v15 += *(_WORD *)(v21 + 80);
          v19 = v21;
        }
        v14 = (_QWORD *)*v14;
        if (!v14)
        {
          v6 = a6;
          if (v7 == a4)
            goto LABEL_26;
          if (v17 < 2)
          {
            *a6 = v19;
            AddAPNode(a1, a2, v24, (uint64_t *)(v19 + 32));
          }
          else if ((NewAPEdge(a1, a2, v24, a6) & 0x80000000) == 0)
          {
            v22 = *a6;
            *(_DWORD *)(v22 + 92) = 1;
            *(_QWORD *)(v22 + 16) = a4;
            *(_QWORD *)(*a6 + 24) = v7;
            *(_QWORD *)*a6 = *(_QWORD *)(a4 + 48);
            *(_QWORD *)(a4 + 48) = *a6;
            *(_QWORD *)(*a6 + 8) = *(_QWORD *)(v7 + 40);
            *(_QWORD *)(v7 + 40) = *a6;
            v23 = *a6;
            *(_WORD *)(v23 + 82) = v16;
            *(_WORD *)(v23 + 80) = v15;
            for (*(_QWORD *)(v23 + 72) = v18; v18; v18 = *(_QWORD *)(v18 + 56))
              *(_QWORD *)(v18 + 48) = *a6;
          }
          return;
        }
      }
    }
    else
    {
LABEL_26:
      *v6 = 0;
    }
  }
}

uint64_t NewAPEdge(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;

  result = mosyntpal_ALLOCATE(a1, a4, 0x60u);
  if ((result & 0x80000000) == 0)
  {
    v9 = *a4;
    v12 = 0;
    result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      *v12 = *(_QWORD *)(a2 + 32);
      v10 = v12;
      *(_QWORD *)(a2 + 32) = v12;
      *((_DWORD *)v10 + 2) = 3;
      v10[2] = v9;
      v11 = *a4;
      *(_QWORD *)(v11 + 72) = 0;
      *(_OWORD *)v11 = 0u;
      *(_OWORD *)(v11 + 16) = 0u;
      *(_OWORD *)(v11 + 48) = 0u;
      *(_OWORD *)(v11 + 32) = 0u;
      *(_QWORD *)(v11 + 84) = *(_QWORD *)(a3 + 52);
      return AddAPNode(a1, a2, a3, (uint64_t *)(v11 + 32));
    }
  }
  return result;
}

uint64_t AddAPNode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  _QWORD *v14;

  v13 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v13, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    v9 = (uint64_t)v13;
    v14 = 0;
    result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v14, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      *v14 = *(_QWORD *)(a2 + 32);
      v10 = v14;
      *(_QWORD *)(a2 + 32) = v14;
      *((_DWORD *)v10 + 2) = 5;
      v10[2] = v9;
      v11 = v13;
      v13[1] = a3;
      *v11 = *a4;
      v12 = (uint64_t)v13;
      v13[2] = 0;
      *a4 = v12;
    }
  }
  return result;
}

uint64_t WriteCoverage(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int *v4;
  uint64_t result;
  _QWORD *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  _QWORD *v13;

  v4 = a3;
  v13 = 0;
  if (a3 != a4)
  {
    while (2)
    {
      HIDWORD(v11) = 0;
      LODWORD(v11) = 0;
      *(_QWORD *)((char *)&v11 + 4) = *v4;
      result = mosyntbase_WriteMessage(a1, " (%i) ", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, v11);
      if ((result & 0x80000000) != 0)
        return result;
      v9 = (_QWORD *)(*((_QWORD *)v4 + 4) + 32);
      do
      {
        v9 = (_QWORD *)*v9;
        if (!v9)
        {
          result = mosyntbase_WriteMessage(a1, "#### ERROR: didn't find terminal\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
          if ((result & 0x80000000) != 0)
            return result;
          goto LABEL_13;
        }
        v10 = v9[1];
      }
      while (!*(_BYTE *)(v10 + 60));
      result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(v10 + 16));
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, "[ ", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntdata_GetSentTermWordPhonList(a1, *(_QWORD *)(a2 + 40), *(_DWORD *)(*((_QWORD *)v4 + 4) + 84), &v13);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), v13);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WString(a1, " ] ", 0);
      if ((result & 0x80000000) != 0)
        return result;
LABEL_13:
      v4 = (unsigned int *)*((_QWORD *)v4 + 2);
      if (v4 != a4)
        continue;
      break;
    }
    v4 = a4;
  }
  HIDWORD(v12) = 0;
  LODWORD(v12) = 0;
  *(_QWORD *)((char *)&v12 + 4) = *v4;
  return mosyntbase_WriteMessage(a1, " (%i) ", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, v12);
}

uint64_t MatchEdge(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t *a5)
{
  _QWORD *v5;
  uint64_t v10;
  uint64_t result;
  int Rule;
  uint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  int v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  char v23;
  uint64_t v24;
  _OWORD v25[2];
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD **)(a3 + 32);
  if (!v5)
    return 0;
  v10 = *(_QWORD *)(a2 + 16);
  v26 = 0u;
  memset(v25, 0, sizeof(v25));
  v23 = 0;
  v21 = (uint64_t *)(a3 + 40);
  do
  {
    result = mosyntkbaccphr_LookupAccPhrRule(a1, *(_QWORD *)(a2 + 16), *(__int16 *)(v5[1] + 16), (__int16 *)(v5[1] + 24), &v23, (uint64_t)v25);
    if ((result & 0x80000000) != 0)
      return result;
    while (v23)
    {
      Rule = mosyntkbaccphr_GetRule(15, v10, DWORD2(v26));
      v13 = DWORD2(v26);
      if (Rule < 1)
      {
        if (IsMatchingRule(a1, a2, DWORD2(v26), (_QWORD **)v5, a3))
        {
          result = AddEdgeRule(a1, a2, SDWORD2(v26), (uint64_t)v5);
          if ((result & 0x80000000) != 0)
            return result;
          if ((int)mosyntkbaccphr_GetRule(0, v10, DWORD2(v26)) >= 1)
          {
            result = AddRuleScenarios(a1, a2, DWORD2(v26), v21, a5);
            if ((result & 0x80000000) != 0)
              return result;
          }
        }
      }
      else
      {
        v24 = 0;
        result = mosyntpal_ALLOCATE(a1, &v24, 0x20u);
        if ((result & 0x80000000) != 0)
          return result;
        result = NoteAPRuleListAlloc(a1, a2, v24);
        if ((result & 0x80000000) != 0)
          return result;
        v14 = (_QWORD *)v24;
        *(_DWORD *)(v24 + 8) = v13;
        v14[2] = a3;
        v14[3] = v5;
        v15 = *a4;
        if (*a4)
        {
          v16 = mosyntkbaccphr_GetRule(15, *(_QWORD *)(a2 + 16), *((unsigned int *)v15 + 2));
          if (v16 < (int)mosyntkbaccphr_GetRule(15, *(_QWORD *)(a2 + 16), v13))
          {
            while (1)
            {
              v17 = v15;
              v15 = (uint64_t *)*v15;
              if (!v15)
                break;
              v18 = mosyntkbaccphr_GetRule(15, *(_QWORD *)(a2 + 16), *((unsigned int *)v15 + 2));
              if (v18 >= (int)mosyntkbaccphr_GetRule(15, *(_QWORD *)(a2 + 16), v13))
              {
                v19 = *v17;
                goto LABEL_22;
              }
            }
            v19 = 0;
LABEL_22:
            *(_QWORD *)v24 = v19;
            *v17 = v24;
            goto LABEL_23;
          }
          v20 = *a4;
          v14 = (_QWORD *)v24;
        }
        else
        {
          v20 = 0;
        }
        *v14 = v20;
        *a4 = (uint64_t *)v24;
      }
LABEL_23:
      result = mosyntkbaccphr_GetNextAccPhrEntry(a1, v10, &v23, (uint64_t)v25);
      if ((result & 0x80000000) != 0)
        return result;
    }
    v5 = (_QWORD *)*v5;
  }
  while (v5);
  return result;
}

uint64_t IsMatchingRule(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD **a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  uint64_t *v24;
  int v25;
  uint64_t v26;
  int Rule;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  _QWORD v33[3];

  v33[2] = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v33[0] = 0;
  *(_QWORD *)((char *)v33 + 5) = 0;
  v10 = *(_QWORD *)(a2 + 16);
  v11 = **(_DWORD **)(a5 + 24) - **(_DWORD **)(a5 + 16);
  if ((int)mosyntkbaccphr_GetRule(8, v10, a3) <= v11
    && v11 <= (int)mosyntkbaccphr_GetRule(9, v10, a3)
    && (v12 = mosyntkbaccphr_GetRule(6, v10, a3), v13 = *(__int16 *)(a5 + 82), v12 <= v13)
    && (int)mosyntkbaccphr_GetRule(7, v10, a3) >= v13
    && (v14 = mosyntkbaccphr_GetRule(10, v10, a3), v15 = *(__int16 *)(a5 + 80), v14 <= v15)
    && (int)mosyntkbaccphr_GetRule(11, v10, a3) >= v15)
  {
    if (IsMatchingNodeContext(a1, a2, a3, a4, (_QWORD *)a5, 0))
    {
      if (IsMatchingNodeContext(a1, a2, a3, a4, (_QWORD *)a5, 1))
      {
        v16 = IsMatchingNodeContext(a1, a2, a3, a4, (_QWORD *)a5, 2);
        if ((_DWORD)v16)
        {
          Rule = mosyntkbaccphr_GetRule(5, v10, a3);
          if (Rule == mosyntkbaccphr_Nil())
          {
            v17 = 0;
          }
          else
          {
            v16 = IsMatchingNodeContext(a1, a2, a3, a4, (_QWORD *)a5, 3);
            if ((_DWORD)v16)
              v17 = 0;
            else
              v17 = 5;
          }
        }
        else
        {
          v17 = 4;
        }
      }
      else
      {
        v16 = 0;
        v17 = 3;
      }
    }
    else
    {
      v16 = 0;
      v17 = 2;
    }
  }
  else
  {
    v16 = 0;
    v17 = 1;
  }
  if (*(int *)a2 >= 2)
  {
    mosyntknowl_WriteTraceHeader(a1, 4u);
    m2__cp__str("[AccPhr]           ", &v32, 21);
    mosyntbase_WString(a1, "[AccPhr] Node ", 0);
    v18 = *(uint64_t **)(a2 + 8);
    v19 = mosyntkbaccphr_GetRule(1, v10, a3);
    mosyntkbaccphr_WriteAccPhrNode(a1, v18, v10, v19);
    mosyntbase_WStringLn(a1, " covers:", 0);
    mosyntbase_WString(a1, "[AccPhr] ", 0);
    WriteCoverage(a1, a2, *(unsigned int **)(a5 + 16), *(unsigned int **)(a5 + 24));
    mosyntbase_WLn(a1);
    mosyntbase_WStringLn(a1, "[AccPhr] Matching rule:", 0);
    mosyntbase_WString(a1, "[AccPhr] ", 0);
    mosyntkbaccphr_WriteRuleHeadline(a1, *(uint64_t **)(a2 + 8), v10, a3);
    mosyntbase_WLn(a1);
    if ((_DWORD)v16)
    {
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule matched successfully.\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
      return v16;
    }
    if (v17 == 5)
    {
      v24 = *(uint64_t **)(a2 + 8);
      v25 = mosyntkbaccphr_GetRule(5, v10, a3);
      mosyntkbaccphr_WriteChildrenList(a1, v24, v10, (unsigned __int8 *)&v32, 21, v25);
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule doesn't match: ", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
      v23 = "children";
    }
    else if (v17 == 1)
    {
      v20 = mosyntkbaccphr_GetRule(8, v10, a3);
      *((_QWORD *)&v29 + 1) = mosyntkbaccphr_GetRule(9, v10, a3);
      LODWORD(v29) = 0;
      DWORD1(v29) = v20;
      mosyntbase_WriteMessage(a1, "%s<wordrange(%i,%i)>\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, v29);
      v21 = mosyntkbaccphr_GetRule(6, v10, a3);
      *((_QWORD *)&v30 + 1) = mosyntkbaccphr_GetRule(7, v10, a3);
      LODWORD(v30) = 0;
      DWORD1(v30) = v21;
      mosyntbase_WriteMessage(a1, "%s<syllrange(%i,%i)>\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, v30);
      v22 = mosyntkbaccphr_GetRule(10, v10, a3);
      *((_QWORD *)&v31 + 1) = mosyntkbaccphr_GetRule(11, v10, a3);
      LODWORD(v31) = 0;
      DWORD1(v31) = v22;
      mosyntbase_WriteMessage(a1, "%s<accrange(%i,%i)>\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, v31);
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule doesn't match: ", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
      v23 = "constraints";
    }
    else
    {
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule doesn't match: ", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
      v26 = v17 - 2;
      if (v26 > 2)
      {
LABEL_18:
        mosyntbase_WStringLn(a1, " definition.", 0);
        return v16;
      }
      v23 = off_1EA93EC88[v26];
    }
    mosyntbase_WString(a1, (unsigned __int8 *)v23, 0);
    goto LABEL_18;
  }
  return v16;
}

uint64_t AddEdgeRule(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  _QWORD *v9;
  uint64_t v10;

  v10 = 0;
  result = mosyntpal_ALLOCATE(a1, &v10, 0x20u);
  if ((result & 0x80000000) == 0)
  {
    result = NoteAPRuleListAlloc(a1, a2, v10);
    if ((result & 0x80000000) == 0)
    {
      v9 = (_QWORD *)v10;
      *(_DWORD *)(v10 + 8) = a3;
      v9[2] = 0;
      v9[3] = a4;
      *v9 = *(_QWORD *)(a4 + 16);
      *(_QWORD *)(a4 + 16) = v10;
    }
  }
  return result;
}

uint64_t AddRuleScenarios(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t Scenario;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _BOOL4 v17;
  int RuleSet;
  int v19;
  uint64_t inserted;
  int v21;
  uint64_t *v23;
  int v24;

  v10 = *(_QWORD *)(a2 + 16);
  Scenario = mosyntkbaccphr_GetScenario(2, v10, *(unsigned int *)(a2 + 60));
  if ((_DWORD)Scenario != mosyntkbaccphr_Nil())
  {
    v23 = a5;
    v12 = 0;
    while (1)
    {
      if (mosyntkbaccphr_GetRuleSetIsSubset(v10, Scenario))
      {
        for (i = mosyntkbaccphr_AccPhrScenarios(*(_QWORD *)(a2 + 16)); ; i = mosyntkbaccphr_GetScenario(3, v10, v14))
        {
          v14 = i;
          if ((_DWORD)i == mosyntkbaccphr_Nil())
            break;
          v15 = mosyntkbaccphr_GetScenario(1, v10, v14);
          if (v15 == mosyntkbaccphr_GetRuleSet(2, v10, Scenario))
            break;
        }
        if ((_DWORD)v14 != mosyntkbaccphr_Nil())
        {
          v16 = mosyntkbaccphr_GetScenario(2, v10, v14);
          if ((_DWORD)v16 != mosyntkbaccphr_Nil())
          {
            do
            {
              if (mosyntkbaccphr_GetRuleSetIsSubset(v10, v16))
              {
                v17 = 0;
              }
              else
              {
                RuleSet = mosyntkbaccphr_GetRuleSet(1, v10, v16);
                v17 = RuleSet == mosyntkbaccphr_GetRule(0, v10, a3);
              }
              v16 = mosyntkbaccphr_GetRuleSet(4, v10, v16);
            }
            while ((_DWORD)v16 != mosyntkbaccphr_Nil() && !v17);
            if (v17)
            {
              v19 = mosyntkbaccphr_GetScenario(1, v10, v14);
              inserted = InsertScenario(a1, a2, v19, a4, &v24);
              if ((inserted & 0x80000000) != 0)
                return inserted;
              v21 = mosyntkbaccphr_GetScenario(1, v10, v14);
              v12 = InsertScenario(a1, a2, v21, v23, &v24);
              if ((v12 & 0x80000000) != 0)
                return v12;
            }
          }
        }
      }
      Scenario = mosyntkbaccphr_GetRuleSet(4, v10, Scenario);
      if ((_DWORD)Scenario == mosyntkbaccphr_Nil())
        return v12;
    }
  }
  return 0;
}

uint64_t NoteAPRuleListAlloc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v6;
  _QWORD *v7;

  v7 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v7, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    *v7 = *(_QWORD *)(a2 + 32);
    v6 = v7;
    *(_QWORD *)(a2 + 32) = v7;
    *((_DWORD *)v6 + 2) = 4;
    v6[2] = a3;
  }
  return result;
}

uint64_t IsMatchingNodeContext(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD **a4, _QWORD *a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t Rule;
  char NodeMatchOp;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v20;
  uint64_t Children;
  int Node;
  _QWORD *v23;
  char v24;
  _QWORD *v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 v32;
  unsigned int v33;
  unsigned int v34;

  v33 = 0;
  v11 = *(_QWORD *)(a2 + 16);
  switch(a6)
  {
    case 0:
      v12 = 2;
      goto LABEL_6;
    case 1:
      v12 = 3;
      goto LABEL_6;
    case 2:
      v12 = 4;
LABEL_6:
      Rule = mosyntkbaccphr_GetRule(v12, *(_QWORD *)(a2 + 16), a3);
      v33 = Rule;
      goto LABEL_7;
    case 3:
      v20 = mosyntkbaccphr_GetRule(5, *(_QWORD *)(a2 + 16), a3);
      break;
    default:
      Rule = 0;
LABEL_7:
      if (mosyntkbaccphr_GetNode(3, v11, Rule))
      {
        NodeMatchOp = mosyntkbaccphr_GetNodeMatchOp(v11, Rule);
        if (a6)
          goto LABEL_14;
        if ((NodeMatchOp & 1) == 0)
          goto LABEL_14;
        v15 = (_QWORD *)a5[4];
        v34 = Rule;
        if (v15 == a4)
          goto LABEL_14;
        do
        {
          v16 = IsMatchingNode(a1, a2, &v34, (uint64_t)v15);
          LODWORD(v17) = v16;
          if (v16)
            break;
          v15 = (_QWORD *)*v15;
        }
        while (v15 != a4);
        if (!v16)
        {
LABEL_14:
          if ((mosyntkbaccphr_GetNodeMatchOp(v11, Rule) & 2) != 0)
          {
            v18 = mosyntkbaccphr_GetNodeMatchOp(v11, Rule);
            LODWORD(v17) = IsMatchingNodeNeighbours(a1, a2, &v33, a5, a6, (v18 >> 2) & 1);
            LODWORD(Rule) = v33;
          }
          else
          {
            LODWORD(v17) = 0;
          }
        }
      }
      else
      {
        LODWORD(v17) = 1;
      }
      if (mosyntkbaccphr_GetNodeNegated(v11, Rule))
        return (_DWORD)v17 == 0;
      else
        return v17;
  }
  while (1)
  {
    if ((_DWORD)v20 == mosyntkbaccphr_Nil())
      return 0;
    Children = mosyntkbaccphr_GetChildren(1, v11, v20);
    if (!mosyntkbaccphr_GetChildrenOp(v11, v20))
      break;
    if ((mosyntkbaccphr_GetNodeMatchOp(v11, Children) & 1) != 0
      && (Node = mosyntkbaccphr_GetNode(8, v11, Children), Node == mosyntkbaccphr_Nil())
      && (v23 = *a4, v34 = Children, v23))
    {
      do
      {
        v17 = IsMatchingNode(a1, a2, &v34, (uint64_t)v23);
        if ((_DWORD)v17)
          break;
        v23 = (_QWORD *)*v23;
      }
      while (v23);
    }
    else
    {
      v17 = 0;
    }
    while ((_DWORD)Children != mosyntkbaccphr_Nil())
    {
      v24 = mosyntkbaccphr_GetNodeMatchOp(v11, Children);
      Children = mosyntkbaccphr_GetNode(8, v11, Children);
      if ((v24 & 2) == 0)
        goto LABEL_55;
    }
    if ((_DWORD)v17)
      goto LABEL_59;
    if (a5[9])
    {
      v29 = mosyntkbaccphr_GetChildren(1, v11, v20);
      v30 = a5[2];
      v31 = a5[9];
      v32 = mosyntkbaccphr_GetChildrenOp(v11, v20) == 2;
      v17 = IsMatchingChildren(a1, a2, v29, v30, (uint64_t)a5, v31, v32);
    }
    else
    {
      v17 = 0;
    }
LABEL_55:
    v20 = mosyntkbaccphr_GetChildren(2, v11, v20);
    if ((_DWORD)v17)
      return v17;
  }
  if ((_DWORD)Children != mosyntkbaccphr_Nil())
  {
    while (1)
    {
      if ((mosyntkbaccphr_GetNodeMatchOp(v11, Children) & 1) == 0)
        goto LABEL_62;
      v25 = *a4;
      v34 = Children;
      if (!v25)
        goto LABEL_62;
      do
      {
        v26 = IsMatchingNode(a1, a2, &v34, (uint64_t)v25);
        LODWORD(v17) = v26;
        if (v26)
          break;
        v25 = (_QWORD *)*v25;
      }
      while (v25);
      if (!v26)
LABEL_62:
        LODWORD(v17) = (mosyntkbaccphr_GetNodeMatchOp(v11, Children) & 2) != 0
                    && (v27 = (_QWORD *)a5[9]) != 0
                    && IsMatchingChildFuzzy(a1, a2, Children, v27);
      v17 = mosyntkbaccphr_GetNodeNegated(v11, Children) ? (_DWORD)v17 == 0 : v17;
      v28 = mosyntkbaccphr_GetNode(8, v11, Children);
      if (!(_DWORD)v17)
        goto LABEL_55;
      Children = v28;
      if ((_DWORD)v28 == mosyntkbaccphr_Nil())
        goto LABEL_59;
    }
  }
  v17 = 1;
LABEL_59:
  mosyntkbaccphr_GetChildren(2, v11, v20);
  return v17;
}

BOOL IsMatchingChildFuzzy(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  _QWORD *v9;
  int v10;
  unsigned int v12;

  v8 = *(_QWORD *)(a2 + 16);
  v9 = (_QWORD *)a4[4];
  v12 = a3;
  if (v9)
  {
    do
    {
      v10 = IsMatchingNode(a1, a2, &v12, (uint64_t)v9);
      if (v10)
        break;
      v9 = (_QWORD *)*v9;
    }
    while (v9);
    if (v10)
      return 1;
  }
  if ((mosyntkbaccphr_GetNodeMatchOp(v8, a3) & 4) != 0 && a4[9] && IsMatchingChildFuzzy(a1, a2, a3))
    return 1;
  if (a4[7])
    return IsMatchingChildFuzzy(a1, a2, a3) != 0;
  return 0;
}

uint64_t IsMatchingChildren(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  _QWORD *v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int Node;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v28;

  while (2)
  {
    if (*(_QWORD *)(a6 + 16) == a4)
    {
      v14 = *(_DWORD *)(a6 + 92) == 0;
      v13 = (_QWORD *)a6;
    }
    else
    {
      v13 = *(_QWORD **)(a4 + 48);
      if (v13)
      {
        v14 = 0;
      }
      else
      {
        v13 = *(_QWORD **)(a4 + 32);
        v14 = 1;
      }
    }
    v15 = *(_QWORD *)(a2 + 16);
    do
    {
      while (1)
      {
        v16 = v13[4];
        v28 = a3;
        if (!v16)
          goto LABEL_22;
        do
        {
          v17 = IsMatchingNode(a1, a2, &v28, v16);
          if (v17)
            break;
          v16 = *(_QWORD *)v16;
        }
        while (v16);
        if (!v17)
          goto LABEL_20;
        Node = mosyntkbaccphr_GetNode(8, v15, a3);
        if (Node != mosyntkbaccphr_Nil())
        {
          if ((mosyntkbaccphr_GetNodeMatchOp(v15, a3) & 4) != 0 && *(_DWORD *)v13[3] < **(_DWORD **)(a6 + 24))
          {
            v19 = mosyntkbaccphr_GetNode(8, v15, a3);
            v20 = v13[3];
            v21 = a7;
            v22 = a1;
            v23 = a2;
            v24 = a5;
            v25 = a6;
LABEL_19:
            v16 = IsMatchingChildren(v22, v23, v19, v20, v24, v25, v21);
            goto LABEL_22;
          }
          if (*(_QWORD *)(a6 + 56))
          {
            v19 = mosyntkbaccphr_GetNode(8, v15, a3);
            v25 = *(_QWORD *)(a6 + 56);
            v20 = *(_QWORD *)(v25 + 16);
            v21 = a7;
            v22 = a1;
            v23 = a2;
            v24 = a5;
            goto LABEL_19;
          }
LABEL_20:
          v16 = 0;
          goto LABEL_22;
        }
        v16 = !a7 || (unint64_t)(v13[3] == *(_QWORD *)(a5 + 24));
LABEL_22:
        if ((mosyntkbaccphr_GetNodeMatchOp(v15, a3) & 4) == 0)
          goto LABEL_28;
        v13 = (_QWORD *)*v13;
        if (!v13)
          break;
        if ((_DWORD)v16)
          goto LABEL_28;
      }
      if (v14)
        break;
      v13 = *(_QWORD **)(a4 + 32);
      v14 = 1;
    }
    while (!(_DWORD)v16);
LABEL_28:
    if (!(v16 | a7))
    {
      if ((mosyntkbaccphr_GetNodeMatchOp(v15, a3) & 4) != 0 && *(_DWORD *)a4 + 1 < **(_DWORD **)(a6 + 24))
      {
        a7 = 0;
        a4 = *(_QWORD *)(a4 + 16);
        continue;
      }
      a6 = *(_QWORD *)(a6 + 56);
      if (a6)
      {
        a7 = 0;
        a4 = *(_QWORD *)(a6 + 16);
        continue;
      }
      return 0;
    }
    return v16;
  }
}

uint64_t IsMatchingNodeNeighbours(uint64_t a1, uint64_t a2, unsigned int *a3, _QWORD *a4, int a5, int a6)
{
  int v6;
  int v7;
  _QWORD *v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v37;
  int v38;
  uint64_t *v39;

  while (1)
  {
    v6 = a6;
    v7 = a5;
    v8 = a4;
    v9 = a3;
    v10 = a2;
    v11 = a1;
    v38 = 0;
    v37 = 0;
    v12 = *(_QWORD *)(a2 + 16);
    if (mosyntkbaccphr_GetNode(3, v12, *a3) == 3)
      break;
    if (v7 == 2)
    {
      v18 = v8[3];
      v19 = *(_QWORD **)(v18 + 48);
      if (v19)
      {
        do
        {
          v20 = (_QWORD *)v19[4];
          LODWORD(v39) = *v9;
          if (v20)
          {
            do
            {
              result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v20);
              if ((_DWORD)result)
                break;
              v20 = (_QWORD *)*v20;
            }
            while (v20);
          }
          else
          {
            result = 0;
          }
          if ((_DWORD)result)
            break;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
        v18 = v8[3];
        if ((_DWORD)result)
          return result;
      }
      else
      {
        result = 0;
      }
      v26 = *(_QWORD **)(v18 + 32);
      if (!v26)
        return result;
      v27 = (_QWORD *)v26[4];
      LODWORD(v39) = *v9;
      if (v27)
      {
        do
        {
          result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v27);
          if ((_DWORD)result)
            break;
          v27 = (_QWORD *)*v27;
        }
        while (v27);
      }
      else
      {
        result = 0;
      }
      if (!v6 || (_DWORD)result)
        return result;
      a1 = v11;
      a2 = v10;
      a3 = v9;
      a4 = v26;
      a5 = 2;
    }
    else if (v7 == 1)
    {
      v21 = v8[2];
      v22 = *(_QWORD *)(v21 + 40);
      if (v22)
      {
        do
        {
          v23 = *(_QWORD **)(v22 + 32);
          LODWORD(v39) = *v9;
          if (v23)
          {
            do
            {
              result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v23);
              if ((_DWORD)result)
                break;
              v23 = (_QWORD *)*v23;
            }
            while (v23);
          }
          else
          {
            result = 0;
          }
          if ((_DWORD)result)
            break;
          v22 = *(_QWORD *)(v22 + 8);
        }
        while (v22);
        v21 = v8[2];
        if ((_DWORD)result)
          return result;
      }
      else
      {
        result = 0;
      }
      v28 = *(_QWORD **)(v21 + 24);
      if (!v28)
        return result;
      v29 = (_QWORD *)v28[4];
      LODWORD(v39) = *v9;
      if (v29)
      {
        do
        {
          result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v29);
          if ((_DWORD)result)
            break;
          v29 = (_QWORD *)*v29;
        }
        while (v29);
      }
      else
      {
        result = 0;
      }
      if (!v6 || (_DWORD)result)
        return result;
      a1 = v11;
      a2 = v10;
      a3 = v9;
      a4 = v28;
      a5 = 1;
    }
    else
    {
      if (v7)
        return 0;
      v15 = v8[6];
      if (!v15)
        return 0;
      v16 = *(_QWORD **)(v15 + 32);
      LODWORD(v39) = *v9;
      if (v16)
      {
        do
        {
          result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v16);
          if ((_DWORD)result)
            break;
          v16 = (_QWORD *)*v16;
        }
        while (v16);
      }
      else
      {
        result = 0;
      }
      if (!v6 || (_DWORD)result)
        return result;
      a4 = (_QWORD *)v8[6];
      a1 = v11;
      a2 = v10;
      a3 = v9;
      a5 = 0;
    }
    a6 = 1;
  }
  if (v7 != 2)
  {
    if (v7 == 1)
    {
      if (mosyntkbaccphr_GetNode(7, v12, *v9) == 1)
      {
        v13 = v8[2];
        v39 = 0;
        if (v13)
        {
          mosyntdata_GetSentTermCommList(v11, *(_QWORD *)(v10 + 40), *(_DWORD *)(v13 + 64), &v39);
          result = v39 != 0;
          if (!v6)
            return result;
        }
        else
        {
          result = 0;
          if (!v6)
            return result;
        }
        if ((result & 1) == 0)
        {
          v32 = v8[2];
          do
          {
            v32 = *(_QWORD *)(v32 + 8);
            if (!v32)
              break;
            v39 = 0;
            mosyntdata_GetSentTermCommList(v11, *(_QWORD *)(v10 + 40), *(_DWORD *)(v32 + 64), &v39);
          }
          while (!v39);
          return v32 != 0;
        }
        return result;
      }
      if (mosyntkbaccphr_GetNode(7, v12, *v9) == 2)
      {
        v24 = *(_QWORD *)(v8[2] + 8);
        return v6 || v24 == 0;
      }
    }
    return 0;
  }
  if (mosyntkbaccphr_GetNode(7, v12, *v9) != 1)
  {
    if (mosyntkbaccphr_GetNode(7, v12, *v9) == 3)
    {
      v24 = *(_QWORD *)(v8[3] + 16);
      return v6 || v24 == 0;
    }
    if (mosyntkbaccphr_GetNode(7, v12, *v9) == 4)
    {
      v30 = v8[3];
      v39 = 0;
      if (v30)
      {
        mosyntdata_GetSentTermCommList(v11, *(_QWORD *)(v10 + 40), *(_DWORD *)(v30 + 64), &v39);
        v31 = v39;
      }
      else
      {
        v31 = 0;
      }
      mosyntdata_GetPunctFromCommandList(v11, v31, &v38, &v37);
      result = v38 == 10;
      if (!v6 || v38 == 10)
        return result;
      v33 = *(_QWORD *)(v8[3] + 16);
      if (v33)
      {
        do
        {
          v34 = v8[3];
          v39 = 0;
          if (v34)
          {
            mosyntdata_GetSentTermCommList(v11, *(_QWORD *)(v10 + 40), *(_DWORD *)(v34 + 64), &v39);
            v35 = v39;
          }
          else
          {
            v35 = 0;
          }
          mosyntdata_GetPunctFromCommandList(v11, v35, &v38, &v37);
          v33 = *(_QWORD *)(v33 + 16);
        }
        while (v38 != 10 && v33 != 0);
        return v38 == 10;
      }
    }
    return 0;
  }
  v17 = v8[3];
  v39 = 0;
  if (v17)
  {
    mosyntdata_GetSentTermCommList(v11, *(_QWORD *)(v10 + 40), *(_DWORD *)(v17 + 64), &v39);
    result = v39 != 0;
    if (!v6)
      return result;
  }
  else
  {
    result = 0;
    if (!v6)
      return result;
  }
  if ((result & 1) == 0)
  {
    v32 = v8[3];
    do
    {
      v32 = *(_QWORD *)(v32 + 16);
      if (!v32)
        break;
      v39 = 0;
      mosyntdata_GetSentTermCommList(v11, *(_QWORD *)(v10 + 40), *(_DWORD *)(v32 + 64), &v39);
    }
    while (!v39);
    return v32 != 0;
  }
  return result;
}

uint64_t IsMatchingNode(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t **v8;
  int v9;
  int Rule;
  int v11;
  int v12;
  int Node;
  unsigned int v15;
  unsigned __int8 v16;

  v7 = *(_QWORD *)(a2 + 16);
  v16 = 0;
  switch(mosyntkbaccphr_GetNode(3, v7, *a3))
  {
    case 0u:
      return 1;
    case 1u:
      v8 = (uint64_t **)(a4 + 16);
      break;
    case 2u:
      Node = mosyntkbaccphr_GetNode(5, v7, *a3);
      v15 = mosyntkbaccphr_GetNode(6, v7, *a3);
      mosyntkbaccphr_CheckMatchingConsFeat2(a1, v7, Node, v15, *(__int16 *)(*(_QWORD *)(a4 + 8) + 16), (unsigned __int16 *)(*(_QWORD *)(a4 + 8) + 24), (char *)&v16);
      return v16;
    case 3u:
      mosyntbase_WriteDevelMessage(a1, "IsMatchingNode -- Property, not handeled here\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
      return 0;
    default:
      return 0;
  }
  while (1)
  {
    v8 = (uint64_t **)*v8;
    if (!v8)
      break;
    v9 = mosyntkbaccphr_GetNode(4, v7, *a3);
    Rule = mosyntkbaccphr_GetRule(0, v7, *((unsigned int *)v8 + 2));
    v11 = mosyntkbaccphr_GetRule(0, v7, *((unsigned int *)v8 + 2));
    if (Rule >= 0)
      v12 = v11;
    else
      v12 = -v11;
    if (v9 == v12)
      return 1;
  }
  return 0;
}

uint64_t InsertScenario(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, _DWORD *a5)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  uint64_t result;
  uint64_t *v11;

  v6 = 0;
  *a5 = 1;
  v7 = a4;
  while (1)
  {
    v8 = v6;
    v11 = v6;
    v6 = (uint64_t *)*v7;
    if (!*v7)
      break;
    v9 = *((_DWORD *)v6 + 2);
    v7 = (uint64_t *)*v7;
    if (v9 >= a3)
    {
      if (v8)
      {
        if (v9 <= a3)
          goto LABEL_13;
        goto LABEL_8;
      }
      if (v9 <= a3)
      {
LABEL_13:
        result = 0;
        *a5 = 0;
        return result;
      }
      goto LABEL_11;
    }
  }
  if (v8)
  {
LABEL_8:
    result = NewScenarioList(a1, a2, a3, v8);
    if ((result & 0x80000000) == 0)
      *(_QWORD *)*v8 = v6;
    return result;
  }
LABEL_11:
  result = NewScenarioList(a1, a2, a3, (uint64_t *)&v11);
  if ((result & 0x80000000) == 0)
  {
    *v11 = *a4;
    *a4 = (uint64_t)v11;
  }
  return result;
}

uint64_t NewScenarioList(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;

  v7 = *(_QWORD *)(a2 + 80);
  if (v7)
  {
    result = 0;
    *a4 = v7;
    *(_QWORD *)(a2 + 80) = **(_QWORD **)(a2 + 80);
LABEL_6:
    v12 = *a4;
    *(_DWORD *)(v12 + 8) = a3;
    *(_QWORD *)v12 = 0;
    return result;
  }
  result = mosyntpal_ALLOCATE(a1, a4, 0x10u);
  if ((result & 0x80000000) == 0)
  {
    v10 = *a4;
    v13 = 0;
    result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v13, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      *v13 = *(_QWORD *)(a2 + 32);
      v11 = v13;
      *(_QWORD *)(a2 + 32) = v13;
      *((_DWORD *)v11 + 2) = 6;
      v11[2] = v10;
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t AddSegment(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  int RuleSet;
  _QWORD *v19;
  uint64_t v21;
  _QWORD *v22;

  v21 = 0;
  v10 = mosyntpal_ALLOCATE(a1, &v21, 0x28u);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v11 = v21;
  v22 = 0;
  v12 = mosyntpal_ALLOCATE(a1, (uint64_t *)&v22, 0x18u);
  if ((v12 & 0x80000000) == 0)
  {
    *v22 = *(_QWORD *)(a2 + 32);
    v13 = v22;
    *(_QWORD *)(a2 + 32) = v22;
    *((_DWORD *)v13 + 2) = 7;
    v13[2] = v11;
    v14 = v21;
    *(_QWORD *)(v21 + 8) = a4;
    *(_QWORD *)(v14 + 16) = a5;
    *(_DWORD *)(v14 + 24) = a3;
    *(_DWORD *)(v14 + 28) = *a5 - *(_DWORD *)a4;
    v15 = *(_QWORD *)(a2 + 16);
    for (i = mosyntkbaccphr_GetScenario(2, v15, *(unsigned int *)(a2 + 60));
          ;
          i = mosyntkbaccphr_GetRuleSet(4, v15, v17))
    {
      v17 = i;
      if ((_DWORD)i == mosyntkbaccphr_Nil()
        || mosyntkbaccphr_GetRuleSet(2, v15, v17) == a3)
      {
        break;
      }
    }
    if ((_DWORD)v17 == mosyntkbaccphr_Nil())
      RuleSet = 10000;
    else
      RuleSet = mosyntkbaccphr_GetRuleSet(3, v15, v17);
    v19 = (_QWORD *)v21;
    *(_DWORD *)(v21 + 32) = RuleSet;
    *v19 = *(_QWORD *)(a4 + 56);
    *(_QWORD *)(a4 + 56) = v21;
  }
  return v12;
}

uint64_t GetBestScenarioPathSuffix(uint64_t a1, _QWORD *a2, uint64_t **a3, uint64_t a4, uint64_t a5, int *a6, _DWORD *a7, _DWORD *a8, uint64_t *a9)
{
  _DWORD *v9;
  uint64_t v17;
  uint64_t result;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  int v22;
  uint64_t *v23;
  int v24;
  _QWORD *v25;
  _QWORD *v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _DWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;

  v9 = a8;
  v17 = *(_QWORD *)(a4 + 16);
  if (v17 == a5)
  {
    result = 0;
    *a6 = 0;
    *a7 = 0;
    *a8 = 0;
    *a9 = 0;
  }
  else
  {
    result = GetBestScenarioPathSuffix(a1, a2, a3, v17, a5, a6, a7, a8, a9);
    if ((result & 0x80000000) != 0)
      return result;
  }
  v19 = *(uint64_t **)(a4 + 56);
  if (!v19)
    return result;
  v39 = 0;
  v40 = 0;
  v37 = 0;
  v38 = 0;
  v36 = v9;
  while (1)
  {
    if (v19[2] == a5)
    {
      v40 = 0;
      HIDWORD(v39) = 0;
      v37 = 0;
      if (!a3)
        goto LABEL_30;
      v22 = *((_DWORD *)v19 + 6);
      v23 = (uint64_t *)a3;
      while (1)
      {
        v24 = *((_DWORD *)v23 + 2);
        if (v24 >= v22)
          break;
        v23 = (uint64_t *)*v23;
        if (!v23)
          goto LABEL_30;
      }
      if (v24 == v22)
        LODWORD(v39) = 0;
      else
LABEL_30:
        LODWORD(v39) = 1;
      goto LABEL_31;
    }
    if (a3)
      break;
    v38 = 0;
LABEL_21:
    result = InsertScenario(a1, (uint64_t)a2, *((_DWORD *)v19 + 6), (uint64_t *)&v38, &v39);
    if ((result & 0x80000000) != 0)
      return result;
    result = GetBestScenarioPathSuffix(a1, a2, v38, v19[2], a5, (char *)&v40 + 4, &v40, (char *)&v39 + 4, &v37);
    if ((result & 0x80000000) != 0)
      return result;
    v25 = v38;
    if (v38)
    {
      do
      {
        v26 = v25;
        v25 = (_QWORD *)*v25;
      }
      while (v25);
      result = 0;
      *v26 = a2[10];
      a2[10] = v38;
      v38 = 0;
    }
    else
    {
      result = 0;
    }
    v9 = v36;
LABEL_31:
    v27 = *((_DWORD *)v19 + 7) + HIDWORD(v40);
    if (v27 <= *a6)
    {
      if (v27 != *a6)
        goto LABEL_49;
      v28 = v40;
      v29 = *((_DWORD *)v19 + 8) + v40;
      if (v29 >= *a7 && (v29 != *a7 || (int)v39 + HIDWORD(v39) >= *v9))
        goto LABEL_49;
    }
    else
    {
      v28 = v40;
    }
    *a6 = v27;
    *a7 = *((_DWORD *)v19 + 8) + v28;
    *v9 = v39 + HIDWORD(v39);
    v30 = *a9;
    if (*a9)
    {
      v31 = *(_QWORD **)v30;
      if (*(_QWORD *)v30)
      {
        do
        {
          v32 = v31;
          v31 = (_QWORD *)*v31;
        }
        while (v31);
        *v32 = a2[11];
        a2[11] = *(_QWORD *)v30;
        *(_QWORD *)v30 = 0;
        v30 = *a9;
      }
      result = 0;
      *(_QWORD *)(v30 + 8) = v19;
    }
    else
    {
      v33 = a2[11];
      if (v33)
      {
        result = 0;
        *a9 = v33;
        a2[11] = *(_QWORD *)a2[11];
      }
      else
      {
        result = mosyntpal_ALLOCATE(a1, a9, 0x10u);
        if ((result & 0x80000000) != 0)
          return result;
        v34 = *a9;
        v41 = 0;
        result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v41, 0x18u);
        if ((result & 0x80000000) != 0)
          return result;
        *v41 = a2[4];
        v35 = v41;
        a2[4] = v41;
        *((_DWORD *)v35 + 2) = 8;
        v35[2] = v34;
        v9 = v36;
      }
      *(_QWORD *)(*a9 + 8) = v19;
      *(_QWORD *)*a9 = 0;
    }
    *(_QWORD *)*a9 = v37;
LABEL_49:
    v19 = (uint64_t *)*v19;
    if (!v19)
      return result;
  }
  result = NewScenarioList(a1, (uint64_t)a2, *((_DWORD *)a3 + 2), (uint64_t *)&v38);
  if ((result & 0x80000000) != 0)
    return result;
  v20 = *a3;
  if (!*a3)
    goto LABEL_21;
  v21 = (uint64_t *)&v38;
  while (1)
  {
    v21 = (uint64_t *)*v21;
    result = NewScenarioList(a1, (uint64_t)a2, *((_DWORD *)v20 + 2), v21);
    if ((result & 0x80000000) != 0)
      return result;
    v20 = (uint64_t *)*v20;
    if (!v20)
      goto LABEL_21;
  }
}

uint64_t IsRightMatchingTarget(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  while (1)
  {
    v10 = *(_QWORD *)(a2 + 16);
    *a5 = a4;
    v11 = (_QWORD *)a4[4];
    v15 = a3;
    if (v11)
    {
      do
      {
        result = IsMatchingNode(a1, a2, &v15, (uint64_t)v11);
        if ((_DWORD)result)
          break;
        v11 = (_QWORD *)*v11;
      }
      while (v11);
      if ((_DWORD)result)
        break;
    }
    if ((mosyntkbaccphr_GetNodeMatchOp(v10, a3) & 4) != 0)
    {
      v13 = a4[9];
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = *(_QWORD *)(v13 + 56);
        }
        while (v13);
        result = IsRightMatchingTarget(a1, a2, a3, v14, a5);
        if ((_DWORD)result)
          break;
      }
    }
    a4 = (_QWORD *)a4[8];
    if (!a4)
      return 0;
  }
  return result;
}

BOOL IsLeftMatchingTarget(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  unsigned int v16;

  v10 = *(_QWORD *)(a2 + 16);
  *a5 = a4;
  v11 = (_QWORD *)a4[4];
  v16 = a3;
  if (v11)
  {
    do
    {
      v12 = IsMatchingNode(a1, a2, &v16, (uint64_t)v11);
      if (v12)
        break;
      v11 = (_QWORD *)*v11;
    }
    while (v11);
    if (v12)
      return 1;
  }
  if ((mosyntkbaccphr_GetNodeMatchOp(v10, a3) & 4) != 0)
  {
    v13 = a4[9];
    if (v13)
    {
      if (IsLeftMatchingTarget(a1, a2, a3, v13, a5))
        return 1;
    }
  }
  v15 = a4[7];
  return v15 && IsLeftMatchingTarget(a1, a2, a3, v15, a5) != 0;
}

uint64_t mosyntsentpho_TreatSentPho(uint64_t a1, int a2, uint64_t a3, int *a4, int *a5, int *a6, uint64_t *a7, uint64_t **a8)
{
  uint64_t result;
  _DWORD *v17;
  _DWORD *v18;
  uint64_t *v19;
  uint64_t *v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v18, 0x10u);
  if ((result & 0x80000000) == 0)
  {
    v17 = v18;
    *v18 = a2;
    *((_QWORD *)v17 + 1) = a3;
    result = ApplyFSTSeq(a1, (uint64_t)v17, 5, a4, a7, &v20);
    if ((result & 0x80000000) == 0)
    {
      result = ApplyFSTSeq(a1, (uint64_t)v18, 6, a5, v20, &v19);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntdata_DisposePhonEleList(a1, &v20);
        if ((result & 0x80000000) == 0)
        {
          result = ApplyFSTSeq(a1, (uint64_t)v18, 7, a6, v19, a8);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntdata_DisposePhonEleList(a1, &v19);
            if ((result & 0x80000000) == 0)
            {
              if (v18)
                return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v18);
              else
                return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ApplyFSTSeq(uint64_t a1, uint64_t a2, int a3, int *a4, uint64_t *a5, uint64_t **a6)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;

  v15 = a5;
  *a6 = a5;
  result = mosyntdata_CopyPhonList(a1, a6);
  if ((result & 0x80000000) == 0)
  {
    v13 = 0;
    v14 = 0;
    result = mosynttrans_InitTransDesc(a1, *(_DWORD *)a2, *(_QWORD *)(a2 + 8), &v13);
    if ((result & 0x80000000) == 0)
    {
      if (*a4 < 1)
      {
        return mosynttrans_FinishTransDesc(a1, &v13);
      }
      else
      {
        v12 = 0;
        while (1)
        {
          v15 = *a6;
          result = mosynttrans_TransducePhonList(a1, v13, a3, *(_QWORD *)&a4[2 * v12 + 2], v12, v15, 0, 0, a6, &v14);
          if ((result & 0x80000000) != 0)
            break;
          result = mosyntdata_DisposePhonEleList(a1, &v15);
          if ((result & 0x80000000) != 0)
            break;
          if (++v12 >= *a4)
            return mosynttrans_FinishTransDesc(a1, &v13);
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbwgram_GetFirstEpsTrans(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _BYTE *a5, int *a6)
{
  uint64_t result;
  int v8;

  v8 = 0;
  result = wgram_GetFirstEpsTrans(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t mosyntkbwgram_GetNextEpsTrans(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, _BYTE *a5, int *a6)
{
  uint64_t result;
  int v8;

  v8 = 0;
  result = wgram_GetNextEpsTrans(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t kbsymtab_LoadData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t *a5, int a6)
{
  uint64_t inited;
  uint64_t v13;
  uint64_t v14;
  uint64_t Lex;
  _QWORD *v16;
  uint64_t i;
  uint64_t v18;
  uint64_t j;
  uint64_t v20;
  char *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  _QWORD *v48;
  uint64_t *v49;
  _QWORD *v50;
  uint64_t *v51;
  _QWORD *v52;
  uint64_t *v53;
  _QWORD *v54;
  uint64_t *v55;
  _QWORD *v56;
  uint64_t *v57;
  uint64_t v59;
  __int128 __s;
  uint64_t (*v61)(const char *, const char *);
  uint64_t (*v62)(const char *, uint64_t, char **);
  _QWORD *(*v63)(_QWORD *, _QWORD *);
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v59 = 0;
  inited = InitRsrcFunction(a1, a2, &v59);
  v13 = inited;
  if (!a5)
    return v13;
  if ((inited & 0x80000000) != 0)
    return v13;
  v13 = 2371887114;
  v14 = heap_Calloc(*(_QWORD **)(v59 + 8), 1, 16624);
  *a5 = v14;
  if (!v14)
    return v13;
  Lex = kblex_loadLex(a1, a2, a3, a4, 3, (_QWORD *)(v14 + 8584));
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  Lex = kblex_loadLex(a1, a2, a3, a4, 4, (_QWORD *)(*a5 + 8592));
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  Lex = kblex_loadLex(a1, a2, a3, a4, 5, (_QWORD *)(*a5 + 8600));
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  Lex = kblex_loadLex(a1, a2, a3, a4, 6, (_QWORD *)(*a5 + 8608));
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  v13 = kblex_loadLex(a1, a2, a3, a4, 7, (_QWORD *)(*a5 + 8616));
  if ((v13 & 0x80000000) != 0)
  {
LABEL_32:
    freeTabsAsLex(*a5, a1, a2, a3, a4);
    heap_Free(*(_QWORD **)(v59 + 8), *a5);
    *a5 = 0;
    return v13;
  }
  if (!*a5)
    return v13;
  *(_QWORD *)(*a5 + 120) = heap_Calloc(*(_QWORD **)(v59 + 8), 1, 1000);
  *(_QWORD *)(*a5 + 128) = LhpuCreate(*(_QWORD *)(v59 + 8));
  v16 = (_QWORD *)*a5;
  if (!*(_QWORD *)(*a5 + 120) || !v16[16])
    v13 = 2371887114;
  *v16 = v59;
  *(_DWORD *)(*a5 + 8) = 1;
  for (i = 1078; i != 2078; ++i)
    *(_QWORD *)(*a5 + 8 * i) = 0;
  v18 = *a5;
  *(_DWORD *)(*a5 + 8536) = 0;
  if (a6)
  {
    for (j = 0; j != 100; ++j)
    {
      LOWORD(__s) = j;
      *(_DWORD *)(v18 + 4 * j + 136) = kbsymtab_KnownGraphId(v18, (unsigned __int8 *)&__s);
    }
    v20 = 0;
    v21 = (char *)(v18 + 536);
    do
    {
      kbsymtab_GraphSymString(v18, v20, (char *)&__s, 0x64uLL);
      if (strlen((const char *)&__s) > 7)
        *v21 = 0;
      else
        strcpy(v21, (const char *)&__s);
      ++v20;
      v21 += 8;
    }
    while (v20 != 1000);
    *(_DWORD *)(v18 + 8536) = 1;
    v18 = *a5;
  }
  *(_DWORD *)(v18 + 12) = kbsymtab_KnownGraphId(v18, "#");
  v22 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{*}");
  *(_DWORD *)(v18 + 16) = v22 & ~(v22 >> 31);
  v23 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"&");
  *(_DWORD *)(v18 + 20) = v23 & ~(v23 >> 31);
  v24 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"#");
  *(_DWORD *)(v18 + 24) = v24 & ~(v24 >> 31);
  v25 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC0}");
  *(_DWORD *)(v18 + 28) = v25 & ~(v25 >> 31);
  v26 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC1}");
  *(_DWORD *)(v18 + 32) = v26 & ~(v26 >> 31);
  v27 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC2}");
  *(_DWORD *)(v18 + 36) = v27 & ~(v27 >> 31);
  v28 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC3}");
  *(_DWORD *)(v18 + 40) = v28 & ~(v28 >> 31);
  v29 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC4}");
  *(_DWORD *)(v18 + 44) = v29 & ~(v29 >> 31);
  v30 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)".");
  *(_DWORD *)(v18 + 48) = v30 & ~(v30 >> 31);
  v31 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"'");
  *(_DWORD *)(v18 + 52) = v31 & ~(v31 >> 31);
  v32 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"'2");
  *(_DWORD *)(v18 + 56) = v32 & ~(v32 >> 31);
  v33 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"_");
  *(_DWORD *)(v18 + 60) = v33 & ~(v33 >> 31);
  v34 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"_");
  *(_DWORD *)(v18 + 64) = v34 & ~(v34 >> 31);
  v35 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"*");
  *(_DWORD *)(v18 + 68) = v35 & ~(v35 >> 31);
  v36 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#PB-S}");
  *(_DWORD *)(v18 + 72) = v36 & ~(v36 >> 31);
  v37 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"+");
  *(_DWORD *)(v18 + 76) = v37 & ~(v37 >> 31);
  v38 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#PB-W}");
  *(_DWORD *)(v18 + 80) = v38 & ~(v38 >> 31);
  v39 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#BEG}");
  *(_DWORD *)(v18 + 84) = v39 & ~(v39 >> 31);
  v40 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#END}");
  *(_DWORD *)(v18 + 88) = v40 & ~(v40 >> 31);
  v41 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)".");
  *(_DWORD *)(v18 + 92) = v41 & ~(v41 >> 31);
  v42 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#WB}");
  *(_DWORD *)(v18 + 96) = v42 & ~(v42 >> 31);
  v43 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"\"");
  *(_DWORD *)(v18 + 100) = v43 & ~(v43 >> 31);
  v44 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"*");
  *(_DWORD *)(v18 + 104) = v44 & ~(v44 >> 31);
  v45 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"**");
  *(_DWORD *)(v18 + 108) = v45 & ~(v45 >> 31);
  v46 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"%");
  *(_DWORD *)(v18 + 112) = v46 & ~(v46 >> 31);
  v47 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"%%");
  *(_DWORD *)(v18 + 116) = v47 & ~(v47 >> 31);
  if ((v13 & 0x80000000) != 0)
    goto LABEL_32;
  v48 = *(_QWORD **)(v59 + 8);
  v49 = (uint64_t *)(*a5 + 8544);
  *(_QWORD *)&__s = ssftmap_ElemCopyString;
  *((_QWORD *)&__s + 1) = ssftmap_ElemFreeString;
  v61 = ssftmap_ElemCompareKeysString;
  v62 = ssftmap_ElemCopyString;
  v63 = ssftmap_ElemFreeString;
  Lex = ssftmap_ObjOpen(v48, 0, &__s, v49);
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  v50 = *(_QWORD **)(v59 + 8);
  v51 = (uint64_t *)(*a5 + 8552);
  *(_QWORD *)&__s = ssftmap_ElemCopyString;
  *((_QWORD *)&__s + 1) = ssftmap_ElemFreeString;
  v61 = ssftmap_ElemCompareKeysString;
  v62 = ssftmap_ElemCopyString;
  v63 = ssftmap_ElemFreeString;
  Lex = ssftmap_ObjOpen(v50, 0, &__s, v51);
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  v52 = *(_QWORD **)(v59 + 8);
  v53 = (uint64_t *)(*a5 + 8560);
  *(_QWORD *)&__s = ssftmap_ElemCopyString;
  *((_QWORD *)&__s + 1) = ssftmap_ElemFreeString;
  v61 = ssftmap_ElemCompareKeysString;
  v62 = ssftmap_ElemCopyString;
  v63 = ssftmap_ElemFreeString;
  Lex = ssftmap_ObjOpen(v52, 0, &__s, v53);
  if ((Lex & 0x80000000) != 0)
    goto LABEL_31;
  v54 = *(_QWORD **)(v59 + 8);
  v55 = (uint64_t *)(*a5 + 8568);
  *(_QWORD *)&__s = ssftmap_ElemCopyString;
  *((_QWORD *)&__s + 1) = ssftmap_ElemFreeString;
  v61 = ssftmap_ElemCompareKeysString;
  v62 = ssftmap_ElemCopyString;
  v63 = ssftmap_ElemFreeString;
  Lex = ssftmap_ObjOpen(v54, 0, &__s, v55);
  if ((Lex & 0x80000000) != 0)
  {
LABEL_31:
    v13 = Lex;
    goto LABEL_32;
  }
  v56 = *(_QWORD **)(v59 + 8);
  v57 = (uint64_t *)(*a5 + 8576);
  *(_QWORD *)&__s = ssftmap_ElemCopyString;
  *((_QWORD *)&__s + 1) = ssftmap_ElemFreeString;
  v61 = ssftmap_ElemCompareKeysString;
  v62 = ssftmap_ElemCopyString;
  v63 = ssftmap_ElemFreeString;
  v13 = ssftmap_ObjOpen(v56, 0, &__s, v57);
  if ((v13 & 0x80000000) != 0)
    goto LABEL_32;
  return v13;
}

uint64_t freeTabsAsLex(uint64_t result, _WORD *a2, int a3, _WORD *a4, int a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = (_QWORD *)result;
  v10 = *(_QWORD *)(result + 8584);
  if (v10)
    result = kblex_FinishLex(a2, a3, a4, a5, v10);
  v11 = v9[1074];
  if (v11)
    result = kblex_FinishLex(a2, a3, a4, a5, v11);
  v12 = v9[1075];
  if (v12)
    result = kblex_FinishLex(a2, a3, a4, a5, v12);
  v13 = v9[1076];
  if (v13)
    result = kblex_FinishLex(a2, a3, a4, a5, v13);
  v14 = v9[1077];
  if (v14)
    return kblex_FinishLex(a2, a3, a4, a5, v14);
  return result;
}

uint64_t kbsymtab_UnloadData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t *a5)
{
  uint64_t v6;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;

  v6 = 2371887111;
  if (a5)
  {
    v11 = *a5;
    if (*a5)
    {
      v12 = *(_QWORD **)(*(_QWORD *)v11 + 8);
      freeTabsAsLex(v11, a1, a2, a3, a4);
      v13 = *a5;
      if (*(_QWORD *)(*a5 + 128))
      {
        LhpuRemove(v12, (uint64_t *)(*a5 + 128));
        v13 = *a5;
      }
      v14 = *(_QWORD *)(v13 + 120);
      if (v14)
      {
        heap_Free(v12, v14);
        v13 = *a5;
      }
      ssftmap_ObjClose(*(_QWORD *)(v13 + 8544));
      ssftmap_ObjClose(*(_QWORD *)(*a5 + 8552));
      ssftmap_ObjClose(*(_QWORD *)(*a5 + 8560));
      ssftmap_ObjClose(*(_QWORD *)(*a5 + 8568));
      ssftmap_ObjClose(*(_QWORD *)(*a5 + 8576));
      for (i = 1078; i != 2078; ++i)
      {
        v16 = *(_QWORD *)(*a5 + 8 * i);
        if (v16)
          heap_Free(v12, v16);
      }
      heap_Free(v12, *a5);
      return 0;
    }
  }
  return v6;
}

uint64_t kbsymtab_KnownGraphId(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2;
  int v3;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 8536))
    {
      v2 = *a2;
      if (v2 <= 0x63 && !a2[1])
        return *(unsigned int *)(a1 + 4 * v2 + 136);
    }
  }
  v3 = dictSingleLookupInt((uint64_t *)a1, 3, (uint64_t)a2);
  return v3 & ~(v3 >> 31);
}

uint64_t kbsymtab_KnownPhonId(uint64_t *a1, uint64_t a2)
{
  int v2;

  v2 = dictSingleLookupInt(a1, 0, a2);
  return v2 & ~(v2 >> 31);
}

uint64_t kbsymtab_KnownAtomId(uint64_t *a1, uint64_t a2)
{
  int v2;

  v2 = dictSingleLookupInt(a1, 2, a2);
  return v2 & ~(v2 >> 31);
}

uint64_t kbsymtab_KnownConsId(uint64_t *a1, uint64_t a2)
{
  int v2;

  v2 = dictSingleLookupInt(a1, 1, a2);
  return v2 & ~(v2 >> 31);
}

char *kbsymtab_GraphSymString(uint64_t a1, signed int a2, char *__dst, unint64_t a4)
{
  char *result;

  *__dst = 0;
  if (!a1)
    return (char *)dictLookupSymStr((uint64_t *)a1, 3, a2, __dst, a4);
  if (a4 < 8)
    return (char *)dictLookupSymStr((uint64_t *)a1, 3, a2, __dst, a4);
  if (a2 > 999)
    return (char *)dictLookupSymStr((uint64_t *)a1, 3, a2, __dst, a4);
  if (!*(_DWORD *)(a1 + 8536))
    return (char *)dictLookupSymStr((uint64_t *)a1, 3, a2, __dst, a4);
  result = strcpy(__dst, (const char *)(a1 + 8 * a2 + 536));
  if (!*__dst)
    return (char *)dictLookupSymStr((uint64_t *)a1, 3, a2, __dst, a4);
  return result;
}

uint64_t dictLookupSymStr(uint64_t *a1, int a2, unsigned int a3, char *a4, uint64_t a5)
{
  uint64_t result;
  size_t v10;
  __int16 v11;
  const char **v12;
  char v13;
  char v14[15];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 58;
  result = (uint64_t)LH_itoa(a3, v14, 0xAu);
  if (a4 && a5)
  {
    v12 = 0;
    *a4 = 0;
    v11 = -1;
    result = dictLookup(a1, a2, (uint64_t)&v13, &v12, &v11);
    if (v11)
    {
      v10 = a5 - 1;
      result = (uint64_t)strncpy(a4, *v12, v10);
      a4[v10] = 0;
    }
  }
  return result;
}

uint64_t kbsymtab_PhonSymString(uint64_t *a1, unsigned int a2, char *a3, uint64_t a4)
{
  return dictLookupSymStr(a1, 0, a2, a3, a4);
}

uint64_t kbsymtab_AtomSymString(uint64_t *a1, unsigned int a2, char *a3, uint64_t a4)
{
  return dictLookupSymStr(a1, 2, a2, a3, a4);
}

uint64_t kbsymtab_ConsSymString(uint64_t *a1, unsigned int a2, char *a3, uint64_t a4)
{
  return dictLookupSymStr(a1, 1, a2, a3, a4);
}

uint64_t kbsymtab_PhonStartId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t kbsymtab_PhonTermId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t kbsymtab_SyllSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t kbsymtab_PrimAccId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t kbsymtab_SecAccId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t kbsymtab_AccId(uint64_t a1, int a2)
{
  unsigned int v2;

  v2 = a2 & ~(a2 >> 31);
  if (v2 >= 4)
    v2 = 4;
  return *(unsigned int *)(a1 + 4 * v2 + 28);
}

uint64_t kbsymtab_WordSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t kbsymtab_PhrSepPauseId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t kbsymtab_PhrSepNoPauseId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t kbsymtab_WordSep2Id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t kbsymtab_PhrSepPause2Id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t kbsymtab_PhrSepNoPause2Id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t kbsymtab_IPABeginId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t kbsymtab_IPAEndId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t kbsymtab_IPASyllSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 92);
}

uint64_t kbsymtab_IPAWordSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t kbsymtab_IPAPrimAccId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t kbsymtab_Star2ConsId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 108);
}

uint64_t kbsymtab_WildConsId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t kbsymtab_Wild2ConsId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

BOOL kbsymtab_PropTabAvailable(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8616) != 0;
}

uint64_t kbsymtab_IntPropValue(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  _BYTE v5[101];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  buildSymFeatPropKey(a1, a2, 0, a3, v5);
  return dictSingleLookupInt(a1, 4, (uint64_t)v5);
}

char *buildSymFeatPropKey(uint64_t *a1, unsigned int a2, __int16 *a3, unsigned int a4, _BYTE *a5)
{
  const char *v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  const char *v18;

  *a5 = 58;
  v8 = a5 + 1;
  LH_itoa(a2, a5 + 1, 0xAu);
  v9 = strlen(v8);
  v10 = (char *)&v8[v9];
  v11 = 100 - v9;
  if (a3)
  {
    *v10 = 40;
    v12 = v10 + 1;
    if (*a3 >= 1)
    {
      v13 = 0;
      v14 = 99 - v9;
      do
      {
        if (v13 && v14 >= 3)
        {
          *v12++ = 44;
          --v14;
        }
        v15 = a3[v13 + 1];
        if (v15 < 0)
        {
          dictLookupSymStr(a1, 2, -v15, v12, v14 - 2);
          v16 = strlen(v12);
          v12 += (int)v16;
          v14 -= v16;
        }
        ++v13;
      }
      while (v13 < *a3);
    }
    *(_WORD *)v12 = 41;
    v17 = strlen(v10);
    v10 += (int)v17;
    v11 -= v17;
  }
  *v10 = 58;
  if (a4 > 9)
    v18 = &byte_1DEBD87CE;
  else
    v18 = off_1EA93ECA0[a4];
  return strncpy(v10 + 1, v18, v11 - 1);
}

uint64_t dictSingleLookupInt(uint64_t *a1, int a2, uint64_t a3)
{
  __int16 v4;
  const char **v5;

  v5 = 0;
  v4 = -1;
  dictLookup(a1, a2, a3, &v5, &v4);
  if (v4)
    return atoi(*v5);
  else
    return 0xFFFFFFFFLL;
}

BOOL kbsymtab_HasIntPropValue(uint64_t *a1, unsigned int a2, unsigned int a3, int a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unsigned __int16 v12;
  uint64_t v13;
  _BYTE v14[101];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  buildSymFeatPropKey(a1, a2, 0, a3, v14);
  v13 = 0;
  v12 = 0;
  dictLookup(a1, 4, (uint64_t)v14, &v13, (__int16 *)&v12);
  v6 = v12;
  if (!v12)
    return 0;
  v7 = 0;
  v8 = v13;
  do
    v9 = atoi(*(const char **)(v8 + 8 * v7++));
  while (v9 != a4 && v7 < v6);
  return v9 == a4;
}

uint64_t **kbsymtab_GetFirstAccPatVal(uint64_t **result, int a2, int a3, uint64_t a4, _QWORD *a5)
{
  if (result)
  {
    if (a4)
    {
      *(_QWORD *)a4 = result;
      *(_DWORD *)(a4 + 8) = a2;
      *(_DWORD *)(a4 + 24) = a3;
      *(_DWORD *)(a4 + 28) = -1;
      return kbsymtab_GetNextAccPatVal((uint64_t **)a4, a5);
    }
  }
  return result;
}

uint64_t **kbsymtab_GetNextAccPatVal(uint64_t **result, _QWORD *a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned __int16 v7;
  char *v8;
  uint64_t v9;
  _BYTE v10[101];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (result && a2)
  {
    v3 = result;
    v9 = 0;
    *a2 = 0;
    buildSymFeatPropKey(*result, *((_DWORD *)v3 + 2), 0, *((_DWORD *)v3 + 6), v10);
    v4 = *v3;
    v7 = 0;
    result = (uint64_t **)dictLookup(v4, 4, (uint64_t)v10, &v9, (__int16 *)&v7);
    v5 = *((int *)v3 + 7) + 1;
    if ((int)v5 < v7)
    {
      v8 = (char *)(*v3)[15];
      v6 = v8;
      *((_DWORD *)v3 + 7) = v5;
      strncpy(v6, *(const char **)(v9 + 8 * v5), 0x3E8uLL);
      return (uint64_t **)stringToPatternTree(*v3, &v8, (uint64_t)a2);
    }
  }
  return result;
}

uint64_t stringToPatternTree(uint64_t *a1, char **a2, uint64_t a3)
{
  uint64_t result;
  char *v7;
  int v8;
  __int16 v9;
  char v10;
  unsigned int v11;
  __int16 v12;
  char *v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  int v17;
  __int16 *v18;
  char *v19;
  unint64_t i;
  unsigned int v21;
  int v22;
  BOOL v23;
  char *v24;
  _QWORD *v25;
  char *v26;
  int v27;
  _QWORD *v28;
  _QWORD *v29;
  __int16 v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  result = heap_Calloc(*(_QWORD **)(*a1 + 8), 1, 24);
  *(_QWORD *)a3 = result;
  if (!result)
    return result;
  *(_QWORD *)result = 0;
  *(_QWORD *)(*(_QWORD *)a3 + 8) = 0;
  *(_DWORD *)(*(_QWORD *)a3 + 16) = 0;
  v7 = *a2;
  v8 = **a2;
  if (v8 == 37)
  {
    *a2 = v7 + 1;
    if (v7[1] == 37)
    {
      *a2 = v7 + 2;
      v9 = 9509;
      goto LABEL_8;
    }
    v15 = 37;
LABEL_15:
    v30 = v15;
    goto LABEL_33;
  }
  if (v8 == 42)
  {
    *a2 = v7 + 1;
    if (v7[1] == 42)
    {
      *a2 = v7 + 2;
      v9 = 10794;
LABEL_8:
      v30 = v9;
      v31 = 0;
LABEL_33:
      result = dictSingleLookupInt(a1, 1, (uint64_t)&v30);
      *(_WORD *)(*(_QWORD *)a3 + 16) = result & ~(unsigned __int16)((int)result >> 31);
      goto LABEL_34;
    }
    v15 = 42;
    goto LABEL_15;
  }
  v10 = **a2;
  v11 = (char)v8 - 48;
  if (v11 > 9)
  {
    v16 = MEMORY[0x1E0C80978];
    if ((char)v8 < 0)
      v17 = __maskrune((char)v8, 0x100uLL);
    else
      v17 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v8 + 60) & 0x100;
    v18 = &v30;
    if (v17)
    {
      LOBYTE(v30) = v10;
      v19 = *a2 + 1;
      *a2 = v19;
      for (i = 1; ; ++i)
      {
        v21 = *v19;
        v22 = (v21 & 0x80000000) != 0 ? __maskrune(*v19, 0x500uLL) : *(_DWORD *)(v16 + 4 * v21 + 60) & 0x500;
        v23 = v22 || v21 == 95;
        if (!v23 || i > 0x62)
          break;
        v19 = *a2 + 1;
        *((_BYTE *)&v30 + i) = **a2;
        *a2 = v19;
      }
      v18 = (__int16 *)((char *)&v30 + i);
    }
    *(_BYTE *)v18 = 0;
    goto LABEL_33;
  }
  v12 = 0;
  v13 = v7 + 1;
  do
  {
    v12 = v11 + 10 * v12;
    *a2 = v13;
    v14 = *v13++;
    LOWORD(v11) = v14 - 48;
  }
  while ((v14 - 48) < 0xA);
  *(_WORD *)(*(_QWORD *)a3 + 18) = v12;
LABEL_34:
  v24 = *a2;
  if (**a2 == 40)
  {
    v29 = 0;
    *a2 = v24 + 1;
    result = stringToPatternTree(a1, a2, &v29);
    v25 = v29;
    *(_QWORD *)(*(_QWORD *)a3 + 8) = v29;
    while (1)
    {
      v26 = *a2;
      v27 = **a2;
      if (v27 != 44)
        break;
      *a2 = v26 + 1;
      result = stringToPatternTree(a1, a2, &v29);
      v28 = v29;
      *v25 = v29;
      v25 = v28;
    }
    if (v27 == 41)
      *a2 = v26 + 1;
  }
  return result;
}

_QWORD *kbsymtab_DisposeAccPat(_QWORD *result, _QWORD **a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  if (result)
  {
    if (a2)
    {
      v3 = *a2;
      if (*a2)
      {
        v4 = result;
        do
        {
          v5 = (_QWORD *)*v3;
          kbsymtab_DisposeAccPat(v4, v3 + 1);
          result = heap_Free(*(_QWORD **)(*v4 + 8), (uint64_t)v3);
          v3 = v5;
        }
        while (v5);
        *a2 = 0;
      }
    }
  }
  return result;
}

void kbsymtab_GetFeatMatchedFirstIntPropVal(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int *a6)
{
  if (a6)
    *a6 = -1;
  if (a5)
  {
    *(_QWORD *)a5 = a1;
    *(_DWORD *)(a5 + 8) = a2;
    *(_QWORD *)(a5 + 16) = a3;
    *(_DWORD *)(a5 + 24) = a4;
    *(_DWORD *)(a5 + 28) = -1;
    kbsymtab_GetFeatMatchedNextIntPropVal(a1, a5, a6);
  }
}

void kbsymtab_GetFeatMatchedNextIntPropVal(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned __int16 v9;
  uint64_t v10;
  _BYTE v11[101];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a3)
    *a3 = -1;
  if (a2)
  {
    v10 = 0;
    buildSymFeatPropKey(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), *(__int16 **)(a2 + 16), *(_DWORD *)(a2 + 24), v11);
    v5 = *(uint64_t **)a2;
    v9 = 0;
    v6 = dictLookup(v5, 4, (uint64_t)v11, &v10, (__int16 *)&v9);
    v7 = *(int *)(a2 + 28) + 1;
    if ((int)v7 >= v9)
    {
      if (*(_QWORD *)(a2 + 16))
      {
        v8 = *(_DWORD *)(a2 + 8);
        if (a3)
          *a3 = -1;
        *(_DWORD *)(a2 + 8) = v8;
        *(_QWORD *)(a2 + 16) = 0;
        *(_DWORD *)(a2 + 28) = -1;
        kbsymtab_GetFeatMatchedNextIntPropVal(v6, a2, a3);
      }
    }
    else
    {
      *(_DWORD *)(a2 + 28) = v7;
      if (a3)
        *a3 = atoi(*(const char **)(v10 + 8 * v7));
    }
  }
}

void kbsymtab_GetLhPlusPhone(uint64_t *a1, uint64_t a2, int a3, int *a4, char *a5, int a6, _BYTE *a7)
{
  uint64_t v11;
  char *v13;
  int ComplexPhoneLen;
  BOOL v15;
  int v16;

  if (a7)
  {
    *a7 = 0;
    if (a5)
    {
      if (!a1)
        goto LABEL_15;
      if (!a2)
        goto LABEL_15;
      if (!a4)
        goto LABEL_15;
      v11 = *a4;
      if ((int)v11 >= a3)
        goto LABEL_15;
      v13 = (char *)(a2 + v11);
      ComplexPhoneLen = getComplexPhoneLen(a1, (_BYTE *)(a2 + v11));
      v15 = ComplexPhoneLen;
      if (!ComplexPhoneLen)
      {
        LhplGetSymbol();
        if (v16)
        {
          v15 = a6;
        }
        else
        {
          v15 = 1;
          if (*v13 == 123)
            v15 = getComplexPhoneLen(a1, v13) == 0;
        }
      }
      if (v15 < a6)
      {
        strncpy(a5, v13, v15);
        a5[v15] = 0;
        *a4 += v15;
        *a7 = 1;
        return;
      }
      if (!*a7)
LABEL_15:
        *a5 = 0;
    }
  }
}

uint64_t getComplexPhoneLen(uint64_t *a1, _BYTE *a2)
{
  uint64_t i;
  int v3;
  char v4;
  _BYTE v7[15];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*a2 != 123)
    return 0;
  v7[0] = 123;
  for (i = 1; i != 13; ++i)
  {
    v3 = a2[i];
    if (!a2[i])
      break;
    if (v3 == 123)
      break;
    if (v3 == 125)
      break;
    v7[i] = v3;
  }
  v4 = i;
  if (a2[i] == 125)
  {
    *(_WORD *)&v7[i] = 125;
    if ((int)dictSingleLookupInt(a1, 0, (uint64_t)v7) >= 1)
      return (v4 + 1);
    else
      return 0;
  }
  else
  {
    return 0;
  }
}

uint64_t dictLookup(uint64_t *a1, int a2, uint64_t a3, _QWORD *a4, __int16 *a5)
{
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  __int16 v15;
  uint64_t result;
  unint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  char *v24;
  __int16 v25;
  BOOL v26;
  char v27;
  uint64_t v28[3];
  _QWORD v29[3];
  char __src[8];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  switch(a2)
  {
    case 0:
      v9 = a1 + 1073;
      v10 = 1068;
      goto LABEL_8;
    case 1:
      v9 = a1 + 1074;
      v10 = 1069;
      goto LABEL_8;
    case 2:
      v9 = a1 + 1075;
      v10 = 1070;
      goto LABEL_8;
    case 3:
      v9 = a1 + 1076;
      v10 = 1071;
      goto LABEL_8;
    case 4:
      v9 = a1 + 1077;
      v10 = 1072;
LABEL_8:
      v11 = *v9;
      v12 = a1[v10];
      break;
    default:
      v11 = 0;
      v12 = 0;
      break;
  }
  memset(v29, 0, sizeof(v29));
  *(_QWORD *)__src = 0;
  memset(v28, 0, sizeof(v28));
  v26 = 0;
  v13 = ssftmap_FindReadOnly(v12, a3, __src) & 0x1FFF;
  if (v13 != 7 && v13 != 20)
  {
    v23 = *(const char **)__src;
    result = strcmp(*(const char **)__src, "~");
    if ((_DWORD)result)
    {
      v24 = (char *)a1[1078];
      if (!v24)
      {
        v24 = (char *)heap_Alloc(*(_QWORD *)(*a1 + 8), 101);
        if (!v24)
          goto LABEL_11;
        v23 = *(const char **)__src;
      }
      result = (uint64_t)strncpy(v24, v23, 0x64uLL);
      *(_BYTE *)(result + 100) = 0;
      a1[1078] = result;
      v25 = 1;
      *a4 = a1 + 1078;
    }
    else
    {
      v25 = 0;
    }
    *a5 = v25;
    return result;
  }
LABEL_11:
  v14 = (unsigned __int16)*a5;
  *a5 = 0;
  kblexXX_StartLookup(v11, (uint64_t)v29);
  v15 = 0;
  v27 = 1;
  while (*(_BYTE *)(a3 + v15))
  {
    result = kblexXX_LookupChar(*(_BYTE *)(a3 + v15++), (int *)v29, &v27);
    if (!v27)
      goto LABEL_28;
  }
  kblexXX_GetFirstEntry(v29, &v26, (uint64_t)v28);
  while (v26)
  {
    if (*a5 && v14 != 0)
      break;
    kblexXX_GetEntryPhon(0, v28, __src, 100);
    v18 = (unsigned __int16)*a5;
    if (v18 <= 0x3E7)
    {
      v19 = (char *)a1[v18 + 1078];
      if (v19 || (v19 = (char *)heap_Alloc(*(_QWORD *)(*a1 + 8), 101)) != 0)
      {
        v20 = strncpy(v19, __src, 0x64uLL);
        v20[100] = 0;
        v21 = (unsigned __int16)*a5;
        a1[v21 + 1078] = (uint64_t)v20;
        *a5 = v21 + 1;
      }
    }
    kblexXX_GetNextEntry(&v26, (int *)v28);
  }
  result = kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v28);
LABEL_28:
  *a4 = a1 + 1078;
  if (*a5)
  {
    if (*a5 != 1)
      return result;
    v22 = (const char *)a1[1078];
  }
  else
  {
    v22 = "~";
  }
  return ssftmap_Insert(v12, a3, (uint64_t)v22);
}

uint64_t mosynt_PadWithChar(uint64_t a1, int a2, int __c, unsigned int a4)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v8;

  v5 = 0;
  do
    LODWORD(v6) = v5;
  while (*(unsigned __int8 *)(a1 + v5++));
  v6 = v6;
  if (a4 >= a2 - 1)
    v8 = (a2 - 1);
  else
    v8 = a4;
  if (v5 - 1 < v8)
  {
    memset((void *)(a1 + v6), __c, v8 - v5 + 1);
    v6 = v8;
  }
  *(_BYTE *)(a1 + v6) = 0;
  return 0;
}

uint64_t mosynt_RemoveAllSubstrOcc(char *a1, _BYTE *a2)
{
  char v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;

  v2 = *a1;
  if (*a1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *a2;
      if (*a2)
      {
        v6 = 0;
        while (a1[v4 + v6] == v5)
        {
          v5 = a2[++v6];
          if (!a2[v6])
            goto LABEL_10;
        }
        a1[v3++] = v2;
        v6 = 1;
      }
      else
      {
        v6 = 0;
      }
LABEL_10:
      v4 += v6;
      v2 = a1[v4];
    }
    while (v2);
  }
  else
  {
    v3 = 0;
  }
  a1[v3] = 0;
  return 0;
}

uint64_t mosynt_SubstAllSubstrOcc(char *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, int a5)
{
  char v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  if (*a2)
  {
    v5 = *a1;
    if (*a1)
    {
      v6 = 0;
      v7 = 0;
      v8 = a5 - 1;
      do
      {
        v9 = *a2;
        if (*a2)
        {
          v10 = 0;
          while (a1[v7 + v10] == v9)
          {
            v9 = a2[++v10];
            if (!a2[v10])
              goto LABEL_10;
          }
          if (v6 < v8)
            a4[v6++] = v5;
          v10 = 1;
        }
        else
        {
          v10 = 0;
LABEL_10:
          LOBYTE(v11) = *a3;
          if (*a3)
          {
            v12 = 1;
            do
            {
              if (v6 < v8)
                a4[v6++] = v11;
              v11 = a3[v12++];
            }
            while (v11);
          }
        }
        v7 += v10;
        v5 = a1[v7];
      }
      while (v5);
    }
    else
    {
      v6 = 0;
    }
    a4 += v6;
  }
  *a4 = 0;
  return 0;
}

uint64_t mosynt_GetTermSubstr(uint64_t a1, _DWORD *a2, unsigned __int8 a3, _DWORD *a4, _BYTE *a5, int a6)
{
  uint64_t v6;
  int v7;
  unsigned int i;
  uint64_t v11;

  if (*(_BYTE *)(a1 + *a2))
  {
    *a4 = 1;
    v6 = *a2;
    v7 = *(unsigned __int8 *)(a1 + v6);
    for (i = 0; v7 != a3 && v7 != 0; v7 = *(unsigned __int8 *)(a1 + v6))
    {
      if (i < a6 - 1)
      {
        a5[i++] = v7;
        LODWORD(v6) = *a2;
      }
      LODWORD(v6) = v6 + 1;
      *a2 = v6;
    }
    a5[i] = 0;
    v11 = *a2;
    if (*(_BYTE *)(a1 + v11))
      *a2 = v11 + 1;
  }
  else
  {
    *a4 = 0;
    *a5 = 0;
  }
  return 0;
}

uint64_t mosynt_RemoveInitSubstr(const char *a1, char *__s)
{
  size_t v4;
  int v5;
  char v6;
  uint64_t v7;

  v4 = strlen(__s);
  if (!strncmp(a1, __s, v4))
  {
    v5 = strlen(__s);
    v6 = a1[(unsigned __int16)v5];
    if (v6)
    {
      LOWORD(v7) = 0;
      do
      {
        a1[(unsigned __int16)v7] = v6;
        ++v5;
        LOWORD(v7) = v7 + 1;
        v6 = a1[(unsigned __int16)v5];
      }
      while (v6);
      v7 = (unsigned __int16)v7;
    }
    else
    {
      v7 = 0;
    }
    a1[v7] = 0;
  }
  return 0;
}

uint64_t mosynt_App(uint64_t a1, int a2, unsigned int *a3, _BYTE *a4, _DWORD *a5)
{
  int v5;
  unsigned int v6;
  unsigned int v7;

  *a5 = 1;
  LOBYTE(v5) = *a4;
  v6 = *a3;
  if (*a4)
  {
    v7 = 1;
    while (v6 < a2 - 1)
    {
      *(_BYTE *)(a1 + v6) = v5;
      v6 = *a3 + 1;
      *a3 = v6;
      v5 = a4[v7++];
      if (!v5)
        goto LABEL_7;
    }
    *a5 = 0;
    v6 = *a3;
  }
LABEL_7:
  *(_BYTE *)(a1 + v6) = 0;
  return 0;
}

uint64_t mosynt_NormalizeSpaceFields(_BYTE *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v5;
  unsigned int v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;

  v14 = 0;
  v5 = *a1;
  if (*a1)
  {
    v13 = 0;
    v7 = a3 - 1;
    while (1)
    {
      result = mosynt_GetSpace(0, (uint64_t)a1, (unsigned int *)&v14 + 1, &v13);
      if ((result & 0x80000000) != 0)
        break;
      v9 = (unsigned __int16)v13;
      LODWORD(v10) = v14;
      if ((_WORD)v13)
      {
        do
        {
          v11 = v10;
          if (v10 < v7)
          {
            v10 = (v10 + 1);
            *(_BYTE *)(a2 + v11) = 32;
            v11 = v10;
          }
          *(_BYTE *)(a2 + v11) = 0;
          --v9;
        }
        while (v9);
      }
      LODWORD(v14) = v10;
      v12 = HIDWORD(v14);
      result = mosynt_GetField((uint64_t)a1, (unsigned int *)&v14 + 1, &v13);
      if ((result & 0x80000000) != 0)
        break;
      result = mosynt_TransferStretchedStringSection((uint64_t)a1, &v12, v13, a2, a3, (unsigned int *)&v14, v13, 32);
      if ((result & 0x80000000) != 0)
        break;
      if (!a1[HIDWORD(v14)])
      {
        v5 = v14;
        goto LABEL_13;
      }
    }
  }
  else
  {
    result = 0;
LABEL_13:
    if (v5 >= a3)
      v5 = a3 - 1;
    *(_BYTE *)(a2 + v5) = 0;
  }
  return result;
}

uint64_t mosynt_GetSpace(int a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t result;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  char __s[5];

  *a4 = 0;
  result = utf8_getUTF8Char(a2, *a3, __s);
  if ((result & 0x80000000) != 0)
    return result;
  while (1)
  {
LABEL_2:
    v9 = __s[0] - 32;
    v10 = v9 > 0x3F;
    v11 = (1 << v9) & 0x8000000000002001;
    if (!v10 && v11 != 0)
      goto LABEL_6;
    if (a1 && (__s[0] == 47 || __s[0] == 35))
    {
      v14 = *a3;
      if (*a3 && *(_BYTE *)(a2 + v14 - 1) != 32 || (*(unsigned __int8 *)(a2 + v14 + 1) | 0x20) != 0x20)
        return result;
LABEL_6:
      ++*a4;
      v13 = *a3 + strlen(__s);
      *a3 = v13;
      result = utf8_getUTF8Char(a2, v13, __s);
      goto LABEL_7;
    }
    if (*(_DWORD *)__s == 8689634)
      break;
    if (*(_DWORD *)__s == 12228322 || *(_DWORD *)__s == 9799394)
      goto LABEL_6;
    if (*(_DWORD *)__s != 11704034)
      return result;
    while (1)
    {
      v15 = *(_DWORD *)__s;
      ++*a4;
      v16 = *a3 + strlen(__s);
      *a3 = v16;
      result = utf8_getUTF8Char(a2, v16, __s);
      if (v15 == 12359394)
        break;
      if ((result & 0x80000000) != 0)
        return result;
      if (!__s[0])
        goto LABEL_2;
    }
LABEL_7:
    if ((result & 0x80000000) != 0)
      return result;
  }
  v17 = 0;
  while (1)
  {
    ++*a4;
    v18 = *a3 + strlen(__s);
    *a3 = v18;
    result = utf8_getUTF8Char(a2, v18, __s);
    if ((result & 0x80000000) != 0)
      return result;
    v10 = v17++ > 1;
    if (v10)
      goto LABEL_2;
  }
}

uint64_t mosynt_GetField(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t result;
  unsigned int v7;
  char __s[5];

  *a3 = 0;
  for (result = utf8_getUTF8Char(a1, *a2, __s); (result & 0x80000000) == 0; result = utf8_getUTF8Char(a1, v7, __s))
  {
    if (!__s[0])
      break;
    if (__s[0] == 32)
      break;
    if (__s[0] == 95)
      break;
    if (*(_DWORD *)__s == 8689634)
      break;
    if (*(_DWORD *)__s == 12228322)
      break;
    if (*(_DWORD *)__s == 9799394)
      break;
    if (*(_DWORD *)__s == 11704034)
      break;
    ++*a3;
    v7 = *a2 + strlen(__s);
    *a2 = v7;
  }
  return result;
}

uint64_t mosynt_TransferStretchedStringSection(uint64_t a1, unsigned int *a2, unsigned int a3, uint64_t a4, int a5, unsigned int *a6, unsigned int a7, int a8)
{
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t UTF8Char;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v25;
  int v26;
  char __s[6];

  __s[0] = 0;
  if (a3)
  {
    v25 = a8;
    v26 = a5;
    v13 = 0;
    v14 = 0;
    v15 = a5 - 1;
    while (1)
    {
      UTF8Char = utf8_getUTF8Char(a1, *a2, __s);
      if ((UTF8Char & 0x80000000) != 0)
        break;
      *a2 += strlen(__s);
      if (v13 < a7)
      {
        LOBYTE(v17) = __s[0];
        v18 = *a6;
        if (__s[0])
        {
          v19 = 1;
          do
          {
            if (v18 >= v15)
              break;
            *(_BYTE *)(a4 + v18) = v17;
            v18 = *a6 + 1;
            *a6 = v18;
            v17 = __s[v19++];
          }
          while (v17);
        }
        UTF8Char = 0;
        *(_BYTE *)(a4 + v18) = 0;
      }
      v13 = (unsigned __int16)++v14;
      if ((unsigned __int16)v14 >= a3)
      {
        LOBYTE(a8) = v25;
        a5 = v26;
        if (v25)
          goto LABEL_14;
        goto LABEL_16;
      }
    }
  }
  else
  {
    v14 = 0;
    UTF8Char = 0;
    if (a8)
    {
LABEL_14:
      __s[0] = a8;
      __s[1] = 0;
    }
    else
    {
      strcpy(__s, " ");
    }
LABEL_16:
    if (a7 > (unsigned __int16)v14)
    {
      v20 = __s[0];
      do
      {
        v21 = *a6;
        if (v20)
        {
          v22 = 1;
          LOBYTE(v23) = v20;
          do
          {
            if (v21 >= a5 - 1)
              break;
            *(_BYTE *)(a4 + v21) = v23;
            v21 = *a6 + 1;
            *a6 = v21;
            v23 = __s[v22++];
          }
          while (v23);
        }
        *(_BYTE *)(a4 + v21) = 0;
        ++v14;
      }
      while (a7 > (unsigned __int16)v14);
      UTF8Char = 0;
    }
    *(_BYTE *)(a4 + *a6) = 0;
  }
  return UTF8Char;
}

uint64_t mosynt_ReplaceNonSpaceFields(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t result;
  uint64_t v13;
  unsigned int v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;

  result = 0;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  while (*(_BYTE *)(a1 + HIDWORD(v25)) || *(_BYTE *)(a2 + v25))
  {
    v22 = HIDWORD(v25);
    result = mosynt_GetSpace(1, a1, (unsigned int *)&v25 + 1, &v24);
    if ((result & 0x80000000) == 0)
    {
      result = mosynt_GetSpace(1, a2, (unsigned int *)&v25, &v23);
      if ((result & 0x80000000) == 0)
      {
        result = mosynt_TransferStretchedStringSection(a1, &v22, v24, a3, a4, (unsigned int *)&v24 + 1, v24, 32);
        if ((result & 0x80000000) == 0)
        {
          v22 = HIDWORD(v25);
          result = mosynt_GetField(a1, (unsigned int *)&v25 + 1, &v24);
          if ((result & 0x80000000) == 0)
          {
            v13 = v25;
            v21 = v25;
            result = mosynt_GetField(a2, (unsigned int *)&v25, &v23);
            if ((result & 0x80000000) == 0)
            {
              if (a6 && *(_BYTE *)(a2 + v13) == 123)
              {
                v14 = v24;
                v15 = &v22;
                v16 = a1;
                v17 = a3;
                v18 = a4;
                v19 = v24;
              }
              else
              {
                v14 = v23;
                v19 = v23 <= v24 ? v24 : v23;
                v15 = (unsigned int *)&v21;
                v16 = a2;
                v17 = a3;
                v18 = a4;
              }
              result = mosynt_TransferStretchedStringSection(v16, v15, v14, v17, v18, (unsigned int *)&v24 + 1, v19, a5);
              if ((result & 0x80000000) == 0)
                continue;
            }
          }
        }
      }
    }
    return result;
  }
  v20 = HIDWORD(v24);
  if (HIDWORD(v24) >= a4)
    v20 = a4 - 1;
  *(_BYTE *)(a3 + v20) = 0;
  return result;
}

uint64_t mosynt_AlignFieldsWithRef(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;

  result = 0;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  while (*(_BYTE *)(a1 + HIDWORD(v15)) || *(_BYTE *)(a2 + v14))
  {
    result = mosynt_GetSpace(1, a1, (unsigned int *)&v15 + 1, &v15);
    if ((result & 0x80000000) == 0)
    {
      v12 = v14;
      result = mosynt_GetSpace(1, a2, (unsigned int *)&v14, (_DWORD *)&v14 + 1);
      if ((result & 0x80000000) == 0)
      {
        result = mosynt_TransferStretchedStringSection(a2, &v12, HIDWORD(v14), a3, a4, &v13, v15, 32);
        if ((result & 0x80000000) == 0)
        {
          result = mosynt_GetField(a1, (unsigned int *)&v15 + 1, &v15);
          if ((result & 0x80000000) == 0)
          {
            v12 = v14;
            result = mosynt_GetField(a2, (unsigned int *)&v14, (_DWORD *)&v14 + 1);
            if ((result & 0x80000000) == 0)
            {
              result = mosynt_TransferStretchedStringSection(a2, &v12, HIDWORD(v14), a3, a4, &v13, v15, a5);
              if ((result & 0x80000000) == 0)
                continue;
            }
          }
        }
      }
    }
    return result;
  }
  v11 = v13;
  if (v13 >= a4)
    v11 = a4 - 1;
  *(_BYTE *)(a3 + v11) = 0;
  return result;
}

uint64_t mosynt_TraceString(uint64_t a1, char *__s, unsigned int a3)
{
  unsigned int v5;
  int v7;

  if (a1)
  {
    v5 = *(_DWORD *)(a1 + 1024);
    if (v5)
    {
      v5 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    v5 = 0;
  }
  if (v5 < a3)
    return 0;
  v7 = strlen(__s);
  return mosyntbase_WString(a1, (unsigned __int8 *)__s, v7);
}

uint64_t mosynt_TraceInt(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;

  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 1024);
    if (v3)
    {
      v3 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    v3 = 0;
  }
  if (v3 >= a3)
    return mosyntbase_WInt(a1, a2, 0);
  else
    return 0;
}

uint64_t mosynt_NumPOSListToPOSList(uint64_t a1, uint64_t *a2, _BYTE *a3, uint64_t a4, int a5)
{
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t result;
  uint64_t v14;
  int v15;
  int v16;

  v16 = 0;
  if (*a3)
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      while (1)
      {
        v12 = a3[v10];
        if (!a3[v10] || v12 == 92)
          break;
        v11 = (char)v12 + 10 * v11 - 48;
        ++v10;
      }
      result = mosyntkbsymtab_AppDecomprConsToString(a1, a2, v11, a4, a5, &v16);
      if ((result & 0x80000000) != 0)
        break;
      v14 = v10;
      v15 = v16;
      if (v16 < a5)
      {
        *(_BYTE *)(a4 + v16) = a3[v10];
        v16 = v15 + 1;
        if (a3[v10])
          v14 = v10 + 1;
        else
          v14 = v10;
        v10 = v14;
      }
      v11 = 0;
      if (!a3[v14])
        goto LABEL_15;
    }
  }
  else
  {
    result = 0;
LABEL_15:
    *(_BYTE *)(a4 + (a5 - 1)) = 0;
  }
  return result;
}

uint64_t mosynt_ResetMosyntWS(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 5000) = 0;
    *(_BYTE *)(a2 + 15000) = 0;
    *(_BYTE *)(a2 + 20000) = 0;
    *(_OWORD *)(a2 + 25000) = 0u;
  }
  return 0;
}

uint64_t mosynt_StartWordAnalysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (!a8)
    return 0;
  *(_QWORD *)a8 = a2;
  *(_WORD *)(a8 + 8) = 1;
  *(_QWORD *)(a8 + 16) = a3;
  *(_WORD *)(a8 + 96) = 1;
  *(_QWORD *)(a8 + 104) = a4;
  *(_QWORD *)(a8 + 184) = a5;
  *(_QWORD *)(a8 + 192) = a6;
  result = fst_getFSTSeq(a7, 0, (_QWORD *)(a8 + 200), (_DWORD *)(a8 + 208));
  if ((result & 0x80000000) == 0)
  {
    result = fst_getFSTSeq(a7, 1, (_QWORD *)(a8 + 216), (_DWORD *)(a8 + 224));
    if ((result & 0x80000000) == 0)
    {
      *(_BYTE *)(a8 + 1248) = 0;
      *(_QWORD *)(a8 + 232) = 0;
      *(_QWORD *)(a8 + 240) = 0;
      *(_BYTE *)(a8 + 248) = 0;
    }
  }
  return result;
}

uint64_t mosynt_WordAnalysis()
{
  uint64_t v0;
  unsigned __int8 *v1;
  _DWORD *v2;
  int *v3;
  int *v4;
  _DWORD *v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t result;
  char v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  char *v24;
  int v25;
  char v26;
  int v27;
  uint64_t v28;
  int v29;
  _BOOL4 v30;
  uint64_t v31;
  uint64_t *v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  char v38;
  uint64_t v39;
  int *v40;
  char v41[16];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  BOOL v47;
  char __s[16];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  char v54[5000];
  uint64_t v55;

  v0 = MEMORY[0x1E0C80A78]();
  v4 = v3;
  v5 = v2;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = (uint64_t)v1;
  v14 = v13;
  v15 = v0;
  v55 = *MEMORY[0x1E0C80C00];
  if (!v0)
    goto LABEL_7;
  if (!*(_DWORD *)(v0 + 1024))
  {
    *(_WORD *)(v0 + 1028) = 0;
    *(_DWORD *)(v0 + 1024) = 1;
    *(_DWORD *)(v0 + 1032) = 20;
LABEL_7:
    v16 = 0;
    *v2 = 0;
    goto LABEL_8;
  }
  v16 = *(unsigned __int16 *)(v0 + 1028);
  *v2 = 0;
  if (!v16)
  {
LABEL_8:
    v18 = 1;
    goto LABEL_9;
  }
  result = mosyntbase_WriteMessage(v0, "\n\n[WANA] analyzing word '%s'\n", 0, v1, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
  if ((result & 0x80000000) != 0)
    return result;
  v18 = 0;
LABEL_9:
  v47 = 0;
  result = utf8_getUTF8Char(v12, 0, __s);
  if ((result & 0x80000000) != 0)
    return result;
  v40 = v4;
  if (__s[0])
  {
    v35 = v16;
    v38 = v11;
    v19 = 0;
    v20 = 0;
    while (1)
    {
      v21 = strlen(__s);
      result = utf8_ToLower(__s, 0, (uint64_t)v41);
      if ((result & 0x80000000) != 0)
        return result;
      v22 = strlen(v41);
      if (v22 && v19 + v22 + 1 <= 0x1388)
      {
        v23 = v22;
        v24 = v41;
        v25 = v19;
        do
        {
          v26 = *v24++;
          v19 = v25 + 1;
          v54[v25++] = v26;
          --v23;
        }
        while (v23);
      }
      v20 += v21;
      utf8_getUTF8Char(v12, v20, __s);
      if (!__s[0])
      {
        v54[v19] = 0;
        v11 = v38;
        v16 = v35;
        if ((v18 & 1) == 0)
          goto LABEL_21;
        goto LABEL_22;
      }
    }
  }
  v54[0] = 0;
  if ((v18 & 1) == 0)
  {
LABEL_21:
    result = mosyntbase_WriteMessage(v15, "[WANA] after lowercase conversion '%s'\n", 0, (unsigned __int8 *)v54, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    if ((result & 0x80000000) != 0)
      return result;
  }
LABEL_22:
  v53 = 0;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  *(_OWORD *)__s = 0u;
  result = hlp_CastFSTSeq(*(_QWORD *)(v14 + 200), *(_DWORD *)(v14 + 208), (int *)__s);
  if ((result & 0x80000000) == 0)
  {
    v39 = *(_QWORD *)v14;
    v27 = *(unsigned __int16 *)(v14 + 8);
    v37 = *(unsigned __int16 *)(v14 + 96);
    v28 = *(_QWORD *)(v14 + 192);
    v36 = *(_QWORD *)(v14 + 184);
    v29 = strlen(v54);
    v43 = v50;
    v44 = v51;
    v45 = v52;
    v46 = v53;
    *(_OWORD *)v41 = *(_OWORD *)__s;
    v42 = v49;
    result = mosyntwordana_ParseWord(v15, v16, v39, v27, (char *)(v14 + 16), v37, (char *)(v14 + 104), v36, (uint64_t)v41, v28, 0, (uint64_t)v54, v29, v11, v9, v7, &v47, (_QWORD *)(v14 + 232));
    v30 = v47;
    *v5 = v47;
    if ((result & 0x80000000) == 0)
    {
      *v40 = 0;
      v31 = *(_QWORD *)(v14 + 232);
      if (v30)
      {
        *v40 = -1;
        v32 = *(uint64_t **)(v31 + 32);
        if (!v32)
          goto LABEL_32;
        v33 = -1;
        do
        {
          v34 = *((_DWORD *)v32 + 3);
          if (v33 < 0 || v34 < v33)
          {
            *v40 = v34;
            v33 = v34;
          }
          v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      if (!v31)
      {
        *(_QWORD *)(v14 + 240) = 0;
        return result;
      }
LABEL_32:
      *(_QWORD *)(v14 + 240) = *(_QWORD *)(v31 + 32);
    }
  }
  return result;
}

uint64_t hlp_CastFSTSeq(uint64_t a1, int a2, int *a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  if (a2 < 1)
  {
    result = 0;
LABEL_7:
    *a3 = a2;
  }
  else
  {
    v6 = 0;
    v8 = 0;
    while (1)
    {
      result = fst_getFST(a1, v6, &v8);
      if ((result & 0x80000000) != 0)
        break;
      *(_QWORD *)&a3[2 * v6++ + 2] = v8;
      if (a2 == v6)
        goto LABEL_7;
    }
  }
  return result;
}

uint64_t mosynt_GetReading(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6, char *a7, int a8, _DWORD *a9)
{
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t result;
  char *v19;
  const char *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  unsigned int v28;
  char *v29;
  char *v30;
  char v31;
  __int128 v32;
  _OWORD v33[5];
  uint64_t v34;
  int v35;
  char __s[12];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      v15 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      v15 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    v15 = 0;
  }
  *a4 = 0;
  *a5 = 0;
  *a7 = 0;
  *a9 = 0;
  v16 = *(_QWORD *)(a2 + 240);
  if (!v16)
    return 0;
  *a4 = 1;
  v35 = 0;
  v17 = a6 - 1;
  result = mosyntkbsymtab_AppDecomprConsToString(a1, *(uint64_t **)a2, *(_DWORD *)(v16 + 8), (uint64_t)a5, a6 - 1, &v35);
  if ((result & 0x80000000) == 0)
  {
    a5[v17] = 0;
    result = hlp_CastFSTSeq(*(_QWORD *)(a2 + 216), *(_DWORD *)(a2 + 224), (int *)v33);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntwordpho_ReadingToPhonString(a1, v15, *(uint64_t **)a2, v16, a7, a8);
      if ((result & 0x80000000) == 0)
      {
        if (!strcmp((const char *)(a2 + 248), a7))
        {
          v20 = (const char *)(a2 + 1248);
          v19 = a7;
        }
        else
        {
          __strcpy_chk();
          result = mosyntwordpho_TreatSingleReadingString(a1, v15, *(_QWORD *)a2, (uint64_t)v33, v16, (unsigned __int8 *)a7, a8);
          if ((result & 0x80000000) != 0)
            return result;
          a7[a8 - 1] = 0;
          v19 = (char *)(a2 + 1248);
          v20 = a7;
        }
        strcpy(v19, v20);
        result = mosyntwordpho_TraceReading(a1, v15, *(uint64_t **)a2, v16, (unsigned __int8 *)a7, a8);
        if ((result & 0x80000000) == 0)
        {
          *a9 = *(_DWORD *)(v16 + 12);
          if (a3)
          {
            *(_DWORD *)__s = 8689634;
            v21 = strlen(__s);
            v22 = strlen(a7);
            v23 = v22 + 2 * v21;
            LODWORD(v24) = ~(2 * v21) + a8;
            if (v23 <= a8 - 1)
              v24 = v22;
            else
              v24 = v24;
            if ((_DWORD)v24)
            {
              v25 = v24 - 1;
              do
                a7[v21 + v25] = a7[v25];
              while ((unint64_t)v25--);
            }
            if (v21)
            {
              v27 = v21;
              if (v23 >= a8 - 1)
                v23 = a8 - 1;
              v28 = v23 - v21;
              v29 = __s;
              v30 = a7;
              do
              {
                v31 = *v29++;
                *v30++ = v31;
                a7[v28++] = v31;
                --v27;
              }
              while (v27);
            }
            result = 0;
            a7[2 * v21 + v24] = 0;
          }
          if (!(_DWORD)v15
            || (HIDWORD(v32) = 0,
                LODWORD(v32) = 0,
                *(_QWORD *)((char *)&v32 + 4) = *(unsigned int *)(v16 + 12),
                result = mosyntbase_WriteMessage(a1, "\n[WANA] reading: %s cost %d  %s\n\n", 0, a5, 0, (unsigned __int8 *)a7, 0, (unsigned __int8 *)&byte_1DEBD87CE, v32), (result & 0x80000000) == 0)&& (result = mosyntdata_WriteReadingStruct(a1, *(uint64_t **)a2, 1, v16, 4), (result & 0x80000000) == 0))
          {
            *(_QWORD *)(a2 + 240) = **(_QWORD **)(a2 + 240);
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosynt_SkipToFirstOptimalReading(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  int v3;
  uint64_t *v4;

  v2 = *(uint64_t **)(a2 + 240);
  if (v2)
  {
    v3 = *((_DWORD *)v2 + 3);
    v4 = *(uint64_t **)(a2 + 240);
    do
    {
      if (*((_DWORD *)v4 + 3) < v3)
      {
        v2 = v4;
        v3 = *((_DWORD *)v4 + 3);
      }
      v4 = (uint64_t *)*v4;
    }
    while (v4);
    *(_QWORD *)(a2 + 240) = v2;
  }
  return 0;
}

uint64_t mosynt_FinishWordAnalysis(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      if (*(_WORD *)(a1 + 1028))
      {
        result = mosyntbase_WriteMessage(a1, "\n\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
        if (!a2 || (result & 0x80000000) != 0)
          return result;
        goto LABEL_9;
      }
    }
    else
    {
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  result = 0;
  if (!a2)
    return result;
LABEL_9:
  v5 = *(_QWORD **)(a2 + 232);
  if (v5)
  {
    while (1)
    {
      v6 = v5;
      v5 = (_QWORD *)*v5;
      result = mosyntdata_DisposeItem(a1, (uint64_t *)&v6);
      if ((result & 0x80000000) != 0)
        break;
      if (!v5)
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    *(_BYTE *)(a2 + 1248) = 0;
    *(_QWORD *)(a2 + 232) = 0;
    *(_QWORD *)(a2 + 240) = 0;
    *(_BYTE *)(a2 + 248) = 0;
  }
  return result;
}

uint64_t mosynt_LHPlusMapping(uint64_t a1, uint64_t *a2, uint64_t a3, char *__s1, char *a5, unsigned int a6)
{
  int v12;
  uint64_t result;
  char *v14;
  char *v15;
  _OWORD v16[5];
  uint64_t v17;
  int v18;
  uint64_t v19;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      v12 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      v12 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    v12 = 0;
  }
  v19 = 0;
  v18 = 0;
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  *a5 = 0;
  if (!strncmp(__s1, "[SVOX]", 6uLL))
  {
    v15 = strncpy(a5, __s1, a6 - 1);
    v14 = "[SVOX]";
LABEL_14:
    mosynt_RemoveInitSubstr(v15, v14);
    if (!v12)
      return 0;
    result = mosyntbase_WriteMessage(a1, "[WANA] before LHPlus mapping: %s\n", 0, (unsigned __int8 *)__s1, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    if ((result & 0x80000000) == 0)
      return mosyntbase_WriteMessage(a1, "[WANA] after LHPlus mapping: %s\n\n", 0, (unsigned __int8 *)a5, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    return result;
  }
  if (a6 >= 6)
  {
    strcpy(a5, "{VOC}");
    strncat(a5, __s1, a6 - 6);
  }
  result = fst_getFSTSeq(a3, 1, &v19, &v18);
  if ((result & 0x80000000) == 0)
  {
    result = hlp_CastFSTSeq(v19, v18, (int *)v16);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntwordpho_LHPlusMapping(a1, v12, a2, (int *)v16, (unsigned __int8 *)a5, a6);
      if ((result & 0x80000000) == 0)
      {
        a5[a6 - 1] = 0;
        v14 = "{VOC}";
        v15 = a5;
        goto LABEL_14;
      }
    }
  }
  return result;
}

uint64_t mosynt_StartSentenceAnalysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  int v9;
  uint64_t result;
  int v11;
  int v12;
  char *v13;

  if (!a1)
  {
    v9 = 0;
    if (a7)
      goto LABEL_6;
    return 0;
  }
  if (!*(_DWORD *)(a1 + 1024))
  {
    v9 = 0;
    *(_WORD *)(a1 + 1028) = 0;
    *(_DWORD *)(a1 + 1024) = 1;
    *(_DWORD *)(a1 + 1032) = 20;
    if (a7)
      goto LABEL_6;
    return 0;
  }
  v9 = *(unsigned __int16 *)(a1 + 1028);
  if (!a7)
    return 0;
LABEL_6:
  v13 = 0;
  *a7 = a5;
  a7[1] = a6;
  result = com_mosynt_GetCfgParamVal(a2, a3, a4, (uint64_t)"mosynt_maxvertexedges", "-1", &v13);
  if ((result & 0x80000000) == 0)
  {
    v11 = atoi(v13);
    if (v11 >= 0)
      v12 = v11;
    else
      v12 = 200;
    result = mosyntsentana_CreateAndInitParseDesc(a1, v9, *a7, a7[1], v12, a7 + 2);
    if ((result & 0x80000000) == 0)
      a7[3] = 0;
  }
  return result;
}

void mosynt_InsertTerminals(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 *a9)
{
  uint64_t v9;
  char *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  signed int v17;
  signed int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  char *v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 v37[5000];
  unsigned __int8 v38[5000];
  unsigned __int8 v39[5000];
  __int16 v40[12];
  uint64_t v41;

  v9 = MEMORY[0x1E0C80A78]();
  v33 = v11;
  v32 = v12;
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v20 = v19;
  v21 = v9;
  v41 = *MEMORY[0x1E0C80C00];
  if (v9)
  {
    if (*(_DWORD *)(v9 + 1024))
    {
      v22 = *(unsigned __int16 *)(v9 + 1028);
    }
    else
    {
      v22 = 0;
      *(_WORD *)(v9 + 1028) = 0;
      *(_DWORD *)(v9 + 1024) = 1;
      *(_DWORD *)(v9 + 1032) = 20;
    }
  }
  else
  {
    v22 = 0;
  }
  memset(v40, 0, sizeof(v40));
  v35 = 0;
  v36 = 0;
  v34 = 0;
  if (*v10)
    v23 = v10;
  else
    v23 = "MosyntDummyConsFeat";
  v24 = strlen(v23);
  while ((mosyntkbsymtab_GetConsFeatFromString(v21, *(uint64_t **)v20, 1, (unsigned __int8 *)v23, v24, (signed int *)&v35, (_DWORD *)&v35 + 1, v40) & 0x80000000) == 0)
  {
    if (SHIDWORD(v35) < 1)
    {
      if ((mosyntbase_WriteMessage(v21, "[SANA] error converting cons/feat \"%s\"\n", 0, (unsigned __int8 *)v23, 0, a9, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0) & 0x80000000) != 0)return;
      goto LABEL_26;
    }
    mosyntdata_NewTermInfo(v21, 0, &v36);
    if (v25 < 0)
      return;
    v26 = v36;
    if (v36)
    {
      *(_DWORD *)(v36 + 8) = v32;
      *(_QWORD *)(v26 + 16) = v33;
      *(_DWORD *)(v26 + 24) = v18;
      *(_DWORD *)(v26 + 28) = v16 - 2;
      *(_QWORD *)(v26 + 32) = a9;
      *(_DWORD *)(v26 + 40) = 0;
      v27 = strlen((const char *)a9);
      v28 = v27 - 1;
      if (v27 > 4999)
        v28 = 4998;
      *(_DWORD *)(v26 + 44) = v28;
      if (v22)
      {
LABEL_20:
        v29 = v28 + 1;
        __strncpy_chk();
        v37[v29] = 0;
        v34 = 0;
        if ((mosyntkbsymtab_AppConsFeatToString(v21, *(uint64_t **)v20, HIDWORD(v35), v40, (uint64_t)v39, 4999, &v34) & 0x80000000) != 0)
          return;
        __strcpy_chk();
        if ((mosyntkbsymtab_ConsFeatToComprConsFeatStr((uint64_t)v38, 5000) & 0x80000000) != 0)
          return;
        *((_QWORD *)&v30 + 1) = v14;
        LODWORD(v30) = 0;
        DWORD1(v30) = ~v18 + v16;
        if ((mosyntbase_WriteMessage(v21, "[SANA] reading from pos 0 to pos %d: %s cost %d  %s\n", 0, v38, 0, v37, 0, (unsigned __int8 *)&byte_1DEBD87CE, v30) & 0x80000000) != 0)return;
        if (v22 >= 2)
        {
          *((_QWORD *)&v31 + 1) = v16;
          LODWORD(v31) = 0;
          DWORD1(v31) = v18;
          if ((mosyntbase_WriteMessage(v21, "[SANA] terminal edge from %d to %d for %s \"%s\"\n", 0, v39, 0, v37, 0, (unsigned __int8 *)&byte_1DEBD87CE, v31) & 0x80000000) != 0)return;
        }
      }
    }
    else
    {
      v28 = 0;
      if (v22)
        goto LABEL_20;
    }
    if ((mosyntsentana_InsertTerminalEdge(v21, *(int **)(v20 + 16), v18, v16, SHIDWORD(v35), (uint64_t)v40, v36, v14) & 0x80000000) != 0)
      return;
LABEL_26:
    if (v23[(int)v35] != 92)
    {
      if (v22)
        mosyntbase_WLn(v21);
      return;
    }
    LODWORD(v35) = v35 + 1;
  }
}

void mosynt_ParseSentence(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      v4 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      v4 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    v4 = 0;
  }
  if ((mosyntsentana_DoParse(a1, *(_QWORD *)(a2 + 16)) & 0x80000000) == 0)
  {
    mosyntsentana_GetOptimalTree(a1, *(_QWORD *)(a2 + 16), (_QWORD *)(a2 + 24));
    if ((v5 & 0x80000000) == 0
      && v4
      && (mosyntbase_WLn(a1) & 0x80000000) == 0
      && (mosyntbase_WLn(a1) & 0x80000000) == 0)
    {
      mosyntsentana_DisplayTree(a1, *(_QWORD *)(a2 + 16), *(uint64_t **)(a2 + 24));
    }
  }
}

uint64_t mosynt_GetTerminalInfoById(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _BYTE *a5, int a6)
{
  uint64_t result;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;

  *a4 = 0;
  *a5 = 0;
  if (!a2)
    return 0;
  result = *(_QWORD *)(a2 + 24);
  if (!result)
    return result;
  v15 = 0;
  mosynt_GetTerminalNode(result, a3, &v15);
  v12 = v15;
  if (!v15)
    return 0;
  *a4 = 1;
  v14 = 0;
  v13 = a6 - 1;
  result = mosyntkbsymtab_AppConsFeatToString(a1, *(uint64_t **)a2, *(__int16 *)(v12 + 16), (__int16 *)(v12 + 24), (uint64_t)a5, v13, &v14);
  if ((result & 0x80000000) == 0)
  {
    result = 0;
    a5[v13] = 0;
  }
  return result;
}

uint64_t mosynt_GetTerminalNode(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  _QWORD *v6;
  BOOL v7;

  *a3 = 0;
  if (*(_BYTE *)(result + 60))
  {
    v5 = *(_QWORD *)(result + 64);
    if (v5)
    {
      if (*(_DWORD *)(v5 + 8) == (_DWORD)a2)
        *a3 = result;
    }
  }
  else
  {
    v6 = *(_QWORD **)(result + 8);
    if (v6)
    {
      do
      {
        result = mosynt_GetTerminalNode(v6, a2, a3);
        v6 = (_QWORD *)*v6;
        if (*a3)
          v7 = 1;
        else
          v7 = v6 == 0;
      }
      while (!v7);
    }
  }
  return result;
}

uint64_t mosynt_SyntTreeToString(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  int v5;

  *a3 = 0;
  if (!a2)
    return 0;
  v5 = 0;
  return mosynt_SyntTreeToString1(a1, *(uint64_t **)a2, *(_QWORD *)(a2 + 24), (uint64_t)a3, a4, &v5);
}

uint64_t mosynt_SyntTreeToString1(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  unsigned int v12;
  uint64_t result;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  char v26;
  int v27;
  char v28[19];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 0;
  v27 = *a6;
  v12 = a5 - 1;
  result = mosyntkbsymtab_AppConsFeatToString(a1, a2, *(__int16 *)(a3 + 16), (__int16 *)(a3 + 24), a4, (int)a5 - 1, &v27);
  if ((result & 0x80000000) != 0)
    return result;
  *(_BYTE *)(a4 + v12) = 0;
  v14 = (unsigned __int16)v27;
  *a6 = (unsigned __int16)v27;
  v15 = (_QWORD *)(a3 + 8);
  if (*(_QWORD *)(a3 + 8))
  {
    if (v14 < v12)
    {
      *(_BYTE *)(a4 + v14) = 91;
      LODWORD(v14) = *a6 + 1;
      *a6 = v14;
    }
    *(_BYTE *)(a4 + v14) = 0;
    v16 = (_QWORD *)(a3 + 8);
    while (1)
    {
      v16 = (_QWORD *)*v16;
      if (!v16)
        break;
      if (v16 != (_QWORD *)*v15)
      {
        v17 = *a6;
        if (v17 < v12)
        {
          *(_BYTE *)(a4 + v17) = 44;
          LODWORD(v17) = *a6 + 1;
          *a6 = v17;
        }
        *(_BYTE *)(a4 + v17) = 0;
      }
      result = mosynt_SyntTreeToString1(a1, a2, v16, a4, a5, a6);
      if ((result & 0x80000000) != 0)
        return result;
    }
    v25 = *a6;
    if (*a6 >= v12)
      goto LABEL_32;
    v26 = 93;
  }
  else
  {
    if (v14 < v12)
    {
      *(_BYTE *)(a4 + v14) = 60;
      LODWORD(v14) = *a6 + 1;
      *a6 = v14;
    }
    *(_BYTE *)(a4 + v14) = 0;
    LH_itoa(*(_DWORD *)(a3 + 52), v28, 0xAu);
    LOBYTE(v18) = v28[0];
    v19 = *a6;
    if (v28[0])
    {
      v20 = 1;
      do
      {
        if (v19 >= v12)
          break;
        *(_BYTE *)(a4 + v19) = v18;
        v19 = *a6 + 1;
        *a6 = v19;
        v18 = v28[v20++];
      }
      while (v18);
    }
    *(_BYTE *)(a4 + v19) = 0;
    v21 = *a6;
    if (v21 < v12)
    {
      *(_BYTE *)(a4 + v21) = 44;
      LODWORD(v21) = *a6 + 1;
      *a6 = v21;
    }
    *(_BYTE *)(a4 + v21) = 0;
    LH_itoa(*(_DWORD *)(a3 + 56), v28, 0xAu);
    LOBYTE(v22) = v28[0];
    v23 = *a6;
    if (v28[0])
    {
      v24 = 1;
      do
      {
        if (v23 >= v12)
          break;
        *(_BYTE *)(a4 + v23) = v22;
        v23 = *a6 + 1;
        *a6 = v23;
        v22 = v28[v24++];
      }
      while (v22);
    }
    *(_BYTE *)(a4 + v23) = 0;
    v25 = *a6;
    if (*a6 >= v12)
      goto LABEL_32;
    v26 = 62;
  }
  *(_BYTE *)(a4 + v25) = v26;
  v25 = *a6 + 1;
  *a6 = v25;
LABEL_32:
  result = 0;
  *(_BYTE *)(a4 + v25) = 0;
  return result;
}

uint64_t mosynt_FinishSentenceAnalysis(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  if (!*(_QWORD *)(a2 + 24))
    return mosyntsentana_DisposeParseDesc(a1, (uint64_t *)(a2 + 16));
  result = mosyntsentana_DisposeTree(a1, *(_QWORD *)(a2 + 16), a2 + 24);
  if ((result & 0x80000000) == 0)
    return mosyntsentana_DisposeParseDesc(a1, (uint64_t *)(a2 + 16));
  return result;
}

void mosynt_StringToSyntTree(uint64_t a1, uint64_t *a2, char *__s, uint64_t *a4)
{
  __int16 v8;
  int v9;
  unint64_t v10;
  int v11;
  uint64_t v12;

  v12 = 0;
  v11 = 0;
  v8 = strlen(__s);
  mosynt_StringToSyntTree1(a1, a2, (unsigned __int8 *)__s, (unsigned __int16)(v8 + 1), (signed int *)&v12 + 1, a4, (int *)&v12, &v11);
  if ((v9 & 0x80000000) == 0)
  {
    if (__s[SHIDWORD(v12)])
    {
      LODWORD(v10) = 0;
      HIDWORD(v10) = HIDWORD(v12);
      mosyntbase_WriteMessage(a1, "### syntax tree not fully parsed; last position is %d: %s\n",
        0,
        (unsigned __int8 *)__s,
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        v10);
    }
  }
}

void mosynt_StringToSyntTree1(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4, signed int *a5, uint64_t *a6, int *a7, _DWORD *a8)
{
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unsigned __int8 *v20;
  uint64_t v21;
  signed int *v22;
  int *v23;
  uint64_t v24;
  int v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  __n128 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if ((mosyntutils_SkipBlanksInString((uint64_t)a3, a4, a5) & 0x80000000) == 0)
  {
    if (a3[*a5])
    {
      v29 = 0;
      v31 = 0;
      v30 = 0uLL;
      v27 = 0;
      v28 = 0;
      v26 = 0;
      v25 = 0;
      if ((mosyntkbsymtab_GetConsFeatFromString(a1, a2, 1, a3, a4, a5, &v29, (__int16 *)&v30) & 0x80000000) == 0)
      {
        mosyntdata_NewSyntNode(a1, v29, &v30, a6);
        if ((v16 & 0x80000000) == 0)
        {
          v17 = *a6;
          *(_BYTE *)(v17 + 60) = 0;
          *(_QWORD *)v17 = 0;
          *(_QWORD *)(*a6 + 8) = 0;
          if (a3[*a5] == 91)
          {
            if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x5Bu) & 0x80000000) == 0
              && (mosyntdata_StartPhonList(a1, &v28, &v27) & 0x80000000) == 0)
            {
              v18 = a1;
              v19 = a2;
              v20 = a3;
              v21 = a4;
              v22 = a5;
              v23 = a7;
              while ((mosynt_StringToSyntTree1(v18, v19, v20, v21, v22, &v26, v23, a8) & 0x80000000) == 0
                   && (mosyntdata_AppendNode(a1, &v28, &v27, 1, v26) & 0x80000000) == 0)
              {
                if (a3[*a5] != 44)
                {
                  if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x5Du) & 0x80000000) == 0)
                  {
                    *(_QWORD *)(*a6 + 8) = v28;
                    v24 = *a6;
                    *(_DWORD *)(v24 + 52) = *a7;
                    *(_DWORD *)(v24 + 56) = *a8;
                  }
                  return;
                }
                if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x2Cu) & 0x80000000) != 0)
                  return;
                v23 = &v25;
                v18 = a1;
                v19 = a2;
                v20 = a3;
                v21 = a4;
                v22 = a5;
              }
            }
          }
          else
          {
            *(_BYTE *)(*a6 + 60) = 1;
            if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x3Cu) & 0x80000000) == 0
              && (mosyntutils_GetCardFromString(a1, a3, a4, a5, a7) & 0x80000000) == 0)
            {
              *(_DWORD *)(*a6 + 52) = *a7;
              if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x2Cu) & 0x80000000) == 0
                && (mosyntutils_GetCardFromString(a1, a3, a4, a5, a8) & 0x80000000) == 0)
              {
                *(_DWORD *)(*a6 + 56) = *a8;
                mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x3Eu);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t mosynt_StartAccentPhrasing(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t result;
  char *__s;

  if (!a7)
    return 0;
  *(_QWORD *)a7 = a5;
  if (mosyntkbaccphr_AccPhrType(a6))
    v14 = a6;
  else
    v14 = 0;
  __s = 0;
  *(_QWORD *)(a7 + 8) = v14;
  result = com_mosynt_GetCfgParamVal(a2, a3, a4, (uint64_t)"mosynt_phrpar", "1", &__s);
  if ((result & 0x80000000) == 0)
  {
    *(_WORD *)(a7 + 16) = atoi(__s);
    result = com_mosynt_GetCfgParamVal(a2, a3, a4, (uint64_t)"mosynt_accphrdefdomain", "DEFAULT", &__s);
    if ((result & 0x80000000) == 0)
    {
      strlen(__s);
      *(_DWORD *)(a7 + 20) = mosyntkbsymtab_KnownAtomId(a1, a5, (uint64_t)__s);
      return mosyntdata_CreateAndInitSentTermData(a1, (uint64_t *)(a7 + 24));
    }
  }
  return result;
}

double mosynt_InsertAccPhrTermWord(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4, int a5, char *__s)
{
  uint64_t *v12;
  int v13;
  double result;
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  v16 = 0;
  v12 = *(uint64_t **)a2;
  v13 = strlen(__s);
  if ((mosyntdata_StringToLexPhonList(a1, v12, (unsigned __int8 *)__s, v13, &v16, &v15) & 0x80000000) == 0)
    return mosyntdata_InsertSentTermWord(a1, *(_QWORD *)(a2 + 24), a3, a4, a5, v16);
  return result;
}

BOOL mosynt_IsPunctChar(uint64_t a1, uint64_t a2, int a3)
{
  return a2 && mosyntknowl_OrthPunctType(a1, a3) != 0;
}

void mosynt_InsertAccPhrPunct(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  int v7;

  v7 = mosyntknowl_OrthPunctType(a1, a4);
  if (v7)
    mosyntdata_InsertSentTermPunct(a1, *(_QWORD *)(a2 + 24), a3, v7);
}

void mosynt_DoAccentPhrasing(uint64_t a1, uint64_t a2, char *a3)
{
  int v5;
  int v6;
  _QWORD *v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      v5 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      v5 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    v5 = 0;
  }
  mosynt_StringToSyntTree(a1, *(uint64_t **)a2, a3, &v8);
  if ((v6 & 0x80000000) == 0
    && (mosyntaccphr_TreatSyntTree(a1, v5, *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(unsigned __int16 *)(a2 + 16), *(_DWORD *)(a2 + 20), *(_QWORD *)(a2 + 24), v8) & 0x80000000) == 0&& (!v5|| (mosyntdata_GenPhonoRepr(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 24), &v7) & 0x80000000) == 0&& (mosyntbase_WLn(a1) & 0x80000000) == 0&& (mosyntbase_WString(a1, "after acc/phr: ", 0) & 0x80000000) == 0&& (mosyntdata_WritePhonList(a1, *(uint64_t **)a2, v7) & 0x80000000) == 0&& (mosyntbase_WLn(a1) & 0x80000000) == 0&& (mosyntbase_WLn(a1) & 0x80000000) == 0&& (mosyntdata_DisposePhonEleList(a1, &v7) & 0x80000000) == 0))
  {
    if (v8)
      mosyntdata_DisposeSyntTree(a1, &v8);
  }
}

uint64_t mosynt_GetWordProminence(uint64_t a1, uint64_t a2, unsigned int a3, _WORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;

  *a4 = 0;
  if (a2
    && (v5 = *(_QWORD *)(a2 + 24)) != 0
    && (v6 = mosyntdata_SentTermWordData(a1, v5, a3)) != 0
    && (v7 = *(_DWORD *)(v6 + 16), (v7 & 0xFFFC) == 0))
  {
    v8 = 0x1000200020000uLL >> (16 * v7);
  }
  else
  {
    LOWORD(v8) = 0;
  }
  *a4 = v8;
  return 0;
}

uint64_t mosynt_GetPhraseInfo(uint64_t a1, uint64_t a2, unsigned int a3, _WORD *a4, _BYTE *a5, int a6)
{
  uint64_t v6;
  uint64_t result;
  int v11;
  int v12;

  *a4 = 0;
  *a5 = 0;
  if (!a2)
    return 0;
  v6 = *(_QWORD *)(a2 + 24);
  if (!v6)
    return 0;
  result = mosyntdata_SentTermBoundData(a1, v6, a3);
  if (!result)
    return result;
  v11 = *(_DWORD *)(result + 8);
  if (v11 < 0)
    return 0;
  *a4 = v11;
  v12 = mosyntkbaccphr_SimplifiedPhraseType(*(_DWORD *)(result + 12));
  result = mosyntkbaccphr_PhraseTypeToString(v12, (uint64_t)a5, a6);
  if ((result & 0x80000000) == 0)
  {
    result = 0;
    a5[a6 - 1] = 0;
  }
  return result;
}

uint64_t mosynt_FinishAccentPhrasing(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;

  if (a2 && (v3 = *(_QWORD *)(a2 + 24), v2 = (uint64_t *)(a2 + 24), v3))
    return mosyntdata_DisposeSentTermData(a1, v2);
  else
    return 0;
}

uint64_t mosynt_SentPhono(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, char *a5, char *a6, int a7)
{
  int v14;
  uint64_t result;
  char v16;
  int v17;
  size_t v18;
  uint64_t *v19;
  int v20;
  _QWORD *v21;
  uint64_t *v22;
  _QWORD *v23;
  int v24;
  BOOL v25;
  __int16 v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  unsigned __int16 v30;
  char *v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  _OWORD v36[5];
  uint64_t v37;
  _OWORD v38[5];
  uint64_t v39;
  _OWORD v40[5];
  uint64_t v41;
  uint64_t *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  _QWORD *v49[2];

  v48 = 0;
  v49[0] = 0;
  if (!a1)
  {
    v14 = 0;
    goto LABEL_7;
  }
  if (!*(_DWORD *)(a1 + 1024))
  {
    v14 = 0;
    *(_WORD *)(a1 + 1028) = 0;
    v16 = 1;
    *(_DWORD *)(a1 + 1024) = 1;
    *(_DWORD *)(a1 + 1032) = 20;
    goto LABEL_9;
  }
  v14 = *(unsigned __int16 *)(a1 + 1028);
  if (!*(_WORD *)(a1 + 1028))
  {
LABEL_7:
    v16 = 1;
    goto LABEL_9;
  }
  result = mosyntbase_WriteMessage(a1, "[SLPH] input string: %s\n", 0, a4, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
  if ((result & 0x80000000) != 0)
    return result;
  v16 = 0;
LABEL_9:
  v46 = 0;
  v47 = 0;
  v44 = 0;
  v45 = 0;
  v43 = 0;
  v42 = 0;
  memset(v40, 0, sizeof(v40));
  v41 = 0;
  memset(v38, 0, sizeof(v38));
  v39 = 0;
  v37 = 0;
  memset(v36, 0, sizeof(v36));
  v17 = strlen((const char *)a4);
  v18 = strlen(a5);
  result = mosyntdata_StringToPhonoPhonList(a1, a2, 1, a4, v17, a5, v18, v49);
  if ((result & 0x80000000) == 0)
  {
    if ((v16 & 1) != 0
      || (result = mosyntbase_WString(a1, "[SLPH] input phono list: ", 0), (result & 0x80000000) == 0)
      && (result = mosyntdata_WritePhonList(a1, a2, v49[0]), (result & 0x80000000) == 0)
      && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
    {
      result = fst_getFSTSeq(a3, 2, &v47, (_DWORD *)&v44 + 1);
      if ((result & 0x80000000) == 0)
      {
        result = hlp_CastFSTSeq(v47, SHIDWORD(v44), (int *)v40);
        if ((result & 0x80000000) == 0)
        {
          result = fst_getFSTSeq(a3, 3, &v46, &v44);
          if ((result & 0x80000000) == 0)
          {
            result = hlp_CastFSTSeq(v46, v44, (int *)v38);
            if ((result & 0x80000000) == 0)
            {
              result = fst_getFSTSeq(a3, 4, &v45, &v43);
              if ((result & 0x80000000) == 0)
              {
                result = hlp_CastFSTSeq(v45, v43, (int *)v36);
                if ((result & 0x80000000) == 0)
                {
                  v19 = v49[0];
                  if (v49[0])
                  {
                    v20 = 0;
                    v21 = v49[0];
                    do
                    {
                      *((_WORD *)v21 + 4) = v20++;
                      v21 = (_QWORD *)*v21;
                    }
                    while (v21);
                  }
                  result = mosyntsentpho_TreatSentPho(a1, v14, (uint64_t)a2, (int *)v40, (int *)v38, (int *)v36, v19, &v48);
                  if ((result & 0x80000000) == 0)
                  {
                    v22 = v48;
                    v23 = v49[0];
                    v42 = v48;
                    if (v49[0])
                    {
                      while (1)
                      {
                        if (!v22)
                          goto LABEL_36;
                        v24 = *((unsigned __int16 *)v22 + 4);
                        if (v24 == 0xFFFF || *((__int16 *)v23 + 4) > (__int16)v24)
                        {
                          v22 = (uint64_t *)*v22;
                          v42 = v22;
                        }
                        else
                        {
                          if (*((_BYTE *)v23 + 20))
                            v25 = v24 == *((unsigned __int16 *)v23 + 4);
                          else
                            v25 = 0;
                          if (v25 && *((_BYTE *)v22 + 20) && *((_DWORD *)v23 + 6) >= 2u && *((_DWORD *)v22 + 6) <= 1u)
                          {
                            v26 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)"*");
                            v27 = v42;
                            *((_DWORD *)v42 + 6) = 2;
                            v28 = *v27;
                            *v27 = 0;
                            result = mosyntdata_AddPhonEle(a1, &v48, (uint64_t *)&v42, 1, v26);
                            if ((result & 0x80000000) != 0)
                              return result;
                            *v42 = v28;
                          }
LABEL_36:
                          v23 = (_QWORD *)*v23;
                          if (!v23)
                            break;
                          v22 = v42;
                        }
                      }
                    }
                    if ((v16 & 1) != 0
                      || (result = mosyntbase_WString(a1, "[SLPH] output phono list: ", 0), (result & 0x80000000) == 0)
                      && (result = mosyntdata_WritePhonList(a1, a2, v48), (result & 0x80000000) == 0)
                      && (result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
                    {
                      result = mosyntdata_PhonListToString(a1, a2, 1, v48, a6, a7);
                      if ((result & 0x80000000) == 0)
                      {
                        a6[a7 - 1] = 0;
                        v29 = *a6;
                        if (*a6)
                        {
                          v30 = 0;
                          v31 = a6;
                          do
                          {
                            if (v30 && v29 == 42 && (v32 = v30 - 1, a6[v32] == 39))
                            {
                              a6[v32] = 42;
                              v33 = 39;
                            }
                            else
                            {
                              v34 = v30 - 2;
                              if (v30 < 2u)
                                goto LABEL_56;
                              if (v29 != 42)
                                goto LABEL_56;
                              v35 = v30 - 1;
                              if (a6[v35] != 50 || a6[v34] != 39)
                                goto LABEL_56;
                              a6[v34] = 42;
                              a6[v35] = 39;
                              v33 = 50;
                            }
                            *v31 = v33;
LABEL_56:
                            v31 = &a6[++v30];
                            v29 = *v31;
                          }
                          while (*v31);
                        }
                        if ((v16 & 1) != 0
                          || (result = mosyntbase_WriteMessage(a1, "[SLPH] output string: %s\n", 0, (unsigned __int8 *)a6, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0), (result & 0x80000000) == 0))
                        {
                          result = mosyntdata_DisposePhonEleList(a1, v49);
                          if ((result & 0x80000000) == 0)
                            return mosyntdata_DisposePhonEleList(a1, &v48);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sgram_CheckIfExists(_WORD *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t inited;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v16;
  uint64_t v17;
  _OWORD v18[16];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  *a3 = 0;
  inited = InitRsrcFunction(a1, a2, &v17);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = kbaux_BuildBrokerString(v17, "sgram", (char *)v18, 0x100uLL);
  if ((inited & 0x80000000) != 0)
    return inited;
  v7 = sgram_OpenRiffForReading(a1, a2, (const char *)v18, (uint64_t *)&v16);
  v14 = v7;
  if ((v7 & 0x80000000) == 0)
  {
    *a3 = 1;
    return sgram_CloseRiff(&v16, v7, v8, v9, v10, v11, v12, v13);
  }
  if ((v7 & 0x1FFF) == 0xD || (v7 & 0x1FFF) == 3)
    return 0;
  return v14;
}

uint64_t sgram_LoadData(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t inited;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v23;
  uint64_t v24;
  _OWORD v25[16];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v24 = 0;
  memset(v25, 0, sizeof(v25));
  inited = InitRsrcFunction(a1, a2, &v24);
  if ((inited & 0x80000000) != 0)
    return inited;
  v7 = 2371887111;
  if (a3)
  {
    v8 = heap_Calloc(*(_QWORD **)(v24 + 8), 1, 232);
    *a3 = v8;
    if (!v8)
      return 2371887114;
    inited = kbaux_BuildBrokerString(v24, "sgram", (char *)v25, 0x100uLL);
    if ((inited & 0x80000000) == 0)
    {
      inited = sgram_OpenRiffForReading(a1, a2, (const char *)v25, (uint64_t *)&v23);
      if ((inited & 0x80000000) == 0)
      {
        v15 = sgram_ReadFromRiff((uint64_t)v23, *a3, v9, v10, v11, v12, v13, v14);
        return sgram_CloseRiff(&v23, v15, v16, v17, v18, v19, v20, v21);
      }
    }
    return inited;
  }
  return v7;
}

uint64_t sgram_UnloadData(_WORD *a1, int a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t inited;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  v3 = 2371887111;
  if (a3)
  {
    v15 = 0;
    inited = InitRsrcFunction(a1, a2, &v15);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else if (*a3)
    {
      v13 = v15;
      v3 = sgram_ReleaseData(*a3, v6, v7, v8, v9, v10, v11, v12);
      heap_Free(*(_QWORD **)(v13 + 8), *a3);
      *a3 = 0;
    }
  }
  return v3;
}

uint64_t sgram_GetStartCons(_DWORD *a1, _DWORD *a2)
{
  uint64_t result;

  result = 2371887111;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *a1;
    }
  }
  return result;
}

BOOL sgram_HasEmptyRules(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 40) != 0;
  return result;
}

BOOL sgram_HasSimpleFollowRel(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 192) != 0;
  return result;
}

uint64_t sgram_GetFirstRuleSameLast(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result;
  int v13;
  int i;

  result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    v13 = *(_DWORD *)(a1 + 80);
    *(_QWORD *)a3 = a1;
    a3[2] = 0;
    for (i = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 4 * (a2 % v13));
          ;
          i = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a3 + 72) + 4 * (int)a3[3] + 32))
    {
      a3[3] = 10 * i;
      getRuleHeadSubCons(a3, a4, a5, a6);
      if (!*a4)
        break;
      if (*a6)
      {
        if (*a6 == a2)
          return 0;
      }
      else
      {
        result = 0;
        if (!a2 || *a5 == a2)
          return result;
      }
    }
    return 0;
  }
  return result;
}

_DWORD *getRuleHeadSubCons(_DWORD *result, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  v4 = result[3];
  if (result[2] == 1)
  {
    if (v4 < *(_DWORD *)(*(_QWORD *)result + 32))
    {
      v5 = (uint64_t *)(*(_QWORD *)result + 48);
      goto LABEL_6;
    }
LABEL_8:
    v7 = 0;
    *a2 = 0;
    *a3 = 0;
    goto LABEL_9;
  }
  if (v4 < 0)
    goto LABEL_8;
  v5 = (uint64_t *)(*(_QWORD *)result + 72);
LABEL_6:
  v6 = *v5;
  if (!v6)
    goto LABEL_8;
  *a2 = *(_DWORD *)(v6 + 4 * (v4 + 1));
  *a3 = *(_DWORD *)(v6 + 4 * (int)result[3] + 8);
  v7 = *(_DWORD *)(v6 + 4 * (int)result[3] + 12);
LABEL_9:
  *a4 = v7;
  return result;
}

uint64_t sgram_GetNextRuleSameLast(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;

  result = 2371887111;
  if (a2 && a3 && a4 && a5)
  {
    while (1)
    {
      a2[3] = 10 * *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 72) + 4 * (int)a2[3] + 32);
      getRuleHeadSubCons(a2, a3, a4, a5);
      if (!*a3)
        break;
      if (*a5)
      {
        if (*a5 == a1)
          return 0;
      }
      else
      {
        result = 0;
        if (!a1 || *a4 == a1)
          return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sgram_GetFirstRuleSameFirst(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result;
  int v13;
  int i;

  result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    v13 = *(_DWORD *)(a1 + 104);
    *(_QWORD *)a3 = a1;
    a3[2] = 0;
    for (i = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * (a2 % v13));
          ;
          i = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a3 + 72) + 4 * (int)a3[3] + 36))
    {
      a3[3] = 10 * i;
      getRuleHeadSubCons(a3, a4, a5, a6);
      if (!*a4 || *a5 != a2)
        break;
    }
    return 0;
  }
  return result;
}

uint64_t sgram_GetNextRuleSameFirst(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;

  result = 2371887111;
  if (a2 && a3 && a4 && a5)
  {
    do
    {
      a2[3] = 10 * *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 72) + 4 * (int)a2[3] + 36);
      getRuleHeadSubCons(a2, a3, a4, a5);
    }
    while (*a3 && *a5 != a1);
    return 0;
  }
  return result;
}

uint64_t sgram_GetFirstEmptyRule(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;

  result = 2371887111;
  if (a1 && a2 && a3 && a4)
  {
    if (a5)
    {
      *(_QWORD *)a2 = a1;
      *(_QWORD *)(a2 + 8) = 1;
      getRuleHeadSubCons((_DWORD *)a2, a3, a4, a5);
      return 0;
    }
  }
  return result;
}

uint64_t sgram_GetNextEmptyRule(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;

  result = 2371887111;
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      a1[3] += 8;
      getRuleHeadSubCons(a1, a2, a3, a4);
      return 0;
    }
  }
  return result;
}

uint64_t sgram_GetRuleFeatLists(uint64_t *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _WORD *v14;
  __int16 *v15;
  __int16 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  _WORD *v22;
  __int16 *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _WORD *v28;
  __int16 *v29;
  __int16 v30;

  result = 2371887111;
  if (a1 && a2 && a3 && a4)
  {
    v6 = *((_DWORD *)a1 + 3);
    if (*((_DWORD *)a1 + 2) == 1)
    {
      v7 = *a1;
      if (v6 >= *(_DWORD *)(v7 + 32))
        goto LABEL_16;
      v8 = (uint64_t *)(v7 + 48);
    }
    else
    {
      if (v6 < 0)
        goto LABEL_16;
      v7 = *a1;
      v8 = (uint64_t *)(v7 + 72);
    }
    v9 = *v8;
    if (v9)
    {
      v10 = *(unsigned int *)(v9 + 4 * (v6 + 4));
      if ((v10 & 0x80000000) != 0)
      {
        LOWORD(v12) = 0;
      }
      else
      {
        v11 = *(_QWORD *)(v7 + 24);
        v12 = *(__int16 *)(v11 + 2 * v10);
        if (v12 >= 1)
        {
          v13 = *(unsigned __int16 *)(v11 + 2 * v10);
          v14 = a2 + 1;
          v15 = (__int16 *)(v11 + 2 * v10 + 2);
          do
          {
            v16 = *v15++;
            *v14++ = v16;
            --v13;
          }
          while (v13);
        }
      }
      *a2 = v12;
      v18 = *(unsigned int *)(v9 + 4 * (v6 + 5));
      if ((v18 & 0x80000000) != 0)
      {
        LOWORD(v20) = 0;
      }
      else
      {
        v19 = *(_QWORD *)(v7 + 24);
        v20 = *(__int16 *)(v19 + 2 * v18);
        if (v20 >= 1)
        {
          v21 = *(unsigned __int16 *)(v19 + 2 * v18);
          v22 = a3 + 1;
          v23 = (__int16 *)(v19 + 2 * v18 + 2);
          do
          {
            v24 = *v23++;
            *v22++ = v24;
            --v21;
          }
          while (v21);
        }
      }
      *a3 = v20;
      v25 = *(unsigned int *)(v9 + 4 * (v6 + 6));
      if ((v25 & 0x80000000) != 0)
      {
        LOWORD(v17) = 0;
      }
      else
      {
        v26 = *(_QWORD *)(v7 + 24);
        v17 = *(__int16 *)(v26 + 2 * v25);
        if (v17 >= 1)
        {
          v27 = *(unsigned __int16 *)(v26 + 2 * v25);
          v28 = a4 + 1;
          v29 = (__int16 *)(v26 + 2 * v25 + 2);
          do
          {
            v30 = *v29++;
            *v28++ = v30;
            --v27;
          }
          while (v27);
        }
      }
      goto LABEL_17;
    }
LABEL_16:
    LOWORD(v17) = 0;
    *a2 = 0;
    *a3 = 0;
LABEL_17:
    result = 0;
    *a4 = v17;
  }
  return result;
}

uint64_t sgram_GetRuleVisAndCost(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  v3 = 2371887111;
  if (a1 && a2 && a3)
  {
    v4 = (int)a1[3];
    if (a1[2] == 1)
    {
      if ((int)v4 >= *(_DWORD *)(*(_QWORD *)a1 + 32))
        goto LABEL_11;
      v5 = (uint64_t *)(*(_QWORD *)a1 + 48);
    }
    else
    {
      if ((v4 & 0x80000000) != 0)
        goto LABEL_11;
      v5 = (uint64_t *)(*(_QWORD *)a1 + 72);
    }
    v6 = *v5;
    if (v6)
    {
      *a2 = *(_DWORD *)(v6 + 4 * v4) != 0;
      v7 = *(_DWORD *)(v6 + 4 * (int)a1[3] + 28);
LABEL_12:
      v3 = 0;
      *a3 = v7;
      return v3;
    }
LABEL_11:
    v7 = 0;
    *a2 = 0;
    goto LABEL_12;
  }
  return v3;
}

BOOL sgram_IsFollowerCons(_BOOL8 result, int a2, int a3)
{
  unsigned int *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  BOOL v11;
  _DWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  if (result)
  {
    v3 = (unsigned int *)(*(_QWORD *)(result + 224) + 4 * (a3 % *(_DWORD *)(result + 208)));
    v4 = *v3;
    LODWORD(v3) = v3[1];
    v5 = (_DWORD)v3 - v4;
    if ((int)v3 <= (int)v4)
      return 0;
    v6 = 2 * v4;
    v7 = *(_QWORD *)(result + 200);
    v8 = v4 << 33;
    v9 = (int *)(v7 + 4 * v6);
    while (1)
    {
      v10 = *v9;
      v9 += 2;
      v11 = v10 == a3;
      if (v10 >= a3)
        break;
      v8 += 0x200000000;
      if (!--v5)
        return 0;
    }
    if (v11
      && (v12 = (_DWORD *)(*(_QWORD *)(result + 176)
                         + 4
                         * (*(_DWORD *)(v7 + ((v8 >> 30) | 4))
                          + *(_DWORD *)(v7 + ((v8 >> 30) | 4)) * *(_DWORD *)(result + 160)
                          + a2 % *(_DWORD *)(result + 160))),
          LODWORD(v14) = *v12,
          v13 = v12[1],
          v14 = (int)v14,
          (int)v14 < v13))
    {
      v15 = *(_QWORD *)(result + 152);
      while (1)
      {
        v16 = *(_DWORD *)(v15 + 4 * v14);
        if (v16 >= a2)
          break;
        result = 0;
        if (v13 <= (int)++v14)
          return result;
      }
      return v16 == a2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t mosyntdata_StartPhonList(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = 0;
  *a3 = 0;
  return 0;
}

uint64_t mosyntdata_AddPhonEle(uint64_t a1, _QWORD *a2, uint64_t *a3, int a4, __int16 a5)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = 0;
  result = mosyntpal_ALLOCATE(a1, &v12, 0x28u);
  if ((result & 0x80000000) == 0)
  {
    v10 = v12;
    *(_BYTE *)(v12 + 20) = 0;
    *(_WORD *)(v10 + 24) = a5;
    *(_WORD *)(v10 + 26) = -1;
    *(_QWORD *)(v10 + 8) = -1;
    *(_DWORD *)(v10 + 16) = 0xFFFF;
    if (a4)
    {
      *(_QWORD *)v10 = 0;
      v11 = v12;
      if (*a3)
      {
        *(_QWORD *)*a3 = v12;
        v11 = v12;
      }
      else
      {
        *a2 = v12;
      }
    }
    else
    {
      *(_QWORD *)v10 = *a2;
      v11 = v12;
      *a2 = v12;
      if (*a3)
        return result;
    }
    *a3 = v11;
  }
  return result;
}

uint64_t mosyntdata_AddBound(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, int a5, __int16 a6, int a7, __int16 a8)
{
  uint64_t result;
  uint64_t *v16;
  uint64_t v17;

  result = mosyntdata_AddPhonEle(a1, a2, a3, a4, 0);
  if ((result & 0x80000000) == 0)
  {
    if (a4)
      v16 = a3;
    else
      v16 = a2;
    v17 = *v16;
    *(_BYTE *)(v17 + 20) = 1;
    *(_DWORD *)(v17 + 24) = a5;
    *(_WORD *)(v17 + 28) = a6;
    *(_DWORD *)(v17 + 32) = a7;
    *(_WORD *)(v17 + 36) = a8;
  }
  return result;
}

uint64_t mosyntdata_AppendPhonList(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  if (!*a3 || (a2 = (_QWORD *)*a3, a5))
  {
    *a2 = a4;
    *a3 = a5;
  }
  return 0;
}

_QWORD *mosyntdata_LastPhonEle(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  if (!a2)
    return 0;
  do
  {
    result = a2;
    a2 = (_QWORD *)*a2;
  }
  while (a2);
  return result;
}

uint64_t mosyntdata_PopPhonEle(uint64_t a1, _QWORD **a2, _QWORD *a3, _QWORD *a4)
{
  if (*a2)
  {
    *a4 = *a2;
    *a2 = (_QWORD *)**a2;
    a4 = (_QWORD *)*a4;
  }
  *a4 = 0;
  if (!*a2)
    *a3 = 0;
  return 0;
}

uint64_t mosyntdata_CopyPhonList(uint64_t a1, uint64_t **a2)
{
  uint64_t *v3;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  _OWORD *v11;
  _OWORD *v12;

  v3 = *a2;
  if (*a2)
  {
    v5 = 0;
    v6 = 0;
    v12 = 0;
    while (1)
    {
      result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x28u);
      if ((result & 0x80000000) != 0)
        break;
      v8 = (uint64_t)v12;
      v9 = v3[4];
      v10 = *((_OWORD *)v3 + 1);
      *v12 = *(_OWORD *)v3;
      *(_OWORD *)(v8 + 16) = v10;
      *(_QWORD *)(v8 + 32) = v9;
      *(_QWORD *)v8 = 0;
      v11 = v12;
      if (v5)
      {
        *v5 = v12;
        v11 = v12;
      }
      else
      {
        v6 = (uint64_t *)v12;
      }
      v3 = (uint64_t *)*v3;
      v5 = v11;
      if (!v3)
        goto LABEL_10;
    }
  }
  else
  {
    result = 0;
    v6 = 0;
LABEL_10:
    *a2 = v6;
  }
  return result;
}

uint64_t mosyntdata_DisposePhonEleList(uint64_t a1, _QWORD **a2)
{
  _QWORD *v3;
  uint64_t result;
  _QWORD *v6;

  v3 = *a2;
  if (*a2)
  {
    while (1)
    {
      v6 = v3;
      v3 = (_QWORD *)*v3;
      result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v6);
      if ((result & 0x80000000) != 0)
        break;
      if (!v3)
        goto LABEL_6;
    }
  }
  else
  {
    result = 0;
LABEL_6:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntdata_WritePhonEle(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, int a5, unsigned __int8 a6, unsigned __int8 a7)
{
  uint64_t result;
  unsigned __int8 *v15;
  int v16;

  v15 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v15, 0x3E8u);
  if ((result & 0x80000000) == 0)
  {
    v16 = 0;
    *v15 = 0;
    result = AppPhonEleString(a1, a2, (uint64_t)v15, 1000, &v16, a3, a4, a5, a6, a7);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_WString(a1, v15, 1000);
      if ((result & 0x80000000) == 0)
        return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v15);
    }
  }
  return result;
}

uint64_t AppPhonEleString(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int *a5, uint64_t a6, unsigned int a7, int a8, unsigned __int8 a9, unsigned __int8 a10)
{
  int v18;
  int v19;
  unsigned int v20;
  uint64_t result;
  unsigned int v22;
  int v23;
  unsigned __int8 v24;
  char *v25;
  char *v26;
  BOOL v27;
  char *v28;
  BOOL v29;
  uint64_t v30;
  __int16 v31;
  _OWORD v32[6];
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  v33 = 0;
  memset(v32, 0, sizeof(v32));
  v31 = 0;
  v30 = 0;
  v18 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)"{VOC}");
  if (!*(_BYTE *)(a6 + 20))
  {
    v22 = *(__int16 *)(a6 + 24);
    if (v18 == v22 && (v23 = *(__int16 *)(a6 + 26), v23 >= 1))
    {
      LOWORD(v32[0]) = v23;
    }
    else
    {
      if (a8 && *(__int16 *)(a6 + 26) >= 1)
        v22 = *(unsigned __int16 *)(a6 + 26);
      result = mosyntkbsymtab_PhonSymString(a1, a2, v22, (char *)v32, 100);
      if ((result & 0x80000000) != 0)
        return result;
    }
    if (a7 == 10 && LOBYTE(v32[0]) == 123 && BYTE1(v32[0]) == 99)
    {
      v24 = BYTE2(v32[0]) - 48;
      if (BYTE2(v32[0]) >= 0x30u && BYTE2(v32[0]) <= 0x39u)
      {
        if (BYTE3(v32[0]) != 125 || BYTE4(v32[0]))
        {
          if (BYTE3(v32[0]) - 48 > 9 || BYTE4(v32[0]) != 125 || BYTE5(v32[0]))
            return mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
          v24 = BYTE3(v32[0]) + 10 * BYTE2(v32[0]) - 16;
        }
        LOWORD(v32[0]) = v24;
      }
    }
    return mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
  }
  v19 = *(_DWORD *)(a6 + 24);
  if (v19 != 3)
  {
    if (v19 != 2)
    {
      if (v19 == 1)
      {
        v20 = mosyntkbsymtab_SyllSepId(a2);
        result = mosyntkbsymtab_PhonSymString(a1, a2, v20, (char *)v32, 100);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
        if ((result & 0x80000000) != 0)
          return result;
LABEL_52:
        if (a7 && a7 != 4)
          goto LABEL_54;
LABEL_59:
        if (*(__int16 *)(a6 + 36) <= 0)
          return result;
        goto LABEL_60;
      }
LABEL_51:
      result = 0;
      goto LABEL_52;
    }
    if (!a7)
    {
      v25 = " ";
LABEL_58:
      result = mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v25, 0, &v29);
      if ((result & 0x80000000) != 0)
        return result;
      goto LABEL_59;
    }
    if (a7 != 1)
    {
      if (a7 == 4)
      {
        v25 = " | ";
        goto LABEL_58;
      }
      if (a7 != 10)
      {
        if (a7 == 5)
        {
          result = mosyntbase_CApp(a3, a4, a5, " {#WB} ", 0, &v29);
          if ((result & 0x80000000) != 0)
            return result;
        }
        else
        {
          result = 0;
        }
LABEL_54:
        v27 = a10 != 0;
        if (a7 != 5 || a10)
          goto LABEL_67;
LABEL_60:
        result = mosyntbase_CApp(a3, a4, a5, "[", 0, &v29);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntpal_IntToString(*(__int16 *)(a6 + 36), 0, v32, 100);
        if ((result & 0x80000000) != 0)
          return result;
        result = mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
        if ((result & 0x80000000) != 0)
          return result;
        v28 = "]";
        return mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v28, 0, &v29);
      }
      v26 = " ";
      goto LABEL_49;
    }
    goto LABEL_47;
  }
  if (a7 > 5 || ((0x31u >> a7) & 1) == 0)
  {
    if (a7 == 10)
    {
      if (!(a10 | a9))
      {
        if (*(__int16 *)(a6 + 28) > 1)
          v26 = " / ";
        else
          v26 = " # ";
LABEL_49:
        result = mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v26, 0, &v29);
        if ((result & 0x80000000) != 0)
          return result;
        goto LABEL_66;
      }
LABEL_65:
      result = 0;
LABEL_66:
      v27 = a10 != 0;
LABEL_67:
      if (a7 != 10 || v27)
        return result;
      if (*(_WORD *)(a6 + 36) && *(__int16 *)(a6 + 36) <= 3)
      {
        v28 = "'";
      }
      else
      {
        if (*(unsigned __int16 *)(a6 + 36) < 4u)
          return result;
        v28 = "'2";
      }
      return mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v28, 0, &v29);
    }
    if (a7 != 1)
      goto LABEL_51;
    if (!*(_DWORD *)(a6 + 32))
      goto LABEL_65;
LABEL_47:
    if (*a5 >= 1)
    {
      v26 = "|";
      goto LABEL_49;
    }
    goto LABEL_65;
  }
  result = mosyntbase_CApp(a3, a4, a5, " #{", 0, &v29);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntpal_IntToString(*(__int16 *)(a6 + 28), 0, v32, 100);
    if ((result & 0x80000000) == 0)
    {
      result = mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v32, 100, &v29);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_CApp(a3, a4, a5, "} ", 0, &v29);
        if ((result & 0x80000000) == 0)
        {
          if (!*(_DWORD *)(a6 + 32))
            goto LABEL_52;
          result = mosyntkbaccphr_PhraseTypeToString(*(_DWORD *)(a6 + 32), (uint64_t)&v30, 10);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_CApp(a3, a4, a5, "(", 0, &v29);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_App(a3, a4, a5, (uint64_t)&v30, 10, &v29);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntbase_CApp(a3, a4, a5, ") ", 0, &v29);
                if ((result & 0x80000000) == 0)
                  goto LABEL_52;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntdata_WritePhonList(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  return mosyntdata_WriteFormattedPhonList(a1, a2, a3, 0, 0);
}

uint64_t mosyntdata_WriteFormattedPhonList(uint64_t a1, uint64_t *a2, _QWORD *a3, unsigned int a4, int a5)
{
  _QWORD *v10;
  uint64_t result;

  if (!a3)
    return 0;
  v10 = a3;
  do
  {
    result = mosyntdata_WritePhonEle(a1, a2, (uint64_t)v10, a4, a5, v10 == a3, *v10 == 0);
    if ((result & 0x80000000) != 0)
      break;
    v10 = (_QWORD *)*v10;
  }
  while (v10);
  return result;
}

uint64_t mosyntdata_PhonListToString(uint64_t a1, uint64_t *a2, int a3, _QWORD *a4, _BYTE *a5, int a6)
{
  unsigned int v11;
  _QWORD *v12;
  uint64_t result;
  int v14;

  v14 = 0;
  *a5 = 0;
  if (!a4)
    return 0;
  if (a3)
    v11 = 10;
  else
    v11 = 0;
  v12 = a4;
  do
  {
    result = AppPhonEleString(a1, a2, (uint64_t)a5, a6, &v14, (uint64_t)v12, v11, 0, v12 == a4, *v12 == 0);
    if ((result & 0x80000000) != 0)
      break;
    v12 = (_QWORD *)*v12;
  }
  while (v12);
  return result;
}

uint64_t mosyntdata_StringToLexPhonList(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, int a4, _QWORD *a5, uint64_t *a6)
{
  uint64_t result;
  __int16 v13;
  uint64_t v14;

  v14 = 0;
  *a5 = 0;
  *a6 = 0;
  result = mosyntknowl_GetPhoneFromString(a1, a2, a3, a4, (int *)&v14, (int *)&v14 + 1);
  if ((result & 0x80000000) == 0)
  {
    v13 = WORD2(v14);
    if (SHIDWORD(v14) >= 1)
    {
      do
      {
        result = mosyntdata_AddPhonEle(a1, a5, a6, 1, v13);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntknowl_GetPhoneFromString(a1, a2, a3, a4, (int *)&v14, (int *)&v14 + 1);
        if ((result & 0x80000000) != 0)
          break;
        v13 = WORD2(v14);
      }
      while (SHIDWORD(v14) > 0);
    }
  }
  return result;
}

uint64_t mosyntdata_StringToPhonoPhonList(uint64_t a1, uint64_t *a2, int a3, unsigned __int8 *a4, int a5, _BYTE *a6, uint64_t a7, _QWORD *a8)
{
  uint64_t PhraseTypeFromString;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t PhraseBoundFromString;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  unsigned __int8 v24;
  int v25;
  uint64_t v27;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;

  v33 = 0;
  v32 = 0;
  v31 = 0;
  *a8 = 0;
  v35 = 0;
  if (a3)
  {
    PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
    if ((PhraseTypeFromString & 0x80000000) != 0)
      return PhraseTypeFromString;
    v13 = v35;
    *(_BYTE *)(v35 + 20) = 1;
    *(_DWORD *)(v13 + 24) = 3;
    *(_WORD *)(v13 + 28) = 0;
    *(_DWORD *)(v13 + 32) = 0;
    *(_WORD *)(v13 + 36) = 0;
  }
  else
  {
    PhraseTypeFromString = 0;
    v13 = 0;
  }
  v14 = 0;
  v15 = 0;
  v34 = 0;
  v16 = *a4;
  v17 = v13;
  while (1)
  {
    if (v16 == 32)
    {
      PhraseTypeFromString = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, &v34);
      if ((PhraseTypeFromString & 0x80000000) != 0)
        return PhraseTypeFromString;
      if (*a8 && v13 != v35)
      {
        PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
        if ((PhraseTypeFromString & 0x80000000) != 0)
          return PhraseTypeFromString;
        v13 = v35;
        *(_BYTE *)(v35 + 20) = 1;
        v20 = 2;
LABEL_18:
        *(_DWORD *)(v13 + 24) = v20;
        *(_WORD *)(v13 + 28) = -1;
        *(_DWORD *)(v13 + 32) = 0;
        *(_WORD *)(v13 + 36) = 0;
        goto LABEL_49;
      }
      goto LABEL_49;
    }
    if (v16 == 35)
    {
      if (a3)
      {
        PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x23u);
        if ((PhraseBoundFromString & 0x80000000) != 0)
          return PhraseBoundFromString;
        v19 = 1;
LABEL_22:
        HIDWORD(v32) = v19;
      }
      else
      {
        PhraseBoundFromString = mosyntknowl_GetPhraseBoundFromString(a1, a4, a5, &v34, (_DWORD *)&v32 + 1);
        if ((PhraseBoundFromString & 0x80000000) != 0)
          return PhraseBoundFromString;
        LOWORD(v19) = WORD2(v32);
        if (!HIDWORD(v32))
        {
          if (v17 && *(_BYTE *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3 && !*(_DWORD *)(v17 + 32))
          {
            LOWORD(v19) = 0;
            *(_DWORD *)(v17 + 32) = 2;
            if (!v15)
              goto LABEL_43;
            goto LABEL_42;
          }
          LOWORD(v19) = 0;
LABEL_41:
          if (!v15)
          {
LABEL_43:
            v13 = v35;
            if (v35 && *(_BYTE *)(v35 + 20) && *(_DWORD *)(v35 + 24) == 2)
            {
              PhraseTypeFromString = 0;
              v15 = 0;
              *(_DWORD *)(v35 + 24) = 3;
              *(_WORD *)(v13 + 28) = v19;
              v17 = v13;
              *(_DWORD *)(v13 + 32) = 0;
            }
            else
            {
              PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
              if ((PhraseTypeFromString & 0x80000000) != 0)
                return PhraseTypeFromString;
              v15 = 0;
              v13 = v35;
              *(_BYTE *)(v35 + 20) = 1;
              *(_DWORD *)(v13 + 24) = 3;
              *(_WORD *)(v13 + 28) = v19;
              *(_DWORD *)(v13 + 32) = 0;
              *(_WORD *)(v13 + 36) = 0;
              v17 = v13;
            }
            goto LABEL_49;
          }
LABEL_42:
          *(_WORD *)(v15 + 36) = 1;
          goto LABEL_43;
        }
      }
      if (v17 && *(_BYTE *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3 && !*(_DWORD *)(v17 + 32))
      {
        *(_DWORD *)(v17 + 32) = 1;
        if (!v15)
          goto LABEL_43;
        goto LABEL_42;
      }
      goto LABEL_41;
    }
    if (!v16)
      break;
    if (a3 && v16 == 47)
    {
      PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x2Fu);
      if ((PhraseBoundFromString & 0x80000000) != 0)
        return PhraseBoundFromString;
      v19 = 2;
      goto LABEL_22;
    }
    if (v16 == 91)
    {
      if (a3)
      {
LABEL_56:
        PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x27u);
        if ((PhraseBoundFromString & 0x80000000) != 0)
          return PhraseBoundFromString;
        if (*a6 && a6[v14] == 49)
          v21 = 3;
        else
          v21 = 2;
        LODWORD(v32) = v21;
        if (v34 < a5 && a4[v34] == 50)
        {
          PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x32u);
          if ((PhraseBoundFromString & 0x80000000) != 0)
            return PhraseBoundFromString;
          v21 = 4;
          LODWORD(v32) = 4;
        }
      }
      else
      {
        PhraseBoundFromString = mosyntknowl_GetAccentFromString(a1, a4, a5, &v34, &v32);
        if ((PhraseBoundFromString & 0x80000000) != 0)
          return PhraseBoundFromString;
        v21 = v32;
      }
      if (v13 && *(_BYTE *)(v13 + 20))
        *(_WORD *)(v13 + 36) = v21;
      PhraseTypeFromString = 0;
      if (v21 == 2)
        v15 = v13;
      goto LABEL_49;
    }
    if (v16 == 40)
    {
      PhraseTypeFromString = mosyntknowl_GetPhraseTypeFromString(a1, a4, a5, &v34, &v31);
      if ((PhraseTypeFromString & 0x80000000) != 0)
        return PhraseTypeFromString;
      if (v17)
        *(_DWORD *)(v17 + 32) = v31;
    }
    else
    {
      if (a3 && v16 == 39)
        goto LABEL_56;
      if (a3)
        v22 = v16 == 46;
      else
        v22 = 0;
      v23 = v22;
      if (v16 == 45 || v23)
      {
        if (a3)
          v24 = 46;
        else
          v24 = 45;
        PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, v24);
        if ((PhraseBoundFromString & 0x80000000) != 0)
          return PhraseBoundFromString;
        PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
        if ((PhraseTypeFromString & 0x80000000) != 0)
          return PhraseTypeFromString;
        v13 = v35;
        v20 = 1;
        *(_BYTE *)(v35 + 20) = 1;
        goto LABEL_18;
      }
      PhraseTypeFromString = mosyntknowl_GetPhoneFromString(a1, a2, a4, a5, &v34, &v33);
      if ((PhraseTypeFromString & 0x80000000) != 0)
        return PhraseTypeFromString;
      if (v33 <= 0)
      {
        v25 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)"{VOC}");
        v33 = v25;
        if (v25 >= 1)
        {
          PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, v25);
          if ((PhraseTypeFromString & 0x80000000) != 0)
            return PhraseTypeFromString;
          *(_WORD *)(v35 + 26) = a4[v14];
        }
        v34 = v14 + 1;
      }
      else
      {
        PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, v33);
        if ((PhraseTypeFromString & 0x80000000) != 0)
          return PhraseTypeFromString;
      }
    }
LABEL_49:
    v16 = 0;
    v14 = v34;
    if (v34 < a5)
      v16 = a4[v34];
  }
  if (a3)
  {
    if (v17 && *(_BYTE *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3 && !*(_DWORD *)(v17 + 32))
      *(_DWORD *)(v17 + 32) = 2;
    if (v15)
      *(_WORD *)(v15 + 36) = 1;
    PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
    if ((PhraseTypeFromString & 0x80000000) == 0)
    {
      v27 = v35;
      *(_BYTE *)(v35 + 20) = 1;
      *(_DWORD *)(v27 + 24) = 3;
      *(_WORD *)(v27 + 28) = 0;
      *(_DWORD *)(v27 + 32) = 0;
      *(_WORD *)(v27 + 36) = 0;
    }
  }
  return PhraseTypeFromString;
}

uint64_t mosyntdata_NewCommand(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;

  result = mosyntpal_ALLOCATE(a1, a2, 0x88u);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)*a2 = 0;
    v4 = *a2;
    *(_QWORD *)(v4 + 20) = 0;
    *(_QWORD *)(v4 + 12) = 0;
    *(_BYTE *)(v4 + 36) = 0;
    *(_QWORD *)(v4 + 28) = 0;
  }
  return result;
}

uint64_t mosyntdata_GetPunctFromCommandList(uint64_t a1, uint64_t *a2, _DWORD *a3, _QWORD *a4)
{
  int v4;

  if (a2)
  {
    while (*((_DWORD *)a2 + 2))
    {
      a2 = (uint64_t *)*a2;
      if (!a2)
        goto LABEL_4;
    }
    v4 = *((_DWORD *)a2 + 3);
  }
  else
  {
LABEL_4:
    v4 = 0;
  }
  *a3 = v4;
  *a4 = a2;
  return 0;
}

uint64_t mosyntdata_DisposeCommandList(uint64_t a1, _QWORD **a2)
{
  _QWORD *v3;
  uint64_t result;
  _QWORD *v6;

  v3 = *a2;
  if (*a2)
  {
    while (1)
    {
      v6 = v3;
      v3 = (_QWORD *)*v3;
      result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v6);
      if ((result & 0x80000000) != 0)
        break;
      if (!v3)
        goto LABEL_6;
    }
  }
  else
  {
    result = 0;
LABEL_6:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntdata_WriteCommandList(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  uint64_t v6;
  char *v7;
  unsigned __int8 *v8;
  int v9;
  BOOL v10;
  _OWORD v11[6];
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v8, 0x3E8u);
  if ((result & 0x80000000) == 0)
  {
    v9 = 0;
    *v8 = 0;
    v5 = v8;
    if (a2)
    {
      v10 = 0;
      memset(v11, 0, sizeof(v11));
      v12 = 0;
      while (1)
      {
        result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, "<", 0, &v10);
        if ((result & 0x80000000) != 0)
          break;
        switch(*((_DWORD *)a2 + 2))
        {
          case 0:
            v6 = (uint64_t)v5;
            v7 = "PUNCT";
            break;
          case 1:
            v6 = (uint64_t)v5;
            v7 = "SPEED";
            break;
          case 2:
            v6 = (uint64_t)v5;
            v7 = "PITCH";
            break;
          case 3:
            v6 = (uint64_t)v5;
            v7 = "VOLUME";
            break;
          case 4:
            v6 = (uint64_t)v5;
            v7 = "SYMBOLICSIL";
            break;
          case 5:
            v6 = (uint64_t)v5;
            v7 = "PROSDOMAIN";
            break;
          default:
            v6 = (uint64_t)v5;
            v7 = "?XXX;";
            break;
        }
        result = mosyntbase_CApp(v6, 1000, &v9, (unsigned __int8 *)v7, 0, &v10);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, ";", 0, &v10);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntpal_IntToString(*((_DWORD *)a2 + 3), 0, v11, 100);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, (unsigned __int8 *)v11, 100, &v10);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, ";", 0, &v10);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, (unsigned __int8 *)a2 + 36, 100, &v10);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, ">", 0, &v10);
        if ((result & 0x80000000) != 0)
          break;
        a2 = (uint64_t *)*a2;
        if (!a2)
        {
          v5 = v8;
          goto LABEL_22;
        }
      }
    }
    else
    {
LABEL_22:
      result = mosyntbase_WString(a1, v5, 1000);
      if ((result & 0x80000000) == 0)
        return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v8);
    }
  }
  return result;
}

uint64_t mosyntdata_GetNilLexItem(uint64_t a1)
{
  uint64_t result;

  result = mosyntkblex_GetNilEntry();
  if ((result & 0x80000000) == 0)
    *(_DWORD *)(a1 + 24) = 0;
  return result;
}

BOOL mosyntdata_IsValidLexItem(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) && mosyntkblex_IsValidEntry() != 0;
}

BOOL mosyntdata_IdenticalLexItems(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24) && mosyntkblex_IdenticalEntries() != 0;
}

uint64_t mosyntdata_GetFirstLexItem(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, int a5, int *a6, _BYTE *a7, uint64_t a8)
{
  *a6 = 0;
  return mosyntdata_GetNextLexItem(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t mosyntdata_GetNextLexItem(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, int a5, int *a6, _BYTE *a7, uint64_t a8)
{
  uint64_t NilEntry;
  int *v17;
  uint64_t SepPartStr;
  int v19;
  __int128 v20;
  BOOL v22;
  _OWORD v23[12];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  *a7 = 0;
  NilEntry = mosyntkblex_GetNilEntry(a8);
  if ((NilEntry & 0x80000000) != 0)
    return NilEntry;
  v22 = 0;
  memset(v23, 0, sizeof(v23));
  v24 = 0;
  *(_DWORD *)(a8 + 24) = 0;
  v17 = (int *)(a8 + 24);
  SepPartStr = mosyntbase_GetSepPartStr(a4, a5, a6, 0x5Cu, v23, 200, (char *)&v22);
  if ((SepPartStr & 0x80000000) == 0)
  {
    if (!v22)
    {
      *v17 = 0;
      return SepPartStr;
    }
    if (LOBYTE(v23[0]) - 48 > 9)
    {
      SepPartStr = mosyntkbsymtab_ConsFeatToComprConsFeatStr((uint64_t)v23, 200);
      if ((SepPartStr & 0x80000000) != 0)
        return SepPartStr;
      v19 = mosyntkbsymtab_KnownConsId(a1, a2, (uint64_t)v23);
      *v17 = v19;
    }
    else
    {
      SepPartStr = mosyntpal_StringToInt((uint64_t)v23, 200, (int *)(a8 + 24), &v22);
      if ((SepPartStr & 0x80000000) != 0)
        return SepPartStr;
      v19 = *v17;
    }
    if (v19 >= 1)
    {
      v20 = *a3;
      *(_QWORD *)(a8 + 16) = *((_QWORD *)a3 + 2);
      *(_OWORD *)a8 = v20;
      *a7 = 1;
    }
  }
  return SepPartStr;
}

uint64_t mosyntdata_SetLexEleRefCounts(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t *i;
  uint64_t *v4;
  int v5;

  if (a2)
  {
    v2 = a2;
    do
    {
      for (i = (uint64_t *)v2[2]; i; i = (uint64_t *)*i)
        *((_DWORD *)i + 12) = 0;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
    do
    {
      v4 = (uint64_t *)a2[2];
      if (v4)
      {
        while (1)
        {
          v5 = *((_DWORD *)v4 + 12);
          if (v5)
            break;
          *((_DWORD *)v4 + 12) = 1;
          v4 = (uint64_t *)*v4;
          if (!v4)
            goto LABEL_11;
        }
        *((_DWORD *)v4 + 12) = v5 + 1;
      }
LABEL_11:
      a2 = (_QWORD *)*a2;
    }
    while (a2);
  }
  return 0;
}

uint64_t mosyntdata_PruneLexEleBranch(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  result = 0;
  v4 = *a2;
  do
  {
    v5 = v4;
    if (!v4)
      break;
    if (*(_DWORD *)(v4 + 48) != 1)
    {
      --*(_DWORD *)(v4 + 48);
      return result;
    }
    v4 = *(_QWORD *)v4;
    result = mosyntpal_DEALLOCATE(a1, &v5);
  }
  while ((result & 0x80000000) == 0);
  return result;
}

uint64_t RemoveInitSubstr(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;
  int v7;
  char v8;
  int v9;

  v9 = 0;
  v8 = 0;
  result = mosyntbase_FindSubstring(a1, 10, a2, a3, 0, &v9);
  if ((result & 0x80000000) == 0 && !v9)
  {
    v7 = mosyntbase_Length(a1, 10);
    return mosyntbase_RemoveSubstring(0, v7, a2, a3, &v8);
  }
  return result;
}

uint64_t mosyntdata_LexEleListToPhonString(uint64_t a1, uint64_t *a2, unsigned int a3, _QWORD *a4, uint64_t a5, int a6)
{
  uint64_t result;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  _QWORD v22[3];
  _QWORD v23[3];
  _OWORD v24[62];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  memset(v24, 0, 512);
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v17 = 0;
  v18 = 0;
  result = mosyntkbsymtab_DecompressCons(a1, a2, a3, &v19, (__int16 *)v22);
  if ((result & 0x80000000) == 0)
  {
    result = AppAddPhonString(a1, a2, v19, (__int16 *)v22, 1, a5, a6, &v18);
    if ((result & 0x80000000) == 0)
    {
      if (a4)
      {
        v12 = 0;
        do
        {
          v13 = v12;
          v12 = a4;
          a4 = (_QWORD *)*a4;
          *v12 = v13;
        }
        while (a4);
        v14 = v12;
        while (1)
        {
          result = mosyntkbsymtab_DecompressCons(a1, a2, *((_DWORD *)v14 + 8), (_DWORD *)&v19 + 1, (__int16 *)v23);
          if ((result & 0x80000000) != 0)
            break;
          result = AppAddPhonString(a1, a2, SHIDWORD(v19), (__int16 *)v23, 1, a5, a6, &v18);
          if ((result & 0x80000000) != 0)
            break;
          result = mosyntkblex_GetEntryPhon(a1, v14 + 1, v24, 1000);
          if ((result & 0x80000000) != 0)
            break;
          m2__cp__str("[SVOX]", &v20, 10);
          result = RemoveInitSubstr((uint64_t)&v20, (uint64_t)v24, 1000);
          if ((result & 0x80000000) != 0)
            break;
          result = mosyntbase_App(a5, a6, &v18, (uint64_t)v24, 1000, &v17);
          if ((result & 0x80000000) != 0)
            break;
          result = AppAddPhonString(a1, a2, SHIDWORD(v19), (__int16 *)v23, 0, a5, a6, &v18);
          if ((result & 0x80000000) != 0)
            break;
          v14 = (_QWORD *)*v14;
          if (!v14)
          {
            v15 = 0;
            do
            {
              v16 = v12;
              v12 = (_QWORD *)*v12;
              *v16 = v15;
              v15 = v16;
            }
            while (v12);
            return AppAddPhonString(a1, a2, v19, (__int16 *)v22, 0, a5, a6, &v18);
          }
        }
      }
      else
      {
        return AppAddPhonString(a1, a2, v19, (__int16 *)v22, 0, a5, a6, &v18);
      }
    }
  }
  return result;
}

uint64_t AppAddPhonString(uint64_t a1, uint64_t *a2, int a3, __int16 *a4, int a5, uint64_t a6, int a7, int *a8)
{
  uint64_t result;
  BOOL v14;
  _OWORD v15[2];
  _QWORD v16[2];
  uint64_t v17;
  _OWORD v18[6];
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v16[1] = 0;
  v17 = 0;
  v16[0] = 0;
  memset(v15, 0, sizeof(v15));
  v19 = 0;
  memset(v18, 0, sizeof(v18));
  v14 = 0;
  for (result = GetFirstAddPhon(a1, (uint64_t)a2, a5, a3, a4, v16, (uint64_t)v15, (int *)&v17 + 1);
        (result & 0x80000000) == 0;
        result = mosyntkbsymtab_GetFeatMatchedNextIntPropVal((uint64_t)v16, (uint64_t)v15, (int *)&v17 + 1))
  {
    if (v17 < 0)
      break;
    result = mosyntkbsymtab_PhonSymString(a1, a2, HIDWORD(v17), (char *)v18, 100);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_App(a6, a7, a8, (uint64_t)v18, 100, &v14);
    if ((result & 0x80000000) != 0)
      break;
  }
  return result;
}

uint64_t mosyntdata_WriteReadingList(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  _QWORD *v3;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t result;

  v3 = *(_QWORD **)(a3 + 16);
  if (!v3)
    return 0;
  do
  {
    v8 = *(_DWORD *)(a3 + 4);
    v7 = *(_DWORD *)(a3 + 8);
    v9 = *(_QWORD *)(a3 + 16);
    result = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WString(a1, "reading from pos ", 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WInt(a1, v8, 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WString(a1, " to pos ", 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WInt(a1, v7, 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WString(a1, ": ", 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntkbsymtab_WriteCons(a1, a2, *(_DWORD *)(v9 + 8));
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WString(a1, " cost ", 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WInt(a1, *(_DWORD *)(v9 + 12), 0);
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WString(a1, "  ", 0);
    if ((result & 0x80000000) != 0)
      break;
    result = WriteLexEleList(a1, *(_QWORD **)(v9 + 16));
    if ((result & 0x80000000) != 0)
      break;
    result = mosyntbase_WLn(a1);
    if ((result & 0x80000000) != 0)
      break;
    v3 = (_QWORD *)*v3;
  }
  while (v3);
  return result;
}

double mosyntdata_NewTermInfo(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  double result;
  _QWORD *v6;
  _QWORD *v7;

  if ((mosyntpal_ALLOCATE(a1, a3, 0x30u) & 0x80000000) == 0)
  {
    *(_QWORD *)*a3 = a2;
    v6 = (_QWORD *)*a3;
    *((_DWORD *)v6 + 2) = -1;
    v6[2] = 0;
    v7 = (_QWORD *)*a3;
    result = NAN;
    v7[3] = 0xFFFFFFFF00000000;
    v7[4] = 0;
    *(_QWORD *)(*a3 + 40) = 0xFFFFFFFF00000000;
  }
  return result;
}

uint64_t mosyntdata_DisposeTermInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;

  if (!*a2)
    return 0;
  v4 = *(_QWORD *)*a2;
  if (!v4)
    return mosyntpal_DEALLOCATE(a1, a2);
  result = mosyntdata_PruneLexEleBranch(a1, (uint64_t *)(v4 + 16));
  if ((result & 0x80000000) == 0)
  {
    result = mosyntpal_DEALLOCATE(a1, (uint64_t *)*a2);
    if ((result & 0x80000000) == 0)
      return mosyntpal_DEALLOCATE(a1, a2);
  }
  return result;
}

double mosyntdata_CopyTermInfo(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  double result;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  __int128 v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;

  if (!a2)
  {
    *a3 = 0;
    return result;
  }
  if ((mosyntpal_ALLOCATE(a1, a3, 0x30u) & 0x80000000) != 0)
    return result;
  v7 = *a2;
  v8 = (uint64_t *)*a3;
  *(_QWORD *)*a3 = 0;
  if (!v7)
    goto LABEL_17;
  v17 = 0;
  v9 = *(uint64_t **)(v7 + 16);
  if (v9)
  {
    v10 = 0;
    v11 = 0;
    while ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v17, 0x38u) & 0x80000000) == 0)
    {
      *v17 = 0;
      v12 = v17;
      if (v10)
      {
        *v10 = v17;
        v12 = v17;
      }
      else
      {
        v11 = v17;
      }
      v13 = *(_OWORD *)(v9 + 1);
      *(_OWORD *)(v12 + 3) = *(_OWORD *)(v9 + 3);
      *(_OWORD *)(v12 + 1) = v13;
      *((_WORD *)v12 + 20) = *((_WORD *)v9 + 20);
      *((_DWORD *)v12 + 12) = 1;
      v9 = (uint64_t *)*v9;
      v10 = v12;
      if (!v9)
        goto LABEL_15;
    }
    return result;
  }
  v11 = 0;
LABEL_15:
  if ((mosyntpal_ALLOCATE(a1, v8, 0x18u) & 0x80000000) == 0)
  {
    *(_QWORD *)*v8 = 0;
    v14 = (_QWORD *)*v8;
    v14[1] = *(_QWORD *)(v7 + 8);
    v14[2] = v11;
LABEL_17:
    v15 = *a3;
    *(_DWORD *)(v15 + 8) = *((_DWORD *)a2 + 2);
    *(_QWORD *)(v15 + 16) = a2[2];
    v16 = *a3;
    *(_QWORD *)(v16 + 24) = a2[3];
    *(_QWORD *)(v16 + 32) = a2[4];
    result = *((double *)a2 + 5);
    *(double *)(*a3 + 40) = result;
  }
  return result;
}

__n128 mosyntdata_NewSyntNode(uint64_t a1, __int16 a2, __n128 *a3, uint64_t *a4)
{
  __n128 result;
  uint64_t v8;
  _QWORD *v9;

  if ((mosyntpal_ALLOCATE(a1, a4, 0x48u) & 0x80000000) == 0)
  {
    *(_QWORD *)*a4 = 0;
    *(_QWORD *)(*a4 + 8) = 0;
    v8 = *a4;
    *(_WORD *)(v8 + 16) = a2;
    result = *a3;
    *(_QWORD *)(v8 + 40) = a3[1].n128_u64[0];
    *(__n128 *)(v8 + 24) = result;
    v9 = (_QWORD *)*a4;
    v9[8] = 0;
    *(_QWORD *)((char *)v9 + 53) = 0;
    v9[6] = 0;
  }
  return result;
}

uint64_t mosyntdata_AppendNode(uint64_t a1, _QWORD *a2, _QWORD **a3, int a4, _QWORD *a5)
{
  _QWORD *v5;

  if (a5)
  {
    if (a4)
    {
      v5 = *a3;
      if (!*a3)
        v5 = a2;
      *v5 = a5;
      goto LABEL_7;
    }
    *a5 = *a2;
    *a2 = a5;
    if (!*a3)
LABEL_7:
      *a3 = a5;
  }
  return 0;
}

void mosyntdata_AddNode(uint64_t a1, _QWORD *a2, _QWORD **a3, int a4, __int16 a5, __n128 *a6)
{
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  v12 = 0;
  mosyntdata_NewSyntNode(a1, a5, a6, (uint64_t *)&v12);
  if ((v9 & 0x80000000) == 0)
  {
    v10 = v12;
    if (v12)
    {
      if (a4)
      {
        v11 = *a3;
        if (!*a3)
          v11 = a2;
        *v11 = v12;
        goto LABEL_9;
      }
      *v12 = *a2;
      *a2 = v10;
      if (!*a3)
LABEL_9:
        *a3 = v10;
    }
  }
}

uint64_t DisposeSyntTreeList(uint64_t a1, _QWORD **a2)
{
  _QWORD *v3;
  uint64_t result;
  _QWORD *v6;
  uint64_t *v7;
  uint64_t v8;
  _QWORD *v9;

  v3 = *a2;
  if (*a2)
  {
    v9 = 0;
    while (1)
    {
      result = DisposeSyntTreeList(a1, v3 + 1);
      if ((result & 0x80000000) != 0)
        break;
      v9 = v3;
      v6 = (_QWORD *)*v3;
      v8 = v3[8];
      v7 = v3 + 8;
      if (v8)
      {
        result = mosyntdata_DisposeTermInfo(a1, v7);
        if ((result & 0x80000000) != 0)
          break;
      }
      result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v9);
      if ((result & 0x80000000) != 0)
        break;
      v3 = v6;
      if (!v6)
        goto LABEL_10;
    }
  }
  else
  {
    result = 0;
LABEL_10:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntdata_WriteReadingStruct(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result;
  int v11;
  int v12;
  _OWORD v13[6];
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  result = mosyntknowl_WriteTraceHeader(a1, a3);
  if ((result & 0x80000000) == 0)
  {
    if (a5 < 1)
    {
LABEL_7:
      v14 = 0;
      memset(v13, 0, sizeof(v13));
      v12 = 0;
      result = mosyntkbsymtab_AppDecomprConsToString(a1, a2, *(_DWORD *)(a4 + 8), (uint64_t)v13, 100, &v12);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, (unsigned __int8 *)v13, 100);
        if ((result & 0x80000000) == 0)
        {
          result = mosyntbase_WString(a1, "  ", 0);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WInt(a1, *(_DWORD *)(a4 + 12), 0);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntbase_WLn(a1);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntbase_WLn(a1);
                if ((result & 0x80000000) == 0)
                  return WriteLexConsList(a1, a2, a3, *(_QWORD *)(a4 + 16), a5 + 2);
              }
            }
          }
        }
      }
    }
    else
    {
      v11 = a5;
      while (1)
      {
        result = mosyntbase_WString(a1, " ", 0);
        if ((result & 0x80000000) != 0)
          break;
        if (!--v11)
          goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t WriteLexConsList(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v7;
  uint64_t result;
  uint64_t v11;
  _QWORD v12[3];
  _OWORD v13[12];
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  v7 = a3;
  result = WriteLexConsList(a1, a2, a3, *(_QWORD *)a4);
  if ((result & 0x80000000) == 0)
  {
    result = mosyntknowl_WriteTraceHeader(a1, v7);
    if ((result & 0x80000000) == 0)
    {
      if (a5 < 1)
      {
LABEL_7:
        v11 = 0;
        memset(v12, 0, sizeof(v12));
        memset(v13, 0, sizeof(v13));
        v14 = 0;
        if (*(_DWORD *)(a4 + 32) && mosyntkblex_IsValidEntry(a4 + 8))
        {
          result = mosyntkbsymtab_DecompressCons(a1, a2, *(_DWORD *)(a4 + 32), &v11, (__int16 *)v12);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntkbsymtab_WriteConsAndFeat(a1, a2, v11, (__int16 *)v12);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, " ", 0);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntkblex_GetEntryGraph(a1, a4 + 8, v13, 200);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, (unsigned __int8 *)v13, 200);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, "  [", 0);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntkblex_GetEntryPhon(a1, a4 + 8, v13, 200);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, (unsigned __int8 *)v13, 200);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WString(a1, "]  ", 0);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntkblex_GetEntryCost(a1, a4 + 8, (char *)&v11 + 4);
          if ((result & 0x80000000) != 0)
            return result;
          result = mosyntbase_WInt(a1, HIDWORD(v11), 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        else
        {
          result = mosyntbase_WString(a1, "NIL", 0);
          if ((result & 0x80000000) != 0)
            return result;
        }
        result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) == 0)
          return mosyntbase_WLn(a1);
        return result;
      }
      while (1)
      {
        result = mosyntbase_WString(a1, " ", 0);
        if ((result & 0x80000000) != 0)
          break;
        if (!--a5)
          goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t mosyntdata_WriteTree(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  return WriteTree1(a1, a2, a3, a4, 0);
}

uint64_t WriteTree1(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t result;
  int v12;
  uint64_t v13;

  if (!a4)
    return 0;
  v6 = a4;
  v10 = (a5 + 2);
  while (1)
  {
    result = mosyntknowl_WriteTraceHeader(a1, a3);
    if ((result & 0x80000000) != 0)
      return result;
    v12 = a5;
    if (a5 >= 1)
    {
      do
      {
        result = mosyntbase_WString(a1, " ", 0);
        if ((result & 0x80000000) != 0)
          return result;
      }
      while (--v12);
    }
    result = mosyntkbsymtab_WriteConsAndFeat(a1, a2, *((__int16 *)v6 + 8), (__int16 *)v6 + 12);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WString(a1, "  ", 0);
    if ((result & 0x80000000) != 0)
      return result;
    result = mosyntbase_WInt(a1, *((_DWORD *)v6 + 12), 0);
    if ((result & 0x80000000) != 0)
      return result;
    if (*((_BYTE *)v6 + 60))
    {
      result = mosyntbase_WString(a1, "  @@", 0);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0)
        return result;
      v13 = v6[8];
      if (v13)
      {
        result = WriteTermInfo(a1, a2, a3, v13, v10);
        if ((result & 0x80000000) != 0)
          return result;
      }
    }
    else
    {
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0)
        return result;
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0)
        return result;
    }
    result = WriteTree1(a1, a2, a3, v6[1], v10);
    if ((result & 0x80000000) != 0)
      return result;
    v6 = (uint64_t *)*v6;
    if (!v6)
      return 0;
  }
}

uint64_t mosyntdata_EncodeSymbolicValue(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  int v4;

  if (a3)
    v4 = -2147482647;
  else
    v4 = -2147481647;
  *a4 = v4 - a2;
  return 0;
}

uint64_t mosyntdata_AppendItem(uint64_t a1, _QWORD *a2, _QWORD **a3, _QWORD *a4)
{
  _QWORD *v4;

  if (a4)
  {
    *a4 = 0;
    v4 = *a3;
    if (!*a3)
      v4 = a2;
    *v4 = a4;
    *a3 = a4;
  }
  return 0;
}

uint64_t mosyntdata_DisposeItem(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;

  v2 = *a2;
  if (!*a2)
    return 0;
  if (*(_DWORD *)(v2 + 8))
    return mosyntpal_DEALLOCATE(a1, a2);
  mosyntdata_SetLexEleRefCounts(a1, *(_QWORD **)(v2 + 32));
  v5 = *(_QWORD **)(v2 + 32);
  if (!v5)
  {
LABEL_8:
    *(_QWORD *)(v2 + 32) = 0;
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  v7 = 0;
  while (1)
  {
    result = mosyntdata_PruneLexEleBranch(a1, v5 + 2);
    if ((result & 0x80000000) != 0)
      return result;
    v7 = v5;
    v5 = (_QWORD *)*v5;
    result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v7);
    if ((result & 0x80000000) != 0)
      return result;
    if (!v5)
      goto LABEL_8;
  }
}

uint64_t mosyntdata_AddOutItem(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  __int128 v10;
  _QWORD *v11;
  _QWORD *i;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;

  v26 = 0;
  result = mosyntpal_ALLOCATE(a1, &v26, 0x28u);
  if ((result & 0x80000000) != 0)
    return result;
  *(_QWORD *)v26 = 0;
  v9 = v26;
  *(_DWORD *)(v26 + 8) = *(_DWORD *)(a4 + 8);
  if (*(_DWORD *)(a4 + 8))
    goto LABEL_32;
  v10 = *(_OWORD *)(a4 + 16);
  *(_QWORD *)(v9 + 32) = *(_QWORD *)(a4 + 32);
  *(_OWORD *)(v9 + 16) = v10;
  v11 = *(_QWORD **)(a4 + 32);
  if (!v11)
    goto LABEL_30;
  v27 = 0;
  v28 = 0;
  do
  {
    for (i = (_QWORD *)v11[2]; i; i = (_QWORD *)*i)
      i[6] = 0;
    v11 = (_QWORD *)*v11;
  }
  while (v11);
  v13 = *(_QWORD **)(a4 + 32);
  if (!v13)
  {
LABEL_30:
    result = 0;
    v15 = 0;
    v23 = v9;
LABEL_31:
    *(_QWORD *)(v9 + 32) = v15;
    v9 = v23;
LABEL_32:
    *(_QWORD *)v9 = 0;
    v24 = v26;
    if (*a3)
    {
      *(_QWORD *)*a3 = v26;
      v24 = v26;
    }
    else
    {
      *a2 = v26;
    }
    *a3 = v24;
    return result;
  }
  v14 = 0;
  v15 = 0;
  while (1)
  {
    result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v28, 0x18u);
    if ((result & 0x80000000) != 0)
      return result;
    *v28 = 0;
    if (v14)
    {
      *v14 = v28;
      v14 = v28;
    }
    else
    {
      v14 = v28;
      v15 = v28;
    }
    v14[1] = v13[1];
    v16 = (uint64_t *)v13[2];
    if (v16)
    {
      v18 = v16 + 6;
      v17 = v16[6];
      if (!v17)
      {
        v25 = v15;
        v19 = 0;
        while (1)
        {
          result = mosyntpal_ALLOCATE(a1, &v27, 0x38u);
          if ((result & 0x80000000) != 0)
            return result;
          v20 = v27;
          v21 = *(_OWORD *)(v16 + 3);
          *(_OWORD *)(v27 + 8) = *(_OWORD *)(v16 + 1);
          *(_OWORD *)(v20 + 24) = v21;
          *(_WORD *)(v20 + 40) = *((_WORD *)v16 + 20);
          *(_QWORD *)v20 = 0;
          if (v19)
          {
            *v19 = v27;
            v19 = (_QWORD *)v27;
          }
          else
          {
            v19 = (_QWORD *)v27;
            v17 = v27;
          }
          *v18 = v19;
          v16 = (uint64_t *)*v16;
          if (!v16)
            goto LABEL_27;
          v18 = v16 + 6;
          v22 = v16[6];
          if (v22)
          {
            if (v19)
              *v19 = v22;
            else
              v17 = v16[6];
LABEL_27:
            v15 = v25;
            break;
          }
        }
      }
    }
    else
    {
      v17 = 0;
    }
    v28[2] = v17;
    v13 = (_QWORD *)*v13;
    if (!v13)
    {
      v23 = v26;
      goto LABEL_31;
    }
  }
}

uint64_t GetFirstAddPhon(uint64_t a1, uint64_t a2, int a3, int a4, __int16 *a5, _WORD *a6, uint64_t a7, int *a8)
{
  uint64_t v8;

  *a6 = *a5;
  if (*a5 >= 1)
  {
    v8 = 1;
    do
      a6[v8] = a5[v8];
    while (v8++ < *a5);
  }
  return mosyntkbsymtab_GetFeatMatchedFirstIntPropVal(a1, a2, a4, (uint64_t)a6, a3 == 0, a7, a8);
}

uint64_t mosyntdata_GenWordPhono(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, uint64_t a5, __int16 a6, _QWORD *a7, uint64_t *a8)
{
  uint64_t *v11;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  __int16 v19;
  int v20;

  *a7 = 0;
  *a8 = 0;
  if (a3)
  {
    v11 = a3;
    v14 = 0;
    while (1)
    {
      if (*((_BYTE *)v11 + 20))
      {
        v15 = mosyntbase_WriteDevelMessage(a1, "*** boundary detected in word phoneme list\\n", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
        goto LABEL_5;
      }
      v16 = *((__int16 *)v11 + 12);
      if (mosyntkbsymtab_SyllSepId(a2) == v16)
      {
        v14 = mosyntdata_AddPhonEle(a1, a7, a8, 1, 0);
        if ((v14 & 0x80000000) != 0)
          return v14;
        v17 = *a8;
        *(_BYTE *)(v17 + 20) = 1;
        *(_DWORD *)(v17 + 24) = 1;
        *(_WORD *)(v17 + 28) = -1;
        *(_DWORD *)(v17 + 32) = 0;
        *(_WORD *)(v17 + 36) = 0;
        a5 = *a8;
        goto LABEL_18;
      }
      v18 = *((__int16 *)v11 + 12);
      if (mosyntkbsymtab_PrimAccId(a2) == v18)
      {
        if (a5)
        {
          v19 = a4;
LABEL_17:
          *(_WORD *)(a5 + 36) = v19;
        }
      }
      else
      {
        v20 = *((__int16 *)v11 + 12);
        if (mosyntkbsymtab_SecAccId(a2) != v20)
        {
          v15 = mosyntdata_AddPhonEle(a1, a7, a8, 1, *((_WORD *)v11 + 12));
LABEL_5:
          v14 = v15;
          if ((v15 & 0x80000000) != 0)
            return v14;
          goto LABEL_18;
        }
        if (a4 >= 1 && a5)
        {
          v19 = a6;
          goto LABEL_17;
        }
      }
LABEL_18:
      v11 = (uint64_t *)*v11;
      if (!v11)
        return v14;
    }
  }
  return 0;
}

uint64_t mosyntdata_CreateAndInitSentTermData(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t i;

  result = mosyntpal_ALLOCATE(a1, a2, 0x13890u);
  if ((result & 0x80000000) == 0)
  {
    for (i = 0; i != 80016; i += 16)
    {
      *(_QWORD *)(*a2 + i) = 0;
      *(_QWORD *)(*a2 + i + 8) = 0;
    }
  }
  return result;
}

uint64_t mosyntdata_DisposeSentTermData(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD **v7;
  uint64_t v8;
  uint64_t result;
  _QWORD **v10;
  _QWORD **v11;
  uint64_t v12;

  if (!*a2)
    return 0;
  v4 = 0;
  v11 = 0;
  v12 = 0;
  do
  {
    v5 = *a2;
    v6 = *(_QWORD *)(*a2 + v4);
    v12 = v6;
    if (v6)
    {
      v8 = *(_QWORD *)(v6 + 8);
      v7 = (_QWORD **)(v6 + 8);
      if (v8)
      {
        result = mosyntdata_DisposePhonEleList(a1, v7);
        if ((result & 0x80000000) != 0)
          return result;
      }
      result = mosyntpal_DEALLOCATE(a1, &v12);
      if ((result & 0x80000000) != 0)
        return result;
      v5 = *a2;
    }
    v10 = *(_QWORD ***)(v5 + v4 + 8);
    v11 = v10;
    if (v10)
    {
      if (*v10)
      {
        result = mosyntdata_DisposeCommandList(a1, v10);
        if ((result & 0x80000000) != 0)
          return result;
      }
      result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v11);
      if ((result & 0x80000000) != 0)
        return result;
    }
    v4 += 16;
  }
  while (v4 != 80016);
  return mosyntpal_DEALLOCATE(a1, a2);
}

double mosyntdata_AssertBoundPosData(uint64_t a1, uint64_t a2, unsigned int a3)
{
  double result;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;

  if (a2)
  {
    if (a3 < 0x1389)
    {
      v4 = a2 + 16 * a3;
      v6 = *(_QWORD *)(v4 + 8);
      v5 = (_QWORD *)(v4 + 8);
      if (!v6)
      {
        v9 = 0;
        if ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v9, 0x10u) & 0x80000000) == 0)
        {
          v7 = v9;
          *v5 = v9;
          *v7 = 0;
          *(_QWORD *)&result = 0xFFFFFFFFLL;
          v9[1] = 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      LODWORD(v8) = 0;
      HIDWORD(v8) = a3;
      mosyntbase_WriteMessage(a1, "***** error in asserting word boundary pos; wrong pos: %d\\n",
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        v8);
    }
  }
  return result;
}

double mosyntdata_InsertSentTermWord(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4, int a5, uint64_t a6)
{
  _QWORD *v10;
  double result;
  uint64_t v14;
  int v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  if (a2)
  {
    if (a3 > 0x1388 || a4 < (int)a3 || a4 >= 5001)
    {
      *((_QWORD *)&v17 + 1) = a4;
      LODWORD(v17) = 0;
      DWORD1(v17) = a3;
      mosyntbase_WriteMessage(a1, "***** error in word term insertion; wrong start/end pos: %d/%d\\n",
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        0,
        (unsigned __int8 *)&byte_1DEBD87CE,
        v17);
    }
    else
    {
      v10 = (_QWORD *)(a2 + 16 * a3);
      if (*v10)
      {
        *((_QWORD *)&v16 + 1) = a4;
        LODWORD(v16) = 0;
        DWORD1(v16) = a3;
        mosyntbase_WriteMessage(a1, "***** error in word term insertion; position %d already occupied\\n",
          0,
          (unsigned __int8 *)&byte_1DEBD87CE,
          0,
          (unsigned __int8 *)&byte_1DEBD87CE,
          0,
          (unsigned __int8 *)&byte_1DEBD87CE,
          v16);
      }
      else
      {
        v18 = 0;
        if ((mosyntpal_ALLOCATE(a1, &v18, 0x18u) & 0x80000000) == 0)
        {
          v14 = v18;
          *v10 = v18;
          *(_DWORD *)v14 = a5;
          *(_DWORD *)(v14 + 4) = a4;
          *(_QWORD *)(v14 + 8) = a6;
          *(_DWORD *)(v14 + 16) = 0;
          result = mosyntdata_AssertBoundPosData(a1, a2, a3);
          if ((v15 & 0x80000000) == 0)
            return mosyntdata_AssertBoundPosData(a1, a2, a4);
        }
      }
    }
  }
  return result;
}

void mosyntdata_InsertSentTermPunct(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  int v8;
  _QWORD **v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  if (a2)
  {
    mosyntdata_AssertBoundPosData(a1, a2, a3);
    if (a3 <= 0x1388 && (v8 & 0x80000000) == 0)
    {
      v9 = *(_QWORD ***)(a2 + 16 * a3 + 8);
      if (v9)
      {
        v12 = 0;
        if ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x88u) & 0x80000000) == 0)
        {
          *v12 = 0;
          v10 = v12;
          v12[2] = 0;
          v10[3] = 0;
          v10[1] = 0;
          *(_QWORD *)((char *)v10 + 29) = 0;
          *((_DWORD *)v10 + 3) = a4;
          v11 = *v9;
          if (!*v9)
            goto LABEL_9;
          do
          {
            v9 = (_QWORD **)v11;
            v11 = (_QWORD *)*v11;
          }
          while (v11);
          if (v10)
LABEL_9:
            *v9 = v10;
        }
      }
    }
  }
}

uint64_t mosyntdata_SentTermBoundData(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = 0;
  if (a2)
  {
    if (a3 <= 0x1388)
      return *(_QWORD *)(a2 + 16 * a3 + 8);
  }
  return result;
}

uint64_t mosyntdata_SentTermWordData(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = 0;
  if (a2)
  {
    if (a3 <= 0x1388)
      return *(_QWORD *)(a2 + 16 * a3);
  }
  return result;
}

uint64_t mosyntdata_GetSentTermWordPhonList(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v4;

  *a4 = 0;
  if (a2)
  {
    if (a3 <= 0x1388)
    {
      v4 = *(_QWORD *)(a2 + 16 * a3);
      if (v4)
        *a4 = *(_QWORD *)(v4 + 8);
    }
  }
  return 0;
}

uint64_t mosyntdata_GetSentTermCommList(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  _QWORD *v4;

  *a4 = 0;
  if (a2)
  {
    if (a3 <= 0x1388)
    {
      v4 = *(_QWORD **)(a2 + 16 * a3 + 8);
      if (v4)
        *a4 = *v4;
    }
  }
  return 0;
}

uint64_t mosyntdata_GenPhonoRepr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t result;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v7 = 0;
  result = 0;
  v17 = 0;
  v18 = 0;
  *a4 = 0;
  v9 = (uint64_t *)(a3 + 8);
  v19 = 0;
  v10 = 5001;
  do
  {
    v12 = *(v9 - 1);
    v11 = *v9;
    if (*v9)
    {
      v13 = *(_DWORD *)(v11 + 8);
      if (v13 < 0)
      {
        result = mosyntdata_AddPhonEle(a1, a4, &v19, 1, 0);
        if ((result & 0x80000000) != 0)
          return result;
        v14 = 0;
        v7 = v19;
        *(_BYTE *)(v19 + 20) = 1;
        *(_DWORD *)(v7 + 24) = 2;
        LOWORD(v13) = -1;
      }
      else
      {
        v14 = *(_DWORD *)(v11 + 12);
        result = mosyntdata_AddPhonEle(a1, a4, &v19, 1, 0);
        if ((result & 0x80000000) != 0)
          return result;
        v7 = v19;
        *(_BYTE *)(v19 + 20) = 1;
        *(_DWORD *)(v7 + 24) = 3;
      }
      *(_WORD *)(v7 + 28) = v13;
      *(_DWORD *)(v7 + 32) = v14;
      *(_WORD *)(v7 + 36) = 0;
    }
    if (v12)
    {
      result = mosyntdata_GenWordPhono(a1, a2, *(uint64_t **)(v12 + 8), *(_DWORD *)(v12 + 16), v7, 4, &v18, &v17);
      if ((result & 0x80000000) != 0)
        return result;
      if (v18)
      {
        v15 = v17;
        v16 = a4;
        if (v19 && (v16 = (_QWORD *)v19, !v17))
        {
          result = 0;
        }
        else
        {
          result = 0;
          *v16 = v18;
          v19 = v15;
        }
      }
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
    v9 += 2;
    --v10;
  }
  while (v10);
  return result;
}

uint64_t WriteLexEleList(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  _OWORD v5[12];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  result = WriteLexEleList(a1, *a2);
  if ((result & 0x80000000) == 0)
  {
    v6 = 0;
    memset(v5, 0, sizeof(v5));
    result = mosyntkblex_GetEntryPhon(a1, a2 + 1, v5, 200);
    if ((result & 0x80000000) == 0)
      return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
  }
  return result;
}

uint64_t WriteTermInfo(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t result;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;

  v5 = a5;
  if (*(_QWORD *)a4)
    return WriteLexConsList(a1, a2, a3, *(_QWORD *)(*(_QWORD *)a4 + 16), a5);
  result = mosyntknowl_WriteTraceHeader(a1, a3);
  if ((result & 0x80000000) == 0)
  {
    if (v5 < 1)
    {
LABEL_7:
      if (*(_QWORD *)(a4 + 16))
      {
        result = mosyntbase_WString(a1, "\"", 0);
        if ((result & 0x80000000) != 0)
          return result;
        v9 = *(int *)(a4 + 24);
        if ((int)v9 <= *(_DWORD *)(a4 + 28))
        {
          do
          {
            result = mosyntbase_Wr(a1, *(char *)(*(_QWORD *)(a4 + 16) + v9));
            if ((result & 0x80000000) != 0)
              return result;
            v10 = v9++ < *(int *)(a4 + 28);
          }
          while (v10);
        }
        result = mosyntbase_WString(a1, "\" ", 0);
        if ((result & 0x80000000) != 0)
          return result;
      }
      if (*(_QWORD *)(a4 + 32))
      {
        result = mosyntbase_WString(a1, " [", 0);
        if ((result & 0x80000000) != 0)
          return result;
        v11 = *(int *)(a4 + 40);
        if ((int)v11 <= *(_DWORD *)(a4 + 44))
        {
          do
          {
            result = mosyntbase_Wr(a1, *(char *)(*(_QWORD *)(a4 + 32) + v11));
            if ((result & 0x80000000) != 0)
              return result;
            v10 = v11++ < *(int *)(a4 + 44);
          }
          while (v10);
        }
        result = mosyntbase_WString(a1, "] ", 0);
        if ((result & 0x80000000) != 0)
          return result;
      }
      result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) == 0)
        return mosyntbase_WLn(a1);
      return result;
    }
    while (1)
    {
      result = mosyntbase_WString(a1, " ", 0);
      if ((result & 0x80000000) != 0)
        break;
      if (!--v5)
        goto LABEL_7;
    }
  }
  return result;
}

uint64_t kblexXX_StartLookup(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = a1;
  if (*(_BYTE *)(a1 + 260))
    *(_DWORD *)(a2 + 8) = 1;
  else
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 264);
  *(_DWORD *)(a2 + 16) = 0;
  return 0;
}

uint64_t kblexXX_LookupChar(unsigned __int8 a1, int *a2, _BYTE *a3)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  _BOOL4 v15;
  int v16;
  BOOL v17;
  unsigned __int8 *v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;

  v5 = a1;
  v6 = *(_QWORD *)a2;
  if (!*(_BYTE *)(*(_QWORD *)a2 + 260))
  {
    v10 = *((_QWORD *)a2 + 1);
    v11 = a2[4];
    *a3 = 0;
    if (*(_BYTE *)(v10 + v11))
    {
      if (*(unsigned __int8 *)(v10 + v11) == v5)
      {
        *a3 = 1;
        v12 = v11 + 1;
LABEL_8:
        result = 0;
        a2[4] = v12;
        return result;
      }
    }
    else
    {
      v19 = *(unsigned __int8 **)(v10 + 16);
      if (v19)
      {
        while (1)
        {
          v20 = *v19;
          if (v20 >= v5)
            break;
          v19 = (unsigned __int8 *)*((_QWORD *)v19 + 3);
          if (!v19)
            return 0;
        }
        if (v20 == v5)
        {
          v12 = 1;
          *a3 = 1;
          *((_QWORD *)a2 + 1) = v19;
          goto LABEL_8;
        }
      }
    }
    return 0;
  }
  v27 = 0;
  v22 = 0;
  v7 = a2[4];
  result = DecomprNode(v6, a2[2], &v28, &v27, &v22, &v26);
  *a3 = 0;
  if (*((_BYTE *)&v22 + v7))
  {
    if (*((unsigned __int8 *)&v22 + v7) != v5)
      return result;
    *a3 = 1;
    v9 = v7 + 1;
    goto LABEL_24;
  }
  v25 = 0;
  v21 = 0;
  v13 = v27;
  v14 = *(_QWORD *)a2;
  result = DecomprNodeStart(*(_QWORD *)a2, v27, &v25, &v21);
  v15 = v13 != 0;
  v16 = v21;
  if (v13 && v21 < v5)
  {
    do
    {
      v13 = v25;
      result = DecomprNodeStart(v14, v25, &v25, &v21);
      v15 = v13 != 0;
      v16 = v21;
      if (v13)
        v17 = v21 >= v5;
      else
        v17 = 1;
    }
    while (!v17);
  }
  if (v15 && v16 == v5)
  {
    *a3 = 1;
    if (!BYTE1(v21))
      result = DecomprNode(*(_QWORD *)a2, v13, &v25, &v24, &v21, &v23);
    a2[2] = v13;
    v9 = 1;
LABEL_24:
    a2[4] = v9;
  }
  return result;
}

uint64_t kblexXX_GetFirstEntry(_DWORD *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  int v12;
  int v13;

  v5 = *(_QWORD *)a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 260))
  {
    v11 = 0;
    v6 = a1[2];
    v7 = (int)a1[4];
    DecomprNode(v5, v6, &v13, &v12, &v11, (int *)&v11 + 1);
    if (v6 && !*((_BYTE *)&v11 + v7) && (v10 = HIDWORD(v11)) != 0 && *(_BYTE *)(*(_QWORD *)(v5 + 272) + SHIDWORD(v11)))
    {
      *a2 = 1;
      *(_QWORD *)a3 = v5;
      *(_DWORD *)(a3 + 8) = v10;
      *(_DWORD *)(a3 + 12) = v6;
    }
    else
    {
      *a2 = 0;
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
    }
  }
  else
  {
    v8 = *((_QWORD *)a1 + 1);
    if (v8 && !*(_BYTE *)(v8 + (int)a1[4]) && *(_QWORD *)(v8 + 32))
    {
      *a2 = 1;
      *(_QWORD *)a3 = v5;
      *(_QWORD *)(a3 + 16) = v8;
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(v8 + 32);
    }
    else
    {
      *a2 = 0;
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
    }
  }
  return 0;
}

uint64_t kblexXX_GetNextEntry(BOOL *a1, int *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v11;
  uint64_t v12;

  v3 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    goto LABEL_11;
  if (*(_BYTE *)(v3 + 260))
  {
    v5 = a2[2];
    if (!(_DWORD)v5)
      goto LABEL_12;
    v6 = *(_QWORD *)(v3 + 272);
    if (*(_BYTE *)(v6 + v5))
    {
      v12 = 0;
      v11 = 0;
      v5 = DecomprEntry1(v3, v5, (*(unsigned __int8 *)(v6 + a2[3]) >> 5) & 1, (int *)&v12 + 1, (int *)&v12, &v11);
      v7 = v11;
      a2[2] = v11;
      if (!(_DWORD)v7)
        goto LABEL_10;
      v3 = *(_QWORD *)a2;
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)a2 + 272) + v7))
        goto LABEL_10;
      goto LABEL_12;
    }
LABEL_11:
    v5 = 0;
    goto LABEL_12;
  }
  v8 = (uint64_t *)*((_QWORD *)a2 + 1);
  if (!v8)
    goto LABEL_11;
  v5 = 0;
  v9 = *v8;
  *((_QWORD *)a2 + 1) = v9;
  if (!v9)
  {
LABEL_10:
    v3 = 0;
    *(_QWORD *)a2 = 0;
  }
LABEL_12:
  *a1 = v3 != 0;
  return v5;
}

uint64_t DecomprEntry1(uint64_t a1, int a2, int a3, int *a4, int *a5, int *a6)
{
  int v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  int v16;

  if (a2)
  {
    v16 = a2;
    DecomprNum(*(_QWORD *)(a1 + 272), &v16, a4);
    if (*a4 < 1)
    {
      v11 = 0;
    }
    else
    {
      if (!a3 || (DecomprNum(*(_QWORD *)(a1 + 272), &v16, a5), *a5 <= 0))
        *a5 = 1;
      v11 = v16;
      if ((*(_DWORD *)(a1 + 280) & 0x80000000) != 0)
      {
        v12 = *(_QWORD *)(a1 + 272);
        if (*(_BYTE *)(v12 + v16))
        {
          v13 = (unsigned __int8 *)(v16 + v12 + 1);
          do
          {
            v14 = *v13++;
            ++v11;
          }
          while (v14);
        }
        ++v11;
      }
    }
  }
  else
  {
    v11 = 0;
    *a4 = 0;
  }
  *a6 = v11;
  return 0;
}

uint64_t kblexXX_GetEntryGraph(uint64_t a1, uint64_t *a2, _BYTE *a3, int a4)
{
  uint64_t v4;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  char v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  int v20;
  uint64_t v21;
  int i;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t result;
  uint64_t v31;
  int v32;
  uint64_t v33;
  _BYTE *v34;
  BOOL v35;
  int __dst;

  *a3 = 0;
  v4 = *a2;
  if (!*a2)
    return 0;
  v35 = 0;
  if (!*(_BYTE *)(v4 + 260))
  {
    if (a2[1])
    {
      v21 = a2[2];
      for (i = a4 - 1; v21; v21 = *(_QWORD *)(v21 + 8))
      {
        if (v21 == *(_QWORD *)(v4 + 264))
          break;
        v23 = 0;
        while (*(unsigned __int8 *)(v21 + v23++))
          ;
        if ((_DWORD)v23 != 1)
        {
          v25 = 0;
          do
          {
            a3[i + v25] = *(_BYTE *)(v21 + (v23 + v25 - 2));
            --v25;
          }
          while (v23 + v25 > 1);
          i += v25;
        }
      }
      v26 = a4 - 1 - i;
      if ((int)v26 >= 1)
      {
        v27 = i + 1;
        v28 = v26;
        v29 = a3;
        do
        {
          *v29++ = a3[v27++];
          --v28;
        }
        while (v28);
      }
      result = 0;
      a3[v26] = 0;
      return result;
    }
    return 0;
  }
  if (!*(_BYTE *)(v4 + 264))
    return mosyntbase_CCopy("???", 0, (uint64_t)a3, a4, &v35);
  v6 = *((_DWORD *)a2 + 3);
  v7 = a4 - 1;
  if (v6)
  {
    __dst = 0;
    v8 = a4 - 1;
    while (1)
    {
      v9 = *(_QWORD *)(v4 + 272);
      v10 = *(_BYTE *)(v9 + v6);
      v11 = v6 + 1;
      v12 = v10 & 3;
      if ((v10 & 3) != 0)
      {
        memcpy(&__dst, (const void *)(v9 + v11), v10 & 3);
        v11 += v12;
        v13 = v10 & 3;
      }
      else
      {
        v13 = 0;
      }
      *(_BYTE *)((unint64_t)&__dst | v13) = 0;
      if ((v10 & 4) != 0)
      {
        if (*(char *)(v9 + v11) < 0)
        {
          v14 = (char *)(v9 + v11 + 1);
          do
          {
            v15 = *v14++;
            ++v11;
          }
          while (v15 < 0);
        }
        ++v11;
      }
      v16 = *(unsigned __int8 *)(v9 + v11);
      if (*(char *)(v9 + v11) < 0)
        break;
      v17 = 0;
      if (v12)
        goto LABEL_16;
LABEL_17:
      v6 = v17 + v6 - v16;
      if (!v6)
        goto LABEL_40;
    }
    v18 = 0;
    v19 = (char *)(v9 + v11 + 1);
    do
    {
      v18 = v16 + (v18 << 7) - 128;
      v20 = *v19++;
      v16 = v20;
    }
    while (v20 < 0);
    v17 = -128 * v18;
    if (!v12)
      goto LABEL_17;
LABEL_16:
    memcpy(&a3[v8 + 1 - v12], &__dst, v12);
    v8 -= v12;
    goto LABEL_17;
  }
  v8 = a4 - 1;
LABEL_40:
  v31 = v7 - v8;
  if ((int)v31 >= 1)
  {
    v32 = v8 + 1;
    v33 = v31;
    v34 = a3;
    do
    {
      *v34++ = a3[v32++];
      --v33;
    }
    while (v33);
  }
  result = 0;
  a3[v31] = 0;
  return result;
}

uint64_t kblexXX_GetEntryPhon(uint64_t a1, uint64_t *a2, _BYTE *a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v11;
  char *v12;
  int v13;
  int v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;

  *a3 = 0;
  v4 = *a2;
  if (*a2)
  {
    if (*(_BYTE *)(v4 + 260))
    {
      v5 = *((_DWORD *)a2 + 2);
      if (v5)
      {
        v6 = *(_QWORD *)(v4 + 272);
        v7 = *(unsigned __int8 *)(v6 + v5);
        if (*(char *)(v6 + v5) < 0)
        {
          v11 = 0;
          v12 = (char *)(v5 + v6 + 1);
          do
          {
            v11 = v7 + (v11 << 7) - 128;
            v13 = *v12++;
            v7 = v13;
            ++v5;
          }
          while (v13 < 0);
          v8 = v11 << 7;
        }
        else
        {
          v8 = 0;
        }
        if (v7 + v8 >= 1)
        {
          v14 = v5 + 1;
          if ((*(_BYTE *)(v6 + *((int *)a2 + 3)) & 0x20) != 0)
          {
            if (*(char *)(v6 + v14) < 0)
            {
              v15 = (char *)(v14 + v6 + 1);
              do
              {
                v16 = *v15++;
                ++v14;
              }
              while (v16 < 0);
            }
            ++v14;
          }
          if ((*(_DWORD *)(v4 + 280) & 0x80000000) == 0)
            return mosyntbase_WriteDevelMessage(a1, "***** extern phon string lexica not supported", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
          v17 = 0;
          v18 = v6 + v14;
          do
          {
            v19 = *(unsigned __int8 *)(v18 + v17);
            if (v17 < a4)
              a3[v17] = v19;
            ++v17;
          }
          while (v19);
        }
      }
    }
    else
    {
      v9 = a2[1];
      if (v9)
        return auxkbcommondef_RecallString(a1, *(_QWORD *)(v4 + 280), *(_DWORD *)(v9 + 12), (uint64_t)a3, a4);
    }
  }
  return 0;
}

uint64_t kblexXX_GetEntryCost(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  int v6;

  *a3 = 0;
  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_BYTE *)(result + 260))
    {
      v6 = 0;
      return DecomprEntry1(result, *(_DWORD *)(a2 + 8), (*(unsigned __int8 *)(*(_QWORD *)(result + 272) + *(int *)(a2 + 12)) >> 5) & 1, &v6, a3, &v5);
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 8);
      result = 0;
      if (v4)
        *a3 = *(_DWORD *)(v4 + 16);
    }
  }
  return result;
}

uint64_t kblexXX_GetEntryCostAndConsList(uint64_t a1, uint64_t a2, int *a3, _BYTE *a4, int a5)
{
  uint64_t v7;
  uint64_t v8;
  int v10;
  int v11;

  v10 = 0;
  v7 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_BYTE *)(v7 + 260))
    {
      DecomprEntry1(v7, *(_DWORD *)(a2 + 8), (*(unsigned __int8 *)(*(_QWORD *)(v7 + 272) + *(int *)(a2 + 12)) >> 5) & 1, &v10, a3, &v11);
      LODWORD(v7) = v10;
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 8);
      if (v8)
      {
        LODWORD(v7) = *(_DWORD *)(v8 + 8);
        *a3 = *(_DWORD *)(v8 + 16);
      }
      else
      {
        LODWORD(v7) = 0;
      }
    }
  }
  return mosyntpal_IntToString(v7, 0, a4, a5);
}

uint64_t kblexXX_GetNilEntry(_QWORD *a1)
{
  *a1 = 0;
  return 0;
}

BOOL kblexXX_IsValidEntry(_QWORD *a1)
{
  return *a1 != 0;
}

BOOL kblexXX_IdenticalEntries(_DWORD *a1, uint64_t a2)
{
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
    return 0;
  if (*(_BYTE *)(*(_QWORD *)a1 + 260))
    return a1[2] == *(_DWORD *)(a2 + 8);
  else
    return *((_QWORD *)a1 + 1) == *(_QWORD *)(a2 + 8);
}

uint64_t DecomprNode(uint64_t a1, int a2, int *a3, int *a4, _BYTE *a5, int *a6)
{
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  _BYTE *v11;
  uint64_t v12;
  char v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  char *v20;
  int v21;
  uint64_t v22;
  char *v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  char *v30;
  int v31;

  if (a2)
  {
    v6 = *(_QWORD *)(a1 + 272);
    v7 = *(unsigned __int8 *)(v6 + a2);
    v8 = a2 + 1;
    v9 = v7 & 3;
    if ((v7 & 3) != 0)
    {
      v10 = (char *)(v6 + v8);
      v8 = a2 + (v7 & 3) + 1;
      v11 = a5;
      v12 = v7 & 3;
      do
      {
        v13 = *v10++;
        *v11++ = v13;
        --v12;
      }
      while (v12);
    }
    else
    {
      v9 = 0;
    }
    a5[v9] = 0;
    if ((v7 & 4) != 0)
    {
      v16 = *(_QWORD *)(a1 + 272);
      v17 = *(unsigned __int8 *)(v16 + v8);
      if (*(char *)(v16 + v8) < 0)
      {
        v19 = 0;
        v20 = (char *)(v8 + v16 + 1);
        do
        {
          v19 = v17 + (v19 << 7) - 128;
          v21 = *v20++;
          v17 = v21;
          ++v8;
        }
        while (v21 < 0);
        v18 = v19 << 7;
      }
      else
      {
        v18 = 0;
      }
      v15 = ++v8 + v18 + v17;
    }
    else
    {
      v15 = 0;
    }
    *a3 = v15;
    if (*(_BYTE *)(a1 + 264))
    {
      v22 = *(_QWORD *)(a1 + 272);
      if (*(char *)(v22 + v8) < 0)
      {
        v23 = (char *)(v8 + v22 + 1);
        do
        {
          v24 = *v23++;
          ++v8;
        }
        while (v24 < 0);
      }
      ++v8;
    }
    if ((v7 & 8) != 0)
    {
      v26 = *(_QWORD *)(a1 + 272);
      v27 = *(unsigned __int8 *)(v26 + v8);
      if (*(char *)(v26 + v8) < 0)
      {
        v29 = 0;
        v30 = (char *)(v8 + v26 + 1);
        do
        {
          v29 = v27 + (v29 << 7) - 128;
          v31 = *v30++;
          v27 = v31;
          ++v8;
        }
        while (v31 < 0);
        v28 = v29 << 7;
      }
      else
      {
        v28 = 0;
      }
      v25 = ++v8 + v28 + v27;
    }
    else
    {
      v25 = 0;
    }
    *a4 = v25;
    v14 = v8 & (v7 << 27 >> 31);
  }
  else
  {
    v14 = 0;
    *a3 = 0;
    *a4 = 0;
    *a5 = 0;
  }
  *a6 = v14;
  return 0;
}

uint64_t DecomprNodeStart(uint64_t a1, int a2, _DWORD *a3, _BYTE *a4)
{
  uint64_t v4;
  char v5;
  int v6;
  uint64_t v7;
  char *v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  char *v16;
  int v17;

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 272);
    v5 = *(_BYTE *)(v4 + a2);
    v6 = a2 + 1;
    v7 = v5 & 3;
    if ((v5 & 3) != 0)
    {
      v8 = (char *)(v4 + v6);
      v6 = a2 + (v5 & 3) + 1;
      v9 = a4;
      v10 = v5 & 3;
      do
      {
        v11 = *v8++;
        *v9++ = v11;
        --v10;
      }
      while (v10);
    }
    else
    {
      v7 = 0;
    }
    a4[v7] = 0;
    if ((v5 & 4) != 0)
    {
      v12 = *(_QWORD *)(a1 + 272);
      v13 = *(unsigned __int8 *)(v12 + v6);
      if (*(char *)(v12 + v6) < 0)
      {
        v15 = 0;
        v16 = (char *)(v6 + v12 + 1);
        do
        {
          v15 = v13 + (v15 << 7) - 128;
          v17 = *v16++;
          v13 = v17;
          ++v6;
        }
        while (v17 < 0);
        v14 = v15 << 7;
      }
      else
      {
        v14 = 0;
      }
      *a3 = v6 + v14 + v13 + 1;
    }
    else
    {
      *a3 = 0;
    }
  }
  else
  {
    *a3 = 0;
    *a4 = 0;
  }
  return 0;
}

uint64_t DecomprNum(uint64_t result, int *a2, _DWORD *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  int v6;

  *a3 = 0;
  v3 = *(unsigned __int8 *)(result + *a2);
  if (*(char *)(result + *a2) < 0)
  {
    do
    {
      *a3 = v3 + (*a3 << 7) - 128;
      v5 = *a2 + 1;
      *a2 = v5;
      v6 = *(char *)(result + v5);
      v3 = *(unsigned __int8 *)(result + v5);
    }
    while (v6 < 0);
    v4 = *a3 << 7;
  }
  else
  {
    v4 = 0;
  }
  *a3 = v4 + v3;
  ++*a2;
  return result;
}

uint64_t mosyntwordpho_LHPlusMapping(uint64_t a1, int a2, uint64_t *a3, int *a4, unsigned __int8 *a5, int a6)
{
  uint64_t v11;
  uint64_t result;
  _QWORD v13[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  unsigned __int8 v23[96];
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*a4 < 2)
    return 0;
  v11 = *(_QWORD *)&a4[2 * (*a4 - 1) + 2];
  if (a2 < 1
    || (result = mosyntknowl_WriteTraceHeader(a1, 3u), (result & 0x80000000) == 0)
    && (result = mosyntbase_WriteMessage(a1, "lhplus mapping input: %s\\n", 0, a5, a6, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0), (result & 0x80000000) == 0))
  {
    v21 = 0;
    v22 = 0;
    memset(v23, 0, sizeof(v23));
    v24 = 0;
    v19 = 0;
    v20 = 0;
    result = mosyntdata_StringToLexPhonList(a1, a3, a5, a6, &v21, &v19);
    if ((result & 0x80000000) == 0)
    {
      result = mosynttrans_InitTransDesc(a1, a2, (uint64_t)a3, &v22);
      if ((result & 0x80000000) == 0)
      {
        m2__cp__str("lhplus mapping", v23, 100);
        v13[0] = 1;
        v13[1] = v11;
        v14 = 0u;
        v15 = 0u;
        v16 = 0u;
        v17 = 0u;
        v18 = 0;
        result = mosynttrans_SeqTransducePhonList(a1, v22, 3u, v21, &v20, (uint64_t)v13, 0, -1, 0xFFFFFFFF, v23, 100);
        if ((result & 0x80000000) == 0)
        {
          result = mosynttrans_FinishTransDesc(a1, &v22);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntdata_PhonListToString(a1, a3, 1, v20, a5, a6);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntdata_DisposePhonEleList(a1, &v21);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntdata_DisposePhonEleList(a1, &v20);
                if (a2 >= 1 && (result & 0x80000000) == 0)
                {
                  result = mosyntknowl_WriteTraceHeader(a1, 3u);
                  if ((result & 0x80000000) == 0)
                    return mosyntbase_WriteMessage(a1, "lhplus mapping output: %s\\n", 0, a5, a6, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntwordpho_ReadingToPhonString(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, _BYTE *a5, int a6)
{
  if (a4)
    return mosyntdata_LexEleListToPhonString(a1, a3, *(_DWORD *)(a4 + 8), *(_QWORD **)(a4 + 16), (uint64_t)a5, a6);
  *a5 = 0;
  return 0;
}

uint64_t mosyntwordpho_TreatSingleReadingString(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6, int a7)
{
  uint64_t result;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  __int128 v21;
  __int128 v22;
  _DWORD *v23;
  _OWORD v24[5];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  _QWORD v30[2];
  _QWORD v31[3];

  v31[2] = *MEMORY[0x1E0C80C00];
  v23 = 0;
  result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v23, 0x68u);
  if ((result & 0x80000000) == 0)
  {
    v15 = (uint64_t)v23;
    *v23 = a2;
    *(_QWORD *)(v15 + 8) = a3;
    v16 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v15 + 16) = *(_OWORD *)a4;
    *(_OWORD *)(v15 + 32) = v16;
    v18 = *(_OWORD *)(a4 + 48);
    v17 = *(_OWORD *)(a4 + 64);
    v19 = *(_OWORD *)(a4 + 32);
    *(_QWORD *)(v15 + 96) = *(_QWORD *)(a4 + 80);
    *(_OWORD *)(v15 + 64) = v18;
    *(_OWORD *)(v15 + 80) = v17;
    *(_OWORD *)(v15 + 48) = v19;
    if (!a5)
      return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v23);
    v29 = 0;
    v30[0] = 0;
    v30[1] = 0;
    v31[0] = 0;
    *(_QWORD *)((char *)v31 + 6) = 0;
    v27 = 0;
    v28 = 0;
    result = mosyntdata_StartPhonList(a1, &v28, &v27);
    if ((result & 0x80000000) == 0)
    {
      v26 = 0;
      result = mosyntdata_StringToLexPhonList(a1, *(uint64_t **)(v15 + 8), a6, a7, &v28, &v27);
      if ((result & 0x80000000) == 0)
      {
        result = mosynttrans_InitTransDesc(a1, *(_DWORD *)v15, *(_QWORD *)(v15 + 8), &v29);
        if ((result & 0x80000000) == 0)
        {
          m2__cp__str("morphophonemic rules", v30, 30);
          v20 = *(_DWORD *)(v15 + 16) - 1;
          v21 = *(_OWORD *)(v15 + 64);
          v24[2] = *(_OWORD *)(v15 + 48);
          v24[3] = v21;
          v24[4] = *(_OWORD *)(v15 + 80);
          v25 = *(_QWORD *)(v15 + 96);
          v22 = *(_OWORD *)(v15 + 32);
          v24[0] = *(_OWORD *)(v15 + 16);
          v24[1] = v22;
          result = mosynttrans_SeqTransducePhonList(a1, v29, 3u, v28, &v26, (uint64_t)v24, 0, v20, 0xFFFFFFFF, (unsigned __int8 *)v30, 30);
          if ((result & 0x80000000) == 0)
          {
            result = mosynttrans_FinishTransDesc(a1, &v29);
            if ((result & 0x80000000) == 0)
            {
              result = mosyntdata_DisposePhonEleList(a1, &v28);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntdata_PhonListToString(a1, *(uint64_t **)(v15 + 8), 1, v26, a6, a7);
                if ((result & 0x80000000) == 0)
                {
                  result = mosyntdata_DisposePhonEleList(a1, &v26);
                  if ((result & 0x80000000) == 0)
                    return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v23);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntwordpho_TraceReading(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5, int a6)
{
  uint64_t result;
  _OWORD v12[12];
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2 < 2)
    return 0;
  result = mosyntknowl_WriteTraceHeader(a1, 3u);
  if ((result & 0x80000000) == 0)
  {
    v13 = 0;
    memset(v12, 0, sizeof(v12));
    result = mosyntkbsymtab_ConsToString(a1, a3, *(_DWORD *)(a4 + 8), (char *)v12, 200);
    if ((result & 0x80000000) == 0)
      return mosyntbase_WriteMessage(a1, "getting internal phon list for word cons %s: %s\\n", 0, (unsigned __int8 *)v12, 200, a5, a6, (unsigned __int8 *)&byte_1DEBD87CE, 0);
  }
  return result;
}

uint64_t mosyntpal_ALLOCATE(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t inited;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v8);
  if ((inited & 0x80000000) == 0)
  {
    v6 = heap_Calloc(*(_QWORD **)(v8 + 8), 1, a3);
    *a2 = v6;
    if (v6)
      return inited;
    else
      return 2371887114;
  }
  return inited;
}

uint64_t mosyntpal_DEALLOCATE(uint64_t a1, uint64_t *a2)
{
  uint64_t inited;
  uint64_t v5;

  v5 = 0;
  inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v5);
  heap_Free(*(_QWORD **)(v5 + 8), *a2);
  *a2 = 0;
  return inited;
}

uint64_t mosyntpal_IntToString(unsigned int a1, uint64_t a2, _BYTE *a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  _BYTE *v9;
  int v10;
  BOOL v11;
  char v13[500];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  LH_itoa(a1, v13, 0xAu);
  v6 = (a4 - 1);
  if (a4 >= 1)
  {
    if (a4 != 1)
    {
      v7 = v6 - 1;
      v8 = v13;
      v9 = a3;
      do
      {
        v10 = *v8++;
        *v9++ = v10;
        if (v10)
          v11 = v7 == 0;
        else
          v11 = 1;
        --v7;
      }
      while (!v11);
    }
    a3[v6] = 0;
  }
  return 0;
}

uint64_t mosyntpal_StringToInt(uint64_t a1, uint64_t a2, int *a3, BOOL *a4)
{
  uint64_t v4;
  int v5;
  int v6;
  int v9;
  uint64_t v10;
  int v11;
  _BOOL4 v12;
  int v13;
  _BOOL8 v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  char *v18;
  int v19;
  int v20;
  int v22;
  BOOL v23;

  v4 = 0;
  do
  {
    v5 = *(char *)(a1 + v4);
    v6 = *(unsigned __int8 *)(a1 + v4++);
  }
  while (v5 <= 32 && v6 != 0);
  if (v6 == 45 || v6 == 43)
    v9 = v4 + 1;
  else
    v9 = v4;
  v10 = (v9 - 1);
  v11 = *(unsigned __int8 *)(a1 + v10);
  v12 = (v11 - 58) < 0xFFFFFFF6;
  if ((v11 - 48) > 9)
  {
    v13 = 0;
  }
  else
  {
    v13 = 0;
    if ((v6 == 43) <= (v6 == 45))
      v14 = v6 == 45;
    else
      v14 = v6 == 43;
    v15 = v14 + v4;
    do
    {
      v16 = v11 + 10 * v13 - 48;
      v17 = v16 < v13;
      if (v16 > v13)
        v13 = v16;
      if (v17)
        v12 = 1;
      v11 = *(unsigned __int8 *)(a1 + v15++);
    }
    while ((v11 - 48) < 0xA);
    v10 = (v15 - 1);
  }
  v18 = (char *)(a1 + v10);
  do
  {
    v20 = *v18++;
    v19 = v20;
  }
  while (v20 <= 32 && v19 != 0);
  if (v6 == 45)
    v22 = -v13;
  else
    v22 = v13;
  v23 = (v12 | v19) == 0;
  if (!v23)
    v22 = 0;
  *a4 = v23;
  *a3 = v22;
  return 0;
}

uint64_t mosyntpal_WriteChar(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t inited;
  int v8;
  uint64_t v10;

  v10 = 0;
  if (!a1)
    return 0;
  inited = InitRsrcFunction(*(_WORD **)a1, *(_QWORD *)(a1 + 8), &v10);
  if ((inited & 0x80000000) == 0)
  {
    if (a2 == 10)
    {
      *(_BYTE *)(a1 + 16 + *(int *)(a1 + 1020)) = 0;
      log_OutText(*(_QWORD *)(v10 + 32), (uint64_t)"FE_MOSYNT", 0, 0, (uint64_t)"%s", v4, v5, v6, a1 + 16);
      *(_DWORD *)(a1 + 1020) = 0;
    }
    else
    {
      v8 = *(_DWORD *)(a1 + 1020);
      if (v8 == 1000)
      {
        *(_BYTE *)(a1 + 1016) = 0;
        log_OutText(*(_QWORD *)(v10 + 32), (uint64_t)"FE_MOSYNT", 0, 0, (uint64_t)"%s", v4, v5, v6, a1 + 16);
        v8 = 0;
        *(_DWORD *)(a1 + 1020) = 0;
      }
      *(_BYTE *)(a1 + v8 + 16) = a2;
      ++*(_DWORD *)(a1 + 1020);
    }
  }
  return inited;
}

uint64_t mosyntpal_WriteString(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v5;
  char v6;
  int v7;

  if (a3 >= 1)
  {
    v5 = a3;
    do
    {
      v7 = *a2++;
      v6 = v7;
      if (!v7)
        break;
      mosyntpal_WriteChar(a1, v6);
      --v5;
    }
    while (v5);
  }
  return 0;
}

uint64_t mosyntpal_WriteLn(uint64_t a1)
{
  mosyntpal_WriteChar(a1, 10);
  return 0;
}

uint64_t mosyntpal_EOL()
{
  return 10;
}

uint64_t wgram_CheckIfExists(_WORD *a1, uint64_t a2, _WORD *a3, int a4, _DWORD *a5)
{
  uint64_t inited;
  _WORD *RsrcHandleForThisApi;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD v25[16];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v24 = 0;
  memset(v25, 0, sizeof(v25));
  v22 = 0;
  *a5 = 0;
  inited = InitRsrcFunction(a1, a2, &v24);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(a3, a4, &v23);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = kbaux_BuildBrokerString(v24, "wgram", (char *)v25, 0x100uLL);
  if ((inited & 0x80000000) != 0)
    return inited;
  RsrcHandleForThisApi = (_WORD *)getRsrcHandleForThisApi(v24, (uint64_t)a1, a2, (uint64_t)a3);
  v13 = wgram_OpenRiffForReading(RsrcHandleForThisApi, v12, (const char *)v25, (uint64_t *)&v22);
  v20 = v13;
  if ((v13 & 0x80000000) == 0)
  {
    *a5 = 1;
    return wgram_CloseRiff(&v22, v13, v14, v15, v16, v17, v18, v19);
  }
  if ((v13 & 0x1FFF) == 0xD || (v13 & 0x1FFF) == 3)
    return 0;
  return v20;
}

uint64_t getRsrcHandleForThisApi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *__s1;

  __s1 = 0;
  if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) == 0
    && __s1
    && *__s1
    && strcmp(__s1, "internal"))
  {
    return a2;
  }
  return a4;
}

uint64_t wgram_LoadData(_WORD *a1, uint64_t a2, _WORD *a3, int a4, _QWORD *a5)
{
  uint64_t inited;
  _WORD *RsrcHandleForThisApi;
  uint64_t v12;
  uint64_t ObjcForThisApi;
  uint64_t AddRefCountedObject;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD v26[16];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v25 = 0;
  memset(v26, 0, sizeof(v26));
  v22 = 0;
  v23 = 0;
  inited = InitRsrcFunction(a1, a2, &v25);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(a3, a4, &v24);
  if ((inited & 0x80000000) != 0)
    return inited;
  if (!a5)
    return 2371887111;
  inited = kbaux_BuildBrokerString(v25, "wgram", (char *)v26, 0x100uLL);
  if ((inited & 0x80000000) != 0)
    return inited;
  RsrcHandleForThisApi = (_WORD *)getRsrcHandleForThisApi(v25, (uint64_t)a1, a2, (uint64_t)a3);
  inited = wgram_OpenRiffForReading(RsrcHandleForThisApi, v12, (const char *)v26, (uint64_t *)&v23);
  if ((inited & 0x80000000) != 0)
    return inited;
  ObjcForThisApi = getObjcForThisApi(v25, v24);
  AddRefCountedObject = objc_GetAddRefCountedObject(ObjcForThisApi, (uint64_t)v26, (uint64_t (*)(_QWORD, _QWORD, uint64_t, __int128 *, uint64_t))wgram_loc_ObjcLoadData, (void (*)(_QWORD, _QWORD, __int128 *))wgram_loc_ObjcUnloadData, (uint64_t)v23, &v22);
  if ((AddRefCountedObject & 0x80000000) == 0)
  {
    *a5 = *(_QWORD *)(v22 + 32);
    return wgram_CloseRiff(&v23, AddRefCountedObject, v15, v16, v17, v18, v19, v20);
  }
  return AddRefCountedObject;
}

uint64_t wgram_loc_ObjcLoadData(_WORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = wgram_ReadFromRiff(a1, a2, a5, (uint64_t *)(a4 + 32));
  if ((v5 & 0x80000000) == 0)
    __strcpy_chk();
  return v5;
}

uint64_t wgram_loc_ObjcUnloadData(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v16 = 0;
  inited = InitRsrcFunction(a1, a2, &v16);
  if ((inited & 0x80000000) != 0)
    return inited;
  v12 = *(_QWORD ***)(a3 + 32);
  if (!v12)
    return 2371887111;
  v13 = v16;
  v14 = wgram_ReleaseData(v12, v5, v6, v7, v8, v9, v10, v11);
  heap_Free(*(_QWORD **)(v13 + 8), (uint64_t)v12);
  return v14;
}

uint64_t wgram_UnloadData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t *a5)
{
  uint64_t result;
  uint64_t ObjcForThisApi;
  uint64_t v10;
  uint64_t v11;

  if (!a5)
    return 2371887111;
  v10 = 0;
  v11 = 0;
  result = InitRsrcFunction(a1, a2, &v11);
  if ((result & 0x80000000) == 0)
  {
    result = InitRsrcFunction(a3, a4, &v10);
    if ((result & 0x80000000) == 0)
    {
      ObjcForThisApi = getObjcForThisApi(v11, v10);
      return objc_ReleaseObject(ObjcForThisApi, *a5);
    }
  }
  return result;
}

uint64_t wgram_GetStartState(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  result = 2371887111;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 256);
    }
  }
  return result;
}

uint64_t wgram_GetFirstTrans(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  int *v14;
  int v15;

  result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    *a4 = -1;
    *a5 = -1;
    *a6 = -1;
    if (a2 < 0)
    {
      return 0;
    }
    else
    {
      v8 = a2 % *(_DWORD *)(a1 + 264);
      v9 = *(_QWORD *)(a1 + 272);
      v10 = *(unsigned int *)(v9 + 4 * v8);
      v11 = *(_DWORD *)(v9 + 4 * (v8 + 1));
      if ((int)v10 >= v11)
      {
LABEL_12:
        result = 0;
        *a3 = v10 + 1;
        a3[1] = v11;
      }
      else
      {
        v12 = *(_QWORD *)(a1 + 280);
        v13 = 0xFFFFFFFC00000000 * v10;
        v14 = (int *)(v12 + 16 * (_DWORD)v10 + 8);
        while (1)
        {
          v15 = *v14;
          v14 += 4;
          LODWORD(v10) = v10 + 1;
          if (v15 == a2)
            break;
          v13 -= 0x400000000;
          if (v11 == (_DWORD)v10)
          {
            LODWORD(v10) = v11;
            goto LABEL_12;
          }
        }
        result = 0;
        *a3 = v10;
        a3[1] = v11;
        *a4 = *(_DWORD *)(v12 + (-(uint64_t)v13 >> 30));
        *a5 = *(_DWORD *)(v12 + ((uint64_t)(0x100000000 - v13) >> 30));
        *a6 = *(_DWORD *)(v12 + (((uint64_t)(0x200000000 - v13) >> 30) | 4));
      }
    }
  }
  return result;
}

uint64_t wgram_GetNextTrans(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t result;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;

  result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    v8 = *a3;
    v9 = a3[1];
    if ((int)v8 >= v9)
    {
LABEL_11:
      *a3 = v8 + 1;
      v14 = -1;
      *a4 = -1;
      *a5 = -1;
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 280);
      v11 = v8 << 34;
      v12 = (int *)(v10 + 16 * (_DWORD)v8 + 8);
      while (1)
      {
        v13 = *v12;
        v12 += 4;
        LODWORD(v8) = v8 + 1;
        if (v13 == a2)
          break;
        v11 += 0x400000000;
        if (v9 == (_DWORD)v8)
        {
          LODWORD(v8) = a3[1];
          goto LABEL_11;
        }
      }
      *a3 = v8;
      *a4 = *(_DWORD *)(v10 + (v11 >> 30));
      *a5 = *(_DWORD *)(v10 + ((v11 >> 30) | 4));
      v14 = *(_DWORD *)(v10 + ((v11 >> 30) | 0xC));
    }
    result = 0;
    *a6 = v14;
  }
  return result;
}

uint64_t wgram_GetFirstEpsTrans(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t v6;
  unsigned int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  int v15;

  v6 = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    v7 = (unsigned int *)(*(_QWORD *)(a1 + 312) + 4 * (a2 % *(_DWORD *)(a1 + 304)));
    v9 = *v7;
    v8 = v7[1];
    if ((int)v9 >= v8)
    {
LABEL_11:
      *a3 = v9 + 1;
      a3[1] = v8;
      v14 = -1;
      *a4 = -1;
      *a5 = 0;
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 320);
      v11 = v9 << 34;
      v12 = (int *)(v10 + 16 * (_DWORD)v9);
      while (1)
      {
        v13 = *v12;
        v12 += 4;
        LODWORD(v9) = v9 + 1;
        if (v13 == a2)
          break;
        v11 += 0x400000000;
        if (v8 == (_DWORD)v9)
        {
          LODWORD(v9) = v8;
          goto LABEL_11;
        }
      }
      *a3 = v9;
      a3[1] = v8;
      v15 = *(_DWORD *)(v10 + ((v11 >> 30) | 4));
      *a4 = v15;
      *a5 = v15 == *(_DWORD *)(a1 + 260);
      v14 = *(_DWORD *)(v10 + ((v11 >> 30) | 0xC));
    }
    v6 = 0;
    *a6 = v14;
  }
  return v6;
}

uint64_t wgram_GetNextEpsTrans(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  int v13;
  int v14;

  v6 = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    v7 = *a3;
    v8 = a3[1];
    if ((int)v7 >= v8)
    {
LABEL_11:
      *a3 = v7 + 1;
      v13 = -1;
      *a4 = -1;
      *a5 = 0;
    }
    else
    {
      v9 = *(_QWORD *)(a1 + 320);
      v10 = v7 << 34;
      v11 = (int *)(v9 + 16 * (_DWORD)v7);
      while (1)
      {
        v12 = *v11;
        v11 += 4;
        LODWORD(v7) = v7 + 1;
        if (v12 == a2)
          break;
        v10 += 0x400000000;
        if (v8 == (_DWORD)v7)
        {
          LODWORD(v7) = a3[1];
          goto LABEL_11;
        }
      }
      *a3 = v7;
      v14 = *(_DWORD *)(v9 + ((v10 >> 30) | 4));
      *a4 = v14;
      *a5 = v14 == *(_DWORD *)(a1 + 260);
      v13 = *(_DWORD *)(v9 + ((v10 >> 30) | 0xC));
    }
    v6 = 0;
    *a6 = v13;
  }
  return v6;
}

uint64_t mosyntkbaccphr_CheckMatchingConsFeat2(uint64_t a1, uint64_t a2, int a3, unsigned int a4, int a5, unsigned __int16 *a6, char *a7)
{
  uint64_t result;
  _QWORD v13[4];

  v13[3] = *MEMORY[0x1E0C80C00];
  memset(v13, 0, 24);
  *a7 = 0;
  GetFeat(a2, a4, v13);
  result = 0;
  if (a3 == a5)
  {
    if (LOWORD(v13[0]))
    {
      return mosyntknowl_CheckUnifiable(a1, (unsigned __int16 *)v13, a6, a7);
    }
    else
    {
      result = 0;
      *a7 = 1;
    }
  }
  return result;
}

uint64_t GetFeat(uint64_t a1, unsigned int a2, _WORD *a3)
{
  uint64_t result;
  __int16 v5;
  int *v6;
  _WORD *v7;
  uint64_t v8;
  int v9;
  _OWORD v10[2];
  uint64_t v11;

  v11 = 0;
  memset(v10, 0, sizeof(v10));
  result = accphr_getFeatList(a1, a2, v10);
  v5 = v10[0];
  if (SLODWORD(v10[0]) >= 1)
  {
    v6 = (int *)v10 + 1;
    v7 = a3 + 1;
    v8 = LODWORD(v10[0]);
    do
    {
      v9 = *v6++;
      *v7++ = v9;
      --v8;
    }
    while (v8);
  }
  *a3 = v5;
  return result;
}

uint64_t mosyntkbaccphr_CheckMatchingConsFeat3(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, int a5, unsigned int a6, char *a7)
{
  uint64_t result;
  _QWORD v13[4];

  v13[3] = *MEMORY[0x1E0C80C00];
  memset(v13, 0, 24);
  *a7 = 0;
  GetFeat(a2, a6, v13);
  result = 0;
  if (a3 == a5)
  {
    if (*a4)
    {
      return mosyntknowl_CheckUnifiable(a1, a4, (unsigned __int16 *)v13, a7);
    }
    else
    {
      result = 0;
      *a7 = 1;
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_GetNodeNegated(uint64_t a1, int a2)
{
  return accphr_getNodeNegated(a1, a2);
}

uint64_t mosyntkbaccphr_GetInstrRight(uint64_t a1, int a2)
{
  return accphr_getInstrRight(a1, a2);
}

uint64_t mosyntkbaccphr_GetRuleSetIsSubset(uint64_t a1, int a2)
{
  return accphr_getRuleSetIsSubset(a1, a2);
}

uint64_t mosyntkbaccphr_LookupAccPhrRule(uint64_t a1, uint64_t a2, int a3, __int16 *a4, _BYTE *a5, uint64_t a6)
{
  int FirstRule;
  uint64_t v13;
  int Rule;
  int Node;
  int v16;
  unsigned int v17;
  char v19;

  FirstRule = accphr_getFirstRule(a2, a3);
  v19 = 0;
  if (FirstRule == accphr_Nil())
  {
    v13 = 0;
LABEL_3:
    if (FirstRule == accphr_Nil())
    {
      *a5 = 0;
    }
    else
    {
      *a5 = 1;
      *(_QWORD *)a6 = a2;
      *(_DWORD *)(a6 + 40) = FirstRule;
      *(_DWORD *)(a6 + 8) = a3;
      return mosyntknowl_CopyFeatList(a4, (_WORD *)(a6 + 16));
    }
  }
  else
  {
    while (1)
    {
      Rule = accphr_getRule(1, a2, FirstRule);
      Node = accphr_getNode(5, a2, Rule);
      v16 = accphr_getRule(1, a2, FirstRule);
      v17 = accphr_getNode(6, a2, v16);
      v13 = mosyntkbaccphr_CheckMatchingConsFeat2(a1, a2, Node, v17, a3, (unsigned __int16 *)a4, &v19);
      if ((v13 & 0x80000000) != 0)
        break;
      if (!v19)
        FirstRule = accphr_getRule(14, a2, FirstRule);
      if (FirstRule == accphr_Nil() || v19)
        goto LABEL_3;
    }
  }
  return v13;
}

uint64_t mosyntkbaccphr_GetNextAccPhrEntry(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  int Rule;
  uint64_t v9;
  int v10;
  int Node;
  int v12;
  unsigned int v13;
  char v15;

  *a3 = 0;
  Rule = accphr_getRule(14, a2, *(_DWORD *)(a4 + 40));
  v15 = 0;
  if (Rule == accphr_Nil())
  {
    v9 = 0;
LABEL_3:
    if (Rule == accphr_Nil())
    {
      *a3 = 0;
    }
    else
    {
      *a3 = 1;
      *(_DWORD *)(a4 + 40) = Rule;
    }
  }
  else
  {
    while (1)
    {
      v10 = accphr_getRule(1, a2, Rule);
      Node = accphr_getNode(5, a2, v10);
      v12 = accphr_getRule(1, a2, Rule);
      v13 = accphr_getNode(6, a2, v12);
      v9 = mosyntkbaccphr_CheckMatchingConsFeat2(a1, a2, Node, v13, *(_DWORD *)(a4 + 8), (unsigned __int16 *)(a4 + 16), &v15);
      if ((v9 & 0x80000000) != 0)
        break;
      if (!v15)
        Rule = accphr_getRule(14, a2, Rule);
      if (Rule == accphr_Nil() || v15)
        goto LABEL_3;
    }
  }
  return v9;
}

uint64_t mosyntkbaccphr_WriteAccPhrNode(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v8;
  char *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int Node;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  char *v17;
  _OWORD v19[6];
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (accphr_getNodeNegated(a3, a4))
  {
    v8 = mosyntbase_Wr(a1, 126);
    if ((v8 & 0x80000000) != 0)
      return v8;
  }
  else
  {
    v8 = 0;
  }
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  switch(accphr_getNode(3, a3, a4))
  {
    case 0u:
      v9 = "?";
      goto LABEL_7;
    case 1u:
      Node = accphr_getNode(4, a3, a4);
      v14 = mosyntkbsymtab_AtomSymString(a1, a2, Node, (char *)v19, 100);
      if ((v14 & 0x80000000) != 0)
        goto LABEL_25;
      v14 = mosyntbase_Wr(a1, 94);
      if ((v14 & 0x80000000) != 0)
        goto LABEL_25;
      v9 = (char *)v19;
      v10 = a1;
      v11 = 100;
LABEL_8:
      v12 = mosyntbase_WString(v10, (unsigned __int8 *)v9, v11);
LABEL_13:
      v8 = v12;
      if ((v12 & 0x80000000) != 0)
        return v8;
LABEL_14:
      if (accphr_getNodeMatchOp(a3, a4) == 6)
      {
        v17 = "*";
      }
      else if (accphr_getNodeMatchOp(a3, a4) == 3)
      {
        v17 = "+";
      }
      else if (accphr_getNodeMatchOp(a3, a4) == 1)
      {
        v17 = "$";
      }
      else
      {
        if (accphr_getNodeMatchOp(a3, a4) != 7)
          return v8;
        v17 = "@";
      }
      v14 = mosyntbase_WString(a1, (unsigned __int8 *)v17, 0);
LABEL_25:
      v8 = v14;
      break;
    case 2u:
      v15 = accphr_getNode(5, a3, a4);
      v16 = accphr_getNode(6, a3, a4);
      v12 = WriteConsFeat1(a1, a2, a3, v15, v16);
      goto LABEL_13;
    case 3u:
      switch(accphr_getNode(7, a3, a4))
      {
        case 1u:
          v9 = "'OBR'";
          break;
        case 2u:
          v9 = "'BOS'";
          break;
        case 3u:
          v9 = "'EOS'";
          break;
        case 4u:
          v9 = "'QOS'";
          break;
        default:
          v9 = "'(unknown property)'";
          break;
      }
LABEL_7:
      v10 = a1;
      v11 = 0;
      goto LABEL_8;
    default:
      goto LABEL_14;
  }
  return v8;
}

uint64_t WriteConsFeat1(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t result;
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  memset(v9, 0, 24);
  GetFeat(a3, a5, v9);
  result = mosyntkbsymtab_WriteCons(a1, a2, a4);
  if ((result & 0x80000000) == 0 && SLOWORD(v9[0]) >= 1)
  {
    result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) == 0)
      return mosyntkbsymtab_WriteFeatList(a1, a2, (__int16 *)v9);
  }
  return result;
}

uint64_t mosyntkbaccphr_WriteRuleHeadline(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  int Rule;
  unsigned int v9;
  unsigned int v10;
  uint64_t result;
  int v12;
  unsigned int Node;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  _OWORD v19[6];
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  Rule = accphr_getRule(0, a3, a4);
  v9 = accphr_getRule(0, a3, a4);
  memset(v19, 0, 32);
  if (Rule >= 0)
    v10 = v9;
  else
    v10 = -v9;
  memset(&v19[2], 0, 64);
  v20 = 0;
  result = mosyntkbsymtab_AtomSymString(a1, a2, v10, (char *)v19, 100);
  if ((result & 0x80000000) == 0)
  {
    if ((int)accphr_getRule(0, a3, a4) < 1)
      result = mosyntbase_WriteMessage(a1, "^%s <== ", 0, (unsigned __int8 *)v19, 100, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    else
      result = mosyntbase_WriteMessage(a1, "^%s <-- ", 0, (unsigned __int8 *)v19, 100, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0);
    if ((result & 0x80000000) == 0)
    {
      v12 = accphr_getRule(1, a3, a4);
      Node = accphr_getNode(5, a3, v12);
      v14 = accphr_getRule(1, a3, a4);
      v15 = accphr_getNode(6, a3, v14);
      result = WriteConsFeat1(a1, a2, a3, Node, v15);
      if ((result & 0x80000000) == 0)
      {
        result = mosyntbase_WString(a1, " [ ", 0);
        if ((result & 0x80000000) == 0)
        {
          v16 = accphr_getRule(2, a3, a4);
          result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v16);
          if ((result & 0x80000000) == 0)
          {
            result = mosyntbase_WString(a1, ", ", 0);
            if ((result & 0x80000000) == 0)
            {
              v17 = accphr_getRule(3, a3, a4);
              result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v17);
              if ((result & 0x80000000) == 0)
              {
                result = mosyntbase_WString(a1, ", ", 0);
                if ((result & 0x80000000) == 0)
                {
                  v18 = accphr_getRule(4, a3, a4);
                  result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v18);
                  if ((result & 0x80000000) == 0)
                    return mosyntbase_WString(a1, " ]", 0);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_WriteChildrenList(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, int a5, int a6)
{
  int v6;
  uint64_t v12;
  uint64_t v13;
  int i;
  int v15;
  int Node;
  int ChildrenOpType;
  uint64_t v18;
  char *v19;
  int Children;
  uint64_t v21;

  v6 = a6;
  if (accphr_Nil() != a6)
  {
    while (1)
    {
      v13 = mosyntbase_WString(a1, a4, a5);
      if ((v13 & 0x80000000) != 0)
        return v13;
      v13 = mosyntbase_WString(a1, "[ ", 0);
      if ((v13 & 0x80000000) != 0)
        return v13;
      for (i = accphr_getChildren(1, a3, v6); ; i = accphr_getNode(8, a3, v15))
      {
        v15 = i;
        if (i == accphr_Nil())
          break;
        v13 = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v15);
        if ((v13 & 0x80000000) != 0)
          return v13;
        Node = accphr_getNode(8, a3, v15);
        if (Node != accphr_Nil())
        {
          v13 = mosyntbase_WString(a1, ", ", 0);
          if ((v13 & 0x80000000) != 0)
            return v13;
        }
      }
      v13 = mosyntbase_WString(a1, " ]", 0);
      if ((v13 & 0x80000000) != 0)
        return v13;
      ChildrenOpType = accphr_getChildrenOpType(a3, v6);
      if (ChildrenOpType == 2)
      {
        v18 = a1;
        v19 = " :FC";
      }
      else
      {
        if (ChildrenOpType != 1)
          goto LABEL_17;
        v18 = a1;
        v19 = " :OL";
      }
      v13 = mosyntbase_WString(v18, (unsigned __int8 *)v19, 0);
      if ((v13 & 0x80000000) != 0)
        return v13;
LABEL_17:
      Children = accphr_getChildren(2, a3, v6);
      if (Children == accphr_Nil())
        v21 = mosyntbase_WLn(a1);
      else
        v21 = mosyntbase_WStringLn(a1, "||", 0);
      v12 = v21;
      if ((v21 & 0x80000000) == 0)
      {
        v6 = accphr_getChildren(2, a3, v6);
        if (v6 != accphr_Nil())
          continue;
      }
      return v12;
    }
  }
  return 0;
}

uint64_t mosyntkbaccphr_WriteInstruction(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  char *v17;
  int Instr;
  int v19;
  int v20;
  int v22;
  char *v23;
  BOOL v24;
  uint64_t v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x1E0C80C00];
  accphr_getInstrType(a3, a4);
  if (accphr_getInstrType(a3, a4) <= 6)
  {
    if (accphr_getInstrTargetRange(a3, a4))
    {
      v8 = (unsigned __int8 *)(accphr_getInstrRight(a3, a4) ? "r_" : "l_");
      v10 = mosyntbase_WString(a1, v8, 0);
      if ((v10 & 0x80000000) != 0)
        return v10;
    }
    if (accphr_getInstrTargetRange(a3, a4) == 2)
    {
      v11 = "syll_";
    }
    else
    {
      if (accphr_getInstrTargetRange(a3, a4) != 3)
        goto LABEL_16;
      if (accphr_getInstr(5, a3, a4) == -1)
      {
        v11 = "prsyll_";
      }
      else if (accphr_getInstr(5, a3, a4))
      {
        v11 = "flsyll_";
      }
      else
      {
        v11 = "ssyll_";
      }
    }
    v10 = mosyntbase_WString(a1, (unsigned __int8 *)v11, 0);
    if ((v10 & 0x80000000) != 0)
      return v10;
LABEL_16:
    v12 = 0;
    v13 = "XL";
    v14 = "L";
    v15 = "H";
    v16 = "XH";
    switch(accphr_getInstrType(a3, a4))
    {
      case 0u:
        if (accphr_getInstr(2, a3, a4))
        {
          v10 = mosyntbase_WString(a1, "br", 0);
          if ((v10 & 0x80000000) != 0)
            return v10;
          v12 = 0;
          v13 = "XW";
          v14 = "W";
          v15 = "S";
        }
        else
        {
          v10 = mosyntbase_WString(a1, "bnd", 0);
          if ((v10 & 0x80000000) != 0)
            return v10;
          v13 = "XW";
          v14 = "W";
          v15 = "S";
          v12 = 1;
        }
        v16 = "XS";
        goto LABEL_27;
      case 2u:
        v17 = "emph";
        goto LABEL_25;
      case 3u:
        v17 = "rate";
        goto LABEL_25;
      case 4u:
        v17 = "pitch";
        goto LABEL_25;
      case 5u:
        v17 = "volume";
        goto LABEL_25;
      case 6u:
        v17 = "stress";
LABEL_25:
        v10 = mosyntbase_WString(a1, (unsigned __int8 *)v17, 0);
        if ((v10 & 0x80000000) != 0)
          return v10;
        v12 = 0;
LABEL_27:
        Instr = accphr_getInstr(0, a3, a4);
        if (Instr != accphr_Nil())
        {
          v19 = accphr_getInstr(0, a3, a4);
          if (accphr_getNode(3, a3, v19))
          {
            v10 = mosyntbase_WString(a1, "(", 0);
            if ((v10 & 0x80000000) != 0)
              return v10;
            v20 = accphr_getInstr(0, a3, a4);
            v10 = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v20);
            if ((v10 & 0x80000000) != 0)
              return v10;
            v10 = mosyntbase_WString(a1, ")", 0);
            if ((v10 & 0x80000000) != 0)
              return v10;
          }
        }
        if ((v12 & 1) != 0)
          return mosyntbase_WString(a1, " = default", 0);
        v25 = 0;
        v26[0] = 0;
        *(_QWORD *)((char *)v26 + 5) = 0;
        v24 = 0;
        v22 = accphr_getInstr(2, a3, a4);
        v23 = "(no value)";
        switch(v22)
        {
          case 0:
            goto LABEL_47;
          case 1:
            v23 = "default";
            goto LABEL_47;
          case 2:
            v23 = (char *)v13;
            goto LABEL_47;
          case 3:
            v23 = (char *)v14;
            goto LABEL_47;
          case 4:
            v23 = "M";
            goto LABEL_47;
          case 5:
            v23 = (char *)v15;
            goto LABEL_47;
          case 6:
            v23 = (char *)v16;
LABEL_47:
            v9 = mosyntbase_CCopy((unsigned __int8 *)v23, 0, (uint64_t)&v25, 21, &v24);
            if ((v9 & 0x80000000) == 0)
              goto LABEL_48;
            return v9;
          default:
            v9 = 0;
LABEL_48:
            if (!accphr_getInstr(2, a3, a4))
              return v9;
            v10 = mosyntbase_WString(a1, " = ", 0);
            if ((v10 & 0x80000000) == 0)
              v10 = mosyntbase_WString(a1, (unsigned __int8 *)&v25, 21);
            break;
        }
        break;
      default:
        goto LABEL_27;
    }
    return v10;
  }
  return 0;
}

uint64_t mosyntkbaccphr_WritePromTemplate(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t result;
  int Children;
  __int128 v10;

  result = mosyntbase_WString(a1, "<prom =", 0);
  if ((result & 0x80000000) == 0)
  {
    Children = accphr_getChildren(1, a3, a4);
    if (Children == accphr_Nil())
    {
      return mosyntbase_WStringLn(a1, " >", 0);
    }
    else
    {
      while (1)
      {
        HIDWORD(v10) = 0;
        LODWORD(v10) = 0;
        *(_QWORD *)((char *)&v10 + 4) = accphr_getNode(2, a3, Children);
        result = mosyntbase_WriteMessage(a1, " [%i] ", 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, v10);
        if ((result & 0x80000000) != 0)
          break;
        result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, Children);
        if ((result & 0x80000000) != 0)
          break;
        Children = accphr_getNode(8, a3, Children);
        if (Children == accphr_Nil())
          return mosyntbase_WStringLn(a1, " >", 0);
      }
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_PhraseTypeToString(int a1, uint64_t a2, int a3)
{
  char *v3;
  BOOL v5;

  v5 = 0;
  if ((a1 - 1) > 8)
    v3 = &byte_1DEBD87CE;
  else
    v3 = off_1EA93ECF0[a1 - 1];
  return mosyntbase_CCopy((unsigned __int8 *)v3, 0, a2, a3, &v5);
}

uint64_t mosyntkbaccphr_StringToPhraseType(uint64_t a1, unsigned __int8 *a2, int a3, int *a4)
{
  int v8;

  if (mosyntbase_CEqual(a2, a3, "P", 0))
  {
    v8 = 1;
LABEL_19:
    *a4 = v8;
    return 0;
  }
  if (mosyntbase_CEqual(a2, a3, "T", 0))
  {
    v8 = 2;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "S", 0))
  {
    v8 = 3;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "Y", 0))
  {
    v8 = 4;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "W", 0))
  {
    v8 = 5;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "AI", 0))
  {
    v8 = 6;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "AM", 0))
  {
    v8 = 7;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "AF", 0))
  {
    v8 = 8;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "E", 0))
  {
    v8 = 9;
    goto LABEL_19;
  }
  return mosyntbase_WriteDevelMessage(a1, "***** illegal phrase type '%s'\\n", 0, a2, a3, (unsigned __int8 *)&byte_1DEBD87CE, 0, (unsigned __int8 *)&byte_1DEBD87CE, 0, 0, 0, 0);
}

uint64_t mosyntkbaccphr_SimplifiedPhraseType(int a1)
{
  if ((a1 - 1) > 8)
    return 0;
  else
    return dword_1DEC65500[a1 - 1];
}

BOOL mosyntkbfst_IsValidPair(_DWORD *a1)
{
  return fst_validPair(a1);
}

uint64_t mosyntkbfst_GetFirstSameInSymPair(__int16 *a1, __int16 a2, uint64_t a3, BOOL *a4)
{
  int v5;

  fst_firstSamePair(a1, a2, a3);
  *a4 = v5 != 0;
  return 0;
}

uint64_t mosyntkbfst_GetNextSameInSymPair(uint64_t a1, int *a2, BOOL *a3)
{
  *a3 = fst_nextSamePair(a1, a2) != 0;
  return 0;
}

uint64_t mosyntkbfst_OutSym(uint64_t a1, _DWORD *a2)
{
  __int16 v3;
  int v4;

  v4 = 0;
  v3 = 0;
  fst_getPair(a1, a2, (_WORD *)&v4 + 1, &v4, &v3);
  return (__int16)v4;
}

uint64_t mosyntkbfst_GetTransductionMode(uint64_t a1, _DWORD *a2)
{
  fst_getTransductionMode(a1, a2);
  return 0;
}

uint64_t mosyntkbfst_WriteGraphPair(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, int a5)
{
  return WritePair(a1, a2, 1, a3, a4, a5);
}

uint64_t WritePair(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, _DWORD *a5, int a6)
{
  uint64_t result;
  char *v11;
  char *v12;
  __int16 v13;
  int v14;

  v14 = 0;
  v13 = 0;
  fst_getPair(a4, a5, (_WORD *)&v14 + 1, &v14, &v13);
  if ((a6 | 2) == 2)
  {
    if (HIWORD(v14))
    {
      result = mosyntbase_WString(a1, "\"", 0);
      if ((result & 0x80000000) != 0)
        return result;
      if (a3)
      {
        result = mosyntkbsymtab_WriteGraphSym(a1, (uint64_t)a2, SHIWORD(v14));
        if ((result & 0x80000000) != 0)
          return result;
      }
      else
      {
        result = mosyntkbsymtab_WritePhonSym(a1, a2, SHIWORD(v14));
        if ((result & 0x80000000) != 0)
          return result;
      }
      v11 = "\"";
    }
    else
    {
      v11 = "@";
    }
    result = mosyntbase_WString(a1, (unsigned __int8 *)v11, 0);
    if ((result & 0x80000000) != 0)
      return result;
  }
  else
  {
    result = 0;
  }
  if (a6 == 2)
  {
    result = mosyntbase_WString(a1, "/", 0);
    if ((result & 0x80000000) != 0)
      return result;
  }
  else if ((a6 - 1) > 1)
  {
    return result;
  }
  if (!(_WORD)v14)
  {
    v12 = "@";
    return mosyntbase_WString(a1, (unsigned __int8 *)v12, 0);
  }
  result = mosyntbase_WString(a1, "\"", 0);
  if ((result & 0x80000000) != 0)
    return result;
  if (!a3)
  {
    result = mosyntkbsymtab_WritePhonSym(a1, a2, (__int16)v14);
    if ((result & 0x80000000) != 0)
      return result;
    goto LABEL_23;
  }
  result = mosyntkbsymtab_WriteGraphSym(a1, (uint64_t)a2, (__int16)v14);
  if ((result & 0x80000000) == 0)
  {
LABEL_23:
    v12 = "\"";
    return mosyntbase_WString(a1, (unsigned __int8 *)v12, 0);
  }
  return result;
}

uint64_t mosyntkbfst_WritePhonPair(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, int a5)
{
  return WritePair(a1, a2, 0, a3, a4, a5);
}

uint64_t mosyntkbsgram_NilIter(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = -1;
  return 0;
}

BOOL mosyntkbsgram_IsNilIter(_QWORD *a1)
{
  return *a1 == 0;
}

uint64_t mosyntkbsgram_StartCons(_DWORD *a1)
{
  unsigned int v2;

  v2 = 0;
  sgram_GetStartCons(a1, &v2);
  return v2;
}

BOOL mosyntkbsgram_HasEmptyRules(_BOOL8 a1)
{
  return sgram_HasEmptyRules(a1);
}

BOOL mosyntkbsgram_HasSimpleFollowRel(_BOOL8 a1)
{
  return sgram_HasSimpleFollowRel(a1);
}

uint64_t mosyntkbsgram_GetNextRuleSameLast(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return sgram_GetNextRuleSameLast(a2, a3, a4, a5, a6);
}

uint64_t mosyntkbsgram_GetNextRuleSameFirst(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return sgram_GetNextRuleSameFirst(a2, a3, a4, a5, a6);
}

uint64_t mosyntkbsgram_GetFirstEmptyRule(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v4;
  int v5;

  v5 = 0;
  v4 = 0;
  sgram_GetFirstEmptyRule(a1, a2, a3, &v5, &v4);
  return 0;
}

uint64_t mosyntkbsgram_GetNextEmptyRule(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v4;
  int v5;

  v5 = 0;
  v4 = 0;
  sgram_GetNextEmptyRule(a2, a3, &v5, &v4);
  return 0;
}

uint64_t mosyntkbsgram_GetRuleFeatLists(uint64_t *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  __int16 v7;
  __int16 v8;
  __int16 v9;
  _QWORD v11[2];
  int v12;
  _QWORD v13[2];
  int v14;
  _QWORD v15[2];
  int v16;

  v15[0] = 0;
  v15[1] = 0;
  v16 = 0;
  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v11[0] = 0;
  v11[1] = 0;
  v12 = 0;
  sgram_GetRuleFeatLists(a1, v15, v13, v11);
  v7 = v15[0];
  if (SLOWORD(v15[0]) >= 1)
    memcpy(a2 + 1, (char *)v15 + 2, 2 * LOWORD(v15[0]));
  *a2 = v7;
  v8 = v13[0];
  if (SLOWORD(v13[0]) >= 1)
    memcpy(a3 + 1, (char *)v13 + 2, 2 * LOWORD(v13[0]));
  *a3 = v8;
  v9 = v11[0];
  if (SLOWORD(v11[0]) >= 1)
    memcpy(a4 + 1, (char *)v11 + 2, 2 * LOWORD(v11[0]));
  *a4 = v9;
  return 0;
}

uint64_t mosyntkbsgram_GetRuleVisAndCost(_DWORD *a1, _BYTE *a2, _DWORD *a3)
{
  int v5;

  v5 = 0;
  sgram_GetRuleVisAndCost(a1, &v5, a3);
  *a2 = v5;
  return 0;
}

BOOL mosyntkbsgram_IsFollowerCons(_BOOL8 a1, int a2, int a3)
{
  return sgram_IsFollowerCons(a1, a2, a3);
}

uint64_t sgram_OpenRiffForReading(_WORD *a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  return ssftriff_reader_ObjOpen(a1, a2, 2, a3, "SGRM", 1031, a4);
}

uint64_t sgram_CloseRiff(_QWORD **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t result;

  v8 = a2;
  if (a1)
  {
    LODWORD(result) = ssftriff_reader_ObjClose(*a1, a2, a3, a4, a5, a6, a7, a8);
    if (v8 >= 0)
      result = result;
    else
      result = v8;
    *a1 = 0;
  }
  else if ((int)a2 < 0)
  {
    return a2;
  }
  else
  {
    return 2371887111;
  }
  return result;
}

uint64_t sgram_ReadFromRiff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int HashTab;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  unsigned int v57;
  int v58;
  unsigned __int8 v59;

  v8 = -1923080188;
  if (!a2)
    return 2371887111;
  result = openChunk(a1, "GRAM", a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) != 0)
    return result;
  v56 = 0;
  v59 = 0;
  v57 = 0;
  v58 = 0;
  HashTab = ssftriff_reader_OpenChunk(a1, &v58, &v57, &v56, v12, v13, v14, v15);
  if (HashTab < 0)
  {
LABEL_18:
    v8 = HashTab;
    goto LABEL_21;
  }
  if (!(v58 ^ 0x53445247 | v59) && v57 == 44)
  {
    v17 = v56;
    *(_DWORD *)a2 = *v56;
    *(_DWORD *)(a2 + 8) = v17[1];
    *(_DWORD *)(a2 + 32) = v17[2];
    *(_DWORD *)(a2 + 56) = v17[3];
    *(_DWORD *)(a2 + 80) = v17[4];
    *(_DWORD *)(a2 + 104) = v17[5];
    *(_DWORD *)(a2 + 128) = v17[6];
    *(_DWORD *)(a2 + 160) = v17[7];
    *(_DWORD *)(a2 + 136) = v17[8];
    *(_DWORD *)(a2 + 208) = v17[9];
    *(_DWORD *)(a2 + 184) = v17[10];
    HashTab = ssftriff_reader_CloseChunk(a1);
    if ((HashTab & 0x80000000) == 0)
    {
      HashTab = detachChunk(a1, "GRFL", (uint64_t *)(a2 + 16), (_QWORD *)(a2 + 24), v18, v19, v20, v21);
      if ((HashTab & 0x80000000) == 0)
      {
        HashTab = detachChunk(a1, "GRER", (uint64_t *)(a2 + 40), (_QWORD *)(a2 + 48), v22, v23, v24, v25);
        if ((HashTab & 0x80000000) == 0)
        {
          HashTab = openChunk(a1, "GRRU", v26, v27, v28, v29, v30, v31);
          if ((HashTab & 0x80000000) == 0)
          {
            v36 = detachChunk(a1, "GRHE", (uint64_t *)(a2 + 64), (_QWORD *)(a2 + 72), v32, v33, v34, v35);
            if ((v36 & 0x80000000) == 0)
            {
              v36 = detachChunk(a1, "GRHS", (uint64_t *)(a2 + 88), (_QWORD *)(a2 + 96), v37, v38, v39, v40);
              if ((v36 & 0x80000000) == 0)
                v36 = detachChunk(a1, "GRHS", (uint64_t *)(a2 + 112), (_QWORD *)(a2 + 120), v41, v42, v43, v44);
            }
            v8 = v36;
            v45 = ssftriff_reader_CloseChunk(a1);
            if (v8 >= 0)
              v8 = v45;
            if (v8 < 0)
              goto LABEL_21;
            HashTab = sgram_ReadHashTab(a1, "GRSE", (uint64_t *)(a2 + 136), v46, v47, v48, v49, v50);
            if ((HashTab & 0x80000000) == 0)
              HashTab = sgram_ReadHashTab(a1, "GRRE", (uint64_t *)(a2 + 184), v51, v52, v53, v54, v55);
          }
        }
      }
    }
    goto LABEL_18;
  }
  ssftriff_reader_CloseChunk(a1);
LABEL_21:
  LODWORD(result) = ssftriff_reader_CloseChunk(a1);
  if (v8 >= 0)
    return result;
  else
    return v8;
}

uint64_t sgram_ReleaseData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _QWORD *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t result;

  if (!a1)
    return 2371887111;
  v16 = ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  v17 = *(_QWORD **)(a1 + 40);
  if (v17)
  {
    v18 = ssftriff_reader_ReleaseChunkData(v17, v9, v10, v11, v12, v13, v14, v15);
    if (v16 >= 0)
      v16 = v18;
  }
  v19 = ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a1 + 64), v9, v10, v11, v12, v13, v14, v15);
  if (v16 >= 0)
    v16 = v19;
  v27 = ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a1 + 88), v20, v21, v22, v23, v24, v25, v26);
  if (v16 >= 0)
    v16 = v27;
  v35 = ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a1 + 112), v28, v29, v30, v31, v32, v33, v34);
  if (v16 >= 0)
    v16 = v35;
  v43 = sgram_ReleaseHashTab(a1 + 136, v36, v37, v38, v39, v40, v41, v42);
  if (v16 >= 0)
    v16 = v43;
  LODWORD(result) = sgram_ReleaseHashTab(a1 + 184, v44, v45, v46, v47, v48, v49, v50);
  if (v16 >= 0)
    return result;
  else
    return v16;
}

uint64_t sgram_ReleaseHashTab(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  unsigned int v12;

  v9 = *(_QWORD **)(a1 + 8);
  if (v9)
    v10 = ssftriff_reader_ReleaseChunkData(v9, a2, a3, a4, a5, a6, a7, a8);
  else
    v10 = 0;
  v11 = *(_QWORD **)(a1 + 32);
  if (v11)
  {
    v12 = ssftriff_reader_ReleaseChunkData(v11, a2, a3, a4, a5, a6, a7, a8);
    if ((int)v10 >= 0)
      return v12;
    else
      return v10;
  }
  return v10;
}

uint64_t openChunk(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v12;
  unsigned int v13;
  char __s1[4];
  char v15;

  v15 = 0;
  v13 = 0;
  *(_DWORD *)__s1 = 0;
  v12 = 0;
  v10 = ssftriff_reader_OpenChunk(a1, __s1, &v13, &v12, a5, a6, a7, a8);
  if ((v10 & 0x80000000) == 0 && strcmp(__s1, a2))
  {
    ssftriff_reader_CloseChunk(a1);
    return 2371887108;
  }
  return v10;
}

uint64_t detachChunk(uint64_t a1, const char *a2, uint64_t *a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v20;
  char __s1[4];
  char v22;

  v22 = 0;
  v20 = 0;
  *(_DWORD *)__s1 = 0;
  v12 = ssftriff_reader_OpenChunk(a1, __s1, &v20, a4, a5, a6, a7, a8);
  if ((v12 & 0x80000000) != 0)
    return v12;
  if (!strcmp(__s1, a2))
  {
    if (!v20)
      return ssftriff_reader_CloseChunk(a1);
    v18 = ssftriff_reader_DetachChunkData(a1, a3, a4, v13, v14, v15, v16, v17);
    v12 = ssftriff_reader_CloseChunk(a1);
    if ((v18 & 0x80000000) != 0)
      return v18;
    return v12;
  }
  ssftriff_reader_CloseChunk(a1);
  return 2371887108;
}

uint64_t sgram_ReadHashTab(uint64_t a1, const char *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;

  result = openChunk(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) == 0)
  {
    v15 = detachChunk(a1, "GRHE", a3 + 1, a3 + 2, v11, v12, v13, v14);
    if ((v15 & 0x80000000) == 0)
      v15 = detachChunk(a1, "GRHS", a3 + 4, a3 + 5, v16, v17, v18, v19);
    v20 = v15;
    LODWORD(result) = ssftriff_reader_CloseChunk(a1);
    if (v20 >= 0)
      return result;
    else
      return v20;
  }
  return result;
}

uint64_t wgram_OpenRiffForReading(_WORD *a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  return ssftriff_reader_ObjOpen(a1, a2, 2, a3, "WGRM", 1031, a4);
}

uint64_t wgram_CloseRiff(_QWORD **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t result;

  v8 = a2;
  if (a1)
  {
    LODWORD(result) = ssftriff_reader_ObjClose(*a1, a2, a3, a4, a5, a6, a7, a8);
    if (v8 < 0)
      result = v8;
    else
      result = result;
    *a1 = 0;
  }
  else if ((int)a2 < 0)
  {
    return a2;
  }
  else
  {
    return 7;
  }
  return result;
}

uint64_t wgram_ReadFromRiff(_WORD *a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t inited;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int HashTab;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v34;
  unsigned int v35;
  int v36;
  unsigned __int8 v37;
  _DWORD *v38;
  unsigned int v39;
  int v40;
  unsigned __int8 v41;

  v34 = 0;
  inited = InitRsrcFunction(a1, a2, &v34);
  if ((inited & 0x80000000) != 0)
    return inited;
  v7 = heap_Calloc(*(_QWORD **)(v34 + 8), 1, 344);
  *a4 = v7;
  if (!v7)
    return 2371887114;
  v12 = v7;
  v37 = 0;
  v35 = 0;
  v36 = 0;
  v17 = ssftriff_reader_OpenChunk(a3, &v36, &v35, 0, v8, v9, v10, v11);
  if ((v17 & 0x80000000) == 0)
  {
    if (!(v36 ^ 0x4741464E | v37))
    {
      v41 = 0;
      v39 = 0;
      v40 = 0;
      v38 = 0;
      HashTab = ssftriff_reader_OpenChunk(a3, &v40, &v39, &v38, v13, v14, v15, v16);
      if ((HashTab & 0x80000000) == 0)
      {
        if (!(v40 ^ 0x5341464E | v41))
        {
          v19 = v38;
          *(_DWORD *)(v12 + 256) = *v38;
          *(_DWORD *)(v12 + 260) = v19[1];
        }
        HashTab = ssftriff_reader_CloseChunk(a3);
        if ((HashTab & 0x80000000) == 0)
        {
          HashTab = wgram_ReadHashTab(a3, v12 + 264, v20, v21, v22, v23, v24, v25);
          if ((HashTab & 0x80000000) == 0)
            HashTab = wgram_ReadHashTab(a3, v12 + 304, v26, v27, v28, v29, v30, v31);
        }
      }
      LODWORD(v17) = HashTab;
    }
    v32 = ssftriff_reader_CloseChunk(a3);
    if ((int)v17 >= 0)
      return v32;
    else
      return v17;
  }
  return v17;
}

uint64_t wgram_ReleaseData(_QWORD **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;

  if (!a1)
    return 2371887111;
  v9 = ssftriff_reader_ReleaseChunkData(a1[36], a2, a3, a4, a5, a6, a7, a8);
  v17 = ssftriff_reader_ReleaseChunkData(a1[37], v10, v11, v12, v13, v14, v15, v16);
  if (v9 >= 0)
    v25 = v17;
  else
    v25 = v9;
  v26 = ssftriff_reader_ReleaseChunkData(a1[41], v18, v19, v20, v21, v22, v23, v24);
  v34 = ssftriff_reader_ReleaseChunkData(a1[42], v27, v28, v29, v30, v31, v32, v33);
  if (v26 >= 0)
    v35 = v34;
  else
    v35 = v26;
  if (v25 >= 0)
    return v35;
  else
    return v25;
}

uint64_t wgram_ReadHashTab(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unsigned __int8 v42;
  _DWORD *v43;
  unsigned int v44;
  int v45;
  unsigned __int8 v46;

  v42 = 0;
  v40 = 0;
  v41 = 0;
  v39 = 0;
  v14 = ssftriff_reader_OpenChunk(a1, &v41, &v40, &v39, a5, a6, a7, a8);
  if ((v14 & 0x80000000) == 0)
  {
    if (!(v41 ^ 0x42544854 | v42))
    {
      v46 = 0;
      v44 = 0;
      v45 = 0;
      v43 = 0;
      v15 = ssftriff_reader_OpenChunk(a1, &v45, &v44, &v43, v10, v11, v12, v13);
      if (v15 < 0)
        goto LABEL_18;
      if (!(v45 ^ 0x44544854 | v46))
      {
        v16 = v43;
        *(_DWORD *)a2 = *v43;
        *(_DWORD *)(a2 + 4) = v16[1];
      }
      v15 = ssftriff_reader_CloseChunk(a1);
      if (v15 < 0)
      {
LABEL_18:
        LODWORD(v14) = v15;
      }
      else
      {
        v46 = 0;
        v44 = 0;
        v45 = 0;
        v43 = 0;
        LODWORD(v14) = ssftriff_reader_OpenChunk(a1, &v45, &v44, &v43, v17, v18, v19, v20);
        if ((v14 & 0x80000000) == 0)
        {
          if (!(v45 ^ 0x53544854 | v46))
            LODWORD(v14) = ssftriff_reader_DetachChunkData(a1, (uint64_t *)(a2 + 24), (_QWORD *)(a2 + 8), v21, v22, v23, v24, v25);
          v26 = ssftriff_reader_CloseChunk(a1);
          if ((int)v14 >= 0)
            LODWORD(v14) = v26;
          if ((v14 & 0x80000000) == 0)
          {
            v46 = 0;
            v44 = 0;
            v45 = 0;
            v43 = 0;
            LODWORD(v14) = ssftriff_reader_OpenChunk(a1, &v45, &v44, &v43, v27, v28, v29, v30);
            if ((v14 & 0x80000000) == 0)
            {
              if (!(v45 ^ 0x45544854 | v46))
                LODWORD(v14) = ssftriff_reader_DetachChunkData(a1, (uint64_t *)(a2 + 32), (_QWORD *)(a2 + 16), v31, v32, v33, v34, v35);
              v36 = ssftriff_reader_CloseChunk(a1);
              if ((int)v14 >= 0)
                LODWORD(v14) = v36;
            }
          }
        }
      }
    }
    v37 = ssftriff_reader_CloseChunk(a1);
    if ((int)v14 >= 0)
      return v37;
    else
      return v14;
  }
  return v14;
}

uint64_t kbaux_BuildBrokerString(uint64_t a1, const char *a2, char *a3, unint64_t a4)
{
  uint64_t result;
  int v9[2];
  char v10[128];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v9 = 0;
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v9);
  if ((result & 0x80000000) == 0)
  {
    auxil_strlcpy(v10, "mosynt_", 0x80uLL);
    auxil_strlcat(v10, a2, 128);
    auxil_strlcat(v10, "_", 128);
    if (auxil_strlcat(v10, *(const char **)v9, 128) > 0x7F)
    {
      return 2371887113;
    }
    else
    {
      LODWORD(result) = brokeraux_ComposeBrokerString(a1, v10, 0, 1, *(char **)v9, 0, 0, a3, a4);
      if ((int)result >= 0)
        return result;
      else
        return result | 0x8D602000;
    }
  }
  return result;
}

uint64_t hlp_VoiceSetup(uint64_t a1)
{
  _DWORD *v2;
  uint64_t result;
  const char *v4;
  char *v5;
  char *v6;
  _BOOL4 v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;
  __int16 v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned __int8 v15;
  __int16 v16;
  char **v17;
  _BYTE __c[11];

  v17 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v2 = (_DWORD *)(a1 + 88);
  result = com_mosynt_UseMosynt(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), (_BOOL4 *)(a1 + 88));
  if ((result & 0x80000000) == 0)
  {
    v16 = 0;
    memset(__c, 0, sizeof(__c));
    *(_DWORD *)(a1 + 244) = 0;
    if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "keep_stress", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(unsigned __int16 *)&__c[1] == 1&& *(_QWORD *)&__c[3])
    {
      v4 = **(const char ***)&__c[3];
      v5 = strchr(**(char ***)&__c[3], __c[0]);
      if (v5)
      {
        *v5 = 0;
        v4 = **(const char ***)&__c[3];
      }
      if (!strcmp(v4, "YES") || !strcmp(v4, "yes"))
        *(_DWORD *)(a1 + 244) = 1;
    }
    *(_BYTE *)(a1 + 360) = 0;
    v16 = 0;
    result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "orthtrigger", &v17, &v16, &v15);
    if ((result & 0x80000000) == 0)
    {
      if (v16 == 1 && v17)
      {
        v6 = strchr(*v17, v15);
        if (v6)
          *v6 = 0;
        __strcpy_chk();
      }
      *(_DWORD *)(a1 + 264) = 0;
      v16 = 0;
      if ((paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"prmigexists", &v14) & 0x80000000) == 0
        && v14 == 1)
      {
        *(_DWORD *)(a1 + 264) = 1;
      }
      *(_DWORD *)(a1 + 248) = 0;
      v16 = 0;
      result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "usetntag", &v17, &v16, &v15);
      if ((result & 0x80000000) == 0)
      {
        if (v16 == 1 && v17 && **v17 == 49)
          *(_DWORD *)(a1 + 248) = 1;
        *(_DWORD *)(a1 + 252) = 0;
        v16 = 0;
        result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "docclassmap", &v17, &v16, &v15);
        if ((result & 0x80000000) == 0)
        {
          if (v16 == 1 && v17 && !strncmp(*v17, "yes", 3uLL))
            *(_DWORD *)(a1 + 252) = 1;
          *(_DWORD *)(a1 + 256) = 0;
          v16 = 0;
          result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "feGlobaluseFullPOS", &v17, &v16, &v15);
          if ((result & 0x80000000) == 0)
          {
            if (v16 == 1 && v17 && **v17 == 49)
              *(_DWORD *)(a1 + 256) = 1;
            *(_DWORD *)(a1 + 260) = 0;
            if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"clcpppipelinemode", &v13) & 0x80000000) == 0
              && v13
              && *v13)
            {
              *(_DWORD *)(a1 + 260) = 1;
            }
            if ((*(unsigned int (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 32) + 72))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), "global") == 2)*(_DWORD *)(a1 + 260) = 1;
            if (*v2 != 1
              || (*(_QWORD *)&__c[3] = 0,
                  result = com_mosynt_GetCfgParamVal(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), (uint64_t)"mosynt_enablegraphsymcache", "yes", (char **)&__c[3]), (result & 0x80000000) == 0)&& (v7 = strcmp(*(const char **)&__c[3], "yes") == 0, result = kbsymtab_LoadData(*(_WORD **)(a1 + 296), *(_QWORD *)(a1 + 304), *(_WORD **)(a1 + 320), *(_QWORD *)(a1 + 328), (uint64_t *)(a1 + 336), v7), (result & 0x80000000) == 0)&& (result = fst_LoadData(*(_WORD **)(a1 + 296), *(_QWORD *)(a1 + 304), (uint64_t *)(a1 + 344)), (result & 0x80000000) == 0))
            {
              result = com_depes_InitLayers(*(_QWORD *)a1, a1 + 96);
              if ((result & 0x80000000) == 0)
              {
                *(_QWORD *)(a1 + 224) = 0x3000200010000;
                *(_WORD *)(a1 + 232) = 4;
                if (*(_DWORD *)(a1 + 88) || *(_DWORD *)(a1 + 264))
                {
                  v8 = 8;
                  v9 = 7;
                  v10 = 6;
                  v11 = 5;
                }
                else
                {
                  v11 = 0;
                  v8 = 7;
                  v9 = 6;
                  v10 = 5;
                }
                *(_WORD *)(a1 + 234) = v11;
                *(_WORD *)(a1 + 238) = v10;
                *(_WORD *)(a1 + 240) = v9;
                v12 = v8 - (*(_DWORD *)(a1 + 248) == 0);
                *(_WORD *)(a1 + 236) = v12;
                *(_WORD *)(a1 + 106) = v12 + 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fe_global_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t Object;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v27 = 0;
  v28 = 0;
  v5 = 2316312583;
  v25 = 0;
  v26 = 0;
  if (a5)
  {
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    inited = InitRsrcFunction(a3, a4, &v28);
    if ((inited & 0x80000000) == 0)
    {
      v12 = heap_Calloc(*(_QWORD **)(v28 + 8), 1, 408);
      v17 = v28;
      if (v12)
      {
        v18 = v12;
        v19 = (_QWORD *)heap_Calloc(*(_QWORD **)(v28 + 8), 1, 1040);
        *(_QWORD *)(v18 + 312) = v19;
        if (v19)
        {
          *v19 = a3;
          v19[1] = a4;
          Object = objc_GetObject(*(_QWORD *)(v28 + 48), (uint64_t)"LINGDB", &v27);
          if ((Object & 0x80000000) != 0)
            goto LABEL_14;
          *(_QWORD *)(v18 + 8) = *(_QWORD *)(v27 + 8);
          Object = objc_GetObject(*(_QWORD *)(v28 + 48), (uint64_t)"FE_DEPES", &v26);
          if ((Object & 0x80000000) != 0)
            goto LABEL_14;
          v21 = v26;
          *(_QWORD *)(v18 + 32) = *(_QWORD *)(v26 + 8);
          *(_OWORD *)(v18 + 16) = *(_OWORD *)(v21 + 16);
          Object = objc_GetObject(*(_QWORD *)(v28 + 48), (uint64_t)"FE_DCTLKP", &v25);
          if ((Object & 0x80000000) != 0)
            goto LABEL_14;
          v22 = v25;
          *(_QWORD *)(v18 + 56) = *(_QWORD *)(v25 + 8);
          *(_OWORD *)(v18 + 40) = *(_OWORD *)(v22 + 16);
          *(_QWORD *)v18 = v28;
          *(_DWORD *)(v18 + 268) = 0;
          *(_QWORD *)(v18 + 296) = a3;
          *(_QWORD *)(v18 + 304) = a4;
          *(_QWORD *)(v18 + 320) = a1;
          *(_QWORD *)(v18 + 328) = a2;
          *(_QWORD *)(v18 + 400) = 0;
          *(_OWORD *)(v18 + 368) = 0u;
          *(_OWORD *)(v18 + 384) = 0u;
          Object = hlp_VoiceSetup(v18);
          if ((Object & 0x80000000) != 0
            || (Object = globalbeadapt_SetFEBOOLKeyword((_QWORD *)v18, (uint64_t)"mdesegpos_morpheme_processing", (_DWORD *)(v18 + 272), 0), (Object & 0x80000000) != 0)|| (Object = globalbeadapt_SetFEBOOLKeyword((_QWORD *)v18, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(v18 + 276), 1), (Object & 0x80000000) != 0))
          {
LABEL_14:
            v5 = Object;
          }
          else
          {
            v5 = globalbeadapt_SetFEBOOLKeyword((_QWORD *)v18, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(v18 + 280), 1);
            if ((v5 & 0x80000000) == 0)
            {
              v23 = 62344;
LABEL_18:
              *(_QWORD *)a5 = v18;
              *(_DWORD *)(a5 + 8) = v23;
              return v5;
            }
          }
LABEL_17:
          fe_global_ObjClose(*(_QWORD *)a5, *(_QWORD *)(a5 + 8));
          v18 = 0;
          v23 = 0;
          goto LABEL_18;
        }
        v17 = v28;
      }
      log_OutPublic(*(_QWORD *)(v17 + 32), (uint64_t)"FE_GLOBAL", 38000, 0, v13, v14, v15, v16, v25);
      v5 = 2316312586;
      goto LABEL_17;
    }
    return inited;
  }
  return v5;
}

uint64_t fe_global_ObjClose(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;

  result = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((result & 0x80000000) != 0)
    return 2316312584;
  if (a1)
  {
    hlp_UnloadSymTabs(a1);
    if (*(_QWORD *)(a1 + 344))
    {
      fst_UnloadData(*(_WORD **)(a1 + 296), *(_QWORD *)(a1 + 304), (uint64_t *)(a1 + 344));
      *(_QWORD *)(a1 + 344) = 0;
    }
    if (*(_QWORD *)(a1 + 8))
      objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"LINGDB");
    if (*(_QWORD *)(a1 + 32))
      objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"FE_DEPES");
    if (*(_QWORD *)(a1 + 56))
      objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"FE_DCTLKP");
    v4 = *(_QWORD *)(a1 + 312);
    if (v4)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v4);
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), a1);
    return 0;
  }
  return result;
}

uint64_t fe_global_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result;

  result = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((result & 0x80000000) != 0)
    return 2316312584;
  if (a1)
  {
    result = hlp_UnloadSymTabs(a1);
    if ((result & 0x80000000) == 0)
    {
      if (!*(_QWORD *)(a1 + 344)
        || (result = fst_UnloadData(*(_WORD **)(a1 + 296), *(_QWORD *)(a1 + 304), (uint64_t *)(a1 + 344)),
            *(_QWORD *)(a1 + 344) = 0,
            (result & 0x80000000) == 0))
      {
        result = hlp_VoiceSetup(a1);
        if ((result & 0x80000000) == 0)
        {
          result = globalbeadapt_SetFEBOOLKeyword((_QWORD *)a1, (uint64_t)"mdesegpos_morpheme_processing", (_DWORD *)(a1 + 272), 0);
          if ((result & 0x80000000) == 0)
          {
            result = globalbeadapt_SetFEBOOLKeyword((_QWORD *)a1, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(a1 + 276), 1);
            if ((result & 0x80000000) == 0)
              return globalbeadapt_SetFEBOOLKeyword((_QWORD *)a1, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(a1 + 280), 1);
          }
        }
      }
    }
  }
  return result;
}

uint64_t hlp_UnloadSymTabs(uint64_t a1)
{
  uint64_t result;

  if (!*(_QWORD *)(a1 + 336))
    return 0;
  result = kbsymtab_UnloadData(*(_WORD **)(a1 + 296), *(_QWORD *)(a1 + 304), *(_WORD **)(a1 + 320), *(_QWORD *)(a1 + 328), (uint64_t *)(a1 + 336));
  *(_QWORD *)(a1 + 336) = 0;
  return result;
}

uint64_t fe_global_ProcessStart(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((int)result >= 0)
    return result;
  else
    return 2316312584;
}

uint64_t fe_global_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  unsigned __int16 v23;
  int v24;
  const char *v25;
  int v27;
  uint64_t v28;
  char *v29;
  size_t v30;
  size_t v31;
  char *j;
  char *v33;
  char *v34;
  const char *v35;
  char *v36;
  size_t v37;
  unsigned int v38;
  BOOL v39;
  int v40;
  BOOL v41;
  unint64_t v42;
  uint64_t v43;
  char *v44;
  unsigned __int8 *v45;
  int v47;
  char *v48;
  char v49;
  __int16 v50;
  int v51;
  unsigned __int16 v52;
  int v53;
  __int16 v54;
  __int16 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int16 v59;
  unsigned __int16 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t k;
  uint64_t v71;
  unsigned int v73;
  int v74;
  size_t v75;
  int v76;
  char *__s1;
  __int16 v78;
  unsigned __int16 v79;
  char *v80;
  int v81;
  char *v82;
  __int16 v83;
  int v84;
  char *__s;
  unsigned __int8 *v86;
  char *v87;
  char v88[2];
  unsigned int v89;
  __int16 v90;
  int v91;
  int v92;
  int v93;
  const char *v94[18];

  v94[16] = *(const char **)MEMORY[0x1E0C80C00];
  v78 = 0;
  __s1 = 0;
  v76 = 0;
  if ((safeh_HandleCheck(a1, a2, 62344, 408) & 0x80000000) != 0)
    return 2316312584;
  v82 = 0;
  v81 = 0;
  v80 = 0;
  v79 = 0;
  *a5 = 1;
  v9 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 144))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a1 + 104);
  if ((v9 & 0x80000000) != 0)
    goto LABEL_174;
  *(_DWORD *)(a1 + 352) = 0;
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"foreignpron", &__s1) & 0x80000000) == 0
    && __s1
    && !strcmp(__s1, "yes"))
  {
    *(_DWORD *)(a1 + 352) = 1;
  }
  *(_DWORD *)(a1 + 356) = 0;
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"nlucompatvc6be", &__s1) & 0x80000000) == 0
    && __s1
    && !strcmp(__s1, "yes"))
  {
    *(_DWORD *)(a1 + 356) = 1;
  }
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 104))(a3, a4, 1, 0, (char *)&v81 + 2);
  if ((v10 & 0x80000000) == 0
    && ((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, __int16 *))(*(_QWORD *)(a1 + 8) + 184))(a3, a4, HIWORD(v81), 0, &v78) & 0x80000000) == 0&& v78 == 1)
  {
    v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char **, int *))(*(_QWORD *)(a1 + 8) + 176))(a3, a4, HIWORD(v81), 0, &v82, &v81);
    if ((v10 & 0x80000000) == 0 && (unsigned __int16)v81 >= 2u)
    {
      if (*(_DWORD *)(a1 + 88))
      {
        v11 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 5000, 1);
        *(_QWORD *)(a1 + 368) = v11;
        v16 = *(_QWORD *)a1;
        if (v11)
        {
          v17 = heap_Calloc(*(_QWORD **)(v16 + 8), 5000, 1);
          *(_QWORD *)(a1 + 376) = v17;
          v16 = *(_QWORD *)a1;
          if (v17)
          {
            v18 = heap_Calloc(*(_QWORD **)(v16 + 8), 5000, 1);
            *(_QWORD *)(a1 + 384) = v18;
            v16 = *(_QWORD *)a1;
            if (v18)
            {
              v19 = heap_Calloc(*(_QWORD **)(v16 + 8), 5000, 1);
              *(_QWORD *)(a1 + 392) = v19;
              v16 = *(_QWORD *)a1;
              if (v19)
              {
                v20 = heap_Calloc(*(_QWORD **)(v16 + 8), 8, 8);
                *(_QWORD *)(a1 + 400) = v20;
                if (v20)
                {
                  for (i = 0; i != 64; i += 8)
                    *(_QWORD *)(*(_QWORD *)(a1 + 400) + i) = 0;
                  v22 = 0;
                  while (1)
                  {
                    *(_QWORD *)(*(_QWORD *)(a1 + 400) + v22) = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 5000, 1);
                    if (!*(_QWORD *)(*(_QWORD *)(a1 + 400) + v22))
                      break;
                    v22 += 8;
                    if (v22 == 64)
                      goto LABEL_27;
                  }
                }
                v16 = *(_QWORD *)a1;
              }
            }
          }
        }
        log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"FE_GLOBAL", 38000, 0, v12, v13, v14, v15, v73);
        v10 = 2316312586;
        goto LABEL_175;
      }
LABEL_27:
      v92 = 0;
      v93 = 0;
      v91 = 0;
      v89 = 0;
      v94[0] = 0;
      v86 = 0;
      v87 = 0;
      __s = 0;
      v84 = 0;
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 104))(a3, a4, 2, HIWORD(v81), (char *)&v93 + 2);
      if ((v9 & 0x80000000) != 0)
        goto LABEL_174;
      LOWORD(v91) = 0;
      v90 = 0;
      v23 = HIWORD(v93);
      if (!HIWORD(v93))
        goto LABEL_132;
      v24 = 0;
      v25 = "PHR:";
LABEL_30:
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, char *))(*(_QWORD *)(a1 + 8) + 168))(a3, a4, v23, 0, 1, &v89, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0)
        goto LABEL_174;
      if (v89 - 9 >= 6 && v89 != 4)
      {
        if (v89 != 15)
          goto LABEL_91;
        v24 = HIWORD(v93);
        v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 120))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
        goto LABEL_41;
      }
      v83 = 0;
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(a1 + 8)
                                                                                                + 168))(a3, a4, HIWORD(v93), 1, 1, &v91, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0)
        goto LABEL_174;
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, char *))(*(_QWORD *)(a1 + 8) + 168))(a3, a4, HIWORD(v93), 2, 1, &v90, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0)
        goto LABEL_174;
      v27 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, __int16 *))(*(_QWORD *)(a1 + 8) + 184))(a3, a4, HIWORD(v93), 14, &v83);
      v28 = *(_QWORD *)(a1 + 8);
      if (v27 < 0 || !v83)
      {
        v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(v28 + 120))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
        goto LABEL_41;
      }
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(v28 + 176))(a3, a4, HIWORD(v93), 14, &__s, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0)
        goto LABEL_174;
      if (*(_DWORD *)(a1 + 356) != 1)
        goto LABEL_81;
      v74 = v24;
      v29 = __s;
      v30 = strlen(__s);
      v31 = v30;
      for (j = __s; ; ++j)
      {
        if (*j == 59)
        {
          *j = 0;
        }
        else if (!*j)
        {
          v33 = &v29[v30];
          v34 = v29;
          if (!v30)
            goto LABEL_80;
          while (2)
          {
            if (!strncmp(v34, v25, 4uLL))
            {
              v35 = v25;
              v36 = v34 + 4;
              v37 = strlen(v34 + 4);
              if (v37 >= 3)
              {
                v38 = *v36 - 66;
                v39 = v38 > 0xD;
                v40 = (1 << v38) & 0x2081;
                v41 = v39 || v40 == 0;
                if (!v41 && v34[5] == 45)
                {
                  v42 = v37;
                  v75 = v37 - 2;
                  memmove(v34 + 4, v34 + 6, v37 - 2);
                  v43 = -1;
                  if (v42 - 1 < v42)
                    v43 = 0;
                  bzero(&v36[v75], v43 + 2);
                }
              }
LABEL_65:
              v44 = strchr(v36, 43);
              v25 = v35;
              if (v44 && *v44)
              {
                v45 = (unsigned __int8 *)(v44 + 1);
                do
                  *(v45 - 1) = 0;
                while (*v45++);
              }
            }
            else if (!strncmp(v34, "POS:", 4uLL))
            {
              v35 = v25;
              v36 = v34 + 4;
              goto LABEL_65;
            }
            if (++v34 != v33)
              continue;
            break;
          }
          v47 = 0;
          v48 = v29;
          do
          {
            v49 = *v48;
            if (*v48)
            {
              if (v47 == 1)
              {
                *v29++ = 59;
                v49 = *v48;
              }
              v47 = 0;
              *v29++ = v49;
            }
            else
            {
              v47 = 1;
            }
            ++v48;
            --v31;
          }
          while (v31);
LABEL_80:
          *v29 = 0;
          v24 = v74;
LABEL_81:
          hlp_NLUStrFind(__s, "BND", (uint64_t *)&v86, (unsigned __int16 *)&v84);
          hlp_NLUStrFind(__s, "PRM", (uint64_t *)&v87, (unsigned __int16 *)&v84 + 1);
          if (v90 && (_WORD)v24)
          {
            v88[0] = 0;
            if (!v87
              || (v88[0] = *v87) == 0
              || (v88[1] = 0,
                  v50 = strlen(v88),
                  v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 13, (unsigned __int16)(v50 + 1), v88, &v92), (v9 & 0x80000000) == 0))
            {
              if (!v86)
                goto LABEL_94;
              v51 = (char)*v86;
              if (v51 != 78 && v51 != 87)
              {
                if (v51 == 83)
                {
                  HIWORD(v91) = 200;
                  goto LABEL_93;
                }
                goto LABEL_94;
              }
              HIWORD(v91) = 0;
LABEL_93:
              v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 8, 1, (char *)&v91 + 2, &v92);
              if ((v9 & 0x80000000) == 0)
              {
LABEL_94:
                v52 = HIWORD(v93);
                while (1)
                {
                  v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 120))(a3, a4, v52, (char *)&v93 + 2);
                  if ((v9 & 0x80000000) != 0)
                    break;
                  if (!HIWORD(v93))
                    goto LABEL_42;
                  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 168))(a3, a4);
                  if ((v9 & 0x80000000) != 0)
                    break;
                  v52 = HIWORD(v93);
                  if (!HIWORD(v93))
                    goto LABEL_42;
                  if (v89 <= 0xF && ((1 << v89) & 0xFE10) != 0)
                  {
                    v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 168))(a3, a4);
                    if ((v9 & 0x80000000) != 0)
                      goto LABEL_174;
                    if (!v86)
                      goto LABEL_42;
                    v53 = *v86;
                    if (v53 == 78)
                    {
                      if (v89 != 15)
                        goto LABEL_42;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, char *))(*(_QWORD *)(a1 + 8) + 168))(a3, a4, HIWORD(v93), 2, 1, &v90, (char *)&v92 + 2);
                      if ((v9 & 0x80000000) == 0)
                      {
                        v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 2, 1, &v90, &v92);
                        if ((v9 & 0x80000000) == 0)
                        {
                          v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, char *))(*(_QWORD *)(a1 + 8) + 176))(a3, a4, HIWORD(v93), 4, v94, (char *)&v92 + 2);
                          if ((v9 & 0x80000000) == 0)
                          {
                            v54 = strlen(v94[0]);
                            v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 4, (unsigned __int16)(v54 + 1), v94[0], &v92);
                            if ((v9 & 0x80000000) == 0)
                            {
                              v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(*(_QWORD *)(a1 + 8)
                                                                                              + 120))(a3, a4, HIWORD(v93), &v93);
                              if ((v9 & 0x80000000) == 0)
                              {
                                v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 8) + 192))(a3, a4, HIWORD(v93));
                                if ((v9 & 0x80000000) == 0)
                                {
                                  HIWORD(v93) = v93;
                                  goto LABEL_42;
                                }
                              }
                            }
                          }
                        }
                      }
                      goto LABEL_174;
                    }
                    if (v89 != 15)
                    {
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 88))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v89 = 15;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 0, 1, &v89, &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 1, 1, &v91, &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, char *))(*(_QWORD *)(a1 + 8) + 168))(a3, a4, (unsigned __int16)v24, 2, 1, &v90, (char *)&v92 + 2);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 2, 1, &v90, &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 2, 1, &v91, &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, char *))(*(_QWORD *)(a1 + 8) + 176))(a3, a4, (unsigned __int16)v24, 4, v94, (char *)&v92 + 2);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v55 = strlen(v94[0]);
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 4, (unsigned __int16)(v55 + 1), v94[0], &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, const char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 4, 2, "P", &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      v53 = *v86;
                    }
                    if (v53 == 87)
                    {
                      HIWORD(v91) = 2;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 7, 1, (char *)&v91 + 2, &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      HIWORD(v91) = 0;
                    }
                    else
                    {
                      if ((char)v53 != 83)
                        goto LABEL_42;
                      HIWORD(v91) = 1;
                      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 7, 1, (char *)&v91 + 2, &v92);
                      if ((v9 & 0x80000000) != 0)
                        goto LABEL_174;
                      HIWORD(v91) = 200;
                    }
                    v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 8, 1, (char *)&v91 + 2, &v92);
                    if ((v9 & 0x80000000) == 0)
                      goto LABEL_42;
                    goto LABEL_174;
                  }
                }
              }
            }
            goto LABEL_174;
          }
LABEL_91:
          v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 120))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
LABEL_41:
          if ((v9 & 0x80000000) != 0)
            goto LABEL_174;
LABEL_42:
          v23 = HIWORD(v93);
          if (!HIWORD(v93))
          {
LABEL_132:
            if (*(_DWORD *)(a1 + 244))
            {
              v56 = 2;
            }
            else if (*(_DWORD *)(a1 + 88))
            {
              v56 = 98;
            }
            else
            {
              v56 = 34;
            }
            v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 8)
                                                                                               + 272))(a3, a4, v56, 3, 0, 0);
            if ((v9 & 0x80000000) != 0)
              goto LABEL_174;
            v9 = globalbeadapt_SetupDepesInput(a1, a3, a4, HIWORD(v81), (uint64_t)"global", 0, v57, v58);
            if ((v9 & 0x80000000) != 0)
              goto LABEL_174;
            if (*(_DWORD *)(a1 + 88))
            {
              v9 = hlp_SaveLayers(a1);
              if ((v9 & 0x80000000) != 0)
                goto LABEL_174;
            }
            strcpy((char *)v94, "global");
            v59 = strlen((const char *)v94);
            if (*(_DWORD *)(a1 + 352))
            {
              v60 = v59;
              __strcat_chk();
              if (((*(uint64_t (**)(_QWORD, _QWORD, const char **))(*(_QWORD *)(a1 + 32) + 80))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v94) & 0x80000000) != 0)
              {
                *((_BYTE *)v94 + v60) = 0;
                v9 = (*(uint64_t (**)(_QWORD, _QWORD, const char **))(*(_QWORD *)(a1 + 32) + 80))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v94);
                if ((v9 & 0x80000000) != 0)
                  goto LABEL_174;
              }
            }
            else
            {
              hlp_WriteDepesLayers(a1, "before cgn");
              v9 = (*(uint64_t (**)(_QWORD, _QWORD, const char **))(*(_QWORD *)(a1 + 32) + 80))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v94);
              if ((v9 & 0x80000000) != 0)
                goto LABEL_174;
              hlp_WriteDepesLayers(a1, "after cgn");
            }
            if (!*(_DWORD *)(a1 + 88))
              goto LABEL_157;
            v9 = hlp_ReconstituteLayers(a1);
            if ((v9 & 0x80000000) != 0)
              goto LABEL_174;
            hlp_WriteDepesLayers(a1, "after realignment");
            v9 = fe_global_ApplyFSTs(a1);
            if ((v9 & 0x80000000) != 0)
              goto LABEL_174;
            v9 = hlp_ReconstituteLayers(a1);
            if ((v9 & 0x80000000) != 0)
              goto LABEL_174;
            hlp_WriteDepesLayers(a1, "before be_adapt");
            strcpy((char *)v94, "be_adapt");
            if (!(*(unsigned int (**)(_QWORD, _QWORD, const char **))(*(_QWORD *)(a1 + 32) + 72))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v94)|| (v61 = (*(uint64_t (**)(_QWORD, _QWORD, const char **))(*(_QWORD *)(a1 + 32) + 80))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v94), (v61 & 0x80000000) == 0)|| (v10 = v61, (v61 & 0x1FFF) == 4))
            {
              hlp_WriteDepesLayers(a1, "after be_adapt");
LABEL_157:
              v9 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, unsigned __int16 *))(*(_QWORD *)(a1 + 32)
                                                                                                  + 128))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 0, &v80, &v79);
              if ((v9 & 0x80000000) != 0)
                goto LABEL_174;
              v80[v79] = 0;
              log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_GLOBAL", 5, 0, (uint64_t)"%s O1: %s", v62, v63, v64, (uint64_t)v94);
              v9 = globalbeadapt_DoPostprocessing((_QWORD *)a1, v82, &v80, 1);
              if ((v9 & 0x80000000) != 0)
                goto LABEL_174;
              v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 320))(a3, a4, 1);
              if ((v9 & 0x80000000) != 0)
                goto LABEL_174;
              v65 = *(_DWORD *)(a1 + 272);
              if (!v65 || v65 == 1 && !*(_DWORD *)(a1 + 276))
                goto LABEL_193;
              v9 = globalbeadapt_OutputMorphemesToLingDBAsWords((uint64_t *)a1, a3, a4, HIWORD(v81), v82, *(unsigned __int8 **)(a1 + 120), v80, &v76);
              if ((v9 & 0x80000000) != 0)
                goto LABEL_174;
              if (v76 == 1)
              {
LABEL_193:
                v9 = globalbeadapt_OutputToLingDB(a1, a3, a4, HIWORD(v81), (uint64_t)v82, v80);
                if ((v9 & 0x80000000) != 0)
                  goto LABEL_174;
              }
              if (*(_DWORD *)(a1 + 272) == 1
                && *(_DWORD *)(a1 + 276) == 1
                && (!v76
                 && (v9 = globalbeadapt_SplitWordRecordsWithSpecialChar((uint64_t *)a1, a3, a4, HIWORD(v81), v82, (const char *)(a1 + 360)), (v9 & 0x80000000) != 0)|| (v9 = globalbeadapt_RemoveSpecialChar((_QWORD *)a1, a3, a4, HIWORD(v81)), (v9 & 0x80000000) != 0)))
              {
LABEL_174:
                v10 = v9;
              }
              else
              {
                v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 8) + 272))(a3, a4, 4, 1, 0, 0);
                if ((v10 & 0x80000000) == 0 && *(_BYTE *)(a1 + 360))
                {
                  v9 = fe_global_CleanTriggerOrth(a1, a3, a4, HIWORD(v81));
                  goto LABEL_174;
                }
              }
            }
LABEL_175:
            com_depes_FreeLayers(*(_QWORD *)a1, a1 + 96);
            if (*(_DWORD *)(a1 + 88))
            {
              v66 = *(_QWORD *)(a1 + 368);
              if (v66)
              {
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v66);
                *(_QWORD *)(a1 + 368) = 0;
              }
              v67 = *(_QWORD *)(a1 + 376);
              if (v67)
              {
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v67);
                *(_QWORD *)(a1 + 376) = 0;
              }
              v68 = *(_QWORD *)(a1 + 384);
              if (v68)
              {
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v68);
                *(_QWORD *)(a1 + 384) = 0;
              }
              v69 = *(_QWORD *)(a1 + 392);
              if (v69)
              {
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v69);
                *(_QWORD *)(a1 + 392) = 0;
              }
              if (*(_QWORD *)(a1 + 400))
              {
                for (k = 0; k != 64; k += 8)
                {
                  v71 = *(_QWORD *)(*(_QWORD *)(a1 + 400) + k);
                  if (v71)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v71);
                    *(_QWORD *)(*(_QWORD *)(a1 + 400) + k) = 0;
                  }
                }
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 400));
                *(_QWORD *)(a1 + 400) = 0;
              }
            }
            return v10;
          }
          goto LABEL_30;
        }
      }
    }
  }
  return v10;
}

uint64_t hlp_SaveLayers(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  char v4;
  char *__src;
  unsigned __int16 v7;

  __src = 0;
  if (!*(_WORD *)(a1 + 104))
    return 0;
  v2 = 0;
  v7 = 0;
  do
  {
    v3 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, unsigned __int16 *))(*(_QWORD *)(a1 + 32) + 128))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), (unsigned __int16)v2, &__src, &v7);
    if ((v3 & 0x80000000) != 0)
      break;
    v4 = __src[v7];
    __src[v7] = 0;
    strncpy(*(char **)(*(_QWORD *)(a1 + 400) + 8 * v2), __src, 0x1387uLL);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 400) + 8 * v2) + 4999) = 0;
    __src[v7] = v4;
    ++v2;
  }
  while (v2 < *(unsigned __int16 *)(a1 + 104));
  return v3;
}

uint64_t hlp_WriteDepesLayers(uint64_t result, char *a2)
{
  uint64_t v3;
  unsigned int v4;
  char *v5;
  unsigned __int16 v6;
  uint64_t v7;
  char *v8;
  int v9;
  int v10;
  char __s[5];
  unsigned __int16 v12;
  unint64_t v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(result + 88))
  {
    v3 = result;
    result = mosynt_TraceString(*(_QWORD *)(result + 312), "\n", 1u);
    if ((result & 0x80000000) == 0)
    {
      v13 = 0;
      v12 = 0;
      result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, unint64_t *, unsigned __int16 *))(*(_QWORD *)(v3 + 32) + 128))(*(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), 0, &v13, &v12);
      if ((result & 0x80000000) == 0)
      {
        result = Utf8_LengthInUtf8chars(v13, v12);
        v14[0] = 0;
        v14[1] = 0;
        v4 = (unsigned __int16)result;
        if ((_WORD)result)
        {
          v5 = "\n";
          while (1)
          {
            v6 = v4 <= 0x32 ? result : 50;
            if (*(_WORD *)(v3 + 104))
              break;
LABEL_24:
            result = mosynt_TraceString(*(_QWORD *)(v3 + 312), v5, 1u);
            if ((result & 0x80000000) == 0)
            {
              result = v4 - v6;
              v4 = (unsigned __int16)(v4 - v6);
              if (v4)
                continue;
            }
            return result;
          }
          v7 = 0;
          while (1)
          {
            result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, unint64_t *, unsigned __int16 *))(*(_QWORD *)(v3 + 32) + 128))(*(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), (unsigned __int16)v7, &v13, &v12);
            if ((result & 0x80000000) != 0)
              break;
            result = mosynt_TraceString(*(_QWORD *)(v3 + 312), a2, 1u);
            if ((result & 0x80000000) != 0)
              break;
            result = mosynt_TraceString(*(_QWORD *)(v3 + 312), " L", 1u);
            if ((result & 0x80000000) != 0)
              break;
            result = mosynt_TraceInt(*(_QWORD *)(v3 + 312), (int)v7 + 1, 1u);
            if ((result & 0x80000000) != 0)
              break;
            result = mosynt_TraceString(*(_QWORD *)(v3 + 312), ": ", 1u);
            if ((result & 0x80000000) != 0)
              break;
            if (v6)
            {
              v8 = v5;
              v9 = 0;
              v10 = *((unsigned __int16 *)v14 + v7);
              while (1)
              {
                result = utf8_getUTF8Char(v13, (unsigned __int16)v10, __s);
                if ((result & 0x80000000) != 0)
                  break;
                result = mosynt_TraceString(*(_QWORD *)(v3 + 312), __s, 1u);
                if ((result & 0x80000000) != 0)
                  break;
                v10 += strlen(__s);
                if ((unsigned __int16)++v9 >= v6)
                {
                  *((_WORD *)v14 + v7) = v10;
                  v5 = v8;
                  goto LABEL_22;
                }
              }
              *((_WORD *)v14 + v7) = v10;
              return result;
            }
LABEL_22:
            result = mosynt_TraceString(*(_QWORD *)(v3 + 312), v5, 1u);
            if ((result & 0x80000000) != 0)
              return result;
            if (++v7 >= (unint64_t)*(unsigned __int16 *)(v3 + 104))
              goto LABEL_24;
          }
        }
      }
    }
  }
  return result;
}

uint64_t hlp_ReconstituteLayers(uint64_t a1)
{
  uint64_t v2;
  char v3;
  char *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned __int16 v8;
  char *__src;
  unsigned __int16 v11;

  v11 = 0;
  __src = 0;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, unsigned __int16 *))(*(_QWORD *)(a1 + 32) + 128))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 0, &__src, &v11);
  if ((v2 & 0x80000000) == 0)
  {
    v3 = __src[v11];
    __src[v11] = 0;
    v4 = __src;
    strncpy(**(char ***)(a1 + 400), __src, 0x1387uLL);
    *(_BYTE *)(**(_QWORD **)(a1 + 400) + 4999) = 0;
    v4[v11] = v3;
    if (*(unsigned __int16 *)(a1 + 104) >= 2u)
    {
      v5 = 1;
      while (1)
      {
        v6 = v5 == 1 ? 126 : 0;
        v7 = mosynt_AlignFieldsWithRef(**(_QWORD **)(a1 + 400), *(_QWORD *)(*(_QWORD *)(a1 + 400) + 8 * v5), *(_QWORD *)(a1 + 384), 0x1388u, v6);
        if ((v7 & 0x80000000) != 0)
          break;
        strcpy(*(char **)(*(_QWORD *)(a1 + 400) + 8 * v5), *(const char **)(a1 + 384));
        v8 = strlen(*(const char **)(a1 + 384));
        v2 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), (unsigned __int16)v5, *(_QWORD *)(a1 + 384), v8);
        if ((v2 & 0x80000000) == 0 && ++v5 < (unint64_t)*(unsigned __int16 *)(a1 + 104))
          continue;
        return v2;
      }
      return v7;
    }
  }
  return v2;
}

uint64_t fe_global_ApplyFSTs(uint64_t a1)
{
  uint64_t result;
  int v3;
  unsigned __int16 v4;
  uint64_t v5;
  char *v6;
  int v7;
  uint64_t v8;
  _BYTE *v9;
  unsigned __int16 v10;
  int v11;
  int v12;
  char *v13;
  uint64_t v14;
  unsigned __int16 v15;
  __int16 v16;
  __int16 v17;
  int v18;
  unsigned int v19;
  char __s[5];
  unsigned __int8 *v21;

  v21 = 0;
  v18 = 0;
  result = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"langcode", &v21);
  if ((result & 0x80000000) != 0)
    return result;
  v3 = *v21;
  result = mosynt_NormalizeSpaceFields(**(_BYTE ***)(a1 + 400), *(_QWORD *)(a1 + 384), 0x1388u);
  if ((result & 0x80000000) != 0)
    return result;
  v4 = 0;
  LOWORD(v5) = 0;
  while (1)
  {
    v6 = *(char **)(a1 + 384);
    v7 = v6[v4];
    if (v7 == 32)
    {
      if ((unsigned __int16)v5 >= v4)
      {
        LOBYTE(v7) = 32;
      }
      else
      {
        v5 = (unsigned __int16)v5;
        do
          *(_BYTE *)(*(_QWORD *)(a1 + 384) + v5++) = 126;
        while (v4 != v5);
        v6 = *(char **)(a1 + 384);
        LOBYTE(v7) = v6[v4];
        LOWORD(v5) = v4;
      }
      goto LABEL_13;
    }
    if (v7 == 126)
      goto LABEL_14;
    if (!v6[v4])
      break;
LABEL_13:
    v6[(unsigned __int16)v5] = v7;
    LOWORD(v5) = v5 + 1;
LABEL_14:
    ++v4;
  }
  if ((unsigned __int16)v5 < v4)
  {
    v8 = (unsigned __int16)v5;
    do
      *(_BYTE *)(*(_QWORD *)(a1 + 384) + v8++) = 126;
    while (v4 != v8);
    v6 = *(char **)(a1 + 384);
  }
  mosynt_SubstAllSubstrOcc(v6, "~", " ", *(_BYTE **)(a1 + 392), 5000);
  result = mosynt_SubstAllSubstrOcc(*(char **)(a1 + 392), "¡", "~", *(_BYTE **)(a1 + 384), 5000);
  if ((result & 0x80000000) == 0)
  {
    v19 = 0;
    v17 = 95;
    v9 = *(_BYTE **)(a1 + 384);
    if (*v9)
    {
      v10 = 0;
      v11 = 0;
      while (1)
      {
        utf8_getUTF8Char((uint64_t)v9, (unsigned __int16)v11, __s);
        v12 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 400) + 32) + v10);
        if ((char)v12 < 33 || (char)v3 < 33 || v12 == v3)
          v13 = __s;
        else
          v13 = (char *)&v17;
        result = mosynt_App(*(_QWORD *)(a1 + 392), 5000, &v19, v13, &v18);
        if ((result & 0x80000000) != 0)
          break;
        v11 += strlen(__s);
        ++v10;
        v9 = *(_BYTE **)(a1 + 384);
        if (!v9[(unsigned __int16)v11])
        {
          v14 = v19;
          goto LABEL_31;
        }
      }
    }
    else
    {
      v14 = 0;
LABEL_31:
      *(_BYTE *)(*(_QWORD *)(a1 + 392) + v14) = 0;
      result = mosynt_SentPhono(*(_QWORD *)(a1 + 312), *(uint64_t **)(a1 + 336), *(_QWORD *)(a1 + 344), *(unsigned __int8 **)(a1 + 392), *(char **)(*(_QWORD *)(a1 + 400) + 40), *(char **)(a1 + 368), 5000);
      if ((result & 0x80000000) == 0)
      {
        result = mosynt_SubstAllSubstrOcc(*(char **)(a1 + 368), "~", "¡", *(_BYTE **)(a1 + 392), 5000);
        if ((result & 0x80000000) == 0)
        {
          strcpy(*(char **)(a1 + 368), *(const char **)(a1 + 392));
          v17 = 95;
          v16 = 123;
          result = mosynt_SubstAllSubstrOcc(*(char **)(a1 + 368), &v17, &v16, *(_BYTE **)(a1 + 384), 5000);
          if ((result & 0x80000000) == 0)
          {
            result = mosynt_ReplaceNonSpaceFields(**(_QWORD **)(a1 + 400), *(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 376), 0x1388u, 126, 1);
            if ((result & 0x80000000) == 0)
            {
              v15 = strlen(*(const char **)(a1 + 376));
              return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 0, *(_QWORD *)(a1 + 376), v15);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fe_global_CleanTriggerOrth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  size_t v12;
  unsigned __int16 v13;
  char *v14;
  unsigned __int16 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  _DWORD *v19;
  uint64_t i;
  unsigned __int16 v22;
  char *__s1;
  uint64_t v24;
  __int16 v25;
  int v26;
  int v27;

  v26 = 0;
  v27 = 0;
  v25 = 0;
  __s1 = 0;
  v24 = 0;
  v22 = 0;
  v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char **, int *))(*(_QWORD *)(a1 + 8) + 176))(a2, a3, a4, 0, &__s1, &v26);
  if ((v8 & 0x80000000) != 0)
    return v8;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, unsigned __int16 *))(*(_QWORD *)(a1 + 8) + 176))(a2, a3, a4, 1, &v24, &v22);
  if ((v9 & 0x80000000) == 0)
  {
    v10 = strstr(__s1, (const char *)(a1 + 360));
    if (v10)
    {
      v11 = v10;
LABEL_5:
      v12 = strlen((const char *)(a1 + 360));
      v13 = v12;
      v14 = &v11[v12];
      v15 = strlen(v11);
      memmove(v11, v14, v15 - (unint64_t)v13 + 1);
      v16 = v22;
      if (v22)
      {
        v17 = v24;
        v18 = (unsigned __int16)((_WORD)v11 - (_WORD)__s1);
        v19 = (_DWORD *)(v24 + 12);
        do
        {
          if (*v19 - *(_DWORD *)(v17 + 12) > v18)
            *v19 -= (unsigned __int16)strlen((const char *)(a1 + 360));
          v19 += 8;
          --v16;
        }
        while (v16);
      }
      for (i = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 104))(a2, a3, 2, a4, (char *)&v27 + 2);
            ;
            i = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 8) + 120))(a2, a3, HIWORD(v27), (char *)&v27 + 2))
      {
        v9 = i;
        if ((i & 0x80000000) != 0)
          break;
        if (!HIWORD(v27))
        {
          v11 = strstr(__s1, (const char *)(a1 + 360));
          if (v11)
            goto LABEL_5;
          return v9;
        }
        v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 8)
                                                                                                 + 168))(a2, a3, HIWORD(v27), 1, 1, &v27, &v26);
        if ((v8 & 0x80000000) != 0)
          return v8;
        if (v11 - __s1 < (unsigned __int16)v27)
        {
          LOWORD(v27) = v27 - strlen((const char *)(a1 + 360));
          v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(*(_QWORD *)(a1 + 8) + 160))(a2, a3, HIWORD(v27), 1, 1, &v27, &v25);
          if ((v8 & 0x80000000) != 0)
            return v8;
        }
        v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 8)
                                                                                                  + 168))(a2, a3, HIWORD(v27), 2, 1, (char *)&v26 + 2, &v26);
        if ((v8 & 0x80000000) != 0)
          return v8;
        if (v11 - __s1 < HIWORD(v26))
        {
          HIWORD(v26) -= strlen((const char *)(a1 + 360));
          v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(*(_QWORD *)(a1 + 8) + 160))(a2, a3, HIWORD(v27), 2, 1, (char *)&v26 + 2, &v25);
          if ((v8 & 0x80000000) != 0)
            return v8;
        }
      }
    }
  }
  return v9;
}

uint64_t fe_global_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((int)result >= 0)
    return result;
  else
    return 2316312584;
}

uint64_t fe_global_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2316312577;
  result = 0;
  *a2 = &IFeGlobal;
  return result;
}

uint64_t fe_global_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2316312583;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_global_ClassClose()
{
  return 0;
}

uint64_t get_ner_brokerstring(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  int v8[2];
  _OWORD v9[8];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  *(_QWORD *)v8 = 0;
  memset(v9, 0, sizeof(v9));
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v7);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v9, 1, 1, *(char **)v8, 0, 0, a2, a3);
    }
  }
  return result;
}

uint64_t updateNLUNE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  uint64_t v14;
  char *v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;
  char *__s;
  __int16 v27;
  int v28;

  v28 = 0;
  v27 = 0;
  __s = 0;
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a4 + 184))(a2, a3, a5, 14, (char *)&v28 + 2);
  if ((v14 & 0x80000000) != 0)
    return v14;
  if (!HIWORD(v28))
  {
LABEL_5:
    v15 = &byte_1DEBD87CE;
    __s = &byte_1DEBD87CE;
    goto LABEL_8;
  }
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char **, int *))(a4 + 176))(a2, a3, a5, 14, &__s, &v28);
  if ((v14 & 0x80000000) != 0)
    return v14;
  if ((unsigned __int16)v28 < 2u)
    goto LABEL_5;
  v15 = __s;
LABEL_8:
  v17 = strlen(v15);
  v18 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), v17 + 7, 1);
  if (!v18)
    return 2314215434;
  v19 = v18;
  v20 = strcpy(v18, __s);
  hlp_NLUStrSet(v20, "NE", (char *)(*(_QWORD *)(a7 + 8) + 40 * a6 + 30));
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"updating WordRecord[%d] word[%d] LD_W_NLU %s -> %s", v21, v22, v23, a5);
  v24 = strlen(v19);
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, const char *, __int16 *))(a4 + 160))(a2, a3, a5, 14, (unsigned __int16)(v24 + 1), v19, &v27);
  heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v19);
  return v16;
}

uint64_t ner_process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unsigned __int16 v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  const char *v35;
  uint64_t v36;
  const void *v37;
  unsigned __int16 v38;
  int v39;

  v39 = 0;
  v38 = 0;
  v36 = 0;
  v37 = 0;
  v35 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a5 + 104))(a3, a4, 1, 0, (char *)&v39 + 2);
  if ((v17 & 0x80000000) != 0)
    return v17;
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, int *))(a5 + 184))(a3, a4, HIWORD(v39), 0, &v39);
  if ((v18 & 0x80000000) == 0 && (unsigned __int16)v39 == 1)
  {
    v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, const char **, unsigned __int16 *))(a5 + 176))(a3, a4, HIWORD(v39), 0, &v35, &v38);
    if ((v18 & 0x80000000) == 0 && v38 >= 2u)
    {
      v19 = a9 || *(_DWORD *)(a2 + 36) != 1
          ? ner_getSentenceData(a1, a3, a4, a5, HIWORD(v39), v35, a2, a6, a7, a8, (uint64_t *)&v37)
          : ner_getSentenceData(a1, a3, a4, a5, HIWORD(v39), v35, a2, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 80), (uint64_t *)&v37);
      v18 = v19;
      if ((v19 & 0x80000000) == 0)
      {
        if (*(_WORD *)(a2 + 16))
        {
          v18 = fi_predict(*(uint64_t ****)a2, &v37, *(unsigned __int16 *)(a2 + 18), &v36, v20, v21, v22, v23);
          if ((v18 & 0x80000000) != 0)
          {
            log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"FI NER Prediction Failed", v25, v26, v27, 0);
            return v18;
          }
          if (*(_WORD *)(a2 + 16))
          {
            v28 = 0;
            v29 = 0;
            v30 = v36;
            v31 = *(_QWORD *)(a2 + 8);
            v32 = 78;
            do
            {
              if (!*(_WORD *)(v31 + 40 * v28 + 24))
                goto LABEL_26;
              v33 = 0;
              while (!v33)
              {
                v32 = **(unsigned __int8 **)(v30 + 8 * v29);
                *(_BYTE *)(v31 + 40 * v28 + 30) = v32;
                *(_BYTE *)(*(_QWORD *)(a2 + 8) + 40 * v28 + 31) = 0;
                v31 = *(_QWORD *)(a2 + 8);
LABEL_25:
                if (++v33 >= (unint64_t)*(unsigned __int16 *)(v31 + 40 * v28 + 24))
                  goto LABEL_26;
              }
              v34 = **(unsigned __int8 **)(v30 + 8 * v29 + 8 * v33);
              if (v32 == v34 || v34 == 78 || v32 == 78)
                goto LABEL_25;
              v32 = 78;
              *(_BYTE *)(v31 + 40 * v28 + 30) = 78;
              *(_BYTE *)(*(_QWORD *)(a2 + 8) + 40 * v28 + 31) = 0;
              v31 = *(_QWORD *)(a2 + 8);
LABEL_26:
              v29 += *(_WORD *)(v31 + 40 * v28++ + 24);
            }
            while (v28 < *(unsigned __int16 *)(a2 + 16));
          }
        }
      }
    }
  }
  return v18;
}

uint64_t ner_getSentenceData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  uint64_t v24;
  const char *v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int16 v31;
  __int16 v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int16 v43;
  size_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t *v49;
  __int16 v50;
  uint64_t v51;
  unsigned __int16 v52;
  unsigned __int16 v53;
  uint64_t UTF8Char;
  _BOOL4 IsChineseLetter;
  BOOL v56;
  uint64_t v57;
  size_t v58;
  char *v59;
  int v60;
  unsigned int v61;
  __int16 *v62;
  __int16 v63;
  uint64_t v64;
  int v65;
  unsigned __int16 v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t CharEmbeddingWithPOS;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v77;
  unsigned __int16 v78;
  __int16 *v79;
  uint64_t v80;
  int *v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  int v85;
  unsigned int v86;
  uint64_t v87;
  unsigned __int16 v88;
  int v89;
  unsigned int v90;
  unsigned __int16 v91;
  char __s[4];
  char v93;

  v18 = a1;
  v87 = 0;
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"ner: processing=\"%s\"", (uint64_t)a6, a7, a8, (uint64_t)a6);
  *(_WORD *)(a7 + 18) = 0;
  *(_QWORD *)(a7 + 8) = 0;
  if (a6)
  {
    v22 = strlen(a6);
    v23 = 1;
    v24 = v22;
    if (v22)
    {
      v25 = a6;
      do
      {
        v27 = *(unsigned __int8 *)v25++;
        v26 = v27;
        if (v27 == 95 || v26 == 32)
          ++v23;
        --v24;
      }
      while (v24);
      *(_WORD *)(a7 + 16) = v23;
      if (!v23)
        goto LABEL_11;
    }
    else
    {
      *(_WORD *)(a7 + 16) = 1;
    }
    v28 = 2314215434;
    v91 = 0;
    v89 = 0;
    v90 = 0;
    v88 = 0;
    v86 = 0;
    v29 = heap_Calloc(*(_QWORD **)(v18 + 8), v23, 40);
    *(_QWORD *)(a7 + 8) = v29;
    if (v29)
    {
      v30 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int16 *))(a4 + 104))(a2, a3, 2, a5, &v91);
      if ((v30 & 0x80000000) != 0)
      {
LABEL_68:
        v28 = v30;
      }
      else
      {
        v31 = v91;
        if (!v91)
        {
LABEL_77:
          *(_WORD *)(a7 + 16) = 0;
          heap_Free(*(_QWORD **)(v18 + 8), *(_QWORD *)(a7 + 8));
          *(_QWORD *)(a7 + 8) = 0;
          return v30;
        }
        v82 = a8;
        v32 = 0;
        v85 = 0;
        while (1)
        {
          v33 = (unsigned __int16)v85 - 1;
          while (1)
          {
            v34 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, char *))(a4 + 168))(a2, a3, v31, 0, 1, &v90, (char *)&v89 + 2);
            if ((v34 & 0x80000000) != 0)
              goto LABEL_78;
            if (v90 > 0xA || ((1 << v90) & 0x610) == 0)
              goto LABEL_59;
            v34 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(a4 + 168))(a2, a3, v91, 1, 1, &v89, (char *)&v89 + 2);
            if ((v34 & 0x80000000) != 0)
              goto LABEL_78;
            v34 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(a4 + 168))(a2, a3, v91, 2, 1, &v88, (char *)&v89 + 2);
            if ((v34 & 0x80000000) != 0)
              goto LABEL_78;
            v39 = v89;
            if ((unsigned __int16)v89 >= v88)
            {
              log_OutText(*(_QWORD *)(v18 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"ner: out of memory", v36, v37, v38, v77);
              v66 = 16049;
LABEL_87:
              v28 = v66 | 0x89F00000;
              goto LABEL_88;
            }
            ++v32;
            v40 = *(_QWORD *)(a7 + 8);
            if (!(_WORD)v85
              || (unsigned __int16)v89 != *(unsigned __int16 *)(v40 + 40 * v33 + 26)
              || v88 != *(unsigned __int16 *)(v40 + 40 * v33 + 28))
            {
              break;
            }
            v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a4 + 120))(a2, a3, v91, &v91);
            if ((v30 & 0x80000000) != 0)
              goto LABEL_68;
            v31 = v91;
            if (!v91)
              goto LABEL_70;
          }
          if (*(unsigned __int16 *)(a7 + 16) <= (unsigned __int16)v85)
          {
            *(_WORD *)(a7 + 16) = v85 + 1;
            v41 = heap_Realloc(*(uint64_t **)(v18 + 8), v40, 40 * (unsigned __int16)(v85 + 1));
            *(_QWORD *)(a7 + 8) = v41;
            if (!v41)
              break;
            v40 = v41;
            v39 = v89;
          }
          v42 = v40 + 40 * (unsigned __int16)v85;
          *(_WORD *)(v42 + 26) = v39;
          *(_WORD *)(v42 + 28) = v88;
          v43 = v88 - v89;
          *(_QWORD *)v42 = 0;
          v44 = v43;
          v45 = (char *)heap_Alloc(*(_QWORD *)(v18 + 8), v43 + 1);
          *(_QWORD *)(*(_QWORD *)(a7 + 8) + 40 * (unsigned __int16)v85) = v45;
          if (!v45)
            break;
          strncpy(v45, &a6[(unsigned __int16)v89], v44);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a7 + 8) + 40 * (unsigned __int16)v85) + v44) = 0;
          v46 = *(_QWORD *)(a7 + 8);
          v47 = v46 + 40 * (unsigned __int16)v85;
          v48 = *(const char **)v47;
          v79 = (__int16 *)(v47 + 24);
          v93 = 0;
          *(_DWORD *)__s = 0;
          v83 = (uint64_t *)v47;
          *(_QWORD *)(v47 + 16) = 0;
          v49 = (uint64_t *)(v47 + 16);
          v50 = Utf8_Utf8NbrOfSymbols(v48);
          if (v50 == 1)
          {
            v63 = 0;
          }
          else
          {
            v84 = v18;
            v51 = 0;
            v52 = 0;
            v81 = (int *)(v46 + 40 * (unsigned __int16)v85 + 32);
            v78 = v50 - 1;
            v80 = (unsigned __int16)(v50 - 1);
            while (1)
            {
              v53 = v52;
              UTF8Char = utf8_getUTF8Char(*v83, v52, __s);
              if ((UTF8Char & 0x80000000) != 0)
              {
                v28 = UTF8Char;
                v18 = v84;
                goto LABEL_88;
              }
              IsChineseLetter = utf8_IsChineseLetter(__s);
              if (strlen(__s) > 1
                || (__s[0] - 33 <= 0x3E
                  ? (v56 = ((1 << (__s[0] - 33)) & 0x7400000056003D8DLL) == 0)
                  : (v56 = 1),
                    v56 && __s[0] != 124))
              {
                if (!v51 && !IsChineseLetter)
                  break;
              }
              if (!v51)
              {
                *v81 = 0;
                v57 = heap_Calloc(*(_QWORD **)(v84 + 8), v80, 8);
                *v49 = v57;
                if (!v57)
                {
                  v18 = v84;
LABEL_86:
                  v66 = 8202;
                  goto LABEL_87;
                }
              }
              v58 = strlen(__s);
              *(_QWORD *)(*v49 + v51) = heap_Calloc(*(_QWORD **)(v84 + 8), v58 + 1, 1);
              v59 = *(char **)(*v49 + v51);
              if (!v59)
              {
                v73 = 0;
                v18 = v84;
                do
                {
                  v74 = *v49;
                  v75 = *(_QWORD *)(*v49 + v73);
                  if (v75)
                  {
                    heap_Free(*(_QWORD **)(v84 + 8), v75);
                    v74 = *v49;
                  }
                  *(_QWORD *)(v74 + v73) = 0;
                  v73 += 8;
                }
                while (8 * v78 != v73);
                heap_Free(*(_QWORD **)(v84 + 8), *v49);
                *v49 = 0;
                goto LABEL_86;
              }
              strcpy(v59, __s);
              v52 = v53 + strlen(__s);
              v51 += 8;
              if (8 * v80 == v51)
              {
                v18 = v84;
                v60 = v85;
                v28 = 2314215434;
                v61 = (unsigned __int16)v85;
                v63 = v78;
                v62 = v79;
                goto LABEL_56;
              }
            }
            if ((__s[0] & 0xDFu) - 65 < 0x1A)
              v65 = 1;
            else
              v65 = 3;
            if (__s[0] - 48 < 0xA)
              v65 = 2;
            *v81 = v65;
            v63 = 1;
            v18 = v84;
          }
          v28 = 2314215434;
          v60 = v85;
          v61 = (unsigned __int16)v85;
          v62 = v79;
LABEL_56:
          *v62 = v63;
          v64 = *(_QWORD *)(a7 + 8);
          *(_WORD *)(a7 + 18) += *(_WORD *)(v64 + 40 * v61 + 24);
          if (*(_DWORD *)(a7 + 32))
            (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *))(a4 + 176))(a2, a3, v91, 5, v64 + 40 * v61 + 8, (char *)&v89 + 2);
          v85 = v60 + 1;
LABEL_59:
          v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a4 + 120))(a2, a3, v91, &v91);
          if ((v30 & 0x80000000) != 0)
            goto LABEL_68;
          v31 = v91;
          if (!v91)
          {
LABEL_70:
            if (!v32)
              goto LABEL_77;
            v34 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(v82 + 40))(a9, a10, &v86);
            if ((v34 & 0x80000000) != 0)
            {
LABEL_78:
              v28 = v34;
              break;
            }
            v67 = v86;
            if (*(_DWORD *)(a7 + 32))
              v67 = v86 + *(unsigned __int16 *)(a7 + 40);
            v68 = heap_Calloc(*(_QWORD **)(v18 + 8), v67 * *(unsigned __int16 *)(a7 + 18), 4);
            v87 = v68;
            if (v68)
            {
              v69 = v68;
              v70 = *(_QWORD *)(a7 + 8);
              v71 = *(unsigned __int16 *)(a7 + 16);
              if (*(_DWORD *)(a7 + 32))
                CharEmbeddingWithPOS = getCharEmbeddingWithPOS(v18, v82, a9, a10, &v87, v86, v70, v71, *(unsigned __int16 *)(a7 + 40));
              else
                CharEmbeddingWithPOS = getCharEmbedding(v18, v82, a9, a10, &v87, v86, v70, v71);
              v28 = CharEmbeddingWithPOS;
              if ((CharEmbeddingWithPOS & 0x80000000) != 0)
              {
                ner_freeNEData(v18, a7);
                heap_Free(*(_QWORD **)(v18 + 8), v69);
              }
              else
              {
                *a11 = v69;
              }
              return v28;
            }
            break;
          }
        }
      }
    }
LABEL_88:
    ner_freeNEData(v18, a7);
    return v28;
  }
  *(_WORD *)(a7 + 16) = 0;
LABEL_11:
  *(_QWORD *)(a7 + 8) = 0;
  log_OutText(*(_QWORD *)(v18 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"ner: no words found", v19, v20, v21, v77);
  return 0;
}

uint64_t ner_freeNEData(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _WORD *v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 8);
    if (v3)
    {
      if (*(_WORD *)(a2 + 16))
      {
        v5 = 0;
        do
        {
          if (*(_QWORD *)(v3 + 40 * v5))
          {
            heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)(v3 + 40 * v5));
            v3 = *(_QWORD *)(a2 + 8);
            *(_QWORD *)(v3 + 40 * v5) = 0;
          }
          v6 = *(_QWORD *)(v3 + 40 * v5 + 16);
          if (v6)
          {
            v7 = v3 + 40 * v5;
            v9 = *(unsigned __int16 *)(v7 + 24);
            v8 = (_WORD *)(v7 + 24);
            if (v9)
            {
              v10 = 0;
              do
              {
                if (*(_QWORD *)(*(_QWORD *)(v3 + 40 * v5 + 16) + 8 * v10))
                {
                  heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)(*(_QWORD *)(v3 + 40 * v5 + 16) + 8 * v10));
                  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 40 * v5 + 16) + 8 * v10) = 0;
                  v3 = *(_QWORD *)(a2 + 8);
                }
                ++v10;
                v11 = v3 + 40 * v5;
                v12 = *(unsigned __int16 *)(v11 + 24);
                v8 = (_WORD *)(v11 + 24);
              }
              while (v10 < v12);
              v6 = *(_QWORD *)(v3 + 40 * v5 + 16);
            }
            *v8 = 0;
            heap_Free(*(_QWORD **)(a1 + 8), v6);
            v3 = *(_QWORD *)(a2 + 8);
            *(_QWORD *)(v3 + 40 * v5 + 16) = 0;
          }
          ++v5;
        }
        while (v5 < *(unsigned __int16 *)(a2 + 16));
      }
      heap_Free(*(_QWORD **)(a1 + 8), v3);
      *(_WORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 8) = 0;
    }
  }
  return 0;
}

uint64_t getCharEmbeddingWithPOS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int a6, uint64_t a7, unsigned int a8, unsigned int a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned __int16 *v18;
  int v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  char **v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  char **v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;

  if (a8)
  {
    v12 = 0;
    v13 = 0;
    v14 = *a5;
    v34 = a6;
    v35 = a8;
    v15 = 4 * a6;
    v39 = v15 + 4 * a9;
    while (1)
    {
      v16 = a7 + 40 * v12;
      v19 = *(unsigned __int16 *)(v16 + 24);
      v18 = (unsigned __int16 *)(v16 + 24);
      v17 = v19;
      v37 = v12;
      if (v19)
      {
        if (v17 != 1)
        {
          v22 = 0;
          v23 = a7 + 40 * v12;
          v24 = (_QWORD *)(v23 + 16);
          v25 = (char **)(v23 + 8);
          do
          {
            v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a2 + 56))(a3, a4, *(_QWORD *)(*v24 + 8 * v22), v14);
            if ((v13 & 0x1FFF) == 0x14)
            {
              log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v26, v27, v28, *(_QWORD *)(*v24 + 8 * v22));
              v13 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
            }
            v40 = v14 + v15;
            getPOSFeature(*v25, &v40);
            v14 += v39;
            v40 = v14;
            ++v22;
          }
          while (v22 < *v18);
          goto LABEL_21;
        }
        v20 = *(_DWORD *)(a7 + 40 * v12 + 32);
        switch(v20)
        {
          case 1:
            v21 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "ENG", v14);
            break;
          case 2:
            v21 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "NUM", v14);
            break;
          case 3:
            v21 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
            break;
          default:
            v29 = 0;
            v30 = a7 + 40 * v12;
            v31 = (_QWORD *)(v30 + 16);
            v32 = (char **)(v30 + 8);
            do
            {
              v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a2 + 56))(a3, a4, *(_QWORD *)(*v31 + 8 * v29), v14);
              if ((v13 & 0x1FFF) == 0x14)
                v13 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
              v40 = v14 + v15;
              getPOSFeature(*v32, &v40);
              v14 += v39;
              v40 = v14;
              ++v29;
            }
            while (v29 < *v18);
            goto LABEL_21;
        }
        v13 = v21;
        v14 += 4 * v34;
        v40 = v14;
      }
LABEL_21:
      v12 = v37 + 1;
      if (v37 + 1 == v35)
        return v13;
    }
  }
  return 0;
}

uint64_t getCharEmbedding(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int a6, uint64_t a7, unsigned int a8)
{
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned __int16 *v18;
  int v19;
  unsigned int v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!a8)
    return 0;
  v12 = 0;
  result = 0;
  v14 = *a5;
  v15 = 4 * a6;
  v28 = a6;
  v29 = a8;
  v30 = a7;
  do
  {
    v16 = a7 + 40 * v12;
    v19 = *(unsigned __int16 *)(v16 + 24);
    v18 = (unsigned __int16 *)(v16 + 24);
    v17 = v19;
    if (v19)
    {
      if (v17 == 1)
      {
        v20 = *(_DWORD *)(a7 + 40 * v12 + 32) - 1;
        if (v20 >= 3)
        {
          v26 = 0;
          v27 = (_QWORD *)(a7 + 40 * v12 + 16);
          do
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a2 + 56))(a3, a4, *(_QWORD *)(*v27 + 8 * v26), v14);
            if ((result & 0x1FFF) == 0x14)
              result = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
            ++v26;
            v14 += v15;
          }
          while (v26 < *v18);
        }
        else
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t))(a2 + 56))(a3, a4, off_1EA93ED38[v20], v14);
          v14 += 4 * v28;
        }
      }
      else
      {
        v21 = 0;
        v22 = (_QWORD *)(a7 + 40 * v12 + 16);
        do
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a2 + 56))(a3, a4, *(_QWORD *)(*v22 + 8 * v21), v14);
          if ((result & 0x1FFF) == 0x14)
          {
            log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v23, v24, v25, *(_QWORD *)(*v22 + 8 * v21));
            result = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
          }
          ++v21;
          v14 += v15;
        }
        while (v21 < *v18);
      }
    }
    ++v12;
    a7 = v30;
  }
  while (v12 != v29);
  return result;
}

uint64_t getPOSFeature(char *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t result;
  unsigned int v4;
  uint64_t v5;
  _BYTE v6[2];

  v2 = *a2;
  result = utf8_ToLower(a1, 0, (uint64_t)v6);
  v4 = v6[0] - 99;
  if (v4 > 0x16)
    v5 = 0;
  else
    v5 = qword_1DEC65578[(char)v4];
  *(_DWORD *)(v2 + 4 * v5) = 1065353216;
  return result;
}

uint64_t hlp_loadOptions(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v19;

  v2 = a1[13];
  if (v2)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v2);
    a1[15] = 0;
  }
  v3 = heap_Alloc(*(_QWORD *)(*a1 + 8), 128);
  a1[13] = v3;
  if (v3)
  {
    a1[15] = 128;
    v8 = a1[14];
    if (v8)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v8);
      a1[16] = 0;
    }
    v9 = heap_Alloc(*(_QWORD *)(*a1 + 8), 128);
    a1[14] = v9;
    if (v9)
    {
      a1[16] = 128;
      v10 = a1[19];
      if (v10)
        heap_Free(*(_QWORD **)(*a1 + 8), v10);
      v11 = heap_Alloc(*(_QWORD *)(*a1 + 8), 128);
      a1[19] = v11;
      if (v11)
      {
        v12 = a1[20];
        if (v12)
          heap_Free(*(_QWORD **)(*a1 + 8), v12);
        v13 = heap_Alloc(*(_QWORD *)(*a1 + 8), 128);
        a1[20] = v13;
        if (v13)
        {
          v14 = a1[21];
          if (v14)
            heap_Free(*(_QWORD **)(*a1 + 8), v14);
          v15 = heap_Alloc(*(_QWORD *)(*a1 + 8), 128);
          a1[21] = v15;
          if (v15)
          {
            v16 = a1[22];
            if (v16)
              heap_Free(*(_QWORD **)(*a1 + 8), v16);
            v17 = heap_Alloc(*(_QWORD *)(*a1 + 8), 128);
            a1[22] = v17;
            if (v17)
              return 0;
          }
        }
      }
    }
  }
  log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v4, v5, v6, v7, v19);
  return 2314215434;
}

uint64_t hlp_loadNNOptions(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  char *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  char *v13;
  const char *v14;
  char *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  _QWORD *v22;
  uint64_t v23;
  char *v24;
  char *i;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  char *v31;
  size_t v32;
  uint64_t v33;
  char *v34;
  size_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  char *v39;
  size_t v40;
  uint64_t v41;
  char *v42;
  size_t v43;
  unsigned int v45;
  __int128 v46;
  uint64_t (*v47)(const char *, const char *);
  uint64_t (*v48)(const char *, uint64_t, char **);
  _QWORD *(*v49)(_QWORD *, _QWORD *);
  char *v50;
  char *__lasts;
  _BYTE __c[11];

  v2 = 2314216452;
  *(_QWORD *)&__c[3] = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  v50 = 0;
  __lasts = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_nn_chars", &__c[3], &__c[1], __c) & 0x80000000) != 0|| !*(_WORD *)&__c[1])
  {
    return v2;
  }
  v3 = **(const char ***)&__c[3];
  v4 = strchr(**(char ***)&__c[3], __c[0]);
  if (v4)
  {
    *v4 = 0;
    v3 = **(const char ***)&__c[3];
  }
  v5 = strlen(v3);
  v6 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), v5 + 1);
  if (!v6)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v7, v8, v9, v10, v45);
    return 2314215434;
  }
  v11 = (char *)v6;
  v12 = strlen(**(const char ***)&__c[3]);
  strncpy(v11, **(const char ***)&__c[3], v12);
  v11[strlen(**(const char ***)&__c[3])] = 0;
  *(_WORD *)&__c[1] = -1;
  v13 = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_nn_default_phones", &__c[3], &__c[1], __c) & 0x80000000) != 0|| !*(_WORD *)&__c[1])
  {
    goto LABEL_38;
  }
  v14 = **(const char ***)&__c[3];
  v15 = strchr(**(char ***)&__c[3], __c[0]);
  if (v15)
  {
    *v15 = 0;
    v14 = **(const char ***)&__c[3];
  }
  v16 = strlen(v14);
  v13 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), v16 + 1);
  if (!v13)
    goto LABEL_36;
  v21 = strlen(**(const char ***)&__c[3]);
  strncpy(v13, **(const char ***)&__c[3], v21);
  v13[strlen(**(const char ***)&__c[3])] = 0;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8);
  *(_QWORD *)&v46 = ssftmap_ElemCopyString;
  *((_QWORD *)&v46 + 1) = ssftmap_ElemFreeString;
  v47 = ssftmap_ElemCompareKeysString;
  v48 = ssftmap_ElemCopyString;
  v49 = ssftmap_ElemFreeString;
  v23 = ssftmap_ObjOpen(v22, 0, &v46, (uint64_t *)(a1 + 248));
  if ((v23 & 0x80000000) != 0)
  {
LABEL_18:
    v2 = v23;
    goto LABEL_38;
  }
  v24 = strtok_r(v11, "|", &__lasts);
  for (i = v13; ; i = 0)
  {
    v26 = strtok_r(i, "|", &v50);
    if (!v24 || !v26)
      break;
    v23 = ssftmap_Insert(*(_QWORD *)(a1 + 248), (uint64_t)v24, (uint64_t)v26);
    if ((v23 & 0x80000000) != 0)
      goto LABEL_18;
    v24 = strtok_r(0, "|", &__lasts);
  }
  if (v24 || v26)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"NN chars amount and default phones amount do not match!", v27, v28, v29, 0);
    v2 = 2314215439;
    goto LABEL_38;
  }
  *(_WORD *)&__c[1] = -1;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_nn_step", &__c[3], &__c[1], __c) & 0x80000000) == 0)
  {
    if (*(_WORD *)&__c[1])
    {
      *(_DWORD *)(a1 + 256) = 0;
      *(_DWORD *)(a1 + 256) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_nn_vect", &__c[3], &__c[1], __c) & 0x80000000) == 0)
      {
        if (*(_WORD *)&__c[1])
        {
          *(_DWORD *)(a1 + 260) = 0;
          *(_DWORD *)(a1 + 260) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
          *(_WORD *)&__c[1] = -1;
          if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_nn_null_fea", &__c[3], &__c[1], __c) & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
            {
              *(_QWORD *)(a1 + 272) = 0;
              v30 = **(const char ***)&__c[3];
              v31 = strchr(**(char ***)&__c[3], __c[0]);
              if (v31)
              {
                *v31 = 0;
                v30 = **(const char ***)&__c[3];
              }
              v32 = strlen(v30);
              v33 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), v32 + 1);
              *(_QWORD *)(a1 + 272) = v33;
              if (v33)
              {
                v34 = (char *)v33;
                v35 = strlen(**(const char ***)&__c[3]);
                strncpy(v34, **(const char ***)&__c[3], v35);
                *(_BYTE *)(*(_QWORD *)(a1 + 272) + strlen(**(const char ***)&__c[3])) = 0;
                *(_WORD *)&__c[1] = -1;
                v36 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_embed_type", &__c[3], &__c[1], __c);
                if ((v36 & 0x80000000) == 0 && *(_WORD *)&__c[1])
                {
                  v37 = v36;
                  *(_QWORD *)(a1 + 264) = 0;
                  v38 = **(const char ***)&__c[3];
                  v39 = strchr(**(char ***)&__c[3], __c[0]);
                  if (v39)
                  {
                    *v39 = 0;
                    v38 = **(const char ***)&__c[3];
                  }
                  v40 = strlen(v38);
                  v41 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), v40 + 1);
                  *(_QWORD *)(a1 + 264) = v41;
                  if (v41)
                  {
                    v42 = (char *)v41;
                    v43 = strlen(**(const char ***)&__c[3]);
                    strncpy(v42, **(const char ***)&__c[3], v43);
                    *(_BYTE *)(*(_QWORD *)(a1 + 264) + strlen(**(const char ***)&__c[3])) = 0;
                    v2 = v37;
                    goto LABEL_38;
                  }
                  goto LABEL_36;
                }
                goto LABEL_38;
              }
LABEL_36:
              log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v45);
              v2 = 2314215434;
            }
          }
        }
      }
    }
  }
LABEL_38:
  heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v11);
  if (v13)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v13);
  return v2;
}

uint64_t hlp_loadStatWordOptions(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  char *v8;
  size_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  unsigned int v22;
  _BYTE __c[11];

  *(_QWORD *)&__c[3] = 0;
  __c[0] = 0;
  *(_WORD *)&__c[1] = -1;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_step", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0)
    return v2;
  *(_DWORD *)(a1 + 320) = 0;
  if (*(_WORD *)&__c[1])
    *(_DWORD *)(a1 + 320) = LH_atou(**(const char ***)&__c[3]);
  *(_WORD *)&__c[1] = -1;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_vect", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0)
    return v2;
  *(_DWORD *)(a1 + 324) = 0;
  if (*(_WORD *)&__c[1])
    *(_DWORD *)(a1 + 324) = LH_atou(**(const char ***)&__c[3]);
  *(_WORD *)&__c[1] = -1;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_thresholdpercent", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0)
    return v2;
  *(_DWORD *)(a1 + 328) = 0;
  if (*(_WORD *)&__c[1])
    *(_DWORD *)(a1 + 328) = LH_atou(**(const char ***)&__c[3]);
  *(_WORD *)&__c[1] = -1;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_list", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0)
    return v2;
  if (*(_WORD *)&__c[1])
  {
    v7 = **(const char ***)&__c[3];
    v8 = strchr(**(char ***)&__c[3], __c[0]);
    if (v8)
    {
      *v8 = 0;
      v7 = **(const char ***)&__c[3];
    }
    v9 = strlen(v7);
    v10 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), v9 + 1);
    *(_QWORD *)(a1 + 336) = v10;
    if (v10)
    {
      strcpy(v10, **(const char ***)&__c[3]);
      strcpy((char *)(a1 + 364), "$MEANW2V$");
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_fbck", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
      {
        v15 = strchr(**(char ***)&__c[3], __c[0]);
        if (v15)
          *v15 = 0;
        __strcpy_chk();
      }
      *(_QWORD *)(a1 + 344) = 0x2D3A3F2E213B2CLL;
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_punc", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
      {
        v16 = strchr(**(char ***)&__c[3], __c[0]);
        if (v16)
          *v16 = 0;
        __strcpy_chk();
      }
      *(_QWORD *)(a1 + 354) = 0x30303433333030;
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_mappunc", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
      {
        v17 = strchr(**(char ***)&__c[3], __c[0]);
        if (v17)
          *v17 = 0;
        __strcpy_chk();
      }
      *(_DWORD *)(a1 + 376) = 0;
      *(_WORD *)&__c[1] = -1;
      v18 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_nnlkpcaseconv", &__c[3], &__c[1], __c);
      if ((v18 & 0x80000000) == 0 && *(_WORD *)&__c[1])
      {
        v19 = **(const char ***)&__c[3];
        v20 = strchr(**(char ***)&__c[3], __c[0]);
        if (v20)
        {
          *v20 = 0;
          v19 = **(const char ***)&__c[3];
        }
        if (!strcmp("yes", v19) || !strcmp("YES", v19))
          *(_DWORD *)(a1 + 376) = 1;
      }
      *(_QWORD *)(a1 + 264) = 0;
    }
    else
    {
      v18 = 2314215434;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v11, v12, v13, v14, v22);
    }
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v3, v4, v5, v6, v22);
    return 2314215444;
  }
  return v18;
}

uint64_t fe_hmogrph_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t Object;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t OptionalHmogrphModels;
  BOOL v28;
  _BOOL4 v29;
  uint64_t v30;
  int v31;
  __int16 v32;
  _BOOL4 v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *__s;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  _OWORD v61[16];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v59 = 0;
  v60 = 0;
  v5 = 2314215431;
  v57 = 0;
  v58 = 0;
  v55 = 0;
  v56 = 0;
  v52 = 0;
  v53 = 0;
  memset(v61, 0, sizeof(v61));
  if (!a5)
    return v5;
  __s = 0;
  v51 = 0;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a1, a2, &v59);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(a3, a4, &v60);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = objc_GetObject(v60[6], (uint64_t)"LINGDB", &v58);
  if ((inited & 0x80000000) != 0)
    return inited;
  Object = objc_GetObject(v60[6], (uint64_t)"FE_DCTLKP", &v56);
  v13 = v60[6];
  if ((Object & 0x80000000) != 0)
  {
    v34 = "LINGDB";
LABEL_25:
    objc_ReleaseObject(v13, (uint64_t)v34);
    return Object;
  }
  v14 = objc_GetObject(v13, (uint64_t)"FE_DEPES", &v57);
  if ((v14 & 0x80000000) != 0)
  {
    Object = v14;
    objc_ReleaseObject(v60[6], (uint64_t)"LINGDB");
    v13 = v60[6];
    v34 = "FE_DCTLKP";
    goto LABEL_25;
  }
  v15 = heap_Alloc(v60[1], 488);
  if (!v15)
  {
    log_OutPublic(v60[4], (uint64_t)"FE_HMOGRPH", 37000, 0, v16, v17, v18, v19, v46);
    objc_ReleaseObject(v60[6], (uint64_t)"LINGDB");
    objc_ReleaseObject(v60[6], (uint64_t)"FE_DEPES");
    objc_ReleaseObject(v60[6], (uint64_t)"FE_DCTLKP");
    return 2314215434;
  }
  v20 = v15;
  *(_QWORD *)v15 = v60;
  *(_QWORD *)(v15 + 8) = a3;
  v21 = v59;
  *(_QWORD *)(v15 + 16) = a4;
  *(_QWORD *)(v15 + 24) = v21;
  *(_QWORD *)(v15 + 32) = a1;
  *(_QWORD *)(v15 + 40) = a2;
  *(_QWORD *)(v15 + 48) = *(_QWORD *)(v58 + 8);
  v22 = v57;
  *(_QWORD *)(v15 + 72) = *(_QWORD *)(v57 + 8);
  *(_OWORD *)(v15 + 56) = *(_OWORD *)(v22 + 16);
  v23 = v56;
  v24 = *(_QWORD *)(v56 + 8);
  *(_QWORD *)(v15 + 96) = v24;
  v25 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)(v15 + 200) = 0u;
  v26 = v15 + 200;
  *(_OWORD *)(v15 + 80) = v25;
  *(_OWORD *)(v15 + 104) = 0u;
  *(_OWORD *)(v15 + 120) = 0u;
  *(_WORD *)(v15 + 136) = 0;
  *(_OWORD *)(v15 + 152) = 0u;
  *(_OWORD *)(v15 + 168) = 0u;
  *(_OWORD *)(v15 + 216) = 0u;
  *(_OWORD *)(v15 + 232) = 0u;
  *(_OWORD *)(v15 + 248) = 0u;
  *(_OWORD *)(v15 + 264) = 0u;
  *(_OWORD *)(v15 + 280) = 0u;
  *(_OWORD *)(v15 + 296) = 0u;
  *(_OWORD *)(v15 + 312) = 0u;
  *(_OWORD *)(v15 + 328) = 0u;
  *(_OWORD *)(v15 + 344) = 0u;
  *(_OWORD *)(v15 + 360) = 0u;
  *(_QWORD *)(v15 + 376) = 0;
  *(_QWORD *)(v15 + 472) = 0;
  *(_OWORD *)(v15 + 440) = 0u;
  *(_OWORD *)(v15 + 456) = 0u;
  *(_OWORD *)(v15 + 408) = 0u;
  *(_OWORD *)(v15 + 424) = 0u;
  *(_OWORD *)(v15 + 392) = 0u;
  *(_QWORD *)(v15 + 188) = 0;
  *(_DWORD *)(v15 + 384) = 0;
  *(_DWORD *)(v15 + 480) = 0;
  *(_QWORD *)(v15 + 280) = 0;
  OptionalHmogrphModels = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(v24 + 88))(*(_QWORD *)(v15 + 80), *(_QWORD *)(v15 + 88), (char *)&v53 + 4, &v53);
  if ((OptionalHmogrphModels & 0x80000000) != 0)
    goto LABEL_53;
  v28 = (_DWORD)v53 == 1 && HIDWORD(v53) == 1;
  v29 = v28;
  *(_DWORD *)(v20 + 184) = v29;
  OptionalHmogrphModels = hlp_loadOptionalHmogrphModels(v20);
  if ((OptionalHmogrphModels & 0x80000000) != 0)
    goto LABEL_53;
  OptionalHmogrphModels = hlp_loadNerOptions(v20);
  if ((OptionalHmogrphModels & 0x80000000) != 0)
    goto LABEL_53;
  v30 = *(_QWORD *)v20;
  *(_QWORD *)(v20 + 200) = *(_QWORD *)v20;
  v31 = paramc_ParamGet(*(_QWORD *)(v30 + 40), (uint64_t)"numberoutputtranscriptions", &__s, 0);
  v32 = 0;
  if ((v31 & 0x80000000) == 0 && __s)
    v32 = atoi(__s);
  *(_WORD *)(v20 + 138) = v32;
  v33 = (paramc_ParamGet(*(_QWORD *)(*(_QWORD *)v20 + 40), (uint64_t)"mlset", &__s, 0) & 0x80000000) == 0
     && strlen(__s) > 3;
  *(_DWORD *)(v20 + 140) = v33;
  OptionalHmogrphModels = checkSkipCrosstoken(*(_QWORD *)(v20 + 80), *(_QWORD *)(v20 + 88), *(_QWORD *)(v20 + 96), (_DWORD *)(v20 + 144));
  if ((OptionalHmogrphModels & 0x80000000) != 0)
    goto LABEL_53;
  if (*(_DWORD *)(v20 + 144))
  {
    OptionalHmogrphModels = hlp_loadOptions((_QWORD *)v20);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
      goto LABEL_53;
  }
  if (!*(_DWORD *)(v20 + 188))
    goto LABEL_49;
  if (*(_DWORD *)(v20 + 480))
  {
    v50 = 0;
    v48 = 0u;
    v49 = 0u;
    OptionalHmogrphModels = hlp_loadStatWordOptions(v20);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
      goto LABEL_53;
    OptionalHmogrphModels = nn_word_lkp_GetInterface(1u, &v51);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
      goto LABEL_53;
    *(_QWORD *)(v20 + 280) = v51;
    *(_QWORD *)(v20 + 288) = safeh_GetNullHandle();
    *(_QWORD *)(v20 + 296) = v35;
    *(_QWORD *)(v20 + 304) = safeh_GetNullHandle();
    *(_QWORD *)(v20 + 312) = v36;
    OptionalHmogrphModels = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _WORD *, uint64_t, uint64_t))(v51 + 16))(*(_QWORD *)(v20 + 288), *(_QWORD *)(v20 + 296), "word", a3, a4, v20 + 304);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
      goto LABEL_53;
    v49 = *(_OWORD *)(v20 + 304);
    *((_QWORD *)&v48 + 1) = v51;
    OptionalHmogrphModels = objc_RegisterObject(v60[6], (uint64_t)"NNWRDLKP", &v48);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
      goto LABEL_53;
    goto LABEL_46;
  }
  if (*(_DWORD *)(v20 + 192))
  {
    OptionalHmogrphModels = hlp_loadNNOptions(v20);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
    {
LABEL_53:
      v5 = OptionalHmogrphModels;
      fe_hmogrph_ObjClose(*(_QWORD *)a5, *(_QWORD *)(a5 + 8));
      return v5;
    }
    v37 = strcmp(*(const char **)(v20 + 264), "albert");
    if ((objc_GetObject(v60[6], (uint64_t)"NNCHRLKP", &v55) & 0x80000000) != 0 || !v37)
    {
      OptionalHmogrphModels = nn_word_lkp_GetInterface(1u, &v51);
      if ((OptionalHmogrphModels & 0x80000000) != 0)
        goto LABEL_53;
      *(_QWORD *)(v20 + 280) = v51;
      *(_QWORD *)(v20 + 288) = safeh_GetNullHandle();
      *(_QWORD *)(v20 + 296) = v39;
      *(_QWORD *)(v20 + 304) = safeh_GetNullHandle();
      *(_QWORD *)(v20 + 312) = v40;
      OptionalHmogrphModels = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _WORD *, uint64_t, uint64_t))(v51 + 16))(*(_QWORD *)(v20 + 288), *(_QWORD *)(v20 + 296), *(_QWORD *)(v20 + 264), a3, a4, v20 + 304);
      if ((OptionalHmogrphModels & 0x80000000) != 0)
        goto LABEL_53;
    }
    else
    {
      *(_QWORD *)(v20 + 280) = *(_QWORD *)(v55 + 8);
      *(_QWORD *)(v20 + 288) = safeh_GetNullHandle();
      *(_QWORD *)(v20 + 296) = v38;
      *(_OWORD *)(v20 + 304) = *(_OWORD *)(v55 + 16);
    }
LABEL_46:
    inited = fi_model_getBrokerString(*(_QWORD *)v20, (char *)v61);
    if ((inited & 0x80000000) == 0)
    {
      v41 = fi_init(a3, a4, a1, a2, &v52, 0, (uint64_t)v61, (uint64_t)"FINN", 1, 0);
      if ((v41 & 0x80000000) != 0)
      {
        v5 = v41;
        log_OutText(*(_QWORD *)(*(_QWORD *)v20 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"create FI model failed", v42, v43, v44, v47);
        return v5;
      }
      *(_QWORD *)(v20 + 240) = v52;
      goto LABEL_49;
    }
    return inited;
  }
  *(_QWORD *)(v20 + 240) = 0;
LABEL_49:
  v5 = init_ner_struct(v20, (_QWORD *)(v26 + 192));
  if ((v5 & 0x80000000) == 0)
  {
    *(_QWORD *)a5 = v20;
    *(_DWORD *)(a5 + 8) = 62342;
  }
  return v5;
}

uint64_t hlp_loadOptionalHmogrphModels(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  char *v4;
  _BYTE __c[11];

  if ((com_useStatHmogrph(*(_QWORD *)a1, (_DWORD *)(a1 + 188)) & 0x80000000) == 0)
  {
    *(_WORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 200) = 0;
    if (*(_DWORD *)(a1 + 188))
    {
      if ((stat_hmogrph_ModelInit(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)a1, *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), (uint64_t *)(a1 + 224), (_WORD *)(a1 + 232), (unsigned __int16 *)(a1 + 234)) & 0x80000000) == 0)*(_QWORD *)(a1 + 200) = *(_QWORD *)a1;
    }
  }
  *(_QWORD *)&__c[3] = 0;
  __c[0] = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(_WORD *)&__c[1] = -1;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "statwordhmogrph_step", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(unsigned __int16 *)&__c[1] == 1)
  {
    *(_DWORD *)(a1 + 188) = 1;
    *(_DWORD *)(a1 + 480) = 1;
  }
  *(_DWORD *)(a1 + 192) = 0;
  *(_WORD *)&__c[1] = -1;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "stathmogrph_enable_nnets", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) == 0 && *(unsigned __int16 *)&__c[1] == 1 && *(_QWORD *)&__c[3])
  {
    v3 = **(const char ***)&__c[3];
    v4 = strchr(**(char ***)&__c[3], __c[0]);
    if (v4)
    {
      *v4 = 0;
      v3 = **(const char ***)&__c[3];
    }
    if (!strcmp("yes", v3) || !strcmp("YES", v3))
      *(_DWORD *)(a1 + 192) = 1;
  }
  return v2;
}

uint64_t hlp_loadNerOptions(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  char v6;
  __int16 v7;
  const char **v8;
  const char **v9;
  const char **v10;

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v7 = -1;
  v6 = 0;
  v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, const char ***, __int16 *, char *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "ner_enable_ner", &v10, &v7, &v6);
  if ((v2 & 0x80000000) == 0)
  {
    if (v7 && v10)
    {
      (*v10)[strlen(*v10) - 1] = 0;
      v3 = strcmp(*v10, "yes");
      *(_DWORD *)(a1 + 384) = v3 == 0;
      if (!v3)
      {
        v7 = -1;
        v6 = 0;
        *(_DWORD *)(a1 + 428) = 0;
        if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, const char ***, __int16 *, char *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "ner_embed_type", &v9, &v7, &v6) & 0x80000000) == 0&& v7&& v9)
        {
          (*v9)[strlen(*v9) - 1] = 0;
          *(_DWORD *)(a1 + 428) = strcmp(*v9, "char") == 0;
        }
        v7 = -1;
        v6 = 0;
        v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, const char ***, __int16 *, char *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "ner_enable_pos", &v9, &v7, &v6);
        if ((v2 & 0x80000000) == 0)
        {
          if (v7 && v9)
          {
            (*v9)[strlen(*v9) - 1] = 0;
            v4 = strcmp(*v9, "yes");
            *(_DWORD *)(a1 + 424) = v4 == 0;
            if (!v4)
            {
              v7 = -1;
              v6 = 0;
              v2 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, const char ***, __int16 *, char *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", "ner_pos_dimension", &v8, &v7, &v6);
              if ((v2 & 0x80000000) == 0)
                *(_WORD *)(a1 + 432) = (unsigned __int16)LH_atou(*v8);
            }
          }
          else
          {
            *(_DWORD *)(a1 + 424) = 0;
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 384) = 0;
    }
  }
  return v2;
}

uint64_t checkSkipCrosstoken(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5;
  const char *v7;
  char *v8;
  _BYTE __c[11];

  *(_QWORD *)&__c[3] = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  *a4 = 0;
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(a3 + 96))(a1, a2, "fecfg", "feoneword_skipcrosstoken", &__c[3], &__c[1], __c);
  if ((v5 & 0x80000000) == 0 && *(unsigned __int16 *)&__c[1] == 1 && *(_QWORD *)&__c[3] != 0)
  {
    v7 = **(const char ***)&__c[3];
    v8 = strchr(**(char ***)&__c[3], __c[0]);
    if (v8)
    {
      *v8 = 0;
      v7 = **(const char ***)&__c[3];
    }
    if (!strcmp("yes", v7) || !strcmp("YES", v7))
      *a4 = 1;
  }
  return v5;
}

uint64_t fi_model_getBrokerString(uint64_t a1, char *a2)
{
  uint64_t result;
  uint64_t v5;
  int v6[2];
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  *(_QWORD *)v6 = 0;
  memset(v7, 0, sizeof(v7));
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v6);
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v5);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v7, 1, 1, *(char **)v6, 0, 0, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t init_ner_struct(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t Interface;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  _OWORD v15[16];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  memset(v15, 0, sizeof(v15));
  v14 = 0;
  *a2 = 0;
  if (!*(_DWORD *)(a1 + 384))
    return 0;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = safeh_GetNullHandle();
  *(_QWORD *)(a1 + 456) = v4;
  *(_QWORD *)(a1 + 464) = safeh_GetNullHandle();
  *(_QWORD *)(a1 + 472) = v5;
  v6 = *(const char **)(a1 + 264);
  if (v6)
  {
    if (strcmp(v6, "char"))
    {
      if (*(_DWORD *)(a1 + 428) == 1)
      {
        Interface = nn_word_lkp_GetInterface(1u, (_QWORD *)(a1 + 440));
        if ((Interface & 0x80000000) != 0)
          return Interface;
        Interface = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 440) + 16))(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 456), "char", *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a1 + 464);
        if ((Interface & 0x80000000) != 0)
          return Interface;
      }
    }
  }
  get_ner_brokerstring(*(_QWORD *)a1, (char *)v15, 0x100uLL);
  v11 = fi_init(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), &v14, 0, (uint64_t)v15, (uint64_t)"FINN", 1, 0);
  if ((v11 & 0x80000000) != 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Init NER FI model failed", v8, v9, v10, v13);
  else
    *a2 = v14;
  return v11;
}

uint64_t fe_hmogrph_ObjClose(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;

  result = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((result & 0x80000000) != 0)
    return 2314215432;
  if (!a1)
    return result;
  v9 = *(_QWORD *)(a1 + 104);
  if (v9)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v9);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  v10 = *(_QWORD *)(a1 + 112);
  if (v10)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v10);
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  v11 = *(_QWORD *)(a1 + 152);
  if (v11)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v11);
  *(_QWORD *)(a1 + 152) = 0;
  v12 = *(_QWORD *)(a1 + 160);
  if (v12)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v12);
  *(_QWORD *)(a1 + 160) = 0;
  v13 = *(_QWORD *)(a1 + 168);
  if (v13)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v13);
  *(_QWORD *)(a1 + 168) = 0;
  v14 = *(_QWORD *)(a1 + 176);
  if (v14)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v14);
  *(_QWORD *)(a1 + 176) = 0;
  v15 = *(_QWORD *)(a1 + 280);
  if (v15)
  {
    if (*(_DWORD *)(a1 + 480))
    {
      if (((*(uint64_t (**)(_QWORD, _QWORD))(v15 + 24))(*(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312)) & 0x80000000) == 0)
        objc_UnregisterObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"NNWRDLKP");
    }
    else if (*(_DWORD *)(a1 + 192)
           && (objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"NNCHRLKP") & 0x80000000) != 0)
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 280) + 24))(*(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312));
    }
    *(_QWORD *)(a1 + 280) = 0;
  }
  if (*(_DWORD *)(a1 + 188))
  {
    if (*(_DWORD *)(a1 + 480))
    {
      v16 = *(_QWORD *)(a1 + 336);
      if (v16)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v16);
        *(_QWORD *)(a1 + 336) = 0;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 192))
      {
LABEL_37:
        if (*(_WORD *)(a1 + 232))
          stat_hmogrph_ModelDeinit(*(_QWORD *)a1, (uint64_t *)(a1 + 224), *(unsigned __int16 *)(a1 + 232), v4, v5, v6, v7, v8);
        goto LABEL_39;
      }
      v17 = *(_QWORD *)(a1 + 272);
      if (v17)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v17);
        *(_QWORD *)(a1 + 272) = 0;
      }
      v18 = *(_QWORD *)(a1 + 248);
      if (v18)
      {
        ssftmap_ObjClose(v18);
        *(_QWORD *)(a1 + 248) = 0;
      }
      v19 = *(_QWORD *)(a1 + 264);
      if (v19)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v19);
        *(_QWORD *)(a1 + 264) = 0;
      }
    }
    v20 = *(uint64_t **)(a1 + 240);
    if (v20)
    {
      fi_deinit(*(_QWORD *)a1, *(_QWORD *)(a1 + 24), v20);
      *(_QWORD *)(a1 + 240) = 0;
    }
    goto LABEL_37;
  }
LABEL_39:
  if (*(_DWORD *)(a1 + 384))
  {
    v21 = *(uint64_t **)(a1 + 392);
    if (v21)
    {
      fi_deinit(*(_QWORD *)a1, *(_QWORD *)(a1 + 24), v21);
      *(_QWORD *)(a1 + 392) = 0;
    }
    v22 = *(_QWORD *)(a1 + 440);
    if (v22)
    {
      (*(void (**)(_QWORD, _QWORD))(v22 + 24))(*(_QWORD *)(a1 + 464), *(_QWORD *)(a1 + 472));
      *(_QWORD *)(a1 + 440) = 0;
    }
  }
  objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"LINGDB");
  objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"FE_DEPES");
  objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"FE_DCTLKP");
  heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), a1);
  return 0;
}

uint64_t fe_hmogrph_ObjReopen(uint64_t a1, int a2)
{
  uint64_t Options;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  __int16 v34;
  _BOOL4 v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *__s;
  _OWORD v48[16];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  v43 = 0;
  v44 = 0;
  memset(v48, 0, sizeof(v48));
  Options = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((Options & 0x80000000) == 0)
  {
    if (!a1)
      return Options;
    __s = 0;
    v45 = 0;
    Options = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)(a1 + 96) + 88))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), (char *)&v46 + 4, &v46);
    if ((Options & 0x80000000) != 0)
      return Options;
    v10 = (_DWORD)v46 == 1 && HIDWORD(v46) == 1;
    *(_DWORD *)(a1 + 184) = v10;
    v11 = *(_QWORD *)(a1 + 104);
    if (v11)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v11);
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    v12 = *(_QWORD *)(a1 + 112);
    if (v12)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v12);
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v13 = *(_QWORD *)(a1 + 152);
    if (v13)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v13);
    *(_QWORD *)(a1 + 152) = 0;
    v14 = *(_QWORD *)(a1 + 160);
    if (v14)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v14);
    *(_QWORD *)(a1 + 160) = 0;
    v15 = *(_QWORD *)(a1 + 168);
    if (v15)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v15);
    *(_QWORD *)(a1 + 168) = 0;
    v16 = *(_QWORD *)(a1 + 176);
    if (v16)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v16);
    *(_QWORD *)(a1 + 176) = 0;
    v17 = *(_QWORD *)(a1 + 280);
    if (v17)
    {
      if (*(_DWORD *)(a1 + 480))
      {
        v45 = *(_QWORD *)(a1 + 280);
        if (((*(uint64_t (**)(_QWORD, _QWORD))(v17 + 24))(*(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312)) & 0x80000000) == 0)
          objc_UnregisterObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"NNWRDLKP");
      }
      else if (*(_DWORD *)(a1 + 192)
             && (objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"NNCHRLKP") & 0x80000000) != 0)
      {
        v45 = *(_QWORD *)(a1 + 280);
        (*(void (**)(_QWORD, _QWORD))(v45 + 24))(*(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312));
      }
      *(_QWORD *)(a1 + 280) = 0;
    }
    if (!*(_DWORD *)(a1 + 188))
    {
LABEL_51:
      Options = checkSkipCrosstoken(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), (_DWORD *)(a1 + 144));
      if ((Options & 0x80000000) != 0)
        return Options;
      if (*(_DWORD *)(a1 + 144))
      {
        Options = hlp_loadOptions((_QWORD *)a1);
        if ((Options & 0x80000000) != 0)
          return Options;
      }
      Options = hlp_loadOptionalHmogrphModels(a1);
      if ((Options & 0x80000000) != 0)
        return Options;
      Options = hlp_loadNerOptions(a1);
      if ((Options & 0x80000000) != 0)
        return Options;
      *(_QWORD *)(a1 + 200) = *(_QWORD *)a1;
      if (*(_DWORD *)(a1 + 188))
      {
        if (*(_DWORD *)(a1 + 480))
        {
          v42 = 0;
          v40 = 0u;
          v41 = 0u;
          Options = hlp_loadStatWordOptions(a1);
          if ((Options & 0x80000000) != 0)
            return Options;
          Options = nn_word_lkp_GetInterface(1u, &v45);
          if ((Options & 0x80000000) != 0)
            return Options;
          *(_QWORD *)(a1 + 280) = v45;
          *(_QWORD *)(a1 + 288) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 296) = v26;
          *(_QWORD *)(a1 + 304) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 312) = v27;
          Options = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD, uint64_t))(v45 + 16))(*(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 296), "word", *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a1 + 304);
          if ((Options & 0x80000000) != 0)
            return Options;
          v41 = *(_OWORD *)(a1 + 304);
          *((_QWORD *)&v40 + 1) = v45;
          Options = objc_RegisterObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"NNWRDLKP", &v40);
          if ((Options & 0x80000000) != 0)
            return Options;
          goto LABEL_67;
        }
        if (*(_DWORD *)(a1 + 192))
        {
          Options = hlp_loadNNOptions(a1);
          if ((Options & 0x80000000) != 0)
            return Options;
          if ((objc_GetObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"NNCHRLKP", &v44) & 0x80000000) != 0)
          {
            Options = nn_word_lkp_GetInterface(1u, &v45);
            if ((Options & 0x80000000) != 0)
              return Options;
            *(_QWORD *)(a1 + 280) = v45;
            *(_QWORD *)(a1 + 288) = safeh_GetNullHandle();
            *(_QWORD *)(a1 + 296) = v37;
            *(_QWORD *)(a1 + 304) = safeh_GetNullHandle();
            *(_QWORD *)(a1 + 312) = v38;
            Options = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v45 + 16))(*(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 296), *(_QWORD *)(a1 + 264), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a1 + 304);
            if ((Options & 0x80000000) != 0)
              return Options;
          }
          else
          {
            *(_QWORD *)(a1 + 280) = *(_QWORD *)(v44 + 8);
            *(_QWORD *)(a1 + 288) = safeh_GetNullHandle();
            *(_QWORD *)(a1 + 296) = v28;
            *(_OWORD *)(a1 + 304) = *(_OWORD *)(v44 + 16);
          }
LABEL_67:
          Options = fi_model_getBrokerString(*(_QWORD *)a1, (char *)v48);
          if ((Options & 0x80000000) == 0)
          {
            v29 = fi_init(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), &v43, 0, (uint64_t)v48, (uint64_t)"FINN", 1, 0);
            if ((v29 & 0x80000000) != 0)
            {
              v18 = v29;
              log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"create FI model failed", v30, v31, v32, v39);
              return v18;
            }
            *(_QWORD *)(a1 + 240) = v43;
            goto LABEL_71;
          }
          return Options;
        }
        *(_QWORD *)(a1 + 240) = 0;
      }
LABEL_71:
      v33 = paramc_ParamGet(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"numberoutputtranscriptions", &__s, 0);
      v34 = 0;
      if ((v33 & 0x80000000) == 0 && __s)
        v34 = atoi(__s);
      *(_WORD *)(a1 + 138) = v34;
      v35 = (paramc_ParamGet(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"mlset", &__s, 0) & 0x80000000) == 0
         && strlen(__s) > 3;
      *(_DWORD *)(a1 + 140) = v35;
      return init_ner_struct(a1, (_QWORD *)(a1 + 392));
    }
    if (*(_DWORD *)(a1 + 480))
    {
      v19 = *(_QWORD *)(a1 + 336);
      if (v19)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v19);
        *(_QWORD *)(a1 + 336) = 0;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 192))
      {
LABEL_44:
        if (*(_DWORD *)(a1 + 384))
        {
          v24 = *(uint64_t **)(a1 + 392);
          if (v24)
          {
            fi_deinit(*(_QWORD *)a1, *(_QWORD *)(a1 + 24), v24);
            *(_QWORD *)(a1 + 392) = 0;
          }
          v25 = *(_QWORD *)(a1 + 440);
          if (v25)
          {
            v45 = *(_QWORD *)(a1 + 440);
            (*(void (**)(_QWORD, _QWORD))(v25 + 24))(*(_QWORD *)(a1 + 464), *(_QWORD *)(a1 + 472));
            *(_QWORD *)(a1 + 440) = 0;
          }
        }
        if (*(_WORD *)(a1 + 232))
          stat_hmogrph_ModelDeinit(*(_QWORD *)a1, (uint64_t *)(a1 + 224), *(unsigned __int16 *)(a1 + 232), v4, v5, v6, v7, v8);
        goto LABEL_51;
      }
      v20 = *(_QWORD *)(a1 + 272);
      if (v20)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v20);
        *(_QWORD *)(a1 + 272) = 0;
      }
      v21 = *(_QWORD *)(a1 + 248);
      if (v21)
      {
        ssftmap_ObjClose(v21);
        *(_QWORD *)(a1 + 248) = 0;
      }
      v22 = *(_QWORD *)(a1 + 264);
      if (v22)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v22);
        *(_QWORD *)(a1 + 264) = 0;
      }
    }
    v23 = *(uint64_t **)(a1 + 240);
    if (v23)
    {
      fi_deinit(*(_QWORD *)a1, *(_QWORD *)(a1 + 24), v23);
      *(_QWORD *)(a1 + 240) = 0;
    }
    goto LABEL_44;
  }
  return 2314215432;
}

uint64_t fe_hmogrph_ProcessStart(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((int)result >= 0)
    return result;
  else
    return 2314215432;
}

uint64_t fe_hmogrph_Process_StatHmogrph(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t SentenceData;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v22;

  *a4 = 1;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"BEGIN fe_hmogrph_Process_StatHmogrph()", a6, a7, a8, 0);
  if (*(_DWORD *)(a1 + 480) == 1)
  {
    SentenceData = stat_hmogrph_disambiguateWords(a1, *(_QWORD *)(a1 + 48), a2, a3, a1 + 200);
LABEL_13:
    v18 = SentenceData;
    v19 = 0;
    goto LABEL_14;
  }
  if (!*(_DWORD *)(a1 + 384))
  {
    *(_QWORD *)(a1 + 400) = 0;
    goto LABEL_10;
  }
  v15 = *(const char **)(a1 + 264);
  v16 = v15 && !strcmp(v15, "char");
  v17 = ner_process(*(_QWORD *)a1, a1 + 392, a2, a3, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312), v16);
  if ((v17 & 0x80000000) == 0)
  {
LABEL_10:
    SentenceData = stat_hmogrph_getSentenceData(a1, *(_QWORD *)(a1 + 48), a2, a3, (uint64_t *)(a1 + 200));
    if ((SentenceData & 0x80000000) == 0)
    {
      SentenceData = stat_hmogrph_disambiguatePhons(a1, a1 + 200);
      if ((SentenceData & 0x80000000) == 0)
        SentenceData = stat_hmogrph_updateLingdb(a1, *(_QWORD *)(a1 + 48), a2, a3, a1 + 200, a1 + 392);
    }
    goto LABEL_13;
  }
  v18 = v17;
  v19 = 1;
LABEL_14:
  if (!(*(_DWORD *)(a1 + 480) | v19))
  {
    v20 = stat_hmogrph_freeSentenceData((unsigned __int16 *)(a1 + 200));
    if ((int)v18 > -1 && v20 < 0)
      v18 = v20;
    else
      v18 = v18;
  }
  if (*(_DWORD *)(a1 + 384))
  {
    v22 = ner_freeNEData(*(_QWORD *)a1, a1 + 392);
    if ((int)v18 > -1 && v22 < 0)
      v18 = v22;
    else
      v18 = v18;
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"END fe_hmogrph_Process_StatHmogrph()", v12, v13, v14, 0);
  return v18;
}

uint64_t checkCRFMDE(_WORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned int v32;
  unsigned int v33;
  _QWORD *v34;
  char *v35;
  char *__s;
  _OWORD v37[8];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  __s = 0;
  v34 = 0;
  v35 = &byte_1DEBD87CE;
  memset(v37, 0, sizeof(v37));
  if ((paramc_ParamGetStr(*(_QWORD *)(a3 + 40), (uint64_t)"langcode", &__s) & 0x80000000) == 0
    && (paramc_ParamGetStr(*(_QWORD *)(a3 + 40), (uint64_t)"fecfg", &v35) & 0x80000000) == 0)
  {
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    v8 = (char *)heap_Calloc(*(_QWORD **)(a3 + 8), 1, 1024);
    if (v8)
    {
      v13 = v8;
      v14 = brokeraux_ComposeBrokerString(a3, (const char *)v37, 1, 1, __s, 0, 0, v8, 0x400uLL);
      v15 = strlen(__s);
      v16 = (char *)heap_Calloc(*(_QWORD **)(a3 + 8), 1, v15 + 1);
      if (v16)
      {
        v21 = v16;
        strcpy(v16, __s);
        if ((v14 & 0x80000000) == 0
          && (ssftriff_reader_ObjOpen(a1, a2, 2, v13, "CRPH", 1031, (uint64_t *)&v34) & 0x80000000) == 0)
        {
          ssftriff_reader_ObjClose(v34, v22, v23, v24, v25, v26, v27, v28);
          *a4 = 1;
        }
        heap_Free(*(_QWORD **)(a3 + 8), (uint64_t)v13);
        v29 = *(_QWORD **)(a3 + 8);
        v30 = (uint64_t)v21;
      }
      else
      {
        log_OutPublic(*(_QWORD *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v33);
        v29 = *(_QWORD **)(a3 + 8);
        v30 = (uint64_t)v13;
      }
      heap_Free(v29, v30);
    }
    else
    {
      log_OutPublic(*(_QWORD *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v9, v10, v11, v12, v32);
    }
  }
  return 0;
}

uint64_t fe_hmogrph_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  int v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  char *v38;
  unsigned __int8 v39;
  unsigned __int16 PreviousUtf8Offset;
  int v41;
  int v42;
  unsigned __int16 NextUtf8Offset;
  unsigned __int16 v45;
  unsigned __int8 v46;
  int v47;
  int v48;
  unsigned __int16 v50;
  int v51;
  unsigned __int16 v53;
  int v54;
  unsigned int v55;
  unsigned __int16 v56;
  int v57;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  char v62;
  unsigned __int16 v63;
  uint64_t v64;
  char v65;
  unsigned __int16 v66;
  char *v67;
  char *v68;
  int v69;
  unsigned __int8 v70;
  int v71;
  uint64_t v72;
  unsigned __int8 v74;
  _BOOL4 v75;
  uint64_t v76;
  int v77;
  int v78;
  __int16 v79;
  int v80;
  int v81;
  int __c[2];
  uint64_t v83;
  int v84;
  _BOOL4 v85;
  unsigned __int16 v86;
  uint64_t v87;
  __int16 v88;
  unsigned __int16 v89;
  int v90;
  unsigned __int16 v91;
  int v92;
  int v93;
  char *__s;
  char __s2[8];
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v88 = 0;
  v86 = 0;
  v84 = 0;
  v85 = 0;
  if ((safeh_HandleCheck(a1, a2, 62342, 488) & 0x80000000) != 0)
    return 2314215432;
  __s = 0;
  v92 = 0;
  v93 = 0;
  v91 = 0;
  v90 = 0;
  v89 = 0;
  v87 = 0;
  *a5 = 1;
  checkCRFMDE(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)a1, &v84);
  v9 = *(_QWORD *)(a1 + 88);
  v10 = *(_QWORD *)(a1 + 96);
  v11 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)__s2 = 0;
  LOWORD(v83) = -1;
  LOBYTE(__c[0]) = 0;
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, char *, uint64_t *, int *))(v10 + 96))(v11, v9, "fecfg", "usecompound", __s2, &v83, __c);
  if ((v12 & 0x80000000) != 0)
    return v12;
  v13 = 0;
  v14 = 1;
  if ((unsigned __int16)v83 == 1 && *(_QWORD *)__s2)
  {
    v15 = **(const char ***)__s2;
    v16 = strchr(**(char ***)__s2, LOBYTE(__c[0]));
    if (v16)
    {
      *v16 = 0;
      v15 = **(const char ***)__s2;
    }
    if (!strcmp("yes", v15) || !strcmp("YES", v15))
    {
      v14 = 0;
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
  }
  v17 = com_mosynt_UseMosynt(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), &v85);
  if ((v17 & 0x80000000) != 0)
    return v17;
  v21 = v85 ? v14 : 0;
  if (v21 == 1 && !*(_DWORD *)(a1 + 188))
    return v17;
  v22 = *(_DWORD *)(a1 + 188);
  if ((v85 & ~v13) != 0)
  {
    if (!v22)
      goto LABEL_23;
  }
  else if (!v22)
  {
    goto LABEL_24;
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph Enabled", v18, v19, v20, 0);
  v17 = fe_hmogrph_Process_StatHmogrph(a1, a3, a4, a5, v23, v24, v25, v26);
  if ((v17 & 0x80000000) != 0)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph Processing Failed", v27, v28, v29, 0);
    return v17;
  }
LABEL_23:
  if (!*(_DWORD *)(a1 + 480))
    return v17;
LABEL_24:
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 48) + 104))(a3, a4, 1, 0, (char *)&v93 + 2);
  if ((v17 & 0x80000000) != 0)
    return v17;
  if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, __int16 *))(*(_QWORD *)(a1 + 48) + 184))(a3, a4, HIWORD(v93), 0, &v88) & 0x80000000) != 0)return v17;
  if (v88 != 1)
    return v17;
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char **, char *))(*(_QWORD *)(a1 + 48) + 176))(a3, a4, HIWORD(v93), 0, &__s, (char *)&v92 + 2);
  if ((v17 & 0x80000000) != 0)
    return v17;
  v30 = HIWORD(v92);
  if (HIWORD(v92) < 2u)
    return v17;
  *(_WORD *)(a1 + 136) = 0;
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, unsigned __int16 *))(*(_QWORD *)(a1 + 48) + 176))(a3, a4, HIWORD(v93), 1, &v87, &v86);
  if ((v12 & 0x80000000) != 0)
    return v12;
  v31 = *(_DWORD *)(v87 + 12);
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(*(_QWORD *)(a1 + 48) + 104))(a3, a4, 2, HIWORD(v93), &v93);
  if ((v12 & 0x80000000) != 0)
    return v12;
  v79 = v31;
  v80 = 0;
  v32 = 0;
  v33 = v30 - 1;
  v34 = 1;
  while (1)
  {
    v35 = *(_QWORD *)(a1 + 48);
    if (!(_WORD)v93)
      break;
    v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v35 + 168))(a3, a4);
    if ((v12 & 0x80000000) != 0)
      return v12;
    if (v90 == 4)
    {
      v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48)
                                                                                                 + 168))(a3, a4, (unsigned __int16)v93, 1, 1, &v92, (char *)&v92 + 2);
      if ((v12 & 0x80000000) != 0)
        return v12;
      v36 = (unsigned __int16)v92;
      if (!v34 && (unsigned __int16)v92 == v80)
      {
        v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 2, 1, &v91, (char *)&v92 + 2);
        if ((v12 & 0x80000000) != 0)
          return v12;
        v37 = (unsigned __int16)v92;
        v38 = __s;
        if (!(_WORD)v92)
          goto LABEL_52;
        v39 = 0;
        do
        {
          PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)v38, v37);
          v38 = __s;
          v37 = PreviousUtf8Offset;
          v41 = __s[PreviousUtf8Offset];
          if (v41 == 95 || v41 == 32)
          {
            v42 = __s[PreviousUtf8Offset + 1];
            if (v42 != 32 && v42 != 95)
              ++v39;
          }
        }
        while (v39 <= 3u && PreviousUtf8Offset);
        if (PreviousUtf8Offset)
        {
          NextUtf8Offset = utf8_GetNextUtf8Offset(__s, PreviousUtf8Offset);
          v38 = __s;
        }
        else
        {
LABEL_52:
          NextUtf8Offset = 0;
        }
        v45 = v91;
        if (v91 >= v33)
        {
          v50 = v91;
        }
        else
        {
          v46 = 0;
          do
          {
            v45 = utf8_GetNextUtf8Offset(v38, v45);
            v38 = __s;
            v47 = __s[v45];
            if (v47 == 95 || v47 == 32)
            {
              v48 = __s[v45 - 1];
              if (v48 != 32 && v48 != 95)
                ++v46;
            }
          }
          while (v46 <= 2u && v33 > v45);
          v50 = v45;
          v45 = v91;
        }
        v51 = (unsigned __int16)v92;
        if (v32)
        {
          v12 = hlp_Disambiguate(a1, a3, a4, v38, v32, NextUtf8Offset, v50, (unsigned __int16)v92, v45);
          if ((v12 & 0x80000000) != 0)
            return v12;
          v38 = __s;
          v51 = (unsigned __int16)v92;
          v45 = v91;
        }
        v12 = hlp_Disambiguate(a1, a3, a4, v38, (unsigned __int16)v93, NextUtf8Offset, v50, v51, v45);
        if ((v12 & 0x80000000) != 0)
          return v12;
        v32 = 0;
        v36 = (unsigned __int16)v92;
      }
      if (v36 != v80 || v34 == 1)
        v32 = v93;
      v80 = v36;
      v34 = 0;
    }
    v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 48) + 120))(a3, a4);
    if ((v17 & 0x80000000) != 0)
      return v17;
  }
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(v35 + 104))(a3, a4, 2, HIWORD(v93), &v93);
  if ((v17 & 0x80000000) == 0)
  {
    v53 = v93;
    if ((_WORD)v93)
    {
      v54 = 0;
      v55 = 0;
      v76 = 0;
      v56 = 0;
      v77 = 1;
      v78 = 0;
      v81 = v84;
      v74 = 1;
      v75 = 0;
      v57 = 1;
      while (1)
      {
        v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48)
                                                                                                  + 168))(a3, a4, v53, 0, 1, &v90, (char *)&v92 + 2);
        if ((v12 & 0x80000000) != 0)
          return v12;
        v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 1, 1, &v92, (char *)&v92 + 2);
        if ((v12 & 0x80000000) != 0)
          return v12;
        if ((unsigned __int16)v92 != v56 || v57 == 1)
          v54 = 0;
        if (v55 < v86)
        {
          v59 = v55;
          v60 = v87 + 32 * v55 + 12;
          while ((__int16)(v92 + 1) > (__int16)(*(_WORD *)v60 - v79))
          {
            if (*(_DWORD *)(v60 - 12) == 14 && *(_DWORD *)(v60 + 12) == 64)
              v54 = 1;
            ++v59;
            v60 += 32;
            if (v86 == v59)
            {
              v55 = v86;
              goto LABEL_101;
            }
          }
          v55 = (unsigned __int16)v59;
        }
LABEL_101:
        if (v90 == 4)
          goto LABEL_112;
        v61 = v90 == 9;
        if (v90 == 9)
          v62 = v13;
        else
          v62 = 0;
        if (!v85)
          v62 = 0;
        if (v81 != 1)
          v61 = 0;
        if ((v62 & 1) != 0 || v61)
        {
LABEL_112:
          v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 7, 1, &v89, (char *)&v92 + 2);
          if ((v12 & 0x80000000) != 0)
            return v12;
          if (v85)
            v65 = v13;
          else
            v65 = 0;
          if ((v65 & 1) != 0 || v81 == 1)
          {
            *(_WORD *)__s2 = 0;
            v88 = 0;
            if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, __int16 *))(*(_QWORD *)(a1 + 48) + 184))(a3, a4, (unsigned __int16)v93, 17, &v88) & 0x80000000) == 0&& v88 == 1)
            {
              v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, char *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 17, 1, __s2, (char *)&v92 + 2);
              if ((v12 & 0x80000000) != 0)
                return v12;
            }
            if (*(_WORD *)__s2)
              v66 = 0;
            else
              v66 = ~v89;
            v89 = v66;
          }
          if (*(_DWORD *)(a1 + 480))
          {
            *(_QWORD *)__c = 0;
            v83 = 0;
            v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, char *))(*(_QWORD *)(a1 + 48)
                                                                                                  + 176))(a3, a4, (unsigned __int16)v93, 5, &v83, (char *)&v92 + 2);
            if ((v12 & 0x80000000) != 0)
              return v12;
            v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48)
                                                                                              + 176))(a3, a4, (unsigned __int16)v93, 14, __c, (char *)&v92 + 2);
            if ((v12 & 0x80000000) != 0)
              return v12;
            strcpy(__s2, "POS:");
            __strcat_chk();
            __strcat_chk();
            v67 = *(char **)__c;
            v68 = strstr(*(char **)__c, __s2);
            if (v68 && (v68 == v67 || *(v68 - 1) == 59))
              v89 += 100;
          }
          v88 = 0;
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, __int16 *))(*(_QWORD *)(a1 + 48) + 184))(a3, a4, (unsigned __int16)v93, 9, &v88) & 0x80000000) == 0&& v88 == 1)
          {
            *(_QWORD *)__s2 = 0;
            v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char *, char *))(*(_QWORD *)(a1 + 48)
                                                                                               + 176))(a3, a4, (unsigned __int16)v93, 9, __s2, (char *)&v92 + 2);
            if ((v12 & 0x80000000) != 0)
              return v12;
            v78 = **(_BYTE **)__s2;
          }
          if (v57 || (unsigned __int16)v92 != v56)
          {
            v63 = 0;
            v57 = 0;
            v64 = (unsigned __int16)v93;
            v70 = v77;
            v69 = v78;
            if (!(_BYTE)v78)
              v69 = v77;
            v75 = v78 == v77;
            LOWORD(v76) = v93;
            v56 = v92;
            HIDWORD(v76) = v89;
            v77 = v69;
            v74 = v70;
            goto LABEL_152;
          }
          if (v89 > HIDWORD(v76)
            || v89 == HIDWORD(v76) && !v75 && (v74 == 101 || v78 != 101))
          {
            v64 = (unsigned __int16)v93;
            if (!v54)
              goto LABEL_149;
          }
          else
          {
            v64 = (unsigned __int16)v93;
            if (v54)
            {
LABEL_149:
              v57 = 0;
              v71 = v78;
              if ((v78 & 0xFE) == 0)
                v71 = 1;
              HIDWORD(v76) = v89;
              v77 = v71;
              v63 = v76;
              v75 = v78 == v74;
              LOWORD(v76) = v64;
              goto LABEL_152;
            }
          }
          v57 = 0;
          v63 = v64;
        }
        else
        {
          v63 = 0;
          v64 = (unsigned __int16)v93;
        }
LABEL_152:
        v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)(a1 + 48) + 120))(a3, a4, v64, &v93);
        if ((v17 & 0x80000000) == 0)
        {
          if (!v63
            || (*(unsigned __int16 *)(a1 + 138) < 2u || !*(_DWORD *)(a1 + 140)
              ? (v72 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 48) + 192))(a3, a4, v63))
              : (*(_WORD *)__s2 = 0,
                 v90 = 16,
                 v72 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48) + 160))(a3, a4, v63, 0, 1, &v90, __s2)), v17 = v72, (v72 & 0x80000000) == 0))
          {
            v53 = v93;
            if ((_WORD)v93)
              continue;
          }
        }
        return v17;
      }
    }
  }
  return v17;
}

uint64_t hlp_Disambiguate(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8, unsigned __int16 a9)
{
  uint64_t NextUtf8Offset;
  uint64_t v14;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t PreviousUtf8Offset;
  uint64_t v31;
  const char *v32;
  int i;
  unsigned __int16 v34;
  const char *v35;
  int v36;
  int j;
  size_t v38;
  size_t v39;
  BOOL v40;
  unint64_t v41;
  BOOL v42;
  size_t v43;
  size_t v44;
  int v45;
  size_t v46;
  const char *v47;
  int k;
  uint64_t v49;
  unsigned __int16 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned __int16 v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  int v69;
  char *__s1;
  int v71;
  char *__s;
  __int16 v73;
  char v74[24];
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;

  LODWORD(NextUtf8Offset) = a8;
  v14 = a3;
  v82 = *MEMORY[0x1E0C80C00];
  v78 = xmmword_1DEC656B2;
  v79 = unk_1DEC656C2;
  v80 = xmmword_1DEC656D2;
  v81 = unk_1DEC656E2;
  strcpy(v74, "disambiguate_homographs");
  v75 = unk_1DEC6568A;
  v76 = xmmword_1DEC65692;
  v77 = unk_1DEC656A2;
  v73 = 0;
  __s = 0;
  v71 = 0;
  __s1 = 0;
  v68 = 0;
  v69 = 0;
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(*(_QWORD *)(a1 + 48) + 104))(a2, a3, 1, 0, &v68);
  if ((v17 & 0x80000000) == 0
    && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int16 *))(*(_QWORD *)(a1 + 48) + 184))(a2, v14, a5, 4, &v73) & 0x80000000) == 0)
  {
    v66 = a7;
    v67 = a2;
    if (v73 == 1)
    {
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char **, int *))(*(_QWORD *)(a1 + 48) + 176))(a2, v14, a5, 4, &__s, &v69);
      if ((v17 & 0x80000000) == 0)
      {
        if (*__s)
        {
          v18 = (int)(a7 - a6 + 14);
          if (v18 > *(unsigned __int16 *)(a1 + 136))
          {
            v19 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 104), (int)(a7 - a6 + 14));
            if (!v19
              || (*(_QWORD *)(a1 + 104) = v19,
                  (v24 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 112), v18)) == 0))
            {
              v17 = 2314215434;
              log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v20, v21, v22, v23, v62);
              return v17;
            }
            *(_QWORD *)(a1 + 112) = v24;
            *(_WORD *)(a1 + 136) = a7 - a6 + 14;
          }
          **(_BYTE **)(a1 + 104) = 0;
          **(_BYTE **)(a1 + 112) = 0;
          v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 48) + 104))(a2, v14, 2, (unsigned __int16)v68, (char *)&v71 + 2);
          if ((v25 & 0x80000000) != 0)
            return v25;
          v29 = 0;
          LODWORD(PreviousUtf8Offset) = a9;
          v65 = a5;
          v64 = v14;
          while (1)
          {
            v31 = HIWORD(v71);
            if (!HIWORD(v71))
              break;
            if (HIWORD(v71) == (_DWORD)a5)
            {
              v32 = &a4[NextUtf8Offset];
              for (i = (*(uint64_t (**)(_QWORD, _QWORD, const char *))(*(_QWORD *)(a1 + 96) + 128))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), v32);
                    i == 1;
                    i = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 96) + 128))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), &a4[NextUtf8Offset]))
              {
                NextUtf8Offset = (unsigned __int16)utf8_GetNextUtf8Offset(a4, NextUtf8Offset);
                v32 = &a4[NextUtf8Offset];
              }
              do
                PreviousUtf8Offset = (unsigned __int16)utf8_GetPreviousUtf8Offset((uint64_t)a4, PreviousUtf8Offset);
              while ((*(unsigned int (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 96) + 128))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), &a4[PreviousUtf8Offset]) == 1);
              v34 = utf8_GetNextUtf8Offset(a4, PreviousUtf8Offset);
              v35 = &a4[a6];
              v36 = NextUtf8Offset - a6;
              strncat(*(char **)(a1 + 104), v35, v36);
              for (j = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)v35, v36); j; --j)
                *(_WORD *)(*(_QWORD *)(a1 + 112) + strlen(*(const char **)(a1 + 112))) = 32;
              a6 = v34;
              v38 = *(_QWORD *)(a1 + 104) + strlen(*(const char **)(a1 + 104));
              *(_WORD *)v38 = -22590;
              *(_BYTE *)(v38 + 2) = 0;
              strncat(*(char **)(a1 + 104), v32, v34 - (int)NextUtf8Offset);
              v39 = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)v32, v34 - NextUtf8Offset);
              v40 = strlen(__s) <= v39 || v29 > 9;
              if (v40)
              {
                a5 = v29;
              }
              else
              {
                v41 = 1;
                do
                {
                  *(_WORD *)(*(_QWORD *)(a1 + 104) + strlen(*(const char **)(a1 + 104))) = 126;
                  a5 = (v29 + 1);
                  v40 = strlen(__s) - v39 > v41++;
                  v42 = !v40 || v29 >= 9;
                  LODWORD(v29) = v29 + 1;
                }
                while (!v42);
              }
              v43 = *(_QWORD *)(a1 + 104) + strlen(*(const char **)(a1 + 104));
              *(_WORD *)v43 = -22590;
              *(_BYTE *)(v43 + 2) = 0;
              v44 = *(_QWORD *)(a1 + 112) + strlen(*(const char **)(a1 + 112));
              *(_WORD *)v44 = -22590;
              *(_BYTE *)(v44 + 2) = 0;
              strcat(*(char **)(a1 + 112), __s);
              if (strlen(__s) < v39)
              {
                v45 = 0;
                do
                {
                  *(_WORD *)(*(_QWORD *)(a1 + 112) + strlen(*(const char **)(a1 + 112))) = 126;
                  ++v45;
                }
                while (v39 - strlen(__s) > (unsigned __int16)v45);
              }
              v46 = *(_QWORD *)(a1 + 112) + strlen(*(const char **)(a1 + 112));
              *(_WORD *)v46 = -22590;
              *(_BYTE *)(v46 + 2) = 0;
              v31 = HIWORD(v71);
              LODWORD(PreviousUtf8Offset) = a6;
              v29 = a5;
              LODWORD(a5) = v65;
              v14 = v64;
            }
            v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)(a1 + 48) + 120))(a2, v14, v31, (char *)&v71 + 2);
            if ((v17 & 0x80000000) != 0)
              return v17;
          }
          if (a6 < v66)
          {
            v47 = &a4[a6];
            strncat(*(char **)(a1 + 104), v47, (int)(v66 - a6));
            for (k = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)v47, v66 - a6); k; --k)
              *(_WORD *)(*(_QWORD *)(a1 + 112) + strlen(*(const char **)(a1 + 112))) = 32;
          }
          v49 = *(_QWORD *)(*(_QWORD *)a1 + 32);
          if (v29 > 9)
          {
            log_OutText(v49, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Homograph validation not OK", v26, v27, v28, v62);
            LOWORD(v71) = 0;
            return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48) + 160))(v67, v64, v65, 7, 1, &v71, (char *)&v68 + 2);
          }
          log_OutText(v49, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L1: %s", v26, v27, v28, (uint64_t)v74);
          v50 = strlen(*(const char **)(a1 + 104));
          v25 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 72) + 120))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), 0, *(_QWORD *)(a1 + 104), v50);
          if ((v25 & 0x80000000) != 0)
            return v25;
          log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L2: %s", v51, v52, v53, (uint64_t)v74);
          v54 = strlen(*(const char **)(a1 + 112));
          v25 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 72) + 120))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), 1, *(_QWORD *)(a1 + 112), v54);
          if ((v25 & 0x80000000) != 0)
            return v25;
          v25 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 72) + 80))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v74);
          if ((v25 & 0x80000000) != 0)
            return v25;
          v17 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, char *))(*(_QWORD *)(a1 + 72) + 128))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), 0, &__s1, (char *)&v69 + 2);
          if ((v17 & 0x80000000) == 0)
          {
            __s1[HIWORD(v69)] = 0;
            log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s O1: %s", v55, v56, v57, (uint64_t)v74);
            if (strstr(__s1, "§"))
            {
              log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Homograph validation not OK", v58, v59, v60, v63);
              LOWORD(v71) = 0;
              return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48) + 160))(v67, v64, v65, 7, 1, &v71, (char *)&v68 + 2);
            }
          }
        }
      }
    }
  }
  return v17;
}

uint64_t fe_hmogrph_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((int)result >= 0)
    return result;
  else
    return 2314215432;
}

uint64_t fe_hmogrph_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2314215425;
  result = 0;
  *a2 = &IFeHmogrph;
  return result;
}

uint64_t fe_hmogrph_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2314215431;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_hmogrph_ClassClose()
{
  return 0;
}

uint64_t com_useStatHmogrph(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD v9[16];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  memset(v9, 0, sizeof(v9));
  *a2 = 0;
  result = stat_hmogrph_getBrokerString(a1, (char *)v9, 0x100uLL);
  if ((result & 0x80000000) == 0)
  {
    if ((brk_DataOpenEx(*(_QWORD *)(a1 + 24), (uint64_t)v9, 1, (uint64_t)&v8) & 0x80000000) != 0)
    {
      log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph data not found", v5, v6, v7, 0);
    }
    else
    {
      *a2 = 1;
      result = brk_DataClose(*(_QWORD *)(a1 + 24), v8);
      if ((result & 0x80000000) != 0)
        return result;
    }
    return 0;
  }
  return result;
}

uint64_t stat_hmogrph_getBrokerString(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9[2];
  _OWORD v10[8];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  *(_QWORD *)v9 = 0;
  memset(v10, 0, sizeof(v10));
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v9);
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v8);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      v7 = brokeraux_ComposeBrokerString(a1, (const char *)v10, 1, 1, *(char **)v9, 0, 0, a2, a3);
      return v7 & (v7 >> 31);
    }
  }
  return result;
}

uint64_t com_getUnicodeOrth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  int v9;
  uint64_t result;
  uint64_t v11;
  char *v12;
  _BYTE __c[11];
  char v14[32];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  *(_QWORD *)&__c[3] = 0;
  strcpy(v14, "stathmogrph_");
  __strcat_chk();
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, char *, _BYTE *, _BYTE *, _BYTE *))(a1 + 96))(a2, a3, "fecfg", v14, &__c[3], &__c[1], __c);
  result = 0;
  if ((v9 & 0x80000000) == 0 && *(_WORD *)&__c[1])
  {
    v11 = **(_QWORD **)&__c[3];
    v12 = strchr(**(char ***)&__c[3], __c[0]);
    if (v12)
    {
      *v12 = 0;
      v11 = **(_QWORD **)&__c[3];
    }
    *a5 = v11;
    return 1;
  }
  return result;
}

uint64_t hlp_addWord(uint64_t a1, char *__s, int a3, int a4, const char *a5, const char *a6, const char *a7, unsigned int a8, const char *a9, uint64_t *a10, const char *a11, const char *a12, uint64_t a13)
{
  __int16 v14;
  __int16 v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char *v33;
  uint64_t v34;
  int v35;
  char *v36;
  char *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _WORD *v42;
  unsigned int v43;
  uint64_t v44;
  __int16 v45;
  unsigned int v46;
  uint64_t v47;
  unsigned __int16 v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t i;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  _WORD *v55;
  uint64_t v56;
  int v57;
  char *v58;
  int v59;
  char *v60;
  int v61;
  char *v62;
  int v63;
  char *v64;
  int v65;
  char *v66;
  unsigned int v67;
  uint64_t v68;
  int v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  char *v87;
  int v88;
  char *v89;
  int v90;
  char *v91;
  int v92;
  char *v93;
  int v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char *__srcb;
  uint64_t v109;
  uint64_t v110;

  v14 = a4;
  v15 = a3;
  v17 = a1;
  v18 = a13;
  v19 = a10;
  if (*(_WORD *)(a13 + 8))
  {
    v20 = a6;
    v21 = *(_QWORD *)a13 + 48;
    v22 = *(unsigned __int16 *)(a13 + 8);
    while (*(unsigned __int16 *)(v21 - 40) != a3 || *(unsigned __int16 *)(v21 - 38) != a4)
    {
      v21 += 64;
      if (!--v22)
        goto LABEL_6;
    }
    if (*(_WORD *)(v21 + 8))
    {
      v39 = 0;
      v40 = *(_QWORD *)v21;
      while (1)
      {
        v41 = v40 + 16 * v39;
        v43 = *(unsigned __int16 *)(v41 + 10);
        v42 = (_WORD *)(v41 + 10);
        v44 = *v19 + 32 * v39;
        v45 = *(_WORD *)(v44 + 8);
        v46 = *(unsigned __int16 *)(v44 + 24);
        if (v43 > v46)
          *v42 = v46;
        v47 = (unsigned __int16)*(v42 - 1);
        v48 = v45 + v47;
        v109 = (unsigned __int16)(v45 + v47);
        v49 = heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)(v40 + 16 * v39), 56 * v109);
        if (!v49)
          break;
        v40 = *(_QWORD *)v21;
        *(_QWORD *)(*(_QWORD *)v21 + 16 * v39) = v49;
        if (v47 < v48)
        {
          v50 = v47;
          v104 = v47;
          for (i = v47; i != v109; ++i)
          {
            v52 = *v19;
            if ((_DWORD)v50)
            {
              v53 = i - v50;
              v54 = *(const char **)(*(_QWORD *)(v52 + 32 * v39) + 8 * (i - v50));
              v55 = (_WORD *)(*(_QWORD *)(v40 + 16 * v39) + 8);
              v56 = v50;
              while (strcmp(*((const char **)v55 - 1), v54))
              {
                v55 += 28;
                if (!--v56)
                {
                  v20 = a6;
                  goto LABEL_29;
                }
              }
              v67 = *(unsigned __int16 *)(*(_QWORD *)(v52 + 32 * v39 + 16) + 2 * v53);
              if ((unsigned __int16)*v55 > v67)
                *v55 = v67;
              v20 = a6;
              v19 = a10;
            }
            else
            {
              v53 = i - v50;
              v54 = *(const char **)(*(_QWORD *)(v52 + 32 * v39) + 8 * (i - v50));
LABEL_29:
              v17 = a1;
              v57 = strlen(v54);
              v58 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, (v57 + 1));
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(_QWORD *)v21 + 16 * v39 + 8)) = v58;
              if (!v58)
                goto LABEL_59;
              v19 = a10;
              strcpy(v58, *(const char **)(*(_QWORD *)(*a10 + 32 * v39) + 8 * v53));
              *(_WORD *)(*(_QWORD *)(*(_QWORD *)v21 + 16 * v39)
                       + 56 * *(unsigned __int16 *)(*(_QWORD *)v21 + 16 * v39 + 8)
                       + 8) = *(_WORD *)(*(_QWORD *)(*a10 + 32 * v39 + 16) + 2 * v53);
              v59 = strlen(a9);
              v60 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, (v59 + 1));
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(_QWORD *)v21 + 16 * v39 + 8)
                        + 16) = v60;
              if (!v60)
                goto LABEL_59;
              strcpy(v60, a9);
              v61 = strlen(a11);
              v62 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, (v61 + 1));
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(_QWORD *)v21 + 16 * v39 + 8)
                        + 24) = v62;
              if (!v62)
                goto LABEL_59;
              strcpy(v62, a11);
              v63 = strlen(a12);
              v64 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, (v63 + 1));
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(_QWORD *)v21 + 16 * v39 + 8)
                        + 32) = v64;
              if (!v64)
                goto LABEL_59;
              strcpy(v64, a12);
              v65 = strlen(v20);
              v66 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, (v65 + 1));
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(_QWORD *)v21 + 16 * v39 + 8)
                        + 40) = v66;
              if (!v66)
                goto LABEL_59;
              strcpy(v66, v20);
              v40 = *(_QWORD *)v21;
              ++*(_WORD *)(*(_QWORD *)v21 + 16 * v39 + 8);
            }
            v50 = v104;
          }
        }
        v68 = 0;
        if (++v39 >= (unint64_t)*(unsigned __int16 *)(v21 + 8))
          return v68;
      }
      v68 = 2314215434;
      v97 = *(_QWORD *)(a1 + 32);
      goto LABEL_61;
    }
    return 0;
  }
LABEL_6:
  v23 = *(unsigned __int16 *)(a13 + 10);
  if (*(_WORD *)(a13 + 10))
  {
    v24 = *(_QWORD *)a13;
    if (*(unsigned __int16 *)(a13 + 8) + 2 > v23)
    {
      v25 = heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)a13, (v23 << 6) + 1280);
      if (!v25)
        goto LABEL_59;
      *(_QWORD *)a13 = v25;
      bzero((void *)(v25 + ((unint64_t)*(unsigned __int16 *)(a13 + 8) << 6)), 0x540uLL);
      *(_WORD *)(a13 + 10) += 20;
      v24 = *(_QWORD *)a13;
    }
  }
  else
  {
    v30 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 3201);
    *(_QWORD *)a13 = v30;
    if (!v30)
      goto LABEL_59;
    v24 = v30;
    *(_WORD *)(a13 + 10) = 50;
  }
  v103 = *(unsigned __int16 *)(a13 + 8);
  v31 = v24 + (v103 << 6);
  v32 = strlen(__s);
  v33 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v32 + 4));
  *(_QWORD *)v31 = v33;
  if (!v33)
    goto LABEL_59;
  strcpy(v33, __s);
  *(_DWORD *)(v31 + 32) = 0;
  v34 = v17;
  *(_DWORD *)(v31 + 36) = hlp_doesWordEndInComma(__s);
  v35 = strlen(__s);
  v36 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v35 + 4));
  *(_QWORD *)(v31 + 40) = v36;
  if (!v36)
    goto LABEL_60;
  v37 = v36;
  if (*(_DWORD *)(v31 + 36) == 1)
  {
    v38 = strlen(*(const char **)v31);
    strncpy(v37, *(const char **)v31, (v38 - 1));
  }
  else
  {
    strcpy(v36, *(const char **)v31);
  }
  v69 = strlen(a5);
  v70 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v69 + 1));
  v71 = v103;
  v72 = v24 + (v103 << 6);
  *(_QWORD *)(v72 + 16) = v70;
  if (!v70
    || (strcpy(v70, a5),
        v73 = (char *)heap_Calloc(*(_QWORD **)(v34 + 8), 1, a8 + 1),
        (*(_QWORD *)(v72 + 24) = v73) == 0))
  {
LABEL_60:
    v68 = 2314215434;
    v97 = *(_QWORD *)(v34 + 32);
    goto LABEL_61;
  }
  strncpy(v73, a7, a8);
  v74 = a10;
  v75 = *((unsigned __int16 *)a10 + 4);
  v76 = v24 + (v103 << 6);
  *(_WORD *)(v76 + 56) = v75;
  v77 = heap_Calloc(*(_QWORD **)(v34 + 8), v75, 16);
  *(_QWORD *)(v76 + 48) = v77;
  __srcb = (char *)(v76 + 48);
  v17 = v34;
  if (!v77)
  {
LABEL_59:
    v68 = 2314215434;
    v97 = *(_QWORD *)(v17 + 32);
LABEL_61:
    log_OutPublic(v97, (uint64_t)"FE_HMOGRPH", 37000, 0, v26, v27, v28, v29, v99);
    return v68;
  }
  if (*((_WORD *)a10 + 4))
  {
    v78 = 0;
    v79 = *a10;
    v99 = a13;
    v100 = v24;
    do
    {
      v80 = v79 + 32 * v78;
      v81 = *(unsigned __int16 *)(v80 + 8);
      v82 = *(_QWORD *)__srcb + 16 * v78;
      *(_WORD *)(v82 + 8) = v81;
      *(_WORD *)(v82 + 10) = *(_WORD *)(v80 + 24);
      if (!v81)
        return 0;
      v83 = heap_Calloc(*(_QWORD **)(v17 + 8), v81, 56);
      v102 = 16 * v78;
      *(_QWORD *)(*(_QWORD *)__srcb + 16 * v78) = v83;
      if (!v83)
        goto LABEL_59;
      v79 = *v74;
      if (*(_WORD *)(*v74 + 32 * v78 + 8))
      {
        v84 = 0;
        v85 = 0;
        v101 = v78;
        while (1)
        {
          v86 = strlen(*(const char **)(*(_QWORD *)(v79 + 32 * v78) + 8 * v85));
          v87 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v86 + 1));
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)__srcb + v102) + v84) = v87;
          if (!v87)
            break;
          strcpy(v87, *(const char **)(*(_QWORD *)(*a10 + 32 * v78) + 8 * v85));
          v110 = v85;
          *(_WORD *)(*(_QWORD *)(*(_QWORD *)__srcb + v102) + v84 + 8) = *(_WORD *)(*(_QWORD *)(*a10 + 32 * v78 + 16)
                                                                                 + 2 * v85);
          v88 = strlen(a9);
          v89 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v88 + 1));
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)__srcb + v102) + v84 + 16) = v89;
          if (!v89)
            goto LABEL_59;
          strcpy(v89, a9);
          v90 = strlen(a11);
          v91 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v90 + 1));
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)__srcb + v102) + v84 + 24) = v91;
          if (!v91)
            goto LABEL_59;
          strcpy(v91, a11);
          v92 = strlen(a12);
          v93 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v92 + 1));
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)__srcb + v102) + v84 + 32) = v93;
          if (!v93)
            goto LABEL_59;
          strcpy(v93, a12);
          v94 = strlen(a6);
          v95 = (char *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, (v94 + 1));
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)__srcb + v102) + v84 + 40) = v95;
          if (!v95)
            goto LABEL_59;
          strcpy(v95, a6);
          ++v85;
          v79 = *a10;
          v78 = v101;
          v84 += 56;
          if (v110 + 1 >= (unint64_t)*(unsigned __int16 *)(*a10 + 32 * v101 + 8))
            goto LABEL_57;
        }
        v68 = 2314215434;
        v97 = *(_QWORD *)(v17 + 32);
        goto LABEL_61;
      }
LABEL_57:
      ++v78;
      v74 = a10;
      v71 = v103;
      v18 = a13;
      v24 = v100;
    }
    while (v78 < *((unsigned __int16 *)a10 + 4));
  }
  v68 = 0;
  v96 = v24 + (v71 << 6);
  *(_WORD *)(v96 + 8) = v15;
  *(_WORD *)(v96 + 10) = v14;
  ++*(_WORD *)(v18 + 8);
  return v68;
}

BOOL hlp_doesWordEndInComma(const char *a1)
{
  size_t v2;
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    v2 = strlen(a1);
    if (v2)
    {
      if (strstr(",.:?!;()", &a1[v2 - 1]))
        return 1;
    }
  }
  return result;
}

uint64_t hlp_do_add(uint64_t *a1, uint64_t a2, char *a3, int a4, int a5, const char *a6, const char *a7, const char *a8, const char *a9, const char *a10, unsigned __int16 a11)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t **v30;
  uint64_t v31;
  int v32;
  _WORD *v33;
  uint64_t v34;
  unsigned __int16 v35;
  unsigned __int16 *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  unsigned __int16 v45;
  uint64_t v46;
  int v47;
  char *v48;
  uint64_t v50;
  unsigned int v51;
  int v52;
  const char *v53;

  if (!*(_WORD *)(a2 + 8))
    return 166731781;
  v15 = heap_Calloc(*(_QWORD **)(*a1 + 8), 1, 16);
  if (v15)
  {
    v20 = (uint64_t *)v15;
    v21 = *(unsigned __int16 *)(a2 + 8);
    *(_WORD *)(v15 + 10) = v21;
    *(_WORD *)(v15 + 8) = v21;
    v22 = heap_Calloc(*(_QWORD **)(*a1 + 8), v21, 32);
    *v20 = v22;
    if (v22)
    {
      v52 = a5;
      v53 = a6;
      if (!*(_WORD *)(a2 + 8))
      {
LABEL_22:
        hlp_addWord(*a1, a3, a4, v52, a9, v53, a10, a11, a9, v20, a7, a8, (uint64_t)(a1 + 1));
LABEL_26:
        stat_hmogrph_freeCandidatePhons((_QWORD *)*a1, (uint64_t)v20);
        heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v20);
        return 0;
      }
      v27 = 0;
      while (1)
      {
        v28 = *(_QWORD *)a2 + (v27 << 6);
        v31 = *(_QWORD *)(v28 + 48);
        v30 = (uint64_t **)(v28 + 48);
        v29 = (_QWORD *)v31;
        v32 = *(unsigned __int16 *)(v31 + 10);
        v33 = (_WORD *)(v22 + 32 * v27);
        v33[12] = v32;
        v34 = *(unsigned __int16 *)(v31 + 8);
        if (*(_WORD *)(v31 + 8))
        {
          v35 = 0;
          v36 = (unsigned __int16 *)(*v29 + 8);
          do
          {
            v37 = *v36;
            v36 += 28;
            if (v37 == v32)
              ++v35;
            --v34;
          }
          while (v34);
        }
        else
        {
          v35 = 0;
        }
        v33[4] = v35;
        v33[5] = v35;
        v38 = heap_Calloc(*(_QWORD **)(*a1 + 8), v35, 8);
        v39 = *v20;
        *(_QWORD *)(*v20 + 32 * v27) = v38;
        v40 = *a1;
        if (!v38)
          break;
        v41 = heap_Calloc(*(_QWORD **)(v40 + 8), *(unsigned __int16 *)(v39 + 32 * v27 + 10), 2);
        v22 = *v20;
        *(_QWORD *)(*v20 + 32 * v27 + 16) = v41;
        if (!v41)
          goto LABEL_24;
        v42 = *v30;
        if (*((_WORD *)*v30 + 4))
        {
          v43 = 0;
          v44 = 0;
          v45 = 0;
          v46 = *v42;
          do
          {
            if (*(unsigned __int16 *)(v46 + v43 + 8) == *(unsigned __int16 *)(v22 + 32 * v27 + 24))
            {
              v47 = strlen(*(const char **)(v46 + v43));
              *(_QWORD *)(*(_QWORD *)(*v20 + 32 * v27) + 8 * v45) = heap_Alloc(*(_QWORD *)(*a1 + 8), (v47 + 1));
              v48 = *(char **)(*(_QWORD *)(*v20 + 32 * v27) + 8 * v45);
              if (!v48)
                goto LABEL_24;
              strcpy(v48, *(const char **)(**v30 + v43));
              v42 = *v30;
              v46 = **v30;
              v22 = *v20;
              *(_WORD *)(*(_QWORD *)(*v20 + 32 * v27 + 16) + 2 * v45++) = *(_WORD *)(v46 + v43 + 8);
            }
            ++v44;
            v43 += 56;
          }
          while (v44 < *((unsigned __int16 *)v42 + 4));
        }
        if (++v27 >= (unint64_t)*(unsigned __int16 *)(a2 + 8))
          goto LABEL_22;
      }
      v50 = *(_QWORD *)(v40 + 32);
    }
    else
    {
LABEL_24:
      v50 = *(_QWORD *)(*a1 + 32);
    }
    log_OutPublic(v50, (uint64_t)"FE_HMOGRPH", 37000, 0, v23, v24, v25, v26, v51);
    goto LABEL_26;
  }
  log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v16, v17, v18, v19, v51);
  return 2314215434;
}

_QWORD *stat_hmogrph_freeCandidatePhons(_QWORD *result, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = *(_QWORD *)a2;
  if (v3)
  {
    v4 = result;
    if (*(_WORD *)(a2 + 8))
    {
      v5 = 0;
      do
      {
        v6 = v3 + 32 * v5;
        v7 = *(_QWORD *)v6;
        if (*(_QWORD *)v6)
        {
          if (*(_WORD *)(v6 + 8))
          {
            v8 = 0;
            do
            {
              if (*(_QWORD *)(*(_QWORD *)v6 + 8 * v8))
              {
                heap_Free((_QWORD *)v4[1], *(_QWORD *)(*(_QWORD *)v6 + 8 * v8));
                *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 32 * v5) + 8 * v8) = 0;
                v3 = *(_QWORD *)a2;
              }
              ++v8;
              v6 = v3 + 32 * v5;
            }
            while (v8 < *(unsigned __int16 *)(v6 + 8));
            v7 = *(_QWORD *)v6;
          }
          heap_Free((_QWORD *)v4[1], v7);
          v3 = *(_QWORD *)a2;
          *(_QWORD *)(*(_QWORD *)a2 + 32 * v5) = 0;
        }
        if (*(_QWORD *)(v3 + 32 * v5 + 16))
        {
          heap_Free((_QWORD *)v4[1], *(_QWORD *)(v3 + 32 * v5 + 16));
          v3 = *(_QWORD *)a2;
          *(_QWORD *)(*(_QWORD *)a2 + 32 * v5 + 16) = 0;
        }
        ++v5;
      }
      while (v5 < *(unsigned __int16 *)(a2 + 8));
    }
    result = heap_Free((_QWORD *)v4[1], v3);
    *(_QWORD *)a2 = 0;
  }
  return result;
}

uint64_t hlp_prepare_phons(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, const char *a6, uint64_t a7, const char *a8, const char *a9, const char *a10, unsigned __int16 a11, unsigned __int16 a12, unsigned __int16 a13, const char *a14, const char *a15, unsigned __int16 a16)
{
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int16 v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  unsigned __int16 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned __int16 v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  char *v59;
  size_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const char *v67;
  size_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int16 v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v80;
  const char *v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  unsigned __int16 v85;
  char *v86;
  const char *v87;
  int v88;
  unsigned __int16 v89;
  unsigned __int16 v90;
  unsigned __int16 v91;
  int v92;
  __int16 v93;
  int v94;
  const char *v95;
  const char *v96;
  int v97;
  _WORD v98[5];

  v95 = 0;
  v96 = 0;
  v92 = 0;
  v98[0] = 0;
  v24 = heap_Calloc(*(_QWORD **)(*a4 + 8), 1, 16);
  if (!v24)
  {
    v71 = 2314215434;
    log_OutPublic(*(_QWORD *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v80);
    return v71;
  }
  v29 = v24;
  v97 = 0;
  v94 = 0;
  v93 = 0;
  *(_DWORD *)(v24 + 8) = 65537;
  v30 = heap_Calloc(*(_QWORD **)(*a4 + 8), 1, 32);
  *(_QWORD *)v29 = v30;
  if (!v30
    || (*(_DWORD *)(v30 + 8) = 0, v35 = strlen(a6), (v36 = heap_Calloc(*(_QWORD **)(*a4 + 8), 1, v35 + 1)) == 0))
  {
    v71 = 2314215434;
    log_OutPublic(*(_QWORD *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v31, v32, v33, v34, v80);
    v37 = 0;
    goto LABEL_62;
  }
  v37 = (char *)v36;
  v87 = a6;
  v38 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _WORD *))(*(_QWORD *)(a1 + 48) + 136))(a2, a3, a13, v98);
  if ((v38 & 0x80000000) != 0)
  {
    v71 = v38;
LABEL_62:
    if (*(_QWORD *)v29)
      heap_Free(*(_QWORD **)(*a4 + 8), *(_QWORD *)v29);
    heap_Free(*(_QWORD **)(*a4 + 8), v29);
    if (v37)
      goto LABEL_85;
    return v71;
  }
  v39 = v98[0];
  HIWORD(v94) = v98[0];
  v86 = v37;
  if (!v98[0])
  {
    v71 = 0;
    v72 = 0;
    goto LABEL_69;
  }
  v89 = 0;
  v90 = 0;
  v91 = 0;
  v88 = 0;
  v83 = 1;
  v85 = 1;
  v81 = a8;
  v82 = a5;
  v84 = a7;
  do
  {
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, __int16 *))(*(_QWORD *)(a1 + 48)
                                                                                                 + 168))(a2, a3, v39, 0, 1, &v97, &v93);
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
    if (v97 != 17)
    {
      if (v95 && v88 == 1)
      {
        v40 = hlp_addWord(*a4, v37, HIWORD(v92), (unsigned __int16)v92, v95, a8, a15, a16, a14, (uint64_t *)v29, a9, a10, a5);
        if ((v40 & 0x80000000) != 0)
          goto LABEL_59;
        v88 = 0;
      }
      v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 48) + 136))(a2, a3, HIWORD(v94), (char *)&v94 + 2);
      if ((v40 & 0x80000000) != 0)
        goto LABEL_59;
      goto LABEL_55;
    }
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(*(_QWORD *)(a1 + 48) + 168))(a2, a3, HIWORD(v94), 1, 1, (char *)&v92 + 2, &v93);
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(*(_QWORD *)(a1 + 48)
                                                                                                  + 168))(a2, a3, HIWORD(v94), 2, 1, &v92, &v93);
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
    if (HIWORD(v92) != v91 || (unsigned __int16)v92 != v90)
    {
      if (v83)
      {
        v90 = v92;
        v91 = HIWORD(v92);
      }
      else
      {
        v40 = hlp_addWord(*a4, v37, v91, v90, v95, a8, a15, a16, a14, (uint64_t *)v29, a9, a10, a5);
        if ((v40 & 0x80000000) != 0)
          goto LABEL_59;
        ++v85;
        v91 = HIWORD(v92);
        v90 = v92;
      }
      v83 = 0;
      v41 = *(_QWORD *)v29;
      *(_WORD *)(v41 + 8) = 0;
      *(_WORD *)(v41 + 24) = -1;
      v88 = 1;
    }
    strncpy(v37, &v87[v91], v90 - (unint64_t)v91);
    v37[(unsigned __int16)v92 - HIWORD(v92)] = 0;
    if (HIWORD(v92) < a11 || (unsigned __int16)v92 > a12)
      break;
    v42 = *(unsigned __int16 *)(*(_QWORD *)v29 + 8);
    *(_WORD *)(*(_QWORD *)v29 + 8) = v42 + 1;
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, __int16 *))(*(_QWORD *)(a1 + 48)
                                                                                                 + 176))(a2, a3, HIWORD(v94), 3, &v96, &v93);
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, __int16 *))(*(_QWORD *)(a1 + 48)
                                                                                                 + 176))(a2, a3, HIWORD(v94), 5, &v95, &v93);
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(*(_QWORD *)(a1 + 48)
                                                                                                  + 168))(a2, a3, HIWORD(v94), 7, 1, &v94, &v93);
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
    v43 = *(_QWORD *)v29;
    v44 = *(unsigned __int16 *)(*(_QWORD *)v29 + 10);
    if (*(_WORD *)(*(_QWORD *)v29 + 10))
    {
      if ((int)v42 + 1 >= v44)
      {
        v53 = heap_Realloc(*(uint64_t **)(*a4 + 8), *(_QWORD *)v43, 8 * v44 + 80);
        if (!v53
          || (v54 = *(_QWORD *)v29,
              *(_QWORD *)v54 = v53,
              (v45 = heap_Realloc(*(uint64_t **)(*a4 + 8), *(_QWORD *)(v54 + 16), 2 * *(unsigned __int16 *)(v54 + 10) + 20)) == 0))
        {
LABEL_87:
          v71 = 2314215434;
          v52 = *a4;
LABEL_90:
          log_OutPublic(*(_QWORD *)(v52 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v47, v48, v49, v50, v80);
          goto LABEL_60;
        }
        v43 = *(_QWORD *)v29;
        *(_QWORD *)(v43 + 16) = v45;
        *(_WORD *)(v43 + 10) += 10;
      }
      else
      {
        v45 = *(_QWORD *)(v43 + 16);
      }
    }
    else
    {
      *(_WORD *)(v43 + 10) = 10;
      v46 = heap_Calloc(*(_QWORD **)(*a4 + 8), 10, 8);
      v51 = *(_QWORD *)v29;
      **(_QWORD **)v29 = v46;
      v52 = *a4;
      if (!v46)
      {
        v71 = 2314215434;
        goto LABEL_90;
      }
      v45 = heap_Calloc(*(_QWORD **)(v52 + 8), *(unsigned __int16 *)(v51 + 10), 2);
      v43 = *(_QWORD *)v29;
      *(_QWORD *)(*(_QWORD *)v29 + 16) = v45;
      if (!v45)
        goto LABEL_87;
    }
    if (v89 <= *(unsigned __int16 *)(v43 + 8))
      v55 = *(_WORD *)(v43 + 8);
    else
      v55 = v89;
    v89 = v55;
    *(_WORD *)(v45 + 2 * v42) = v94;
    if (*(unsigned __int16 *)(v43 + 24) > (unsigned __int16)v94)
      *(_WORD *)(v43 + 24) = v94;
    v56 = v85 - 1;
    v57 = *(const char **)(v84 + 8 * v56);
    v58 = *(_QWORD *)v43;
    v59 = *(char **)(v58 + 8 * v42);
    if (v57)
    {
      if (!v59 || (v60 = strlen(*(const char **)(v58 + 8 * v42)), v60 < strlen(v57)))
      {
        v61 = strlen(v57);
        v62 = heap_Realloc(*(uint64_t **)(*a4 + 8), (uint64_t)v59, (v61 + 1));
        if (!v62)
          goto LABEL_88;
        *(_QWORD *)(**(_QWORD **)v29 + 8 * v42) = v62;
        v59 = *(char **)(**(_QWORD **)v29 + 8 * v42);
        v57 = *(const char **)(v84 + 8 * v56);
      }
      v37 = v86;
      a8 = v81;
      strcpy(v59, v57);
    }
    else
    {
      v67 = v96;
      if (!v59 || (v68 = strlen(*(const char **)(v58 + 8 * v42)), v68 < strlen(v96)))
      {
        v69 = strlen(v96);
        v70 = heap_Realloc(*(uint64_t **)(*a4 + 8), (uint64_t)v59, (v69 + 1));
        if (!v70)
        {
LABEL_88:
          v71 = 2314215434;
          log_OutPublic(*(_QWORD *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v63, v64, v65, v66, v80);
          v37 = v86;
          goto LABEL_60;
        }
        *(_QWORD *)(**(_QWORD **)v29 + 8 * v42) = v70;
        v59 = *(char **)(**(_QWORD **)v29 + 8 * v42);
        v67 = v96;
      }
      v37 = v86;
      strcpy(v59, v67);
      a8 = v81;
    }
    v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a1 + 48) + 136))(a2, a3, HIWORD(v94), (char *)&v94 + 2);
    a5 = v82;
    if ((v40 & 0x80000000) != 0)
      goto LABEL_59;
LABEL_55:
    v39 = HIWORD(v94);
  }
  while (HIWORD(v94));
  v71 = 0;
  if (v95 && v88 == 1)
  {
    v40 = hlp_addWord(*a4, v37, HIWORD(v92), (unsigned __int16)v92, v95, a8, a15, a16, a14, (uint64_t *)v29, a9, a10, a5);
LABEL_59:
    v71 = v40;
  }
LABEL_60:
  v72 = v89;
LABEL_69:
  v73 = *a4;
  v74 = *(_QWORD *)v29;
  if (*(_QWORD *)v29)
  {
    if (*(_WORD *)(v29 + 8))
    {
      v75 = 0;
      do
      {
        v76 = *(_QWORD *)(v74 + 32 * v75);
        if (v76)
        {
          if (v72)
          {
            v77 = 0;
            do
            {
              v78 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v29 + 32 * v75) + v77);
              if (v78)
              {
                heap_Free(*(_QWORD **)(v73 + 8), v78);
                *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v29 + 32 * v75) + v77) = 0;
              }
              v77 += 8;
            }
            while (8 * v72 != v77);
            v76 = *(_QWORD *)(*(_QWORD *)v29 + 32 * v75);
          }
          heap_Free(*(_QWORD **)(v73 + 8), v76);
          v74 = *(_QWORD *)v29;
          *(_QWORD *)(*(_QWORD *)v29 + 32 * v75) = 0;
        }
        if (*(_QWORD *)(v74 + 32 * v75 + 16))
        {
          heap_Free(*(_QWORD **)(v73 + 8), *(_QWORD *)(v74 + 32 * v75 + 16));
          v74 = *(_QWORD *)v29;
          *(_QWORD *)(*(_QWORD *)v29 + 32 * v75 + 16) = 0;
        }
        ++v75;
      }
      while (v75 < *(unsigned __int16 *)(v29 + 8));
    }
    heap_Free(*(_QWORD **)(v73 + 8), v74);
    *(_QWORD *)v29 = 0;
    v73 = *a4;
    v37 = v86;
  }
  heap_Free(*(_QWORD **)(v73 + 8), v29);
LABEL_85:
  heap_Free(*(_QWORD **)(*a4 + 8), (uint64_t)v37);
  return v71;
}

uint64_t hlp_merge_add(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, const char *a5, char *a6, const char *a7, const char *a8, const char *a9, unsigned __int16 a10, const char *a11, const char *a12, unsigned __int16 a13)
{
  uint64_t v21;
  __int16 ChineseUTFCharNum;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  unsigned __int16 v47;
  int v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v57;
  uint64_t *v58;
  unsigned int v59;
  int v60;
  int v61;
  unsigned __int16 v62;
  char *__dst;
  const char *v64;
  uint64_t v65;
  const char *v66;
  char *__s;
  unsigned __int16 v68;
  int v69;
  char *__lasts;
  char *v71;

  __lasts = 0;
  v71 = 0;
  v69 = 0;
  v68 = 0;
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(a1 + 48)
                                                                                             + 168))(a2, a3, a10, 1, 1, &v69, (char *)&v69 + 2);
  if ((v21 & 0x80000000) != 0)
    return v21;
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(*(_QWORD *)(a1 + 48) + 168))(a2, a3, a10, 2, 1, &v68, (char *)&v69 + 2);
  if ((v21 & 0x80000000) != 0)
    return v21;
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(a1 + 48) + 176))(a2, a3, a10, 3, &v71, (char *)&v69 + 2);
  if ((v21 & 0x80000000) != 0)
    return v21;
  v66 = a7;
  __s = a6;
  ChineseUTFCharNum = utf8_GetChineseUTFCharNum((uint64_t)a5, v68);
  v23 = utf8_GetChineseUTFCharNum((uint64_t)a5, (unsigned __int16)v69);
  v24 = heap_Calloc(*(_QWORD **)(*a4 + 8), 1, 16);
  v29 = *a4;
  if (v24)
  {
    v30 = v24;
    v64 = a8;
    v31 = *(_QWORD **)(v29 + 8);
    v32 = strlen(__s);
    v33 = heap_Calloc(v31, 1, (v32 + 4));
    v38 = *a4;
    if (v33)
    {
      v39 = v33;
      v62 = ChineseUTFCharNum - v23;
      v44 = heap_Calloc(*(_QWORD **)(v38 + 8), 1, 8 * (unsigned __int16)(ChineseUTFCharNum - v23));
      v65 = v30;
      if (!v44)
      {
        v55 = 2314215434;
        log_OutPublic(*(_QWORD *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v40, v41, v42, v43, v59);
        goto LABEL_23;
      }
      __dst = (char *)v39;
      v45 = strtok_r(v71, ".", &__lasts);
      if (v45)
      {
        v46 = v45;
        v47 = 0;
        do
        {
          if (strcmp(v46, "*"))
          {
            v48 = strlen(v46);
            v49 = (char *)heap_Calloc(*(_QWORD **)(*a4 + 8), 1, (v48 + 1));
            *(_QWORD *)(v44 + 8 * v47) = v49;
            if (!v49)
            {
              v55 = 2314215434;
              log_OutPublic(*(_QWORD *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v50, v51, v52, v53, v59);
LABEL_22:
              v39 = (uint64_t)__dst;
              goto LABEL_23;
            }
            strcpy(v49, v46);
            *(_BYTE *)(*(_QWORD *)(v44 + 8 * v47) + (unsigned __int16)strlen(v46)) = 0;
          }
          v46 = strtok_r(0, ".", &__lasts);
          ++v47;
        }
        while (v46);
      }
      strcpy(__dst, __s);
      v61 = (unsigned __int16)v69;
      v54 = hlp_prepare_phons(a1, a2, a3, a4, v65, a5, v44, v66, v64, a9, v69, v68, a10, a11, a12, a13);
      if ((v54 & 0x80000000) != 0)
      {
        v55 = v54;
        goto LABEL_22;
      }
      v39 = (uint64_t)__dst;
      v55 = hlp_do_add(a4, v65, __dst, v61, v60, v66, v64, a9, a11, a12, a13);
LABEL_23:
      heap_Free(*(_QWORD **)(*a4 + 8), v39);
      if (v44)
      {
        v57 = v62;
        v30 = v65;
        if (v62)
        {
          v58 = (uint64_t *)v44;
          do
          {
            if (*v58)
            {
              heap_Free(*(_QWORD **)(*a4 + 8), *v58);
              *v58 = 0;
            }
            ++v58;
            --v57;
          }
          while (v57);
        }
        heap_Free(*(_QWORD **)(*a4 + 8), v44);
      }
      else
      {
        v30 = v65;
      }
    }
    else
    {
      v55 = 2314215434;
      log_OutPublic(*(_QWORD *)(v38 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v34, v35, v36, v37, v59);
    }
    stat_hmogrph_freeNewSentData((uint64_t)a4, v30);
    heap_Free(*(_QWORD **)(*a4 + 8), v30);
  }
  else
  {
    v55 = 2314215434;
    log_OutPublic(*(_QWORD *)(v29 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v59);
  }
  return v55;
}

uint64_t stat_hmogrph_freeNewSentData(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unsigned __int16 v18;
  unsigned __int16 *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  if (*(_WORD *)(a2 + 10))
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)a2;
      v6 = (uint64_t *)(*(_QWORD *)a2 + (v4 << 6));
      if (*v6)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *v6);
        *v6 = 0;
      }
      v9 = v6[2];
      v8 = v6 + 2;
      v7 = v9;
      if (v9)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v7);
        *v8 = 0;
      }
      v10 = v5 + (v4 << 6);
      v11 = *(_QWORD *)(v10 + 24);
      if (v11)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v11);
        *(_QWORD *)(v10 + 24) = 0;
      }
      v14 = *(_QWORD *)(v10 + 40);
      v13 = (_QWORD *)(v10 + 40);
      v12 = v14;
      if (v14)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v12);
        *v13 = 0;
      }
      v15 = v5 + (v4 << 6);
      v17 = (uint64_t *)(v15 + 48);
      v16 = *(_QWORD *)(v15 + 48);
      if (v16)
      {
        v20 = *(unsigned __int16 *)(v15 + 56);
        v19 = (unsigned __int16 *)(v15 + 56);
        v18 = v20;
        if (v20)
        {
          v21 = 0;
          do
          {
            v22 = *(_QWORD *)(v16 + 16 * v21);
            if (v22)
            {
              if (*(_WORD *)(v16 + 16 * v21 + 8))
              {
                v23 = 0;
                v24 = 0;
                do
                {
                  v25 = *(_QWORD *)(v22 + v23);
                  if (v25)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v25);
                    v16 = *v17;
                    v22 = *(_QWORD *)(*v17 + 16 * v21);
                    *(_QWORD *)(v22 + v23) = 0;
                  }
                  v26 = *(_QWORD *)(v22 + v23 + 16);
                  if (v26)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v26);
                    v16 = *v17;
                    v22 = *(_QWORD *)(*v17 + 16 * v21);
                    *(_QWORD *)(v22 + v23 + 16) = 0;
                  }
                  v27 = *(_QWORD *)(v22 + v23 + 24);
                  if (v27)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v27);
                    v16 = *v17;
                    v22 = *(_QWORD *)(*v17 + 16 * v21);
                    *(_QWORD *)(v22 + v23 + 24) = 0;
                  }
                  v28 = *(_QWORD *)(v22 + v23 + 32);
                  if (v28)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v28);
                    v16 = *v17;
                    v22 = *(_QWORD *)(*v17 + 16 * v21);
                    *(_QWORD *)(v22 + v23 + 32) = 0;
                  }
                  v29 = *(_QWORD *)(v22 + v23 + 40);
                  if (v29)
                  {
                    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v29);
                    v16 = *v17;
                    v22 = *(_QWORD *)(*v17 + 16 * v21);
                    *(_QWORD *)(v22 + v23 + 40) = 0;
                  }
                  ++v24;
                  v23 += 56;
                }
                while (v24 < *(unsigned __int16 *)(v16 + 16 * v21 + 8));
              }
              heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v22);
              v16 = *v17;
              *(_QWORD *)(*v17 + 16 * v21) = 0;
              v18 = *v19;
            }
            ++v21;
          }
          while (v21 < v18);
        }
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v16);
        *v17 = 0;
      }
      ++v4;
    }
    while (v4 < *(unsigned __int16 *)(a2 + 10));
  }
  if (*(_QWORD *)a2)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_QWORD *)a2);
    *(_QWORD *)a2 = 0;
  }
  return 0;
}

uint64_t stat_hmogrph_getSentenceData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  int v28;
  unsigned __int16 v29;
  uint64_t v30;
  char *v32;
  int v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  char *v37;
  const char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  _BYTE *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  size_t v58;
  char *v59;
  uint64_t v60;
  unsigned __int16 v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  unsigned int NextUtf8Offset;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _WORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  unsigned __int16 v76;
  int v77;
  const char *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int16 v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  unsigned __int16 v89;
  int v90;
  const char *v91;
  unsigned __int16 v92;
  char *v93;
  uint64_t v94;
  char *v95;
  const char *v96;
  char *__s;
  int v98;
  int v99;
  int v100;
  uint64_t v101;
  _BYTE v102[7];
  char *__s1;
  const char *v104;
  char *v105;
  const char *v106;
  const char *v107;
  char *v108;
  char *v109;
  __int16 v110;
  int v111;
  unsigned int v112;
  int v113;
  const char *v114;
  int v115;
  unsigned __int16 v116[6];

  v115 = 0;
  *(_DWORD *)v116 = 0;
  v114 = 0;
  v112 = 0;
  v113 = 0;
  v111 = 0;
  v110 = 0;
  v108 = 0;
  v109 = 0;
  v106 = 0;
  v107 = 0;
  v104 = 0;
  v105 = 0;
  __s1 = 0;
  v101 = 0;
  a5[1] = 0;
  v10 = (uint64_t)(a5 + 1);
  *((_DWORD *)a5 + 4) = 0;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a2 + 104))(a3, a4, 1, 0, &v116[1]);
  if ((v11 & 0x80000000) != 0)
  {
    v12 = v11;
    goto LABEL_111;
  }
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, int *))(a2 + 184))(a3, a4, v116[1], 0, &v115);
  if ((v12 & 0x80000000) != 0
    || (unsigned __int16)v115 != 1
    || (v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, const char **, char *))(a2 + 176))(a3, a4, v116[1], 0, &v114, (char *)&v115 + 2), (v12 & 0x80000000) != 0)|| HIWORD(v115) < 2u)
  {
    if ((v12 & 0x80000000) != 0)
      goto LABEL_111;
    return v12;
  }
  log_OutText(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph: processing=\"%s\"", v13, v14, v15, (uint64_t)v114);
  v16 = heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 1024);
  if (!v16)
  {
    v12 = 2314215434;
    log_OutPublic(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v85);
    goto LABEL_111;
  }
  v21 = v16;
  v22 = strlen(v114);
  v27 = (char *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, (unsigned __int16)(v22 + 1));
  if (!v27)
  {
    v12 = 2314215434;
    log_OutPublic(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v23, v24, v25, v26, v85);
    v96 = 0;
    v28 = 0;
    v98 = 0;
    v99 = 0;
    goto LABEL_149;
  }
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a2 + 104))(a3, a4, 2, v116[1], v116);
  v28 = 0;
  v96 = 0;
  if ((v12 & 0x80000000) != 0)
  {
    v98 = 0;
    v99 = 0;
    goto LABEL_149;
  }
  v29 = v116[0];
  v98 = 0;
  v99 = 0;
  if (!v116[0])
    goto LABEL_149;
  v86 = v21;
  v95 = 0;
  v89 = 0;
  v28 = 0;
  v98 = 0;
  v99 = 0;
  while (1)
  {
    v100 = 0;
    v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, char *))(a2 + 168))(a3, a4, v29, 0, 1, &v112, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0)
    {
      v96 = 0;
      goto LABEL_121;
    }
    if (v112 > 0xA || ((1 << v112) & 0x610) == 0)
      goto LABEL_104;
    v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, char *))(a2 + 168))(a3, a4, v116[0], 1, 1, (char *)&v111 + 2, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0
      || (v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(a2 + 168))(a3, a4, v116[0], 2, 1, &v111, (char *)&v115 + 2), (v30 & 0x80000000) != 0))
    {
LABEL_116:
      v96 = 0;
      v28 = 0;
LABEL_119:
      v98 = 0;
      goto LABEL_120;
    }
    if (HIWORD(v111) > (unsigned __int16)v111)
    {
      v96 = 0;
      v28 = 0;
      v98 = 0;
      v99 = 0;
      v84 = 16049;
      goto LABEL_138;
    }
    strncpy(v27, &v114[HIWORD(v111)], (unsigned __int16)v111 - (unint64_t)HIWORD(v111));
    v27[(unsigned __int16)v111 - HIWORD(v111)] = 0;
    v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, int *))(a2 + 184))(a3, a4, v116[0], 14, &v115);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_116;
    if ((unsigned __int16)v115 != 1)
      goto LABEL_36;
    v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(a2 + 176))(a3, a4, v116[0], 14, &v109, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_116;
    hlp_NLUStrFind(v109, "POS", (uint64_t *)&v105, (unsigned __int16 *)&v113 + 1);
    v32 = v109;
    if (strstr(v109, "POI"))
    {
      LOWORD(v113) = 0;
      hlp_NLUStrFind(v32, "S_POI", (uint64_t *)&v104, (unsigned __int16 *)&v113);
      v33 = (unsigned __int16)v113;
      if (!(_WORD)v113)
      {
        hlp_NLUStrFind(v109, "I_POI", (uint64_t *)&v104, (unsigned __int16 *)&v113);
        v33 = (unsigned __int16)v113;
        if (!(_WORD)v113)
        {
          hlp_NLUStrFind(v109, "E_POI", (uint64_t *)&v104, (unsigned __int16 *)&v113);
          v33 = (unsigned __int16)v113;
        }
      }
      v34 = v104;
      if (!v33)
        v34 = &byte_1DEBD87CE;
      v104 = v34;
      if (v33)
        v35 = 4;
      else
        v35 = 3;
      v92 = v33 + v35 + 1;
      v36 = (const char *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, v92);
      if (!v36)
      {
        v96 = 0;
        v28 = 0;
LABEL_135:
        v98 = 0;
LABEL_136:
        v99 = 0;
LABEL_137:
        v84 = 8202;
LABEL_138:
        v12 = v84 | 0x89F00000;
        goto LABEL_139;
      }
      v37 = (char *)v36;
      v38 = v33 ? "_" : &byte_1DEBD87CE;
      *v36 = 0;
      *(_DWORD *)&v36[strlen(v36)] = 6909808;
      v39 = strcat(v37, v38);
      strncat(v39, v104, (unsigned __int16)v113);
    }
    else
    {
LABEL_36:
      v92 = 0;
      v37 = 0;
    }
    v91 = v105;
    if (v105)
    {
      v28 = 0;
      if (v37)
        goto LABEL_44;
    }
    else
    {
      v28 = 1;
      v40 = (char *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 2);
      v105 = v40;
      if (!v40)
      {
        v96 = v37;
        goto LABEL_135;
      }
      *v40 = 61;
      v105[1] = 0;
      v28 = 1;
      if (v37)
        goto LABEL_44;
    }
    v41 = (char *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 2);
    if (!v41)
    {
      v96 = 0;
      goto LABEL_135;
    }
    v37 = v41;
    LOWORD(v113) = 1;
    *(_WORD *)v41 = 61;
LABEL_44:
    v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, char *))(*(_QWORD *)(a1 + 48)
                                                                                              + 176))(a3, a4, v116[0], 6, &v107, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0
      || (v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, char *))(*(_QWORD *)(a1 + 48) + 176))(a3, a4, v116[0], 9, &v106, (char *)&v115 + 2), (v30 & 0x80000000) != 0)|| (v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, int *))(a2 + 184))(a3, a4, v116[0], 4, &v115), (v30 & 0x80000000) != 0)|| (unsigned __int16)v115 == 1&& (v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(a2 + 176))(a3, a4, v116[0],
                  4,
                  &v108,
                  (char *)&v115 + 2),
          (v30 & 0x80000000) != 0))
    {
      v96 = v37;
      goto LABEL_119;
    }
    v88 = v108;
    if (v108)
    {
      v98 = 0;
    }
    else
    {
      v42 = (char *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 2);
      v108 = v42;
      if (!v42)
      {
        v98 = 1;
        v96 = v37;
        goto LABEL_136;
      }
      *v42 = 61;
      v108[1] = 0;
      v98 = 1;
    }
    v30 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, char *))(a2 + 176))(a3, a4, v116[0], 5, &v101, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0)
    {
      v96 = v37;
LABEL_120:
      v99 = 0;
LABEL_121:
      v12 = v30;
LABEL_139:
      v21 = v86;
      goto LABEL_147;
    }
    v87 = v101;
    if (v101)
    {
      v99 = 0;
    }
    else
    {
      v43 = (_BYTE *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 2);
      v101 = (uint64_t)v43;
      if (!v43)
      {
        v99 = 1;
        v96 = v37;
        goto LABEL_137;
      }
      *v43 = 61;
      *(_BYTE *)(v101 + 1) = 0;
      v99 = 1;
    }
    if (*(_DWORD *)(a1 + 144) && v112 == 9 && utf8_IsChineseLetter(v27))
    {
      v30 = hlp_merge_add(a1, a3, a4, a5, v114, v27, v108, v107, v106, v116[0], (const char *)v101, v37, v92);
      if ((v30 & 0x80000000) != 0)
      {
        v96 = v37;
        goto LABEL_121;
      }
      goto LABEL_97;
    }
    __s = v27;
    v44 = heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 16);
    v96 = v37;
    if (!v44)
    {
      log_OutPublic(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v45, v46, v47, v48, v85);
      v21 = v86;
      v12 = 2314215434;
      goto LABEL_147;
    }
    v49 = v44;
    *(_DWORD *)(v44 + 8) = 655360;
    v50 = heap_Calloc(*(_QWORD **)(*a5 + 8), 10, 32);
    *(_QWORD *)v49 = v50;
    if (!v50)
    {
      v60 = 0;
      v56 = v95;
      goto LABEL_143;
    }
    v94 = a1;
    v55 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(a2 + 176))(a3, a4, v116[0], 3, &__s1, (char *)&v115 + 2);
    v56 = v95;
    if ((v55 & 0x80000000) != 0)
    {
      v60 = 0;
LABEL_129:
      v12 = v55;
      goto LABEL_144;
    }
    v90 = v28;
    v57 = __s1;
    if (strstr(__s1, "[SVOX]"))
    {
      v57 += 6;
      __s1 = v57;
    }
    v58 = strlen(v57);
    v59 = (char *)heap_Alloc(*(_QWORD *)(*a5 + 8), v58 + 1);
    v60 = (uint64_t)v59;
    if (!v59)
    {
LABEL_117:
      v28 = v90;
      goto LABEL_143;
    }
    strcpy(v59, __s1);
    v61 = strlen(__s1);
    v28 = v90;
    if (v61 >= v89)
    {
      if ((unsigned __int16)(v61 + 1) <= 4u)
        v62 = 4;
      else
        v62 = (unsigned __int16)(v61 + 1);
      v89 = v62;
      v63 = heap_Realloc(*(uint64_t **)(*a5 + 8), (uint64_t)v95, v62);
      if (!v63)
        goto LABEL_143;
      v56 = (char *)v63;
    }
    v55 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, char *))(a2 + 168))(a3, a4, v116[0], 7, 1, &v110, (char *)&v115 + 2);
    if ((v55 & 0x80000000) != 0)
      goto LABEL_129;
    v93 = (char *)v60;
    v95 = v56;
    v64 = 0;
    if (strlen(__s))
    {
      NextUtf8Offset = 0;
      v66 = (uint64_t)__s;
      a1 = v94;
      while ((utf8_getUTF8Char(v66, NextUtf8Offset, v102) & 0x80000000) == 0)
      {
        v67 = *(unsigned __int16 *)(v49 + 10);
        v56 = v95;
        v60 = (uint64_t)v93;
        if (*(unsigned __int16 *)(v49 + 8) >= v67)
        {
          v68 = heap_Realloc(*(uint64_t **)(*a5 + 8), *(_QWORD *)v49, 32 * v67 + 320);
          if (!v68)
            goto LABEL_117;
          *(_QWORD *)v49 = v68;
          *(_WORD *)(v49 + 10) += 10;
        }
        if (!hlp_getPhonFromPhonStr(__s, NextUtf8Offset, v93, v95, &v100))
          goto LABEL_89;
        *(_DWORD *)(*(_QWORD *)v49 + 32 * *(unsigned __int16 *)(v49 + 8) + 8) = 65537;
        v69 = (_WORD *)heap_Calloc(*(_QWORD **)(*a5 + 8), 1, 2);
        v70 = *(_QWORD *)v49;
        *(_QWORD *)(*(_QWORD *)v49 + 32 * *(unsigned __int16 *)(v49 + 8) + 16) = v69;
        if (!v69)
          goto LABEL_117;
        *v69 = v110;
        *(_WORD *)(v70 + 32 * *(unsigned __int16 *)(v49 + 8) + 24) = v110;
        v71 = heap_Alloc(*(_QWORD *)(*a5 + 8), 8);
        *(_QWORD *)(*(_QWORD *)v49 + 32 * *(unsigned __int16 *)(v49 + 8)) = v71;
        if (!v71)
          goto LABEL_117;
        v72 = strlen(v95) + 1;
        v73 = heap_Alloc(*(_QWORD *)(*a5 + 8), v72);
        v74 = 32 * *(unsigned __int16 *)(v49 + 8);
        **(_QWORD **)(*(_QWORD *)v49 + v74) = v73;
        v75 = **(char ***)(*(_QWORD *)v49 + v74);
        if (!v75)
          goto LABEL_142;
        v64 += v72;
        strcpy(v75, v95);
        v76 = *(_WORD *)(v49 + 8) + 1;
        *(_WORD *)(v49 + 8) = v76;
        if (v100 == 1)
        {
          a1 = v94;
          goto LABEL_91;
        }
        v66 = (uint64_t)__s;
        NextUtf8Offset = utf8_GetNextUtf8Offset(__s, NextUtf8Offset);
        a1 = v94;
        if (NextUtf8Offset >= strlen(__s))
          break;
      }
    }
    else
    {
LABEL_89:
      a1 = v94;
    }
    v76 = *(_WORD *)(v49 + 8);
LABEL_91:
    if (v76)
    {
      v77 = strlen(__s1);
      if (v64 < v77 + 1)
        break;
    }
LABEL_95:
    v37 = (char *)v96;
    v82 = hlp_addWord(*a5, __s, HIWORD(v111), (unsigned __int16)v111, v105, v108, v96, v92, (const char *)v101, (uint64_t *)v49, v107, v106, v10);
    stat_hmogrph_freeCandidatePhons((_QWORD *)*a5, v49);
    heap_Free(*(_QWORD **)(*a5 + 8), v49);
    heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v93);
    if ((v82 & 0x80000000) != 0)
    {
      v12 = v82;
      v21 = v86;
      v27 = __s;
      v28 = v90;
      goto LABEL_147;
    }
    v27 = __s;
    v28 = v90;
LABEL_97:
    if (!v91)
    {
      heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v105);
      v105 = 0;
    }
    heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v37);
    if (!v88)
    {
      heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v108);
      v108 = 0;
    }
    if (v87)
    {
      v99 = 0;
    }
    else
    {
      heap_Free(*(_QWORD **)(*a5 + 8), v101);
      v101 = 0;
      v99 = 1;
    }
LABEL_104:
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a2 + 120))(a3, a4, v116[0], v116);
    if ((v12 & 0x80000000) == 0)
    {
      v29 = v116[0];
      if (v116[0])
        continue;
    }
    v96 = 0;
    goto LABEL_139;
  }
  v78 = **(const char ***)(*(_QWORD *)v49 + 32 * (v76 - 1));
  v79 = strlen(v78);
  v80 = heap_Realloc(*(uint64_t **)(*a5 + 8), (uint64_t)v78, v77 - v64 + v79 + 2);
  if (v80)
  {
    v81 = 32 * *(unsigned __int16 *)(v49 + 8) - 32;
    **(_QWORD **)(*(_QWORD *)v49 + v81) = v80;
    strcat(**(char ***)(*(_QWORD *)v49 + v81), &__s1[v64 - 1]);
    goto LABEL_95;
  }
  v56 = v95;
LABEL_142:
  v28 = v90;
  v60 = (uint64_t)v93;
LABEL_143:
  log_OutPublic(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v51, v52, v53, v54, v85);
  v12 = 2314215434;
LABEL_144:
  v95 = v56;
  stat_hmogrph_freeCandidatePhons((_QWORD *)*a5, v49);
  heap_Free(*(_QWORD **)(*a5 + 8), v49);
  if (v60)
    heap_Free(*(_QWORD **)(*a5 + 8), v60);
  v21 = v86;
  v27 = __s;
LABEL_147:
  if (v95)
    heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v95);
LABEL_149:
  heap_Free(*(_QWORD **)(*a5 + 8), v21);
  if (v27)
    heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v27);
  if ((v12 & 0x80000000) != 0)
  {
    if (v28 == 1)
    {
      heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v105);
      v105 = 0;
    }
    if (v96)
      heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v96);
    if (v98 == 1)
    {
      heap_Free(*(_QWORD **)(*a5 + 8), (uint64_t)v108);
      v108 = 0;
    }
    if (v99 == 1)
    {
      heap_Free(*(_QWORD **)(*a5 + 8), v101);
      v101 = 0;
    }
LABEL_111:
    stat_hmogrph_freeSentenceData((unsigned __int16 *)a5);
  }
  return v12;
}

uint64_t hlp_getPhonFromPhonStr(char *a1, unsigned int a2, char *a3, char *a4, _DWORD *a5)
{
  uint64_t result;
  unsigned int NextUtf8Offset;
  int v11;
  __int16 v12;
  unsigned int v13;

  result = 0;
  v13 = a2;
  if (a4 && a5)
  {
    v12 = 0;
    *a5 = 0;
    if (utf8_Utf8CharTo16bit((unsigned __int8 *)a1, (uint64_t)&v12)
      && (unsigned __int16)((unsigned __int16)(v12 + 24576) >> 9) <= 0x56u)
    {
      strcpy(a4, a3);
      result = 1;
      *a5 = 1;
    }
    else
    {
      utf8_GetPreviousValidUtf8Offset((uint64_t)a1, &v13);
      if (v13)
      {
        NextUtf8Offset = 0;
        while (1)
        {
          NextUtf8Offset = utf8_GetNextUtf8Offset(a1, NextUtf8Offset);
          result = (uint64_t)strchr(a3, 46);
          if (!result)
            break;
          if (*(_BYTE *)result == 46)
            a3 = (char *)(result + 1);
          else
            a3 = (char *)result;
          if (NextUtf8Offset == v13)
            goto LABEL_13;
        }
      }
      else
      {
LABEL_13:
        for (NextUtf8Offset = 0; ; ++NextUtf8Offset)
        {
          v11 = a3[NextUtf8Offset];
          if (!a3[NextUtf8Offset] || v11 == 46)
            break;
          a4[NextUtf8Offset] = v11;
          if (NextUtf8Offset && v11 == 125 && a4[NextUtf8Offset - 1] - 48 <= 9)
          {
            a3[NextUtf8Offset++] = 46;
            break;
          }
        }
        result = 1;
      }
      a4[NextUtf8Offset] = 0;
    }
  }
  return result;
}

uint64_t stat_hmogrph_freeSentenceData(unsigned __int16 *a1)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unsigned __int16 v17;
  unsigned __int16 *v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (a1)
  {
    v2 = (uint64_t *)(a1 + 4);
    if (a1[8])
    {
      v3 = 0;
      do
      {
        v4 = *v2;
        v5 = (uint64_t *)(*v2 + (v3 << 6));
        if (*v5)
        {
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *v5);
          *v5 = 0;
        }
        v8 = v5[2];
        v7 = v5 + 2;
        v6 = v8;
        if (v8)
        {
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v6);
          *v7 = 0;
        }
        v9 = v4 + (v3 << 6);
        v10 = *(_QWORD *)(v9 + 24);
        if (v10)
        {
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v10);
          *(_QWORD *)(v9 + 24) = 0;
        }
        v13 = *(_QWORD *)(v9 + 40);
        v12 = (_QWORD *)(v9 + 40);
        v11 = v13;
        if (v13)
        {
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v11);
          *v12 = 0;
        }
        v14 = v4 + (v3 << 6);
        v16 = (uint64_t *)(v14 + 48);
        v15 = *(_QWORD *)(v14 + 48);
        if (v15)
        {
          v19 = *(unsigned __int16 *)(v14 + 56);
          v18 = (unsigned __int16 *)(v14 + 56);
          v17 = v19;
          if (v19)
          {
            v20 = 0;
            do
            {
              v21 = *(_QWORD *)(v15 + 16 * v20);
              if (v21)
              {
                if (*(_WORD *)(v15 + 16 * v20 + 8))
                {
                  v22 = 0;
                  v23 = 0;
                  do
                  {
                    v24 = *(_QWORD *)(v21 + v22);
                    if (v24)
                    {
                      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v24);
                      v15 = *v16;
                      v21 = *(_QWORD *)(*v16 + 16 * v20);
                      *(_QWORD *)(v21 + v22) = 0;
                    }
                    v25 = *(_QWORD *)(v21 + v22 + 16);
                    if (v25)
                    {
                      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v25);
                      v15 = *v16;
                      v21 = *(_QWORD *)(*v16 + 16 * v20);
                      *(_QWORD *)(v21 + v22 + 16) = 0;
                    }
                    v26 = *(_QWORD *)(v21 + v22 + 24);
                    if (v26)
                    {
                      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v26);
                      v15 = *v16;
                      v21 = *(_QWORD *)(*v16 + 16 * v20);
                      *(_QWORD *)(v21 + v22 + 24) = 0;
                    }
                    v27 = *(_QWORD *)(v21 + v22 + 32);
                    if (v27)
                    {
                      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v27);
                      v15 = *v16;
                      v21 = *(_QWORD *)(*v16 + 16 * v20);
                      *(_QWORD *)(v21 + v22 + 32) = 0;
                    }
                    v28 = *(_QWORD *)(v21 + v22 + 40);
                    if (v28)
                    {
                      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v28);
                      v15 = *v16;
                      v21 = *(_QWORD *)(*v16 + 16 * v20);
                      *(_QWORD *)(v21 + v22 + 40) = 0;
                    }
                    ++v23;
                    v22 += 56;
                  }
                  while (v23 < *(unsigned __int16 *)(v15 + 16 * v20 + 8));
                }
                heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v21);
                v15 = *v16;
                *(_QWORD *)(*v16 + 16 * v20) = 0;
                v17 = *v18;
              }
              ++v20;
            }
            while (v20 < v17);
          }
          heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v15);
          *v16 = 0;
        }
        ++v3;
      }
      while (v3 < a1[8]);
    }
    if (*v2)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), *v2);
    *v2 = 0;
    v2[1] = 0;
  }
  return 0;
}

uint64_t hlp_initFeatureVector(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  uint64_t v5;
  _WORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v12;

  if (!a3)
    return 0;
  v5 = a3;
  while (1)
  {
    v6 = (_WORD *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 65);
    *a2 = v6;
    if (!v6)
      break;
    *v6 = 61;
    ++a2;
    if (!--v5)
      return 0;
  }
  log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v7, v8, v9, v10, v12);
  return 2314215434;
}

uint64_t hlp_isFeatureRequired(uint64_t a1, unsigned int a2, int a3, _WORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;

  if (a2 < 2)
    return 0;
  v6 = 0;
  v7 = a2 - 1;
  v8 = g_featureNames[a3];
  while (strcmp(*(const char **)(a1 + 8 * v6), v8))
  {
    if (v7 == ++v6)
      return 0;
  }
  *a4 = v6;
  return 1;
}

uint64_t hlp_setFeature(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, const char *a6)
{
  uint64_t result;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned __int16 v18;

  v18 = -1;
  result = hlp_isFeatureRequired(a2, a3, a4, &v18);
  if ((_DWORD)result)
  {
    if (!*a6)
    {
      result = 0;
      **(_WORD **)(a5 + 8 * v18) = 61;
      return result;
    }
    v10 = strlen(a6);
    v11 = v18;
    if (v10 <= 0x40)
    {
      v12 = *(char **)(a5 + 8 * v18);
      goto LABEL_8;
    }
    v12 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)(a5 + 8 * v18), (v10 + 1));
    if (v12)
    {
      *(_QWORD *)(a5 + 8 * v11) = v12;
LABEL_8:
      strcpy(v12, a6);
      return 0;
    }
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v17);
    return 2314215434;
  }
  return result;
}

uint64_t hlp_wordStrLowerCase(char *a1, char *a2)
{
  unsigned int NextUtf8Offset;
  char __s[8];

  *(_DWORD *)&__s[3] = 0;
  *(_DWORD *)__s = 0;
  *a2 = 0;
  if ((utf8_getUTF8Char((uint64_t)a1, 0, __s) & 0x80000000) == 0)
  {
    NextUtf8Offset = 0;
    do
    {
      if (strlen(a1) <= NextUtf8Offset)
        break;
      if (strlen(__s) == 1 && __s[0] >= 0x41u && __s[0] <= 0x5Au)
        a2[NextUtf8Offset] = __s[0] + 32;
      else
        strcat(a2, __s);
      NextUtf8Offset = utf8_GetNextUtf8Offset(a1, NextUtf8Offset);
    }
    while ((utf8_getUTF8Char((uint64_t)a1, NextUtf8Offset, __s) & 0x80000000) == 0);
  }
  return 0;
}

uint64_t feat_character(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, const char *a6, char *a7)
{
  const char **v11;
  uint64_t v12;
  int v13;
  int v14;
  const char **v15;
  const char *v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  const char **v20;
  uint64_t v21;
  const char *v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  unsigned int NextUtf8Offset;
  unint64_t v33;
  int v34;
  unsigned int PreviousUtf8Offset;
  uint64_t v37;

  v11 = *(const char ***)a2;
  v12 = a3;
  v13 = strlen(*(const char **)(*(_QWORD *)a2 + ((unint64_t)a3 << 6)));
  v37 = v12;
  v14 = 0;
  if (a3)
  {
    v15 = v11;
    do
    {
      v16 = *v15;
      v15 += 8;
      v14 += strlen(v16);
      --v12;
    }
    while (v12);
  }
  v17 = *(unsigned __int16 *)(a2 + 8);
  if (v17 <= (unsigned __int16)(a3 + 1))
  {
    v18 = 0;
  }
  else
  {
    v18 = 0;
    v19 = (unsigned __int16)(a3 + 1);
    v20 = &v11[8 * v19];
    v21 = v19 + 1;
    do
    {
      v22 = *v20;
      v20 += 8;
      v18 += strlen(v22);
      v23 = v17 == (unsigned __int16)v21++;
    }
    while (!v23);
  }
  v24 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, (v13 + v14 + v18 + 1));
  if (!v24)
  {
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v37);
    return 2314215434;
  }
  v29 = (char *)v24;
  if (!*(_WORD *)(a2 + 8))
    goto LABEL_27;
  v30 = 0;
  v31 = 0;
  NextUtf8Offset = v14 + a4;
  do
  {
    strcat(v29, *(const char **)(*(_QWORD *)a2 + v30));
    ++v31;
    v33 = *(unsigned __int16 *)(a2 + 8);
    v30 += 64;
  }
  while (v31 < v33);
  if (v33 <= a3 || strlen(*(const char **)(*(_QWORD *)a2 + (v37 << 6))) <= a4)
    goto LABEL_27;
  if (a5 < 0)
  {
    if (!NextUtf8Offset)
      goto LABEL_27;
    do
    {
      PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)v29, NextUtf8Offset);
      NextUtf8Offset = PreviousUtf8Offset;
      v23 = (unsigned __int16)~(_WORD)a5 == 0;
      LOWORD(a5) = a5 + 1;
    }
    while (!v23 && PreviousUtf8Offset);
    if ((_WORD)a5)
      goto LABEL_27;
  }
  else if (a5)
  {
    while (NextUtf8Offset != strlen(v29))
    {
      NextUtf8Offset = utf8_GetNextUtf8Offset(v29, NextUtf8Offset);
      v34 = (__int16)a5--;
      if (v34 <= 1)
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ((utf8_getUTF8Char((uint64_t)v29, NextUtf8Offset, a7) & 0x80000000) != 0)
LABEL_27:
    strcpy(a7, a6);
  heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v29);
  return 0;
}

uint64_t feat_colloc(unsigned __int16 *a1, unsigned int a2, char *__s1)
{
  unsigned int v4;
  uint64_t v6;
  const char **v7;
  uint64_t v8;
  unint64_t v9;
  const char *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;

  v4 = a2;
  if (a2)
  {
    v6 = *(_QWORD *)a1;
    if (!strcmp(__s1, *(const char **)(*(_QWORD *)a1 + 40)))
    {
      v12 = 76;
      v13 = 66;
    }
    else
    {
      v7 = (const char **)(v6 + 104);
      v8 = 1;
      while (1)
      {
        v9 = v8;
        if (v4 == v8)
          break;
        v10 = *v7;
        v7 += 8;
        v11 = strcmp(__s1, v10);
        v8 = v9 + 1;
        if (!v11)
        {
          v12 = 76;
          goto LABEL_10;
        }
      }
      v12 = 78;
LABEL_10:
      if (v9 >= v4)
        v13 = 82;
      else
        v13 = 66;
    }
  }
  else
  {
    v12 = 78;
    v13 = 82;
  }
  v14 = a1[4];
  while (1)
  {
    LOWORD(v4) = v4 + 1;
    if (v14 <= (unsigned __int16)v4)
      break;
    if (!strcmp(__s1, *(const char **)(*(_QWORD *)a1 + ((unint64_t)(unsigned __int16)v4 << 6) + 40)))
      return v13;
  }
  return v12;
}

char *feat_wordbeg(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  uint64_t v5;

  v5 = (a3 + a2);
  if (a3 + a2 < 0 || v5 >= *(unsigned __int16 *)(a1 + 8))
    return strcpy(__dst, __src);
  else
    return (char *)utf8_getUTF8Char(*(_QWORD *)(*(_QWORD *)a1 + (v5 << 6) + 40), 0, __dst);
}

char *feat_wordend(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  uint64_t v6;
  char *v7;
  unsigned int v8;

  v6 = (a3 + a2);
  if (a3 + a2 < 0 || v6 >= *(unsigned __int16 *)(a1 + 8))
    return strcpy(__dst, __src);
  v7 = *(char **)(*(_QWORD *)a1 + (v6 << 6) + 40);
  v8 = strlen(v7);
  return utf8_GetUtf8Symbol(v7, v8 - 1, v8, __dst);
}

char *feat_wordlc(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  uint64_t v5;

  *__dst = 0;
  v5 = (a3 + a2);
  if (a3 + a2 < 0 || v5 >= *(unsigned __int16 *)(a1 + 8))
    return strcpy(__dst, __src);
  else
    return (char *)hlp_wordStrLowerCase(*(char **)(*(_QWORD *)a1 + (v5 << 6) + 40), __dst);
}

char *feat_wordlen(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  uint64_t v6;
  int v7;

  *__dst = 0;
  v6 = (a3 + a2);
  if (a3 + a2 < 0 || v6 >= *(unsigned __int16 *)(a1 + 8))
    return strcpy(__dst, __src);
  v7 = Utf8_Utf8NbrOfSymbols(*(const char **)(*(_QWORD *)a1 + (v6 << 6) + 40));
  return (char *)sprintf(__dst, "%d", v7 - 1);
}

uint64_t feat_pos(uint64_t a1, int a2, int a3, uint64_t a4)
{
  __int16 v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v8 = a3 + a2;
  if (a3 <= 0)
    v9 = a3 + a2;
  else
    v9 = a2;
  LOWORD(v10) = v9;
  if (a3 <= 0)
    v8 = a2;
  v11 = v8 - 1;
  if (v9 > v11)
  {
LABEL_12:
    v13 = (a3 + a2);
    if (a3 + a2 >= 0 && v13 < *(unsigned __int16 *)(a1 + 8))
      return *(_QWORD *)(*(_QWORD *)a1 + (v13 << 6) + 16);
  }
  else
  {
    v12 = v11;
    while ((v10 & 0x8000) != 0
         || *(unsigned __int16 *)(a1 + 8) <= (unsigned __int16)v10
         || !hlp_doesWordEndInComma(*(const char **)(*(_QWORD *)a1 + ((unint64_t)(unsigned __int16)v10 << 6))))
    {
      v10 = (__int16)(v10 + 1);
      if (v10 > v12)
        goto LABEL_12;
    }
  }
  return a4;
}

uint64_t feat_matchprevpos(uint64_t *a1, int a2, char *__s2, uint64_t a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;

  if (a2)
  {
    v6 = *a1;
    v7 = a2;
    while (1)
    {
      v8 = v6 + ((unint64_t)(v7 - 1) << 6);
      if (!strcmp(*(const char **)(v8 + 16), __s2))
        break;
      if (!(_WORD)--v7)
        return a4;
    }
    return *(_QWORD *)(v8 + 40);
  }
  return a4;
}

uint64_t feat_matchnextpos(uint64_t a1, unsigned __int16 a2, char *__s2, uint64_t a4)
{
  unsigned int v8;
  unint64_t v9;

  v8 = *(unsigned __int16 *)(a1 + 8);
  while (v8 > ++a2)
  {
    v9 = *(_QWORD *)a1 + ((unint64_t)a2 << 6);
    if (!strcmp(*(const char **)(v9 + 16), __s2))
      return *(_QWORD *)(v9 + 40);
  }
  return a4;
}

uint64_t feat_mosyntpos(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _WORD *i;

  v4 = (a3 + a2);
  if (a3 + a2 >= 0 && v4 < *(unsigned __int16 *)(a1 + 8))
  {
    v5 = *(_QWORD *)a1 + (v4 << 6);
    v6 = *(unsigned __int16 *)(v5 + 56);
    if (*(_WORD *)(v5 + 56))
    {
      for (i = (_WORD *)(*(_QWORD *)(v5 + 48) + 8); *i != 1; i += 8)
      {
        if (!--v6)
          return a4;
      }
      return *(_QWORD *)(*((_QWORD *)i - 1) + 16);
    }
  }
  return a4;
}

uint64_t hlp_setFeatureVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6, unsigned int a7, char **a8, unsigned __int16 a9, uint64_t a10)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  const char *v89;
  uint64_t v90;
  const char *v91;
  const char *v92;
  const char *v93;
  const char *v94;
  const char *v95;
  const char *v96;
  const char *v97;
  const char *v98;
  const char *v99;
  const char *v100;
  const char *v101;
  const char *v102;
  const char *v103;
  const char *v104;
  int v105;
  int v106;
  size_t v107;
  int v108;
  char **v109;
  uint64_t i;
  unsigned __int16 v111;
  char v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  BOOL v116;
  const char *v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  const char *v121;
  uint64_t v122;
  const char *v123;
  uint64_t v124;
  const char *v125;
  uint64_t v126;
  const char *v127;
  unsigned int v129;
  char **v130;
  unsigned int v131;
  unsigned int v132;
  __int16 v133;

  v133 = 0;
  v18 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 2048);
  if (v18)
  {
    v23 = (char *)v18;
    v131 = a6;
    v132 = a7;
    v130 = a8;
    if (a4 < 2)
    {
      v26 = 0;
LABEL_9:
      if (!hlp_isFeatureRequired(a3, a4, 11, &v133)
        || (!a6 || (v27 = a6 - 1, v27 >= a5[4])
          ? (v28 = "=")
          : (v28 = *(const char **)(*(_QWORD *)a5 + (v27 << 6) + 40)),
            v26 = hlp_setFeature(a1, a3, a4, 11, a2, v28),
            (v26 & 0x80000000) == 0))
      {
        if (!hlp_isFeatureRequired(a3, a4, 10, &v133)
          || ((v35 = a6 - 2, a6 < 2) || v35 >= a5[4]
            ? (v36 = "=")
            : (v36 = *(const char **)(*(_QWORD *)a5 + (v35 << 6) + 40)),
              v26 = hlp_setFeature(a1, a3, a4, 10, a2, v36),
              (v26 & 0x80000000) == 0))
        {
          if (!hlp_isFeatureRequired(a3, a4, 9, &v133)
            || ((v37 = a6 - 3, a6 < 3) || v37 >= a5[4]
              ? (v38 = "=")
              : (v38 = *(const char **)(*(_QWORD *)a5 + (v37 << 6) + 40)),
                v26 = hlp_setFeature(a1, a3, a4, 9, a2, v38),
                (v26 & 0x80000000) == 0))
          {
            if (!hlp_isFeatureRequired(a3, a4, 8, &v133)
              || ((v39 = a6 - 4, a6 < 4) || v39 >= a5[4]
                ? (v40 = "=")
                : (v40 = *(const char **)(*(_QWORD *)a5 + (v39 << 6) + 40)),
                  v26 = hlp_setFeature(a1, a3, a4, 8, a2, v40),
                  (v26 & 0x80000000) == 0))
            {
              if (!hlp_isFeatureRequired(a3, a4, 7, &v133)
                || ((v41 = a6 - 5, a6 < 5) || v41 >= a5[4]
                  ? (v42 = "=")
                  : (v42 = *(const char **)(*(_QWORD *)a5 + (v41 << 6) + 40)),
                    v26 = hlp_setFeature(a1, a3, a4, 7, a2, v42),
                    (v26 & 0x80000000) == 0))
              {
                if (!hlp_isFeatureRequired(a3, a4, 15, &v133)
                  || ((v50 = a6 + 1, v50 >= a5[4])
                    ? (v51 = "=")
                    : (v51 = *(const char **)(*(_QWORD *)a5 + (v50 << 6) + 40)),
                      v26 = hlp_setFeature(a1, a3, a4, 15, a2, v51),
                      (v26 & 0x80000000) == 0))
                {
                  if (!hlp_isFeatureRequired(a3, a4, 16, &v133)
                    || ((v64 = a6 + 2, v64 >= a5[4])
                      ? (v65 = "=")
                      : (v65 = *(const char **)(*(_QWORD *)a5 + (v64 << 6) + 40)),
                        v26 = hlp_setFeature(a1, a3, a4, 16, a2, v65),
                        (v26 & 0x80000000) == 0))
                  {
                    if (!hlp_isFeatureRequired(a3, a4, 17, &v133)
                      || ((v72 = a6 + 3, v72 >= a5[4])
                        ? (v73 = "=")
                        : (v73 = *(const char **)(*(_QWORD *)a5 + (v72 << 6) + 40)),
                          v26 = hlp_setFeature(a1, a3, a4, 17, a2, v73),
                          (v26 & 0x80000000) == 0))
                    {
                      if (!hlp_isFeatureRequired(a3, a4, 18, &v133)
                        || ((v80 = a6 + 4, v80 >= a5[4])
                          ? (v81 = "=")
                          : (v81 = *(const char **)(*(_QWORD *)a5 + (v80 << 6) + 40)),
                            v26 = hlp_setFeature(a1, a3, a4, 18, a2, v81),
                            (v26 & 0x80000000) == 0))
                      {
                        if (!hlp_isFeatureRequired(a3, a4, 19, &v133)
                          || ((v88 = a6 + 5, v88 >= a5[4])
                            ? (v89 = "=")
                            : (v89 = *(const char **)(*(_QWORD *)a5 + (v88 << 6) + 40)),
                              v26 = hlp_setFeature(a1, a3, a4, 19, a2, v89),
                              (v26 & 0x80000000) == 0))
                        {
                          if (!hlp_isFeatureRequired(a3, a4, 23, &v133)
                            || (v92 = (const char *)feat_pos((uint64_t)a5, a6, 0, (uint64_t)"="),
                                v26 = hlp_setFeature(a1, a3, a4, 23, a2, v92),
                                (v26 & 0x80000000) == 0))
                          {
                            if (!hlp_isFeatureRequired(a3, a4, 22, &v133)
                              || (v93 = (const char *)feat_pos((uint64_t)a5, a6, -1, (uint64_t)"="),
                                  v26 = hlp_setFeature(a1, a3, a4, 22, a2, v93),
                                  (v26 & 0x80000000) == 0))
                            {
                              if (!hlp_isFeatureRequired(a3, a4, 21, &v133)
                                || (v94 = (const char *)feat_pos((uint64_t)a5, a6, -2, (uint64_t)"="),
                                    v26 = hlp_setFeature(a1, a3, a4, 21, a2, v94),
                                    (v26 & 0x80000000) == 0))
                              {
                                if (!hlp_isFeatureRequired(a3, a4, 20, &v133)
                                  || (v95 = (const char *)feat_pos((uint64_t)a5, a6, -3, (uint64_t)"="),
                                      v26 = hlp_setFeature(a1, a3, a4, 20, a2, v95),
                                      (v26 & 0x80000000) == 0))
                                {
                                  if (!hlp_isFeatureRequired(a3, a4, 24, &v133)
                                    || (v96 = (const char *)feat_pos((uint64_t)a5, a6, 1, (uint64_t)"="),
                                        v26 = hlp_setFeature(a1, a3, a4, 24, a2, v96),
                                        (v26 & 0x80000000) == 0))
                                  {
                                    if (!hlp_isFeatureRequired(a3, a4, 25, &v133)
                                      || (v97 = (const char *)feat_pos((uint64_t)a5, a6, 2, (uint64_t)"="),
                                          v26 = hlp_setFeature(a1, a3, a4, 25, a2, v97),
                                          (v26 & 0x80000000) == 0))
                                    {
                                      if (!hlp_isFeatureRequired(a3, a4, 26, &v133)
                                        || (v98 = (const char *)feat_pos((uint64_t)a5, a6, 3, (uint64_t)"="),
                                            v26 = hlp_setFeature(a1, a3, a4, 26, a2, v98),
                                            (v26 & 0x80000000) == 0))
                                      {
                                        if (!hlp_isFeatureRequired(a3, a4, 27, &v133)
                                          || (v99 = (const char *)feat_mosyntpos((uint64_t)a5, a6, -1, (uint64_t)"="),
                                              v26 = hlp_setFeature(a1, a3, a4, 27, a2, v99),
                                              (v26 & 0x80000000) == 0))
                                        {
                                          if (!hlp_isFeatureRequired(a3, a4, 28, &v133)
                                            || (v100 = (const char *)feat_mosyntpos((uint64_t)a5, a6, 1, (uint64_t)"="),
                                                v26 = hlp_setFeature(a1, a3, a4, 28, a2, v100),
                                                (v26 & 0x80000000) == 0))
                                          {
                                            if (!hlp_isFeatureRequired(a3, a4, 29, &v133)
                                              || (v101 = (const char *)feat_matchprevpos((uint64_t *)a5, a6, "n", (uint64_t)"="), v26 = hlp_setFeature(a1, a3, a4, 29, a2, v101), (v26 & 0x80000000) == 0))
                                            {
                                              if (!hlp_isFeatureRequired(a3, a4, 30, &v133)
                                                || (v102 = (const char *)feat_matchnextpos((uint64_t)a5, a6, "n", (uint64_t)"="), v26 = hlp_setFeature(a1, a3, a4, 30, a2, v102), (v26 & 0x80000000) == 0))
                                              {
                                                if (!hlp_isFeatureRequired(a3, a4, 31, &v133)
                                                  || (v103 = (const char *)feat_matchprevpos((uint64_t *)a5, a6, "v", (uint64_t)"="), v26 = hlp_setFeature(a1, a3, a4, 31, a2, v103), (v26 & 0x80000000) == 0))
                                                {
                                                  if (!hlp_isFeatureRequired(a3, a4, 32, &v133)
                                                    || (v104 = (const char *)feat_matchnextpos((uint64_t)a5, a6, "v", (uint64_t)"="), v26 = hlp_setFeature(a1, a3, a4, 32, a2, v104), (v26 & 0x80000000) == 0))
                                                  {
                                                    if (!hlp_isFeatureRequired(a3, a4, 33, &v133))
                                                      goto LABEL_250;
                                                    *v23 = 0;
                                                    v105 = 0xFFFF;
                                                    v106 = a6;
                                                    do
                                                    {
                                                      v107 = strlen(v23);
                                                      v108 = (__int16)v105;
                                                      feat_wordlen((uint64_t)a5, v106, (__int16)v105++, "=", &v23[v107]);
                                                    }
                                                    while (v108 < 1);
                                                    v26 = hlp_setFeature(a1, a3, a4, 33, a2, v23);
                                                    a6 = v106;
                                                    if ((v26 & 0x80000000) == 0)
                                                    {
LABEL_250:
                                                      if (!hlp_isFeatureRequired(a3, a4, 34, &v133))
                                                        goto LABEL_249;
                                                      *v23 = 0;
                                                      v109 = v130;
                                                      if (a9)
                                                      {
                                                        for (i = a9 - 1; ; --i)
                                                        {
                                                          v111 = strlen(v23);
                                                          v112 = feat_colloc(a5, v131, *v109);
                                                          v113 = &v23[v111];
                                                          *v113 = v112;
                                                          v113[1] = 0;
                                                          if (!i)
                                                            break;
                                                          ++v109;
                                                          if (*v23)
                                                            *(_WORD *)&v23[strlen(v23)] = 32;
                                                        }
                                                      }
                                                      v26 = hlp_setFeature(a1, a3, a4, 34, a2, v23);
                                                      a6 = v131;
                                                      if ((v26 & 0x80000000) == 0)
                                                      {
LABEL_249:
                                                        if (!hlp_isFeatureRequired(a3, a4, 35, &v133)
                                                          || (v132 + 1 < 2 ? (v116 = a6 == 0) : (v116 = 0),
                                                              !v116 ? (v117 = "SI") : (v117 = "SB"),
                                                              v26 = hlp_setFeature(a1, a3, a4, 35, a2, v117),
                                                              (v26 & 0x80000000) == 0))
                                                        {
                                                          if (!hlp_isFeatureRequired(a3, a4, 38, &v133)
                                                            || (feat_wordbeg((uint64_t)a5, a6, 0, "=", v23),
                                                                v26 = hlp_setFeature(a1, a3, a4, 38, a2, v23),
                                                                (v26 & 0x80000000) == 0))
                                                          {
                                                            if (!hlp_isFeatureRequired(a3, a4, 43, &v133)
                                                              || (feat_wordend((uint64_t)a5, a6, 0, "=", v23),
                                                                  v26 = hlp_setFeature(a1, a3, a4, 43, a2, v23),
                                                                  (v26 & 0x80000000) == 0))
                                                            {
                                                              if (!hlp_isFeatureRequired(a3, a4, 37, &v133)|| (feat_wordbeg((uint64_t)a5, a6, -1, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 37, a2, v23), (v26 & 0x80000000) == 0))
                                                              {
                                                                if (!hlp_isFeatureRequired(a3, a4, 42, &v133)|| (feat_wordend((uint64_t)a5, a6, -1, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 42, a2, v23), (v26 & 0x80000000) == 0))
                                                                {
                                                                  if (!hlp_isFeatureRequired(a3, a4, 39, &v133)|| (feat_wordbeg((uint64_t)a5, a6, 1, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 39, a2, v23), (v26 & 0x80000000) == 0))
                                                                  {
                                                                    if (!hlp_isFeatureRequired(a3, a4, 44, &v133)|| (feat_wordend((uint64_t)a5, a6, 1, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 44, a2, v23), (v26 & 0x80000000) == 0))
                                                                    {
                                                                      if (!hlp_isFeatureRequired(a3, a4, 36, &v133)|| (feat_wordbeg((uint64_t)a5, a6, -2, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 36, a2, v23), (v26 & 0x80000000) == 0))
                                                                      {
                                                                        if (!hlp_isFeatureRequired(a3, a4, 41, &v133)|| (feat_wordend((uint64_t)a5, a6, -2, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 41, a2, v23), (v26 & 0x80000000) == 0))
                                                                        {
                                                                          if (!hlp_isFeatureRequired(a3, a4, 40, &v133)|| (feat_wordbeg((uint64_t)a5, a6, 2, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 40, a2, v23), (v26 & 0x80000000) == 0))
                                                                          {
                                                                            if (!hlp_isFeatureRequired(a3, a4, 45, &v133)|| (feat_wordend((uint64_t)a5, a6, 2, "=", v23), v26 = hlp_setFeature(a1, a3, a4, 45, a2, v23), (v26 & 0x80000000) == 0))
                                                                            {
                                                                              if (!hlp_isFeatureRequired(a3, a4, 46, &v133)|| (v26 = hlp_setFeature(a1, a3, a4, 46, a2, "="), (v26 & 0x80000000) == 0))
                                                                              {
                                                                                if (!hlp_isFeatureRequired(a3, a4, 47, &v133)
                                                                                  || (v26 = hlp_setFeature(a1, a3, a4, 47, a2, "="), (v26 & 0x80000000) == 0))
                                                                                {
                                                                                  if (!hlp_isFeatureRequired(a3, a4, 48, &v133)
                                                                                    || (v26 = hlp_setFeature(a1, a3, a4, 48, a2, "="), (v26 & 0x80000000) == 0))
                                                                                  {
                                                                                    if (!hlp_isFeatureRequired(a3, a4, 49, &v133)
                                                                                      || ((v118 = *(_QWORD *)(a10 + 8)) == 0
                                                                                       || v131 - 2 >= *(unsigned __int16 *)(a10 + 16)
                                                                                        ? (v119 = "=")
                                                                                        : (v119 = (const char *)(v118 + 40 * (v131 - 2) + 30)),
                                                                                          v26 = hlp_setFeature(a1, a3, a4, 49, a2, v119), (v26 & 0x80000000) == 0))
                                                                                    {
                                                                                      if (!hlp_isFeatureRequired(a3, a4, 50, &v133)
                                                                                        || ((v120 = *(_QWORD *)(a10 + 8)) == 0
                                                                                         || v131 - 1 >= *(unsigned __int16 *)(a10 + 16)
                                                                                          ? (v121 = "=")
                                                                                          : (v121 = (const char *)(v120 + 40 * (v131 - 1) + 30)),
                                                                                            v26 = hlp_setFeature(a1, a3, a4, 50, a2, v121), (v26 & 0x80000000) == 0))
                                                                                      {
                                                                                        if (!hlp_isFeatureRequired(a3, a4, 51, &v133)
                                                                                          || ((v122 = *(_QWORD *)(a10 + 8)) == 0
                                                                                           || *(unsigned __int16 *)(a10 + 16) <= v131
                                                                                            ? (v123 = "=")
                                                                                            : (v123 = (const char *)(v122 + 40 * v131 + 30)),
                                                                                              v26 = hlp_setFeature(a1, a3, a4, 51, a2, v123),
                                                                                              (v26 & 0x80000000) == 0))
                                                                                        {
                                                                                          if (!hlp_isFeatureRequired(a3, a4, 52, &v133)
                                                                                            || ((v124 = *(_QWORD *)(a10 + 8)) == 0
                                                                                             || v131 + 1 >= *(unsigned __int16 *)(a10 + 16)
                                                                                              ? (v125 = "=")
                                                                                              : (v125 = (const char *)(v124 + 40 * (v131 + 1) + 30)),
                                                                                                v26 = hlp_setFeature(a1, a3, a4, 52, a2, v125),
                                                                                                (v26 & 0x80000000) == 0))
                                                                                          {
                                                                                            if (hlp_isFeatureRequired(a3, a4, 53, &v133))
                                                                                            {
                                                                                              v126 = *(_QWORD *)(a10 + 8);
                                                                                              if (v126
                                                                                                && v131 + 2 < *(unsigned __int16 *)(a10 + 16))
                                                                                              {
                                                                                                v127 = (const char *)(v126 + 40 * (v131 + 2) + 30);
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                v127 = "=";
                                                                                              }
                                                                                              v31 = hlp_setFeature(a1, a3, a4, 53, a2, v127);
LABEL_244:
                                                                                              v26 = v31;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      v24 = 0;
      v25 = a4 - 1;
      while (strcmp(*(const char **)(a3 + 8 * v24), "char0"))
      {
        if (v25 == ++v24)
        {
          v26 = 0;
LABEL_42:
          v43 = a2;
          v44 = 0;
          while (strcmp(*(const char **)(a3 + 8 * v44), "lchar"))
          {
            if (v25 == ++v44)
              goto LABEL_56;
          }
          v133 = v44;
          v45 = "=";
          v46 = a1;
          if (v132 == -1)
          {
            v48 = a3;
            v49 = a4;
            v47 = v43;
          }
          else
          {
            v31 = feat_character(a1, (uint64_t)a5, v131, v132, -1, "=", v23);
            if ((v31 & 0x80000000) != 0)
              goto LABEL_244;
            v47 = v43;
            v46 = a1;
            v48 = a3;
            v49 = a4;
            v45 = v23;
          }
          v26 = hlp_setFeature(v46, v48, v49, 3, v47, v45);
          if ((v26 & 0x80000000) == 0)
          {
LABEL_56:
            v52 = 0;
            while (strcmp(*(const char **)(a3 + 8 * v52), "llchar"))
            {
              if (v25 == ++v52)
                goto LABEL_65;
            }
            v133 = v52;
            v53 = "=";
            v54 = a1;
            if (v132 == -1)
            {
              v56 = a3;
              v57 = a4;
              v55 = v43;
            }
            else
            {
              v31 = feat_character(a1, (uint64_t)a5, v131, v132, -2, "=", v23);
              if ((v31 & 0x80000000) != 0)
                goto LABEL_244;
              v55 = v43;
              v54 = a1;
              v56 = a3;
              v57 = a4;
              v53 = v23;
            }
            v26 = hlp_setFeature(v54, v56, v57, 2, v55, v53);
            if ((v26 & 0x80000000) == 0)
            {
LABEL_65:
              v58 = 0;
              while (strcmp(*(const char **)(a3 + 8 * v58), "l3char"))
              {
                if (v25 == ++v58)
                  goto LABEL_79;
              }
              v133 = v58;
              v59 = "=";
              v60 = a1;
              if (v132 == -1)
              {
                v62 = a3;
                v63 = a4;
                v61 = v43;
              }
              else
              {
                v31 = feat_character(a1, (uint64_t)a5, v131, v132, -3, "=", v23);
                if ((v31 & 0x80000000) != 0)
                  goto LABEL_244;
                v61 = v43;
                v60 = a1;
                v62 = a3;
                v63 = a4;
                v59 = v23;
              }
              v26 = hlp_setFeature(v60, v62, v63, 1, v61, v59);
              if ((v26 & 0x80000000) == 0)
              {
LABEL_79:
                v66 = 0;
                while (strcmp(*(const char **)(a3 + 8 * v66), "rchar"))
                {
                  if (v25 == ++v66)
                    goto LABEL_93;
                }
                v133 = v66;
                v67 = "=";
                v68 = a1;
                if (v132 == -1)
                {
                  v70 = a3;
                  v71 = a4;
                  v69 = v43;
                }
                else
                {
                  v31 = feat_character(a1, (uint64_t)a5, v131, v132, 1, "=", v23);
                  if ((v31 & 0x80000000) != 0)
                    goto LABEL_244;
                  v69 = v43;
                  v68 = a1;
                  v70 = a3;
                  v71 = a4;
                  v67 = v23;
                }
                v26 = hlp_setFeature(v68, v70, v71, 4, v69, v67);
                if ((v26 & 0x80000000) == 0)
                {
LABEL_93:
                  v74 = 0;
                  while (strcmp(*(const char **)(a3 + 8 * v74), "rrchar"))
                  {
                    if (v25 == ++v74)
                      goto LABEL_107;
                  }
                  v133 = v74;
                  v75 = "=";
                  v76 = a1;
                  if (v132 == -1)
                  {
                    v78 = a3;
                    v79 = a4;
                    v77 = v43;
                  }
                  else
                  {
                    v31 = feat_character(a1, (uint64_t)a5, v131, v132, 2, "=", v23);
                    if ((v31 & 0x80000000) != 0)
                      goto LABEL_244;
                    v77 = v43;
                    v76 = a1;
                    v78 = a3;
                    v79 = a4;
                    v75 = v23;
                  }
                  v26 = hlp_setFeature(v76, v78, v79, 5, v77, v75);
                  if ((v26 & 0x80000000) == 0)
                  {
LABEL_107:
                    v82 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v82), "r3char"))
                    {
                      if (v25 == ++v82)
                        goto LABEL_121;
                    }
                    v133 = v82;
                    v83 = "=";
                    v84 = a1;
                    if (v132 == -1)
                    {
                      v86 = a3;
                      v87 = a4;
                      v85 = v43;
                    }
                    else
                    {
                      v31 = feat_character(a1, (uint64_t)a5, v131, v132, 3, "=", v23);
                      if ((v31 & 0x80000000) != 0)
                        goto LABEL_244;
                      v85 = v43;
                      v84 = a1;
                      v86 = a3;
                      v87 = a4;
                      v83 = v23;
                    }
                    v26 = hlp_setFeature(v84, v86, v87, 6, v85, v83);
                    if ((v26 & 0x80000000) != 0)
                      goto LABEL_245;
LABEL_121:
                    v90 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v90), "word"))
                    {
                      if (v25 == ++v90)
                        goto LABEL_168;
                    }
                    v133 = v90;
                    if (a5[4] <= v131)
                      v91 = "=";
                    else
                      v91 = *(const char **)(*(_QWORD *)a5 + ((unint64_t)v131 << 6) + 40);
                    v26 = hlp_setFeature(a1, a3, a4, 12, v43, v91);
                    if ((v26 & 0x80000000) != 0)
                      goto LABEL_245;
LABEL_168:
                    v114 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v114), "wordnocase"))
                    {
                      if (v25 == ++v114)
                        goto LABEL_173;
                    }
                    v133 = v114;
                    feat_wordlc((uint64_t)a5, v131, 0, "=", v23);
                    v26 = hlp_setFeature(a1, a3, a4, 13, v43, v23);
                    if ((v26 & 0x80000000) != 0)
                      goto LABEL_245;
LABEL_173:
                    v115 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v115), "wordlen"))
                    {
                      if (v25 == ++v115)
                      {
                        a2 = v43;
                        a6 = v131;
                        goto LABEL_9;
                      }
                    }
                    v133 = v115;
                    a6 = v131;
                    feat_wordlen((uint64_t)a5, v131, 0, "=", v23);
                    a2 = v43;
                    v26 = hlp_setFeature(a1, a3, a4, 14, v43, v23);
                    if ((v26 & 0x80000000) == 0)
                      goto LABEL_9;
                    goto LABEL_245;
                  }
                  goto LABEL_245;
                }
                goto LABEL_245;
              }
              goto LABEL_245;
            }
            goto LABEL_245;
          }
          goto LABEL_245;
        }
      }
      v133 = v24;
      v29 = "=";
      v30 = a1;
      if (v132 == -1)
      {
        v32 = a3;
        v33 = a4;
        v34 = a2;
      }
      else
      {
        v31 = feat_character(a1, (uint64_t)a5, v131, v132, 0, "=", v23);
        if ((v31 & 0x80000000) != 0)
          goto LABEL_244;
        v30 = a1;
        v32 = a3;
        v33 = a4;
        v34 = a2;
        v29 = v23;
      }
      v26 = hlp_setFeature(v30, v32, v33, 0, v34, v29);
      if ((v26 & 0x80000000) == 0)
        goto LABEL_42;
    }
LABEL_245:
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v23);
  }
  else
  {
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v19, v20, v21, v22, v129);
    return 2314215434;
  }
  return v26;
}

uint64_t _hmgrph_param_split(uint64_t a1, const char *a2, uint64_t *a3, _DWORD *a4)
{
  int v8;
  size_t v9;
  int v10;
  unsigned __int8 *v11;
  size_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned int v26;

  do
    v8 = *(unsigned __int8 *)a2++;
  while (v8 == 32);
  v9 = strlen(a2 - 1);
  v10 = v9;
  v11 = (unsigned __int8 *)&a2[v9 - 2];
  if (*v11 == 32)
  {
    do
    {
      *v11 = 0;
      v12 = strlen(a2 - 1);
      v11 = (unsigned __int8 *)&a2[v12 - 2];
    }
    while (*v11 == 32);
    v10 = v12;
  }
  v13 = 0;
  v14 = 0;
  *a4 = 0;
  if ((v10 + 1) > 1)
    v15 = (v10 + 1);
  else
    v15 = 1;
  do
  {
    if ((a2[v14 - 1] | 0x20) == 0x20)
      *a4 = ++v13;
    ++v14;
  }
  while (v15 != v14);
  v16 = (_QWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 8 * v13);
  *a3 = (uint64_t)v16;
  if (v16)
  {
    *v16 = a2 - 1;
    if (v10)
    {
      v21 = 0;
      v22 = 0;
      do
      {
        v23 = (unsigned __int8 *)&a2[v21];
        if (a2[v21 - 1] == 32)
        {
          *(v23 - 1) = 0;
          ++v21;
          *(_QWORD *)(*a3 + 8 * ++v22) = v23;
        }
        else
        {
          ++v21;
        }
      }
      while (v21 != v10);
    }
    return 0;
  }
  else
  {
    v24 = 2314215434;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v26);
    if (*a3)
      heap_Free(*(_QWORD **)(a1 + 8), *a3);
  }
  return v24;
}

uint64_t _hmgrph_parse_params(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char **v10;
  uint64_t v11;
  unsigned int v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;

  *(_QWORD *)(a4 + 32) = 0;
  v6 = (uint64_t *)(a4 + 32);
  v7 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(v7 + 56) = 0;
  *(_BYTE *)(v7 + 64) = 0;
  *(_WORD *)(a4 + 40) = 0;
  if (a3)
  {
    v8 = 2314215424;
    v9 = a3;
    v10 = (const char **)(a2 + 8);
    do
    {
      v11 = *(_QWORD *)(a4 + 16);
      v12 = *(unsigned __int8 *)(v11 + 64);
      v23 = *(unsigned __int16 *)(a4 + 40);
      v24 = v12;
      v13 = *(v10 - 1);
      if (!strcmp(v13, "features"))
      {
        _hmgrph_param_split(a1, *v10, (uint64_t *)(v11 + 56), &v24);
        if (v24 > 0xFF)
          return v8;
        *(_BYTE *)(*(_QWORD *)(a4 + 16) + 64) = v24;
      }
      else if (!strcmp(v13, "collocations"))
      {
        _hmgrph_param_split(a1, *v10, v6, &v23);
        if (HIWORD(v23))
          return v8;
        *(_WORD *)(a4 + 40) = v23;
      }
      v10 += 2;
      --v9;
    }
    while (v9);
  }
  else
  {
    *(_BYTE *)(v7 + 64) = 29;
    v14 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 232);
    v19 = *(_QWORD *)(a4 + 16);
    *(_QWORD *)(v19 + 56) = v14;
    if (!v14)
    {
      log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v15, v16, v17, v18, v22);
      return 2314215434;
    }
    if (*(_BYTE *)(v19 + 64))
    {
      v20 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v19 + 56) + 8 * v20) = off_1EA93EF00[v20];
        ++v20;
        v19 = *(_QWORD *)(a4 + 16);
      }
      while (v20 < *(unsigned __int8 *)(v19 + 64));
    }
  }
  return 0;
}

uint64_t stat_hmogrph_ModelInit(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, _WORD *a8, unsigned __int16 *a9)
{
  uint64_t BrokerString;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int16 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84[2];
  uint64_t v85;
  unsigned int v86;
  char __s2[4];
  unsigned __int8 v88;
  _OWORD v89[16];
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v88 = 0;
  v86 = 0;
  *(_DWORD *)__s2 = 0;
  *(_QWORD *)v84 = 0;
  v85 = 0;
  memset(v89, 0, sizeof(v89));
  v83 = 0;
  *a7 = 0;
  *a8 = 0;
  *a9 = 0;
  BrokerString = stat_hmogrph_getBrokerString(a3, (char *)v89, 0x100uLL);
  if ((BrokerString & 0x80000000) != 0)
    goto LABEL_40;
  BrokerString = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v89, "HMGR", 1031, (uint64_t *)v84);
  if ((BrokerString & 0x80000000) != 0)
    goto LABEL_40;
  v82 = a4;
  v25 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v21, v22, v23, v24);
  if ((v25 & 0x80000000) != 0)
  {
    v39 = v25;
    v33 = 0;
  }
  else
  {
    v33 = 0;
    do
    {
      ++v33;
      ssftriff_reader_CloseChunk(*(uint64_t *)v84);
      v38 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v34, v35, v36, v37);
    }
    while ((v38 & 0x80000000) == 0);
    v39 = v38;
  }
  ssftriff_reader_ObjClose(*(_QWORD **)v84, v26, v27, v28, v29, v30, v31, v32);
  *(_QWORD *)v84 = 0;
  if ((v39 & 0x1FFF) != 0x14)
    goto LABEL_49;
  v40 = heap_Calloc(*(_QWORD **)(a3 + 8), 1, 48 * v33);
  *a7 = v40;
  if (!v40)
  {
    v39 = 2314215434;
    v78 = *(_QWORD *)(a3 + 32);
    v65 = 0;
    goto LABEL_52;
  }
  *a9 = v33;
  BrokerString = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v89, "HMGR", 1031, (uint64_t *)v84);
  if ((BrokerString & 0x80000000) != 0)
  {
LABEL_40:
    v39 = BrokerString;
    goto LABEL_41;
  }
  v45 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v21, v22, v23, v24);
  if ((v45 & 0x80000000) != 0)
  {
LABEL_37:
    if ((v45 & 0x1FFF) == 0x14)
      v39 = 0;
    else
      v39 = v45;
    goto LABEL_41;
  }
  v80 = a5;
  v81 = a6;
  while (1)
  {
    v46 = (unsigned __int16)*a8;
    v47 = *a7;
    if (!*a8)
    {
      v53 = 0;
LABEL_20:
      v49 = v47 + 48 * v53;
      *a8 = v46 + 1;
      __strcpy_chk();
      if (com_getUnicodeOrth(v82, a5, a6, (uint64_t)__s2, &v83))
        __strcpy_chk();
      else
        log_OutText(*(_QWORD *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Orth for unicode %s does not exist in dic_cfg4.cfg", v54, v55, v56, (uint64_t)__s2);
      goto LABEL_23;
    }
    v48 = 0;
    while (1)
    {
      v49 = v47 + v48;
      if (!strcmp((const char *)(v47 + v48 + 7), __s2))
        break;
      v48 += 48;
      if (48 * v46 == v48)
      {
        v53 = v46;
        a5 = v80;
        a6 = v81;
        goto LABEL_20;
      }
    }
    v53 = v46;
    a5 = v80;
    a6 = v81;
    if (!v47)
      goto LABEL_20;
LABEL_23:
    log_OutText(*(_QWORD *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"model #%d, homograph %s", v50, v51, v52, (unsigned __int16)*a8);
    v61 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v57, v58, v59, v60);
    if ((v61 & 0x80000000) == 0)
      break;
LABEL_35:
    v39 = v61;
    if ((v61 & 0x1FFF) != 0x14)
      goto LABEL_41;
    ssftriff_reader_CloseChunk(*(uint64_t *)v84);
    v45 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v71, v72, v73, v74);
    if ((v45 & 0x80000000) != 0)
      goto LABEL_37;
  }
  while (1)
  {
    log_OutText(*(_QWORD *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"model chunk %s for homograph %s, size %d", v22, v23, v24, (uint64_t)__s2);
    if (*(_DWORD *)__s2 ^ 0x48505243 | v88)
      break;
    v65 = *(_QWORD *)(v49 + 16);
    if (!v65)
    {
      v65 = heap_Calloc(*(_QWORD **)(a3 + 8), 1, 344);
      *(_QWORD *)(v49 + 16) = v65;
      if (!v65)
        goto LABEL_55;
    }
    *(_DWORD *)(v65 + 72) = 1;
    v66 = crf_Init(a1, a2, *(uint64_t *)v84, v65);
    if ((v66 & 0x80000000) != 0)
    {
LABEL_53:
      v39 = v66;
      ssftriff_reader_CloseChunk(*(uint64_t *)v84);
      goto LABEL_41;
    }
    _hmgrph_parse_params(a3, *(_QWORD *)(*(_QWORD *)(v49 + 16) + 32), *(_DWORD *)(*(_QWORD *)(v49 + 16) + 40), v49);
LABEL_34:
    ssftriff_reader_CloseChunk(*(uint64_t *)v84);
    v61 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v67, v68, v69, v70);
    if ((v61 & 0x80000000) != 0)
      goto LABEL_35;
  }
  if (*(_DWORD *)__s2 ^ 0x52544749 | v88)
  {
    log_OutText(*(_QWORD *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 0, 0, (uint64_t)"unknown model type %s", v62, v63, v64, (uint64_t)__s2);
    v39 = 2314215428;
    goto LABEL_41;
  }
  v65 = *(_QWORD *)(v49 + 24);
  if (v65 || (v65 = heap_Calloc(*(_QWORD **)(a3 + 8), 1, 1600), (*(_QWORD *)(v49 + 24) = v65) != 0))
  {
    v66 = igtree_Init(a1, a2, *(uint64_t *)v84, (char *)v65);
    if ((v66 & 0x80000000) != 0)
      goto LABEL_53;
    goto LABEL_34;
  }
LABEL_55:
  v39 = 2314215434;
  v78 = *(_QWORD *)(a3 + 32);
LABEL_52:
  log_OutPublic(v78, (uint64_t)"FE_HMOGRPH", 37000, (char *)v65, v41, v42, v43, v44, v79);
LABEL_41:
  if (*(_QWORD *)v84)
  {
    v75 = ssftriff_reader_ObjClose(*(_QWORD **)v84, v18, v19, v20, v21, v22, v23, v24);
    if (v75 >= 0 || (int)v39 <= -1)
      v39 = v39;
    else
      v39 = v75;
  }
  if ((v39 & 0x80000000) != 0)
  {
LABEL_49:
    stat_hmogrph_ModelDeinit(a3, a7, (unsigned __int16)*a8, v20, v21, v22, v23, v24);
    *a8 = 0;
  }
  return v39;
}

uint64_t stat_hmogrph_ModelDeinit(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if ((_DWORD)a3)
  {
    v10 = 0;
    v11 = 0;
    v12 = 48 * a3;
    do
    {
      v13 = *a2;
      v14 = *(_QWORD *)(*a2 + v10 + 24);
      if (v14)
      {
        v11 = igtree_Deinit(a1, v14, a3, a4, a5, a6, a7, a8);
        if ((v11 & 0x80000000) != 0)
          return v11;
        heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)(*a2 + v10 + 24));
        *(_QWORD *)(*a2 + v10 + 24) = 0;
        v13 = *a2;
      }
      v15 = *(_QWORD *)(v13 + v10 + 16);
      if (v15)
      {
        v11 = crf_Deinit(v15, v14, a3, a4, a5, a6, a7, a8);
        if ((v11 & 0x80000000) != 0)
          return v11;
        heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)(*a2 + v10 + 16));
        *(_QWORD *)(*a2 + v10 + 16) = 0;
        v13 = *a2;
      }
      v16 = *(_QWORD *)(v13 + v10 + 32);
      if (v16)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v16);
        *(_QWORD *)(*a2 + v10 + 32) = 0;
      }
      v10 += 48;
    }
    while (v12 != v10);
  }
  else
  {
    v11 = 0;
  }
  heap_Free(*(_QWORD **)(a1 + 8), *a2);
  *a2 = 0;
  return v11;
}

uint64_t hlp_getcharPhons(uint64_t a1, const char **a2, unsigned int a3, uint64_t *a4, _WORD *a5)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t result;
  unsigned int v26;

  if (a3)
  {
    v6 = a4;
    v10 = a3;
    v11 = a3;
    v12 = a4;
    do
    {
      v13 = (unsigned __int16)strlen(*a2);
      v14 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, v13 + 1);
      *v12 = (uint64_t)v14;
      if (!v14)
      {
        log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v15, v16, v17, v18, v26);
        do
        {
          if (*v6)
          {
            heap_Free(*(_QWORD **)(a1 + 8), *v6);
            *v6 = 0;
          }
          ++v6;
          --v10;
        }
        while (v10);
        return 2314215434;
      }
      v19 = *a2;
      a2 += 7;
      memcpy(v14, v19, v13);
      v20 = *v12++;
      *(_BYTE *)(v20 + v13) = 0;
      --v11;
    }
    while (v11);
    *a5 = 1;
    if (a3 != 1)
    {
      v21 = 1;
      v22 = 1;
      do
      {
        v23 = 0;
        v24 = (const char *)v6[v22];
        while (strcmp((const char *)v6[v23], v24))
        {
          if (v22 == ++v23)
          {
            *a5 = ++v21;
            break;
          }
        }
        ++v22;
      }
      while (v22 != v10);
    }
    return 0;
  }
  else
  {
    result = 0;
    *a5 = 0;
  }
  return result;
}

uint64_t hlp_concatFeatureVector(uint64_t a1, const char **a2, unsigned int a3, char **a4)
{
  uint64_t v8;
  uint64_t v9;
  const char **v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v19;

  if (a3)
  {
    LODWORD(v8) = 0;
    v9 = a3;
    v10 = a2;
    do
    {
      v11 = *v10++;
      v8 = v8 + strlen(v11) + 2;
      --v9;
    }
    while (v9);
  }
  else
  {
    v8 = 0;
  }
  v12 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, v8);
  *a4 = (char *)v12;
  if (v12)
  {
    if (a3)
    {
      v17 = 0;
      do
      {
        strcat(*a4, a2[v17]);
        if (v17 < a3 - 1)
          *(_WORD *)&(*a4)[strlen(*a4)] = 32;
        ++v17;
      }
      while (a3 != v17);
    }
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v19);
    return 2314215434;
  }
}

uint64_t hlp_disamWithModels(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, const char *a6, uint64_t a7, uint64_t a8, char *a9, __int128 *a10)
{
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  char *v23;
  __int128 *v24;
  const char *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  const char **v29;
  const char **v30;
  uint64_t inited;
  uint64_t v32;
  unsigned int v33;
  const char *v34;
  char **v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  _DWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  const char *v74;
  const char *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  const char *v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const char *v92;
  char *v93;
  uint64_t v94;
  _DWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  float *v100;
  uint64_t nnSent;
  uint64_t v102;
  unsigned int v103;
  uint64_t v104;
  unint64_t i;
  uint64_t v106;
  uint64_t v107;
  uint64_t *v108;
  uint64_t v110;
  const char *v111;
  int v112;
  int v113;
  int v114;
  uint64_t v115;
  uint64_t (**v116)(_QWORD, _QWORD, char *, float *);
  float v117;
  const char **v118;
  int v119;
  const char **v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  unsigned int NextUtf8Offset;
  const char **v132;
  uint64_t v133;
  const char *v134;
  int v135;
  int v136;
  __int16 v137;
  unsigned int PreviousUtf8Offset;
  BOOL v139;
  int v140;
  int v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  const char *v146;
  const char **v147;
  unsigned int v148;
  void (**v149)(_QWORD, _QWORD, char *, float *);
  uint64_t (**v150)(_QWORD, _QWORD, char *, float *);
  const char **v151;
  char *__src;
  float *v153;
  int v154;
  int v155;
  char *__dst;
  uint64_t *v157;
  __int128 *v158;
  unsigned int v159;
  unsigned int v160;
  const char *v161;
  const char **v162;
  _BOOL4 v165;
  int ReadOnly;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  uint64_t v173;
  const char **v174;
  uint64_t v175;
  const char *v176;
  int v177;
  const char **v178;
  _DWORD *v179;
  const char *v180;
  unsigned int v181;
  const char **v182;
  char *v183[2];

  v182 = 0;
  v183[0] = 0;
  v181 = 0;
  v179 = 0;
  v180 = 0;
  v178 = 0;
  v177 = 0;
  v175 = 0;
  v176 = 0;
  v174 = 0;
  if (!*(_QWORD *)(a2 + 40))
  {
    ReadOnly = 0;
LABEL_6:
    v165 = 0;
    goto LABEL_9;
  }
  v15 = *(_QWORD *)(a2 + 48);
  if (v15)
  {
    ReadOnly = ssftmap_FindReadOnly(v15, (uint64_t)a6, &v176);
    if (!*(_QWORD *)(a2 + 40))
      goto LABEL_6;
  }
  else
  {
    ReadOnly = 0;
  }
  v165 = strcmp(*(const char **)(a2 + 64), "albert") == 0;
LABEL_9:
  v16 = *(unsigned __int16 *)(a2 + 32);
  v162 = (const char **)a8;
  if (*(_WORD *)(a2 + 32))
  {
    LOWORD(v17) = 0;
    v18 = 0;
    v19 = 0;
    v20 = *(const char **)(a2 + 24);
    v21 = v20;
    do
    {
      if (!strcmp(v21, a6))
      {
        LOWORD(v17) = v18;
        v19 = 1;
      }
      ++v18;
      v21 += 48;
    }
    while (v16 != v18);
    if (v19)
      goto LABEL_19;
  }
  else
  {
    v20 = *(const char **)(a2 + 24);
    LOWORD(v17) = 0;
  }
  if (ReadOnly < 0)
  {
    log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 0, 0, (uint64_t)"No model for homograph %s exist", (uint64_t)a6, a7, a8, (uint64_t)a6);
    v22 = 0;
    v23 = 0;
    goto LABEL_78;
  }
LABEL_19:
  v24 = a10;
  v17 = (unsigned __int16)v17;
  v25 = &v20[48 * (unsigned __int16)v17];
  v27 = *((_QWORD *)v25 + 2);
  v26 = (uint64_t *)(v25 + 16);
  v28 = *(_QWORD *)(a1 + 32);
  v160 = a5;
  v161 = v20;
  if (!v27)
  {
    log_OutText(v28, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"MaxEnt model for homograph %s does not exist", (uint64_t)a6, a7, a8, (uint64_t)a6);
    v22 = 0;
    v30 = 0;
    goto LABEL_30;
  }
  log_OutText(v28, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Disambiguate homograph %s with MaxEnt model", (uint64_t)a6, a7, a8, (uint64_t)a6);
  v29 = (const char **)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 8 * *(unsigned __int8 *)(*v26 + 64) - 8);
  if (!v29)
  {
    v23 = 0;
    v22 = 2314215434;
    goto LABEL_78;
  }
  v30 = v29;
  inited = hlp_initFeatureVector(a1, v29, (unsigned __int16)(*(unsigned __int8 *)(*v26 + 64) - 1));
  if ((inited & 0x80000000) != 0)
    goto LABEL_37;
  v32 = *(_QWORD *)(*v26 + 56);
  v33 = *(unsigned __int8 *)(*v26 + 64);
  v34 = &v20[48 * (unsigned __int16)v17];
  v35 = (char **)*((_QWORD *)v34 + 4);
  LOWORD(v34) = *((_WORD *)v34 + 20);
  v36 = a10[3];
  v170 = a10[2];
  v171 = v36;
  v172 = a10[4];
  v173 = *((_QWORD *)a10 + 10);
  v37 = a10[1];
  v168 = *a10;
  v169 = v37;
  hlp_setFeatureVector(a1, (uint64_t)v30, v32, v33, (unsigned __int16 *)(a2 + 8), a3, v160, v35, (unsigned __int16)v34, (uint64_t)&v168);
  inited = hlp_concatFeatureVector(a1, v30, (*(_BYTE *)(*v26 + 64) - 1), v183);
  if ((inited & 0x80000000) != 0)
  {
LABEL_37:
    v22 = inited;
    goto LABEL_38;
  }
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATHMOGRPH_FEATURE: homograph %s at word %d, char %d", v38, v39, v40, (uint64_t)a6);
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATHMOGRPH_FEATURE: %s", v41, v42, v43, (uint64_t)v183[0]);
  v22 = crf_Process(*v26, v183, 1u, (uint64_t *)&v182, &v181);
  if ((v22 & 0x80000000) != 0)
  {
LABEL_38:
    v23 = 0;
    v69 = 0;
    goto LABEL_75;
  }
  if (*(_BYTE *)(*v26 + 64) != 1)
  {
    v47 = (unsigned __int16)(*(unsigned __int8 *)(*v26 + 64) - 1);
    v48 = (uint64_t *)v30;
    do
    {
      v49 = *v48++;
      heap_Free(*(_QWORD **)(a1 + 8), v49);
      --v47;
    }
    while (v47);
  }
  v24 = a10;
  if (v181 == 1)
  {
    v50 = strcpy(a9, *v182);
    a9[strlen(v50) - 1] = 0;
  }
  else
  {
    log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%d predictions for homograph %s with maxent model (discarded)", v44, v45, v46, v181);
  }
LABEL_30:
  v54 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(a2 + 40) || ReadOnly < 0)
  {
    v158 = v24;
    __dst = a9;
    log_OutText(v54, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No NN model for homograph %s !", v51, v52, v53, (uint64_t)a6);
    v23 = 0;
    goto LABEL_40;
  }
  log_OutText(v54, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Disambiguate homograph %s with NN model", v51, v52, v53, (uint64_t)a6);
  v55 = *(_QWORD *)(a2 + 80);
  v56 = (*(uint64_t (**)(_QWORD, _QWORD, int *))(v55 + 40))(*(_QWORD *)(a2 + 104), *(_QWORD *)(a2 + 112), &v177);
  if ((v56 & 0x80000000) != 0)
  {
    v22 = v56;
LABEL_73:
    v69 = 0;
    v23 = 0;
    goto LABEL_74;
  }
  v159 = (unsigned __int16)v17;
  v62 = (_DWORD *)(a2 + 60);
  v61 = *(_DWORD *)(a2 + 60);
  if (v165)
  {
    if (v61 == v177)
    {
      __dst = a9;
      v157 = (uint64_t *)(a1 + 8);
      v63 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 8);
      if (v63)
      {
        v23 = (char *)v63;
        v68 = *(_DWORD *)(a2 + 56) + 2;
        goto LABEL_60;
      }
      goto LABEL_72;
    }
LABEL_64:
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v57, v58, v59, v60, v148);
    v69 = 0;
    v23 = 0;
    v22 = 2314215449;
    goto LABEL_74;
  }
  if (v61 != v177 + 1)
    goto LABEL_64;
  __dst = a9;
  v157 = (uint64_t *)(a1 + 8);
  v94 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 8);
  if (!v94)
  {
LABEL_72:
    v22 = 2314215434;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v64, v65, v66, v67, v148);
    goto LABEL_73;
  }
  v23 = (char *)v94;
  v62 = (_DWORD *)(a2 + 56);
  v68 = *(_DWORD *)(a2 + 60);
LABEL_60:
  v95 = (_DWORD *)heap_Alloc(*v157, 4 * (v68 * *v62));
  v179 = v95;
  if (!v95)
  {
    v22 = 2314215434;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v96, v97, v98, v99, v148);
    goto LABEL_54;
  }
  v100 = (float *)v95;
  nnSent = make_nnSent(a1, a2 + 8, (uint64_t)&v174);
  if ((nnSent & 0x80000000) != 0)
  {
    v22 = nnSent;
    v110 = *(_QWORD *)(a1 + 32);
    v111 = "Make NN Sent Failed";
    goto LABEL_170;
  }
  if (v165)
  {
    *v100++ = 101.0;
    v103 = *(_DWORD *)(a2 + 56);
    v179[v103 + 1] = 1120665600;
  }
  else
  {
    v103 = *(_DWORD *)(a2 + 56);
  }
  v17 = v159;
  v112 = 1 - (__int16)v103;
  if (v112 < 0)
    v112 = 2 - (__int16)v103;
  v113 = v112 >> 1;
  if ((__int16)v103 >= -1)
    v114 = (__int16)v103 + 1;
  else
    v114 = (__int16)v103 + 2;
  v158 = v24;
  if (v113 >= v114 >> 1)
  {
LABEL_158:
    if (v165)
      v143 = v103 + 2;
    else
      v143 = v103;
    v22 = fi_predict(*(uint64_t ****)(a2 + 40), (const void **)&v179, v143, &v178, v102, v70, v71, v72);
    if ((v22 & 0x80000000) == 0)
    {
      v144 = *(_QWORD *)(a7 + 48) + 16 * a4;
      v145 = *(unsigned __int16 *)(v144 + 8);
      if (*(_WORD *)(v144 + 8))
      {
        v146 = *v178;
        v147 = v162;
        v73 = 1;
        while (strcmp(*v147, v146))
        {
          ++v147;
          if (!--v145)
            goto LABEL_173;
        }
        strcpy(__dst, v146);
        v73 = 0;
LABEL_173:
        v74 = v161;
        v17 = v159;
        goto LABEL_41;
      }
LABEL_40:
      v73 = 1;
      v74 = v161;
LABEL_41:
      v75 = &v74[48 * v17];
      v77 = *((_QWORD *)v75 + 3);
      v76 = (uint64_t *)(v75 + 24);
      v78 = *(_QWORD *)(a1 + 32);
      if (v77)
      {
        log_OutText(v78, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Disambiguate homograph %s with igtree model", v70, v71, v72, (uint64_t)a6);
        v69 = (uint64_t *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 8 * *(unsigned __int8 *)(*v76 + 1296) - 8);
        if (!v69)
        {
          v22 = 2314215434;
          goto LABEL_74;
        }
        v79 = hlp_initFeatureVector(a1, v69, (unsigned __int16)(*(unsigned __int8 *)(*v76 + 1296) - 1));
        if ((v79 & 0x80000000) != 0)
        {
          v22 = v79;
          goto LABEL_74;
        }
        v80 = *(_QWORD *)(*v76 + 1312);
        v81 = *(unsigned __int8 *)(*v76 + 1296);
        v82 = v158[3];
        v170 = v158[2];
        v171 = v82;
        v172 = v158[4];
        v173 = *((_QWORD *)v158 + 10);
        v83 = v158[1];
        v168 = *v158;
        v169 = v83;
        hlp_setFeatureVector(a1, (uint64_t)v69, v80, v81, (unsigned __int16 *)(a2 + 8), a3, v160, 0, 0, (uint64_t)&v168);
        igtree_Process(*v76, (uint64_t)v69, &v180);
        if (*(_BYTE *)(*v76 + 1296) != 1)
        {
          v84 = (unsigned __int16)(*(unsigned __int8 *)(*v76 + 1296) - 1);
          v85 = v69;
          do
          {
            v86 = *v85++;
            heap_Free(*(_QWORD **)(a1 + 8), v86);
            --v84;
          }
          while (v84);
        }
        v87 = v180;
        v88 = strcmp(v180, "NOMATCH");
        if ((v73 & 1) != 0)
        {
          if (!v88)
          {
            v92 = v176;
            if (!v176 || ReadOnly < 0)
            {
              log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No igtree rule matched for homograph %s", v89, v90, v91, (uint64_t)a6);
              if (!*__dst)
              {
                v22 = 0;
                *(_QWORD *)__dst = 0x484354414D4F4ELL;
                goto LABEL_74;
              }
LABEL_71:
              v22 = 0;
              goto LABEL_74;
            }
            v93 = __dst;
LABEL_70:
            strcpy(v93, v92);
            goto LABEL_71;
          }
        }
        else if (!v88 || !strcmp(v87, *v178))
        {
          goto LABEL_71;
        }
        v93 = __dst;
        v92 = v87;
        goto LABEL_70;
      }
      log_OutText(v78, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"IGTree model for homograph %s does not exist", v70, v71, v72, (uint64_t)a6);
LABEL_54:
      v69 = 0;
      goto LABEL_74;
    }
    v110 = *(_QWORD *)(a1 + 32);
    v111 = "FIhmogrph Prediction Failed";
LABEL_170:
    log_OutText(v110, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)v111, v70, v71, v72, 0);
    goto LABEL_54;
  }
  v115 = a3;
  v151 = v30;
  v116 = (uint64_t (**)(_QWORD, _QWORD, char *, float *))(v55 + 72);
  if (!v165)
    v116 = (uint64_t (**)(_QWORD, _QWORD, char *, float *))(v55 + 56);
  v149 = (void (**)(_QWORD, _QWORD, char *, float *))(v55 + 56);
  v150 = v116;
  while (1)
  {
    v155 = v113;
    if (!v165)
    {
      if ((_WORD)v113)
        v117 = 0.0;
      else
        v117 = 1.0;
      *v100++ = v117;
    }
    v118 = v174;
    __src = *(char **)(a2 + 72);
    v153 = v100;
    v154 = strlen(v174[v115]);
    v119 = 0;
    if (a3)
    {
      v120 = v174;
      v121 = (unsigned __int16)(a3 + 1);
      do
      {
        v122 = *v120++;
        v119 += strlen(v122);
        --v115;
      }
      while (v115);
    }
    else
    {
      v121 = 1;
    }
    v123 = (unsigned __int16)v175;
    if (v121 >= (unsigned __int16)v175)
    {
      v124 = 0;
      v17 = v159;
    }
    else
    {
      v124 = 0;
      v17 = v159;
      do
        v124 += strlen(v174[v121++]);
      while ((unsigned __int16)v175 != (unsigned __int16)v121);
    }
    v125 = heap_Calloc((_QWORD *)*v157, 1, (v154 + v119 + v124 + 1));
    if (!v125)
      break;
    v130 = (char *)v125;
    if ((_DWORD)v123)
    {
      NextUtf8Offset = v119 + v160;
      v132 = v118;
      v133 = v123;
      do
      {
        v134 = *v132++;
        strcat(v130, v134);
        --v133;
      }
      while (v133);
      v17 = v159;
      if (v123 > a3 && strlen(v118[a3]) > v160)
      {
        v135 = v155;
        if ((v155 & 0x8000) != 0)
        {
          if (NextUtf8Offset)
          {
            v137 = v155;
            do
            {
              PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)v130, NextUtf8Offset);
              NextUtf8Offset = PreviousUtf8Offset;
              v139 = (unsigned __int16)~v137++ == 0;
            }
            while (!v139 && PreviousUtf8Offset);
            if (!v137)
            {
LABEL_140:
              if ((utf8_getUTF8Char((uint64_t)v130, NextUtf8Offset, v23) & 0x80000000) == 0)
                goto LABEL_142;
            }
          }
        }
        else
        {
          if (!(_WORD)v155)
            goto LABEL_140;
          while (NextUtf8Offset != strlen(v130))
          {
            NextUtf8Offset = utf8_GetNextUtf8Offset(v130, NextUtf8Offset);
            v136 = (__int16)v135--;
            if (v136 <= 1)
              goto LABEL_140;
          }
        }
      }
    }
    strcpy(v23, __src);
LABEL_142:
    heap_Free((_QWORD *)*v157, (uint64_t)v130);
    if (!*v23)
      strcpy(v23, *(const char **)(a2 + 72));
    v30 = v151;
    v115 = a3;
    if (utf8_IsChineseLetter(v23))
      goto LABEL_152;
    v140 = *v23;
    switch(v140)
    {
      case 's':
        strcpy(v23, *(const char **)(a2 + 72));
        break;
      case 'e':
        v141 = 4673093;
        goto LABEL_151;
      case '0':
        v141 = 5068110;
LABEL_151:
        *(_DWORD *)v23 = v141;
        break;
    }
LABEL_152:
    if (((*v150)(*(_QWORD *)(a2 + 104), *(_QWORD *)(a2 + 112), v23, v153) & 0x1FFF) == 0x14)
    {
      log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v70, v71, v72, (uint64_t)v23);
      strcpy(v23, *(const char **)(a2 + 72));
      (*v149)(*(_QWORD *)(a2 + 104), *(_QWORD *)(a2 + 112), v23, v153);
    }
    v100 = &v153[v177];
    v113 = v155 + 1;
    v103 = *(_DWORD *)(a2 + 56);
    if ((__int16)v103 >= -1)
      v142 = (__int16)v103 + 1;
    else
      v142 = (__int16)v103 + 2;
    if (v142 >> 1 <= (__int16)v113)
      goto LABEL_158;
  }
  v22 = 2314215434;
  log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v126, v127, v128, v129, v148);
  v69 = 0;
  v30 = v151;
LABEL_74:
  if (v30)
LABEL_75:
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v30);
  if (v69)
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v69);
LABEL_78:
  if (v183[0])
  {
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v183[0]);
    v183[0] = 0;
  }
  v104 = (uint64_t)v182;
  if (v182)
  {
    if (v181)
    {
      for (i = 0; i < v181; heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v182[i++]))
        ;
      v104 = (uint64_t)v182;
    }
    heap_Free(*(_QWORD **)(a1 + 8), v104);
    v182 = 0;
  }
  if (v23)
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v23);
  v106 = (unsigned __int16)v175;
  v107 = (uint64_t)v174;
  if ((_WORD)v175)
  {
    v108 = (uint64_t *)v174;
    do
    {
      if (*v108)
      {
        heap_Free(*(_QWORD **)(a1 + 8), *v108);
        *v108 = 0;
      }
      ++v108;
      --v106;
    }
    while (v106);
LABEL_95:
    heap_Free(*(_QWORD **)(a1 + 8), v107);
  }
  else if (v174)
  {
    goto LABEL_95;
  }
  return v22;
}

uint64_t make_nnSent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BOOL4 IsChineseLetter;
  const char *v15;
  int v16;
  _WORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL4 v22;
  const char *v23;
  size_t v24;
  size_t v25;
  char *v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  __int16 v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  unsigned int v43;

  v6 = *(unsigned __int16 *)(a2 + 8);
  *(_WORD *)(a3 + 8) = v6;
  v7 = heap_Alloc(*(_QWORD *)(a1 + 8), 8 * v6);
  *(_QWORD *)a3 = v7;
  if (!v7)
  {
LABEL_39:
    v36 = 2314215434;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v8, v9, v10, v11, v43);
    return v36;
  }
  if (!*(_WORD *)(a3 + 8))
    return 0;
  v12 = 0;
  v13 = 0;
  while (1)
  {
    IsChineseLetter = utf8_IsChineseLetter(*(const char **)(*(_QWORD *)a2 + 8 * v12));
    v15 = *(const char **)(*(_QWORD *)a2 + 8 * v12);
    if (IsChineseLetter || strlen(*(const char **)(*(_QWORD *)a2 + 8 * v12)) != 1)
      break;
    v16 = *(unsigned __int8 *)v15;
    if ((v16 - 48) <= 9)
    {
      v17 = (_WORD *)heap_Alloc(*(_QWORD *)(a1 + 8), 2);
      *(_QWORD *)(*(_QWORD *)a3 + v12) = v17;
      if (!v17)
        goto LABEL_42;
LABEL_19:
      *v17 = 48;
      goto LABEL_20;
    }
    v33 = (v16 & 0xFFFFFFDF) - 65;
    v26 = (char *)heap_Alloc(*(_QWORD *)(a1 + 8), 2);
    *(_QWORD *)(*(_QWORD *)a3 + v12) = v26;
    if (v33 <= 0x19)
    {
      if (!v26)
        goto LABEL_42;
LABEL_24:
      v34 = 101;
LABEL_25:
      *(_WORD *)v26 = v34;
      goto LABEL_20;
    }
    if (!v26)
    {
LABEL_42:
      v36 = 2314215434;
      log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v18, v19, v20, v21, v43);
      v41 = *(_QWORD *)(a1 + 32);
      v42 = "Tag 1-char orth word for NN Failed";
      goto LABEL_44;
    }
LABEL_12:
    strcpy(v26, *(const char **)(*(_QWORD *)a2 + 8 * v12));
LABEL_20:
    ++v13;
    v12 += 8;
    if (v13 >= *(unsigned __int16 *)(a3 + 8))
      return 0;
  }
  v22 = utf8_IsChineseLetter(v15);
  v23 = *(const char **)(*(_QWORD *)a2 + 8 * v12);
  if (v22 || (v24 = strlen(*(const char **)(*(_QWORD *)a2 + 8 * v12)), v24 == 1))
  {
    v25 = strlen(v23);
    v26 = (char *)heap_Alloc(*(_QWORD *)(a1 + 8), v25 + 1);
    *(_QWORD *)(*(_QWORD *)a3 + v12) = v26;
    if (!v26)
      goto LABEL_39;
    goto LABEL_12;
  }
  v27 = *(unsigned __int8 *)v23;
  if ((v27 - 48) < 0xA
    || ((v27 - 35) <= 0x3C
      ? (v28 = ((1 << (v27 - 35)) & 0x1800000004000503) == 0)
      : (v28 = 1),
        !v28 || v27 == 124))
  {
    v17 = (_WORD *)heap_Alloc(*(_QWORD *)(a1 + 8), 2);
    *(_QWORD *)(*(_QWORD *)a3 + v12) = v17;
    if (!v17)
      goto LABEL_43;
    goto LABEL_19;
  }
  if ((v27 & 0xFFFFFFDF) - 65 < 0x1A)
    goto LABEL_30;
  v35 = v27 - 34;
  if (v35 > 0x39)
    goto LABEL_37;
  if (((1 << v35) & 0x200000006000061) != 0)
  {
    v26 = (char *)heap_Alloc(*(_QWORD *)(a1 + 8), (v24 + 1));
    *(_QWORD *)(*(_QWORD *)a3 + v12) = v26;
    if (!v26)
      goto LABEL_43;
    goto LABEL_12;
  }
  if (((1 << v35) & 0x40000010) != 0)
  {
LABEL_30:
    v26 = (char *)heap_Alloc(*(_QWORD *)(a1 + 8), 2);
    *(_QWORD *)(*(_QWORD *)a3 + v12) = v26;
    if (!v26)
      goto LABEL_43;
    goto LABEL_24;
  }
LABEL_37:
  v26 = (char *)heap_Alloc(*(_QWORD *)(a1 + 8), 2);
  *(_QWORD *)(*(_QWORD *)a3 + v12) = v26;
  if (v26)
  {
    v34 = 115;
    goto LABEL_25;
  }
LABEL_43:
  v36 = 2314215434;
  log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v29, v30, v31, v32, v43);
  v41 = *(_QWORD *)(a1 + 32);
  v42 = "Tag orth word for NN Failed";
LABEL_44:
  log_OutText(v41, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)v42, v38, v39, v40, 0);
  return v36;
}

uint64_t hlp_disamCharByChar(uint64_t a1, unsigned int a2, unsigned int a3, _WORD *a4, int *a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned int NextUtf8Offset;
  unsigned int UTF8Char;
  uint64_t v35;
  int v36;
  const char *v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char **v43;
  int v44;
  char *v45;
  int v46;
  int hasRcdWithGivenPOIClass;
  _WORD *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  unsigned __int16 *v52;
  unsigned int v53;
  unsigned int v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  unsigned __int16 v58;
  int *v59;
  int v60;
  int v61;
  uint64_t *v62;
  unsigned int v64;
  int *v65;
  _WORD *v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  uint64_t v70;
  int v71;
  unsigned int v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t *v75;
  __int128 v76[5];
  uint64_t v77;
  unsigned __int16 v78;
  char __s2[15];

  v12 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(a1 + 8);
  v14 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 1024);
  if (v14)
  {
    v19 = v14;
    v68 = a6;
    v20 = v13 + ((unint64_t)a2 << 6);
    *v14 = 0;
    v21 = *(_QWORD *)(v20 + 48);
    v74 = (_QWORD *)(v20 + 48);
    v22 = *(unsigned __int16 *)(v21 + 16 * a3 + 8);
    v73 = a3;
    v70 = a2;
    v69 = a2;
    if (*(_WORD *)(v21 + 16 * a3 + 8))
    {
      v23 = (_DWORD *)(*(_QWORD *)(v21 + 16 * a3) + 48);
      v24 = v22;
      do
      {
        *v23 = 0;
        v23 += 14;
        --v24;
      }
      while (v24);
      v25 = v22;
    }
    else
    {
      v25 = 0;
    }
    v27 = heap_Calloc(*(_QWORD **)(v12 + 8), v25, 8);
    if (!v27)
    {
      v26 = 2314215434;
      log_OutPublic(*(_QWORD *)(v12 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v28, v29, v30, v31, v64);
LABEL_57:
      heap_Free(*(_QWORD **)(v12 + 8), (uint64_t)v19);
      return v26;
    }
    v67 = v13;
    v75 = (uint64_t *)v27;
    v71 = v22;
    if (a3)
    {
      v32 = 0;
      NextUtf8Offset = 0;
      do
      {
        NextUtf8Offset = utf8_GetNextUtf8Offset(*(char **)v20, NextUtf8Offset);
        ++v32;
      }
      while (a3 > (unsigned __int16)v32);
    }
    else
    {
      NextUtf8Offset = 0;
    }
    UTF8Char = utf8_getUTF8Char(*(_QWORD *)v20, NextUtf8Offset, __s2);
    if ((UTF8Char & 0x80000000) != 0)
    {
      v72 = UTF8Char;
    }
    else
    {
      v78 = 0;
      v72 = hlp_getcharPhons(v12, *(const char ***)(*v74 + 16 * a3), *(unsigned __int16 *)(*v74 + 16 * a3 + 8), v75, &v78);
      if ((v72 & 0x80000000) == 0)
      {
        v66 = a4;
        if (v78 >= 2u)
        {
          v65 = a5;
          v35 = *(unsigned __int16 *)(a1 + 32);
          if (!*(_WORD *)(a1 + 32))
            goto LABEL_33;
          v36 = 0;
          v37 = *(const char **)(a1 + 24);
          do
          {
            if (!strcmp(v37, __s2))
              v36 = 1;
            v37 += 48;
            --v35;
          }
          while (v35);
          if (v36)
          {
            v38 = *(_OWORD *)(v68 + 48);
            v76[2] = *(_OWORD *)(v68 + 32);
            v76[3] = v38;
            v76[4] = *(_OWORD *)(v68 + 64);
            v77 = *(_QWORD *)(v68 + 80);
            v39 = *(_OWORD *)(v68 + 16);
            v76[0] = *(_OWORD *)v68;
            v76[1] = v39;
            hlp_disamWithModels(v12, a1, v69, a3, NextUtf8Offset, __s2, v20, (uint64_t)v75, v19, v76);
            a5 = v65;
            if (strcmp(v19, "NOMATCH"))
            {
              v40 = *v74 + 16 * a3;
              if (*(_WORD *)(v40 + 8))
              {
                v41 = 0;
                v42 = 56 * *(unsigned __int16 *)(v40 + 8);
                v43 = (const char **)v75;
                do
                {
                  if (strcmp(*v43, v19))
                    *(_DWORD *)(*(_QWORD *)v40 + v41 + 48) = 1;
                  ++v43;
                  v41 += 56;
                }
                while (v42 != v41);
              }
            }
          }
          else
          {
LABEL_33:
            a5 = v65;
            *v65 = 0;
          }
        }
        v45 = *(char **)(v67 + (v70 << 6) + 24);
        if (*v45)
        {
          v46 = strcmp(*(const char **)(v67 + (v70 << 6) + 24), "poi");
          hasRcdWithGivenPOIClass = hlp_hasRcdWithGivenPOIClass(v20, v45);
          v48 = v66;
          if (v46)
          {
            if (!hasRcdWithGivenPOIClass)
            {
              v44 = v71;
              if (hlp_hasRcdWithGivenPOIClass(v20, "poi"))
                hlp_filterWordCandIfTnIsNot(v20, "poi");
              else
                hlp_filterWordCandIfTnHas((char *)v20);
LABEL_43:
              *v48 = -1;
              v51 = *v74 + 16 * v73;
              v54 = *(unsigned __int16 *)(v51 + 8);
              v52 = (unsigned __int16 *)(v51 + 8);
              v53 = v54;
              if (!v54)
                goto LABEL_50;
              v55 = 0;
              v56 = *(_QWORD *)(*v74 + 16 * v73) + 48;
              v57 = 0xFFFF;
              v58 = -1;
              v59 = (int *)v56;
              do
              {
                v60 = *v59;
                v59 += 14;
                if (!v60 && *(unsigned __int16 *)(v56 - 40) < v58)
                {
                  v57 = (unsigned __int16)v55;
                  *v48 = v55;
                  v58 = *(_WORD *)(v56 - 40);
                  v53 = *v52;
                }
                ++v55;
                v56 = (uint64_t)v59;
              }
              while (v55 < v53);
              if (v57 != 0xFFFF)
                v61 = 1;
              else
LABEL_50:
                v61 = 0;
              *a5 = v61;
              goto LABEL_53;
            }
            v49 = v20;
            v50 = v45;
          }
          else
          {
            if (!hasRcdWithGivenPOIClass)
            {
              hlp_filterWordCandIfTnHas((char *)v20);
              goto LABEL_42;
            }
            v50 = "poi";
            v49 = v20;
          }
          hlp_filterWordCandIfTnIsNot(v49, v50);
        }
        else
        {
          hlp_filterWordCandIfTnHas((char *)v20);
          v48 = v66;
        }
LABEL_42:
        v44 = v71;
        goto LABEL_43;
      }
    }
    v44 = v71;
LABEL_53:
    if (v44)
    {
      v62 = v75;
      do
      {
        heap_Free(*(_QWORD **)(v12 + 8), *v62);
        *v62++ = 0;
        --v25;
      }
      while (v25);
    }
    heap_Free(*(_QWORD **)(v12 + 8), (uint64_t)v75);
    v26 = v72;
    goto LABEL_57;
  }
  v26 = 2314215434;
  log_OutPublic(*(_QWORD *)(v12 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v15, v16, v17, v18, v64);
  return v26;
}

uint64_t hlp_disamSpecialWords(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v9;
  unsigned __int16 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char **v18;
  uint64_t v19;
  unsigned int NextUtf8Offset;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _WORD *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int16 *v31;
  uint64_t i;
  unsigned int v33;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t inited;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  __int128 v43;
  __int128 v44;
  unsigned __int16 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char **v54;
  uint64_t v56;
  _OWORD v58[5];
  uint64_t v59;
  const char *v60;
  __int16 v61;
  unsigned __int8 v62[8];

  *(_DWORD *)&v62[3] = 0;
  *(_DWORD *)v62 = 0;
  v61 = 0;
  v10 = (unsigned __int16 *)(a2 + 1);
  v9 = a2[1];
  v60 = 0;
  *a5 = 0;
  v11 = v9 + ((unint64_t)a3 << 6);
  v13 = (uint64_t *)(v11 + 48);
  v12 = *(_QWORD *)(v11 + 48);
  v14 = a4;
  v15 = v12 + 16 * a4;
  v16 = *(unsigned __int16 *)(v15 + 8);
  if (*(_WORD *)(v15 + 8))
  {
    v17 = *(char ***)(v12 + 16 * a4);
    while (!strstr(*v17, "{SEP"))
    {
      v17 += 7;
      if (!--v16)
        goto LABEL_5;
    }
LABEL_16:
    v21 = 0;
LABEL_17:
    v24 = 0;
LABEL_18:
    if (!*(_DWORD *)(a1 + 144))
    {
      v25 = *v13 + 16 * v14;
      v26 = *(unsigned __int16 *)(v25 + 8);
      if (*(_WORD *)(v25 + 8))
      {
        v29 = *(_QWORD *)v25;
        v28 = (_WORD *)(v25 + 12);
        v27 = v29;
        *v28 = 0;
        if ((_DWORD)v26 != 1)
        {
          v30 = 0;
          v31 = (unsigned __int16 *)(v27 + 64);
          for (i = 1; i != v26; ++i)
          {
            v33 = *v31;
            v31 += 28;
            if (v33 < *(unsigned __int16 *)(v27 + 56 * v30 + 8))
            {
              v30 = (unsigned __int16)i;
              *v28 = i;
            }
          }
        }
      }
LABEL_25:
      *a5 = 1;
    }
    if (v24)
LABEL_27:
      heap_Free(*(_QWORD **)(*a2 + 8), v24);
  }
  else
  {
LABEL_5:
    v19 = *(_QWORD *)(v11 + 40);
    v18 = (char **)(v11 + 40);
    if ((utf8_getUTF8Char(v19, 0, v62) & 0x80000000) == 0)
    {
      NextUtf8Offset = 0;
      while (strlen(*v18) > NextUtf8Offset)
      {
        if (utf8_Utf8CharTo16bit(v62, (uint64_t)&v61)
          && (unsigned __int16)((unsigned __int16)(v61 + 24576) >> 9) <= 0x56u)
        {
          if (!*((_WORD *)a2 + 16))
            goto LABEL_16;
          v22 = 0;
          v21 = a2[3];
          v23 = 48 * *((unsigned __int16 *)a2 + 16);
          while (strcmp((const char *)(v21 + v22 + 7), "0000"))
          {
            v22 += 48;
            if (v23 == v22)
              goto LABEL_16;
          }
          if (!v21)
            goto LABEL_17;
          v35 = v21 + v22;
          v36 = *(_QWORD *)(v35 + 24);
          if (!v36)
            goto LABEL_16;
          v37 = (_QWORD *)heap_Calloc(*(_QWORD **)(*a2 + 8), 1, 8 * *(unsigned __int8 *)(v36 + 1296) - 8);
          if (!v37)
            return 2314215434;
          v24 = (uint64_t)v37;
          inited = hlp_initFeatureVector(*a2, v37, (unsigned __int16)(*(unsigned __int8 *)(*(_QWORD *)(v35 + 24) + 1296) - 1));
          if ((inited & 0x80000000) != 0)
          {
            v21 = inited;
            goto LABEL_27;
          }
          v39 = *a2;
          v40 = *(_QWORD *)(v35 + 24);
          v41 = *(_QWORD *)(v40 + 1312);
          v42 = *(unsigned __int8 *)(v40 + 1296);
          v43 = *(_OWORD *)(a6 + 48);
          v58[2] = *(_OWORD *)(a6 + 32);
          v58[3] = v43;
          v58[4] = *(_OWORD *)(a6 + 64);
          v59 = *(_QWORD *)(a6 + 80);
          v44 = *(_OWORD *)(a6 + 16);
          v58[0] = *(_OWORD *)a6;
          v58[1] = v44;
          hlp_setFeatureVector(v39, v24, v41, v42, v10, a3, 0xFFFFFFFF, 0, 0, (uint64_t)v58);
          v21 = igtree_Process(*(_QWORD *)(v35 + 24), v24, &v60);
          if ((v21 & 0x80000000) != 0)
            goto LABEL_27;
          v45 = *(unsigned __int8 *)(*(_QWORD *)(v35 + 24) + 1296) - 1;
          if (*(_BYTE *)(*(_QWORD *)(v35 + 24) + 1296) != 1)
          {
            v46 = *a2;
            v47 = v45;
            v48 = (uint64_t *)v24;
            do
            {
              v49 = *v48++;
              heap_Free(*(_QWORD **)(v46 + 8), v49);
              --v47;
            }
            while (v47);
          }
          v50 = v60;
          if (strcmp(v60, "NOMATCH"))
          {
            v51 = *v13 + 16 * v14;
            v52 = *(unsigned __int16 *)(v51 + 8);
            if (*(_WORD *)(v51 + 8))
            {
              v53 = 0;
              v56 = *v13;
              v54 = *(const char ***)(*v13 + 16 * v14);
              while (strcmp(v50, *v54))
              {
                ++v53;
                v54 += 7;
                if (v52 == v53)
                  goto LABEL_18;
              }
              *(_WORD *)(v56 + 16 * v14 + 12) = v53;
              goto LABEL_25;
            }
          }
          goto LABEL_18;
        }
        NextUtf8Offset = utf8_GetNextUtf8Offset(*v18, NextUtf8Offset);
        if ((utf8_getUTF8Char((uint64_t)*v18, NextUtf8Offset, v62) & 0x80000000) != 0)
          return 0;
      }
    }
    return 0;
  }
  return v21;
}

uint64_t stat_hmogrph_disambiguatePhons(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unint64_t v5;
  uint64_t result;
  __int128 *v7;
  unint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int16 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  int v26;
  __int16 v27;

  v27 = 0;
  v26 = 0;
  v2 = *(unsigned __int16 *)(a2 + 16);
  if (!*(_WORD *)(a2 + 16))
    return 0;
  v5 = 0;
  result = 0;
  v7 = (__int128 *)(a1 + 392);
  do
  {
    v8 = *(_QWORD *)(a2 + 8) + (v5 << 6);
    v10 = *(unsigned __int16 *)(v8 + 56);
    v9 = (unsigned __int16 *)(v8 + 56);
    if (!v10)
      goto LABEL_17;
    v11 = 0;
    v12 = 0;
    v13 = (uint64_t *)(*(_QWORD *)(a2 + 8) + (v5 << 6) + 48);
    do
    {
      v14 = *v13;
      if (*(_WORD *)(*v13 + v11 + 8) == 1)
      {
        v19 = 0;
LABEL_14:
        *(_WORD *)(v14 + v11 + 12) = v19;
        goto LABEL_15;
      }
      if (!*(_WORD *)(*v13 + v11 + 8))
        return result;
      v15 = *(_OWORD *)(a1 + 440);
      v22 = *(_OWORD *)(a1 + 424);
      v23 = v15;
      v24 = *(_OWORD *)(a1 + 456);
      v25 = *(_QWORD *)(a1 + 472);
      v16 = *(_OWORD *)(a1 + 408);
      v20 = *v7;
      v21 = v16;
      result = hlp_disamSpecialWords(a1, (uint64_t *)a2, (unsigned __int16)v5, (unsigned __int16)v12, &v26, (uint64_t)&v20);
      if ((result & 0x80000000) != 0)
        return result;
      if (v26 != 1)
      {
        v17 = *(_OWORD *)(a1 + 440);
        v22 = *(_OWORD *)(a1 + 424);
        v23 = v17;
        v24 = *(_OWORD *)(a1 + 456);
        v25 = *(_QWORD *)(a1 + 472);
        v18 = *(_OWORD *)(a1 + 408);
        v20 = *v7;
        v21 = v18;
        result = hlp_disamCharByChar(a2, (unsigned __int16)v5, (unsigned __int16)v12, &v27, &v26, (uint64_t)&v20);
        if ((result & 0x80000000) != 0)
          return result;
        v19 = v27;
        if (v26 != 1)
          v19 = 0;
        v14 = *v13;
        goto LABEL_14;
      }
LABEL_15:
      ++v12;
      v11 += 16;
    }
    while (v12 < *v9);
    v2 = *(unsigned __int16 *)(a2 + 16);
LABEL_17:
    ++v5;
  }
  while (v5 < v2);
  return result;
}

uint64_t hlp_CallDepesFunc(_QWORD *a1)
{
  int v2;
  unsigned __int16 v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  int v30;
  char *v31;
  const char *v32;
  size_t v33;
  char *v34;
  const char *v35;
  size_t v36;
  size_t v37;
  __int16 v38;
  char *v39;
  unsigned __int16 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 i;
  uint64_t v47;
  int v48;
  unsigned int v50;
  int v51;
  unsigned __int16 v52;
  uint64_t v53;
  char *v54;
  char __s[128];
  uint64_t v56;

  v2 = 0;
  v56 = *MEMORY[0x1E0C80C00];
  v53 = 0;
  v54 = 0;
  v52 = 0;
  *(_BYTE *)a1[19] = 0;
  *(_BYTE *)a1[21] = 0;
  while (1)
  {
    strcpy(__s, "cross_token");
    v3 = strlen(__s);
    v4 = (unsigned __int16)v2;
    if ((_WORD)v2)
    {
      *(_WORD *)(a1[19] + strlen((const char *)a1[19])) = 32;
      *(_WORD *)(a1[21] + strlen((const char *)a1[21])) = 32;
    }
    v5 = a1[13];
    v6 = (unsigned __int16)v2;
    v7 = *(unsigned __int8 *)(v5 + (unsigned __int16)v2);
    if (*(_BYTE *)(v5 + (unsigned __int16)v2))
    {
      v8 = (unsigned __int16)v2;
      while ((v7 > 0x20 || ((1 << v7) & 0x100002600) == 0) && v7 != 95)
      {
        v8 = (unsigned __int16)++v2;
        v7 = *(unsigned __int8 *)(v5 + (unsigned __int16)v2);
        if (!*(_BYTE *)(v5 + (unsigned __int16)v2))
        {
          v51 = 1;
          goto LABEL_12;
        }
      }
      v51 = 0;
LABEL_12:
      v9 = (unsigned __int16)v2;
    }
    else
    {
      v51 = 1;
      v9 = (unsigned __int16)v2;
      v8 = (unsigned __int16)v2;
    }
    *(_BYTE *)(v5 + v8) = 0;
    v10 = Utf8_LengthInUtf8chars(a1[13], v9);
    v11 = Utf8_LengthInUtf8chars(a1[13], v4);
    *(_BYTE *)(a1[14] + v10) = 0;
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L1: %s", v12, v13, v14, (uint64_t)__s);
    v15 = strlen((const char *)(a1[13] + v6));
    v16 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t, _QWORD))(a1[9] + 120))(a1[7], a1[8], 0, a1[13] + v6, v15);
    if ((v16 & 0x80000000) != 0)
      return v16;
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L2: %s", v17, v18, v19, (uint64_t)__s);
    v20 = strlen((const char *)(a1[14] + v11));
    v16 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(a1[9] + 120))(a1[7], a1[8], 1, a1[14] + v11, v20);
    if ((v16 & 0x80000000) != 0)
      return v16;
    if (((*(uint64_t (**)(_QWORD, _QWORD, char *))(a1[9] + 80))(a1[7], a1[8], __s) & 0x80000000) != 0)
    {
      __s[v3] = 0;
      v16 = (*(uint64_t (**)(_QWORD, _QWORD, char *))(a1[9] + 80))(a1[7], a1[8], __s);
      if ((v16 & 0x80000000) != 0)
        return v16;
    }
    v16 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, unsigned __int16 *))(a1[9] + 128))(a1[7], a1[8], 0, &v54, &v52);
    if ((v16 & 0x80000000) != 0)
      return v16;
    v54[v52] = 0;
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s O1: %s", v21, v22, v23, (uint64_t)__s);
    v27 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t *, unsigned __int16 *))(a1[9] + 128))(a1[7], a1[8], 1, &v53, &v52);
    if ((v27 & 0x80000000) != 0)
      return v27;
    *(_BYTE *)(v53 + v52) = 0;
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s O2: %s", v24, v25, v26, (uint64_t)__s);
    v28 = v54;
    if (*v54)
    {
      v29 = 0;
      v30 = 0;
      do
      {
        v31 = &v28[v29];
        if (v28[v29] == 126)
        {
          v32 = &v28[v29 + 1];
          v33 = strlen(v32);
          memmove(v31, v32, v33 + 1);
          --v30;
        }
        else if (!strncmp(&v28[v29], "¡", 2uLL))
        {
          v34 = &v28[(unsigned __int16)v30 + 1];
          v35 = &v28[(unsigned __int16)v30 + 2];
          v36 = strlen(v35);
          memmove(v34, v35, v36 + 1);
          v54[v29] = 126;
        }
        v29 = (unsigned __int16)++v30;
        v28 = v54;
        v37 = strlen(v54);
      }
      while (v37 > (unsigned __int16)v30);
      v38 = v37;
    }
    else
    {
      v38 = 0;
    }
    v39 = (char *)a1[19];
    v40 = v38 + strlen(v39) + 2;
    if (v40 >= 0x81u)
      break;
LABEL_32:
    strcat(v39, v28);
    for (i = 0; ; ++i)
    {
      v47 = i;
      v48 = *(unsigned __int8 *)(v53 + i);
      if (v48 != 32 && v48 != 126)
        break;
    }
    if (!*(_BYTE *)(v53 + i))
      goto LABEL_42;
    while (v48 != 32 && v48 != 126)
      LOBYTE(v48) = *(_BYTE *)(v53 + ++i);
    *(_BYTE *)(v53 + i) = 0;
    if (*(_BYTE *)(v53 + v47))
      strcat((char *)a1[21], (const char *)(v53 + v47));
    else
LABEL_42:
      *(_WORD *)(a1[21] + strlen((const char *)a1[21])) = 42;
    ++v2;
    if (v51)
      return v27;
  }
  v41 = heap_Realloc(*(uint64_t **)(*a1 + 8), (uint64_t)v39, v40);
  if (v41)
  {
    v39 = (char *)v41;
    a1[19] = v41;
    v28 = v54;
    goto LABEL_32;
  }
  log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v42, v43, v44, v45, v50);
  return 2314215434;
}

uint64_t hlp_AppendPhon(uint64_t a1, char *a2, char *__s, uint64_t a4)
{
  const char *v8;
  __int16 v9;
  unsigned __int16 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  int v25;
  __int16 v26;
  int v27;
  int v28;
  int v29;
  signed int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  unsigned int v36;
  int v37;
  unsigned int v39;

  if (strlen(__s) >= 2 && !strchr(__s, 32))
    __s[1] = 0;
  if (strlen((const char *)a4) >= 2 && !strchr((char *)a4, 32))
    *(_BYTE *)(a4 + 1) = 0;
  if (!*a2)
    return 0;
  v8 = *(const char **)(a1 + 152);
  v9 = strlen(v8);
  v10 = v9 + strlen(a2) + 7;
  if (v10 >= 0x81u)
  {
    v11 = v10;
    v12 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), (uint64_t)v8, v10);
    if (!v12
      || (*(_QWORD *)(a1 + 152) = v12,
          (v17 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 168), v11)) == 0))
    {
      v34 = 2314215434;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v39);
      return v34;
    }
    *(_QWORD *)(a1 + 168) = v17;
    v8 = *(const char **)(a1 + 152);
  }
  *(_DWORD *)&v8[strlen(v8)] = 8689634;
  *(_WORD *)(*(_QWORD *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
  v18 = strstr(a2, "◄");
  if (strchr(__s, 32) || !v18)
  {
    strcat(*(char **)(a1 + 152), a2);
    strcat(*(char **)(a1 + 168), (const char *)a4);
    v35 = strlen(a2);
    v36 = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)a2, v35);
    if (v36 > (unsigned __int16)strlen((const char *)a4))
    {
      v37 = 0;
      do
      {
        *(_WORD *)(*(_QWORD *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 126;
        ++v37;
      }
      while ((int)(v36 - (unsigned __int16)strlen((const char *)a4)) > (unsigned __int16)v37);
    }
  }
  else
  {
    v19 = strstr(v18 + 3, "◄");
    if (!v19)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v20, v21, v22, v23, v39);
      return 2314215431;
    }
    v24 = v19;
    strncat(*(char **)(a1 + 152), a2, (unsigned __int16)((_WORD)v18 - (_WORD)a2 + 3));
    if ((unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)a2, (int)v18 - (int)a2 + 3))
    {
      v25 = 0;
      do
      {
        *(_WORD *)(*(_QWORD *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
        ++v25;
      }
      while ((unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)a2, (int)v18 - (int)a2 + 3) > (unsigned __int16)v25);
    }
    strncat(*(char **)(a1 + 152), v18 + 3, (unsigned __int16)((_WORD)v24 - (_WORD)v18 - 3));
    strcat(*(char **)(a1 + 168), (const char *)a4);
    v26 = Utf8_LengthInUtf8chars((unint64_t)v18, (int)v24 - (int)v18);
    if (~(__int16)strlen((const char *)a4) + v26 >= 1)
    {
      v27 = 0;
      do
      {
        *(_WORD *)(*(_QWORD *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 126;
        ++v27;
      }
      while (v26 + ~(__int16)strlen((const char *)a4) > (__int16)v27);
    }
    strcat(*(char **)(a1 + 152), v24);
    v28 = (_DWORD)v24 - (_DWORD)a2;
    v29 = strlen(a2);
    v30 = Utf8_LengthInUtf8chars((unint64_t)a2, v29) << 16;
    if (v30 > (int)(Utf8_LengthInUtf8chars((unint64_t)a2, v28) << 16))
    {
      v31 = 0;
      do
      {
        *(_WORD *)(*(_QWORD *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
        ++v31;
        v32 = strlen(a2);
        v33 = (__int16)Utf8_LengthInUtf8chars((unint64_t)a2, v32);
      }
      while (v33 - (__int16)Utf8_LengthInUtf8chars((unint64_t)a2, v28) > (__int16)v31);
    }
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 152) + strlen(*(const char **)(a1 + 152))) = 8689634;
  v34 = 0;
  *(_WORD *)(*(_QWORD *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
  return v34;
}

uint64_t hlp_ProcessNTokens(_QWORD *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t appended;
  unsigned __int16 v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  _BOOL4 v29;
  int v30;
  size_t v32;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;

  *(_BYTE *)a1[19] = 0;
  *(_BYTE *)a1[21] = 0;
  v5 = *(unsigned __int16 *)(a2 + 16);
  if (*(_WORD *)(a2 + 16))
  {
    v8 = 0;
    v36 = a4;
    while (1)
    {
      v9 = *(_QWORD *)(a2 + 8);
      v10 = v9 + (v8 << 6);
      if (*(unsigned __int16 *)(v10 + 8) >= a3 && *(unsigned __int16 *)(v10 + 10) <= a4)
      {
        v11 = v9 + (v8 << 6);
        v12 = (unsigned __int16 *)(v11 + 56);
        if (*(_WORD *)(v11 + 56))
          break;
      }
LABEL_10:
      if (++v8 >= (unint64_t)v5)
        goto LABEL_11;
    }
    v13 = 0;
    v14 = 0;
    v15 = (_QWORD *)(v11 + 48);
    while (1)
    {
      v16 = *(_QWORD *)(*v15 + v13) + 56 * *(unsigned __int16 *)(*v15 + v13 + 12);
      strcpy((char *)a1[22], *(const char **)(v16 + 32));
      appended = hlp_AppendPhon((uint64_t)a1, *(char **)v16, *(char **)(v16 + 16), *(_QWORD *)(v16 + 24));
      if ((appended & 0x80000000) != 0)
        return appended;
      ++v14;
      v13 += 16;
      if (v14 >= *v12)
      {
        v5 = *(unsigned __int16 *)(a2 + 16);
        a4 = v36;
        goto LABEL_10;
      }
    }
  }
LABEL_11:
  v18 = (2 * strlen((const char *)a1[19])) | 1;
  v19 = (char *)a1[13];
  if (!v19 || *((unsigned __int16 *)a1 + 60) < v18)
  {
    v20 = heap_Realloc(*(uint64_t **)(*a1 + 8), a1[13], v18);
    if (!v20)
      goto LABEL_31;
    v19 = (char *)v20;
    a1[13] = v20;
    a1[15] = v18;
  }
  v25 = a1[14];
  if (v25 && *((unsigned __int16 *)a1 + 64) >= v18)
    goto LABEL_19;
  v26 = heap_Realloc(*(uint64_t **)(*a1 + 8), v25, v18);
  if (!v26)
  {
LABEL_31:
    v34 = 2314215434;
    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v21, v22, v23, v24, v35);
    return v34;
  }
  a1[14] = v26;
  a1[16] = v18;
  v19 = (char *)a1[13];
LABEL_19:
  strcpy(v19, (const char *)a1[19]);
  strcpy((char *)a1[14], (const char *)a1[21]);
  v27 = (const char *)a1[13];
  if (*v27)
  {
    v28 = 0;
    v29 = 0;
    v30 = 0;
    do
    {
      if (!strncmp(&v27[v28], "◄", 3uLL))
      {
        v29 = !v29;
      }
      else if (v27[v28] == 126 && v29)
      {
        v32 = strlen(&v27[v28]);
        memmove((void *)&v27[v28 + 1], &v27[v28], v32 + 1);
        *(_WORD *)(a1[13] + v28) = -24126;
        v27 = (const char *)a1[13];
        v29 = 1;
      }
      v28 = (unsigned __int16)++v30;
    }
    while (strlen(v27) > (unsigned __int16)v30);
  }
  return hlp_CallDepesFunc(a1);
}

uint64_t stat_hmogrph_updateLingdb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t updated;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  __int16 v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t (*v29)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, char *);
  uint64_t v30;
  const char *v31;
  __int16 v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int16 v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _WORD *v43;
  uint64_t v44;
  unsigned __int16 v45;
  unsigned __int16 *v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  char *v50;
  uint64_t v51;
  unint64_t i;
  uint64_t *v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  char *v59;
  unint64_t v60;
  BOOL v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v71;
  __int16 v72;
  uint64_t v73;
  unsigned __int16 v74;
  unsigned __int16 v75;
  __int16 v76;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int16 v82;
  int v83;
  uint64_t v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  unsigned __int16 v93;
  uint64_t v94;
  int v95;
  unsigned int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  unsigned __int16 v101;
  __int16 v102;
  char *__src;
  __int16 v104;
  int v105;
  char *__s[2];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  _WORD v122[36];
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  v101 = 0;
  v99 = 0;
  v100 = 0;
  v97 = 0;
  v98 = 0;
  v95 = 0;
  v96 = 0;
  v94 = 0;
  memset(v122, 0, 64);
  v93 = 0;
  v120 = 0u;
  v121 = 0u;
  v118 = 0u;
  v119 = 0u;
  v116 = 0u;
  v117 = 0u;
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  v113 = 0u;
  v111 = 0u;
  v109 = 0u;
  v110 = 0u;
  v107 = 0u;
  v108 = 0u;
  *(_OWORD *)__s = 0u;
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a2 + 104))(a3, a4, 1, 0, &v101);
  if ((v12 & 0x80000000) != 0)
    return v12;
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, int *))(a2 + 184))(a3, a4, v101, 0, &v97);
  if ((v13 & 0x80000000) == 0)
  {
    v92 = a6;
    if ((unsigned __int16)v97 == 1)
    {
      v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t *, int *))(a2 + 176))(a3, a4, v101, 0, &v94, &v98);
      if ((v13 & 0x80000000) == 0 && (unsigned __int16)v98 >= 2u)
      {
        updated = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a2 + 104))(a3, a4, 2, v101, (char *)&v100 + 2);
        if ((updated & 0x80000000) != 0)
          goto LABEL_123;
        v15 = 0;
        v16 = 0;
        v17 = 0;
        v91 = a5;
        while (1)
        {
          if (!HIWORD(v100))
          {
            if (v122[0])
            {
              if (v96 == 4 && v15 == 0)
              {
                v71 = v93;
                if (v93)
                {
                  if (v93 != 1)
                  {
                    v81 = a1;
                    v73 = 0;
                    v74 = 0;
                    v75 = 10000;
                    while (1)
                    {
                      updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v122[v73], 7, 1, (char *)&v98 + 2, &v98);
                      if ((updated & 0x80000000) != 0)
                        goto LABEL_123;
                      if (HIWORD(v98) < v75)
                      {
                        v75 = HIWORD(v98);
                        v74 = v73;
                      }
                      if (v71 == ++v73)
                      {
                        v76 = strlen(__s[v74]);
                        updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, char *))(a2 + 160))(a3, a4, (unsigned __int16)v122[v74], 3, (unsigned __int16)(v76 + 1), __s[v74], (char *)&v97 + 2);
                        a1 = v81;
                        if ((updated & 0x80000000) != 0)
                          goto LABEL_123;
                        goto LABEL_117;
                      }
                    }
                  }
                  v72 = strlen(__s[0]);
                  updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, char *))(a2 + 160))(a3, a4, v122[0], 3, (unsigned __int16)(v72 + 1), __s[0], (char *)&v97 + 2);
                  if ((updated & 0x80000000) != 0)
                  {
LABEL_123:
                    v13 = updated;
                    goto LABEL_124;
                  }
                }
              }
LABEL_117:
              hlp_freeWordPhoneList((_QWORD *)a5, &v93, (uint64_t)v122, (uint64_t)__s);
            }
            if (!*(_DWORD *)(a1 + 144)
              || (updated = hlp_updateLingdb_process_skipcrosstoekn_cleanup(a1, a2, a3, a4, v101),
                  (updated & 0x80000000) == 0))
            {
              updated = hlp_updateLingdb_delete_duplicated_words(*(_QWORD *)a1, a2, a3, a4, a5, v101, *(_DWORD *)(a1 + 384), v92);
              if ((updated & 0x80000000) == 0)
              {
                v13 = stat_hmogrph_selectSubOrWholeRcd(a1, a2, a3, a4, (uint64_t *)a5);
                if ((v13 & 0x80000000) != 0)
                  return v13;
                goto LABEL_124;
              }
            }
            goto LABEL_123;
          }
          updated = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a3, a4);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
          updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, HIWORD(v100), 1, 1, (char *)&v99 + 2, &v98);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
          updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(a2 + 168))(a3, a4, HIWORD(v100), 2, 1, &v99, &v98);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
          if (HIWORD(v99) > (unsigned __int16)v99)
          {
            v13 = 2314223281;
LABEL_124:
            hlp_freeWordPhoneList((_QWORD *)a5, &v93, (uint64_t)v122, (uint64_t)__s);
            return v13;
          }
          if (HIWORD(v99) == (unsigned __int16)v16 && (unsigned __int16)v99 == (unsigned __int16)v17)
          {
            v18 = v96;
            if (v96 == 4)
              break;
          }
          updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(*(_QWORD *)(a1 + 48) + 136))(a3, a4, HIWORD(v100), &v100);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
          if ((_WORD)v100)
          {
            updated = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 48) + 168))(a3, a4);
            if ((updated & 0x80000000) != 0)
              goto LABEL_123;
          }
          if (v95 == 4 && !v15)
          {
            v19 = v93;
            if (v93)
            {
              v85 = v16;
              v20 = a1;
              if (v93 == 1)
              {
                v21 = strlen(__s[0]);
                updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, char *))(a2 + 160))(a3, a4, v122[0], 3, (unsigned __int16)(v21 + 1), __s[0], (char *)&v97 + 2);
              }
              else
              {
                v88 = v17;
                v22 = 0;
                v23 = 0;
                v24 = 10000;
                do
                {
                  updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v122[v22], 7, 1, (char *)&v98 + 2, &v98);
                  if ((updated & 0x80000000) != 0)
                    goto LABEL_123;
                  if (HIWORD(v98) < v24)
                  {
                    v24 = HIWORD(v98);
                    v23 = v22;
                  }
                  ++v22;
                }
                while (v19 != v22);
                v25 = strlen(__s[v23]);
                updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, char *))(a2 + 160))(a3, a4, (unsigned __int16)v122[v23], 3, (unsigned __int16)(v25 + 1), __s[v23], (char *)&v97 + 2);
                v16 = v85;
                v17 = v88;
              }
              a1 = v20;
              v15 = 0;
              if ((updated & 0x80000000) != 0)
                goto LABEL_123;
            }
          }
          hlp_freeWordPhoneList((_QWORD *)a5, &v93, (uint64_t)v122, (uint64_t)__s);
          v18 = v96;
          if (v96 <= 0xA && ((1 << v96) & 0x610) != 0)
            break;
LABEL_63:
          updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 120))(a3, a4, HIWORD(v100), (char *)&v100 + 2);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
        }
        if (HIWORD(v99) != (unsigned __int16)v16 || (unsigned __int16)v99 != (unsigned __int16)v17)
        {
          v15 = 0;
          v16 = HIWORD(v99);
          v17 = (unsigned __int16)v99;
        }
        if (v18 == 9)
        {
          updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(*(_QWORD *)(a1 + 48) + 136))(a3, a4, HIWORD(v100), &v100);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
          if ((_WORD)v100)
          {
            updated = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 48) + 168))(a3, a4);
            if ((updated & 0x80000000) != 0)
              goto LABEL_123;
          }
        }
        if (*(_DWORD *)(a1 + 144) && v96 == 9 && v95 == 17)
        {
          updated = hlp_ProcessNTokens((_QWORD *)a1, a5, HIWORD(v99), (unsigned __int16)v99);
          if ((updated & 0x80000000) != 0)
            goto LABEL_123;
          v26 = strlen(*(const char **)(a1 + 152));
          v27 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 48) + 160))(a3, a4, HIWORD(v100), 3, (unsigned __int16)(v26 + 1), *(_QWORD *)(a1 + 152), (char *)&v97 + 2);
          if ((v27 & 0x80000000) == 0)
          {
            v28 = strlen(*(const char **)(a1 + 168));
            v27 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, char *))(*(_QWORD *)(a1 + 48) + 160))(a3, a4, HIWORD(v100), 6, (unsigned __int16)(v28 + 1), *(_QWORD *)(a1 + 168), (char *)&v97 + 2);
            if ((v27 & 0x80000000) == 0)
            {
              HIWORD(v98) = 4;
              v27 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, char *))(*(_QWORD *)(a1 + 48) + 160))(a3, a4, HIWORD(v100), 7, 1, (char *)&v98 + 2, (char *)&v97 + 2);
              if ((v27 & 0x80000000) == 0)
              {
                v29 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, char *))(*(_QWORD *)(a1 + 48) + 160);
                v30 = a1;
                v31 = *(const char **)(a1 + 176);
                v32 = strlen(v31);
                v33 = v31;
                a1 = v30;
                updated = v29(a3, a4, HIWORD(v100), 9, (unsigned __int16)(v32 + 1), v33, (char *)&v97 + 2);
                a5 = v91;
                if ((updated & 0x80000000) != 0)
                  goto LABEL_123;
                goto LABEL_63;
              }
            }
          }
          v13 = v27;
          a5 = v91;
          goto LABEL_124;
        }
        v83 = (unsigned __int16)v99;
        v84 = HIWORD(v99);
        v34 = v93;
        v105 = 0;
        v104 = 0;
        __src = 0;
        v102 = 0;
        v90 = HIWORD(v100);
        v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 184))(a3, a4);
        if ((v13 & 0x80000000) == 0 && v102)
        {
          v89 = v17;
          v35 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, int *))(a2 + 176))(a3, a4, v90, 3, &__src, &v105);
          if ((v35 & 0x80000000) != 0)
          {
            v13 = v35;
            goto LABEL_124;
          }
          v102 = 0;
          v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, __int16 *))(a2 + 184))(a3, a4, v90, 7, &v102);
          if ((v13 & 0x80000000) == 0)
          {
            if (v102)
            {
              v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, v90, 7, 1, (char *)&v105 + 2, &v105);
              if ((v13 & 0x80000000) != 0)
                goto LABEL_124;
              v36 = strlen(__src);
              v37 = (char *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a5 + 8), 1, v36 + 1);
              __s[v34] = v37;
              if (!v37)
              {
LABEL_126:
                v13 = 2314215434;
                log_OutPublic(*(_QWORD *)(*(_QWORD *)a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v38, v39, v40, v41, v78);
                goto LABEL_124;
              }
              strcpy(v37, __src);
              v42 = *(unsigned __int16 *)(a5 + 16);
              if (!*(_WORD *)(a5 + 16))
                goto LABEL_62;
              v87 = v15;
              v80 = a1;
              v43 = (_WORD *)(*(_QWORD *)(a5 + 8) + 56);
              while ((unsigned __int16)*(v43 - 24) != (_DWORD)v84 || (unsigned __int16)*(v43 - 23) != v83)
              {
                v43 += 32;
                if (!--v42)
                {
                  a1 = v80;
                  goto LABEL_61;
                }
              }
              v79 = v34;
              v86 = v16;
              v44 = (unsigned __int16)*v43;
              if (*v43)
              {
                v45 = 0;
                v46 = (unsigned __int16 *)(*((_QWORD *)v43 - 1) + 12);
                do
                {
                  v47 = *v46;
                  v48 = *(v46 - 2);
                  if (v48 <= v47)
                    LOWORD(v47) = v48 - 1;
                  v49 = strlen(*(const char **)(*(_QWORD *)(v46 - 6) + 56 * (unsigned __int16)v47));
                  if (v49)
                    v45 += v49 + 1;
                  v46 += 8;
                  --v44;
                }
                while (v44);
              }
              else
              {
                v45 = 0;
              }
              v50 = (char *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a5 + 8), 1, v45 + 1);
              if (!v50)
                goto LABEL_126;
              v82 = v45;
              *v50 = 0;
              if (*v43)
              {
                v51 = 0;
                for (i = 0; i < v60; ++i)
                {
                  v53 = (uint64_t *)(*((_QWORD *)v43 - 1) + v51);
                  v54 = *((unsigned __int16 *)v53 + 6);
                  v55 = *((unsigned __int16 *)v53 + 4);
                  if (v55 <= v54)
                    LOWORD(v54) = v55 - 1;
                  v56 = *v53;
                  v57 = 56 * (unsigned __int16)v54;
                  v58 = v50;
                  strcat(v50, *(const char **)(*v53 + v57));
                  v59 = *(char **)(v56 + v57);
                  v60 = (unsigned __int16)*v43;
                  if (*v59)
                    v61 = (_DWORD)i == (_DWORD)v60 - 1;
                  else
                    v61 = 1;
                  if (!v61)
                  {
                    if (!strstr(v59, "{SEP"))
                    {
                      *(_WORD *)&v58[strlen(v58)] = 46;
                      v50 = (char *)v58;
                      v60 = (unsigned __int16)*v43;
                      goto LABEL_87;
                    }
                    --v82;
                  }
                  v50 = (char *)v58;
LABEL_87:
                  v51 += 16;
                }
              }
              if (v82 >= 2u)
                v50[v82 - 1] = 0;
              v62 = (uint64_t)v50;
              v16 = v86;
              v15 = v87;
              a5 = v91;
              v17 = v89;
              if (strcmp(v50, __src) | v87)
              {
                v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, const char *, __int16 *))(a2 + 160))(a3, a4, v90, 3, 8, "DELETED", &v104);
                v69 = *(_QWORD *)v91;
                if ((v13 & 0x80000000) != 0)
                {
                  heap_Free(*(_QWORD **)(v69 + 8), v62);
                  goto LABEL_124;
                }
                log_OutText(*(_QWORD *)(v69 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"DELETED: from %d to %d, orth %s with phon %s and priority %d", v66, v67, v68, v84);
              }
              else
              {
                log_OutText(*(_QWORD *)(*(_QWORD *)v91 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"from %d to %d, orth %s, disambiguated phon %s, priority %d", v63, v64, v65, v84);
                v15 = 1;
              }
              heap_Free(*(_QWORD **)(*(_QWORD *)v91 + 8), v62);
              v34 = v79;
              a1 = v80;
            }
          }
        }
LABEL_61:
        if ((v13 & 0x80000000) != 0)
          goto LABEL_124;
LABEL_62:
        v122[v34] = HIWORD(v100);
        v93 = v34 + 1;
        goto LABEL_63;
      }
    }
  }
  return v13;
}

_QWORD *hlp_freeWordPhoneList(_QWORD *result, _WORD *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t i;
  uint64_t v9;

  v7 = result;
  for (i = 0; i != 32; ++i)
  {
    if (*(_WORD *)(a3 + 2 * i))
      *(_WORD *)(a3 + 2 * i) = 0;
    v9 = *(_QWORD *)(a4 + 8 * i);
    if (v9)
    {
      result = heap_Free(*(_QWORD **)(*v7 + 8), v9);
      *(_QWORD *)(a4 + 8 * i) = 0;
    }
  }
  *a2 = 0;
  return result;
}

uint64_t hlp_updateLingdb_process_skipcrosstoekn_cleanup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  unsigned __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;

  v15 = 0;
  v16 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a2 + 104))(a3, a4, 2, a5, (char *)&v16 + 2);
  if ((result & 0x80000000) == 0)
  {
    v11 = HIWORD(v16);
    if (HIWORD(v16))
    {
      v12 = 0;
      do
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, int *))(a2 + 168))(a3, a4, v11, 0, 1, &v15, &v16);
        if ((result & 0x80000000) != 0)
          break;
        if (v15 == 17)
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 48) + 192))(a3, a4, HIWORD(v16));
          if ((result & 0x80000000) != 0)
            return result;
          HIWORD(v16) = v12;
          v13 = v12;
        }
        else
        {
          v13 = HIWORD(v16);
        }
        v14 = *(_QWORD *)(a1 + 48);
        if ((_WORD)v13)
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(v14 + 120))(a3, a4, (unsigned __int16)v13, (char *)&v16 + 2);
          v12 = v13;
          if ((result & 0x80000000) != 0)
            return result;
        }
        else
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(v14 + 104))(a3, a4, 2, a5, (char *)&v16 + 2);
          if ((result & 0x80000000) != 0)
            return result;
        }
        v11 = HIWORD(v16);
      }
      while (HIWORD(v16));
    }
  }
  return result;
}

uint64_t hlp_updateLingdb_delete_duplicated_words(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  uint64_t updated;
  unsigned __int16 v15;
  unsigned __int16 v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v24;
  __int16 v25;
  int v26;
  int v27;
  char *__s1;

  __s1 = 0;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  v24 = 0;
  updated = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a2 + 104))(a3, a4, 2, a6, (char *)&v26 + 2);
  if ((updated & 0x80000000) == 0)
  {
    v15 = HIWORD(v26);
    if (HIWORD(v26))
    {
      v16 = 0;
      do
      {
        updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(a2 + 120))(a3, a4, v15, &v26);
        if ((updated & 0x80000000) != 0)
          break;
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, __int16 *))(a2 + 168))(a3, a4, HIWORD(v26), 0, 1, &v24, &v25);
        if (v24 <= 0xA && ((1 << v24) & 0x610) != 0)
        {
          v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(a2 + 168))(a3, a4, HIWORD(v26), 1, 1, (char *)&v27 + 2, &v25);
          if ((v18 & 0x80000000) != 0)
            return v18;
          v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(a2 + 168))(a3, a4, HIWORD(v26), 2, 1, &v27, &v25);
          if ((v18 & 0x80000000) != 0)
            return v18;
          updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, __int16 *))(a2 + 176))(a3, a4, HIWORD(v26), 3, &__s1, &v25);
          if ((updated & 0x80000000) != 0)
            return updated;
          if (!strcmp(__s1, "DELETED"))
          {
            updated = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a2 + 192))(a3, a4, HIWORD(v26));
            if ((updated & 0x80000000) != 0)
              return updated;
            log_OutText(*(_QWORD *)(*(_QWORD *)a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"delete a word record from pos %d to pos %d", v19, v20, v21, HIWORD(v27));
          }
          else if (a7)
          {
            updated = updateNLUNE(a1, a3, a4, a2, HIWORD(v26), v16, a8);
            if ((updated & 0x80000000) != 0)
              return updated;
            ++v16;
          }
        }
        v15 = v26;
        HIWORD(v26) = v26;
      }
      while ((_WORD)v26);
    }
  }
  return updated;
}

uint64_t stat_hmogrph_selectSubOrWholeRcd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t *v7;
  uint64_t v8;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  int isSubWordRec;
  unsigned __int16 *v15;
  unsigned int v16;
  int v17;
  int hasSubWordWithGivenTn;
  uint64_t v19;
  uint64_t v20;
  unsigned __int16 v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  char *v47;
  size_t v48;
  __int16 v49;
  uint64_t v50;
  unsigned __int16 v51;
  __int16 v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  _WORD *v60;
  __int16 v61;
  unsigned int v62;
  _WORD *v63;
  uint64_t v64;
  char *v65;
  unsigned int v66;
  unsigned int v68;
  uint64_t v69;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  char *__s;
  unsigned __int16 v82;

  v5 = 0;
  v76 = 0;
  if (a2 && a5)
  {
    v77 = 0;
    v74 = 0;
    v75 = 0;
    v7 = a5 + 1;
    if (*((_WORD *)a5 + 8))
    {
      v8 = 0;
      for (i = 0; i < *((unsigned __int16 *)a5 + 8); ++i)
      {
        v10 = *v7;
        v11 = *v7 + v8;
        v12 = *(char **)(v11 + 24);
        if (!*v12)
        {
          if (stat_hmogrph_isSubWordRec((uint64_t)(a5 + 1), (unsigned __int16)i))
            *(_DWORD *)(v11 + 32) = 1;
          else
            *(_DWORD *)(v11 + 32) = 0;
          goto LABEL_22;
        }
        v13 = strcmp(*(const char **)(v11 + 24), "poi");
        isSubWordRec = stat_hmogrph_isSubWordRec((uint64_t)(a5 + 1), (unsigned __int16)i);
        if (v13)
        {
          if (!isSubWordRec)
          {
            if (hlp_hasRcdWithGivenPOIClass(v11, v12))
              goto LABEL_15;
            if (stat_hmogrph_hasSubWordWithGivenTn((uint64_t)(a5 + 1), (unsigned __int16)i, v12))
            {
              *(_DWORD *)(v10 + v8 + 32) = 1;
              v15 = (unsigned __int16 *)(a5 + 1);
              v16 = (unsigned __int16)i;
              goto LABEL_20;
            }
LABEL_14:
            if (hlp_hasRcdWithGivenPOIClass(v11, "poi"))
            {
LABEL_15:
              *(_DWORD *)(v10 + v8 + 32) = 0;
              v16 = (unsigned __int16)i;
              v15 = (unsigned __int16 *)(a5 + 1);
              goto LABEL_16;
            }
            hasSubWordWithGivenTn = stat_hmogrph_hasSubWordWithGivenTn((uint64_t)(a5 + 1), (unsigned __int16)i, "poi");
            v19 = v10 + v8;
            if (hasSubWordWithGivenTn)
            {
              *(_DWORD *)(v19 + 32) = 1;
              v15 = (unsigned __int16 *)(a5 + 1);
              v16 = (unsigned __int16)i;
LABEL_20:
              v17 = 0;
            }
            else
            {
              *(_DWORD *)(v19 + 32) = 0;
              v15 = (unsigned __int16 *)(a5 + 1);
              v16 = (unsigned __int16)i;
LABEL_16:
              v17 = 1;
            }
            stat_hmogrph_setWillBeDeleteOfSubWords(v15, v16, v17);
          }
        }
        else if (!isSubWordRec)
        {
          goto LABEL_14;
        }
LABEL_22:
        v8 += 64;
      }
    }
    v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a2 + 104))(a3, a4, 1, 0, (char *)&v75 + 2);
    if ((v20 & 0x80000000) != 0)
    {
      return v20;
    }
    else
    {
      v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(a2 + 104))(a3, a4, 2, HIWORD(v75), &v75);
      if ((v5 & 0x80000000) == 0)
      {
        v21 = v75;
        if ((_WORD)v75)
        {
          do
          {
            v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 120))(a3, a4, v21, (char *)&v74 + 2);
            if ((v20 & 0x80000000) != 0)
              return v20;
            v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v75, 0, 1, &v77, &v74);
            if ((v5 & 0x80000000) != 0)
              return v5;
            if (v77 == 4
              || (v77 == 9 ? (v22 = *(_DWORD *)(a1 + 144) == 0) : (v22 = 0),
                  !v22 ? (v23 = 0) : (v23 = 1),
                  v77 == 10 || v23))
            {
              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v75, 1, 1, (char *)&v76 + 2, &v74);
              if ((v20 & 0x80000000) != 0)
                return v20;
              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v75, 2, 1, &v76, &v74);
              if ((v20 & 0x80000000) != 0)
                return v20;
              if (!*((_WORD *)a5 + 8))
              {
LABEL_106:
                v5 = 2314215424;
                log_OutText(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"cant find lingdb word : no word found with pos=%d,%d", v24, v25, v26, HIWORD(v76));
                return v5;
              }
              v27 = 0;
              v28 = *v7;
              v29 = 32;
              while (__PAIR64__(*(unsigned __int16 *)(v28 + v29 - 22), *(unsigned __int16 *)(v28 + v29 - 24)) != __PAIR64__((unsigned __int16)v76, HIWORD(v76)))
              {
                ++v27;
                v29 += 64;
                if (*((unsigned __int16 *)a5 + 8) == v27)
                  goto LABEL_106;
              }
              if (*(_DWORD *)(v28 + v29) != 1)
                goto LABEL_102;
              v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a2 + 192))(a3, a4, (unsigned __int16)v75);
              if ((v5 & 0x80000000) != 0)
                return v5;
              log_OutText(*(_QWORD *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Due to POI priority, delete a word record from pos %d to pos %d", v30, v31, v32, HIWORD(v76));
              v33 = a5[1];
              if (*(_DWORD *)(v33 + v29) != 1
                || stat_hmogrph_isSubWordRec((uint64_t)(a5 + 1), (unsigned __int16)v27))
              {
                goto LABEL_103;
              }
              if (*((_WORD *)a5 + 8))
              {
                v34 = 0;
                v5 = 0;
                v35 = v33 + v29;
                v36 = a2;
                v69 = v35;
                do
                {
                  if (v27 != v34)
                  {
                    v37 = *v7 + (v34 << 6);
                    if (*(unsigned __int16 *)(v35 - 24) <= *(unsigned __int16 *)(v37 + 8))
                    {
                      v38 = *(unsigned __int16 *)(v37 + 10);
                      if (*(unsigned __int16 *)(v35 - 22) > v38)
                      {
                        v39 = *a5;
                        v82 = 0;
                        v80 = 0;
                        __s = 0;
                        HIWORD(v79) = 0;
                        v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(v36 + 104))(a3, a4, 1, 0, &v82);
                        if ((v20 & 0x80000000) != 0)
                          return v20;
                        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char *))(v36 + 184))(a3, a4, v82, 0, (char *)&v80 + 2);
                        if ((v5 & 0x80000000) != 0
                          || HIWORD(v80) != 1
                          || (v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char **, int *))(v36 + 176))(a3, a4, v82, 0, &__s, &v80), (v5 & 0x80000000) != 0)|| (unsigned __int16)v80 < 2u)
                        {
                          if ((v5 & 0x80000000) != 0)
                            return v5;
                        }
                        else
                        {
                          v40 = strlen(__s);
                          v41 = (char *)heap_Calloc(*(_QWORD **)(v39 + 8), 1, v40 + 2);
                          if (!v41)
                          {
                            log_OutPublic(*(_QWORD *)(v39 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v42, v43, v44, v45, v68);
                            return 2314215434;
                          }
                          v46 = v41;
                          v47 = &strcpy(v41, __s)[v38];
                          v48 = strlen(v47);
                          memmove(v47 + 1, v47, v48 + 1);
                          *v47 = 32;
                          v49 = strlen(v46);
                          v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, const char *, char *))(a2 + 160))(a3, a4, v82, 0, (unsigned __int16)(v49 + 1), v46, (char *)&v79 + 2);
                          if ((v20 & 0x80000000) != 0)
                            return v20;
                          heap_Free(*(_QWORD **)(v39 + 8), (uint64_t)v46);
                        }
                        v80 = 0;
                        LODWORD(__s) = 0;
                        v82 = 0;
                        v78 = 0;
                        v79 = 0;
                        v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(a2 + 104))(a3, a4, 1, 0, &v80);
                        if ((v20 & 0x80000000) != 0)
                          return v20;
                        v50 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a2 + 104))(a3, a4, 2, (unsigned __int16)v80, (char *)&v79 + 2);
                        v5 = v50;
                        if ((v50 & 0x80000000) == 0)
                        {
                          v51 = HIWORD(v79);
                          if (HIWORD(v79))
                          {
                            while (1)
                            {
                              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(a2 + 120))(a3, a4, v51, &v79);
                              if ((v20 & 0x80000000) != 0)
                                return v20;
                              (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, char **, char *))(a2 + 168))(a3, a4, HIWORD(v79), 0, 1, &__s, (char *)&v78 + 2);
                              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(a2 + 168))(a3, a4, HIWORD(v79), 1, 1, &v82, (char *)&v78 + 2);
                              if ((v20 & 0x80000000) != 0)
                                return v20;
                              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, char *))(a2 + 168))(a3, a4, HIWORD(v79), 2, 1, (char *)&v80 + 2, (char *)&v78 + 2);
                              if ((v20 & 0x80000000) != 0)
                                return v20;
                              if (v82 >= v38)
                              {
                                ++v82;
                                v52 = HIWORD(v80);
                              }
                              else
                              {
                                v52 = HIWORD(v80);
                                if (HIWORD(v80) <= v38)
                                  goto LABEL_75;
                              }
                              HIWORD(v80) = v52 + 1;
LABEL_75:
                              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(a2 + 160))(a3, a4, HIWORD(v79), 1, 1, &v82, &v78);
                              if ((v20 & 0x80000000) != 0)
                                return v20;
                              v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(a2 + 160))(a3, a4, HIWORD(v79), 2, 1, (char *)&v80 + 2, &v78);
                              if ((v20 & 0x80000000) != 0)
                                return v20;
                              v51 = v79;
                              HIWORD(v79) = v79;
                              if (!(_WORD)v79)
                                goto LABEL_80;
                            }
                          }
                        }
                        if ((v50 & 0x80000000) != 0)
                          return v5;
LABEL_80:
                        v36 = a2;
                        if (*((_WORD *)a5 + 8))
                        {
                          v53 = 0;
                          v54 = 0;
                          v55 = (unint64_t)*((unsigned __int16 *)a5 + 8) << 6;
                          v56 = v27;
                          do
                          {
                            if (v56)
                            {
                              v57 = *v7;
                              v58 = *v7 + v53;
                              v59 = *(unsigned __int16 *)(v58 + 8);
                              if (v59 >= v38)
                              {
                                *(_WORD *)(v58 + 8) = v59 + 1;
                                v63 = (_WORD *)(v57 + (v54 << 6) + 10);
                                v61 = *(_WORD *)(v58 + 10);
                                goto LABEL_87;
                              }
                              v62 = *(unsigned __int16 *)(v58 + 10);
                              v60 = (_WORD *)(v58 + 10);
                              v61 = v62;
                              if (v62 > v38)
                              {
                                v63 = v60;
LABEL_87:
                                *v63 = v61 + 1;
                              }
                            }
                            ++v54;
                            --v56;
                            v53 += 64;
                          }
                          while (v55 != v53);
                        }
                        v82 = 0;
                        __s = 0;
                        HIWORD(v80) = 0;
                        v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a2 + 104))(a3, a4, 1, 0, (char *)&v80 + 2);
                        if ((v20 & 0x80000000) != 0)
                          return v20;
                        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, unsigned __int16 *))(a2 + 176))(a3, a4, HIWORD(v80), 1, &__s, &v82);
                        if ((v5 & 0x80000000) != 0)
                          return v5;
                        v64 = v82;
                        if (v82)
                        {
                          v65 = __s + 16;
                          do
                          {
                            v66 = *((_DWORD *)v65 - 1);
                            if (v66 >= v38)
                            {
                              *((_DWORD *)v65 - 1) = v66 + 1;
                            }
                            else if (*(_DWORD *)v65 + v66 > v38)
                            {
                              ++*(_DWORD *)v65;
                            }
                            v65 += 32;
                            --v64;
                          }
                          while (v64);
                        }
                        v35 = v69;
                      }
                    }
                  }
                  ++v34;
                }
                while (v34 < *((unsigned __int16 *)a5 + 8));
                if ((v5 & 0x80000000) != 0)
                  return v5;
              }
              else
              {
LABEL_102:
                v5 = 0;
              }
            }
LABEL_103:
            v21 = HIWORD(v74);
            LOWORD(v75) = HIWORD(v74);
          }
          while (HIWORD(v74));
        }
      }
    }
  }
  return v5;
}

uint64_t stat_hmogrph_getIOBTNToken(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, char *a8)
{
  uint64_t i;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  char *v20;
  uint64_t v22;
  int v23;
  int v24;
  int v25;

  v24 = 0;
  v25 = 0;
  v23 = 0;
  v22 = 0;
  for (i = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a2 + 104))(a3, a4, 2, a5, (char *)&v25 + 2);
        ;
        i = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 120))(a3, a4, HIWORD(v25), (char *)&v25 + 2))
  {
    v16 = i;
    if ((i & 0x80000000) != 0)
      break;
    if (!HIWORD(v25))
      goto LABEL_19;
    v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, int *))(a2 + 168))(a3, a4, HIWORD(v25), 0, 1, &v23, &v25);
    if ((v17 & 0x80000000) != 0)
      return v17;
    if (v23 == 6)
    {
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 48)
                                                                                                 + 168))(a3, a4, HIWORD(v25), 1, 1, (char *)&v24 + 2, &v25);
      if ((v17 & 0x80000000) != 0)
        return v17;
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 48)
                                                                                                + 168))(a3, a4, HIWORD(v25), 2, 1, &v24, &v25);
      if ((v17 & 0x80000000) != 0)
        return v17;
      if (HIWORD(v24) <= a6 && (unsigned __int16)v24 + 1 >= a7)
      {
        v18 = HIWORD(v24) + 1 == a6 || HIWORD(v24) == a6;
        v19 = "I-";
        if (v18)
          v19 = "B-";
        *(_WORD *)a8 = *(_WORD *)v19;
        a8[2] = v19[2];
        v16 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, int *))(*(_QWORD *)(a1 + 48)
                                                                                             + 176))(a3, a4, HIWORD(v25), 4, &v22, &v25);
        if ((v16 & 0x80000000) == 0)
        {
          v20 = strncat(a8, (const char *)(v22 + 1), 0x3CuLL);
          a8 += (unsigned __int16)strlen(v20) - 1;
LABEL_19:
          *a8 = 0;
        }
        return v16;
      }
    }
  }
  return v16;
}

uint64_t stat_hmogrph_disambiguateWords(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 v17;
  char *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int NextUtf8Offset;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 v49;
  int v50;
  unsigned __int16 v51;
  unsigned __int16 v52;
  int v53;
  uint64_t IOBTNToken;
  uint64_t v56;
  uint64_t v57;
  float *v58;
  float *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int16 v63;
  unsigned __int16 v64;
  unsigned int v66;
  int v67;
  uint64_t v68;
  unsigned int v69;
  size_t v70;
  uint64_t v71;
  char *v72;
  int v73;
  int v74;
  int v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t ***v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  unsigned __int16 v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  char *v105;
  unsigned int v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  char *HomographPhon;
  const char *v112;
  unsigned __int16 v113;
  unsigned __int16 v114;
  int v116;
  unsigned __int16 v117;
  unsigned __int16 v118;
  int v119;
  int v120;
  uint64_t v122;
  __int16 v123;
  unsigned __int16 v124;
  uint64_t v125;
  char *v126;
  char *v127;
  char *v128;
  char *v129;
  char *v130;
  char *v131;
  char *v132;
  __int16 v133;
  uint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  char *__dst;
  uint64_t v140;
  unsigned int v141;
  unsigned __int16 v142;
  int v143;
  int v144;
  int v145;
  int v146;
  char *__s;
  char *__s1;
  unsigned int v149;
  uint64_t v150;
  char *v151;
  char *__s2;
  _BYTE __c[11];
  const char **v154;
  float *v155;
  uint64_t v156;
  char *v157;
  unsigned int v158;
  unsigned int v159;
  int v160;
  unsigned __int16 v161;
  unsigned __int16 v162;
  int v163;
  int v164;
  int v165;
  char __src[64];
  uint64_t v167;

  v167 = *MEMORY[0x1E0C80C00];
  v164 = 0;
  v165 = 0;
  v163 = 0;
  v162 = 0;
  v161 = 0;
  v159 = 0;
  v160 = 0;
  v158 = 0;
  v156 = 0;
  v157 = 0;
  v154 = 0;
  v155 = 0;
  memset(__c, 0, sizeof(__c));
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a2 + 104))(a3, a4, 1, 0, (char *)&v165 + 2);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, int *))(a2 + 184))(a3, a4, HIWORD(v165), 0, &v163);
  if ((v11 & 0x80000000) != 0)
    return v11;
  if ((unsigned __int16)v163 != 1)
    return v11;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t *, int *))(a2 + 176))(a3, a4, HIWORD(v165), 0, &v156, &v164);
  if ((v11 & 0x80000000) != 0 || (unsigned __int16)v164 < 2u)
    return v11;
  v12 = *(_QWORD *)(a1 + 280);
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, unsigned int *))(v12 + 40))(*(_QWORD *)(a5 + 104), *(_QWORD *)(a5 + 112), &v158);
  if ((v10 & 0x80000000) != 0)
    return v10;
  if (strlen((const char *)(a1 + 344)) + v158 != *(_DWORD *)(a1 + 324))
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v135);
    return 2314215449;
  }
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(a2 + 104))(a3, a4, 2, HIWORD(v165), &v165);
  if ((v11 & 0x80000000) == 0)
  {
    v17 = v165;
    if ((_WORD)v165)
    {
      __s = (char *)(a1 + 344);
      __s1 = 0;
      v18 = 0;
      v150 = 0;
      v142 = 0;
      v141 = 0;
      v149 = 0;
      v140 = v12;
      while (1)
      {
        v19 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v17, 0, 1, &v159, &v164);
        if ((v19 & 0x80000000) != 0)
        {
LABEL_188:
          v11 = v19;
          goto LABEL_189;
        }
        if (v159 <= 0xA && ((1 << v159) & 0x610) != 0)
          break;
LABEL_28:
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(a2 + 120))(a3, a4, (unsigned __int16)v165, &v165);
        if ((v11 & 0x80000000) == 0)
        {
          v17 = v165;
          if ((_WORD)v165)
            continue;
        }
        goto LABEL_189;
      }
      v19 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v165, 1, 1, &v162, &v164);
      if ((v19 & 0x80000000) != 0)
        goto LABEL_188;
      v19 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v165, 2, 1, &v161, &v164);
      if ((v19 & 0x80000000) != 0)
        goto LABEL_188;
      v21 = v161;
      v22 = v162;
      v23 = v161 - v162;
      if (v23 <= v149)
      {
        v29 = v162;
        v30 = (char *)v150;
      }
      else
      {
        v24 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), v150, (v23 + 1));
        if (!v24)
          goto LABEL_195;
        v149 = (unsigned __int16)v23;
        v29 = v162;
        v30 = (char *)v24;
      }
      strncpy(v30, (const char *)(v156 + v29), v23);
      v150 = (uint64_t)v30;
      if (v21 == v22)
      {
        *v30 = 0;
        goto LABEL_28;
      }
      if (strchr(__s, v30[(v23 - 1)]))
        v31 = v23 - 1;
      else
        v31 = v23;
      v30[v31] = 0;
      if (!v31)
        goto LABEL_28;
      v32 = strlen(v30);
      v33 = v32;
      __dst = v18;
      if (v32 <= v142)
      {
        if (!v32)
        {
          v143 = 0;
          goto LABEL_45;
        }
      }
      else
      {
        v34 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), (uint64_t)__s1, v32 + 1);
        if (!v34)
        {
LABEL_195:
          v11 = 2314215434;
LABEL_196:
          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v135);
          goto LABEL_189;
        }
        __s1 = (char *)v34;
        v142 = v33;
      }
      v143 = 0;
      v35 = 0;
      do
      {
        NextUtf8Offset = utf8_GetNextUtf8Offset(&v30[v35], 0);
        if (utf8_ToLower(v30, v35, (uint64_t)__src))
        {
          if (strlen(__src) <= NextUtf8Offset)
          {
            strcpy(&__s1[v143], __src);
            v143 = strlen(__s1);
          }
          else
          {
            v142 += 5;
            v37 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), (uint64_t)__s1, v142 + 1);
            if (!v37)
              goto LABEL_198;
            __s1 = (char *)v37;
          }
        }
        else
        {
          strncpy(&__s1[v143], &v30[v35], NextUtf8Offset);
          v143 += NextUtf8Offset;
        }
        v35 += NextUtf8Offset;
      }
      while (v35 < v33);
LABEL_45:
      __s1[v143] = 0;
      if (IsModelHomograph(__s1, *(char **)(a5 + 136)))
      {
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PRESENT: %s", v42, v43, v44, (uint64_t)__s1);
        v49 = v165;
        HIWORD(v164) = v165;
        if ((_WORD)v165)
        {
          v50 = 0;
          v51 = v161;
          v52 = v162;
          LOWORD(v53) = v165;
          while (1)
          {
            IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 136))(a3, a4, (unsigned __int16)v53, (char *)&v164 + 2);
            if ((IOBTNToken & 0x80000000) != 0)
              break;
            if (!HIWORD(v164))
              goto LABEL_66;
            IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a3, a4);
            if ((IOBTNToken & 0x80000000) != 0)
              break;
            if (v159 > 0xA || ((1 << v159) & 0x610) == 0)
            {
              v53 = HIWORD(v164);
            }
            else
            {
              IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
              if ((IOBTNToken & 0x80000000) != 0)
                break;
              IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
              if ((IOBTNToken & 0x80000000) != 0)
                break;
              v53 = HIWORD(v164);
              if (HIWORD(v160) == v52 && (unsigned __int16)v160 == v51)
              {
                v49 = HIWORD(v164);
              }
              else
              {
                if (++v50 == (*(_DWORD *)(a1 + 320) - 1) >> 1)
                {
                  HIWORD(v164) = 0;
                  v49 = v53;
                  goto LABEL_66;
                }
                v49 = HIWORD(v164);
                v52 = HIWORD(v160);
                v51 = v160;
              }
            }
            if (!v53)
              goto LABEL_66;
          }
LABEL_197:
          v11 = IOBTNToken;
LABEL_199:
          v18 = __dst;
          goto LABEL_189;
        }
LABEL_66:
        v56 = *(_QWORD *)a1;
        if (!(*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320)))
        {
          log_OutPublic(*(_QWORD *)(v56 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v45, v46, v47, v48, v135);
          v11 = 2314215449;
          goto LABEL_199;
        }
        v57 = 4 * (*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320));
        v58 = (float *)heap_Alloc(*(_QWORD *)(v56 + 8), v57);
        v155 = v58;
        if (!v58)
        {
LABEL_198:
          v11 = 2314215434;
          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v38, v39, v40, v41, v135);
          goto LABEL_199;
        }
        v59 = v58;
        memset_pattern16(v58, &unk_1DEC65190, v57);
        HIWORD(v164) = v49;
        if (v49)
        {
          v137 = 0;
          v144 = 0;
          v63 = 0;
          v64 = 0;
          while (1)
          {
            IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v49, 0, 1, &v159, &v164);
            if ((IOBTNToken & 0x80000000) != 0)
              goto LABEL_197;
            if (v159 <= 0xA && ((1 << v159) & 0x610) != 0)
            {
              IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
              if ((IOBTNToken & 0x80000000) != 0)
                goto LABEL_197;
              IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
              if ((IOBTNToken & 0x80000000) != 0)
                goto LABEL_197;
              v66 = HIWORD(v160);
              v67 = (unsigned __int16)v160;
              if (HIWORD(v160) != v64 || (unsigned __int16)v160 != v63)
              {
                v68 = strlen(__s);
                if (v68)
                {
                  v69 = v158;
                  do
                  {
                    v59[v69++] = 0.0;
                    --v68;
                  }
                  while (v68);
                }
                v70 = v67 - v66;
                if (v70 <= v149)
                {
                  v72 = (char *)v150;
                }
                else
                {
                  v71 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), v150, (v70 + 1));
                  if (!v71)
                    goto LABEL_198;
                  v149 = (unsigned __int16)v70;
                  v66 = HIWORD(v160);
                  v72 = (char *)v71;
                }
                strncpy(v72, (const char *)(v156 + v66), v70);
                v72[v70] = 0;
                v73 = strcmp(__s1, v72);
                v74 = v137;
                if (HIWORD(v164) == (unsigned __int16)v165)
                  v75 = v137;
                else
                  v75 = 1;
                if (!v73)
                  v74 = v75;
                v137 = v74;
                v76 = (v70 - 1);
                v77 = strchr(__s, v72[v76]);
                if (v77)
                {
                  v81 = *(_BYTE *)(a1 + ((_DWORD)v77 - (_DWORD)__s) + 354) - 48;
                  v59[v158 + v81] = 1.0;
                  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PUNC: %i", v78, v79, v80, v81);
                  v72[v76] = 0;
                }
                v150 = (uint64_t)v72;
                IOBTNToken = stat_hmogrph_getIOBTNToken(a1, a2, a3, a4, HIWORD(v165), HIWORD(v160), (unsigned __int16)v160, __src);
                if ((IOBTNToken & 0x80000000) != 0)
                  goto LABEL_197;
                if (__src[0])
                  v85 = __src;
                else
                  v85 = v72;
                log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_WORD: %s", v82, v83, v84, (uint64_t)v85);
                v86 = (*(uint64_t (**)(_QWORD, _QWORD, char *, float *))(v140 + 56))(*(_QWORD *)(a5 + 104), *(_QWORD *)(a5 + 112), v85, v59);
                v11 = v86;
                if ((v86 & 0x1FFF) == 0x14)
                {
                  if (*(_DWORD *)(a5 + 176))
                  {
                    v87 = *v85;
                    if ((v87 - 65) <= 0x19)
                    {
                      *v85 = v87 + 32;
                      LOWORD(v11) = (*(uint64_t (**)(_QWORD, _QWORD, char *, float *))(v140 + 56))(*(_QWORD *)(a5 + 104), *(_QWORD *)(a5 + 112), v85, v59);
                      *v85 = v87;
                    }
                  }
                  if ((v11 & 0x1FFF) == 0x14)
                  {
                    IOBTNToken = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, float *))(v140 + 56))(*(_QWORD *)(a5 + 104), *(_QWORD *)(a5 + 112), a5 + 164, v59);
                    if ((IOBTNToken & 0x80000000) != 0)
                      goto LABEL_197;
                  }
                }
                else if ((v86 & 0x80000000) != 0)
                {
                  goto LABEL_199;
                }
                if (HIWORD(v164) == (unsigned __int16)v165)
                  v144 = *(_DWORD *)(a1 + 320) >> 1;
                ++v144;
                v64 = HIWORD(v160);
                v63 = v160;
                v59 += *(unsigned int *)(a1 + 324);
              }
            }
            IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 120))(a3, a4, HIWORD(v164), (char *)&v164 + 2);
            if ((IOBTNToken & 0x80000000) != 0)
              goto LABEL_197;
            if (v144 == *(_DWORD *)(a1 + 320))
            {
              HIWORD(v164) = 0;
              goto LABEL_114;
            }
            v49 = HIWORD(v164);
            if (!HIWORD(v164))
              goto LABEL_114;
          }
        }
        v137 = 0;
LABEL_114:
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_FEATURE: BEGIN", v60, v61, v62, v135);
        if (*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320))
        {
          v91 = 0;
          do
            log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%f", v88, v89, v90, COERCE__INT64(v155[v91++]));
          while (v91 < (*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320)));
        }
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_FEATURE: END", v88, v89, v90, v136);
        v92 = *(uint64_t ****)(a5 + 40);
        *((float *)*v92 + 49) = (float)*(unsigned int *)(a5 + 128) / 100.0;
        v19 = fi_predict(v92, (const void **)&v155, *(unsigned int *)(a1 + 320), &v154, v93, v94, v95, v96);
        v18 = __dst;
        if ((v19 & 0x80000000) != 0)
          goto LABEL_188;
        v11 = 2314215434;
        LODWORD(__s2) = 0;
        if ((fi_shape_get_size((int *)(**(_QWORD **)(a5 + 40) + 92), (int *)&__s2) & 0x80000000) != 0)
        {
          v11 = 2314215431;
          goto LABEL_196;
        }
        if ((_DWORD)__s2 != 1)
        {
          v11 = 2314215449;
          goto LABEL_196;
        }
        v97 = strlen(__s1);
        v98 = v97 + 18;
        if (v97 + 18 > v141)
        {
          v99 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), (uint64_t)__dst, (v97 + 19));
          if (!v99)
            goto LABEL_196;
          v141 = v98;
          v18 = (char *)v99;
        }
        strcpy(v18, "statwordhmogrph__");
        strcat(v18, __s1);
        *(_WORD *)&__c[1] = -1;
        v19 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 96) + 96))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), "fecfg", v18, &__c[3], &__c[1], __c);
        if ((v19 & 0x80000000) != 0)
          goto LABEL_188;
        if (!*(_WORD *)&__c[1])
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v100, v101, v102, v103, v135);
          v11 = 2314215444;
LABEL_189:
          if (__s1)
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)__s1);
          if (v150)
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v150);
          if (v18)
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v18);
          return v11;
        }
        v104 = **(const char ***)&__c[3];
        v105 = strchr(**(char ***)&__c[3], __c[0]);
        if (v105)
        {
          *v105 = 0;
          v104 = **(const char ***)&__c[3];
        }
        v106 = strlen(v104);
        if (v141 < v106)
        {
          v107 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), (uint64_t)v18, v106 + 1);
          if (!v107)
            goto LABEL_196;
          v141 = (unsigned __int16)v106;
          v104 = **(const char ***)&__c[3];
          v18 = (char *)v107;
        }
        strcpy(v18, v104);
        __dst = v18;
        if (*v154)
        {
          HomographPhon = GetHomographPhon(*v154, v18);
          if (HomographPhon)
          {
            if (v137 != 1)
            {
              v112 = HomographPhon;
              log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PHON: %s", v108, v109, v110, (uint64_t)HomographPhon);
              v113 = v165;
              HIWORD(v164) = v165;
              if ((_WORD)v165)
              {
                v114 = 0;
                v145 = v162;
                v138 = v161;
                while (1)
                {
                  IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v113, 0, 1, &v159, &v164);
                  if ((IOBTNToken & 0x80000000) != 0)
                    goto LABEL_197;
                  if (v159 <= 0xA && ((1 << v159) & 0x610) != 0)
                  {
                    IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
                    if ((IOBTNToken & 0x80000000) != 0)
                      goto LABEL_197;
                    IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
                    if ((IOBTNToken & 0x80000000) != 0)
                      goto LABEL_197;
                    if (HIWORD(v160) == v145 && (unsigned __int16)v160 == v138)
                    {
                      IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, int *))(*(_QWORD *)(a1 + 48) + 176))(a3, a4, HIWORD(v164), 3, &v157, &v164);
                      if ((IOBTNToken & 0x80000000) != 0)
                        goto LABEL_197;
                      v116 = strcmp(v157, v112);
                      v117 = HIWORD(v164);
                      IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 120))(a3, a4, HIWORD(v164), (char *)&v164 + 2);
                      if ((IOBTNToken & 0x80000000) != 0)
                        goto LABEL_197;
                      if (!v116)
                        v114 = v117;
                      v113 = HIWORD(v164);
                      if (HIWORD(v164))
                        continue;
                    }
                  }
                  goto LABEL_152;
                }
              }
              goto LABEL_184;
            }
          }
        }
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PHON: <>", v108, v109, v110, v135);
      }
      v114 = 0;
LABEL_152:
      v118 = v165;
      HIWORD(v164) = v165;
      if ((_WORD)v165)
      {
        v119 = v162;
        v120 = v161;
        do
        {
          IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v118, 0, 1, &v159, &v164);
          if ((IOBTNToken & 0x80000000) != 0)
            goto LABEL_197;
          if (v159 > 0xA || ((1 << v159) & 0x610) == 0)
            goto LABEL_183;
          IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
          if ((IOBTNToken & 0x80000000) != 0)
            goto LABEL_197;
          IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*(_QWORD *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
          if ((IOBTNToken & 0x80000000) != 0)
            goto LABEL_197;
          if (HIWORD(v160) != v119 || (unsigned __int16)v160 != v120)
          {
LABEL_183:
            HIWORD(v164) = 0;
            break;
          }
          v122 = HIWORD(v164);
          IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a2 + 120))(a3, a4, HIWORD(v164), (char *)&v164 + 2);
          if ((IOBTNToken & 0x80000000) != 0)
            goto LABEL_197;
          if (!v114 || (_DWORD)v122 == v114)
          {
            LOWORD(v165) = v122;
            if ((_DWORD)v122 == v114)
            {
              v151 = 0;
              __s2 = 0;
              IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, int *))(*(_QWORD *)(a1 + 48) + 176))(a3, a4, v114, 5, &__s2, &v164);
              if ((IOBTNToken & 0x80000000) != 0)
                goto LABEL_197;
              IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, int *))(*(_QWORD *)(a1 + 48) + 176))(a3, a4, (unsigned __int16)v165, 14, &v151, &v164);
              if ((IOBTNToken & 0x80000000) != 0)
                goto LABEL_197;
              v123 = strlen(v151);
              v124 = strlen(__s2) + v123;
              v146 = v120;
              if (v124 <= v141)
              {
                v126 = __dst;
              }
              else
              {
                v125 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), (uint64_t)__dst, v124 + 1);
                if (!v125)
                  goto LABEL_198;
                v141 = v124;
                v126 = (char *)v125;
              }
              strcpy(v126, "POS:");
              v127 = strcat(v126, __s2);
              *(_WORD *)&v126[strlen(v127)] = 59;
              v128 = v151;
              __dst = v126;
              if (!strstr(v151, v126))
              {
                v129 = strstr(v128, "POS");
                if (v129)
                {
                  v130 = v129;
                  v131 = strncpy(__dst, v128, v129 - v128);
                  __dst[v130 - v151] = 0;
                  strcpy(&__dst[strlen(v131)], "POS:");
                  strcat(__dst, __s2);
                  v132 = strchr(v130, 59);
                  if (v132)
                    strcat(__dst, v132);
                  v133 = strlen(__dst);
                  IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, char *))(*(_QWORD *)(a1 + 48) + 160))(a3, a4, (unsigned __int16)v165, 14, (unsigned __int16)(v133 + 1), __dst, (char *)&v163 + 2);
                  if ((IOBTNToken & 0x80000000) != 0)
                    goto LABEL_197;
                }
              }
              v120 = v146;
            }
          }
          else
          {
            IOBTNToken = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 192))(a3, a4, v122);
            if ((IOBTNToken & 0x80000000) != 0)
              goto LABEL_197;
          }
          v118 = HIWORD(v164);
        }
        while (HIWORD(v164));
      }
LABEL_184:
      v18 = __dst;
      goto LABEL_28;
    }
  }
  return v11;
}

char *IsModelHomograph(const char *a1, char *a2)
{
  unsigned __int16 v4;
  char *result;

  v4 = strlen(a1);
  result = strstr(a2, a1);
  if (result)
  {
    if (result == a2 || *(result - 1) == 124)
      return (char *)(!result[v4] || result[v4] == 124);
    else
      return 0;
  }
  return result;
}

char *GetHomographPhon(const char *a1, char *__s)
{
  const char *v2;
  char *i;
  char *v5;
  char *v6;
  int v7;
  char *v8;

  v2 = __s;
  for (i = __s; ; i = v8 + 1)
  {
    v5 = strchr(i, 61);
    v6 = v5;
    if (!v5)
      break;
    *v5 = 0;
    v6 = v5 + 1;
    v7 = strcmp(a1, v2);
    v8 = strchr(v6, 124);
    if (!v7)
    {
      if (v8)
        *v8 = 0;
      return v6;
    }
    if (!v8)
      return 0;
    v2 = v8 + 1;
  }
  return v6;
}

char *hlp_filterWordCandIfTnHas(char *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;

  v1 = *((unsigned __int16 *)result + 28);
  if (*((_WORD *)result + 28))
  {
    v2 = 0;
    v3 = *((_QWORD *)result + 6);
    do
    {
      v4 = v3 + 16 * v2;
      v5 = *(unsigned __int16 *)(v4 + 8);
      if (*(_WORD *)(v4 + 8))
      {
        v6 = (_DWORD *)(*(_QWORD *)(v3 + 16 * v2) + 48);
        do
        {
          result = strstr(*((char **)v6 - 1), "poi");
          if (result)
            *v6 = 1;
          v6 += 14;
          --v5;
        }
        while (v5);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

uint64_t hlp_hasRcdWithGivenPOIClass(uint64_t a1, char *__s2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char **v8;

  v2 = *(unsigned __int16 *)(a1 + 56);
  if (!*(_WORD *)(a1 + 56))
    return 0;
  v4 = 0;
  v5 = *(_QWORD *)(a1 + 48);
  while (1)
  {
    v6 = v5 + 16 * v4;
    v7 = *(unsigned __int16 *)(v6 + 8);
    if (*(_WORD *)(v6 + 8))
      break;
LABEL_7:
    if (++v4 == v2)
      return 0;
  }
  v8 = (const char **)(*(_QWORD *)(v5 + 16 * v4) + 40);
  while (strcmp(*v8, __s2))
  {
    v8 += 7;
    if (!--v7)
      goto LABEL_7;
  }
  return 1;
}

uint64_t hlp_filterWordCandIfTnIsNot(uint64_t result, char *__s2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;

  v2 = *(unsigned __int16 *)(result + 56);
  if (*(_WORD *)(result + 56))
  {
    v4 = 0;
    v5 = *(_QWORD *)(result + 48);
    do
    {
      v6 = v5 + 16 * v4;
      v7 = *(unsigned __int16 *)(v6 + 8);
      if (*(_WORD *)(v6 + 8))
      {
        v8 = (_DWORD *)(*(_QWORD *)(v5 + 16 * v4) + 48);
        do
        {
          result = strcmp(*((const char **)v8 - 1), __s2);
          if ((_DWORD)result)
            *v8 = 1;
          v8 += 14;
          --v7;
        }
        while (v7);
      }
      ++v4;
    }
    while (v4 != v2);
  }
  return result;
}

uint64_t stat_hmogrph_isSubWordRec(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (!*(_WORD *)(a1 + 8))
    return 0;
  v2 = 0;
  while (1)
  {
    if ((unint64_t)a2 << 6 != v2)
    {
      v3 = *(_QWORD *)a1 + ((unint64_t)a2 << 6);
      v4 = *(_QWORD *)a1 + v2;
      if (*(unsigned __int16 *)(v3 + 8) >= *(unsigned __int16 *)(v4 + 8)
        && *(unsigned __int16 *)(v3 + 10) <= *(unsigned __int16 *)(v4 + 10))
      {
        break;
      }
    }
    v2 += 64;
    if ((unint64_t)*(unsigned __int16 *)(a1 + 8) << 6 == v2)
      return 0;
  }
  return 1;
}

unsigned __int16 *stat_hmogrph_setWillBeDeleteOfSubWords(unsigned __int16 *result, unsigned int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  _DWORD *v8;

  v3 = result[4];
  if (result[4])
  {
    v4 = a2;
    v5 = *(_QWORD *)result + ((unint64_t)a2 << 6);
    v6 = (unsigned __int16 *)(v5 + 8);
    v7 = (unsigned __int16 *)(v5 + 10);
    v8 = (_DWORD *)(*(_QWORD *)result + 32);
    do
    {
      if (v4
        && *v6 <= *((unsigned __int16 *)v8 - 12)
        && *v7 >= *((unsigned __int16 *)v8 - 11))
      {
        *v8 = a3;
      }
      v8 += 16;
      --v4;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t stat_hmogrph_hasSubWordWithGivenTn(uint64_t a1, unsigned int a2, char *__s2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;

  v3 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 8))
    return 0;
  v5 = *(_QWORD *)a1;
  v6 = a2;
  v7 = *(_QWORD *)a1 + ((unint64_t)a2 << 6);
  v8 = (unsigned __int16 *)(v7 + 8);
  v9 = (unsigned __int16 *)(v7 + 10);
  while (!v6
       || *v8 > *(unsigned __int16 *)(v5 + 8)
       || *v9 < *(unsigned __int16 *)(v5 + 10)
       || !hlp_hasRcdWithGivenPOIClass(v5, __s2))
  {
    v5 += 64;
    --v6;
    if (!--v3)
      return 0;
  }
  return 1;
}

uint64_t nntn_AllInOneLoop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t DomainDefBlockInfo;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int NumberChildren;
  uint64_t v32;
  uint64_t v33;
  size_t *v34;
  unint64_t v35;
  unsigned int v36;
  size_t v37;
  int v38;
  uint64_t DomainRange;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int Type;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  BOOL v62;
  BOOL v64;
  BOOL v65;
  char v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t *v79;
  int v80;
  int v81;
  int v82;
  int v83;
  char *v84;
  int v85;
  uint64_t **i;
  int StringAttribute;
  char *v88;
  int v89;
  const char *v90;
  uint64_t v91;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  int v96;
  unsigned int v97;
  size_t *v98;
  char *v99;
  int v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  unsigned __int16 v104;
  int v105;
  char *v106;
  char *v107;
  char *__s1;
  uint64_t **v109;
  unint64_t v110;
  uint64_t v111;
  _WORD v112[500];
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  v104 = 0;
  v103 = 0;
  v102 = 0;
  v101 = 0;
  v100 = 0;
  v99 = 0;
  v97 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 4, 0, (uint64_t)"nntn : AllInOneLoop Begin", a6, a7, a8, v93);
  if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"maxTNNNcallspersent", (int *)&v97) & 0x80000000) == 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 5, 0, (uint64_t)"set maxTNNNCallsPerSent to %d", v13, v14, v15, v97);
  if (v97)
    *(_DWORD *)(a1 + 872) = v97;
  v16 = *(uint64_t **)(a1 + 168);
  *(_QWORD *)(*(_QWORD *)(*v16 + 16) + 32) = a1;
  v17 = setDomainsOnSentence_NNTN((uint64_t *)a1, v9, v10, v11, v12, v13, v14, v15);
  if ((v17 & 0x80000000) != 0)
    return v17;
  DomainDefBlockInfo = mergeDomainsOnSentence_NNTN((_QWORD *)a1, v18, v19, v20, v21, v22, v23, v24);
  if ((DomainDefBlockInfo & 0x80000000) != 0)
    return DomainDefBlockInfo;
  v26 = *v16;
  *(_QWORD *)(*(_QWORD *)(*v16 + 16) + 16) = *(_QWORD *)(a1 + 304);
  *(_WORD *)(v26 + 64) = 16;
  *(_WORD *)(v26 + 42) = *(_WORD *)(a1 + 312);
  v27 = *(_QWORD *)(*(_QWORD *)(a1 + 264) + 16);
  NumberChildren = LDOTreeNode_GetNumberChildren(v27);
  v32 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  v33 = *(_QWORD *)(a1 + 184);
  if (!NumberChildren)
  {
    v90 = "no basic token records to process";
    v91 = 5;
LABEL_106:
    log_OutText(v32, v33, v91, 0, (uint64_t)v90, v28, v29, v30, v94);
    return DomainDefBlockInfo;
  }
  log_OutText(v32, v33, 4, 0, (uint64_t)"tokentn : start loop...", v28, v29, v30, v94);
  v34 = *(size_t **)(v27 + 80);
  v35 = *(_QWORD *)(v27 + 88);
  v98 = v34;
  v95 = v35;
  if ((unint64_t)v34 < v35)
  {
    v36 = 0;
    do
    {
      __s1 = 0;
      LODWORD(v107) = 0;
      LODWORD(v106) = 0;
      v37 = *v34;
      v38 = LDOTreeNode_ComputeAbsoluteFrom(*v34, &v107);
      DomainRange = LH_ERROR_to_VERROR(v38);
      if ((DomainRange & 0x80000000) != 0
        || (v46 = LDOTreeNode_ComputeAbsoluteTo(v37, &v106),
            DomainRange = LH_ERROR_to_VERROR(v46),
            (DomainRange & 0x80000000) != 0))
      {
LABEL_104:
        DomainDefBlockInfo = DomainRange;
        goto LABEL_105;
      }
      v47 = (unsigned __int16)v107;
      v96 = (unsigned __int16)v106;
      Type = LDOObject_GetType(v37, (uint64_t *)&__s1);
      DomainDefBlockInfo = LH_ERROR_to_VERROR(Type);
      if ((DomainDefBlockInfo & 0x80000000) != 0)
        goto LABEL_105;
      *(_DWORD *)(*v16 + 72) = 0;
      v49 = __s1;
      if (!strcmp(__s1, "TOKEN_ALPHA"))
        v36 = 0;
      if (!strcmp(v49, "TOKEN_DIGIT"))
        v36 = 1;
      if (!strcmp(v49, "TOKEN_PUNCT"))
        v36 = 2;
      if (!strcmp(v49, "TOKEN_WSPACE"))
        v36 = 3;
      if (!strcmp(v49, "TOKEN_DCT"))
        v36 = 4;
      if (!strcmp(v49, "TOKEN_USER_TN"))
        v36 = 5;
      if (!strcmp(v49, "TOKEN_INT_TN"))
        v36 = 6;
      if (!strcmp(v49, "TOKEN_CASEGENDER"))
        v36 = 7;
      if (v36 <= 2)
      {
        HIWORD(v102) = 0;
        FERuntimeData_GetActiveDomains(a1, (uint64_t)v112, (_WORD *)&v102 + 1, v47, v96, 0);
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 5, 0, (uint64_t)"START basic token %d,%d ... %d active domains", v50, v51, v52, v47);
        if (HIWORD(v102))
        {
          v53 = 0;
          while (1)
          {
            LOWORD(v102) = 0;
            v104 = 0;
            v54 = *v16;
            *(_WORD *)(v54 + 46) = 0;
            *(_WORD *)(v54 + 44) = v47;
            *(_QWORD *)(v54 + 56) = 0;
            DomainRange = FERuntimeData_GetDomainRange(a1, (unsigned __int16)v112[v53], &v103);
            if ((DomainRange & 0x80000000) != 0)
              goto LABEL_104;
            log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 5, 0, (uint64_t)"Domain %d : range %d,%d", v43, v44, v45, v53);
            *(_WORD *)(*v16 + 46) = *(_WORD *)(v103 + 2);
            DomainRange = FERuntimeData_GetDomainBlockIndex((_QWORD *)a1, (unsigned __int16)v112[v53], &v102, &v104);
            if ((DomainRange & 0x80000000) != 0)
              goto LABEL_104;
            DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo((_QWORD *)a1, (unsigned __int16)v102, &v101, v41, v42, v43, v44, v45);
            if ((DomainDefBlockInfo & 0x80000000) != 0)
              goto LABEL_105;
            if (v104 > *(unsigned __int16 *)(v101 + 24))
              break;
            v55 = *(_QWORD *)(v101 + 40) + 16 * *(unsigned __int16 *)(*(_QWORD *)(v101 + 16) + 72 * v104 + 12);
            log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 5, 0, (uint64_t)"doing domain %d, Domain[%s:%s] (applying %d rules)", v43, v44, v45, v53);
            if (*(_WORD *)(v55 + 8))
            {
              v56 = *v16;
              if (*(_DWORD *)(*v16 + 72) != 1)
              {
                v57 = 0;
                v58 = 0;
                while (1)
                {
                  v59 = *(_QWORD *)v55 + v57;
                  *(_WORD *)(v56 + 40) = 0;
                  v60 = v56 + 40;
                  *(_QWORD *)(v60 + 16) = v59;
                  DomainDefBlockInfo = FEData_blockData_getTokenAndRegexData_NNTN((_QWORD *)a1, v59, (_QWORD *)(v60 - 8), (_WORD *)v60, (_QWORD *)(v60 - 16), &v100, v44, v45);
                  if ((DomainDefBlockInfo & 0x80000000) != 0)
                    goto LABEL_105;
                  v61 = v36 < 2;
                  v62 = v36 == 2;
                  if (v100 != 1)
                    v62 = 0;
                  v64 = v36 == 1 && v100 == 2;
                  if (v36)
                    v65 = 0;
                  else
                    v65 = v100 == 3;
                  v66 = v65;
                  if (v100 != 4)
                    v61 = 0;
                  if (!v100 || v62 || v64 || (v66 & 1) != 0 || v61)
                    break;
                  if (v100 == 5)
                  {
                    if ((v36 & 0xFFFFFFFD) == 0)
                      break;
                  }
                  else if (v100 == 6 && v36 - 1 < 2)
                  {
                    break;
                  }
                  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 5, 0, (uint64_t)"rule %s (token %s, %d,%d) blocked by triggerType %s", v43, v44, v45, *(_QWORD *)(*v16 + 24));
LABEL_68:
                  if (++v58 < (unint64_t)*(unsigned __int16 *)(v55 + 8))
                  {
                    v57 += 24;
                    v56 = *v16;
                    if (*(_DWORD *)(*v16 + 72) != 1)
                      continue;
                  }
                  goto LABEL_70;
                }
                v67 = *v16;
                v68 = *(uint64_t **)(*v16 + 16);
                v69 = *v68;
                *(_BYTE *)(v69 + 82) = 0;
                *(_WORD *)(v69 + 40) = 0;
                v68[2] = *(_QWORD *)(a1 + 304);
                v68[3] = *(_QWORD *)(v67 + 24);
                *(_QWORD *)(v69 + 96) = *(_QWORD *)(v67 + 56);
                *(_WORD *)(v69 + 104) = v102;
                *(_WORD *)(v69 + 106) = v104;
                *((_WORD *)v68 + 26) = *(_WORD *)(v67 + 44);
                *((_WORD *)v68 + 27) = *(_WORD *)(v67 + 46);
                *((_DWORD *)v68 + 11) = 0;
                *((_DWORD *)v68 + 12) = 0;
                DomainDefBlockInfo = tokenizer_apply_regex_NNTN((uint64_t *)a1, v67, &v98);
                if ((DomainDefBlockInfo & 0x80000000) != 0)
                  goto LABEL_105;
                v70 = *(_QWORD *)(*v16 + 16);
                **(_DWORD **)(v70 + 8) = 0;
                *(_DWORD *)(v70 + 44) = 0;
                goto LABEL_68;
              }
            }
LABEL_70:
            if (++v53 >= (unint64_t)HIWORD(v102))
              goto LABEL_71;
          }
          log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 24028, "%s%d%s%d", v42, v43, v44, v45, "domain");
          return NNTNERROR(0);
        }
LABEL_71:
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 5, 0, (uint64_t)"END of loop for basic token %d,%d", v43, v44, v45, v47);
        FERuntimeData_FreeMatches((_QWORD *)a1, 0, v71, v72, v73, v74, v75, v76);
      }
      v34 = v98 + 1;
      v98 = v34;
    }
    while ((unint64_t)v34 < v95);
  }
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"spaceInPYT", &v99) & 0x80000000) != 0
    || LH_stricmp(v99, "yes"))
  {
    goto LABEL_105;
  }
  DomainDefBlockInfo = 0;
  v110 = 0;
  v111 = 0;
  __s1 = 0;
  v109 = 0;
  v77 = *(_QWORD *)(*(_QWORD *)(a1 + 264) + 16);
  v78 = *(uint64_t **)(v77 + 80);
  if ((unint64_t)v78 < *(_QWORD *)(v77 + 88))
  {
    v79 = 0;
    v80 = 0;
    do
    {
      v107 = 0;
      if (v79)
      {
        v81 = LDOObject_GetType(*v79, (uint64_t *)&v107);
        v17 = LH_ERROR_to_VERROR(v81);
        if ((v17 & 0x80000000) != 0)
          return v17;
      }
      v82 = LDOTreeNode_ComputeAbsoluteFrom(*v78, (_DWORD *)&v111 + 1);
      v17 = LH_ERROR_to_VERROR(v82);
      if ((v17 & 0x80000000) != 0)
        return v17;
      v83 = LDOTreeNode_ComputeAbsoluteTo(*v78, &v111);
      DomainDefBlockInfo = LH_ERROR_to_VERROR(v83);
      if ((DomainDefBlockInfo & 0x80000000) != 0)
        return DomainDefBlockInfo;
      if (v79 && ((v84 = v107, !strcmp(v107, "TOKEN_PUNCT")) || !strcmp(v84, "TOKEN_WSPACE")))
      {
        v80 = 1;
      }
      else
      {
        v85 = LDO_ComputeOverlappingLabels(*(_QWORD *)(a1 + 264), (unsigned int *)&v111 + 1, (unsigned int *)&v111, 0, (unsigned int *)&__s1);
        DomainDefBlockInfo = LH_ERROR_to_VERROR(v85);
        if ((DomainDefBlockInfo & 0x80000000) != 0)
          return DomainDefBlockInfo;
        for (i = v109; (unint64_t)i < v110; ++i)
        {
          v106 = 0;
          v105 = 0;
          StringAttribute = LDOObject_GetStringAttribute(*i, "TNTAG", &v105, (uint64_t *)&v106);
          DomainDefBlockInfo = LH_ERROR_to_VERROR(StringAttribute);
          if ((DomainDefBlockInfo & 0x80000000) != 0)
            goto LABEL_99;
          if (v105 && !strcmp(v106, "_PI1a_"))
          {
            if (v80 == 1)
              v88 = "left";
            else
              v88 = "none";
            v89 = LDOObject_SetStringAttribute(*v78, "INPUTSPACETAG", v88);
            DomainDefBlockInfo = LH_ERROR_to_VERROR(v89);
            if ((DomainDefBlockInfo & 0x80000000) != 0)
              goto LABEL_99;
            v80 = 0;
          }
        }
        LDO_FreeLDOLabelVector(*(_QWORD *)(a1 + 264), (uint64_t)&__s1);
        v79 = v78;
      }
      ++v78;
    }
    while ((unint64_t)v78 < *(_QWORD *)(v77 + 88));
  }
LABEL_99:
  if (v109)
    LDO_FreeLDOLabelVector(*(_QWORD *)(a1 + 264), (uint64_t)&__s1);
  if ((DomainDefBlockInfo & 0x80000000) == 0)
  {
LABEL_105:
    FERuntimeData_FreeMatches((_QWORD *)a1, 1, v40, v41, v42, v43, v44, v45);
    v32 = *(_QWORD *)(*(_QWORD *)a1 + 32);
    v33 = *(_QWORD *)(a1 + 184);
    v90 = "nntn : AllInOneLoop End (%x)";
    v94 = DomainDefBlockInfo;
    v91 = 4;
    goto LABEL_106;
  }
  return DomainDefBlockInfo;
}

BOOL isEnglishLetter(char *a1)
{
  unsigned int v2;
  int WCharFromUtf8;
  BOOL v5;

  v2 = strlen(a1);
  WCharFromUtf8 = utf8_GetWCharFromUtf8(a1, 0, v2);
  if ((*a1 & 0xDFu) - 65 < 0x1A
    || (WCharFromUtf8 - 192) < 0x17
    || (unsigned __int16)(WCharFromUtf8 - 216) < 7u
    || (unsigned __int16)(WCharFromUtf8 - 223) < 0x18u
    || (WCharFromUtf8 & 0xFFF8) == 0xF8
    || (WCharFromUtf8 - 256) <= 0x36 && (WCharFromUtf8 & 1) == 0
    || (unsigned __int16)(WCharFromUtf8 - 328) >= 0xFFF1u && (WCharFromUtf8 & 1) != 0
    || (WCharFromUtf8 - 330) <= 0x2E && (WCharFromUtf8 & 1) == 0
    || (unsigned __int16)(WCharFromUtf8 - 382) >= 0xFFFBu && (WCharFromUtf8 & 1) != 0)
  {
    return 1;
  }
  v5 = (WCharFromUtf8 - 312) < 0x11;
  if ((WCharFromUtf8 & 1) != 0)
    v5 = (unsigned __int16)(WCharFromUtf8 - 312) > 0xFFC8u;
  if (v5 || (unsigned __int16)(WCharFromUtf8 - 376) >= 0xFFD1u && (WCharFromUtf8 & 1) != 0)
    return 1;
  if ((WCharFromUtf8 - 378) <= 4)
    return (WCharFromUtf8 & 1) == 0;
  return WCharFromUtf8 == 383;
}

uint64_t updateLDOTreeNode_CHN(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4;
  int NumberChildren;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t *v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int Type;
  uint64_t UTF8Char;
  _QWORD *v30;
  unsigned int v31;
  int v32;
  unsigned int NextUtf8Offset;
  _QWORD *v34;
  char *v35;
  uint64_t v36;
  unsigned __int16 v37;
  _BOOL4 v38;
  int v39;
  uint64_t v40;
  int v41;
  _QWORD *v42;
  unint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  _QWORD *v48;
  int v49;
  int v50;
  _QWORD *v51;
  unint64_t v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  _QWORD *v60;
  unint64_t v61;
  unsigned int v62;
  unsigned int v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  BOOL v67;
  int v68;
  int v69;
  _QWORD *v70;
  unint64_t v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  uint64_t v75;
  int v76;
  int v77;
  _QWORD *v78;
  unint64_t v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v97;
  unsigned __int16 v98;
  char *v99;
  unsigned int v100;
  int v101;
  _QWORD *v102;
  uint64_t v103;
  char *__s2;
  unsigned int v105;
  char *__s;
  int v107;
  uint64_t v108;
  char *__s1;
  uint64_t v110;
  uint64_t v111;

  v110 = 0;
  v111 = 0;
  v108 = 0;
  __s1 = 0;
  v107 = 0;
  v4 = *(_QWORD *)(a1[33] + 16);
  NumberChildren = LDOTreeNode_GetNumberChildren(v4);
  *a2 = NumberChildren;
  if (!NumberChildren)
  {
    UTF8Char = 0;
    goto LABEL_127;
  }
  v6 = heap_Calloc(*(_QWORD **)(*a1 + 8), 1, *((unsigned __int16 *)a1 + 156) + 1);
  v11 = *a1;
  if (!v6)
  {
    log_OutPublic(*(_QWORD *)(v11 + 32), (uint64_t)"FE_NNTN", 37000, 0, v7, v8, v9, v10, v97);
    UTF8Char = NNTNERROR(10);
    goto LABEL_127;
  }
  v12 = v6;
  v17 = (char *)heap_Calloc(*(_QWORD **)(v11 + 8), 1, *((unsigned __int16 *)a1 + 156) + 1);
  v18 = *a1;
  if (!v17)
    goto LABEL_108;
  v19 = heap_Calloc(*(_QWORD **)(v18 + 8), 1, 48 * *a2);
  if (!v19)
  {
    v18 = *a1;
LABEL_108:
    log_OutPublic(*(_QWORD *)(v18 + 32), (uint64_t)"FE_NNTN", 37000, 0, v13, v14, v15, v16, v97);
    UTF8Char = NNTNERROR(10);
    v20 = 0;
    v90 = 0;
    goto LABEL_124;
  }
  v20 = v19;
  v21 = *(size_t **)(v4 + 80);
  if ((unint64_t)v21 >= *(_QWORD *)(v4 + 88))
  {
    UTF8Char = 0;
  }
  else
  {
    v98 = 0;
    do
    {
      if (!v21)
      {
        v91 = 6;
        goto LABEL_114;
      }
      v22 = LDOTreeNode_ComputeText(*v21, &v111);
      v23 = LH_ERROR_to_VERROR(v22);
      if ((v23 & 0x80000000) != 0
        || (__s = (char *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v111),
            v24 = LDOTreeNode_ComputeAbsoluteFrom(*v21, (_DWORD *)&v110 + 1),
            v23 = LH_ERROR_to_VERROR(v24),
            (v23 & 0x80000000) != 0)
        || (v25 = LDOTreeNode_ComputeAbsoluteTo(*v21, &v110), v23 = LH_ERROR_to_VERROR(v25), (v23 & 0x80000000) != 0))
      {
LABEL_115:
        UTF8Char = v23;
        goto LABEL_116;
      }
      v26 = v110;
      v27 = HIDWORD(v110);
      Type = LDOObject_GetType(*v21, (uint64_t *)&__s1);
      UTF8Char = LH_ERROR_to_VERROR(Type);
      if ((UTF8Char & 0x80000000) != 0)
        goto LABEL_116;
      if (!strcmp(__s1, "TOKEN_ALPHA"))
      {
        UTF8Char = utf8_getUTF8Char((uint64_t)__s, 0, v17);
        if ((UTF8Char & 0x80000000) != 0)
          goto LABEL_116;
        v100 = v26 - v27;
        if (v26 - v27 > (unsigned __int16)strlen(v17))
        {
          v30 = (_QWORD *)OOCAllocator_Realloc((uint64_t)(a1 + 28), 0, 64, &v107);
          if (!v107)
          {
            v103 = 0;
            __s2 = v17;
            v99 = (char *)v12;
            v102 = 0;
            v31 = 0;
            v101 = 0;
            v32 = 0;
            NextUtf8Offset = 0;
            *v30 = *v21;
            v34 = (_QWORD *)(v20 + 48 * v98);
            *v34 = 8;
            v34[1] = v30;
            v34[2] = v30 + 1;
            v35 = __s;
            while (1)
            {
              v36 = (uint64_t)v35;
              v105 = NextUtf8Offset;
              v17 = __s2;
              UTF8Char = utf8_getUTF8Char(v36, NextUtf8Offset, __s2);
              if ((UTF8Char & 0x80000000) != 0)
              {
                v12 = (uint64_t)v99;
                goto LABEL_116;
              }
              v37 = strlen(__s2);
              v38 = isEnglishLetter(__s2);
              if (!(v38 | v32))
                break;
              if (v32 == 1 && !v38)
              {
                v39 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), v99, "TOKEN", "TOKEN_ALPHA", &v108);
                v40 = LH_ERROR_to_VERROR(v39);
                v35 = __s;
                if ((v40 & 0x80000000) != 0)
                  goto LABEL_110;
                LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                UTF8Char = LH_ERROR_to_VERROR(v41);
                if ((UTF8Char & 0x80000000) != 0)
                  goto LABEL_111;
                v42 = v102;
                v43 = (unint64_t)v102 - v103;
                v44 = (((unint64_t)v102 - v103) >> 3) + 1;
                if (v44 > v31)
                {
                  v45 = 2 * v31;
                  if (2 * v31 >= v31 + 1000000)
                    v45 = v31 + 1000000;
                  if (v45 > v44)
                    v44 = v45;
                  if (v44 <= 8)
                    v46 = 8;
                  else
                    v46 = v44;
                  v47 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v46, &v107);
                  if (v107)
                    goto LABEL_111;
                  v103 = v47;
                  v42 = (_QWORD *)(v47 + (v43 & 0x7FFFFFFF8));
                  v31 = v46;
                }
                *v42 = v108;
                v48 = v42 + 1;
                v99[2] = 0;
                *(_WORD *)v99 = 0;
                v49 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), __s2, "TOKEN", "TOKEN_ALPHA", &v108);
                v40 = LH_ERROR_to_VERROR(v49);
                if ((v40 & 0x80000000) != 0)
                  goto LABEL_110;
                LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                UTF8Char = LH_ERROR_to_VERROR(v50);
                if ((UTF8Char & 0x80000000) != 0)
                  goto LABEL_111;
                v51 = v48;
                v52 = (unint64_t)v48 - v103;
                v53 = (v52 >> 3) + 1;
                if (v53 > v31)
                {
                  v54 = 2 * v31;
                  if (2 * v31 >= v31 + 1000000)
                    v54 = v31 + 1000000;
                  if (v54 > v53)
                    v53 = v54;
                  if (v53 <= 8)
                    v55 = 8;
                  else
                    v55 = v53;
                  v56 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v55, &v107);
                  if (v107)
                    goto LABEL_111;
                  v103 = v56;
                  v51 = (_QWORD *)(v56 + (v52 & 0x7FFFFFFF8));
                  v31 = v55;
                }
                v32 = 0;
                *v51 = v108;
                v102 = v51 + 1;
                v57 = v101 + 2;
                goto LABEL_77;
              }
              v65 = v105;
              v66 = v105 + v37;
              v67 = !v38;
              if (v32 != 1)
                v67 = 1;
              v35 = __s;
              if (v67)
              {
                if (v32 || !v38)
                  goto LABEL_96;
                *v99 = 0;
                strcat(v99, __s2);
                if (v66 == v100)
                {
                  v76 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), v99, "TOKEN", "TOKEN_ALPHA", &v108);
                  v40 = LH_ERROR_to_VERROR(v76);
                  if ((v40 & 0x80000000) != 0)
                  {
LABEL_110:
                    UTF8Char = v40;
LABEL_111:
                    v12 = (uint64_t)v99;
                    v17 = __s2;
                    goto LABEL_116;
                  }
                  LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                  UTF8Char = LH_ERROR_to_VERROR(v77);
                  if ((UTF8Char & 0x80000000) != 0)
                    goto LABEL_111;
                  v78 = v102;
                  v79 = (unint64_t)v102 - v103;
                  v80 = (((unint64_t)v102 - v103) >> 3) + 1;
                  if (v80 > v31)
                  {
                    v81 = 2 * v31;
                    if (2 * v31 >= v31 + 1000000)
                      v81 = v31 + 1000000;
                    if (v81 > v80)
                      v80 = v81;
                    if (v80 <= 8)
                      v82 = 8;
                    else
                      v82 = v80;
                    v83 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v82, &v107);
                    if (v107)
                      goto LABEL_111;
                    v103 = v83;
                    v78 = (_QWORD *)(v83 + (v79 & 0x7FFFFFFF8));
                    v31 = v82;
                  }
                  *v78 = v108;
                  v102 = v78 + 1;
                  ++v101;
                  v99[2] = 0;
                  *(_WORD *)v99 = 0;
                }
              }
              else
              {
                strcat(v99, __s2);
                if (v66 == v100)
                {
                  v68 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), v99, "TOKEN", "TOKEN_ALPHA", &v108);
                  v40 = LH_ERROR_to_VERROR(v68);
                  if ((v40 & 0x80000000) != 0)
                    goto LABEL_110;
                  LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                  UTF8Char = LH_ERROR_to_VERROR(v69);
                  if ((UTF8Char & 0x80000000) != 0)
                    goto LABEL_111;
                  v70 = v102;
                  v71 = (unint64_t)v102 - v103;
                  v72 = (((unint64_t)v102 - v103) >> 3) + 1;
                  if (v72 > v31)
                  {
                    v73 = 2 * v31;
                    if (2 * v31 >= v31 + 1000000)
                      v73 = v31 + 1000000;
                    if (v73 > v72)
                      v72 = v73;
                    if (v72 <= 8)
                      v74 = 8;
                    else
                      v74 = v72;
                    v75 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v74, &v107);
                    if (v107)
                      goto LABEL_111;
                    v103 = v75;
                    v70 = (_QWORD *)(v75 + (v71 & 0x7FFFFFFF8));
                    v31 = v74;
                  }
                  v32 = 0;
                  *v70 = v108;
                  v102 = v70 + 1;
                  ++v101;
                  v99[2] = 0;
                  *(_WORD *)v99 = 0;
                  goto LABEL_95;
                }
              }
              v32 = 1;
LABEL_95:
              v65 = v105;
LABEL_96:
              NextUtf8Offset = utf8_GetNextUtf8Offset(v35, v65);
              if (NextUtf8Offset >= v100)
              {
                v84 = v20 + 48 * v98;
                *(_DWORD *)(v84 + 24) = v31;
                *(_DWORD *)(v84 + 28) = 0;
                *(_QWORD *)(v84 + 32) = v103;
                *(_QWORD *)(v84 + 40) = v102;
                if ((((unint64_t)v102 - v103) >> 3) == (unsigned __int16)v101)
                {
                  v12 = (uint64_t)v99;
                  ++v98;
                  v17 = __s2;
                  goto LABEL_99;
                }
                v91 = 0;
                v12 = (uint64_t)v99;
                v17 = __s2;
LABEL_114:
                v23 = NNTNERROR(v91);
                goto LABEL_115;
              }
            }
            v58 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), __s2, "TOKEN", "TOKEN_ALPHA", &v108);
            v40 = LH_ERROR_to_VERROR(v58);
            if ((v40 & 0x80000000) != 0)
              goto LABEL_110;
            LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
            UTF8Char = LH_ERROR_to_VERROR(v59);
            if ((UTF8Char & 0x80000000) != 0)
              goto LABEL_111;
            v60 = v102;
            v61 = (unint64_t)v102 - v103;
            v62 = (((unint64_t)v102 - v103) >> 3) + 1;
            if (v62 <= v31)
            {
              v35 = __s;
            }
            else
            {
              v63 = 2 * v31;
              if (2 * v31 >= v31 + 1000000)
                v63 = v31 + 1000000;
              if (v63 > v62)
                v62 = v63;
              if (v62 <= 8)
                v31 = 8;
              else
                v31 = v62;
              v64 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v31, &v107);
              v35 = __s;
              if (v107)
                goto LABEL_111;
              v103 = v64;
              v60 = (_QWORD *)(v64 + (v61 & 0x7FFFFFFF8));
            }
            v32 = 0;
            *v60 = v108;
            v102 = v60 + 1;
            v57 = v101 + 1;
LABEL_77:
            v101 = v57;
            goto LABEL_95;
          }
          goto LABEL_116;
        }
      }
LABEL_99:
      v85 = LDOString_BorrowAllocator(v111);
      OOC_PlacementDeleteObject(v85, v111);
      ++v21;
    }
    while ((unint64_t)v21 < *(_QWORD *)(v4 + 88));
    if (!v98)
      goto LABEL_123;
    v86 = v98 - 1;
    v87 = v20;
    do
    {
      v88 = v86;
      v89 = LDO_ReplaceNodes(a1[33], v87, v87 + 24);
      UTF8Char = LH_ERROR_to_VERROR(v89);
      if ((UTF8Char & 0x80000000) != 0)
        break;
      v86 = v88 - 1;
      v87 += 48;
    }
    while (v88);
LABEL_116:
    if (v98)
    {
      v92 = 0;
      do
      {
        v93 = v20 + v92;
        *(_DWORD *)(v20 + v92) = 0;
        v94 = *(_QWORD *)(v20 + v92 + 8);
        if (v94)
        {
          OOCAllocator_Free((uint64_t)(a1 + 28), v94);
          *(_QWORD *)(v93 + 8) = 0;
        }
        *(_QWORD *)(v93 + 16) = 0;
        *(_DWORD *)(v93 + 24) = 0;
        v95 = *(_QWORD *)(v93 + 32);
        if (v95)
        {
          OOCAllocator_Free((uint64_t)(a1 + 28), v95);
          *(_QWORD *)(v93 + 32) = 0;
        }
        *(_QWORD *)(v20 + v92 + 40) = 0;
        v92 += 48;
      }
      while (48 * v98 != v92);
    }
  }
LABEL_123:
  v90 = 1;
LABEL_124:
  heap_Free(*(_QWORD **)(*a1 + 8), v12);
  if (v17)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v17);
    if ((v90 & 1) == 0)
      goto LABEL_127;
    goto LABEL_126;
  }
  if (v90)
LABEL_126:
    heap_Free(*(_QWORD **)(*a1 + 8), v20);
LABEL_127:
  if (v107)
    return NNTNERROR(0);
  return UTF8Char;
}

uint64_t applyIgtreeExpansion(uint64_t a1, __int16 *a2, char *a3, char **a4, _DWORD *a5)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  unsigned int v18;

  v10 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 1024);
  if (v10)
  {
    v15 = v10;
    *v10 = 0;
    v16 = fe_nntn_IGTR(a1, a2, a3, v10, a5, v12, v13, v14);
    if (*a5 == 1)
      strcpy(*a4, v15);
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v15);
    return v16;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v11, v12, v13, v14, v18);
    return NNTNERROR(10);
  }
}

uint64_t applyNNExpansion(_DWORD *a1, __int16 *a2, char **a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v18;

  v6 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 1024);
  if (v6)
  {
    v11 = v6;
    *v6 = 0;
    v12 = *(_QWORD *)(*(_QWORD *)a1 + 32);
    if (a1[210])
    {
      log_OutText(v12, (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FI prediction enabled", v8, v9, v10, 0);
      v16 = fe_mnc_nntn_Process((uint64_t)a1, a2, v11);
      if ((v16 & 0x80000000) != 0)
        log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FI prediction failed", v13, v14, v15, 0);
      else
        strcpy(*a3, v11);
    }
    else
    {
      log_OutText(v12, (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FI prediction is not enabled", v8, v9, v10, 0);
      v16 = 0;
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v11);
    return v16;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v7, v8, v9, v10, v18);
    return NNTNERROR(10);
  }
}

uint64_t writeExpandFuncNameToLDO(uint64_t a1, char *a2, uint64_t *a3, unsigned __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;

  v26 = 0;
  v11 = *a4;
  v24 = a4[1];
  v25 = v11;
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 4, 0, (uint64_t)"nntn : writeExpandFuncNameToLDO Begin (%s)", a6, a7, a8, *a3);
  v12 = LDO_AddLabelOnSubstring(*(_QWORD *)(a1 + 264), "TOKEN", "TOKEN", &v25, &v24, &v26);
  v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) != 0)
    goto LABEL_8;
  LDOObject_SetU32Attribute(v26, "_TTYPE", 6);
  v13 = LH_ERROR_to_VERROR(v17);
  if ((v13 & 0x80000000) != 0)
    goto LABEL_8;
  v18 = LDOObject_SetStringAttribute(v26, "TNTAG", a2);
  v13 = LH_ERROR_to_VERROR(v18);
  if ((v13 & 0x80000000) != 0)
    goto LABEL_8;
  v19 = LDOObject_SetStringAttribute(v26, "TNFUNCTAG", (char *)*a3);
  v13 = LH_ERROR_to_VERROR(v19);
  if ((v13 & 0x80000000) != 0)
    goto LABEL_8;
  v20 = LDOObject_SetStringAttribute(v26, "NORM", &byte_1DEBD87CE);
  v21 = LH_ERROR_to_VERROR(v20);
  if ((v21 & 0x80000000) == 0 && *(_WORD *)(a1 + 418))
  {
    v22 = LDOObject_SetStringAttribute(v26, "LANGMAP", *(char **)(a1 + 408));
    v13 = LH_ERROR_to_VERROR(v22);
LABEL_8:
    v21 = v13;
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 4, 0, (uint64_t)"nntn : writeExpandFuncNameToLDO End (%x) ", v14, v15, v16, v21);
  return v21;
}

uint64_t sortExpansionNNTN(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char **v15;
  uint64_t v16;
  __int16 *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v26;
  int v27;

  v27 = 0;
  v4 = heap_Alloc(*(_QWORD *)(*a1 + 8), 256);
  *(_QWORD *)(*(_QWORD *)(a2 + 16) + 56) = v4;
  v9 = *a1;
  if (!v4)
  {
    log_OutPublic(*(_QWORD *)(v9 + 32), (uint64_t)"FE_NNTN", 37000, 0, v5, v6, v7, v8, v26);
    v23 = NNTNERROR(10);
    v15 = 0;
    goto LABEL_22;
  }
  v10 = (char **)heap_Calloc(*(_QWORD **)(v9 + 8), 1, 8);
  v15 = v10;
  if (!v10)
  {
    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v11, v12, v13, v14, v26);
    v22 = NNTNERROR(10);
    goto LABEL_21;
  }
  v16 = *(_QWORD *)(a2 + 16);
  v17 = *(__int16 **)(v16 + 8);
  v18 = *(char **)(v16 + 56);
  *v10 = v18;
  v19 = *(char **)(a2 + 24);
  v20 = *(_QWORD *)(**(_QWORD **)(a2 + 16) + 96);
  v21 = **(unsigned __int16 **)(v20 + 8);
  if (v21 == 3)
  {
    v22 = applyIgtreeExpansion((uint64_t)a1, v17, *(char **)(a2 + 24), v10, &v27);
    if ((v22 & 0x80000000) != 0)
      goto LABEL_21;
    if (v27)
      goto LABEL_20;
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"IGtree found NOMATCH. Set user-defined func from domain def file.", v12, v13, v14, 0);
LABEL_17:
    *v15 = *(char **)(v20 + 16);
    goto LABEL_20;
  }
  if (v21 == 2)
    goto LABEL_17;
  if (v21 != 1)
  {
    v23 = 0;
    goto LABEL_22;
  }
  if (*((_DWORD *)a1 + 219) >= *((_DWORD *)a1 + 218))
  {
    strcpy(v18, "DefaultFunc");
    goto LABEL_20;
  }
  if (strcmp(*(const char **)(v20 + 16), "0"))
  {
    v22 = applyIgtreeExpansion((uint64_t)a1, v17, v19, v15, &v27);
    if ((v22 & 0x80000000) != 0)
      goto LABEL_21;
    if (v27)
    {
LABEL_20:
      v22 = writeExpandFuncNameToLDO((uint64_t)a1, v19, (uint64_t *)v15, (unsigned __int16 *)v17, v11, v12, v13, v14);
      goto LABEL_21;
    }
  }
  v22 = applyNNExpansion(a1, v17, v15);
  if ((v22 & 0x80000000) == 0)
  {
    ++*((_DWORD *)a1 + 219);
    goto LABEL_20;
  }
LABEL_21:
  v23 = v22;
LABEL_22:
  v24 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 56);
  if (v24)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v24);
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 56) = 0;
  }
  if (v15)
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v15);
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"sortExpansionNNTN_new : DoExpansions End (%x)", v12, v13, v14, v23);
  return v23;
}

uint64_t fe_nntn_tryLoading_NNTN_igModel(_WORD *a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t Str;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v25;
  int v26[2];
  uint64_t v27;
  int v28[2];
  _OWORD v29[16];
  char v30[136];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  memset(v29, 0, 240);
  *(_QWORD *)v26 = 0;
  v27 = 0;
  *a4 = 0;
  *(_QWORD *)v28 = 0;
  memset(v30, 0, 128);
  v29[15] = 0u;
  Str = paramc_ParamGetStr(*(_QWORD *)(a3 + 40), (uint64_t)"langcode", v28);
  if ((Str & 0x80000000) != 0
    || (Str = paramc_ParamGetStr(*(_QWORD *)(a3 + 40), (uint64_t)"fecfg", &v27), (Str & 0x80000000) != 0)
    || (__strcat_chk(),
        __strcat_chk(),
        __strcat_chk(),
        __strcat_chk(),
        Str = brokeraux_ComposeBrokerString(a3, v30, 1, 1, *(char **)v28, 0, 0, (char *)v29, 0x100uLL),
        (Str & 0x80000000) != 0)
    || (Str = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v29, "IGTR", 1031, (uint64_t *)v26),
        (Str & 0x80000000) != 0))
  {
    v21 = Str;
  }
  else
  {
    v16 = (char *)heap_Calloc(*(_QWORD **)(a3 + 8), 1, 1600);
    *a4 = v16;
    if (v16)
    {
      v21 = igtree_Init(a1, a2, *(uint64_t *)v26, v16);
      ssftriff_reader_CloseChunk(*(uint64_t *)v26);
      if ((v21 & 0x80001FFF) == 0x14)
      {
        ssftriff_reader_CloseChunk(*(uint64_t *)v26);
        v21 = 0;
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(a3 + 32), (uint64_t)"FE_NNTN", 37000, 0, v17, v18, v19, v20, v25);
      v21 = 2589990922;
    }
  }
  if (*(_QWORD *)v26)
  {
    v22 = ssftriff_reader_ObjClose(*(_QWORD **)v26, v9, v10, v11, v12, v13, v14, v15);
    if (v22 >= 0 || (int)v21 <= -1)
      return v21;
    else
      return v22;
  }
  return v21;
}

uint64_t fe_nntn_IGTR(uint64_t a1, __int16 *a2, char *a3, char *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int16 v19;
  _QWORD *v20;
  char *v21;
  char *v22;
  _DWORD *v23;
  uint64_t v24;
  _WORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int16 *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  signed int v45;
  BOOL v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v60;
  char *__src;
  _DWORD *v62;
  unsigned int v63;
  char *__dst;
  uint64_t v65;
  __int16 *v66;
  signed int v67;
  char *__s1;

  v8 = *(_QWORD *)(a1 + 936);
  __s1 = 0;
  v9 = *(_QWORD *)(a1 + 944);
  if (!v9)
  {
    log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 0, 0, (uint64_t)"IGTree model for nntn does not exist", a6, a7, a8, v60);
    return 0;
  }
  v15 = 2589990922;
  v16 = heap_Calloc(*(_QWORD **)(v8 + 8), 1, 8 * *(unsigned __int8 *)(v9 + 1296) - 8);
  if (v16)
  {
    v17 = v16;
    v18 = *(unsigned __int8 *)(v9 + 1296);
    v19 = v18 - 1;
    if (v18 != 1)
    {
      v66 = a2;
      v20 = (_QWORD *)v16;
      v21 = a3;
      v22 = a4;
      v23 = a5;
      v24 = v19;
      while (1)
      {
        v25 = (_WORD *)heap_Calloc(*(_QWORD **)(v8 + 8), 1, 65);
        *v20 = v25;
        if (!v25)
          break;
        *v25 = 61;
        ++v20;
        if (!--v24)
        {
          v18 = *(unsigned __int8 *)(v9 + 1296);
          a5 = v23;
          a4 = v22;
          a3 = v21;
          a2 = v66;
          v15 = 2589990922;
          goto LABEL_8;
        }
      }
      log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v26, v27, v28, v29, v60);
      v15 = 2589990922;
      goto LABEL_64;
    }
LABEL_8:
    v65 = *(_QWORD *)(a1 + 304);
    v67 = *(__int16 *)(a1 + 312);
    v30 = *(_QWORD *)(v9 + 1312);
    v31 = heap_Calloc(*(_QWORD **)(v8 + 8), 1, 2048);
    if (v31)
    {
      v36 = v18 - 1;
      if (v18 <= 1)
      {
        heap_Free(*(_QWORD **)(v8 + 8), v31);
        v15 = 0;
      }
      else
      {
        v63 = v18;
        __dst = (char *)v31;
        __src = a3;
        v62 = a5;
        v37 = a2;
        v38 = 0;
        while (strcmp(*(const char **)(v30 + v38), "token"))
        {
          v38 += 8;
          if (8 * (v18 - 1) == v38)
          {
            v39 = 0;
            goto LABEL_29;
          }
        }
        if ((*a2 & 0x80000000) == 0
          && ((v44 = (unsigned __int16)*a2, v45 = a2[1], v45 > (__int16)v44) ? (v46 = v45 <= v67) : (v46 = 0), v46))
        {
          v47 = __dst;
          strncpy(__dst, (const char *)(v65 + v44), (unsigned __int16)(v45 - v44));
        }
        else
        {
          v47 = __dst;
          *(_WORD *)__dst = 61;
        }
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v18, 3, v17, v47);
        if ((v39 & 0x80000000) != 0)
        {
LABEL_63:
          heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)__dst);
          v15 = v39;
          goto LABEL_64;
        }
LABEL_29:
        v48 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v48), "lchar"))
        {
          if (v36 == ++v48)
            goto LABEL_34;
        }
        nntn_feat_character(v65, v37, v67, -1, __dst);
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 2, v17, __dst);
        if ((v39 & 0x80000000) != 0)
          goto LABEL_63;
LABEL_34:
        v49 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v49), "llchar"))
        {
          if (v36 == ++v49)
            goto LABEL_39;
        }
        nntn_feat_character(v65, v37, v67, -2, __dst);
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 1, v17, __dst);
        if ((v39 & 0x80000000) != 0)
          goto LABEL_63;
LABEL_39:
        v50 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v50), "l3char"))
        {
          if (v36 == ++v50)
            goto LABEL_44;
        }
        nntn_feat_character(v65, v37, v67, -3, __dst);
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 0, v17, __dst);
        if ((v39 & 0x80000000) != 0)
          goto LABEL_63;
LABEL_44:
        v51 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v51), "rchar"))
        {
          if (v36 == ++v51)
            goto LABEL_49;
        }
        nntn_feat_character(v65, v37, v67, 1, __dst);
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 4, v17, __dst);
        if ((v39 & 0x80000000) != 0)
          goto LABEL_63;
LABEL_49:
        v52 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v52), "rrchar"))
        {
          if (v36 == ++v52)
            goto LABEL_54;
        }
        nntn_feat_character(v65, v37, v67, 2, __dst);
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 5, v17, __dst);
        if ((v39 & 0x80000000) != 0)
          goto LABEL_63;
LABEL_54:
        v53 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v53), "r3char"))
        {
          if (v36 == ++v53)
            goto LABEL_59;
        }
        nntn_feat_character(v65, v37, v67, 3, __dst);
        v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 6, v17, __dst);
        if ((v39 & 0x80000000) != 0)
          goto LABEL_63;
LABEL_59:
        v54 = a4;
        v55 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v55), "tnpattern"))
        {
          if (v36 == ++v55)
          {
            v15 = v39;
            v56 = (uint64_t)__dst;
            goto LABEL_72;
          }
        }
        v56 = (uint64_t)__dst;
        strcpy(__dst, __src);
        v15 = fe_nntn_IGTR_setFeature(v8, v30, v63, 7, v17, __dst);
LABEL_72:
        heap_Free(*(_QWORD **)(v8 + 8), v56);
        a5 = v62;
        a4 = v54;
        if ((v15 & 0x80000000) != 0)
          goto LABEL_64;
      }
      igtree_Process(v9, v17, &__s1);
      v40 = __s1;
      if (!strcmp(__s1, "NOMATCH"))
      {
        log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"No igtree rule matched", v41, v42, v43, 0);
        *a5 = 0;
      }
      else
      {
        strcpy(a4, v40);
        *a5 = 1;
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v32, v33, v34, v35, v60);
    }
LABEL_64:
    if (*(_BYTE *)(v9 + 1296) != 1)
    {
      v57 = (unsigned __int16)(*(unsigned __int8 *)(v9 + 1296) - 1);
      v58 = (uint64_t *)v17;
      do
      {
        if (*v58)
        {
          heap_Free(*(_QWORD **)(v8 + 8), *v58);
          *v58 = 0;
        }
        ++v58;
        --v57;
      }
      while (v57);
    }
    heap_Free(*(_QWORD **)(v8 + 8), v17);
  }
  return v15;
}

uint64_t fe_nntn_IGTR_isFeatureRequired(uint64_t a1, unsigned int a2, int a3, _WORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;

  if (a2 < 2)
    return 0;
  v6 = 0;
  v7 = a2 - 1;
  v8 = g_featureNames_0[a3];
  while (strcmp(*(const char **)(a1 + 8 * v6), v8))
  {
    if (v7 == ++v6)
      return 0;
  }
  *a4 = v6;
  return 1;
}

uint64_t fe_nntn_IGTR_setFeature(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, const char *a6)
{
  uint64_t result;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned __int16 v18;

  v18 = -1;
  result = fe_nntn_IGTR_isFeatureRequired(a2, a3, a4, &v18);
  if ((_DWORD)result)
  {
    if (!*a6)
    {
      result = 0;
      **(_WORD **)(a5 + 8 * v18) = 61;
      return result;
    }
    v10 = strlen(a6);
    v11 = v18;
    if (v10 <= 0x40)
    {
      v12 = *(char **)(a5 + 8 * v18);
      goto LABEL_8;
    }
    v12 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)(a5 + 8 * v18), (unsigned __int16)v10 + 1);
    if (v12)
    {
      *(_QWORD *)(a5 + 8 * v11) = v12;
LABEL_8:
      strcpy(v12, a6);
      return 0;
    }
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v13, v14, v15, v16, v17);
    return 2589990922;
  }
  return result;
}

uint64_t nntn_feat_character(uint64_t __s, __int16 *a2, signed int a3, int a4, _BYTE *a5)
{
  signed int v6;
  signed int v8;
  __int16 v10;
  char *v11;
  BOOL v12;

  v6 = *a2;
  if (v6 < 0)
    goto LABEL_6;
  v8 = a2[1];
  if (v6 >= v8 || v8 > a3)
    goto LABEL_6;
  v10 = a4;
  v11 = (char *)__s;
  if (a4 < 0)
  {
    if (!*a2)
      goto LABEL_6;
    do
    {
      __s = utf8_GetPreviousUtf8Offset((uint64_t)v11, v6);
      v6 = __s;
      v12 = (unsigned __int16)~v10++ == 0;
    }
    while (!v12 && (_DWORD)__s);
    goto LABEL_17;
  }
  if (a4)
  {
    v6 = v8 - 1;
    if (v8 - 1 == a3)
      goto LABEL_6;
    do
    {
      __s = utf8_GetNextUtf8Offset(v11, v6);
      v6 = __s;
      --v10;
    }
    while (v10 && (_DWORD)__s != a3);
LABEL_17:
    if (!v10)
      goto LABEL_20;
LABEL_6:
    *(_WORD *)a5 = 61;
    return __s;
  }
  v6 = 0;
LABEL_20:
  __s = utf8_getUTF8Char((uint64_t)v11, v6, a5);
  if ((__s & 0x80000000) != 0 || !*a5)
    goto LABEL_6;
  return __s;
}

uint64_t NNTNERROR(int a1)
{
  return a1 | 0x9A602000;
}

uint64_t fe_nntn_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2589990913;
  result = 0;
  *a2 = &ITokenizer;
  return result;
}

uint64_t NNTN_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2589990919;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t NNTN_ClassClose()
{
  return 0;
}

uint64_t NNTN_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _OWORD *v30;
  _OWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t Object;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t IDStrings;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _OWORD v77[16];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v75 = 0;
  v76 = 0;
  v73 = 0;
  v74 = 0;
  v5 = 2589990922;
  v71 = 0;
  v72 = 0;
  v69 = 0;
  v70 = 0;
  memset(v77, 0, sizeof(v77));
  if (!a5)
    return 2589990919;
  v68 = 0;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v76);
  if ((inited & 0x80000000) == 0)
  {
    inited = InitRsrcFunction(a1, a2, &v75);
    if ((inited & 0x80000000) == 0)
    {
      log_OutText(*(_QWORD *)(v76 + 32), (uint64_t)"FE_NNTN", 4, 0, (uint64_t)"nntn : ObjOpen Begin", v12, v13, v14, v65);
      v15 = heap_Calloc(*(_QWORD **)(v76 + 8), 1, 16);
      if (!v15)
      {
        log_OutPublic(*(_QWORD *)(v76 + 32), (uint64_t)"FE_NNTN", 21000, 0, v16, v17, v18, v19, v66);
LABEL_49:
        v60 = *(_QWORD *)(v76 + 32);
        v61 = "nntn : ObjOpen End (%x)";
        v66 = v5;
        v62 = 4;
LABEL_50:
        log_OutText(v60, (uint64_t)"FE_NNTN", v62, 0, (uint64_t)v61, v25, v26, v27, v66);
        return v5;
      }
      v20 = v15;
      *(_QWORD *)v15 = 0;
      *(_DWORD *)(v15 + 8) = 0;
      v21 = heap_Calloc(*(_QWORD **)(v76 + 8), 1, 968);
      if (!v21)
      {
LABEL_48:
        NNTN_loc_ObjClose(v76, (uint64_t *)v20, v22, v23, v24, v25, v26, v27);
        goto LABEL_49;
      }
      v28 = v21;
      *(_QWORD *)v20 = v21;
      v67 = v20;
      *(_DWORD *)(v20 + 8) = 58765;
      *(_QWORD *)v21 = v76;
      *(_QWORD *)(v21 + 8) = a3;
      v29 = v75;
      *(_QWORD *)(v21 + 16) = a4;
      *(_QWORD *)(v21 + 24) = v29;
      *(_QWORD *)(v21 + 32) = a1;
      *(_QWORD *)(v21 + 40) = a2;
      *(_QWORD *)(v21 + 96) = 0;
      v30 = (_OWORD *)(v21 + 96);
      *(_DWORD *)(v21 + 104) = 0;
      *(_QWORD *)(v21 + 120) = 0;
      v31 = (_OWORD *)(v21 + 120);
      *(_DWORD *)(v21 + 128) = 0;
      *(_QWORD *)(v21 + 152) = 0;
      *(_QWORD *)(v21 + 160) = 0;
      *(_QWORD *)(v21 + 176) = 0;
      *(_QWORD *)(v21 + 184) = "FE_NNTN";
      *(_WORD *)(v21 + 336) = 0;
      *(_QWORD *)(v21 + 344) = 0;
      *(_BYTE *)(v21 + 352) = 0;
      *(_DWORD *)(v21 + 548) = 0;
      *(_QWORD *)(v21 + 552) = 0;
      *(_QWORD *)(v21 + 520) = 0;
      *(_WORD *)(v21 + 528) = 0;
      *(_QWORD *)(v21 + 536) = 0;
      *(_WORD *)(v21 + 544) = 0;
      *(_QWORD *)(v21 + 288) = 0;
      *(_DWORD *)(v21 + 296) = 0;
      *(_WORD *)(v21 + 608) = 257;
      *(_QWORD *)(v21 + 856) = 0;
      *(_QWORD *)(v21 + 888) = 0;
      *(_WORD *)(v21 + 280) = 32;
      if ((paramc_ParamGetUInt(*(_QWORD *)(v76 + 40), (uint64_t)"tokentninitstrlen", (unsigned int *)&v71 + 1) & 0x80000000) == 0)
        *(_WORD *)(v28 + 280) = WORD2(v71);
      *(_WORD *)(v28 + 282) = 5;
      if ((paramc_ParamGetUInt(*(_QWORD *)(v76 + 40), (uint64_t)"tokentnmaxpcreframeblocks", (unsigned int *)&v71 + 1) & 0x80000000) == 0)
        *(_WORD *)(v28 + 282) = WORD2(v71);
      *(_WORD *)(v28 + 284) = 20;
      if ((paramc_ParamGetUInt(*(_QWORD *)(v76 + 40), (uint64_t)"tokentnnumframesinblock", (unsigned int *)&v71 + 1) & 0x80000000) == 0)
        *(_WORD *)(v28 + 284) = WORD2(v71);
      v32 = nuance_pcre_ObjOpen(a3, a4, v28 + 136);
      if ((v32 & 0x80000000) != 0)
      {
        v59 = v32;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)v28 + 32), *(_QWORD *)(v28 + 184), 24021, 0, v33, v34, v35, v36, v66);
        v5 = v59;
LABEL_47:
        v20 = v67;
        goto LABEL_48;
      }
      Object = addIdentifier2List(v28, "x");
      if ((Object & 0x80000000) == 0)
      {
        if ((objc_GetObject(*(_QWORD *)(v76 + 48), (uint64_t)"FE_DCTLKP", &v73) & 0x80000000) != 0)
        {
          v64 = 24022;
        }
        else
        {
          v42 = v73;
          *(_QWORD *)(v28 + 88) = *(_QWORD *)(v73 + 8);
          *v30 = *(_OWORD *)(v42 + 16);
          if ((objc_GetObject(*(_QWORD *)(v76 + 48), (uint64_t)"FE_DEPES", &v72) & 0x80000000) == 0)
          {
            v43 = v72;
            *(_QWORD *)(v28 + 112) = *(_QWORD *)(v72 + 8);
            *v31 = *(_OWORD *)(v43 + 16);
            Object = objc_GetObject(*(_QWORD *)(v76 + 48), (uint64_t)"LINGDB", &v74);
            if ((Object & 0x80000000) == 0)
            {
              *(_QWORD *)(v28 + 64) = *(_QWORD *)(v74 + 8);
              IDStrings = FEData_ObjOpen_NNTN((uint64_t)a3, a4, (uint64_t *)v28, v23, v24, v25, v26, v27);
              v20 = v67;
              if ((IDStrings & 0x80000000) != 0)
                goto LABEL_56;
              IDStrings = FERuntimeData_ObjOpen((uint64_t *)v28, v45, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0)
                goto LABEL_56;
              IDStrings = FEFunctionMap_ObjOpen((uint64_t *)v28, v46, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0)
                goto LABEL_56;
              IDStrings = tokenizer_NNTN_ObjOpen((uint64_t *)v28, v47, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0)
                goto LABEL_56;
              IDStrings = textnormalizer_ObjOpen((uint64_t *)v28, v48, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0)
                goto LABEL_56;
              IDStrings = createIDStrings((_BYTE *)v28);
              if ((IDStrings & 0x80000000) != 0)
                goto LABEL_56;
              if (!*(_WORD *)(v28 + 336))
                goto LABEL_57;
              v49 = 0;
              do
              {
                log_OutText(*(_QWORD *)(*(_QWORD *)v28 + 32), *(_QWORD *)(v28 + 184), 5, 0, (uint64_t)"nntn : identifier=\"%s\"", v25, v26, v27, *(_QWORD *)(*(_QWORD *)(v28 + 344) + 8 * v49++));
                v51 = *(unsigned __int16 *)(v28 + 336);
              }
              while (v49 < v51);
              if (!*(_WORD *)(v28 + 336))
              {
LABEL_57:
                log_OutPublic(*(_QWORD *)(*(_QWORD *)v28 + 32), (uint64_t)"FE_NNTN", 24024, 0, v24, v25, v26, v27, v66);
                v5 = 2589990912;
                goto LABEL_48;
              }
              IDStrings = FEData_blockData_loadDataFiles_NNTN(v28, v51, *(_QWORD *)(v28 + 344), v50, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0 || (IDStrings = getFECFGInfo(v28), (IDStrings & 0x80000000) != 0))
              {
LABEL_56:
                v5 = IDStrings;
                goto LABEL_48;
              }
              v52 = *(_QWORD *)v28;
              *(_QWORD *)(v28 + 848) = *(_QWORD *)v28;
              *(_DWORD *)(v28 + 876) = 0;
              if (!*(_DWORD *)(v28 + 840))
                goto LABEL_35;
              Object = nn_word_lkp_GetInterface(1u, &v68);
              if ((Object & 0x80000000) == 0)
              {
                *(_QWORD *)(v28 + 888) = v68;
                *(_QWORD *)(v28 + 896) = safeh_GetNullHandle();
                *(_QWORD *)(v28 + 904) = v53;
                *(_QWORD *)(v28 + 912) = safeh_GetNullHandle();
                *(_QWORD *)(v28 + 920) = v54;
                Object = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _WORD *, uint64_t, uint64_t))(v68 + 16))(*(_QWORD *)(v28 + 896), *(_QWORD *)(v28 + 904), "nntn", a3, a4, v28 + 912);
                if ((Object & 0x80000000) == 0)
                {
                  inited = fi_model_getBrokerString_0(*(_QWORD *)v28, (char *)v77);
                  if ((inited & 0x80000000) == 0)
                  {
                    v55 = fi_init(a3, a4, a1, a2, &v70, 0, (uint64_t)v77, (uint64_t)"FINN", 1, 0);
                    if ((v55 & 0x80000000) != 0)
                    {
                      v5 = v55;
                      v60 = *(_QWORD *)(*(_QWORD *)v28 + 32);
                      v61 = "create FI model failed";
                      goto LABEL_61;
                    }
                    *(_QWORD *)(v28 + 856) = v70;
                    v52 = *(_QWORD *)v28;
LABEL_35:
                    *(_QWORD *)(v28 + 936) = v52;
                    if (!*(_DWORD *)(v28 + 928))
                    {
LABEL_38:
                      *(_QWORD *)(v28 + 192) = heap_Alloc;
                      *(_QWORD *)(v28 + 200) = heap_Calloc;
                      *(_QWORD *)(v28 + 208) = heap_Realloc;
                      *(_QWORD *)(v28 + 216) = heap_Free;
                      v57 = OOCAllocator_Con(v28 + 224, (_OWORD *)(v28 + 192), *(_QWORD *)(v52 + 8));
                      v5 = LH_ERROR_to_VERROR(v57);
                      if ((v5 & 0x80000000) == 0)
                      {
                        *(_QWORD *)(v28 + 264) = 0;
                        v20 = v67;
                        if (*(_DWORD *)(v28 + 840))
                        {
                          v5 = load_lua_code(v28, &v71);
                          if ((v5 & 0x80000000) != 0)
                            goto LABEL_48;
                        }
LABEL_55:
                        *(_QWORD *)a5 = v20;
                        *(_DWORD *)(a5 + 8) = 58764;
                        goto LABEL_49;
                      }
                      log_OutPublic(*(_QWORD *)(*(_QWORD *)v28 + 32), (uint64_t)"FE_NNTN", 24024, 0, v58, v25, v26, v27, v66);
                      goto LABEL_47;
                    }
                    v56 = fe_nntn_tryLoading_NNTN_igModel(a3, a4, v52, &v69);
                    if ((v56 & 0x80000000) == 0)
                    {
                      *(_QWORD *)(v28 + 944) = v69;
                      v52 = *(_QWORD *)v28;
                      goto LABEL_38;
                    }
                    v5 = v56;
                    v60 = *(_QWORD *)(*(_QWORD *)v28 + 32);
                    v61 = "create Igtree model failed";
LABEL_61:
                    v62 = 5;
                    goto LABEL_50;
                  }
                  return inited;
                }
              }
            }
            goto LABEL_46;
          }
          v64 = 24023;
        }
        v20 = v67;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)v28 + 32), *(_QWORD *)(v28 + 184), v64, 0, v38, v39, v40, v41, v66);
        v5 = 0;
        goto LABEL_55;
      }
LABEL_46:
      v5 = Object;
      goto LABEL_47;
    }
  }
  return inited;
}

uint64_t NNTN_ObjClose(uint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;

  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  v9 = *a1;
  v10 = *(_QWORD *)(*a1 + 888);
  if (v10)
  {
    (*(void (**)(_QWORD, _QWORD))(v10 + 24))(*(_QWORD *)(v9 + 912), *(_QWORD *)(v9 + 920));
    *(_QWORD *)(v9 + 888) = 0;
  }
  if (*(_DWORD *)(v9 + 840))
  {
    v3 = *(uint64_t **)(v9 + 856);
    if (v3)
    {
      fi_deinit(*(_QWORD *)v9, *(_QWORD *)(v9 + 24), v3);
      *(_QWORD *)(v9 + 856) = 0;
    }
    if (*(_DWORD *)(v9 + 864) || *(_DWORD *)(v9 + 868))
      *(_QWORD *)(v9 + 864) = 0;
  }
  if (*(_DWORD *)(v9 + 928))
  {
    v11 = *(_QWORD *)(v9 + 944);
    if (v11)
    {
      igtree_Deinit(*(_QWORD *)v9, v11, (uint64_t)v3, v4, v5, v6, v7, v8);
      heap_Free(*(_QWORD **)(*(_QWORD *)v9 + 8), *(_QWORD *)(v9 + 944));
      *(_QWORD *)(v9 + 944) = 0;
    }
  }
  v12 = *(_QWORD *)(v9 + 272);
  if (v12)
  {
    OOC_PlacementDeleteObject(v9 + 224, v12);
    *(_QWORD *)(v9 + 272) = 0;
  }
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v9 + 224));
  v13 = *(_QWORD *)(v9 + 184);
  log_OutText(*(_QWORD *)(*(_QWORD *)v9 + 32), v13, 4, 0, (uint64_t)"nntn : ObjClose Begin", v14, v15, v16, v36);
  v17 = *(_QWORD *)v9;
  v25 = FEData_blockData_unloadDataFiles((_QWORD *)v9, v18, v19, v20, v21, v22, v23, v24);
  NNTN_loc_ObjClose(v17, a1, v26, v27, v28, v29, v30, v31);
  log_OutText(*(_QWORD *)(v17 + 32), v13, 4, 0, (uint64_t)"nntn : ObjClose End (%x)", v32, v33, v34, v25);
  return v25;
}

uint64_t NNTN_ObjReopen(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t IDStrings;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t DataFiles_NNTN;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t BrokerString_0;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  int v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  _OWORD v39[16];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v36 = 0;
  v37 = 0;
  memset(v39, 0, sizeof(v39));
  v35 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0)
    return TOKENTNERROR(8);
  v38 = 0;
  if ((safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
    return TOKENTNERROR(8);
  v3 = *a1;
  v4 = *(_QWORD *)(v3 + 344);
  if (v4)
  {
    if (*(_WORD *)(v3 + 336))
    {
      v5 = 0;
      do
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)v3 + 8), *(_QWORD *)(*(_QWORD *)(v3 + 344) + 8 * v5));
        *(_QWORD *)(*(_QWORD *)(v3 + 344) + 8 * v5++) = 0;
      }
      while (v5 < *(unsigned __int16 *)(v3 + 336));
      v4 = *(_QWORD *)(v3 + 344);
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)v3 + 8), v4);
    *(_QWORD *)(v3 + 344) = 0;
    *(_WORD *)(v3 + 336) = 0;
    *(_BYTE *)(v3 + 352) = 0;
    *(_WORD *)(v3 + 608) = 257;
  }
  IDStrings = addIdentifier2List(v3, "x");
  if ((IDStrings & 0x80000000) != 0)
    goto LABEL_47;
  IDStrings = createIDStrings((_BYTE *)v3);
  if ((IDStrings & 0x80000000) != 0)
    goto LABEL_47;
  if (!*(_QWORD *)(v3 + 344))
    return 6;
  if (*(_WORD *)(v3 + 336))
  {
    v13 = 0;
    do
      log_OutText(*(_QWORD *)(*(_QWORD *)v3 + 32), *(_QWORD *)(v3 + 184), 5, 0, (uint64_t)"nntn : identifier=\"%s\"", v10, v11, v12, *(_QWORD *)(*(_QWORD *)(v3 + 344) + 8 * v13++));
    while (v13 < *(unsigned __int16 *)(v3 + 336));
  }
  v14 = *(_QWORD *)(v3 + 888);
  if (v14)
  {
    v38 = *(_QWORD *)(v3 + 888);
    (*(void (**)(_QWORD, _QWORD))(v14 + 24))(*(_QWORD *)(v3 + 912), *(_QWORD *)(v3 + 920));
    *(_QWORD *)(v3 + 888) = 0;
  }
  if (*(_DWORD *)(v3 + 840))
  {
    v7 = *(uint64_t **)(v3 + 856);
    if (v7)
    {
      fi_deinit(*(_QWORD *)v3, *(_QWORD *)(v3 + 24), v7);
      *(_QWORD *)(v3 + 856) = 0;
    }
    if (*(_DWORD *)(v3 + 864) || *(_DWORD *)(v3 + 868))
      *(_QWORD *)(v3 + 864) = 0;
  }
  if (*(_DWORD *)(v3 + 928))
  {
    v15 = *(_QWORD *)(v3 + 944);
    if (v15)
    {
      igtree_Deinit(*(_QWORD *)v3, v15, (uint64_t)v7, v8, v9, v10, v11, v12);
      heap_Free(*(_QWORD **)(*(_QWORD *)v3 + 8), *(_QWORD *)(v3 + 944));
      *(_QWORD *)(v3 + 944) = 0;
    }
    if (*(_QWORD *)(v3 + 936))
      *(_QWORD *)(v3 + 936) = 0;
  }
  v16 = *(_QWORD *)(v3 + 288);
  if (v16)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)v3 + 8), v16);
    *(_QWORD *)(v3 + 288) = 0;
  }
  IDStrings = FEData_blockData_unloadUnusedDataFiles((_QWORD *)v3, *(unsigned __int16 *)(v3 + 336), *(_QWORD *)(v3 + 344), v8, v9, v10, v11, v12);
  if ((IDStrings & 0x80000000) != 0)
    goto LABEL_47;
  IDStrings = getFECFGInfo(v3);
  if ((IDStrings & 0x80000000) != 0)
    goto LABEL_47;
  if (!*(_WORD *)(v3 + 336))
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)v3 + 32), (uint64_t)"FE_NNTN", 24024, 0, v18, v19, v20, v21, v34);
    return 2589990912;
  }
  DataFiles_NNTN = FEData_blockData_loadDataFiles_NNTN(v3, *(unsigned __int16 *)(v3 + 336), *(_QWORD *)(v3 + 344), v17, v18, v19, v20, v21);
  if ((DataFiles_NNTN & 0x80000000) != 0)
    goto LABEL_48;
  v23 = *(_QWORD *)v3;
  *(_QWORD *)(v3 + 848) = *(_QWORD *)v3;
  if (!*(_DWORD *)(v3 + 840))
    goto LABEL_40;
  IDStrings = nn_word_lkp_GetInterface(1u, &v38);
  if ((IDStrings & 0x80000000) != 0
    || (*(_QWORD *)(v3 + 888) = v38,
        *(_QWORD *)(v3 + 896) = safeh_GetNullHandle(),
        *(_QWORD *)(v3 + 904) = v24,
        *(_QWORD *)(v3 + 912) = safeh_GetNullHandle(),
        *(_QWORD *)(v3 + 920) = v25,
        IDStrings = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD, uint64_t))(v38 + 16))(*(_QWORD *)(v3 + 896), *(_QWORD *)(v3 + 904), "nntn", *(_QWORD *)(v3 + 8), *(_QWORD *)(v3 + 16), v3 + 912), (IDStrings & 0x80000000) != 0))
  {
LABEL_47:
    DataFiles_NNTN = IDStrings;
    goto LABEL_48;
  }
  BrokerString_0 = fi_model_getBrokerString_0(*(_QWORD *)v3, (char *)v39);
  if ((BrokerString_0 & 0x80000000) != 0)
    return BrokerString_0;
  DataFiles_NNTN = fi_init(*(_WORD **)(v3 + 8), *(_QWORD *)(v3 + 16), *(_WORD **)(v3 + 32), *(_QWORD *)(v3 + 40), &v37, 0, (uint64_t)v39, (uint64_t)"FINN", 1, 0);
  if ((DataFiles_NNTN & 0x80000000) != 0)
  {
    v32 = *(_QWORD *)(*(_QWORD *)v3 + 32);
    v33 = "create FI model failed";
    goto LABEL_57;
  }
  *(_QWORD *)(v3 + 856) = v37;
  v23 = *(_QWORD *)v3;
LABEL_40:
  *(_QWORD *)(v3 + 936) = v23;
  if (*(_DWORD *)(v3 + 928))
  {
    DataFiles_NNTN = fe_nntn_tryLoading_NNTN_igModel(*(_WORD **)(v3 + 8), *(_QWORD *)(v3 + 16), v23, &v36);
    if ((DataFiles_NNTN & 0x80000000) == 0)
    {
      *(_QWORD *)(v3 + 944) = v36;
      goto LABEL_43;
    }
    v32 = *(_QWORD *)(*(_QWORD *)v3 + 32);
    v33 = "create Igtree model failed";
LABEL_57:
    log_OutText(v32, (uint64_t)"FE_NNTN", 5, 0, (uint64_t)v33, v27, v28, v29, v34);
    return DataFiles_NNTN;
  }
LABEL_43:
  if (*(_DWORD *)(v3 + 840))
  {
    DataFiles_NNTN = load_lua_code(v3, &v35);
    if ((DataFiles_NNTN & 0x80000000) != 0)
    {
LABEL_48:
      v31 = *(_QWORD *)(v3 + 272);
      if (v31)
      {
        OOC_PlacementDeleteObject(v3 + 224, v31);
        *(_QWORD *)(v3 + 272) = 0;
      }
      kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v3 + 224));
    }
  }
  return DataFiles_NNTN;
}

uint64_t NNTN_ProcessStart(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  unsigned int v18;

  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  v6 = *a1;
  log_OutText(*(_QWORD *)(*(_QWORD *)*a1 + 32), *(_QWORD *)(*a1 + 184), 4, 0, (uint64_t)"nntn : ProcessStart Begin", v3, v4, v5, v17);
  if (*(_WORD *)(v6 + 336))
  {
    v15 = nuance_pcre_Init(*(_QWORD **)(v6 + 136), *(_QWORD *)(v6 + 144), *(unsigned __int16 *)(v6 + 282), *(_WORD *)(v6 + 284));
    if ((v15 & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(*(_QWORD *)v6 + 32), *(_QWORD *)(v6 + 184), 24051, 0, v11, v12, v13, v14, v18);
    log_OutText(*(_QWORD *)(*(_QWORD *)v6 + 32), *(_QWORD *)(v6 + 184), 4, 0, (uint64_t)"nntn : ProcessStart End (%x)", v12, v13, v14, v15);
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)v6 + 32), (uint64_t)"FE_NNTN", 24024, 0, v7, v8, v9, v10, v18);
    return 2589990912;
  }
  return v15;
}

uint64_t NNTN_Process(uint64_t *a1, int a2, _QWORD *a3, int a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t inited;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  unsigned int i;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;

  v55 = 0;
  v54 = 0;
  v53 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  v12 = (_QWORD **)*a1;
  log_OutText((*v12)[4], (uint64_t)v12[23], 4, 0, (uint64_t)"NNTN : Process Begin", v9, v10, v11, v51);
  v12[9] = a3;
  *((_DWORD *)v12 + 20) = a4;
  *((_DWORD *)v12 + 219) = 0;
  *((_DWORD *)v12 + 137) = log_GetLogLevel((*v12)[4]) > 4;
  v12[33] = 0;
  v13 = LingDBHasSentence((uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], &v55);
  if ((v13 & 0x80000000) == 0)
  {
    v14 = (uint64_t *)(v12 + 33);
    if (!v55)
      goto LABEL_46;
    inited = initLDO((uint64_t)(v12 + 28), v12 + 33);
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = importFromLingDB((uint64_t)*v12, (uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], (uint64_t *)v12 + 33);
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    v13 = 2589990922;
    v16 = LDO_ComputeText(*v14, &v54);
    if ((LH_ERROR_to_VERROR(v16) & 0x80000000) != 0)
      goto LABEL_52;
    v12[38] = (_QWORD *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v54);
    *((_WORD *)v12 + 156) = LHString_Length(v54);
    log_OutText((*v12)[4], (uint64_t)v12[23], 5, 0, (uint64_t)"<LOGFE> processing sentence : _%s_", v17, v18, v19, (uint64_t)v12[38]);
    v20 = heap_Calloc((_QWORD *)(*v12)[1], 1, *((unsigned __int16 *)v12 + 156) + 1);
    v12[69] = (_QWORD *)v20;
    if (!v20)
      goto LABEL_52;
    *((_WORD *)v12 + 157) = 1;
    if (*((_WORD *)v12 + 156))
    {
      v21 = 0;
      while (utf8_strchr(g_szSpace, (unsigned __int8 *)v12[38] + (unsigned __int16)v21))
      {
        v21 += utf8_determineUTF8CharLength(*((unsigned __int8 *)v12[38] + (unsigned __int16)v21));
        v22 = *((unsigned __int16 *)v12 + 156);
        if (v22 <= (unsigned __int16)v21)
          goto LABEL_16;
      }
      v22 = *((unsigned __int16 *)v12 + 156);
LABEL_16:
      if (v22 > (unsigned __int16)v21)
      {
        do
        {
          v21 = (unsigned __int16)v21;
          if (utf8_strchr(g_szSpace, (unsigned __int8 *)v12[38] + (unsigned __int16)v21))
          {
            ++*((_WORD *)v12 + 157);
            for (i = *((unsigned __int8 *)v12[38] + (unsigned __int16)v21);
                  ;
                  i = *((unsigned __int8 *)v12[38] + (unsigned __int16)v21))
            {
              v21 += utf8_determineUTF8CharLength(i);
              if (*((unsigned __int16 *)v12 + 156) <= (unsigned __int16)v21
                || !utf8_strchr(g_szSpace, (unsigned __int8 *)v12[38] + (unsigned __int16)v21))
              {
                break;
              }
            }
          }
          else
          {
            LOWORD(v21) = v21 + utf8_determineUTF8CharLength(*((unsigned __int8 *)v12[38] + (unsigned __int16)v21));
          }
        }
        while (*((unsigned __int16 *)v12 + 156) > (unsigned __int16)v21);
      }
    }
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 49));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 51));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 61));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 70));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 72));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 74));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 63));
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initAlignmentData((uint64_t)v12);
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initMatchList((uint64_t)v12);
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    inited = initSolutionList((uint64_t)v12);
    if ((inited & 0x80000000) != 0)
      goto LABEL_51;
    v25 = heap_Calloc((_QWORD *)(*v12)[1], 1, 40);
    v12[40] = (_QWORD *)v25;
    v30 = (uint64_t)*v12;
    if (v25)
    {
      v31 = heap_Calloc(*(_QWORD **)(v30 + 8), 1, 48);
      v12[41] = (_QWORD *)v31;
      if (v31)
      {
        if (*((_DWORD *)v12 + 238) == 1)
        {
          inited = updateLDOTreeNode_CHN((uint64_t *)v12, &v53);
          if ((inited & 0x80000000) != 0)
            goto LABEL_51;
          if (!v53)
          {
            *a5 = 1;
            goto LABEL_51;
          }
        }
        inited = nntn_AllInOneLoop((uint64_t)v12, v32, v33, v34, v26, v27, v28, v29);
        if ((inited & 0x80000000) == 0)
        {
          v38 = (uint64_t)v12[34];
          if (!v38)
          {
            log_OutText((*v12)[4], (uint64_t)v12[23], 0, 0, (uint64_t)"NNTN : error - pLuaVMLDO is NULL", v35, v36, v37, v52);
            v13 = 2589990918;
            goto LABEL_52;
          }
          v39 = LuaVMLDO_RunFunction(v38, (uint64_t)"run", *v14);
          inited = LH_ERROR_to_VERROR(v39);
          if ((inited & 0x80000000) == 0)
          {
            if (*((_DWORD *)v12 + 137) != 1
              || (inited = dumpTokenRecordsInLingDB(v12, (uint64_t)"At End of Processing", 1, v40, v41, v42, v43, v44),
                  (inited & 0x80000000) == 0))
            {
              inited = exportToLingDB((uint64_t)*v12, (uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], (uint64_t)(v12 + 28), (uint64_t)v12[33], 1, 1);
              if ((inited & 0x80000000) == 0)
              {
                v13 = replaceBasicTokensWithTokenIntTnInLingDB((uint64_t)*v12, (uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], (uint64_t)v12[33], (uint64_t)v12[23]);
                if ((v13 & 0x80000000) != 0)
                {
LABEL_52:
                  if (v54)
                  {
                    OOC_PlacementDeleteObject((uint64_t)(v12 + 28), v54);
                    v54 = 0;
                  }
                  if (*v14)
                  {
                    deinitLDO((uint64_t)(v12 + 28), *v14);
                    v12[33] = 0;
                  }
                  v45 = (uint64_t)v12[69];
                  if (v45)
                  {
                    heap_Free((_QWORD *)(*v12)[1], v45);
                    v12[69] = 0;
                  }
                  clearStrRes(*v12, (uint64_t)(v12 + 49));
                  clearStrRes(*v12, (uint64_t)(v12 + 51));
                  clearStrRes(*v12, (uint64_t)(v12 + 61));
                  clearStrRes(*v12, (uint64_t)(v12 + 70));
                  clearStrRes(*v12, (uint64_t)(v12 + 72));
                  clearStrRes(*v12, (uint64_t)(v12 + 74));
                  clearStrRes(*v12, (uint64_t)(v12 + 63));
                  freeAlignmentData(v12);
                  freeMatchList(v12);
                  freeSolutionList(v12);
                  v49 = (uint64_t)v12[40];
                  if (v49)
                  {
                    heap_Free((_QWORD *)(*v12)[1], v49);
                    v12[40] = 0;
                  }
                  v50 = (uint64_t)v12[41];
                  if (v50)
                  {
                    heap_Free((_QWORD *)(*v12)[1], v50);
                    v12[41] = 0;
                  }
                  log_OutText((*v12)[4], (uint64_t)v12[23], 4, 0, (uint64_t)"nntn : Process End (%x)", v46, v47, v48, v13);
                  return v13;
                }
LABEL_46:
                *a5 = 1;
                goto LABEL_52;
              }
            }
          }
        }
LABEL_51:
        v13 = inited;
        goto LABEL_52;
      }
      v30 = (uint64_t)*v12;
    }
    log_OutPublic(*(_QWORD *)(v30 + 32), (uint64_t)v12[23], 24048, 0, v26, v27, v28, v29, v52);
    goto LABEL_52;
  }
  return v13;
}

uint64_t NNTN_ProcessEnd(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  v6 = *a1;
  log_OutText(*(_QWORD *)(*(_QWORD *)v6 + 32), *(_QWORD *)(v6 + 184), 4, 0, (uint64_t)"nntn : ProcessEnd Begin", v3, v4, v5, v12);
  v7 = nuance_pcre_DeInit(*(_QWORD **)(v6 + 136), *(_QWORD *)(v6 + 144));
  log_OutText(*(_QWORD *)(*(_QWORD *)v6 + 32), *(_QWORD *)(v6 + 184), 4, 0, (uint64_t)"nntn : ProcessEnd End (%x)", v8, v9, v10, v7);
  return 0;
}

uint64_t addIdentifier2List(uint64_t a1, char *__s2)
{
  uint64_t v4;
  const char **v5;
  uint64_t v6;
  const char **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unsigned int v19;

  v4 = *(unsigned __int16 *)(a1 + 336);
  if (*(_WORD *)(a1 + 336))
  {
    v5 = *(const char ***)(a1 + 344);
    v6 = *(unsigned __int16 *)(a1 + 336);
    v7 = v5;
    do
    {
      if (v5 && !strcmp(*v7, __s2))
        return 0;
      ++v7;
      --v6;
    }
    while (v6);
    v8 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 344), 8 * v4 + 8);
    if (v8)
      goto LABEL_9;
    goto LABEL_11;
  }
  v8 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 1, 8);
  if (!v8)
  {
LABEL_11:
    v17 = 2589990922;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 184), 24048, 0, v9, v10, v11, v12, v19);
    return v17;
  }
LABEL_9:
  *(_QWORD *)(a1 + 344) = v8;
  v13 = strlen(__s2);
  v14 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 1, (v13 + 1));
  v15 = *(unsigned __int16 *)(a1 + 336);
  *(_QWORD *)(*(_QWORD *)(a1 + 344) + 8 * v15) = v14;
  v16 = *(char **)(*(_QWORD *)(a1 + 344) + 8 * v15);
  if (!v16)
    goto LABEL_11;
  strcpy(v16, __s2);
  v17 = 0;
  ++*(_WORD *)(a1 + 336);
  return v17;
}

uint64_t createIDStrings(_BYTE *a1)
{
  uint64_t result;
  char *v3;
  uint64_t v4;
  int v5;
  char v6;
  char *v7;
  size_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  char *__s;
  char v15[16];
  __int128 v16;
  char v17[16];
  __int128 v18;
  char __s2[16];
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  __s = 0;
  *(_OWORD *)__s2 = 0u;
  v20 = 0u;
  *(_OWORD *)v17 = 0u;
  v18 = 0u;
  *(_OWORD *)v15 = 0u;
  v16 = 0u;
  result = paramc_ParamGet(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"langcode", &__s, 0);
  if ((result & 0x80000000) == 0)
  {
    v3 = __s;
    if (*__s)
    {
      v4 = 0;
      v5 = 0;
      do
      {
        v6 = v3[v4];
        v17[v4] = v6;
        __s2[v4] = v6;
        v4 = (unsigned __int16)++v5;
      }
      while (strlen(v3) > (unsigned __int16)v5);
    }
    strcpy(&__s2[2], "x");
    v17[3] = 0;
    if (*(_DWORD *)v17 == 6840675)
      __s2[1] = 110;
    result = paramc_ParamGet(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"voice", &__s, 0);
    if ((result & 0x80000000) == 0)
    {
      v7 = __s;
      v8 = strlen(__s);
      if (v8 <= 0x1A)
      {
        if (v8)
        {
          v9 = 0;
          v10 = 0;
          do
          {
            v15[v9] = v7[v9];
            v9 = (unsigned __int16)++v10;
            v8 = strlen(v7);
          }
          while (v8 > (unsigned __int16)v10);
        }
        v15[v8] = 0;
        if ((int)strlen(__s2) >= 1)
        {
          v11 = 0;
          do
          {
            __s2[(unsigned __int16)v11] = ssft_tolower(__s2[(unsigned __int16)v11]);
            ++v11;
          }
          while ((int)strlen(__s2) > (unsigned __int16)v11);
        }
        if ((int)strlen(v17) >= 1)
        {
          v12 = 0;
          do
          {
            v17[(unsigned __int16)v12] = ssft_tolower(v17[(unsigned __int16)v12]);
            ++v12;
          }
          while ((int)strlen(v17) > (unsigned __int16)v12);
        }
        if ((int)strlen(v15) >= 1)
        {
          v13 = 0;
          do
          {
            v15[(unsigned __int16)v13] = ssft_tolower(v15[(unsigned __int16)v13]);
            ++v13;
          }
          while ((int)strlen(v15) > (unsigned __int16)v13);
        }
        result = addIdentifier2List((uint64_t)a1, __s2);
        if ((result & 0x80000000) == 0)
        {
          a1[352] = a1[336];
          result = addIdentifier2List((uint64_t)a1, v17);
          if ((result & 0x80000000) == 0)
            return addIdentifier2List((uint64_t)a1, v15);
        }
      }
      else
      {
        return 2589990912;
      }
    }
  }
  return result;
}

uint64_t getFECFGInfo(uint64_t a1)
{
  uint64_t v2;
  const char *v4;
  char *v5;
  const char *v6;
  char *v7;
  int v8;
  const char *v9;
  char *v10;
  int v11;
  const char *v12;
  char *v13;
  int v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const char *v21;
  char *v22;
  const char *v23;
  char *v24;
  const char *v25;
  char *v26;
  const char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  char *v32;
  uint64_t v34;
  unsigned __int8 __c;
  char **__c_1;
  unsigned __int16 v37;

  v2 = 2589991940;
  v37 = -1;
  __c_1 = 0;
  __c = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nrpart_g2p", &__c_1, &v37, &__c) & 0x80000000) != 0)return 2589990912;
  if (v37 == 1 && __c_1 != 0)
  {
    v4 = *__c_1;
    v5 = strchr(*__c_1, __c);
    if (v5)
    {
      *v5 = 0;
      v4 = *__c_1;
    }
    *(_BYTE *)(a1 + 608) = atoi(v4);
  }
  v37 = -1;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nrpart_tn", &__c_1, &v37, &__c) & 0x80000000) != 0)return 2589990912;
  if (v37 == 1 && __c_1)
  {
    v6 = *__c_1;
    v7 = strchr(*__c_1, __c);
    if (v7)
    {
      *v7 = 0;
      v6 = *__c_1;
    }
    *(_BYTE *)(a1 + 609) = atoi(v6);
  }
  v37 = -1;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_nn_step", &__c_1, &v37, &__c) & 0x80000000) == 0)
  {
    v8 = v37;
    if (v37)
    {
      *(_DWORD *)(a1 + 864) = 0;
      if (v8 == 1 && __c_1)
      {
        v9 = *__c_1;
        v10 = strchr(*__c_1, __c);
        if (v10)
        {
          *v10 = 0;
          v9 = *__c_1;
        }
        *(_DWORD *)(a1 + 864) = (unsigned __int16)LH_atou(v9);
      }
      v37 = -1;
      if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_nn_vect", &__c_1, &v37, &__c) & 0x80000000) == 0)
      {
        v11 = v37;
        if (v37)
        {
          *(_DWORD *)(a1 + 868) = 0;
          if (v11 == 1 && __c_1)
          {
            v12 = *__c_1;
            v13 = strchr(*__c_1, __c);
            if (v13)
            {
              *v13 = 0;
              v12 = *__c_1;
            }
            *(_DWORD *)(a1 + 868) = (unsigned __int16)LH_atou(v12);
          }
          v37 = -1;
          if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_nn_max", &__c_1, &v37, &__c) & 0x80000000) == 0)
          {
            v14 = v37;
            if (v37)
            {
              *(_DWORD *)(a1 + 872) = 0;
              if (v14 == 1 && __c_1)
              {
                v15 = *__c_1;
                v16 = strchr(*__c_1, __c);
                if (v16)
                {
                  *v16 = 0;
                  v15 = *__c_1;
                }
                *(_DWORD *)(a1 + 872) = (unsigned __int16)LH_atou(v15);
              }
              *(_DWORD *)(a1 + 880) = 0;
              v37 = -1;
              if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_window_option", &__c_1, &v37, &__c) & 0x80000000) != 0|| (v20 = v37) == 0)
              {
                log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"Load nntn_window_option from CFG failed, use default 0.", v17, v18, v19, v34);
                v20 = v37;
              }
              if (v20 == 1 && __c_1)
              {
                v21 = *__c_1;
                v22 = strchr(*__c_1, __c);
                if (v22)
                {
                  *v22 = 0;
                  v21 = *__c_1;
                }
                *(_DWORD *)(a1 + 880) = (unsigned __int16)LH_atou(v21);
              }
              v37 = -1;
              if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_use_NNTN", &__c_1, &v37, &__c) & 0x80000000) == 0&& v37)
              {
                if (v37 == 1 && __c_1)
                {
                  v23 = *__c_1;
                  v24 = strchr(*__c_1, __c);
                  if (v24)
                  {
                    *v24 = 0;
                    v23 = *__c_1;
                  }
                  if (!strcmp(v23, "yes"))
                    *(_DWORD *)(a1 + 840) = 1;
                }
                v37 = -1;
                if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_use_NNTN_IGTree", &__c_1, &v37, &__c) & 0x80000000) == 0&& v37)
                {
                  if (v37 == 1 && __c_1)
                  {
                    v25 = *__c_1;
                    v26 = strchr(*__c_1, __c);
                    if (v26)
                    {
                      *v26 = 0;
                      v25 = *__c_1;
                    }
                    if (!strcmp(v25, "yes"))
                      *(_DWORD *)(a1 + 928) = 1;
                  }
                  v37 = -1;
                  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_one_char_per_node", &__c_1, &v37, &__c) & 0x80000000) == 0&& v37)
                  {
                    if (v37 == 1 && __c_1)
                    {
                      v27 = *__c_1;
                      v28 = strchr(*__c_1, __c);
                      if (v28)
                      {
                        *v28 = 0;
                        v27 = *__c_1;
                      }
                      if (!strcmp(v27, "yes"))
                        *(_DWORD *)(a1 + 952) = 1;
                    }
                    v37 = -1;
                    v29 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(_QWORD *)(a1 + 88) + 96))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), "fecfg", "nntn_feat_focus", &__c_1, &v37, &__c);
                    if ((v29 & 0x80000000) == 0 && v37)
                    {
                      v30 = v29;
                      if (v37 == 1 && __c_1)
                      {
                        v31 = *__c_1;
                        v32 = strchr(*__c_1, __c);
                        if (v32)
                        {
                          *v32 = 0;
                          v31 = *__c_1;
                        }
                        if (!strcmp(v31, "yes"))
                          *(_DWORD *)(a1 + 956) = 1;
                      }
                      return v30;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

uint64_t fi_model_getBrokerString_0(uint64_t a1, char *a2)
{
  uint64_t result;
  uint64_t v5;
  int v6[2];
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  *(_QWORD *)v6 = 0;
  memset(v7, 0, sizeof(v7));
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v6);
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v5);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v7, 1, 1, *(char **)v6, 0, 0, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t load_lua_code(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t *v5;
  int IsLuaCodeAvailable;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int ScriptFromRIFF;

  *a2 = 0;
  v4 = *(_QWORD *)(a1 + 272);
  if (v4)
  {
    OOC_PlacementDeleteObject(a1 + 224, v4);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v5 = (uint64_t *)(a1 + 272);
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 224));
  IsLuaCodeAvailable = LuaVMLDO_IsLuaCodeAvailable(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), 0, a2);
  v7 = LH_ERROR_to_VERROR(IsLuaCodeAvailable);
  if ((v7 & 0x80000000) == 0)
  {
    if (*a2 != 1)
      return v7;
    *a2 = 0;
    v8 = OOCAllocator_Con(a1 + 224, (_OWORD *)(a1 + 192), *(_QWORD *)(*(_QWORD *)a1 + 8));
    v9 = LH_ERROR_to_VERROR(v8);
    if ((v9 & 0x80000000) != 0
      || (v10 = PNEW_LuaVMLDO_Con(a1 + 224, a1 + 224, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)hlp_lua_log_callback_1, (uint64_t **)(a1 + 272)), v9 = LH_ERROR_to_VERROR(v10), (v9 & 0x80000000) != 0))
    {
      v7 = v9;
    }
    else
    {
      ScriptFromRIFF = LuaVMLDO_LoadScriptFromRIFF(*v5, 0);
      v7 = LH_ERROR_to_VERROR(ScriptFromRIFF);
      if ((v7 & 0x80000000) == 0)
      {
        *a2 = 1;
        return v7;
      }
    }
  }
  if (*v5)
  {
    OOC_PlacementDeleteObject(a1 + 224, *v5);
    *v5 = 0;
  }
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 224));
  return v7;
}

uint64_t NNTN_loc_ObjClose(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t NullHandle;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;

  if (a2)
  {
    v9 = result;
    log_OutText(*(_QWORD *)(result + 32), (uint64_t)"FE_NNTN", 4, 0, (uint64_t)"nntn : loc ObjClose Begin", a6, a7, a8, v72);
    NullHandle = safeh_GetNullHandle();
    v12 = 0;
    if (!safeh_HandlesEqual(*a2, a2[1], NullHandle, v11))
    {
      result = safeh_HandleCheck(*a2, a2[1], 58765, 968);
      if ((result & 0x80000000) != 0)
        return result;
      LODWORD(v12) = result;
      v20 = *a2;
      v21 = tokenizer_NNTN_ObjClose((_QWORD *)*a2, v13, v14, v15, v16, v17, v18, v19);
      if (v21 < 0)
        LODWORD(v12) = v21;
      v29 = textnormalizer_ObjClose((uint64_t *)v20, v22, v23, v24, v25, v26, v27, v28);
      if (v29 < 0)
        LODWORD(v12) = v29;
      v30 = safeh_GetNullHandle();
      if (!safeh_HandlesEqual(*(_QWORD *)(v20 + 136), *(_QWORD *)(v20 + 144), v30, v31))
      {
        v39 = nuance_pcre_ObjClose(*(_QWORD *)(v20 + 136), *(_QWORD *)(v20 + 144));
        if (v39 < 0)
          LODWORD(v12) = v39;
      }
      v40 = FEData_ObjClose_NNTN((uint64_t *)v20, v32, v33, v34, v35, v36, v37, v38);
      if (v40 < 0)
        LODWORD(v12) = v40;
      *(_QWORD *)(v20 + 152) = 0;
      v48 = FERuntimeData_ObjClose((_QWORD *)v20, v41, v42, v43, v44, v45, v46, v47);
      if (v48 < 0)
        LODWORD(v12) = v48;
      *(_QWORD *)(v20 + 176) = 0;
      v56 = FEFunctionMap_ObjClose((_QWORD *)v20, v49, v50, v51, v52, v53, v54, v55);
      if (v56 >= 0)
        v12 = v12;
      else
        v12 = v56;
      *(_QWORD *)(v20 + 160) = 0;
      if (*(_QWORD *)(v20 + 88))
        objc_ReleaseObject(*(_QWORD *)(v9 + 48), (uint64_t)"FE_DCTLKP");
      if (*(_QWORD *)(v20 + 112))
        objc_ReleaseObject(*(_QWORD *)(v9 + 48), (uint64_t)"FE_DEPES");
      if (*(_QWORD *)(v20 + 64))
        objc_ReleaseObject(*(_QWORD *)(v9 + 48), (uint64_t)"LINGDB");
      v63 = *(_QWORD *)(v20 + 344);
      if (v63)
      {
        if (*(_WORD *)(v20 + 336))
        {
          v64 = 0;
          do
          {
            heap_Free(*(_QWORD **)(v9 + 8), *(_QWORD *)(*(_QWORD *)(v20 + 344) + 8 * v64));
            *(_QWORD *)(*(_QWORD *)(v20 + 344) + 8 * v64++) = 0;
          }
          while (v64 < *(unsigned __int16 *)(v20 + 336));
          v63 = *(_QWORD *)(v20 + 344);
        }
        heap_Free(*(_QWORD **)(v9 + 8), v63);
      }
      v65 = *(_QWORD *)(v20 + 288);
      if (v65)
        heap_Free(*(_QWORD **)(v9 + 8), v65);
      v66 = *(_QWORD *)(v20 + 888);
      if (v66)
      {
        v12 = (*(uint64_t (**)(_QWORD, _QWORD))(v66 + 24))(*(_QWORD *)(v20 + 912), *(_QWORD *)(v20 + 920));
        *(_QWORD *)(v20 + 888) = 0;
      }
      if (*(_DWORD *)(v20 + 840))
      {
        v57 = *(uint64_t **)(v20 + 856);
        if (v57)
        {
          v12 = fi_deinit(*(_QWORD *)v20, *(_QWORD *)(v20 + 24), v57);
          *(_QWORD *)(v20 + 856) = 0;
        }
        if (*(_DWORD *)(v20 + 864) || *(_DWORD *)(v20 + 868))
          *(_QWORD *)(v20 + 864) = 0;
      }
      if (*(_DWORD *)(v20 + 928))
      {
        v67 = *(_QWORD *)(v20 + 944);
        if (v67)
        {
          igtree_Deinit(*(_QWORD *)v20, v67, (uint64_t)v57, v58, v59, v60, v61, v62);
          heap_Free(*(_QWORD **)(*(_QWORD *)v20 + 8), *(_QWORD *)(v20 + 944));
          *(_QWORD *)(v20 + 944) = 0;
        }
        if (*(_QWORD *)(v20 + 936))
          *(_QWORD *)(v20 + 936) = 0;
      }
      v68 = *(_QWORD *)(v20 + 272);
      if (v68)
      {
        OOC_PlacementDeleteObject(v20 + 224, v68);
        *(_QWORD *)(v20 + 272) = 0;
      }
      kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v20 + 224));
      heap_Free(*(_QWORD **)(v9 + 8), v20);
    }
    heap_Free(*(_QWORD **)(v9 + 8), (uint64_t)a2);
    return log_OutText(*(_QWORD *)(v9 + 32), (uint64_t)"FE_NNTN", 4, 0, (uint64_t)"nntn : loc ObjClose End (%x)", v69, v70, v71, v12);
  }
  return result;
}

uint64_t hlp_lua_log_callback_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_NNTN", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t setDomainsOnSentence_NNTN(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t DomainDefBlockInfo;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t i;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t **v29;
  int StringAttribute;
  __int16 AbsoluteFrom;
  __int16 AbsoluteTo;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int IsRemappable;
  char *v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int16 *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v73;
  uint64_t v74;
  uint64_t **v75;
  __int16 v76;
  int v77;
  uint64_t v78;
  int v79;
  char *__s2;
  uint64_t *v81;
  uint64_t v82;
  unsigned __int16 v83;
  uint64_t v84;
  _WORD v85[500];
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v84 = 0;
  v83 = 0;
  v81 = 0;
  v82 = 0;
  if (!a1)
    return NNTNERROR(7);
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : setDomainsOnSentence_NNTN Begin", a6, a7, a8, v73);
  DomainDefBlockInfo = dumpTokenRecordsInLingDB(a1, (uint64_t)"TRACE", 1, v9, v10, v11, v12, v13);
  if ((DomainDefBlockInfo & 0x80000000) == 0)
  {
    FEData_blockData_getDomains2SearchIn(a1, *((unsigned __int16 *)a1 + 168), a1[43], (uint64_t)v85, &v83, 0, v14, v15);
    log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : %d block(s) to search in", v17, v18, v19, v83);
    if (v83)
    {
      for (i = 0; i < v83; ++i)
      {
        FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v85[i], &v82, v20, v21, v22, v23, v24);
        if (*(_WORD *)(v82 + 24))
        {
          v26 = 0;
          v27 = 0;
          do
          {
            log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : domain[%d,%d,%s,type=%d] marker \"%s\"%s %s", v22, v23, v24, i);
            ++v27;
            v26 += 72;
          }
          while (v27 < *(unsigned __int16 *)(v82 + 24));
        }
      }
      v28 = *(_QWORD *)(a1[33] + 32);
      v29 = *(uint64_t ***)(v28 + 24);
      if ((unint64_t)v29 < *(_QWORD *)(v28 + 32))
      {
        do
        {
          __s2 = 0;
          v79 = 0;
          StringAttribute = LDOObject_GetStringAttribute(*v29, "TNTAG", &v79, (uint64_t *)&__s2);
          DomainDefBlockInfo = LH_ERROR_to_VERROR(StringAttribute);
          if ((DomainDefBlockInfo & 0x80000000) != 0)
            return DomainDefBlockInfo;
          if (v79)
          {
            v78 = 0;
            v77 = 0;
            AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)*v29);
            v75 = v29;
            AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)*v29);
            log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"doing DB token %s %d,%d", v33, v34, v35, (uint64_t)__s2);
            if (v83)
            {
              v38 = 0;
              v76 = AbsoluteFrom;
              do
              {
                FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v85[v38], &v82, v36, v37, v22, v23, v24);
                IsRemappable = FEData_blockData_IsRemappable(a1, __s2, &v78, (_WORD *)&v77 + 1, &v77, v39, v40, v41);
                v81 = 0;
                v43 = __s2;
                if (IsRemappable == 1)
                {
                  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"domain %s is remappable to %s", v22, v23, v24, (uint64_t)__s2);
                  v44 = HIWORD(v77);
                  v45 = v77;
                  DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v77, &v81, v46, v47, v48, v49, v50);
                  if ((DomainDefBlockInfo & 0x80000000) != 0)
                    return DomainDefBlockInfo;
                  v55 = v81;
                  if (v81)
                    goto LABEL_24;
                  log_OutPublic(*(_QWORD *)(*a1 + 32), a1[23], 24041, "%s%s", v51, v52, v53, v54, "skipping undefined remapped domain:");
                }
                else
                {
                  v55 = (uint64_t *)v82;
                  v56 = *(unsigned __int16 *)(v82 + 24);
                  if (*(_WORD *)(v82 + 24))
                  {
                    v57 = 0;
                    v58 = *(unsigned __int16 **)(v82 + 16);
                    while (strcmp((const char *)(*((_QWORD *)v58 + 6) + *v58), v43))
                    {
                      ++v57;
                      v58 += 36;
                      if (v56 == v57)
                        goto LABEL_35;
                    }
                    v45 = v85[v38];
                    v81 = v55;
                    v44 = (unsigned __int16)v57;
LABEL_24:
                    v59 = v55[2];
                    DomainDefBlockInfo = FERuntimeData_AddDomainRange((uint64_t)a1, &v84);
                    if ((DomainDefBlockInfo & 0x80000000) != 0)
                      return DomainDefBlockInfo;
                    v63 = v84;
                    *(_WORD *)(v84 + 6) = v45;
                    *(_WORD *)(v63 + 4) = v44;
                    *(_WORD *)v63 = v76;
                    *(_WORD *)(v63 + 2) = AbsoluteTo;
                    *(_DWORD *)(v63 + 8) = 1;
                    log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"Set Active Domain[%s:%s] range %d,%d", v60, v61, v62, *v81);
                    if (!strcmp((const char *)(*(_QWORD *)(v59 + 72 * v44 + 48)+ *(unsigned __int16 *)(v59 + 72 * v44)), (const char *)a1[36])|| *(_DWORD *)(v59 + 72 * v44 + 60) == 1)
                    {
                      log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"normal domain OR was remapped to EscNormal - set additional domains, if any", v22, v23, v24, v74);
                      v64 = v82;
                      if (*(_WORD *)(v82 + 24))
                      {
                        v65 = 0;
                        v66 = 48;
                        do
                        {
                          if (v44 != v65)
                          {
                            v67 = *(_QWORD *)(v64 + 16);
                            if (!strcmp((const char *)(*(_QWORD *)(v67 + v66) + *(unsigned __int16 *)(v67 + v66 - 48)), (const char *)a1[36])|| *(_DWORD *)(v67 + v66 + 12) == 1)
                            {
                              DomainDefBlockInfo = FERuntimeData_AddDomainRange((uint64_t)a1, &v84);
                              if ((DomainDefBlockInfo & 0x80000000) != 0)
                                return DomainDefBlockInfo;
                              v71 = v84;
                              *(_WORD *)(v84 + 6) = v85[v38];
                              *(_WORD *)(v71 + 4) = v65;
                              *(_WORD *)v71 = v76;
                              *(_WORD *)(v71 + 2) = AbsoluteTo;
                              *(_DWORD *)(v71 + 8) = 1;
                              log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"Set (as mapped to normal) Active Domain[%s:%s] range %d,%d", v68, v69, v70, *(_QWORD *)v82);
                              v64 = v82;
                            }
                          }
                          ++v65;
                          v66 += 72;
                        }
                        while (v65 < *(unsigned __int16 *)(v64 + 24));
                      }
                    }
                  }
                }
LABEL_35:
                ++v38;
              }
              while (v38 < v83);
            }
            v29 = v75;
          }
          ++v29;
        }
        while ((unint64_t)v29 < *(_QWORD *)(*(_QWORD *)(a1[33] + 32) + 32));
      }
      log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : setDomainsOnSentence_NNTN End (%x)", v22, v23, v24, DomainDefBlockInfo);
    }
    else
    {
      return 0;
    }
  }
  return DomainDefBlockInfo;
}

uint64_t mergeDomainsOnSentence_NNTN(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t DomainBlockIndex;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t DomainDefBlockInfo;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int16 *v30;
  int v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  unsigned __int16 v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int16 v41;
  int v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  _WORD v47[500];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v45 = 0;
  v46 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v39 = 0;
  v40 = 0;
  if (!a1)
    return NNTNERROR(7);
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : mergeDomainsOnSentence_NNTN Begin", a6, a7, a8, v37);
  v44 = 0;
  FERuntimeData_GetActiveDomains((uint64_t)a1, (uint64_t)v47, &v44, 0, *((unsigned __int16 *)a1 + 156), 1);
  if (v44)
  {
    v9 = 0;
    v10 = 1;
    do
    {
      FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v9], &v46);
      DomainBlockIndex = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v9++], &v43, (_WORD *)&v42 + 1);
      v15 = v44;
      v16 = v10;
      if (v9 < v44)
      {
        while (1)
        {
          FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v16], &v45);
          v17 = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v16], &v42, &v41);
          if (*((_DWORD *)v45 + 2) == 1
            && (unsigned __int16)v42 == v43
            && v41 == HIWORD(v42)
            && *v46 == *v45
            && v46[1] == v45[1])
          {
            *((_DWORD *)v45 + 2) = 0;
            log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : Remove duplicate domain %d,%d RANGE %d,%d ?", v12, v13, v14, 1);
          }
          if ((v17 & 0x80000000) != 0)
            goto LABEL_42;
          ++v16;
          v15 = v44;
          if (v16 >= v44)
            goto LABEL_15;
        }
      }
      v17 = DomainBlockIndex;
LABEL_15:
      ++v10;
    }
    while (v9 < v15);
    if ((_DWORD)v15)
    {
      v18 = 0;
      while (1)
      {
        FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v18], &v46);
        DomainDefBlockInfo = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v18], &v43, (_WORD *)&v42 + 1);
        if ((DomainDefBlockInfo & 0x80000000) != 0)
          goto LABEL_41;
        DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo(a1, v43, &v40, v20, v21, v12, v13, v14);
        if ((DomainDefBlockInfo & 0x80000000) != 0)
          goto LABEL_41;
        v22 = *(_QWORD *)(v40 + 16);
        v23 = (unsigned __int16 *)(v22 + 72 * HIWORD(v42));
        if (*(_WORD *)(*(_QWORD *)(v40 + 40) + 16 * v23[6] + 8) && *((_DWORD *)v46 + 2) == 1)
        {
          v38 = v46[1];
          v24 = v22 + 72 * HIWORD(v42);
          v26 = *(_QWORD *)(v24 + 48);
          v25 = (_QWORD *)(v24 + 48);
          log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : Modify domain \"%s\" RANGE %d,%d ?", v12, v13, v14, v26 + *v23);
          if (v18 < v44)
          {
            v27 = v18;
            do
            {
              FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v27], &v45);
              DomainDefBlockInfo = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v27], &v42, &v41);
              if ((DomainDefBlockInfo & 0x80000000) != 0)
                goto LABEL_41;
              DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v42, &v39, v28, v29, v12, v13, v14);
              if ((DomainDefBlockInfo & 0x80000000) != 0)
                goto LABEL_41;
              v30 = v45;
              if (v45 != v46 && *((_DWORD *)v45 + 2) == 1)
              {
                v31 = *v45;
                if (v31 == v38 || v31 == *v46 && v45[1] == v46[1])
                {
                  v32 = (const char *)(*v25 + *v23);
                  if (!strcmp(v32, (const char *)(*(_QWORD *)(*(_QWORD *)(v39 + 16) + 72 * v41 + 48)+ *(unsigned __int16 *)(*(_QWORD *)(v39 + 16) + 72 * v41))))
                  {
                    v38 = v30[1];
                    log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : Modify domain \"%s\" RANGE %d,%d -> %d %d (merge with %s)", v33, v34, v35, (uint64_t)v32);
                    *((_DWORD *)v45 + 2) = 0;
                  }
                }
              }
            }
            while (++v27 < v44);
          }
          if ((__int16)v46[1] != v38)
          {
            DomainDefBlockInfo = FERuntimeData_UpdateDomainRange(a1, (unsigned __int16)v18, v38);
            if ((DomainDefBlockInfo & 0x80000000) != 0)
              goto LABEL_41;
          }
        }
        if (++v18 >= v44)
          goto LABEL_40;
      }
    }
    if ((v17 & 0x80000000) != 0)
      goto LABEL_42;
  }
LABEL_40:
  DomainDefBlockInfo = FERuntimeData_PruneAndDumpActiveDomains(a1);
LABEL_41:
  v17 = DomainDefBlockInfo;
LABEL_42:
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : mergeDomainsOnSentence_NNTN End (%x)", v12, v13, v14, v17);
  return v17;
}

uint64_t fe_mnc_nntn_Process(uint64_t a1, __int16 *a2, char *a3)
{
  return stat_mnctn_seq2rule(a1, (uint64_t *)(a1 + 848), a2, a3);
}

uint64_t stat_mnctn_seq2rule(uint64_t a1, uint64_t *a2, __int16 *a3, char *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  int v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int16 v30;
  int v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int16 v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  unsigned int NextUtf8Offset;
  int v45;
  int v46;
  float v47;
  float *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v53;
  unsigned int v54;
  char *__dst;
  uint64_t v56;
  int v57;
  float *v58;
  int v59;
  const char **v60;
  const void *v61;
  int v62;

  v8 = *a2;
  v62 = 0;
  v60 = 0;
  v9 = a2[5];
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(v9 + 40))(a2[8], a2[9], &v62);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v11 = heap_Calloc(*(_QWORD **)(v8 + 8), 1, 8);
  if (!v11)
  {
    v32 = 2589990922;
    log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v12, v13, v14, v15, v53);
    return v32;
  }
  v16 = (char *)v11;
  v17 = heap_Calloc(*(_QWORD **)(v8 + 8), 1, 2048);
  if (!v17)
  {
    v32 = 2589990922;
    log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v18, v19, v20, v21, v53);
    v33 = *(_QWORD **)(v8 + 8);
    v34 = (uint64_t)v16;
    goto LABEL_48;
  }
  v22 = (char *)v17;
  v23 = *((_DWORD *)a2 + 5);
  if (*(_DWORD *)(a1 + 956) == 1)
    ++v23;
  v24 = (void *)heap_Alloc(*(_QWORD *)(v8 + 8), 4 * (v23 * *((_DWORD *)a2 + 4)));
  v61 = v24;
  if (!v24)
  {
    v32 = 2589990922;
    log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v25, v26, v27, v28, v53);
    goto LABEL_47;
  }
  v29 = *a3;
  __dst = a4;
  v58 = (float *)v24;
  if (*((_DWORD *)a2 + 8) == 1)
  {
    v30 = *((_DWORD *)a2 + 4) - (a3[1] - v29);
    v54 = ((v30 & 1) + v30) >> 1;
    v31 = -v54;
  }
  else
  {
    LOWORD(v54) = 7;
    LOWORD(v31) = -7;
  }
  strncpy(v22, (const char *)(*(_QWORD *)(a1 + 304) + v29), (unsigned __int16)(a3[1] - v29 + 1));
  v39 = 0;
  v57 = 0;
  v40 = 0;
  v22[a3[1] - *a3] = 0;
LABEL_15:
  v41 = v39;
  while (1)
  {
    v42 = *((unsigned int *)a2 + 4);
    if (v42 <= v41)
      break;
    if ((v31 & 0x8000) != 0)
    {
      nnGetChar(*(_QWORD *)(a1 + 304), a3, (__int16)v31, v16);
      LOWORD(v31) = v31 + 1;
      if (*v16)
      {
        v59 = v40;
LABEL_32:
        v46 = *(_DWORD *)(a1 + 956);
        v47 = 0.0;
        goto LABEL_33;
      }
    }
    else
    {
      v59 = v40;
      if (v57)
      {
        if ((__int16)v54 < 1)
        {
          strcpy(v16, "</s>");
        }
        else
        {
          nnGetChar(*(_QWORD *)(a1 + 304), a3, (__int16)(8 - v54), v16);
          if (!*v16)
            strcpy(v16, "</s>");
          LOWORD(v54) = v54 - 1;
        }
        goto LABEL_32;
      }
      v56 = v9;
      if ((v40 & 0x8000) == 0)
      {
        v43 = v40;
        if ((_WORD)v40)
        {
          NextUtf8Offset = 0;
          while (NextUtf8Offset != strlen(v22))
          {
            NextUtf8Offset = utf8_GetNextUtf8Offset(v22, NextUtf8Offset);
            v45 = (__int16)v43--;
            if (v45 <= 1)
              goto LABEL_28;
          }
        }
        else
        {
          NextUtf8Offset = 0;
LABEL_28:
          if ((utf8_getUTF8Char((uint64_t)v22, NextUtf8Offset, v16) & 0x80000000) == 0)
            goto LABEL_30;
        }
      }
      *v16 = 0;
LABEL_30:
      v40 = v59 + 1;
      v57 = 1;
      v9 = v56;
      if (*v16)
      {
        ++v59;
        v57 = 0;
        v46 = *(_DWORD *)(a1 + 956);
        v47 = 1.0;
LABEL_33:
        if (v46 == 1)
        {
          *v58 = v47;
          v48 = v58 + 1;
        }
        else
        {
          v48 = v58;
        }
        if (((*(uint64_t (**)(uint64_t, uint64_t, char *, float *))(v9 + 56))(a2[8], a2[9], v16, v48) & 0x1FFF) == 0x14)
        {
          log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v36, v37, v38, (uint64_t)v16);
          strcpy(v16, "</s>");
          (*(void (**)(uint64_t, uint64_t, char *, float *))(v9 + 56))(a2[8], a2[9], v16, v48);
        }
        v39 = v41 + 1;
        v58 = &v48[v62];
        v40 = v59;
        goto LABEL_15;
      }
    }
  }
  v32 = fi_predict((uint64_t ***)a2[1], &v61, v42, &v60, v35, v36, v37, v38);
  if ((v32 & 0x80000000) != 0)
    log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FIhmogrph Prediction Failed", v49, v50, v51, 0);
  else
    strcpy(__dst, *v60);
LABEL_47:
  heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)v16);
  v33 = *(_QWORD **)(v8 + 8);
  v34 = (uint64_t)v22;
LABEL_48:
  heap_Free(v33, v34);
  return v32;
}

uint64_t nnGetChar(uint64_t __s, __int16 *a2, int a3, _BYTE *a4)
{
  signed int NextUtf8Offset;
  signed int v6;
  int v7;
  char *v8;
  int v9;
  BOOL v10;

  NextUtf8Offset = *a2;
  if ((NextUtf8Offset & 0x80000000) == 0)
  {
    v6 = a2[1];
    if (NextUtf8Offset < v6)
    {
      v7 = a3;
      v8 = (char *)__s;
      if ((a3 & 0x80000000) == 0)
      {
        if (a3)
        {
          NextUtf8Offset = v6 - 1;
          while (1)
          {
            __s = strlen(v8);
            if (NextUtf8Offset == (_DWORD)__s)
              goto LABEL_16;
            NextUtf8Offset = utf8_GetNextUtf8Offset(v8, NextUtf8Offset);
            v9 = (__int16)v7--;
            if (v9 <= 1)
              goto LABEL_15;
          }
        }
        NextUtf8Offset = 0;
LABEL_15:
        __s = utf8_getUTF8Char((uint64_t)v8, NextUtf8Offset, a4);
        if ((__s & 0x80000000) == 0)
          return __s;
        goto LABEL_16;
      }
      if (*a2)
      {
        do
        {
          __s = utf8_GetPreviousUtf8Offset((uint64_t)v8, NextUtf8Offset);
          NextUtf8Offset = __s;
          v10 = (unsigned __int16)~(_WORD)v7 == 0;
          LOWORD(v7) = v7 + 1;
        }
        while (!v10 && (_DWORD)__s);
        if (!(_WORD)v7)
          goto LABEL_15;
      }
    }
  }
LABEL_16:
  *a4 = 0;
  return __s;
}

uint64_t FEData_ObjOpen_NNTN(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  unsigned int v28;

  log_OutText(*(_QWORD *)(*a3 + 32), a3[23], 4, 0, (uint64_t)"fe_data : ObjOpen Begin", a6, a7, a8, v27);
  v9 = (_QWORD *)heap_Calloc(*(_QWORD **)(*a3 + 8), 1, 24);
  if (!v9)
  {
    log_OutPublic(*(_QWORD *)(*a3 + 32), a3[23], 24048, 0, v12, v13, v14, v15, v28);
    return NNTNERROR(10);
  }
  v16 = v9;
  a3[19] = (uint64_t)v9;
  v17 = FEData_functionData_ObjOpen(a3, v9, v10, v11, v12, v13, v14, v15);
  if ((v17 & 0x80000000) != 0
    || (v17 = FEData_domainDefs_ObjOpen(a3, v16 + 1, v19, v20, v21, v22, v23, v24), (v17 & 0x80000000) != 0))
  {
    v25 = v17;
LABEL_8:
    FEData_ObjClose_NNTN(a3, v18, v19, v20, v21, v22, v23, v24);
    goto LABEL_9;
  }
  v25 = FEData_blockData_ObjOpen(a3, v16 + 2, v19, v20, v21, v22, v23, v24);
  if ((v25 & 0x80000000) != 0)
    goto LABEL_8;
LABEL_9:
  log_OutText(*(_QWORD *)(*a3 + 32), a3[23], 4, 0, (uint64_t)"fe_data : ObjOpen End (%x)", v22, v23, v24, v25);
  return v25;
}

uint64_t FEData_ObjClose_NNTN(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v39;

  v8 = a1[19];
  if (!v8)
    return NNTNERROR(8);
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"fe_data : ObjClose Begin", a6, a7, a8, v39);
  v17 = FEData_functionData_ObjClose(a1, v10, v11, v12, v13, v14, v15, v16);
  LODWORD(v18) = v17 & (v17 >> 31);
  v26 = FEData_blockData_ObjClose_NNTN(a1, v19, v20, v21, v22, v23, v24, v25);
  if (v26 < 0)
    LODWORD(v18) = v26;
  v34 = FEData_domainDefs_ObjClose(a1, v27, v28, v29, v30, v31, v32, v33);
  if (v34 >= 0)
    v18 = v18;
  else
    v18 = v34;
  heap_Free(*(_QWORD **)(*a1 + 8), v8);
  a1[19] = 0;
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"fe_data : ObjClose End (%x)", v35, v36, v37, v18);
  return v18;
}

uint64_t FEData_blockData_ObjClose_NNTN(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v9 = *(_QWORD *)(a1[19] + 16);
  v10 = *(_QWORD *)(*a1 + 32);
  v11 = a1[23];
  if (v9)
  {
    log_OutText(v10, v11, 4, 0, (uint64_t)"blockData : ObjClose Begin", a6, a7, a8, v16);
    log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"blockData : ObjClose End (%x)", v12, v13, v14, 0);
    heap_Free(*(_QWORD **)(*a1 + 8), v9);
    return 0;
  }
  else
  {
    log_OutPublic(v10, v11, 24049, 0, a5, a6, a7, a8, v16);
    return FEDATA_ERROR(7);
  }
}

uint64_t FEData_blockData_getTokenAndRegexData_NNTN(_QWORD *a1, uint64_t a2, _QWORD *a3, _WORD *a4, _QWORD *a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int vars0;

  v8 = *(_QWORD *)(a1[19] + 16);
  if (v8)
  {
    v9 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 136) + 8)
                                + 8 * *(unsigned __int16 *)(*(_QWORD *)a2 + 2))
                    + 8);
    v10 = v9[6] + 32 * *(unsigned __int16 *)(*(_QWORD *)a2 + 4);
    v11 = v9[8] + 16 * *(unsigned __int16 *)(v10 + 6);
    *a4 = *(_WORD *)(v11 + 10);
    *a6 = *(_DWORD *)(v11 + 12);
    *a3 = v9[4] + *(unsigned int *)(v11 + 4);
    *a5 = v9[3] + *(unsigned __int16 *)(v10 + 4);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*a1 + 32), a1[23], 24049, 0, (uint64_t)a5, (uint64_t)a6, a7, a8, vars0);
    return FEDATA_ERROR(7);
  }
}

uint64_t FEData_blockData_loadDataFiles_NNTN(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  unsigned __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  _WORD *RsrcHandleForThisApi;
  uint64_t v18;
  _WORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t Chunk;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t DataBlockFromFileRefCnt;
  _BOOL4 v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unsigned __int16 *v53;
  unint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  int v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int16 *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned __int16 *v84;
  const char *v85;
  unint64_t v86;
  unint64_t j;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t *v96;
  unint64_t v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t i;
  uint64_t v103;
  uint64_t v104;
  unsigned __int16 *v105;
  uint64_t v106;
  int v107[2];
  uint64_t v108;
  unsigned __int16 *v109;
  unsigned int v110;
  _QWORD *v111;
  _OWORD v112[8];
  char v113[136];
  uint64_t v114;

  v8 = (uint64_t *)a1;
  v114 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 152);
  v111 = 0;
  memset(v113, 0, 128);
  memset(v112, 0, sizeof(v112));
  v110 = 0;
  v108 = 0;
  v109 = 0;
  *(_QWORD *)v107 = 0;
  v10 = *(unsigned __int16 **)(v9 + 16);
  if (!v10)
  {
    v11 = *(_QWORD *)(*(_QWORD *)a1 + 32);
    v12 = v8[23];
    v13 = 24049;
    goto LABEL_5;
  }
  if (*v10)
  {
    v11 = *(_QWORD *)(*(_QWORD *)a1 + 32);
    v12 = v8[23];
    v13 = 24055;
LABEL_5:
    log_OutPublic(v11, v12, v13, 0, a5, a6, a7, a8, v93);
    return FEDATA_ERROR(7);
  }
  v15 = *(_QWORD *)a1;
  if (*(unsigned __int8 *)(a1 + 352) > *(unsigned __int16 *)(a1 + 336))
  {
    log_OutPublic(*(_QWORD *)(v15 + 32), *(_QWORD *)(a1 + 184), 24056, "%s%d%s%d", a5, a6, a7, a8, "invalid language identifier index");
    return FEDATA_ERROR(0);
  }
  if ((paramc_ParamGetStr(*(_QWORD *)(v15 + 40), (uint64_t)"langcode", v107) & 0x80000000) != 0)
    *(_QWORD *)v107 = &byte_1DEBD87CE;
  if ((paramc_ParamGetStr(*(_QWORD *)(*v8 + 40), (uint64_t)"fecfg", &v108) & 0x80000000) == 0)
  {
    strcpy((char *)v112, "nntokentn/");
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    v16 = brokeraux_ComposeBrokerString(*v8, (const char *)v112, 1, 1, *(char **)v107, 0, 0, v113, 0x80uLL);
    if ((v16 & 0x80000000) != 0)
      return FEDATA_ERROR(v16);
    RsrcHandleForThisApi = (_WORD *)getRsrcHandleForThisApi(*v8, v8[1], v8[2], v8[4]);
    if ((ssftriff_reader_ObjOpen(RsrcHandleForThisApi, v18, 2, v113, "TOKN", 1031, (uint64_t *)&v111) & 0x80000000) == 0)
    {
LABEL_15:
      Chunk = ssftriff_reader_FindChunk((uint64_t)v111, "CFIG", 0, &v110, &v109);
      v30 = Chunk & 0x1FFF;
      if ((Chunk & 0x80000000) != 0)
      {
        DataBlockFromFileRefCnt = Chunk;
        if (v30 != 20)
          goto LABEL_104;
      }
      if (v30 == 20)
      {
        v32 = 0;
        v33 = 0;
        v34 = 0;
      }
      else
      {
        v33 = *v109;
        if (*v109)
        {
          if (v33 == 3)
          {
            v33 = 0;
            v32 = v109[1] == 1;
            v34 = 1;
          }
          else
          {
            v32 = v109[1] == 1;
            if (v33 < 2)
            {
              v33 = 0;
              v34 = 0;
            }
            else
            {
              v34 = 0;
              v33 = v109[2] == 1;
            }
          }
        }
        else
        {
          v32 = 0;
          v34 = *v109;
        }
        v35 = ssftriff_reader_CloseChunk((uint64_t)v111);
        if ((v35 & 0x80000000) != 0)
          goto LABEL_103;
      }
      v35 = ssftriff_reader_FindChunk((uint64_t)v111, "FILE", 0, &v110, &v109);
      if ((v35 & 0x80000000) == 0)
      {
        *v10 = *v109;
        v35 = ssftriff_reader_CloseChunk((uint64_t)v111);
        if ((v35 & 0x80000000) == 0)
        {
          __strcpy_chk();
          DataBlockFromFileRefCnt = readDataBlockFromFileRefCnt((uint64_t)v8, (uint64_t)v111, v32, v33, v34, (uint64_t)v113);
          if ((DataBlockFromFileRefCnt & 0x80000000) == 0)
          {
            ssftriff_reader_ObjClose(v111, v36, v37, v38, v26, v27, v28, v29);
            v111 = 0;
            v46 = *v10;
            if (*v10)
            {
              v95 = DataBlockFromFileRefCnt;
              v96 = v8;
              v47 = 0;
              v48 = 0;
              v105 = v10;
              do
              {
                v49 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v10 + 17) + 8) + 8 * v47);
                v106 = v49;
                if (v49)
                {
                  v50 = *(_QWORD *)(v49 + 16);
                  if (v50)
                  {
                    v51 = 0;
                    while (v51 < *(unsigned __int16 *)(v50 + 24))
                    {
                      v52 = *(_QWORD *)(v50 + 16);
                      v53 = (unsigned __int16 *)(v52 + 72 * v51);
                      if (*((_DWORD *)v53 + 16) == 1)
                      {
                        if (v96[36])
                        {
                          if (strcmp((const char *)v96[36], (const char *)(*(_QWORD *)(v52 + 72 * v51 + 48) + *v53)))
                          {
                            log_OutPublic(*(_QWORD *)(*v96 + 32), v96[23], 24053, "%s%s%s%s", v42, v43, v44, v45, "first assigned");
                            goto LABEL_102;
                          }
                        }
                        else
                        {
                          v54 = v51;
                          v55 = v52 + 72 * v51;
                          v57 = *(_QWORD *)(v55 + 48);
                          v56 = (_QWORD *)(v55 + 48);
                          v58 = strlen((const char *)(v57 + *v53));
                          v59 = (char *)heap_Calloc(*(_QWORD **)(*v96 + 8), 1, (v58 + 1));
                          v96[36] = (uint64_t)v59;
                          if (!v59)
                          {
                            log_OutPublic(*(_QWORD *)(*v96 + 32), v96[23], 24048, 0, v60, v61, v62, v63, v94);
                            v16 = 10;
                            return FEDATA_ERROR(v16);
                          }
                          strcpy(v59, (const char *)(*v56 + *v53));
                          *((_WORD *)v96 + 148) = v47;
                          *((_WORD *)v96 + 149) = v54;
                          v51 = v54;
                        }
                      }
                      v97 = v51;
                      if (*(_DWORD *)(v52 + 72 * v51 + 8) == 1)
                      {
                        v64 = *(_QWORD *)(v106 + 16);
                        v101 = *(unsigned __int16 *)(v64 + 48);
                        if (*(_WORD *)(v64 + 48))
                        {
                          v65 = 0;
                          v99 = *(_QWORD *)(v64 + 40);
                          while (1)
                          {
                            v103 = v65;
                            v66 = v99 + 16 * v65;
                            v67 = *(unsigned __int16 *)(v66 + 8);
                            if (*(_WORD *)(v66 + 8))
                            {
                              v68 = 0;
                              v69 = *v10;
                              do
                              {
                                if ((_DWORD)v69)
                                {
                                  v70 = 0;
                                  v71 = *(_QWORD *)(*((_QWORD *)v10 + 17) + 8);
                                  while (1)
                                  {
                                    v72 = *(_QWORD *)(v71 + 8 * v70);
                                    if (*(_DWORD *)v72 != 1 && *(_DWORD *)v72 != 4)
                                    {
                                      if (*(_WORD *)(v64 + 50))
                                      {
                                        v74 = *(unsigned __int16 **)(*(_QWORD *)v66 + 24 * v68);
                                        v75 = *v74;
                                        if (*(unsigned __int16 *)(v64 + 50) > v75
                                          && !strcmp(**(const char ***)(v72 + 8), *(const char **)(*(_QWORD *)(v64 + 56) + 8 * v75)))
                                        {
                                          break;
                                        }
                                      }
                                    }
                                    if (v69 == ++v70)
                                    {
                                      v48 = 0;
                                      goto LABEL_62;
                                    }
                                  }
                                  v74[1] = v70;
                                  v48 = 1;
LABEL_62:
                                  v10 = v105;
                                }
                                else
                                {
                                  v48 = 0;
                                }
                                ++v68;
                              }
                              while (v68 != v67);
                            }
                            if (!v48)
                              break;
                            v65 = v103 + 1;
                            v48 = 1;
                            if (v103 + 1 == v101)
                              goto LABEL_67;
                          }
                          log_OutPublic(*(_QWORD *)(*v96 + 32), v96[23], 24045, 0, v42, v43, v44, v45, v94);
                          return v95;
                        }
                      }
LABEL_67:
                      v51 = v97 + 1;
                      v49 = v106;
                      v50 = *(_QWORD *)(v106 + 16);
                      if (!v50)
                        break;
                    }
                  }
                  v46 = *v10;
                }
                if (v46)
                {
                  v76 = 0;
                  v98 = v46;
                  v100 = *(_QWORD *)(*((_QWORD *)v10 + 17) + 8);
                  for (i = v46; i != v76; v86 = i)
                  {
                    v77 = *(_QWORD *)(v100 + 8 * v76);
                    if (v77)
                    {
                      v78 = *(_QWORD *)(v77 + 24);
                      if (v78)
                      {
                        v79 = *(unsigned __int16 *)(v78 + 16);
                        if (*(_WORD *)(v78 + 16))
                        {
                          v80 = 0;
                          v104 = *(_QWORD *)(v78 + 8);
                          do
                          {
                            if (v49)
                            {
                              v81 = *(_QWORD *)(v106 + 16);
                              if (v81)
                              {
                                v82 = *(unsigned __int16 *)(v81 + 24);
                                if (*(_WORD *)(v81 + 24))
                                {
                                  v83 = *(_QWORD *)(v104 + 8 * v80);
                                  v84 = *(unsigned __int16 **)(v81 + 16);
                                  v85 = *(const char **)v83;
                                  do
                                  {
                                    if (!strcmp(v85, (const char *)(*((_QWORD *)v84 + 6) + *v84)))
                                      *(_WORD *)(v83 + 10) = v47;
                                    v84 += 36;
                                    --v82;
                                  }
                                  while (v82);
                                }
                              }
                            }
                            ++v80;
                            v49 = v106;
                          }
                          while (v80 != v79);
                        }
                      }
                    }
                    ++v76;
                  }
                  v10 = v105;
                  v46 = v98;
                }
                else
                {
                  v86 = 0;
                }
                ++v47;
              }
              while (v47 < v86);
              v8 = v96;
              DataBlockFromFileRefCnt = v95;
              if (v46)
              {
                for (j = 0; j < v46; ++j)
                {
                  v88 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v10 + 17) + 8) + 8 * j);
                  if (v88)
                  {
                    v89 = *(_QWORD *)(v88 + 16);
                    if (v89)
                    {
                      v90 = 0;
                      v91 = -1;
                      do
                      {
                        if (++v91 >= (unint64_t)*(unsigned __int16 *)(v89 + 24))
                          break;
                        v92 = *(_QWORD *)(v89 + 16) + v90;
                        if (*(_WORD *)(v92 + 40) && (!*(_DWORD *)(v92 + 8) || !*(_WORD *)(v89 + 48)))
                          log_OutPublic(*(_QWORD *)(*v96 + 32), v96[23], 24062, 0, v42, v43, v44, v45, v94);
                        v90 += 72;
                        v89 = *(_QWORD *)(v88 + 16);
                      }
                      while (v89);
                    }
                    v46 = *v10;
                  }
                }
              }
            }
            if (!v8[36])
            {
              log_OutPublic(*(_QWORD *)(*v8 + 32), v8[23], 24054, 0, v42, v43, v44, v45, v94);
LABEL_102:
              v16 = 0;
              return FEDATA_ERROR(v16);
            }
LABEL_105:
            if (v111)
              ssftriff_reader_ObjClose(v111, v39, v40, v41, v42, v43, v44, v45);
            return DataBlockFromFileRefCnt;
          }
LABEL_104:
          log_OutPublic(*(_QWORD *)(*v8 + 32), v8[23], 24052, 0, v26, v27, v28, v29, v94);
          goto LABEL_105;
        }
      }
LABEL_103:
      DataBlockFromFileRefCnt = v35;
      goto LABEL_104;
    }
  }
  strcpy((char *)v112, "nntokentn/");
  __strcat_chk();
  v16 = brokeraux_ComposeBrokerString(*v8, (const char *)v112, 1, 1, *(char **)v107, 0, 0, v113, 0x80uLL);
  if ((v16 & 0x80000000) == 0)
  {
    v19 = (_WORD *)getRsrcHandleForThisApi(*v8, v8[1], v8[2], v8[4]);
    if ((ssftriff_reader_ObjOpen(v19, v20, 0, v113, "TOKN", 1031, (uint64_t *)&v111) & 0x80000000) == 0)
      goto LABEL_15;
    log_OutPublic(*(_QWORD *)(*v8 + 32), v8[23], 24057, "%s%s", v21, v22, v23, v24, "Missing broker header file");
    v16 = 3;
  }
  return FEDATA_ERROR(v16);
}

uint64_t readDataBlockFromFileRefCnt(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[2];
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *__s1;

  v21 = 0;
  v22 = 0;
  v19 = 0;
  v20 = 0;
  result = InitRsrcFunction(*(_WORD **)(a1 + 8), *(_QWORD *)(a1 + 16), &v22);
  if ((result & 0x80000000) == 0)
  {
    result = InitRsrcFunction(*(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), &v21);
    if ((result & 0x80000000) == 0)
    {
      v16[0] = a1;
      v16[1] = a2;
      v17 = a3;
      v18 = a4;
      LODWORD(v19) = a5;
      v14 = v21;
      v13 = v22;
      __s1 = 0;
      if ((paramc_ParamGetStr(*(_QWORD *)(v22 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
        || !__s1
        || !*__s1
        || !strcmp(__s1, "internal"))
      {
        v13 = v14;
      }
      result = objc_GetAddRefCountedObject(*(_QWORD *)(v13 + 48), a6, (uint64_t (*)(_QWORD, _QWORD, uint64_t, __int128 *, uint64_t))readDataBlockFromFile_ObjcLoad, (void (*)(_QWORD, _QWORD, __int128 *))readDataBlockFromFile_ObjcClose, (uint64_t)v16, &v20);
      if ((result & 0x80000000) != 0)
        v15 = 0;
      else
        v15 = *(_QWORD *)(v20 + 32);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 152) + 16) + 136) = v15;
    }
  }
  return result;
}

uint64_t readDataBlockFromFile_ObjcLoad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  unsigned __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  unsigned __int16 *v21;
  uint64_t v22;
  uint64_t Chunk;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _WORD *v38;
  unsigned __int16 v39;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  char *v57;
  uint64_t FunctionDataFromBinaryFile;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  __int16 v77;
  unsigned __int16 v78;
  _BYTE *v79;
  unsigned int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unsigned int v87;
  __int16 v88;
  unsigned __int16 v89;
  int v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  size_t v95;
  uint64_t v96;
  void *v97;
  int v98;
  uint64_t v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  _WORD *v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t i;
  _WORD *v118;
  uint64_t v119;
  int v120;
  __int16 v121;
  unsigned int v122;
  __int16 v123;
  int v124;
  _WORD *v125;
  int v126;
  __int16 v127;
  unsigned __int16 v128;
  _BYTE *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  _QWORD *v144;
  __int16 v145;
  unsigned __int16 v146;
  _BYTE *v147;
  unsigned int v148;
  uint64_t v149;
  _QWORD *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  unint64_t v157;
  unsigned int v158;
  __int16 v159;
  unsigned __int16 v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  unsigned int v169;
  unsigned int v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _QWORD *v174;
  int v175;
  int v176;
  int v177;
  unsigned __int16 *v178;
  unsigned int v179;
  int v180[2];
  uint64_t v181;

  v6 = *(uint64_t **)a5;
  v7 = *(_QWORD *)(a5 + 8);
  v8 = *(_DWORD *)(a5 + 16);
  v9 = *(_DWORD *)(a5 + 20);
  v10 = *(_DWORD *)(a5 + 24);
  v11 = *(unsigned __int16 **)(*(_QWORD *)(*(_QWORD *)a5 + 152) + 16);
  v12 = heap_Calloc(*(_QWORD **)(**(_QWORD **)a5 + 8), 1, 16);
  *(_QWORD *)(a4 + 32) = v12;
  v17 = *v6;
  if (!v12)
  {
LABEL_141:
    log_OutPublic(*(_QWORD *)(v17 + 32), v6[23], 24048, 0, v13, v14, v15, v16, v169);
    v29 = FEDATA_ERROR(10);
    if ((v29 & 0x80000000) != 0)
LABEL_142:
      log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24052, 0, v164, v165, v166, v167, v170);
    return v29;
  }
  *(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) = heap_Calloc(*(_QWORD **)(v17 + 8), 1, (8 * *v11) | 1);
  v18 = *(_QWORD *)(a4 + 32);
  if (!*(_QWORD *)(v18 + 8))
  {
LABEL_140:
    v17 = *v6;
    goto LABEL_141;
  }
  v178 = v11;
  v19 = *v11;
  *(_WORD *)v18 = v19;
  if (v19)
  {
    v175 = v10;
    v176 = v8;
    v177 = v9;
    v20 = 0;
    v21 = v178;
    while (1)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 8 * v20) = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 48);
      v22 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 8 * v20);
      if (!v22)
        goto LABEL_140;
      *(_QWORD *)v180 = 0;
      v181 = 0;
      v179 = 0;
      Chunk = ssftriff_reader_FindChunk(v7, "HEAD", 1, (unsigned int *)&v181 + 1, v180);
      if ((Chunk & 0x80000000) != 0)
      {
LABEL_94:
        v29 = Chunk;
LABEL_95:
        v42 = 0;
LABEL_96:
        log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24052, 0, (uint64_t)v24, v25, v26, v27, v169);
        goto LABEL_97;
      }
      LODWORD(v181) = 0;
      v28 = (unsigned __int16)**(_WORD **)v180;
      LODWORD(v181) = 2;
      *(_DWORD *)v22 = v28;
      v29 = ssftriff_reader_CloseChunk(v7);
      if ((v29 & 0x80000000) != 0)
        goto LABEL_95;
      v30 = *(_DWORD *)v22;
      if ((*(_DWORD *)v22 - 3) <= 2)
      {
        v31 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 24);
        *(_QWORD *)(v22 + 24) = v31;
        if (!v31)
          goto LABEL_102;
        Chunk = ssftriff_reader_FindChunk(v7, "REMP", 1, (unsigned int *)&v181 + 1, v180);
        if ((Chunk & 0x80000000) != 0)
          goto LABEL_94;
        LODWORD(v181) = 0;
        v33 = *(_QWORD *)v180;
        v34 = (unsigned __int16)**(_WORD **)v180;
        LODWORD(v181) = 2;
        v35 = *(_QWORD *)(v22 + 24);
        *(_DWORD *)v35 = v34;
        if (!v34)
        {
          *(_WORD *)(v35 + 16) = *(_WORD *)(v33 + 2);
          LODWORD(v181) = 4;
          if (*(_WORD *)(*(_QWORD *)(v22 + 24) + 16))
          {
            v135 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 8 * *(unsigned __int16 *)(*(_QWORD *)(v22 + 24) + 16));
            v140 = *(_QWORD *)(v22 + 24);
            *(_QWORD *)(v140 + 8) = v135;
            if (!v135)
            {
              log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24048, 0, v136, v137, v138, v139, v169);
              *(_WORD *)(*(_QWORD *)(v22 + 24) + 16) = 0;
              goto LABEL_129;
            }
            if (*(_WORD *)(v140 + 16))
            {
              v141 = 0;
              while (1)
              {
                *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v22 + 24) + 8) + 8 * v141) = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 24);
                v142 = *(_QWORD *)(v22 + 24);
                if (!*(_QWORD *)(*(_QWORD *)(v142 + 8) + 8 * v141))
                  goto LABEL_127;
                if (++v141 >= (unint64_t)*(unsigned __int16 *)(v142 + 16))
                {
                  v21 = v178;
                  if (!*(_WORD *)(v142 + 16))
                    break;
                  v143 = 0;
                  while (1)
                  {
                    v172 = v143;
                    v144 = *(_QWORD **)(*(_QWORD *)(v142 + 8) + 8 * v143);
                    v145 = *(_WORD *)(*(_QWORD *)v180 + v181);
                    LODWORD(v181) = v181 + 2;
                    v146 = v145 + 1;
                    v147 = (_BYTE *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, (unsigned __int16)(v145 + 1));
                    *v144 = v147;
                    if (!v147)
                      goto LABEL_127;
                    v174 = v144;
                    v179 = v146;
                    v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v147, &v179);
                    v42 = 1;
                    if ((v29 & 0x80000000) != 0 || v179 != v146)
                      goto LABEL_104;
                    v148 = v181 + v146;
                    LODWORD(v181) = v148;
                    v149 = *(_QWORD *)v180;
                    v150 = v174;
                    *((_WORD *)v174 + 4) = *(_WORD *)(*(_QWORD *)v180 + v148);
                    LODWORD(v181) = v148 + 2;
                    *((_WORD *)v174 + 5) = *(_WORD *)(v149 + v148 + 2);
                    LODWORD(v181) = v148 + 4;
                    v151 = *(unsigned __int16 *)(v149 + v148 + 4);
                    *((_WORD *)v174 + 6) = v151;
                    LODWORD(v181) = v148 + 6;
                    if (v151)
                    {
                      v152 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 8 * v151);
                      v174[2] = v152;
                      if (!v152)
                      {
                        log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24048, 0, v153, v154, v155, v156, v169);
                        *((_WORD *)v174 + 6) = 0;
                        goto LABEL_129;
                      }
                      if (*((_WORD *)v174 + 6))
                      {
                        v157 = 0;
                        v158 = v181;
                        do
                        {
                          v159 = *(_WORD *)(*(_QWORD *)v180 + v158);
                          LODWORD(v181) = v158 + 2;
                          v160 = v159 + 1;
                          *(_QWORD *)(v150[2] + 8 * v157) = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, (unsigned __int16)(v159 + 1));
                          v24 = *(_BYTE **)(v150[2] + 8 * v157);
                          if (!v24)
                            goto LABEL_127;
                          v179 = v160;
                          v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v24, &v179);
                          v42 = 1;
                          if ((v29 & 0x80000000) != 0 || v179 != v160)
                            goto LABEL_104;
                          v158 = v181 + v160;
                          LODWORD(v181) = v158;
                          ++v157;
                          v150 = v174;
                        }
                        while (v157 < *((unsigned __int16 *)v174 + 6));
                      }
                    }
                    v143 = v172 + 1;
                    v142 = *(_QWORD *)(v22 + 24);
                    v21 = v178;
                    if (v172 + 1 >= (unint64_t)*(unsigned __int16 *)(v142 + 16))
                      goto LABEL_12;
                  }
                }
              }
            }
          }
        }
LABEL_12:
        v29 = ssftriff_reader_CloseChunk(v7);
        if ((v29 & 0x80000000) != 0)
          goto LABEL_95;
        v30 = *(_DWORD *)v22;
      }
      if (v30 <= 5 && ((1 << v30) & 0x2D) != 0)
      {
        v36 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 72);
        *(_QWORD *)(v22 + 8) = v36;
        if (!v36)
          goto LABEL_102;
        v30 = *(_DWORD *)v22;
      }
      if (v30 <= 5 && ((1 << v30) & 0x36) != 0)
      {
        v37 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 64);
        *(_QWORD *)(v22 + 16) = v37;
        if (!v37)
        {
LABEL_102:
          log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24048, 0, v32, v25, v26, v27, v169);
          v134 = FEDATA_ERROR(10);
          goto LABEL_103;
        }
        v30 = *(_DWORD *)v22;
      }
      if (v30 <= 5 && ((1 << v30) & 0x2D) != 0)
      {
        Chunk = ssftriff_reader_FindChunk(v7, "TDAT", 1, (unsigned int *)&v181 + 1, v180);
        if ((Chunk & 0x80000000) != 0)
          goto LABEL_94;
        LODWORD(v181) = 0;
        v38 = *(_WORD **)v180;
        *(_QWORD *)(v22 + 40) = *(_QWORD *)v180;
        LOWORD(v38) = *v38;
        LODWORD(v181) = 2;
        v39 = (_WORD)v38 + 1;
        v40 = (_BYTE *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, (unsigned __int16)((_WORD)v38 + 1));
        **(_QWORD **)(v22 + 8) = v40;
        if (!v40)
          goto LABEL_127;
        v179 = v39;
        v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v40, &v179);
        v42 = 1;
        if ((v29 & 0x80000000) != 0 || v179 != v39)
          goto LABEL_104;
        v43 = v181 + v39;
        LODWORD(v181) = v43;
        v44 = *(_QWORD *)v180;
        *(_WORD *)(*(_QWORD *)(v22 + 8) + 8) = *(_WORD *)(*(_QWORD *)v180 + v43);
        LODWORD(v181) = v43 + 2;
        *(_WORD *)(*(_QWORD *)(v22 + 8) + 12) = *(_WORD *)(v44 + v43 + 2);
        LODWORD(v181) = v43 + 4;
        v45 = *(_DWORD *)(v44 + v43 + 4);
        LODWORD(v181) = v43 + 8;
        v46 = *(_DWORD *)(v44 + v43 + 8);
        v47 = v43 + 12;
        v48 = *(_QWORD *)(v22 + 8);
        *(_DWORD *)(v48 + 16) = v47;
        *(_QWORD *)(v48 + 24) = v44 + v47;
        LODWORD(v181) = v45 + v47;
        v49 = (v45 + v47 + *(_DWORD *)(v44 + (v45 + v47)) + 4);
        *(_DWORD *)(v48 + 40) = v49;
        *(_QWORD *)(v48 + 32) = v44 + v49;
        LODWORD(v181) = v49 + v46;
        if (*(_WORD *)(v48 + 8))
        {
          v50 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 32 * *(unsigned __int16 *)(v48 + 8));
          v48 = *(_QWORD *)(v22 + 8);
          *(_QWORD *)(v48 + 48) = v50;
          if (!v50)
            goto LABEL_131;
          if (*(_WORD *)(v48 + 8))
          {
            v51 = 0;
            v52 = 0;
            while (1)
            {
              v53 = *(_QWORD *)(v48 + 48) + v51;
              v54 = *(_QWORD *)v180;
              v55 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_DWORD *)v53 = v55;
              *(_WORD *)(v53 + 4) = *(_WORD *)(v54 + v181);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v53 + 6) = *(_WORD *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              LODWORD(v54) = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
              *(_WORD *)(v53 + 24) = v54;
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v53 + 26) = *(_WORD *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v53 + 28) = *(_WORD *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_QWORD *)(v53 + 8) = 0;
              if ((_DWORD)v54)
              {
                v56 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 56);
                v57 = (char *)v56;
                *(_QWORD *)(v53 + 8) = v56;
                if (!v56)
                  goto LABEL_133;
                *(_QWORD *)v56 = &StaticIntPointers;
                *(_BYTE *)(v56 + 24) = 0;
                *(_QWORD *)(v56 + 16) = 0;
                *(_QWORD *)(v56 + 40) = 0;
                *(_QWORD *)(v56 + 48) = 0;
                *(_QWORD *)(v56 + 32) = 0;
                FunctionDataFromBinaryFile = FEData_readFunctionDataFromBinaryFile(v6, v7, *v6, v56, *(uint64_t *)v180, (unsigned int *)&v181, HIDWORD(v181));
                if ((FunctionDataFromBinaryFile & 0x80000000) != 0)
                  break;
              }
              *(_QWORD *)(v53 + 16) = 0;
              if (*(_WORD *)(v53 + 26))
              {
                v59 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 56);
                v57 = (char *)v59;
                *(_QWORD *)(v53 + 16) = v59;
                if (!v59)
                {
LABEL_133:
                  v161 = *(_QWORD *)(*v6 + 32);
                  v162 = v6[23];
                  goto LABEL_128;
                }
                *(_QWORD *)v59 = &StaticIntPointers;
                *(_BYTE *)(v59 + 24) = 0;
                *(_QWORD *)(v59 + 16) = 0;
                *(_QWORD *)(v59 + 40) = 0;
                *(_QWORD *)(v59 + 48) = 0;
                *(_QWORD *)(v59 + 32) = 0;
                FunctionDataFromBinaryFile = FEData_readFunctionDataFromBinaryFile(v6, v7, *v6, v59, *(uint64_t *)v180, (unsigned int *)&v181, HIDWORD(v181));
                if ((FunctionDataFromBinaryFile & 0x80000000) != 0)
                  break;
              }
              ++v52;
              v48 = *(_QWORD *)(v22 + 8);
              v51 += 32;
              if (v52 >= *(unsigned __int16 *)(v48 + 8))
                goto LABEL_39;
            }
            v29 = FunctionDataFromBinaryFile;
            v42 = 1;
            v21 = v178;
            goto LABEL_96;
          }
        }
LABEL_39:
        v60 = *(unsigned __int16 *)(v48 + 12);
        v21 = v178;
        if (v60)
        {
          v61 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 16 * v60);
          v62 = *(_QWORD *)(v22 + 8);
          *(_QWORD *)(v62 + 64) = v61;
          if (!v61)
            goto LABEL_127;
          if (*(_WORD *)(v62 + 12))
          {
            v63 = 0;
            v64 = 0;
            do
            {
              v65 = *(_QWORD *)(v62 + 64);
              if (v176 == 1)
              {
                *(_DWORD *)(v65 + v63 + 4) = *(_DWORD *)(*(_QWORD *)v180 + v181);
                v66 = v181 + 4;
                LODWORD(v181) = v181 + 4;
                v67 = *(_QWORD *)v180;
              }
              else
              {
                v67 = *(_QWORD *)v180;
                v68 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
                LODWORD(v181) = v181 + 2;
                *(_DWORD *)(v65 + v63 + 4) = v68;
                v66 = v181;
              }
              v69 = v65 + v63;
              *(_WORD *)(v69 + 8) = *(_WORD *)(v67 + v66);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v69 + 10) = *(_WORD *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)v69 = *(_WORD *)(*(_QWORD *)v180 + v181);
              v70 = v181;
              LODWORD(v181) = v181 + 2;
              v71 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v70 + 4;
              *(_DWORD *)(v69 + 12) = v71;
              ++v64;
              v62 = *(_QWORD *)(v22 + 8);
              v63 += 16;
            }
            while (v64 < *(unsigned __int16 *)(v62 + 12));
          }
        }
        v72 = ssftriff_reader_DetachChunkData(v7, (uint64_t *)(v22 + 32), v180, v41, (uint64_t)v24, v25, v26, v27);
        if ((v72 & 0x80000000) != 0)
        {
          v29 = v72;
          v42 = 1;
          goto LABEL_96;
        }
        v73 = *(_QWORD *)v180;
        *(_QWORD *)(v22 + 40) = *(_QWORD *)v180;
        v74 = *(_QWORD *)(v22 + 8);
        v75 = v73 + *(unsigned int *)(v74 + 16);
        v76 = v73 + *(unsigned int *)(v74 + 40);
        *(_QWORD *)(v74 + 24) = v75;
        *(_QWORD *)(v74 + 32) = v76;
        v29 = ssftriff_reader_CloseChunk(v7);
        if ((v29 & 0x80000000) != 0)
          goto LABEL_95;
        v30 = *(_DWORD *)v22;
      }
      if (v30 > 5 || ((1 << v30) & 0x36) == 0)
        goto LABEL_100;
      Chunk = ssftriff_reader_FindChunk(v7, "DDAT", 1, (unsigned int *)&v181 + 1, v180);
      if ((Chunk & 0x80000000) != 0)
        goto LABEL_94;
      LODWORD(v181) = 0;
      v77 = **(_WORD **)v180;
      LODWORD(v181) = 2;
      v78 = v77 + 1;
      v79 = (_BYTE *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, (unsigned __int16)(v77 + 1));
      **(_QWORD **)(v22 + 16) = v79;
      if (!v79)
        goto LABEL_127;
      v179 = v78;
      v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v79, &v179);
      v42 = 1;
      if ((v29 & 0x80000000) == 0 && v179 == v78)
      {
        v80 = v181 + v78;
        LODWORD(v181) = v80;
        v81 = *(_QWORD *)v180;
        v82 = *(unsigned __int16 *)(*(_QWORD *)v180 + v80);
        LODWORD(v181) = v80 + 2;
        v83 = *(_QWORD *)(v22 + 16);
        *(_DWORD *)(v83 + 8) = v82;
        *(_WORD *)(v83 + 24) = *(_WORD *)(v81 + v80 + 2);
        LODWORD(v181) = v80 + 4;
        *(_WORD *)(*(_QWORD *)(v22 + 16) + 50) = *(_WORD *)(v81 + v80 + 4);
        LODWORD(v181) = v80 + 6;
        v84 = *(_QWORD *)(v22 + 16);
        *(_QWORD *)(v84 + 56) = 0;
        if (*(_WORD *)(v84 + 50))
        {
          v85 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 8 * *(unsigned __int16 *)(v84 + 50));
          v84 = *(_QWORD *)(v22 + 16);
          *(_QWORD *)(v84 + 56) = v85;
          if (v85)
          {
            if (*(_WORD *)(v84 + 50))
            {
              v86 = 0;
              v87 = v181;
              while (1)
              {
                v88 = *(_WORD *)(*(_QWORD *)v180 + v87);
                LODWORD(v181) = v87 + 2;
                v89 = v88 + 1;
                *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v22 + 16) + 56) + 8 * v86) = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, (unsigned __int16)(v88 + 1));
                v24 = *(_BYTE **)(*(_QWORD *)(*(_QWORD *)(v22 + 16) + 56) + 8 * v86);
                if (!v24)
                  goto LABEL_127;
                v90 = v89;
                v179 = v89;
                v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v24, &v179);
                v42 = 1;
                if ((v29 & 0x80000000) != 0 || v179 != v90)
                  goto LABEL_104;
                v87 = v181 + v90;
                LODWORD(v181) = v181 + v90;
                ++v86;
                v84 = *(_QWORD *)(v22 + 16);
                if (v86 >= *(unsigned __int16 *)(v84 + 50))
                  goto LABEL_64;
              }
            }
            goto LABEL_64;
          }
        }
        else
        {
LABEL_64:
          if (!*(_WORD *)(v84 + 24))
            goto LABEL_75;
          v91 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 72 * *(unsigned __int16 *)(v84 + 24));
          v84 = *(_QWORD *)(v22 + 16);
          *(_QWORD *)(v84 + 16) = v91;
          if (v91)
          {
            if (*(_WORD *)(v84 + 24))
            {
              v92 = 0;
              v93 = 40;
              while (1)
              {
                v94 = *(_QWORD *)(v84 + 16);
                v95 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
                LODWORD(v181) = v181 + 2;
                v173 = v94;
                v96 = v94 + v93;
                *(_WORD *)(v94 + v93 + 16) = v95;
                v97 = (void *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, v95 + 1);
                *(_QWORD *)(v96 + 8) = v97;
                if (!v97)
                  break;
                memcpy(v97, (const void *)(*(_QWORD *)v180 + v181), v95);
                *(_BYTE *)(*(_QWORD *)(v96 + 8) + v95) = 0;
                LODWORD(v181) = v181 + *(unsigned __int16 *)(v96 + 16);
                *(_WORD *)(v96 - 40) = *(_WORD *)(*(_QWORD *)v180 + v181);
                LODWORD(v181) = v181 + 2;
                *(_WORD *)(v96 - 38) = *(_WORD *)(*(_QWORD *)v180 + v181);
                v98 = v181;
                LODWORD(v181) = v181 + 2;
                v99 = *(_QWORD *)v180;
                v100 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
                LODWORD(v181) = v98 + 4;
                *(_DWORD *)(v96 + 20) = v100;
                v101 = *(unsigned __int16 *)(v99 + v181);
                LODWORD(v181) = v181 + 2;
                *(_DWORD *)(v96 + 24) = v101;
                v102 = *(unsigned __int16 *)(v99 + v181);
                LODWORD(v181) = v181 + 2;
                *(_DWORD *)(v96 - 32) = v102;
                if (v102 == 1)
                {
                  v103 = v173 + v93;
                  *(_WORD *)(v103 - 36) = *(_WORD *)(v99 + v181);
                  LODWORD(v181) = v181 + 2;
                  *(_WORD *)(v103 - 28) = *(_WORD *)(*(_QWORD *)v180 + v181);
                  LODWORD(v181) = v181 + 2;
                }
                if (!v177)
                {
                  v104 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
                  *(_WORD *)(v173 + v93) = v104;
                  v105 = v181;
                  LODWORD(v181) = v181 + 2;
                  if (v104)
                    LODWORD(v181) = v105 + 4 * (unsigned __int16)(v104 - 1) + 6;
                }
                ++v92;
                v84 = *(_QWORD *)(v22 + 16);
                v93 += 72;
                if (v92 >= *(unsigned __int16 *)(v84 + 24))
                  goto LABEL_75;
              }
            }
            else
            {
LABEL_75:
              v106 = v181;
              *(_WORD *)(v84 + 48) = *(_WORD *)(*(_QWORD *)v180 + v181);
              LODWORD(v181) = v106 + 2;
              v107 = *(_QWORD *)(v22 + 16);
              v108 = *(unsigned __int16 *)(v107 + 48);
              if (!*(_WORD *)(v107 + 48))
                goto LABEL_93;
              *(_QWORD *)(v107 + 40) = 0;
              v109 = heap_Calloc(*(_QWORD **)(v6[3] + 8), 1, 16 * v108);
              v110 = *(_QWORD *)(v22 + 16);
              *(_QWORD *)(v110 + 40) = v109;
              if (v109)
              {
                if (!*(_WORD *)(v110 + 48))
                {
LABEL_93:
                  v134 = ssftriff_reader_CloseChunk(v7);
LABEL_103:
                  v29 = v134;
                  v42 = 0;
                  goto LABEL_104;
                }
                v111 = 0;
                while (1)
                {
                  v112 = *(unsigned __int16 *)(*(_QWORD *)v180 + v181);
                  v171 = v111;
                  v113 = *(_QWORD *)(v110 + 40) + 16 * v111;
                  *(_WORD *)(v113 + 8) = v112;
                  v114 = (_WORD *)(v113 + 8);
                  LODWORD(v181) = v181 + 2;
                  *(_QWORD *)v113 = 0;
                  v115 = heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 24 * v112);
                  *(_QWORD *)v113 = v115;
                  if (!v115)
                    break;
                  if (*v114)
                  {
                    v116 = 0;
                    for (i = 0; i < (unsigned __int16)*v114; ++i)
                    {
                      *(_QWORD *)(*(_QWORD *)v113 + v116) = 0;
                      v118 = (_WORD *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 12);
                      *(_QWORD *)(*(_QWORD *)v113 + v116) = v118;
                      if (!v118)
                        goto LABEL_127;
                      v118[1] = 0;
                      v119 = *(_QWORD *)v180;
                      v120 = v181;
                      if (v177)
                      {
                        v121 = *(unsigned __int8 *)(*(_QWORD *)v180 + v181);
                        LODWORD(v181) = v181 + 1;
                        v122 = v181;
                        *v118 = v121;
                        v123 = *(unsigned __int8 *)(v119 + v122);
                        LODWORD(v181) = v120 + 2;
                        v118[2] = v123;
                      }
                      else
                      {
                        *v118 = *(_WORD *)(*(_QWORD *)v180 + v181);
                        v124 = v181;
                        LODWORD(v181) = v181 + 2;
                        *(_WORD *)(*(_QWORD *)(*(_QWORD *)v113 + v116) + 4) = *(_WORD *)(*(_QWORD *)v180
                                                                                         + v181);
                        LODWORD(v181) = v124 + 4;
                        if (v175 == 1)
                        {
                          *(_QWORD *)(*(_QWORD *)v113 + v116 + 8) = 0;
                          v125 = (_WORD *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, 2);
                          *(_QWORD *)(*(_QWORD *)v113 + v116 + 8) = v125;
                          if (!v125)
                            goto LABEL_127;
                          *v125 = *(_WORD *)(*(_QWORD *)v180 + v181);
                          v126 = v181;
                          LODWORD(v181) = v181 + 2;
                          v127 = *(_WORD *)(*(_QWORD *)v180 + v181);
                          LODWORD(v181) = v126 + 4;
                          v128 = v127 + 1;
                          v129 = (_BYTE *)heap_Calloc(*(_QWORD **)(*v6 + 8), 1, (unsigned __int16)(v127 + 1));
                          *(_QWORD *)(*(_QWORD *)v113 + v116 + 16) = v129;
                          if (!v129)
                          {
                            log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24048, 0, v130, v131, v132, v133, v169);
                            v163 = 10;
                            goto LABEL_138;
                          }
                          v179 = v128;
                          if ((ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v129, &v179) & 0x80000000) != 0
                            || v179 != v128)
                          {
                            v163 = 0;
LABEL_138:
                            v29 = FEDATA_ERROR(v163);
                            v21 = v178;
                            if ((v29 & 0x80000000) == 0)
                              goto LABEL_100;
                            goto LABEL_139;
                          }
                          LODWORD(v181) = v181 + v128;
                          v114 = (_WORD *)(v113 + 8);
                        }
                      }
                      v116 += 24;
                    }
                  }
                  v111 = v171 + 1;
                  v110 = *(_QWORD *)(v22 + 16);
                  if (v171 + 1 >= (unint64_t)*(unsigned __int16 *)(v110 + 48))
                    goto LABEL_93;
                }
              }
            }
LABEL_127:
            v161 = *(_QWORD *)(*v6 + 32);
            v162 = v6[23];
            v57 = 0;
LABEL_128:
            log_OutPublic(v161, v162, 24048, v57, (uint64_t)v24, v25, v26, v27, v169);
LABEL_129:
            v29 = FEDATA_ERROR(10);
            v42 = 1;
            goto LABEL_104;
          }
        }
LABEL_131:
        log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24048, 0, (uint64_t)v24, v25, v26, v27, v169);
        v29 = FEDATA_ERROR(10);
      }
LABEL_104:
      v21 = v178;
      if ((v29 & 0x80000000) != 0)
        goto LABEL_96;
LABEL_97:
      if (v42)
        ssftriff_reader_CloseChunk(v7);
      if ((v29 & 0x80000000) != 0)
      {
LABEL_139:
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 8 * v20) = 0;
        log_OutPublic(*(_QWORD *)(*v6 + 32), v6[23], 24044, 0, (uint64_t)v24, v25, v26, v27, v169);
        goto LABEL_142;
      }
LABEL_100:
      log_OutText(*(_QWORD *)(*v6 + 32), v6[23], 4, 0, (uint64_t)"loaded data block %d", v25, v26, v27, v20);
      v20 = (unsigned __int16)v20 + 1;
      if (v20 >= *v21)
        return v29;
    }
  }
  return 0;
}

uint64_t readDataBlockFromFile_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  unsigned __int16 *v3;
  uint64_t inited;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int16 v37;
  unint64_t i;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 v46;
  unint64_t j;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned __int16 *v55;
  unsigned int v56;
  _QWORD **v57;
  uint64_t v58;

  v3 = *(unsigned __int16 **)(a3 + 32);
  v58 = 0;
  inited = InitRsrcFunction(a1, a2, &v58);
  v11 = inited;
  if ((inited & 0x80000000) == 0)
  {
    if (v3)
    {
      v12 = *((_QWORD *)v3 + 1);
      if (v12)
      {
        v13 = *v3;
        if (*v3)
        {
          v56 = inited;
          v14 = 0;
          v55 = v3;
          while (1)
          {
            v15 = *(_QWORD *)(*((_QWORD *)v3 + 1) + 8 * v14);
            if (v15)
            {
              v16 = *(_QWORD **)(v15 + 32);
              if (v16)
              {
                v56 = ssftriff_reader_ReleaseChunkData(v16, v12, v5, v6, v7, v8, v9, v10);
                if ((v56 & 0x80000000) != 0)
                  return v56;
                *(_QWORD *)(v15 + 32) = 0;
                *(_QWORD *)(v15 + 40) = 0;
              }
              v57 = (_QWORD **)(v15 + 32);
              v17 = v58;
              v19 = *(_QWORD *)(v15 + 8);
              v18 = *(_QWORD *)(v15 + 16);
              v20 = *(_QWORD *)(v15 + 24);
              if (v19)
              {
                if (*(_DWORD *)v15 <= 5u && ((1 << *(_DWORD *)v15) & 0x2D) != 0)
                {
                  heap_Free(*(_QWORD **)(v58 + 8), *(_QWORD *)v19);
                  *(_QWORD *)v19 = 0;
                  v22 = *(_QWORD *)(v19 + 48);
                  if (v22)
                  {
                    if (*(_WORD *)(v19 + 8))
                    {
                      v23 = 0;
                      v24 = 0;
                      do
                      {
                        v25 = *(_QWORD *)(v19 + 48) + v23;
                        v26 = *(_QWORD *)(v25 + 8);
                        if (v26)
                        {
                          FEData_freeEntry((_QWORD *)v17, v26, 1);
                          heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v25 + 8));
                          *(_QWORD *)(v25 + 8) = 0;
                        }
                        v27 = *(_QWORD *)(v25 + 16);
                        if (v27)
                        {
                          FEData_freeEntry((_QWORD *)v17, v27, 1);
                          heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v25 + 16));
                          *(_QWORD *)(v25 + 16) = 0;
                        }
                        ++v24;
                        v23 += 32;
                      }
                      while (v24 < *(unsigned __int16 *)(v19 + 8));
                      v22 = *(_QWORD *)(v19 + 48);
                      v3 = v55;
                    }
                    heap_Free(*(_QWORD **)(v17 + 8), v22);
                    *(_QWORD *)(v19 + 48) = 0;
                  }
                  v28 = *(_QWORD *)(v19 + 64);
                  if (v28)
                  {
                    heap_Free(*(_QWORD **)(v17 + 8), v28);
                    *(_QWORD *)(v19 + 64) = 0;
                  }
                  heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v15 + 8));
                  *(_QWORD *)(v15 + 8) = 0;
                }
              }
              if (v18)
              {
                if (*(_DWORD *)v15 <= 5u && ((1 << *(_DWORD *)v15) & 0x36) != 0)
                {
                  if (*(_QWORD *)v18)
                  {
                    heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)v18);
                    *(_QWORD *)v18 = 0;
                  }
                  v30 = *(_QWORD *)(v18 + 56);
                  if (v30)
                  {
                    if (*(_WORD *)(v18 + 50))
                    {
                      v31 = 0;
                      do
                      {
                        heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(*(_QWORD *)(v18 + 56) + 8 * v31));
                        *(_QWORD *)(*(_QWORD *)(v18 + 56) + 8 * v31++) = 0;
                      }
                      while (v31 < *(unsigned __int16 *)(v18 + 50));
                      v30 = *(_QWORD *)(v18 + 56);
                    }
                    heap_Free(*(_QWORD **)(v17 + 8), v30);
                    *(_QWORD *)(v18 + 56) = 0;
                  }
                  if (*(_QWORD *)(v18 + 16))
                  {
                    if (*(_WORD *)(v18 + 24))
                    {
                      v32 = 0;
                      v33 = 0;
                      do
                      {
                        v34 = *(_QWORD *)(v18 + 16) + v32;
                        heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v34 + 48));
                        *(_QWORD *)(v34 + 48) = 0;
                        v35 = *(_QWORD *)(v34 + 16);
                        if (v35)
                        {
                          heap_Free(*(_QWORD **)(v17 + 8), v35);
                          *(_QWORD *)(v34 + 16) = 0;
                        }
                        ++v33;
                        v32 += 72;
                      }
                      while (v33 < *(unsigned __int16 *)(v18 + 24));
                    }
                    v36 = *(_QWORD *)(v18 + 40);
                    v3 = v55;
                    if (v36)
                    {
                      v37 = *(_WORD *)(v18 + 48);
                      if (v37)
                      {
                        for (i = 0; i < v37; ++i)
                        {
                          v39 = *(_QWORD *)(v18 + 40) + 16 * i;
                          v40 = *(_QWORD *)v39;
                          if (*(_QWORD *)v39)
                          {
                            if (*(_WORD *)(v39 + 8))
                            {
                              v41 = 0;
                              v42 = 0;
                              do
                              {
                                heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v40 + v41));
                                v43 = (_QWORD *)(*(_QWORD *)v39 + v41);
                                *v43 = 0;
                                heap_Free(*(_QWORD **)(v17 + 8), v43[1]);
                                v44 = *(_QWORD *)v39 + v41;
                                *(_QWORD *)(v44 + 8) = 0;
                                heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v44 + 16));
                                v40 = *(_QWORD *)v39;
                                *(_QWORD *)(*(_QWORD *)v39 + v41 + 16) = 0;
                                ++v42;
                                v41 += 24;
                              }
                              while (v42 < *(unsigned __int16 *)(v39 + 8));
                            }
                            heap_Free(*(_QWORD **)(v17 + 8), v40);
                            *(_QWORD *)v39 = 0;
                            v37 = *(_WORD *)(v18 + 48);
                          }
                        }
                        v36 = *(_QWORD *)(v18 + 40);
                        v3 = v55;
                      }
                      heap_Free(*(_QWORD **)(v17 + 8), v36);
                      *(_QWORD *)(v18 + 40) = 0;
                    }
                    heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v18 + 16));
                    *(_QWORD *)(v18 + 16) = 0;
                  }
                  heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)(v15 + 16));
                  *(_QWORD *)(v15 + 16) = 0;
                }
              }
              if (v20)
              {
                v45 = *(_QWORD *)(v20 + 8);
                if (v45)
                {
                  v46 = *(_WORD *)(v20 + 16);
                  if (v46)
                  {
                    for (j = 0; j < v46; ++j)
                    {
                      v48 = *(_QWORD *)(v20 + 8);
                      v49 = *(_QWORD *)(v48 + 8 * j);
                      if (v49)
                      {
                        if (*(_QWORD *)v49)
                        {
                          heap_Free(*(_QWORD **)(v17 + 8), *(_QWORD *)v49);
                          v48 = *(_QWORD *)(v20 + 8);
                          **(_QWORD **)(v48 + 8 * j) = 0;
                          v49 = *(_QWORD *)(v48 + 8 * j);
                        }
                        v50 = *(_QWORD *)(v49 + 16);
                        if (v50)
                        {
                          if (*(_WORD *)(v49 + 12))
                          {
                            v51 = 0;
                            do
                            {
                              v52 = *(_QWORD *)(*(_QWORD *)(v49 + 16) + 8 * v51);
                              if (v52)
                              {
                                heap_Free(*(_QWORD **)(v17 + 8), v52);
                                *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v20 + 8) + 8 * j) + 16) + 8 * v51) = 0;
                                v48 = *(_QWORD *)(v20 + 8);
                              }
                              ++v51;
                              v49 = *(_QWORD *)(v48 + 8 * j);
                            }
                            while (v51 < *(unsigned __int16 *)(v49 + 12));
                            v50 = *(_QWORD *)(v49 + 16);
                          }
                          heap_Free(*(_QWORD **)(v17 + 8), v50);
                          v53 = *(_QWORD *)(v20 + 8);
                          *(_QWORD *)(*(_QWORD *)(v53 + 8 * j) + 16) = 0;
                          v49 = *(_QWORD *)(v53 + 8 * j);
                        }
                        *(_WORD *)(v49 + 12) = 0;
                        heap_Free(*(_QWORD **)(v17 + 8), v49);
                        *(_QWORD *)(*(_QWORD *)(v20 + 8) + 8 * j) = 0;
                        v46 = *(_WORD *)(v20 + 16);
                      }
                    }
                    v45 = *(_QWORD *)(v20 + 8);
                  }
                  heap_Free(*(_QWORD **)(v17 + 8), v45);
                  *(_QWORD *)(v20 + 8) = 0;
                }
                *(_WORD *)(v20 + 16) = 0;
                heap_Free(*(_QWORD **)(v17 + 8), v20);
              }
              if (*v57)
              {
                ssftriff_reader_ReleaseChunkData(*v57, v12, v5, v6, v7, v8, v9, v10);
                *v57 = 0;
                *(_QWORD *)(v15 + 40) = 0;
              }
              heap_Free(*(_QWORD **)(v17 + 8), v15);
              v13 = *v3;
            }
            if (++v14 >= (unint64_t)v13)
            {
              v12 = *((_QWORD *)v3 + 1);
              v11 = v56;
              break;
            }
          }
        }
        heap_Free(*(_QWORD **)(v58 + 8), v12);
        heap_Free(*(_QWORD **)(v58 + 8), (uint64_t)v3);
      }
    }
  }
  return v11;
}

uint64_t partialMatchFoundInBasicToken_NNTN(uint64_t result, __int16 *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *i;
  int v6;
  int v7;
  int Type;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int16 v14;
  char *__s1;
  uint64_t v16;

  v16 = 0;
  if (result)
  {
    v2 = (uint64_t *)result;
    v3 = *(_QWORD *)(*(_QWORD *)(result + 264) + 16);
    for (i = *(uint64_t **)(v3 + 80); (unint64_t)i < *(_QWORD *)(v3 + 88); ++i)
    {
      __s1 = 0;
      v6 = LDOTreeNode_ComputeAbsoluteFrom(*i, (_DWORD *)&v16 + 1);
      if ((LH_ERROR_to_VERROR(v6) & 0x80000000) != 0)
        break;
      v7 = LDOTreeNode_ComputeAbsoluteTo(*i, &v16);
      if ((LH_ERROR_to_VERROR(v7) & 0x80000000) != 0)
        break;
      Type = LDOObject_GetType(*i, (uint64_t *)&__s1);
      if ((LH_ERROR_to_VERROR(Type) & 0x80000000) != 0)
        break;
      v9 = __s1;
      if (!strcmp(__s1, "TOKEN_ALPHA")
        || !strcmp(v9, "TOKEN_DIGIT")
        || !strcmp(v9, "TOKEN_PUNCT")
        || !strcmp(v9, "TOKEN_WSPACE"))
      {
        v13 = *a2;
        if (__PAIR64__((__int16)v16, SWORD2(v16)) != __PAIR64__(a2[1], v13))
        {
          if (SWORD2(v16) >= (int)v13)
          {
            v14 = a2[1];
          }
          else
          {
            v14 = a2[1];
            if ((int)v13 < (__int16)v16)
              goto LABEL_20;
          }
          if (SWORD2(v16) < v14 && v14 < (__int16)v16)
          {
LABEL_20:
            log_OutText(*(_QWORD *)(*v2 + 32), v2[23], 5, 0, (uint64_t)"Regex match %d,%d bisects basic token %d,%d", v10, v11, v12, v13);
            return 1;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t tokenizer_apply_regex_NNTN(uint64_t *a1, uint64_t a2, size_t **a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int16 v16;
  uint64_t v17;
  __int16 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  int v23;
  uint64_t v24;
  size_t *v25;
  int v26;
  uint64_t v27;
  int v29;
  int v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int16 *)(a2 + 44);
  v29 = 0;
  v7 = nuance_pcre_exec((_QWORD *)a1[17], a1[18], *(_QWORD *)(a2 + 32), *(int **)a2, (char *)a1[38], *(unsigned __int16 *)(a2 + 42), v6, *(unsigned __int16 *)(a2 + 64), &v30, 100);
  v11 = v31;
  if (v31 > *(unsigned __int16 *)(a2 + 46))
    goto LABEL_13;
  if ((v7 & 0x80000000) != 0)
  {
    v12 = nuance_pcre_ErrorToLhError(v7);
    if (v12 >> 20 == 2213)
    {
      v14 = v12;
      if ((v12 & 0x1FFF) == 0xA)
      {
        v15 = 11002;
        goto LABEL_23;
      }
      if ((v12 & 0x1FFF) != 0x14)
      {
        v15 = 11027;
LABEL_23:
        log_OutPublic(*(_QWORD *)(*a1 + 32), a1[23], v15, "%s%x%s%s", v13, v8, v9, v10, "lhError");
        return v14;
      }
      goto LABEL_13;
    }
    v11 = v31;
  }
  v16 = v30;
  v17 = *(_QWORD *)(a2 + 16);
  v18 = *(__int16 **)(v17 + 8);
  *v18 = v30;
  v18[1] = v11;
  if (!(v16 | (unsigned __int16)v11))
    goto LABEL_13;
  if (*(_DWORD *)(v17 + 44) != 1)
  {
    if (partialMatchFoundInBasicToken_NNTN((uint64_t)a1, v18) != 1)
      goto LABEL_19;
    log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"token %s invalidated.", v19, v20, v21, *(_QWORD *)(a2 + 24));
LABEL_13:
    v22 = 1;
    goto LABEL_14;
  }
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"token %s already validated", v8, v9, v10, *(_QWORD *)(a2 + 24));
LABEL_19:
  *(_QWORD *)(**(_QWORD **)(a2 + 16) + 96) = *(_QWORD *)(a2 + 56);
  v27 = sortExpansionNNTN(a1, a2);
  if ((v27 & 0x80000000) != 0)
    return v27;
  v22 = 0;
  *(_DWORD *)(a2 + 72) = 1;
LABEL_14:
  v23 = LDOTreeNode_ComputeAbsoluteTo(**a3, &v29);
  v24 = LH_ERROR_to_VERROR(v23);
  v14 = v24;
  if ((v22 & 1) == 0 && (v24 & 0x80000000) == 0)
  {
    do
    {
      if ((unsigned __int16)v29 >= *(__int16 *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8) + 2))
        break;
      v25 = (*a3)++;
      v26 = LDOTreeNode_ComputeAbsoluteTo(v25[1], &v29);
      v14 = LH_ERROR_to_VERROR(v26);
    }
    while ((v14 & 0x80000000) == 0);
  }
  return v14;
}

uint64_t tokenizer_NNTN_ObjOpen(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  _QWORD **v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t Map;
  uint64_t i;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;

  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjOpen Begin", a6, a7, a8, v47);
  v9 = heap_Calloc(*(_QWORD **)(*a1 + 8), 1, 8);
  if (!v9)
  {
    log_OutPublic(*(_QWORD *)(*a1 + 32), a1[23], 24048, 0, v10, v11, v12, v13, v48);
    return NNTNERROR(10);
  }
  v14 = v9;
  a1[21] = v9;
  v15 = heap_Calloc(*(_QWORD **)(*a1 + 8), 1, 80);
  *(_QWORD *)v14 = v15;
  v20 = *a1;
  if (v15)
  {
    v21 = heap_Calloc(*(_QWORD **)(v20 + 8), 1, 40);
    **(_QWORD **)v14 = v21;
    v20 = *a1;
    if (v21)
    {
      v22 = heap_Calloc(*(_QWORD **)(v20 + 8), 1, 64);
      *(_QWORD *)(*(_QWORD *)v14 + 16) = v22;
      v20 = *a1;
      if (v22)
      {
        v23 = (_DWORD *)heap_Calloc(*(_QWORD **)(v20 + 8), 1, 4);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 16) + 8) = v23;
        if (v23)
        {
          *v23 = 0;
          v24 = heap_Calloc(*(_QWORD **)(*a1 + 8), 1, 112);
          v25 = *(_QWORD ***)v14;
          v26 = *(_QWORD *)(*(_QWORD *)v14 + 16);
          *(_QWORD *)v26 = v24;
          if (v24)
          {
            *(_QWORD *)(v24 + 96) = 0;
            *(_WORD *)(v26 + 40) = 0;
            *(_DWORD *)(v26 + 48) = 0;
            *(_QWORD *)(v26 + 16) = 0;
            *(_QWORD *)(v26 + 24) = 0;
            v27 = *v25;
            *v27 |= 4uLL;
            v27[3] = v26;
            v50 = 0;
            log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : InitCheckFunctions Begin", v17, v18, v19, v48);
            Map = FEFunctionMap_GetMap(a1, &v50);
            if ((Map & 0x80000000) != 0)
            {
              v38 = Map;
            }
            else
            {
              for (i = 0; i != 128; i += 16)
              {
                v30 = ssftmap_Insert(v50, *(uint64_t *)((char *)&off_1EA93F080 + i), *(uint64_t *)((char *)&off_1EA93F080 + i + 8));
                if ((v30 & 0x80000000) != 0)
                {
                  v38 = v30;
                  log_OutPublic(*(_QWORD *)(*a1 + 32), a1[23], 21011, 0, v31, v32, v33, v34, v49);
                  goto LABEL_20;
                }
              }
              v38 = FEFunctionMap_AddFunctionMap((uint64_t)a1, 0, v50);
              if ((v38 & 0x80000000) == 0)
                goto LABEL_21;
            }
LABEL_20:
            ssftmap_ObjClose(v50);
LABEL_21:
            log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : InitCheckFunctions End (%x)", v35, v36, v37, v38);
            if ((v38 & 0x80000000) == 0)
              goto LABEL_17;
            goto LABEL_16;
          }
        }
        v20 = *a1;
      }
    }
  }
  log_OutPublic(*(_QWORD *)(v20 + 32), a1[23], 24048, 0, v16, v17, v18, v19, v48);
  v38 = NNTNERROR(10);
  if ((v38 & 0x80000000) != 0)
LABEL_16:
    tokenizer_loc_ObjClose(a1, v40, v41, v42, v43, v44, v45, v46);
LABEL_17:
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjOpen End (%x)", v44, v45, v46, v38);
  return v38;
}

uint64_t tokenizer_loc_ObjClose(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v9 = a1[21];
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : loc ObjClose Begin", a6, a7, a8, v16);
  v10 = *(uint64_t **)v9;
  if (*(_QWORD *)v9)
  {
    v11 = (uint64_t *)v10[2];
    if (v11)
    {
      if (v11[1])
      {
        heap_Free(*(_QWORD **)(*a1 + 8), v11[1]);
        v11 = *(uint64_t **)(*(_QWORD *)v9 + 16);
        v11[1] = 0;
      }
      if (*v11)
      {
        heap_Free(*(_QWORD **)(*a1 + 8), *v11);
        v11 = *(uint64_t **)(*(_QWORD *)v9 + 16);
        *v11 = 0;
      }
      heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v11);
      v10 = *(uint64_t **)v9;
      *(_QWORD *)(*(_QWORD *)v9 + 16) = 0;
    }
    if (*v10)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), *v10);
      v10 = *(uint64_t **)v9;
      **(_QWORD **)v9 = 0;
    }
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v10);
    *(_QWORD *)v9 = 0;
  }
  heap_Free(*(_QWORD **)(*a1 + 8), v9);
  a1[21] = 0;
  return log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : loc ObjClose End (%x)", v12, v13, v14, 0);
}

uint64_t tokenizer_NNTN_ObjClose(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  if (!a1[21])
    return NNTNERROR(8);
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjClose Begin", a6, a7, a8, v20);
  tokenizer_loc_ObjClose(a1, v9, v10, v11, v12, v13, v14, v15);
  log_OutText(*(_QWORD *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjOpen End (%x)", v16, v17, v18, 0);
  return 0;
}

uint64_t fe_nnws_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2588942337;
  result = 0;
  *a2 = &IFeNNWS;
  return result;
}

uint64_t fe_nnws_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2588942343;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_nnws_ClassClose()
{
  return 0;
}

uint64_t fe_nnws_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t Object;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t (*v28)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _OWORD v59[16];
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  v58 = 0;
  v55 = 0;
  v56 = 0;
  v5 = 2588942343;
  v49 = 0;
  v50 = 0;
  memset(v59, 0, sizeof(v59));
  if (!a5)
    return v5;
  v54 = 0;
  v52 = 0uLL;
  v53 = 0uLL;
  v51 = 0;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a1, a2, &v57);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = InitRsrcFunction(a3, a4, &v58);
  if ((inited & 0x80000000) != 0)
    return inited;
  v12 = heap_Calloc(*(_QWORD **)(v58 + 8), 1, 208);
  if (!v12)
  {
    log_OutPublic(*(_QWORD *)(v58 + 32), (uint64_t)"FE_NNWS", 75000, 0, v13, v14, v15, v16, v47);
    v5 = 2588942346;
LABEL_25:
    fe_nnws_ObjClose(*(uint64_t **)a5, *(_QWORD *)(a5 + 8));
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    return v5;
  }
  v17 = v12;
  Object = objc_GetObject(*(_QWORD *)(v58 + 48), (uint64_t)"LINGDB", &v56);
  if ((Object & 0x80000000) != 0)
    goto LABEL_24;
  *(_QWORD *)(v17 + 48) = *(_QWORD *)(v56 + 8);
  Object = objc_GetObject(*(_QWORD *)(v58 + 48), (uint64_t)"FE_DCTLKP", &v55);
  if ((Object & 0x80000000) != 0)
    goto LABEL_24;
  v22 = v55;
  *(_QWORD *)(v17 + 56) = *(_QWORD *)(v55 + 8);
  *(_OWORD *)(v17 + 64) = *(_OWORD *)(v22 + 16);
  *(_QWORD *)v17 = v58;
  *(_QWORD *)(v17 + 8) = a3;
  v23 = v57;
  *(_QWORD *)(v17 + 16) = a4;
  *(_QWORD *)(v17 + 24) = v23;
  *(_QWORD *)(v17 + 32) = a1;
  *(_QWORD *)(v17 + 40) = a2;
  *(_QWORD *)(v17 + 104) = 0;
  Object = fe_nnws_loadCfg(v17);
  if ((Object & 0x80000000) != 0
    || (*(_QWORD *)(v17 + 128) = 0, Object = nn_word_lkp_GetInterface(1u, &v51), (Object & 0x80000000) != 0))
  {
LABEL_24:
    v5 = Object;
    log_OutText(*(_QWORD *)(*(_QWORD *)v17 + 32), (uint64_t)"FE_NNWS", 2, 0, (uint64_t)"fe_nnws ObjOpen Failed!", v19, v20, v21, v47);
    goto LABEL_25;
  }
  *(_QWORD *)(v17 + 128) = v51;
  *(_QWORD *)(v17 + 136) = safeh_GetNullHandle();
  *(_QWORD *)(v17 + 144) = v24;
  *(_QWORD *)(v17 + 152) = safeh_GetNullHandle();
  *(_QWORD *)(v17 + 160) = v25;
  *(_QWORD *)(v17 + 168) = safeh_GetNullHandle();
  *(_QWORD *)(v17 + 176) = v26;
  v27 = *(_QWORD *)(v17 + 136);
  v28 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v17 + 128)
                                                                                            + 16);
  v29 = *(_QWORD *)(v17 + 144);
  v30 = *(_QWORD *)(v17 + 8);
  v31 = *(_QWORD *)(v17 + 16);
  if (*(_DWORD *)(v17 + 200))
  {
    Object = v28(v27, v29, "albert", v30, v31, v17 + 152);
    if ((Object & 0x80000000) != 0)
      goto LABEL_24;
  }
  else
  {
    Object = v28(v27, v29, "char", v30, v31, v17 + 152);
    if ((Object & 0x80000000) != 0)
      goto LABEL_24;
    v53 = *(_OWORD *)(v17 + 152);
    *((_QWORD *)&v52 + 1) = v51;
    Object = objc_RegisterObject(*(_QWORD *)(v58 + 48), (uint64_t)"NNCHRLKP", &v52);
    if ((Object & 0x80000000) != 0)
      goto LABEL_24;
  }
  if (!*(_DWORD *)(v17 + 200))
  {
    Object = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(v17 + 128)
                                                                                              + 16))(*(_QWORD *)(v17 + 136), *(_QWORD *)(v17 + 144), "nnws_wlist", *(_QWORD *)(v17 + 8), *(_QWORD *)(v17 + 16), v17 + 168);
    if ((Object & 0x80000000) != 0)
      goto LABEL_24;
  }
  Object = fe_nnws_CreateBrokerString(*(_QWORD *)v17, (char *)v59);
  if ((Object & 0x80000000) != 0)
    goto LABEL_24;
  v32 = fi_init(a3, a4, a1, a2, &v50, 0, (uint64_t)v59, (uint64_t)"FINN", 1, 0);
  if ((v32 & 0x80000000) != 0)
  {
    v5 = v32;
    v45 = *(_QWORD *)(*(_QWORD *)v17 + 32);
    v46 = "create FI model failed";
LABEL_29:
    log_OutText(v45, (uint64_t)"FE_NNWS", 5, 0, (uint64_t)v46, v33, v34, v35, v48);
    return v5;
  }
  *(_QWORD *)(v17 + 80) = v50;
  v36 = fe_nnws_tagInit(*(_QWORD *)v17, &v49);
  if ((v36 & 0x80000000) != 0)
  {
    v5 = v36;
    v45 = *(_QWORD *)(*(_QWORD *)v17 + 32);
    v46 = "create SBME tags failed";
    goto LABEL_29;
  }
  *(_QWORD *)(v17 + 120) = v49;
  v37 = (uint64_t *)(v17 + 184);
  v5 = fe_nnws_tryLoadingIGTree(*(_WORD **)(v17 + 8), *(_QWORD *)(v17 + 16), *(_QWORD *)v17, (char **)(v17 + 184));
  if ((v5 & 0x80000000) != 0)
  {
    if (*v37)
    {
      igtree_Deinit(*(_QWORD *)v17, *v37, v38, v39, v40, v41, v42, v43);
      heap_Free(*(_QWORD **)(*(_QWORD *)v17 + 8), *(_QWORD *)(v17 + 184));
      v5 = 0;
      *(_QWORD *)(v17 + 184) = 0;
    }
    else
    {
      v5 = 0;
    }
  }
  *(_QWORD *)a5 = v17;
  *(_DWORD *)(a5 + 8) = 62346;
  return v5;
}

uint64_t fe_nnws_ObjClose(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t i;
  uint64_t v15;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 62346, 208);
  if ((v3 & 0x80000000) != 0)
    return 2588942344;
  v9 = v3;
  if (a1)
  {
    if (a1[6])
      objc_ReleaseObject(*(_QWORD *)(*a1 + 48), (uint64_t)"LINGDB");
    if (a1[7])
      objc_ReleaseObject(*(_QWORD *)(*a1 + 48), (uint64_t)"FE_DCTLKP");
    v10 = a1[16];
    if (v10)
    {
      v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 24))(a1[19], a1[20]);
      v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[16] + 24))(a1[21], a1[22]);
      if ((v9 & 0x80000000) == 0 && (v11 & 0x80000000) == 0)
        objc_UnregisterObject(*(_QWORD *)(*a1 + 48), (uint64_t)"NNCHRLKP");
    }
    v12 = a1[14];
    if (v12)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v12);
      a1[14] = 0;
    }
    v13 = (uint64_t *)a1[10];
    if (v13)
      v9 = fi_deinit(*a1, a1[3], v13);
    if (a1[15])
    {
      for (i = 0; i != 32; i += 8)
      {
        heap_Free(*(_QWORD **)(*a1 + 8), *(_QWORD *)(a1[15] + i));
        *(_QWORD *)(a1[15] + i) = 0;
      }
      heap_Free(*(_QWORD **)(*a1 + 8), a1[15]);
      a1[15] = 0;
    }
    v15 = a1[23];
    if (v15)
    {
      igtree_Deinit(*a1, v15, (uint64_t)v13, v4, v5, v6, v7, v8);
      heap_Free(*(_QWORD **)(*a1 + 8), a1[23]);
      a1[23] = 0;
    }
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)a1);
  }
  return v9;
}

uint64_t fe_nnws_ObjReopen(_QWORD *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t *v13;
  uint64_t Cfg;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, _QWORD *);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  _OWORD v44[16];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v43 = 0;
  v4 = 2588942342;
  v39 = 0;
  memset(v44, 0, sizeof(v44));
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62346, 208) & 0x80000000) != 0)
    return 2588942344;
  if (a1)
  {
    v42 = 0;
    v40 = 0u;
    v41 = 0u;
    v10 = a1[16];
    if (v10)
    {
      v11 = (*(uint64_t (**)(_QWORD, _QWORD))(v10 + 24))(a1[19], a1[20]);
      v12 = (*(uint64_t (**)(_QWORD, _QWORD))(a1[16] + 24))(a1[21], a1[22]);
      if ((v11 & 0x80000000) == 0 && (v12 & 0x80000000) == 0)
        objc_UnregisterObject(*(_QWORD *)(*a1 + 48), (uint64_t)"NNCHRLKP");
    }
    v13 = (uint64_t *)a1[10];
    if (v13)
    {
      Cfg = fi_deinit(*a1, a1[3], v13);
      if ((Cfg & 0x80000000) != 0)
      {
LABEL_29:
        v4 = Cfg;
LABEL_30:
        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 2, 0, (uint64_t)"fe_nnws ObjReopen Failed!", v7, v8, v9, v37);
        fe_nnws_ObjClose(a1, a2);
        return v4;
      }
      a1[10] = 0;
    }
    v15 = a1[14];
    if (v15)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v15);
      a1[14] = 0;
    }
    v17 = a1 + 23;
    v16 = a1[23];
    if (v16)
    {
      igtree_Deinit(*a1, v16, (uint64_t)v13, v5, v6, v7, v8, v9);
      heap_Free(*(_QWORD **)(*a1 + 8), a1[23]);
      a1[23] = 0;
    }
    a1[13] = 0;
    Cfg = fe_nnws_loadCfg((uint64_t)a1);
    if ((Cfg & 0x80000000) != 0)
      goto LABEL_29;
    Cfg = nn_word_lkp_GetInterface(1u, &v43);
    if ((Cfg & 0x80000000) != 0)
      goto LABEL_29;
    a1[16] = v43;
    a1[17] = safeh_GetNullHandle();
    a1[18] = v18;
    a1[19] = safeh_GetNullHandle();
    a1[20] = v19;
    a1[21] = safeh_GetNullHandle();
    a1[22] = v20;
    v21 = a1[17];
    v22 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, _QWORD *))(a1[16] + 16);
    v23 = a1[18];
    v24 = a1[1];
    v25 = a1[2];
    if (*((_DWORD *)a1 + 50))
    {
      Cfg = v22(v21, v23, "albert", v24, v25, a1 + 19);
      if ((Cfg & 0x80000000) != 0)
        goto LABEL_29;
    }
    else
    {
      Cfg = v22(v21, v23, "char", v24, v25, a1 + 19);
      if ((Cfg & 0x80000000) != 0)
        goto LABEL_29;
      v41 = *(_OWORD *)(a1 + 19);
      *((_QWORD *)&v40 + 1) = v43;
      Cfg = objc_RegisterObject(*(_QWORD *)(*a1 + 48), (uint64_t)"NNCHRLKP", &v40);
      if ((Cfg & 0x80000000) != 0)
        goto LABEL_29;
    }
    if (!*((_DWORD *)a1 + 50))
    {
      Cfg = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD, _QWORD *))(a1[16] + 16))(a1[17], a1[18], "nnws_wlist", a1[1], a1[2], a1 + 21);
      if ((Cfg & 0x80000000) != 0)
        goto LABEL_29;
    }
    Cfg = fe_nnws_CreateBrokerString(*a1, (char *)v44);
    if ((Cfg & 0x80000000) != 0)
      goto LABEL_29;
    v26 = fi_init((_WORD *)a1[1], a1[2], (_WORD *)a1[4], a1[5], &v39, 0, (uint64_t)v44, (uint64_t)"FINN", 1, 0);
    if ((v26 & 0x80000000) != 0)
    {
      v4 = v26;
      log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"re-create FI model failed", v27, v28, v29, v38);
      goto LABEL_30;
    }
    a1[10] = v39;
    v4 = fe_nnws_tryLoadingIGTree((_WORD *)a1[1], a1[2], *a1, (char **)a1 + 23);
    if ((v4 & 0x80000000) != 0)
    {
      if (*v17)
      {
        igtree_Deinit(*a1, *v17, v30, v31, v32, v33, v34, v35);
        heap_Free(*(_QWORD **)(*a1 + 8), a1[23]);
        v4 = 0;
        a1[23] = 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return v4;
}

uint64_t fe_nnws_ProcessStart(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62346, 208);
  if ((int)result >= 0)
    return result;
  else
    return 2588942344;
}

uint64_t fe_nnws_Process(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v5;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  size_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t UTF8Char;
  unsigned __int16 v32;
  uint64_t v33;
  int v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  _DWORD *v54;
  int v55;
  _DWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  unint64_t v63;
  int v64;
  int *v65;
  uint64_t v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  int v73;
  int v74;
  int32x2_t *v75;
  _DWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const char *v81;
  _DWORD *v82;
  uint64_t v83;
  _DWORD *v84;
  int v85;
  _DWORD *v86;
  uint64_t v87;
  unsigned int v88;
  int v89;
  int v90;
  int v91;
  int32x2_t *v92;
  int v93;
  size_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  unsigned __int16 v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  unsigned int v112;
  uint64_t v113;
  __int16 v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  int v123;
  _DWORD *v124;
  _DWORD *v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t (**v128)(_QWORD, _QWORD, uint64_t, _DWORD *);
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t (**v134)(_QWORD, _QWORD, _QWORD, _DWORD *);
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t ***v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unsigned int v149;
  unsigned int v150;
  _BOOL4 v151;
  uint64_t v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  uint64_t v156;
  int v157;
  int v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unsigned int v162;
  uint64_t v163;
  unsigned int v164;
  uint64_t v165;
  int v166;
  const void *v167;
  uint64_t *v168;
  unsigned int v169;
  uint64_t *v170;
  char *v171;
  char *__s;
  int v173;
  __int16 v174;
  int v175;
  unsigned __int16 v176;
  __int16 v177;
  int v178;
  uint64_t v179;
  uint64_t v180;
  const char *v181;
  int v182;
  int v183;
  const char *v184;
  int v185;
  char __src[2];

  v176 = 0;
  v171 = 0;
  __s = 0;
  v5 = 2588942346;
  v170 = 0;
  v169 = 0;
  v167 = 0;
  v168 = 0;
  v166 = 0;
  *a5 = 1;
  if (!a1)
    return 2588942343;
  v175 = 0;
  v174 = 0;
  v173 = 0;
  v9 = log_GetLogLevel(*(_QWORD *)(*a1 + 32)) > 4;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a1[6] + 104))(a3, a4, 1, 0, &v176);
  if ((v10 & 0x80000000) != 0)
  {
    v11 = v10;
LABEL_19:
    v12 = 0;
    goto LABEL_20;
  }
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, __int16 *))(a1[6] + 184))(a3, a4, v176, 0, &v174);
  v12 = 0;
  if ((v11 & 0x80000000) != 0 || v174 != 1)
    goto LABEL_20;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char **, char *))(a1[6] + 176))(a3, a4, v176, 0, &__s, (char *)&v175 + 2);
  if ((v11 & 0x80000000) != 0)
    goto LABEL_19;
  if (HIWORD(v175) < 2u)
    return v11;
  v13 = strlen(__s);
  v14 = (char *)heap_Alloc(*(_QWORD *)(*a1 + 8), v13 + 1);
  v171 = v14;
  if (!v14)
  {
    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v15, v16, v17, v18, v149);
    v12 = 0;
LABEL_241:
    v11 = 2588942346;
    goto LABEL_20;
  }
  v19 = v14;
  v20 = strcpy(v14, __s);
  v21 = strlen(v20);
  v22 = Utf8_LengthInUtf8chars((unint64_t)v19, v21);
  v23 = heap_Calloc(*(_QWORD **)(*a1 + 8), v22, 56);
  v168 = (uint64_t *)v23;
  if (!v23)
    goto LABEL_240;
  v28 = v23;
  v29 = a1[6];
  v159 = *a1;
  v30 = v176;
  v185 = 0;
  v184 = 0;
  v182 = 0;
  v183 = 0;
  v180 = 0;
  v181 = 0;
  v179 = 0;
  v165 = v29;
  UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, char *))(v29 + 176))(a3, a4, v176, 1, &v179, (char *)&v183 + 2);
  if ((UTF8Char & 0x80000000) != 0
    || (UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(v165 + 104))(a3, a4, 3, v30, &v183), (UTF8Char & 0x80000000) != 0))
  {
    v43 = 0;
LABEL_47:
    v5 = UTF8Char;
LABEL_48:
    v169 = v43;
    v12 = 1;
    v11 = v5;
LABEL_20:
    v35 = v171;
    if (!v171)
      goto LABEL_22;
LABEL_21:
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v35);
    goto LABEL_22;
  }
  v32 = v183;
  v161 = v28;
  if ((_WORD)v183)
  {
    while (1)
    {
      v178 = 0;
      v177 = 0;
      v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, v32, 0, 1, &v178, &v177);
      if ((v33 & 0x80000000) != 0)
        goto LABEL_264;
      if (v178 == 6)
        break;
      v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(v165 + 120))(a3, a4, (unsigned __int16)v183, &v183);
      if ((v33 & 0x80000000) != 0)
        goto LABEL_264;
      v32 = v183;
      if (!(_WORD)v183)
      {
        v151 = 0;
        v34 = 1;
        goto LABEL_50;
      }
    }
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 1, 1, (char *)&v180 + 4, &v177);
    if ((v33 & 0x80000000) != 0)
      goto LABEL_264;
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 2, 1, &v180, &v177);
    if ((v33 & 0x80000000) != 0)
      goto LABEL_264;
    v110 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char *))(v165 + 184))(a3, a4, (unsigned __int16)v183, 8, (char *)&v182 + 2);
    if ((v110 & 0x80000000) != 0)
      goto LABEL_201;
    if (HIWORD(v182) == 1)
    {
      v110 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 8, 1, &v185, &v177);
      if ((v110 & 0x80000000) != 0)
        goto LABEL_201;
    }
    else
    {
      v185 = v180 - HIDWORD(v180);
    }
    v110 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v183, 4, &v184, &v177);
    if ((v110 & 0x80000000) != 0)
    {
LABEL_201:
      v5 = v110;
      v43 = 0;
      goto LABEL_48;
    }
    v111 = strcmp(v184, "_PR_");
    v34 = 0;
    v151 = v111 == 0;
  }
  else
  {
    v151 = 0;
    v34 = 1;
  }
LABEL_50:
  v150 = v30;
  v44 = HIWORD(v183);
  if (!HIWORD(v183))
  {
    v43 = 0;
    goto LABEL_153;
  }
  v157 = v34;
  v45 = 0;
  v163 = 0;
  v43 = 0;
  v154 = 0;
  v46 = 0;
  v47 = 40;
  v156 = 1;
  v153 = v22;
  do
  {
    v48 = v179;
    v49 = *(_DWORD *)(v179 + 32 * v45);
    v160 = v45;
    if (v49 != 1)
    {
      if (v43 && (*(_QWORD *)(v28 + 56 * (v43 - 1) + 36) = 0x100000001, v45 >= 2) && v49 == 99)
      {
        if (*(_DWORD *)(v48 + 32 * (v45 - 1)) == 1
          && *(_DWORD *)(v48 + 32 * v45 + 12) == *(_DWORD *)(v48 + 32 * (v45 - 1) + 12))
        {
          *(_DWORD *)(v28 + 56 * (v43 - 1) + 48) = 1;
        }
      }
      else if (v49 == 0x4000)
      {
        v154 = *(_DWORD *)(v48 + 32 * v45 + 12);
      }
      goto LABEL_150;
    }
    v50 = v179 + 32 * v45;
    v51 = *(_DWORD *)(v50 + 12);
    v154 += v46;
    v152 = v47;
    if (v51 <= v154 || *(_DWORD *)(v50 + 4) <= v154)
    {
      v63 = v160;
    }
    else
    {
      v52 = v43;
      v53 = v28 + 56 * v43;
      *(_QWORD *)(v53 + 36) = 1;
      *(int32x2_t *)(v53 + 8) = vdup_n_s32(v46);
      *(_DWORD *)(v53 + 16) = v51 + ~v154;
      v54 = (_DWORD *)(v53 + 16);
      v55 = v46;
      v56 = (_DWORD *)heap_Alloc(*(_QWORD *)(v159 + 8), 4);
      *(_QWORD *)v53 = v56;
      if (!v56)
      {
LABEL_197:
        log_OutPublic(*(_QWORD *)(v159 + 32), (uint64_t)"FE_NNWS", 75000, 0, v57, v58, v59, v60, v149);
        v43 = v52;
        goto LABEL_48;
      }
      *v56 = 4673093;
      v61 = (*v54 + v55);
      LODWORD(v163) = *v54 + v163;
      HIDWORD(v163) = v61;
      v62 = v52 + 1;
      v44 = HIWORD(v183);
      v48 = v179;
      v22 = v153;
      v63 = v160;
      v28 = v161;
      v47 = v152;
      v46 = v61;
      v43 = v62;
    }
    if (v63 + 1 >= v44)
    {
      v64 = 0;
LABEL_75:
      v69 = *(_DWORD *)(v48 + 12);
      v68 = *(_DWORD *)(v48 + 16);
      v70 = *(_DWORD *)(v48 + 32 * v160 + 12);
      v71 = v68 + v69 - v64;
    }
    else
    {
      v64 = 0;
      v65 = (int *)(v48 + v47);
      v66 = v156;
      while (*(v65 - 2) != 1)
      {
        v67 = *v65;
        v65 += 8;
        if (v67 == 1)
          ++v64;
        if (v44 == ++v66)
          goto LABEL_75;
      }
      v71 = *(_DWORD *)(v48 + 32 * v66 + 12);
      v70 = v64 + *(_DWORD *)(v48 + 32 * v160 + 12);
    }
    v155 = v71 - v70;
    if (v43 >= v22)
      goto LABEL_148;
    v162 = 0;
    v158 = 1;
    while (1)
    {
      v72 = v46;
      if (strlen(v19) <= v163 || v162 >= v155)
        break;
      if ((_WORD)v183 && v157 == 1)
      {
        if (v72 >= v180)
        {
          do
          {
            v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v165 + 120))(a3, a4);
            if ((v33 & 0x80000000) != 0)
              goto LABEL_264;
            if (!(_WORD)v183)
              goto LABEL_84;
            v178 = 0;
            v177 = 0;
            v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 0, 1, &v178, &v177);
            if ((v33 & 0x80000000) != 0)
              goto LABEL_264;
          }
          while (v178 != 6);
          v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 1, 1, (char *)&v180 + 4, &v177);
          if ((v33 & 0x80000000) != 0)
            goto LABEL_264;
          v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 2, 1, &v180, &v177);
          if ((v33 & 0x80000000) != 0)
            goto LABEL_264;
          UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char *))(v165 + 184))(a3, a4, (unsigned __int16)v183, 8, (char *)&v182 + 2);
          if ((UTF8Char & 0x80000000) != 0)
            goto LABEL_47;
          if (HIWORD(v182) == 1)
          {
            UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 8, 1, &v185, &v177);
            if ((UTF8Char & 0x80000000) != 0)
              goto LABEL_47;
          }
          else
          {
            v185 = v180 - HIDWORD(v180);
          }
          UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v183, 4, &v184, &v177);
          if ((UTF8Char & 0x80000000) != 0)
            goto LABEL_47;
          v157 = 0;
          v151 = strcmp(v184, "_PR_") == 0;
        }
        else
        {
LABEL_84:
          v157 = 1;
        }
      }
      UTF8Char = utf8_getUTF8Char((uint64_t)v19, HIDWORD(v163), __src);
      if ((UTF8Char & 0x80000000) != 0)
        goto LABEL_47;
      if (utf8_IsChineseLetter(__src))
      {
        v73 = 0;
        v74 = 1;
        v46 = v72;
      }
      else
      {
        v46 = v72;
        v74 = 0;
        v73 = 1;
        if (__src[0] - 48 >= 0xA
          && (__src[0] - 35 > 0x3C
           || ((1 << (__src[0] - 35)) & 0x1800000004000503) == 0)
          && __src[0] != 124)
        {
          if ((__src[0] & 0xDFu) - 65 < 0x1A
            || __src[0] - 38 <= 0x1A && ((1 << (__src[0] - 38)) & 0x4000003) != 0)
          {
            v74 = 0;
            v73 = 2;
          }
          else
          {
            v73 = 0;
            v74 = 1;
          }
        }
      }
      if ((_WORD)v183 && HIDWORD(v163) == HIDWORD(v180))
      {
        if (!v158)
        {
          *(_DWORD *)(v161 + 56 * v43++ + 16) = HIDWORD(v163) - v46;
          LODWORD(v46) = HIDWORD(v163);
        }
        v82 = (_DWORD *)(v161 + 56 * v43 + 32);
        if (v151)
        {
          *v82 = 5;
          if (v43)
            *(_QWORD *)(v161 + 56 * (v43 - 1) + 36) = 0x100000001;
        }
        else
        {
          *v82 = 3;
        }
        v52 = v43;
        v83 = v161 + 56 * v43;
        *(int32x2_t *)(v83 + 8) = vdup_n_s32(v46);
        *(_DWORD *)(v83 + 20) = v185;
        *(_DWORD *)(v83 + 16) = v180 - HIDWORD(v163);
        v84 = (_DWORD *)(v83 + 16);
        *(_QWORD *)(v83 + 36) = 1;
        v85 = v46;
        v86 = (_DWORD *)heap_Calloc(*(_QWORD **)(v159 + 8), 1, 4);
        *(_QWORD *)v83 = v86;
        if (!v86)
          goto LABEL_197;
        *v86 = 5068110;
        LODWORD(v163) = *v84 + v163;
        v162 += *v84;
        v87 = (*v84 + v85);
        v157 = 1;
        v158 = 1;
        HIDWORD(v163) = v87;
        v88 = v52 + 1;
        v22 = v153;
        v28 = v161;
        v46 = v87;
        v43 = v88;
      }
      else
      {
        if (!v74)
        {
          if (v158)
          {
            v75 = (int32x2_t *)(v161 + 56 * v43);
            v75[1] = vdup_n_s32(v46);
            v75[2].i32[0] = 1;
            v76 = (_DWORD *)heap_Calloc(*(_QWORD **)(v159 + 8), 1, 4);
            *v75 = (int32x2_t)v76;
            if (!v76)
            {
              log_OutPublic(*(_QWORD *)(v159 + 32), (uint64_t)"FE_NNWS", 75000, 0, v77, v78, v79, v80, v149);
              goto LABEL_48;
            }
            v22 = v153;
            v46 = v72;
            if (v73 == 1)
            {
              v81 = "NUM";
LABEL_124:
              *v76 = *(_DWORD *)v81;
            }
            else if (v73 == 2)
            {
              v81 = "ENG";
              goto LABEL_124;
            }
            v158 = 0;
            v89 = v72 + 1;
          }
          else
          {
            v158 = 0;
            v89 = HIDWORD(v163) + 1;
          }
          HIDWORD(v163) = v89;
          v90 = 1;
          v91 = 1;
LABEL_132:
          v162 += v90;
          LODWORD(v163) = v91 + v163;
          v28 = v161;
          goto LABEL_133;
        }
        if (v158)
        {
          v158 = 1;
          v28 = v161;
        }
        else
        {
          v28 = v161;
          if (**(_BYTE **)(v161 + 56 * v43) == 124)
          {
            v158 = 0;
          }
          else
          {
            *(_DWORD *)(v161 + 56 * v43++ + 16) = HIDWORD(v163) - v46;
            v158 = 1;
            LODWORD(v46) = HIDWORD(v163);
          }
        }
        if (__src[0] != 32)
        {
          v92 = (int32x2_t *)(v28 + 56 * v43);
          v92[4].i32[1] = (v92[4].i32[0] & 0xFFFFFFFE) == 2;
          v92[5].i32[0] = 0;
          v92[1] = vdup_n_s32(v46);
          v164 = v43;
          v93 = v46;
          v90 = utf8_determineUTF8CharLength(v19[v46]);
          v92[2].i32[0] = v90;
          v94 = strlen(__src);
          v95 = (char *)heap_Calloc(*(_QWORD **)(v159 + 8), 1, v94 + 1);
          *v92 = (int32x2_t)v95;
          if (!v95)
          {
            log_OutPublic(*(_QWORD *)(v159 + 32), (uint64_t)"FE_NNWS", 75000, 0, v96, v97, v98, v99, v149);
LABEL_211:
            v43 = v164;
            goto LABEL_48;
          }
          strcpy(v95, __src);
          v91 = v92[2].i32[0];
          v100 = (v91 + v93);
          v101 = v164 + 1;
          HIDWORD(v163) = v100;
          v22 = v153;
          v46 = v100;
          v43 = v101;
          goto LABEL_132;
        }
        v46 = (v46 + 1);
        ++v162;
        LODWORD(v163) = v163 + 1;
        HIDWORD(v163) = v46;
      }
LABEL_133:
      if (v43 >= v22)
        goto LABEL_146;
    }
    v46 = v72;
LABEL_146:
    if (!v158)
    {
      *(_DWORD *)(v28 + 56 * v43++ + 16) = HIDWORD(v163) - v46;
      v46 = HIDWORD(v163);
    }
LABEL_148:
    v45 = v160;
    v47 = v152;
    if (v43)
      *(_QWORD *)(v28 + 56 * (v43 - 1) + 36) = 0x100000001;
LABEL_150:
    ++v45;
    v44 = HIWORD(v183);
    ++v156;
    v47 += 32;
  }
  while (v45 < HIWORD(v183));
LABEL_153:
  v169 = v43;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, int *))(v165 + 104))(a3, a4, 3, v150, &v182);
  if ((v11 & 0x80000000) != 0)
  {
LABEL_196:
    v5 = v11;
    goto LABEL_48;
  }
  v102 = v182;
  if ((_WORD)v182)
  {
    while (1)
    {
      v178 = 0;
      v177 = 0;
      v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, v102, 0, 1, &v178, &v177);
      if ((v33 & 0x80000000) != 0)
        goto LABEL_264;
      if (v178 == 5)
      {
        v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 1, 1, (char *)&v180 + 4, &v177);
        if ((v33 & 0x80000000) != 0)
          goto LABEL_264;
        v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 2, 1, &v180, &v177);
        if ((v33 & 0x80000000) != 0)
          goto LABEL_264;
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v182, 4, &v181, &v177);
        if ((v11 & 0x80000000) != 0)
          goto LABEL_196;
        if (!strcmp(v181, "phon"))
          break;
      }
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *))(v165 + 120))(a3, a4, (unsigned __int16)v182, &v182);
      if ((v11 & 0x80000000) != 0)
        goto LABEL_265;
      v102 = v182;
      if (!(_WORD)v182)
        goto LABEL_163;
    }
    v103 = 1;
    if (!v43)
    {
LABEL_203:
      v112 = 0;
      v169 = 0;
LABEL_204:
      v33 = fe_nnws_writeLDB_v2(a1, a3, a4, v176, v161, v112, (uint64_t)__s);
      if ((v33 & 0x80000000) != 0)
      {
LABEL_264:
        v11 = v33;
      }
      else
      {
        v35 = v171;
        v113 = fe_nnws_adjustTokenRecordBND(v161, v112, v171, v176, a3, a4, (uint64_t)a1);
        if ((v113 & 0x80000000) != 0)
          goto LABEL_258;
        v114 = strlen(v35);
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, const char *, int *))(a1[6] + 160))(a3, a4, v176, 0, (unsigned __int16)(v114 + 1), v35, &v175);
        if ((v11 & 0x80000000) == 0)
          log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)v35, v115, v116, v117, 0);
      }
LABEL_265:
      v12 = 1;
      goto LABEL_20;
    }
  }
  else
  {
LABEL_163:
    v103 = 0;
    if (!v43)
      goto LABEL_203;
  }
  v164 = v43;
  v104 = 0;
  while (2)
  {
    v105 = *(_DWORD *)(v161 + 56 * v104 + 12);
    if (v103 == 1)
    {
      v106 = v180;
      if (v105 >= HIDWORD(v180) && *(_DWORD *)(v161 + 56 * v104 + 16) + v105 <= v180)
      {
        v103 = 1;
        *(_DWORD *)(v161 + 56 * v104 + 44) = 1;
        goto LABEL_176;
      }
    }
    else
    {
      v106 = v180;
    }
    if (*(_DWORD *)(v161 + 56 * v104 + 16) + v105 > v106 && (unsigned __int16)v182 != 0)
    {
      while (1)
      {
        v108 = (*(uint64_t (**)(uint64_t, uint64_t))(v165 + 120))(a3, a4);
        v11 = v108;
        if ((v108 & 0x80000000) != 0)
          goto LABEL_265;
        if (!(_WORD)v182)
          goto LABEL_177;
        v178 = 0;
        v177 = 0;
        v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 0, 1, &v178, &v177);
        if ((v33 & 0x80000000) != 0)
          goto LABEL_264;
        if (v178 == 5)
        {
          v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 1, 1, (char *)&v180 + 4, &v177);
          if ((v33 & 0x80000000) != 0)
            goto LABEL_264;
          v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 2, 1, &v180, &v177);
          if ((v33 & 0x80000000) != 0)
            goto LABEL_264;
          v109 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v182, 4, &v181, &v177);
          v11 = v109;
          if ((v109 & 0x80000000) != 0)
          {
            v5 = v109;
            goto LABEL_211;
          }
          if (!strcmp(v181, "phon"))
          {
            v103 = 1;
            goto LABEL_177;
          }
          v103 = 0;
        }
      }
    }
    *(_DWORD *)(v161 + 56 * v104 + 44) = 0;
LABEL_176:
    ++v104;
LABEL_177:
    if (v104 < v43)
      continue;
    break;
  }
  v169 = v43;
  if ((v11 & 0x80000000) != 0)
    goto LABEL_265;
  v33 = (*(uint64_t (**)(_QWORD, _QWORD, int *))(a1[16] + 40))(a1[19], a1[20], &v173);
  if ((v33 & 0x80000000) != 0)
    goto LABEL_264;
  v122 = *((_DWORD *)a1 + 24);
  if (v122 != *((_DWORD *)a1 + 25) + v173)
  {
    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v118, v119, v120, v121, v149);
    v11 = 2588942361;
    goto LABEL_265;
  }
  v123 = *((_DWORD *)a1 + 50) ? v43 + 2 : v43;
  v124 = (_DWORD *)heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * (v122 * v123));
  v167 = v124;
  if (!v124)
  {
LABEL_240:
    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v24, v25, v26, v27, v149);
    v12 = 1;
    goto LABEL_241;
  }
  v125 = v124;
  if (*((_DWORD *)a1 + 50))
  {
    *v124 = 1120534528;
    v125 = &v124[v173];
  }
  v126 = 0;
  v127 = 0;
  do
  {
    if (*((_DWORD *)a1 + 48))
    {
      v128 = (uint64_t (**)(_QWORD, _QWORD, uint64_t, _DWORD *))(a1[16] + 64);
    }
    else
    {
      v129 = a1[16];
      if (*((_DWORD *)a1 + 50))
        v128 = (uint64_t (**)(_QWORD, _QWORD, uint64_t, _DWORD *))(v129 + 72);
      else
        v128 = (uint64_t (**)(_QWORD, _QWORD, uint64_t, _DWORD *))(v129 + 56);
    }
    v11 = (*v128)(a1[19], a1[20], v168[v126], v125);
    if ((v11 & 0x1FFF) == 0x14)
    {
      log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v131, v132, v133, v168[v126]);
      if (*((_DWORD *)a1 + 48))
      {
        v134 = (uint64_t (**)(_QWORD, _QWORD, _QWORD, _DWORD *))(a1[16] + 64);
      }
      else
      {
        v135 = a1[16];
        if (*((_DWORD *)a1 + 50))
          v134 = (uint64_t (**)(_QWORD, _QWORD, _QWORD, _DWORD *))(v135 + 72);
        else
          v134 = (uint64_t (**)(_QWORD, _QWORD, _QWORD, _DWORD *))(v135 + 56);
      }
      v11 = (*v134)(a1[19], a1[20], a1[14], v125);
    }
    v136 = (uint64_t)&v125[v173];
    if (*((_DWORD *)a1 + 48) || *((_DWORD *)a1 + 50))
    {
      if ((v11 & 0x80000000) != 0)
        goto LABEL_265;
    }
    else
    {
      fe_nnws_dynamic_feat(a1, (uint64_t)v168, (unsigned __int16)v169, (unsigned __int16)v127, v136);
    }
    v125 = (_DWORD *)(v136 + 4 * *((unsigned int *)a1 + 25));
    ++v127;
    v137 = v169;
    v126 += 7;
  }
  while (v127 < v169);
  if (*((_DWORD *)a1 + 50))
  {
    *v125 = 1120665600;
    v138 = (uint64_t ***)a1[10];
    v139 = (v137 + 2);
  }
  else
  {
    v138 = (uint64_t ***)a1[10];
    v139 = v169;
  }
  v11 = fi_predict(v138, &v167, v139, &v170, v130, v131, v132, v133);
  if ((v11 & 0x80000000) != 0)
  {
    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"FI Word Segmentation Prediction Failed", v140, v141, v142, 0);
    goto LABEL_265;
  }
  if (*((_DWORD *)a1 + 50))
    ++v170;
  if ((paramc_ParamGetInt(*(_QWORD *)(*a1 + 40), (uint64_t)"nnwsAddonEnable", &v166) & 0x80000000) != 0)
  {
    v143 = *((_DWORD *)a1 + 49);
  }
  else
  {
    v143 = v166;
    *((_DWORD *)a1 + 49) = v166;
  }
  if (v143 < 1
    || (v35 = v171,
        v113 = fe_nnws_addon_lookup(a1, (uint64_t)v168, v137, (uint64_t)v171, (uint64_t *)&v170, (_QWORD *)a1[15], v143),
        (v113 & 0x80000000) == 0))
  {
    v144 = *a1;
    v161 = (uint64_t)v168;
    v145 = (uint64_t *)a1[15];
    if (*((_DWORD *)a1 + 50))
      fe_nnws_adjustBMES_Edge(v144, v137, (uint64_t)v168, v9, v145, &v170);
    else
      fe_nnws_adjustBMES(v144, v137, (uint64_t)v168, v9, v145, &v170);
    v33 = fe_nnws_IGTreeProcess(a1, v137, (uint64_t *)a1[15], v161, (uint64_t *)&v170, v146, v147, v148);
    if ((v33 & 0x80000000) == 0)
    {
      fe_nnws_retag_word_under_phon(&v170, (uint64_t *)&v168, &v169, (_QWORD *)a1[15]);
      v33 = fe_nnws_group(*a1, (uint64_t)v170, (uint64_t *)&v168, &v169, (const char **)&v171);
      if ((v33 & 0x80000000) == 0)
      {
        v112 = v169;
        goto LABEL_204;
      }
    }
    goto LABEL_264;
  }
LABEL_258:
  v11 = v113;
  v12 = 1;
  if (v35)
    goto LABEL_21;
LABEL_22:
  v36 = (uint64_t)v168;
  if (v168)
  {
    v37 = v169;
    if (v169)
    {
      v38 = v168;
      do
      {
        if (*v38)
        {
          heap_Free(*(_QWORD **)(*a1 + 8), *v38);
          *v38 = 0;
        }
        v38 += 7;
        --v37;
      }
      while (v37);
    }
    heap_Free(*(_QWORD **)(*a1 + 8), v36);
  }
  v39 = v12 ^ 1;
  if ((int)v11 < 0)
    v39 = 1;
  if ((v39 & 1) == 0)
  {
    LODWORD(v184) = 0;
    LODWORD(v181) = 0;
    LODWORD(v179) = 0;
    *(_WORD *)__src = 0;
    LOWORD(v185) = 0;
    v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a1[6] + 104))(a3, a4, 3, v176, __src);
    if ((v11 & 0x80000000) == 0)
    {
      while (*(_WORD *)__src)
      {
        v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, const char **, int *))(a1[6] + 168))(a3, a4, *(unsigned __int16 *)__src, 0, 1, &v184, &v185);
        if ((v40 & 0x80000000) != 0)
          return v40;
        v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, const char **, int *))(a1[6] + 168))(a3, a4, *(unsigned __int16 *)__src, 1, 1, &v181, &v185);
        if ((v40 & 0x80000000) != 0)
          return v40;
        v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t *, int *))(a1[6] + 168))(a3, a4, *(unsigned __int16 *)__src, 2, 1, &v179, &v185);
        if ((v40 & 0x80000000) != 0)
          return v40;
        if (((_DWORD)v184 - 7) >= 0xFFFFFFFD)
          v41 = 0;
        else
          v41 = *(unsigned __int16 *)__src;
        v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[6] + 120))(a3, a4);
        if ((v11 & 0x80000000) != 0)
          return v11;
        if ((_DWORD)v41)
          v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[6] + 192))(a3, a4, v41);
      }
    }
  }
  return v11;
}

uint64_t fe_nnws_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62346, 208);
  if ((int)result >= 0)
    return result;
  else
    return 2588942344;
}

uint64_t fe_nnws_loadCfg(uint64_t a1)
{
  const char *v2;
  char *v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  unsigned int v20;
  _BYTE __c[11];

  memset(__c, 0, sizeof(__c));
  *(_DWORD *)(a1 + 192) = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), "fecfg", "nnws_use_static_feat", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
  {
    v2 = **(const char ***)&__c[3];
    v3 = strchr(**(char ***)&__c[3], __c[0]);
    if (v3)
    {
      *v3 = 0;
      v2 = **(const char ***)&__c[3];
    }
    if (!strcmp(v2, "yes"))
      *(_DWORD *)(a1 + 192) = 1;
  }
  v4 = 2588943364;
  *(_WORD *)&__c[1] = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), "fecfg", "nnws_nn_null_fea", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
  {
    *(_QWORD *)(a1 + 112) = 0;
    v5 = **(const char ***)&__c[3];
    v6 = strchr(**(char ***)&__c[3], __c[0]);
    if (v6)
    {
      *v6 = 0;
      v5 = **(const char ***)&__c[3];
    }
    v7 = strlen(v5);
    v8 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), v7 + 1);
    *(_QWORD *)(a1 + 112) = v8;
    if (v8)
    {
      v13 = (char *)v8;
      v14 = strlen(**(const char ***)&__c[3]);
      strncpy(v13, **(const char ***)&__c[3], v14);
      *(_BYTE *)(*(_QWORD *)(a1 + 112) + strlen(**(const char ***)&__c[3])) = 0;
      *(_WORD *)&__c[1] = 0;
      if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), "fecfg", "nnws_nn_indim", &__c[3], &__c[1], __c) & 0x80000000) == 0)
      {
        if (*(_WORD *)&__c[1])
        {
          *(_DWORD *)(a1 + 96) = 0;
          *(_DWORD *)(a1 + 96) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
          *(_WORD *)&__c[1] = 0;
          if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), "fecfg", "nnws_nn_ddim", &__c[3], &__c[1], __c) & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
            {
              *(_DWORD *)(a1 + 100) = 0;
              *(_DWORD *)(a1 + 100) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
              *(_WORD *)&__c[1] = 0;
              *(_DWORD *)(a1 + 196) = 0;
              if (((*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), "fecfg", "nnws_use_force_ws", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
              {
                *(_DWORD *)(a1 + 196) = LH_atou(**(const char ***)&__c[3]);
              }
              *(_WORD *)&__c[1] = 0;
              *(_DWORD *)(a1 + 200) = 0;
              v15 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), "fecfg", "nnws_use_albert", &__c[3], &__c[1], __c);
              v4 = 0;
              if ((v15 & 0x80000000) == 0 && *(_WORD *)&__c[1])
              {
                v16 = v15;
                v17 = **(const char ***)&__c[3];
                v18 = strchr(**(char ***)&__c[3], __c[0]);
                if (v18)
                {
                  *v18 = 0;
                  v17 = **(const char ***)&__c[3];
                }
                if (!strcmp(v17, "yes"))
                  *(_DWORD *)(a1 + 200) = 1;
                return v16;
              }
            }
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v9, v10, v11, v12, v20);
      return 2588942346;
    }
  }
  return v4;
}

uint64_t fe_nnws_CreateBrokerString(uint64_t a1, char *a2)
{
  uint64_t result;
  uint64_t v5;
  int v6[2];
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  *(_QWORD *)v6 = 0;
  memset(v7, 0, sizeof(v7));
  result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", v6);
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"fecfg", &v5);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v7, 1, 1, *(char **)v6, 0, 0, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t fe_nnws_tagInit(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  unsigned int v19;

  v8 = heap_Calloc(*(_QWORD **)(a1 + 8), 4, 8);
  if (v8)
  {
    v9 = 0;
    while (1)
    {
      v10 = (_BYTE *)heap_Calloc(*(_QWORD **)(a1 + 8), 2, 1);
      *(_QWORD *)(v8 + 8 * v9) = v10;
      if (!v10)
        break;
      *v10 = aSbme[v9++];
      if (v9 == 4)
      {
        v15 = 0;
        goto LABEL_12;
      }
    }
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v11, v12, v13, v14, v19);
    for (i = 0; i != 32; i += 8)
    {
      v17 = *(_QWORD *)(v8 + i);
      if (v17)
        heap_Free(*(_QWORD **)(a1 + 8), v17);
    }
    v15 = 2588942346;
    heap_Free(*(_QWORD **)(a1 + 8), v8);
    v8 = 0;
  }
  else
  {
    v15 = 2588942346;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v4, v5, v6, v7, v19);
  }
LABEL_12:
  *a2 = v8;
  return v15;
}

uint64_t fe_nnws_tryLoadingIGTree(_WORD *a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t BrokerString;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v25;
  int v26[2];
  _OWORD v27[16];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  memset(v27, 0, sizeof(v27));
  *(_QWORD *)v26 = 0;
  *a4 = 0;
  BrokerString = fe_nnws_CreateBrokerString(a3, (char *)v27);
  if ((BrokerString & 0x80000000) != 0
    || (BrokerString = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v27, "IGTR", 1031, (uint64_t *)v26),
        (BrokerString & 0x80000000) != 0))
  {
    v21 = BrokerString;
  }
  else
  {
    v16 = (char *)heap_Calloc(*(_QWORD **)(a3 + 8), 1, 1600);
    *a4 = v16;
    if (v16)
    {
      v21 = igtree_Init(a1, a2, *(uint64_t *)v26, v16);
      ssftriff_reader_CloseChunk(*(uint64_t *)v26);
      if ((v21 & 0x80001FFF) == 0x14)
      {
        ssftriff_reader_CloseChunk(*(uint64_t *)v26);
        v21 = 0;
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(a3 + 32), (uint64_t)"FE_NNWS", 37000, 0, v17, v18, v19, v20, v25);
      v21 = 2588942346;
    }
  }
  if (*(_QWORD *)v26)
  {
    v22 = ssftriff_reader_ObjClose(*(_QWORD **)v26, v9, v10, v11, v12, v13, v14, v15);
    if (v22 >= 0 || (int)v21 <= -1)
      return v21;
    else
      return v22;
  }
  return v21;
}

uint64_t fe_nnws_dynamic_feat(_QWORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  unsigned int v6;
  const char *v10;
  uint64_t result;
  const char **v12;
  uint64_t v13;
  unsigned int v14;
  const char *v15;
  uint64_t v16;
  const char **v17;
  const char *v18;
  int v19;
  _QWORD *v20;
  float *v21;
  unsigned int v22;
  float v23;
  int v24;
  unsigned int v25;
  float v26;
  BOOL v27;
  char v28;
  unsigned int v29;
  float v30;
  BOOL v31;
  char v32;
  unsigned int v33;
  float v34;
  int v35;
  BOOL v36;
  char v37;
  unsigned int v38;
  float v39;
  char v40;
  unsigned int v41;
  float v42;
  char v43;
  unsigned int v44;
  float v45;
  char v46;
  unsigned int v47;
  _QWORD *v48;
  float v49;
  char v50;
  unsigned int v51;
  float v52;
  float *v53;
  _QWORD *v54;
  _BYTE v55[4];
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  __int128 v60;
  __int128 v61;
  char v62;
  uint64_t v63;

  v6 = a4;
  v63 = *MEMORY[0x1E0C80C00];
  v62 = 0;
  v60 = 0u;
  v61 = 0u;
  v56 = 0;
  v57 = 0;
  v59 = 0;
  v58 = 0;
  v10 = *(const char **)(a2 + 56 * a4);
  result = strcmp(v10, "NUM");
  if ((_DWORD)result && (result = strcmp(v10, "ENG"), (_DWORD)result))
  {
    v53 = (float *)a5;
    v54 = a1;
    v12 = (const char **)(a2 + 56 * v6 - 56);
    v13 = 8;
    v14 = 1;
    do
    {
      if (v14 < v6)
      {
        v15 = *v12;
        result = strcmp(*v12, "NUM");
        if ((_DWORD)result)
        {
          result = strcmp(v15, "ENG");
          if ((_DWORD)result)
            *(_DWORD *)((char *)&v56 + v13) = 1;
        }
      }
      ++v14;
      v13 -= 4;
      v12 -= 7;
    }
    while (v13 != -4);
    v16 = 0;
    v17 = (const char **)(a2 + 56 * v6 + 56);
    do
    {
      if ((unint64_t)v6 + 1 + v16 < a3)
      {
        v18 = *v17;
        result = strcmp(*v17, "NUM");
        if ((_DWORD)result)
        {
          result = strcmp(v18, "ENG");
          if ((_DWORD)result)
            *((_DWORD *)&v58 + v16) = 1;
        }
      }
      ++v16;
      v17 += 7;
    }
    while (v16 != 3);
    v19 = v57;
    if ((_DWORD)v57 == 1)
    {
      v21 = v53;
      v20 = v54;
      if (v6)
      {
        v22 = v6 - 1;
        do
        {
          __strcat_chk();
          ++v22;
        }
        while (v6 >= (unsigned __int16)v22);
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      v23 = 0.0;
      if ((int)result >= 0)
        v23 = 1.0;
      *v53 = v23;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21 = v53;
      v20 = v54;
      *v53 = 0.0;
    }
    v24 = v58;
    if ((_DWORD)v58 == 1)
    {
      v25 = v6;
      do
      {
        __strcat_chk();
        ++v25;
      }
      while (v6 + 2 > (unsigned __int16)v25);
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v20[16] + 56))(v20[21], v20[22], &v60, v55);
      v26 = 0.0;
      if ((int)result >= 0)
        v26 = 1.0;
      v21[1] = v26;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[1] = 0.0;
    }
    v27 = v19 == 1 && HIDWORD(v56) == 1;
    v28 = v27;
    if (v27)
    {
      v29 = v6 - 2;
      if (v6 >= 2)
      {
        do
        {
          __strcat_chk();
          ++v29;
        }
        while (v6 >= (unsigned __int16)v29);
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v20[16] + 56))(v20[21], v20[22], &v60, v55);
      v30 = 0.0;
      if ((int)result >= 0)
        v30 = 1.0;
      v21[2] = v30;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[2] = 0.0;
    }
    v31 = v19 == 1 && v24 == 1;
    v32 = v31;
    if (v31)
    {
      v33 = v6 - 1;
      if (v6 + 2 > (unsigned __int16)(v6 - 1))
      {
        do
        {
          __strcat_chk();
          ++v33;
        }
        while (v6 + 2 > (unsigned __int16)v33);
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v20[16] + 56))(v20[21], v20[22], &v60, v55);
      v34 = 0.0;
      if ((int)result >= 0)
        v34 = 1.0;
      v21[3] = v34;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[3] = 0.0;
    }
    v35 = HIDWORD(v58);
    v36 = v24 == 1 && HIDWORD(v58) == 1;
    v37 = v36;
    if (v36)
    {
      v38 = v6;
      do
      {
        __strcat_chk();
        ++v38;
      }
      while (v6 + 3 > (unsigned __int16)v38);
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      v39 = 0.0;
      if ((int)result >= 0)
        v39 = 1.0;
      v21 = v53;
      v53[4] = v39;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[4] = 0.0;
    }
    if ((_DWORD)v56 == 1)
      v40 = v28;
    else
      v40 = 0;
    if ((v40 & 1) != 0)
    {
      v41 = v6 - 3;
      if (v6 >= 3)
      {
        do
        {
          __strcat_chk();
          ++v41;
        }
        while (v6 >= (unsigned __int16)v41);
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      v42 = 0.0;
      if ((int)result >= 0)
        v42 = 1.0;
      v21[5] = v42;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[5] = 0.0;
    }
    if (v24 == 1)
      v43 = v28;
    else
      v43 = 0;
    if ((v43 & 1) != 0)
    {
      v44 = v6 - 2;
      if (v6 + 2 > (unsigned __int16)(v6 - 2))
      {
        do
        {
          __strcat_chk();
          ++v44;
        }
        while (v6 + 2 > (unsigned __int16)v44);
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      v45 = 0.0;
      if ((int)result >= 0)
        v45 = 1.0;
      v21[6] = v45;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[6] = 0.0;
    }
    if (v35 == 1)
      v46 = v32;
    else
      v46 = 0;
    if ((v46 & 1) != 0)
    {
      v47 = v6 - 1;
      v48 = v54;
      if (v6 + 3 > (unsigned __int16)(v6 - 1))
      {
        do
        {
          __strcat_chk();
          ++v47;
        }
        while (v6 + 3 > (unsigned __int16)v47);
      }
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      v49 = 0.0;
      if ((int)result >= 0)
        v49 = 1.0;
      v21[7] = v49;
      v60 = 0u;
      v61 = 0u;
      v62 = 0;
    }
    else
    {
      v21[7] = 0.0;
      v48 = v54;
    }
    if (v59 == 1)
      v50 = v37;
    else
      v50 = 0;
    if ((v50 & 1) != 0)
    {
      v51 = v6 + 4;
      do
      {
        __strcat_chk();
        ++v6;
      }
      while (v51 > (unsigned __int16)v6);
      result = (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, _BYTE *))(v48[16] + 56))(v48[21], v48[22], &v60, v55);
      v52 = 0.0;
      if ((int)result >= 0)
        v52 = 1.0;
      v21[8] = v52;
    }
    else
    {
      v21[8] = 0.0;
    }
  }
  else
  {
    *(_DWORD *)(a5 + 32) = 0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }
  return result;
}

uint64_t fe_nnws_addon_lookup(_QWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5, _QWORD *a6, unsigned __int16 a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  _DWORD *v23;
  unint64_t v24;
  const char *v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  unsigned int v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v55;
  _BYTE *__dst;
  unint64_t v57;
  unint64_t v58;
  unsigned int v59;
  char v60;
  uint64_t v61;
  __int16 v62;

  v11 = *a5;
  v62 = 0;
  v61 = 0;
  v60 = 0;
  v59 = a7;
  v55 = a7 + 1;
  __dst = (_BYTE *)heap_Calloc(*(_QWORD **)(*a1 + 8), 1, v55);
  if (!__dst)
  {
    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v12, v13, v14, v15, v47);
    return 2588942346;
  }
  if (!a3)
  {
    v17 = 1;
    goto LABEL_44;
  }
  v48 = v11;
  v49 = a6;
  v16 = 0;
  v50 = a6 + 1;
  v51 = a6 + 3;
  v58 = a3;
  v17 = 1;
  v52 = a4;
  v53 = a3;
  while (1)
  {
    v18 = 0;
    v19 = 56 * v16;
    v20 = *(unsigned int *)(a2 + v19 + 12);
    v21 = v16 + 1;
    if (a3 <= v16 + 1)
      v22 = v16 + 1;
    else
      v22 = a3;
    v23 = (_DWORD *)(a2 + 16 + v19);
    v57 = v16;
    v24 = v16;
    while (1)
    {
      v25 = (const char *)*((_QWORD *)v23 - 2);
      if (!strcmp(v25, "NUM"))
        break;
      if (!strcmp(v25, "ENG"))
        break;
      v26 = *v23 + v18;
      if (v26 > v59)
        break;
      ++v24;
      v23 += 14;
      v18 = v26;
      if (v24 >= v58)
      {
        v18 = v26;
        goto LABEL_14;
      }
    }
    v22 = v24;
LABEL_14:
    v27 = v57;
    if (v57 >= v22)
    {
      __dst[v18] = 0;
      goto LABEL_24;
    }
    memcpy(__dst, (const void *)(a4 + v20), v18 + 1);
    __dst[v18] = 0;
    if (v18)
      break;
LABEL_24:
    if (v27 == v22)
      v16 = v22 + 1;
    else
      v16 = v22;
    a3 = v53;
    if (v16 >= v53)
      goto LABEL_44;
  }
  v28 = 0;
  v29 = v22;
  v30 = (int *)(a2 - 40 + 56 * v22);
  v31 = v22 - v57 - 2;
  v32 = -1;
  v33 = 1;
  while (1)
  {
    bzero(&__dst[v18], v55 - v18);
    __dst[v18] = 0;
    v62 = 0;
    v17 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _BYTE *, uint64_t *, __int16 *, char *, _QWORD))(a1[7] + 232))(a1[8], a1[9], "force_ws", __dst, &v61, &v62, &v60, 0);
    if ((v17 & 0x80000000) != 0)
      break;
    if (v62)
    {
      v35 = *v50;
      v27 = v57;
      if ((_DWORD)v57)
      {
        v36 = (v57 - 1);
        v38 = v48;
        v37 = v49;
        v39 = *(_QWORD *)(v48 + 8 * v36);
        v40 = v49;
        v41 = v21;
        if (v39 == v35 || (v40 = v51, v39 == v49[2]))
        {
          *(_QWORD *)(v48 + 8 * v36) = *v40;
          v35 = v49[1];
        }
      }
      else
      {
        v38 = v48;
        v37 = v49;
        v41 = v21;
      }
      v22 = v29 - v28;
      v42 = v29 - v33;
      *(_QWORD *)(v38 + 8 * v57) = v35;
      if ((int)v29 - v28 < v53)
      {
        v43 = *(_QWORD *)(v38 + 8 * v22);
        v44 = v50;
        if (v43 == v37[2] || (v44 = v37, v43 == *v51))
          *(_QWORD *)(v38 + 8 * v42) = *v44;
      }
      a4 = v52;
      *(_QWORD *)(v38 + 8 * v42) = *v51;
      if (v41 < v42)
      {
        v45 = (_QWORD *)(v38 + 8 * v41);
        do
        {
          *v45++ = v37[2];
          --v31;
        }
        while (v31);
      }
      v17 = 1;
      goto LABEL_24;
    }
    ++v28;
    if (v29 != v33 && v29 + v32 > v57)
    {
      v34 = *v30;
      v30 -= 14;
      ++v33;
      --v32;
      --v31;
      v18 -= v34;
      if (v18)
        continue;
    }
    v22 = v29 - v28;
    a4 = v52;
    v27 = v57;
    goto LABEL_24;
  }
LABEL_44:
  heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)__dst);
  return v17;
}

uint64_t fe_nnws_adjustBMES_Edge(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, uint64_t **a6)
{
  unsigned int v7;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *i;
  unsigned int v12;
  int v13;
  uint64_t *v14;
  int v15;
  int v16;
  uint64_t *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;

  v7 = a2;
  v9 = *a6;
  v24 = *a6;
  if (a2 < 2)
    goto LABEL_26;
  v10 = a2 - 2;
  for (i = v9; ; ++i)
  {
    v12 = *(unsigned __int8 *)i[1];
    if (v12 <= 0x4C)
    {
      if (v12 != 66)
      {
        if (v12 == 69)
        {
          v13 = *(unsigned __int8 *)*i;
          v14 = a5;
          if (v13 == 83)
            goto LABEL_19;
          v14 = a5;
          if (v13 == 69)
            goto LABEL_19;
        }
        goto LABEL_20;
      }
      v15 = *(unsigned __int8 *)*i;
      v14 = a5 + 2;
      if (v15 == 66)
        goto LABEL_19;
      v14 = a5 + 2;
LABEL_15:
      if (v15 == 77)
        goto LABEL_19;
      goto LABEL_20;
    }
    if (v12 != 77)
    {
      if (v12 != 83)
        goto LABEL_20;
      v15 = *(unsigned __int8 *)*i;
      v14 = a5 + 3;
      if (v15 == 66)
      {
LABEL_19:
        i[1] = *v14;
        goto LABEL_20;
      }
      v14 = a5 + 3;
      goto LABEL_15;
    }
    v16 = *(unsigned __int8 *)*i;
    v14 = a5 + 1;
    if (v16 == 69)
      goto LABEL_19;
    v14 = a5 + 1;
    if (v16 == 83)
      goto LABEL_19;
LABEL_20:
    if (!v10)
      break;
    --v10;
  }
  v17 = a5 + 3;
  if (*(_BYTE *)*i == 77 || (v17 = a5, *(_BYTE *)i[1] == 66))
    i[1] = *v17;
LABEL_26:
  result = fe_nnws_adjust_ENP_labels(a2, a3, a5, (uint64_t *)&v24);
  if (a4 == 1 && v7)
  {
    v22 = v7;
    do
    {
      v23 = *v9++;
      result = log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"[NNWS][adjustBMES_Edge] Predicted Tag: %s", v19, v20, v21, v23);
      --v22;
    }
    while (v22);
  }
  return result;
}

uint64_t fe_nnws_adjustBMES(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, uint64_t **a6)
{
  unsigned int v7;
  uint64_t *v9;
  unsigned __int8 **v10;
  uint64_t i;
  int v12;
  uint64_t *v13;
  int v14;
  int v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;

  v7 = a2;
  v9 = *a6;
  v22 = *a6;
  if ((_DWORD)a2)
  {
    v10 = (unsigned __int8 **)(v9 + 1);
    for (i = a2; i; --i)
    {
      v12 = **(v10 - 1);
      if (i == 1)
      {
        v13 = a5 + 3;
        if (v12 != 77)
        {
          v13 = a5;
          if (v12 != 66)
            goto LABEL_22;
        }
        goto LABEL_21;
      }
      if (**(v10 - 1) > 0x4Cu)
      {
        if (v12 == 77)
        {
          v15 = **v10;
          v13 = a5 + 3;
          if (v15 == 66)
            goto LABEL_21;
          v13 = a5 + 3;
LABEL_20:
          if (v15 == 83)
            goto LABEL_21;
          goto LABEL_22;
        }
        if (v12 == 83)
        {
          v14 = **v10 | 8;
          v13 = a5 + 1;
          goto LABEL_14;
        }
      }
      else
      {
        if (v12 == 66)
        {
          v15 = **v10;
          v13 = a5;
          if (v15 == 66)
            goto LABEL_21;
          v13 = a5;
          goto LABEL_20;
        }
        if (v12 == 69)
        {
          v14 = **v10 | 8;
          v13 = a5 + 2;
LABEL_14:
          if (v14 != 77)
            goto LABEL_22;
LABEL_21:
          *(v10 - 1) = (unsigned __int8 *)*v13;
        }
      }
LABEL_22:
      ++v10;
    }
  }
  result = fe_nnws_adjust_ENP_labels(a2, a3, a5, (uint64_t *)&v22);
  if (a4 == 1 && v7)
  {
    v20 = v7;
    do
    {
      v21 = *v9++;
      result = log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"[NNWS] Predicted Tag: %s", v17, v18, v19, v21);
      --v20;
    }
    while (v20);
  }
  return result;
}

uint64_t fe_nnws_IGTreeProcess(uint64_t *a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char **v18;
  uint64_t v19;
  _QWORD *v20;
  _WORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  const char **v28;
  unsigned int v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  const char *v36;
  const char *v37;
  const char *v38;
  const char *v39;
  const char *v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t *v53;
  uint64_t *v54;
  char *__s1;
  char v57[4];

  __s1 = 0;
  v8 = *a1;
  v9 = a1[23];
  if (!a2 || !v9)
  {
    log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"IGTree model for NNWS does not exist", a6, a7, a8, v49);
    return 0;
  }
  v13 = heap_Alloc(*(_QWORD *)(v8 + 8), 8 * *(unsigned __int8 *)(v9 + 1296) - 8);
  if (!v13)
  {
    v41 = 2588942346;
    log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNWS", 750000, 0, v14, v15, v16, v17, v49);
    return v41;
  }
  v18 = (char **)v13;
  v54 = a5;
  if (*(_BYTE *)(v9 + 1296) != 1)
  {
    v19 = (unsigned __int16)(*(unsigned __int8 *)(v9 + 1296) - 1);
    v20 = (_QWORD *)v13;
    do
    {
      v21 = (_WORD *)heap_Calloc(*(_QWORD **)(v8 + 8), 1, 65);
      *v20 = v21;
      if (!v21)
      {
        v41 = 2588942346;
        log_OutPublic(*(_QWORD *)(v8 + 32), (uint64_t)"FE_NNWS", 750000, 0, v22, v23, v24, v25, v49);
        goto LABEL_57;
      }
      *v21 = 61;
      ++v20;
      --v19;
    }
    while (v19);
  }
  v26 = 0;
  v52 = a3 + 2;
  v53 = a3;
  v50 = a3 + 3;
  v51 = a3 + 1;
  v27 = v54;
  do
  {
    v28 = *(const char ***)(v9 + 1312);
    v29 = *(unsigned __int8 *)(v9 + 1296);
    v30 = fe_nnws_setFeature(v8, v28, v29, 0, v18, *(const char **)(*v27 + 8 * (unsigned __int16)v26));
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v31 = "=";
    if ((unsigned __int16)a2 > (unsigned __int16)v26)
      v31 = *(const char **)(a4 + 56 * (unsigned __int16)v26);
    v30 = fe_nnws_setFeature(v8, v28, v29, 1, v18, v31);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v32 = "=";
    if ((unsigned __int16)v26 - 1 < (unsigned __int16)a2)
      v32 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 1));
    v30 = fe_nnws_setFeature(v8, v28, v29, 2, v18, v32);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v33 = "=";
    if ((unsigned __int16)v26 - 2 < (unsigned __int16)a2)
      v33 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 2));
    v30 = fe_nnws_setFeature(v8, v28, v29, 3, v18, v33);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v34 = "=";
    if ((unsigned __int16)v26 - 3 < (unsigned __int16)a2)
      v34 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 3));
    v30 = fe_nnws_setFeature(v8, v28, v29, 4, v18, v34);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v35 = "=";
    if ((unsigned __int16)v26 - 4 < (unsigned __int16)a2)
      v35 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 4));
    v30 = fe_nnws_setFeature(v8, v28, v29, 5, v18, v35);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v36 = "=";
    if ((unsigned __int16)v26 + 1 < (unsigned __int16)a2)
      v36 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 1));
    v30 = fe_nnws_setFeature(v8, v28, v29, 6, v18, v36);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v37 = "=";
    if ((unsigned __int16)v26 + 2 < (unsigned __int16)a2)
      v37 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 2));
    v30 = fe_nnws_setFeature(v8, v28, v29, 7, v18, v37);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v38 = "=";
    if ((unsigned __int16)v26 + 3 < (unsigned __int16)a2)
      v38 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 3));
    v30 = fe_nnws_setFeature(v8, v28, v29, 8, v18, v38);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_55;
    v39 = "=";
    if ((unsigned __int16)v26 + 4 < (unsigned __int16)a2)
      v39 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 4));
    v30 = fe_nnws_setFeature(v8, v28, v29, 9, v18, v39);
    if ((v30 & 0x80000000) != 0)
    {
LABEL_55:
      v41 = v30;
      goto LABEL_57;
    }
    v40 = "=";
    if ((unsigned __int16)v26 < a2)
    {
      v40 = v57;
      LH_itoa((unsigned __int16)v26 + 1, v57, 0xAu);
    }
    v41 = fe_nnws_setFeature(v8, v28, v29, 10, v18, v40);
    v27 = v54;
    if ((v41 & 0x80000000) != 0)
      goto LABEL_57;
    igtree_Process(v9, (uint64_t)v18, &__s1);
    v42 = __s1;
    if (strcmp(__s1, "NOMATCH"))
    {
      v41 = 0;
      v43 = *v42;
      if (v43 <= 0x4C)
      {
        v44 = v51;
        if (v43 != 66)
        {
          if (v43 != 69)
            goto LABEL_48;
          v44 = v50;
        }
LABEL_47:
        *(_QWORD *)(*v54 + 8 * v26) = *v44;
        fe_hlp_adjustBMES_basedSingleLabel(a2, v26, v53, v54);
        v41 = 0;
        goto LABEL_48;
      }
      v44 = v52;
      if (v43 == 77)
        goto LABEL_47;
      v44 = v53;
      if (v43 == 83)
        goto LABEL_47;
    }
LABEL_48:
    ++v26;
  }
  while (a2 != v26);
  if (*(_BYTE *)(v9 + 1296) != 1)
  {
    v45 = (unsigned __int16)(*(unsigned __int8 *)(v9 + 1296) - 1);
    v46 = (uint64_t *)v18;
    do
    {
      v47 = *v46++;
      heap_Free(*(_QWORD **)(v8 + 8), v47);
      --v45;
    }
    while (v45);
  }
LABEL_57:
  heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)v18);
  return v41;
}

_QWORD **fe_nnws_retag_word_under_phon(_QWORD **result, uint64_t *a2, unsigned int *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  v4 = *a2;
  v5 = *a3;
  v6 = *result;
  if (v5 >= 2)
  {
    v7 = (_DWORD *)(v4 + 96);
    v8 = 8 * v5;
    v9 = 8;
    while (1)
    {
      if (*(v7 - 13) != 1 || v7[1] != 1)
        goto LABEL_19;
      v10 = *(v7 - 14);
      if (v10 == 1)
      {
        if (!*v7)
        {
          v12 = a4[1];
LABEL_16:
          v6[(unint64_t)v9 / 8] = v12;
          v13 = a4;
LABEL_17:
          if (v9 == 8)
            *v6 = *v13;
          goto LABEL_19;
        }
        if (*v7 == 1)
        {
          v12 = *a4;
          goto LABEL_16;
        }
      }
      else if (!v10)
      {
        if (!*v7)
        {
          v11 = a4[2];
          goto LABEL_14;
        }
        if (*v7 == 1)
        {
          v11 = a4[3];
LABEL_14:
          v6[(unint64_t)v9 / 8] = v11;
          v13 = a4 + 1;
          goto LABEL_17;
        }
      }
LABEL_19:
      v9 += 8;
      v7 += 14;
      if (v8 == v9)
        return result;
    }
  }
  if (*(_DWORD *)(v4 + 44) == 1)
    *v6 = *a4;
  return result;
}

uint64_t fe_nnws_group(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4, const char **a5)
{
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  size_t v24;
  int v25;
  uint64_t *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  const char **v43;
  char *v44;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  const void **v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int *v67;
  int v68;
  uint64_t v70;
  uint64_t v71;
  unsigned int v74;
  unsigned int *v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;

  v7 = *a3;
  v8 = *a5;
  v9 = *a4;
  v81 = (uint64_t)*a5;
  v74 = strlen(*a5);
  v75 = a4;
  if ((_DWORD)v9)
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = v7 + 32;
    v78 = a2;
    v79 = v9;
    while (1)
    {
      v19 = **(unsigned __int8 **)(a2 + 8 * v14);
      switch(v19)
      {
        case 'B':
          v41 = v7 + 56 * v17;
          *(_QWORD *)(v41 + 8) = *(_QWORD *)(v18 - 24);
          *(_DWORD *)(v41 + 32) = *(_DWORD *)v18;
          v16 = v14;
          break;
        case 'S':
          v77 = v16;
          v42 = *(unsigned int *)(v18 - 16);
          v43 = (const char **)(v7 + 56 * v17);
          v44 = (char *)*v43;
          if (!strcmp(*v43, "NUM"))
          {
            if ((v42 - 4) < 0xFFFFFFFB)
              goto LABEL_23;
          }
          else if (!strcmp(v44, "ENG") && (v42 - 4) < 0xFFFFFFFB)
          {
LABEL_23:
            v47 = heap_Realloc(*(uint64_t **)(a1 + 8), (uint64_t)v44, v42 + 1);
            *v43 = (const char *)v47;
            if (!v47)
            {
LABEL_60:
              v70 = 2588942346;
              v71 = *(_QWORD *)(a1 + 32);
              goto LABEL_62;
            }
            v44 = (char *)v47;
            v48 = *(_DWORD *)(v18 - 16);
            goto LABEL_26;
          }
          if (*(_DWORD *)(v7 + 56 * v17 + 16) < (v42 + 1))
            goto LABEL_23;
          v48 = v42;
LABEL_26:
          strncpy(v44, &v8[*(unsigned int *)(v18 - 20)], v48);
          (*v43)[*(unsigned int *)(v18 - 16)] = 0;
          v49 = v7 + 56 * v17;
          v50 = *(_DWORD *)(v18 - 12);
          *(_DWORD *)(v49 + 16) = v42;
          *(_DWORD *)(v49 + 20) = v50;
          *(_QWORD *)(v49 + 8) = *(_QWORD *)(v18 - 24);
          *(_DWORD *)(v49 + 40) = *(_DWORD *)(v18 + 8);
          *(_QWORD *)(v49 + 32) = *(_QWORD *)v18;
          *(_DWORD *)(v49 + 48) = *(_DWORD *)(v18 + 16);
          v15 += v42;
          ++v17;
          a2 = v78;
          v9 = v79;
          v16 = v77;
          break;
        case 'E':
          v20 = v7 + 56 * v16;
          v22 = *(_DWORD *)(v20 + 12);
          v21 = (unsigned int *)(v20 + 12);
          v23 = *(_DWORD *)(v18 - 16) + *(_DWORD *)(v18 - 20);
          v24 = v23 - v22;
          if (v23 < v22)
          {
            log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v10, v11, v12, v13, a5);
            return 2588942343;
          }
          v25 = v15;
          v26 = (uint64_t *)(v7 + 56 * v17);
          v27 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *v26, (v24 + 1));
          *v26 = (uint64_t)v27;
          if (!v27)
            goto LABEL_60;
          v32 = v17;
          v33 = v7;
          v76 = v32;
          v34 = v32;
          strncpy(v27, (const char *)(v81 + *v21), v24);
          v35 = v34;
          v7 = v33;
          *(_BYTE *)(*v26 + v24) = 0;
          v36 = v33 + 56 * v35;
          v38 = *(_DWORD *)(v36 + 32);
          v37 = v36 + 32;
          *(_DWORD *)(v37 - 16) = v24;
          *(_QWORD *)(v37 + 4) = *(_QWORD *)(v18 + 4);
          v39 = *(_DWORD *)v18;
          if (v38 == 1 && v39 == 2)
          {
            v39 = 3;
            v40 = v25;
            v8 = (const char *)v81;
            v9 = v79;
            goto LABEL_28;
          }
          v40 = v25;
          v9 = v79;
          if (v39 == 3)
          {
            v8 = (const char *)v81;
LABEL_28:
            v46 = v76;
          }
          else
          {
            v8 = (const char *)v81;
            v46 = v76;
            if (v39 != 2)
              goto LABEL_30;
          }
          *(_DWORD *)v37 = v39;
          *(_DWORD *)(v7 + 56 * v35 + 20) = *(_DWORD *)(v18 - 12);
LABEL_30:
          v15 = v24 + v40;
          v17 = v46 + 1;
          v16 = v14 + 1;
          a2 = v78;
          break;
      }
      ++v14;
      v18 += 56;
      if (v9 == v14)
        goto LABEL_34;
    }
  }
  v17 = 0;
  v15 = 0;
LABEL_34:
  v51 = v15;
  if (v17 < v9)
  {
    v52 = (uint64_t *)(v7 + 56 * v17);
    v53 = v9 - v17;
    do
    {
      v54 = *v52;
      v52 += 7;
      heap_Free(*(_QWORD **)(a1 + 8), v54);
      --v53;
    }
    while (v53);
  }
  *v75 = v17;
  v55 = v51 + v17;
  if ((int)v55 + 1 <= v74)
  {
    v56 = v81;
    if (v17)
    {
LABEL_40:
      v57 = 0;
      v58 = (const void **)(v7 + 16);
      v59 = v17;
      do
      {
        v60 = v57;
        memcpy((void *)(v56 + v57), *(v58 - 2), *(unsigned int *)v58);
        *(_BYTE *)(v56 + *(_DWORD *)v58 + v60) = 32;
        v62 = *(_DWORD *)v58;
        v58 += 7;
        v61 = v62;
        v57 = v60 + v62 + 1;
        --v59;
      }
      while (v59);
      if (v57)
        *(_BYTE *)(v56 + v60 + v61) = 0;
      LODWORD(v63) = 0;
      *a5 = (const char *)v56;
      do
      {
        if (*(_DWORD *)(v7 + 56 * v63 + 32) == 1)
        {
          v64 = v63;
          v65 = v63;
          if (v63 < v17)
          {
            v66 = 0;
            v67 = (int *)(v7 + 88 + 56 * v64);
            do
            {
              *(v67 - 14) = 4;
              ++v66;
              v68 = *v67;
              v67 += 14;
            }
            while (v68 != 2 && v66 + v64 < (unint64_t)v17);
            v63 = v64 + v66;
            v65 = v63;
          }
          *(_QWORD *)(v7 + 56 * v65 + 8) = *(_QWORD *)(v7 + 56 * v64 + 8);
        }
        else
        {
          LODWORD(v63) = v63 + 1;
        }
      }
      while (v63 < v17);
      return 0;
    }
LABEL_59:
    v70 = 0;
    *a5 = (const char *)v56;
    return v70;
  }
  v56 = heap_Realloc(*(uint64_t **)(a1 + 8), v81, v55);
  if (v56)
  {
    if (v17)
      goto LABEL_40;
    goto LABEL_59;
  }
  v70 = 2588942346;
  v71 = *(_QWORD *)(a1 + 32);
LABEL_62:
  log_OutPublic(v71, (uint64_t)"FE_NNWS", 75000, 0, v28, v29, v30, v31, a5);
  return v70;
}

uint64_t fe_nnws_writeLDB_v2(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  unsigned int v10;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  __int128 *v30;
  uint64_t v31;
  __int128 *v32;
  int v33;
  int v34;
  uint64_t v36;
  unsigned int v37;
  __int128 *v38;
  int v39;
  int v40;
  unint64_t v41;
  unsigned __int16 v42;
  unint64_t v43;
  __int128 *v44;
  unint64_t v45;
  __int128 *v46;
  _DWORD *v47;
  int v48;
  int v49;
  int v50;
  __int128 *v51;
  int v52;
  __int128 *v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  _DWORD *v62;
  uint64_t v63;
  int v64;
  _DWORD *v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  uint64_t v70;
  _DWORD *v71;
  int v72;
  int *v73;
  _DWORD *v74;
  __int128 *v76;
  __int128 v77;
  int v78;
  int v79;
  __int128 *v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  unsigned int v85;
  _DWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  int v92;
  int v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  int v97;
  unsigned int v98;
  unsigned int v99;
  __int128 *v100;
  int v101;
  int v102;
  __int128 *v103;
  _DWORD *v104;
  __int128 v105;
  int v106;
  uint64_t v107;
  _DWORD *v108;
  __int128 *v109;
  _DWORD *v110;
  int v111;
  _DWORD *v112;
  __int128 v113;
  unsigned int v114;
  uint64_t v115;
  int v116;
  _DWORD *v117;
  __int128 v118;
  _DWORD *v119;
  uint64_t v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  _DWORD *v124;
  _DWORD *v125;
  int v126;
  _DWORD *v127;
  _DWORD *v128;
  unsigned int v129;
  unsigned int v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unsigned int v134;
  _DWORD *v135;
  __int128 v136;
  unsigned int v137;
  uint64_t v138;
  _DWORD *v139;
  _DWORD *v140;
  unsigned int v141;
  unsigned int v142;
  _DWORD *v143;
  unsigned int v144;
  unint64_t v145;
  int v146;
  int v147;
  unsigned int v149;
  unsigned int v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  unsigned int v159;
  uint64_t v160;
  unsigned int v161;
  int v162;
  __int128 *v163;
  __int128 v164;
  __int128 v165;

  v10 = a4;
  v163 = 0;
  v162 = 0;
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 **, int *))(a1[6] + 176))(a2, a3, a4, 1, &v163, &v162);
  if ((v14 & 0x80000000) != 0)
    return v14;
  v160 = a3;
  v161 = v10;
  reorder_pMrk(&v163, (unsigned __int16)v162, 40);
  reorder_pMrk(&v163, (unsigned __int16)v162, 1);
  if (a6)
  {
    v15 = heap_Calloc(*(_QWORD **)(*a1 + 8), a6, 32);
    v20 = *a1;
    if (!v15)
    {
      v27 = 2588942346;
      log_OutPublic(*(_QWORD *)(v20 + 32), (uint64_t)"FE_NNWS", 75000, 0, v16, v17, v18, v19, v159);
      return v27;
    }
    v21 = v15;
    v26 = heap_Calloc(*(_QWORD **)(v20 + 8), a6, 4);
    if (!v26)
    {
      v27 = 2588942346;
      log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v22, v23, v24, v25, v159);
      v28 = 0;
LABEL_180:
      heap_Free(*(_QWORD **)(*a1 + 8), v21);
      goto LABEL_181;
    }
  }
  else
  {
    v21 = 0;
    v26 = 0;
  }
  v29 = (unsigned __int16)v162;
  v30 = v163;
  if ((_WORD)v162)
  {
    v31 = 0;
    v32 = v163;
    while (1)
    {
      v34 = *(_DWORD *)v32;
      v32 += 2;
      v33 = v34;
      if (v34 == 41 || v33 == 1)
        break;
      if ((unsigned __int16)v162 == ++v31)
      {
        LODWORD(v31) = -1;
        break;
      }
    }
    v36 = 0;
    v37 = v31 & ~((int)v31 >> 31);
    v38 = v163;
    while (1)
    {
      v39 = *(_DWORD *)v38;
      v38 += 2;
      if (v39 == 40)
        break;
      if ((unsigned __int16)v162 == ++v36)
        goto LABEL_22;
    }
    v40 = v36;
    if (a6)
      goto LABEL_50;
LABEL_23:
    if (!(_WORD)v162)
      goto LABEL_81;
    goto LABEL_24;
  }
  v37 = 0;
LABEL_22:
  v40 = -1;
  if (!a6)
    goto LABEL_23;
LABEL_50:
  v59 = 0;
  v60 = 0;
  v61 = *((_DWORD *)v163 + 3);
  v62 = (_DWORD *)&v163[2 * v37] + 1;
  do
  {
    v63 = a5 + 56 * v59;
    v66 = *(_DWORD *)(v63 + 32);
    v65 = (_DWORD *)(v63 + 32);
    v64 = v66;
    v67 = v21 + 32 * v59;
    if (v66 == 4)
    {
      v60 += *(_DWORD *)(a5 + 56 * v59 + 16) + 1;
      *(_DWORD *)v67 = 0;
      goto LABEL_79;
    }
    *(_DWORD *)(v67 + 4) = *v62 + *(_DWORD *)(a5 + 56 * v59 + 8);
    if ((v64 & 0xFFFFFFFE) == 2)
    {
      v68 = *(_DWORD *)(a5 + 56 * v59 + 20);
      v69 = *(_DWORD *)(a5 + 56 * v59 + 16) + v60;
    }
    else
    {
      v68 = *(_DWORD *)(a5 + 56 * v59 + 16);
      v69 = v68;
    }
    v70 = v21 + 32 * v59;
    *(_DWORD *)(v70 + 8) = v68;
    v71 = (_DWORD *)(v70 + 8);
    v72 = v61;
    if (v59)
      v72 = *(_DWORD *)(v70 - 20) + *(_DWORD *)(v70 - 16) + 1;
    *(_DWORD *)(v70 + 12) = v72;
    v73 = (int *)(v70 + 12);
    v73[1] = v69;
    v74 = v73 + 1;
    if (v64 != 5 || v40 == -1)
    {
      *(_DWORD *)v67 = 1;
      goto LABEL_73;
    }
    v76 = &v30[2 * v40];
    v77 = v76[1];
    *(_OWORD *)v67 = *v76;
    *(_OWORD *)(v67 + 16) = v77;
    v78 = *(_DWORD *)(a5 + 56 * v59 + 16);
    *v71 = v78;
    v79 = v61;
    if (v59)
      v79 = *(_DWORD *)(v21 + 32 * v59 - 20) + *(_DWORD *)(v21 + 32 * v59 - 16) + 1;
    *v73 = v79;
    *v74 = v78;
    if (v40 + 1 < v29)
    {
      v80 = &v30[2 * ++v40];
      while (1)
      {
        v81 = *(_DWORD *)v80;
        v80 += 2;
        if (v81 == 40)
          break;
        if (v29 == ++v40)
        {
          v40 = -1;
          break;
        }
      }
    }
    v82 = *(_DWORD *)v67;
    if (v82 != 40)
    {
      if (v82 != 1)
        goto LABEL_75;
LABEL_73:
      if (*(_DWORD *)(a5 + 56 * v59 + 36) != 1)
        goto LABEL_75;
    }
    *(_DWORD *)(v26 + 4 * v59) = 1;
LABEL_75:
    if ((*v65 & 0xFFFFFFFE) == 2 && !*(_DWORD *)(a5 + 56 * v59 + 40))
      *(_DWORD *)(v26 + 4 * v59) = 2;
    v60 = 0;
    v83 = *v73 - *((_DWORD *)v30 + 3);
    v84 = a5 + 56 * v59;
    *(_DWORD *)(v84 + 24) = v83;
    *(_DWORD *)(v84 + 28) = *v74 + v83;
LABEL_79:
    ++v59;
  }
  while (v59 != a6);
  v30 = v163;
  if (!v29)
  {
LABEL_81:
    LOWORD(v162) = 0;
    goto LABEL_83;
  }
LABEL_24:
  v41 = 0;
  v42 = v29;
  do
  {
    v43 = v42;
    v44 = &v30[2 * v41];
    if (*(_DWORD *)v44 == 40)
    {
      v45 = v41 + 1;
      if (v42 > v41 + 1)
      {
        v51 = &v30[2 * v45];
        if (*(_DWORD *)v51 == 1 && HIDWORD(v30[2 * v41]) == *((_DWORD *)v51 + 3))
        {
          memmove(v44, v51, 32 * (v42-- - v45));
          v43 = v42;
        }
      }
    }
    else if (*(_DWORD *)v44 == 99)
    {
      v45 = v41 + 1;
      if (v41 + 1 < v42)
      {
        v46 = &v30[2 * v41];
        v49 = *((_DWORD *)v46 + 3);
        v47 = (_DWORD *)v46 + 3;
        v48 = v49;
        v50 = HIDWORD(v30[2 * v45]);
        if (v49 == v50 - 1 && *(_BYTE *)(a7 + (v48 - *((_DWORD *)v30 + 3))) == 32)
        {
          *v47 = v50;
          DWORD1(v30[2 * v41]) = DWORD1(v30[2 * v45]);
        }
      }
    }
    else
    {
      v45 = v41 + 1;
    }
    v41 = v45;
  }
  while (v45 < v43);
  LOWORD(v162) = v42;
  if (v42)
  {
    v52 = 0;
    v29 = 0;
    v53 = v163;
    v54 = v42;
    do
    {
      v56 = *(_DWORD *)v53;
      v53 += 2;
      v55 = v56;
      if (v52)
        v57 = v29;
      else
        v57 = v29 + 1;
      if (v55 == 0x4000)
      {
        v58 = 1;
      }
      else
      {
        v57 = v29 + 1;
        v58 = v52;
      }
      if (v55 != 1)
      {
        v29 = v57;
        v52 = v58;
      }
      --v54;
    }
    while (v54);
  }
  else
  {
    v29 = 0;
  }
LABEL_83:
  v85 = v29 + a6;
  v86 = (_DWORD *)heap_Alloc(*(_QWORD *)(*a1 + 8), 32 * (v29 + a6));
  v28 = v86;
  if (v86)
  {
    v91 = (unsigned __int16)v162;
    if ((_WORD)v162)
    {
      v92 = 0;
      v93 = 0;
      v94 = 0;
      v95 = 0;
      v96 = 0;
      v97 = 0;
      v98 = 0;
      v99 = 0;
      v100 = v163;
      v159 = (_DWORD)v86 + 36;
      v101 = 1;
      v102 = 1;
      while (1)
      {
        v103 = &v100[2 * v99];
        if (*(_DWORD *)v103 == 0x4000)
        {
          if (!v93)
          {
            v104 = &v86[8 * v95];
            v105 = v103[1];
            *(_OWORD *)v104 = *v103;
            *((_OWORD *)v104 + 1) = v105;
            v106 = v104[1];
            if (v106)
              v106 = *((_DWORD *)a1 + 27);
            else
              a1[13] = 0;
            v86[8 * v95 + 3] = v106;
            v96 = v106 - HIDWORD(v100[2 * v99]);
            ++v95;
          }
          ++v99;
          v93 = 1;
          goto LABEL_141;
        }
        if (*(_DWORD *)v103 == 1)
        {
          if (v102 == 1)
            v92 = DWORD1(v100[2 * v99]);
          v102 = 0;
          goto LABEL_113;
        }
        if (v98 < a6)
        {
          v107 = v21 + 32 * v98;
          v108 = (_DWORD *)(v107 + 12);
          v109 = &v100[2 * v99];
          v111 = *((_DWORD *)v109 + 3);
          v110 = (_DWORD *)v109 + 3;
          if (*(_DWORD *)(v107 + 12) < (v111 + v97))
          {
            v112 = &v86[8 * v95];
            v113 = *(_OWORD *)(v107 + 16);
            *(_OWORD *)v112 = *(_OWORD *)v107;
            *((_OWORD *)v112 + 1) = v113;
            v114 = *v108 + v96;
            v112[3] = v114;
            if (v95)
            {
              v115 = v95 - 1;
              if (v95 == 1)
              {
                v116 = v86[1];
                goto LABEL_122;
              }
              v123 = v86[8 * v95 - 8];
              if (v123 <= 0x28 && ((1 << v123) & 0x10020000002) != 0)
              {
                v116 = v86[8 * v115 + 2] + v86[8 * v115 + 1];
LABEL_122:
                v124 = &v86[8 * v95];
                v124[1] = v116;
                v125 = v124 + 1;
                v126 = *(_DWORD *)(v26 + 4 * v98);
                if (v126 == 2)
                {
                  if (*v108 - v97 != *v110)
                    ++v97;
                  if (!v95)
                    goto LABEL_136;
LABEL_126:
                  if (v86[8 * v95 - 8] == 29)
                  {
                    v127 = &v86[8 * v95 - 8];
                    v130 = v127[3];
                    v128 = v127 + 3;
                    v129 = v130;
                    if (v114 > v130)
                      *v128 = v129 + 1;
                  }
                  if (v101 == 1)
                  {
                    *v125 = v92;
                    if (v95 == 2)
                    {
                      v125 = v86 + 9;
                      if (v86[8] == 36)
LABEL_137:
                        *v125 = v92;
                    }
                  }
                }
                else
                {
                  if (!v126)
                    ++v97;
                  if (v95)
                    goto LABEL_126;
LABEL_136:
                  if (v101 == 1)
                    goto LABEL_137;
                }
                v101 = 0;
                if (++v98 == a6)
                  v94 = v95;
                ++v95;
                goto LABEL_141;
              }
            }
            else
            {
              v115 = 0xFFFFFFFFLL;
            }
            v116 = v86[8 * v115 + 1];
            goto LABEL_122;
          }
        }
        v117 = &v86[8 * v95];
        v118 = v103[1];
        *(_OWORD *)v117 = *v103;
        *((_OWORD *)v117 + 1) = v118;
        v117[3] = v97 + v96 + HIDWORD(v100[2 * v99]);
        v119 = v117 + 3;
        if (v98 == a6 && v94)
          *v119 = v86[8 * v94 + 4] + v86[8 * v94 + 3];
        v120 = v95 - 1;
        if (v95 == 1)
          break;
        if (v98 != a6)
        {
          if (v95)
          {
            v122 = v86[8 * v95 - 8];
            if (v122 <= 0x28 && ((1 << v122) & 0x10020000002) != 0)
            {
              v121 = v86[8 * v120 + 2] + v86[8 * v120 + 1];
              goto LABEL_111;
            }
          }
        }
        if (v98 != a6)
        {
          v121 = v86[8 * v120 + 1];
          goto LABEL_111;
        }
LABEL_112:
        ++v95;
LABEL_113:
        ++v99;
LABEL_141:
        if (v99 >= v91)
          goto LABEL_145;
      }
      v121 = v86[1];
LABEL_111:
      v86[8 * v95 + 1] = v121;
      goto LABEL_112;
    }
    v98 = 0;
    v96 = 0;
    v95 = 0;
LABEL_145:
    if (v98 < a6)
    {
      v131 = v98;
      v132 = a6 - (unint64_t)v98;
      v133 = v21 + 32 * v131;
      while (1)
      {
        v134 = v95;
        v135 = &v86[8 * v95];
        v136 = *(_OWORD *)(v133 + 16);
        *(_OWORD *)v135 = *(_OWORD *)v133;
        *((_OWORD *)v135 + 1) = v136;
        v137 = *(_DWORD *)(v133 + 12) + v96;
        v135[3] = v137;
        if (v95 >= 3)
          break;
        if (v95)
        {
          v138 = v95 - 1;
          goto LABEL_151;
        }
LABEL_154:
        v133 += 32;
        v95 = v134 + 1;
        if (!--v132)
          goto LABEL_155;
      }
      v138 = v95 - 1;
      v135[1] = v86[8 * v138 + 2] + v86[8 * v138 + 1];
LABEL_151:
      if (v86[8 * v138] == 29)
      {
        v139 = &v86[8 * v138];
        v142 = v139[3];
        v140 = v139 + 3;
        v141 = v142;
        if (v137 > v142)
          *v140 = v141 + 1;
      }
      goto LABEL_154;
    }
LABEL_155:
    v143 = &v86[8 * v95 - 8];
    v86[4] = v143[4] + v143[3] - v86[3];
    v86[2] = v143[2] + v143[1] - v86[1];
    if (v85)
    {
      v144 = 0;
      LODWORD(v145) = -1;
      do
      {
        v146 = v28[8 * v144];
        if (v146 == 51)
        {
          v147 = (v85 - v144 > 1) & (strcmp(*(const char **)&v28[8 * v144 + 6], "R_CLASS") == 0);
          if (v147)
            LODWORD(v145) = v144;
          v144 += v147;
        }
        else if (v146 == 57 && (_DWORD)v145 != -1)
        {
          v149 = v144 - 1;
          do
          {
            v150 = v149;
            if (!v149)
              break;
            v151 = v28[8 * v149--];
          }
          while (v151 != 1);
          if (v145 < v150)
          {
            v152 = v145;
            v145 = v145 + 1;
            if (v145 < v150)
            {
              LODWORD(v145) = v150;
              v153 = (uint64_t)&v28[8 * v152 + 8];
              v154 = ~v152 + v150;
              do
              {
                v156 = *(_OWORD *)(v153 - 16);
                v164 = *(_OWORD *)(v153 - 32);
                v155 = v164;
                v165 = v156;
                v157 = *(_OWORD *)(v153 + 16);
                *(_OWORD *)(v153 - 32) = *(_OWORD *)v153;
                *(_OWORD *)(v153 - 16) = v157;
                *(_OWORD *)v153 = v155;
                *(_OWORD *)(v153 + 16) = v156;
                *(_DWORD *)(v153 - 28) = *(_DWORD *)(v153 + 4);
                v153 += 32;
                --v154;
              }
              while (v154);
            }
          }
          if ((_DWORD)v145)
            v28[8 * (v145 - 1) + 3] = v28[8 * v145 + 3];
          LODWORD(v145) = -1;
        }
        ++v144;
      }
      while (v144 < v85);
    }
    v27 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _DWORD *, char *))(a1[6] + 160))(a2, v160, v161, 1, (unsigned __int16)v85, v28, (char *)&v162 + 2);
    if ((v27 & 0x80000000) == 0)
    {
      *((_DWORD *)a1 + 26) = v28[2] + v28[1];
      *((_DWORD *)a1 + 27) = v28[4] + v28[3];
      if (!v21)
        goto LABEL_181;
      goto LABEL_180;
    }
  }
  else
  {
    v27 = 2588942346;
  }
  log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v87, v88, v89, v90, v159);
  if (v21)
    goto LABEL_180;
LABEL_181:
  if (v26)
    heap_Free(*(_QWORD **)(*a1 + 8), v26);
  if (v28)
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v28);
  return v27;
}

uint64_t fe_nnws_adjustTokenRecordBND(uint64_t a1, unsigned int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result;
  unsigned __int16 v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  int v20;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  _DWORD *v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37;
  _DWORD *v38;
  uint64_t v39;
  uint64_t v40;
  char *__s;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  char *__s1;
  uint64_t v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;

  v52 = 0;
  v50 = 0;
  v51 = 0;
  v48 = 0;
  v49 = 0;
  __s1 = 0;
  v47 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, int *))(*(_QWORD *)(a7 + 48) + 176))(a5, a6, a4, 1, &v47, &v48);
  if ((result & 0x80000000) == 0)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)(a7 + 48) + 104))(a5, a6, 3, a4, (char *)&v49 + 2);
    if ((result & 0x80000000) == 0)
    {
      v15 = HIWORD(v49);
      if (HIWORD(v49))
      {
        v45 = 0;
        v16 = 0;
        v44 = a2;
        v38 = (_DWORD *)(a1 + 48);
        v39 = a1 + 32;
        v42 = a2;
        v40 = a1;
        __s = a3;
        while (1)
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, char *))(*(_QWORD *)(a7 + 48) + 168))(a5, a6, v15, 0, 1, &v52, (char *)&v48 + 2);
          if ((result & 0x80000000) != 0)
            return result;
          if (v52 == 5)
            break;
          if (v52 != 6)
          {
            v33 = HIWORD(v49);
LABEL_54:
            result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(a7 + 48) + 120))(a5, a6, HIWORD(v49), (char *)&v49 + 2);
            if ((result & 0x80000000) != 0)
              return result;
            if ((_DWORD)v33)
              result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a7 + 48) + 192))(a5, a6, v33);
            goto LABEL_57;
          }
          if (v16 < a2)
          {
            v17 = v16;
            v18 = (unsigned int *)(v39 + 56 * v16);
            do
            {
              v19 = *v18;
              v18 += 14;
              v20 = (1 << v19) & 0x2C;
              if (v19 <= 5 && v20 != 0)
              {
                v16 = v17;
                goto LABEL_39;
              }
              ++v17;
            }
            while (v44 != v17);
            v16 = v44;
          }
LABEL_39:
          v34 = a1 + 56 * v16;
          v35 = *(_DWORD *)(v34 + 24);
          v50 = *(_DWORD *)(v34 + 28);
          v51 = v35;
          ++v16;
          v36 = *(_QWORD *)(a7 + 48);
          if (v50 > v35)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned int *, int *))(v36 + 160))(a5, a6, HIWORD(v49), 1, 1, &v51, &v49);
            if ((result & 0x80000000) != 0)
              return result;
            result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned int *, int *))(*(_QWORD *)(a7 + 48) + 160))(a5, a6, HIWORD(v49), 2, 1, &v50, &v49);
            if ((result & 0x80000000) != 0)
              return result;
            v33 = 0;
            goto LABEL_54;
          }
          result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(v36 + 120))(a5, a6, HIWORD(v49), (char *)&v49 + 2);
          if ((result & 0x80000000) != 0)
            return result;
LABEL_57:
          v15 = HIWORD(v49);
          if (!HIWORD(v49))
            return result;
        }
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned int *, char *))(*(_QWORD *)(a7 + 48) + 168))(a5, a6, HIWORD(v49), 1, 1, &v51, (char *)&v48 + 2);
        if ((result & 0x80000000) != 0)
          return result;
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned int *, char *))(*(_QWORD *)(a7 + 48) + 168))(a5, a6, HIWORD(v49), 2, 1, &v50, (char *)&v48 + 2);
        if ((result & 0x80000000) != 0)
          return result;
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(a7 + 48)
                                                                                               + 176))(a5, a6, HIWORD(v49), 4, &__s1, (char *)&v48 + 2);
        if ((result & 0x80000000) != 0)
          return result;
        v43 = v16;
        v22 = v50;
        v23 = v51;
        v24 = v47;
        v25 = *(_DWORD *)(v47 + 16);
        if (v50 < v25 + v51)
        {
          v51 += v45;
          v26 = v44;
          if (a2)
          {
            v27 = 0;
            v28 = __s1;
            v29 = v38;
            while (1)
            {
              if (*(v29 - 2) == 1 && ((v30 = strcmp(v28, "prompt"), v26 = v44, v30) || *(v29 - 4) == 5) && *v29 != 1)
              {
                v31 = *(v29 - 9);
              }
              else
              {
                v31 = *(v29 - 9);
                if (v31 >= v23 && *(v29 - 8) + v31 < v22)
                {
                  ++v45;
                  goto LABEL_36;
                }
              }
              v32 = *(v29 - 8) + v31;
              if (v32 >= v22)
              {
                if (*v29 != 1)
                {
LABEL_46:
                  v22 += v45;
                  v50 = v22;
                  a2 = v42;
                  goto LABEL_47;
                }
                v22 += ++v45;
                v50 = v22;
              }
              else if (v32 == v25 + *(_DWORD *)(v24 + 12))
              {
                goto LABEL_46;
              }
LABEL_36:
              ++v27;
              v29 += 14;
              if (v26 == v27)
                goto LABEL_48;
            }
          }
          LODWORD(v27) = 0;
LABEL_47:
          if ((_DWORD)v27 == a2)
          {
LABEL_48:
            v22 += v45;
            v50 = v22;
          }
        }
        v37 = strlen(__s);
        if (v22 > v37)
          v50 = v37;
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned int *, int *))(*(_QWORD *)(a7 + 48) + 160))(a5, a6, HIWORD(v49), 1, 1, &v51, &v49);
        a1 = v40;
        v16 = v43;
        if ((result & 0x80000000) != 0)
          return result;
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned int *, int *))(*(_QWORD *)(a7 + 48) + 160))(a5, a6, HIWORD(v49), 2, 1, &v50, &v49);
        if ((result & 0x80000000) != 0)
          return result;
        v33 = 0;
        a2 = v42;
        goto LABEL_54;
      }
    }
  }
  return result;
}

uint64_t fe_nnws_adjust_ENP_labels(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6;
  unsigned __int8 **v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  const char *v11;
  int v12;
  int v13;
  int v14;
  uint64_t *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t *v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  unint64_t v24;

  if ((_DWORD)result)
  {
    v6 = result;
    v7 = (unsigned __int8 **)*a4;
    v22 = a3 + 1;
    v23 = a3 + 3;
    v24 = result;
    v8 = (_DWORD *)(a2 + 36);
    v9 = -(uint64_t)result;
    v10 = 1;
    do
    {
      v11 = *(const char **)(v8 - 9);
      if (!strcmp(v11, "ENG") || (result = strcmp(v11, "NUM"), !(_DWORD)result))
      {
        *v7 = (unsigned __int8 *)*a3;
        result = fe_hlp_adjustBMES_basedSingleLabel(v6, (int)v10 - 1, a3, a4);
        goto LABEL_13;
      }
      if (v10 != 1 && !*(v8 - 13) && *(v8 - 5) == 1)
      {
        result = strcmp(v11, "/");
        if ((_DWORD)result)
        {
          *v7 = (unsigned __int8 *)a3[3];
          result = fe_hlp_adjustBMES_basedSingleLabel(v6, (int)v10 - 1, a3, a4);
          v12 = *(v8 - 15);
          if (v12 == 3)
          {
            *(v8 - 15) = 1;
            goto LABEL_37;
          }
          if (v12 == 2)
          {
            *(v8 - 15) = 0;
LABEL_37:
            *(v8 - 1) = 2;
            *(v8 - 4) = *(v8 - 18) + 1;
            goto LABEL_13;
          }
          goto LABEL_13;
        }
      }
      if (!*v8)
      {
        v13 = *(v8 - 1);
        if ((v13 - 2) >= 2)
        {
          if (v13 != 1)
            goto LABEL_13;
          v18 = **v7;
          v19 = a3;
          if (v18 == 69)
          {
LABEL_29:
            *v7 = (unsigned __int8 *)*v19;
          }
          else if (v18 == 77)
          {
            v19 = v22;
            goto LABEL_29;
          }
          if (v10 != 1)
          {
            v20 = **(v7 - 1);
            if (v20 == 77)
            {
              v21 = *v23;
              goto LABEL_39;
            }
            if (v20 == 66)
            {
              v21 = *a3;
LABEL_39:
              *(v7 - 1) = (unsigned __int8 *)v21;
              goto LABEL_13;
            }
          }
          goto LABEL_13;
        }
      }
      v14 = **v7;
      v15 = a3;
      if (v14 != 66)
      {
        if (v14 != 77)
          goto LABEL_21;
        v15 = v23;
      }
      *v7 = (unsigned __int8 *)*v15;
LABEL_21:
      if (v10 < v24)
      {
        v16 = *v7[1];
        if (v16 == 69)
        {
          v17 = *a3;
          goto LABEL_35;
        }
        if (v16 == 77)
        {
          v17 = *v22;
LABEL_35:
          v7[1] = (unsigned __int8 *)v17;
        }
      }
LABEL_13:
      ++v10;
      v8 += 14;
      ++v7;
    }
    while (v9 + v10 != 1);
  }
  return result;
}

uint64_t fe_hlp_adjustBMES_basedSingleLabel(uint64_t result, unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  int v19;
  int v20;
  uint64_t v21;

  v4 = *a4;
  v5 = **(unsigned __int8 **)(*a4 + 8 * a2);
  if (v5 > 0x4C)
  {
    if (v5 != 77)
    {
      if (v5 != 83)
        return result;
      if (a2)
      {
        v6 = a2 - 1;
        v9 = **(unsigned __int8 **)(v4 + 8 * v6);
        v10 = a3;
        if (v9 != 66)
        {
          if (v9 != 77)
            goto LABEL_27;
          v10 = a3 + 3;
        }
        v11 = *v10;
        goto LABEL_26;
      }
LABEL_27:
      if (a2 + 1 >= result)
        return result;
      v18 = (uint64_t *)(v4 + 8 * (a2 + 1));
      v19 = *(unsigned __int8 *)*v18;
      if (v19 != 69)
      {
        if (v19 != 77)
          return result;
        ++a3;
      }
      goto LABEL_40;
    }
    if (a2)
    {
      v12 = a2 - 1;
      v16 = **(unsigned __int8 **)(v4 + 8 * v12);
      if (v16 == 69)
      {
        v17 = 2;
      }
      else
      {
        if (v16 != 83)
          goto LABEL_34;
        v17 = 1;
      }
      v15 = a3[v17];
      goto LABEL_33;
    }
  }
  else
  {
    if (v5 != 66)
    {
      if (v5 != 69)
        return result;
      if (a2)
      {
        v6 = a2 - 1;
        v7 = **(unsigned __int8 **)(v4 + 8 * v6);
        if (v7 == 69)
        {
          v8 = 2;
        }
        else
        {
          if (v7 != 83)
            goto LABEL_27;
          v8 = 1;
        }
        v11 = a3[v8];
LABEL_26:
        *(_QWORD *)(v4 + 8 * v6) = v11;
        goto LABEL_27;
      }
      goto LABEL_27;
    }
    if (a2)
    {
      v12 = a2 - 1;
      v13 = **(unsigned __int8 **)(v4 + 8 * v12);
      v14 = a3;
      if (v13 == 66)
      {
LABEL_19:
        v15 = *v14;
LABEL_33:
        *(_QWORD *)(v4 + 8 * v12) = v15;
        goto LABEL_34;
      }
      if (v13 == 77)
      {
        v14 = a3 + 3;
        goto LABEL_19;
      }
    }
  }
LABEL_34:
  if (a2 + 1 >= result)
    return result;
  v18 = (uint64_t *)(v4 + 8 * (a2 + 1));
  v20 = *(unsigned __int8 *)*v18;
  if (v20 == 66)
  {
    v21 = 2;
  }
  else
  {
    if (v20 != 83)
      return result;
    v21 = 3;
  }
  a3 += v21;
LABEL_40:
  *v18 = *a3;
  return result;
}

uint64_t fe_nnws_setFeature(uint64_t a1, const char **a2, unsigned int a3, int a4, char **a5, const char *a6)
{
  unsigned int v6;
  uint64_t v11;
  const char *v12;
  uint64_t result;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;

  if (a3 < 2)
    return 0;
  v20 = v6;
  v11 = a3 - 1;
  v12 = nnws_g_featureNames[a4];
  while (strcmp(*a2, v12))
  {
    ++a5;
    ++a2;
    if (!--v11)
      return 0;
  }
  if (*a6)
  {
    v14 = strlen(a6);
    if (v14 < 0x41)
    {
LABEL_11:
      strcpy(*a5, a6);
      return 0;
    }
    v15 = heap_Realloc(*(uint64_t **)(a1 + 8), (uint64_t)*a5, (unsigned __int16)v14 + 1);
    if (v15)
    {
      *a5 = (char *)v15;
      goto LABEL_11;
    }
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_NNWS", 37000, 0, v16, v17, v18, v19, v20);
    return 2588942346;
  }
  else
  {
    result = 0;
    *(_WORD *)*a5 = 61;
  }
  return result;
}

__int128 **reorder_pMrk(__int128 **result, unsigned int a2, int a3)
{
  uint64_t v3;
  __int128 *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  if (a2)
  {
    v3 = 0;
    v4 = *result;
    do
    {
      if (++v3 < (unint64_t)a2 && *(_DWORD *)v4 == a3 && *((_DWORD *)v4 + 11) == *((_DWORD *)v4 + 3))
      {
        v5 = *v4;
        v7 = v4[1];
        v6 = v4[3];
        *v4 = v4[2];
        v4[1] = v6;
        v4[2] = v5;
        v4[3] = v7;
        *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 9);
      }
      v4 += 2;
    }
    while (a2 != v3);
  }
  return result;
}

uint64_t fe_initlingdb_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t LowerCasedMainLng3;
  uint64_t inited;
  uint64_t Object;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL4 v25;
  const char *v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v32 = 0;
  v33 = 0;
  v30 = 0;
  v31 = 0;
  LowerCasedMainLng3 = 2307923975;
  v28 = 0;
  v29 = 0;
  if (!a5)
    return LowerCasedMainLng3;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v33);
  if ((inited & 0x80000000) != 0)
    return inited;
  inited = objc_GetObject(*(_QWORD *)(v33 + 48), (uint64_t)"LINGDB", &v31);
  if ((inited & 0x80000000) != 0)
    return inited;
  Object = objc_GetObject(*(_QWORD *)(v33 + 48), (uint64_t)"SYNTHSTREAM", &v32);
  v13 = *(_QWORD *)(v33 + 48);
  if ((Object & 0x80000000) != 0)
  {
    v26 = "LINGDB";
LABEL_20:
    objc_ReleaseObject(v13, (uint64_t)v26);
    return Object;
  }
  v14 = objc_GetObject(v13, (uint64_t)"FE_DCTLKP", &v30);
  if ((v14 & 0x80000000) != 0)
  {
    Object = v14;
    objc_ReleaseObject(*(_QWORD *)(v33 + 48), (uint64_t)"LINGDB");
    v13 = *(_QWORD *)(v33 + 48);
    v26 = "SYNTHSTREAM";
    goto LABEL_20;
  }
  v15 = heap_Calloc(*(_QWORD **)(v33 + 8), 1, 976);
  if (v15)
  {
    v20 = v15;
    *(_QWORD *)a5 = v15;
    *(_DWORD *)(a5 + 8) = 62336;
    *(_QWORD *)(v15 + 32) = a1;
    *(_QWORD *)(v15 + 40) = a2;
    *(_QWORD *)v15 = v33;
    *(_QWORD *)(v15 + 8) = a1;
    *(_QWORD *)(v15 + 16) = a3;
    *(_QWORD *)(v15 + 24) = a4;
    *(_QWORD *)(v15 + 72) = *(_QWORD *)(v31 + 8);
    *(_QWORD *)(v15 + 80) = *(_QWORD *)(v32 + 8);
    v21 = v30;
    *(_QWORD *)(v15 + 64) = *(_QWORD *)(v30 + 8);
    *(_OWORD *)(v15 + 48) = *(_OWORD *)(v21 + 16);
    v22 = objc_GetObject(*(_QWORD *)(v33 + 48), (uint64_t)"CLMOBJECT", &v29);
    if ((v22 & 0x80000000) != 0
      || (v23 = v29,
          *(_QWORD *)(v20 + 968) = *(_QWORD *)(v29 + 8),
          *(_OWORD *)(v20 + 952) = *(_OWORD *)(v23 + 16),
          v22 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)(v20 + 64) + 88))(*(_QWORD *)(v20 + 48), *(_QWORD *)(v20 + 56), (char *)&v28 + 4, &v28), (v22 & 0x80000000) != 0))
    {
      LowerCasedMainLng3 = v22;
LABEL_23:
      fe_initlingdb_ObjClose(*(_QWORD *)a5, *(_QWORD *)(a5 + 8));
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      return LowerCasedMainLng3;
    }
    v25 = (_DWORD)v28 == 1 && HIDWORD(v28) == 1;
    *(_DWORD *)(v20 + 944) = v25;
    LowerCasedMainLng3 = hlp_GetLowerCasedMainLng3(*(_QWORD *)v20, (char *)(v20 + 948));
    if ((LowerCasedMainLng3 & 0x80000000) != 0)
      goto LABEL_23;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(v33 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v16, v17, v18, v19, v28);
    objc_ReleaseObject(*(_QWORD *)(v33 + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(_QWORD *)(v33 + 48), (uint64_t)"SYNTHSTREAM");
    objc_ReleaseObject(*(_QWORD *)(v33 + 48), (uint64_t)"FE_DCTLKP");
    return 2307923978;
  }
  return LowerCasedMainLng3;
}

uint64_t hlp_GetLowerCasedMainLng3(uint64_t a1, char *a2)
{
  uint64_t Str;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char *__s;

  __s = 0;
  Str = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", &__s);
  if ((Str & 0x80000000) != 0)
    return Str;
  v4 = 2307923968;
  if (__s && strlen(__s) == 3)
  {
    strcpy(a2, __s);
    if (*a2)
    {
      v5 = 0;
      v6 = 0;
      do
      {
        a2[v5] = ssft_tolower(a2[v5]);
        v5 = ++v6;
      }
      while (strlen(a2) > v6);
    }
    return Str;
  }
  return v4;
}

uint64_t fe_initlingdb_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = safeh_HandleCheck(a1, a2, 62336, 976);
  if ((v3 & 0x80000000) != 0)
    return 2307923976;
  v4 = v3;
  if (a1)
  {
    objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"SYNTHSTREAM");
    objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"FE_DCTLKP");
    objc_ReleaseObject(*(_QWORD *)(*(_QWORD *)a1 + 48), (uint64_t)"CLMOBJECT");
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), a1);
  }
  return v4;
}

uint64_t fe_initlingdb_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result;
  _BOOL4 v5;
  uint64_t v6;

  v6 = 0;
  result = safeh_HandleCheck(a1, a2, 62336, 976);
  if ((result & 0x80000000) != 0)
    return 2307923976;
  if (a1)
  {
    result = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)(a1 + 64) + 88))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), (char *)&v6 + 4, &v6);
    if ((result & 0x80000000) == 0)
    {
      v5 = (_DWORD)v6 == 1 && HIDWORD(v6) == 1;
      *(_DWORD *)(a1 + 944) = v5;
      return hlp_GetLowerCasedMainLng3(*(_QWORD *)a1, (char *)(a1 + 948));
    }
  }
  return result;
}

uint64_t fe_initlingdb_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if ((safeh_HandleCheck(a1, a2, 62336, 976) & 0x80000000) != 0)
    return 2307923976;
  synstrmaux_InitStreamOpener(a1 + 88, *(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_INITLINGDB");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 88), (uint64_t)"text/plain;charset=utf-8", 0, a1 + 912);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 88), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    0,
    a1 + 928);
  v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 88), *(_QWORD *)(a1 + 80), a3, a4);
  if ((v7 & 0x80000000) != 0)
    synstrmaux_CloseStreams((_WORD *)(a1 + 88), *(_QWORD *)(a1 + 80));
  return v7;
}

uint64_t fe_initlingdb_Process(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int *v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  BOOL v29;
  unsigned int v31;
  unsigned int v32;
  _DWORD *v33;
  unsigned int v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  char *v37;
  uint64_t v38;
  int v39;
  unsigned __int16 v40;
  char **v41;
  size_t v42;
  uint64_t v43;
  const void **v44;
  size_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _DWORD *v71;
  uint64_t v72;
  unsigned int *v73;
  uint64_t v74;
  int *v75;
  int v76;
  unsigned __int16 v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _DWORD *v82;
  _DWORD *v83;
  char *v84;
  const char *v85;
  uint64_t v86;
  char *v87;
  int v88;
  uint64_t v89;
  const char *v90;
  unsigned int v91;
  uint64_t v92;
  int *v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v98;
  int v99;
  unsigned __int16 v100;
  unsigned __int16 v101;
  int *v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  int v106;
  uint64_t v107;
  _DWORD *v108;
  int v109;
  unsigned int v110;
  char *v111;
  unsigned int v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int NextUtf8Offset;
  uint64_t inserted;
  int v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unsigned __int16 v127;
  unsigned __int16 v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  const char *v133;
  int v134;
  unsigned int v135;
  int v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char *v142;
  int v143;
  int v144;
  unsigned __int16 v145;
  unsigned __int16 v146;
  uint64_t BestTNType;
  char *v148;
  char *v149;
  int v150;
  char *v151;
  int v152;
  char *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  int v162;
  unsigned __int16 v163;
  uint64_t i;
  char *v165;
  unsigned __int8 v166;
  int v167;
  unsigned __int8 v168;
  int v169;
  char *v170;
  const char **v171;
  char *v172;
  __int16 v173;
  unsigned __int16 v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  unsigned __int16 v178;
  uint64_t v179;
  uint64_t v180;
  _DWORD *v181;
  uint64_t v182;
  unsigned int v183;
  unsigned int v184;
  char *v185;
  int v186;
  const char *v187;
  uint64_t v188;
  unsigned int v189;
  char *__s;
  uint64_t v191;
  const char *v192;
  const char *v193;
  uint64_t v194;
  int v195;
  unsigned int v196;
  uint64_t v197;
  uint64_t v198;
  char *__s1;
  char *__s1a;
  char *__s1b;
  char *__s1c;
  char __s2[13];
  _BYTE __c[11];
  char *v205;
  char *v206;
  int v207;
  unsigned __int16 v208;
  unsigned __int16 v209;
  int v210;
  unsigned int v211;
  _DWORD *v212;
  unsigned int *v213;
  unsigned int v214;
  char *v215;
  char *v216;
  _QWORD v217[2];

  memset(v217, 0, 12);
  v9 = 2307923978;
  v215 = 0;
  v216 = 0;
  v214 = 0;
  v212 = 0;
  v213 = 0;
  v209 = 0;
  v207 = 0;
  v206 = 0;
  *(_QWORD *)&__c[3] = 0;
  v205 = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62336, 976) & 0x80000000) != 0)
    return 2307923976;
  v210 = 0;
  v211 = 0;
  v208 = 0;
  *a5 = 1;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *, _QWORD *))(a1[10] + 144))(a1[114], a1[115], &v217[1], v217);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, char *, _QWORD *))(a1[10] + 144))(a1[116], a1[117], (char *)v217 + 4, v217);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[9] + 56))(a3, a4);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a1[9] + 104))(a3, a4, 1, 0, (char *)&v210 + 2);
  if ((v10 & 0x80000000) != 0)
    return v10;
  if (!LODWORD(v217[1]))
  {
    v22 = v217[0];
    if (v217[0])
    {
      if (HIDWORD(v217[0]))
      {
        v10 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int **, unsigned int *))(a1[10] + 88))(a1[116], a1[117], &v213, &v211);
        if ((v10 & 0x80000000) != 0)
          return v10;
        if ((v211 & 0x1FFFE0) == 0 || !(unsigned __int16)(v211 >> 5))
          goto LABEL_32;
        v23 = v213;
        v24 = (unsigned __int16)((unint64_t)v211 >> 5);
        v25 = 1;
        do
        {
          v27 = *v23;
          v23 += 8;
          v26 = v27;
          v28 = (1 << v27) & 0x1000001003070000;
          v29 = v27 > 0x3C || v28 == 0;
          if (v29 && v26 != 0x4000)
            v25 = 0;
          --v24;
        }
        while (v24);
        if (!v25)
        {
          v53 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, unsigned int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 1, (unsigned __int16)(v211 >> 5), v213, &v210);
          if ((v53 & 0x80000000) != 0)
          {
            v9 = v53;
            log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30002, 0, v54, v55, v56, v57, v183);
            return v9;
          }
        }
        else
        {
LABEL_32:
          *a5 = 1;
        }
        v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[10] + 96))(a1[116], a1[117]);
        if ((v10 & 0x80000000) != 0)
          return v10;
        v22 = v217[0];
      }
      if (v22)
      {
        *a5 = 1;
        v207 = 1;
      }
    }
    else
    {
      *(_QWORD *)__s2 = 0;
      if ((paramc_ParamGetStr(*(_QWORD *)(*a1 + 40), (uint64_t)"clcpppipelinemode", __s2) & 0x80000000) != 0
        || !*(_QWORD *)__s2
        || !**(_BYTE **)__s2)
      {
        *a5 = 0;
      }
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 3, 1, &v207, &v210);
  }
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 3, 1, &v207, &v210);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, char **, unsigned int *))(a1[10] + 88))(a1[114], a1[115], &v215, &v214);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v11 = hlp_CopyString(*a1, (uint64_t *)&v216, v215, 0);
  if ((v11 & 0x80000000) != 0)
    goto LABEL_79;
  v12 = a1[10];
  if (v214 != 1)
  {
    v11 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int **, unsigned int *))(v12 + 88))(a1[116], a1[117], &v213, &v211);
    if ((v11 & 0x80000000) == 0)
    {
      v31 = v211;
      v32 = v211 >> 5;
      v209 = v211 >> 5;
      v33 = (_DWORD *)heap_Alloc(*(_QWORD *)(*a1 + 8), v211);
      v212 = v33;
      if (!v33)
      {
LABEL_82:
        v51 = *(_QWORD *)(*a1 + 32);
        v52 = 30000;
LABEL_100:
        log_OutPublic(v51, (uint64_t)"FE_INITLINGDB", v52, 0, v15, v16, v17, v18, v183);
        goto LABEL_101;
      }
      memcpy(v33, v213, v211);
      if ((unsigned __int16)(v31 >> 5))
      {
        v34 = 0;
        v35 = 0;
        v36 = -1;
        v37 = "normal";
        while (1)
        {
          v38 = v35;
          v39 = v212[8 * v35];
          if (v39 == 34)
            v36 = v35;
          if (v39 == 100)
          {
            if (*(_QWORD *)&v212[8 * v35 + 6])
            {
              if (v36 == 0xFFFF)
              {
                if ((unsigned __int16)v32 <= (unsigned __int16)(v35 + 1))
                  v40 = v35 + 1;
                else
                  v40 = v32;
                v36 = v35;
                while (++v36 < (unsigned __int16)v32)
                {
                  if (v212[8 * v36] == 34)
                    goto LABEL_63;
                }
                v36 = v40;
              }
LABEL_63:
              v41 = (char **)&v212[8 * v36];
              if (*((_DWORD *)v41 + 3) == v212[8 * v35 + 3])
              {
                if ((hlp_ValidatePhoneticTranscription((uint64_t)a1, v37, v41[3]) & 0x80000000) != 0)
                {
                  __s1 = v37;
                  v42 = strlen(v216);
                  v43 = (uint64_t)v212;
                  v44 = (const void **)&v212[8 * v38];
                  v45 = *((unsigned int *)v44 + 2);
                  if (v42 >= v45)
                  {
                    if (v34 >= v36)
                      v48 = v36;
                    else
                      v48 = v34;
                    if (v34 <= v36)
                      v49 = v36;
                    else
                      v49 = v34;
                    memcpy(&v216[*((unsigned int *)v44 + 3) - v212[3]], v44[3], v45);
                    v50 = v209;
                    memmove((void *)(v43 + 32 * v49), (const void *)(v43 + 32 * (v49 + 1)), 32 * (v209 + ~(_DWORD)v49));
                    memmove((void *)(v43 + 32 * v48), (const void *)(v43 + 32 * (v48 + 1)), 32 * (~(_DWORD)v48 + (unsigned __int16)(v50 - 1)));
                    v32 = v50 - 2;
                    v209 = v50 - 2;
                    v47 = heap_Realloc(*(uint64_t **)(*a1 + 8), v43, 32 * (unsigned __int16)(v50 - 2));
                    if (!v47)
                      goto LABEL_82;
                  }
                  else
                  {
                    v46 = v209;
                    memmove(v44, &v212[8 * v34 + 8], 32 * (int)(v209 + ~v34));
                    v32 = v46 - 1;
                    v209 = v46 - 1;
                    v47 = heap_Realloc(*(uint64_t **)(*a1 + 8), v43, 32 * (unsigned __int16)(v46 - 1));
                    if (!v47)
                      goto LABEL_82;
                  }
                  v37 = __s1;
                  v35 = 0;
                  v212 = (_DWORD *)v47;
                  v36 = -1;
                }
                else
                {
                  v36 = -1;
                  v32 = v209;
                }
              }
            }
          }
          else if (v39 == 36)
          {
            v37 = *(char **)&v212[8 * v35 + 6];
          }
          v34 = ++v35;
          if (v35 == (unsigned __int16)v32)
            goto LABEL_86;
        }
      }
      v32 = 0;
      v37 = "normal";
LABEL_86:
      __s1a = v37;
      v58 = v216;
      v59 = strlen(v216);
      v64 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, char *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 0, (unsigned __int16)(v59 + 1), v216, &v210);
      v65 = *(_QWORD *)(*a1 + 32);
      if ((v64 & 0x80000000) != 0)
      {
        log_OutPublic(v65, (uint64_t)"FE_INITLINGDB", 30002, 0, v60, v61, v62, v63, v183);
        v20 = 0;
        v21 = 0;
        v9 = v64;
        goto LABEL_103;
      }
      log_OutText(v65, (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Initializing LINGDB with %s", v61, v62, v63, (uint64_t)v58);
      v20 = heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * (unsigned __int16)v32);
      if (!v20)
      {
        log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v66, v67, v68, v69, v184);
        goto LABEL_102;
      }
      v70 = (uint64_t)v212;
      if ((_WORD)v32)
      {
        v71 = v212 + 4;
        v72 = (unsigned __int16)v32;
        do
        {
          if (*(v71 - 4) == 1)
            *v71 = 0;
          v71 += 8;
          --v72;
        }
        while (v72);
        v73 = (unsigned int *)(v70 + 12);
        if ((_WORD)v32)
        {
          v74 = 0;
          v75 = (int *)(v70 + 12);
          while (1)
          {
            v76 = *v75;
            v75 += 8;
            if (v76 != *(_DWORD *)(v70 + 12))
              break;
            if ((unsigned __int16)v32 == ++v74)
            {
              v77 = v32;
              v74 = (unsigned __int16)v32;
              goto LABEL_118;
            }
          }
          v77 = v74;
        }
        else
        {
          v77 = 0;
          v74 = 0;
        }
      }
      else
      {
        v77 = 0;
        v74 = 0;
        v73 = v212 + 3;
      }
LABEL_118:
      v78 = v70 + 32 * v74;
      v197 = v70;
      if ((unsigned __int16)v32 == v77)
      {
        marker_sort(v78, (unsigned __int16)v32 - v74);
        v79 = v197;
      }
      else
      {
        v80 = 0;
        v81 = (unsigned __int16)(v32 - v77);
        v82 = (_DWORD *)(v78 + 4);
        do
        {
          *(_DWORD *)(v20 + 4 * v80) = *v82;
          *v82 = v80;
          v82 += 8;
          ++v80;
        }
        while (v81 != v80);
        marker_sort(v78, (unsigned __int16)v32 - v74);
        v79 = v197;
        v83 = (_DWORD *)(v197 + 32 * v74 + 4);
        do
        {
          *v83 = *(_DWORD *)(v20 + 4 * *v83);
          v83 += 8;
          --v81;
        }
        while (v81);
      }
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a1[8] + 56))(a1[6], a1[7], a3, a4, v79, (unsigned __int16)v32);
      if ((v11 & 0x80000000) == 0)
      {
        v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a1[9] + 104))(a3, a4, 3, HIWORD(v210), &v208);
        if ((v11 & 0x80000000) == 0)
        {
          v196 = *v73;
          v11 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(a1[8] + 96))(a1[6], a1[7], "fecfg", "normal", &__c[3], &__c[1], __c);
          if ((v11 & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
            {
              v84 = strchr(**(char ***)&__c[3], __c[0]);
              if (v84)
                *v84 = 0;
              hlp_CreatePauseDurParam(*a1, "normal");
              v85 = **(const char ***)&__c[3];
            }
            else
            {
              v85 = "normal";
            }
            v86 = v197;
            v87 = __s1a;
            if (!(_WORD)v32)
            {
              v194 = 0;
              v89 = 0;
              v195 = 0;
              v92 = v196;
              goto LABEL_275;
            }
            v88 = 0;
            v195 = 0;
            v89 = 0;
            v194 = 0;
            v90 = 0;
            v91 = 0;
            v92 = v196;
            __s = "normal";
            v188 = v20;
            while (2)
            {
              v93 = (int *)(v86 + 32 * (unsigned __int16)(v91 + 1));
              while (1)
              {
                v94 = (unsigned __int16)v91;
                v95 = 32 * (unsigned __int16)v91;
                v96 = *(_DWORD *)(v86 + v95);
                if (v96 > 0x24 || ((1 << v96) & 0x1400200000) == 0)
                  goto LABEL_272;
                v98 = v91 + 1;
                if ((unsigned __int16)(v91 + 1) < (unsigned __int16)v32
                  && (v99 = *(_DWORD *)(v86 + 32 * (unsigned __int16)v91 + 12),
                      *(_DWORD *)(v86 + 32 * (unsigned __int16)(v91 + 1) + 12) == v99))
                {
                  v100 = 0;
                  v101 = 0;
                  v102 = v93;
                  v103 = v91;
                  v104 = v91 + 1;
                  while (1)
                  {
                    v91 = v104;
                    v106 = *v102;
                    v102 += 8;
                    v105 = v106;
                    if (v106 == 36)
                    {
                      v100 = v91;
                    }
                    else if (v105 == 34)
                    {
                      v91 = v103;
                      goto LABEL_152;
                    }
                    if (v105 == 21)
                      v101 = v91;
                    v104 = v91 + 1;
                    if ((unsigned __int16)(v91 + 1) >= (unsigned __int16)v32)
                      break;
                    v103 = v91;
                    if (*(_DWORD *)(v86 + 32 * (unsigned __int16)(v91 + 1) + 12) != v99)
                      goto LABEL_152;
                  }
                  v91 = v32 - 1;
                }
                else
                {
                  v100 = 0;
                  v101 = 0;
                }
LABEL_152:
                if (!v88 || v96 != 36 || v101)
                  break;
                v90 = *(const char **)(v86 + 32 * v94 + 24);
                v93 += 8;
                v88 = 1;
                v91 = v98;
                if ((unsigned __int16)v98 >= (unsigned __int16)v32)
                  goto LABEL_275;
              }
              v107 = v86 + 32 * v94;
              v109 = *(_DWORD *)(v107 + 12);
              v108 = (_DWORD *)(v107 + 12);
              v110 = v109 - v196;
              v189 = v91;
              v191 = v94;
              if (v109 != v196)
              {
                v187 = v90;
                v186 = v92;
                v192 = v85;
                v185 = (char *)v89;
                v198 = v86;
                __s1b = v87;
                v111 = v216;
                v112 = strlen(v216);
                while (v111[v110] == 95 || utf8_BelongsToSet(0, v111, v110, v112))
                {
                  NextUtf8Offset = utf8_GetNextUtf8Offset(v111, v110);
                  *v108 += NextUtf8Offset - v110;
                  v110 = NextUtf8Offset;
                }
                v90 = v187;
                v20 = v188;
                v86 = v198;
                v87 = __s1b;
                v94 = v191;
                if (v186 != *v108)
                {
                  log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating USER TN %s token at pos  %u,%u in lingdb", v113, v114, v115, (uint64_t)v192);
                  inserted = hlp_InsertUserTNToken((char *)a1, a3, a4, HIWORD(v210), &v208, (unsigned __int16)(v186 - v196), LOWORD(v212[8 * v191 + 3]) - (unsigned __int16)v196, v192, v185, __s1b, v216, v195, (uint64_t)v212, v209);
                  if ((inserted & 0x80000000) != 0)
                    goto LABEL_286;
                  v86 = (uint64_t)v212;
                  v87 = __s1b;
                  v94 = v191;
                  v90 = v187;
                }
              }
              v118 = *(_DWORD *)(v86 + v95);
              if (v118 == 36)
              {
                v87 = *(char **)(v86 + 32 * v94 + 24);
              }
              else if (v118 == 21)
              {
                __s = *(char **)(v86 + 32 * v94 + 24);
              }
              if (v100)
                v87 = *(char **)(v86 + 32 * v100 + 24);
              if (v101)
                __s = *(char **)(v86 + 32 * v101 + 24);
              if (v118 == 34)
              {
                v119 = v90;
                v120 = v94;
                v121 = strlen(*(const char **)(v86 + 32 * v94 + 24)) + 1;
                v122 = heap_Realloc(*(uint64_t **)(*a1 + 8), v194, v121);
                if (v122)
                {
                  v89 = v122;
                  v127 = 0;
                  v128 = 0;
                  v86 = (uint64_t)v212;
                  v91 = v189;
                  v129 = v120;
                  v90 = v119;
                  while (1)
                  {
                    v130 = *(unsigned __int8 *)(*(_QWORD *)(v86 + 32 * v120 + 24) + v128);
                    if (v130 != 32)
                    {
                      if (!*(_BYTE *)(*(_QWORD *)(v86 + 32 * v120 + 24) + v128))
                      {
                        v195 = 0;
                        *(_BYTE *)(v122 + v127) = 0;
                        v88 = 1;
                        v85 = "phon";
                        v194 = v122;
                        goto LABEL_271;
                      }
                      v131 = v127++;
                      *(_BYTE *)(v122 + v131) = v130;
                    }
                    ++v128;
                  }
                }
                log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v123, v124, v125, v126, v184);
                v21 = v194;
                goto LABEL_103;
              }
              if (v118 == 36 || v90 == 0)
                v133 = v87;
              else
                v133 = v90;
              v134 = strlen(__s);
              __s1c = (char *)v133;
              v135 = strlen(v133);
              if (v135 >= 6)
                v136 = v135;
              else
                v136 = 6;
              v137 = (char *)heap_Realloc(*(uint64_t **)(*a1 + 8), (uint64_t)v206, (v134 + v136 + 2));
              if (!v137)
              {
                log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v138, v139, v140, v141, v184);
                goto LABEL_287;
              }
              v142 = v137;
              v206 = v137;
              if (!strcmp(__s, "normal") && !strcmp(v133, "normal"))
              {
                v195 = 0;
                strcpy(v142, "normal");
                goto LABEL_264;
              }
              *v142 = 0;
              if (!strcmp(__s, "normal"))
              {
                v146 = 0;
                goto LABEL_236;
              }
              LOBYTE(v143) = *__s;
              if (*__s)
              {
                v144 = 0;
                do
                {
                  v142[(unsigned __int16)v144] = ssft_tolower(v143);
                  v145 = v144 + 1;
                  v143 = __s[(unsigned __int16)++v144];
                }
                while (v143);
              }
              else
              {
                v145 = 0;
              }
              v142[v145] = 0;
              if (*((_DWORD *)a1 + 236) == 1 && strcmp(v142, "normal") && *v142)
              {
                *(_WORD *)&__c[1] = -1;
                BestTNType = (*(uint64_t (**)(uint64_t, uint64_t, const char *, char *, _BYTE *, _BYTE *, _BYTE *))(a1[8] + 96))(a1[6], a1[7], "fecfg", v142, &__c[3], &__c[1], __c);
                if ((BestTNType & 0x80000000) != 0)
                  goto LABEL_294;
                if (*(_WORD *)&__c[1])
                {
                  v148 = **(char ***)&__c[3];
                  v149 = strchr(**(char ***)&__c[3], __c[0]);
                  if (v149)
                  {
                    *v149 = 0;
                    v148 = **(char ***)&__c[3];
                  }
                  v150 = strlen(__s1c);
                  BestTNType = hlp_CopyString(*a1, (uint64_t *)&v206, v148, v150 + 1);
                  if ((BestTNType & 0x80000000) != 0)
                    goto LABEL_294;
                }
              }
              *(_WORD *)&__c[1] = -1;
              BestTNType = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(a1[8] + 96))(a1[6], a1[7], "fecfg", "esctn", &__c[3], &__c[1], __c);
              if ((BestTNType & 0x80000000) != 0)
                goto LABEL_294;
              if (*(_WORD *)&__c[1])
              {
                v151 = v206;
                v152 = strlen(__s1c);
                BestTNType = hlp_FindBestTNType(*a1, **(char ***)&__c[3], __c[0], v206, (const char **)&v205, v152 + 1);
                if ((BestTNType & 0x80000000) == 0)
                {
                  v153 = v205;
                  if (v205 != v151)
                  {
                    if (hlp_LogUnsupportedTNType(*a1, v151))
                      log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30005, "%s%s%s%s", v154, v155, v156, v157, "OriginalTNType");
                    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v151);
                    v206 = v153;
                  }
                  goto LABEL_231;
                }
                if ((BestTNType & 0x1FFF) != 0)
                  goto LABEL_294;
              }
              else
              {
                v151 = v206;
                if (!strcmp(v206, "normal")
                  || !strcmp(v151, "sms")
                  || !strcmp(v151, "address")
                  || !strcmp(v151, "spell")
                  || !strcmp(v151, "NOR")
                  || !strcmp(v151, "SMS")
                  || !strcmp(v151, "ADR"))
                {
LABEL_231:
                  v142 = v206;
                  v163 = strlen(v206);
                  if (!strcmp(__s1c, "normal") || !strcmp(v142, "normal") || !*v142)
                  {
                    v146 = v163;
                  }
                  else
                  {
                    v146 = v163 + 1;
                    v142[v163] = 95;
                  }
LABEL_236:
                  if (!strcmp(__s1c, "normal") || !strcmp(v142, "normal"))
                  {
                    v195 = 0;
                    goto LABEL_261;
                  }
                  if (strlen(__s1c) == 7 && strstr(__s1c, "_lid"))
                  {
                    __s1c[3] = 0;
                    v195 = 1;
                  }
                  else
                  {
                    v195 = 0;
                  }
                  if (strlen(__s1c) == 3)
                  {
                    for (i = 0; i != 3; ++i)
                      __s2[i] = ssft_tolower(__s1c[i]);
                    __s2[3] = 0;
                    *(_WORD *)&__c[1] = -1;
                    BestTNType = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, _BYTE *, _BYTE *, _BYTE *))(a1[8] + 96))(a1[6], a1[7], "fecfg", "esclang", &__c[3], &__c[1], __c);
                    if ((BestTNType & 0x80000000) != 0)
                      goto LABEL_294;
                    if (*(_WORD *)&__c[1])
                    {
                      v165 = strstr(**(char ***)&__c[3], __s2);
                      v142 = v206;
                      if (v165)
                      {
                        v166 = *__s1c;
                        if (*__s1c)
                        {
                          v167 = 0;
                          do
                          {
                            v142[v146++] = ssft_tolower(v166);
                            v166 = __s1c[(unsigned __int16)++v167];
                          }
                          while (v166);
                        }
                        goto LABEL_261;
                      }
                      goto LABEL_255;
                    }
                  }
                  else if (!strcmp(__s1c, "latin"))
                  {
                    v168 = *__s1c;
                    v142 = v206;
                    if (*__s1c)
                    {
                      v169 = 0;
                      do
                      {
                        v142[v146++] = ssft_tolower(v168);
                        v168 = __s1c[(unsigned __int16)++v169];
                      }
                      while (v168);
                    }
                    goto LABEL_261;
                  }
                  v142 = v206;
LABEL_255:
                  if (*v142)
                    v142[v146 - 1] = 0;
                  else
                    strcpy(v142, "normal");
LABEL_261:
                  if (strncmp(v142, "normal", 6uLL) && *v142)
                  {
                    v142[v146] = 0;
                    v142 = v206;
                  }
LABEL_264:
                  *(_WORD *)&__c[1] = -1;
                  BestTNType = (*(uint64_t (**)(uint64_t, uint64_t, const char *, char *, _BYTE *, _BYTE *, _BYTE *))(a1[8] + 96))(a1[6], a1[7], "fecfg", v142, &__c[3], &__c[1], __c);
                  if ((BestTNType & 0x80000000) == 0)
                  {
                    if (*(_WORD *)&__c[1])
                    {
                      v170 = strchr(**(char ***)&__c[3], __c[0]);
                      if (v170)
                        *v170 = 0;
                      hlp_CreatePauseDurParam(*a1, v142);
                      v171 = *(const char ***)&__c[3];
                    }
                    else
                    {
                      v171 = (const char **)&v206;
                    }
                    v20 = v188;
                    v91 = v189;
                    v90 = 0;
                    v89 = 0;
                    v88 = 0;
                    v85 = *v171;
                    v86 = (uint64_t)v212;
                    v87 = __s1c;
                    v129 = v191;
LABEL_271:
                    v92 = *(unsigned int *)(v86 + 32 * v129 + 12);
                    v32 = v209;
LABEL_272:
                    if ((unsigned __int16)++v91 < (unsigned __int16)v32)
                      continue;
LABEL_275:
                    v193 = v85;
                    v172 = (char *)v89;
                    v173 = v92;
                    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating USER TN %s token in lingdb", v89, (uint64_t)v85, v92, (uint64_t)v85);
                    v174 = strlen(v216);
                    inserted = hlp_InsertUserTNToken((char *)a1, a3, a4, HIWORD(v210), &v208, (unsigned __int16)(v173 - v196), v174, v193, v172, v87, v216, v195, (uint64_t)v212, v209);
                    if ((inserted & 0x80000000) != 0)
                    {
LABEL_286:
                      v9 = inserted;
LABEL_287:
                      v21 = v194;
                      goto LABEL_103;
                    }
                    v175 = v209;
                    v176 = 0;
                    if (v209)
                    {
                      v177 = (uint64_t)v212;
                      v178 = v209;
                      while (*(_DWORD *)(v177 + 12) == v196)
                      {
                        ++v176;
                        --v178;
                        v177 += 32;
                        if (v209 == v176)
                        {
                          v176 = v209;
                          goto LABEL_281;
                        }
                      }
                      if (v209 != (unsigned __int16)v176)
                      {
                        v179 = 0;
                        v180 = 0;
                        v181 = (_DWORD *)(v177 + 4);
                        do
                        {
                          *(_DWORD *)(v20 + 4 * v180) = *(_DWORD *)(v177 + v179 + 4);
                          *(_DWORD *)(v177 + v179 + 4) = v180++;
                          v179 += 32;
                        }
                        while (v178 != v180);
                        marker_sort(v177, v175 - v176);
                        v182 = v178;
                        do
                        {
                          *v181 = *(_DWORD *)(v20 + 4 * *v181);
                          v181 += 8;
                          --v182;
                        }
                        while (v182);
LABEL_283:
                        inserted = hlp_ReplacePauseZeroWithNluBndNo_And_WriteMarkersToLingDB(*a1, a1[9], a3, a4, HIWORD(v210), (uint64_t *)&v212, &v209);
                        if ((inserted & 0x80000000) == 0)
                        {
                          inserted = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1[10] + 96))(a1[114], a1[115], v214);
                          if ((inserted & 0x80000000) == 0)
                            inserted = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1[10] + 96))(a1[116], a1[117], v211);
                        }
                        goto LABEL_286;
                      }
                    }
                    else
                    {
LABEL_281:
                      v177 = (uint64_t)&v212[8 * v176];
                    }
                    marker_sort(v177, v209 - v176);
                    goto LABEL_283;
                  }
LABEL_294:
                  v9 = BestTNType;
                  v20 = v188;
                  goto LABEL_287;
                }
              }
              break;
            }
            if (hlp_LogUnsupportedTNType(*a1, v151))
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30004, "%s%s", v158, v159, v160, v161, "TNType");
            if (!strcmp(__s1c, "normal"))
            {
              v162 = strlen(__s1c);
              BestTNType = hlp_CopyString(*a1, (uint64_t *)&v206, "normal", v162 + 1);
              if ((BestTNType & 0x80000000) != 0)
                goto LABEL_294;
            }
            else
            {
              *v151 = 0;
            }
            goto LABEL_231;
          }
        }
      }
LABEL_80:
      v21 = 0;
      v9 = v11;
      goto LABEL_103;
    }
LABEL_79:
    v20 = 0;
    goto LABEL_80;
  }
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 96))(a1[114], a1[115], 1);
  if ((v13 & 0x80000000) != 0
    || (v13 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int **, unsigned int *))(a1[10] + 88))(a1[116], a1[117], &v213, &v211), (v13 & 0x80000000) != 0))
  {
    v9 = v13;
LABEL_101:
    v20 = 0;
LABEL_102:
    v21 = 0;
    goto LABEL_103;
  }
  if (HIDWORD(v217[0]))
  {
    v209 = v211 >> 5;
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, unsigned int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 1, v209, v213, &v210);
    if ((v14 & 0x80000000) != 0)
    {
      v9 = v14;
      v51 = *(_QWORD *)(*a1 + 32);
      v52 = 30002;
      goto LABEL_100;
    }
  }
  v19 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1[10] + 96))(a1[116], a1[117], v211);
  v20 = 0;
  v21 = 0;
  v9 = v19 & (v19 >> 31);
LABEL_103:
  if (v206)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v206);
    v206 = 0;
  }
  if (v21)
    heap_Free(*(_QWORD **)(*a1 + 8), v21);
  if (v212)
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v212);
  if (v216)
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v216);
  if (v20)
    heap_Free(*(_QWORD **)(*a1 + 8), v20);
  return v9;
}

uint64_t hlp_CopyString(uint64_t a1, uint64_t *a2, char *__s, int a4)
{
  int v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v16;

  if (__s)
    v8 = strlen(__s) + 1;
  else
    v8 = 1;
  v9 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *a2, (v8 + a4));
  if (v9)
  {
    if (__s)
      v9 = strcpy(v9, __s);
    else
      *v9 = 0;
    v14 = 0;
    *a2 = (uint64_t)v9;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v10, v11, v12, v13, v16);
    return 2307923978;
  }
  return v14;
}

uint64_t hlp_ValidatePhoneticTranscription(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3;
  uint64_t v6;
  char *v7;
  char *v8;
  unsigned __int16 v9;
  int v10;
  char *v11;
  char *v12;
  int v13;
  uint64_t v14;
  int v15;
  _BYTE v17[4];
  char __s[4];
  char v19[10];
  uint64_t v20;

  v3 = (uint64_t)a3;
  v20 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return v3;
  hlp_GetPhonSrcAndLanguageOfOriginFromPhonWithMetaData(a3, v19, v17);
  hlp_GetLowerCasedLng3FromLangTag(a1, a2, __s);
  if (strlen(__s) != 3)
    return 0;
  v6 = *(_QWORD *)(a1 + 968);
  if (!v6 || !(*(unsigned int (**)(_QWORD, _QWORD))(v6 + 56))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960)))
  {
    if (!strcmp(__s, (const char *)(a1 + 948)))
      return 0;
    else
      return 2307923968;
  }
  v7 = strstr((char *)v3, "_#_");
  if (v7)
  {
    v8 = v7;
    do
    {
      *v8 = 35;
      v9 = strlen((const char *)v3);
      memmove(v8 + 1, v8 + 3, v9 - (unint64_t)(unsigned __int16)((_WORD)v8 - v3) - 2);
      v8 = strstr((char *)v3, "_#_");
    }
    while (v8);
  }
  if (hlp_checkDoClmInCurrentComponent((_QWORD *)a1))
    v10 = hlp_checkDoClmForLng3((const char *)a1, __s);
  else
    v10 = 0;
  v11 = strchr((char *)v3, 20);
  v12 = v11;
  if (v11)
    *v11 = 0;
  if (!v10)
  {
    v14 = 0;
    v3 = 0;
    if (!v11)
      goto LABEL_23;
    goto LABEL_22;
  }
  v13 = strlen((const char *)v3);
  v14 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), (4 * v13 + 4));
  if (v14)
  {
    v15 = strlen((const char *)v3);
    v3 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 968) + 64))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), __s, v3, v14, 0, 0, (4 * v15 + 4));
    if (!v12)
      goto LABEL_23;
LABEL_22:
    *v12 = 20;
    goto LABEL_23;
  }
  v3 = 2307923978;
  if (v12)
    goto LABEL_22;
LABEL_23:
  if (v14)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v14);
  return v3;
}

uint64_t hlp_CreatePauseDurParam(uint64_t a1, char *__s)
{
  size_t v3;
  uint64_t result;
  unsigned int v5;
  char __sa[256];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  strcpy(__sa, "tnpausedur");
  v3 = strlen(__s);
  result = strlen(__sa);
  if (v3 < 255 - result)
  {
    __strcat_chk();
    result = paramc_ParamGetUInt(*(_QWORD *)(a1 + 40), (uint64_t)__sa, &v5);
    if ((result & 0x80000000) == 0)
    {
      strcpy(__sa, "tnpausedur");
      __strcat_chk();
      return paramc_ParamSetUInt(*(_QWORD *)(a1 + 40), (uint64_t)__sa, v5);
    }
  }
  return result;
}

uint64_t hlp_InsertUserTNToken(char *a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6, unsigned __int16 a7, const char *a8, char *a9, char *a10, const char *a11, int a12, uint64_t a13, unsigned __int16 a14)
{
  uint64_t v21;
  _BOOL4 v22;
  unsigned __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;
  char *v35;
  char *v36;
  unsigned __int16 v37;
  char *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  int v48;
  int v49;
  char *v50;
  __int16 v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  unsigned int v57;
  unsigned __int16 v59;
  unsigned __int16 v60;
  char *v61;
  int v62;
  size_t v63;
  __int16 v64;
  unsigned __int16 v65;
  unsigned int v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  unsigned __int16 v71;
  uint64_t i;
  int *v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  int v78;
  int v79;
  unsigned __int16 v80;
  unsigned int v81;
  __int16 v82;
  __int16 v83;
  uint64_t v84;
  unsigned int v86;
  unsigned __int16 v87;
  unsigned __int16 v88;
  int v89;
  const char *v90;
  unsigned int v91;
  unsigned int v92;
  char *__s2;
  int v94;
  unsigned __int16 v95;
  unsigned __int16 v96;
  _BYTE v97[4];
  char __s[4];
  int v99;
  int v100;
  __int16 v101;
  unsigned __int16 v102;
  char v103[10];
  char __src[50];
  uint64_t v105;

  v105 = *MEMORY[0x1E0C80C00];
  v102 = a7;
  v101 = 0;
  v99 = 0;
  v100 = 0;
  v21 = *a5;
  v22 = hlp_checkDoClmInCurrentComponent(a1);
  hlp_GetLowerCasedLng3FromLangTag((uint64_t)a1, a10, __s);
  if (!*a5)
    return 0;
  v23 = *a5;
  v92 = a4;
  __s2 = a1 + 948;
  do
  {
    v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(*((_QWORD *)a1 + 9) + 168))(a2, a3, v23, 1, 1, (char *)&v100 + 2, &v101);
    if ((v28 & 0x80000000) != 0)
    {
LABEL_122:
      v32 = *(_QWORD *)(*(_QWORD *)a1 + 32);
      v84 = 30003;
      goto LABEL_127;
    }
    if (HIWORD(v100) < a6)
      goto LABEL_8;
    v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, __int16 *))(*((_QWORD *)a1 + 9)
                                                                                                 + 168))(a2, a3, *a5, 0, 1, &v99, &v101);
    if ((v28 & 0x80000000) != 0)
      goto LABEL_122;
    if (v99 == 3 || HIWORD(v100) == v102)
    {
LABEL_8:
      v29 = 1;
      goto LABEL_9;
    }
    v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned __int16 *))(*((_QWORD *)a1 + 9) + 80))(a2, a3, *a5, a5);
    if ((v31 & 0x80000000) != 0)
      return v31;
    v99 = 5;
    v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, int *))(*((_QWORD *)a1 + 9)
                                                                                             + 160))(a2, a3, *a5, 0, 1, &v99, &v100);
    v32 = *(_QWORD *)(*(_QWORD *)a1 + 32);
    if ((v28 & 0x80000000) != 0)
      goto LABEL_126;
    log_OutText(v32, (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating token %u %u in lingdb", v25, v26, v27, HIWORD(v100));
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*((_QWORD *)a1 + 9)
                                                                                               + 160))(a2, a3, *a5, 1, 1, (char *)&v100 + 2, &v100);
    if ((v33 & 0x80000000) != 0)
      goto LABEL_124;
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 2, 1, &v102, &v100);
    if ((v33 & 0x80000000) != 0)
      goto LABEL_124;
    v34 = strlen(a8);
    v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 4, (unsigned __int16)(v34 + 1), a8, &v100);
    if ((v28 & 0x80000000) != 0)
      goto LABEL_125;
    if (a12)
    {
      v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, const char *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 6, 4, "lid", &v100);
      if ((v28 & 0x80000000) != 0)
        return v28;
    }
    if (!a9)
    {
      v29 = 0;
      goto LABEL_9;
    }
    v91 = v21;
    v90 = a8;
    v35 = strstr(a9, "_#_");
    if (v35)
    {
      v36 = v35;
      do
      {
        *v36 = 35;
        v37 = strlen(a9);
        memmove(v36 + 1, v36 + 3, v37 - (unint64_t)(unsigned __int16)((_WORD)v36 - (_WORD)a9) - 2);
        v36 = strstr(a9, "_#_");
      }
      while (v36);
    }
    if (strlen(__s) != 3)
    {
      v38 = a9;
      v21 = v21;
      goto LABEL_110;
    }
    if (v22)
      v89 = hlp_checkDoClmForLng3(a1, __s);
    else
      v89 = 0;
    v39 = strlen(a9);
    v40 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * v39 + 200);
    v21 = v21;
    if (!v40)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_INITLINGDB", 34000, 0, v41, v42, v43, v44, v86);
      return 2307923978;
    }
    v38 = (char *)v40;
    hlp_GetPhonSrcAndLanguageOfOriginFromPhonWithMetaData(a9, v103, v97);
    __src[0] = 0;
    v45 = strchr(a9, 20);
    if (v45)
    {
      v46 = v45;
      __strcat_chk();
      *v46 = 0;
    }
    v47 = *((_QWORD *)a1 + 121);
    if (!v47
      || !(*(unsigned int (**)(_QWORD, _QWORD))(v47 + 56))(*((_QWORD *)a1 + 119), *((_QWORD *)a1 + 120)))
    {
      v49 = strcmp(__s, __s2);
      if ((v28 & 0x80000000) != 0 || v49)
        goto LABEL_49;
      if (v89)
      {
LABEL_44:
        strcat(v38, __src);
      }
      else
      {
LABEL_46:
        v50 = strcpy(v38, a9);
        strcat(v50, __src);
        if (strcmp(__s, __s2))
        {
          v51 = strlen(__s);
          v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 6, (unsigned __int16)(v51 + 1), __s, &v100);
          if ((v31 & 0x80000000) != 0)
            return v31;
        }
      }
LABEL_110:
      v82 = strlen(v38);
      v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, char *, int *))(*((_QWORD *)a1 + 9)
                                                                                                + 160))(a2, a3, *a5, 3, (unsigned __int16)(v82 + 1), v38, &v100);
      if (v38 != a9)
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v38);
      goto LABEL_112;
    }
    if (v89)
    {
      v48 = strlen(a9);
      if (((*(uint64_t (**)(_QWORD, _QWORD, char *, char *, char *, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1 + 121) + 64))(*((_QWORD *)a1 + 119), *((_QWORD *)a1 + 120), __s, a9, v38, 0, 0, (4 * v48 + 4)) & 0x80000000) == 0)goto LABEL_44;
    }
    else if ((v28 & 0x80000000) == 0)
    {
      goto LABEL_46;
    }
LABEL_49:
    v96 = v102;
    v52 = HIWORD(v100);
    v53 = (char *)&a11[HIWORD(v100)];
    v54 = strstr(v53, "§");
    if (v54 == v53)
    {
      strcpy(v38, __src);
      v28 = 0;
    }
    else
    {
      v55 = v54;
      if (v54)
      {
        v56 = (char *)a11;
        do
        {
          v57 = v96;
          if (v55 - v56 >= v96 || v55 == &v56[v52])
            goto LABEL_88;
          if (v55 <= v56)
          {
            v87 = (_WORD)v55 - (_WORD)v56;
            v60 = 2;
          }
          else
          {
            v59 = (_WORD)v55 - (_WORD)v56 + 2;
            v60 = 2;
            v61 = v55;
            while (1)
            {
              v62 = *--v61;
              if (v62 != 32)
                break;
              ++v60;
              v55 = v61;
              if (v61 <= v56)
              {
                v60 = v59;
                v55 = v56;
                break;
              }
            }
            v87 = (_WORD)v55 - (_WORD)v56;
          }
          v96 -= v60;
          v63 = strlen(&v55[v60]);
          memmove(v55, &v55[v60], v63 + 1);
          v64 = strlen(a11);
          v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, const char *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, v92, 0, (unsigned __int16)(v64 + 1), a11, &v100);
          if ((v31 & 0x80000000) != 0)
            return v31;
          v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 2, 1, &v96, &v100);
          if ((v31 & 0x80000000) != 0)
            return v31;
          v94 = 0;
          v95 = *a5;
          v31 = (*(uint64_t (**)(uint64_t, uint64_t))(*((_QWORD *)a1 + 9) + 120))(a2, a3);
          if ((v31 & 0x80000000) != 0)
            return v31;
          v65 = v95;
          if (v95)
          {
            v88 = v60;
            v66 = v60 + v87;
            do
            {
              v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, __int16 *))(*((_QWORD *)a1 + 9) + 168))(a2, a3, v65, 1, 1, (char *)&v94 + 2, &v101);
              if ((v31 & 0x80000000) != 0)
                return v31;
              v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, __int16 *))(*((_QWORD *)a1 + 9) + 168))(a2, a3, v95, 2, 1, &v94, &v101);
              if ((v31 & 0x80000000) != 0)
                return v31;
              v67 = v87 <= HIWORD(v94) && v66 >= HIWORD(v94);
              if (v67 && v87 <= (unsigned __int16)v94 && v66 >= (unsigned __int16)v94)
              {
                v68 = v95;
                v69 = v95;
              }
              else
              {
                v68 = v95;
                if (v66 <= HIWORD(v94))
                {
                  HIWORD(v94) -= v88;
                  LOWORD(v94) = v94 - v88;
                  v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, v95, 1, 1, (char *)&v94 + 2, &v100);
                  if ((v31 & 0x80000000) != 0)
                    return v31;
                  v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, v95, 2, 1, &v94, &v100);
                  if ((v31 & 0x80000000) != 0)
                    return v31;
                  v69 = 0;
                  v68 = v95;
                }
                else
                {
                  v69 = 0;
                }
              }
              v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*((_QWORD *)a1 + 9)
                                                                                             + 120))(a2, a3, v68, &v95);
              if ((v31 & 0x80000000) != 0)
                return v31;
              if ((_DWORD)v69)
              {
                v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((_QWORD *)a1 + 9) + 192))(a2, a3, v69);
                if ((v31 & 0x80000000) != 0)
                  return v31;
              }
              v65 = v95;
            }
            while (v95);
          }
          v52 = HIWORD(v100);
          v56 = (char *)a11;
          v55 = strstr((char *)&a11[HIWORD(v100)], "§");
        }
        while (v55);
        v57 = v96;
LABEL_88:
        v70 = v102;
        v71 = v102 - v57;
        if (v102 > v57)
        {
          if (a14)
          {
            v73 = (int *)(a13 + 16);
            for (i = a14; i; --i)
            {
              v74 = *(v73 - 1);
              if (v74 <= v57)
              {
                v79 = *v73;
                if (!*v73)
                  goto LABEL_105;
                v80 = v79 + v74;
                if (v57 >= v80)
                  goto LABEL_105;
                v81 = (unsigned __int16)(v80 - v57);
                if (v81 >= v71)
                  v81 = v71;
                v78 = v79 - v81;
              }
              else
              {
                v75 = (unsigned __int16)(v74 - v57);
                v76 = *v73;
                v77 = v70 - (unsigned __int16)v74;
                if (v70 < (unsigned __int16)v74)
                  v77 = 0;
                if (!v76)
                  v77 = 0;
                if (v75 >= v71)
                  v75 = v71;
                *(v73 - 1) = v74 - v75;
                v78 = v76 - v77;
              }
              *v73 = v78;
LABEL_105:
              v73 += 8;
            }
          }
        }
      }
      v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, const char *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 4, 7, "normal", &v100);
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v38);
      if ((v28 & 0x80000000) != 0)
        goto LABEL_125;
      v38 = 0;
    }
    v21 = v91;
    if (v38)
      goto LABEL_110;
LABEL_112:
    if ((v28 & 0x80000000) != 0)
      goto LABEL_125;
    v29 = 0;
    a8 = v90;
LABEL_9:
    if (HIWORD(v100) == v102)
      return v28;
    v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned __int16 *))(*((_QWORD *)a1 + 9) + 120))(a2, a3, *a5, a5);
    v30 = (int)v28 >= 0 ? v29 : 0;
    if ((v30 & 1) == 0)
      return v28;
    v23 = *a5;
  }
  while (*a5);
  if (HIWORD(v100) != a6)
    return v28;
  v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*((_QWORD *)a1 + 9) + 80))(a2, a3, v21, a5);
  if ((v31 & 0x80000000) != 0)
    return v31;
  v99 = 5;
  v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 0, 1, &v99, &v100);
  v32 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  if ((v28 & 0x80000000) != 0)
    goto LABEL_126;
  log_OutText(v32, (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating token %u %u in lingdb", v25, v26, v27, HIWORD(v100));
  v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, char *, int *))(*((_QWORD *)a1 + 9)
                                                                                             + 160))(a2, a3, *a5, 1, 1, (char *)&v100 + 2, &v100);
  if ((v33 & 0x80000000) != 0
    || (v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(*((_QWORD *)a1 + 9) + 160))(a2, a3, *a5, 2, 1, &v102, &v100), (v33 & 0x80000000) != 0))
  {
LABEL_124:
    v28 = v33;
    goto LABEL_125;
  }
  v83 = strlen(a8);
  v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, int *))(*((_QWORD *)a1 + 9)
                                                                                                  + 160))(a2, a3, *a5, 4, (unsigned __int16)(v83 + 1), a8, &v100);
  if ((v28 & 0x80000000) != 0)
  {
LABEL_125:
    v32 = *(_QWORD *)(*(_QWORD *)a1 + 32);
LABEL_126:
    v84 = 30002;
LABEL_127:
    log_OutPublic(v32, (uint64_t)"FE_INITLINGDB", v84, 0, v24, v25, v26, v27, v86);
  }
  return v28;
}

uint64_t hlp_LogUnsupportedTNType(uint64_t a1, char *__s)
{
  int v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t result;
  int v9;
  char *__s1;

  __s1 = 0;
  v4 = strlen(__s);
  if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"domainmngrtntypes", &__s1) & 0x80000000) != 0
    || (v5 = __s1) == 0
    || !*__s1
    || (v6 = strstr(__s1, __s)) == 0
    || (v7 = v6, v6 != v5) && *(v6 - 1) != 124
    || (result = 0, (v9 = v7[v4]) != 0) && v9 != 124)
  {
    if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"extraesctn", &__s1) & 0x80000000) != 0)
      return 1;
    if (!__s1)
      return 1;
    result = strcmp(__s1, __s);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

uint64_t hlp_FindBestTNType(uint64_t a1, char *a2, int a3, char *__s1, const char **a5, int a6)
{
  uint64_t result;
  char *v13;
  char *v14;
  unsigned __int8 v15;
  char *v16;

  *a5 = __s1;
  result = strcmp(__s1, "internal-nuance-system-norm");
  if ((_DWORD)result)
  {
    while (1)
    {
      v13 = (char *)*a5;
      v14 = strstr(a2, *a5);
      if (v14)
      {
        v15 = v14[strlen(v13)];
        if (a3 == v15)
          return 0;
        result = 0;
        if (!v15 || v15 == 124)
          return result;
      }
      v16 = strrchr(v13, 58);
      if (!v16)
        break;
      if (v13 == __s1)
      {
        *a5 = 0;
        result = hlp_CopyString(a1, (uint64_t *)a5, __s1, a6);
        if ((result & 0x80000000) != 0)
          return result;
        v16 = strrchr((char *)*a5, 58);
        if (!v16)
          continue;
      }
      *v16 = 0;
    }
    if (v13 != __s1)
      heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v13);
    *a5 = 0;
    return 2307923968;
  }
  return result;
}

uint64_t hlp_ReplacePauseZeroWithNluBndNo_And_WriteMarkersToLingDB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, unsigned __int16 *a7)
{
  unsigned __int16 *v7;
  unsigned __int16 v14;
  unsigned __int16 v15;
  _DWORD *v16;
  uint64_t v17;
  _DWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  int *v33;
  unsigned int v34;
  BOOL v35;
  int v36;
  int v37;
  BOOL v38;
  int v39;
  unsigned __int16 *v40;
  unsigned __int16 v41;
  _DWORD *v42;
  uint64_t v43;
  unsigned __int16 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  unsigned __int16 *v59;
  unsigned __int16 v60;
  __int16 v61;

  v7 = a7;
  v61 = 0;
  v14 = *a7;
  if (!*a7)
    goto LABEL_36;
  v15 = 0;
  v16 = (_DWORD *)*a6;
  v17 = *a7;
  v18 = (_DWORD *)*a6;
  do
  {
    v19 = *v18;
    v18 += 8;
    if (v19 == 8 && v16[6] == 1)
      ++v15;
    v16 = v18;
    --v17;
  }
  while (v17);
  if (v15)
  {
    v20 = 2307923978;
    v21 = heap_Calloc(*(_QWORD **)(a1 + 8), 8, v15);
    if (!v21)
      goto LABEL_46;
    v22 = v21;
    v14 = *v7;
    if (*v7)
    {
      v53 = a2;
      v54 = a3;
      v55 = a4;
      v56 = a5;
      v23 = 0;
      v59 = v7;
      v60 = 0;
      v24 = 0;
      v25 = -1;
      v57 = v21;
      while (1)
      {
        v26 = *a6;
        v27 = (_DWORD *)(*a6 + 32 * v23);
        if (*v27 == 1)
        {
          v25 = v23;
        }
        else if ((v25 & 0x80000000) == 0 && *v27 == 8 && *(_DWORD *)(v26 + 32 * v23 + 24) == 1)
        {
          v28 = v25;
          v29 = v26 + 32 * v25;
          v30 = *(_DWORD *)(v29 + 12);
          v31 = v25;
          if (v14)
          {
            v32 = 0;
            v33 = (int *)*a6;
            v31 = v25;
            do
            {
              v34 = v33[3];
              v35 = v34 == v30;
              if (v34 > v30)
                break;
              v37 = *v33;
              v33 += 8;
              v36 = v37;
              v38 = v35 && v36 == 51;
              ++v32;
              if (v38)
                v31 = v32;
            }
            while (v14 != v32);
            v28 = v31;
          }
          v39 = *(_DWORD *)(v29 + 4);
          if (v23 == v28)
          {
            v7 = v59;
          }
          else
          {
            v58 = v39;
            if (v23 + 1 == v14)
            {
              v40 = v59;
            }
            else
            {
              memmove(v27, (const void *)(v26 + 32 * (v23 + 1)), 32 * (v14 + ~v24));
              v40 = v59;
              v14 = *v59;
              v26 = *a6;
            }
            v41 = v14 - 1;
            *v40 = v41;
            memmove((void *)(v26 + 32 * (int)(v31 + 1)), (const void *)(v26 + 32 * v28), 32 * (v41 - v31));
            ++*v40;
            v26 = *a6;
            v7 = v40;
            v22 = v57;
            v39 = v58;
          }
          v42 = (_DWORD *)(v26 + 32 * v28);
          *v42 = 51;
          v42[1] = v39;
          v42[2] = 0;
          v42[3] = v30;
          v42[4] = 0;
          *(_QWORD *)(*a6 + 32 * v28 + 24) = heap_Alloc(*(_QWORD *)(a1 + 8), 6);
          v43 = *(_QWORD *)(*a6 + 32 * v28 + 24);
          if (!v43)
          {
            v20 = 2307923978;
            v44 = v60;
            goto LABEL_40;
          }
          *(_QWORD *)(v22 + 8 * v60) = v43;
          strcpy(*(char **)(*a6 + 32 * v28 + 24), "BND:N");
          v14 = *v7;
          ++v60;
        }
        ++v23;
        ++v24;
        if (v23 >= v14)
        {
          a5 = v56;
          a3 = v54;
          a4 = v55;
          a2 = v53;
          v44 = v60;
          goto LABEL_37;
        }
      }
    }
    v44 = 0;
  }
  else
  {
LABEL_36:
    v44 = 0;
    v22 = 0;
  }
LABEL_37:
  v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, __int16 *))(a2 + 160))(a3, a4, a5, 1, v14, *a6, &v61);
  if ((v20 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"FE_INITLINGDB", 30002, 0, v45, v46, v47, v48, v52);
  if (v22)
  {
LABEL_40:
    if (v44)
    {
      v49 = v44;
      v50 = (uint64_t *)v22;
      do
      {
        if (*v50)
          heap_Free(*(_QWORD **)(a1 + 8), *v50);
        ++v50;
        --v49;
      }
      while (v49);
    }
    heap_Free(*(_QWORD **)(a1 + 8), v22);
  }
LABEL_46:
  heap_Free(*(_QWORD **)(a1 + 8), *a6);
  *a6 = 0;
  *v7 = 0;
  return v20;
}

uint64_t fe_initlingdb_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 62336, 976) & 0x80000000) != 0)
    return 2307923976;
  else
    return synstrmaux_CloseStreams((_WORD *)(a1 + 88), *(_QWORD *)(a1 + 80));
}

uint64_t fe_initlingdb_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2307923969;
  result = 0;
  *a2 = &IFeInitlingdb;
  return result;
}

size_t hlp_GetPhonSrcAndLanguageOfOriginFromPhonWithMetaData(char *a1, char *a2, _BYTE *a3)
{
  size_t result;
  const char *v6;
  size_t v7;
  size_t v8;
  size_t v9;
  uint64_t i;

  *(_QWORD *)a2 = 0x504B524D545845;
  *a3 = 0;
  result = (size_t)strchr(a1, 20);
  if (result)
  {
    v6 = (const char *)(result + 1);
    result = (size_t)strchr((char *)(result + 1), 20);
    v7 = result;
    if (result)
    {
      v8 = result - (_QWORD)v6;
    }
    else
    {
      result = strlen(v6);
      v8 = result;
    }
    if (v8 <= 9)
    {
      result = (size_t)strncpy(a2, v6, v8);
      a2[v8] = 0;
    }
    if (v7)
    {
      v9 = v7 + 1;
      result = strlen((const char *)(v7 + 1));
      if (result == 3 || result >= 4 && (result = strcmp((const char *)(v7 + 4), "\x14"), !(_DWORD)result))
      {
        for (i = 0; i != 3; ++i)
        {
          result = ssft_tolower(*(unsigned __int8 *)(v9 + i));
          a3[i] = result;
        }
        a3[3] = 0;
      }
    }
  }
  return result;
}

char *hlp_GetLowerCasedLng3FromLangTag(uint64_t a1, char *a2, char *__dst)
{
  char *result;
  uint64_t v7;
  int v8;

  if (!*a2 || !LH_stricmp(a2, "normal"))
    return strcpy(__dst, (const char *)(a1 + 948));
  result = (char *)strlen(a2);
  if (result == (char *)3)
  {
    result = strcpy(__dst, a2);
    if (*__dst)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        __dst[v7] = ssft_tolower(__dst[v7]);
        v7 = ++v8;
        result = (char *)strlen(__dst);
      }
      while ((unint64_t)result > v8);
    }
  }
  else
  {
    *__dst = 0;
  }
  return result;
}

BOOL hlp_checkDoClmInCurrentComponent(_QWORD *a1)
{
  _BOOL8 result;
  int v3;
  char *__s1;

  __s1 = 0;
  v3 = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, int *))(a1[121] + 96))(a1[119], a1[120], &v3) & 0x80000000) != 0)
    return (paramc_ParamGetStr(*(_QWORD *)(*a1 + 40), (uint64_t)"clm", &__s1) & 0x80000000) != 0
        || !__s1
        || !strcmp(__s1, "yes");
  result = 0;
  if (!v3)
    return (paramc_ParamGetStr(*(_QWORD *)(*a1 + 40), (uint64_t)"clm", &__s1) & 0x80000000) != 0
        || !__s1
        || !strcmp(__s1, "yes");
  return result;
}

uint64_t hlp_checkDoClmForLng3(const char *a1, char *__s1)
{
  uint64_t result;
  char *v5;
  int Str;
  char *__s1a;
  int v8[3];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  __s1a = 0;
  result = strcmp(__s1, a1 + 948);
  if ((_DWORD)result)
  {
    v8[0] = 7171171;
    __strcat_chk();
    if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)v8, &__s1a) & 0x80000000) != 0
      || (v5 = __s1a) == 0)
    {
      __s1a = 0;
      Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"noclmset", &__s1a);
      v5 = __s1a;
      if (Str < 0 || !__s1a)
      {
        if (!__s1a)
          return 1;
      }
      else
      {
        if (strstr(__s1a, __s1))
          v5 = "no";
        else
          v5 = "yes";
        __s1a = v5;
      }
    }
    return strcmp(v5, "yes") == 0;
  }
  return result;
}

uint64_t fe_initlingdb_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2307923975;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = a1;
    *(_QWORD *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_initlingdb_ClassClose()
{
  return 0;
}

uint64_t CLM_InitFromCLMv2Lua(uint64_t a1, const char *a2)
{
  int Allocator;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int16 v25;
  uint64_t v26;
  const char *v27;
  uint64_t i;
  char *v29;
  char *v30;
  char *v31;
  unsigned __int16 j;
  char *v33;
  int v34;
  uint64_t v35;
  char *v36;
  char *v37;
  unsigned __int16 v38;
  unsigned int v39;
  uint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  int v47;
  uint64_t v48;
  uint64_t v49;
  _OWORD v50[2];
  uint64_t v51;
  char __s1[8];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  v49 = 0;
  Allocator = ooc_utils_createAllocator((uint64_t)v50, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
  v5 = LH_ERROR_to_VERROR(Allocator);
  if ((v5 & 0x80000000) != 0)
    goto LABEL_35;
  v6 = luavmldoutil_initialize_lua_vm(*(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)v50, (uint64_t)"getForeignLangSupportForCLMv2", (uint64_t)hlp_lua_log_callback_2, &v49, "clm");
  v7 = 0;
  v8 = v49;
  if ((v6 & 0x80000000) == 0 && v49)
  {
    *(_DWORD *)(a1 + 200) = 0;
    v9 = LuaVMLDO_RunFunctionReturningString(v8, (uint64_t)"getForeignLangSupportForCLMv2", (uint64_t)a2, 0x400u, __s1);
    v5 = LH_ERROR_to_VERROR(v9);
    if ((v5 & 0x80000000) == 0)
    {
      if (__s1[0]
        || (v47 = LuaVMLDO_RunFunctionReturningString(v8, (uint64_t)"getFeClmSupportedLanguages", (uint64_t)"all", 0x400u, __s1), (LH_ERROR_to_VERROR(v47) & 0x80000000) == 0)&& strstr(__s1, a2))
      {
        *(_DWORD *)(a1 + 200) = 1;
      }
      v10 = v49;
      *(_QWORD *)__s1 = 0;
      v11 = PNEW_LDOObject_Con((uint64_t)v50, (uint64_t)v50, (uint64_t *)__s1);
      v12 = LH_ERROR_to_VERROR(v11);
      if ((v12 & 0x80000000) != 0)
      {
        v7 = v12;
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Error creating LDOObject", v13, v14, v15, v48);
      }
      else
      {
        v16 = LuaVMLDO_RunFunctionWithStringArgumentReturningTableWithStrings(v10, (uint64_t)"getLoanPhonemeSupport", (uint64_t)a2, *(uint64_t *)__s1);
        v17 = LH_ERROR_to_VERROR(v16);
        if ((v17 & 0x80000000) != 0)
        {
          v7 = 0;
        }
        else
        {
          v7 = v17;
          v18 = *(uint64_t **)(*(_QWORD *)__s1 + 32);
          v19 = *(_QWORD *)(*(_QWORD *)__s1 + 40);
          *(_WORD *)(a1 + 204) = (v19 - (unint64_t)v18) >> 5;
          if (((v19 - (_QWORD)v18) & 0x1FFFE0) != 0)
          {
            v20 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (unsigned __int16)((v19 - (unint64_t)v18) >> 5), 16);
            *(_QWORD *)(a1 + 208) = v20;
            if (v20)
            {
              if ((unint64_t)v18 < v19)
              {
                v25 = 0;
                LODWORD(v48) = v19;
                while (1)
                {
                  v26 = v18[3];
                  v27 = (const char *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(*v18);
                  if (strlen(v27) != 3)
                    goto LABEL_49;
                  for (i = 0; i != 3; ++i)
                    *(_BYTE *)(*(_QWORD *)(a1 + 208) + 16 * v25 + i) = __tolower(v27[i]);
                  v29 = (char *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v26);
                  if (!v29 || (v30 = v29, !*v29))
                  {
LABEL_49:
                    v7 = 2347769856;
                    goto LABEL_51;
                  }
                  v31 = strstr(v29, "||");
                  for (j = 1; v31; ++j)
                  {
                    v34 = v31[2];
                    v33 = v31 + 2;
                    if (!v34)
                      break;
                    v31 = strstr(v33, "||");
                  }
                  *(_WORD *)(*(_QWORD *)(a1 + 208) + 16 * v25 + 4) = j;
                  v35 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), j, 24);
                  *(_QWORD *)(*(_QWORD *)(a1 + 208) + 16 * v25 + 8) = v35;
                  if (!v35)
                    goto LABEL_50;
                  v36 = strchr(v30, 124);
                  if (v36)
                    break;
LABEL_33:
                  ++v25;
                  v18 += 4;
                  if ((unint64_t)v18 >= v19)
                    goto LABEL_51;
                }
                v37 = v36;
                v38 = 0;
                while (1)
                {
                  v39 = v38;
                  v40 = hlp_AllocAndCopy(*(_QWORD *)(a1 + 24), (char **)(*(_QWORD *)(*(_QWORD *)(a1 + 208) + 16 * v25 + 8) + 24 * v38), v30, (uint64_t)v37);
                  if ((v40 & 0x80000000) != 0)
                    break;
                  v41 = strchr(v37 + 1, 124);
                  if (!v41)
                    goto LABEL_32;
                  v42 = v41;
                  v40 = hlp_AllocAndCopy(*(_QWORD *)(a1 + 24), (char **)(*(_QWORD *)(*(_QWORD *)(a1 + 208) + 16 * v25 + 8) + 24 * v39 + 8), v37 + 1, (uint64_t)v41);
                  if ((v40 & 0x80000000) != 0)
                    break;
                  v43 = v42 + 1;
                  v44 = strchr(v43, 124);
                  if (!v44)
                    v44 = &v43[strlen(v43)];
                  v40 = hlp_AllocAndCopy(*(_QWORD *)(a1 + 24), (char **)(*(_QWORD *)(*(_QWORD *)(a1 + 208) + 16 * v25 + 8) + 24 * v39 + 16), v43, (uint64_t)v44);
                  if ((v40 & 0x80000000) != 0)
                    break;
                  v45 = strstr(v43, "||");
                  if (v45)
                  {
                    v30 = v45 + 2;
                    v37 = strchr(v45 + 2, 124);
                    v38 = v39 + 1;
                    if (v37)
                      continue;
                  }
LABEL_32:
                  v7 = 0;
                  goto LABEL_33;
                }
                v7 = v40;
              }
            }
            else
            {
LABEL_50:
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v21, v22, v23, v24, v48);
              v7 = 2347769866;
            }
          }
        }
      }
LABEL_51:
      if (*(_QWORD *)__s1)
        OOC_PlacementDeleteObject((uint64_t)v50, *(uint64_t *)__s1);
      goto LABEL_36;
    }
LABEL_35:
    v7 = v5;
LABEL_36:
    v8 = v49;
  }
  if (v8)
    luavmldoutil_destroy_lua_vm((uint64_t)v50, &v49);
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v50);
  if ((v7 & 0x80000000) != 0)
    CLM_DeInitFromCLMv2Lua((_QWORD *)a1);
  return v7;
}

uint64_t hlp_lua_log_callback_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"CLM", 4, 0, a2, a6, a7, a8, 0);
}

_QWORD *CLM_DeInitFromCLMv2Lua(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v1 = result;
  *((_DWORD *)result + 50) = 0;
  v2 = result[26];
  if (v2)
  {
    v3 = *((unsigned __int16 *)result + 102);
    if (*((_WORD *)result + 102))
    {
      v4 = 0;
      do
      {
        v5 = v2 + 16 * v4;
        v6 = *(_QWORD *)(v5 + 8);
        if (v6)
        {
          if (*(_WORD *)(v5 + 4))
          {
            v7 = 0;
            v8 = 0;
            do
            {
              v9 = *(_QWORD *)(v2 + 16 * v4 + 8);
              v10 = *(_QWORD *)(v9 + v7);
              if (v10)
              {
                heap_Free(*(_QWORD **)(v1[3] + 8), v10);
                v2 = v1[26];
                v9 = *(_QWORD *)(v2 + 16 * v4 + 8);
                *(_QWORD *)(v9 + v7) = 0;
              }
              v11 = *(_QWORD *)(v9 + v7 + 8);
              if (v11)
              {
                heap_Free(*(_QWORD **)(v1[3] + 8), v11);
                v2 = v1[26];
                v9 = *(_QWORD *)(v2 + 16 * v4 + 8);
                *(_QWORD *)(v9 + v7 + 8) = 0;
              }
              v12 = *(_QWORD *)(v9 + v7 + 16);
              if (v12)
              {
                heap_Free(*(_QWORD **)(v1[3] + 8), v12);
                v2 = v1[26];
                *(_QWORD *)(*(_QWORD *)(v2 + 16 * v4 + 8) + v7 + 16) = 0;
              }
              ++v8;
              v13 = v2 + 16 * v4;
              v7 += 24;
            }
            while (v8 < *(unsigned __int16 *)(v13 + 4));
            v6 = *(_QWORD *)(v13 + 8);
          }
          heap_Free(*(_QWORD **)(v1[3] + 8), v6);
          v2 = v1[26];
          *(_QWORD *)(v2 + 16 * v4 + 8) = 0;
          v3 = *((unsigned __int16 *)v1 + 102);
        }
        ++v4;
      }
      while (v4 < v3);
    }
    result = heap_Free(*(_QWORD **)(v1[3] + 8), v2);
    v1[26] = 0;
  }
  *((_WORD *)v1 + 102) = 0;
  return result;
}

uint64_t hlp_AllocAndCopy(uint64_t a1, char **a2, char *__s, uint64_t a4)
{
  size_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v14;

  if (a4)
    v7 = a4 - (_QWORD)__s;
  else
    v7 = strlen(__s);
  v8 = (char *)heap_Calloc(*(_QWORD **)(a1 + 8), v7 + 1, 1);
  *a2 = v8;
  if (v8)
  {
    strncpy(v8, __s, v7);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v9, v10, v11, v12, v14);
    return 2347769866;
  }
}

uint64_t CLM_AlignPhonlists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int CountStrings;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned __int16 v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  const char *v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  __int16 v25;
  __int16 v26;
  const char *v27;
  const char *v28;
  const char *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int16 v50;

  v48 = 0;
  v49 = 0;
  if (!a3 || !a4)
    return 2347769856;
  CountStrings = StringList_GetCountStrings(a3);
  v9 = StringList_GetCountStrings(a4);
  v46 = a1;
  if (a2 && StringList_GetCountStrings(a2) != CountStrings)
  {
    v14 = 2347769856;
    goto LABEL_79;
  }
  v10 = StringList_GetCountStrings(a3);
  v11 = StringList_GetCountStrings(a4);
  v12 = v11;
  if (CountStrings && v9)
  {
    v13 = 0;
    if (v10)
    {
      v14 = 0;
      v47 = a2;
      while (v13 < (unsigned __int16)v12)
      {
        v15 = (const char *)StringList_GetAt(a3, v13);
        if (!strcmp(v15, "*"))
        {
          v18 = StringList_InsertAt(a4, v13, "*");
          if (v18)
          {
            v14 = LH_ERROR_to_VERROR(v18);
            if ((v14 & 0x80000000) != 0)
              goto LABEL_79;
          }
          else
          {
            v14 = 0;
          }
          LOWORD(v12) = v12 + 1;
        }
        else
        {
          v16 = (const char *)StringList_GetAt(a3, v13);
          a2 = v47;
          v17 = (const char *)StringList_GetAt(a4, v13);
          if (strcmp(v16, v17))
            break;
        }
        if (v10 <= ++v13)
        {
          v13 = v10;
          goto LABEL_58;
        }
      }
      if (v10 > v13)
      {
        while (1)
        {
          v25 = v12;
          v26 = v10;
          if ((unsigned __int16)v12 <= v13)
            break;
          LOWORD(v10) = v10 - 1;
          v27 = (const char *)StringList_GetAt(a3, (unsigned __int16)(v26 - 1));
          if (!strcmp(v27, "*"))
          {
            v31 = StringList_InsertAt(a4, (unsigned __int16)v12, "*");
            if (v31)
            {
              v14 = LH_ERROR_to_VERROR(v31);
              a2 = v47;
              if ((v14 & 0x80000000) != 0)
                goto LABEL_79;
            }
            else
            {
              v14 = 0;
              a2 = v47;
            }
          }
          else
          {
            v28 = (const char *)StringList_GetAt(a3, (unsigned __int16)(v26 - 1));
            LOWORD(v12) = v12 - 1;
            v29 = (const char *)StringList_GetAt(a4, (unsigned __int16)(v25 - 1));
            v30 = strcmp(v28, v29);
            a2 = v47;
            if (v30)
              break;
          }
          if ((unsigned __int16)v10 <= v13)
            goto LABEL_58;
        }
        LOWORD(v10) = v26;
        LOWORD(v12) = v25;
      }
LABEL_58:
      v21 = v14;
    }
    else
    {
      v21 = 0;
    }
    v32 = StringList_GetCountStrings(a3) - (unsigned __int16)v10;
    v14 = 2347769856;
    if (v32 == StringList_GetCountStrings(a4) - (unsigned __int16)v12)
    {
      if ((v21 & 0x80000000) != 0)
      {
        v14 = v21;
      }
      else if (v13 != (unsigned __int16)v10 || (v14 = v21, v13 != (unsigned __int16)v12))
      {
        v50 = 0;
        v33 = hlp_RecursiveAddBestAnchorsForSublist(v46, a3, v13, (unsigned __int16)v10, a4, v13, (unsigned __int16)v12, (unsigned __int16 *)&v48, &v50);
        if ((v33 & 0x80000000) != 0)
        {
          v14 = v33;
        }
        else
        {
          if (v50 == 0xFFFF)
            v34 = 0;
          else
            v34 = v48 + 16 * v50;
          v35 = hlp_Align(a2, a3, a4, (unsigned __int16)v10, (unsigned __int16)v12, v34);
          v36 = v35;
          if ((v35 & 0x80000000) != 0)
          {
            v14 = v35;
          }
          else
          {
            v37 = StringList_GetCountStrings(a3);
            v38 = StringList_GetCountStrings(a4);
            if (v37 == v38)
              v14 = v36;
            else
              v14 = 2347769856;
            if (a2 && v37 == v38)
            {
              if (StringList_GetCountStrings(a2) == v37)
                v14 = v36;
              else
                v14 = 2347769856;
            }
          }
        }
      }
    }
    goto LABEL_79;
  }
  if (v10)
  {
    if (!v11)
    {
      v19 = 0;
      do
      {
        v20 = StringList_Append(a4, "*");
        if (v20)
        {
          v14 = LH_ERROR_to_VERROR(v20);
          if ((v14 & 0x80000000) != 0)
            goto LABEL_79;
        }
        else
        {
          v14 = 0;
        }
        ++v19;
      }
      while (v10 > (unsigned __int16)v19);
      goto LABEL_79;
    }
    goto LABEL_45;
  }
  if (v11)
  {
    v22 = 0;
    while (1)
    {
      v23 = StringList_Append(a3, "*");
      if (v23)
      {
        v14 = LH_ERROR_to_VERROR(v23);
        if ((v14 & 0x80000000) != 0)
          goto LABEL_79;
        if (a2)
        {
LABEL_39:
          v24 = StringList_Append(a2, "*");
          if (v24)
          {
            v14 = LH_ERROR_to_VERROR(v24);
            if ((v14 & 0x80000000) != 0)
              goto LABEL_79;
          }
          else
          {
            v14 = 0;
          }
        }
      }
      else
      {
        v14 = 0;
        if (a2)
          goto LABEL_39;
      }
      if (v12 <= (unsigned __int16)++v22)
        goto LABEL_79;
    }
  }
LABEL_45:
  v14 = 0;
LABEL_79:
  v39 = v48;
  if (v48)
  {
    v40 = (unsigned __int16)v49;
    if ((_WORD)v49)
    {
      v41 = 0;
      v42 = 8;
      v43 = v46;
      do
      {
        v44 = *(_QWORD *)(v48 + v42);
        if (v44)
        {
          heap_Free(*(_QWORD **)(v46 + 8), v44);
          v40 = (unsigned __int16)v49;
        }
        ++v41;
        v42 += 16;
      }
      while (v41 < v40);
      v39 = v48;
    }
    else
    {
      v43 = v46;
    }
    heap_Free(*(_QWORD **)(v43 + 8), v39);
  }
  return v14;
}

uint64_t hlp_RecursiveAddBestAnchorsForSublist(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, unsigned int a6, uint64_t a7, unsigned __int16 *a8, _WORD *a9)
{
  uint64_t v10;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned __int16 v18;
  unsigned __int16 v19;
  const char *v20;
  const char *v21;
  unsigned __int16 v22;
  uint64_t appended;
  uint64_t v24;
  unsigned __int16 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned __int16 *v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  int v34;
  unsigned __int16 v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;
  int v43;
  unsigned __int16 v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _WORD *v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  int v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  unsigned int v64;
  int v67;
  uint64_t *v68;

  v10 = 0;
  v68 = 0;
  *a9 = -1;
  if (a3 < a4 && a6 < a7)
  {
    if (!a8 || (v15 = a8[4]) == 0)
    {
LABEL_9:
      v67 = 0;
      v68 = 0;
      v18 = a3 + 1;
      v19 = a6;
      do
      {
        v20 = (const char *)StringList_GetAt(a2, a3);
        v21 = (const char *)StringList_GetAt(a5, v19);
        v22 = v19 + 1;
        if (!strcmp(v20, v21))
        {
          appended = hlp_RecursiveAddBestAnchorsForSublist(a1, a2, v18, a4, a5, (unsigned __int16)(v19 + 1), a7, a8, &v67);
          if ((appended & 0x80000000) != 0)
            goto LABEL_20;
          v24 = (unsigned __int16)v67 == 0xFFFFLL ? 0 : *(_QWORD *)a8 + 16 * (unsigned __int16)v67;
          appended = hlp_AppendCombinedResult(a1, a3, v19, v24, (uint64_t *)&v68, (unsigned __int16 *)&v67 + 1);
          if ((appended & 0x80000000) != 0)
            goto LABEL_20;
        }
        ++v19;
      }
      while (a7 > v22);
      v25 = a8;
      appended = hlp_RecursiveAddBestAnchorsForSublist(a1, a2, v18, a4, a5, a6, a7, a8, &v67);
      if ((appended & 0x80000000) != 0)
      {
LABEL_20:
        v10 = appended;
        goto LABEL_60;
      }
      if ((unsigned __int16)v67 == 0xFFFFLL)
        v26 = 0;
      else
        v26 = *(_QWORD *)a8 + 16 * (unsigned __int16)v67;
      v27 = hlp_AppendCombinedResult(a1, 65534, 65534, v26, (uint64_t *)&v68, (unsigned __int16 *)&v67 + 1);
      if ((v27 & 0x80000000) == 0)
      {
        v28 = v68;
        if (v68 && (v29 = (unsigned __int16 *)*v68) != 0)
        {
          v30 = 0;
          v31 = 0;
          v32 = -1;
          v33 = -1;
          do
          {
            v34 = 0;
            do
            {
              v35 = v34;
              v36 = (__int16)v29[2 * (unsigned __int16)v34++];
            }
            while (v36 != -1);
            if (v35 <= v31)
            {
              if (v35 && v35 == v31)
              {
                v41 = *v29;
                if (v41 == 0xFFFF)
                {
                  v44 = 0;
                }
                else
                {
                  v42 = 0;
                  v43 = 0;
                  v44 = 0;
                  do
                  {
                    v45 = v41 - v29[2 * v42 + 1];
                    v44 += v45 * v45;
                    v42 = (unsigned __int16)++v43;
                    v41 = v29[2 * (unsigned __int16)v43];
                  }
                  while (v41 != 0xFFFF);
                }
                if (v44 < v33)
                {
                  v32 = v30;
                  v33 = v44;
                }
              }
            }
            else
            {
              v37 = *v29;
              if (v37 == 0xFFFF)
              {
                v33 = 0;
              }
              else
              {
                v38 = 0;
                v39 = 0;
                v33 = 0;
                do
                {
                  v40 = v37 - v29[2 * v38 + 1];
                  v33 += v40 * v40;
                  v38 = (unsigned __int16)++v39;
                  v37 = v29[2 * (unsigned __int16)v39];
                }
                while (v37 != 0xFFFF);
              }
              v32 = v30;
              v31 = v35;
            }
            v29 = (unsigned __int16 *)v68[++v30];
          }
          while (v29);
        }
        else
        {
          v32 = -1;
        }
        v46 = v25[4];
        if ((_DWORD)v46 == v25[5])
        {
          v10 = 2347769856;
          if (v46 > 0xFFFC)
            goto LABEL_60;
          v47 = heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)v25, 16 * v46 + 32);
          *(_QWORD *)v25 = v47;
          if (!v47)
          {
            log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v48, v49, v50, v51, v64);
            v10 = 2347769866;
            goto LABEL_60;
          }
          v25[5] += 2;
          LODWORD(v46) = v25[4];
        }
        else
        {
          v47 = *(_QWORD *)v25;
        }
        v52 = (_WORD *)(v47 + 16 * v46);
        *v52 = a3;
        v52[1] = a6;
        if (v32 == 0xFFFF)
        {
          v59 = v47 + 16 * v46;
          *(_WORD *)(v59 + 4) = 0;
          *(_QWORD *)(v59 + 8) = 0;
        }
        else
        {
          v53 = 0;
          do
          {
            v54 = v53;
            v55 = (unsigned __int16)v53;
            v56 = *(__int16 *)(v28[v32] + 4 * (unsigned __int16)v53++);
          }
          while (v56 != -1);
          *(_WORD *)(v47 + 16 * v46 + 4) = v54;
          v57 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), 4, v55);
          v58 = *(_QWORD *)v25 + 16 * v25[4];
          *(_QWORD *)(v58 + 8) = v57;
          memmove(v57, (const void *)v28[v32], 4 * *(unsigned __int16 *)(v58 + 4));
          LOWORD(v46) = v25[4];
        }
        *a9 = v46;
        ++v25[4];
      }
      v10 = v27;
      goto LABEL_60;
    }
    v16 = (unsigned __int16 *)(*(_QWORD *)a8 + 2);
    while (*(v16 - 1) != a3 || *v16 != a6)
    {
      v16 += 8;
      if (!--v15)
        goto LABEL_9;
    }
    v10 = 0;
  }
LABEL_60:
  v60 = (uint64_t)v68;
  if (v68)
  {
    v61 = *v68;
    if (*v68)
    {
      v62 = 0;
      do
      {
        heap_Free(*(_QWORD **)(a1 + 8), v61);
        v61 = *(_QWORD *)(v60 + 8 * (unsigned __int16)++v62);
      }
      while (v61);
    }
    heap_Free(*(_QWORD **)(a1 + 8), v60);
  }
  return v10;
}

uint64_t hlp_Align(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  unsigned int v10;
  uint64_t result;
  unsigned __int16 v12;
  int v13;
  int v14;
  int v15;
  unsigned __int16 *v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t v24;
  unsigned int v25;
  int v26;

  StringList_GetCountStrings(a2);
  StringList_GetCountStrings(a3);
  v24 = a6;
  if (a6)
    v25 = *(unsigned __int16 *)(a6 + 4);
  else
    v25 = 0;
  v10 = 0;
  result = 0;
  v12 = 0;
  v13 = 0;
  v26 = 0;
  v14 = 0;
  v15 = 0;
  while (1)
  {
    if (v24 && v25 > v10)
    {
      v16 = (unsigned __int16 *)(*(_QWORD *)(v24 + 8) + 4 * v12);
      v17 = *v16 + v26;
      v18 = v16[1] + v13;
    }
    else
    {
      v17 = v26 + a4;
      v18 = v13 + a5;
    }
    if ((unsigned __int16)v15 < (unsigned __int16)v17)
    {
      v19 = (unsigned __int16)(v18 + ~(_WORD)v14);
      if (v19 >= (unsigned __int16)(v17 + ~(_WORD)v15))
        v19 = (unsigned __int16)(v17 + ~(_WORD)v15);
      v20 = v14 + v19;
      v21 = v15 + v19;
      if ((unsigned __int16)v14 < (unsigned __int16)v18)
      {
        v15 = v21 + 1;
        v14 = v20 + 1;
      }
    }
    if ((unsigned __int16)v15 < (unsigned __int16)v17)
      break;
LABEL_20:
    if ((unsigned __int16)v14 < (unsigned __int16)v18)
    {
      v26 = v18 + v26 - v14;
      while (1)
      {
        result = StringList_InsertAt(a2, (unsigned __int16)v15, "*");
        if ((_DWORD)result)
        {
          result = LH_ERROR_to_VERROR(result);
          if ((result & 0x80000000) != 0)
            return result;
        }
        if (a1)
        {
          result = StringList_InsertAt(a1, (unsigned __int16)v15, "*");
          if ((_DWORD)result)
          {
            result = LH_ERROR_to_VERROR(result);
            if ((result & 0x80000000) != 0)
              return result;
          }
        }
        ++v15;
        if ((unsigned __int16)++v14 >= (unsigned __int16)v18)
        {
          v14 = v18;
          break;
        }
      }
    }
    ++v15;
    ++v14;
    v10 = ++v12;
    if (v12 > v25)
      return result;
  }
  v13 = v17 + v13 - v15;
  while (1)
  {
    result = StringList_InsertAt(a3, (unsigned __int16)v14, "*");
    if ((_DWORD)result)
    {
      result = LH_ERROR_to_VERROR(result);
      if ((result & 0x80000000) != 0)
        return result;
    }
    ++v14;
    if ((unsigned __int16)++v15 >= (unsigned __int16)v17)
    {
      v15 = v17;
      goto LABEL_20;
    }
  }
}

uint64_t CLM_MergeSubsequentInsertionAndDeletions(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int CountStrings;
  int v6;
  unsigned __int16 v7;
  const char *v8;
  const char *v9;
  int v10;
  unsigned __int16 v11;
  const char *v12;
  const char *v13;
  int v14;

  v4 = 2347769856;
  CountStrings = StringList_GetCountStrings(a1);
  if (CountStrings == StringList_GetCountStrings(a2))
  {
    if (StringList_GetCountStrings(a1))
    {
      v6 = 0;
      v7 = 0;
      do
      {
        v8 = (const char *)StringList_GetAt(a1, v7);
        if (!strcmp(v8, "*"))
        {
          v9 = (const char *)StringList_GetAt(a2, v7);
          v10 = strcmp(v9, "*");
          if (v10 && v7)
          {
            v11 = v7 - 1;
            v12 = (const char *)StringList_GetAt(a2, (unsigned __int16)(v7 - 1));
            if (!strcmp(v12, "*"))
              goto LABEL_15;
          }
          else
          {
            v11 = v7;
            if (!v10)
              goto LABEL_15;
          }
          v11 = v6 + 1;
          if (v6 + 1 < StringList_GetCountStrings(a2))
          {
            v13 = (const char *)StringList_GetAt(a2, (unsigned __int16)(v6 + 1));
            if (!strcmp(v13, "*"))
            {
LABEL_15:
              StringList_RemoveAt(a1, v7);
              StringList_RemoveAt(a2, v11);
              goto LABEL_6;
            }
          }
        }
        ++v7;
LABEL_6:
        v6 = v7;
      }
      while (v7 < StringList_GetCountStrings(a1));
    }
    v14 = StringList_GetCountStrings(a1);
    if (v14 == StringList_GetCountStrings(a2))
      return 0;
    else
      return 2347769856;
  }
  return v4;
}

uint64_t CLM_PhonList_InsertAt(uint64_t a1, unsigned int a2, char *a3)
{
  uint64_t result;

  result = StringList_InsertAt(a1, a2, a3);
  if ((_DWORD)result)
    return LH_ERROR_to_VERROR(result);
  return result;
}

uint64_t CLM_PhonList_Append(uint64_t a1, char *a2)
{
  uint64_t result;

  result = StringList_Append(a1, a2);
  if ((_DWORD)result)
    return LH_ERROR_to_VERROR(result);
  return result;
}

uint64_t hlp_AppendCombinedResult(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t *a5, unsigned __int16 *a6)
{
  uint64_t v12;
  int v13;
  unsigned __int16 v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int16 v21;
  uint64_t v22;
  _BOOL4 v24;
  unsigned __int16 v25;
  _WORD *v26;
  unsigned int v27;
  unint64_t v28;
  __int16 v29;
  uint64_t v30;
  uint64_t result;
  unsigned int v32;

  v12 = *a5;
  if (*a6)
  {
    v13 = 0;
    do
      v14 = v13;
    while (*(_QWORD *)(v12 + 8 * (unsigned __int16)v13++));
    if (*a6 - 1 != v14)
      goto LABEL_11;
  }
  else
  {
    v14 = 0;
  }
  v16 = heap_Realloc(*(uint64_t **)(a1 + 8), v12, 8 * *a6 + 16);
  *a5 = v16;
  if (v16)
  {
    v21 = *a6 + 2;
    *a6 = v21;
    if (v14 < v21)
    {
      v22 = v14;
      do
        *(_QWORD *)(*a5 + 8 * v22++) = 0;
      while (v21 != v22);
    }
LABEL_11:
    v24 = a2 != 65534 && a3 != 65534;
    v25 = v24;
    if (a4)
      v25 = *(_WORD *)(a4 + 4) + v24;
    *(_QWORD *)(*a5 + 8 * v14) = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 4 * v25 + 4);
    if (v24)
    {
      v26 = *(_WORD **)(*a5 + 8 * v14);
      *v26 = a2;
      v26[1] = a3;
      v27 = 1;
      if (!a4)
        goto LABEL_27;
    }
    else
    {
      v27 = 0;
      if (!a4)
      {
LABEL_27:
        result = 0;
        *(_DWORD *)(*(_QWORD *)(*a5 + 8 * v14) + 4 * (unsigned __int16)v27) = -1;
        return result;
      }
    }
    if (*(_WORD *)(a4 + 4))
    {
      v28 = 0;
      v29 = v27;
      v30 = 4 * v27;
      do
      {
        *(_DWORD *)(*(_QWORD *)(*a5 + 8 * v14) + v30 + 4 * v28) = *(_DWORD *)(*(_QWORD *)(a4 + 8) + 4 * v28);
        ++v28;
      }
      while (v28 < *(unsigned __int16 *)(a4 + 4));
      LOWORD(v27) = v29 + v28;
    }
    goto LABEL_27;
  }
  log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v17, v18, v19, v20, v32);
  return 2347769866;
}

uint64_t CLM_EnumerateLanguages(uint64_t a1, uint64_t *a2, unsigned int *a3, unsigned int a4, uint64_t a5, unsigned int a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t i;
  uint64_t v30;
  const char *LangRecord;
  char *v32;
  char *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int Allocator;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  _OWORD v48[2];
  uint64_t v49;
  int v50;
  int v51;
  const char *v52;
  unsigned int v53;
  char v54[200];
  _DWORD v55[100];
  char v56[400];
  uint64_t v57;

  v7 = a7;
  v8 = a6;
  v57 = *MEMORY[0x1E0C80C00];
  v53 = 0;
  v52 = 0;
  v14 = 2347769856;
  v51 = 0;
  *a3 = 0;
  if (!CLM_FindNrOfLanguages(a1, a5, a6, a7, v56, 0x64u, v55, a3))
  {
    v15 = *a3;
    if ((_DWORD)v15)
    {
      v16 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), v15, 24);
      *a2 = v16;
      if (!v16)
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v17, v18, v19, v20, v43);
        return 2347769866;
      }
      if (*a3)
      {
        v44 = a3;
        v21 = 0;
        v46 = 0;
        v47 = v8;
        v45 = v7;
        while (1)
        {
          __strcpy_chk();
          if (a4 <= 1)
          {
            v22 = &v55[v21];
            *(_QWORD *)(*a2 + 24 * v21 + 16) = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), *v22, 24);
            v27 = *a2 + 24 * v21;
            if (!*(_QWORD *)(v27 + 16))
            {
              v40 = 2347769866;
              v39 = 50000;
LABEL_30:
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", v39, 0, v23, v24, v25, v26, v43);
              v41 = v40;
              goto LABEL_31;
            }
            *(_DWORD *)(v27 + 8) = *v22;
          }
          v53 = v7;
          if (v55[v21])
          {
            v28 = 0;
            for (i = 0; i < v55[v21]; ++i)
            {
              v30 = *a2;
              LangRecord = (const char *)CLM_FindLangRecord(a5, v8, &v53, (const char *)(*a2 + 24 * v21));
              if (!LangRecord)
              {
                v39 = 50003;
                v40 = 2347769856;
                goto LABEL_30;
              }
              v32 = (char *)LangRecord;
              if (a4)
              {
                if (a4 == 1)
                {
                  v50 = 0;
                  *(_QWORD *)(*(_QWORD *)(v30 + 24 * v21 + 16) + v28) = LangRecord;
                  *(_QWORD *)(*(_QWORD *)(*a2 + 24 * v21 + 16) + v28 + 8) = &LangRecord[strlen(LangRecord) + 1];
                  v8 = v47;
                  v33 = *(char **)(*(_QWORD *)(*a2 + 24 * v21 + 16) + v28 + 8);
                  if (*v33)
                  {
                    v34 = CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), v33, v54, 0xC8u, 0, &v50);
                    if ((v34 & 0x80000000) != 0 || v50)
                    {
                      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 1, 0, (uint64_t)"WARNING CLM %s to %s : invalid mapping %s %s", v35, v36, v37, *a2 + 24 * v21);
                      v34 = 0;
                      v54[0] = 0;
                    }
                    v46 = v34;
                    v49 = 0;
                    memset(v48, 0, sizeof(v48));
                    Allocator = ooc_utils_createAllocator((uint64_t)v48, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
                    if (Allocator
                      || (Allocator = PNEW_StringList_Con((uint64_t)v48, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)(*(_QWORD *)(*a2 + 24 * v21 + 16) + v28 + 16))) != 0|| (Allocator = StringList_FromSplitString(*(_QWORD *)(*(_QWORD *)(*a2 + 24 * v21 + 16) + v28 + 16), v54, 0x20u)) != 0)
                    {
                      v46 = LH_ERROR_to_VERROR(Allocator);
                      goto LABEL_33;
                    }
                  }
                }
                else
                {
                  *(_QWORD *)(v30 + 24 * v21 + 8) = LangRecord;
                }
              }
              else
              {
                *(_QWORD *)(*(_QWORD *)(v30 + 24 * v21 + 16) + v28) = LangRecord;
                *(_QWORD *)(*(_QWORD *)(*a2 + 24 * v21 + 16) + v28 + 16) = &LangRecord[strlen(LangRecord) + 1];
                v8 = v47;
                *(_QWORD *)(*(_QWORD *)(*a2 + 24 * v21 + 16) + v28 + 8) = nuance_pcre_compile(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176), v32, 0, &v52, &v51, 0);
              }
              ++v53;
              v28 += 24;
            }
          }
          *(_DWORD *)(*a2 + 24 * v21++ + 4) = a4;
          v7 = v45;
          if (v21 >= *v44)
          {
LABEL_33:
            v41 = v46;
            v14 = v46;
            if ((v46 & 0x80000000) == 0)
              return v14;
LABEL_31:
            v14 = v41;
            CLM_EmptyLanguageStruct((_QWORD *)a1, a2, v21);
            return v14;
          }
        }
      }
    }
    return 0;
  }
  return v14;
}

BOOL CLM_FindNrOfLanguages(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, void *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 result;
  unsigned int v21;
  uint64_t v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned int v27;
  char __dst[8];

  *(_QWORD *)__dst = 0;
  *a8 = 0;
  bzero(a5, 4 * a6);
  bzero(a7, 4 * a6);
  if (a4 <= a3)
  {
    do
    {
      if (a4 >= a3)
        break;
      strncpy(&__dst[4], (const char *)(a2 + a4), 3uLL);
      result = CLM_IsSeperationRecord(a2, a4);
      if (!result)
        return result;
      if (CLM_FindLanguageInArray((char *)a5, a6, (uint64_t)a7, &__dst[4], __dst))
      {
        if (*(_DWORD *)__dst >= a6)
          goto LABEL_2;
        strcpy((char *)a5 + 4 * *(unsigned int *)__dst, &__dst[4]);
        ++*a8;
      }
      v21 = 0;
      v22 = a4 <= a3 ? a3 : a4;
      v23 = (unsigned __int8 *)(a2 + a4);
      v24 = ~(unint64_t)a4 + v22;
      do
      {
        if (!*v23++)
          ++v21;
        ++a4;
      }
      while (v21 <= 1 && v24-- != 0);
    }
    while (a3 != a4);
    return 0;
  }
  else
  {
LABEL_2:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v16, v17, v18, v19, v27);
    return 1;
  }
}

uint64_t CLM_FindLangRecord(uint64_t a1, unsigned int a2, _DWORD *a3, const char *a4)
{
  uint64_t v8;
  _BOOL4 v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  char __dst[4];

  *(_DWORD *)__dst = 0;
  v8 = *a3;
  strncpy(__dst, (const char *)(a1 + v8), 3uLL);
  if (strcmp(a4, __dst))
  {
    v9 = 0;
    while (1)
    {
      v10 = v8;
      if (v8 >= a2 || v9)
        break;
      v11 = 0;
      v12 = 0;
      v13 = a1;
      do
      {
        v15 = *(_BYTE *)(v13 + v8) == 0;
        v14 = 1 - a2 + v8 + v11;
        *a3 = v8 + v11 + 1;
        if (v15)
          ++v12;
        ++v13;
        ++v11;
        v15 = v12 > 1 || v14 == 0;
      }
      while (!v15);
      v9 = (_DWORD)v8 - a2 + (_DWORD)v11 == 0;
      LODWORD(v8) = v8 + v11;
      strncpy(__dst, (const char *)(a1 + (v10 + v11)), 3uLL);
      if (!strcmp(a4, __dst))
      {
        LODWORD(v8) = v10 + v11;
        break;
      }
    }
  }
  if (v8 >= a2)
    return 0;
  else
    return a1 + (v8 + 3);
}

_QWORD *CLM_EmptyLanguageStruct(_QWORD *result, uint64_t *a2, unsigned int a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  _OWORD v21[2];
  uint64_t v22;

  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = result;
      if (a3)
      {
        v6 = 0;
        v7 = a3;
        while (1)
        {
          v8 = *(_DWORD *)(v4 + 24 * v6 + 4);
          if (v8 == 1)
            break;
          if (!v8)
          {
            v9 = v4 + 24 * v6;
            v12 = *(_DWORD *)(v9 + 8);
            v11 = (unsigned int *)(v9 + 8);
            v10 = v12;
            v13 = *((_QWORD *)v11 + 1);
            if (v12)
            {
              v14 = 0;
              v15 = 8;
              do
              {
                if (*(_QWORD *)(v13 + v15))
                {
                  heap_Free(*(_QWORD **)(v5[3] + 8), *(_QWORD *)(v13 + v15));
                  v13 = *((_QWORD *)v11 + 1);
                  *(_QWORD *)(v13 + v15) = 0;
                  v10 = *v11;
                }
                ++v14;
                v15 += 24;
              }
              while (v14 < v10);
            }
LABEL_20:
            heap_Free(*(_QWORD **)(v5[3] + 8), v13);
            *((_QWORD *)v11 + 1) = 0;
            *v11 = 0;
          }
          if (++v6 == v7)
            goto LABEL_22;
        }
        v16 = v4 + 24 * v6;
        v18 = *(_DWORD *)(v16 + 8);
        v11 = (unsigned int *)(v16 + 8);
        v17 = v18;
        v13 = *((_QWORD *)v11 + 1);
        if (v18)
        {
          v19 = 0;
          v20 = 16;
          do
          {
            if (*(_QWORD *)(v13 + v20))
            {
              v22 = 0;
              memset(v21, 0, sizeof(v21));
              if (!ooc_utils_createAllocator((uint64_t)v21, (_WORD *)v5[4], v5[5]))
                OOC_PlacementDeleteObject((uint64_t)v21, *(_QWORD *)(*((_QWORD *)v11 + 1) + v20));
              v13 = *((_QWORD *)v11 + 1);
              *(_QWORD *)(v13 + v20) = 0;
              v17 = *v11;
            }
            ++v19;
            v20 += 24;
          }
          while (v19 < v17);
        }
        goto LABEL_20;
      }
LABEL_22:
      result = heap_Free(*(_QWORD **)(v5[3] + 8), v4);
      *a2 = 0;
    }
  }
  return result;
}

BOOL CLM_IsSeperationRecord(uint64_t a1, unsigned int a2)
{
  char __dst[4];

  *(_DWORD *)__dst = 0;
  strncpy(__dst, (const char *)(a1 + a2), 3uLL);
  return *(_DWORD *)__dst != 7173476 || *(_BYTE *)(a1 + a2 + 3) || *(_BYTE *)(a1 + a2 + 4);
}

BOOL CLM_FindLanguageInArray(char *__s2, unsigned int a2, uint64_t a3, char *__s1, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;

  v9 = 0;
  if (a2 <= 1)
    v10 = 1;
  else
    v10 = a2;
  while (strcmp(__s1, __s2) && *__s2)
  {
    ++v9;
    __s2 += 4;
    if (v10 == v9)
      return 1;
  }
  *a5 = v9;
  ++*(_DWORD *)(a3 + 4 * v9);
  return *__s2 == 0;
}

uint64_t CLM_FindSeperationRecord(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  unsigned int v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;

  v6 = *a3;
  while (1)
  {
    result = CLM_IsSeperationRecord(a1, v6);
    if (!(_DWORD)result)
      break;
    if (v6 <= a2)
      v8 = a2;
    else
      v8 = v6;
    if (v6 < a2)
    {
      v9 = 0;
      v10 = (unsigned __int8 *)(a1 + v6);
      v11 = ~(unint64_t)v6 + v8;
      do
      {
        v12 = *v10++;
        *a3 = ++v6;
        if (!v12)
          ++v9;
      }
      while (v9 <= 1 && v11-- != 0);
    }
    if (v6 == a2)
      return 2347769856;
  }
  *a3 = v6 + 5;
  return result;
}

uint64_t CLM_PreCompileSplitWordRegEx(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v12;
  _DWORD v13[2];
  const char *v14;
  char v15[16];
  char v16[32];
  char v17[32];
  char v18[68];
  char v19[500];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13[1] = 0;
  strcpy(v16, "[\"#\\$&'\\.789=\\?@A-Z^_a-z]");
  strcpy((char *)v13, "\\*");
  strcpy(v15, "(\\\\)?[!\\?,\\.;:]");
  if (a1[23]
    || (v14 = 0,
        __sprintf_chk(v19, 0, 0x1F4uLL, "(%s%s*(%%%s|%%\"%s+\"){0,}(&%s%s*(%%%s|%%\"%s+\"){0,}){0,})|(%s%s)", v16, v17, v18, v18, v16, v17, v18, v18, (const char *)v13, v15), v10 = nuance_pcre_compile(a1[21], a1[22], v19, 0, &v14, &v13[1], 0), v9 = 0, (a1[23] = v10) == 0))
  {
    v9 = 2347769856;
    log_OutPublic(*(_QWORD *)(a1[3] + 32), (uint64_t)"CLM", 50003, 0, a5, a6, a7, a8, v12);
  }
  return v9;
}

_QWORD *CLM_FreePreCompiledSplitWordRegEx(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = result[23];
  if (v1)
  {
    v2 = result;
    result = heap_Free(*(_QWORD **)(result[3] + 8), v1);
    v2[23] = 0;
  }
  return result;
}

uint64_t CLM_PreCompileReplacementRegEx(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v12;
  int v13;
  const char *v14;
  char v15[24];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  strcpy(v15, "(^|[^\\\\])([\\$][0-9]+)");
  if (a1[24]
    || (v14 = 0, v10 = nuance_pcre_compile(a1[21], a1[22], v15, 0, &v14, &v13, 0), v9 = 0, (a1[24] = v10) == 0))
  {
    v9 = 2347769856;
    log_OutPublic(*(_QWORD *)(a1[3] + 32), (uint64_t)"CLM", 50003, 0, a5, a6, a7, a8, v12);
  }
  return v9;
}

_QWORD *CLM_FreePreCompiledReplacementRegEx(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = result[24];
  if (v1)
  {
    v2 = result;
    result = heap_Free(*(_QWORD **)(result[3] + 8), v1);
    v2[24] = 0;
  }
  return result;
}

uint64_t CLM_DeleteNonPhoneChars(uint64_t a1, char *__s)
{
  _QWORD *v4;
  size_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  unsigned int v16;
  char *__lasts;

  v4 = *(_QWORD **)(*(_QWORD *)(a1 + 24) + 8);
  v5 = strlen(__s);
  v6 = (char *)heap_Calloc(v4, 1, v5 + 1);
  if (v6)
  {
    v11 = (uint64_t)v6;
    __lasts = 0;
    v12 = strcpy(v6, __s);
    *__s = 0;
    v13 = strtok_r(v12, "\t ", &__lasts);
    if (v13)
    {
      v14 = v13;
      do
      {
        strcat(__s, v14);
        v14 = strtok_r(0, "\t ", &__lasts);
      }
      while (v14);
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), v11);
    return 0;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v7, v8, v9, v10, v16);
    return 2347769866;
  }
}

uint64_t CLM_SplitWordInPhonemes(uint64_t a1, char *__s, char *a3, unsigned int a4, _QWORD *a5, _DWORD *a6)
{
  const char *v9;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  const char *v20;
  uint64_t v21;
  char *v22;
  unsigned int v24;
  uint64_t v25;

  v9 = __s;
  if (a6)
    *a6 = 0;
  if (a3)
  {
    if (((2 * strlen(__s)) | 1) > a4)
      return 2347769865;
    *a3 = 0;
  }
  if (a5)
    StringList_Reset(a5);
  v12 = strlen(v9);
  v25 = LhpuCreate(*(_QWORD *)(a1 + 8));
  if (!v25)
  {
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v13, v14, v15, v16, v24);
    return 2347769866;
  }
  v11 = 0;
  v17 = (unint64_t)&v9[v12 + 1];
  if (v17 <= (unint64_t)v9)
    goto LABEL_32;
  v11 = 0;
  v18 = 1;
  do
  {
    if (*v9 == 18)
    {
      if (a3)
      {
        *(_WORD *)&a3[strlen(a3)] = 32;
        *(_WORD *)&a3[strlen(a3)] = 18;
      }
      goto LABEL_29;
    }
    LhplGetSymbol();
    if (!v19)
    {
      if (v18)
      {
        if (!a3)
        {
LABEL_26:
          if (a5)
          {
            v21 = v25;
            kaldi::CuMatrixBase<float>::~CuMatrixBase(v25);
            v11 = CLM_PhonList_Append((uint64_t)a5, v22);
            if ((v11 & 0x80000000) != 0)
              goto LABEL_31;
          }
          v18 = 0;
          goto LABEL_29;
        }
      }
      else
      {
        if (!a3)
          goto LABEL_26;
        *(_WORD *)&a3[strlen(a3)] = 32;
      }
      kaldi::CuMatrixBase<float>::~CuMatrixBase(v25);
      strcat(a3, v20);
      goto LABEL_26;
    }
    if (v19 == 1)
      break;
    if (a6)
      *a6 = 1;
LABEL_29:
    ++v9;
  }
  while ((unint64_t)v9 < v17);
  v21 = v25;
LABEL_31:
  if (v21)
LABEL_32:
    LhpuRemove(*(_QWORD **)(a1 + 8), &v25);
  return v11;
}

BOOL CLM_SearchAndReplace(uint64_t a1, _BYTE *a2, char *a3, uint64_t a4, char *__s, uint64_t a6, unsigned int a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  const char **v22;
  uint64_t i;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  _BYTE *v33;
  char *v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  unsigned int v39;
  _QWORD *v41;
  unsigned int v43;
  uint64_t v45;
  uint64_t v47;
  unsigned int v48;
  _OWORD v49[22];
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v48 = 0;
  v47 = 0;
  memset(v49, 0, sizeof(v49));
  v50 = 0;
  v43 = strlen(__s);
  if (v43)
  {
    LODWORD(v14) = 0;
    v15 = 0;
    v16 = 0;
    v41 = (_QWORD *)a1;
    do
    {
      if (v16 && *a2 == 94)
        break;
      v17 = strlen(__s);
      if ((int)nuance_pcre_exec(*(_QWORD **)(a1 + 168), *(_QWORD *)(a1 + 176), a4, 0, &__s[v16], v17 - v16, 0, 0, v49, 90) < 1)break;
      v18 = CLM_InterpretReplacementString(a1, a3, &v47, &v48);
      if ((v18 & 0x80000000) != 0)
        return v18;
      v19 = v48;
      if (!v48)
        v16 = *((_DWORD *)v49 + (v14 + 1)) + v16 - *((_DWORD *)v49 + v14);
      v20 = LODWORD(v49[0]);
      v21 = v16;
      if (LODWORD(v49[0]))
      {
        do
        {
          *(_BYTE *)(a6 + v15++) = __s[v21++];
          --v20;
        }
        while (v20);
      }
      v45 = v47;
      if ((_DWORD)v19)
      {
        v22 = (const char **)(v47 + 8);
        for (i = v19; i; --i)
        {
          v24 = *((_DWORD *)v22 - 2);
          if (v24 == 1)
          {
            v25 = *((_DWORD *)v22 - 1);
            v26 = (2 * v25) | 1u;
            v14 = (2 * v25);
            v27 = *((_DWORD *)v49 + v14);
            v28 = (*((_DWORD *)v49 + v26) - v27);
            if (v28 + v15 >= a7)
            {
LABEL_23:
              v29 = 2347769865;
              v30 = v41[3];
              goto LABEL_37;
            }
            strncpy((char *)(a6 + v15), &__s[v27 + v16], v28);
            v15 = *((_DWORD *)v49 + v26) + v15 - *((_DWORD *)v49 + v14);
          }
          else if (!v24 && *v22)
          {
            if (v15 + strlen(*v22) >= a7)
              goto LABEL_23;
            strcpy((char *)(a6 + v15), *v22);
            v15 += strlen(*v22);
          }
          v22 += 2;
        }
      }
      v16 += DWORD1(v49[0]);
      a1 = (uint64_t)v41;
      CLM_FreeListOfTypes(v41, v45, v19);
      v47 = 0;
    }
    while (v16 < v43);
  }
  else
  {
    v16 = 0;
    v15 = 0;
  }
  v31 = v43 - v16;
  if (v43 <= v16)
  {
    v31 = 0;
LABEL_34:
    v37 = v31 + v15;
    if (v37 < a7)
    {
      *(_BYTE *)(a6 + v37) = 0;
      return v16 == 0;
    }
  }
  else
  {
    LODWORD(v32) = a7 - v15;
    if (a7 >= v15)
      v32 = v32;
    else
      v32 = 0;
    v33 = (_BYTE *)(a6 + v15);
    v34 = &__s[v16];
    v35 = v43 - v16;
    while (v32)
    {
      v36 = *v34++;
      *v33++ = v36;
      --v32;
      if (!--v35)
        goto LABEL_34;
    }
  }
  v29 = 2347769865;
  v30 = *(_QWORD *)(a1 + 24);
LABEL_37:
  log_OutPublic(*(_QWORD *)(v30 + 32), (uint64_t)"CLM", 50002, 0, v10, v11, v12, v13, v39);
  return v29;
}

uint64_t CLM_InterpretReplacementString(uint64_t a1, char *__s, uint64_t *a3, unsigned int *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  char *v34;
  int v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  uint64_t v39;
  char *v40;
  unsigned int v42;
  _BYTE v43[5];
  int v44;
  size_t __n;
  __int128 v46;
  size_t v47[2];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  __n = 0;
  v15 = strlen(__s);
  if ((_DWORD)v15)
  {
    v16 = *(_QWORD *)(a1 + 192);
    if (!v16)
    {
      v17 = CLM_PreCompileReplacementRegEx((_QWORD *)a1, v8, v9, v10, v11, v12, v13, v14);
      if ((v17 & 0x80000000) != 0)
        return v17;
      v16 = *(_QWORD *)(a1 + 192);
    }
    nuance_pcre_fullinfo(v16, 0, 1, (int *)&__n);
    v22 = *(_QWORD *)(a1 + 24);
    if (__n)
    {
      v23 = heap_Alloc(*(_QWORD *)(v22 + 8), __n);
      if (v23)
      {
        v28 = (void *)v23;
        *a3 = 0;
        v29 = (void *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), (32 * v15) & 0xFFFFFFFE0);
        *a3 = (uint64_t)v29;
        if (v29)
        {
          bzero(v29, (32 * v15) & 0xFFFFFFFE0);
          v30 = 0;
          v31 = 0;
          v68 = 0;
          v66 = 0u;
          v67 = 0u;
          v64 = 0u;
          v65 = 0u;
          v62 = 0u;
          v63 = 0u;
          v60 = 0u;
          v61 = 0u;
          v58 = 0u;
          v59 = 0u;
          v56 = 0u;
          v57 = 0u;
          v54 = 0u;
          v55 = 0u;
          v52 = 0u;
          v53 = 0u;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v32 = v15;
          v46 = 0u;
          *(_OWORD *)v47 = 0u;
          while (1)
          {
            memcpy(v28, *(const void **)(a1 + 192), __n);
            if (nuance_pcre_exec(*(_QWORD **)(a1 + 168), *(_QWORD *)(a1 + 176), (uint64_t)v28, 0, &__s[v31], v32, 0, 0, &v46, 90) != 3)break;
            v33 = v47[0];
            if (LODWORD(v47[0]))
            {
              *(_DWORD *)(*a3 + 16 * v30) = 0;
              *(_QWORD *)(*a3 + 16 * v30 + 8) = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), (v33 + 1));
              v34 = *(char **)(*a3 + 16 * v30 + 8);
              if (!v34)
                goto LABEL_26;
              strncpy(v34, &__s[v31], LODWORD(v47[0]));
              *(_BYTE *)(*(_QWORD *)(*a3 + 16 * v30++ + 8) + SLODWORD(v47[0])) = 0;
            }
            *(_DWORD *)(*a3 + 16 * v30) = 1;
            __strncpy_chk();
            v35 = 0;
            v43[HIDWORD(v47[0]) + ~LODWORD(v47[0])] = 0;
            v36 = v43[0];
            if (v43[0] - 58 >= 0xFFFFFFF6)
            {
              v35 = 0;
              v37 = (unsigned __int8 *)&v44;
              do
              {
                v35 = v36 + 10 * v35 - 48;
                v38 = *v37++;
                v36 = v38;
              }
              while ((v38 - 58) >= 0xFFFFFFF6);
            }
            *(_DWORD *)(*a3 + 16 * v30 + 4) = v35;
            v31 += DWORD1(v46);
            ++v30;
            v32 = v15 - v31;
            if ((_DWORD)v15 == v31)
              goto LABEL_25;
          }
          *(_DWORD *)(*a3 + 16 * v30) = 0;
          *(_QWORD *)(*a3 + 16 * v30 + 8) = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), v32 + 1);
          v40 = *(char **)(*a3 + 16 * v30 + 8);
          if (v40)
          {
            strncpy(v40, &__s[v31], v32);
            *(_BYTE *)(*(_QWORD *)(*a3 + 16 * v30++ + 8) + v32) = 0;
LABEL_25:
            *a4 = v30;
            heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v28);
            return 0;
          }
LABEL_26:
          v39 = 2347769866;
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v28);
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), *a3);
          *a3 = 0;
        }
        else
        {
          v39 = 2347769866;
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v28);
        }
      }
      else
      {
        v39 = 2347769866;
      }
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v24, v25, v26, v27, v42);
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v22 + 32), (uint64_t)"CLM", 50003, 0, v18, v19, v20, v21, v42);
      return 2347769856;
    }
  }
  else
  {
    v39 = 0;
    *a4 = 0;
  }
  return v39;
}

_QWORD *CLM_FreeListOfTypes(_QWORD *result, uint64_t a2, unsigned int a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t *v6;

  if (a2)
  {
    v4 = result;
    if (a3)
    {
      v5 = a3;
      v6 = (uint64_t *)(a2 + 8);
      do
      {
        if (*v6)
          heap_Free(*(_QWORD **)(v4[3] + 8), *v6);
        v6 += 2;
        --v5;
      }
      while (v5);
    }
    return heap_Free(*(_QWORD **)(v4[3] + 8), a2);
  }
  return result;
}

uint64_t CLM_RemoveInvalidPhonemes(uint64_t a1, int a2, char *a3, char *a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  char *__s1;
  char *__lasts;
  char __s2[2];
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (a5)
    *a5 = 0;
  v9 = 2347769864;
  if ((safeh_HandleCheck(a1, a2, 63000, 216) & 0x80000000) == 0 && a1)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM RemoveInvalidPhonemes : Begin (%s)", v10, v11, v12, (uint64_t)a4);
    v13 = CLM_GiveLanguageBuffer(a3, *(_QWORD *)(a1 + 152), *(_DWORD *)(a1 + 160), 2);
    if (v13)
    {
      v14 = v13;
      v15 = CLM_DeleteNonPhoneChars(a1, a4);
      if ((v15 & 0x80000000) != 0)
      {
        return v15;
      }
      else
      {
        v16 = (2 * strlen(a4)) | 1;
        v17 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), v16);
        if (v17)
        {
          v22 = v17;
          bzero(v17, v16);
          v9 = CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a4, v22, v16, 0, 0);
          if ((v9 & 0x80000000) != 0)
          {
            heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v22);
          }
          else
          {
            __s1 = *(char **)(v14 + 8);
            __lasts = 0;
            if (!hlp_ShouldTempWorkAroundVO9614(a1, a3))
            {
              *a4 = 0;
              v27 = strtok_r(v22, " ", &__lasts);
              if (v27)
              {
                v28 = v27;
                do
                {
                  if (!strcmp(v28, "T") && !strcmp(a3, "spm"))
                  {
                    v32 = strcmp((const char *)(a1 + 56), "SPE");
                    v37 = 0;
                    v38 = 0;
                    v39 = 0;
                    strcpy(__s2, " ");
                    __strcat_chk();
                    __strcat_chk();
                    if (!v32)
                      goto LABEL_23;
                  }
                  else
                  {
                    v37 = 0;
                    v38 = 0;
                    v39 = 0;
                    strcpy(__s2, " ");
                    __strcat_chk();
                    __strcat_chk();
                  }
                  if (*v28 != 18 && !strstr(__s1, __s2))
                  {
                    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Wrong L&H+ phoneme %s", v29, v30, v31, (uint64_t)v28);
                    if (a5)
                      *a5 = 1;
                    goto LABEL_24;
                  }
LABEL_23:
                  strcat(a4, v28);
LABEL_24:
                  v28 = strtok_r(0, " ", &__lasts);
                }
                while (v28);
              }
            }
            heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), (uint64_t)v22);
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM RemoveInvalidPhonemes : End (%s)", v23, v24, v25, (uint64_t)a4);
          }
        }
        else
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v18, v19, v20, v21, v33);
          return 2347769866;
        }
      }
    }
    else
    {
      return 2347777677;
    }
  }
  return v9;
}

uint64_t CLM_GiveLanguageBuffer(char *a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = 0;
  if (a2 && a3)
  {
    v7 = a2;
    v8 = a3;
    while (LH_stricmp((char *)v7, a1))
    {
      v7 += 24;
      if (!--v8)
        return 0;
    }
    if (*(_DWORD *)(v7 + 4) == a4)
      return v7;
    else
      return 0;
  }
  return result;
}

uint64_t hlp_ShouldTempWorkAroundVO9614(uint64_t a1, char *__s1)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (strcmp(__s1, "mnc") && strcmp(__s1, "mnt") && strcmp(__s1, "cah") && strcmp(__s1, "sic"))
    return 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"VO-9614 lang code don't check phonemes against phoneme set (%s).", v4, v5, v6, (uint64_t)__s1);
  return 1;
}

uint64_t CLM_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t NullHandle;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;

  v22 = 0;
  v23 = 0;
  v5 = 2347769863;
  if (a5)
  {
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    inited = InitRsrcFunction(a3, a4, &v23);
    if ((inited & 0x80000000) != 0)
      return inited;
    NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual((uint64_t)a1, a2, NullHandle, v13))
    {
      inited = InitRsrcFunction(a1, a2, &v22);
      if ((inited & 0x80000000) == 0)
      {
        v14 = (_QWORD *)heap_Calloc(*(_QWORD **)(v23 + 8), 1, 216);
        v19 = v23;
        if (!v14)
        {
          log_OutPublic(*(_QWORD *)(v23 + 32), (uint64_t)"CLM", 50000, 0, v15, v16, v17, v18, v22);
          return 2347769866;
        }
        v20 = (uint64_t)v14;
        v14[4] = a3;
        v14[5] = a4;
        v14[2] = a2;
        v14[3] = v19;
        *v14 = v22;
        v14[1] = a1;
        inited = nuance_pcre_ObjOpen(a3, a4, (uint64_t)(v14 + 21));
        if ((inited & 0x80000000) == 0)
        {
          inited = nuance_pcre_Init(*(_QWORD **)(v20 + 168), *(_QWORD *)(v20 + 176), 0xAu, 10);
          if ((inited & 0x80000000) == 0)
          {
            *(_QWORD *)a5 = v20;
            *(_DWORD *)(a5 + 8) = 63000;
            return CLM_ObjReopen(v20, *(_QWORD *)(a5 + 8));
          }
        }
      }
      return inited;
    }
  }
  return v5;
}

uint64_t CLM_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t Language;
  int v7;
  uint64_t ObjcForThisApi_0;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v35;
  char v36[4];
  uint64_t v37;
  char v38[4];
  int v39;
  char v40[256];
  char v41[264];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = safeh_HandleCheck(a1, a2, 63000, 216);
  v4 = 2347769864;
  if ((v3 & 0x80000000) != 0 || !a1)
    return v4;
  v5 = v3;
  if ((hlp_GetLanguage(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 40), v36) & 0x80000000) == 0
    && !LH_stricmp((char *)(a1 + 56), v36))
  {
    return v5;
  }
  CLM_DeInitFromCLMv2Lua((_QWORD *)a1);
  Language = CLM_DeInit((uint64_t *)a1);
  if ((Language & 0x80000000) != 0)
    return Language;
  memset(v41, 0, 256);
  v37 = 0;
  Language = hlp_GetLanguage(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 40), v38);
  if ((Language & 0x80000000) != 0)
    return Language;
  __strcat_chk();
  __strcat_chk();
  v7 = brokeraux_ComposeBrokerString(*(_QWORD *)(a1 + 24), v41, 0, 1, v38, 0, 0, v40, 0x100uLL);
  if (v7 < 0)
    return v7 | 0x8BF02000;
  ObjcForThisApi_0 = getObjcForThisApi_0(*(_QWORD *)(a1 + 24), *(_QWORD *)a1);
  if (!ObjcForThisApi_0)
    return 2347769856;
  if ((objc_GetAddRefCountedObject(ObjcForThisApi_0, (uint64_t)v40, (uint64_t (*)(_QWORD, _QWORD, uint64_t, __int128 *, uint64_t))IRefCnt_ObjcLoadCLMData, (void (*)(_QWORD, _QWORD, __int128 *))IRefCnt_ObjcUnloadCLMData, a1, &v37) & 0x80000000) != 0)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 200) = 0;
    return v4;
  }
  v4 = 2347777666;
  v9 = *(_QWORD *)(v37 + 32);
  *(_QWORD *)(a1 + 48) = v9;
  CLM_UnloadSettings(a1);
  v14 = *(_DWORD *)(v9 + 40);
  if (!v14)
    return 2347777673;
  v15 = *(_QWORD *)(v9 + 32);
  if (!v15)
    return 2347777665;
  if (v14 <= 0x12)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v10, v11, v12, v13, v35);
    return CLM_InitFromCLMv2Lua(a1, v38);
  }
  strncpy((char *)(a1 + 56), (const char *)(v15 + 14), 3uLL);
  *(_BYTE *)(a1 + 59) = 0;
  *(_BYTE *)(a1 + 60) = *(_BYTE *)(v15 + 17);
  *(_BYTE *)(a1 + 61) = *(_BYTE *)(v15 + 18);
  v39 = 19;
  if ((CLM_EnumerateLanguages(a1, (uint64_t *)(a1 + 72), (unsigned int *)(a1 + 80), 1u, *(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), 0x13u) & 0x80000000) != 0)return 2347777667;
  if (!*(_DWORD *)(a1 + 80))
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v16, v17, v18, v19, v35);
    return 2347777667;
  }
  if ((CLM_FindSeperationRecord(*(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), (unsigned int *)&v39) & 0x80000000) != 0)
    return 2347777667;
  if ((CLM_LoadRules(a1, *(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), 0, (unsigned int *)&v39) & 0x80000000) != 0
    || (CLM_FindSeperationRecord(*(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), (unsigned int *)&v39) & 0x80000000) != 0
    || (CLM_LoadRules(a1, *(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), 1, (unsigned int *)&v39) & 0x80000000) != 0)
  {
    return v4;
  }
  v5 = 2347777668;
  if ((CLM_FindSeperationRecord(*(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), (unsigned int *)&v39) & 0x80000000) != 0
    || (CLM_EnumerateLanguages(a1, (uint64_t *)(a1 + 152), (unsigned int *)(a1 + 160), 2u, *(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 40), v39) & 0x80000000) != 0)
  {
    return v5;
  }
  v4 = 2347777671;
  if ((CLM_PreCompileSplitWordRegEx((_QWORD *)a1, v20, v21, v22, v23, v24, v25, v26) & 0x80000000) == 0
    && (CLM_PreCompileReplacementRegEx((_QWORD *)a1, v27, v28, v29, v30, v31, v32, v33) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 64) = 1;
    return CLM_InitFromCLMv2Lua(a1, v38);
  }
  return v4;
}

uint64_t CLM_ObjClose(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = 2347769864;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 63000, 216) & 0x80000000) == 0 && a1)
  {
    CLM_DeInitFromCLMv2Lua(a1);
    v4 = CLM_DeInit(a1);
    if ((v4 & 0x80000000) == 0)
    {
      v4 = nuance_pcre_DeInit((_QWORD *)a1[21], a1[22]);
      if ((v4 & 0x80000000) == 0)
        v4 = nuance_pcre_ObjClose(a1[21], a1[22]);
    }
    v3 = v4;
    heap_Free(*(_QWORD **)(a1[3] + 8), (uint64_t)a1);
  }
  return v3;
}

uint64_t CLM_DeInit(uint64_t *a1)
{
  uint64_t ObjcForThisApi_0;

  CLM_UnloadSettings((uint64_t)a1);
  if (!a1[6])
    return 0;
  ObjcForThisApi_0 = getObjcForThisApi_0(a1[3], *a1);
  if (ObjcForThisApi_0)
    return objc_ReleaseObject(ObjcForThisApi_0, a1[6] + 48);
  else
    return 2347769856;
}

uint64_t CLM_ConvertTranscription(uint64_t a1, int a2, char *a3, const char *a4, char *a5, char *a6, char *a7, unsigned int a8)
{
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  size_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  size_t v35;
  uint64_t *v36;
  uint64_t *v37;
  int v39;
  int v40;
  BOOL v41;
  int v42;
  char *v43;
  int v44;
  int v45;
  int CountStrings;
  int v47;
  unsigned int v48;
  unsigned __int16 v49;
  size_t v50;
  const char *v51;
  size_t v52;
  const char *v53;
  const char *v54;
  char *v55;
  const char *v56;
  char *v57;
  unsigned int v58;
  size_t v59;
  char *__dst;
  unsigned int v61;
  char *__src;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  int v67;
  char __s2[4];

  v64 = 0;
  strcpy(__s2, "ANY");
  v67 = 0;
  v65 = 0;
  v66 = 0;
  v15 = -1947197430;
  v16 = safeh_HandleCheck(a1, a2, 63000, 216);
  v17 = 2347769864;
  if ((v16 & 0x80000000) == 0 && a1)
  {
    if (!*(_DWORD *)(a1 + 64))
      return 2347777672;
    v17 = 2347777674;
    if (a4)
    {
      v18 = v16;
      v19 = strlen(a4);
      if (v19)
      {
        if (a8 && v19 + 1 > a8)
          return 2347777673;
        if (a8)
        {
          v20 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), (v19 + 1));
          if (v20)
          {
            v25 = v20;
            strcpy(v20, a4);
            __src = v25;
            v26 = CLM_RemoveInvalidPhonemes(a1, a2, a3, v25, &v67);
            v27 = v26;
            if (v26 < 0)
            {
              v28 = v26;
              if ((v26 & 0x1FFF) != 0x1E8D)
              {
                v29 = 0;
                a8 = 0;
                v15 = v26;
                goto LABEL_31;
              }
            }
            else if (v67)
            {
              v28 = -1947189627;
            }
            else
            {
              v28 = 0;
            }
            v61 = v28;
            if (!strcmp(a3, __s2))
            {
              v29 = 0;
              v15 = -1947189621;
              goto LABEL_23;
            }
            v59 = a8;
            if ((v61 & 0x1FFF) != 0x1E8D && strcmp((const char *)(a1 + 56), a3))
            {
              __dst = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), a8 + 1);
              if (__dst)
              {
                if (a6 && a7)
                {
                  v35 = a8 + 1;
                  *a6 = 0;
                  *a7 = 0;
                  if (strlen(a4) <= 0x95)
                  {
                    v36 = &v65;
                    if ((int)hlp_AllocateAndInitializePhonlists(a1, __src, (uint64_t *)&v66, &v65, &v64) >= 0)
                    {
                      v37 = &v64;
                    }
                    else
                    {
                      v36 = 0;
                      v37 = 0;
                    }
                  }
                  else
                  {
                    a6 = 0;
                    a7 = 0;
                    v36 = 0;
                    v37 = 0;
                  }
                }
                else
                {
                  v35 = a8 + 1;
                  v37 = 0;
                  v36 = 0;
                }
                bzero(__dst, v35);
                strcpy(__dst, __src);
                strcpy(a5, __src);
                v39 = CLM_ApplyRules(a1, *(_QWORD *)(a1 + 88), *(_DWORD *)(a1 + 96), a3, __dst, a5, a8, v66, (_QWORD **)v36, (_QWORD **)v37);
                if (v39)
                {
                  if (v39 < 0)
                    goto LABEL_69;
                }
                else
                {
                  strcpy(__dst, a5);
                }
                v39 = CLM_ApplyRules(a1, *(_QWORD *)(a1 + 120), *(_DWORD *)(a1 + 128), a3, __dst, a5, a8, v66, (_QWORD **)v37, (_QWORD **)v36);
                if (v39)
                {
                  if (v39 < 0)
                    goto LABEL_69;
                }
                else
                {
                  strcpy(__dst, a5);
                }
                v39 = CLM_ApplyRules(a1, *(_QWORD *)(a1 + 88), *(_DWORD *)(a1 + 96), __s2, __dst, a5, a8, v66, (_QWORD **)v36, (_QWORD **)v37);
                if (v39)
                {
                  if (v39 < 0)
                    goto LABEL_69;
                }
                else
                {
                  strcpy(__dst, a5);
                }
                v40 = CLM_ApplyPhonemeMapping(a1, *(_QWORD *)(a1 + 72), *(_DWORD *)(a1 + 80), a3, __dst, a5, a8, v66, (_QWORD **)v37, (_QWORD **)v36);
                if (v40 < 0)
                {
                  if ((v40 & 0x1FFF) != 0)
                    v15 = v40;
                  else
                    v15 = -1947189621;
                  a8 = v61;
                  v30 = (uint64_t)__src;
                  v29 = (uint64_t)__dst;
                  goto LABEL_32;
                }
                strcpy(__dst, a5);
                v39 = CLM_ApplyRules(a1, *(_QWORD *)(a1 + 104), *(_DWORD *)(a1 + 112), a3, __dst, a5, a8, v66, (_QWORD **)v36, (_QWORD **)v37);
                if (v39)
                {
                  if (v39 < 0)
                  {
                    v41 = (v39 & 0x1FFF) == 0;
                    v42 = 7819;
LABEL_70:
                    if (v41)
                      v15 = v42;
                    else
                      v15 = v39;
                    a8 = v61;
LABEL_74:
                    v30 = (uint64_t)__src;
                    v29 = (uint64_t)__dst;
                    goto LABEL_32;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                v39 = CLM_ApplyRules(a1, *(_QWORD *)(a1 + 104), *(_DWORD *)(a1 + 112), __s2, __dst, a5, a8, v66, (_QWORD **)v37, (_QWORD **)v36);
                if (v39)
                {
                  if (v39 < 0)
                  {
LABEL_69:
                    v41 = (v39 & 0x1FFF) == 0;
                    v42 = -1947189621;
                    goto LABEL_70;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                v43 = a3;
                v29 = (uint64_t)__dst;
                v44 = CLM_ApplyRules(a1, *(_QWORD *)(a1 + 136), *(_DWORD *)(a1 + 144), v43, __dst, a5, a8, v66, (_QWORD **)v36, (_QWORD **)v37);
                if (v44)
                {
                  if (v44 < 0)
                  {
                    if ((v44 & 0x1FFF) != 0)
                      v15 = v44;
                    else
                      v15 = -1947189621;
                    goto LABEL_23;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                v45 = CLM_RemoveInvalidPhonemes(a1, a2, (char *)(a1 + 56), a5, &v67);
                v15 = v45;
                if ((v45 & 0x80000000) == 0)
                {
                  a8 = v61;
                  if (v67)
                  {
                    a8 = -1947189626;
                    goto LABEL_31;
                  }
LABEL_86:
                  if (a6 && a7)
                  {
                    *a6 = 0;
                    *a7 = 0;
                    CountStrings = StringList_GetCountStrings((uint64_t)v66);
                    if (v37)
                      v47 = StringList_GetCountStrings(*v37);
                    else
                      v47 = 0;
                    if (CountStrings)
                    {
                      if (v47 == CountStrings
                        && (CLM_MergeSubsequentInsertionAndDeletions((uint64_t)v66, *v37) & 0x80000000) == 0)
                      {
                        v48 = StringList_GetCountStrings((uint64_t)v66);
                        if (v48 == StringList_GetCountStrings(*v37))
                        {
                          if (v48)
                          {
                            v49 = 0;
                            while (1)
                            {
                              v50 = strlen(a6);
                              v51 = (const char *)StringList_GetAt((uint64_t)v66, v49);
                              if (v50 + strlen(v51) + 1 >= v59)
                                break;
                              v52 = strlen(a7);
                              v53 = (const char *)StringList_GetAt(*v37, v49);
                              if (v52 + strlen(v53) + 1 >= v59)
                                break;
                              v54 = (const char *)StringList_GetAt((uint64_t)v66, v49);
                              v55 = strcat(a6, v54);
                              *(_WORD *)&a6[strlen(v55)] = 32;
                              v56 = (const char *)StringList_GetAt(*v37, v49);
                              v57 = strcat(a7, v56);
                              *(_WORD *)&a7[strlen(v57)] = 32;
                              if (v48 <= ++v49)
                                goto LABEL_74;
                            }
                            *a6 = 0;
                            *a7 = 0;
                          }
                        }
                      }
                    }
                    goto LABEL_74;
                  }
                  goto LABEL_31;
                }
                a8 = 7821;
                if ((v45 & 0x1FFF) == 0x1E8D)
                  goto LABEL_86;
              }
              else
              {
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v31, v32, v33, v34, v58);
                v29 = 0;
              }
LABEL_23:
              a8 = v61;
LABEL_31:
              v30 = (uint64_t)__src;
              goto LABEL_32;
            }
            v30 = (uint64_t)__src;
            strcpy(a5, __src);
            v29 = 0;
            v15 = v27;
            a8 = v61;
          }
          else
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v21, v22, v23, v24, v58);
            v29 = 0;
            v30 = 0;
            a8 = 0;
          }
        }
        else
        {
          v29 = 0;
          v30 = 0;
          v15 = v18;
        }
LABEL_32:
        hlp_FreePhonlist(a1, (uint64_t *)&v66);
        hlp_FreePhonlist(a1, &v65);
        hlp_FreePhonlist(a1, &v64);
        if (v30)
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), v30);
        if (v29)
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), v29);
        if (v15 >= 0)
          return a8;
        else
          return v15;
      }
    }
  }
  return v17;
}

uint64_t hlp_AllocateAndInitializePhonlists(uint64_t a1, char *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  int Allocator;
  uint64_t result;
  BOOL v12;
  int v13;
  _OWORD v14[2];
  uint64_t v15;

  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v13 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  Allocator = ooc_utils_createAllocator((uint64_t)v14, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
  if (Allocator)
    return LH_ERROR_to_VERROR(Allocator);
  Allocator = PNEW_StringList_Con((uint64_t)v14, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), a3);
  if (Allocator)
    return LH_ERROR_to_VERROR(Allocator);
  Allocator = PNEW_StringList_Con((uint64_t)v14, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), a4);
  if (Allocator)
    return LH_ERROR_to_VERROR(Allocator);
  Allocator = PNEW_StringList_Con((uint64_t)v14, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), a5);
  if (Allocator)
    return LH_ERROR_to_VERROR(Allocator);
  LODWORD(result) = CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a2, 0, 0, (_QWORD *)*a3, &v13);
  if ((result & 0x80000000) != 0 || v13)
  {
    if ((int)result < 0)
      return result;
    else
      return 2347769856;
  }
  else
  {
    LODWORD(result) = CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a2, 0, 0, (_QWORD *)*a4, &v13);
    if (v13)
      v12 = (int)result <= -1;
    else
      v12 = 1;
    if (v12)
      return result;
    else
      return 2347769856;
  }
}

uint64_t CLM_ApplyRules(uint64_t a1, uint64_t a2, unsigned int a3, char *a4, char *a5, char *a6, unsigned int a7, _QWORD *a8, _QWORD **a9, _QWORD **a10)
{
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  _BOOL8 v23;
  _BOOL8 v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  unsigned int v31;
  int v32;

  v32 = 0;
  v17 = hlp_CheckDoAlignment(a8, a9, a10);
  v18 = CLM_GiveLanguageBuffer(a4, a2, a3, 0);
  if (v18)
  {
    v19 = v18;
    if (*(_DWORD *)(v18 + 8))
    {
      v31 = v17;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      do
      {
        v23 = CLM_SearchAndReplace(a1, *(_BYTE **)(*(_QWORD *)(v19 + 16) + v20), *(char **)(*(_QWORD *)(v19 + 16) + v20 + 16), *(_QWORD *)(*(_QWORD *)(v19 + 16) + v20 + 8), a5, (uint64_t)a6, a7);
        v24 = v23;
        if (v23)
        {
          if (v23 & 0x80000000)
            break;
        }
        else
        {
          strcpy(a5, a6);
          if (v31)
          {
            if (!v22)
            {
              v22 = 1;
              if ((CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a6, 0, 0, *a10, &v32) & 0x80000000) == 0 && !v32)
              {
                if ((CLM_AlignPhonlists(*(_QWORD *)(a1 + 24), (uint64_t)a8, (uint64_t)*a9, (uint64_t)*a10) & 0x80000000) != 0)
                {
                  v22 = 1;
                }
                else
                {
                  v25 = *a9;
                  *a9 = *a10;
                  *a10 = v25;
                  StringList_Reset(v25);
                  v22 = 0;
                }
              }
            }
          }
        }
        ++v21;
        v20 += 24;
      }
      while (v21 < *(unsigned int *)(v19 + 8));
      if (v31)
      {
        v26 = *a10;
        *a10 = *a9;
        *a9 = v26;
        if (v22)
        {
          StringList_Reset(a8);
          StringList_Reset(*a9);
          StringList_Reset(*a10);
        }
      }
    }
    else
    {
      v24 = 0;
      if (v17)
      {
        v28 = *a10;
        *a10 = *a9;
        *a9 = v28;
      }
    }
  }
  else
  {
    if (v17)
    {
      v27 = *a10;
      *a10 = *a9;
      *a9 = v27;
    }
    return 1;
  }
  return v24;
}

uint64_t CLM_ApplyPhonemeMapping(uint64_t a1, uint64_t a2, unsigned int a3, char *a4, char *a5, char *a6, unsigned int a7, _QWORD *a8, _QWORD **a9, _QWORD **a10)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int Allocator;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned __int16 v27;
  size_t v28;
  char *v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unsigned int CountStrings;
  unsigned int v38;
  unsigned int v39;
  BOOL v40;
  int v41;
  unsigned __int16 v42;
  const char *v43;
  const char *v44;
  const char *v45;
  int v46;
  const char *v48;
  int v49;
  int v50;
  int v51;
  char *v52;
  _QWORD *v53;
  _BYTE *v54;
  uint64_t v55;
  _QWORD *v56;
  unsigned __int16 v57;
  char *v58;
  int v59;
  int v60;
  uint64_t v61;
  char *v62;
  unsigned int v63;
  uint64_t v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  _QWORD *v70;
  _OWORD v71[2];
  uint64_t v72;

  v69 = 0;
  v70 = 0;
  v16 = 2347769856;
  v17 = CLM_GiveLanguageBuffer(a4, a2, a3, 1);
  if (!v17)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Invalid Language : %s", v18, v19, v20, (uint64_t)a4);
    return v16;
  }
  if (a6)
  {
    v21 = v17;
    v72 = 0;
    memset(v71, 0, sizeof(v71));
    Allocator = ooc_utils_createAllocator((uint64_t)v71, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
    if (Allocator
      || (Allocator = PNEW_StringList_Con((uint64_t)v71, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t *)&v70)) != 0)
    {
      v23 = LH_ERROR_to_VERROR(Allocator);
    }
    else
    {
      v23 = CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a5, 0, 0, v70, 0);
    }
    v24 = v23;
    if ((v23 & 0x80000000) == 0)
    {
      v68 = v23;
      v25 = v21 + 8;
      *(_QWORD *)&v71[0] = 0;
      v67 = (uint64_t)a8;
      v26 = hlp_CheckDoAlignment(a8, a9, a10);
      *a6 = 0;
      if (StringList_GetCountStrings((uint64_t)v70))
      {
        v27 = 0;
        v28 = a7;
        while (1)
        {
          v29 = (char *)StringList_GetAt((uint64_t)v70, v27);
          hlp_FindPhonemeMapping(v25, v29, v71, &v69);
          if (*(_QWORD *)&v71[0])
            v29 = *(char **)&v71[0];
          v30 = strlen(a6);
          if (v30 + strlen(v29) + 1 > v28)
            break;
          strcat(a6, v29);
          if (StringList_GetCountStrings((uint64_t)v70) <= ++v27)
            goto LABEL_13;
        }
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v31, v32, v33, v34, v63);
        return v16;
      }
LABEL_13:
      if (!v26)
        goto LABEL_30;
      v35 = v70;
      v24 = v68;
      if (v70)
      {
        v36 = *a9;
        if (*a9)
        {
          CountStrings = StringList_GetCountStrings((uint64_t)v70);
          v38 = StringList_GetCountStrings((uint64_t)v36);
          v39 = v38;
          v40 = CountStrings != 0;
          if (v38 && CountStrings)
          {
            v64 = (uint64_t)v35;
            v41 = 0;
            v42 = 0;
            while (2)
            {
              v65 = CountStrings > v42;
              while (1)
              {
                v43 = (const char *)StringList_GetAt((uint64_t)v36, (unsigned __int16)v41);
                if (strcmp(v43, "*"))
                  break;
                if (v39 <= (unsigned __int16)++v41 || CountStrings <= v42)
                {
                  v24 = v68;
                  v40 = v65;
                  if (v39 > (unsigned __int16)v41)
                    goto LABEL_39;
LABEL_45:
                  if (!v40)
                  {
LABEL_46:
                    if (!StringList_GetCountStrings((uint64_t)*a9))
                      goto LABEL_31;
                    v50 = 0;
                    v51 = 0;
                    v66 = v25;
                    while (2)
                    {
                      v52 = (char *)StringList_GetAt((uint64_t)*a9, (unsigned __int16)v51);
                      hlp_FindPhonemeMapping(v25, v52, v71, &v69);
                      v53 = *a9;
                      if (v50)
                      {
                        v50 = 1;
                        goto LABEL_66;
                      }
                      v54 = *(_BYTE **)&v71[0];
                      v55 = v69;
                      v56 = *a10;
                      if (!strcmp(v52, "*"))
                        goto LABEL_62;
                      if (v54)
                      {
                        if (*v54)
                        {
                          if (v55)
                          {
                            if (StringList_GetCountStrings(v55))
                            {
                              v57 = 0;
                              while (1)
                              {
                                v58 = (char *)StringList_GetAt(v55, v57);
                                v59 = CLM_PhonList_Append((uint64_t)v56, v58);
                                if (v59 < 0)
                                  break;
                                if (v57)
                                {
                                  v60 = CLM_PhonList_InsertAt((uint64_t)v53, (unsigned __int16)++v51, "*");
                                  if (v60 < 0)
                                  {
                                    v59 = v60;
                                    v25 = v66;
                                    goto LABEL_65;
                                  }
                                  v59 = CLM_PhonList_InsertAt(v67, (unsigned __int16)v51, "*");
                                  v25 = v66;
                                  if (v59 < 0)
                                    goto LABEL_65;
                                }
                                if (StringList_GetCountStrings(v55) <= ++v57)
                                  goto LABEL_65;
                              }
                            }
                            else
                            {
                              v59 = 0;
                            }
                          }
                          else
                          {
                            v59 = -1947197440;
                          }
                          goto LABEL_65;
                        }
LABEL_62:
                        v61 = (uint64_t)v56;
                        v62 = "*";
                      }
                      else
                      {
                        v61 = (uint64_t)v56;
                        v62 = v52;
                      }
                      v59 = CLM_PhonList_Append(v61, v62);
LABEL_65:
                      v50 = v59 >> 31;
                      v53 = *a9;
                      v24 = v59 & ~(v59 >> 31);
LABEL_66:
                      if (StringList_GetCountStrings((uint64_t)v53) <= (unsigned __int16)++v51)
                        goto LABEL_31;
                      continue;
                    }
                  }
                  goto LABEL_31;
                }
              }
              v44 = (const char *)StringList_GetAt((uint64_t)v36, (unsigned __int16)v41);
              v45 = (const char *)StringList_GetAt(v64, v42);
              v46 = strcmp(v44, v45);
              if (!v46)
                ++v42;
              ++v41;
              v40 = CountStrings > v42;
              if (!v46 && v39 > (unsigned __int16)v41 && CountStrings > v42)
                continue;
              break;
            }
            if (!v46)
            {
              v24 = v68;
              if (v39 > (unsigned __int16)v41)
                goto LABEL_39;
              goto LABEL_45;
            }
LABEL_30:
            v24 = v68;
          }
          else
          {
            if (!v38)
              goto LABEL_45;
            LOWORD(v41) = 0;
LABEL_39:
            if (v39 <= (unsigned __int16)v41)
              goto LABEL_46;
            do
            {
              v48 = (const char *)StringList_GetAt((uint64_t)v36, (unsigned __int16)v41);
              v49 = strcmp(v48, "*");
              if (v49)
                break;
              LOWORD(v41) = v41 + 1;
            }
            while (v39 > (unsigned __int16)v41);
            if (!v49)
              goto LABEL_46;
          }
        }
      }
    }
LABEL_31:
    hlp_FreePhonlist(a1, (uint64_t *)&v70);
    return v24;
  }
  return v16;
}

uint64_t hlp_FreePhonlist(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = ooc_utils_createAllocator((uint64_t)v4, *(_WORD **)(a1 + 32), *(_QWORD *)(a1 + 40));
  if ((_DWORD)result)
    return LH_ERROR_to_VERROR(result);
  if (a2)
  {
    if (*a2)
    {
      result = OOC_PlacementDeleteObject((uint64_t)v4, *a2);
      *a2 = 0;
    }
  }
  return result;
}

uint64_t CLM_TokenizeTranscription(uint64_t a1, int a2, char *a3, char *a4, unsigned int a5, _DWORD *a6)
{
  if ((safeh_HandleCheck(a1, a2, 63000, 216) & 0x80000000) != 0 || !a1)
    return 2347769864;
  else
    return CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a3, a4, a5, 0, a6);
}

uint64_t CLM_GetFeClmCompInfo(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t result;
  unsigned int v7;

  *a3 = 0;
  v5 = safeh_HandleCheck(a1, a2, 63000, 216);
  result = 2347769864;
  if ((v5 & 0x80000000) == 0 && a1)
  {
    if (*(_DWORD *)(a1 + 200))
    {
      v7 = 0;
      result = paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 40), (uint64_t)"fe_clm_component", &v7);
      if ((result & 0x80000000) == 0)
        *a3 = v7;
    }
    else
    {
      return v5;
    }
  }
  return result;
}

BOOL CLM_HasData(uint64_t a1, int a2)
{
  int v3;
  _BOOL8 result;

  v3 = safeh_HandleCheck(a1, a2, 63000, 216);
  result = 0;
  if ((v3 & 0x80000000) == 0)
  {
    if (a1)
      return *(_QWORD *)(a1 + 48) != 0;
  }
  return result;
}

uint64_t CLM_ClassOpen(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 2347769863;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t CLM_ClassClose()
{
  return 0;
}

uint64_t hlp_GetLanguage(uint64_t a1, char *a2)
{
  uint64_t Str;
  char *v5;
  size_t v6;
  unint64_t v7;
  size_t v8;
  char *__s;

  __s = 0;
  *a2 = 0;
  Str = paramc_ParamGetStr(a1, (uint64_t)"langcode", &__s);
  if ((Str & 0x80000000) == 0)
  {
    v5 = __s;
    if (*__s)
    {
      v6 = 0;
      do
      {
        v7 = v6;
        a2[v6] = __tolower(v5[v6]);
        ++v6;
        v5 = __s;
        v8 = strlen(__s);
      }
      while (v7 <= 1 && v6 < v8);
    }
    else
    {
      v6 = 0;
    }
    a2[v6] = 0;
    if (strcmp(v5, a2))
      return paramc_ParamSetStr(a1, (uint64_t)"langcode", a2);
  }
  return Str;
}

uint64_t CLM_GetSuitableLocationOfFeCLMComponent(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t result;

  result = safeh_HandleCheck(a1, a2, 63000, 216);
  if ((result & 0x80000000) != 0)
    return 2347769864;
  *a3 = *(_DWORD *)(a1 + 200) != 0;
  return result;
}

uint64_t CLM_ValidateTranscriptionEx(uint64_t a1, int a2, char *a3, char *a4, char *a5, _DWORD *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int ShouldTempWorkAroundVO9614;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  unint64_t i;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  char *v54;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  int v59;

  v14 = 2347769864;
  v15 = safeh_HandleCheck(a1, a2, 63000, 216);
  if ((v15 & 0x80000000) != 0 || !a1)
    return v14;
  v16 = v15;
  ShouldTempWorkAroundVO9614 = hlp_ShouldTempWorkAroundVO9614(a1, a3);
  if ((safeh_HandleCheck(a1, a2, 63000, 216) & 0x80000000) != 0 || !*(_QWORD *)(a1 + 48))
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : CLM data not available, assume valid transcription", v18, v19, v20, v52);
    *a6 = 1;
    return v16;
  }
  v58 = ShouldTempWorkAroundVO9614;
  v21 = CLM_GiveLanguageBuffer(a3, *(_QWORD *)(a1 + 152), *(_DWORD *)(a1 + 160), 2);
  if (!v21)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : CLM data not available for %s", v22, v23, v24, (uint64_t)a3);
    *a6 = 0;
    return v16;
  }
  v25 = v21;
  v59 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : Begin (%s)", v22, v23, v24, (uint64_t)a5);
  CLM_GetFeClmCompInfo(a1, a2, &v59);
  v26 = v59;
  if (v59)
  {
    v27 = LH_stricmp((char *)(a1 + 56), a3);
    v28 = 0;
    if (!a4 || v27)
      goto LABEL_20;
    if (*a4 && *(_WORD *)(a1 + 204))
    {
      v56 = v26;
      v29 = 0;
      v30 = 0;
      while (LH_stricmp((char *)(*(_QWORD *)(a1 + 208) + v29), a4))
      {
        ++v30;
        v29 += 16;
        if (v30 >= *(unsigned __int16 *)(a1 + 204))
        {
          v28 = 0;
          goto LABEL_41;
        }
      }
      v28 = *(_QWORD *)(a1 + 208) + v29;
LABEL_41:
      v26 = v56;
      goto LABEL_20;
    }
  }
  v28 = 0;
LABEL_20:
  *a6 = 1;
  v32 = CLM_DeleteNonPhoneChars(a1, a5);
  if ((v32 & 0x80000000) != 0)
  {
    v44 = 0;
    v14 = v32;
  }
  else
  {
    v57 = v26;
    v36 = (2 * strlen(a5)) | 1;
    v37 = (char *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), v36, 1);
    if (v37)
    {
      v42 = *(char **)(v25 + 8);
      v43 = v37;
      v54 = v42;
      v55 = v36;
      v14 = CLM_ValidateInForeignLooLoanSet(a1, a5, v37, v36, v42, v58, v28, a6);
      if ((v14 & 0x80000000) != 0)
      {
        v44 = (uint64_t)v43;
      }
      else
      {
        v44 = (uint64_t)v43;
        if (a7 == 1)
        {
          if (v57)
          {
            if (!*a6)
            {
              v45 = LH_stricmp((char *)(a1 + 56), a3);
              if (a4)
              {
                if (!v45 && !*a4 && *(_WORD *)(a1 + 204))
                {
                  v46 = 0;
                  for (i = 0; i < *(unsigned __int16 *)(a1 + 204); ++i)
                  {
                    v48 = *(_QWORD *)(a1 + 208);
                    *a6 = 1;
                    v14 = CLM_ValidateInForeignLooLoanSet(a1, a5, v43, v55, v54, v58, v48 + v46, a6);
                    if ((v14 & 0x80000000) != 0)
                      break;
                    if (*a6 == 1)
                    {
                      strcpy(a4, (const char *)(v48 + v46));
                      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Extended phoneme set %s valid, so returned as foreign loan phoneme set", v49, v50, v51, (uint64_t)a4);
                      break;
                    }
                    v46 += 16;
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v38, v39, v40, v41, v53);
      v44 = 0;
      v14 = 2347769866;
    }
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : End (%s)", v33, v34, v35, (uint64_t)a5);
  if (v44)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), v44);
  return v14;
}

uint64_t CLM_ValidateInForeignLooLoanSet(uint64_t a1, char *a2, char *a3, unsigned int a4, char *a5, int a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char **v20;
  char *__lasts;
  char __s2[20];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v13 = CLM_SplitWordInPhonemes(*(_QWORD *)(a1 + 24), a2, a3, a4, 0, 0);
  if ((v13 & 0x80000000) == 0)
  {
    __lasts = 0;
    v14 = strtok_r(a3, " ", &__lasts);
    *a2 = 0;
    if (v14)
    {
      v15 = v14;
      do
      {
        strcat(a2, v15);
        strcpy(__s2, " ");
        __strcat_chk();
        __strcat_chk();
        if (!a6 && *v15 != 18 && !strstr(a5, __s2))
        {
          if (a7 && (v19 = *(unsigned __int16 *)(a7 + 4), *(_WORD *)(a7 + 4)))
          {
            v20 = *(const char ***)(a7 + 8);
            while (strcmp(v15, *v20))
            {
              v20 += 3;
              if (!--v19)
                goto LABEL_12;
            }
          }
          else
          {
LABEL_12:
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Wrong L&H+ phoneme %s", v16, v17, v18, (uint64_t)v15);
            *a8 = 0;
          }
        }
        v15 = strtok_r(0, " ", &__lasts);
      }
      while (v15);
    }
  }
  return v13;
}

uint64_t CLM_ValidateTranscription(uint64_t a1, int a2, char *a3, uint64_t a4, char *a5, _DWORD *a6)
{
  char *v11;
  char v13;

  if (a4)
  {
    v11 = &v13;
    __strcpy_chk();
  }
  else
  {
    v11 = 0;
  }
  return CLM_ValidateTranscriptionEx(a1, a2, a3, v11, a5, a6, 0);
}

uint64_t CLM_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2347769857;
  result = 0;
  *a2 = &ICLM;
  return result;
}

_QWORD *hlp_CheckDoAlignment(_QWORD *result, _QWORD **a2, _QWORD **a3)
{
  int CountStrings;
  int v6;

  if (result)
  {
    CountStrings = StringList_GetCountStrings((uint64_t)result);
    result = 0;
    if (a2)
    {
      if (CountStrings)
      {
        result = *a2;
        if (*a2)
        {
          v6 = StringList_GetCountStrings((uint64_t)result);
          result = 0;
          if (a3)
          {
            if (v6)
            {
              result = *a3;
              if (*a3)
              {
                StringList_Reset(result);
                return (_QWORD *)(CountStrings == v6);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hlp_FindPhonemeMapping(uint64_t result, char *__s2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *a3 = 0;
  *a4 = 0;
  v4 = *(unsigned int *)result;
  if ((_DWORD)v4)
  {
    v8 = result;
    v9 = 0;
    v10 = *(_QWORD *)(result + 8);
    v11 = 24 * v4;
    while (1)
    {
      result = *(_QWORD *)(v10 + v9);
      if (result)
      {
        v12 = *(_QWORD *)(v10 + v9 + 8);
        if (v12)
        {
          result = strcmp((const char *)result, __s2);
          if (!(_DWORD)result)
            break;
        }
      }
      v9 += 24;
      if (v11 == v9)
        return result;
    }
    *a3 = v12;
    *a4 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + v9 + 16);
  }
  return result;
}

_QWORD *CLM_UnloadSettings(uint64_t a1)
{
  CLM_EmptyLanguageStruct((_QWORD *)a1, (uint64_t *)(a1 + 88), *(_DWORD *)(a1 + 96));
  *(_DWORD *)(a1 + 96) = 0;
  CLM_EmptyLanguageStruct((_QWORD *)a1, (uint64_t *)(a1 + 104), *(_DWORD *)(a1 + 112));
  *(_DWORD *)(a1 + 112) = 0;
  CLM_EmptyLanguageStruct((_QWORD *)a1, (uint64_t *)(a1 + 120), *(_DWORD *)(a1 + 128));
  *(_DWORD *)(a1 + 128) = 0;
  CLM_EmptyLanguageStruct((_QWORD *)a1, (uint64_t *)(a1 + 136), *(_DWORD *)(a1 + 144));
  *(_DWORD *)(a1 + 144) = 0;
  CLM_EmptyLanguageStruct((_QWORD *)a1, (uint64_t *)(a1 + 72), *(_DWORD *)(a1 + 80));
  *(_DWORD *)(a1 + 80) = 0;
  CLM_EmptyLanguageStruct((_QWORD *)a1, (uint64_t *)(a1 + 152), *(_DWORD *)(a1 + 160));
  *(_DWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  CLM_FreePreCompiledSplitWordRegEx((_QWORD *)a1);
  return CLM_FreePreCompiledReplacementRegEx((_QWORD *)a1);
}

uint64_t getObjcForThisApi_0(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char *__s1;

  result = 0;
  __s1 = 0;
  if (a1 && a2)
  {
    if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
      || !__s1
      || !*__s1
      || !strcmp(__s1, "internal"))
    {
      a1 = a2;
    }
    return *(_QWORD *)(a1 + 48);
  }
  return result;
}

uint64_t IRefCnt_ObjcLoadCLMData(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  BOOL v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  unsigned int v51;
  _BYTE *v52;
  char __s2[4];
  char v54[8];
  int v55;
  uint64_t v56;
  _QWORD *v57;
  int v58;
  unsigned __int8 v59;
  char __s1[256];
  char v61[241];
  char v62[21];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  _BYTE v76[27];
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v50 = 0;
  inited = InitRsrcFunction(a1, a2, &v50);
  if ((inited & 0x80000000) != 0)
    goto LABEL_38;
  v11 = 2347769856;
  v12 = (_QWORD *)heap_Calloc(*(_QWORD **)(v50 + 8), 1, 304);
  *(_QWORD *)(a5 + 48) = v12;
  if (!v12)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a5 + 24) + 32), (uint64_t)"CLM", 50000, 0, v13, v14, v15, v16, v49);
    v11 = 2347769866;
    goto LABEL_39;
  }
  *v12 = v50;
  v12[1] = a1;
  v12[2] = a2;
  if (strlen(a3) - 256 < 0xFFFFFFFFFFFFFEFFLL)
    goto LABEL_39;
  strcpy((char *)(*(_QWORD *)(a5 + 48) + 48), a3);
  v59 = 0;
  v58 = 0;
  v56 = 0;
  v57 = 0;
  v55 = 0;
  strcpy(v54, "CLMP");
  memset(v76, 0, sizeof(v76));
  v75 = 0u;
  v74 = 0u;
  v73 = 0u;
  v72 = 0u;
  v71 = 0u;
  v70 = 0u;
  v69 = 0u;
  v68 = 0u;
  v67 = 0u;
  v66 = 0u;
  v65 = 0u;
  v64 = 0u;
  v63 = 0u;
  *(_OWORD *)&v62[5] = 0u;
  v52 = 0;
  v17 = *(uint64_t **)(a5 + 48);
  inited = hlp_GetLanguage(*(_QWORD *)(*(_QWORD *)(a5 + 24) + 40), __s2);
  if ((inited & 0x80000000) != 0)
    goto LABEL_38;
  if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a5 + 24) + 40), (uint64_t)"clcpppipelinemode", &v52) & 0x80000000) != 0)
  {
    v18 = 1;
  }
  else
  {
    v18 = 1;
    if (v52)
      v18 = *v52 == 0;
  }
  v19 = *(_QWORD *)(*v17 + 24);
  if (v19)
    v20 = "clm";
  else
    v20 = "clm.dat";
  if (v19)
    v21 = 2;
  else
    v21 = 1;
  v22 = ssftriff_reader_ObjOpen((_WORD *)v17[1], v17[2], v21, v20, v54, 1031, (uint64_t *)&v57);
  if ((v22 & 0x80000000) == 0)
  {
    v30 = 0;
    while (!v30
         && (ssftriff_reader_OpenChunk((uint64_t)v57, &v58, (unsigned int *)&v55, &v56, v26, v27, v28, v29) & 0x80000000) == 0)
    {
      if (v58 ^ 0x504D4C43 | v59)
        goto LABEL_21;
      v51 = 256;
      v31 = ssftriff_reader_ReadStringZ((uint64_t)v57, v56, v55, 0, __s1, &v51);
      if ((v31 & 0x80000000) != 0)
        goto LABEL_42;
      if (!strstr(__s1, __s2))
      {
LABEL_21:
        v30 = 0;
      }
      else
      {
        v31 = ssftriff_reader_DetachChunkData((uint64_t)v57, v17 + 3, v17 + 4, v32, v33, v34, v35, v36);
        if ((v31 & 0x80000000) != 0)
        {
LABEL_42:
          v11 = v31;
          ssftriff_reader_CloseChunk((uint64_t)v57);
          ssftriff_reader_ObjClose(v57, v42, v43, v44, v45, v46, v47, v48);
          goto LABEL_39;
        }
        v37 = v51 | 0xFFFFFFFC;
        if ((v51 & 3) == 0)
          v37 = 0;
        v38 = v51 - v37;
        v17[4] += v38;
        v30 = 1;
        *((_DWORD *)v17 + 10) = v55 - v38;
        *((_DWORD *)v17 + 11) = 1;
      }
      v39 = ssftriff_reader_CloseChunk((uint64_t)v57);
      if ((v39 & 0x80000000) != 0)
      {
        v11 = v39;
        ssftriff_reader_ObjClose(v57, v23, v24, v25, v26, v27, v28, v29);
        v17[3] = 0;
        goto LABEL_39;
      }
    }
    v11 = ssftriff_reader_ObjClose(v57, v23, v24, v25, v26, v27, v28, v29);
    if ((v11 & 0x80000000) != 0)
      goto LABEL_39;
    goto LABEL_33;
  }
  if (v18)
  {
    v11 = v22;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a5 + 24) + 32), (uint64_t)"CLM", 30006, "%s", v26, v27, v28, v29, "clm.dat not found");
    goto LABEL_39;
  }
  strcpy(v62, "clm/");
  __strcat_chk();
  inited = brokeraux_ComposeBrokerString(*(_QWORD *)(a5 + 24), v62, 0, 1, __s2, 0, 0, v61, 0x100uLL);
  if ((inited & 0x80000000) != 0
    || (inited = brk_DataOpenEx(*(_QWORD *)(*v17 + 24), (uint64_t)v61, 1, (uint64_t)(v17 + 3)),
        (inited & 0x80000000) != 0))
  {
LABEL_38:
    v11 = inited;
  }
  else
  {
    *((_DWORD *)v17 + 10) = 0;
    v11 = brk_DataMapEx(*(_QWORD *)(*v17 + 24), v17[3], 0, (uint64_t)(v17 + 5), (uint64_t)(v17 + 4));
    if ((v11 & 0x80000000) == 0)
    {
LABEL_33:
      *(_QWORD *)(a4 + 32) = *(_QWORD *)(a5 + 48);
      return v11;
    }
    brk_DataClose(*(_QWORD *)(*v17 + 24), v17[3]);
  }
LABEL_39:
  v40 = *(_QWORD *)(a5 + 48);
  if (v40)
  {
    heap_Free(*(_QWORD **)(v50 + 8), v40);
    *(_QWORD *)(a5 + 48) = 0;
  }
  return v11;
}

uint64_t IRefCnt_ObjcUnloadCLMData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = *(_QWORD *)(a3 + 32);
  if (v8)
  {
    if (*(_DWORD *)(v8 + 44))
    {
      ssftriff_reader_ReleaseChunkData(*(_QWORD **)(v8 + 24), a2, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      brk_DataUnmap(*(_QWORD *)(*(_QWORD *)v8 + 24), *(_QWORD *)(v8 + 24), *(_QWORD *)(v8 + 32));
      brk_DataClose(*(_QWORD *)(*(_QWORD *)v8 + 24), *(_QWORD *)(v8 + 24));
    }
    *(_QWORD *)(v8 + 24) = 0;
    *(_QWORD *)(v8 + 32) = 0;
    *(_DWORD *)(v8 + 40) = 0;
    heap_Free(*(_QWORD **)(*(_QWORD *)v8 + 8), v8);
  }
  return 0;
}

uint64_t CLM_LoadRules(uint64_t a1, uint64_t a2, unsigned int a3, int a4, unsigned int *a5)
{
  uint64_t *v9;
  uint64_t *v10;
  unsigned int *v11;
  unsigned int *v12;
  uint64_t result;
  int v14;

  if (a4)
    v9 = (uint64_t *)(a1 + 120);
  else
    v9 = (uint64_t *)(a1 + 88);
  if (a4)
    v10 = (uint64_t *)(a1 + 136);
  else
    v10 = (uint64_t *)(a1 + 104);
  if (a4)
    v11 = (unsigned int *)(a1 + 128);
  else
    v11 = (unsigned int *)(a1 + 96);
  if (a4)
    v12 = (unsigned int *)(a1 + 144);
  else
    v12 = (unsigned int *)(a1 + 112);
  result = CLM_EnumerateLanguages(a1, v9, v11, 0, a2, a3, *a5);
  if ((result & 0x80000000) == 0)
  {
    if ((CLM_FindSeperationRecord(a2, a3, a5) & 0x80000000) != 0)
    {
      return 2347777666;
    }
    else
    {
      v14 = CLM_EnumerateLanguages(a1, v10, v12, 0, a2, a3, *a5);
      return v14 & (v14 >> 31);
    }
  }
  return result;
}

uint64_t CLM_GetForeignLoanPhonemeSets(uint64_t a1, int a2, _WORD *a3, _QWORD *a4)
{
  int v7;
  uint64_t result;

  v7 = safeh_HandleCheck(a1, a2, 63000, 216);
  result = 2347769864;
  if ((v7 & 0x80000000) == 0)
  {
    if (a1)
    {
      result = 0;
      *a3 = *(_WORD *)(a1 + 204);
      *a4 = *(_QWORD *)(a1 + 208);
    }
  }
  return result;
}

uint64_t fe_normout_ObjClose(_QWORD *a1, int a2)
{
  uint64_t result;
  uint64_t v4;

  result = safeh_HandleCheck((uint64_t)a1, a2, 62387, 120);
  if ((result & 0x80000000) != 0)
    return 2340429832;
  if (a1)
  {
    v4 = a1[14];
    if (v4)
      heap_Free(*(_QWORD **)(*a1 + 8), v4);
    a1[14] = 0;
    objc_ReleaseObject(*(_QWORD *)(*a1 + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(_QWORD *)(*a1 + 48), (uint64_t)"FE_DEPES");
    objc_ReleaseObject(*(_QWORD *)(*a1 + 48), (uint64_t)"FE_DCTLKP");
    heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_normout_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result;

  result = safeh_HandleCheck(a1, a2, 62387, 120);
  if ((result & 0x80000000) != 0)
    return 2340429832;
  if (a1)
    return fe_normout_get_fecfg(a1);
  return result;
}

uint64_t fe_normout_get_fecfg(uint64_t a1)
{
  uint64_t result;
  char v3;
  __int16 v4;
  _BYTE **v5;

  v5 = 0;
  v4 = 0;
  v3 = 0;
  *(_QWORD *)(a1 + 104) = 0;
  result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE ***, __int16 *, char *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "usetntag", &v5, &v4, &v3);
  if ((result & 0x80000000) == 0)
  {
    if (v4 == 1 && v5 && **v5 == 49)
      *(_DWORD *)(a1 + 104) = 1;
    v4 = 0;
    result = (*(uint64_t (**)(_QWORD, _QWORD, const char *, const char *, _BYTE ***, __int16 *, char *))(*(_QWORD *)(a1 + 56) + 96))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), "fecfg", "mdesegpos_morpheme_processing", &v5, &v4, &v3);
    if ((result & 0x80000000) == 0 && v4 == 1 && v5 && **v5 == 49)
      *(_DWORD *)(a1 + 108) = 1;
  }
  return result;
}

uint64_t fe_normout_ProcessStart(uint64_t a1, int a2)
{
  uint64_t result;

  LODWORD(result) = safeh_HandleCheck(a1, a2, 62387, 120);
  if ((int)result >= 0)
    return result;
  else
    return 2340429832;
}

uint64_t fe_normout_Process(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  uint64_t v31;
  _BOOL4 v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE *v44;
  _BYTE *v45;
  _BYTE *v46;
  _BYTE *v47;
  _BYTE *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int16 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int16 v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int16 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int16 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned __int16 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  unint64_t v87;
  unsigned __int16 v88;
  unint64_t v89;
  unsigned __int16 v90;
  char *v91;
  unsigned __int16 v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  unsigned __int16 v100;
  _OWORD *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unsigned __int16 v114;
  int NextWord;
  __int16 v116;
  uint64_t v117;
  char *v118;
  char *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  void *v125;
  size_t v126;
  unsigned __int16 v127;
  unsigned __int16 v128;
  unsigned int v129;
  uint64_t v130;
  uint64_t v131;
  unsigned int v132;
  uint64_t v133;
  int *v134;
  int v135;
  uint64_t v136;
  unsigned int *v137;
  unsigned int v138;
  unsigned int v139;
  uint32x2_t v140;
  int v141;
  uint32x2_t v142;
  const char *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  __int16 v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unsigned int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  int v177;
  unsigned __int16 v178;
  unsigned __int16 v179;
  __int16 v180;
  unsigned __int16 v181;
  char *__dst;
  int v183;
  uint64_t v184;
  char *__src;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int16 v198;
  unsigned __int16 v199;
  unsigned __int16 v200;
  int v201;
  __int16 v202;
  int v203;
  uint64_t v204;
  int v205;
  int v206;
  int v207;
  int v208;
  unint64_t v209;
  char *v210;
  __int16 v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  int v217;
  char *__s;
  unsigned __int16 v219;
  int v220;
  unsigned int v221;
  unsigned __int16 v222;
  _QWORD v223[18];

  v223[16] = *MEMORY[0x1E0C80C00];
  __s = 0;
  v217 = 0;
  v215 = 0;
  v214 = 0;
  LOWORD(v213) = 0;
  v212 = 0;
  v211 = 0;
  v209 = 0;
  v210 = 0;
  v207 = 0;
  v206 = 0;
  v205 = 0;
  v202 = 0;
  v201 = 1;
  v200 = 1;
  v199 = 1;
  v198 = 0;
  v223[0] = 0x74756F6D726F6ELL;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62387, 120) & 0x80000000) != 0)
    return 2340429832;
  v216 = 0;
  HIWORD(v213) = 0;
  v208 = 0;
  v204 = 0;
  v203 = 0;
  v186 = 0u;
  v187 = 0u;
  v188 = 0u;
  v189 = 0u;
  v190 = 0u;
  v191 = 0u;
  v192 = 0u;
  v193 = 0u;
  v194 = 0u;
  v195 = 0u;
  v196 = 0u;
  v197 = 0u;
  *a5 = 1;
  v9 = (*(uint64_t (**)(_QWORD, _QWORD, int *, _QWORD))(a1[4] + 112))(a1[2], a1[3], &v203, 0);
  if ((v9 & 0x80000000) != 0)
    return v9;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a1[1] + 104))(a3, a4, 1, 0, (char *)&v217 + 2);
  if ((v10 & 0x80000000) == 0
    && ((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char *))(a1[1] + 184))(a3, a4, HIWORD(v217), 0, (char *)&v207 + 2) & 0x80000000) == 0&& HIWORD(v207) == 1)
  {
    v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char **, int *))(a1[1] + 176))(a3, a4, HIWORD(v217), 0, &__s, &v215);
    if ((v10 & 0x80000000) == 0 && (unsigned __int16)v215 >= 2u)
    {
      v11 = strlen(__s);
      v12 = (char *)heap_Calloc(*(_QWORD **)(*a1 + 8), 1, v11 + 1);
      if (!v12)
      {
        log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v13, v14, v15, v16, v170);
        return 2340429834;
      }
      v17 = (uint64_t)v12;
      strcpy(v12, __s);
      v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, char *))(a1[1] + 176))(a3, a4, HIWORD(v217), 1, &v204, (char *)&v216 + 2);
      if ((v18 & 0x80000000) == 0)
      {
        v23 = HIWORD(v216);
        v24 = *(_DWORD *)(v204 + 12);
        log_Markers((uint64_t)a1, (uint64_t)"Markers IN", v204, HIWORD(v216), v19, v20, v21, v22);
        v222 = 0;
        v220 = 0;
        v221 = 0;
        v219 = 0;
        v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a1[1] + 104))(a3, a4, 2, HIWORD(v217), &v222);
        v10 = v25;
        if ((v25 & 0x80000000) == 0)
        {
          v29 = v222;
          if (v222)
          {
            __src = (char *)v17;
            v30 = 0;
            while (1)
            {
              v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, char *))(a1[1] + 168))(a3, a4, v29, 0, 1, &v221, (char *)&v220 + 2);
              if ((v31 & 0x80000000) != 0)
                break;
              if (v221 > 0xA || ((1 << v221) & 0x610) == 0)
              {
                v36 = 0;
                v35 = v222;
              }
              else
              {
                v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(a1[1] + 168))(a3, a4, v222, 1, 1, &v220, (char *)&v220 + 2);
                if ((v31 & 0x80000000) != 0)
                  break;
                v31 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(a1[1] + 168))(a3, a4, v222, 2, 1, &v219, (char *)&v220 + 2);
                if ((v31 & 0x80000000) != 0)
                  break;
                v34 = (unsigned __int16)v220 > v30 || v219 > v30;
                v35 = v222;
                if (v34)
                {
                  v30 = v219;
                  v36 = 0;
                }
                else
                {
                  v36 = v222;
                }
              }
              v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(a1[1] + 120))(a3, a4, v35, &v222);
              if ((v31 & 0x80000000) != 0)
                break;
              if ((_DWORD)v36)
              {
                log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 1, 0, (uint64_t)"%s", v26, v27, v28, (uint64_t)"Dropping nested word record");
                v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 192))(a3, a4, v36);
                if ((v31 & 0x80000000) != 0)
                  break;
              }
              v29 = v222;
              if (!v222)
              {
                v17 = (uint64_t)__src;
                goto LABEL_40;
              }
            }
            v10 = v31;
            v143 = 0;
            v43 = 0;
            goto LABEL_121;
          }
        }
        if ((v25 & 0x80000000) != 0)
          goto LABEL_118;
LABEL_40:
        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v26, v27, v28, v170);
        *((_QWORD *)&v187 + 1) = &v200;
        *(_QWORD *)&v188 = &v199;
        *(_QWORD *)&v187 = &v207;
        *(_QWORD *)&v186 = a1;
        *((_QWORD *)&v189 + 1) = v17;
        *(_QWORD *)&v190 = 0;
        *((_QWORD *)&v190 + 1) = &v202;
        *(_QWORD *)&v191 = (char *)&v215 + 2;
        *((_QWORD *)&v188 + 1) = (char *)&v206 + 2;
        *(_QWORD *)&v189 = &v201;
        *((_QWORD *)&v191 + 1) = &v205;
        *(_QWORD *)&v192 = &v206;
        *((_QWORD *)&v192 + 1) = (char *)&v205 + 2;
        v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t (*)(uint64_t, uint64_t, _WORD *, uint64_t), uint64_t (*)(uint64_t, uint64_t, unsigned __int16 *, uint64_t *), _QWORD, uint64_t (*)(), __int128 *))(a1[1] + 288))(a3, a4, HIWORD(v217), getSentenceAndInsertedCGNLengthPre, getSentenceAndInsertedCGNLength, 0, getSentenceAndInsertedCGNLengthPost, &v186);
        if ((v18 & 0x80000000) == 0)
        {
          LOWORD(v217) = WORD4(v186);
          v38 = (_QWORD *)heap_Calloc(*(_QWORD **)(*a1 + 8), 1, (16 * (unsigned __int16)v207) | 1);
          v43 = (uint64_t)v38;
          if (v38)
          {
            *v38 = 0;
            v38[1] = 0;
            v44 = (_BYTE *)heap_Alloc(*(_QWORD *)(*a1 + 8), v199 + 128);
            a1[8] = v44;
            if (v44)
            {
              *v44 = 0;
              v45 = (_BYTE *)heap_Alloc(*(_QWORD *)(*a1 + 8), v200);
              a1[9] = v45;
              if (v45)
              {
                *v45 = 0;
                v46 = (_BYTE *)heap_Alloc(*(_QWORD *)(*a1 + 8), v200);
                a1[10] = v46;
                if (v46)
                {
                  *v46 = 0;
                  v47 = (_BYTE *)heap_Alloc(*(_QWORD *)(*a1 + 8), v199 + 128);
                  a1[11] = v47;
                  if (v47)
                  {
                    *v47 = 0;
                    if (!*((_DWORD *)a1 + 26))
                      goto LABEL_49;
                    v48 = (_BYTE *)heap_Alloc(*(_QWORD *)(*a1 + 8), v200);
                    a1[12] = v48;
                    if (v48)
                    {
                      *v48 = 0;
LABEL_49:
                      v201 = 1;
                      *((_QWORD *)&v194 + 1) = v43;
                      v49 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t (*)(uint64_t, uint64_t, _WORD *, uint64_t *), _QWORD, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t), __int128 *))(a1[1] + 288))(a3, a4, HIWORD(v217), 0, normOutFnc, 0, normOutFncPost, &v186);
                      if ((v49 & 0x80000000) == 0)
                      {
                        v183 = v24;
                        v184 = v23;
                        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"ORIG   : %s", v50, v51, v52, v17);
                        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v53, v54, v55, v172);
                        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L1: %s", v56, v57, v58, a1[8]);
                        v59 = strlen((const char *)a1[8]);
                        v49 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1[4] + 120))(a1[2], a1[3], 0, a1[8], v59);
                        if ((v49 & 0x80000000) == 0)
                        {
                          log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L2: %s", v60, v61, v62, a1[9]);
                          v63 = strlen((const char *)a1[9]);
                          v49 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(a1[4] + 120))(a1[2], a1[3], 1, a1[9], v63);
                          if ((v49 & 0x80000000) == 0)
                          {
                            log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L3: %s", v64, v65, v66, a1[10]);
                            v67 = strlen((const char *)a1[10]);
                            v49 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(a1[4] + 120))(a1[2], a1[3], 2, a1[10], v67);
                            if ((v49 & 0x80000000) == 0)
                            {
                              __src = (char *)v17;
                              log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L4: %s", v68, v69, v70, a1[11]);
                              v71 = strlen((const char *)a1[11]);
                              v72 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(a1[4] + 120))(a1[2], a1[3], 3, a1[11], v71);
                              if ((v72 & 0x80000000) == 0)
                              {
                                if (!*((_DWORD *)a1 + 26)
                                  || (log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L5: %s", v73, v74, v75, a1[12]), v76 = strlen((const char *)a1[12]), v72 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(a1[4] + 136))(a1[2], a1[3], 4, a1[12], v76), (v72 & 0x80000000) == 0))
                                {
                                  log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v73, v74, v75, v173);
                                  if (((*(uint64_t (**)(_QWORD, _QWORD, _QWORD *))(a1[4] + 80))(a1[2], a1[3], v223) & 0x80000000) != 0)
                                  {
                                    v10 = 0;
                                    goto LABEL_143;
                                  }
                                  v72 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char **, int *))(a1[4] + 128))(a1[2], a1[3], 0, &v210, &v208);
                                  if ((v72 & 0x80000000) == 0)
                                  {
                                    v210[(unsigned __int16)v208] = 0;
                                    log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"O1     : %s", v77, v78, v79, (uint64_t)v210);
                                    v72 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, unint64_t *, char *))(a1[4] + 128))(a1[2], a1[3], 3, &v209, (char *)&v208 + 2);
                                    if ((v72 & 0x80000000) == 0)
                                    {
                                      *(_BYTE *)(v209 + HIWORD(v208)) = 0;
                                      log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"O4     : %s", v80, v81, v82, v209);
                                      log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"ORIGL1 : %s", v83, v84, v85, v17);
                                      v86 = HIWORD(v208);
                                      if (HIWORD(v208))
                                      {
                                        v87 = 0;
                                        v88 = 0;
                                        do
                                        {
                                          v89 = v209;
                                          if (!strncmp((const char *)(v209 + v87), "▬", 3uLL)
                                            && strncmp(&v210[v88], "▬", 3uLL))
                                          {
                                            v90 = Utf8_LengthInUtf8chars(v89, v87);
                                            v88 = Utf8_LengthInBytes((unsigned __int8 *)v210, v90);
                                            memmove(&v210[v88 + 3], &v210[v88 + 1], (unsigned __int16)v208 - (unint64_t)v88);
                                            v91 = &v210[v88];
                                            *(_WORD *)v91 = -26910;
                                            v91[2] = -84;
                                            LOWORD(v208) = v208 + 2;
                                            v86 = HIWORD(v208);
                                          }
                                          ++v87;
                                          ++v88;
                                        }
                                        while (v87 < v86);
                                      }
                                      v92 = v208;
                                      if ((_WORD)v208)
                                      {
                                        v93 = 0;
                                        do
                                        {
                                          v94 = (unsigned __int16)v93;
                                          if (v210[(unsigned __int16)v93] == 126)
                                          {
                                            if ((unsigned __int16)v93 < v92)
                                            {
                                              do
                                              {
                                                v210[v94] = v210[v94 + 1];
                                                v92 = v208;
                                                ++v94;
                                              }
                                              while (v94 < (unsigned __int16)v208);
                                            }
                                            LOWORD(v208) = --v92;
                                            --v93;
                                          }
                                          ++v93;
                                        }
                                        while ((unsigned __int16)v93 < v92);
                                      }
                                      v210[v92] = 0;
                                      __dst = (char *)heap_Calloc(*(_QWORD **)(*a1 + 8), 1, (unsigned __int16)v215 + 1);
                                      if (!__dst)
                                      {
                                        log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v95, v96, v97, v98, v174);
                                        v143 = 0;
                                        v144 = 0;
                                        v10 = 2340429834;
                                        goto LABEL_122;
                                      }
                                      v99 = strcpy(__dst, __src);
                                      v100 = strlen(v99);
                                      v101 = (_OWORD *)a1[14];
                                      *v101 = 0u;
                                      v101[1] = 0u;
                                      v101[2] = 0u;
                                      v101[3] = 0u;
                                      v101[4] = 0u;
                                      v101[5] = 0u;
                                      v101[6] = 0u;
                                      v101[7] = 0u;
                                      v102 = fe_normout_split_words(a1, a3, a4, v210, a1[14], (unsigned __int16 *)&v212);
                                      if ((v102 & 0x80000000) != 0)
                                        goto LABEL_154;
                                      v102 = fe_normout_split_words(a1, a3, a4, __src, 0, (unsigned __int16 *)&v212 + 1);
                                      if ((v102 & 0x80000000) != 0)
                                        goto LABEL_154;
                                      log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v103, v104, v105, v174);
                                      v106 = (unsigned __int16)v212;
                                      v107 = HIWORD(v212);
                                      log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"comparing O1 (%d words) and ORIGL1 (%d words) ", v108, v109, v110, (unsigned __int16)v212);
                                      if (v107 != v106)
                                      {
                                        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"Mismatch number of orthographic words and number of phonetic words : abandon processing", v111, v112, v113, v175);
                                        v10 = 0;
LABEL_155:
                                        v144 = 0;
LABEL_156:
                                        v143 = __dst;
                                        goto LABEL_122;
                                      }
                                      v213 = 0;
                                      v114 = v215;
                                      if (!(_WORD)v215)
                                      {
                                        v180 = 0;
LABEL_147:
                                        log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v111, v112, v113, v175);
                                        v198 = 0;
                                        LOWORD(v212) = 0;
                                        v197 = (unint64_t)__dst;
                                        *(_QWORD *)&v193 = &v212;
                                        *((_QWORD *)&v193 + 1) = &v211;
                                        *(_QWORD *)&v195 = 0;
                                        *(_QWORD *)&v194 = &v198;
                                        v102 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t (*)(uint64_t, uint64_t, _WORD *, uint64_t), _QWORD, _QWORD, __int128 *))(a1[1] + 288))(a3, a4, HIWORD(v217), 0, MvToEqWordRecUpdFieldsFnc, 0, 0, &v186);
                                        if ((v102 & 0x80000000) == 0)
                                        {
                                          v144 = *((_QWORD *)&v197 + 1);
                                          v150 = v197;
                                          v151 = strlen((const char *)v197);
                                          v152 = a4;
                                          v143 = (const char *)v197;
                                          v153 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, int *))(a1[1] + 160))(a3, v152, HIWORD(v217), 0, (unsigned __int16)(v151 + 1), v197, &v216);
                                          if ((v153 & 0x80000000) != 0)
                                          {
                                            v10 = v153;
                                          }
                                          else
                                          {
                                            log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"new SE_TEXT : %s", v154, v155, v156, v150);
                                            log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v157, v158, v159, v176);
                                            if ((_WORD)v207)
                                            {
                                              v163 = 0;
                                              v164 = v43 + 14;
                                              do
                                              {
                                                v165 = *(unsigned __int16 *)(v164 - 14);
                                                v164 += 16;
                                                log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"WORDREC[%d] %d,%d --> %d,%d", v160, v161, v162, v165);
                                                ++v163;
                                              }
                                              while (v163 < (unsigned __int16)v207);
                                            }
                                            *(_DWORD *)(v204 + 16) = (unsigned __int16)strlen(v143);
                                            v203 += v180;
                                            v10 = (*(uint64_t (**)(_QWORD, _QWORD))(a1[4] + 104))(a1[2], a1[3]);
                                            if ((v10 & 0x80000000) == 0)
                                              log_Markers((uint64_t)a1, (uint64_t)"Markers OUT", v204, v184, v166, v167, v168, v169);
                                          }
                                          goto LABEL_122;
                                        }
                                        goto LABEL_154;
                                      }
                                      v180 = 0;
                                      v181 = 0;
                                      v177 = v100;
                                      while (1)
                                      {
                                        if (getNextWord((_WORD *)&v213 + 1, (_WORD *)&v214 + 1, (uint64_t)__src, v114))
                                        {
                                          NextWord = getNextWord(&v213, &v214, (uint64_t)v210, (unsigned __int16)v208);
                                          v116 = HIWORD(v213);
                                          if (NextWord)
                                          {
                                            v117 = (unsigned __int16)v213;
                                            log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"COMPARE WORD[%d] \"%s\" and \"%s\"", v111, v112, v113, v181);
                                            if (strcmp(&__src[HIWORD(v213)], &v210[v117]))
                                            {
                                              log_OutText(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"   UPDATE WORD[%d] \"%s\" and \"%s\"", v111, v112, v113, v181);
                                              v118 = v210;
                                              v119 = strstr(&v210[v117], "▲");
                                              if (v119)
                                              {
                                                v120 = 0;
                                                while (1)
                                                {
                                                  *((_QWORD *)&v195 + 1) = v119;
                                                  *(_QWORD *)&v196 = v120;
                                                  *((_QWORD *)&v196 + 1) = (char *)&v213 + 2;
                                                  v102 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t (*)(uint64_t, uint64_t, unsigned __int16 *, uint64_t), __int128 *))(a1[1] + 280))(a3, a4, &v217, updateWordRecFnc, &v186);
                                                  if ((v102 & 0x80000000) != 0)
                                                    break;
                                                  v125 = (void *)*((_QWORD *)&v195 + 1);
                                                  v120 = v196;
                                                  HIWORD(v213) = **((_WORD **)&v196 + 1);
                                                  **((_BYTE **)&v195 + 1) = 0;
                                                  if (!v120)
                                                  {
                                                    log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43001, "%s%s", v121, v122, v123, v124, "message");
                                                    v144 = 0;
                                                    v10 = 2340429831;
                                                    goto LABEL_156;
                                                  }
                                                  v126 = strlen((const char *)(v120 + 3));
                                                  memmove(v125, (const void *)(v120 + 3), v126 + 1);
                                                  v118 = v210;
                                                  v119 = strstr(&v210[v117], "▲");
                                                  if (!v119)
                                                    goto LABEL_86;
                                                }
LABEL_154:
                                                v10 = v102;
                                                goto LABEL_155;
                                              }
LABEL_86:
                                              v127 = strlen(&v118[v117]);
                                              v128 = strlen(&__src[HIWORD(v213)]);
                                              v178 = strlen(__dst);
                                              v179 = v127;
                                              v129 = v127;
                                              if (v127 > v128)
                                              {
                                                v130 = (unsigned __int16)(v127 - v128 + v178);
                                                v131 = heap_Realloc(*(uint64_t **)(*a1 + 8), (uint64_t)__dst, (v130 + 1));
                                                if (!v131)
                                                {
                                                  v144 = 0;
                                                  v10 = 2340429834;
                                                  goto LABEL_156;
                                                }
                                                *(_BYTE *)(v131 + v130) = 0;
                                                __dst = (char *)v131;
                                              }
                                              v132 = v129 - v128;
                                              if (v129 == v128)
                                              {
                                                memcpy(&__dst[HIWORD(v213) + (uint64_t)v180], &v210[(unsigned __int16)v213], v179);
                                                goto LABEL_106;
                                              }
                                              memmove(&__dst[v129 + v180 + HIWORD(v213)], &__dst[v128 + HIWORD(v213) + v180], v177 - (v128 + HIWORD(v213)));
                                              memcpy(&__dst[HIWORD(v213) + (uint64_t)v180], &v210[(unsigned __int16)v213], v179);
                                              updateWordRecs((uint64_t)a1, a3, a4, v43, (unsigned __int16)v207, HIWORD(v213), v128, v179);
                                              if ((_DWORD)v184)
                                              {
                                                v133 = 0;
                                                v134 = (int *)(v204 + 12);
                                                while (1)
                                                {
                                                  v135 = *v134;
                                                  v134 += 8;
                                                  if (v135 - v183 > (unsigned __int16)(HIWORD(v213) + v180))
                                                    break;
                                                  if (v184 == ++v133)
                                                    goto LABEL_106;
                                                }
                                              }
                                              else
                                              {
                                                LOWORD(v133) = 0;
                                              }
                                              if (v184 > (unsigned __int16)v133)
                                              {
                                                v136 = v204;
                                                v133 = (unsigned __int16)v133;
                                                v137 = (unsigned int *)(v204 + 32 * (unsigned __int16)v133 + 12);
                                                do
                                                {
                                                  if (v133)
                                                  {
                                                    v138 = v132 + *v137;
                                                    if (*(_DWORD *)(v136 + 32 * (v133 - 1) + 12) > v138)
                                                      goto LABEL_105;
                                                  }
                                                  else
                                                  {
                                                    v138 = v132 + *(_DWORD *)(v136 + 12);
                                                  }
                                                  *v137 = v138;
LABEL_105:
                                                  ++v133;
                                                  v137 += 8;
                                                }
                                                while (v184 != v133);
                                              }
LABEL_106:
                                              v180 += v179 - v128;
                                              if (v129 < v128 && (int)(v128 - v129) >= 1)
                                              {
                                                v139 = 0;
                                                v140 = (uint32x2_t)vdup_n_s32(v128 - v129 - 1);
                                                v141 = v178 - 1;
                                                do
                                                {
                                                  v142 = vcge_u32(v140, (uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v139), (int8x8_t)0x100000000));
                                                  if ((v142.i8[0] & 1) != 0)
                                                    __dst[v141] = 0;
                                                  if ((v142.i8[4] & 1) != 0)
                                                    __dst[v178 + (v139 ^ 0xFFFFFFFE)] = 0;
                                                  v139 += 2;
                                                  v141 -= 2;
                                                }
                                                while (((v128 - v129 + 1) & 0xFFFFFFFE) != v139);
                                              }
                                            }
                                            v116 = HIWORD(v214);
                                            LOWORD(v213) = v214;
                                            ++v181;
                                            v114 = v215;
                                          }
                                        }
                                        else
                                        {
                                          v116 = HIWORD(v213);
                                        }
                                        HIWORD(v213) = v116 + 1;
                                        if ((unsigned __int16)(v116 + 1) >= v114)
                                          goto LABEL_147;
                                      }
                                    }
                                  }
                                }
                              }
                              v10 = v72;
LABEL_143:
                              v143 = 0;
LABEL_121:
                              v144 = 0;
LABEL_122:
                              v17 = (uint64_t)__src;
                              goto LABEL_124;
                            }
                          }
                        }
                      }
                      v10 = v49;
                      v143 = 0;
LABEL_119:
                      v144 = 0;
LABEL_124:
                      heap_Free(*(_QWORD **)(*a1 + 8), v17);
                      if (v144)
                        heap_Free(*(_QWORD **)(*a1 + 8), v144);
                      if (v43)
                        heap_Free(*(_QWORD **)(*a1 + 8), v43);
                      if (v143)
                        heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v143);
                      v145 = a1[8];
                      if (v145)
                      {
                        heap_Free(*(_QWORD **)(*a1 + 8), v145);
                        a1[8] = 0;
                      }
                      v146 = a1[9];
                      if (v146)
                      {
                        heap_Free(*(_QWORD **)(*a1 + 8), v146);
                        a1[9] = 0;
                      }
                      v147 = a1[10];
                      if (v147)
                      {
                        heap_Free(*(_QWORD **)(*a1 + 8), v147);
                        a1[10] = 0;
                      }
                      v148 = a1[11];
                      if (v148)
                      {
                        heap_Free(*(_QWORD **)(*a1 + 8), v148);
                        a1[11] = 0;
                      }
                      v149 = a1[12];
                      if (v149)
                      {
                        heap_Free(*(_QWORD **)(*a1 + 8), v149);
                        a1[12] = 0;
                      }
                      return v10;
                    }
                  }
                }
              }
            }
          }
          log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v39, v40, v41, v42, v171);
          v143 = 0;
          v144 = 0;
          v10 = 2340429834;
          goto LABEL_124;
        }
      }
      v10 = v18;
LABEL_118:
      v143 = 0;
      v43 = 0;
      goto LABEL_119;
    }
  }
  return v10;
}

uint64_t log_Markers(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = log_OutText(*(_QWORD *)(*(_QWORD *)a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, a2, a6, a7, a8, v19);
  if (a4)
  {
    v15 = a4;
    v16 = a3 + 8;
    do
    {
      v17 = *(_QWORD *)(*(_QWORD *)a1 + 32);
      v18 = *(unsigned int *)(v16 - 8);
      if ((_DWORD)v18 == 0x4000)
        result = log_OutText(v17, (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"Marker [type=SYNC] Ref (%d,%d) Cur(%d,%d)", v12, v13, v14, *(unsigned int *)(v16 - 4));
      else
        result = log_OutText(v17, (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"Marker [type=%5u] Ref (%d,%d) Cur(%d,%d)", v12, v13, v14, v18);
      v16 += 32;
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t getSentenceAndInsertedCGNLengthPre(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4)
{
  *(_WORD *)(a4 + 8) = *a3;
  return 0;
}

uint64_t getSentenceAndInsertedCGNLength(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  _DWORD *v11;
  uint64_t v12;
  char *v13;
  BOOL v14;
  char *v15;
  char *__s;
  unsigned __int16 v18;
  int v19;
  unsigned int v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  __s = 0;
  v8 = *a4;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, char *))(*(_QWORD *)(*a4 + 8) + 168))(a1, a2, *a3, 0, 1, &v20, (char *)&v19 + 2);
  if ((v9 & 0x80000000) != 0)
    return v9;
  ++*(_WORD *)a4[2];
  v10 = v20;
  if (v20 <= 0xA && ((1 << v20) & 0x610) != 0)
  {
    v11 = (_DWORD *)a4[6];
    if (!*v11)
    {
      ++*(_WORD *)a4[3];
      ++*(_WORD *)a4[4];
    }
    *v11 = 0;
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(v8 + 8)
                                                                                               + 168))(a1, a2, *a3, 1, 1, &v19, (char *)&v19 + 2);
    if ((v12 & 0x80000000) != 0)
      return v12;
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(*(_QWORD *)(v8 + 8) + 168))(a1, a2, *a3, 2, 1, &v18, (char *)&v19 + 2);
    if ((v9 & 0x80000000) != 0)
      return v9;
    *(_WORD *)a4[3] += Utf8_LengthInUtf8chars(a4[7] + (unsigned __int16)v19, v18 - (unsigned __int16)v19);
    *(_WORD *)a4[4] = v18 + *(_WORD *)a4[4] - v19;
    v10 = v20;
  }
  if (v10 == 7)
  {
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(v8 + 8) + 176))(a1, a2, *a3, 4, &__s, (char *)&v19 + 2);
    if ((v9 & 0x80000000) != 0)
      return v9;
    v13 = __s;
    *(_WORD *)a4[4] += strlen(__s) + 6;
    *(_WORD *)a4[3] += strlen(v13) + 2;
    v10 = v20;
  }
  if (*(_DWORD *)(*a4 + 104))
    v14 = v10 == 6;
  else
    v14 = 0;
  if (v14)
  {
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(v8 + 8) + 176))(a1, a2, *a3, 4, &__s, (char *)&v19 + 2);
    if ((v9 & 0x80000000) == 0)
    {
      v15 = __s;
      *(_WORD *)a4[3] = *(_WORD *)a4[3] + 2 * strlen(__s) - 2;
      *(_WORD *)a4[4] = *(_WORD *)a4[4] + 2 * strlen(v15) - 2;
    }
  }
  return v9;
}

uint64_t getSentenceAndInsertedCGNLengthPost()
{
  return 0;
}

uint64_t normOutFnc(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t BacktransPOS;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned int v16;
  const char *v17;
  unsigned int v18;
  size_t v19;
  size_t v20;
  const char *v21;
  const char *v22;
  size_t v23;
  int v24;
  const char *v25;
  const char *v26;
  size_t v27;
  const char *v28;
  const char *v29;
  size_t v30;
  size_t v31;
  int v32;
  unsigned int v33;
  __int16 v34;
  unsigned __int16 v35;
  int v36;
  uint64_t v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  unsigned int v52;
  char *v53;
  const char *v54;
  size_t v55;
  size_t v56;
  const char *v57;
  const char *v58;
  size_t v59;
  int v60;
  const char *v61;
  const char *v62;
  size_t v63;
  const char *v64;
  const char *v65;
  size_t v66;
  size_t v67;
  unsigned __int16 v69;
  uint64_t v70;
  char *__s;
  char *v72;
  char *__s2;
  __int16 v74;
  _BOOL4 v75;
  unsigned __int16 v76;
  int v77;
  unsigned int v78;

  v6 = a2;
  v77 = 0;
  v78 = 0;
  v76 = 0;
  v75 = 0;
  v72 = 0;
  __s2 = 0;
  __s = 0;
  v8 = *a4;
  *(_WORD *)(a4[17] + 16 * *(unsigned __int16 *)a4[10]) = *a3;
  BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, char *))(*(_QWORD *)(v8 + 8) + 168))(a1, a2, (unsigned __int16)*a3, 0, 1, &v78, (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0)
    return BacktransPOS;
  *(_DWORD *)(a4[17] + 16 * *(unsigned __int16 *)a4[10] + 4) = v78;
  BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, int *, char *))(*(_QWORD *)(v8 + 8) + 168))(a1, v6, (unsigned __int16)*a3, 1, 1, &v77, (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0)
    return BacktransPOS;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(*(_QWORD *)(v8 + 8) + 168))(a1, v6, (unsigned __int16)*a3, 2, 1, &v76, (char *)&v77 + 2);
  if ((v10 & 0x80000000) != 0)
    return v10;
  v11 = v77;
  v12 = a4[17];
  v13 = (unsigned __int16 *)a4[10];
  *(_WORD *)(v12 + 16 * *v13 + 12) = v77;
  *(_WORD *)(v12 + 16 * *v13 + 8) = v11;
  v14 = v76;
  *(_WORD *)(v12 + 16 * *v13 + 14) = v76;
  *(_WORD *)(v12 + 16 * *v13 + 10) = v14;
  v15 = Utf8_LengthInUtf8chars(a4[7] + (unsigned __int16)v77, v76 - (unsigned __int16)v77);
  v16 = v78;
  if (v78 <= 0xA && ((1 << v78) & 0x610) != 0)
  {
    *(_WORD *)a4[5] = v76;
    BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(v8 + 8)
                                                                                                 + 176))(a1, v6, (unsigned __int16)*a3, 5, &__s2, (char *)&v77 + 2);
    if ((BacktransPOS & 0x80000000) != 0)
      return BacktransPOS;
    BacktransPOS = com_mosynt_UseMosynt(*(_QWORD *)(v8 + 40), *(_QWORD *)(v8 + 48), *(_QWORD *)(v8 + 56), &v75);
    if ((BacktransPOS & 0x80000000) != 0)
      return BacktransPOS;
    if (v75)
    {
      BacktransPOS = com_mosynt_GetBacktransPOS(*(_QWORD *)(v8 + 40), *(_QWORD *)(v8 + 48), *(_QWORD *)(v8 + 56), __s2, &v74);
      if ((BacktransPOS & 0x80000000) != 0)
        return BacktransPOS;
      __s2 = (char *)&v74;
    }
    v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(v8 + 8) + 176))(a1, v6, (unsigned __int16)*a3, 6, &v72, (char *)&v77 + 2);
    if ((v10 & 0x80000000) != 0)
      return v10;
    if (*(_DWORD *)(v8 + 104) && !*(_DWORD *)a4[6])
    {
      v17 = (const char *)a4[8];
      if (v17 && (unsigned __int16)v77 != *(unsigned __int16 *)a4[13])
      {
        if ((unsigned __int16)v77 > *(unsigned __int16 *)a4[12])
        {
          v19 = *(unsigned __int16 *)a4[11];
          v20 = 2 * strlen(v17) - 2;
          *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 88;
          v21 = (const char *)a4[8];
          v22 = v21 + 1;
          v23 = strlen(v21);
          strncat(*(char **)(v8 + 96), v22, v23 - 2);
          if (v20 >= v19)
          {
            *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
            v28 = (const char *)a4[8];
            v29 = v28 + 1;
            v30 = strlen(v28);
            strncat(*(char **)(v8 + 96), v29, v30 - 2);
            v31 = *(unsigned __int16 *)a4[11];
            if (2 * strlen((const char *)a4[8]) - 2 > v31)
            {
              do
              {
                *(_WORD *)(*(_QWORD *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 126;
                *(_WORD *)(*(_QWORD *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 126;
                *(_WORD *)(*(_QWORD *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 126;
                *(_WORD *)(*(_QWORD *)(v8 + 88) + strlen(*(const char **)(v8 + 88))) = 126;
                LODWORD(v31) = v31 + 1;
              }
              while (2 * strlen((const char *)a4[8]) - 2 > (unsigned __int16)v31);
            }
          }
          else
          {
            v24 = 2 * strlen((const char *)a4[8]) - 2;
            if ((v24 & 0xFFFEu) < *(unsigned __int16 *)a4[11])
            {
              do
              {
                *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 126;
                ++v24;
              }
              while (*(unsigned __int16 *)a4[11] > (unsigned __int16)v24);
            }
            *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
            v25 = (const char *)a4[8];
            v26 = v25 + 1;
            v27 = strlen(v25);
            strncat(*(char **)(v8 + 96), v26, v27 - 2);
          }
          a4[8] = 0;
        }
      }
      else if (*(_WORD *)a4[9])
      {
        v18 = 0;
        do
        {
          *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 32;
          ++v18;
        }
        while (v18 < *(unsigned __int16 *)a4[9]);
      }
    }
    v32 = *(_DWORD *)a4[6];
    v33 = (unsigned __int16)v77;
    if (v32)
    {
      v34 = 0;
    }
    else
    {
      v35 = v33 - utf8_GetPreviousUtf8Offset(a4[7], (unsigned __int16)v77);
      strncat(*(char **)(v8 + 64), (const char *)(a4[7] + (unsigned __int16)v77 - v35), v35);
      *(_WORD *)(*(_QWORD *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 32;
      *(_WORD *)(*(_QWORD *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 32;
      strncat(*(char **)(v8 + 88), (const char *)(a4[7] + (unsigned __int16)v77 - v35), v35);
      v34 = 1;
      v33 = (unsigned __int16)v77;
    }
    strncat(*(char **)(v8 + 64), (const char *)(a4[7] + v33), v76 - (unint64_t)v33);
    strncat(*(char **)(v8 + 88), (const char *)(a4[7] + (unsigned __int16)v77), v76 - (unint64_t)(unsigned __int16)v77);
    v15 = Utf8_LengthInUtf8chars(a4[7] + (unsigned __int16)v77, v76 - (unsigned __int16)v77);
    v36 = v15;
    if (v15)
    {
      do
      {
        strncat(*(char **)(v8 + 72), __s2, 1uLL);
        strncat(*(char **)(v8 + 80), v72, 1uLL);
        --v36;
      }
      while (v36);
    }
    *(_WORD *)a4[9] = v15;
    if (*(_DWORD *)(v8 + 104))
    {
      v37 = a4[8];
      if (v37 && (unsigned __int16)v77 != *(unsigned __int16 *)a4[13])
      {
        *(_WORD *)a4[11] += v34 + v15;
      }
      else
      {
        if (!v32)
        {
          *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 32;
          v37 = a4[8];
        }
        if (v37)
          *(_WORD *)a4[11] = *(_WORD *)a4[9];
      }
    }
    *(_DWORD *)a4[6] = 0;
    v16 = v78;
  }
  if (v16 == 7)
  {
    v38 = strlen(*(const char **)(v8 + 64));
    v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char **, char *))(*(_QWORD *)(v8 + 8) + 176))(a1, v6, (unsigned __int16)*a3, 4, &__s, (char *)&v77 + 2);
    if ((v10 & 0x80000000) != 0)
      return v10;
    v70 = v6;
    v39 = strlen(__s);
    v40 = (unsigned __int16)Utf8_LengthInUtf8chars(*(_QWORD *)(v8 + 64), v38);
    v69 = Utf8_LengthInBytes(*(unsigned __int8 **)(v8 + 88), v40);
    if ((unsigned __int16)v77 >= *(unsigned __int16 *)a4[5])
    {
      *(_DWORD *)(*(_QWORD *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 11704034;
      strcat(*(char **)(v8 + 64), __s);
      v51 = 0;
      *(_DWORD *)(*(_QWORD *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 12359394;
      v52 = v39 + 2;
      do
      {
        *(_WORD *)(*(_QWORD *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 32;
        *(_WORD *)(*(_QWORD *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 32;
        *(_WORD *)(*(_QWORD *)(v8 + 88) + strlen(*(const char **)(v8 + 88))) = 126;
        ++v51;
      }
      while (v52 > (unsigned __int16)v51);
    }
    else
    {
      memmove((void *)(*(_QWORD *)(v8 + 64) + v38 + (unsigned __int16)v77 - *(unsigned __int16 *)a4[5] + v39 + 6), (const void *)(*(_QWORD *)(v8 + 64) + v38 - *(unsigned __int16 *)a4[5] + (unsigned __int16)v77), *(unsigned __int16 *)a4[5] - (unsigned __int16)v77 + 1);
      v41 = (char *)(*(_QWORD *)(v8 + 72) + v40 - v15);
      memmove(&v41[v39 + 2], v41, v15 + 1);
      v42 = (char *)(*(_QWORD *)(v8 + 80) + v40 - v15);
      memmove(&v42[v39 + 2], v42, v15 + 1);
      v43 = *(unsigned __int16 *)a4[5];
      v44 = (char *)(*(_QWORD *)(v8 + 88) + v69 - v43 + (unsigned __int16)v77);
      memmove(&v44[v39 + 2], v44, v43 - (unsigned __int16)v77 + 1);
      v45 = *(_QWORD *)(v8 + 64) + (unsigned __int16)(v38 - *(_WORD *)a4[5] + v77);
      *(_BYTE *)(v45 + 2) = -78;
      *(_WORD *)v45 = -26910;
      v46 = v40 - v15;
      *(_BYTE *)(*(_QWORD *)(v8 + 72) + v46) = 32;
      *(_BYTE *)(*(_QWORD *)(v8 + 80) + v46) = 32;
      *(_BYTE *)(*(_QWORD *)(v8 + 88) + v69 - (unint64_t)*(unsigned __int16 *)a4[5] + (unsigned __int16)v77) = 126;
      if (v39)
      {
        v47 = 0;
        v48 = v46 + 1;
        do
        {
          if (__s[v47])
            *(_BYTE *)(*(_QWORD *)(v8 + 64) + (int)(v38 + 3 + v47 - *(unsigned __int16 *)a4[5] + (unsigned __int16)v77)) = __s[v47];
          *(_BYTE *)(*(_QWORD *)(v8 + 72) + v48 + v47) = 32;
          *(_BYTE *)(*(_QWORD *)(v8 + 80) + v48 + v47) = 32;
          *(_BYTE *)(*(_QWORD *)(v8 + 88) + (int)(v69 + 1 + v47++ - *(unsigned __int16 *)a4[5] + (unsigned __int16)v77)) = 126;
        }
        while (v39 != v47);
      }
      v49 = *(_QWORD *)(v8 + 64) + (unsigned __int16)(v38 + v39 - *(_WORD *)a4[5] + v77 + 3);
      *(_BYTE *)(v49 + 2) = -68;
      *(_WORD *)v49 = -26910;
      v50 = v39 + 1 + v46;
      *(_BYTE *)(*(_QWORD *)(v8 + 72) + v50) = 32;
      *(_BYTE *)(*(_QWORD *)(v8 + 80) + v50) = 32;
      *(_BYTE *)(*(_QWORD *)(v8 + 88)
               + (unsigned __int16)v77
               - (unint64_t)*(unsigned __int16 *)a4[5]
               + v39
               + 1
               + v69) = 126;
    }
    v53 = __s;
    if (a4[8])
      *(_WORD *)a4[11] += strlen(__s) + 2;
    *(_WORD *)a4[9] += strlen(v53) + 2;
    v16 = v78;
    v6 = v70;
  }
  if (v16 != 6)
  {
LABEL_71:
    ++*(_WORD *)a4[10];
    return v10;
  }
  BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)(v8 + 8) + 168))(a1, v6, (unsigned __int16)*a3, 1, 1, a4[13], (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0)
    return BacktransPOS;
  if (*(_DWORD *)(v8 + 104))
  {
    v54 = (const char *)a4[8];
    if (v54)
    {
      if (*(unsigned __int16 *)a4[13] > *(unsigned __int16 *)a4[12])
      {
        v55 = *(unsigned __int16 *)a4[11];
        v56 = 2 * strlen(v54) - 2;
        *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 88;
        v57 = (const char *)a4[8];
        v58 = v57 + 1;
        v59 = strlen(v57);
        strncat(*(char **)(v8 + 96), v58, v59 - 2);
        if (v56 >= v55)
        {
          *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
          v64 = (const char *)a4[8];
          v65 = v64 + 1;
          v66 = strlen(v64);
          strncat(*(char **)(v8 + 96), v65, v66 - 2);
          v67 = *(unsigned __int16 *)a4[11];
          if (2 * strlen((const char *)a4[8]) - 2 > v67)
          {
            do
            {
              *(_WORD *)(*(_QWORD *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 126;
              *(_WORD *)(*(_QWORD *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 126;
              *(_WORD *)(*(_QWORD *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 126;
              *(_WORD *)(*(_QWORD *)(v8 + 88) + strlen(*(const char **)(v8 + 88))) = 126;
              LODWORD(v67) = v67 + 1;
            }
            while (2 * strlen((const char *)a4[8]) - 2 > (unsigned __int16)v67);
          }
        }
        else
        {
          v60 = 2 * strlen((const char *)a4[8]) - 2;
          if ((v60 & 0xFFFEu) < *(unsigned __int16 *)a4[11])
          {
            do
            {
              *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 126;
              ++v60;
            }
            while (*(unsigned __int16 *)a4[11] > (unsigned __int16)v60);
          }
          *(_WORD *)(*(_QWORD *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
          v61 = (const char *)a4[8];
          v62 = v61 + 1;
          v63 = strlen(v61);
          strncat(*(char **)(v8 + 96), v62, v63 - 2);
        }
        a4[8] = 0;
        *(_WORD *)a4[9] = 0;
      }
    }
  }
  BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, char *))(*(_QWORD *)(v8 + 8)
                                                                                                 + 176))(a1, v6, (unsigned __int16)*a3, 4, a4 + 8, (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0)
    return BacktransPOS;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)(v8 + 8)
                                                                                               + 168))(a1, v6, (unsigned __int16)*a3, 2, 1, a4[12], (char *)&v77 + 2);
  if ((v10 & 0x80000000) == 0)
  {
    *(_WORD *)a4[11] = *(_WORD *)a4[9];
    goto LABEL_71;
  }
  return v10;
}

uint64_t normOutFncPost(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char **v4;
  const char *v7;
  size_t v8;
  size_t v9;
  const char *v10;
  const char *v11;
  size_t v12;
  int v13;
  const char *v14;
  const char *v15;
  size_t v16;
  unsigned int v17;
  const char *v18;
  const char *v19;
  size_t v20;
  size_t v21;

  v4 = *(const char ***)a4;
  if (*(_DWORD *)(*(_QWORD *)a4 + 104) && !**(_DWORD **)(a4 + 48))
  {
    v7 = *(const char **)(a4 + 64);
    if (v7)
    {
      v8 = **(unsigned __int16 **)(a4 + 88);
      v9 = 2 * strlen(v7) - 2;
      *(_WORD *)&v4[12][strlen(v4[12])] = 88;
      v10 = *(const char **)(a4 + 64);
      v11 = v10 + 1;
      v12 = strlen(v10);
      strncat((char *)v4[12], v11, v12 - 2);
      if (v9 >= v8)
      {
        *(_WORD *)&v4[12][strlen(v4[12])] = 89;
        v18 = *(const char **)(a4 + 64);
        v19 = v18 + 1;
        v20 = strlen(v18);
        strncat((char *)v4[12], v19, v20 - 2);
        v21 = **(unsigned __int16 **)(a4 + 88);
        if (2 * strlen(*(const char **)(a4 + 64)) - 2 > v21)
        {
          do
          {
            *(_WORD *)&v4[8][strlen(v4[8])] = 126;
            *(_WORD *)&v4[9][strlen(v4[9])] = 126;
            *(_WORD *)&v4[10][strlen(v4[10])] = 126;
            *(_WORD *)&v4[11][strlen(v4[11])] = 126;
            LODWORD(v21) = v21 + 1;
          }
          while (2 * strlen(*(const char **)(a4 + 64)) - 2 > (unsigned __int16)v21);
        }
      }
      else
      {
        v13 = 2 * strlen(*(const char **)(a4 + 64)) - 2;
        if ((v13 & 0xFFFEu) < **(unsigned __int16 **)(a4 + 88))
        {
          do
          {
            *(_WORD *)&v4[12][strlen(v4[12])] = 126;
            ++v13;
          }
          while (**(unsigned __int16 **)(a4 + 88) > (unsigned __int16)v13);
        }
        *(_WORD *)&v4[12][strlen(v4[12])] = 89;
        v14 = *(const char **)(a4 + 64);
        v15 = v14 + 1;
        v16 = strlen(v14);
        strncat((char *)v4[12], v15, v16 - 2);
      }
    }
    else if (**(_WORD **)(a4 + 72))
    {
      v17 = 0;
      do
      {
        *(_WORD *)&v4[12][strlen(v4[12])] = 32;
        ++v17;
      }
      while (v17 < **(unsigned __int16 **)(a4 + 72));
    }
  }
  return 0;
}

uint64_t fe_normout_split_words(_QWORD *a1, uint64_t a2, uint64_t a3, char *__s, uint64_t a5, unsigned __int16 *a6)
{
  unsigned __int16 v10;
  unsigned int v11;
  int v12;
  unsigned __int16 v13;
  int v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  int v25;
  int v26;
  int v28;
  BOOL v29;
  unsigned int v30;
  int *v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  int v41;
  int v43;
  int v44;
  char *v45;
  int v46;
  uint64_t v47;
  unsigned __int16 v48;
  uint64_t result;
  unsigned __int16 *v50;
  unint64_t v51;
  unsigned __int16 v53;
  uint64_t v54;
  int v56;
  uint64_t v57;
  unsigned int v58;
  __int16 v59;
  unsigned __int16 v60;
  unsigned __int16 v61;
  unsigned __int16 v62;
  int v63;
  unsigned __int16 v64;
  unsigned __int16 v65;
  uint64_t v66;

  v10 = strlen(__s);
  *a6 = 0;
  v11 = v10;
  if (!v10)
  {
    v48 = 0;
    goto LABEL_85;
  }
  v53 = 0;
  v54 = a2;
  v50 = a6;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  do
  {
    v15 = &__s[(unsigned __int16)v14];
    v16 = *v15;
    if (v16 != 32 && v16 != 95 && strncmp(&__s[(unsigned __int16)v14], "▬", 3uLL))
      goto LABEL_79;
    if (a5 && v53 >= 0x80u)
    {
      v17 = heap_Realloc(*(uint64_t **)(*a1 + 8), a1[14], (v53 & 0xFF80u) + 128);
      if (!v17)
      {
        log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v18, v19, v20, v21, v50);
        return 2340429834;
      }
      a1[14] = v17;
      bzero((void *)(v17 + v53), (v53 & 0xFF80) + 128 - v53);
      v22 = a3;
    }
    else
    {
      v22 = a3;
      if (!a5)
        goto LABEL_67;
    }
    if (strncmp(&__s[(unsigned __int16)v14], "▬", 3uLL))
      goto LABEL_67;
    v64 = 0;
    v63 = 0;
    v62 = 0;
    v61 = -1;
    v60 = -1;
    v59 = 0;
    v58 = 11;
    v57 = 0;
    v56 = 0;
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int16 *))(a1[1] + 104))(v54, v22, 1, 0, &v64) & 0x80000000) != 0)goto LABEL_63;
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, __int16 *))(a1[1] + 152))(v54, v22, 2, v64, &v59) & 0x80000000) != 0)goto LABEL_63;
    if (!v59)
      goto LABEL_63;
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(a1[1] + 104))(v54, v22, 2, v64, (char *)&v63 + 2) & 0x80000000) != 0)goto LABEL_63;
    v23 = HIWORD(v63);
    if (!HIWORD(v63))
      goto LABEL_63;
    v24 = 0;
    while (1)
    {
      v25 = v61;
      v26 = v60;
      if (v61 != 0xFFFF && v60 != 0xFFFF)
        break;
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, unsigned int *, int *))(a1[1] + 168))(v54, v22, v23, 0, 1, &v58, &v63) & 0x80000000) != 0)goto LABEL_63;
      if (v58 > 0xA || ((1 << v58) & 0x610) == 0)
        goto LABEL_32;
      if (v24 == v13)
      {
        v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(a1[1] + 168))(v54, v22, HIWORD(v63), 1, 1, &v61, &v63);
        goto LABEL_30;
      }
      if (v13 + 1 == v24)
      {
        v28 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, int *))(a1[1] + 168))(v54, v22, HIWORD(v63), 2, 1, &v60, &v63);
LABEL_30:
        if (v28 < 0)
          goto LABEL_63;
      }
      ++v24;
LABEL_32:
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, char *))(a1[1] + 120))(v54, v22, HIWORD(v63), (char *)&v63 + 2) & 0x80000000) != 0)goto LABEL_63;
      v23 = HIWORD(v63);
      if (!HIWORD(v63))
      {
        v25 = v61;
        v26 = v60;
        break;
      }
    }
    v29 = v25 == 0xFFFF || v26 == 0xFFFF;
    if (!v29
      && ((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *, unsigned __int16 *))(a1[1] + 176))(v54, v22, v64, 1, &v57, &v62) & 0x80000000) == 0)
    {
      v30 = v62;
      if (v62 < 2u)
      {
        v34 = 1;
      }
      else
      {
        v31 = (int *)(v57 + 44);
        v32 = 1;
        while (1)
        {
          v33 = *v31;
          v31 += 8;
          if (v33 - *(_DWORD *)(v57 + 12) > v61)
            break;
          if (v62 == ++v32)
            goto LABEL_63;
        }
        v34 = (unsigned __int16)v32;
      }
      if (v34 < v62 && !v56)
      {
        v35 = v34 + 1;
        v36 = 32 * v34;
        while (1)
        {
          v37 = (unsigned int *)(v57 + v36);
          if (*(_DWORD *)(v57 + v36 + 12) - *(_DWORD *)(v57 + 12) >= v60)
            break;
          v38 = *v37;
          v39 = (char *)*((_QWORD *)v37 + 3);
          v66 = 0;
          v65 = 0;
          if (v38 <= 0x39)
          {
            if (v38 == 51)
            {
              v51 = v35;
              v40 = hlp_NLUStrFind(v39, "PUNC", &v66, &v65);
              v35 = v51;
              if (!v40)
                goto LABEL_62;
              v41 = v56;
              v30 = v62;
              goto LABEL_58;
            }
            if (((1 << v38) & 0x3C0010124001140) != 0)
              goto LABEL_62;
          }
          if ((_DWORD)v38 == 17)
          {
LABEL_62:
            v56 = 1;
            break;
          }
          v41 = 0;
LABEL_58:
          if (!v41)
          {
            v36 += 32;
            if (v35++ < v30)
              continue;
          }
          break;
        }
      }
    }
LABEL_63:
    if (!v56)
    {
      fe_normout_check_if_word_in_prompt((uint64_t)a1, v54, v22, v13, &v56);
      if (!v56)
      {
        fe_normout_check_if_word_in_prompt((uint64_t)a1, v54, v22, (unsigned __int16)(v13 + 1), &v56);
        if (!v56)
          *(_BYTE *)(a1[14] + v53++) = v13 + 1;
      }
    }
LABEL_67:
    if (!strncmp(&__s[(unsigned __int16)v14], "▬", 3uLL))
    {
      *v15 = 0;
      __s[v12 + 1] = 0;
      v14 += 2;
    }
    __s[(unsigned __int16)v14] = 0;
    v43 = v14 + 1;
    if (v11 > (unsigned __int16)(v14 + 1))
    {
      v44 = (unsigned __int16)(v14 + 1);
      do
      {
        v45 = &__s[(unsigned __int16)v43];
        v46 = *v45;
        if (v46 != 32 && v46 != 95 && strncmp(&__s[(unsigned __int16)v43], "▬", 3uLL))
          break;
        if (!strncmp(&__s[(unsigned __int16)v43], "▬", 3uLL))
        {
          *v45 = 0;
          __s[v44 + 1] = 0;
          v43 = v14 + 3;
          v47 = (unsigned __int16)(v14 + 3);
        }
        else
        {
          v47 = (unsigned __int16)v43;
        }
        v14 = v43;
        __s[v47] = 0;
        v44 = (unsigned __int16)++v43;
      }
      while (v11 > (unsigned __int16)v43);
    }
    ++v13;
LABEL_79:
    v12 = (unsigned __int16)++v14;
  }
  while (v11 > (unsigned __int16)v14);
  if (__s[(unsigned __int16)v14 - 1])
    v48 = v13 + 1;
  else
    v48 = v13;
  a6 = v50;
LABEL_85:
  result = 0;
  *a6 = v48;
  return result;
}

uint64_t getNextWord(_WORD *a1, _WORD *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  int v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned int i;
  int v11;

  *a2 = *a1;
  v4 = (unsigned __int16)*a1;
  if (v4 >= a4)
    return 0;
  while (!*(_BYTE *)(a3 + v4))
  {
    *a1 = ++v4;
    if (a4 == (unsigned __int16)v4)
      return 0;
  }
  v6 = (unsigned __int16)*a2;
  v7 = a3 + (unsigned __int16)(v6 + 1) + 1;
  do
  {
    v8 = (unsigned __int8 *)v7;
    *a2 = ++v6;
    if (a4 <= (unsigned __int16)v6)
      break;
    ++v7;
  }
  while (*(_BYTE *)(a3 + (unsigned __int16)v6));
  for (i = (unsigned __int16)v6 + 1; i < a4; i = v11 + 2)
  {
    if (*v8++)
      break;
    v11 = (unsigned __int16)v6++;
    *a2 = v6;
  }
  return 1;
}

uint64_t updateWordRecFnc(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t result;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  int v19;
  int v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  v8 = *(_QWORD **)a4;
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, int *, char *))(*(_QWORD *)(*(_QWORD *)a4 + 8)
                                                                                               + 168))(a1, a2, *a3, 0, 1, &v20, (char *)&v19 + 2);
  if ((result & 0x80000000) == 0)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, unsigned __int16 *, char *))(v8[1] + 168))(a1, a2, *a3, 1, 1, &v18, (char *)&v19 + 2);
    if ((result & 0x80000000) == 0 && v18 > **(unsigned __int16 **)(a4 + 168) && v20 == 7)
    {
      v11 = strstr((char *)(*(_QWORD *)(a4 + 152) + 3), "▼");
      *(_QWORD *)(a4 + 160) = v11;
      if (v11)
      {
        *v11 = 0;
        v16 = *(const char **)(a4 + 152);
        v17 = strlen(v16);
        LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, const char *, int *))(v8[1] + 160))(a1, a2, *a3, 4, v17, v16 + 3, &v19);
        if ((int)result >= 0)
          return 2340437532;
        else
          return result;
      }
      else
      {
        log_OutPublic(*(_QWORD *)(*v8 + 32), (uint64_t)"FE_NORMOUT", 43001, "%s%s", v12, v13, v14, v15, "message");
        return 2340429831;
      }
    }
  }
  return result;
}

uint64_t updateWordRecs(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, __int16 a8)
{
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  unsigned int v14;
  int v15;
  unsigned __int16 *v17;
  int v18;
  uint64_t v19;
  unsigned __int16 *v20;
  uint64_t v21;
  _WORD *v22;
  __int16 v23;
  unsigned __int16 *v24;
  _WORD *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _WORD *v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  _WORD *v42;
  _WORD __n[5];

  v39 = result;
  if (a5)
  {
    v8 = 0;
    v9 = (__int16)(a8 - a7);
    v10 = a7 + a6;
    v11 = a5;
    v35 = (_WORD *)(a4 + 14);
    v38 = a6;
    v37 = a4;
    v36 = a7 + a6;
    do
    {
      v12 = a4 + 16 * v8;
      v14 = *(_DWORD *)(v12 + 4);
      v13 = (_DWORD *)(v12 + 4);
      v15 = (1 << v14) & 0x610;
      if (v14 <= 0xA && v15 != 0)
      {
        v18 = *(unsigned __int16 *)(v12 + 8);
        v17 = (unsigned __int16 *)(v12 + 8);
        if (v18 == a6)
        {
          v19 = a4 + 16 * v8;
          v20 = (unsigned __int16 *)(v19 + 10);
          if (v10 == *(unsigned __int16 *)(v19 + 10))
          {
            v21 = 0;
            v23 = *(_WORD *)(v19 + 14);
            v22 = (_WORD *)(v19 + 14);
            *v22 = v23 + v9;
            v42 = v22;
            v24 = v22 - 1;
            v25 = v35;
            do
            {
              if (v8 != v21)
              {
                v26 = (unsigned __int16)*(v25 - 1);
                if (v26 > *v24)
                {
                  *(v25 - 1) = (v26 + v9) & ~((__int16)(v26 + v9) >> 15);
                  *v25 += v9;
                }
                v27 = *(_DWORD *)(v25 - 5);
                if (v27 <= 0xF && ((1 << v27) & 0x8060) != 0)
                {
                  v29 = *v17;
                  if (v29 >= (unsigned __int16)*(v25 - 3))
                  {
                    v30 = (unsigned __int16)*(v25 - 2);
                    if (v29 < v30 && v30 + 1 >= *v20)
                    {
                      if (v27 != 6
                        || (memset(__n, 0, sizeof(__n)),
                            result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _WORD *, _WORD *))(*(_QWORD *)(v39 + 8) + 176))(a2, a3, (unsigned __int16)*(v25 - 7), 4, &__n[1], __n), !__n[0])|| (result = strncmp(*(const char **)&__n[1], "_PR_", __n[0]), (v9 & 0x80000000) == 0)|| (_DWORD)result)
                      {
                        *v25 += v9;
                      }
                    }
                  }
                }
              }
              ++v21;
              v25 += 8;
            }
            while (v11 != v21);
            v31 = v8 + 1;
            a4 = v37;
            if (v8 + 1 < v11 && *v13 == 4)
            {
              v32 = v37 + 16 * v31;
              if (*(_DWORD *)(v32 + 4) == 16 && *(unsigned __int16 *)(v32 + 12) == *v24)
                *(_WORD *)(v37 + 16 * v31 + 14) = *v42;
            }
            a6 = v38;
            v10 = v36;
            if (v8)
            {
              if (*v13 == 4)
              {
                v33 = (v8 - 1);
                v34 = v37 + 16 * v33;
                if (*(_DWORD *)(v34 + 4) == 16 && *(unsigned __int16 *)(v34 + 12) == *v24)
                  *(_WORD *)(v37 + 16 * v33 + 14) = *v42;
              }
            }
          }
        }
      }
      ++v8;
    }
    while (v8 != v11);
  }
  return result;
}

