BOOL op_extract_gif_params(uint64_t a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  _BOOL8 result;

  result = op_is_gif (a1, a2);
  if (a2 >= 0xE && result)
  {
    *a3 = *(unsigned __int16 *)(a1 + 6);
    *a4 = *(unsigned __int16 *)(a1 + 8);
    *a5 = 24;
    *a6 = 1 << ((*(_BYTE *)(a1 + 10) & 7) + 1);
    *a7 = 1;
  }
  return result;
}

uint64_t op_strncasecmp(char *a1, char *a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;

  if (a3 < 1)
    return 0;
  v3 = a3;
  while (1)
  {
    v5 = *a1++;
    v4 = v5;
    v7 = *a2++;
    v6 = v7;
    if ((v4 - 97) < 0x1A)
      v4 -= 32;
    if ((v6 - 97) < 0x1A)
      v6 -= 32;
    v8 = (v4 - v6);
    if ((_DWORD)v8)
      break;
    if (!--v3)
      return 0;
  }
  return v8;
}

_QWORD *op_mem_stream_create(_OWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  if (a3 < 0)
    return 0;
  result = malloc(0x18uLL);
  if (result)
  {
    *a1 = OP_MEM_CALLBACKS;
    a1[1] = *(_OWORD *)off_24D294020;
    *result = a2;
    result[1] = a3;
    result[2] = 0;
  }
  return result;
}

uint64_t op_mem_read(_QWORD *a1, void *__dst, int a3)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;

  if (a3 < 1)
    return 0;
  v4 = a1[1];
  v5 = a1[2];
  v6 = v4 <= v5;
  v7 = v4 - v5;
  if (v6)
    return 0;
  if (v7 >= a3)
    v8 = a3;
  else
    v8 = v7;
  memcpy(__dst, (const void *)(*a1 + v5), (int)v8);
  a1[2] = v5 + (int)v8;
  return v8;
}

uint64_t op_mem_seek(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;

  if (a3 == 2)
  {
    v3 = *(_QWORD *)(a1 + 8);
LABEL_8:
    if (-v3 > a2 || (v3 ^ 0x7FFFFFFFFFFFFFFFLL) < a2)
      return 0xFFFFFFFFLL;
    a2 += v3;
LABEL_14:
    v5 = 0;
    *(_QWORD *)(a1 + 16) = a2;
    return v5;
  }
  if (a3 == 1)
  {
    v3 = *(_QWORD *)(a1 + 16);
    goto LABEL_8;
  }
  if (!a3 && (a2 & 0x8000000000000000) == 0)
    goto LABEL_14;
  return 0xFFFFFFFFLL;
}

uint64_t op_mem_tell(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t op_mem_close(void *a1)
{
  free(a1);
  return 0;
}

int *opus_fft(int *result, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  __int16 *v21;
  int *v22;
  int v23;
  int *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  __int16 *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int32x2_t *v47;
  __int16 *v48;
  __int16 *v49;
  uint64_t v50;
  int32x2_t *v51;
  int32x2_t *v52;
  uint32x2_t v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  __int32 v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int32x2_t *v82;
  __int16 *v83;
  __int16 *v84;
  __int16 *v85;
  int v86;
  int32x2_t *v87;
  int32x2_t *v88;
  int32x2_t v89;
  int32x2_t v90;
  int32x2_t v91;
  int32x2_t v92;
  int32x2_t v93;
  int32x2_t v94;
  int32x2_t v95;
  int32x2_t v96;
  int32x2_t v97;
  int32x2_t v98;
  int32x2_t v99;
  int32x2_t v100;
  int32x2_t v101;
  int32x2_t v102;
  int32x2_t v103;
  int32x2_t v104;
  int32x2_t v105;
  int32x2_t v106;
  int32x2_t v107;
  int32x2_t v108;
  int32x2_t v109;
  int32x2_t v110;
  int32x2_t v111;
  int32x2_t v112;
  int32x2_t v113;
  int32x2_t v114;
  int32x2_t v115;
  int32x2_t v116;
  int32x2_t v117;
  int32x2_t v118;
  int32x2_t v119;
  int32x2_t v120;
  int32x2_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  __int16 *v126;
  int v127;
  uint64_t v128;
  __int16 *v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  __int16 *v138;
  __int16 *v139;
  __int16 *v140;
  __int16 *v141;
  uint32x2_t *v142;
  int32x2_t v143;
  int32x2_t v144;
  uint32x2_t v145;
  uint32x2_t v146;
  uint32x2_t v147;
  uint32x2_t v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  __int16 *v162;
  int v163;
  int v164;
  __int32 v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  int v195;
  int v196;
  int *v197;
  int v198;
  int *v199;
  uint64_t v200;
  int v201;
  __int16 *v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  _DWORD *v218;
  uint32x2_t *v219;
  int *v220;
  _DWORD *v221;
  __int16 *v222;
  __int16 *v223;
  _DWORD v224[8];
  uint64_t v225;

  v225 = *MEMORY[0x24BDAC8D0];
  v3 = result[1];
  if (*result >= 1)
  {
    v4 = 0;
    do
    {
      *(_QWORD *)(a3 + 8 * *(__int16 *)(*((_QWORD *)result + 5) + 2 * v4)) = *(_QWORD *)(a2 + 8 * v4);
      ++v4;
    }
    while (v4 < *result);
  }
  v198 = v3 & ~(v3 >> 31);
  v5 = 1;
  v224[0] = 1;
  v6 = (unsigned __int16 *)result + 5;
  v7 = -1;
  v8 = 1;
  do
  {
    v8 *= (__int16)*(v6 - 1);
    v224[v5] = v8;
    v9 = *v6;
    v6 += 2;
    ++v5;
    v7 += 2;
  }
  while (v9 != 1);
  v201 = *((__int16 *)result + v7 + 4);
  v197 = (int *)(a3 + 4);
  v10 = v5 - 2;
  v11 = vdup_n_s32(0x5556u);
  v12 = vdup_n_s32(0x2AABu);
  v203 = a3;
  v199 = result;
  do
  {
    v13 = v201;
    v200 = v10;
    if (v10)
    {
      v14 = v10;
      v201 = SHIWORD(result[(int)v10 + 1]);
      v15 = v10;
    }
    else
    {
      v14 = 0;
      v15 = 0;
      v201 = 1;
    }
    switch(LOWORD(result[v14 + 2]))
    {
      case 2:
        v16 = v224[v15];
        if ((int)v16 >= 1)
        {
          v17 = 0;
          v18 = *((_QWORD *)v199 + 6) + 2;
          v19 = 2 * v13;
          v20 = v197;
          do
          {
            if (v13 >= 1)
            {
              v21 = (__int16 *)v18;
              v22 = v20;
              v23 = v13;
              do
              {
                v24 = &v22[v19];
                v25 = *(v22 - 1);
                v26 = *v22;
                v27 = v22[v19 - 1];
                v28 = v22[2 * v13];
                v29 = *(v21 - 1);
                v30 = v27 >> 17;
                v31 = (unsigned __int16)(v27 >> 1);
                v32 = *v21;
                v33 = v28 >> 17;
                v34 = (unsigned __int16)(v28 >> 1);
                v35 = ((v31 * v29) >> 15) - ((v34 * v32) >> 15) + 2 * (v30 * v29 - v33 * v32);
                v36 = ((v31 * v32) >> 15) + ((v34 * v29) >> 15) + 2 * (v33 * v29 + v30 * v32);
                *(v24 - 1) = (v25 >> 1) - v35;
                *v24 = (v26 >> 1) - v36;
                *(v22 - 1) = v35 + (v25 >> 1);
                *v22 = v36 + (v26 >> 1);
                v22 += 2;
                v21 += 2 * ((_DWORD)v16 << v198);
                --v23;
              }
              while (v23);
            }
            ++v17;
            v20 += 2 * v201;
          }
          while (v17 != v16);
        }
        break;
      case 3:
        v37 = v224[v15];
        if ((int)v37 >= 1)
        {
          v38 = 0;
          v39 = (int)((_DWORD)v37 << v198);
          v40 = *((_QWORD *)v199 + 6);
          v41 = *(__int16 *)(v40 + 4 * (int)v39 * (uint64_t)v13 + 2);
          v42 = 2 * v41;
          v43 = (__int16 *)(v40 + 2);
          v44 = 8 * v39;
          v45 = v13;
          v46 = 4 * v39;
          do
          {
            v47 = (int32x2_t *)(a3 + 8 * v38 * v201);
            v48 = v43;
            v49 = v43;
            v50 = v13;
            do
            {
              *v47 = (int32x2_t)vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*v47, 0x10uLL), v11), (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)*v47, (int8x8_t)0xFFFF0000FFFFLL), v12), 0xFuLL);
              v51 = &v47[v45];
              v47[v13] = (int32x2_t)vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(v47[v13], 0x10uLL), v11), (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v47[v13], (int8x8_t)0xFFFF0000FFFFLL), v12), 0xFuLL);
              v52 = &v47[2 * v13];
              v53 = vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*v52, 0x10uLL), v11), (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)*v52, (int8x8_t)0xFFFF0000FFFFLL), v12), 0xFuLL);
              *v52 = (int32x2_t)v53;
              v54 = *(v48 - 1);
              v55 = v47[v13].i32[0] >> 16;
              v56 = (unsigned __int16)v47[v13].i32[0];
              v57 = *v48;
              v58 = v47[v45].i32[1] >> 16;
              v59 = (unsigned __int16)v47[v45].i32[1];
              v60 = ((v56 * v54) >> 15) - ((v59 * v57) >> 15) + 2 * (v55 * v54 - v58 * v57);
              v61 = ((v59 * v54) >> 15) + ((v56 * v57) >> 15) + 2 * (v55 * v57 + v58 * v54);
              v62 = *(v49 - 1);
              v63 = *v49;
              v64 = ((v53.u16[0] * v62) >> 15)
                  - ((v53.u16[2] * v63) >> 15)
                  + 2 * ((v53.i32[0] >> 16) * v62 - (v53.i32[1] >> 16) * v63);
              v65 = ((v53.u16[0] * v63) >> 15)
                  + ((v53.u16[2] * v62) >> 15)
                  + 2 * ((v53.i32[1] >> 16) * v62 + (v53.i32[0] >> 16) * v63);
              v66 = v65 + v61;
              v67 = v61 - v65;
              v68 = v47->i32[1] - (v66 >> 1);
              v51->i32[0] = v47->i32[0] - ((v64 + v60) >> 1);
              v51->i32[1] = v68;
              v69 = ((v60 - v64) >> 16) * v42 + (((unsigned __int16)(v60 - v64) * v41) >> 15);
              v70 = (v67 >> 16) * v42 + (((unsigned __int16)v67 * v41) >> 15);
              v71 = v47->i32[1];
              v47->i32[0] += v64 + v60;
              v47->i32[1] = v71 + v66;
              ++v47;
              v72 = v51->i32[1] - v69;
              v52->i32[0] = v70 + v51->i32[0];
              v52->i32[1] = v72;
              LODWORD(v52) = v51->i32[0] - v70;
              v73 = v51->i32[1] + v69;
              v51->i32[0] = (int)v52;
              v51->i32[1] = v73;
              v49 = (__int16 *)((char *)v49 + v44);
              v48 = (__int16 *)((char *)v48 + v46);
              --v50;
            }
            while (v50);
            ++v38;
          }
          while (v38 != v37);
        }
        break;
      case 4:
        v74 = v224[v15];
        if ((int)v74 >= 1)
        {
          v75 = 0;
          v76 = (int)((_DWORD)v74 << v198);
          v77 = 2 * v13;
          v78 = *((_QWORD *)v199 + 6) + 2;
          v79 = 12 * v76;
          v80 = 4 * v76;
          v81 = 8 * v76;
          do
          {
            if (v13 >= 1)
            {
              v82 = (int32x2_t *)(a3 + 8 * v75 * v201);
              v83 = (__int16 *)v78;
              v84 = (__int16 *)v78;
              v85 = (__int16 *)v78;
              v86 = v13;
              do
              {
                v87 = &v82[v13];
                v88 = &v82[3 * v13];
                v89 = vshr_n_s32(*v87, 0x10uLL);
                v90 = (int32x2_t)vand_s8((int8x8_t)*v87, (int8x8_t)0xFFFF0000FFFFLL);
                v91 = vdup_n_s32(*v84);
                v92 = vmul_s32(vrev64_s32(v89), v91);
                v93 = vmul_s32(vrev64_s32(v90), v91);
                v94 = vdup_n_s32(*(v84 - 1));
                v95 = vmul_s32(v89, v94);
                v96 = vshr_n_s32(vmul_s32(v90, v94), 0xFuLL);
                v94.i32[0] = vsub_s32(v95, v92).u32[0];
                v94.i32[1] = vadd_s32(v95, v92).i32[1];
                v92.i32[0] = vsub_s32(v96, vshr_n_s32(v93, 0xFuLL)).u32[0];
                v92.i32[1] = vsra_n_s32(v96, v93, 0xFuLL).i32[1];
                v97 = vadd_s32(v92, vadd_s32(v94, v94));
                v98 = v82[v77];
                v99 = vshr_n_s32(v98, 0x10uLL);
                v100 = (int32x2_t)vand_s8((int8x8_t)v98, (int8x8_t)0xFFFF0000FFFFLL);
                v101 = vdup_n_s32(*v83);
                v102 = vmul_s32(vrev64_s32(v99), v101);
                v103 = vmul_s32(vrev64_s32(v100), v101);
                v104 = vdup_n_s32(*(v83 - 1));
                v105 = vmul_s32(v99, v104);
                v106 = vshr_n_s32(vmul_s32(v100, v104), 0xFuLL);
                v104.i32[0] = vsub_s32(v105, v102).u32[0];
                v104.i32[1] = vadd_s32(v105, v102).i32[1];
                v105.i32[0] = vsub_s32(v106, vshr_n_s32(v103, 0xFuLL)).u32[0];
                v105.i32[1] = vsra_n_s32(v106, v103, 0xFuLL).i32[1];
                v107 = vadd_s32(v105, vadd_s32(v104, v104));
                v108 = vshr_n_s32(*v88, 0x10uLL);
                v109 = (int32x2_t)vand_s8((int8x8_t)*v88, (int8x8_t)0xFFFF0000FFFFLL);
                v110 = vdup_n_s32(*v85);
                v111 = vmul_s32(vrev64_s32(v108), v110);
                v112 = vmul_s32(vrev64_s32(v109), v110);
                v113 = vdup_n_s32(*(v85 - 1));
                v114 = vmul_s32(v108, v113);
                v115 = vshr_n_s32(vmul_s32(v109, v113), 0xFuLL);
                v113.i32[0] = vsub_s32(v114, v111).u32[0];
                v113.i32[1] = vadd_s32(v114, v111).i32[1];
                v111.i32[0] = vsub_s32(v115, vshr_n_s32(v112, 0xFuLL)).u32[0];
                v111.i32[1] = vsra_n_s32(v115, v112, 0xFuLL).i32[1];
                v116 = vshr_n_s32(vadd_s32(v111, vadd_s32(v113, v113)), 2uLL);
                v117 = vshr_n_s32(vadd_s32(*v82, (int32x2_t)0x200000002), 2uLL);
                v118 = vsub_s32(v117, vshr_n_s32(v107, 2uLL));
                v119 = vsra_n_s32(v117, v107, 2uLL);
                v120 = vsub_s32(vshr_n_s32(v97, 2uLL), v116);
                v121 = vsra_n_s32(v116, v97, 2uLL);
                v82[v77] = vsub_s32(v119, v121);
                *v82++ = vadd_s32(v121, v119);
                v87->i32[0] = v120.i32[1] + v118.i32[0];
                v87->i32[1] = v118.i32[1] - v120.i32[0];
                v88->i32[0] = v118.i32[0] - v120.i32[1];
                v88->i32[1] = v120.i32[0] + v118.i32[1];
                v85 = (__int16 *)((char *)v85 + v79);
                v84 = (__int16 *)((char *)v84 + v80);
                v83 = (__int16 *)((char *)v83 + v81);
                --v86;
              }
              while (v86);
            }
            ++v75;
          }
          while (v75 != v74);
        }
        break;
      case 5:
        v206 = v224[v15];
        if ((int)v206 >= 1)
        {
          v122 = 0;
          v123 = (int)((_DWORD)v206 << v198);
          v124 = *((_QWORD *)v199 + 6);
          v125 = (int)v123 * (uint64_t)v13;
          v126 = (__int16 *)(v124 + 8 * v125);
          v127 = v126[1];
          v128 = *v126;
          v129 = (__int16 *)(v124 + 4 * v125);
          v130 = v129[1];
          v131 = *v129;
          v132 = a3 + 32 * v13;
          v204 = 8 * v201;
          v205 = v13;
          v202 = (__int16 *)(v124 + 2);
          v133 = a3 + 24 * v13;
          v134 = a3 + 8 * v13;
          v135 = a3;
          v136 = a3 + 16 * v13;
          v211 = 12 * v123;
          v212 = 8 * v13;
          v209 = 2 * v123;
          v210 = 4 * v123;
          v208 = 8 * v123;
          do
          {
            v207 = v122;
            if (v13 >= 1)
            {
              v137 = 0;
              v138 = v202;
              v139 = v202;
              v140 = v202;
              v141 = v202;
              v216 = v133;
              v217 = v132;
              v214 = v135;
              v215 = v134;
              v213 = v136;
              do
              {
                v222 = v140;
                v223 = v139;
                v142 = (uint32x2_t *)(v135 + v137);
                v219 = (uint32x2_t *)(v134 + v137);
                v143 = vdup_n_s32(0x3334u);
                v144 = vdup_n_s32(0x199Au);
                *v142 = vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*(int32x2_t *)(v135 + v137), 0x10uLL), v143), (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)(v135 + v137), (int8x8_t)0xFFFF0000FFFFLL), v144), 0xFuLL);
                v145 = vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*(int32x2_t *)(v134 + v137), 0x10uLL), v143), (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)(v134 + v137), (int8x8_t)0xFFFF0000FFFFLL), v144), 0xFuLL);
                *v219 = v145;
                v220 = (int *)(v133 + v137);
                v221 = (_DWORD *)(v136 + v137);
                v146 = vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*(int32x2_t *)(v136 + v137), 0x10uLL), v143), (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)(v136 + v137), (int8x8_t)0xFFFF0000FFFFLL), v144), 0xFuLL);
                *(uint32x2_t *)(v136 + v137) = v146;
                v218 = (_DWORD *)(v132 + v137);
                v147 = vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*(int32x2_t *)(v133 + v137), 0x10uLL), v143), (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)(v133 + v137), (int8x8_t)0xFFFF0000FFFFLL), v144), 0xFuLL);
                *(uint32x2_t *)(v133 + v137) = v147;
                v148 = vsra_n_u32((uint32x2_t)vmul_s32(vshr_n_s32(*(int32x2_t *)(v132 + v137), 0x10uLL), v143), (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)(v132 + v137), (int8x8_t)0xFFFF0000FFFFLL), v144), 0xFuLL);
                *(uint32x2_t *)(v132 + v137) = v148;
                v149 = *(v139 - 1);
                v150 = *v139;
                v151 = *(v140 - 1);
                v152 = *v140;
                v154 = *(_DWORD *)(v135 + v137);
                v153 = *(_DWORD *)(v135 + v137 + 4);
                v155 = -((v146.i32[1] >> 16) * v152);
                v156 = *(v141 - 1);
                v157 = ((v146.u16[0] * v151) >> 15) - ((v146.u16[2] * v152) >> 15);
                v158 = *v141;
                v159 = ((v145.u16[0] * v150) >> 15)
                     + ((v145.u16[2] * v149) >> 15)
                     + 2 * ((v145.i32[1] >> 16) * v149 + (v145.i32[0] >> 16) * v150);
                v160 = ((v146.u16[0] * v152) >> 15)
                     + ((v146.u16[2] * v151) >> 15)
                     + 2 * ((v146.i32[1] >> 16) * v151 + (v146.i32[0] >> 16) * v152);
                v161 = ((v147.u16[0] * v158) >> 15)
                     + ((v147.u16[2] * v156) >> 15)
                     + 2 * ((v147.i32[1] >> 16) * v156 + (v147.i32[0] >> 16) * v158);
                v162 = v138;
                v163 = *(v138 - 1);
                v164 = ((v145.u16[0] * v149) >> 15)
                     - ((v145.u16[2] * v150) >> 15)
                     + 2 * ((v145.i32[0] >> 16) * v149 - (v145.i32[1] >> 16) * v150);
                v165 = v157 + 2 * (v155 + (v146.i32[0] >> 16) * v151);
                v166 = *v138;
                v167 = ((v147.u16[0] * v156) >> 15)
                     - ((v147.u16[2] * v158) >> 15)
                     + 2 * ((v147.i32[0] >> 16) * v156 - (v147.i32[1] >> 16) * v158);
                v168 = ((v148.u16[0] * v163) >> 15)
                     - ((v148.u16[2] * v166) >> 15)
                     + 2 * ((v148.i32[0] >> 16) * v163 - (v148.i32[1] >> 16) * v166);
                v169 = ((v148.u16[0] * v166) >> 15)
                     + ((v148.u16[2] * v163) >> 15)
                     + 2 * ((v148.i32[1] >> 16) * v163 + (v148.i32[0] >> 16) * v166);
                v170 = v168 + v164;
                v171 = v169 + v159;
                v172 = v159 - v169;
                v173 = v167 + v165;
                v174 = v161 + v160;
                v175 = v165 - v167;
                v176 = v164 - v168;
                v177 = v160 - v161;
                v142->i32[0] = v173 + v154 + v170;
                v142->i32[1] = v174 + v153 + v171;
                v178 = v170 >> 16;
                v179 = (unsigned __int16)v170;
                LODWORD(v142) = v173 >> 16;
                v180 = (unsigned __int16)v170 * (_DWORD)v131;
                v181 = v171 >> 16;
                v182 = (v173 >> 16) * v128 + (v170 >> 16) * v131;
                v183 = v172 >> 16;
                v184 = (unsigned __int16)v172;
                v185 = v131;
                v186 = v128;
                v187 = v153
                     + (((unsigned __int16)v174 * (int)v128) >> 15)
                     + (((unsigned __int16)v171 * (int)v131) >> 15)
                     + 2 * ((v174 >> 16) * v128 + (v171 >> 16) * v131);
                v188 = ((v184 * v130) >> 15)
                     + (((unsigned __int16)v177 * v127) >> 15)
                     + 2 * ((v177 >> 16) * v127 + v183 * v130);
                v189 = v154 + (((unsigned __int16)v173 * (int)v128) >> 15) + (v180 >> 15) + 2 * v182;
                v190 = (((unsigned __int16)v176 * v130) >> 15)
                     + (((unsigned __int16)v175 * v127) >> 15)
                     + 2 * ((v175 >> 16) * v127 + (v176 >> 16) * v130);
                v219->i32[0] = v189 - v188;
                v219->i32[1] = v187 + v190;
                *v218 = v189 + v188;
                v218[1] = v187 - v190;
                v191 = v154 + (((unsigned __int16)v173 * (int)v185) >> 15) + ((v179 * (int)v186) >> 15);
                v192 = (unsigned __int16)v171 * (_DWORD)v186;
                v136 = v213;
                v135 = v214;
                LODWORD(v142) = v191 + 2 * ((_DWORD)v142 * v185 + v178 * v186);
                v193 = v153
                     + (((unsigned __int16)v174 * (int)v185) >> 15)
                     + (v192 >> 15)
                     + 2 * ((v174 >> 16) * v185 + v181 * v186);
                v194 = 2 * v130 * (v177 >> 16)
                     + (((unsigned __int16)v177 * v130) >> 15)
                     + -2 * v127 * v183
                     - ((v184 * v127) >> 15);
                v195 = (((unsigned __int16)v176 * v127) >> 15)
                     - (((unsigned __int16)v175 * v130) >> 15)
                     + 2 * ((v176 >> 16) * v127 - (v175 >> 16) * v130);
                *v221 = (_DWORD)v142 + v194;
                v221[1] = v193 + v195;
                v131 = v185;
                v133 = v216;
                v132 = v217;
                v196 = (_DWORD)v142 - v194;
                LODWORD(v142) = v193 - v195;
                v128 = v186;
                *v220 = v196;
                v220[1] = (int)v142;
                v134 = v215;
                v137 += 8;
                v138 = &v162[v208];
                v141 = (__int16 *)((char *)v141 + v211);
                v140 = &v222[v210];
                v139 = &v223[v209];
              }
              while (v212 != v137);
            }
            v122 = v207 + 1;
            a3 = v203;
            v132 += v204;
            v133 += v204;
            v135 += v204;
            v134 += v204;
            v136 += v204;
            v13 = v205;
          }
          while (v207 + 1 != v206);
        }
        break;
      default:
        break;
    }
    result = v199;
    v10 = v200 - 1;
  }
  while (v200 > 0);
  return result;
}

int *opus_ifft(int *result, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  __int16 *v19;
  int *v20;
  int v21;
  int *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  __int16 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  __int16 *v45;
  __int16 *v46;
  int *v47;
  int v48;
  int v49;
  int *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int *v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _DWORD *v82;
  __int16 *v83;
  __int16 *v84;
  __int16 *v85;
  int v86;
  int v87;
  _DWORD *v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  _DWORD *v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  _DWORD *v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  __int16 *v125;
  uint64_t v126;
  int v127;
  __int16 *v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  __int16 *v137;
  __int16 *v138;
  __int16 *v139;
  __int16 *v140;
  int v141;
  int v142;
  int v143;
  int *v144;
  int *v145;
  int *v146;
  _DWORD *v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int v187;
  int v188;
  uint64_t v189;
  int v190;
  int v191;
  int v192;
  int *v193;
  int v194;
  int *v195;
  uint64_t v196;
  int v197;
  __int16 *v198;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  int v215;
  int v216;
  int v217;
  _DWORD *v218;
  int *v219;
  __int16 *v220;
  _DWORD v221[8];
  uint64_t v222;

  v222 = *MEMORY[0x24BDAC8D0];
  v3 = result[1];
  if (*result >= 1)
  {
    v4 = 0;
    do
    {
      *(_QWORD *)(a3 + 8 * *(__int16 *)(*((_QWORD *)result + 5) + 2 * v4)) = *(_QWORD *)(a2 + 8 * v4);
      ++v4;
    }
    while (v4 < *result);
  }
  v194 = v3 & ~(v3 >> 31);
  v5 = 1;
  v221[0] = 1;
  v6 = (unsigned __int16 *)result + 5;
  v7 = -1;
  v8 = 1;
  do
  {
    v8 *= (__int16)*(v6 - 1);
    v221[v5] = v8;
    v9 = *v6;
    v6 += 2;
    ++v5;
    v7 += 2;
  }
  while (v9 != 1);
  v197 = *((__int16 *)result + v7 + 4);
  v193 = (int *)(a3 + 4);
  v10 = v5 - 2;
  v195 = result;
  do
  {
    v11 = v197;
    v196 = v10;
    if (v10)
    {
      v12 = v10;
      v197 = SHIWORD(result[(int)v10 + 1]);
      v13 = v10;
    }
    else
    {
      v12 = 0;
      v13 = 0;
      v197 = 1;
    }
    v203 = v11;
    switch(LOWORD(result[v12 + 2]))
    {
      case 2:
        v14 = v221[v13];
        if ((int)v14 >= 1)
        {
          v15 = 0;
          v16 = *((_QWORD *)v195 + 6) + 2;
          v17 = 2 * v11;
          v18 = v193;
          do
          {
            if (v11 >= 1)
            {
              v19 = (__int16 *)v16;
              v20 = v18;
              v21 = v11;
              do
              {
                v22 = &v20[v17];
                v23 = *(v19 - 1);
                v24 = v20[v17 - 1] >> 16;
                v25 = (unsigned __int16)v20[v17 - 1];
                v26 = *v19;
                v27 = v20[2 * v11] >> 16;
                v28 = (unsigned __int16)v20[2 * v11];
                v29 = ((v28 * v26) >> 15) + ((v25 * v23) >> 15) + 2 * (v24 * v23 + v27 * v26);
                v30 = ((v28 * v23) >> 15) - ((v25 * v26) >> 15) + 2 * (v27 * v23 - v24 * v26);
                v31 = *(v20 - 1);
                *(v22 - 1) = v31 - v29;
                v32 = *v20;
                *v22 = *v20 - v30;
                *(v20 - 1) = v29 + v31;
                *v20 = v30 + v32;
                v20 += 2;
                v19 += 2 * ((_DWORD)v14 << v194);
                --v21;
              }
              while (v21);
            }
            ++v15;
            v18 += 2 * v197;
          }
          while (v15 != v14);
        }
        break;
      case 3:
        v33 = v221[v13];
        if ((int)v33 >= 1)
        {
          v34 = 0;
          v35 = (int)((_DWORD)v33 << v194);
          v36 = *((_QWORD *)v195 + 6);
          v37 = (__int16)-*(_WORD *)(v36 + 4 * (int)v35 * (uint64_t)v11 + 2);
          v38 = (-65536 * *(unsigned __int16 *)(v36 + 4 * (int)v35 * (uint64_t)v11 + 2)) >> 15;
          v39 = 2 * v11;
          v40 = (__int16 *)(v36 + 2);
          v41 = 8 * v35;
          v42 = 4 * v11;
          v43 = 4 * v35;
          v44 = v193;
          do
          {
            v45 = v40;
            v46 = v40;
            v47 = v44;
            v48 = v11;
            do
            {
              v49 = *(v45 - 1);
              v50 = &v47[v39];
              v51 = v47[v39 - 1] >> 16;
              v52 = (unsigned __int16)v47[v39 - 1];
              v53 = *v45;
              v54 = v47[2 * v11] >> 16;
              v55 = (unsigned __int16)v47[2 * v11];
              v56 = ((v55 * v53) >> 15) + ((v52 * v49) >> 15) + 2 * (v51 * v49 + v54 * v53);
              v57 = ((v55 * v49) >> 15) - ((v52 * v53) >> 15) + 2 * (v54 * v49 - v51 * v53);
              v58 = *(v46 - 1);
              v59 = &v47[v42];
              v60 = v47[v42 - 1] >> 16;
              v61 = (unsigned __int16)v47[v42 - 1];
              v62 = *v46;
              v63 = v47[4 * v11] >> 16;
              v64 = (unsigned __int16)v47[4 * v11];
              v65 = ((v64 * v62) >> 15) + ((v61 * v58) >> 15) + 2 * (v60 * v58 + v63 * v62);
              v66 = ((v64 * v58) >> 15) - ((v61 * v62) >> 15) + 2 * (v63 * v58 - v60 * v62);
              v67 = v66 + v57;
              v68 = v57 - v66;
              *(v50 - 1) = *(v47 - 1) - ((v65 + v56) >> 1);
              *v50 = *v47 - (v67 >> 1);
              v69 = ((v56 - v65) >> 16) * v38 + (((unsigned __int16)(v56 - v65) * v37) >> 15);
              v70 = (v68 >> 16) * v38 + (((unsigned __int16)v68 * v37) >> 15);
              *(v47 - 1) += v65 + v56;
              *v47 += v67;
              v47 += 2;
              *(v59 - 1) = v70 + *(v50 - 1);
              *v59 = *v50 - v69;
              v71 = *v50 + v69;
              *(v50 - 1) -= v70;
              *v50 = v71;
              v46 = (__int16 *)((char *)v46 + v41);
              v45 = (__int16 *)((char *)v45 + v43);
              --v48;
            }
            while (v48);
            ++v34;
            v44 += 2 * v197;
          }
          while (v34 != v33);
        }
        break;
      case 4:
        v72 = v221[v13];
        if ((int)v72 >= 1)
        {
          v73 = 0;
          v74 = (int)((_DWORD)v72 << v194);
          v75 = *((_QWORD *)v195 + 6) + 2;
          v76 = 12 * v74;
          v77 = 8 * v74;
          v78 = 6 * v11;
          v79 = 4 * v74;
          v80 = 4 * v11;
          v81 = 2 * v11;
          do
          {
            if (v11 >= 1)
            {
              v82 = (_DWORD *)(a3 + 8 * v73 * v197);
              v83 = (__int16 *)v75;
              v84 = (__int16 *)v75;
              v85 = (__int16 *)v75;
              v86 = v203;
              do
              {
                v87 = *(v83 - 1);
                v88 = &v82[v81];
                v89 = (int)v82[v81] >> 16;
                v90 = (unsigned __int16)v82[v81];
                v91 = *v83;
                v92 = (int)v82[v81 + 1] >> 16;
                v93 = (unsigned __int16)v82[v81 + 1];
                v94 = ((v93 * v91) >> 15) + ((v90 * v87) >> 15) + 2 * (v89 * v87 + v92 * v91);
                v95 = ((v93 * v87) >> 15) - ((v90 * v91) >> 15) + 2 * (v92 * v87 - v89 * v91);
                v96 = *(v84 - 1);
                v97 = &v82[v80];
                v98 = (int)v82[v80] >> 16;
                v99 = (unsigned __int16)v82[v80];
                v100 = *v84;
                v101 = (int)v82[v80 + 1] >> 16;
                v102 = (unsigned __int16)v82[v80 + 1];
                v103 = ((v102 * v100) >> 15) + ((v99 * v96) >> 15) + 2 * (v98 * v96 + v101 * v100);
                v104 = ((v102 * v96) >> 15) - ((v99 * v100) >> 15) + 2 * (v101 * v96 - v98 * v100);
                v105 = *(v85 - 1);
                v106 = &v82[v78];
                v107 = (int)v82[v78] >> 16;
                v108 = (unsigned __int16)v82[v78];
                v109 = *v85;
                v110 = (int)v82[v78 + 1] >> 16;
                v111 = (unsigned __int16)v82[v78 + 1];
                v112 = ((v111 * v109) >> 15) + ((v108 * v105) >> 15) + 2 * (v107 * v105 + v110 * v109);
                v113 = ((v111 * v105) >> 15) - ((v108 * v109) >> 15) + 2 * (v110 * v105 - v107 * v109);
                v114 = v82[1];
                v115 = *v82 - v103;
                v116 = v114 - v104;
                v117 = *v82 + v103;
                v118 = v114 + v104;
                v119 = v112 + v94;
                v120 = v94 - v112;
                *v97 = v117 - v119;
                v97[1] = v118 - (v113 + v95);
                *v82 = v119 + v117;
                v82[1] = v113 + v95 + v118;
                v82 += 2;
                *v88 = v115 - (v95 - v113);
                v88[1] = v120 + v116;
                *v106 = v95 - v113 + v115;
                v106[1] = v116 - v120;
                v85 = (__int16 *)((char *)v85 + v76);
                v84 = (__int16 *)((char *)v84 + v77);
                v83 = (__int16 *)((char *)v83 + v79);
                --v86;
              }
              while (v86);
            }
            ++v73;
            v11 = v203;
          }
          while (v73 != v72);
        }
        break;
      case 5:
        v201 = v221[v13];
        if ((int)v201 >= 1)
        {
          v121 = 0;
          v122 = (int)((_DWORD)v201 << v194);
          v123 = *((_QWORD *)v195 + 6);
          v124 = (int)v122 * (uint64_t)v11;
          v125 = (__int16 *)(v123 + 8 * v124);
          v126 = v125[1];
          v127 = *v125;
          v128 = (__int16 *)(v123 + 4 * v124);
          v129 = v128[1];
          v130 = a3 + 32 * v11;
          v200 = 8 * v197;
          v198 = (__int16 *)(v123 + 2);
          v131 = a3 + 24 * v11;
          v132 = a3 + 16 * v11;
          v133 = *v128;
          v134 = a3;
          v135 = a3 + 8 * v11;
          v209 = -2 * v126;
          v207 = 16 * v122;
          v208 = 8 * v11;
          v205 = 4 * v122;
          v206 = 12 * v122;
          v204 = 4 * v122;
          do
          {
            v202 = v121;
            if (v11 >= 1)
            {
              v136 = 0;
              v137 = v198;
              v138 = v198;
              v139 = v198;
              v140 = v198;
              v213 = v131;
              v214 = v130;
              v211 = v134;
              v212 = v132;
              v210 = v135;
              do
              {
                v220 = v139;
                v218 = (_DWORD *)(v135 + v136);
                v141 = *(v138 - 1);
                v142 = *(_DWORD *)(v135 + v136);
                v143 = *(_DWORD *)(v135 + v136 + 4);
                v144 = (int *)(v130 + v136);
                v145 = (int *)(v131 + v136);
                v146 = (int *)(v132 + v136);
                v147 = (_DWORD *)(v134 + v136);
                v148 = *v138;
                v149 = (unsigned __int16)v143;
                v150 = v143 >> 16;
                v151 = (((unsigned __int16)v143 * v148) >> 15)
                     + (((unsigned __int16)v142 * v141) >> 15)
                     + 2 * ((v142 >> 16) * v141 + (v143 >> 16) * v148);
                v152 = ((v149 * v141) >> 15)
                     - (((unsigned __int16)v142 * v148) >> 15)
                     + 2 * (v150 * v141 - (v142 >> 16) * v148);
                v153 = *(v139 - 1);
                v219 = v146;
                v154 = *v146 >> 16;
                v155 = (unsigned __int16)*v146;
                v156 = *v139;
                v157 = v146[1] >> 16;
                v158 = (unsigned __int16)v146[1];
                v159 = ((v158 * v156) >> 15) + ((v155 * v153) >> 15) + 2 * (v154 * v153 + v157 * v156);
                v160 = ((v158 * v153) >> 15) - ((v155 * v156) >> 15) + 2 * (v157 * v153 - v154 * v156);
                v161 = *(v140 - 1);
                v162 = *v145 >> 16;
                v163 = (unsigned __int16)*v145;
                v164 = *v140;
                v165 = v145[1] >> 16;
                v166 = (unsigned __int16)v145[1];
                v167 = ((v166 * v164) >> 15) + ((v163 * v161) >> 15) + 2 * (v162 * v161 + v165 * v164);
                v168 = ((v166 * v161) >> 15) - ((v163 * v164) >> 15) + 2 * (v165 * v161 - v162 * v164);
                v169 = *(v137 - 1);
                v170 = *v144 >> 16;
                v171 = (unsigned __int16)*v144;
                v172 = *v137;
                v173 = v144[1] >> 16;
                v174 = (unsigned __int16)v144[1];
                v175 = ((v174 * v172) >> 15) + ((v171 * v169) >> 15) + 2 * (v170 * v169 + v173 * v172);
                v176 = ((v174 * v169) >> 15) - ((v171 * v172) >> 15) + 2 * (v173 * v169 - v170 * v172);
                v177 = v175 + v151;
                v178 = v176 + v152;
                v179 = v151 - v175;
                v180 = v152 - v176;
                v181 = v167 + v159;
                v182 = v168 + v160;
                v183 = v159 - v167;
                v184 = v160 - v168;
                v215 = *(_DWORD *)(v134 + v136 + 4);
                v216 = *(_DWORD *)(v134 + v136);
                *v147 = v181 + v216 + v177;
                v147[1] = v182 + v215 + v178;
                v185 = v177 >> 16;
                v217 = (unsigned __int16)v177;
                v186 = v216
                     + (((unsigned __int16)v181 * v127) >> 15)
                     + (((unsigned __int16)v177 * v133) >> 15)
                     + 2 * ((v181 >> 16) * v127 + (v177 >> 16) * v133);
                v187 = v215
                     + (((unsigned __int16)v182 * v127) >> 15)
                     + (((unsigned __int16)v178 * v133) >> 15)
                     + 2 * ((v182 >> 16) * v127 + (v178 >> 16) * v133);
                v188 = (((unsigned __int16)v180 * v129) >> 15)
                     + (((unsigned __int16)v184 * (int)v126) >> 15)
                     + 2 * ((v184 >> 16) * v126 + (v180 >> 16) * v129);
                v189 = v126;
                v190 = (((unsigned __int16)v179 * v129) >> 15)
                     + (((unsigned __int16)v183 * (int)v126) >> 15)
                     + 2 * ((v183 >> 16) * v126 + (v179 >> 16) * v129);
                *v218 = v186 + v188;
                v218[1] = v187 - v190;
                *v144 = v186 - v188;
                v144[1] = v187 + v190;
                LODWORD(v144) = (v181 >> 16) * v133 + v185 * v127;
                v130 = v214;
                v132 = v212;
                v131 = v213;
                LODWORD(v144) = v216
                              + (((unsigned __int16)v181 * v133) >> 15)
                              + ((v217 * v127) >> 15)
                              + 2 * (_DWORD)v144;
                v191 = v215
                     + (((unsigned __int16)v182 * v133) >> 15)
                     + (((unsigned __int16)v178 * v127) >> 15)
                     + 2 * ((v182 >> 16) * v133 + (v178 >> 16) * v127);
                v192 = (((unsigned __int16)v180 * (int)v189) >> 15)
                     - (((unsigned __int16)v184 * v129) >> 15)
                     + 2 * ((v180 >> 16) * v189 - (v184 >> 16) * v129);
                v126 = v189;
                v134 = v211;
                LODWORD(v146) = 2 * v129 * (v183 >> 16)
                              + (((unsigned __int16)v183 * v129) >> 15)
                              + v209 * (v179 >> 16)
                              - (((unsigned __int16)v179 * (int)v126) >> 15);
                *v219 = (_DWORD)v144 + v192;
                v219[1] = v191 + (_DWORD)v146;
                *v145 = (_DWORD)v144 - v192;
                v145[1] = v191 - (_DWORD)v146;
                v135 = v210;
                v136 += 8;
                v137 = (__int16 *)((char *)v137 + v207);
                v140 = (__int16 *)((char *)v140 + v206);
                v139 = &v220[v205];
                v138 = (__int16 *)((char *)v138 + v204);
              }
              while (v208 != v136);
            }
            v11 = v203;
            v121 = v202 + 1;
            v130 += v200;
            v131 += v200;
            v132 += v200;
            v135 += v200;
            v134 += v200;
          }
          while (v202 + 1 != v201);
        }
        break;
      default:
        break;
    }
    result = v195;
    v10 = v196 - 1;
  }
  while (v196 > 0);
  return result;
}

uint64_t compute_allocation(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int *a7, int *a8, int a9, unsigned int *a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, uint64_t *a16, int a17, int a18, unsigned int a19)
{
  _BYTE *v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  BOOL v27;
  int v28;
  size_t v29;
  unint64_t v30;
  _BYTE *v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  __int16 *v37;
  __int16 *v38;
  __int16 v39;
  __int16 v40;
  int *v41;
  _BYTE *v42;
  _DWORD *v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  __int16 v51;
  int v52;
  int v53;
  int v54;
  _BYTE *v55;
  int v56;
  int v57;
  _BYTE *v58;
  _BYTE *v59;
  uint64_t v60;
  int v61;
  int v62;
  _BYTE *v63;
  int v64;
  int v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  uint64_t v74;
  __int16 *v75;
  __int16 v76;
  _WORD *v77;
  __int16 v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _BYTE *v83;
  uint64_t v84;
  _BYTE *v85;
  uint64_t v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  _BYTE *v97;
  _BYTE *v98;
  int v99;
  uint64_t v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  char v105;
  int v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  _BYTE *v114;
  uint64_t v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int *v130;
  int *v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  char v138;
  _BOOL4 v139;
  int v140;
  uint64_t v141;
  __int16 v142;
  int v143;
  int v144;
  int v145;
  _DWORD *v146;
  uint64_t v147;
  __int16 *v148;
  uint64_t v149;
  __int16 v150;
  int v151;
  _DWORD *v152;
  __int16 *v153;
  __int16 v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  int v159;
  __int16 v160;
  unsigned int v161;
  char v162;
  uint64_t v163;
  int v164;
  int v165;
  int v166;
  _BOOL4 v167;
  int v168;
  int v169;
  unsigned int v170;
  unsigned int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  uint64_t v186;
  _DWORD *v187;
  int *v188;
  int *v189;
  int v190;
  _BYTE v192[4];
  int v193;
  _BOOL4 v194;
  int v195;
  int *v196;
  int v197;
  unsigned int *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  int *v206;
  _BYTE *v207;
  uint64_t v208;
  int v209;
  int v210;
  uint64_t *v211;
  _BYTE *v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  _BYTE *v216;
  uint64_t v217;

  v196 = a8;
  v206 = a7;
  v203 = a5;
  v21 = a2;
  v213 = a1;
  v217 = *MEMORY[0x24BDAC8D0];
  v22 = a9 & ~(a9 >> 31);
  v215 = (char *)*(int *)(a1 + 8);
  v210 = v22 > 7;
  v23 = v22 - 8 * v210;
  v205 = a4;
  if (a14 == 2)
  {
    v24 = LOG2_FRAC_TABLE[(int)a3 - (int)a2];
    v25 = 8 * (v23 - v24 > 7);
    v26 = v23 - v24 - v25;
    v27 = v23 < v24;
    if (v23 < v24)
      v24 = 0;
    v197 = v24;
    if (v27)
      v28 = 0;
    else
      v28 = v25;
    v195 = v28;
    if (!v27)
      v23 = v26;
  }
  else
  {
    v197 = 0;
    v195 = 0;
  }
  v211 = a16;
  v199 = a13;
  v200 = a12;
  v214 = a11;
  v198 = a10;
  v29 = 4 * (_QWORD)v215;
  v30 = (4 * (_QWORD)v215 + 15) & 0xFFFFFFFFFFFFFFF0;
  v216 = &v192[-v30];
  bzero(&v192[-v30], 4 * (_QWORD)v215);
  v208 = (uint64_t)&v192[-v30];
  bzero(&v192[-v30], v29);
  v31 = &v192[-v30];
  bzero(&v192[-v30], v29);
  v207 = &v192[-v30];
  bzero(&v192[-v30], v29);
  v32 = 8 * a14;
  v212 = &v192[-v30];
  if ((int)v21 >= (int)a3)
  {
    v36 = (int)a3;
    v35 = (int)v21;
    v47 = v203;
    v33 = v213;
    v55 = v216;
    v48 = v205;
    v42 = v207;
  }
  else
  {
    v33 = v213;
    v34 = a6 - a15 - 5;
    v35 = (int)v21;
    v36 = (int)a3;
    v37 = (__int16 *)(*(_QWORD *)(v213 + 24) + 2 * (int)v21);
    v40 = *v37;
    v38 = v37 + 1;
    v39 = v40;
    v41 = (int *)&v31[4 * (int)v21];
    v42 = v207;
    v43 = &v207[4 * (int)v21];
    v44 = a14 * v34;
    v45 = v44 * (~(_DWORD)v21 + a3);
    v46 = (int)a3 - (uint64_t)(int)v21;
    v47 = v203;
    v48 = v205;
    do
    {
      v49 = *v38++;
      v50 = v49 - v39;
      v51 = v49;
      v52 = (8 * ((3 * v50) << a15)) >> 4;
      if (v32 > v52)
        v52 = 8 * a14;
      *v41++ = v52;
      v53 = (v45 * v50) << (a15 + 3) >> 6;
      if (v50 << a15 == 1)
        v54 = 8 * a14;
      else
        v54 = 0;
      *v43++ = v53 - v54;
      v45 -= v44;
      v39 = v51;
      --v46;
    }
    while (v46);
    v55 = v216;
  }
  v204 = a19;
  v193 = 8 * v210;
  v56 = *(_DWORD *)(v33 + 44);
  v57 = v56 - 1;
  v58 = v42 - 4;
  LODWORD(v207) = a18;
  v210 = a17;
  v59 = v212 - 4;
  v60 = v47 - 4;
  v61 = 1;
  v202 = v36;
  v216 = v21;
  do
  {
    while (1)
    {
      v62 = (v57 + v61) >> 1;
      if ((int)v21 < (int)a3)
        break;
      if (v23 < 0)
        v57 = v62 - 1;
      else
        v61 = v62 + 1;
      if (v61 > v57)
      {
        v87 = (int)v21;
        goto LABEL_57;
      }
    }
    v63 = v42;
    v64 = 0;
    v65 = 0;
    v66 = *(_QWORD *)(v33 + 24);
    LOWORD(v67) = *(_WORD *)(v66 + 2 * v36);
    v68 = v66 - 2;
    v69 = v36;
    do
    {
      v70 = (__int16)v67;
      v67 = *(__int16 *)(v68 + 2 * v69);
      v71 = ((v70 - v67) * a14 * *(unsigned __int8 *)(*(_QWORD *)(v33 + 48) + (int)v215 * (uint64_t)v62 - 1 + v69)) << a15;
      v72 = v71 >> 2;
      if (v71 >= 4)
        v72 = (*(_DWORD *)&v58[4 * v69] + v72) & ~((*(_DWORD *)&v58[4 * v69] + v72) >> 31);
      v73 = *(_DWORD *)(v48 - 4 + 4 * v69) + v72;
      if (v65 || v73 >= *(_DWORD *)&v59[4 * v69])
      {
        if (v73 >= *(_DWORD *)(v60 + 4 * v69))
          v73 = *(_DWORD *)(v60 + 4 * v69);
        v65 = 1;
      }
      else
      {
        v65 = 0;
        if (v73 >= v32)
          v73 = 8 * a14;
        else
          v73 = 0;
      }
      --v69;
      v64 += v73;
    }
    while (v69 > v35);
    if (v64 > v23)
      v57 = v62 - 1;
    else
      v61 = v62 + 1;
    v42 = v63;
  }
  while (v61 <= v57);
  v74 = 0;
  v75 = (__int16 *)(*(_QWORD *)(v33 + 24) + 2 * v35);
  v78 = *v75;
  v77 = v75 + 1;
  v76 = v78;
  v79 = *(_QWORD *)(v33 + 48) + v35;
  v80 = v79 + (int)v215 * (uint64_t)v61;
  v81 = v47 + 4 * v35;
  v82 = v79 + (v61 - 1) * (_QWORD)v215;
  v83 = &v63[4 * v35];
  v84 = v48 + 4 * v35;
  v85 = (_BYTE *)(v208 + 4 * v35);
  v86 = v35 - v36;
  v87 = (int)v21;
  do
  {
    v88 = ((__int16)v77[v74] - v76) * a14;
    if (v61 >= v56)
      v89 = *(_DWORD *)(v81 + 4 * v74);
    else
      v89 = (v88 * *(unsigned __int8 *)(v80 + v74)) << a15 >> 2;
    v90 = (v88 * *(unsigned __int8 *)(v82 + v74)) << a15;
    v91 = v90 >> 2;
    if (v90 >= 4)
      v91 = (*(_DWORD *)&v83[4 * v74] + v91) & ~((*(_DWORD *)&v83[4 * v74] + v91) >> 31);
    if (v89 >= 1)
      v89 = (*(_DWORD *)&v83[4 * v74] + v89) & ~((*(_DWORD *)&v83[4 * v74] + v89) >> 31);
    v76 = v77[v74];
    v92 = *(_DWORD *)(v84 + 4 * v74);
    if (v61 <= 1)
      v93 = 0;
    else
      v93 = *(_DWORD *)(v84 + 4 * v74);
    v94 = v91 + v93;
    if (v92 > 0)
      v87 = v35 + v74;
    *(_DWORD *)&v55[4 * v35 + 4 * v74] = v94;
    *(_DWORD *)&v85[4 * v74++] = (v89 - v94 + v92) & ~((v89 - v94 + v92) >> 31);
    LODWORD(v21) = (_DWORD)v216;
  }
  while (v86 + v74);
LABEL_57:
  v95 = 0;
  v96 = 0;
  v194 = a14 > 1;
  v97 = (_BYTE *)(v208 - 4);
  v98 = v55 - 4;
  v99 = 64;
  v100 = v214;
  do
  {
    while ((int)v21 >= (int)a3)
    {
      if (v23 < 0)
        v99 = (v96 + v99) >> 1;
      else
        v96 = (v96 + v99) >> 1;
      if (++v95 == 6)
      {
        v106 = 0;
        goto LABEL_87;
      }
    }
    v101 = 0;
    v102 = 0;
    v103 = v202;
    do
    {
      v104 = *(_DWORD *)&v98[4 * v103] + ((*(_DWORD *)&v97[4 * v103] * ((v96 + v99) >> 1)) >> 6);
      if (v101 || v104 >= *(_DWORD *)&v59[4 * v103])
      {
        if (v104 >= *(_DWORD *)(v60 + 4 * v103))
          v104 = *(_DWORD *)(v60 + 4 * v103);
        v101 = 1;
      }
      else
      {
        v101 = 0;
        if (v104 >= v32)
          v104 = 8 * a14;
        else
          v104 = 0;
      }
      --v103;
      v102 += v104;
    }
    while (v103 > v35);
    if (v102 > v23)
      v99 = (v96 + v99) >> 1;
    else
      v96 = (v96 + v99) >> 1;
    ++v95;
  }
  while (v95 != 6);
  v105 = 0;
  v106 = 0;
  v107 = v202;
  do
  {
    v108 = *(_DWORD *)&v98[4 * v107] + ((*(_DWORD *)&v97[4 * v107] * v96) >> 6);
    v105 |= v108 >= *(_DWORD *)&v59[4 * v107];
    if (v108 >= v32)
      v109 = 8 * a14;
    else
      v109 = 0;
    if ((v105 & 1) == 0)
      v108 = v109;
    if (v108 >= *(_DWORD *)(v60 + 4 * v107))
      v108 = *(_DWORD *)(v60 + 4 * v107);
    *(_DWORD *)(v100 - 4 + 4 * v107) = v108;
    v106 += v108;
    --v107;
  }
  while (v107 > v35);
LABEL_87:
  v201 = a3;
  if ((int)a3 - 1 <= v87)
  {
    v127 = v197;
    v110 = a3;
LABEL_111:
    v129 = v23 + v193;
LABEL_112:
    v130 = v196;
    if (v127 > 0)
    {
      if (!v210)
        goto LABEL_119;
      v131 = v206;
      v132 = *v206;
      if (*v206 >= (int)v110)
        v132 = v110;
      *v206 = v132;
      v133 = (int)v216;
      ec_enc_uint(v211, v132 - (_DWORD)v216, v110 - (_DWORD)v216 + 1);
      v33 = v213;
      v100 = v214;
      v134 = *v131;
LABEL_127:
      if (v134 <= v133)
        v137 = v195;
      else
        v137 = 0;
      if (v195 && v134 > v133)
      {
        v138 = v194;
        if (!v210)
          goto LABEL_134;
        ec_enc_bit_logp(v211, *v130, 1);
        v33 = v213;
        v100 = v214;
        goto LABEL_138;
      }
LABEL_136:
      v138 = v194;
      goto LABEL_137;
    }
LABEL_126:
    v134 = 0;
    *v206 = 0;
    v133 = (int)v216;
    goto LABEL_127;
  }
  LODWORD(v205) = (_DWORD)v21 + 2;
  v110 = a3;
  v111 = (int)a3 - 1;
  v204 = (int)v204;
  v112 = v87;
  v215 = (char *)&LOG2_FRAC_TABLE[-v35];
  v113 = v197;
  v114 = v212;
  v208 = v87;
  v209 = v23;
  while (1)
  {
    v115 = *(_QWORD *)(v33 + 24);
    v116 = *(__int16 *)(v115 + 2 * (int)v110);
    v117 = *(__int16 *)(v115 + 2 * v35);
    v118 = (v23 - v106) / (v116 - v117);
    LODWORD(v115) = *(__int16 *)(v115 + 2 * v111);
    v119 = v23 - v106 + v117 - (v115 + (v116 - v117) * v118);
    v120 = v119 & ~(v119 >> 31);
    v121 = v116 - v115;
    v122 = *(_DWORD *)(v100 + 4 * v111);
    v123 = v122 + v121 * v118 + v120;
    v124 = *(_DWORD *)&v114[4 * v111];
    if (v124 <= v32 + 8)
      v124 = v32 + 8;
    if (v123 < v124)
      goto LABEL_102;
    if (v210)
    {
      v125 = v113;
      if ((int)v110 <= (int)v205
        || ((int)v110 <= (int)v207 ? (v126 = 7) : (v126 = 9), v111 <= v204 && v123 > (8 * ((v121 * v126) << a15)) >> 4))
      {
        ec_enc_bit_logp(v211, 1, 1);
        v33 = v213;
        v100 = v214;
        v127 = v125;
        v129 = v209;
        goto LABEL_112;
      }
      ec_enc_bit_logp(v211, 0, 1);
      goto LABEL_101;
    }
    v125 = v113;
    if (ec_dec_bit_logp((uint64_t)v211, 1))
      break;
LABEL_101:
    v106 += 8;
    v123 -= 8;
    v33 = v213;
    v100 = v214;
    v122 = *(_DWORD *)(v214 + 4 * v111);
    v113 = v125;
    v23 = v209;
    v114 = v212;
    v112 = v208;
LABEL_102:
    if (v113)
      v127 = v215[v111];
    else
      v127 = 0;
    if (v123 >= v32)
      v128 = 8 * a14;
    else
      v128 = 0;
    v106 = v106 - v122 - v113 + v127 + v128;
    *(_DWORD *)(v100 + 4 * v111--) = v128;
    v110 = (v110 - 1);
    v113 = v127;
    if (v111 <= v112)
      goto LABEL_111;
  }
  v27 = v125 <= 0;
  v130 = v196;
  v33 = v213;
  v100 = v214;
  v129 = v209;
  if (v27)
    goto LABEL_126;
LABEL_119:
  v135 = (int)v216;
  v136 = ec_dec_uint((uint64_t)v211, (int)v110 - (int)v216 + 1);
  *v206 = v136 + v135;
  if (v136 + v135 <= v135)
    v137 = v195;
  else
    v137 = 0;
  if (!v195)
  {
    v33 = v213;
    v100 = v214;
    goto LABEL_136;
  }
  v27 = v136 + v135 <= v135;
  v33 = v213;
  v100 = v214;
  v138 = v194;
  if (!v27)
  {
LABEL_134:
    v139 = ec_dec_bit_logp((uint64_t)v211, 1);
    v33 = v213;
    v100 = v214;
    *v130 = v139;
    goto LABEL_138;
  }
LABEL_137:
  *v130 = 0;
LABEL_138:
  if ((int)v110 > (int)v216)
  {
    v140 = v129 - v106 + v137;
    v141 = *(_QWORD *)(v33 + 24);
    v142 = *(_WORD *)(v141 + 2 * v35);
    v143 = *(__int16 *)(v141 + 2 * (int)v110) - v142;
    v144 = v140 / v143;
    v145 = v140 % v143;
    v146 = (_DWORD *)(v100 + 4 * v35);
    v147 = (int)v110 - v35;
    v148 = (__int16 *)(v141 + 2 * v35 + 2);
    v149 = v147;
    v150 = v142;
    do
    {
      v151 = *v148++;
      *v146++ += (v151 - v150) * v144;
      v150 = v151;
      --v149;
    }
    while (v149);
    v152 = (_DWORD *)(v100 + 4 * v35);
    v153 = (__int16 *)(v141 + 2 * v35 + 2);
    v154 = v142;
    v155 = v203;
    v157 = v199;
    v156 = v200;
    do
    {
      v158 = *v153++;
      v159 = v158 - v154;
      v160 = v158;
      if (v145 < v159)
        v159 = v145;
      *v152++ += v159;
      v145 -= v159;
      v154 = v160;
      --v147;
    }
    while (v147);
    v161 = 0;
    if (a14 <= 1)
      v162 = 3;
    else
      v162 = 4;
    v163 = v141 + 2;
    while (1)
    {
      v164 = *(__int16 *)(v163 + 2 * v35);
      v165 = (v164 - v142) << a15;
      v166 = *(_DWORD *)(v100 + 4 * v35) + v161;
      if (v165 < 2)
      {
        v170 = (v166 - v32) & ~((v166 - v32) >> 31);
        if (v166 >= v32)
          v166 = 8 * a14;
        *(_DWORD *)(v100 + 4 * v35) = v166;
        *(_DWORD *)(v156 + 4 * v35) = 0;
        *(_DWORD *)(v157 + 4 * v35) = 1;
        if (v170)
        {
LABEL_159:
          v171 = v170 >> v162;
          v172 = *(_DWORD *)(v156 + 4 * v35);
          if ((int)(v170 >> v162) >= 8 - v172)
            v171 = 8 - v172;
          *(_DWORD *)(v156 + 4 * v35) = v171 + v172;
          v173 = v171 * v32;
          *(_DWORD *)(v157 + 4 * v35) = v173 >= (int)(v170 - v161);
          v161 = v170 - v173;
          goto LABEL_176;
        }
      }
      else
      {
        v167 = 0;
        v168 = *(_DWORD *)(v155 + 4 * v35);
        v169 = v166 - v168;
        if (v166 >= v168)
          v166 = *(_DWORD *)(v155 + 4 * v35);
        *(_DWORD *)(v100 + 4 * v35) = v166;
        if (a14 == 2 && v165 != 2)
        {
          if (*v130)
            v167 = 0;
          else
            v167 = v35 < *v206;
        }
        v174 = v165 * a14 + v167;
        v175 = (8 * a15 + *(__int16 *)(*(_QWORD *)(v33 + 56) + 2 * v35)) * v174;
        v176 = 8 * v174;
        if (v165 == 2)
          v177 = (8 * v174) >> 2;
        else
          v177 = 0;
        v178 = v177 - 21 * v174 + (v175 >> 1);
        v179 = v178 + v166;
        v180 = v178 + (v175 >> 3);
        if (v178 + v166 >= 24 * v174)
          v180 = v178;
        v181 = v178 + (v175 >> 2);
        if (v179 >= 16 * v174)
          v181 = v180;
        v182 = ((v166 + 4 * v174 + v181) / v176) & ~(((v166 + 4 * v174 + v181) / v176) >> 31);
        *(_DWORD *)(v156 + 4 * v35) = v182;
        v100 = v214;
        v183 = *(_DWORD *)(v214 + 4 * v35);
        if (v182 * a14 > v183 >> 3)
          v182 = v183 >> v138 >> 3;
        if (v182 >= 8)
          v182 = 8;
        *(_DWORD *)(v156 + 4 * v35) = v182;
        *(_DWORD *)(v157 + 4 * v35) = v182 * v176 >= *(_DWORD *)(v100 + 4 * v35) + v181;
        v170 = v169 & ~(v169 >> 31);
        *(_DWORD *)(v100 + 4 * v35) -= *(_DWORD *)(v156 + 4 * v35) * v32;
        if (v170)
          goto LABEL_159;
      }
      v161 = 0;
LABEL_176:
      ++v35;
      v142 = v164;
      if ((int)v110 == v35)
      {
        v184 = v110;
        goto LABEL_179;
      }
    }
  }
  v161 = 0;
  v157 = v199;
  v156 = v200;
  v184 = (int)v216;
LABEL_179:
  v185 = v201;
  *v198 = v161;
  if (v184 < v185)
  {
    v186 = v202 - v184;
    v187 = (_DWORD *)(v157 + 4 * v184);
    v188 = (int *)(v156 + 4 * v184);
    v189 = (int *)(v100 + 4 * v184);
    do
    {
      *v188 = *v189 >> v138 >> 3;
      *v189++ = 0;
      v190 = *v188++;
      *v187++ = v190 < 1;
      --v186;
    }
    while (v186);
  }
  return v110;
}

int *clt_mdct_forward(int *a1, uint64_t a2, _DWORD *a3, __int16 *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  int *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 *v23;
  int v24;
  uint64_t v25;
  int *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int *v31;
  int *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int *v37;
  uint64_t v38;
  int *v39;
  int v40;
  BOOL v41;
  int v42;
  __int16 *v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  int *v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int *result;
  int v71;
  _DWORD *v72;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  int *v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  size_t v91;
  char *v92;
  int *v93;
  uint64_t v94;
  uint64_t v95;

  v88 = a7;
  v95 = *MEMORY[0x24BDAC8D0];
  v12 = (*a1 >> a6);
  v13 = (int)v12 >> 1;
  v14 = (int)v12 >> 2;
  v93 = a1;
  v94 = v12;
  v15 = (uint64_t)(int)v12 >> 1;
  v16 = 4 * ((int)v12 >> 1);
  v17 = (char *)&v87 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v91 = v16;
  bzero(v17, v16);
  v18 = (int *)(a2 + 4 * ((int)a5 >> 1));
  v87 = a5;
  v90 = ((int)a5 + 3) >> 2;
  if ((int)a5 < 1)
  {
    v24 = 0;
    v32 = &v18[v13 - 1];
    v31 = (int *)v17;
  }
  else
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = (uint64_t)(int)a5 >> 1;
    v23 = &a4[v22];
    if (((int)a5 + 3) >> 2 <= 1)
      v24 = 1;
    else
      v24 = ((int)a5 + 3) >> 2;
    do
    {
      v26 = (int *)&v17[v19];
      v27 = v23[v20 - 1];
      v28 = v23[v21];
      v25 = a2 + 4 * v15 + 4 * v22;
      v29 = (((unsigned __int16)*(_DWORD *)(v25 + 4 * v20 - 4) * v28) >> 15)
          + (((unsigned __int16)*(_DWORD *)(v25 + v19) * v27) >> 15)
          + 2 * ((*(int *)(v25 + v19) >> 16) * v27 + (*(int *)(v25 + 4 * v20 - 4) >> 16) * v28);
      v30 = (((unsigned __int16)v18[v19 / 4] * v28) >> 15)
          - (((unsigned __int16)v18[v20 - 1] * v27) >> 15)
          + 2 * ((v18[v19 / 4] >> 16) * v28 - (v18[v20 - 1] >> 16) * v27);
      *v26 = v29;
      v26[1] = v30;
      v21 += 2;
      v20 -= 2;
      v19 += 8;
    }
    while (4 * v24 != (_DWORD)(v21 * 2));
    v31 = (int *)&v17[v19];
    v32 = (int *)(a2 + 4 * v15 + 4 * v22 - v19 - 4);
    v18 = (int *)((char *)v18 + v19);
  }
  v89 = ((int)v94 >> 1) + 25736;
  v92 = v17;
  bzero(v17, v91);
  v33 = v14 - v90;
  if (v24 >= v14 - v90)
  {
    v33 = v24;
  }
  else
  {
    do
    {
      v35 = *v32;
      v32 -= 2;
      v34 = v35;
      v36 = *v18;
      v18 += 2;
      v37 = v31 + 2;
      *v31 = v34;
      v31[1] = v36;
      ++v24;
      v31 += 2;
    }
    while (v24 < v33);
    v31 = v37;
  }
  v38 = (uint64_t)v92;
  v39 = v93;
  v40 = v89 / (int)v94;
  v41 = __OFSUB__(v14, v33);
  v42 = v14 - v33;
  if (!((v42 < 0) ^ v41 | (v42 == 0)))
  {
    v43 = &a4[(int)v87 - 1];
    do
    {
      v45 = *a4;
      a4 += 2;
      v44 = v45;
      v46 = (v18[-v15] >> 16) * v45;
      v48 = *v43;
      v43 -= 2;
      v47 = v48;
      v49 = (((unsigned __int16)*v32 * v48) >> 15)
          - (((unsigned __int16)v18[-v15] * v44) >> 15)
          + 2 * ((*v32 >> 16) * v48 - v46);
      v50 = *v18;
      v18 += 2;
      v51 = (((unsigned __int16)v32[v15] * v44) >> 15)
          + (((unsigned __int16)v50 * v47) >> 15)
          + 2 * ((v50 >> 16) * v47 + (v32[v15] >> 16) * v44);
      *v31 = v49;
      v31[1] = v51;
      v31 += 2;
      v32 -= 2;
      --v42;
    }
    while (v42);
  }
  v52 = v40 << 16;
  v53 = (__int16)v40;
  v54 = 2 * (__int16)v40;
  if ((int)v94 >= 4)
  {
    v55 = 0;
    v56 = *((_QWORD *)v39 + 5);
    if (v14 <= 1)
      v57 = 1;
    else
      v57 = v14;
    v58 = v14;
    v59 = (int *)v17;
    do
    {
      v60 = *(__int16 *)(v56 + 2 * (v55 << a6));
      v61 = *v59 >> 16;
      v62 = (unsigned __int16)*v59;
      v63 = *(__int16 *)(v56 + 2 * (v58 << a6));
      v64 = v59[1] >> 16;
      v65 = (unsigned __int16)v59[1];
      v66 = ((v65 * v63) >> 15) + ((v62 * v60) >> 15) + 2 * (v61 * v60 + v64 * v63);
      v67 = ((v62 * v63) >> 15) + 2 * v61 * v63 - (2 * v60 * v64 + ((v65 * v60) >> 15));
      *v59 = v54 * (v67 >> 16) - v66 + (((unsigned __int16)v67 * v53) >> 15);
      v59[1] = v67 + -(v52 >> 15) * (-v66 >> 16) - (((unsigned __int16)-(__int16)v66 * v53) >> 15);
      v59 += 2;
      ++v55;
      --v58;
    }
    while (v57 != v55);
  }
  v68 = (uint64_t)v17;
  v69 = v38;
  result = opus_fft(*(int **)&v39[2 * a6 + 2], v68, v38);
  if ((int)v94 >= 4)
  {
    v71 = 0;
    v72 = &a3[((int)v15 - 1) * v88];
    v73 = *((_QWORD *)v39 + 5);
    v74 = 2 * v88;
    if (v14 <= 1)
      v75 = 1;
    else
      v75 = v14;
    v76 = -4 * v74;
    v77 = 4 * v74;
    v78 = (int *)(v69 + 4);
    do
    {
      v79 = *(__int16 *)(v73 + 2 * (v14 << a6));
      v80 = *v78 >> 16;
      v81 = (unsigned __int16)*v78;
      v82 = *(__int16 *)(v73 + 2 * (v71 << a6));
      v83 = *(v78 - 1) >> 16;
      v84 = (unsigned __int16)*(v78 - 1);
      v85 = ((v84 * v82) >> 15) + ((v81 * v79) >> 15) + 2 * (v80 * v79 + v83 * v82);
      v86 = ((v84 * v79) >> 15) - ((v81 * v82) >> 15) + 2 * (v83 * v79 - v80 * v82);
      result = (int *)(v85 >> 16);
      ++v71;
      --v14;
      *a3 = v85 + -(v52 >> 15) * (v86 >> 16) - (((unsigned __int16)v86 * v53) >> 15);
      *v72 = v86 + v54 * (_DWORD)result + (((unsigned __int16)v85 * v53) >> 15);
      v72 = (_DWORD *)((char *)v72 + v76);
      a3 = (_DWORD *)((char *)a3 + v77);
      v78 += 2;
    }
    while (v75 != v71);
  }
  return result;
}

int *clt_mdct_backward(int *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  int v13;
  int v14;
  size_t v15;
  char *v16;
  int *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int *v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _DWORD *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int *v41;
  int *result;
  int v43;
  uint64_t v44;
  int v45;
  int *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;

  v73 = a5;
  v74 = *MEMORY[0x24BDAC8D0];
  v13 = *a1 >> a6;
  v14 = v13 >> 2;
  v72 = (uint64_t)v13 >> 1;
  v15 = 4 * (v13 >> 1);
  v16 = (char *)&v71 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v16, v15);
  v17 = a1;
  v18 = ((v13 >> 1) + 25736) / v13;
  v19 = (__int16)v18;
  v20 = 2 * (__int16)v18;
  if (v13 >= 4)
  {
    v21 = 0;
    v22 = &a2[((int)v72 - 1) * a7];
    v23 = v18 << 16;
    v24 = *((_QWORD *)v17 + 5);
    v25 = -(v23 >> 15);
    v26 = 2 * a7;
    if (v14 <= 1)
      v27 = 1;
    else
      v27 = v13 >> 2;
    v28 = 4 * v26;
    v29 = -4 * v26;
    v30 = v13 >> 2;
    v31 = v16;
    do
    {
      v32 = *(__int16 *)(v24 + 2 * (v21 << a6));
      v33 = *v22 >> 16;
      v34 = (unsigned __int16)*v22;
      v35 = *(__int16 *)(v24 + 2 * (v30 << a6));
      v36 = *a2 >> 16;
      v37 = (unsigned __int16)*a2;
      v38 = 2 * v35 * v36 - (2 * v33 * v32 + ((v34 * v32) >> 15)) + ((v37 * v35) >> 15);
      v39 = ((v37 * v32) >> 15) + ((v34 * v35) >> 15) + 2 * (v33 * v35 + v36 * v32);
      ++v21;
      --v30;
      *v31 = v38 + v25 * (-v39 >> 16) - (((unsigned __int16)-(__int16)v39 * v19) >> 15);
      v31[1] = v20 * (v38 >> 16) - v39 + (((unsigned __int16)v38 * v19) >> 15);
      v31 += 2;
      a2 = (int *)((char *)a2 + v28);
      v22 = (int *)((char *)v22 + v29);
    }
    while (v27 != v21);
  }
  v40 = v73;
  v41 = (int *)(a3 + 4 * ((int)v73 >> 1));
  result = opus_ifft(*(int **)&v17[2 * a6 + 2], (uint64_t)v16, (uint64_t)v41);
  if (v13 >= 4)
  {
    v43 = 0;
    v44 = *((_QWORD *)v17 + 5);
    v45 = (v14 + 1) >> 1;
    if (v45 <= 1)
      v45 = 1;
    v46 = (int *)(4 * v72 + 4 * ((uint64_t)v40 >> 1) + a3 - 4);
    do
    {
      v47 = *(__int16 *)(v44 + 2 * (v43 << a6));
      v48 = *(__int16 *)(v44 + 2 * (v14 << a6));
      v49 = *v41 >> 16;
      v50 = (unsigned __int16)*v41;
      v51 = v41[1] >> 16;
      v52 = (unsigned __int16)v41[1];
      v53 = ((v50 * v47) >> 15) - ((v52 * v48) >> 15) + 2 * (v49 * v47 - v51 * v48);
      v54 = ((v50 * v48) >> 15) + ((v52 * v47) >> 15) + 2 * (v51 * v47 + v49 * v48);
      v55 = *(v46 - 1);
      v56 = *v46;
      *v41 = v20 * (v54 >> 16) - v53 + (((unsigned __int16)v54 * v19) >> 15);
      v57 = *(__int16 *)(v44 + 2 * (--v14 << a6));
      v58 = *(__int16 *)(v44 + 2 * (++v43 << a6));
      *v46 = v54 + v20 * (v53 >> 16) + (((unsigned __int16)v53 * v19) >> 15);
      v59 = (((unsigned __int16)v55 * v57) >> 15)
          - (((unsigned __int16)v56 * v58) >> 15)
          + 2 * ((v55 >> 16) * v57 - (v56 >> 16) * v58);
      result = (int *)((v56 >> 16) * v57);
      v60 = (((unsigned __int16)v55 * v58) >> 15)
          + (((unsigned __int16)v56 * v57) >> 15)
          + 2 * ((_DWORD)result + (v55 >> 16) * v58);
      *(v46 - 1) = v20 * (v60 >> 16) - v59 + (((unsigned __int16)v60 * v19) >> 15);
      v41[1] = v60 + v20 * (v59 >> 16) + (((unsigned __int16)v59 * v19) >> 15);
      v46 -= 2;
      v41 += 2;
    }
    while (v45 != v43);
  }
  if (v40 >= 0)
    v61 = v40;
  else
    v61 = v40 + 1;
  if (v40 >= 2)
  {
    v62 = 0;
    v63 = v61 >> 1;
    v64 = v40 - 1;
    do
    {
      v65 = *(__int16 *)(a4 + 2 * v64);
      v66 = *(int *)(a3 + 4 * v62) >> 16;
      v67 = (unsigned __int16)*(_DWORD *)(a3 + 4 * v62);
      v68 = *(__int16 *)(a4 + 2 * v62);
      v69 = *(int *)(a3 + 4 * v64) >> 16;
      v70 = (unsigned __int16)*(_DWORD *)(a3 + 4 * v64);
      result = (int *)(v70 * v68);
      *(_DWORD *)(a3 + 4 * v62) = ((v67 * v65) >> 15) - ((int)result >> 15) + 2 * (v66 * v65 - v69 * v68);
      *(_DWORD *)(a3 + 4 * v64) = ((v67 * v68) >> 15) + ((v70 * v65) >> 15) + 2 * (v69 * v65 + v66 * v68);
      ++v62;
      --v64;
    }
    while (v63 != (_DWORD)v62);
  }
  return result;
}

uint64_t *encode_pulses(uint64_t a1, int a2, int a3, uint64_t *a4)
{
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;

  v4 = *(_DWORD *)(a1 + 4 * (a2 - 1));
  v5 = v4 >> 31;
  if (v4 >= 0)
    v6 = *(_DWORD *)(a1 + 4 * (a2 - 1));
  else
    v6 = -v4;
  v7 = a2;
  v8 = 2;
  do
  {
    if ((int)v8 >= v6)
      v9 = v6;
    else
      v9 = v8;
    v10 = (uint64_t)*(&CELT_PVQ_U_ROW + v9);
    if ((int)v8 <= v6)
      v11 = v6;
    else
      v11 = v8;
    v5 += *(_DWORD *)(v10 + 4 * v11);
    v12 = *(_DWORD *)(a1 - 8 + 4 * v7);
    if (v12 >= 0)
      v13 = *(_DWORD *)(a1 - 8 + 4 * v7);
    else
      v13 = -v12;
    v6 += v13;
    if (v12 < 0)
    {
      if (v8 > v6)
        v14 = v6 + 1;
      else
        v14 = v8;
      v15 = (uint64_t)*(&CELT_PVQ_U_ROW + v14);
      if ((int)v8 <= v6 + 1)
        v16 = v6 + 1;
      else
        v16 = v8;
      v5 += *(_DWORD *)(v15 + 4 * v16);
    }
    --v7;
    ++v8;
  }
  while (v7 > 1);
  if (a2 >= a3)
    v17 = a3;
  else
    v17 = a2;
  v18 = (uint64_t)*(&CELT_PVQ_U_ROW + v17);
  if (a2 <= a3)
    v19 = a3;
  else
    v19 = a2;
  v20 = *(_DWORD *)(v18 + 4 * v19);
  if (a3 + 1 < a2)
    v21 = a3 + 1;
  else
    v21 = a2;
  v22 = (uint64_t)*(&CELT_PVQ_U_ROW + v21);
  if (a3 + 1 > a2)
    v23 = a3 + 1;
  else
    v23 = a2;
  return ec_enc_uint(a4, v5, *(_DWORD *)(v22 + 4 * v23) + v20);
}

uint64_t decode_pulses(int *a1, int a2, int a3, uint64_t a4)
{
  unsigned int v4;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  _UNKNOWN **v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  _UNKNOWN **v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  _UNKNOWN **v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;

  v4 = a3;
  if (a2 >= a3)
    v7 = a3;
  else
    v7 = a2;
  v8 = (uint64_t)*(&CELT_PVQ_U_ROW + v7);
  if (a2 <= a3)
    v9 = a3;
  else
    v9 = a2;
  v10 = *(_DWORD *)(v8 + 4 * v9);
  if (a3 + 1 < a2)
    v11 = a3 + 1;
  else
    v11 = a2;
  v12 = (uint64_t)*(&CELT_PVQ_U_ROW + v11);
  if (a3 + 1 > a2)
    v13 = a3 + 1;
  else
    v13 = a2;
  result = ec_dec_uint(a4, *(_DWORD *)(v12 + 4 * v13) + v10);
  if (a2 >= 3)
  {
    v15 = a2;
    do
    {
      if (v15 <= (int)v4)
      {
        v26 = (uint64_t)*(&CELT_PVQ_U_ROW + v15);
        v27 = *(_DWORD *)(v26 + 4 * (int)v4 + 4);
        if (result >= v27)
          v28 = *(_DWORD *)(v26 + 4 * (int)v4 + 4);
        else
          v28 = 0;
        v29 = result - v28;
        if (*(_DWORD *)(v26 + 4 * v15) <= v29)
        {
          v34 = v4;
          v30 = (int)v4 + 1;
          do
          {
            v32 = *(_DWORD *)(v26 + 4 * v34);
            v34 = v30 - 2;
            --v30;
          }
          while (v32 > v29);
        }
        else
        {
          v30 = v15;
          do
          {
            v31 = &CELT_PVQ_U_ROW + v30--;
            v32 = *((_DWORD *)*(v31 - 1) + v15);
          }
          while (v32 > v29);
        }
        v19 = result >= v27;
        result = v29 - v32;
        v33 = v4 - v30;
        if (v19)
          v33 = v30 - v4;
        v4 = v30;
      }
      else
      {
        v16 = &CELT_PVQ_U_ROW + (int)v4;
        v17 = *((_DWORD *)*v16 + v15);
        v18 = *((_DWORD *)v16[1] + v15);
        v19 = result < v17 || result >= v18;
        if (v19)
        {
          v20 = 0;
          if (result >= v18)
            v21 = *((_DWORD *)v16[1] + v15);
          else
            v21 = 0;
          v22 = result - v21;
          v23 = v16 - 1;
          do
          {
            v24 = *((_DWORD *)v23[v20--] + v15);
            v19 = v22 >= v24;
            v25 = v22 - v24;
          }
          while (!v19);
          v4 += v20;
          if (result >= v18)
            v33 = v20;
          else
            v33 = -(int)v20;
          result = v25;
        }
        else
        {
          v33 = 0;
          result = result - v17;
        }
      }
      *a1++ = v33;
    }
    while (v15-- > 3);
  }
  v36 = (2 * v4) | 1;
  if (result >= v36)
    v37 = (2 * v4) | 1;
  else
    v37 = 0;
  v38 = result - v37;
  v39 = v38 + 1;
  v40 = v4 - ((v38 + 1) >> 1);
  if (result >= v36)
    v40 = ((v38 + 1) >> 1) - v4;
  v41 = ((v38 + 1) & 0xFFFFFFFE) - 1;
  v19 = v39 >= 2;
  v42 = v39 >> 1;
  if (!v19)
    v41 = 0;
  *a1 = v40;
  a1[1] = (v42 - (v38 - v41)) ^ (v41 - v38);
  return result;
}

void *opus_custom_mode_create(int a1, int a2, int *a3)
{
  int v3;
  void *result;
  int v5;

  v3 = 0;
  while (a1 != 48000 || a2 << v3 != 960)
  {
    if (++v3 == 4)
    {
      result = 0;
      if (!a3)
        return result;
      v5 = -1;
      goto LABEL_9;
    }
  }
  result = &mode48000_960_120;
  if (!a3)
    return result;
  v5 = 0;
LABEL_9:
  *a3 = v5;
  return result;
}

uint64_t celt_decoder_get_size(int a1)
{
  _DWORD *v2;

  v2 = opus_custom_mode_create(48000, 960, 0);
  return ((4 * v2[1] + 8240) * a1 + 16 * v2[2] + 84);
}

uint64_t celt_decoder_init(_QWORD *a1, int a2, unsigned int a3)
{
  _DWORD *v6;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int *v16;

  v6 = opus_custom_mode_create(48000, 960, 0);
  if (a3 > 2)
    return 0xFFFFFFFFLL;
  if (!a1)
    return 4294967289;
  v8 = v6;
  bzero(a1, (int)((4 * v6[1] + 8240) * a3 + 16 * v6[2] + 84));
  *a1 = v8;
  *((_DWORD *)a1 + 2) = v8[1];
  *((_DWORD *)a1 + 3) = a3;
  *((_DWORD *)a1 + 4) = a3;
  *(_QWORD *)((char *)a1 + 20) = 1;
  *((_DWORD *)a1 + 7) = v8[3];
  a1[4] = 1;
  *((_DWORD *)a1 + 13) = 0;
  opus_custom_decoder_ctl(a1, 4028, v9, v10, v11, v12, v13, v14, v16);
  v15 = resampling_factor(a2);
  *((_DWORD *)a1 + 5) = v15;
  if (v15)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t celt_decode_with_ec(int32x2_t *a1, unsigned __int8 *a2, unsigned int a3, _WORD *a4, int a5, uint64_t *a6)
{
  uint64_t *v6;
  int32x2_t *v8;
  uint64_t v9;
  int v10;
  __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  __int32 v18;
  _DWORD *v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  int v26;
  uint64_t result;
  int v28;
  _BOOL4 v30;
  uint64_t v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  __int32 v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  _BOOL8 v43;
  signed int v44;
  _BOOL4 v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  BOOL v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  char *v62;
  int v63;
  _BOOL4 v64;
  int32x2_t *v65;
  uint64_t v66;
  signed int v67;
  _BOOL4 v68;
  int v69;
  uint64_t v70;
  int *v71;
  uint64_t *v72;
  uint64_t v73;
  size_t v74;
  unint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  uint64_t *v91;
  _BOOL4 v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t *v97;
  int v98;
  __int16 *v99;
  int v100;
  _BOOL4 v101;
  int v102;
  int v103;
  int v104;
  size_t v105;
  char *v106;
  _BYTE *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t *v110;
  int v111;
  unsigned int v112;
  char *v113;
  int v114;
  size_t v115;
  char *v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  uint64_t v122;
  int v123;
  int v124;
  int v125;
  uint64_t v126;
  int v127;
  int v128;
  size_t v129;
  char *v130;
  int v131;
  uint64_t v132;
  int v133;
  size_t v134;
  void **v135;
  char *v136;
  int v137;
  int v138;
  __int32 v139;
  int v140;
  uint64_t v141;
  int v142;
  _DWORD *v143;
  int v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t *v147;
  __int16 *v148;
  int v149;
  uint64_t v150;
  _DWORD *v151;
  uint64_t v152;
  int *v153;
  unint64_t v154;
  int v155;
  int32x2_t v156;
  char *v157;
  __int32 v158;
  __int32 v159;
  int v160;
  __int16 v161;
  int v162;
  _WORD *v163;
  uint64_t v164;
  int v165;
  unint64_t v166;
  uint64_t v167;
  char *v168;
  char *v169;
  char *v170;
  int v171;
  uint64_t v172;
  char *v173;
  int v174;
  uint64_t v175;
  int v176;
  uint64_t v177;
  uint64_t v178;
  __int16 v179;
  uint64_t v180;
  char *v181;
  int v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  char v189;
  char v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  int v197;
  uint64_t v198;
  uint64_t v199;
  int v200;
  int v201;
  unint64_t v202;
  unsigned int v203;
  _BOOL4 v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  uint64_t v208;
  _WORD *v209;
  int v210;
  int v211;
  char *v212;
  char *v213;
  int v214;
  int v215;
  char *v216;
  unsigned int v217;
  int v218;
  uint64_t v219;
  char *v220;
  __int16 *v221;
  _BOOL8 v222;
  int v223;
  char *v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  int32x2_t *v229;
  int v230;
  int v231;
  int v232;
  int v233;
  uint64_t v234;
  uint64_t *v235;
  _DWORD *v236;
  int v237;
  uint64_t v238;
  _OWORD v239[3];
  uint64_t v240;
  _QWORD v241[2];
  _QWORD v242[3];

  v6 = a6;
  v8 = a1;
  v9 = 0;
  v242[2] = *MEMORY[0x24BDAC8D0];
  v240 = 0;
  memset(v239, 0, sizeof(v239));
  v242[0] = 0;
  v242[1] = 0;
  v241[0] = 0;
  v241[1] = 0;
  v238 = 0;
  v10 = a1[1].i32[1];
  v233 = a1[2].i32[0];
  v11 = (__int16 *)*a1;
  v12 = *(int *)(*(_QWORD *)a1 + 8);
  v13 = *(unsigned int *)(*(_QWORD *)a1 + 8);
  v14 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  v230 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v16 = v230 + 2048;
  if (v10 <= 1)
    v17 = 1;
  else
    v17 = v10;
  v18 = a1[2].i32[1];
  v19 = (_DWORD *)&a1[10] + 1;
  do
  {
    v242[v9++] = v19;
    v19 += v16;
  }
  while (v17 != v9);
  v20 = *((_DWORD *)v11 + 8);
  if (v20 < 0)
    return 0xFFFFFFFFLL;
  v227 = v17;
  v21 = 0;
  v22 = 0;
  v23 = (v18 * a5);
  v15 = (_DWORD *)&a1[10] + 1;
  v24 = (char *)&a1[6 * v10 + 10] + 4 * v16 * v10 + 4;
  v25 = 2 * (int)v13;
  v26 = v20 + 1;
  while (*((_DWORD *)v11 + 10) << v22 != (_DWORD)v23)
  {
    ++v22;
    v21 += 8;
    if (v26 == v22)
      return 0xFFFFFFFFLL;
  }
  result = 0xFFFFFFFFLL;
  if (a3 <= 0x4FB && a4)
  {
    v28 = v8[3].i32[1];
    if (v28 >= *((_DWORD *)v11 + 3))
      v28 = *((_DWORD *)v11 + 3);
    if (!a2 || a3 <= 1)
    {
      celt_decode_lost(v8, a4, v23, v22);
      return ((int)v23 / v8[2].i32[1]);
    }
    v210 = v28;
    v206 = 24 * v10;
    v207 = v16 * v10;
    v237 = 0;
    v205 = 2 * (int)v13;
    v224 = (char *)&v15[v207 + v206 / 2];
    v213 = &v24[2 * v25];
    v212 = &v213[2 * v25];
    v226 = v14;
    LODWORD(v228) = a3;
    if (!a6)
    {
      v6 = (uint64_t *)v239;
      ec_dec_init((uint64_t *)v239, a2, v228);
      a3 = v228;
      v24 = v224;
    }
    v30 = v233 == 1 && (int)v13 > 0;
    v204 = v30;
    if (v30)
    {
      v31 = 0;
      do
      {
        v32 = *(__int16 *)&v24[v31];
        if (v32 <= *(__int16 *)&v24[2 * v13 + v31])
          LOWORD(v32) = *(_WORD *)&v24[2 * v13 + v31];
        *(_WORD *)&v24[v31] = v32;
        v31 += 2;
      }
      while (2 * v13 != v31);
    }
    v33 = 8 * a3;
    v34 = __clz(*((_DWORD *)v6 + 8));
    v35 = *((_DWORD *)v6 + 6) + v34 - 32;
    v223 = 8 * a3;
    v209 = a4;
    if (v35 < (int)(8 * a3))
    {
      if (v35 != 1)
      {
        v200 = 1;
        goto LABEL_39;
      }
      if (!ec_dec_bit_logp((uint64_t)v6, 15))
      {
        v35 = 1;
        v200 = 1;
        v33 = v223;
        goto LABEL_39;
      }
      v34 = __clz(*((_DWORD *)v6 + 8));
      v33 = v223;
    }
    v200 = 0;
    *((_DWORD *)v6 + 6) = v33 - v34 + 32;
    v35 = v33;
LABEL_39:
    v36 = 0;
    v37 = v8[3].i32[0];
    v235 = v6;
    v208 = v13;
    if (v37)
    {
      v38 = 0;
      v39 = 0;
    }
    else
    {
      v38 = 0;
      v39 = 0;
      if (v35 + 16 <= v33)
      {
        v39 = ec_dec_bit_logp((uint64_t)v6, 1);
        if (v39)
        {
          v40 = v12;
          v41 = ec_dec_uint((uint64_t)v6, 6u);
          v6 = v235;
          v36 = ec_dec_bits(v235, v41 + 4) + (16 << v41) - 1;
          v42 = ec_dec_bits(v235, 3u);
          v33 = v223;
          if ((int)(*((_DWORD *)v6 + 6) + __clz(*((_DWORD *)v6 + 8)) - 30) <= v223)
          {
            v39 = ec_dec_icdf((uint64_t)v235, tapset_icdf, 2);
            v33 = v223;
          }
          else
          {
            v39 = 0;
          }
          v38 = 3072 * v42 + 3072;
          v12 = v40;
        }
        else
        {
          v36 = 0;
          v38 = 0;
          v33 = v223;
        }
        v35 = *((_DWORD *)v6 + 6) + __clz(*((_DWORD *)v6 + 8)) - 32;
      }
    }
    v218 = v38;
    v231 = v39;
    v232 = v36;
    v43 = 0;
    v44 = v35 + 3;
    if (v22 && v44 <= v33)
    {
      v43 = ec_dec_bit_logp((uint64_t)v6, 3);
      v33 = v223;
      v44 = *((_DWORD *)v6 + 6) + __clz(*((_DWORD *)v6 + 8)) - 29;
    }
    v45 = 0;
    v222 = v43;
    if (v43)
      v46 = 1 << v22;
    else
      v46 = 0;
    v217 = v46;
    if (v44 <= v33)
      v45 = ec_dec_bit_logp((uint64_t)v6, 3);
    v211 = 1 << v22;
    v234 = v23;
    v214 = v10;
    v47 = v8[3].i32[0];
    v48 = v8[3].i32[1];
    v221 = v11;
    unquant_coarse_energy((uint64_t)v11, v47, v48, (uint64_t)v224, v45, (uint64_t)v6, v233, v22);
    v219 = v12;
    v49 = (char *)&v198 - ((4 * v12 + 15) & 0xFFFFFFFFFFFFFFF0);
    v220 = (char *)(4 * v12);
    bzero(v49, 4 * v12);
    v51 = v8[3].i32[0];
    v50 = v8[3].i32[1];
    v229 = v8;
    v52 = 8 * *((_DWORD *)v6 + 2);
    v53 = *((_DWORD *)v6 + 6) + __clz(*((_DWORD *)v6 + 8)) - 32;
    if (v222)
      v54 = 2;
    else
      v54 = 4;
    if (v22)
      v55 = v53 + v54 + 1 > v52;
    else
      v55 = 1;
    v56 = !v55;
    v216 = v49;
    v225 = v50;
    LODWORD(v236) = v56;
    v57 = 0;
    if ((int)v51 < (int)v50)
    {
      v58 = 0;
      v59 = v52 - v56;
      if (v222)
        v60 = 4;
      else
        v60 = 5;
      v61 = v50 - v51;
      v62 = &v49[4 * v51];
      do
      {
        if (v54 + v53 <= v59)
        {
          v58 ^= ec_dec_bit_logp((uint64_t)v6, v54);
          v53 = *((_DWORD *)v6 + 6) + __clz(*((_DWORD *)v6 + 8)) - 32;
          v57 |= v58;
        }
        *(_DWORD *)v62 = v58;
        v62 += 4;
        v54 = v60;
        --v61;
      }
      while (v61);
    }
    v63 = (int)v236;
    if ((_DWORD)v236)
    {
      v64 = v222;
      v65 = v229;
      v66 = (uint64_t)v216;
      if (tf_select_table[v57 + (uint64_t)(4 * (int)v222) + v21] == tf_select_table[4 * v222 + 2 + v57 + v21])
      {
        v63 = 0;
      }
      else
      {
        v68 = ec_dec_bit_logp((uint64_t)v235, 1);
        v64 = v222;
        v63 = 2 * v68;
      }
      v67 = v223;
    }
    else
    {
      v65 = v229;
      v67 = v223;
      v64 = v222;
      v66 = (uint64_t)v216;
    }
    if ((int)v51 < (int)v225)
    {
      v69 = v63 + 4 * v64;
      v70 = v225 - v51;
      v71 = (int *)(v66 + 4 * v51);
      do
      {
        *v71 = tf_select_table[*v71 + (uint64_t)v69 + v21];
        ++v71;
        --v70;
      }
      while (v70);
    }
    v72 = v235;
    if ((int)(*((_DWORD *)v235 + 6) + __clz(*((_DWORD *)v235 + 8)) - 28) <= v67)
      v203 = ec_dec_icdf((uint64_t)v235, spread_icdf, 5);
    else
      v203 = 2;
    v73 = (uint64_t)v221;
    v74 = (size_t)v220;
    v75 = (unint64_t)(v220 + 15) & 0xFFFFFFFFFFFFFFF0;
    bzero((char *)&v198 - v75, (size_t)v220);
    v76 = v73;
    v236 = (_DWORD *)((char *)&v198 - v75);
    v77 = v233;
    init_caps(v76, (uint64_t)&v198 - v75, v22, v233);
    v202 = v75;
    v225 = (uint64_t)&v198 - v75;
    bzero((char *)&v198 - v75, v74);
    v78 = (_DWORD)v228 << 6;
    v79 = ec_tell_frac((uint64_t)v72);
    v80 = v65[3].i32[1];
    v81 = v65[3].i32[0];
    v215 = v78;
    if ((int)v81 < v80)
    {
      v82 = 6;
      v83 = v226;
      v84 = v225;
      do
      {
        v85 = v81 + 1;
        v86 = ((*(__int16 *)(v83 + 2 * (v81 + 1)) - *(__int16 *)(v83 + 2 * v81)) * v77) << v22;
        v87 = 8 * v86;
        if (v86 <= 48)
          v86 = 48;
        if (v87 >= v86)
          v88 = v86;
        else
          v88 = v87;
        if (v79 + 8 * v82 >= v78)
        {
          *(_DWORD *)(v84 + 4 * v81) = 0;
        }
        else
        {
          if ((int)v236[v81] < 1)
          {
            v90 = 0;
          }
          else
          {
            v89 = 0;
            LODWORD(v228) = v82;
            while (1)
            {
              v90 = v89;
              v91 = v235;
              v92 = ec_dec_bit_logp((uint64_t)v235, v82);
              v93 = ec_tell_frac((uint64_t)v91);
              v79 = v93;
              if (!v92)
                break;
              v94 = v78 - v88;
              if (v93 + 8 < v78 - v88)
              {
                v89 = v90 + v88;
                LOBYTE(v82) = 1;
                v78 -= v88;
                if (v90 + v88 < v236[v81])
                  continue;
              }
              v90 += v88;
              v78 = v94;
              break;
            }
            v77 = v233;
            v83 = v226;
            v84 = v225;
            v82 = v228;
          }
          *(_DWORD *)(v84 + 4 * v81) = v90;
          v80 = v229[3].i32[1];
          if (v82 <= 3)
            v95 = 3;
          else
            v95 = v82;
          v96 = v95 - 1;
          if (v90 > 0)
            v82 = v96;
        }
        ++v81;
      }
      while (v85 < v80);
    }
    v228 = (uint64_t)&v198 - v202;
    bzero((char *)&v198 - v202, (size_t)v220);
    v97 = v235;
    if (v79 + 48 <= v78)
      v98 = ec_dec_icdf((uint64_t)v235, trim_icdf, 7);
    else
      v98 = 5;
    v99 = v221;
    v100 = ec_tell_frac((uint64_t)v97);
    v101 = 0;
    v102 = v215 + ~v100;
    v8 = v229;
    v103 = 0;
    if (v22 >= 2 && v222)
    {
      v101 = v102 >= (int)v21 + 16;
      if (v102 < (int)v21 + 16)
        v103 = 0;
      else
        v103 = 8;
    }
    v201 = v103;
    LODWORD(v202) = v101;
    v104 = v102 - v103;
    v105 = (size_t)v220;
    v106 = (char *)&v198 - ((unint64_t)(v220 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v106, (size_t)v220);
    bzero(v106, v105);
    v107 = (_BYTE *)v8[3].u32[0];
    v108 = v8[3].u32[1];
    v220 = v106;
    v109 = v228;
    v197 = v104;
    v110 = v235;
    v111 = v77;
    v112 = compute_allocation((uint64_t)v99, v107, v108, v225, (uint64_t)v236, v98, (int *)&v238 + 1, (int *)&v238, v197, (unsigned int *)&v237, (uint64_t)v106, v228, (uint64_t)v106, v77, v22, v235, 0, 0, 0);
    unquant_fine_energy((uint64_t)v99, v8[3].i32[0], v8[3].i32[1], (uint64_t)v224, v109, v110, v111);
    v225 = (v219 * v111);
    v113 = (char *)&v198 - (((int)v225 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v113, (int)v225);
    v114 = v234;
    v199 = (v234 * v111);
    v115 = 2 * (int)v199;
    v116 = (char *)&v198 - ((v115 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v116, v115);
    v117 = v8[3].i32[0];
    v118 = v8[3].u32[1];
    if (v111 == 2)
      v119 = (uint64_t)&v116[2 * v114];
    else
      v119 = 0;
    v236 = v106;
    quant_all_bands(0, (uint64_t)v99, v117, v118, (uint64_t)v116, v119, (uint64_t)v113, 0, (uint64_t)v106, v217, v203, v238, HIDWORD(v238), (uint64_t)v216, v215 - v201, v237, (uint64_t)v110, v22, v112,
      &v8[5]);
    v120 = 0;
    if ((v202 & 1) != 0)
      v120 = ec_dec_bits(v110, 1u);
    v121 = v233;
    v122 = (uint64_t)v224;
    unquant_energy_finalise((uint64_t)v99, v8[3].i32[0], v8[3].i32[1], (uint64_t)v224, v228, (uint64_t)v220, v223 - *((_DWORD *)v110 + 6) - __clz(*((_DWORD *)v110 + 8)) + 32, v110, v233);
    v123 = v234;
    v124 = v230;
    if (v120)
      anti_collapse(v99, (uint64_t)v116, (uint64_t)v113, v22, v121, v234, v8[3].i32[0], v8[3].i32[1], v122, (uint64_t)v213, (uint64_t)v212, (uint64_t)v236, v8[5].i32[0]);
    v125 = v121;
    v126 = v123;
    v127 = v214;
    if (v214 <= v125)
      v128 = v125;
    else
      v128 = v214;
    v129 = 4 * v123 * v128;
    v130 = (char *)&v198 - ((v129 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v130, v129);
    v236 = v130;
    if ((v200 & 1) != 0)
    {
      denormalise_bands((uint64_t)v99, (uint64_t)v116, (uint64_t)v130, (uint64_t)v224, v8[3].i32[0], v210, v125, v211);
      v131 = v234;
      v132 = v227;
    }
    else
    {
      v132 = v227;
      if ((int)v225 >= 1)
        memset_pattern16(v224, &unk_214F95410, 2 * v225);
      v131 = v234;
      if ((int)v199 >= 1)
        bzero(v236, 4 * v199);
    }
    if (v124 >= 0)
      v133 = v124;
    else
      v133 = v124 + 1;
    v134 = 4 * ((v133 >> 1) - v131 + 2048);
    v135 = (void **)v242;
    do
    {
      v136 = (char *)*v135++;
      memmove(v136, &v136[4 * v126], v134);
      --v132;
    }
    while (v132);
    v137 = 0;
    v138 = *(__int16 *)(v226 + 2 * v210) << v22;
    v139 = v8[2].i32[1];
    if (v233 <= 1)
      v140 = 1;
    else
      v140 = v233;
    v141 = v234;
    v142 = (int)v234 / v139;
    v143 = v236;
    do
    {
      v144 = v138;
      if (v139 != 1)
      {
        if (v138 >= v142)
          v144 = v142;
        else
          v144 = v138;
      }
      if (v144 < (int)v141)
      {
        bzero(&v143[v144 + v137], 4 * (v141 + ~v144) + 4);
        v143 = v236;
      }
      v137 += v141;
      --v140;
    }
    while (v140);
    v145 = 0;
    v146 = 8 * v227;
    do
    {
      v241[v145 / 8] = v242[v145 / 8] - 4 * v126 + 0x2000;
      v145 += 8;
    }
    while (v146 != v145);
    v147 = v235;
    v148 = v221;
    v149 = v230;
    if (v127 == 2 && v233 == 1 && (int)v141 >= 1)
    {
      v150 = v141;
      v151 = v143;
      do
      {
        v151[v126] = *v151;
        ++v151;
        --v150;
      }
      while (v150);
    }
    if (v127 == 1 && v233 == 2 && (int)v141 >= 1)
    {
      v152 = v141;
      v153 = v143;
      do
      {
        *v153 = (v153[v126] + *v153) >> 1;
        ++v153;
        --v152;
      }
      while (v152);
    }
    compute_inv_mdcts((unsigned int *)v148, v217, (uint64_t)v143, (uint64_t)v241, v127, v22);
    v154 = 0;
    v155 = (__int16)v218;
    do
    {
      v156 = vmax_s32(v8[7], (int32x2_t)0xF0000000FLL);
      v8[7] = v156;
      v157 = (char *)v241[v154 / 8];
      comb_filter(v157, v157, v156.i32[1], v156.i32[0], *((_DWORD *)v148 + 10), v8[8].i16[1], v8[8].i16[0], v8[9].i32[0], v8[8].i32[1], *((__int16 **)v148 + 8), v149);
      if (v22)
        comb_filter(&v157[4 * *((int *)v148 + 10)], &v157[4 * *((int *)v148 + 10)], v8[7].i32[0], v232, v234 - *((_DWORD *)v148 + 10), v8[8].i16[0], v155, v8[8].i32[1], v231, *((__int16 **)v148 + 8), v149);
      v154 += 8;
    }
    while (v146 != v154);
    v158 = v8[7].i32[0];
    v8[8].i16[1] = v8[8].i16[0];
    v159 = v8[8].i32[1];
    v160 = v232;
    v8[7].i32[0] = v232;
    v8[7].i32[1] = v158;
    v161 = v218;
    v8[8].i16[0] = v218;
    v162 = v231;
    v8[8].i32[1] = v231;
    v8[9].i32[0] = v159;
    if (v22)
    {
      v8[7].i32[1] = v160;
      v8[8].i16[1] = v161;
      v8[9].i32[0] = v162;
    }
    v163 = v209;
    LODWORD(v23) = v234;
    v164 = v219;
    v165 = v208;
    v166 = v206;
    v167 = v205;
    v168 = v224;
    v169 = v213;
    v170 = v212;
    v171 = v211;
    if (v204)
    {
      v172 = v208;
      v173 = v224;
      do
      {
        *(_WORD *)&v173[2 * v164] = *(_WORD *)v173;
        v173 += 2;
        --v172;
      }
      while (v172);
    }
    if (v222)
    {
      v174 = v214;
      if ((int)v164 >= 1)
      {
        if ((int)v167 <= 1)
          v175 = 1;
        else
          v175 = v167;
        do
        {
          v176 = *(__int16 *)&v168[2 * v167];
          if (v176 >= *(__int16 *)v168)
            LOWORD(v176) = *(_WORD *)v168;
          *(_WORD *)&v168[2 * v167] = v176;
          v168 += 2;
          --v175;
        }
        while (v175);
      }
    }
    else
    {
      v174 = v214;
      if (v165 >= 1)
      {
        if ((int)v167 <= 1)
          v177 = 1;
        else
          v177 = v167;
        v178 = v177;
        do
        {
          v179 = *(_WORD *)v169;
          v169 += 2;
          *(_WORD *)v170 = v179;
          v170 += 2;
          --v178;
        }
        while (v178);
        v180 = v177;
        v181 = v168;
        do
        {
          *(_WORD *)&v181[2 * v167] = *(_WORD *)v181;
          v181 += 2;
          --v180;
        }
        while (v180);
        do
        {
          v182 = v171 + *(__int16 *)&v168[6 * v167];
          if (v182 >= *(__int16 *)v168)
            LOWORD(v182) = *(_WORD *)v168;
          *(_WORD *)&v168[6 * v167] = v182;
          v168 += 2;
          --v177;
        }
        while (v177);
      }
    }
    v183 = 0;
    v184 = (uint64_t)&v8[10] + 4 * v207 + 2 * v166 + 4;
    v185 = v184 + 4 * v167;
    v186 = v184 + 2 * v167;
    v187 = v8[3].u32[0];
    v188 = v8[3].i32[1];
    v189 = 1;
    do
    {
      v190 = v189;
      if ((int)v187 >= 1)
      {
        v191 = 0;
        do
        {
          *(_WORD *)(v184 + 2 * v183 * (int)v164 + v191) = 0;
          *(_WORD *)(v185 + 2 * v183 * (int)v164 + v191) = -28672;
          *(_WORD *)(v186 + 2 * v183 * (int)v164 + v191) = -28672;
          v191 += 2;
        }
        while (2 * v187 != v191);
      }
      if ((int)v188 < v165)
      {
        v192 = 0;
        v193 = v188 + v183 * v165;
        v194 = v184 + 2 * v193;
        v195 = v185 + 2 * v193;
        v196 = v186 + 2 * v193;
        do
        {
          *(_WORD *)(v194 + 2 * v192) = 0;
          *(_WORD *)(v195 + 2 * v192) = -28672;
          *(_WORD *)(v196 + 2 * v192++) = -28672;
        }
        while (v164 - v188 != v192);
      }
      v189 = 0;
      v183 = 1;
    }
    while ((v190 & 1) != 0);
    v8[5].i32[0] = *((_DWORD *)v147 + 8);
    deemphasis((uint64_t)v241, v163, v23, v174, v8[2].i32[1], v148 + 8, (uint64_t)&v8[9] + 4, v236);
    v8[6].i32[1] = 0;
    if ((int)(*((_DWORD *)v147 + 6) + __clz(*((_DWORD *)v147 + 8)) - 32) > v223)
      return 4294967293;
    if (*((_DWORD *)v147 + 12))
      v8[5].i32[1] = 1;
    return ((int)v23 / v8[2].i32[1]);
  }
  return result;
}

uint64_t celt_decode_lost(_DWORD *a1, _WORD *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  int v18;
  int v19;
  size_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  char *v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _WORD *v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  char *v44;
  uint64_t v45;
  _DWORD *v46;
  char v47;
  _DWORD *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  size_t v57;
  void **v58;
  uint64_t v59;
  char *v60;
  unsigned int *v61;
  int v62;
  char *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  int8x16_t v73;
  uint64_t v74;
  int64x2_t v75;
  int64x2_t v76;
  int32x4_t v77;
  int32x4_t v78;
  int32x4_t v79;
  int32x4_t v80;
  int32x4_t v81;
  int32x4_t v82;
  int32x4_t v83;
  int64x2_t v84;
  uint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  __int16 v91;
  unsigned __int16 v92;
  int v93;
  __int16 *v94;
  uint64_t v95;
  __int16 *v96;
  uint64_t v97;
  int v98;
  int v99;
  char v100;
  unsigned int v101;
  __int16 v102;
  unsigned __int16 v103;
  int v104;
  int v105;
  unsigned int v106;
  __int16 v107;
  uint64_t v108;
  int v109;
  unsigned int v110;
  unsigned int v111;
  int v112;
  int v113;
  unsigned int v114;
  uint64_t v115;
  __int16 v116;
  int v117;
  unsigned int v118;
  int v119;
  unsigned int v120;
  uint64_t v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  uint64_t v127;
  int v128;
  __int16 *v129;
  uint64_t v130;
  unsigned int v131;
  int v132;
  int v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  __int16 v137;
  int v138;
  uint64_t v139;
  __int16 *v140;
  int v141;
  int v142;
  int v143;
  uint64_t v144;
  _DWORD *v145;
  uint64_t v146;
  __int16 *v147;
  int *v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  uint64_t result;
  uint64_t v156;
  _DWORD *v157;
  int v158;
  _WORD *v159;
  int v160;
  unsigned int *v161;
  __int128 v162;
  __int128 v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  size_t v169;
  __int16 *v170;
  uint64_t v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  _DWORD *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  int v182;
  signed int v183[7];
  _QWORD v184[2];
  int *v185[3];

  LODWORD(v181) = a4;
  v4 = a3;
  v159 = a2;
  v6 = 0;
  v185[2] = *(int **)MEMORY[0x24BDAC8D0];
  v185[0] = 0;
  v185[1] = 0;
  v7 = *(_QWORD *)a1;
  v178 = *(int *)(*(_QWORD *)a1 + 8);
  v8 = *(int *)(v7 + 4);
  v176 = *(unsigned int *)(v7 + 4);
  v9 = a1[3];
  v184[0] = 0;
  v184[1] = 0;
  v177 = v8;
  v10 = v8 + 2048;
  v174 = (int)a3;
  v171 = -(uint64_t)(int)a3;
  if (v9 <= 1)
    v11 = 1;
  else
    v11 = v9;
  LODWORD(v169) = v11;
  v161 = (unsigned int *)v7;
  v180 = *(_QWORD *)(v7 + 24);
  v12 = a1;
  do
  {
    v185[v6] = v12 + 21;
    v184[v6++] = (char *)v12 + 8276 - 4 * (int)a3;
    v12 += v10;
  }
  while (v11 != v6);
  v166 = (v10 * v9);
  v13 = (uint64_t)&a1[(int)v166 + 21];
  v14 = a1[13];
  v15 = (int)a1[6];
  v158 = a1[5];
  v16 = v14 <= 4 && v15 == 0;
  v17 = !v16;
  v18 = v9 * a3;
  if (v16)
    v19 = a3;
  else
    v19 = v9 * a3;
  v20 = 4 * v19;
  v21 = (char *)&v156 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v21, v20);
  v175 = a1;
  v179 = v4;
  v167 = v9;
  v172 = v14;
  v173 = v11;
  v157 = v21;
  if (v17 != 1)
  {
    v181 = v13;
    v182 = 0;
    if (v14)
    {
      v28 = a1[12];
      v29 = 26214;
    }
    else
    {
      bzero(&v156 - 256, 0x800uLL);
      pitch_downsample(v185, (char *)&v156 - 2048, 2048, v9);
      pitch_search((__int16 *)&v156 - 664, (__int16 *)&v156 - 1024, 1328, 620, &v182);
      v28 = 720 - v182;
      a1[12] = 720 - v182;
      v29 = 0x7FFF;
    }
    LODWORD(v166) = v29;
    v182 = v28;
    v62 = v177;
    v63 = (char *)&v156 - ((4 * v177 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v63, 4 * v177);
    v170 = (__int16 *)&v156;
    v64 = &v156 - 256;
    bzero(&v156 - 256, 0x800uLL);
    v65 = 0;
    v66 = *((_QWORD *)v161 + 8);
    v178 = (2048 - v179);
    v169 = 4 * (int)v178;
    if ((int)v176 >= 0)
      v67 = v176;
    else
      v67 = v176 + 1;
    v165 = (v67 >> 1);
    v180 = (v176 + v179);
    v68 = (int)v176 + (int)v179;
    LODWORD(v168) = 2047 - v179;
    v160 = v62 - v179 + 2048;
    v164 = v62 - 1;
    v163 = xmmword_214F95400;
    v162 = xmmword_214EFA5E0;
    v69 = v181;
    while (1)
    {
      v70 = 0;
      v71 = (char *)v185[v65];
      v72 = 4096;
      do
      {
        *(int16x8_t *)&v64[v70] = vrshrn_high_n_s32(vrshrn_n_s32(*(int32x4_t *)&v71[v72], 0xCuLL), *(int32x4_t *)&v71[v72 + 16], 0xCuLL);
        v72 += 32;
        v70 += 2;
      }
      while (v70 != 256);
      if (!v14)
      {
        _celt_autocorr((char *)&v156 - 2048, (unsigned int *)v183, v66, v177, 24, 1024);
        v73.i64[0] = 0xFFFF0000FFFFLL;
        v73.i64[1] = 0xFFFF0000FFFFLL;
        v183[0] += v183[0] >> 13;
        v74 = 1;
        v75 = (int64x2_t)v162;
        v76 = (int64x2_t)v163;
        do
        {
          v77.i64[0] = (v75.i32[0] * v75.i32[0]);
          v77.i64[1] = (v75.i32[2] * v75.i32[2]);
          v78.i64[0] = (v76.i32[0] * v76.i32[0]);
          v78.i64[1] = (v76.i32[2] * v76.i32[2]);
          v79 = *(int32x4_t *)&v183[v74];
          v80 = vuzp1q_s32(v77, v78);
          v81 = vaddq_s32(v80, v80);
          v82 = (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v79, v73), v81), 0xFuLL);
          v83 = vmulq_s32(v81, vshrq_n_s32(v79, 0x10uLL));
          *(int32x4_t *)&v183[v74] = vsubq_s32(vsubq_s32(v79, vaddq_s32(v83, v83)), v82);
          v84 = vdupq_n_s64(4uLL);
          v76 = vaddq_s64(v76, v84);
          v75 = vaddq_s64(v75, v84);
          v74 += 4;
        }
        while (v74 != 25);
        _celt_lpc((_WORD *)(v69 + 2 * (24 * v65)), v183, 24);
      }
      v85 = 0;
      v86 = v182;
      v87 = 2 * v182;
      if (2 * v182 >= 1024)
        v87 = 1024;
      v88 = v87;
      v89 = 2047 - v87;
      do
      {
        *(_WORD *)((char *)v183 + v85) = (*(_DWORD *)&v71[4 * v89--] + 2048) >> 12;
        v85 += 2;
      }
      while (v85 != 48);
      v90 = v181 + 2 * (24 * v65);
      celt_fir(&v170[-v88], v90, (uint64_t)&v170[-v88], v88, 24, v183);
      if (v86 < 1)
      {
        v111 = 1;
        v110 = 1;
      }
      else
      {
        v91 = 0;
        v92 = 0;
        v93 = 1024 - v88;
        v94 = (__int16 *)v64 + 1024 - (int)v88;
        v95 = v88;
        v96 = v94;
        v97 = v88;
        do
        {
          v99 = *v96++;
          v98 = v99;
          if (v99 >= v92)
            v92 = v98;
          if (v91 >= v98)
            v91 = v98;
          --v97;
        }
        while (v97);
        v100 = 0;
        if (v92 <= -v91)
          v101 = -v91;
        else
          v101 = v92;
        if (v101 >= 0x400)
        {
          v102 = 0;
          v103 = 0;
          do
          {
            v105 = *v94++;
            v104 = v105;
            if (v105 >= v103)
              v103 = v104;
            if (v102 >= v104)
              v102 = v104;
            --v95;
          }
          while (v95);
          if (v103 <= -v102)
            v106 = -v102;
          else
            v106 = v103;
          v107 = ((62 - 2 * __clz(v106)) & 0xFFFE) - 20;
          if (v106)
            v100 = v107;
          else
            v100 = -20;
        }
        LODWORD(v108) = (int)v88 >> 1;
        if ((int)v88 >> 1 <= 1)
          v108 = 1;
        else
          v108 = v108;
        v109 = 1024 - ((int)v88 >> 1);
        v110 = 1;
        v111 = 1;
        do
        {
          v112 = *((__int16 *)v64 + v109);
          v111 += (v112 * v112) >> v100;
          v113 = *((__int16 *)v64 + v93);
          v110 += (v113 * v113) >> v100;
          ++v93;
          ++v109;
          --v108;
        }
        while (v108);
      }
      if (v111 >= v110)
        v114 = v110;
      else
        v114 = v111;
      v115 = frac_div32(v114 >> 1, v110);
      v116 = celt_sqrt(v115);
      memmove(v71, &v71[4 * v174], v169);
      if ((int)v68 < 1)
      {
        v118 = 0;
      }
      else
      {
        v117 = 0;
        v118 = 0;
        v119 = 1024 - v182;
        v120 = (v116 * (_DWORD)v166) >> 15;
        v121 = v180;
        v122 = 1024 - v182 - v179 + 1024;
        v123 = v178;
        do
        {
          v124 = v182;
          if (v117 < v182)
            v124 = 0;
          else
            LOWORD(v120) = (v116 * (__int16)v120) >> 15;
          v125 = v117 - v124;
          *(_DWORD *)&v71[4 * v123] = (((__int16)v120 * *((__int16 *)v64 + v125 + v119)) >> 3) & 0xFFFFF000;
          v126 = (16 * *(_DWORD *)&v71[4 * v122 + 4 * v125] + 0x8000) >> 16;
          v118 += (v126 * v126) >> 8;
          v117 = v125 + 1;
          ++v123;
          --v121;
        }
        while (v121);
      }
      v127 = 0;
      v128 = v168;
      do
      {
        *(_WORD *)((char *)v183 + v127) = (*(_DWORD *)&v71[4 * v128--] + 2048) >> 12;
        v127 += 2;
      }
      while (v127 != 48);
      v129 = (__int16 *)v90;
      v130 = v180;
      celt_iir(&v71[4 * v171 + 0x2000], v129, (uint64_t)&v71[4 * v171 + 0x2000], v180, 24, v183);
      if ((int)v130 < 1)
      {
        v46 = v175;
        if (v118)
        {
          v131 = 0;
LABEL_121:
          if (v118 < v131)
          {
            v136 = frac_div32((v118 >> 1) + 1, v131 + 1);
            v137 = celt_sqrt(v136);
            v138 = 2 * v137;
            if ((int)v176 >= 1)
            {
              v139 = v176;
              v140 = (__int16 *)v66;
              v141 = v178;
              do
              {
                v142 = *v140++;
                *(_DWORD *)&v71[4 * v141] = ((*(int *)&v71[4 * v141] >> 15) & 0xFFFFFFFE)
                                          * ((int)(((v138 ^ 0xFFFE) * v142) & 0xFFFF0000 ^ 0x7FFF0000) >> 16)
                                          + ((((int)(((v138 ^ 0xFFFE) * v142) & 0xFFFF0000 ^ 0x7FFF0000) >> 16)
                                            * (unsigned __int16)*(_DWORD *)&v71[4 * v141]) >> 15);
                ++v141;
                --v139;
              }
              while (v139);
            }
            if ((int)v179 >= 1)
            {
              v143 = v160;
              v144 = v177;
              do
              {
                *(_DWORD *)&v71[4 * v143] = v138 * (*(int *)&v71[4 * v143] >> 16)
                                          + (((unsigned __int16)*(_DWORD *)&v71[4 * v143] * v137) >> 15);
                ++v144;
                ++v143;
              }
              while (v144 < v68);
            }
          }
        }
      }
      else
      {
        v131 = 0;
        v132 = v178;
        do
        {
          v133 = (16 * *(_DWORD *)&v71[4 * v132] + 0x8000) >> 16;
          v131 += (v133 * v133) >> 8;
          ++v132;
          --v130;
        }
        while (v130);
        v46 = v175;
        if (v118 > v131 >> 2)
          goto LABEL_121;
        if ((int)v68 >= 1)
        {
          v134 = v180;
          v135 = v178;
          do
          {
            *(_DWORD *)&v71[4 * v135++] = 0;
            --v134;
          }
          while (v134);
        }
      }
      comb_filter(v63, v71 + 0x2000, v46[14], v46[14], v177, (__int16)-*((_WORD *)v46 + 32), (__int16)-*((_WORD *)v46 + 32), v46[17], v46[17], 0, 0);
      if ((int)v176 > 1)
      {
        v145 = v71 + 0x2000;
        v146 = v165;
        v147 = (__int16 *)v66;
        v148 = (int *)v63;
        v149 = v164;
        do
        {
          v151 = *v147++;
          v150 = v151;
          v152 = (*(int *)&v63[4 * v149] >> 16) * v151;
          v153 = *(__int16 *)(v66 + 2 * v149);
          v154 = *v148++;
          *v145++ = (((unsigned __int16)v154 * v153) >> 15)
                  + (((unsigned __int16)*(_DWORD *)&v63[4 * v149--] * v150) >> 15)
                  + 2 * (v152 + (v154 >> 16) * v153);
          --v146;
        }
        while (v146);
      }
      ++v65;
      v14 = v172;
      v69 = v181;
      if (v65 == v173)
      {
        LODWORD(v4) = v179;
        v9 = v167;
        v61 = v161;
        v52 = v158;
        v48 = v157;
        goto LABEL_133;
      }
    }
  }
  v170 = (__int16 *)(v13 + 48 * v9);
  v22 = v14;
  v23 = (int)a1[7];
  LODWORD(v24) = v161[3];
  if ((int)v23 < (int)v24)
    LODWORD(v24) = a1[7];
  LODWORD(v177) = v24;
  if ((int)v15 <= (int)v24)
    v24 = v24;
  else
    v24 = v15;
  v168 = v24;
  v25 = 2 * v18;
  v26 = (char *)&v156 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v26, v25);
  if (v22 <= 4)
  {
    v27 = (uint64_t)v170;
    v30 = 0;
    if (v22)
      v31 = -512;
    else
      v31 = -1536;
    v32 = (uint64_t)&a1[12 * v9 + 21 + (int)v166] + 2 * v15;
    v33 = 2 * v178;
    do
    {
      if ((int)v15 < (int)v23)
      {
        v34 = v23 - v15;
        v35 = (_WORD *)v32;
        do
        {
          *v35++ += v31;
          --v34;
        }
        while (v34);
      }
      ++v30;
      v32 += v33;
    }
    while (v30 != v11);
  }
  else
  {
    v27 = (uint64_t)&v170[2 * v178 + 2 * v178 + 2 * v178];
  }
  v36 = a1[10];
  v170 = (__int16 *)v27;
  if (v9 >= 1)
  {
    v37 = 0;
    v38 = 0;
    v39 = (int)v168;
    v171 = v15;
    do
    {
      LODWORD(v178) = v38;
      if ((int)v15 < (int)v177)
      {
        v40 = v38 * v4;
        do
        {
          v41 = *(__int16 *)(v180 + 2 * v15);
          v42 = v41 << v181;
          ++v15;
          v43 = (*(__int16 *)(v180 + 2 * v15) - v41) << v181;
          if (v43 >= 1)
          {
            v44 = &v26[2 * v37 + 2 * v42];
            v45 = ((*(__int16 *)(v180 + 2 * v15) - v41) << v181);
            do
            {
              v36 = celt_lcg_rand(v36);
              *(_WORD *)v44 = v36 >> 20;
              v44 += 2;
              --v45;
            }
            while (v45);
          }
          renormalise_vector((__int16 *)&v26[2 * v42 + 2 * v40], v43, 0x7FFF);
        }
        while (v15 != v39);
      }
      v38 = v178 + 1;
      LODWORD(v4) = v179;
      v37 += v179;
      v9 = v167;
      v15 = v171;
    }
    while ((_DWORD)v178 + 1 != v167);
  }
  v46 = v175;
  v175[10] = v36;
  v47 = v181;
  v48 = v157;
  v49 = v168;
  denormalise_bands((uint64_t)v161, (uint64_t)v26, (uint64_t)v157, (uint64_t)v170, v15, v168, v9, 1 << v181);
  v50 = 0;
  v51 = *(__int16 *)(v180 + 2 * v49) << v47;
  v52 = v158;
  v53 = (int)v4 / v158;
  v54 = v173;
  v55 = v169;
  do
  {
    v56 = v51;
    if (v52 != 1)
    {
      if (v51 >= v53)
        v56 = v53;
      else
        v56 = v51;
    }
    if (v56 < (int)v4)
      bzero(&v48[v56 + v50], 4 * (~v56 + v4) + 4);
    v50 += v4;
    --v55;
  }
  while (v55);
  v57 = 4 * (((int)v176 >> 1) - (int)v4 + 2048);
  v58 = (void **)v185;
  v59 = v174;
  do
  {
    v60 = (char *)*v58++;
    memmove(v60, &v60[4 * v59], v57);
    --v54;
  }
  while (v54);
  v61 = v161;
  compute_inv_mdcts(v161, 0, (uint64_t)v48, (uint64_t)v184, v9, v181);
  v14 = v172;
LABEL_133:
  result = deemphasis((uint64_t)v184, v159, v4, v9, v52, (__int16 *)v61 + 8, (uint64_t)(v46 + 19), v48);
  v46[13] = v14 + 1;
  return result;
}

unsigned int *compute_inv_mdcts(unsigned int *result, unsigned int a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  unsigned int *v6;
  uint64_t v7;
  signed int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v6 = result;
  v7 = result[1];
  v8 = result[10];
  if (a2)
  {
    v9 = result[8];
  }
  else
  {
    v8 <<= a6;
    v9 = result[8] - a6;
    a2 = 1;
  }
  v20 = 0;
  v10 = 0;
  if (a5 <= 1)
    v11 = 1;
  else
    v11 = a5;
  v19 = v11;
  v12 = 4 * v8;
  v18 = v8 * a2;
  v13 = a2;
  v21 = a4;
  do
  {
    if ((int)v13 >= 1)
    {
      v14 = 0;
      v15 = (int *)(a3 + 4 * v20);
      v16 = v13;
      do
      {
        result = (unsigned int *)clt_mdct_backward((int *)v6 + 18, v15, *(_QWORD *)(a4 + 8 * v10) + v14, *((_QWORD *)v6 + 8), v7, v9, v13);
        a4 = v21;
        v14 += v12;
        ++v15;
        --v16;
      }
      while (v16);
    }
    ++v10;
    v20 += v18;
  }
  while (v10 != v19);
  return result;
}

uint64_t deemphasis(uint64_t result, _WORD *a2, int a3, int a4, int a5, __int16 *a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  int v19;
  uint64_t v20;
  _WORD *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  _DWORD *v26;
  _WORD *v27;
  int v28;

  v8 = 0;
  v9 = 0;
  v10 = *a6;
  v11 = 2 * v10;
  if (a4 <= 1)
    v12 = 1;
  else
    v12 = a4;
  v13 = 2 * a4;
  do
  {
    v14 = *(_DWORD *)(a7 + 4 * v8);
    v15 = *(int **)(result + 8 * v8);
    if (a5 <= 1)
    {
      v20 = a3;
      v21 = a2;
      if (a3 >= 1)
      {
        do
        {
          v22 = *v15++;
          v23 = v22 + v14;
          v14 = v11 * ((v22 + v14) >> 16) + (((unsigned __int16)(v22 + v14) * v10) >> 15);
          v24 = (v23 + 2048) >> 12;
          if (v24 <= -32768)
            v24 = -32768;
          if (v24 >= 0x7FFF)
            LOWORD(v24) = 0x7FFF;
          *v21 = v24;
          v21 = (_WORD *)((char *)v21 + v13);
          --v20;
        }
        while (v20);
      }
    }
    else
    {
      if (a3 >= 1)
      {
        v16 = a3;
        v17 = a8;
        do
        {
          v18 = *v15++;
          v19 = v18 + v14;
          v14 = v11 * ((v18 + v14) >> 16) + (((unsigned __int16)(v18 + v14) * v10) >> 15);
          *v17++ = v19;
          --v16;
        }
        while (v16);
      }
      v9 = 1;
    }
    *(_DWORD *)(a7 + 4 * v8) = v14;
    if (v9 && a3 / a5 >= 1)
    {
      v25 = (a3 / a5);
      v26 = a8;
      v27 = a2;
      do
      {
        v28 = (*v26 + 2048) >> 12;
        if (v28 <= -32768)
          v28 = -32768;
        if (v28 >= 0x7FFF)
          LOWORD(v28) = 0x7FFF;
        *v27 = v28;
        v27 = (_WORD *)((char *)v27 + v13);
        v26 += a5;
        --v25;
      }
      while (v25);
    }
    ++v8;
    ++a2;
  }
  while (v8 != v12);
  return result;
}

uint64_t opus_custom_decoder_ctl(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t result;
  int *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _WORD *v17;
  _WORD *v18;

  result = 4294967291;
  switch(a2)
  {
    case 10007:
      if (!a9)
        goto LABEL_29;
      result = 0;
      *a9 = a1[11];
      a1[11] = 0;
      break;
    case 10008:
      if (((_DWORD)a9 - 3) < 0xFFFFFFFE)
        goto LABEL_29;
      result = 0;
      a1[4] = (_DWORD)a9;
      break;
    case 10009:
    case 10011:
    case 10013:
    case 10014:
      return result;
    case 10010:
      if ((a9 & 0x80000000) != 0 || (int)a9 >= *(_DWORD *)(*(_QWORD *)a1 + 8))
        goto LABEL_29;
      result = 0;
      a1[6] = (_DWORD)a9;
      break;
    case 10012:
      if ((int)a9 < 1 || (int)a9 > *(_DWORD *)(*(_QWORD *)a1 + 8))
        goto LABEL_29;
      result = 0;
      a1[7] = (_DWORD)a9;
      break;
    case 10015:
      if (a9)
      {
        result = 0;
        *(_QWORD *)a9 = *(_QWORD *)a1;
      }
      else
      {
LABEL_29:
        result = 0xFFFFFFFFLL;
      }
      break;
    case 10016:
      result = 0;
      a1[8] = (_DWORD)a9;
      break;
    default:
      switch(a2)
      {
        case 4027:
          v11 = a9;
          if (!a9)
            goto LABEL_29;
          result = 0;
          v12 = a1[2] / a1[5];
          goto LABEL_28;
        case 4028:
          v14 = a1[2];
          v13 = a1[3];
          v15 = *(_DWORD *)(*(_QWORD *)a1 + 8);
          bzero(a1 + 10, (4 * *(_DWORD *)(*(_QWORD *)a1 + 4) + 8240) * v13 + 16 * v15 + 84 - 40);
          if (v15 >= 1)
          {
            LODWORD(v16) = 2 * v15;
            v17 = &a1[12 * v13 + 21 + (v14 + 2048) * v13 + v15];
            v18 = &v17[2 * v15];
            if (2 * v15 <= 1)
              v16 = 1;
            else
              v16 = v16;
            do
            {
              *v18++ = -28672;
              *v17++ = -28672;
              --v16;
            }
            while (v16);
          }
          return 0;
        case 4031:
          v11 = a9;
          if (!a9)
            goto LABEL_29;
          result = 0;
          v12 = a1[10];
          goto LABEL_28;
        case 4033:
          v11 = a9;
          if (!a9)
            goto LABEL_29;
          result = 0;
          v12 = a1[14];
LABEL_28:
          *v11 = v12;
          break;
        default:
          return result;
      }
      break;
  }
  return result;
}

uint64_t quant_coarse_energy(uint64_t a1, int a2, int a3, int a4, uint64_t a5, char *a6, unsigned int a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11, int a12, int a13, int *a14, int a15, int a16, int a17)
{
  _BOOL4 v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  __int16 *v26;
  __int16 *v27;
  char *v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  __int128 *v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  size_t v39;
  char *v40;
  _BOOL4 v41;
  _BOOL4 v42;
  void *v43;
  uint64_t v44;
  int v45;
  size_t v46;
  void *v47;
  const void *v48;
  uint64_t v49;
  int v50;
  void *v51;
  size_t v52;
  char *v53;
  uint64_t v54;
  uint64_t result;
  uint64_t v56;
  _DWORD *v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  signed int v62;
  int v63;
  uint64_t v64;
  void *v65;
  char *v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  int *v72;
  void *v73;
  _BOOL4 v74;
  int v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  uint64_t v82;
  char *v83;
  __int128 v84;
  int v85;
  __int128 v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  _BYTE v90[28];
  uint64_t v91;

  v82 = a11;
  v83 = a6;
  v91 = *MEMORY[0x24BDAC8D0];
  v72 = a14;
  if (a13)
  {
    v69 = *a14;
    v18 = 1;
  }
  else
  {
    v19 = (a3 - a2) * a10;
    v69 = *a14;
    v18 = v69 > 2 * v19 && v19 < a12;
    if (a15)
      v18 = 0;
  }
  v74 = v18;
  v20 = 0;
  v21 = 0;
  v81 = a7;
  v68 = a16 * a7;
  v67 = a10 << 9;
  v22 = *(int *)(a1 + 8);
  if (a10 <= 1)
    v23 = 1;
  else
    v23 = a10;
  v24 = &v83[2 * a2];
  v25 = 2 * v22;
  v79 = a5;
  v26 = (__int16 *)(a5 + 2 * a2);
  do
  {
    if (a2 < a4)
    {
      v27 = v26;
      v28 = v24;
      v29 = a4 - (uint64_t)a2;
      do
      {
        v30 = *v27++;
        v31 = v30 >> 3;
        v32 = *(__int16 *)v28;
        v28 += 2;
        v21 += (v31 - (v32 >> 3)) * (v31 - (v32 >> 3));
        --v29;
      }
      while (v29);
    }
    ++v20;
    v24 += v25;
    v26 = (__int16 *)((char *)v26 + v25);
  }
  while (v20 != v23);
  v80 = a1;
  v73 = (void *)a8;
  v33 = v21 >> 14;
  if (v33 >= 200)
    v33 = 200;
  v71 = v33;
  v34 = (__int128 *)(a9 + 32);
  v35 = *(unsigned int *)(a9 + 28);
  v36 = *(_DWORD *)(a9 + 24) + __clz(*(_DWORD *)(a9 + 32));
  v78 = a3;
  v37 = a12 << 7;
  if (a12 << 7 >= 0x4000)
    v37 = 0x4000;
  v76 = v36 - 32;
  v38 = v36 - 29;
  if (a3 - a2 <= 10)
    v37 = 0x4000;
  v77 = a17;
  if (a17)
    v37 = 3;
  v75 = v37;
  *(_OWORD *)v90 = *(_OWORD *)a9;
  *(_OWORD *)&v90[12] = *(_OWORD *)(a9 + 12);
  v89 = *(_QWORD *)(a9 + 48);
  v88 = *v34;
  v39 = 2 * (int)v22 * a10;
  v40 = (char *)&v61 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v40, v39);
  bzero(v40, v39);
  memcpy(v40, v83, v39);
  v41 = v38 <= v81 && a15 != 0;
  v42 = v74 && v38 <= v81;
  v43 = (void *)(int)v82;
  if (v41 || v42)
  {
    v65 = (void *)(int)v82;
    v44 = v80;
    v45 = quant_coarse_energy_impl(v80, a2, v78, v79, (uint64_t)v40, v81, v76, (uint64_t)&e_prob_model + 84 * (int)v82 + 42, (uint64_t)v40, a9, a10, v82, 1, v75, v77);
    if (v42)
    {
      memcpy(v83, v40, 2 * *(_DWORD *)(v44 + 8) * a10);
      v46 = 2 * *(_DWORD *)(v44 + 8) * a10;
      v47 = v73;
      v48 = v40;
      goto LABEL_39;
    }
    v70 = v45;
    v74 = v41;
    v66 = v40;
    v43 = v65;
  }
  else
  {
    v74 = v41;
    v66 = v40;
    v70 = 0;
  }
  v62 = ec_tell_frac(a9);
  v49 = *(_QWORD *)a9;
  v84 = *(_OWORD *)(a9 + 8);
  v50 = *(_DWORD *)(a9 + 28);
  v85 = *(_DWORD *)(a9 + 24);
  v86 = *v34;
  v87 = *(_QWORD *)(a9 + 48);
  v64 = v49;
  v51 = (void *)(v49 + v35);
  v63 = v50;
  v52 = (v50 - v35);
  v53 = (char *)&v61 - ((v52 + 15) & 0x1FFFFFFF0);
  bzero(v53, v52);
  v65 = v51;
  memcpy(v53, v51, v52);
  *(_OWORD *)a9 = *(_OWORD *)v90;
  *(_OWORD *)(a9 + 12) = *(_OWORD *)&v90[12];
  *(_DWORD *)(a9 + 28) = v35;
  *v34 = v88;
  *(_QWORD *)(a9 + 48) = v89;
  v54 = (uint64_t)v73;
  result = quant_coarse_energy_impl(v80, a2, v78, v79, (uint64_t)v83, v81, v76, (uint64_t)&e_prob_model + 84 * (int)v43, (uint64_t)v73, a9, a10, v82, 0, v75, v77);
  if (!v74
    || v70 >= (int)result
    && (v70 != (_DWORD)result || (v59 = v68 * v69 / v67, result = ec_tell_frac(a9), (int)(result + v59) <= v62)))
  {
    v60 = (__int16)((pred_coef[(_QWORD)v43] * pred_coef[(_QWORD)v43]) >> 15);
    v57 = v72;
    v58 = v71 + ((*v72 >> 15) & 0xFFFFFFFE) * v60 + ((v60 * (unsigned __int16)*v72) >> 15);
    goto LABEL_43;
  }
  *(_QWORD *)a9 = v64;
  *(_OWORD *)(a9 + 8) = v84;
  *(_DWORD *)(a9 + 24) = v85;
  *(_DWORD *)(a9 + 28) = v63;
  *v34 = v86;
  *(_QWORD *)(a9 + 48) = v87;
  memcpy(v65, v53, v52);
  v56 = v80;
  memcpy(v83, v40, 2 * *(_DWORD *)(v80 + 8) * a10);
  v46 = 2 * *(_DWORD *)(v56 + 8) * a10;
  v47 = (void *)v54;
  v48 = v66;
LABEL_39:
  result = (uint64_t)memcpy(v47, v48, v46);
  v57 = v72;
  v58 = v71;
LABEL_43:
  *v57 = v58;
  return result;
}

uint64_t quant_coarse_energy_impl(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, int a13, __int16 a14, int a15)
{
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  BOOL v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  BOOL v35;
  int v36;
  signed int v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v47;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  int v59;
  _QWORD v60[3];

  v60[1] = *MEMORY[0x24BDAC8D0];
  v60[0] = 0;
  v51 = a2;
  if (a7 + 3 <= a6)
  {
    ec_enc_bit_logp((uint64_t *)a10, a13, 3);
    a2 = v51;
  }
  if (a13)
  {
    v55 = 0;
    v56 = 4915;
  }
  else
  {
    v55 = pred_coef[a12];
    v56 = beta_coef[a12];
  }
  if (a2 >= a3)
  {
    v18 = 0;
    goto LABEL_66;
  }
  v18 = 0;
  v54 = a6 + 32;
  v47 = a3;
  if (a11 <= 1)
    v19 = 1;
  else
    v19 = a11;
  v53 = v19;
  v20 = *(_DWORD *)(a1 + 8);
  v21 = a2;
  do
  {
    v22 = 0;
    v52 = 3 * a11 * (v21 - a3);
    if (a15)
      v23 = v21 <= 1;
    else
      v23 = 1;
    v24 = !v23;
    if (v21 >= 20)
      v25 = 20;
    else
      v25 = v21;
    v49 = (2 * v25) | 1;
    v50 = 2 * v25;
    do
    {
      v26 = v21 + v20 * v22;
      v27 = *(__int16 *)(a4 + 2 * v26);
      v28 = *(__int16 *)(a5 + 2 * v26);
      if (v28 <= -9216)
        v29 = -9216;
      else
        v29 = v28;
      v30 = *((_DWORD *)v60 + v22);
      v31 = v30 + ((v55 * v29 + 128) >> 8);
      v32 = (v27 << 7) - v31;
      v33 = (v32 + 0x10000) >> 17;
      v59 = v33;
      if (v32 <= -65537)
      {
        v34 = v28 - a14;
        if (v34 <= -28672)
          LOWORD(v34) = -28672;
        v35 = __OFSUB__((__int16)v34, v27);
        v36 = (__int16)v34 - v27;
        if (!((v36 < 0) ^ v35 | (v36 == 0)))
        {
          v33 = (v33 + (v36 >> 10)) & ((v33 + (v36 >> 10)) >> 31);
          v59 = v33;
        }
      }
      v37 = v54 - *(_DWORD *)(a10 + 24) - __clz(*(_DWORD *)(a10 + 32));
      v38 = v33;
      if (v21 != a2)
      {
        v39 = v37 + v52;
        v40 = v37 + v52 <= 29 && v39 <= 23;
        v38 = v33;
        if (v40)
        {
          v38 = v33 >= 1 ? 1 : v33;
          v59 = v38;
          if (v39 <= 15)
          {
            if (v38 < 0)
              v38 = -1;
            v59 = v38;
          }
        }
      }
      if (v24)
      {
        v38 &= v38 >> 31;
        v59 = v38;
      }
      if (v37 >= 15)
      {
        ec_laplace_encode((uint64_t *)a10, &v59, *(unsigned __int8 *)(a8 + v50) << 7, *(unsigned __int8 *)(a8 + v49) << 6);
LABEL_55:
        a2 = v51;
        goto LABEL_56;
      }
      if (v37 >= 2)
      {
        if (v38 >= 1)
          v41 = 1;
        else
          v41 = v38;
        if (v41 < 0)
          v41 = -1;
        v59 = v41;
        ec_enc_icdf((uint64_t *)a10, (2 * v41) ^ (v41 >> 31), (uint64_t)small_energy_icdf, 2);
        goto LABEL_55;
      }
      if (v37 == 1)
      {
        v59 = v38 & (v38 >> 31);
        ec_enc_bit_logp((uint64_t *)a10, -v59, 1);
        goto LABEL_55;
      }
      v59 = -1;
LABEL_56:
      v42 = v59;
      v20 = *(_DWORD *)(a1 + 8);
      v43 = v21 + v20 * v22;
      *(_WORD *)(a9 + 2 * v43) = ((v32 + 64) >> 7) - ((_WORD)v59 << 10);
      v44 = v33 - v42;
      if (v33 - v42 < 0)
        v44 = v42 - v33;
      v18 += v44;
      v45 = v31 + (v42 << 17);
      if (v45 <= -3670016)
        v45 = -3670016;
      *(_WORD *)(a5 + 2 * v43) = (v45 + 64) >> 7;
      *((_DWORD *)v60 + v22++) = v30 + (v42 << 17) - v56 * (__int16)(4 * v42);
    }
    while (v53 != v22);
    ++v21;
    a3 = v47;
  }
  while (v21 != v47);
LABEL_66:
  if (a15)
    return 0;
  else
    return v18;
}

uint64_t *quant_fine_energy(uint64_t *result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8)
{
  uint64_t *v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  unsigned int v22;

  if (a2 < a3)
  {
    v12 = result;
    if (a8 <= 1)
      v13 = 1;
    else
      v13 = a8;
    v14 = a2;
    do
    {
      v15 = *(_DWORD *)(a6 + 4 * v14);
      if (v15 >= 1)
      {
        v16 = 0;
        v17 = 0x10000 << v15 >> 16;
        v18 = *((_DWORD *)v12 + 2);
        do
        {
          v19 = (*(__int16 *)(a5 + 2 * (v14 + v18 * v16)) + 512) >> (10 - v15);
          if (v19 >= v17)
            v19 = v17 - 1;
          v20 = v19 & ~(v19 >> 31);
          result = ec_enc_bits(a7, v20, v15);
          v15 = *(_DWORD *)(a6 + 4 * v14);
          v18 = *((_DWORD *)v12 + 2);
          v21 = v14 + v18 * v16;
          v22 = (((v20 << 10) | 0x200u) >> v15) - 512;
          *(_WORD *)(a4 + 2 * v21) += v22;
          *(_WORD *)(a5 + 2 * v21) -= v22;
          ++v16;
        }
        while (v13 != v16);
      }
      ++v14;
    }
    while ((_DWORD)v14 != a3);
  }
  return result;
}

uint64_t *quant_energy_finalise(uint64_t *result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t *a9, int a10)
{
  uint64_t *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  char v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;

  v13 = result;
  v14 = 0;
  v15 = a10;
  if (a10 <= 1)
    v16 = 1;
  else
    v16 = a10;
  v23 = a2;
  v17 = a3;
  v18 = 1;
  v28 = a7;
  v27 = a3;
  do
  {
    v26 = v18;
    if (a2 < a3 && a8 >= v15)
    {
      v19 = v23;
      v29 = v14;
      do
      {
        if (*(int *)(a6 + 4 * v19) <= 7 && *(_DWORD *)(a7 + 4 * v19) == v14)
        {
          v30 = a8;
          v20 = 0;
          v21 = *((_DWORD *)v13 + 2);
          do
          {
            v22 = *(unsigned __int16 *)(a5 + 2 * (v19 + v21 * v20));
            result = ec_enc_bits(a9, (v22 >> 15) ^ 1, 1);
            v21 = *((_DWORD *)v13 + 2);
            *(_WORD *)(a4 + 2 * (v19 + v21 * v20++)) += (int)((~(v22 >> 5) & 0x400) - 512) >> (*(_BYTE *)(a6 + 4 * v19)
                                                                                             + 1);
          }
          while (v16 != v20);
          v14 = v29;
          a8 = v30 - v16;
          a7 = v28;
          v15 = a10;
          v17 = v27;
        }
        ++v19;
      }
      while (v19 < v17 && a8 >= v15);
    }
    v18 = 0;
    v14 = 1;
  }
  while ((v26 & 1) != 0);
  return result;
}

uint64_t unquant_coarse_energy(uint64_t result, int a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, int a8)
{
  int v10;
  char *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  signed int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  _QWORD v28[2];

  v10 = a2;
  v27 = result;
  v28[1] = *MEMORY[0x24BDAC8D0];
  v28[0] = 0;
  if (a5)
  {
    v25 = 0;
    v26 = 4915;
  }
  else
  {
    v25 = pred_coef[a8];
    v26 = beta_coef[a8];
  }
  if (a2 < a3)
  {
    v11 = (char *)&e_prob_model + 84 * a8 + 42 * a5;
    v12 = 8 * *(_DWORD *)(a6 + 8) + 32;
    if (a7 <= 1)
      v13 = 1;
    else
      v13 = a7;
    do
    {
      v14 = 0;
      if (v10 >= 20)
        v15 = 20;
      else
        v15 = v10;
      v23 = (2 * v15) | 1;
      v24 = 2 * v15;
      do
      {
        v16 = v12 - *(_DWORD *)(a6 + 24) - __clz(*(_DWORD *)(a6 + 32));
        if (v16 < 15)
        {
          if (v16 < 2)
          {
            if (v16 == 1)
              result = -ec_dec_bit_logp(a6, 1);
            else
              result = 0xFFFFFFFFLL;
          }
          else
          {
            v17 = ec_dec_icdf(a6, small_energy_icdf, 2);
            result = -(v17 & 1) ^ (v17 >> 1);
          }
        }
        else
        {
          result = ec_laplace_decode((uint64_t *)a6, v11[v24] << 7, v11[v23] << 6);
        }
        v18 = v10 + *(_DWORD *)(v27 + 8) * v14;
        v19 = *(__int16 *)(a4 + 2 * v18);
        if (v19 <= -9216)
          v19 = -9216;
        v20 = *((_DWORD *)v28 + v14) + ((_DWORD)result << 17);
        v21 = v20 + ((v25 * v19 + 128) >> 8);
        if (v21 <= -3670016)
          v21 = -3670016;
        *(_WORD *)(a4 + 2 * v18) = (v21 + 64) >> 7;
        *((_DWORD *)v28 + v14++) = v20 - v26 * (__int16)(4 * result);
      }
      while (v13 != v14);
      ++v10;
    }
    while (v10 != a3);
  }
  return result;
}

uint64_t unquant_fine_energy(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t *a6, int a7)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  signed int v14;
  int i;
  uint64_t v16;

  if (a2 < a3)
  {
    v11 = result;
    if (a7 <= 1)
      v12 = 1;
    else
      v12 = a7;
    v13 = a2;
    do
    {
      v14 = *(_DWORD *)(a5 + 4 * v13);
      if (v14 >= 1)
      {
        for (i = 0; i != v12; ++i)
        {
          result = ec_dec_bits(a6, v14);
          v14 = *(_DWORD *)(a5 + 4 * v13);
          v16 = v13 + *(int *)(v11 + 8) * (uint64_t)i;
          *(_WORD *)(a4 + 2 * v16) = *(_WORD *)(a4 + 2 * v16) + ((((_DWORD)result << 10) | 0x200) >> v14) - 512;
        }
      }
      ++v13;
    }
    while ((_DWORD)v13 != a3);
  }
  return result;
}

uint64_t unquant_energy_finalise(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t *a8, int a9)
{
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  int i;
  uint64_t v21;
  uint64_t v22;
  char v25;
  uint64_t v26;
  int v27;

  v14 = result;
  v15 = 0;
  if (a9 <= 1)
    v16 = 1;
  else
    v16 = a9;
  v22 = a2;
  v17 = a3;
  v18 = 1;
  v26 = a3;
  do
  {
    v25 = v18;
    if (a2 < a3 && a7 >= a9)
    {
      v19 = v22;
      v27 = v15;
      do
      {
        if (*(int *)(a5 + 4 * v19) <= 7 && *(_DWORD *)(a6 + 4 * v19) == v15)
        {
          for (i = 0; i != v16; ++i)
          {
            result = ec_dec_bits(a8, 1u);
            v21 = v19 + *(int *)(v14 + 8) * (uint64_t)i;
            *(_WORD *)(a4 + 2 * v21) += ((__int16)((_WORD)result << 10) - 512) >> (*(_BYTE *)(a5 + 4 * v19) + 1);
          }
          a7 -= v16;
          v17 = v26;
          v15 = v27;
        }
        ++v19;
      }
      while (v19 < v17 && a7 >= a9);
    }
    v18 = 0;
    v15 = 1;
  }
  while ((v25 & 1) != 0);
  return result;
}

uint64_t amp2Log2(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int *v11;
  _WORD *v12;
  char *v13;
  int v14;
  signed int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  __int16 v20;
  int v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;

  v7 = 0;
  v22 = 2 * (~a2 + a3) + 2;
  v23 = a2;
  if (a6 <= 1)
    v8 = 1;
  else
    v8 = a6;
  v26 = a2;
  v24 = result;
  v25 = a2;
  v21 = a3;
  do
  {
    if (a2 >= 1)
    {
      v9 = *(_DWORD *)(result + 8) * v7;
      v10 = v26;
      v11 = (int *)(a4 + 4 * v9);
      v12 = (_WORD *)(a5 + 2 * v9);
      v13 = eMeans;
      do
      {
        v14 = *v11++;
        v15 = 4 * v14;
        if (4 * v14)
        {
          v16 = __clz(v15) ^ 0x1F;
          v17 = v15 >> (v16 - 15);
          v18 = v15 << (15 - v16);
          if (v16 > 0xF)
            v18 = v17;
          v19 = (v16 << 10)
              + (((unsigned __int16)((((((unsigned __int16)(((-2802
                                                                                        * (((v18 << 16) + 0x40000000) >> 16)) >> 16)
                                                                        + 2545)
                                                     * (((v18 << 16) + 0x40000000) >> 15)
                                                     - 341901312) >> 16)
                                                   * (((v18 << 16) + 0x40000000) >> 16)) >> 15)
                                   + 15746)
                * (((v18 << 16) + 0x40000000) >> 15)
                - 445186048) >> 20)
              - 13312;
        }
        else
        {
          LOWORD(v19) = -32767;
        }
        v20 = *v13++;
        *v12++ = v19 - (v20 << 6);
        --v10;
      }
      while (v10);
    }
    if (a2 < a3)
    {
      memset_pattern16((void *)(a5 + 2 * (v23 + *(int *)(result + 8) * (uint64_t)v7)), &unk_214F955D0, v22);
      result = v24;
      a2 = v25;
      a3 = v21;
    }
    ++v7;
  }
  while (v7 != v8);
  return result;
}

uint64_t alg_quant(__int16 *a1, int a2, int a3, int a4, int a5, uint64_t *a6)
{
  size_t v11;
  _BYTE *v12;
  size_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  signed int v20;
  int v21;
  int v22;
  unsigned __int16 v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  __int16 *v28;
  int *v29;
  _WORD *v30;
  int v31;
  int v32;
  int v33;
  int i;
  uint64_t v35;
  int v36;
  __int16 v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t j;
  int v45;
  uint64_t result;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  int v53;
  _BYTE v54[12];
  int v55;
  uint64_t *v56;
  uint64_t v57;

  v56 = a6;
  v57 = *MEMORY[0x24BDAC8D0];
  v11 = 2 * a2;
  v12 = &v54[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v12, v11);
  v13 = 4 * a2;
  v14 = &v54[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v14, v13);
  bzero(v12, v11);
  exp_rotation((uint64_t)a1, a2, 1, a5, a3, a4);
  v15 = 0;
  if (a2 <= 1)
    v16 = 1;
  else
    v16 = a2;
  do
  {
    v17 = a1[v15];
    if (v17 <= 0)
    {
      a1[v15] = -(__int16)v17;
      v18 = -1;
    }
    else
    {
      v18 = 1;
    }
    *(_WORD *)&v12[2 * v15] = v18;
    v14[v15] = 0;
    *(_WORD *)&v12[2 * v15++] = 0;
  }
  while (v16 != v15);
  if (a3 <= a2 >> 1)
  {
    v24 = 0;
    v25 = 0;
    v31 = a3;
  }
  else
  {
    v19 = 0;
    v20 = 0;
    do
      v20 += a1[v19++];
    while (v16 != v19);
    v55 = a5;
    if (v20 <= a3)
    {
      v20 = 0x4000;
      *a1 = 0x4000;
      if (a2 <= 2)
        v21 = 2;
      else
        v21 = a2;
      bzero(a1 + 1, 2 * (v21 - 1));
    }
    v22 = celt_rcp(v20);
    v23 = celt_rcp(v20);
    v24 = 0;
    LOWORD(v25) = 0;
    v26 = (int)((v22 & 0xFFFF0000 | v23) * (__int16)(a3 - 1)) >> 16;
    v27 = v16;
    v28 = a1;
    v29 = v14;
    v30 = v12;
    v31 = a3;
    do
    {
      v32 = *v28++;
      v33 = (v26 * v32) >> 15;
      *v29++ = v33;
      v25 = (__int16)v33 * (__int16)v33 + (__int16)v25;
      v24 += (__int16)v33 * v32;
      *v30++ = 2 * v33;
      v31 -= v33;
      --v27;
    }
    while (v27);
    a5 = v55;
  }
  if (v31 <= a2 + 3)
  {
    if (v31 >= 1)
    {
      for (i = 0; i != v31; ++i)
      {
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = 32 - __clz(a3 - v31 + 1 + i);
        v39 = v25 + 1;
        v40 = -32767;
        do
        {
          v41 = (v24 + a1[v35]) >> v38;
          v42 = (2 * (__int16)v41 * (__int16)v41) >> 16;
          if (v42 * v37 > v40 * (__int16)(*(_WORD *)&v12[2 * v35] + v39))
          {
            v36 = v35;
            v40 = v42;
            v37 = *(_WORD *)&v12[2 * v35] + v39;
          }
          ++v35;
        }
        while (v16 != v35);
        v43 = *(unsigned __int16 *)&v12[2 * v36];
        v24 += a1[v36];
        *(_WORD *)&v12[2 * v36] = v43 + 2;
        v25 = v43 + v39;
        ++v14[v36];
      }
    }
  }
  else
  {
    *v14 += v31;
  }
  for (j = 0; j != v16; ++j)
  {
    v45 = *(__int16 *)&v12[2 * j];
    a1[j] *= *(_WORD *)&v12[2 * j];
    if (v45 < 0)
      v14[j] = -v14[j];
  }
  encode_pulses((uint64_t)v14, a2, a3, v56);
  if (a5 < 2)
    return 1;
  v47 = 0;
  LODWORD(result) = 0;
  v48 = a2 / a5;
  if (a2 / a5 <= 1)
    v49 = 1;
  else
    v49 = v48;
  v50 = 4 * v48;
  do
  {
    v51 = v14;
    v52 = v49;
    do
    {
      v53 = *v51++;
      result = ((v53 != 0) << v47) | result;
      --v52;
    }
    while (v52);
    ++v47;
    v14 = (_DWORD *)((char *)v14 + v50);
  }
  while (v47 != a5);
  return result;
}

uint64_t exp_rotation(uint64_t result, int a2, int a3, int a4, int a5, int a6)
{
  __int16 *v9;
  int v10;
  signed int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  __int16 *v23;
  int v24;
  int v25;
  int v26;
  int v27;

  if (a2 > 2 * a5 && a6)
  {
    v9 = (__int16 *)result;
    v10 = (a2 << 16 >> 1) - (__int16)a2;
    v11 = a2 + exp_rotation_SPREAD_FACTOR[a6 - 1] * a5;
    v12 = (v10 >> 16) * (celt_rcp(v11) >> 16);
    v13 = (((unsigned __int16)celt_rcp(v11) * (v10 >> 16)) >> 15) + 2 * v12;
    v14 = (__int16)(v13 + ((((int)celt_rcp(v11) >> 16) * (unsigned __int16)v10) >> 15));
    v15 = (v14 * v14) >> 16;
    v16 = celt_cos_norm(v15);
    result = celt_cos_norm(v15 ^ 0x7FFF);
    v17 = result;
    if (a2 >= 8 * a4)
    {
      v18 = 0;
      v19 = a4;
      do
      {
        v20 = (a4 >> 2) + v19 * (v18 + 2);
        ++v18;
        v19 += a4;
      }
      while (v20 < a2);
    }
    else
    {
      v18 = 0;
    }
    if (a4 >= 1)
    {
      v21 = a2 / a4;
      v22 = a4;
      while ((a3 & 0x80000000) == 0)
      {
        result = (uint64_t)exp_rotation1(v9, v21, 1, v16, (__int16)-(__int16)v17);
        if (v18)
        {
          v23 = v9;
          v24 = v21;
          v25 = v18;
          v26 = v17;
          v27 = (__int16)-(__int16)v16;
LABEL_15:
          result = (uint64_t)exp_rotation1(v23, v24, v25, v26, v27);
        }
        v9 += v21;
        if (!--v22)
          return result;
      }
      if (v18)
        exp_rotation1(v9, v21, v18, v17, v16);
      v23 = v9;
      v24 = v21;
      v25 = 1;
      v26 = v16;
      v27 = v17;
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t alg_unquant(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, int a7)
{
  size_t v14;
  char *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  __int16 *v19;
  int v20;
  unsigned int v21;
  int v22;
  char v23;
  unsigned int v24;
  unsigned int v25;
  __int16 v26;
  int v27;
  uint64_t i;
  uint64_t result;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  int v36;
  _QWORD v37[2];

  v37[1] = *MEMORY[0x24BDAC8D0];
  v14 = 4 * a2;
  v15 = (char *)v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v15, v14);
  decode_pulses((int *)v15, a2, a3, a6);
  v16 = 0;
  if (a2 <= 1)
    v17 = 1;
  else
    v17 = a2;
  v18 = v17;
  v19 = (__int16 *)v15;
  do
  {
    v20 = *v19;
    v19 += 2;
    v16 += v20 * v20;
    --v18;
  }
  while (v18);
  v21 = __clz(v16);
  v22 = (int)(31 - v21) >> 1;
  v23 = (31 - v21) & 0xFE;
  v24 = v16 >> (v23 - 14);
  v25 = v16 << (14 - v23);
  if (v21 >= 0x10)
    v26 = v25;
  else
    v26 = v24;
  v27 = celt_rsqrt_norm(v26);
  for (i = 0; i != v17; ++i)
    *(_WORD *)(a1 + 2 * i) = (int)(((1 << (v22 + 1)) >> 1)
                                 + *(__int16 *)&v15[4 * i] * ((2 * a7 * v27 + 0x8000) >> 16)) >> (v22 + 1);
  exp_rotation(a1, a2, -1, a5, a3, a4);
  if (a5 < 2)
    return 1;
  v30 = 0;
  LODWORD(result) = 0;
  v31 = a2 / a5;
  if (a2 / a5 <= 1)
    v32 = 1;
  else
    v32 = v31;
  v33 = 4 * v31;
  do
  {
    v34 = (int *)v15;
    v35 = v32;
    do
    {
      v36 = *v34++;
      result = ((v36 != 0) << v30) | result;
      --v35;
    }
    while (v35);
    ++v30;
    v15 += v33;
  }
  while (v30 != a5);
  return result;
}

uint64_t renormalise_vector(__int16 *a1, int a2, int a3)
{
  int v4;
  __int16 *v5;
  unsigned int v6;
  int v7;
  __int16 *v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  __int16 v14;
  uint64_t result;

  v4 = a2;
  v5 = a1;
  v6 = 1;
  if (a2 >= 1)
  {
    v7 = a2;
    v8 = a1;
    do
    {
      v9 = *v8++;
      v6 += v9 * v9;
      --v7;
    }
    while (v7);
  }
  v10 = __clz(v6) ^ 0x1F;
  v11 = v10 >> 1;
  v12 = v6 >> (2 * (v10 >> 1) - 14);
  v13 = v6 << (14 - 2 * (v10 >> 1));
  if (v10 <= 0xF)
    v14 = v13;
  else
    v14 = v12;
  result = celt_rsqrt_norm(v14);
  if (v4 >= 1)
  {
    do
    {
      *v5 = (int)(((2 << v11) >> 1) + ((2 * a3 * (int)result + 0x8000) >> 16) * *v5) >> (v11 + 1);
      ++v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t stereo_itheta(__int16 *a1, __int16 *a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  __int16 v15;
  __int16 v16;
  signed int v17;
  char v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;

  if (a3)
  {
    if (a4 >= 1)
    {
      v4 = a4;
      LODWORD(v5) = 1;
      LODWORD(v6) = 1;
      do
      {
        v8 = *a1++;
        v7 = v8;
        v9 = v8 >> 1;
        v10 = *a2++;
        v6 = (v6 + ((v10 >> 1) + (v7 >> 1)) * ((v10 >> 1) + (v7 >> 1)));
        v5 = (v5 + (v9 - (v10 >> 1)) * (v9 - (v10 >> 1)));
        --v4;
      }
      while (v4);
      goto LABEL_11;
    }
LABEL_10:
    v6 = 1;
    v5 = 1;
    goto LABEL_11;
  }
  if (a4 < 1)
    goto LABEL_10;
  v11 = a4;
  LODWORD(v5) = 1;
  LODWORD(v6) = 1;
  do
  {
    v13 = *a1++;
    v12 = v13;
    v14 = *a2++;
    v6 = (v6 + v12 * v12);
    v5 = (v5 + v14 * v14);
    --v11;
  }
  while (v11);
LABEL_11:
  v15 = celt_sqrt(v6);
  v16 = celt_sqrt(v5);
  v17 = v16;
  if (v16 >= v15)
  {
    v24 = v15 >> 1;
    v25 = v24 * ((int)celt_rcp(v16) >> 16);
    v26 = (((unsigned __int16)celt_rcp(v17) * v24) >> 15) + 2 * v25;
    v27 = v26 + ((((int)celt_rcp(v17) >> 16) * ((v15 & 1) << 15)) >> 15);
    if (v27 >= 0x7FFF)
      LOWORD(v27) = 0x7FFF;
    v23 = 25736
        - ((__int16)((((((((9872 * (__int16)v27 - 782663680) >> 16) * 2 * (__int16)v27 - 1343488) >> 16)
                      * 2
                      * (__int16)v27
                      + 2147450880) >> 16)
                    * (__int16)v27
                    + 0x4000) >> 15) >> 1);
  }
  else
  {
    v18 = v16;
    v19 = v16 >> 1;
    v20 = v19 * ((int)celt_rcp(v15) >> 16);
    v21 = (((unsigned __int16)celt_rcp(v15) * v19) >> 15) + 2 * v20;
    v22 = v21 + ((((int)celt_rcp(v15) >> 16) * ((v18 & 1) << 15)) >> 15);
    if (v22 >= 0x7FFF)
      LOWORD(v22) = 0x7FFF;
    v23 = (int)((((((((9872 * (__int16)v22 - 782663680) >> 16) * 2 * (__int16)v22 - 1343488) >> 16)
                               * 2
                               * (__int16)v22
                               + 2147450880) >> 16)
                             * (__int16)v22
                             + 0x4000) >> 15 << 16) >> 17;
  }
  return ((20861 * (__int16)v23) >> 15);
}

__int16 *exp_rotation1(__int16 *result, int a2, int a3, int a4, int a5)
{
  int v5;
  __int16 *v6;
  int v7;
  int v8;
  int v9;
  __int16 *v10;
  int v11;
  int v12;
  int v13;

  v5 = a2 - a3;
  if (a2 - a3 >= 1)
  {
    v6 = result;
    do
    {
      v7 = *v6;
      v8 = v6[a3];
      v6[a3] = (v7 * a5 + v8 * a4) >> 15;
      *v6++ = (v7 * a4 - v8 * a5) >> 15;
      --v5;
    }
    while (v5);
  }
  v9 = ~(2 * a3) + a2;
  if (v9 >= 0)
  {
    v10 = &result[v9];
    v11 = a2 - 2 * a3;
    do
    {
      v12 = *v10;
      v13 = v10[a3];
      v10[a3] = (v12 * a5 + v13 * a4) >> 15;
      *v10-- = (v12 * a4 - v13 * a5) >> 15;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t isqrt32(unsigned int a1)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  LODWORD(result) = 0;
  v3 = (int)(31 - __clz(a1)) >> 1;
  v4 = 1 << v3;
  do
  {
    v5 = (v4 + 2 * (_DWORD)result) << v3;
    if (v5 <= a1)
    {
      v6 = v4;
    }
    else
    {
      v5 = 0;
      v6 = 0;
    }
    a1 -= v5;
    result = v6 + result;
    v4 >>= 1;
  }
  while (v3-- > 0);
  return result;
}

uint64_t frac_div32(int a1, unsigned int a2)
{
  char v2;
  char v3;
  char v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  signed int v10;
  int v11;
  int v12;
  unsigned int v13;

  v2 = __clz(a2);
  v3 = v2 - 2;
  v4 = 2 - v2;
  if (a2 >> 30)
    v5 = a1 >> v4;
  else
    v5 = a1 << v3;
  v6 = (int)a2 >> v4;
  v7 = a2 << v3;
  if (a2 >> 30)
    v8 = v6;
  else
    v8 = v7;
  v9 = (int)((celt_rcp((v8 + 0x8000) >> 16) << 13) + 0x8000) >> 16;
  v10 = ((v5 >> 15) & 0xFFFFFFFE) * v9 + ((v9 * (unsigned __int16)v5) >> 15);
  v11 = (unsigned __int16)(((v5 >> 15) & 0xFFFE) * v9 + ((v9 * (unsigned __int16)v5) >> 15)) * (v8 >> 16);
  v12 = v10
      + 8
      * v9
      * ((((v5 + 2) >> 2) - 2 * (v8 >> 16) * (v10 >> 16) - ((((v10 >> 16) * (unsigned __int16)v8) >> 15) + (v11 >> 15))) >> 16)
      + 4
      * (((unsigned __int16)(((v5 + 2) >> 2)
                           - 2 * HIWORD(v8) * HIWORD(v10)
                           - ((((v10 >> 16) * (unsigned __int16)v8) >> 15)
                            + (v11 >> 15)))
        * v9) >> 15);
  v13 = 4 * v12;
  if (v12 < -536870911)
    v13 = -2147483647;
  if (v12 <= 0x1FFFFFFF)
    return v13;
  else
    return 0x7FFFFFFFLL;
}

uint64_t celt_rcp(signed int a1)
{
  unsigned int v1;
  int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;

  v1 = __clz(a1);
  v2 = a1 >> (16 - v1);
  if (v1 >= 0x10)
    LOWORD(v2) = a1 << (v1 - 16);
  v3 = (__int16)v2 ^ 0xFFFF8000;
  v4 = ((int)(-30840 * v3 + 2021130240) >> 16)
     - (((__int16)((((-30840 * v3 + 2021130240) >> 16) ^ 0x8000)
                               + ((((int)(-30840 * v3 + 2021130240) >> 16) * v3) >> 15))
                     * ((int)(-30840 * v3 + 2021130240) >> 16)) >> 15);
  v5 = (__int16)(v4
               - ((2 * (__int16)v4 * (__int16)((v4 ^ 0x8000) + (((__int16)v4 * v3) >> 15)) + 0x10000) >> 16));
  v6 = v5 << (v1 - 15);
  v7 = v5 >> (15 - v1);
  if (v1 <= 0xE)
    return v7;
  else
    return v6;
}

uint64_t celt_rsqrt_norm(__int16 a1)
{
  unsigned int v1;
  int v2;
  int v3;

  v1 = a1 ^ 0xFFFF8000;
  v2 = 2 * v1 * (((int)(6713 * v1) >> 15) + 2147470158) + 1543831552;
  v3 = (__int16)((2 * ((((__int16)(((v2 >> 16) * (v2 >> 16)) >> 15) * v1) >> 15) + (((v2 >> 16) * (v2 >> 16)) >> 15))) ^ 0x8000);
  return (__int16)(((((((24576 * v3 - 0x40000000) >> 16) * v3) >> 15) * (v2 >> 16)) >> 15)
                               + HIWORD(v2));
}

uint64_t celt_sqrt(uint64_t result)
{
  unsigned int v1;
  int v2;
  int v3;

  if ((_DWORD)result)
  {
    if ((int)result <= 0x3FFFFFFF)
    {
      v1 = __clz(result) ^ 0x1F;
      v2 = (int)result >> (2 * (v1 >> 1) - 14);
      if (v1 <= 0xF)
        LOWORD(v2) = (_DWORD)result << (14 - 2 * (v1 >> 1));
      v3 = (int)(2
               * ((__int16)v2 ^ 0xFFFF8000)
               * (unsigned __int16)(((((int)(2
                                           * ((__int16)v2 ^ 0xFFFF8000)
                                           * (unsigned __int16)(((-1328 * ((__int16)v2 ^ 0xFFFF8000)) >> 16) + 1699)
                                           - 197328896) >> 16)
                                    * ((__int16)v2 ^ 0xFFFF8000)) >> 15)
                                  + 11561)
               + 1518796800) >> 16;
      if (v1 >= 0x1C)
        return (v3 << ((v1 >> 1) - 14));
      else
        return (v3 >> (14 - (v1 >> 1)));
    }
    else
    {
      return 0x7FFFLL;
    }
  }
  return result;
}

uint64_t celt_cos_norm(int a1)
{
  unsigned int v1;
  signed int v2;
  __int16 v4;
  int v5;
  int v6;

  v1 = a1 & 0x1FFFF;
  if ((a1 & 0x1FFFFu) > 0x10000)
    v1 = 0x20000 - (a1 & 0x1FFFF);
  if ((v1 & 0x7FFF) != 0)
  {
    if (v1 >> 15)
    {
      v5 = ((int)(-65536 * v1) >> 15) * -(__int16)v1 + 0x8000;
      v6 = ((((2 * (v5 >> 16) * (unsigned __int16)(((2147483022 * (v5 >> 16) + 0x4000) >> 15) + 8277)
             - 501383168) >> 16)
           * (v5 >> 16)
           + 0x4000) >> 15)
         - (v5 >> 16);
      if (v6 < 0)
        return (__int16)((v6 ^ 0x7FFF) + 1);
      else
        return -32767;
    }
    else
    {
      v2 = ((int)(((int)(2
                       * ((2 * v1 * v1 + 0x8000) >> 16)
                       * (unsigned __int16)(((2147483022 * ((2 * v1 * v1 + 0x8000) >> 16) + 0x4000) >> 15) + 8277)
                       - 501383168) >> 16)
                * ((2 * v1 * v1 + 0x8000) >> 16)
                + 0x4000) >> 15)
         - ((2 * v1 * v1 + 0x8000) >> 16);
      if (v2 < 0)
        return (__int16)(v2 ^ 0x8000);
      else
        return 0x7FFF;
    }
  }
  else
  {
    if ((v1 & 0x1FFFF) != 0)
      v4 = -32767;
    else
      v4 = 0x7FFF;
    if ((_WORD)v1)
      return 0;
    else
      return v4;
  }
}

void _celt_lpc(_WORD *a1, signed int *a2, int a3)
{
  signed int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int *v23;
  int v24;
  _DWORD v25[24];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v6 = *a2;
  if (a3 >= 1)
    bzero(v25, 4 * a3);
  if (v6)
  {
    v7 = 0;
    v8 = 0;
    v9 = -4;
    do
    {
      if (v8 == (a3 & ~(a3 >> 31)))
        break;
      v10 = 0;
      if (v8)
      {
        v11 = v25;
        v12 = v7;
        do
        {
          v13 = *v11++;
          v10 += 2 * (v13 >> 16) * (*(signed int *)((char *)a2 + v12) >> 16)
               + (((unsigned __int16)*(signed int *)((char *)a2 + v12) * (v13 >> 16)) >> 15)
               + (((*(signed int *)((char *)a2 + v12) >> 16) * (unsigned __int16)v13) >> 15);
          v12 -= 4;
        }
        while (v12);
      }
      v14 = -(int)frac_div32((a2[(v8 + 1)] + 8 * v10) & 0xFFFFFFF8, v6);
      v25[v8] = v14 >> 3;
      v15 = v14 >> 16;
      if (v8)
      {
        v16 = 0;
        v17 = 2 * v15;
        v14 = (unsigned __int16)v14;
        v18 = v9;
        do
        {
          v19 = v25[v16];
          v20 = *(_DWORD *)((char *)v25 + v18);
          v25[v16] = v19
                   + v17 * (v20 >> 16)
                   + (((unsigned __int16)v20 * v15) >> 15)
                   + (((v20 >> 16) * (unsigned __int16)v14) >> 15);
          *(_DWORD *)((char *)v25 + v18) = v20
                                         + v17 * (v19 >> 16)
                                         + (((unsigned __int16)v19 * v15) >> 15)
                                         + (((v19 >> 16) * (unsigned __int16)v14) >> 15);
          ++v16;
          v18 -= 4;
        }
        while (v16 < (v8 + 1) >> 1);
      }
      else
      {
        v17 = 2 * v15;
        v14 = (unsigned __int16)v14;
      }
      v21 = v17 * v15 + 2 * ((v15 * v14) >> 15);
      v6 = v6
         - 2 * (v6 >> 16) * (v21 >> 16)
         - ((((v21 >> 16) * (unsigned __int16)v6) >> 15)
          + (((v21 & 0xFFFE) * (v6 >> 16)) >> 15));
      v7 += 4;
      v9 += 4;
      ++v8;
    }
    while (v6 >= *a2 >> 10);
  }
  if (a3 >= 1)
  {
    v22 = a3;
    v23 = v25;
    do
    {
      v24 = *v23++;
      *a1++ = (v24 + 0x8000) >> 16;
      --v22;
    }
    while (v22);
  }
}

uint64_t celt_fir(__int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _WORD *a6)
{
  size_t v12;
  char *v13;
  size_t v14;
  double v15;
  double v16;
  double v17;
  double v18;
  int32x2_t v19;
  _WORD *v20;
  uint64_t v21;
  _WORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  __int16 *v27;
  _WORD *v28;
  unsigned __int16 *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t result;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  int v41;
  uint64_t v42;
  __int16 *v43;
  char *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v12 = 2 * a5;
  v13 = (char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  v14 = 2 * (a5 + (int)a4);
  v53 = (char *)&v49 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v53, v14);
  if (a5 >= 1)
  {
    v20 = (_WORD *)((char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
    v21 = a5;
    do
      *v20++ = *(_WORD *)(a2 + 2 * (int)--v21);
    while (v21);
    v22 = v53;
    v23 = a5;
    do
      *v22++ = a6[(int)--v23];
    while (v23);
  }
  v24 = a4 - 1;
  if ((int)a4 >= 1)
    memcpy(&v53[v12], a1, 2 * a4);
  if (a5 >= 1)
  {
    v25 = a5;
    do
    {
      *a6++ = a1[v24--];
      --v25;
    }
    while (v25);
  }
  v50 = a5;
  v51 = a3;
  v52 = a4;
  v26 = 0;
  if ((int)a4 >= 4)
  {
    v27 = a1 + 2;
    v28 = (_WORD *)(a3 + 4);
    v29 = (unsigned __int16 *)v53;
    do
    {
      v54 = 0;
      v55 = 0;
      *(int32x2_t *)&v15 = xcorr_kernel((__int16 *)v13, v29, (int *)&v54, a5, v15, v16, v17, v18, v19);
      v30 = HIDWORD(v54);
      v31 = *(v27 - 2) + (((int)v54 + 2048) >> 12);
      if (v31 <= -32768)
        v31 = -32768;
      if (v31 >= 0x7FFF)
        LOWORD(v31) = 0x7FFF;
      *(v28 - 2) = v31;
      v32 = *(v27 - 1) + ((v30 + 2048) >> 12);
      if (v32 <= -32768)
        v32 = -32768;
      if (v32 >= 0x7FFF)
        LOWORD(v32) = 0x7FFF;
      *(v28 - 1) = v32;
      v33 = HIDWORD(v55);
      v34 = *v27 + (((int)v55 + 2048) >> 12);
      if (v34 <= -32768)
        v34 = -32768;
      if (v34 >= 0x7FFF)
        LOWORD(v34) = 0x7FFF;
      *v28 = v34;
      v35 = v27[1] + ((v33 + 2048) >> 12);
      if (v35 <= -32768)
        v35 = -32768;
      if (v35 >= 0x7FFF)
        LOWORD(v35) = 0x7FFF;
      v28[1] = v35;
      v26 += 4;
      v27 += 4;
      v29 += 4;
      v28 += 4;
    }
    while ((int)a4 - 3 > v26);
  }
  v37 = v51;
  result = v52;
  v38 = v50;
  if (v26 < (int)v52)
  {
    v39 = v26;
    v40 = &v53[2 * v26];
    do
    {
      if (a5 < 1)
      {
        v41 = 0;
      }
      else
      {
        v41 = 0;
        v42 = v38;
        v43 = (__int16 *)v13;
        v44 = v40;
        do
        {
          v46 = *v43++;
          v45 = v46;
          v47 = *(__int16 *)v44;
          v44 += 2;
          v41 += v47 * v45;
          --v42;
        }
        while (v42);
      }
      v48 = a1[v39] + ((v41 + 2048) >> 12);
      if (v48 <= -32768)
        v48 = -32768;
      if (v48 >= 0x7FFF)
        LOWORD(v48) = 0x7FFF;
      *(_WORD *)(v37 + 2 * v39++) = v48;
      v40 += 2;
    }
    while ((int)v39 < (int)result);
  }
  return result;
}

int32x2_t xcorr_kernel(__int16 *a1, unsigned __int16 *a2, int *a3, int a4, double a5, double a6, double a7, double a8, int32x2_t a9)
{
  __int32 v9;
  __int16 v10;
  unsigned __int16 *v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  signed int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  __int16 *v37;
  int v38;
  __int16 *v39;
  int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  int v47;
  int32x2_t result;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int32x2_t v53;
  int32x2_t v54;

  v9 = *a2;
  v10 = a2[1];
  v11 = a2 + 3;
  v12 = a2[2];
  if (a4 < 4)
  {
    v41 = 0;
    v16 = 0;
  }
  else
  {
    v13 = 0;
    v14 = *a3;
    v15 = a3[1];
    v16 = a4 & 0xFFFFFFFC;
    v18 = a3[2];
    v17 = a3[3];
    do
    {
      v19 = *a1;
      v20 = (__int16)*v11;
      v21 = v14 + v19 * (__int16)v9;
      v22 = v15 + v19 * v10;
      v23 = v18 + v19 * (__int16)v12;
      v24 = v17 + v20 * v19;
      v25 = a1[1];
      v26 = (__int16)v11[1];
      v9 = v11[1];
      v27 = v21 + v25 * v10;
      v28 = v22 + v25 * (__int16)v12;
      v29 = v23 + v25 * v20;
      v30 = v24 + v26 * v25;
      v31 = a1[2];
      v32 = (__int16)v11[2];
      v10 = v11[2];
      v33 = v27 + v31 * (__int16)v12;
      v34 = v28 + v31 * v20;
      v35 = v29 + v31 * v26;
      v36 = v30 + v32 * v31;
      v37 = a1 + 4;
      v38 = a1[3];
      v39 = (__int16 *)(v11 + 4);
      v40 = (__int16)v11[3];
      v12 = (unsigned __int16)v40;
      v14 = v33 + v38 * v20;
      v15 = v34 + v38 * v26;
      v18 = v35 + v38 * v32;
      v17 = v36 + v40 * v38;
      v13 += 4;
      a1 = v37;
      v11 = (unsigned __int16 *)v39;
    }
    while (v13 < a4 - 3);
    v41 = (unsigned __int16)v20;
    *a3 = v14;
    a3[1] = v15;
    v11 = (unsigned __int16 *)v39;
    a1 = v37;
    a3[2] = v18;
    a3[3] = v17;
  }
  v42 = v16 | 1;
  if (v16 < a4)
  {
    v44 = *a1++;
    v43 = v44;
    v45 = *a3 + v44 * (__int16)v9;
    v46 = *v11++;
    v41 = v46;
    v47 = a3[1] + v43 * v10;
    *a3 = v45;
    a3[1] = v47;
    result = vmla_s32(*(int32x2_t *)(a3 + 2), vdup_n_s32(v43), vshr_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(v46, v12), 0x10uLL), 0x10uLL));
    *((int32x2_t *)a3 + 1) = result;
  }
  v49 = v16 | 2;
  if (v42 < a4)
  {
    v51 = *a1++;
    v50 = v51;
    v52 = (__int16)*v11++;
    v9 = (unsigned __int16)v52;
    *a3 += v50 * v10;
    result = vshr_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(v41, v12), 0x10uLL), 0x10uLL);
    *(int32x2_t *)(a3 + 1) = vmla_s32(*(int32x2_t *)(a3 + 1), vdup_n_s32(v50), result);
    a3[3] += v52 * v50;
  }
  if (v49 < a4)
  {
    v53 = vdup_n_s32(*a1);
    a9.i32[0] = v9;
    a9.i16[2] = *v11;
    result = vshr_n_s32(vshl_n_s32(a9, 0x10uLL), 0x10uLL);
    v54 = vmla_s32(*(int32x2_t *)(a3 + 2), v53, result);
    *(int32x2_t *)a3 = vmla_s32(*(int32x2_t *)a3, v53, vshr_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(v41, v12), 0x10uLL), 0x10uLL));
    *((int32x2_t *)a3 + 1) = v54;
  }
  return result;
}

void celt_iir(_OWORD *a1, __int16 *a2, uint64_t a3, uint64_t a4, int a5, _WORD *a6)
{
  int v7;
  size_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  size_t v16;
  char *v17;
  double v18;
  double v19;
  double v20;
  int32x2_t v21;
  uint64_t v22;
  _WORD *v23;
  uint64_t v24;
  _WORD *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned __int16 *v31;
  int v32;
  uint64_t v33;
  int *v34;
  __int128 *v35;
  unsigned __int16 *v36;
  __int128 v37;
  uint64_t v38;
  unsigned int v39;
  unsigned __int16 *v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  int v52;
  char *v53;
  uint64_t v54;
  __int16 *v55;
  int v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  unsigned __int16 *v61;
  _OWORD *v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  __int128 v66;
  uint64_t v67;

  v7 = a5;
  v67 = *MEMORY[0x24BDAC8D0];
  v12 = 2 * a5;
  v13 = (char *)&v60 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  v14 = a4;
  v15 = v7 + a4;
  v16 = 2 * v15;
  v17 = (char *)&v60 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v17, v16);
  v22 = v7;
  if (v7 < 1)
  {
    v27 = 0;
  }
  else
  {
    v23 = v13;
    v24 = v7;
    do
      *v23++ = a2[(int)--v24];
    while (v24);
    v25 = v17;
    v26 = v7;
    do
      *v25++ = -a6[(int)--v26];
    while (v26);
    v27 = v7;
  }
  if (v27 < v15)
    bzero(&v17[2 * v27], 2 * (v15 + ~v27) + 2);
  v28 = v7;
  v29 = v14;
  if ((int)v14 < 4)
  {
    LODWORD(v30) = 0;
  }
  else
  {
    v30 = 0;
    v63 = v29;
    v64 = a3;
    v31 = (unsigned __int16 *)v17;
    v65 = (v29 - 3);
    v32 = v7;
    v60 = v7;
    v61 = v31;
    v33 = v7;
    v34 = (int *)(a3 + 8);
    v62 = a1;
    v35 = a1;
    v36 = v31;
    do
    {
      v37 = *v35++;
      v66 = v37;
      xcorr_kernel((__int16 *)v13, v36, (int *)&v66, v32, *(double *)&v37, v18, v19, v20, v21);
      v38 = v66;
      v39 = -((16 * v66 + 0x8000) >> 16);
      v40 = &v36[v33];
      *v40 = v39;
      *(v34 - 2) = v38;
      v41 = (__int16)v39;
      v42 = *a2;
      v43 = HIDWORD(v38) + v41 * v42;
      v44 = -((16 * v43 + 0x8000) >> 16);
      v40[1] = v44;
      *(v34 - 1) = v43;
      v45 = (__int16)v44;
      v46 = HIDWORD(v66);
      v47 = a2[1];
      v48 = DWORD2(v66) + (__int16)v44 * v42 + v47 * v41;
      *v34 = v48;
      v49 = -((16 * v48 + 0x8000) >> 16);
      v40[2] = v49;
      v50 = v46 + v45 * v47 + (__int16)v49 * v42 + a2[2] * v41;
      v40[3] = -((16 * v50 + 0x8000) >> 16);
      v34[1] = v50;
      v30 += 4;
      v36 += 4;
      v34 += 4;
    }
    while (v30 < v65);
    LODWORD(v29) = v63;
    a3 = v64;
    v7 = v32;
    v17 = (char *)v61;
    a1 = v62;
    v28 = v60;
  }
  if ((int)v30 < (int)v29)
  {
    v51 = (int)v30;
    do
    {
      v52 = *((_DWORD *)a1 + v51);
      if (v7 >= 1)
      {
        v53 = &v17[2 * v51];
        v54 = v22;
        v55 = (__int16 *)v13;
        do
        {
          v57 = *v55++;
          v56 = v57;
          v58 = *(__int16 *)v53;
          v53 += 2;
          v52 -= v58 * v56;
          --v54;
        }
        while (v54);
      }
      *(_WORD *)&v17[2 * v51 + 2 * v28] = (v52 + 2048) >> 12;
      *(_DWORD *)(a3 + 4 * v51++) = v52;
    }
    while (v51 != (int)v29);
  }
  if (v7 >= 1)
  {
    v59 = v29 - 1;
    do
    {
      *a6++ = *(_DWORD *)(a3 + 4 * v59--);
      --v22;
    }
    while (v22);
  }
}

uint64_t _celt_autocorr(char *a1, unsigned int *a2, uint64_t a3, int a4, int a5, int a6)
{
  size_t v12;
  char *v13;
  int v14;
  char *v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  _WORD *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  char *v34;
  char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  _QWORD v44[2];

  v44[1] = *MEMORY[0x24BDAC8D0];
  v12 = 2 * a6;
  v13 = (char *)v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  if (a4)
  {
    v14 = a6 - 1;
    if (a6 >= 1)
      memcpy(v13, a1, 2 * a6);
    v15 = v13;
    if (a4 >= 1)
    {
      v16 = 0;
      do
      {
        v17 = *(__int16 *)(a3 + v16);
        *(_WORD *)&v13[v16] = (v17 * *(__int16 *)&a1[v16]) >> 15;
        *(_WORD *)&v13[2 * v14] = (*(__int16 *)&a1[2 * v14] * v17) >> 15;
        --v14;
        v16 += 2;
      }
      while (2 * a4 != v16);
      v15 = v13;
    }
  }
  else
  {
    v15 = a1;
  }
  v18 = (a6 << 7) | 1;
  if ((a6 & 1) != 0)
    v18 += (*(__int16 *)v15 * *(__int16 *)v15) >> 9;
  v19 = a6 - a5;
  v20 = a6;
  if (a6 >= 2)
  {
    v21 = a6 & 1;
    do
    {
      v18 += ((*(__int16 *)&v15[2 * v21] * *(__int16 *)&v15[2 * v21]) >> 9)
           + ((*(__int16 *)&v15[2 * v21 + 2] * *(__int16 *)&v15[2 * v21 + 2]) >> 9);
      v21 += 2;
    }
    while (v21 < a6);
  }
  if (v18 < 0x400000)
  {
    v27 = 0;
    v13 = v15;
  }
  else
  {
    v22 = __clz(v18);
    v23 = (int)((11 - v22 + (((11 - v22) & 0x80) >> 7)) << 24) >> 25;
    if (a6 >= 1)
    {
      v24 = a6;
      v25 = v13;
      do
      {
        v26 = *(__int16 *)v15;
        v15 += 2;
        *v25++ = (int)(((1 << v23) >> 1) + v26) >> v23;
        --v24;
      }
      while (v24);
    }
    v27 = (2 * v23);
  }
  v28 = (a5 + 1);
  celt_pitch_xcorr_c((__int16 *)v13, (uint64_t)v13, (uint64_t)a2, v19, a5 + 1);
  if ((a5 & 0x80000000) == 0)
  {
    v29 = 0;
    v30 = 0;
    v31 = a5;
    v32 = v20 - v19;
    do
    {
      if (v30 >= v32)
      {
        v33 = 0;
      }
      else
      {
        v33 = 0;
        v34 = &v13[2 * v29 + 2 * v19];
        v35 = &v13[2 * v19];
        v36 = v31;
        do
        {
          v38 = *(__int16 *)v35;
          v35 += 2;
          v37 = v38;
          v39 = *(__int16 *)v34;
          v34 += 2;
          v33 += v39 * v37;
          --v36;
        }
        while (v36);
      }
      a2[v30++] += v33;
      ++v19;
      --v29;
      --v31;
    }
    while (v30 != v28);
  }
  v40 = *a2;
  if (!(_DWORD)v27)
    *a2 = ++v40;
  if ((int)v40 > 0xFFFFFFF)
  {
    if (v40 >> 29)
    {
      if (v40 >> 30)
        v42 = 2;
      else
        v42 = 1;
      if ((a5 & 0x80000000) == 0)
      {
        do
        {
          *a2 = (int)*a2 >> v42;
          ++a2;
          --v28;
        }
        while (v28);
      }
      return (v42 + v27);
    }
  }
  else
  {
    v41 = __clz(v40) - 3;
    if ((a5 & 0x80000000) == 0)
    {
      do
      {
        *a2++ <<= v41;
        --v28;
      }
      while (v28);
    }
    return v27 - v41;
  }
  return v27;
}

void pitch_downsample(int **a1, char *a2, int a3, int a4)
{
  char *v5;
  int *v6;
  int v7;
  int v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  signed int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  _WORD *v28;
  uint64_t v29;
  int v30;
  int *v31;
  uint64_t v32;
  _DWORD *v33;
  _WORD *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  __int16 v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  __int16 v49;
  __int16 v50;
  __int16 v51;
  __int16 v52;
  signed int v53;
  int32x4_t v54;
  uint64_t v55;

  v5 = a2;
  v55 = *MEMORY[0x24BDAC8D0];
  v6 = *a1;
  if (a3 < 1)
  {
    v14 = 0;
    v16 = 0;
    v15 = 0;
    v20 = 0;
    if (a4 != 2)
      goto LABEL_27;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = a3;
    v10 = *a1;
    v11 = a3;
    do
    {
      v13 = *v10++;
      v12 = v13;
      if (v8 <= v13)
        v8 = v12;
      if (v7 >= v12)
        v7 = v12;
      --v11;
    }
    while (v11);
    if (v8 <= -v7)
      v14 = -v7;
    else
      v14 = v8;
    if (a4 != 2)
    {
      v20 = 0;
      goto LABEL_27;
    }
    v15 = 0;
    v16 = 0;
    v17 = a1[1];
    do
    {
      v19 = *v17++;
      v18 = v19;
      if (v16 <= v19)
        v16 = v18;
      if (v15 >= v18)
        v15 = v18;
      --v9;
    }
    while (v9);
  }
  if (v16 <= -v15)
    v21 = -v15;
  else
    v21 = v16;
  if (v14 <= v21)
    v14 = v21;
  v20 = 1;
LABEL_27:
  if (v14 <= 1)
    v22 = 1;
  else
    v22 = v14;
  v23 = __clz(v22) ^ 0x1F;
  if (v23 <= 10)
    LOBYTE(v23) = 10;
  v24 = v20 + v23 - 10;
  v25 = (a3 >> 1);
  if (a3 >= 4)
  {
    if ((int)v25 <= 2)
      v26 = 2;
    else
      v26 = v25;
    v27 = v6 + 2;
    v28 = a2 + 2;
    v29 = v26 - 1;
    do
    {
      *v28++ = (*v27 + ((v27[1] + *(v27 - 1)) >> 1)) >> 1 >> v24;
      v27 += 2;
      --v29;
    }
    while (v29);
  }
  v30 = (*v6 + (v6[1] >> 1)) >> 1 >> v24;
  *(_WORD *)a2 = v30;
  if (v20)
  {
    v31 = a1[1];
    if (a3 >= 4)
    {
      if ((int)v25 <= 2)
        v32 = 2;
      else
        v32 = v25;
      v33 = v31 + 2;
      v34 = a2 + 2;
      v35 = v32 - 1;
      do
      {
        *v34++ += (*v33 + ((v33[1] + *(v33 - 1)) >> 1)) >> 1 >> v24;
        v33 += 2;
        --v35;
      }
      while (v35);
    }
    *(_WORD *)a2 = ((*v31 + (v31[1] >> 1)) >> 1 >> v24) + v30;
  }
  _celt_autocorr(a2, (unsigned int *)&v53, 0, 0, 4, a3 >> 1);
  v53 += v53 >> 13;
  v54 = vsubq_s32(vmlaq_s32(v54, vshrq_n_s32(v54, 0x10uLL), (int32x4_t)xmmword_214F95600), (int32x4_t)vshrq_n_u32(vmull_u16((uint16x4_t)vmovn_s32(v54), (uint16x4_t)0x20001200080002), 0xFuLL));
  _celt_lpc(&v49, &v53, 4);
  v36 = 0;
  LOWORD(v37) = 0x7FFF;
  do
  {
    v37 = (29491 * (__int16)v37) >> 15;
    *(__int16 *)((char *)&v49 + v36) = (v37 * *(__int16 *)((char *)&v49 + v36)) >> 15;
    v36 += 2;
  }
  while (v36 != 8);
  if (a3 >= 2)
  {
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v42 = 0;
    v43 = (__int16)(v49 + 3277);
    v44 = (__int16)(v50 + ((26214 * v49) >> 15));
    v45 = (__int16)(v51 + ((26214 * v50) >> 15));
    v46 = (__int16)(v52 + ((26214 * v51) >> 15));
    v47 = (52428 * v52) >> 16;
    do
    {
      v48 = v39 * v46 + v38 * v47 + v40 * v45 + v41 * v44;
      v38 = v39;
      v39 = v40;
      v40 = v41;
      v41 = v42;
      v42 = *(_WORD *)v5;
      *(_WORD *)v5 += (v48 + v41 * v43 + 2048) >> 12;
      v5 += 2;
      --v25;
    }
    while (v25);
  }
}

uint64_t celt_pitch_xcorr_c(__int16 *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unint64_t v5;
  uint64_t v6;
  __int16 *v7;
  __int16 v8;
  __int16 v9;
  __int16 *v10;
  __int16 v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  __int16 *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  __int16 *v36;
  int v37;
  __int16 *v38;
  int v39;
  __int16 v40;
  signed int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  __int16 *v51;
  int v52;
  uint64_t v53;
  __int16 *v54;
  __int16 *v55;
  int v56;
  int v57;
  int v58;

  if (a5 < 4)
  {
    LODWORD(v5) = 0;
    v6 = 1;
  }
  else
  {
    v5 = 0;
    LODWORD(v6) = 1;
    do
    {
      v7 = (__int16 *)(a2 + 2 * v5);
      v8 = *v7;
      v9 = v7[1];
      v10 = v7 + 3;
      v11 = v7[2];
      if (a4 < 4)
      {
        v15 = 0;
        v14 = 0;
        v13 = 0;
        v12 = 0;
        v40 = 0;
        v41 = 0;
        v36 = a1;
      }
      else
      {
        v12 = 0;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = a1;
        do
        {
          v18 = *v17;
          v19 = *v10;
          v20 = v15 + v18 * v8;
          v21 = v14 + v18 * v9;
          v22 = v13 + v18 * v11;
          v23 = v12 + v19 * v18;
          v24 = v17[1];
          v25 = v10[1];
          v8 = v10[1];
          v26 = v20 + v24 * v9;
          v27 = v21 + v24 * v11;
          v28 = v22 + v24 * v19;
          v29 = v23 + v25 * v24;
          v30 = v17[2];
          v31 = v10[2];
          v9 = v10[2];
          v32 = v26 + v30 * v11;
          v33 = v27 + v30 * v19;
          v34 = v28 + v30 * v25;
          v35 = v29 + v31 * v30;
          v36 = v17 + 4;
          v37 = v17[3];
          v38 = v10 + 4;
          v39 = v10[3];
          v11 = v39;
          v15 = v32 + v37 * v19;
          v14 = v33 + v37 * v25;
          v13 = v34 + v37 * v31;
          v12 = v35 + v39 * v37;
          v16 += 4;
          v17 = v36;
          v10 = v38;
        }
        while (v16 < a4 - 3);
        v40 = v19;
        v41 = a4 & 0xFFFFFFFC;
        v10 = v38;
      }
      if (v41 < a4)
      {
        v43 = *v36++;
        v42 = v43;
        v44 = *v10++;
        v40 = v44;
        v15 += v42 * v8;
        v14 += v42 * v9;
        v13 += v42 * v11;
        v12 += v44 * v42;
      }
      if ((v41 | 1) < a4)
      {
        v46 = *v36++;
        v45 = v46;
        v47 = *v10++;
        v8 = v47;
        v15 += v45 * v9;
        v14 += v45 * v11;
        v13 += v45 * v40;
        v12 += v47 * v45;
      }
      if ((v41 | 2) < a4)
      {
        v48 = *v36;
        v15 += v48 * v11;
        v14 += v48 * v40;
        v13 += v48 * v8;
        v12 += *v10 * v48;
      }
      *(_DWORD *)(a3 + 4 * v5) = v15;
      *(_DWORD *)(a3 + ((4 * v5) | 4)) = v14;
      *(_DWORD *)(a3 + ((4 * v5) | 8)) = v13;
      *(_DWORD *)(a3 + ((4 * v5) | 0xC)) = v12;
      if (v15 <= v14)
        v49 = v14;
      else
        v49 = v15;
      if (v13 <= v12)
        v13 = v12;
      if (v49 > v13)
        v13 = v49;
      if ((int)v6 <= v13)
        v6 = v13;
      else
        v6 = v6;
      v5 += 4;
    }
    while (v5 < (a5 - 3));
  }
  if ((int)v5 < a5)
  {
    v50 = v5;
    v51 = (__int16 *)(a2 + 2 * v5);
    do
    {
      if (a4 < 1)
      {
        v52 = 0;
      }
      else
      {
        v52 = 0;
        v53 = a4;
        v54 = a1;
        v55 = v51;
        do
        {
          v57 = *v54++;
          v56 = v57;
          v58 = *v55++;
          v52 += v58 * v56;
          --v53;
        }
        while (v53);
      }
      *(_DWORD *)(a3 + 4 * v50) = v52;
      if ((int)v6 <= v52)
        v6 = v52;
      else
        v6 = v6;
      ++v50;
      ++v51;
    }
    while (v50 != a5);
  }
  return v6;
}

uint64_t pitch_search(__int16 *a1, __int16 *a2, int a3, int a4, _DWORD *a5)
{
  int v8;
  uint64_t v9;
  size_t v10;
  _BYTE *v11;
  int v12;
  size_t v13;
  __int16 *v14;
  size_t v15;
  _BYTE *v16;
  uint64_t v17;
  _WORD *v18;
  __int16 *v19;
  __int16 v20;
  uint64_t v21;
  __int16 *v22;
  __int16 *v23;
  __int16 v24;
  int v25;
  unsigned __int16 v26;
  __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  __int16 *v35;
  uint64_t v36;
  int v37;
  int v38;
  char v39;
  unsigned int v40;
  unsigned int v41;
  char v42;
  uint64_t v43;
  __int16 *v44;
  uint64_t v45;
  __int16 *v46;
  int v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  int v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  signed int v56;
  __int16 *v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  __int16 *v62;
  __int16 *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  uint64_t result;
  int v69;
  int v70;
  int v71;
  int v72;
  _BYTE v73[4];
  int v74;
  uint64_t v75;
  _DWORD *v76;
  __int16 *v77;
  _QWORD v78[2];

  v76 = a5;
  v77 = a2;
  v78[1] = *MEMORY[0x24BDAC8D0];
  v78[0] = 0;
  v8 = a4 + a3;
  v9 = (a3 >> 2);
  v10 = 2 * (int)v9;
  v11 = &v73[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v11, v10);
  v12 = v8 >> 2;
  v13 = 2 * (v8 >> 2);
  v14 = (__int16 *)&v73[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v74 = a4;
  v75 = (a4 >> 1);
  v15 = 4 * (int)v75;
  v16 = &v73[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0)];
  if (a3 >= 4)
  {
    if ((int)v9 <= 1)
      v17 = 1;
    else
      v17 = v9;
    v18 = v11;
    v19 = a1;
    do
    {
      v20 = *v19;
      v19 += 2;
      *v18++ = v20;
      --v17;
    }
    while (v17);
  }
  bzero(&v73[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0)], v13);
  if (v8 >= 4)
  {
    if (v12 <= 1)
      v21 = 1;
    else
      v21 = v12;
    v22 = v14;
    v23 = v77;
    do
    {
      v24 = *v23;
      v23 += 2;
      *v22++ = v24;
      --v21;
    }
    while (v21);
  }
  if (a3 < 4)
  {
    v31 = 0;
    v25 = 0;
  }
  else
  {
    LOWORD(v25) = 0;
    v26 = 0;
    v27 = (__int16 *)v11;
    v28 = v9;
    do
    {
      v30 = *v27++;
      v29 = v30;
      if (v30 >= v26)
        v26 = v29;
      if ((__int16)v25 >= v29)
        LOWORD(v25) = v29;
      --v28;
    }
    while (v28);
    v31 = v26;
    v25 = (__int16)v25;
  }
  v32 = 0;
  v33 = 0;
  if (v31 <= -v25)
    v34 = -v25;
  else
    v34 = v31;
  if (v8 >= 4)
  {
    LOWORD(v33) = 0;
    LOWORD(v32) = 0;
    v35 = v14;
    v36 = (v8 >> 2);
    do
    {
      v38 = *v35++;
      v37 = v38;
      if (v38 >= (unsigned __int16)v32)
        LOWORD(v32) = v37;
      if ((__int16)v33 >= v37)
        LOWORD(v33) = v37;
      --v36;
    }
    while (v36);
    v32 = (unsigned __int16)v32;
    v33 = (__int16)v33;
  }
  v39 = 0;
  if (v32 <= -v33)
    v40 = -v33;
  else
    v40 = v32;
  if (v34 <= v40)
    v34 = v40;
  if (v34 <= 1)
    v34 = 1;
  v41 = __clz(v34);
  if ((v41 ^ 0x1C) >= 0xC)
  {
    v42 = 20 - v41;
    if (a3 >= 4)
    {
      if ((int)v9 <= 1)
        v43 = 1;
      else
        v43 = v9;
      v44 = (__int16 *)v11;
      do
      {
        *v44++ >>= v42;
        --v43;
      }
      while (v43);
    }
    if (v8 >= 4)
    {
      if (v12 <= 1)
        v45 = 1;
      else
        v45 = v12;
      v46 = v14;
      do
      {
        *v46++ >>= v42;
        --v45;
      }
      while (v45);
    }
    v39 = 2 * v42;
  }
  bzero(v16, v15);
  v47 = v74;
  v48 = celt_pitch_xcorr_c((__int16 *)v11, (uint64_t)v14, (uint64_t)v16, v9, v74 >> 2);
  find_best_pitch((uint64_t)v16, v14, v9, v47 >> 2, (uint64_t)v78, 0, v48);
  if (v47 <= 1)
  {
    v52 = a3 >> 1;
    v56 = 1;
    v54 = v75;
  }
  else
  {
    v49 = 0;
    v50 = 2 * LODWORD(v78[0]);
    v51 = 2 * HIDWORD(v78[0]);
    v52 = a3 >> 1;
    if (a3 >> 1 <= 1)
      v53 = 1;
    else
      v53 = v52;
    v54 = v75;
    if ((int)v75 <= 1)
      v55 = 1;
    else
      v55 = v75;
    v56 = 1;
    v57 = v77;
    do
    {
      *(_DWORD *)&v16[4 * v49] = 0;
      v58 = v49 - v50;
      if ((int)v49 - v50 < 0)
        v58 = v50 - v49;
      if (v58 < 3)
        goto LABEL_68;
      v59 = v49 - v51;
      if ((int)v49 - v51 < 0)
        v59 = v51 - v49;
      if (v59 <= 2)
      {
LABEL_68:
        if (a3 < 2)
        {
          v60 = 0;
        }
        else
        {
          v60 = 0;
          v61 = v53;
          v62 = a1;
          v63 = v57;
          do
          {
            v65 = *v62++;
            v64 = v65;
            v66 = *v63++;
            v60 += (v66 * v64) >> v39;
            --v61;
          }
          while (v61);
        }
        if (v60 < 0)
          v67 = -1;
        else
          v67 = v60;
        *(_DWORD *)&v16[4 * v49] = v67;
        if (v56 <= v60)
          v56 = v60;
      }
      ++v49;
      ++v57;
    }
    while (v49 != v55);
  }
  result = find_best_pitch((uint64_t)v16, v77, v52, v54, (uint64_t)v78, v39 | 1u, v56);
  v69 = 0;
  if (SLODWORD(v78[0]) >= 1 && SLODWORD(v78[0]) < v54 - 1)
  {
    v70 = *(_DWORD *)&v16[4 * (LODWORD(v78[0]) - 1)];
    v71 = *(_DWORD *)&v16[4 * LODWORD(v78[0])];
    v72 = *(_DWORD *)&v16[4 * LODWORD(v78[0]) + 4];
    if (v72 - v70 <= (int)(45876 * ((v71 - v70) >> 16) + ((22938 * (unsigned __int16)(v71 - v70)) >> 15)))
      v69 = v70 - v72 > (int)(45876 * ((v71 - v72) >> 16) + ((22938 * (unsigned __int16)(v71 - v72)) >> 15));
    else
      v69 = -1;
  }
  *v76 = v69 + 2 * LODWORD(v78[0]);
  return result;
}

uint64_t find_best_pitch(uint64_t result, __int16 *a2, int a3, int a4, uint64_t a5, char a6, unsigned int a7)
{
  uint64_t v7;
  signed int v8;
  __int16 *v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  char v15;
  unsigned int v16;
  char v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;

  *(_QWORD *)a5 = 0x100000000;
  if (a3 < 1)
  {
    v8 = 1;
  }
  else
  {
    v7 = a3;
    v8 = 1;
    v9 = a2;
    do
    {
      v10 = *v9++;
      v8 += (v10 * v10) >> a6;
      --v7;
    }
    while (v7);
  }
  if (a4 >= 1)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = __clz(a7);
    v16 = a7 >> 15;
    v17 = v15 - 17;
    v18 = 17 - v15;
    LOWORD(v19) = -1;
    LOWORD(a7) = -1;
    v20 = a4;
    v21 = &a2[a3];
    do
    {
      v22 = *(_DWORD *)(result + 4 * v12);
      if (v22 >= 1)
      {
        v23 = v22 >> v18;
        v24 = v22 << v17;
        if (v16)
          LOWORD(v24) = v23;
        v25 = (__int16)v24 * (__int16)v24;
        v26 = (__int16)(v25 >> 15);
        v27 = (v8 >> 15) & 0xFFFFFFFE;
        if ((int)(((v14 >> 15) & 0xFFFFFFFE) * v26 + ((v26 * (unsigned __int16)v14) >> 15)) > (int)(v27 * (__int16)a7 + (((unsigned __int16)v8 * (__int16)a7) >> 15)))
        {
          if ((int)(((v13 >> 15) & 0xFFFFFFFE) * v26 + ((v26 * (unsigned __int16)v13) >> 15)) <= (int)(v27 * (__int16)v19 + (((unsigned __int16)v8 * (__int16)v19) >> 15)))
          {
            a7 = v25 >> 15;
            *(_DWORD *)(a5 + 4) = v12;
            v14 = v8;
          }
          else
          {
            LOWORD(a7) = v19;
            v19 = v25 >> 15;
            *(_DWORD *)a5 = v12;
            *(_DWORD *)(a5 + 4) = v11;
            v11 = v12;
            v14 = v13;
            v13 = v8;
          }
        }
      }
      v8 = ((v21[v12] * v21[v12]) >> a6) + v8 - ((a2[v12] * a2[v12]) >> a6);
      if (v8 <= 1)
        v8 = 1;
      ++v12;
    }
    while (v20 != v12);
  }
  return result;
}

uint64_t remove_doubling(uint64_t a1, int a2, int a3, int a4, int *a5, int a6, int a7)
{
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  int v19;
  int v20;
  uint64_t v21;
  __int16 *v22;
  uint64_t v23;
  int v24;
  int *v25;
  uint64_t v26;
  __int16 *v27;
  int *v28;
  uint64_t v29;
  int v30;
  int v31;
  signed int v32;
  unsigned int v33;
  int v34;
  signed int v35;
  __int16 v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  __int16 *v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  signed int v54;
  unsigned int v55;
  int v56;
  signed int v57;
  __int16 v58;
  int v59;
  int v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  __int16 v64;
  int v65;
  int v66;
  int v67;
  BOOL v68;
  int v69;
  unsigned int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  __int16 *v77;
  int v78;
  int v79;
  int v80;
  uint64_t result;
  int v82;
  uint64_t v83;
  int *v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  int v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int *v104;
  int v105;
  int v106;
  int v107;
  int v108;
  uint64_t v109;

  v102 = a7;
  v109 = *MEMORY[0x24BDAC8D0];
  if (a2 >= 0)
    v9 = a2;
  else
    v9 = a2 + 1;
  v10 = v9 >> 1;
  HIDWORD(v83) = a3;
  if (a3 >= 0)
    v11 = a3;
  else
    v11 = a3 + 1;
  v12 = *a5 / 2;
  if (a6 >= 0)
    v13 = a6;
  else
    v13 = a6 + 1;
  if (a4 >= 0)
    v14 = a4;
  else
    v14 = a4 + 1;
  v95 = (v14 >> 1);
  v15 = (__int16 *)(a1 + 2 * v10);
  LODWORD(v16) = v10 - 1;
  if (v12 >= v9 >> 1)
    v16 = v16;
  else
    v16 = v12;
  v84 = a5;
  *a5 = v16;
  v17 = (v10 + 1);
  v18 = 4 * (int)v17;
  v104 = (int *)((char *)&v83 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
  v19 = 0;
  v20 = 0;
  v96 = v16;
  v21 = (int)v16;
  v94 = a4;
  if (a4 >= 2)
  {
    v20 = 0;
    v19 = 0;
    v22 = (__int16 *)(a1 + 2 * v10);
    v23 = v95;
    do
    {
      v24 = *v22;
      v19 += v24 * v24;
      v20 += v22[-(int)v16] * v24;
      ++v22;
      --v23;
    }
    while (v23);
  }
  v90 = (uint64_t)v9 >> 1;
  v25 = v104;
  bzero(v104, v18);
  *v25 = v19;
  if (a2 >= 2)
  {
    v26 = (int)v95;
    v27 = (__int16 *)(a1 + 2 * v90 - 2);
    v28 = v104 + 1;
    v29 = v17 - 1;
    v30 = v19;
    do
    {
      v30 = v30 + *v27 * *v27 - v27[v26] * v27[v26];
      *v28++ = v30 & ~(v30 >> 31);
      --v27;
      --v29;
    }
    while (v29);
  }
  v103 = v11 >> 1;
  v31 = v104[v21];
  v100 = 2 * (v19 >> 16);
  v101 = v19 >> 16;
  v91 = v31;
  v99 = (unsigned __int16)v19;
  v32 = ((v100 * (v31 >> 16)
        + (((unsigned __int16)v31 * (v19 >> 16)) >> 15)
        + (((v31 >> 16) * (unsigned __int16)v19) >> 15)) >> 1)
      + 1;
  v33 = __clz(v32);
  v34 = v32 >> (((31 - v33) & 0xFE) - 14);
  v35 = v32 << (14 - ((31 - v33) & 0xFE));
  if (v33 >= 0x10)
    v36 = v35;
  else
    v36 = v34;
  v37 = v20 >> 15;
  if (v33 > 0x1F)
  {
    v41 = (v37 & 0xFFFFFFFE) * (unsigned __int16)celt_rsqrt_norm(v36);
    v40 = v41 + ((int)((unsigned __int16)v20 * celt_rsqrt_norm(v36)) >> 15);
  }
  else
  {
    v38 = ((int)(31 - v33) >> 1) + 1;
    v39 = (v37 & 0xFFFFFFFE) * celt_rsqrt_norm(v36);
    v40 = (v39 + ((int)((unsigned __int16)v20 * celt_rsqrt_norm(v36)) >> 15)) >> v38;
  }
  v42 = v94;
  v98 = -(v13 >> 1);
  v105 = 2 * v96;
  v86 = v102 >> 1;
  v92 = v96;
  v93 = v40;
  v97 = 3 * v103;
  v89 = (22938 * (__int16)v40) >> 15;
  v88 = 2 * v103;
  v85 = (29491 * (__int16)v40) >> 15;
  v87 = (27853 * (__int16)v40) >> 15;
  v43 = 2;
  v44 = 2;
  do
  {
    v45 = (v44 + v105) / (2 * (int)v43);
    if (v45 < v103)
      break;
    if (v43 == 2)
    {
      v46 = v45 + v96;
      if (v45 + (int)v96 > (int)v90)
        v46 = v96;
    }
    else
    {
      v46 = ((int)v43 + v105 * second_check[v43]) / (2 * (int)v43);
    }
    if (v42 < 2)
    {
      v52 = 0;
    }
    else
    {
      v47 = 0;
      v48 = 0;
      v49 = v15;
      v50 = v95;
      do
      {
        v51 = *v49;
        v48 += v49[-v45] * v51;
        v47 += v49[-v46] * v51;
        ++v49;
        --v50;
      }
      while (v50);
      v52 = v47 + v48;
    }
    v53 = v104[v46] + v104[v45];
    v54 = ((v100 * (v53 >> 16)) | 1) + (((unsigned __int16)v53 * v101) >> 15) + (((v53 >> 16) * v99) >> 15);
    v55 = __clz(v54);
    v56 = v54 >> (((31 - v55) & 0xFE) - 14);
    v57 = v54 << (14 - ((31 - v55) & 0xFE));
    if (v55 >= 0x10)
      v58 = v57;
    else
      v58 = v56;
    if (v55 > 0x1F)
    {
      v62 = ((v52 >> 15) & 0xFFFFFFFE) * (unsigned __int16)celt_rsqrt_norm(v58);
      v61 = v62 + ((int)((unsigned __int16)v52 * celt_rsqrt_norm(v58)) >> 15);
    }
    else
    {
      v59 = ((int)(31 - v55) >> 1) + 1;
      v60 = ((v52 >> 15) & 0xFFFFFFFE) * celt_rsqrt_norm(v58);
      v61 = (v60 + ((int)((unsigned __int16)v52 * celt_rsqrt_norm(v58)) >> 15)) >> v59;
      v42 = v94;
    }
    if (v45 + v98 >= 0)
      v63 = v45 + v98;
    else
      v63 = -(v45 + v98);
    v64 = v102;
    if (v63 >= 2)
    {
      if (v63 == 2)
      {
        v64 = v86;
        if (5 * v44 * (int)v43 >= (int)v96)
          v64 = 0;
      }
      else
      {
        v64 = 0;
      }
    }
    v65 = v64;
    if (v45 >= v97)
    {
      v66 = v89 - v64;
      if (v89 - v65 <= 9830)
        v66 = 9830;
      if (v45 >= v88)
        goto LABEL_63;
      v66 = v85 - v65;
      v68 = v85 - v65 <= 0x4000;
      v67 = 0x4000;
    }
    else
    {
      v66 = v87 - v64;
      v67 = 13107;
      v68 = v66 <= 13107;
    }
    if (v68)
      v66 = v67;
LABEL_63:
    if (v61 << 16 > v66 << 16)
    {
      v92 = v45;
      v93 = v61;
      v20 = v52;
      v91 = v53;
    }
    ++v43;
    ++v44;
  }
  while (v43 != 16);
  v69 = v20 & ~(v20 >> 31);
  if (v91 <= v69)
    LOWORD(v70) = 0x7FFF;
  else
    v70 = frac_div32(v69, v91 + 1) >> 16;
  v71 = v95;
  v72 = v92;
  v73 = 0;
  v74 = 1 - v92;
  do
  {
    if (v42 < 2)
    {
      v75 = 0;
    }
    else
    {
      v75 = 0;
      v76 = v71;
      v77 = v15;
      v78 = v74;
      do
      {
        v79 = *v77++;
        v75 += v15[v78++] * v79;
        --v76;
      }
      while (v76);
    }
    *(&v106 + v73++) = v75;
    --v74;
  }
  while (v73 != 3);
  if (v108 - v106 <= (int)(45876 * ((v107 - v106) >> 16)
                          + ((22938 * (unsigned __int16)(v107 - v106)) >> 15)))
  {
    if (v106 - v108 <= (int)(45876 * ((v107 - v108) >> 16)
                            + ((22938 * (unsigned __int16)(v107 - v108)) >> 15)))
      v80 = 0;
    else
      v80 = -1;
  }
  else
  {
    v80 = 1;
  }
  if ((__int16)v70 >= (__int16)v93)
    result = (__int16)v93;
  else
    result = (__int16)v70;
  v82 = v80 + 2 * v72;
  if (v82 <= SHIDWORD(v83))
    v82 = HIDWORD(v83);
  *v84 = v82;
  return result;
}

uint64_t *ec_laplace_encode(uint64_t *a1, int *a2, unsigned int a3, int a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;

  v4 = *a2;
  if (*a2)
  {
    if (v4 >= 0)
      v5 = *a2;
    else
      v5 = -v4;
    v6 = (0x4000 - a4) * (32736 - a3);
    v7 = v6 >> 15;
    v8 = 1;
    if (v6 >= 0x8000)
    {
      v10 = __OFSUB__(v5, 2);
      v9 = v5 - 2 < 0;
    }
    else
    {
      v10 = 0;
      v9 = 1;
    }
    if (v9 == v10)
    {
      do
      {
        a3 += 2 * v7 + 2;
        v6 = 2 * v7 * a4;
        ++v8;
        v7 = v6 >> 15;
        if (v6 >= 0x8000)
        {
          v12 = __OFSUB__(v8, v5);
          v11 = v8 - v5 < 0;
        }
        else
        {
          v12 = 0;
          v11 = 0;
        }
      }
      while (v11 != v12);
    }
    if (v6 >> 15)
    {
      if (v4 >= 0)
        v16 = v7 + 1;
      else
        v16 = 0;
      v4 = v16 + a3;
      a3 = v7 + 1;
    }
    else
    {
      v13 = v4 >> 31;
      v14 = v5 - v8;
      v15 = ((int)(((v4 >> 31) | 0x8000) - a3) >> 1) - 1;
      if (v14 >= v15)
        v14 = v15;
      v4 = v13 + a3 + 2 * v14 + 1;
      a3 = v13 + a3 + 2 * v14 != 0x7FFF;
      *a2 = (v8 + v13 + v14) ^ v13;
    }
  }
  return ec_encode_bin(a1, v4, v4 + a3, 15);
}

uint64_t ec_laplace_decode(uint64_t *a1, unsigned int a2, int a3)
{
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;

  v6 = ec_decode_bin(a1, 15);
  if (v6 >= a2)
  {
    v9 = (0x4000 - a3) * (32736 - a2);
    v10 = (v9 >> 15) + 1;
    if (v9 >= 0x8000)
    {
      v11 = 1;
      v12 = a2;
      while (1)
      {
        a2 = v12 + 2 * v10;
        if (v6 < a2)
          break;
        ++v11;
        v13 = ((2 * v10 - 2) * a3) >> 15;
        v10 = v13 + 1;
        v12 = a2;
        if (!v13)
          goto LABEL_8;
      }
    }
    else
    {
      v11 = 1;
LABEL_8:
      v11 += (v6 - a2) >> 1;
      v12 = ((v6 - a2) & 0xFFFFFFFE) + a2;
    }
    if (v6 >= v12 + v10)
      v7 = v11;
    else
      v7 = -v11;
    if (v6 >= v12 + v10)
      v8 = v12 + v10;
    else
      v8 = v12;
    a2 = v10;
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  if (a2 + v8 >= 0x8000)
    v14 = 0x8000;
  else
    v14 = a2 + v8;
  ec_dec_update(a1, v8, v14, 0x8000);
  return v7;
}

double ec_enc_init(uint64_t a1, uint64_t a2, int a3)
{
  double result;

  *(_QWORD *)a1 = a2;
  *(_OWORD *)(a1 + 12) = xmmword_214F95650;
  *(_OWORD *)(a1 + 28) = xmmword_214F95660;
  *(_DWORD *)(a1 + 8) = a3;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 44) = 0xFFFFFFFFLL;
  return result;
}

uint64_t *ec_encode(uint64_t *result, int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  int v5;
  int v6;

  v4 = *((_DWORD *)result + 8);
  v5 = v4 / a4;
  if (a2)
  {
    *((_DWORD *)result + 9) += v4 + v5 * (a2 - a4);
    v6 = v5 * (a3 - a2);
  }
  else
  {
    v6 = v4 + v5 * (a3 - a4);
  }
  *((_DWORD *)result + 8) = v6;
  return ec_enc_normalize(result);
}

uint64_t *ec_enc_normalize(uint64_t *result)
{
  uint64_t *v1;
  unsigned int v2;
  unsigned int v3;

  if (*((_DWORD *)result + 8) <= 0x800000u)
  {
    v1 = result;
    v2 = *((_DWORD *)result + 9);
    do
    {
      result = ec_enc_carry_out(v1, v2 >> 23);
      v2 = (*((_DWORD *)v1 + 9) & 0x7FFFFF) << 8;
      v3 = *((_DWORD *)v1 + 8) << 8;
      *((_DWORD *)v1 + 8) = v3;
      *((_DWORD *)v1 + 9) = v2;
      *((_DWORD *)v1 + 6) += 8;
    }
    while (v3 < 0x800001);
  }
  return result;
}

uint64_t *ec_encode_bin(uint64_t *result, int a2, int a3, char a4)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;

  v4 = *((_DWORD *)result + 8);
  v5 = v4 >> a4;
  v6 = -1 << a4;
  if (a2)
  {
    *((_DWORD *)result + 9) += v4 + v5 * (v6 + a2);
    v7 = v5 * (a3 - a2);
  }
  else
  {
    v7 = v4 + v5 * (v6 + a3);
  }
  *((_DWORD *)result + 8) = v7;
  return ec_enc_normalize(result);
}

uint64_t *ec_enc_bit_logp(uint64_t *result, int a2, char a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  v3 = *((_DWORD *)result + 8);
  v4 = v3 >> a3;
  v5 = v3 - (v3 >> a3);
  if (a2)
  {
    *((_DWORD *)result + 9) += v5;
    v5 = v4;
  }
  *((_DWORD *)result + 8) = v5;
  return ec_enc_normalize(result);
}

uint64_t *ec_enc_icdf(uint64_t *result, int a2, uint64_t a3, char a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;

  v4 = *((_DWORD *)result + 8);
  v5 = v4 >> a4;
  v6 = a2 - 1;
  if (a2 < 1)
  {
    v7 = v4 - v5 * *(unsigned __int8 *)(a3 + a2);
  }
  else
  {
    *((_DWORD *)result + 9) = *((_DWORD *)result + 9) + v4 - v5 * *(unsigned __int8 *)(a3 + v6);
    v7 = (*(unsigned __int8 *)(a3 + v6) - *(unsigned __int8 *)(a3 + a2)) * v5;
  }
  *((_DWORD *)result + 8) = v7;
  return ec_enc_normalize(result);
}

uint64_t *ec_enc_uint(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5;
  unsigned int v6;
  int v7;

  v5 = a3 - 1;
  if (a3 - 1 < 0x100)
    return ec_encode(a1, a2, a2 + 1, a3);
  v6 = __clz(v5);
  v7 = 24 - v6;
  ec_encode(a1, a2 >> (24 - v6), (a2 >> (24 - v6)) + 1, (v5 >> (24 - v6)) + 1);
  return ec_enc_bits(a1, a2 & ~(-1 << v7), v7);
}

uint64_t *ec_enc_bits(uint64_t *result, int a2, int a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  BOOL v12;

  v3 = *((_DWORD *)result + 4);
  v4 = *((_DWORD *)result + 5);
  v5 = v4 + a3;
  if ((v4 + a3) < 0x21)
  {
    v11 = *((_DWORD *)result + 5);
  }
  else
  {
    do
    {
      v7 = *((_DWORD *)result + 2);
      v6 = *((_DWORD *)result + 3);
      if (v6 + *((_DWORD *)result + 7) >= v7)
      {
        v8 = -1;
      }
      else
      {
        v8 = 0;
        v9 = *result;
        v10 = v6 + 1;
        *((_DWORD *)result + 3) = v10;
        *(_BYTE *)(v9 + v7 - v10) = v3;
      }
      *((_DWORD *)result + 12) |= v8;
      v3 >>= 8;
      v11 = v4 - 8;
      v12 = v4 <= 15;
      v4 -= 8;
    }
    while (!v12);
    v5 = a3 + v11;
  }
  *((_DWORD *)result + 4) = (a2 << v11) | v3;
  *((_DWORD *)result + 5) = v5;
  *((_DWORD *)result + 6) += a3;
  return result;
}

uint64_t ec_enc_patch_initial_bits(uint64_t result, int a2, char a3)
{
  char v3;
  int v4;
  int v5;

  v3 = 8 - a3;
  v4 = ~(-1 << a3) << (8 - a3);
  if (*(_DWORD *)(result + 28))
  {
    **(_BYTE **)result = **(_BYTE **)result & ~(_BYTE)v4 | ((_BYTE)a2 << v3);
  }
  else
  {
    v5 = *(_DWORD *)(result + 44);
    if (v5 < 0)
    {
      if (*(_DWORD *)(result + 32) <= 0x80000000 >> a3)
        *(_DWORD *)(result + 36) = *(_DWORD *)(result + 36) & ~(v4 << 23) | (a2 << ~a3);
      else
        *(_DWORD *)(result + 48) = -1;
    }
    else
    {
      *(_DWORD *)(result + 44) = v5 & ~v4 | (a2 << v3);
    }
  }
  return result;
}

void *ec_enc_shrink(uint64_t a1, unsigned int a2)
{
  void *result;

  result = memmove((void *)(*(_QWORD *)a1 + a2 - *(unsigned int *)(a1 + 12)), (const void *)(*(_QWORD *)a1 + *(unsigned int *)(a1 + 8) - *(unsigned int *)(a1 + 12)), *(unsigned int *)(a1 + 12));
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

void ec_enc_done(uint64_t a1)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  BOOL v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  unsigned int v20;

  v3 = *(_DWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 36);
  v4 = __clz(v3);
  v5 = ((0x7FFFFFFFu >> v4) + v2) & ((int)0x80000000 >> v4);
  if ((v5 | (0x7FFFFFFFu >> v4)) >= v2 + v3)
  {
    v6 = 0x3FFFFFFFu >> v4;
    v7 = -1073741824 >> v4++;
    v5 = (v6 + v2) & v7;
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  do
  {
    ec_enc_carry_out((uint64_t *)a1, v5 >> 23);
    v5 = (v5 & 0x7FFFFF) << 8;
    v8 = v4 >= 8;
    v4 -= 8;
  }
  while (v4 != 0 && v8);
LABEL_6:
  if ((*(_DWORD *)(a1 + 44) & 0x80000000) == 0 || *(_DWORD *)(a1 + 40))
    ec_enc_carry_out((uint64_t *)a1, 0);
  v9 = *(_DWORD *)(a1 + 16);
  v10 = *(_DWORD *)(a1 + 20);
  if (v10 <= 7)
  {
    if (*(_DWORD *)(a1 + 48))
      return;
    goto LABEL_18;
  }
  do
  {
    v12 = *(_DWORD *)(a1 + 8);
    v11 = *(_DWORD *)(a1 + 12);
    if (v11 + *(_DWORD *)(a1 + 28) >= v12)
    {
      v13 = -1;
    }
    else
    {
      v13 = 0;
      v14 = *(_QWORD *)a1;
      v15 = v11 + 1;
      *(_DWORD *)(a1 + 12) = v15;
      *(_BYTE *)(v14 + v12 - v15) = v9;
    }
    v16 = *(_DWORD *)(a1 + 48) | v13;
    *(_DWORD *)(a1 + 48) = v16;
    v9 >>= 8;
    v17 = v10 - 8;
    v18 = v10 <= 15;
    v10 -= 8;
  }
  while (!v18);
  v10 = v17;
  if (!v16)
  {
LABEL_18:
    bzero((void *)(*(_QWORD *)a1 + *(unsigned int *)(a1 + 28)), (*(_DWORD *)(a1 + 8) - (*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 12))));
    if (v10 >= 1)
    {
      v20 = *(_DWORD *)(a1 + 8);
      v19 = *(_DWORD *)(a1 + 12);
      if (v19 >= v20)
      {
        *(_DWORD *)(a1 + 48) = -1;
      }
      else
      {
        if (*(_DWORD *)(a1 + 28) + v19 >= v20 && v10 > (signed int)-v4)
        {
          v9 &= ~(-1 << -(char)v4);
          *(_DWORD *)(a1 + 48) = -1;
        }
        *(_BYTE *)(*(_QWORD *)a1 + v20 + ~v19) |= v9;
      }
    }
  }
}

uint64_t *ec_enc_carry_out(uint64_t *result, int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int i;
  uint64_t v7;
  int v8;
  uint64_t v9;

  if (a2 == 255)
  {
    ++*((_DWORD *)result + 10);
  }
  else
  {
    v2 = *((_DWORD *)result + 11);
    if ((v2 & 0x80000000) == 0)
    {
      v3 = *((unsigned int *)result + 7);
      if ((*((_DWORD *)result + 3) + v3) >= *((_DWORD *)result + 2))
      {
        v4 = -1;
      }
      else
      {
        v4 = 0;
        v5 = *result;
        *((_DWORD *)result + 7) = v3 + 1;
        *(_BYTE *)(v5 + v3) = v2 + BYTE1(a2);
      }
      *((_DWORD *)result + 12) |= v4;
    }
    for (i = *((_DWORD *)result + 10); i; *((_DWORD *)result + 10) = i)
    {
      v7 = *((unsigned int *)result + 7);
      if ((*((_DWORD *)result + 3) + v7) >= *((_DWORD *)result + 2))
      {
        v8 = -1;
      }
      else
      {
        v8 = 0;
        v9 = *result;
        *((_DWORD *)result + 7) = v7 + 1;
        *(_BYTE *)(v9 + v7) = BYTE1(a2) - 1;
        i = *((_DWORD *)result + 10);
      }
      *((_DWORD *)result + 12) |= v8;
      --i;
    }
    *((_DWORD *)result + 11) = a2;
  }
  return result;
}

uint64_t *ec_dec_init(uint64_t *result, unsigned __int8 *a2, int a3)
{
  unsigned int v3;

  *result = (uint64_t)a2;
  *((_DWORD *)result + 2) = a3;
  *(_OWORD *)((char *)result + 12) = xmmword_214F95670;
  *(uint64_t *)((char *)result + 28) = 0x8000000000;
  if (a3)
  {
    *((_DWORD *)result + 7) = 1;
    v3 = *a2;
  }
  else
  {
    v3 = 0;
  }
  *((_DWORD *)result + 9) = (v3 >> 1) ^ 0x7F;
  *((_DWORD *)result + 11) = v3;
  *((_DWORD *)result + 12) = 0;
  return ec_dec_normalize(result);
}

uint64_t *ec_dec_normalize(uint64_t *result)
{
  unsigned int v1;
  unint64_t v2;
  int v3;
  unint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  BOOL v9;

  v1 = *((_DWORD *)result + 8);
  if (v1 <= 0x800000)
  {
    v2 = *((unsigned int *)result + 2);
    v3 = *((_DWORD *)result + 11);
    v4 = *((unsigned int *)result + 7);
    v5 = *((_DWORD *)result + 9);
    v6 = *((_DWORD *)result + 6) + 8;
    do
    {
      *((_DWORD *)result + 6) = v6;
      *((_DWORD *)result + 8) = v1 << 8;
      if (v4 >= v2)
      {
        v8 = 0;
      }
      else
      {
        v7 = *result;
        *((_DWORD *)result + 7) = v4 + 1;
        v8 = *(unsigned __int8 *)(v7 + v4++);
      }
      v5 = (((v8 | (v3 << 8)) >> 1) | ((v5 & 0x7FFFFF) << 8)) ^ 0xFF;
      *((_DWORD *)result + 11) = v8;
      *((_DWORD *)result + 9) = v5;
      v6 += 8;
      v3 = v8;
      v9 = v1 > 0x8000;
      v1 <<= 8;
    }
    while (!v9);
  }
  return result;
}

uint64_t ec_decode(_DWORD *a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;

  v2 = a1[9];
  v3 = a1[8] / a2;
  a1[10] = v3;
  v4 = v2 / v3 + 1;
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v5)
    return v6;
  else
    return 0;
}

uint64_t ec_decode_bin(_DWORD *a1, char a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;

  v2 = a1[9];
  v3 = a1[8] >> a2;
  a1[10] = v3;
  v4 = v2 / v3 + 1;
  v5 = 1 << a2 >= v4;
  v6 = (1 << a2) - v4;
  if (v5)
    return v6;
  else
    return 0;
}

uint64_t *ec_dec_update(uint64_t *result, int a2, int a3, int a4)
{
  int v4;
  int v5;
  int v6;

  v4 = *((_DWORD *)result + 10);
  v5 = v4 * (a4 - a3);
  *((_DWORD *)result + 9) -= v5;
  if (a2)
    v6 = v4 * (a3 - a2);
  else
    v6 = *((_DWORD *)result + 8) - v5;
  *((_DWORD *)result + 8) = v6;
  return ec_dec_normalize(result);
}

BOOL ec_dec_bit_logp(uint64_t a1, char a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  _BOOL8 v6;

  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 36);
  v4 = v2 >> a2;
  if (v3 >= v2 >> a2)
    *(_DWORD *)(a1 + 36) = v3 - (v2 >> a2);
  v5 = v2 - v4;
  v6 = v3 < v4;
  if (v3 >= v4)
    v4 = v5;
  *(_DWORD *)(a1 + 32) = v4;
  ec_dec_normalize((uint64_t *)a1);
  return v6;
}

uint64_t ec_dec_icdf(uint64_t a1, unsigned __int8 *a2, char a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;

  v4 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 36);
  v5 = v4 >> a3;
  LODWORD(v6) = -1;
  do
  {
    v7 = v4;
    v8 = *a2++;
    v4 = v5 * v8;
    v6 = (v6 + 1);
  }
  while (v3 < v5 * v8);
  *(_DWORD *)(a1 + 32) = v7 - v4;
  *(_DWORD *)(a1 + 36) = v3 - v4;
  ec_dec_normalize((uint64_t *)a1);
  return v6;
}

uint64_t ec_dec_uint(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;

  v3 = a2 - 1;
  if (v3 < 0x100)
  {
    v14 = *(_DWORD *)(a1 + 36);
    v15 = *(_DWORD *)(a1 + 32) / a2;
    *(_DWORD *)(a1 + 40) = v15;
    v16 = v14 / v15 + 1;
    v10 = a2 >= v16;
    v17 = a2 - v16;
    if (v10)
      v13 = v17;
    else
      v13 = 0;
    ec_dec_update((uint64_t *)a1, v13, v13 + 1, a2);
  }
  else
  {
    v4 = __clz(v3);
    v5 = 24 - v4;
    v6 = (v3 >> (24 - v4)) + 1;
    v7 = *(_DWORD *)(a1 + 36);
    v8 = *(_DWORD *)(a1 + 32) / v6;
    *(_DWORD *)(a1 + 40) = v8;
    v9 = v7 / v8 + 1;
    v10 = v6 >= v9;
    v11 = v6 - v9;
    if (v10)
      v12 = v11;
    else
      v12 = 0;
    ec_dec_update((uint64_t *)a1, v12, v12 + 1, v6);
    v13 = (v12 << v5) | ec_dec_bits((uint64_t *)a1, v5);
    if (v13 > v3)
    {
      *(_DWORD *)(a1 + 48) = 1;
      return v3;
    }
  }
  return v13;
}

uint64_t ec_dec_bits(uint64_t *a1, unsigned int a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;

  v3 = *((_DWORD *)a1 + 4);
  v2 = *((_DWORD *)a1 + 5);
  if (v2 >= a2)
  {
    v8 = *((_DWORD *)a1 + 5);
  }
  else
  {
    v4 = *((_DWORD *)a1 + 2);
    v5 = *((_DWORD *)a1 + 3);
    do
    {
      if (v5 >= v4)
      {
        v7 = 0;
      }
      else
      {
        v6 = *a1;
        *((_DWORD *)a1 + 3) = ++v5;
        v7 = *(unsigned __int8 *)(v6 + v4 - v5);
      }
      v3 |= v7 << v2;
      v8 = v2 + 8;
      v9 = v2 < 17;
      v2 += 8;
    }
    while (v9);
  }
  *((_DWORD *)a1 + 4) = v3 >> a2;
  *((_DWORD *)a1 + 5) = v8 - a2;
  *((_DWORD *)a1 + 6) += a2;
  return v3 & ~(-1 << a2);
}

uint64_t ec_tell_frac(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int i;
  int v6;

  v1 = *(_DWORD *)(a1 + 32);
  v2 = __clz(v1);
  v3 = 32 - v2;
  v4 = v1 >> (16 - v2);
  for (i = 4; i > 1; --i)
  {
    v6 = v4 * v4;
    v3 = __PAIR64__(v3, v6) >> 31;
    v4 = v6 >> 15 >> (v6 < 0);
  }
  return 8 * *(_DWORD *)(a1 + 24) - v3;
}

uint64_t hysteresis_decision(int a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result;

  if (a4 < 1)
  {
    result = 0;
  }
  else
  {
    result = 0;
    while (*(__int16 *)(a2 + 2 * result) <= a1)
    {
      if (a4 == ++result)
      {
        result = a4;
        break;
      }
    }
  }
  if ((int)result > a5)
  {
    if (*(__int16 *)(a3 + 2 * a5) + *(__int16 *)(a2 + 2 * a5) <= a1)
      result = result;
    else
      result = a5;
  }
  if ((int)result < a5)
  {
    if (*(__int16 *)(a2 + 2 * a5 - 2) - *(__int16 *)(a3 + 2 * a5 - 2) >= a1)
      return result;
    else
      return a5;
  }
  return result;
}

uint64_t celt_lcg_rand(int a1)
{
  return (1664525 * a1 + 1013904223);
}

uint64_t compute_band_energies(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  signed int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  signed int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  char v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;

  v32 = result;
  v8 = 0;
  v9 = *(_QWORD *)(result + 24);
  if (a5 <= 1)
    v10 = 1;
  else
    v10 = a5;
  v11 = a4;
  v29 = 4 * *(_DWORD *)(result + 40) * a6;
  v30 = v10;
  do
  {
    if (a4 >= 1)
    {
      v12 = 0;
      do
      {
        v13 = 0;
        v14 = v12;
        LODWORD(v16) = *(__int16 *)(v9 + 2 * v12++) * a6;
        v15 = *(__int16 *)(v9 + 2 * v12) * (uint64_t)a6;
        v16 = (int)v16;
        v17 = (int)v16;
        do
        {
          v18 = *(_DWORD *)(a2 + 4 * v17);
          if (v13 <= v18)
            v13 = *(_DWORD *)(a2 + 4 * v17);
          if (v13 <= -v18)
            v13 = -v18;
          ++v17;
        }
        while (v17 < v15);
        if (v13 < 1)
        {
          v28 = 1;
        }
        else
        {
          LODWORD(v19) = 0;
          v20 = __clz(v13);
          v21 = v20 ^ 0x1F;
          v22 = v20 - 21;
          v23 = 21 - v20;
          do
          {
            v24 = *(_DWORD *)(a2 + 4 * v16);
            v25 = v24 >> v23;
            v26 = v24 << v22;
            if (v21 > 0xA)
              LOWORD(v26) = v25;
            v19 = (v19 + (__int16)v26 * (__int16)v26);
            ++v16;
          }
          while (v16 < v15);
          result = celt_sqrt(v19);
          v27 = (int)result >> v22;
          if (v21 >= 0xA)
            v27 = (_DWORD)result << v23;
          v28 = v27 + 1;
        }
        *(_DWORD *)(a3 + 4 * (v14 + *(_DWORD *)(v32 + 8) * (int)v8)) = v28;
      }
      while (v12 != v11);
    }
    ++v8;
    a2 += v29;
  }
  while (v8 != v30);
  return result;
}

uint64_t normalise_bands(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  signed int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  signed int v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v12 = 0;
  v13 = *(_QWORD *)(a1 + 24);
  v14 = *(_DWORD *)(a1 + 40) * a7;
  if (a5 <= 1)
    v15 = 1;
  else
    v15 = a5;
  if (a6 <= 1)
    v16 = 1;
  else
    v16 = a6;
  v31 = v16;
  v29 = 4 * v14;
  v30 = 2 * v14;
  do
  {
    v17 = 0;
    do
    {
      v18 = *(_DWORD *)(a4 + 4 * ((int)v17 + *(_DWORD *)(a1 + 8) * (int)v12));
      v19 = 31 - __clz(v18);
      if (v18 >= 1)
        v20 = v19;
      else
        v20 = 0;
      v21 = v18 >> (v20 - 13);
      v22 = v18 << (13 - v20);
      if (v20 > 0xD)
        LOWORD(v22) = v21;
      result = celt_rcp(8 * (__int16)v22);
      LODWORD(v25) = *(__int16 *)(v13 + 2 * v17++) * a7;
      v24 = *(__int16 *)(v13 + 2 * v17) * (uint64_t)a7;
      v25 = (int)v25;
      do
      {
        v26 = *(_DWORD *)(a2 + 4 * v25);
        v27 = v26 << (14 - v20);
        v28 = v26 >> (v20 - 14);
        if ((unsigned __int16)v20 <= 0xEu)
          LOWORD(v28) = v27;
        *(_WORD *)(a3 + 2 * v25++) = ((__int16)v28 * (__int16)result) >> 15;
      }
      while (v25 < v24);
    }
    while (v17 != v15);
    ++v12;
    a3 += v30;
    a2 += v29;
  }
  while (v12 != v31);
  return result;
}

void denormalise_bands(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  __int16 *v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  size_t v41;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v48;
  int v49;

  v11 = 0;
  v12 = 0;
  v13 = *(_QWORD *)(a1 + 24);
  v14 = *(_DWORD *)(a1 + 40);
  v15 = v14 * a8;
  v39 = a5;
  v38 = *(_WORD *)(v13 + 2 * a5);
  v16 = v38 * a8;
  v37 = a2 + 2 * v16;
  v17 = a6;
  v18 = *(__int16 *)(v13 + 2 * a6);
  v44 = v18 * a8;
  v41 = 4 * v16;
  v45 = v16;
  v40 = a3 + 4 * (v16 - 1) + 4;
  v36 = 4 * ((v14 - v18) * a8 - 1) + 4;
  v19 = v14 * a8;
  if (a7 <= 1)
    v20 = 1;
  else
    v20 = a7;
  v43 = v20;
  v48 = v15;
  do
  {
    v21 = v11 * v19;
    v49 = v12;
    if (v45 < 1)
    {
      v22 = (int *)(a3 + 4 * v21);
    }
    else
    {
      v22 = (int *)(v40 + 4 * v12);
      bzero((void *)(a3 + 4 * (int)v19 * (int)v11), v41);
    }
    if (a5 < a6)
    {
      v23 = (__int16 *)(v37 + 2 * v21);
      LOWORD(v24) = v38;
      v25 = v39;
      v19 = v48;
      while (1)
      {
        v26 = (__int16)v24 * a8;
        v27 = v25 + 1;
        v24 = *(__int16 *)(v13 + 2 * (v25 + 1));
        v28 = v24 * a8;
        v29 = (__int16)(*(_WORD *)(a4 + 2 * (v25 + v11 * *(int *)(a1 + 8))) + (eMeans[v25] << 6));
        if (v29 >= -15360)
        {
          v30 = 16 - (v29 >> 10);
          v31 = ((((((326528 * (v29 & 0x3FFu)) >> 16) + 14819) * 32 * (v29 & 0x3FF) + 1494482944) >> 16)
               * 32
               * (v29 & 0x3FF)
               + 1073676288) >> 16;
          if (v29 > 17407)
          {
            if (v30 == -1)
              v32 = -1;
            else
              v32 = -2;
            if (v30 >= 0xFFFFFFFE)
              v33 = v31;
            else
              v33 = 0x7FFF;
            do
            {
              v34 = *v23++;
              *v22++ = (v33 * v34) << -v32;
              ++v26;
            }
            while (v26 < v28);
            goto LABEL_22;
          }
        }
        else
        {
          LOBYTE(v30) = 0;
          v31 = 0;
        }
        do
        {
          v35 = *v23++;
          *v22++ = (int)(v31 * v35) >> v30;
          ++v26;
        }
        while (v26 < v28);
LABEL_22:
        v25 = v27;
        if (v27 == v17)
          goto LABEL_25;
      }
    }
    v19 = v48;
LABEL_25:
    if (v44 < (int)v19)
    {
      bzero(v22, v36);
      v19 = v48;
    }
    ++v11;
    v12 = v49 + v19;
  }
  while (v11 != v43);
}

__int16 *anti_collapse(__int16 *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13)
{
  __int16 *v15;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  signed int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  __int16 v41;
  uint64_t v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  __int16 v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  BOOL v60;
  int v61;
  __int16 v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  __int16 *v67;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  int v73;
  int v74;

  if (a7 < a8)
  {
    v15 = result;
    if (1 << a4 <= 1)
      v17 = 1;
    else
      v17 = 1 << a4;
    v71 = a6;
    if (a5 <= 1)
      v18 = 1;
    else
      v18 = a5;
    v66 = v18;
    v19 = a7;
    v63 = a8;
    v64 = a5;
    v67 = result;
    do
    {
      v70 = v19;
      v20 = *(__int16 *)(*((_QWORD *)v15 + 3) + 2 * (v19 + 1)) - *(__int16 *)(*((_QWORD *)v15 + 3) + 2 * v19);
      v69 = v20 << a4;
      v21 = (*(_DWORD *)(a12 + 4 * v19) + 1) / (v20 << a4);
      v22 = (__int16)(-128 * v21);
      v65 = v19 + 1;
      if (v22 <= 15359)
      {
        if (v22 >= -15360)
        {
          v24 = (((((20408 * ((-2048 * v21) & 0x3800u)) >> 16) + 14819) * 2 * ((-2048 * v21) & 0x3800) + 1494482944) >> 16)
              * 2
              * ((-2048 * v21) & 0x3800)
              + 1073676288;
          v25 = -2 - ((__int16)(-128 * v21) >> 10);
          v26 = HIWORD(v24);
          if (v22 > -2049)
            v23 = v26 << -(char)v25;
          else
            v23 = v26 >> v25;
        }
        else
        {
          v23 = 0;
        }
      }
      else
      {
        v23 = 2130706432;
      }
      v27 = v23 >> 1;
      if (v27 >= 0x7FFF)
        v28 = 0x7FFF;
      else
        v28 = v27;
      v29 = 31 - __clz(v69);
      v74 = v29 >> 1;
      result = (__int16 *)celt_rsqrt_norm(v69 << (14 - (v29 & 0xFE)));
      v73 = (int)result;
      v30 = 0;
      v31 = (__int16)(v28 >> 1);
      v32 = v70;
      v15 = v67;
      v33 = a5;
      v34 = v66;
      v35 = a11;
      v37 = a9;
      v36 = a10;
      do
      {
        v38 = *((int *)v15 + 2);
        v39 = v32 + (int)v38 * (uint64_t)(int)v30;
        LOWORD(v40) = *(_WORD *)(v36 + 2 * v39);
        v41 = *(_WORD *)(v35 + 2 * v39);
        if (v33 == 1)
        {
          v42 = v32 + v38;
          if ((__int16)v40 <= *(__int16 *)(v36 + 2 * v42))
            LOWORD(v40) = *(_WORD *)(v36 + 2 * v42);
          v43 = *(__int16 *)(v35 + 2 * v42);
          if (v41 <= v43)
            v41 = v43;
        }
        v44 = *(__int16 *)(v37 + 2 * v39);
        v40 = (__int16)v40;
        if ((__int16)v40 >= v41)
          v40 = v41;
        v45 = (v44 - v40) & ~((v44 - v40) >> 31);
        if (v45 >> 14)
        {
          v47 = 0;
        }
        else
        {
          if ((unsigned __int16)v45 <= 0x3C00u)
          {
            v48 = (unsigned __int16)v45;
            v49 = -v45;
            v50 = (((((326528 * (v49 & 0x3FFu)) >> 16) + 14819) * 32 * (v49 & 0x3FF) + 1494482944) >> 16)
                * 32
                * (v49 & 0x3FF)
                + 1073676288;
            v51 = -2 - ((__int16)v49 >> 10);
            v52 = HIWORD(v50);
            if (v48 < 0x801)
              v46 = v52 << -(char)v51;
            else
              v46 = v52 >> v51;
          }
          else
          {
            v46 = 0;
          }
          v53 = v46 >> 1;
          if (v53 >= 0x3FFF)
            LOWORD(v53) = 0x3FFF;
          v47 = 2 * v53;
        }
        v54 = v47;
        if (v47 >= 23169)
          v54 = 23169;
        v55 = (23170 * v54) >> 14;
        if (a4 == 3)
          v47 = v55;
        v56 = v47;
        if (v31 < v47)
          v56 = v31;
        if (a4 != 31)
        {
          v57 = 0;
          v58 = 0;
          v59 = ((v56 >> 1) * v73) >> 15 >> v74;
          result = (__int16 *)(a2 + 2 * v30 * v71 + 2 * (*(__int16 *)(*((_QWORD *)v15 + 3) + 2 * v32) << a4));
          do
          {
            if (((1 << v58) & *(unsigned __int8 *)(a3 + v30 + v70 * v64)) != 0)
            {
              v60 = 1;
            }
            else
            {
              v57 = 1;
              v60 = v20 < 1;
            }
            if (!v60)
            {
              v61 = 0;
              do
              {
                a13 = 1664525 * a13 + 1013904223;
                if ((a13 & 0x8000) != 0)
                  v62 = v59;
                else
                  v62 = -(__int16)v59;
                result[(v61++ << a4) + v58] = v62;
              }
              while (v20 != v61);
              v57 = 1;
            }
            ++v58;
          }
          while (v58 != v17);
          if (v57)
          {
            result = (__int16 *)renormalise_vector(result, v69, 0x7FFF);
            v37 = a9;
            v36 = a10;
            v32 = v70;
            v34 = v66;
            v35 = a11;
            v15 = v67;
            v33 = a5;
          }
        }
        ++v30;
      }
      while (v30 != v34);
      v19 = v65;
    }
    while (v65 != v63);
  }
  return result;
}

uint64_t spreading_decision(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, _DWORD *a5, int *a6, int a7, int a8, int a9, int a10)
{
  __int16 *v10;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;

  v10 = *(__int16 **)(a1 + 24);
  if ((v10[a8] - v10[a8 - 1]) * a10 < 9)
    return 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  if (a9 <= 1)
    v16 = 1;
  else
    v16 = a9;
  do
  {
    if (a8 >= 1)
    {
      v17 = 0;
      v18 = *v10;
      do
      {
        v19 = v17 + 1;
        v20 = v10[v17 + 1];
        v21 = ((v20 - v18) * a10);
        if ((int)v21 >= 9)
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v25 = v18 * a10;
          v26 = (__int16)((v20 - v18) * a10);
          v27 = (__int16 *)(a2 + 2 * v25);
          v28 = v21;
          do
          {
            v29 = *v27++;
            v30 = (__int16)((v29 * v29) >> 15) * v26;
            if (v30 < 2048)
              ++v24;
            if (v30 < 512)
              ++v23;
            if (v30 < 128)
              ++v22;
            --v28;
          }
          while (v28);
          if (v17 > *(int *)(a1 + 8) - 4)
            v15 += 32 * (v23 + v24) / (int)v21;
          v31 = (int)v21 <= 2 * v24;
          if ((int)v21 <= 2 * v23)
            ++v31;
          if ((int)v21 <= 2 * v22)
            ++v31;
          v13 += v31 << 8;
          ++v14;
        }
        v18 = v20;
        v17 = v19;
      }
      while (v19 != a8);
    }
    ++v12;
    a2 += 2 * *(_DWORD *)(a1 + 40) * a10;
  }
  while (v12 != v16);
  if (a7)
  {
    if (v15)
      v32 = v15 / ((a8 - *(_DWORD *)(a1 + 8) + 4) * a9);
    else
      v32 = 0;
    v33 = (*a5 + v32) >> 1;
    *a5 = v33;
    v34 = v33 - 4;
    if (*a6 == 2)
      v33 += 4;
    if (!*a6)
      v33 = v34;
    if (v33 <= 22)
      v35 = v33 > 18;
    else
      v35 = 2;
    *a6 = v35;
  }
  v36 = *a3 + v13 / v14;
  *a3 = v36 >> 1;
  v37 = (v36 & 0xFFFFFFFE) + (v36 >> 1) - (a4 << 7) + 450;
  if ((int)v37 < 320)
    return 3;
  if (v37 >= 0x400)
    return v37 < 0x600;
  return 2;
}

__int16 *haar1(__int16 *result, int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 *v8;
  uint64_t v9;
  __int16 *v10;
  __int16 *v11;
  int v12;
  int v13;

  if ((int)a3 >= 1)
  {
    v3 = 0;
    LODWORD(v4) = a2 >> 1;
    v5 = a3;
    if (a2 >> 1 <= 1)
      v4 = 1;
    else
      v4 = v4;
    v6 = 4 * a3;
    v7 = 4 * a3;
    v8 = &result[a3];
    do
    {
      if (a2 >= 2)
      {
        v9 = v4;
        v10 = v8;
        v11 = result;
        do
        {
          v12 = 46340 * *v11;
          v13 = 46340 * *v10;
          *v11 = HIWORD(v13) + HIWORD(v12);
          *v10 = HIWORD(v12) - HIWORD(v13);
          v11 = (__int16 *)((char *)v11 + v6);
          v10 = (__int16 *)((char *)v10 + v7);
          --v9;
        }
        while (v9);
      }
      ++v3;
      ++result;
      ++v8;
    }
    while (v3 != v5);
  }
  return result;
}

void quant_all_bands(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11, int a12, unsigned int a13, uint64_t a14, int a15, int a16, uint64_t a17, int a18, unsigned int a19, _DWORD *a20)
{
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  char *v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  __int16 *v36;
  BOOL v37;
  int v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  __int16 *v44;
  __int16 *v45;
  int v46;
  int v47;
  __int16 *v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  __int16 *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  __int16 *v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  BOOL v72;
  __int16 *v73;
  __int16 *v74;
  __int16 *v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  __int16 *v82;
  int v83;
  int v84;
  int v85;
  int v86;
  __int16 *v87;
  int v88;
  uint64_t v89;
  int v90;
  __int16 *v91;
  __int16 *v92;
  uint64_t v93;
  int v94;
  _WORD *v95;
  __int16 *v96;
  __int16 *v97;
  char *v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  unsigned int v104;
  int v105;
  uint64_t *v106;
  uint64_t *v107;
  int v108;
  int v109;
  __int16 *v110;
  __int16 *v111;
  char *v112;
  unsigned int v113;
  char v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v123;
  int v124;
  uint64_t *v125;
  uint64_t v126;
  __int16 *v127;
  int v128;
  int v129;
  int v130;
  BOOL v131;
  int v132;
  int v133;
  int v134;
  __int16 *v135;
  __int16 *v136;
  uint64_t v137;
  __int16 v138;
  int v139;
  int v140;
  int v141;
  __int16 v142;
  int v143;
  int v144;
  unsigned int v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  __int16 *v152;
  uint64_t v153;
  __int16 v154;
  unsigned int v155;
  unsigned int v156;
  int v157;
  int v158;
  __int16 *v159;
  uint64_t v160;
  unsigned int v161;
  __int16 v162;
  uint64_t v163;
  __int16 *v164;
  int v165;
  uint64_t v166;
  _DWORD *v167;
  int v168;
  int v169;
  int v170;
  int v171;
  _BYTE v172[12];
  char *v173;
  __int16 *v174;
  char *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  int v179;
  __int16 *v180;
  uint64_t v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  int v188;
  __int16 *v189;
  __int16 *v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  unsigned int v198;
  uint64_t v199;
  int v200;
  uint64_t v201;
  int v202;
  int v203;
  int v204;
  unsigned int v205;
  uint64_t v206;
  int v207;
  uint64_t v208;
  uint64_t v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  int v217;
  int v218;
  uint64_t v219;

  v209 = a8;
  v194 = a5;
  v208 = a4;
  v206 = a13;
  v205 = a11;
  v219 = *MEMORY[0x24BDAC8D0];
  v24 = *(_QWORD *)(a2 + 24);
  v195 = a6;
  v25 = a6 != 0;
  v212 = 0u;
  v213 = 0u;
  v210 = 0u;
  v211 = 0u;
  if (a10)
    v26 = 1 << a18;
  else
    v26 = 1;
  v200 = v26;
  v27 = *(__int16 *)(v24 + 2 * a3);
  v28 = *(int *)(a2 + 8);
  v196 = v24;
  v29 = v24 + 2 * v28;
  LODWORD(v28) = *(__int16 *)(v29 - 2);
  v193 = v27;
  v30 = 2 * (((int)v28 - v27) << a18 << v25);
  v31 = (char *)&v166 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v31, v30);
  v32 = *(__int16 *)(v29 - 2);
  *(_QWORD *)&v213 = v209;
  v191 = a17;
  *(_QWORD *)&v212 = a17;
  v202 = a1;
  LODWORD(v210) = a1;
  v192 = a2;
  *((_QWORD *)&v210 + 1) = a2;
  v167 = a20;
  v33 = *a20;
  DWORD2(v213) = *a20;
  *(_QWORD *)((char *)&v211 + 4) = __PAIR64__(v205, v206);
  if (a3 < (int)v208)
  {
    v207 = 0;
    v34 = v193 << a18;
    v35 = v32 << a18;
    if (v195)
      v36 = (__int16 *)v31;
    else
      v36 = 0;
    v189 = v36;
    v37 = v205 == 3 && v200 <= 1;
    v38 = !v37;
    v188 = v38;
    v187 = ~(-1 << v200);
    v178 = a19;
    v186 = (int)a19;
    v185 = (int)v208;
    v184 = (int)v208 - 1;
    v181 = (int)v206;
    v183 = a15;
    v182 = a14;
    v203 = a12;
    v40 = v196;
    v177 = v196 - 2;
    v176 = v196 + 2;
    v41 = (uint64_t)&v31[2 * (int)v35 + -2 * v34];
    v190 = (__int16 *)v31;
    v175 = &v31[-2 * v34];
    v201 = a9;
    v199 = a3;
    v42 = a3;
    v43 = 1;
    v44 = (__int16 *)(v194 + 2 * v35);
    v179 = v193 << a18;
    v197 = v41;
    v166 = v41 - 2 * v34;
    while (1)
    {
      v209 = v42;
      v45 = v44;
      LODWORD(v211) = v42;
      v46 = *(__int16 *)(v40 + 2 * v42);
      v47 = v46 << a18;
      if (v195)
        v48 = (__int16 *)(v195 + 2 * v47);
      else
        v48 = 0;
      v206 = v42 + 1;
      v49 = *(__int16 *)(v40 + 2 * (v42 + 1));
      v50 = ec_tell_frac(v191);
      v51 = v209;
      v52 = 0;
      if (v209 == v199)
        v53 = 0;
      else
        v53 = v50;
      v54 = a16 - v53;
      v205 = v50;
      v55 = v183 - v50;
      DWORD2(v212) = v183 - v50 - 1;
      if (v209 < v186)
      {
        v56 = v178 - v209;
        if ((int)v178 - (int)v209 >= 3)
          v56 = 3;
        v57 = *(_DWORD *)(v201 + 4 * v209) + v54 / v56;
        if (v55 >= v57)
          v55 = v57;
        v58 = v55 & ~(v55 >> 31);
        if (v58 >= 0x3FFF)
          v52 = 0x3FFF;
        else
          v52 = v58;
      }
      v59 = v49 - v46;
      v204 = v54;
      if (v202)
      {
        v60 = v194;
        v40 = v196;
        v61 = v200;
        v62 = v193;
        v63 = v190;
        v64 = v207;
        v65 = v184;
        v66 = v197;
      }
      else
      {
        v40 = v196;
        v60 = v194;
        v61 = v200;
        v62 = v193;
        v63 = v190;
        v64 = v207;
        v65 = v184;
        v66 = v197;
        if ((*(__int16 *)(v196 + 2 * v209) - v59) << a18 >= *(__int16 *)(v196 + 2 * v199) << a18 && (v43 || v207 == 0))
          v64 = v209;
      }
      v68 = (__int16 *)(v60 + 2 * v47);
      v69 = *(_DWORD *)(v182 + 4 * v209);
      v70 = (v59 << a18);
      HIDWORD(v211) = v69;
      v71 = *(int *)(v192 + 12);
      v72 = v209 < v71;
      if (v209 >= v71)
        v73 = 0;
      else
        v73 = v45;
      if (v72)
        v74 = v68;
      else
        v74 = v63;
      if (v72)
        v75 = v48;
      else
        v75 = v189;
      if (v209 == v65)
        v44 = 0;
      else
        v44 = v73;
      if (v69 < 0)
        v76 = 1;
      else
        v76 = v188;
      v77 = -1;
      if (v64)
      {
        v78 = v187;
        v79 = v187;
        if (v76)
        {
          v80 = (*(__int16 *)(v40 + 2 * v64) - v62 - v59) << a18;
          v77 = v80 & ~(v80 >> 31);
          v81 = v77 + v179;
          v82 = (__int16 *)(v177 + 2 * v64);
          v83 = v64;
          do
          {
            v84 = *v82--;
            --v83;
          }
          while (v84 << a18 > v81);
          v85 = v81 + v70;
          v86 = v64 - 2;
          v87 = (__int16 *)(v176 + 2 * (v64 - 1));
          do
          {
            v88 = *v87++;
            ++v86;
          }
          while (v88 << a18 < v85);
          v79 = 0;
          v78 = 0;
          do
          {
            v79 |= *(unsigned __int8 *)(a7 + (v83 << v25));
            v78 |= *(unsigned __int8 *)(a7 + (v83 << v25) + v25);
            v37 = v83++ < v86;
          }
          while (v37);
        }
      }
      else
      {
        v78 = v187;
        v79 = v187;
      }
      v207 = v64;
      if (v203)
      {
        if (v202 || v209 != v181)
        {
          if (v209 != v181)
          {
            v180 = v44;
            v198 = v52;
            v90 = v52 >> 1;
            *(_QWORD *)&v172[4] = v77;
            if (v77 == -1)
              v91 = 0;
            else
              v91 = &v63[v77];
            LODWORD(v173) = v52 >> 1;
            if (v209 == v65)
            {
              v92 = v74;
              v93 = v70;
              v94 = v61;
              LODWORD(v174) = quant_band((int *)&v210, v92, v70, v90, v61, v91, a18, 0, 0x7FFF, 0, v79);
              v95 = 0;
              if (v77 == -1)
                v96 = 0;
              else
                v96 = (__int16 *)(v197 + 2 * *(_QWORD *)&v172[4]);
            }
            else
            {
              v126 = v209;
              v127 = v74;
              v93 = v70;
              v94 = v61;
              LODWORD(v174) = quant_band((int *)&v210, v127, v70, v90, v61, v91, a18, &v175[2 * (*(__int16 *)(v40 + 2 * v209) << a18)], 0x7FFF, v73, v79);
              if (v77 == -1)
                v96 = 0;
              else
                v96 = (__int16 *)(v197 + 2 * *(_QWORD *)&v172[4]);
              v95 = (_WORD *)(v166 + 2 * (*(__int16 *)(v40 + 2 * v126) << a18));
            }
            v128 = v94;
            v44 = v180;
            v114 = quant_band((int *)&v210, v75, v93, (int)v173, v128, v96, a18, v95, 0x7FFF, v180, v78);
            v103 = v206;
            v104 = v205;
            v105 = v198;
            LODWORD(v100) = v93;
            LOBYTE(v102) = (_BYTE)v174;
            goto LABEL_121;
          }
        }
        else if ((*(__int16 *)(v40 + 2 * v209) - v62) << a18 >= 1)
        {
          v89 = 0;
          do
          {
            v63[v89] = (*(__int16 *)(v66 + 2 * v89) + v63[v89]) >> 1;
            ++v89;
          }
          while (v89 < (*(__int16 *)(v40 + 2 * v51) - v62) << a18);
        }
      }
      if (v77 == -1)
        v97 = 0;
      else
        v97 = &v63[v77];
      v208 = v70;
      if (v75)
      {
        if (v51 == v65)
          v98 = 0;
        else
          v98 = &v175[2 * (*(__int16 *)(v40 + 2 * v51) << a18)];
        v99 = v78 | v79;
        v198 = v52;
        v217 = v78 | v79;
        v218 = v52;
        if ((_DWORD)v70 == 1)
        {
          quant_band_n1((uint64_t)&v210, v74, v75, v98);
          LODWORD(v100) = v208;
          v101 = v209;
          LOBYTE(v102) = 1;
          v103 = v206;
          v104 = v205;
          v105 = v198;
LABEL_159:
          v203 = 0;
          v114 = v102;
          goto LABEL_160;
        }
        v173 = v98;
        v174 = v97;
        v203 = v210;
        v106 = (uint64_t *)v212;
        v214 = 0;
        v215 = 0;
        v216 = 0;
        compute_theta((int *)&v210, (uint64_t)&v214, v74, v75, v208, &v218, v61, v61, a18, 1, &v217);
        *(_QWORD *)v172 = v214;
        if ((_DWORD)v208 == 2)
        {
          v107 = v106;
          v108 = v218;
          if ((v216 & 0xFFFFBFFF) != 0)
            v109 = -8;
          else
            v109 = 0;
          DWORD2(v212) += v109 - HIDWORD(v216);
          if ((int)v216 <= 0x2000)
            v110 = v74;
          else
            v110 = v75;
          if ((int)v216 <= 0x2000)
            v111 = v75;
          else
            v111 = v74;
          v171 = v215;
          if ((v216 & 0xFFFFBFFF) != 0)
          {
            v168 = v109;
            v169 = v218;
            if (v203)
            {
              v170 = v111[1] * *v110 < *v111 * v110[1];
              ec_enc_bits(v107, v170, 1);
            }
            else
            {
              v170 = ec_dec_bits(v107, 1u);
            }
            v108 = v169;
            v109 = v168;
          }
          else
          {
            v170 = 0;
          }
          LOBYTE(v102) = quant_band((int *)&v210, v110, 2, v108 + v109, v200, v174, a18, v173, 0x7FFF, v44, v99);
          v142 = 2 * v170;
          *v111 = (2 * v170 - 1) * v110[1];
          v111[1] = *v110 - *v110 * v142;
          if (v203)
          {
            v103 = v206;
            v104 = v205;
            v105 = v198;
            LODWORD(v100) = v208;
            v101 = v209;
            goto LABEL_159;
          }
          v143 = *(__int16 *)&v172[4];
          *v74 = (*(__int16 *)&v172[4] * *v74) >> 15;
          v74[1] = (v143 * v74[1]) >> 15;
          v144 = (__int16)v171;
          v145 = (__int16)v171 * *v75;
          *v75 = v145 >> 15;
          v75[1] = (v144 * v75[1]) >> 15;
          LOWORD(v144) = *v74;
          *v74 -= v145 >> 15;
          *v75 += v144;
          LOWORD(v144) = v74[1];
          v74[1] = v144 - v75[1];
          v75[1] += v144;
          v105 = v198;
          v100 = v208;
          v101 = v209;
        }
        else
        {
          v170 = v216;
          v115 = v217;
          v116 = v218 - HIDWORD(v215);
          if (v218 < SHIDWORD(v215))
            ++v116;
          if (v218 >= v116 >> 1)
            v117 = v116 >> 1;
          else
            v117 = v218;
          v118 = v117 & ~(v117 >> 31);
          v119 = DWORD2(v212) - HIDWORD(v216);
          DWORD2(v212) -= HIDWORD(v216);
          v180 = v44;
          if (v118 >= v218 - v118)
          {
            v164 = v44;
            v169 = v218 - v118;
            v129 = v200;
            v171 = v215;
            LODWORD(v174) = quant_band((int *)&v210, v74, v208, v117 & ~(v117 >> 31), v200, v174, a18, v173, 0x7FFF, v164, v217);
            v130 = DWORD2(v212) - v119 + v118;
            if (v170)
              v131 = v130 <= 24;
            else
              v131 = 1;
            if (v131)
              v132 = 0;
            else
              v132 = v130 - 24;
            v124 = quant_band((int *)&v210, v75, v208, v132 + v169, v129, 0, a18, 0, v171, 0, v115 >> v129);
            v125 = &v209;
          }
          else
          {
            v120 = v218 - v118;
            v171 = quant_band((int *)&v210, v75, v208, v218 - v118, v200, 0, a18, 0, v215, 0, v217 >> v200);
            v121 = DWORD2(v212) - v119 + v120;
            if (v170 == 0x4000 || v121 <= 24)
              v123 = 0;
            else
              v123 = v121 - 24;
            v124 = quant_band((int *)&v210, v74, v208, v123 + v118, v200, v174, a18, v173, 0x7FFF, v180, v115);
            v125 = &v206;
          }
          v102 = v124 | *((_DWORD *)v125 - 64);
          v105 = v198;
          v101 = v209;
          if (v203)
          {
            v103 = v206;
            v104 = v205;
            LODWORD(v100) = v208;
            v44 = v180;
            goto LABEL_159;
          }
          v100 = v208;
          if ((int)v208 < 1)
          {
            v134 = 0;
            v133 = 0;
            v138 = *(_WORD *)&v172[4];
          }
          else
          {
            v133 = 0;
            v134 = 0;
            v135 = v75;
            v136 = v74;
            v137 = v208;
            v138 = *(_WORD *)&v172[4];
            do
            {
              v140 = *v135++;
              v139 = v140;
              v141 = *v136++;
              v134 += v141 * v139;
              v133 += v139 * v139;
              --v137;
            }
            while (v137);
          }
          v146 = v138;
          v147 = v133 + (v138 >> 1) * (v138 >> 1);
          v148 = (v134 >> 16) * 4 * v138 + 2 * (((unsigned __int16)v134 * v138) >> 15);
          v149 = v147 - v148;
          v150 = v148 + v147;
          if (v148 + v147 < 161061 || (int)v149 < 161061)
          {
            v44 = v180;
            if ((int)v208 < 1)
            {
              v103 = v206;
              v104 = v205;
              goto LABEL_159;
            }
            v152 = v75;
            v153 = v208;
            do
            {
              v154 = *v74++;
              *v152++ = v154;
              --v153;
            }
            while (v153);
          }
          else
          {
            LODWORD(v174) = v102;
            v155 = 31 - __clz(v149);
            v156 = 31 - __clz(v150);
            v157 = celt_rsqrt_norm(v149 >> ((v155 & 0xFE) - 14));
            v158 = celt_rsqrt_norm(v150 >> ((v156 & 0xFE) - 14));
            v100 = v208;
            if ((int)v208 < 1)
            {
              v40 = v196;
              v44 = v180;
              v103 = v206;
              v104 = v205;
              v105 = v198;
              LOBYTE(v102) = (_BYTE)v174;
              v101 = v209;
              goto LABEL_159;
            }
            v159 = v75;
            v160 = v208;
            v44 = v180;
            v105 = v198;
            v101 = v209;
            do
            {
              v161 = v146 * *v74;
              v162 = *v159;
              *v74++ = (int)(((2 << (v155 >> 1)) >> 1) + (__int16)((v161 >> 15) - *v159) * v157) >> ((v155 >> 1) + 1);
              *v159++ = (int)(((2 << (v156 >> 1)) >> 1) + (__int16)(v162 + (v161 >> 15)) * v158) >> ((v156 >> 1) + 1);
              --v160;
            }
            while (v160);
            v40 = v196;
            LOBYTE(v102) = (_BYTE)v174;
          }
        }
        v103 = v206;
        v104 = v205;
        if ((int)v100 >= 1 && *(_DWORD *)v172)
        {
          v163 = v100;
          do
          {
            *v75 = -*v75;
            ++v75;
            --v163;
          }
          while (v163);
        }
        goto LABEL_159;
      }
      if (v51 == v65)
        v112 = 0;
      else
        v112 = &v175[2 * (*(__int16 *)(v40 + 2 * v51) << a18)];
      v165 = v78 | v79;
      v113 = v52;
      v114 = quant_band((int *)&v210, v74, v70, v52, v61, v97, a18, v112, 0x7FFF, v44, v165);
      LODWORD(v100) = v208;
      v105 = v113;
      LOBYTE(v102) = v114;
      v203 = 0;
      v103 = v206;
      v104 = v205;
LABEL_121:
      v101 = v209;
LABEL_160:
      *(_BYTE *)(a7 + (int)((_DWORD)v101 << v25)) = v102;
      *(_BYTE *)(a7 + ((_DWORD)v101 << v25) + v25) = v114;
      a16 = v204 + v104 + *(_DWORD *)(v201 + 4 * v101);
      v43 = v105 > 8 * (int)v100;
      v42 = v103;
      if (v103 >= v185)
      {
        v33 = DWORD2(v213);
        break;
      }
    }
  }
  *v167 = v33;
}

uint64_t quant_band(int *a1, __int16 *a2, uint64_t a3, int a4, int a5, __int16 *a6, int a7, _WORD *a8, __int16 a9, __int16 *a10, int a11)
{
  uint64_t v11;
  __int16 *v12;
  __int16 *v13;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  char v32;
  BOOL v33;
  _BOOL4 v34;
  int v35;
  _WORD *v36;
  __int16 v37;
  uint64_t v38;
  int v39;
  int v41;
  int v42;
  _BOOL4 v44;
  char v45;
  int v46;
  int v50;
  int v51;

  v11 = a3;
  v12 = a2;
  if ((_DWORD)a3 == 1)
  {
    quant_band_n1((uint64_t)a1, a2, 0, a8);
    return v11;
  }
  v13 = a6;
  v16 = *a1;
  v17 = a1[7] & ~(a1[7] >> 31);
  v18 = (int)a3 / a5;
  v50 = a1[7];
  v51 = v17;
  v44 = a5 == 1;
  if (a6 && a10)
  {
    if (v50 <= 0)
    {
      v33 = (v18 & 1) != 0 || v50 == 0;
      v34 = !v33;
      if (a5 <= 1 && !v34)
      {
        v45 = 1;
        goto LABEL_18;
      }
    }
    if ((int)a3 >= 1)
    {
      v19 = 0;
      do
      {
        a10[v19] = a6[v19];
        ++v19;
      }
      while (a3 != v19);
    }
    v13 = a10;
  }
  v45 = 1;
  if (v50 >= 1)
  {
    v46 = (int)a3 / a5;
    v20 = 0;
    do
    {
      v21 = v11;
      v22 = (int)v11 >> v20;
      if (v16)
        haar1(v12, v22, 1 << v20);
      if (v13)
        haar1(v13, v22, 1 << v20);
      a11 = quant_band_bit_interleave_table[a11 & 0xF] | (4 * quant_band_bit_interleave_table[a11 >> 4]);
      ++v20;
      v11 = v21;
    }
    while (v51 != v20);
    v45 = 0;
    LOBYTE(v17) = v51;
    v18 = v46;
  }
LABEL_18:
  v23 = 0;
  v24 = a5 >> v17;
  v25 = v18 << v17;
  if (((v18 << v17) & 1) != 0 || (v50 & 0x80000000) == 0)
  {
    v27 = v18 << v17;
  }
  else
  {
    v26 = 0;
    do
    {
      if (v16)
        haar1(v12, v25, v24);
      if (v13)
        haar1(v13, v25, v24);
      a11 |= a11 << v24;
      v24 *= 2;
      v27 = v25 >> 1;
      v23 = v26 + 1;
      if ((v25 & 2) != 0)
        break;
      v28 = v50 + v26++;
      v25 >>= 1;
    }
    while (v28 < -1);
  }
  if (v24 < 2)
  {
    v42 = a11;
    v31 = v11;
    v11 = quant_partition((uint64_t)a1, v12, v11, a4, v24, v13, a7, a9, v42);
    if (v16)
      return v11;
    goto LABEL_37;
  }
  v29 = v27 >> v51;
  v30 = v24 << v51;
  if (v16)
    deinterleave_hadamard(v12, v27 >> v51, v24 << v51, v44);
  if (v13)
    deinterleave_hadamard(v13, v29, v30, v44);
  v41 = a11;
  v31 = v11;
  v11 = quant_partition((uint64_t)a1, v12, v11, a4, v24, v13, a7, a9, v41);
  if (!v16)
  {
    interleave_hadamard((char *)v12, v29, v30, v44);
LABEL_37:
    while (v23)
    {
      v24 >>= 1;
      v27 *= 2;
      LODWORD(v11) = (v11 >> v24) | v11;
      haar1(v12, v27, v24);
      --v23;
    }
    if ((v45 & 1) != 0)
    {
      v32 = v51;
    }
    else
    {
      v35 = 0;
      v32 = v51;
      do
      {
        LODWORD(v11) = quant_band_bit_deinterleave_table[v11];
        haar1(v12, v31 >> v35, 1 << v35);
        ++v35;
      }
      while (v51 != v35);
    }
    v36 = a8;
    if (a8)
    {
      v37 = celt_sqrt((v31 << 22));
      if (v31 >= 1)
      {
        v38 = v31;
        do
        {
          v39 = *v12++;
          *v36++ = (v37 * v39) >> 15;
          --v38;
        }
        while (v38);
      }
    }
    return v11 & ~(-1 << (v24 << v32));
  }
  return v11;
}

uint64_t quant_band_n1(uint64_t result, __int16 *a2, __int16 *a3, _WORD *a4)
{
  uint64_t v7;
  int v8;
  uint64_t *v9;
  int v10;
  char v11;
  __int16 *v12;
  int v13;
  __int16 v14;
  char v15;

  v7 = result;
  v8 = *(_DWORD *)result;
  v9 = *(uint64_t **)(result + 32);
  v10 = *(_DWORD *)(result + 40);
  v11 = 1;
  v12 = a2;
  do
  {
    if (v10 < 8)
    {
      v13 = 0;
      if (v8)
        goto LABEL_13;
LABEL_9:
      if (v13)
        v14 = -16384;
      else
        v14 = 0x4000;
      *v12 = v14;
      goto LABEL_13;
    }
    if (v8)
    {
      v13 = (unsigned __int16)*v12 >> 15;
      result = (uint64_t)ec_enc_bits(v9, v13, 1);
    }
    else
    {
      result = ec_dec_bits(v9, 1u);
      v13 = result;
    }
    v10 = *(_DWORD *)(v7 + 40) - 8;
    *(_DWORD *)(v7 + 40) = v10;
    if (!v8)
      goto LABEL_9;
LABEL_13:
    v15 = (a3 != 0) & v11;
    v12 = a3;
    v11 = 0;
  }
  while ((v15 & 1) != 0);
  if (a4)
    *a4 = *a2 >> 4;
  return result;
}

void deinterleave_hadamard(_WORD *a1, int a2, int a3, int a4)
{
  int v8;
  size_t v9;
  char *v10;
  uint64_t v11;
  _WORD *v12;
  char *v13;
  uint64_t v14;
  _WORD *v15;
  uint64_t v16;
  _WORD *v17;
  _WORD *v18;
  uint64_t v19;
  _WORD *v20;
  _WORD *v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x24BDAC8D0];
  v8 = a3 * a2;
  v9 = 2 * a3 * a2;
  v10 = (char *)v22 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v10, v9);
  if (a4)
  {
    if (a3 >= 1)
    {
      v11 = 0;
      v12 = a1;
      do
      {
        if (a2 >= 1)
        {
          v13 = &v10[2 * ordery_table[a3 - 2 + v11] * a2];
          v14 = a2;
          v15 = v12;
          do
          {
            *(_WORD *)v13 = *v15;
            v13 += 2;
            v15 += a3;
            --v14;
          }
          while (v14);
        }
        ++v11;
        ++v12;
      }
      while (v11 != a3);
    }
  }
  else if (a3 >= 1)
  {
    v16 = 0;
    v17 = a1;
    v18 = v10;
    do
    {
      if (a2 >= 1)
      {
        v19 = a2;
        v20 = v17;
        v21 = v18;
        do
        {
          *v21++ = *v20;
          v20 += a3;
          --v19;
        }
        while (v19);
      }
      ++v16;
      v18 += a2;
      ++v17;
    }
    while (v16 != a3);
  }
  if (v8 >= 1)
    memcpy(a1, v10, 2 * v8);
}

uint64_t quant_partition(uint64_t a1, __int16 *a2, int a3, int a4, int a5, __int16 *a6, int a7, int a8, int a9)
{
  char v9;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned __int8 *v24;
  uint64_t v25;
  __int16 *v26;
  uint64_t v27;
  __int16 v28;
  __int16 v29;
  int v30;
  int v31;
  int v32;
  int v33;
  BOOL v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  __int16 *v40;
  int v41;
  int v42;
  int v44;
  uint64_t v45;
  int v46;
  unsigned __int8 *v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  unint64_t v58;
  int v60;
  BOOL v61;
  int v62;
  int v63;
  __int16 *v64;
  uint64_t v65;
  __int16 v66;
  __int16 v67;
  __int16 v68;
  int v69;
  __int16 *v70;
  uint64_t v71;
  __int16 v72;
  __int16 v73;
  __int16 *v74;
  int v75;
  unsigned int v76;
  int v78;
  unsigned int v79;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;

  v9 = a7;
  v14 = a9;
  v84 = a4;
  v15 = *(_DWORD *)a1;
  v16 = *(_QWORD *)(a1 + 8);
  v17 = *(_DWORD *)(a1 + 16);
  v18 = *(_DWORD *)(a1 + 24);
  v19 = *(uint64_t **)(a1 + 32);
  v21 = *(_QWORD *)(v16 + 128);
  v20 = *(_QWORD *)(v16 + 136);
  if (a7 == -1)
  {
    v23 = v17;
  }
  else
  {
    v22 = *(_DWORD *)(v16 + 8) + *(_DWORD *)(v16 + 8) * a7 + v17;
    v23 = v22;
    if (a3 >= 3)
    {
      v24 = (unsigned __int8 *)(v20 + *(__int16 *)(v21 + 2 * v22));
      if (v24[*v24] + 12 < a4)
      {
        v81 = 0;
        v82 = 0;
        v83 = 0;
        v25 = a3 >> 1;
        v26 = &a2[v25];
        if (a5 == 1)
          a9 = a9 & 1 | (2 * a9);
        v27 = ((a5 + 1) >> 1);
        v79 = a7 - 1;
        compute_theta((int *)a1, (uint64_t)&v81, a2, &a2[v25], v25, &v84, (a5 + 1) >> 1, a5, a7 - 1, 0, &a9);
        v28 = WORD2(v81);
        v29 = v82;
        v30 = HIDWORD(v82);
        v31 = v83;
        v32 = (HIDWORD(v82) + ((8 * (int)v25) >> (6 - v9))) & ((HIDWORD(v82) + ((8 * (int)v25) >> (6 - v9))) >> 31);
        if ((int)v83 > 0x2000)
          v32 = HIDWORD(v82) - (SHIDWORD(v82) >> (5 - v9));
        if ((v83 & 0x3FFF) != 0)
          v33 = v32;
        else
          v33 = HIDWORD(v82);
        if (a5 >= 2)
          v30 = v33;
        v34 = __OFSUB__(v84, v30);
        v35 = v84 - v30;
        if (v35 < 0 != v34)
          ++v35;
        if (v84 >= v35 >> 1)
          v36 = v35 >> 1;
        else
          v36 = v84;
        v37 = v36 & ~(v36 >> 31);
        v75 = a5;
        v38 = (v84 - v37);
        v39 = *(_DWORD *)(a1 + 40) - HIDWORD(v83);
        *(_DWORD *)(a1 + 40) = v39;
        if (a6)
          v40 = &a6[v25];
        else
          v40 = 0;
        v41 = a9;
        if ((int)v37 >= (int)v38)
        {
          v72 = v29;
          v74 = v40;
          v78 = quant_partition(a1, a2, v25, v37, v27, a6, v79, (__int16)((v28 * a8 + 0x4000) >> 15), a9);
          v60 = *(_DWORD *)(a1 + 40) - v39 + v37;
          if (v31)
            v61 = v60 <= 24;
          else
            v61 = 1;
          if (v61)
            v62 = 0;
          else
            v62 = v60 - 24;
          return (quant_partition(a1, v26, v25, (v62 + v38), v27, v74, v79, (__int16)((v72 * a8 + 0x4000) >> 15), v41 >> v27) << (v75 >> 1)) | v78;
        }
        else
        {
          v73 = v28;
          v76 = quant_partition(a1, v26, v25, v38, v27, v40, v79, (__int16)((v29 * a8 + 0x4000) >> 15), a9 >> v27) << (v75 >> 1);
          v42 = *(_DWORD *)(a1 + 40) - v39 + v38;
          if (v31 == 0x4000 || v42 <= 24)
            v44 = 0;
          else
            v44 = v42 - 24;
          return quant_partition(a1, a2, v25, (v44 + v37), v27, a6, v79, (__int16)((v73 * a8 + 0x4000) >> 15), v41) | v76;
        }
      }
    }
  }
  v46 = 0;
  v47 = (unsigned __int8 *)(v20 + *(__int16 *)(v21 + 2 * v23));
  v48 = *v47;
  v49 = a4 - 1;
  v50 = 6;
  do
  {
    if (v49 <= v47[(v48 + v46 + 1) >> 1])
      v48 = (v48 + v46 + 1) >> 1;
    else
      v46 = (v48 + v46 + 1) >> 1;
    --v50;
  }
  while (v50);
  if (v46)
    v51 = v47[v46];
  else
    v51 = -1;
  if (v49 - v51 <= v47[v48] - v49)
    v52 = v46;
  else
    v52 = v48;
  if (!(_DWORD)v52)
    goto LABEL_55;
  v53 = v47[(int)v52] + 1;
  v54 = *(_DWORD *)(a1 + 40) - v53;
  *(_DWORD *)(a1 + 40) = v54;
  if (v54 < 0 && (int)v52 >= 1)
  {
    v55 = v52 - 1;
    do
    {
      v56 = v53 + v54;
      *(_DWORD *)(a1 + 40) = v56;
      v57 = v55;
      if ((_DWORD)v55)
        v53 = v47[v55] + 1;
      else
        v53 = 0;
      v54 = v56 - v53;
      *(_DWORD *)(a1 + 40) = v54;
      LODWORD(v52) = v52 - 1;
      if ((v54 & 0x80000000) == 0)
        break;
      v58 = v55-- + 1;
    }
    while (v58 > 1);
    if (!v57)
    {
LABEL_55:
      if (!v15)
      {
        v45 = (1 << a5) - 1;
        if ((v45 & v14) != 0)
        {
          if (a6)
          {
            if (a3 >= 1)
            {
              v63 = *(_DWORD *)(a1 + 56);
              v64 = a2;
              v65 = a3;
              do
              {
                v63 = 1664525 * v63 + 1013904223;
                v67 = *a6++;
                v66 = v67;
                if ((v63 & 0x8000) != 0)
                  v68 = 4;
                else
                  v68 = -4;
                *v64++ = v68 + v66;
                --v65;
              }
              while (v65);
              *(_DWORD *)(a1 + 56) = v63;
            }
            v45 = v45 & v14;
          }
          else if (a3 >= 1)
          {
            v69 = *(_DWORD *)(a1 + 56);
            v70 = a2;
            v71 = a3;
            do
            {
              v69 = 1664525 * v69 + 1013904223;
              *v70++ = v69 >> 20;
              --v71;
            }
            while (v71);
            *(_DWORD *)(a1 + 56) = v69;
          }
          renormalise_vector(a2, a3, a8);
          return v45;
        }
        if (a3 >= 1)
          bzero(a2, 2 * a3);
      }
      return 0;
    }
  }
  if ((int)v52 >= 8)
    LODWORD(v52) = (v52 & 7 | 8) << ((v52 >> 3) - 1);
  if (v15)
    return alg_quant(a2, a3, v52, v18, a5, v19);
  else
    return alg_unquant((uint64_t)a2, a3, v52, v18, a5, (uint64_t)v19, a8);
}

void interleave_hadamard(char *a1, int a2, int a3, int a4)
{
  int v8;
  size_t v9;
  char *v10;
  uint64_t v11;
  _WORD *v12;
  char *v13;
  uint64_t v14;
  _WORD *v15;
  __int16 v16;
  uint64_t v17;
  __int16 *v18;
  _WORD *v19;
  uint64_t v20;
  __int16 *v21;
  _WORD *v22;
  __int16 v23;
  _QWORD v24[2];

  v24[1] = *MEMORY[0x24BDAC8D0];
  v8 = a3 * a2;
  v9 = 2 * a3 * a2;
  v10 = (char *)v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v10, v9);
  if (a4)
  {
    if (a3 >= 1)
    {
      v11 = 0;
      v12 = v10;
      do
      {
        if (a2 >= 1)
        {
          v13 = &a1[2 * ordery_table[a3 - 2 + v11] * a2];
          v14 = a2;
          v15 = v12;
          do
          {
            v16 = *(_WORD *)v13;
            v13 += 2;
            *v15 = v16;
            v15 += a3;
            --v14;
          }
          while (v14);
        }
        ++v11;
        ++v12;
      }
      while (v11 != a3);
    }
  }
  else if (a3 >= 1)
  {
    v17 = 0;
    v18 = (__int16 *)a1;
    v19 = v10;
    do
    {
      if (a2 >= 1)
      {
        v20 = a2;
        v21 = v18;
        v22 = v19;
        do
        {
          v23 = *v21++;
          *v22 = v23;
          v22 += a3;
          --v20;
        }
        while (v20);
      }
      ++v17;
      ++v19;
      v18 += a2;
    }
    while (v17 != a3);
  }
  if (v8 >= 1)
    memcpy(a1, v10, 2 * v8);
}

uint64_t compute_theta(int *a1, uint64_t a2, __int16 *a3, __int16 *a4, int a5, int *a6, char a7, int a8, int a9, int a10, _DWORD *a11)
{
  int v11;
  __int16 *v12;
  __int16 *v13;
  uint64_t v15;
  int v16;
  _BOOL4 v17;
  _BOOL4 v18;
  BOOL v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v28;
  int v30;
  int v31;
  int v32;
  BOOL v33;
  int *v34;
  uint64_t v35;
  __int16 *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  __int16 v47;
  char v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  int *v55;
  int v56;
  int v57;
  int v58;
  _DWORD *v59;
  int v60;
  uint64_t result;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  int32x2_t v70;
  int v71;
  int v72;
  int32x2_t v73;
  int32x2_t v74;
  int32x2_t v75;
  int32x2_t v76;
  unsigned __int16 v77;
  int32x2_t v78;
  uint32x2_t v79;
  int v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v86;
  int v87;
  uint64_t *v89;

  v11 = a5;
  v12 = a4;
  v13 = a3;
  v15 = a1[4];
  v89 = (uint64_t *)*((_QWORD *)a1 + 4);
  v16 = *(__int16 *)(*(_QWORD *)(*((_QWORD *)a1 + 1) + 56) + 2 * v15) + 8 * a9;
  v17 = a10 != 0;
  v18 = a5 == 2;
  v19 = !v18 || !v17;
  if (v18 && v17)
    v20 = -16;
  else
    v20 = -4;
  v21 = v20 + (v16 >> 1);
  v22 = *a6;
  if (v19)
    v23 = -1;
  else
    v23 = -2;
  v24 = v22 - v16 - 32;
  v25 = (v22 + v21 * (v23 + 2 * a5)) / (v23 + 2 * a5);
  if (v24 >= v25)
    v24 = v25;
  if (v24 >= 64)
    v24 = 64;
  v83 = *((_QWORD *)a1 + 1);
  if (v24 >= 4)
    v28 = ((compute_qn_exp2_table8[v24 & 7] >> (14 - (v24 >> 3))) + 1) & 0xFFFFFFFE;
  else
    v28 = 1;
  v82 = *((_QWORD *)a1 + 6);
  v84 = a1[4];
  if ((int)v15 < a1[5] || a10 == 0)
    v30 = v28;
  else
    v30 = 1;
  v31 = *a1;
  if (*a1)
    v32 = stereo_itheta(a3, a4, a10, a5);
  else
    v32 = 0;
  v87 = ec_tell_frac((uint64_t)v89);
  if (v30 == 1)
  {
    if (a10)
    {
      if (v31)
      {
        v33 = v32 <= 0x2000;
        v32 = v32 > 0x2000;
        v34 = a6;
        if (!v33 && v11 >= 1)
        {
          v35 = v11;
          v36 = v12;
          do
          {
            *v36 = -*v36;
            ++v36;
            --v35;
          }
          while (v35);
        }
        intensity_stereo(v83, v13, v12, v82, v84, v11);
        v37 = v31;
      }
      else
      {
        v37 = 0;
        v32 = 0;
        v34 = a6;
      }
      v59 = a11;
      v60 = v87;
      if (*v34 < 17 || a1[10] < 17)
      {
        v32 = 0;
      }
      else if (v37)
      {
        ec_enc_bit_logp(v89, v32, 2);
      }
      else
      {
        v32 = ec_dec_bit_logp((uint64_t)v89, 2);
      }
      goto LABEL_67;
    }
    goto LABEL_59;
  }
  v38 = v32 * v30 + 0x2000;
  v39 = v38 >> 14;
  if (v11 > 2 && a10)
  {
    v80 = v11;
    v81 = a7;
    v86 = a2;
    if (v30 >= 0)
      v40 = v30;
    else
      v40 = v30 + 1;
    v41 = v40 >> 1;
    v42 = (v40 >> 1) + 1;
    v43 = 3 * v42;
    v44 = 3 * v42 + (v40 >> 1);
    if (v31)
    {
      if (v39 <= v41)
        v45 = 3 * v39;
      else
        v45 = v43 + ~v41 + v39;
      if (v39 <= v41)
        v46 = 3 * v39 + 3;
      else
        v46 = v43 - v41 + v39;
      ec_encode(v89, v45, v46, v44);
      a2 = v86;
      v11 = v80;
      a7 = v81;
      goto LABEL_53;
    }
    v63 = 3 * v42 + (v40 >> 1);
    v64 = ec_decode(v89, v44);
    if (v64 < v43)
      v39 = v64 / 3;
    else
      v39 = v64 - 2 * v42;
    if (v39 <= v41)
      v65 = 3 * v39;
    else
      v65 = v43 + ~v41 + v39;
    if (v39 <= v41)
      v66 = 3 * v39 + 3;
    else
      v66 = v43 - v41 + v39;
    ec_dec_update(v89, v65, v66, v63);
    a2 = v86;
    LOWORD(v11) = v80;
    a7 = v81;
LABEL_85:
    v55 = a6;
    v58 = v87;
    v32 = (v39 << 14) / v30;
    goto LABEL_86;
  }
  if (a8 < 2 && !a10)
  {
    v47 = v11;
    v48 = a7;
    v49 = a2;
    v50 = v30 >> 1;
    v11 = (v30 >> 1) + 1;
    v51 = v11 * v11;
    if (v31)
    {
      v52 = v30 - v39 + 1;
      if (v39 > v50)
      {
        v53 = v51 - ((v52 * (v30 - v39 + 2)) >> 1);
      }
      else
      {
        v52 = v39 + 1;
        v53 = ((v39 + 1) * v39) >> 1;
      }
      ec_encode(v89, v53, v53 + v52, v11 * v11);
      a2 = v49;
      a7 = v48;
      LOWORD(v11) = v47;
    }
    else
    {
      v67 = ec_decode(v89, v11 * v11);
      if (v67 >= (v11 * v50) >> 1)
      {
        v39 = (2 * (v30 + 1) - isqrt32((8 * (v51 + ~v67)) | 1u)) >> 1;
        v68 = v30 + 1 - v39;
        v69 = v51 - ((v68 * (v30 - v39 + 2)) >> 1);
      }
      else
      {
        v39 = (isqrt32((8 * v67) | 1u) - 1) >> 1;
        v68 = v39 + 1;
        v69 = ((v39 + 1) * v39) >> 1;
      }
      a7 = v48;
      LOWORD(v11) = v47;
      ec_dec_update(v89, v69, v69 + v68, v51);
      a2 = v49;
    }
    goto LABEL_85;
  }
  if (!v31)
  {
    v39 = ec_dec_uint((uint64_t)v89, v30 + 1);
    goto LABEL_85;
  }
  ec_enc_uint(v89, v38 >> 14, v30 + 1);
LABEL_53:
  v32 = (int)(v38 & 0xFFFFC000) / v30;
  if (a10)
  {
    if (!v32)
    {
      intensity_stereo(v83, v13, v12, v82, v84, v11);
      v34 = a6;
      v59 = a11;
      v60 = v87;
LABEL_67:
      result = ec_tell_frac((uint64_t)v89);
      v62 = result - v60;
      *v34 -= result - v60;
      goto LABEL_89;
    }
    if (v11 >= 1)
    {
      v54 = v11;
      v55 = a6;
      do
      {
        v56 = 46340 * *v13;
        v57 = (46340 * *v12) >> 16;
        *v13++ = ((46340 * *v12) >> 16) + HIWORD(v56);
        *v12++ = v57 - HIWORD(v56);
        --v54;
      }
      while (v54);
      goto LABEL_60;
    }
  }
LABEL_59:
  v55 = a6;
LABEL_60:
  v58 = v87;
LABEL_86:
  result = ec_tell_frac((uint64_t)v89);
  v62 = result - v58;
  *v55 -= result - v58;
  if (v32 == 0x4000)
  {
    v72 = 0;
    *a11 &= ~(-1 << a7) << a7;
    v70 = (int32x2_t)0x7FFF00000000;
    v71 = 0x4000;
    goto LABEL_92;
  }
  if (v32)
  {
    v72 = 0;
    v73.i32[0] = v32 << 16;
    v73.i32[1] = 0x40000000 - (v32 << 16);
    v74 = vshr_n_s32(vmla_s32((int32x2_t)0x800000008000, vshl_s32(v73, (int32x2_t)0xFFFFFFF3FFFFFFF0), vshl_s32(v73, (int32x2_t)0xFFFFFFF0FFFFFFF3)), 0x10uLL);
    v75 = vmul_s32(v74, (int32x2_t)(*(_QWORD *)&vsra_n_u32((uint32x2_t)vdup_n_s32(0x2055u), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, v74, vdup_n_s32(0x7FFFFD8Eu)), 0xFuLL) & 0xFFFCFFFFFFFCFFFFLL));
    v70 = (int32x2_t)veor_s8((int8x8_t)vshr_n_s32(vshl_n_s32(vsub_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vshr_n_s32(vadd_s32(vadd_s32(v75, v75), vdup_n_s32(0xE21D8000)), 0x10uLL), v74), 0xFuLL), v74), 0x10uLL), 0x10uLL), (int8x8_t)0x7F0000007FLL);
    v76 = vclz_s32(v70);
    v77 = vsub_s32(v76, vdup_lane_s32(v76, 1)).u16[0];
    v78 = vshr_n_s32(vshl_n_s32((int32x2_t)vshl_u32((uint32x2_t)v70, (uint32x2_t)vadd_s32(v76, (int32x2_t)0x1000000010)), 0x10uLL), 0x10uLL);
    v79 = vshr_n_u32((uint32x2_t)vmla_s32((int32x2_t)0x400000004000, (int32x2_t)(*(_QWORD *)&vsra_n_u32((uint32x2_t)vdup_n_s32(0x1EFCu), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, v78, vdup_n_s32(0x7FFFF5DBu)), 0xFuLL) & 0xFFFCFFFFFFFCFFFFLL), v78), 0xFuLL);
    v71 = ((__int16)(v79.i16[2] - v79.i16[0] + (v77 << 11)) * (__int16)(((_WORD)v11 << 7) - 128) + 0x4000) >> 15;
    goto LABEL_92;
  }
  v59 = a11;
LABEL_89:
  *v59 &= ~(-1 << a7);
  v70 = (int32x2_t)0x7FFFLL;
  v71 = -16384;
  v72 = v32;
  v32 = 0;
LABEL_92:
  *(_DWORD *)a2 = v72;
  *(int32x2_t *)(a2 + 4) = v70;
  *(_DWORD *)(a2 + 12) = v71;
  *(_DWORD *)(a2 + 16) = v32;
  *(_DWORD *)(a2 + 20) = v62;
  return result;
}

uint64_t intensity_stereo(uint64_t a1, __int16 *a2, __int16 *a3, uint64_t a4, int a5, int a6)
{
  int v9;
  int v10;
  signed int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t result;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;

  v9 = *(_DWORD *)(a4 + 4 * a5);
  v10 = *(_DWORD *)(a4 + 4 * (*(_DWORD *)(a1 + 8) + a5));
  if (v9 <= v10)
    v11 = *(_DWORD *)(a4 + 4 * (*(_DWORD *)(a1 + 8) + a5));
  else
    v11 = *(_DWORD *)(a4 + 4 * a5);
  v12 = 31 - __clz(v11);
  if (v11 >= 1)
    v13 = v12;
  else
    v13 = 0;
  v14 = v9 << (13 - v13);
  v15 = v10 << (13 - v13);
  v16 = v9 >> (v13 - 13);
  v17 = v10 >> (v13 - 13);
  if (v13 >= 0xE)
    v18 = v16;
  else
    v18 = v14;
  if (v13 >= 0xE)
    v19 = v17;
  else
    v19 = v15;
  result = celt_sqrt(((__int16)v19 * (__int16)v19 + (__int16)v18 * (__int16)v18 + 1));
  if (a6 >= 1)
  {
    v21 = (__int16)(result + 1);
    v22 = (__int16)((v18 << 16 >> 2) / v21);
    v23 = (__int16)((v19 << 16 >> 2) / v21);
    v24 = a6;
    do
    {
      v25 = *a3++;
      *a2 = ((v23 * v25) >> 14) + ((v22 * *a2) >> 14);
      ++a2;
      --v24;
    }
    while (v24);
  }
  return result;
}

uint64_t resampling_factor(int a1)
{
  if (a1 <= 15999)
  {
    if (a1 == 8000)
      return 6;
    if (a1 == 12000)
      return 4;
  }
  else
  {
    switch(a1)
    {
      case 16000:
        return 3;
      case 48000:
        return 1;
      case 24000:
        return 2;
    }
  }
  return 0;
}

char *comb_filter(char *result, char *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 *a10, int a11)
{
  uint64_t v11;
  __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  __int16 *v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  int *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  uint64_t v53;
  char *v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  char *v60;
  int v61;
  int v62;
  size_t v63;
  __int16 v64;
  __int16 v65;
  __int16 v66;
  int v68;
  unsigned int v69;

  if (!(a7 | a6))
  {
    if (a2 == result)
      return result;
    v63 = 4 * a5;
    return (char *)memmove(result, a2, v63);
  }
  v11 = a11;
  v12 = (__int16 *)((char *)&comb_filter_gains + 6 * a9);
  v13 = (*v12 * a7) >> 15;
  v14 = (v12[1] * a7) >> 15;
  v15 = (v12[2] * a7) >> 15;
  v16 = 1 - a4;
  v17 = -a4;
  v18 = ~a4;
  v19 = -2 - a4;
  if (a11 < 1)
  {
    v52 = 0;
    if (a7)
      goto LABEL_6;
    goto LABEL_13;
  }
  v68 = a5;
  v20 = *(_DWORD *)&a2[4 * v19];
  v21 = *(_DWORD *)&a2[4 * v18];
  v22 = *(_DWORD *)&a2[4 * v17];
  v23 = *(_DWORD *)&a2[4 * v16];
  v24 = (__int16 *)((char *)&comb_filter_gains + 6 * a8);
  v69 = ((2 * a6 * *v24) >> 15) & 0xFFFFFFFE;
  v25 = ((2 * a6 * v24[1]) >> 15) & 0xFFFFFFFE;
  v26 = ((2 * a6 * v24[2]) >> 15) & 0xFFFFFFFE;
  v65 = v14;
  v66 = v13;
  v27 = 2 * (__int16)v13;
  v28 = 2 * (__int16)v14;
  v64 = v15;
  v30 = 2 * (__int16)v15;
  v31 = 2 - a4;
  v32 = 0x3FFFFFFFFFFFFFFFLL * a3;
  v33 = result;
  v34 = (int *)a2;
  do
  {
    v35 = *(_DWORD *)&a2[4 * v31];
    v36 = *a10++;
    v37 = (__int16)((v36 * v36) >> 15);
    v38 = (int)((2 * v36 * v36) & 0xFFFF0000 ^ 0x7FFF0000) >> 16;
    v39 = (v27 * v37) >> 16;
    v40 = (v28 * v37) >> 16;
    v41 = (int)(v69 * v38) >> 16;
    v42 = (v30 * v37) >> 16;
    v43 = v35 + v20;
    v44 = v41 * (unsigned __int16)v34[v32];
    v45 = (int)(v25 * v38) >> 16;
    v46 = v39 * (v22 >> 16)
        + v40 * ((v21 + v23) >> 16)
        + v42 * (v43 >> 16)
        + v41 * (v34[v32] >> 16)
        + v45 * ((v34[v32 - 1] + v34[v32 + 1]) >> 16);
    v47 = v45 * (unsigned __int16)(LOWORD(v34[v32 - 1]) + LOWORD(v34[v32 + 1]));
    v48 = (int)(v26 * v38) >> 16;
    v49 = v46 + v48 * ((v34[v32 - 2] + v34[v32 + 2]) >> 16);
    v50 = v48 * (unsigned __int16)(LOWORD(v34[v32 - 2]) + LOWORD(v34[v32 + 2]));
    v51 = *v34++;
    *(_DWORD *)v33 = v51
                   + ((v42 * (unsigned __int16)v43) >> 15)
                   + ((v40 * (unsigned __int16)(v21 + v23)) >> 15)
                   + ((v39 * (unsigned __int16)v22) >> 15)
                   + (v50 >> 15)
                   + (v47 >> 15)
                   + (v44 >> 15)
                   + 2 * v49;
    v33 += 4;
    ++v31;
    v20 = v21;
    v21 = v22;
    v22 = v23;
    v23 = v35;
    --v11;
  }
  while (v11);
  LODWORD(v11) = a11;
  v52 = a11;
  a5 = v68;
  LOWORD(v14) = v65;
  LOWORD(v13) = v66;
  LOWORD(v15) = v64;
  v17 = -a4;
  v16 = 1 - a4;
  v19 = -2 - a4;
  v18 = ~a4;
  if (!a7)
  {
LABEL_13:
    if (a2 == result)
      return result;
    result += 4 * (int)v11;
    a2 += 4 * (int)v11;
    v63 = 4 * (a5 - (int)v11);
    return (char *)memmove(result, a2, v63);
  }
LABEL_6:
  v53 = a5 - v52;
  if ((int)v53 >= 1)
  {
    v54 = &a2[4 * v52];
    v55 = *(_DWORD *)&v54[4 * v16];
    v56 = *(_DWORD *)&v54[4 * v17];
    v57 = *(_DWORD *)&v54[4 * v18];
    v58 = *(_DWORD *)&v54[4 * v19];
    v59 = 2 - a4;
    v60 = v54;
    result += 4 * v52;
    do
    {
      v61 = *(_DWORD *)&v54[4 * v59];
      v62 = *(_DWORD *)v60;
      v60 += 4;
      *(_DWORD *)result = v62
                        + (((unsigned __int16)v56 * (__int16)v13) >> 15)
                        + (((unsigned __int16)(v55 + v57) * (__int16)v14) >> 15)
                        + (((unsigned __int16)(v61 + v58) * (__int16)v15) >> 15)
                        + 2
                        * ((v56 >> 16) * (__int16)v13
                         + ((v55 + v57) >> 16) * (__int16)v14
                         + ((v61 + v58) >> 16) * (__int16)v15);
      result += 4;
      ++v59;
      v58 = v57;
      v57 = v56;
      v56 = v55;
      v55 = v61;
      --v53;
    }
    while (v53);
  }
  return result;
}

uint64_t init_caps(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;
  _WORD *v8;
  __int16 v9;
  __int16 v10;
  int v11;

  LODWORD(v4) = *(_DWORD *)(result + 8);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = *(__int16 **)(result + 24);
    v7 = *(_QWORD *)(result + 144);
    v10 = *v6;
    v8 = v6 + 1;
    v9 = v10;
    do
    {
      v11 = (__int16)v8[v5];
      *(_DWORD *)(a2 + 4 * v5) = (((v11 - v9) << a3)
                                * a4
                                * (*(unsigned __int8 *)(v7 + (int)v4 * (a4 + 2 * a3 - 1) + v5) + 64)) >> 2;
      v9 = v11;
      v4 = *(int *)(result + 8);
      ++v5;
    }
    while (v5 < v4);
  }
  return result;
}

const char *opus_strerror(int a1)
{
  if ((a1 - 1) >= 0xFFFFFFF8)
    return opus_strerror_error_strings[-a1];
  else
    return "unknown error";
}

const char *opus_get_version_string()
{
  return "libopus 1.1-fixed";
}

void silk_decode_parameters(uint64_t a1, uint64_t a2, int a3)
{
  int v5;
  int v6;
  __int16 *v7;
  __int16 *v8;
  __int16 *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  __int16 v22[16];
  __int16 __src[16];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  silk_gains_dequant(a2 + 16, (char *)(a1 + 2760), (_BYTE *)(a1 + 2312), a3 == 2, *(_DWORD *)(a1 + 2324));
  silk_NLSF_decode(__src, (char *)(a1 + 2768), *(_QWORD *)(a1 + 2752));
  silk_NLSF2A((__int16 *)(a2 + 64), __src, *(_DWORD *)(a1 + 2340));
  if (*(_DWORD *)(a1 + 2376) == 1)
  {
    *(_BYTE *)(a1 + 2791) = 4;
LABEL_8:
    memcpy((void *)(a2 + 32), (const void *)(a2 + 64), 2 * *(int *)(a1 + 2340));
    goto LABEL_9;
  }
  v5 = *(char *)(a1 + 2791);
  if (v5 > 3)
    goto LABEL_8;
  v6 = *(_DWORD *)(a1 + 2340);
  if (v6 >= 1)
  {
    v7 = (__int16 *)(a1 + 2344);
    v8 = v22;
    v9 = __src;
    v10 = *(unsigned int *)(a1 + 2340);
    do
    {
      v12 = *v7++;
      v11 = v12;
      v13 = *v9++;
      *v8++ = v11 + (((v13 - v11) * v5) >> 2);
      --v10;
    }
    while (v10);
  }
  silk_NLSF2A((__int16 *)(a2 + 32), v22, v6);
LABEL_9:
  v14 = *(int *)(a1 + 2340);
  memcpy((void *)(a1 + 2344), __src, 2 * v14);
  if (*(_DWORD *)(a1 + 4184))
  {
    silk_bwexpander((__int16 *)(a2 + 32), v14, 63570);
    silk_bwexpander((__int16 *)(a2 + 64), *(_DWORD *)(a1 + 2340), 63570);
  }
  if (*(_BYTE *)(a1 + 2789) == 2)
  {
    silk_decode_pitch(*(__int16 *)(a1 + 2786), *(char *)(a1 + 2788), (int *)a2, *(_DWORD *)(a1 + 2316), *(_DWORD *)(a1 + 2324));
    v15 = *(unsigned int *)(a1 + 2324);
    if ((int)v15 >= 1)
    {
      v16 = 0;
      v17 = (uint64_t)*(&silk_LTP_vq_ptrs_Q7 + *(char *)(a1 + 2792));
      v18 = a2 + 96;
      do
      {
        v19 = 0;
        v20 = v17 + 5 * *(char *)(a1 + v16 + 2764);
        do
        {
          *(_WORD *)(v18 + 2 * v19) = *(char *)(v20 + v19) << 7;
          ++v19;
        }
        while (v19 != 5);
        ++v16;
        v18 += 10;
      }
      while (v16 != v15);
    }
    v21 = silk_LTPScales_table_Q14[*(char *)(a1 + 2793)];
  }
  else
  {
    bzero((void *)a2, 4 * *(int *)(a1 + 2324));
    bzero((void *)(a2 + 96), 10 * *(int *)(a1 + 2324));
    v21 = 0;
    *(_BYTE *)(a1 + 2792) = 0;
  }
  *(_DWORD *)(a2 + 136) = v21;
}

uint64_t silk_gains_quant(uint64_t result, uint64_t a2, _BYTE *a3, int a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  char v18;
  int v19;

  if (a5 >= 1)
  {
    v8 = result;
    v9 = 0;
    v10 = a5;
    do
    {
      silk_lin2log(*(_DWORD *)(a2 + 4 * v9));
      v11 = silk_lin2log(*(_DWORD *)(a2 + 4 * v9));
      v12 = (2251 * (__int16)(v11 - 2090)) >> 16;
      *(_BYTE *)(v8 + v9) = (2251 * (__int16)(v11 - 2090)) >> 16;
      if ((char)*a3 > (char)((2251 * (__int16)(v11 - 2090)) >> 16))
        LOBYTE(v12) = v12 + 1;
      v13 = (char)v12 & ~((char)v12 >> 31);
      if (v13 >= 63)
        LOBYTE(v13) = 63;
      *(_BYTE *)(v8 + v9) = v13;
      v14 = (char)*a3;
      if (v9 | a4)
      {
        LOBYTE(v14) = v13 - v14;
        *(_BYTE *)(v8 + v9) = v14;
        v15 = (char)*a3;
        v16 = v15 + 8;
        v17 = v15 + 8 + (((char)v14 - v15 + 505) >> 1);
        if (v16 < (char)v14)
          LOBYTE(v14) = v17;
        v14 = (char)v14;
        if ((char)v14 <= -4)
          v14 = -4;
        if (v14 >= 36)
          v14 = 36;
        *(_BYTE *)(v8 + v9) = v14;
        if (v16 >= v14)
          v18 = *a3 + v14;
        else
          v18 = *a3 - v16 + 2 * v14;
        *a3 = v18;
        *(_BYTE *)(v8 + v9) += 4;
        LOBYTE(v13) = *a3;
      }
      else
      {
        if (v14 - 4 > v13)
          LOBYTE(v13) = v14 - 4;
        if (v14 > 67)
          LOBYTE(v13) = 63;
        *(_BYTE *)(v8 + v9) = v13;
        *a3 = v13;
      }
      v19 = 29 * (char)v13 + ((7281 * (char)v13) >> 16);
      if (v19 >= 1877)
        v19 = 1877;
      result = silk_log2lin(v19 + 2090);
      *(_DWORD *)(a2 + 4 * v9++) = result;
    }
    while (v10 != v9);
  }
  return result;
}

uint64_t silk_gains_dequant(uint64_t result, char *a2, _BYTE *a3, int a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if (a5 >= 1)
  {
    v8 = result;
    v9 = 0;
    v10 = a5;
    do
    {
      if (v9 | a4)
      {
        v11 = a2[v9] - 4;
        if (v11 > (char)*a3 + 8)
          LOBYTE(v11) = 2 * v11 - 8;
        else
          LOBYTE(v11) = *a3 + v11;
      }
      else
      {
        v11 = *a2;
        if (v11 <= (char)*a3 - 16)
          LOBYTE(v11) = *a3 - 16;
      }
      v12 = (char)v11 & ~((char)v11 >> 31);
      if (v12 >= 63)
        v12 = 63;
      *a3 = v12;
      result = silk_log2lin(29 * v12 + ((7281 * v12) >> 16) + 2090);
      *(_DWORD *)(v8 + 4 * v9++) = result;
    }
    while (v10 != v9);
  }
  return result;
}

unint64_t silk_gains_ID(unint64_t result, int a2)
{
  char *v2;
  uint64_t v3;
  int v4;

  if (a2 < 1)
    return 0;
  v2 = (char *)result;
  LODWORD(result) = 0;
  v3 = a2;
  do
  {
    v4 = *v2++;
    result = (v4 + ((_DWORD)result << 8));
    --v3;
  }
  while (v3);
  return result;
}

_BYTE *silk_VQ_WMat_EC(_BYTE *result, int *a2, _DWORD *a3, _WORD *a4, int *a5, char *a6, uint64_t a7, uint64_t a8, __int16 a9, int a10, int a11)
{
  uint64_t i;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;

  *a2 = 0x7FFFFFFF;
  if (a11 >= 1)
  {
    for (i = 0; i != a11; ++i)
    {
      v12 = *(unsigned __int8 *)(a7 + i);
      v13 = (v12 - a10) & ~((v12 - a10) >> 31);
      v14 = (__int16)(a4[1] - (a6[1] << 7));
      v15 = (a5[1] >> 16) * v14;
      v16 = (__int16)(a4[2] - (a6[2] << 7));
      v17 = (__int16)(a4[3] - (a6[3] << 7));
      v18 = (__int16)(a4[4] - (a6[4] << 7));
      v19 = (__int16)(*a4 - (*a6 << 7));
      v20 = ((*a5 >> 16) * v19
           + (((unsigned __int16)*a5 * v19) >> 16)
           + 2
           * (v15
            + (((unsigned __int16)a5[1] * v14) >> 16)
            + (a5[2] >> 16) * v16
            + (((unsigned __int16)a5[2] * v16) >> 16)
            + (a5[3] >> 16) * v17
            + (((unsigned __int16)a5[3] * v17) >> 16)
            + (a5[4] >> 16) * v18
            + (((unsigned __int16)a5[4] * v18) >> 16))) >> 16;
      v21 = (unsigned __int16)(HIWORD(*a5) * v19
                             + (((unsigned __int16)*a5 * v19) >> 16)
                             + 2
                             * (v15
                              + (((unsigned __int16)a5[1] * v14) >> 16)
                              + HIWORD(a5[2]) * v16
                              + (((unsigned __int16)a5[2] * v16) >> 16)
                              + HIWORD(a5[3]) * v17
                              + (((unsigned __int16)a5[3] * v17) >> 16)
                              + HIWORD(a5[4]) * v18
                              + (((unsigned __int16)a5[4] * v18) >> 16)))
          * v19;
      v22 = ((a5[6] >> 16) * v14
           + (((unsigned __int16)a5[6] * v14) >> 16)
           + 2
           * ((a5[7] >> 16) * v16
            + (((unsigned __int16)a5[7] * v16) >> 16)
            + (a5[8] >> 16) * v17
            + (((unsigned __int16)a5[8] * v17) >> 16)
            + (a5[9] >> 16) * v18
            + (((unsigned __int16)a5[9] * v18) >> 16))) >> 16;
      v23 = ((a5[12] >> 16) * v16
           + (((unsigned __int16)a5[12] * v16) >> 16)
           + 2
           * ((a5[13] >> 16) * v17
            + (((unsigned __int16)a5[13] * v17) >> 16)
            + (a5[14] >> 16) * v18
            + (((unsigned __int16)a5[14] * v18) >> 16))) >> 16;
      v24 = (unsigned __int16)(HIWORD(a5[12]) * v16
                             + (((unsigned __int16)a5[12] * v16) >> 16)
                             + 2
                             * (HIWORD(a5[13]) * v17
                              + (((unsigned __int16)a5[13] * v17) >> 16)
                              + HIWORD(a5[14]) * v18
                              + (((unsigned __int16)a5[14] * v18) >> 16)))
          * v16;
      v25 = ((a5[18] >> 16) * v17
           + (((unsigned __int16)a5[18] * v17) >> 16)
           + 2 * ((a5[19] >> 16) * v18 + (((unsigned __int16)a5[19] * v18) >> 16))) >> 16;
      v26 = a9 * *(unsigned __int8 *)(a8 + i)
          + (v13 << 10)
          + v20 * v19
          + (v21 >> 16)
          + v22 * v14
          + (((unsigned __int16)(HIWORD(a5[6]) * v14
                               + (((unsigned __int16)a5[6] * v14) >> 16)
                               + 2
                               * (HIWORD(a5[7]) * v16
                                + (((unsigned __int16)a5[7] * v16) >> 16)
                                + HIWORD(a5[8]) * v17
                                + (((unsigned __int16)a5[8] * v17) >> 16)
                                + HIWORD(a5[9]) * v18
                                + (((unsigned __int16)a5[9] * v18) >> 16)))
            * v14) >> 16)
          + v23 * v16
          + (v24 >> 16)
          + (((a5[24] >> 16) * v18 + (((unsigned __int16)a5[24] * v18) >> 16)) >> 16) * v18
          + v25 * v17
          + (((unsigned __int16)(HIWORD(a5[24]) * v18 + (((unsigned __int16)a5[24] * v18) >> 16)) * v18) >> 16)
          + (((unsigned __int16)(HIWORD(a5[18]) * v17
                               + (((unsigned __int16)a5[18] * v17) >> 16)
                               + 2 * (HIWORD(a5[19]) * v18 + (((unsigned __int16)a5[19] * v18) >> 16)))
            * v17) >> 16);
      if (v26 < *a2)
      {
        *a2 = v26;
        *result = i;
        *a3 = v12;
      }
      a6 += 5;
    }
  }
  return result;
}

uint64_t silk_init_encoder(_DWORD *a1, int a2)
{
  unsigned int v4;

  bzero(a1, 0x2648uLL);
  a1[1285] = a2;
  v4 = (silk_lin2log(0x3C0000u) << 8) - 0x80000;
  a1[2] = v4;
  a1[3] = v4;
  a1[1174] = 1;
  return silk_VAD_Init((uint64_t)(a1 + 8));
}

uint64_t silk_NLSF_encode(char *a1, __int16 *a2, __int16 *a3, __int16 *a4, int a5, uint64_t a6, int a7)
{
  int v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  char *v16;
  int v17;
  size_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 *v24;
  uint64_t v25;
  char *v26;
  __int16 *v27;
  __int16 *v28;
  __int16 v29;
  __int16 v30;
  __int16 v31;
  uint64_t v32;
  _WORD *v33;
  char *v34;
  __int16 *v35;
  uint64_t v36;
  unsigned __int16 v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  _WORD *v45;
  __int16 *v46;
  __int16 *v47;
  int v48;
  int v49;
  int v50;
  int v51;
  unsigned __int8 *v52;
  int v53;
  unsigned int *v54;
  uint64_t v55;
  char *v56;
  char *v57;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  __int16 *v62;
  __int16 *v63;
  int v64;
  int v65;
  int v66;
  unsigned int *v67;
  char *v68;
  int v69;
  _BYTE v70[32];
  _BYTE v71[16];
  _BYTE v72[32];
  _WORD v73[16];
  __int16 v74[16];
  _BYTE v75[32];
  char v76;
  uint64_t v77;

  v66 = a5;
  v62 = a4;
  v60 = a1;
  v77 = *MEMORY[0x24BDAC8D0];
  v69 = 0;
  silk_NLSF_stabilize(a2, *((__int16 **)a3 + 7), a3[1]);
  v11 = *a3;
  v12 = 4 * *a3;
  v13 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  v14 = *((_QWORD *)a3 + 1);
  v15 = a3[1];
  v63 = a2;
  silk_NLSF_VQ((uint64_t)v13, (uint64_t)a2, v14, v11, v15);
  v16 = (char *)&v59 - ((4 * (int)a6 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v16, 4 * (int)a6);
  v17 = *a3;
  v68 = v16;
  silk_insertion_sort_increasing((uint64_t)v13, (uint64_t)v16, v17, a6);
  v67 = (unsigned int *)v16;
  bzero(v16, 4 * (int)a6);
  v18 = 16 * (int)a6;
  v19 = (char *)&v59 - v18;
  bzero((char *)&v59 - v18, v18);
  v61 = a6;
  if ((int)a6 >= 1)
  {
    v20 = 0;
    v65 = a7 >> 1;
    v64 = (__int16)(v66 >> 2);
    v21 = v61;
    do
    {
      v22 = *(int *)&v68[4 * v20];
      v23 = a3[1];
      if (v23 >= 1)
      {
        v24 = (unsigned __int8 *)(*((_QWORD *)a3 + 1) + (int)v22 * (uint64_t)a3[1]);
        v25 = v23;
        v26 = &v76;
        v27 = v74;
        v28 = v63;
        do
        {
          v30 = *v24++;
          v29 = v30;
          *v27++ = v30 << 7;
          v31 = *v28++;
          *(_WORD *)v26 = v31 - (v29 << 7);
          v26 += 2;
          --v25;
        }
        while (v25);
      }
      silk_NLSF_VQ_weights_laroia(v73, v74, v23);
      v32 = a3[1];
      if (v32 >= 1)
      {
        v32 = v32;
        v33 = v75;
        v34 = &v76;
        v35 = v73;
        v36 = v32;
        do
        {
          v38 = *v35++;
          v37 = v38;
          if (v38 < 1)
          {
            LOWORD(v43) = 0;
          }
          else
          {
            v39 = v37 << 16;
            v40 = __clz(v39);
            v41 = (v39 >> (24 - v40)) & 0x7F;
            if ((v40 & 1) != 0)
              v42 = 0x8000;
            else
              v42 = 46214;
            v43 = (v42 >> (v40 >> 1)) + ((213 * (v42 >> (v40 >> 1)) * v41) >> 16);
          }
          v44 = *(__int16 *)v34;
          v34 += 2;
          *v33++ = ((__int16)v43 * v44) >> 14;
          --v36;
        }
        while (v36);
        v45 = v72;
        v46 = v73;
        v47 = v62;
        do
        {
          v48 = *v47++;
          v49 = 32 * v48;
          v50 = *v46++;
          *v45++ = v49 / v50;
          --v32;
        }
        while (v32);
      }
      silk_NLSF_unpack((uint64_t)v70, (uint64_t)v71, (uint64_t)a3, v22);
      v51 = silk_NLSF_del_dec_quant(&v19[(16 * v20)], (uint64_t)v75, (uint64_t)v72, (uint64_t)v71, (uint64_t)v70, *((_QWORD *)a3 + 6), a3[2], a3[3], v66, SHIWORD(v66), a3[1]);
      v52 = (unsigned __int8 *)(*((_QWORD *)a3 + 2) + *a3 * (uint64_t)v65);
      if ((_DWORD)v22)
      {
        v52 += v22;
        v53 = *(v52 - 1);
      }
      else
      {
        v53 = 256;
      }
      v67[v20++] = v51 + (__int16)(1024 - silk_lin2log(v53 - *v52)) * v64;
    }
    while (v20 != v21);
  }
  v54 = v67;
  silk_insertion_sort_increasing((uint64_t)v67, (uint64_t)&v69, v61, 1);
  v55 = v69;
  v56 = v60;
  v57 = v60;
  *v60 = *(_DWORD *)&v68[4 * v69];
  memcpy(v57 + 1, &v19[16 * v55], a3[1]);
  silk_NLSF_decode(v63, v56, (uint64_t)a3);
  return *v54;
}

uint64_t check_control_input(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  BOOL v3;
  int v4;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v10;
  int v11;

  v1 = a1[2];
  v2 = 4294967194;
  if (v1 <= 23999)
  {
    v3 = v1 == 8000 || v1 == 12000;
    v4 = 16000;
  }
  else if (v1 > 44099)
  {
    v3 = v1 == 48000;
    v4 = 44100;
  }
  else
  {
    v3 = v1 == 24000;
    v4 = 32000;
  }
  if (v3 || v1 == v4)
  {
    v6 = a1[5];
    if ((v6 == 8000 || v6 == 16000 || v6 == 12000)
      && ((v7 = a1[3], v7 == 8000) || v7 == 16000 || v7 == 12000)
      && ((v8 = a1[4], v8 == 8000) || v8 == 16000 || v8 == 12000)
      && v8 <= v6)
    {
      v2 = 4294967194;
      if (v7 >= v6 && v8 <= v7)
      {
        v10 = a1[6];
        v2 = 4294967193;
        if (v10 <= 0x3C && ((1 << v10) & 0x1000010000100400) != 0)
        {
          if (a1[8] <= 0x64u)
          {
            if (a1[11] <= 1u)
            {
              if (a1[12] <= 1u)
              {
                if (a1[10] <= 1u)
                {
                  if ((*a1 - 3) >= 0xFFFFFFFE)
                  {
                    v11 = a1[1];
                    v2 = 4294967185;
                    if (v11 <= *a1 && (v11 - 3) >= 0xFFFFFFFE)
                    {
                      if (a1[9] <= 0xAu)
                        return 0;
                      else
                        return 4294967190;
                    }
                  }
                  else
                  {
                    return 4294967185;
                  }
                }
                else
                {
                  return 4294967189;
                }
              }
              else
              {
                return 4294967187;
              }
            }
            else
            {
              return 4294967188;
            }
          }
          else
          {
            return 4294967191;
          }
        }
      }
    }
    else
    {
      return 4294967194;
    }
  }
  return v2;
}

uint64_t silk_control_audio_bandwidth(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int v4;
  int v5;
  int v6;
  BOOL v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;

  result = *(unsigned int *)(a1 + 4600);
  if (!((_DWORD)result << 16))
  {
    v10 = *(_DWORD *)(a1 + 4596);
    v9 = *(_DWORD *)(a1 + 4580);
    if (v10 < v9)
      v9 = v10;
    return (v9 / 1000);
  }
  v4 = 1000 * (__int16)result;
  v5 = *(_DWORD *)(a1 + 4580);
  v6 = *(_DWORD *)(a1 + 4588);
  v7 = v4 <= v5 && v4 <= v6;
  if (!v7 || v4 < *(_DWORD *)(a1 + 4592))
  {
    if (v5 >= v6)
      v8 = *(_DWORD *)(a1 + 4588);
    else
      v8 = *(_DWORD *)(a1 + 4580);
    v9 = *(_DWORD *)(a1 + 4592);
    if (v8 > v9)
      v9 = v8;
    return (v9 / 1000);
  }
  v11 = *(_DWORD *)(a1 + 24);
  if (v11 >= 256)
    *(_DWORD *)(a1 + 28) = 0;
  if (*(_DWORD *)(a1 + 4560) || a2[15])
  {
    v12 = *(_DWORD *)(a1 + 4596);
    if (v4 <= v12)
    {
      if (v4 >= v12)
      {
        if ((*(_DWORD *)(a1 + 28) & 0x80000000) == 0)
          return result;
      }
      else
      {
        if (a2[15])
        {
          if ((_DWORD)result == 8)
            result = 12;
          else
            result = 16;
          *(_QWORD *)(a1 + 16) = 0;
          *(_QWORD *)(a1 + 24) = 0x100000000;
          return result;
        }
        if (!*(_DWORD *)(a1 + 28))
        {
LABEL_43:
          a2[21] = 1;
          a2[13] -= 5 * a2[13] / (a2[6] + 5);
          return result;
        }
      }
      v13 = 1;
      goto LABEL_41;
    }
    if (*(_DWORD *)(a1 + 28))
    {
      if (!a2[15])
      {
        if (v11 <= 0)
          goto LABEL_43;
        goto LABEL_38;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 24) = 256;
      *(_QWORD *)(a1 + 16) = 0;
      if (!a2[15])
      {
LABEL_38:
        v13 = -2;
LABEL_41:
        *(_DWORD *)(a1 + 28) = v13;
        return result;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    if ((_DWORD)result == 16)
      return 12;
    else
      return 8;
  }
  return result;
}

_WORD *silk_interpolate(_WORD *result, __int16 *a2, __int16 *a3, __int16 a4, int a5)
{
  uint64_t v5;
  __int16 v6;
  __int16 v7;
  __int16 v8;

  if (a5 >= 1)
  {
    v5 = a5;
    do
    {
      v7 = *a2++;
      v6 = v7;
      v8 = *a3++;
      *result++ = v6 + ((a4 * (__int16)(v8 - v6)) >> 2);
      --v5;
    }
    while (v5);
  }
  return result;
}

__int16 *silk_NLSF_decode(__int16 *a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  signed int v23;
  int v24;
  int v25;
  _WORD v27[32];
  _BYTE v28[32];
  _BYTE v29[16];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*(__int16 *)(a3 + 2) < 1)
  {
    v8 = *a2;
  }
  else
  {
    v6 = 0;
    v7 = *(_QWORD *)(a3 + 8) + *(__int16 *)(a3 + 2) * (uint64_t)*a2;
    do
    {
      a1[v6] = *(unsigned __int8 *)(v7 + v6) << 7;
      ++v6;
    }
    while (v6 < *(__int16 *)(a3 + 2));
    v8 = *a2;
  }
  silk_NLSF_unpack((uint64_t)v28, (uint64_t)v29, a3, v8);
  v9 = *(unsigned __int16 *)(a3 + 2);
  if (*(__int16 *)(a3 + 2) >= 1)
  {
    LOWORD(v10) = 0;
    v11 = *(__int16 *)(a3 + 4);
    v12 = v9 + 1;
    do
    {
      v13 = a2[(v12 - 2) + 1];
      v14 = (__int16)v10 * v29[(v12 - 2)];
      v15 = (v13 << 10) - 102;
      if (v13 <= 0)
        v15 = ((v13 << 10) | 0x66) & (v13 >> 31);
      v10 = (v15 >> 16) * v11 + (v14 >> 8) + (((v15 & 0xFFFE) * v11) >> 16);
      v27[(v12-- - 2) + 16] = v10;
    }
    while (v12 > 1);
  }
  silk_NLSF_VQ_weights_laroia(v27, a1, (__int16)v9);
  v16 = *(__int16 *)(a3 + 2);
  if (v16 >= 1)
  {
    v17 = 0;
    do
    {
      v18 = (__int16)v27[v17];
      if (v18 < 1)
      {
        v23 = 0;
      }
      else
      {
        v19 = (unsigned __int16)v18 << 16;
        v20 = __clz(v19);
        v21 = (v19 >> (24 - v20)) & 0x7F;
        if ((v20 & 1) != 0)
          v22 = 0x8000;
        else
          v22 = 46214;
        v23 = (v22 >> (v20 >> 1)) + ((213 * (v22 >> (v20 >> 1)) * v21) >> 16);
      }
      v24 = (__int16)v27[v17 + 16] << 14;
      v25 = (v24 / v23 + a1[v17]) & ~((v24 / v23 + a1[v17]) >> 31);
      if (v25 >= 0x7FFF)
        LOWORD(v25) = 0x7FFF;
      a1[v17++] = v25;
    }
    while (v17 < *(__int16 *)(a3 + 2));
    LOWORD(v16) = *(_WORD *)(a3 + 2);
  }
  return silk_NLSF_stabilize(a1, *(__int16 **)(a3 + 56), (__int16)v16);
}

uint64_t silk_control_encoder(uint64_t a1, uint64_t a2, signed int a3, int a4, int a5, int a6)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  void *v19;
  int v20;
  uint64_t result;
  void *v22;
  int v23;
  void *v24;
  void *v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  signed int v38;

  v10 = a1 + 4565;
  v11 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 6128) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 4708) = v11;
  v12 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 4580) = v12;
  *(_QWORD *)(a1 + 4588) = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 4596) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 6140) = *(_DWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 5800) = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 4560) = a4;
  *(_DWORD *)(a1 + 5808) = a5;
  if (*(_DWORD *)(a1 + 4700) && !*(_DWORD *)(a1 + 4712))
  {
    if (v12 == *(_DWORD *)(a1 + 4584))
      return 0;
    v20 = *(_DWORD *)(a1 + 4600);
    if (v20 < 1)
      return 0;
    else
      return silk_setup_resamplers(a1, v20);
  }
  v13 = silk_control_audio_bandwidth(a1, (_DWORD *)a2);
  if (!a6)
    a6 = v13;
  v14 = silk_setup_resamplers(a1, a6);
  v15 = *(_DWORD *)(a2 + 24);
  if (*(_DWORD *)(a1 + 4636) != v15)
  {
    if (v15 <= 0x3C && ((1 << v15) & 0x1000010000100400) != 0)
      v16 = 0;
    else
      v16 = -103;
    if (v15 > 10)
    {
      *(_DWORD *)(a1 + 5792) = v15 / 0x14u;
      *(_DWORD *)(a1 + 4604) = 4;
      *(_DWORD *)(a1 + 4608) = 20 * (__int16)a6;
      *(_DWORD *)(a1 + 4572) = 24 * (__int16)a6;
      v17 = *(_DWORD *)(a1 + 4600);
      if (v17 == 8)
      {
        v19 = &silk_pitch_contour_NB_iCDF;
        goto LABEL_21;
      }
      v22 = &silk_pitch_contour_iCDF;
    }
    else
    {
      *(_DWORD *)(a1 + 5792) = 1;
      if (v15 == 10)
        v18 = 2;
      else
        v18 = 1;
      *(_DWORD *)(a1 + 4604) = v18;
      *(_DWORD *)(a1 + 4608) = (__int16)v15 * (__int16)a6;
      *(_DWORD *)(a1 + 4572) = 14 * (__int16)a6;
      v17 = *(_DWORD *)(a1 + 4600);
      if (v17 == 8)
      {
        v19 = &silk_pitch_contour_10_ms_NB_iCDF;
LABEL_21:
        *(_QWORD *)(a1 + 4728) = v19;
        v17 = 8;
LABEL_26:
        *(_DWORD *)(a1 + 4636) = v15;
        *(_DWORD *)(a1 + 4632) = 0;
        goto LABEL_27;
      }
      v22 = &silk_pitch_contour_10_ms_iCDF;
    }
    *(_QWORD *)(a1 + 4728) = v22;
    goto LABEL_26;
  }
  v16 = 0;
  v17 = *(_DWORD *)(a1 + 4600);
LABEL_27:
  if (v17 != a6)
  {
    *(_QWORD *)(a1 + 7224) = 0;
    *(_QWORD *)(a1 + 7232) = 0;
    bzero((void *)(a1 + 7240), 0x45CuLL);
    bzero((void *)(a1 + 144), 0x111CuLL);
    *(_OWORD *)(a1 + 4524) = 0u;
    *(_OWORD *)(a1 + 4540) = 0u;
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 5788) = 0;
    *(_DWORD *)(a1 + 5796) = 0;
    *(_DWORD *)(a1 + 4632) = 0;
    *(_DWORD *)(a1 + 4568) = 100;
    *(_DWORD *)(a1 + 4696) = 1;
    *(_DWORD *)(a1 + 8352) = 100;
    *(_BYTE *)(a1 + 7224) = 10;
    *(_DWORD *)(a1 + 4500) = 100;
    *(_DWORD *)(a1 + 4516) = 0x10000;
    *(_BYTE *)v10 = 0;
    *(_DWORD *)(a1 + 4600) = a6;
    v23 = *(_DWORD *)(a1 + 4604);
    if (a6 == 8)
    {
      v24 = &silk_pitch_contour_10_ms_NB_iCDF;
      if (v23 == 4)
        v24 = &silk_pitch_contour_NB_iCDF;
      v25 = &silk_NLSF_CB_NB_MB;
      v26 = 10;
    }
    else
    {
      v24 = &silk_pitch_contour_10_ms_iCDF;
      if (v23 == 4)
        v24 = &silk_pitch_contour_iCDF;
      if (a6 == 12)
        v26 = 10;
      else
        v26 = 16;
      v25 = &silk_NLSF_CB_WB;
      if (a6 == 12)
        v25 = &silk_NLSF_CB_NB_MB;
    }
    *(_QWORD *)(a1 + 4728) = v24;
    *(_DWORD *)(a1 + 4664) = v26;
    *(_QWORD *)(a1 + 4736) = v25;
    *(_DWORD *)(a1 + 4612) = 5 * a6;
    *(_DWORD *)(a1 + 4608) = (__int16)v23 * (__int16)(5 * a6);
    *(_DWORD *)(a1 + 4616) = 20 * (__int16)a6;
    *(_DWORD *)(a1 + 4620) = 2 * (__int16)a6;
    *(_DWORD *)(a1 + 4576) = 18 * (__int16)a6;
    if (v23 == 4)
      v27 = 24;
    else
      v27 = 14;
    *(_DWORD *)(a1 + 4572) = v27 * (__int16)a6;
    if (a6 == 16)
    {
      v28 = silk_uniform8_iCDF;
      v29 = 10;
    }
    else if (a6 == 12)
    {
      v28 = (unsigned __int8 *)&silk_uniform6_iCDF;
      v29 = 13;
    }
    else
    {
      v28 = silk_uniform4_iCDF;
      v29 = 15;
    }
    *(_DWORD *)(a1 + 4684) = v29;
    *(_QWORD *)(a1 + 4720) = v28;
  }
  v30 = *(_DWORD *)(a2 + 36);
  if ((int)v30 > 1)
  {
    if (v30 > 3)
    {
      v32 = 5 * a6;
      if (v30 > 5)
      {
        v34 = 983 * a6;
        if (v30 > 7)
        {
          v33 = 16;
          *(_DWORD *)(a1 + 4660) = 16;
          *(_DWORD *)(a1 + 4624) = v32;
          *(_QWORD *)(v10 + 87) = 0x100000004;
          *(_OWORD *)(v10 + 103) = xmmword_214F95BD0;
          *(_DWORD *)(a1 + 4692) = 32;
          *(_DWORD *)(a1 + 4704) = v34;
        }
        else
        {
          *(_DWORD *)(a1 + 4660) = 14;
          *(_DWORD *)(a1 + 4624) = v32;
          *(_QWORD *)(v10 + 87) = 0x100000003;
          *(_OWORD *)(v10 + 103) = xmmword_214F95BE0;
          *(_DWORD *)(a1 + 4692) = 16;
          *(_DWORD *)(a1 + 4704) = v34;
          v33 = 12;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 4624) = v32;
        *(_DWORD *)(a1 + 4652) = 2;
        *(_QWORD *)(a1 + 4656) = 0xC00000001;
        *(_OWORD *)(v10 + 103) = xmmword_214F95BF0;
        *(_DWORD *)(a1 + 4692) = 8;
        *(_DWORD *)(a1 + 4704) = 983 * a6;
        v33 = 10;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 4676) = 49807;
      *(_DWORD *)(a1 + 4668) = 1;
      v32 = 5 * a6;
      *(_DWORD *)(a1 + 4624) = 5 * a6;
      *(_DWORD *)(a1 + 4652) = 1;
      *(_QWORD *)(a1 + 4656) = 0xA00000000;
      *(_DWORD *)(a1 + 4692) = 4;
      *(_DWORD *)(a1 + 4704) = 0;
      v33 = 8;
    }
    v31 = v32;
  }
  else
  {
    *(_DWORD *)(a1 + 4668) = 0;
    *(_QWORD *)(a1 + 4676) = 0x10000CCCDLL;
    v31 = 3 * a6;
    *(_DWORD *)(a1 + 4624) = 3 * a6;
    *(_DWORD *)(a1 + 4652) = 1;
    *(_QWORD *)(a1 + 4656) = 0x800000000;
    *(_DWORD *)(a1 + 4692) = 2;
    *(_DWORD *)(a1 + 4704) = 0;
    v32 = 5 * a6;
    v33 = 6;
  }
  result = (v16 + v14);
  if (v33 >= *(_DWORD *)(a1 + 4664))
    v33 = *(_DWORD *)(a1 + 4664);
  *(_DWORD *)(a1 + 4672) = v33;
  *(_DWORD *)(a1 + 4628) = v32 + 2 * v31;
  *(_DWORD *)(a1 + 4648) = v30;
  v35 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 4640) = v35;
  *(_DWORD *)(a1 + 6144) = 0;
  if (*(_DWORD *)(a1 + 6140) && v35 >= 1)
  {
    if (a6 == 12)
      v36 = 14000;
    else
      v36 = 16000;
    if (a6 == 8)
      v36 = 12000;
    v37 = 125 - v35;
    if (v35 >= 0x19)
      v37 = 100;
    if ((int)(655 * ((v36 * v37) >> 16) + ((655 * ((v36 * v37) & 0xFFF0u)) >> 16)) < a3)
    {
      *(_DWORD *)(a1 + 6144) = 1;
      v38 = -26214 * HIWORD(v35) - ((26214 * (unsigned __int16)v35) >> 16) + 7;
      if (v38 <= 2)
        v38 = 2;
      *(_DWORD *)(a1 + 6148) = v38;
    }
  }
  *(_DWORD *)(a1 + 4700) = 1;
  return result;
}

uint64_t silk_setup_resamplers(uint64_t a1, int a2)
{
  __int16 v2;
  int v4;
  uint64_t result;
  int v6;
  int v7;
  int v8;
  int v9;
  size_t v10;
  char *v11;
  int v12;
  int v13;
  _DWORD v14[78];
  uint64_t v15;

  v2 = a2;
  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(a1 + 4600);
  if (v4 == a2 && *(_DWORD *)(a1 + 4584) == *(_DWORD *)(a1 + 4580))
  {
    result = 0;
  }
  else if (v4)
  {
    v6 = 10 * *(_DWORD *)(a1 + 4604) + 5;
    v7 = v6 * v4;
    memset(v14, 0, 304);
    v8 = silk_resampler_init((uint64_t)v14, 1000 * (__int16)v4, *(_DWORD *)(a1 + 4580), 0);
    v9 = *(_DWORD *)(a1 + 4580) / 1000 * v6;
    v10 = 2 * v9;
    v11 = (char *)v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v11, v10);
    v12 = silk_resampler(v14, v11, (char *)(a1 + 8356), v7);
    v13 = v12 + v8 + silk_resampler_init(a1 + 5824, *(_DWORD *)(a1 + 4580), 1000 * v2, 1);
    result = v13 + silk_resampler((_DWORD *)(a1 + 5824), (_WORD *)(a1 + 8356), v11, v9);
  }
  else
  {
    result = silk_resampler_init(a1 + 5824, *(_DWORD *)(a1 + 4580), 1000 * a2, 1);
  }
  *(_DWORD *)(a1 + 4584) = *(_DWORD *)(a1 + 4580);
  return result;
}

uint64_t silk_resampler_init(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  char *v7;
  char v8;
  void *v9;
  unsigned int v10;
  signed int v11;
  unsigned int v12;
  signed int v13;

  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (!a4)
  {
    if (a2 != 8000 && a2 != 16000 && a2 != 12000)
      return 0xFFFFFFFFLL;
    v4 = 0xFFFFFFFFLL;
    if ((int)a3 <= 15999)
    {
      if (a3 != 8000)
      {
        v6 = 12000;
LABEL_22:
        if (a3 != v6)
          return v4;
      }
    }
    else if (a3 != 16000 && a3 != 48000)
    {
      v6 = 24000;
      goto LABEL_22;
    }
    v7 = (char *)&delay_matrix_dec + 5 * (a2 >> 12) + (((a3 >> 12) - (a3 > 0x3E80)) >> (a3 > 0x5DC0)) - 6;
    goto LABEL_24;
  }
  v4 = 0xFFFFFFFFLL;
  if ((int)a2 <= 15999)
  {
    if (a2 != 8000)
    {
      v5 = 12000;
LABEL_15:
      if (a2 != v5)
        return v4;
    }
  }
  else if (a2 != 16000 && a2 != 48000)
  {
    v5 = 24000;
    goto LABEL_15;
  }
  if (a3 != 8000 && a3 != 16000 && a3 != 12000)
    return 0xFFFFFFFFLL;
  v7 = (char *)&delay_matrix_enc + 3 * (((a2 >> 12) - (a2 > 0x3E80)) >> (a2 > 0x5DC0)) + (a3 >> 12) - 4;
LABEL_24:
  *(_DWORD *)(a1 + 292) = *v7;
  *(_DWORD *)(a1 + 284) = (unsigned __int16)a2 / 0x3E8u;
  *(_DWORD *)(a1 + 288) = (unsigned __int16)a3 / 0x3E8u;
  *(_DWORD *)(a1 + 268) = 10 * ((unsigned __int16)a2 / 0x3E8u);
  if (a3 > a2)
  {
    if (a3 == 2 * a2)
    {
      v8 = 0;
      *(_DWORD *)(a1 + 264) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 264) = 2;
      v8 = 1;
    }
    goto LABEL_43;
  }
  if (a3 >= a2)
  {
    v8 = 0;
    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_43;
  }
  *(_DWORD *)(a1 + 264) = 3;
  if (4 * a3 != 3 * a2)
  {
    if (3 * a3 == 2 * a2)
    {
      v8 = 0;
      *(_QWORD *)(a1 + 276) = 0x200000012;
      v9 = &silk_Resampler_2_3_COEFS;
      goto LABEL_42;
    }
    if (a2 == 2 * a3)
    {
      v8 = 0;
      *(_QWORD *)(a1 + 276) = 0x100000018;
      v9 = &silk_Resampler_1_2_COEFS;
      goto LABEL_42;
    }
    if (3 * a3 == a2)
    {
      v8 = 0;
      *(_QWORD *)(a1 + 276) = 0x100000024;
      v9 = &silk_Resampler_1_3_COEFS;
      goto LABEL_42;
    }
    if (4 * a3 == a2)
    {
      v8 = 0;
      *(_QWORD *)(a1 + 276) = 0x100000024;
      v9 = &silk_Resampler_1_4_COEFS;
      goto LABEL_42;
    }
    if (6 * a3 == a2)
    {
      v8 = 0;
      *(_QWORD *)(a1 + 276) = 0x100000024;
      v9 = &silk_Resampler_1_6_COEFS;
      goto LABEL_42;
    }
    return 0xFFFFFFFFLL;
  }
  v8 = 0;
  *(_QWORD *)(a1 + 276) = 0x300000012;
  v9 = &silk_Resampler_3_4_COEFS;
LABEL_42:
  *(_QWORD *)(a1 + 296) = v9;
LABEL_43:
  v10 = 4 * ((a2 << (v8 | 0xE)) / a3);
  v11 = a2 << v8;
  do
  {
    v12 = v10;
    v13 = v10 * (((a3 >> 15) + 1) >> 1) + HIWORD(v10) * (__int16)a3 + (((unsigned __int16)v10 * (__int16)a3) >> 16);
    ++v10;
  }
  while (v13 < v11);
  v4 = 0;
  *(_DWORD *)(a1 + 272) = v12;
  return v4;
}

uint64_t silk_resampler(_DWORD *a1, _WORD *a2, char *__src, int a4)
{
  uint64_t v8;
  __int16 *v9;
  uint64_t v10;
  int v11;

  v8 = (int)a1[73];
  v9 = (__int16 *)(a1 + 42);
  v10 = a1[71] - (int)v8;
  memcpy((char *)a1 + 2 * v8 + 168, __src, 2 * v10);
  v11 = a1[66];
  switch(v11)
  {
    case 3:
      silk_resampler_private_down_FIR((uint64_t)a1, a2, v9, a1[71]);
      silk_resampler_private_down_FIR((uint64_t)a1, &a2[a1[72]], (__int16 *)&__src[2 * v10], a4 - a1[71]);
      break;
    case 2:
      silk_resampler_private_IIR_FIR((uint64_t)a1, a2, v9, a1[71]);
      silk_resampler_private_IIR_FIR((uint64_t)a1, &a2[a1[72]], (__int16 *)&__src[2 * v10], a4 - a1[71]);
      break;
    case 1:
      silk_resampler_private_up2_HQ_wrapper(a1, a2, v9, a1[71]);
      silk_resampler_private_up2_HQ_wrapper(a1, &a2[a1[72]], &__src[2 * v10], (a4 - a1[71]));
      break;
    default:
      memcpy(a2, v9, 2 * (int)a1[71]);
      memcpy(&a2[a1[72]], &__src[2 * v10], 2 * (a4 - a1[71]));
      break;
  }
  memcpy(v9, &__src[2 * (a4 - a1[73])], 2 * (int)a1[73]);
  return 0;
}

void silk_LPC_analysis_filter(void *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  _BYTE v10[32];
  _WORD v11[16];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v6 = a5 - 1;
  if (a5 < 1)
  {
    celt_fir((__int16 *)(a2 + 2 * a5), (uint64_t)v10, (uint64_t)a1 + 2 * a5, (a4 - a5), a5, v11);
  }
  else
  {
    v7 = 0;
    v8 = a5;
    do
    {
      *(_WORD *)&v10[v7] = -*(_WORD *)(a3 + v7);
      v7 += 2;
    }
    while (2 * a5 != v7);
    for (i = 0; i != a5; v11[i++] = *(_WORD *)(a2 + 2 * v6--))
      ;
    celt_fir((__int16 *)(a2 + 2 * a5), (uint64_t)v10, (uint64_t)a1 + 2 * a5, (a4 - a5), a5, v11);
    bzero(a1, 2 * v8);
  }
}

unint64_t silk_stereo_LR_to_MS(unsigned __int16 *a1, __int16 *a2, uint64_t a3, uint64_t a4, _BYTE *a5, int *a6, int a7, __int16 a8, int a9, int a10, int a11)
{
  __int16 *v13;
  int v14;
  size_t v15;
  unsigned __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned __int16 *v19;
  __int16 *v20;
  int v21;
  int v22;
  int v23;
  size_t v24;
  int v25;
  unint64_t v26;
  char *v27;
  char *v28;
  __int16 *v29;
  __int16 v30;
  int v31;
  uint64_t v32;
  _WORD *v33;
  _WORD *v34;
  int v35;
  unsigned int v36;
  int v37;
  char *v38;
  char *v39;
  uint64_t v40;
  signed __int16 v41;
  int v42;
  unsigned __int16 *v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned int predictor;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  _DWORD *v68;
  int v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  unsigned int v82;
  int v83;
  int v84;
  int v85;
  unsigned int v86;
  int v87;
  int v88;
  _BYTE *v89;
  unint64_t result;
  int v91;
  int v92;
  signed int v93;
  signed __int16 v94;
  int v95;
  int v96;
  unsigned __int16 v97;
  unsigned __int16 v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  uint64_t v106;
  int v107;
  int v108;
  int v109;
  __int16 *v110;
  _WORD *v111;
  __int16 *v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  unsigned __int16 *v119;
  _WORD *v120;
  uint64_t v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  uint64_t v127;
  int v128;
  int v129;
  uint64_t v130;
  _BYTE *v131;
  int *v132;
  uint64_t v133;
  __int16 *v134;
  uint64_t v135;
  _QWORD v136[2];

  v129 = a7;
  v131 = a5;
  v132 = a6;
  v130 = a4;
  v133 = a3;
  v136[1] = *MEMORY[0x24BDAC8D0];
  v134 = a2;
  v13 = a2 - 2;
  v14 = a11 + 2;
  v15 = 2 * (a11 + 2);
  v16 = (unsigned __int16 *)((char *)&v127 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v16, v15);
  if (a11 >= -1)
  {
    if (v14 <= 1)
      v17 = 1;
    else
      v17 = v14;
    v18 = (__int16 *)(v133 - 4);
    v19 = v16;
    v20 = v13;
    do
    {
      v21 = *v20;
      v22 = *v18++;
      *v20++ = ((v22 + v21) & 1) + ((v22 + v21) >> 1);
      v23 = ((v21 - v22) & 1) + ((v21 - v22) >> 1);
      if (v23 >= 0x7FFF)
        LOWORD(v23) = 0x7FFF;
      *v19++ = v23;
      --v17;
    }
    while (v17);
  }
  *(_DWORD *)v13 = *((_DWORD *)a1 + 1);
  *(_DWORD *)v16 = *((_DWORD *)a1 + 2);
  v24 = 2 * a11;
  v25 = *(_DWORD *)&v16[v24 / 2];
  *((_DWORD *)a1 + 1) = *(_DWORD *)&v13[v24 / 2];
  *((_DWORD *)a1 + 2) = v25;
  v26 = (v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  v27 = (char *)&v127 - v26;
  bzero((char *)&v127 - v26, v24);
  v28 = (char *)&v127 - v26;
  bzero((char *)&v127 - v26, v24);
  if (a11 <= 0)
  {
    v38 = (char *)&v127 - v26;
    bzero((char *)&v127 - v26, 2 * a11);
    v39 = (char *)&v127 - v26;
    bzero(v39, 2 * a11);
  }
  else
  {
    v29 = v134;
    v30 = *(v134 - 2);
    v31 = (unsigned __int16)*(v134 - 1);
    v32 = a11;
    v33 = (_WORD *)((char *)&v127 - v26);
    v34 = (_WORD *)((char *)&v127 - v26);
    do
    {
      v35 = *v29++;
      v36 = ((v35 + v30) >> 1) + (__int16)v31 + 1;
      v37 = v31 - (v36 >> 1);
      v30 = v31;
      v31 = (unsigned __int16)v35;
      *v33++ = v36 >> 1;
      *v34++ = v37;
      --v32;
    }
    while (v32);
    v38 = (char *)&v127 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v38, 2 * a11);
    v39 = v38;
    bzero(v38, 2 * a11);
    v40 = 0;
    v41 = *v16;
    v42 = v16[1];
    v43 = v16 + 2;
    do
    {
      v44 = (((__int16)v43[v40] + v41) >> 1) + (__int16)v42 + 1;
      v45 = v42 - (v44 >> 1);
      v41 = v42;
      v42 = v43[v40];
      *(_WORD *)&v38[v40 * 2] = v44 >> 1;
      *(_WORD *)&v38[v40 * 2] = v45;
      ++v40;
    }
    while (a11 != v40);
  }
  v128 = a9;
  v135 = 0;
  if (10 * a10 == a11)
    v46 = 328;
  else
    v46 = 655;
  v47 = v46 * ((a8 * a8) >> 16) + ((v46 * (unsigned __int16)(a8 * a8)) >> 16);
  if (10 * a10 == a11)
    v48 = -1200;
  else
    v48 = -600;
  LODWORD(v136[0]) = silk_stereo_find_predictor((int *)&v135 + 1, (unint64_t)v27, (__int16 *)v38, (int *)a1 + 3, a11, v47);
  predictor = silk_stereo_find_predictor((int *)&v135, (unint64_t)v28, (__int16 *)v39, (int *)a1 + 5, a11, v47);
  HIDWORD(v136[0]) = predictor;
  v50 = 3 * SWORD2(v135) + v135;
  if (v50 >= 0x10000)
    v50 = 0x10000;
  v51 = v48 + v129;
  if (v48 + v129 <= 1)
    v52 = 1;
  else
    v52 = v48 + v129;
  v53 = 900 * (__int16)a10 + 2000;
  v54 = __clz(v52);
  v55 = -851968 - 3 * v50;
  if (3 * v50 + 851968 >= 0)
    v55 = 3 * v50 + 851968;
  v56 = __clz(v55);
  v57 = (3 * v50 + 851968) << (v56 - 1);
  v58 = 0x1FFFFFFF / (v57 >> 16);
  v59 = v58 * ((int)(v52 << (v54 - 1)) >> 16) + ((v58 * (unsigned __int16)(v52 << (v54 - 1))) >> 16);
  v60 = (v52 << (v54 - 1)) - (((unint64_t)(v57 * (uint64_t)v59) >> 29) & 0xFFFFFFF8);
  v61 = v59 + (v60 >> 16) * v58 + (((unsigned __int16)v60 * v58) >> 16);
  v62 = v54 - v56;
  if ((v62 + 10) >= 0x20)
    v63 = 0;
  else
    v63 = v61 >> (v62 + 10);
  v64 = (int)0x80000000 >> (-10 - v62);
  if (v61 > v64)
    v64 = v61;
  if (v61 <= (int)(0x7FFFFFFFu >> (-10 - v62)))
    v65 = v64;
  else
    v65 = 0x7FFFFFFFu >> (-10 - v62);
  v66 = v65 << (-10 - v62);
  if (v62 <= -11)
    v67 = v66;
  else
    v67 = v63;
  v68 = v132;
  *v132 = v67;
  if (v67 >= v53)
  {
    v68[1] = v52 - v67;
    v88 = 0x4000;
  }
  else
  {
    *v68 = v53;
    v68[1] = v52 - v53;
    v69 = 2 * (v52 - v53) - v53;
    v70 = ((3 * v50 + 0x10000) >> 16) * (__int16)v53 + (((unsigned __int16)(3 * v50) * (__int16)v53) >> 16);
    if (v69 >= 0)
      v71 = 2 * (v52 - v53) - v53;
    else
      v71 = v53 - 2 * (v52 - v53);
    v72 = __clz(v71);
    v73 = v69 << (v72 - 1);
    if (v70 >= 0)
      v74 = ((3 * v50 + 0x10000) >> 16) * (__int16)v53 + (((unsigned __int16)(3 * v50) * (__int16)v53) >> 16);
    else
      v74 = -v70;
    v75 = __clz(v74);
    v76 = v70 << (v75 - 1);
    v77 = 0x1FFFFFFF / (v76 >> 16);
    v78 = v77 * (v73 >> 16) + ((v77 * (v73 & 0xFFFE)) >> 16);
    v79 = v73 - (((unint64_t)(v78 * (uint64_t)v76) >> 29) & 0xFFFFFFF8);
    v80 = v78 + (v79 >> 16) * v77 + (((v79 & 0xFFFE) * v77) >> 16);
    v81 = v72 - v75;
    v82 = v72 - v75 + 13;
    v83 = v80 >> (v72 - v75 + 13);
    if (v82 >= 0x20)
      v84 = 0;
    else
      v84 = v83;
    v85 = (int)0x80000000 >> (-13 - v81);
    if (v80 > v85)
      v85 = v80;
    if (v80 <= (int)(0x7FFFFFFFu >> (-13 - v81)))
      v86 = v85;
    else
      v86 = 0x7FFFFFFFu >> (-13 - v81);
    v87 = v86 << (-13 - v81);
    if (v81 > -14)
      v87 = v84;
    v88 = v87 & ~(v87 >> 31);
    if (v88 >= 0x4000)
      v88 = 0x4000;
  }
  v89 = v131;
  a1[14] += ((v88 - (__int16)a1[14]) * (unsigned __int16)v47) >> 16;
  *v89 = 0;
  if (v128)
  {
    v136[0] = 0;
    result = (unint64_t)silk_stereo_quant_pred(v136, v130);
    v91 = 0;
    goto LABEL_72;
  }
  v92 = 8 * v52;
  v93 = (__int16)a1[14];
  if (a1[15])
  {
    if (v92 < 11 * v53 || (v50 >> 16) * v93 + (((unsigned __int16)v50 * v93) >> 16) <= 327)
    {
      v136[0] = vshr_n_s32(vmul_s32(vshr_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(predictor, v136[0]), 0x10uLL), 0x10uLL), vdup_n_s32(v93)), 0xEuLL);
      result = (unint64_t)silk_stereo_quant_pred(v136, v130);
      v91 = 0;
      v136[0] = 0;
      goto LABEL_72;
    }
  }
  else if (v92 < 13 * v53 || (v50 >> 16) * v93 + (((unsigned __int16)v50 * v93) >> 16) <= 818)
  {
    v136[0] = vshr_n_s32(vmul_s32(vshr_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(predictor, v136[0]), 0x10uLL), 0x10uLL), vdup_n_s32(v93)), 0xEuLL);
    result = (unint64_t)silk_stereo_quant_pred(v136, v130);
    v91 = 0;
    v136[0] = 0;
    *v68 = v52;
    v68[1] = 0;
    *v89 = 1;
    goto LABEL_73;
  }
  if (v93 < 15566)
  {
    v136[0] = vshr_n_s32(vmul_s32(vshr_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(predictor, v136[0]), 0x10uLL), 0x10uLL), vdup_n_s32(v93)), 0xEuLL);
    result = (unint64_t)silk_stereo_quant_pred(v136, v130);
    v91 = (__int16)a1[14];
  }
  else
  {
    result = (unint64_t)silk_stereo_quant_pred(v136, v130);
    v91 = 0x4000;
  }
LABEL_72:
  if (*v89 != 1)
  {
    a1[16] = 0;
    goto LABEL_77;
  }
LABEL_73:
  v94 = a1[16] + a11 - 8 * a10;
  a1[16] = v94;
  if (5 * a10 <= v94)
  {
    a1[16] = 10000;
LABEL_77:
    if (*v89)
      goto LABEL_83;
    goto LABEL_78;
  }
  *v89 = 0;
LABEL_78:
  if ((int)v68[1] <= 0)
  {
    if (v51 <= 2)
      v95 = 2;
    else
      v95 = v51;
    *v68 = v95 - 1;
    v68[1] = 1;
  }
LABEL_83:
  v96 = 8 * a10;
  v97 = v136[0];
  v98 = WORD2(v136[0]);
  if (a10 >= 1)
  {
    v99 = *a1;
    v100 = a1[1];
    v101 = (__int16)a1[15];
    v102 = (__int16)(0x10000 / v96);
    v103 = (((v102 * (__int16)(LOWORD(v136[0]) - v99)) >> 15) + 1) >> 1;
    v104 = (((v102 * (__int16)(WORD2(v136[0]) - v100)) >> 15) + 1) >> 1;
    v105 = (((v91 - v101) >> 16) * v102 + (((unsigned __int16)(v91 - a1[15]) * v102) >> 16)) << 10;
    if (v96 <= 1)
      v106 = 1;
    else
      v106 = v96;
    v107 = v103 << 16;
    v108 = -(v107 + (v99 << 16));
    v109 = v104 << 16;
    LODWORD(result) = -(v109 + (v100 << 16));
    v110 = v134;
    v111 = (_WORD *)(v133 - 2);
    v112 = (__int16 *)(v16 + 1);
    v113 = v105 + (v101 << 10);
    do
    {
      v114 = *(v110 - 1);
      v115 = (v114 << 10) + ((*v110 + *(v110 - 2)) << 9);
      v116 = *v112++;
      v117 = (v114 >> 5) * ((int)result >> 16)
           + (v113 >> 16) * v116
           + (((v113 & 0xFC00) * v116) >> 16)
           + ((((v114 & 0x1F) << 11) * ((int)result >> 16)) >> 16)
           + (v115 >> 16) * (v108 >> 16)
           + (((v115 & 0xFE00) * (v108 >> 16)) >> 16);
      if (v117 <= 8388479)
      {
        v118 = ((v117 >> 7) + 1) >> 1;
        if (v118 <= -32768)
          LOWORD(v118) = 0x8000;
      }
      else
      {
        LOWORD(v118) = 0x7FFF;
      }
      ++v110;
      *v111++ = v118;
      v108 -= v107;
      result = (result - v109);
      v113 += v105;
      --v106;
    }
    while (v106);
  }
  if (v96 < a11)
  {
    v119 = &v16[v96 + 1];
    result = (unint64_t)&v134[v96];
    v120 = (_WORD *)(v133 + 2 * v96 - 2);
    v121 = a11 - (uint64_t)v96;
    do
    {
      v122 = *(__int16 *)(result - 2);
      v123 = (v122 << 10) + ((*(__int16 *)result + *(__int16 *)(result - 4)) << 9);
      v124 = (__int16)*v119++;
      v125 = (v122 >> 5) * (__int16)-v98
           + (v91 >> 6) * v124
           + ((((v91 & 0x3F) << 10) * v124) >> 16)
           + ((((v122 & 0x1F) << 11) * (__int16)-v98) >> 16)
           + (v123 >> 16) * (__int16)-v97
           + (((v123 & 0xFE00) * (__int16)-v97) >> 16);
      if (v125 <= 8388479)
      {
        v126 = ((v125 >> 7) + 1) >> 1;
        if (v126 <= -32768)
          LOWORD(v126) = 0x8000;
      }
      else
      {
        LOWORD(v126) = 0x7FFF;
      }
      result += 2;
      *v120++ = v126;
      --v121;
    }
    while (v121);
  }
  *a1 = v97;
  a1[1] = v98;
  a1[15] = v91;
  return result;
}

double silk_PLC_Reset(uint64_t a1)
{
  double result;

  *(_DWORD *)(a1 + 4192) = *(_DWORD *)(a1 + 2328) << 7;
  *(_QWORD *)&result = 0x1000000010000;
  *(_QWORD *)(a1 + 4264) = 0x1000000010000;
  *(_QWORD *)(a1 + 4276) = 0x1400000002;
  return result;
}

void silk_PLC(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4)
{
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;

  v6 = *(_DWORD *)(a1 + 2316);
  if (v6 != *(_DWORD *)(a1 + 4272))
  {
    *(_DWORD *)(a1 + 4192) = *(_DWORD *)(a1 + 2328) << 7;
    *(_QWORD *)(a1 + 4264) = 0x1000000010000;
    *(_QWORD *)(a1 + 4276) = 0x1400000002;
    *(_DWORD *)(a1 + 4272) = v6;
  }
  if (a4)
  {
    silk_PLC_conceal(a1, a2, a3);
    ++*(_DWORD *)(a1 + 4184);
  }
  else
  {
    v7 = *(char *)(a1 + 2789);
    *(_DWORD *)(a1 + 4188) = v7;
    if (v7 == 2)
    {
      v8 = 0;
      v9 = *(unsigned int *)(a1 + 2324);
      if ((_DWORD)v9)
      {
        v10 = (int)v9 - 1;
        v11 = a2->i32[v10];
        if (v11 >= 1)
        {
          v12 = 0;
          v8 = 0;
          v13 = *(int *)(a1 + 2332);
          v14 = 5 * v9 - 5;
          do
          {
            v15 = 0;
            v16 = 0;
            v17 = v9 + ~(_DWORD)v12;
            do
              v16 += a2[6].i16[v14 + v15++];
            while (v15 != 5);
            if (v16 > v8)
            {
              v18 = &a2->i8[10 * (__int16)v17];
              v19 = *((_QWORD *)v18 + 12);
              *(_WORD *)(a1 + 4204) = *((_WORD *)v18 + 52);
              *(_QWORD *)(a1 + 4196) = v19;
              *(_DWORD *)(a1 + 4192) = a2->i32[v17] << 8;
              v11 = a2->i32[v10];
              v8 = v16;
            }
            if (++v12 == v9)
              break;
            v14 -= 5;
          }
          while (v12 * v13 < v11);
        }
      }
      *(_QWORD *)(a1 + 4196) = 0;
      *(_WORD *)(a1 + 4204) = 0;
      *(_WORD *)(a1 + 4200) = v8;
      if (v8 > 11468)
      {
        if (v8 >= 0x3CCE)
        {
          v23 = 0;
          v24 = 0xF334000u / v8;
          do
          {
            *(_WORD *)(a1 + 4196 + v23) = (v24 * *(__int16 *)(a1 + 4196 + v23)) >> 14;
            v23 += 2;
          }
          while (v23 != 10);
        }
      }
      else
      {
        v20 = 0;
        if (v8 <= 1)
          v8 = 1;
        v21 = (__int16)(0xB33400u / v8);
        do
        {
          *(_WORD *)(a1 + 4196 + v20) = (v21 * *(__int16 *)(a1 + 4196 + v20)) >> 10;
          v20 += 2;
        }
        while (v20 != 10);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4192) = 4608 * (__int16)v6;
      *(_WORD *)(a1 + 4204) = 0;
      *(_QWORD *)(a1 + 4196) = 0;
    }
    memcpy((void *)(a1 + 4206), &a2[4], 2 * *(int *)(a1 + 2340));
    *(_WORD *)(a1 + 4260) = a2[8].i32[2];
    v22 = *(_DWORD *)(a1 + 2324);
    *(_QWORD *)(a1 + 4264) = *(uint64_t *)((char *)&a2->i64[1] + 4 * v22);
    *(_DWORD *)(a1 + 4280) = *(_DWORD *)(a1 + 2332);
    *(_DWORD *)(a1 + 4276) = v22;
  }
}

int32x4_t silk_PLC_conceal(uint64_t a1, int32x4_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  char *v8;
  size_t v9;
  uint64_t v10;
  char v11;
  char *v12;
  char v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  __int16 v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  __int16 *v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  char v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  char v51;
  int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  char *v70;
  int *v71;
  int *v72;
  int v73;
  uint64_t i;
  int v75;
  char *v76;
  int *v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  char *v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int *v99;
  int v100;
  int v101;
  uint64_t v102;
  __int16 *v103;
  int *v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  unsigned int v110;
  __int16 v111;
  int *v112;
  __int128 v113;
  _OWORD *v114;
  __int128 v115;
  uint64_t v116;
  int32x4_t result;
  uint64_t v118;
  int v119;
  int v120;
  uint64_t v121;
  int32x4_t *v122;
  char *v123;
  char *v124;
  int v125;
  int v126;
  int v127;
  _OWORD *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  __int16 *v132;
  uint64_t v133;
  uint64_t v134;
  _DWORD v135[2];
  _WORD v136[10];
  _BYTE v137[28];

  v129 = a3;
  v122 = a2;
  v3 = a1;
  *(_QWORD *)&v137[12] = *MEMORY[0x24BDAC8D0];
  v4 = *(int *)(a1 + 4280);
  v5 = *(unsigned int *)(a1 + 4280);
  v6 = *(int *)(a1 + 2336);
  v7 = 2 * v6;
  v8 = (char *)&v118 - ((2 * v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = 4 * (*(_DWORD *)(a1 + 2328) + (int)v6);
  v124 = (char *)&v118 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  LODWORD(v6) = *(int *)(a1 + 4264) >> 6;
  v120 = *(_DWORD *)(a1 + 4268);
  v135[0] = v6;
  v135[1] = v120 >> 6;
  v119 = v120 >> 6;
  if (*(_DWORD *)(a1 + 2376))
  {
    *(_OWORD *)(a1 + 4222) = 0u;
    *(_OWORD *)(a1 + 4206) = 0u;
  }
  bzero((char *)&v118 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0), 4 * v4);
  v10 = 0;
  v11 = 1;
  v12 = (char *)&v118 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  do
  {
    v13 = v11;
    if ((int)v4 >= 1)
    {
      v14 = 0;
      v15 = v135[v10];
      v16 = ((v10 | 0xFFFFFFFE) + *(_DWORD *)(v3 + 4276)) * v5;
      v17 = (__int16)v15;
      v18 = ((v15 >> 15) + 1) >> 1;
      v19 = v3 + 4 + 4 * v16;
      do
      {
        v20 = v17 * (*(int *)(v19 + 4 * v14) >> 16)
            + ((v17 * (unsigned __int16)*(_DWORD *)(v19 + 4 * v14)) >> 16)
            + v18 * *(_DWORD *)(v19 + 4 * v14);
        v21 = v20 >> 8;
        if (v20 < -8388608)
          LOWORD(v21) = 0x8000;
        if (v20 < 0x800000)
          v22 = v21;
        else
          v22 = 0x7FFF;
        *(_WORD *)&v12[2 * v14++] = v22;
      }
      while (v5 != v14);
    }
    v11 = 0;
    v12 += 2 * v4;
    v10 = 1;
  }
  while ((v13 & 1) != 0);
  v133 = 0;
  v134 = 0;
  bzero(v8, v7);
  bzero(v124, v9);
  silk_sum_sqr_shift((unsigned int *)&v133 + 1, (int *)&v134 + 1, (uint64_t)&v118 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  silk_sum_sqr_shift((unsigned int *)&v133, (int *)&v134, (uint64_t)&v118 + 2 * *(int *)(v3 + 4280) - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0), *(_DWORD *)(v3 + 4280));
  v23 = *(_DWORD *)(v3 + 4276);
  if (SHIDWORD(v133) >> v134 >= (int)v133 >> SBYTE4(v134))
  {
    v24 = *(_DWORD *)(v3 + 4280);
  }
  else
  {
    v24 = v23 - 1;
    v23 = *(_DWORD *)(v3 + 4280);
  }
  v25 = v24 * v23;
  if (v25 <= 128)
    v25 = 128;
  LODWORD(v132) = v25;
  v26 = v3 + 4196;
  LOWORD(v27) = *(_WORD *)(v3 + 4248);
  v28 = *(_DWORD *)(v3 + 4184);
  if (v28 >= 1)
    v28 = 1;
  v29 = HARM_ATT_Q15[v28];
  if (*(_DWORD *)(v3 + 4188) == 2)
    v30 = (__int16 *)&PLC_RAND_ATTENUATE_V_Q15;
  else
    v30 = (__int16 *)&PLC_RAND_ATTENUATE_UV_Q15;
  v31 = v30[v28];
  silk_bwexpander((__int16 *)(v3 + 4206), *(_DWORD *)(v3 + 2340), 64881);
  v32 = *(_DWORD *)(v3 + 2340);
  __memcpy_chk();
  if (!*(_DWORD *)(v3 + 4184))
  {
    if (*(_DWORD *)(v3 + 4188) == 2)
    {
      v33 = 0;
      LOWORD(v34) = 0x4000;
      do
      {
        LOWORD(v34) = v34 - *(_WORD *)(v26 + v33);
        v33 += 2;
      }
      while (v33 != 10);
      v34 = (__int16)v34;
      if ((__int16)v34 <= 3277)
        v34 = 3277;
      v27 = (*(__int16 *)(v3 + 4260) * v34) >> 14;
    }
    else
    {
      v35 = silk_LPC_inverse_pred_gain((__int16 *)(v3 + 4206), v32);
      if (v35 >= 0x8000000)
        v36 = 0x8000000;
      else
        v36 = v35;
      if (v36 <= 0x400000)
        v36 = 0x400000;
      v31 = (int)((v36 >> 13) * v31 + ((8 * (v36 & 0x1FFF) * v31) >> 16)) >> 14;
      v32 = *(_DWORD *)(v3 + 2340);
      LOWORD(v27) = 0x4000;
    }
  }
  v37 = *(_DWORD *)(v3 + 4244);
  v38 = ((*(int *)(v3 + 4192) >> 7) + 1) >> 1;
  v39 = *(_DWORD *)(v3 + 2336);
  v40 = v32;
  v41 = v39 - (v32 + v38) - 2;
  silk_LPC_analysis_filter(&v8[2 * v41], v3 + 2 * v41 + 1348, (uint64_t)v136, v39 - v41, v40);
  v42 = *(_DWORD *)(v3 + 4268);
  if (v42 >= 0)
    v43 = *(_DWORD *)(v3 + 4268);
  else
    v43 = -v42;
  v44 = __clz(v43);
  v45 = v42 << (v44 - 1);
  v46 = 0x1FFFFFFF / (v45 >> 16);
  v47 = (v45 >> 16) * (__int16)v46 + (((unsigned __int16)v45 * (__int16)v46) >> 16);
  v48 = (v46 << 16)
      - 8 * v47 * (((v46 >> 15) + 1) >> 1)
      + ((-8 * v47) >> 16) * (__int16)v46
      + ((((-8 * v47) & 0xFFF8) * (__int16)v46) >> 16);
  v49 = HIWORD(v43);
  v50 = v48 >> (16 - v44);
  v51 = v44 - 16;
  v52 = (int)0x80000000 >> v51;
  if (v48 > (int)0x80000000 >> v51)
    v52 = v48;
  if (v48 <= (int)(0x7FFFFFFFu >> v51))
    v53 = v52;
  else
    v53 = 0x7FFFFFFFu >> v51;
  v54 = v53 << v51;
  if (v49)
    v54 = v50;
  v130 = *(unsigned int *)(v3 + 2340);
  LODWORD(v55) = v130 + v41;
  v56 = *(int *)(v3 + 2336);
  v57 = v124;
  if ((int)v130 + v41 < (int)v56)
  {
    if (v54 >= 0x3FFFFFFF)
      v58 = 0x3FFFFFFF;
    else
      v58 = v54;
    v55 = (int)v55;
    do
    {
      *(_DWORD *)&v57[4 * v55] = (v58 >> 16) * *(__int16 *)&v8[2 * v55]
                               + (((unsigned __int16)v58 * *(__int16 *)&v8[2 * v55]) >> 16);
      ++v55;
    }
    while (v55 < v56);
  }
  v121 = v56;
  LODWORD(v128) = *(_DWORD *)(v3 + 2324);
  v131 = v3;
  if ((int)v128 >= 1)
  {
    v59 = 0;
    v60 = v3 + 4 * ((_DWORD)v132 - 128) + 4;
    v61 = *(_DWORD *)(v3 + 2332);
    v125 = 4608 * *(__int16 *)(v3 + 2316);
    v126 = (__int16)v31;
    v62 = *(_DWORD *)(v3 + 4192);
    v123 = v57 - 8;
    v127 = v61;
    do
    {
      LODWORD(v132) = v59;
      v63 = (__int16)v27;
      if (v61 >= 1)
      {
        v64 = v39 - v38 + 2;
        v65 = *(__int16 *)(v3 + 4196);
        v66 = *(__int16 *)(v3 + 4198);
        v67 = *(__int16 *)(v3 + 4200);
        v68 = *(__int16 *)(v3 + 4202);
        v69 = *(__int16 *)(v3 + 4204);
        v70 = &v124[4 * v39];
        v71 = (int *)&v123[4 * v64];
        v72 = v71;
        do
        {
          v73 = v72[1];
          ++v72;
          v37 = 196314165 * v37 + 907633515;
          *(_DWORD *)v70 = 4
                         * ((v71[2] >> 16) * v65
                          + (((unsigned __int16)v71[2] * v65) >> 16)
                          + (v73 >> 16) * v66
                          + (((unsigned __int16)v73 * v66) >> 16)
                          + (*v71 >> 16) * v67
                          + (((unsigned __int16)*v71 * v67) >> 16)
                          + (*(v71 - 1) >> 16) * v68
                          + (((unsigned __int16)*(v71 - 1) * v68) >> 16)
                          + (*(v71 - 2) >> 16) * v69
                          + (((unsigned __int16)*(v71 - 2) * v69) >> 16)
                          + (*(int *)(v60 + 4 * (v37 >> 25)) >> 16) * v63
                          + (((unsigned __int16)*(_DWORD *)(v60 + 4 * (v37 >> 25)) * v63) >> 16))
                         + 8;
          v70 += 4;
          ++v39;
          v71 = v72;
          --v61;
        }
        while (v61);
      }
      for (i = 0; i != 10; i += 2)
        *(_WORD *)(v26 + i) = (*(__int16 *)(v26 + i) * v29) >> 15;
      v27 = (v126 * v63) >> 15;
      if ((int)(v62 + 655 * (v62 >> 16) + ((655 * (unsigned __int16)v62) >> 16)) >= v125)
        v62 = v125;
      else
        v62 += 655 * (v62 >> 16) + ((655 * (unsigned __int16)v62) >> 16);
      v3 = v131;
      *(_DWORD *)(v131 + 4192) = v62;
      v38 = ((v62 >> 7) + 1) >> 1;
      v59 = (_DWORD)v132 + 1;
      v61 = v127;
    }
    while ((_DWORD)v132 + 1 != (_DWORD)v128);
  }
  v75 = v121 - 16;
  v76 = v124;
  v77 = (int *)&v124[4 * (int)v121 - 64];
  v78 = *(_OWORD *)(v3 + 1300);
  *(_OWORD *)v77 = *(_OWORD *)(v3 + 1284);
  *((_OWORD *)v77 + 1) = v78;
  v79 = *(_OWORD *)(v3 + 1316);
  v80 = *(_OWORD *)(v3 + 1332);
  v128 = (_OWORD *)(v3 + 1284);
  *((_OWORD *)v77 + 2) = v79;
  *((_OWORD *)v77 + 3) = v80;
  v81 = *(unsigned int *)(v3 + 2328);
  if ((int)v81 >= 1)
  {
    v82 = 0;
    v83 = v136[0];
    v84 = v136[1];
    v85 = (int)v130 >> 1;
    v86 = v136[2];
    v87 = v136[3];
    v88 = v76;
    v89 = v136[4];
    v90 = v136[5];
    v91 = (__int16)v119;
    v92 = v136[6];
    v93 = v136[7];
    v94 = ((v120 >> 21) + 1) >> 1;
    v95 = (uint64_t)&v88[4 * v75 + 20];
    v132 = (__int16 *)v137;
    v96 = v130 - 10;
    v97 = v136[8];
    v98 = v136[9];
    do
    {
      v99 = &v77[v82];
      v100 = v85
           + (v99[15] >> 16) * v83
           + (((unsigned __int16)v99[15] * v83) >> 16)
           + (v99[14] >> 16) * v84
           + (((unsigned __int16)v99[14] * v84) >> 16)
           + (v99[13] >> 16) * v86
           + (((unsigned __int16)v99[13] * v86) >> 16);
      v101 = v100
           + (v99[12] >> 16) * v87
           + (((unsigned __int16)v99[12] * v87) >> 16)
           + (v99[11] >> 16) * v89
           + (((unsigned __int16)v99[11] * v89) >> 16)
           + (v77[(v82 + 10)] >> 16) * v90
           + (((unsigned __int16)v77[(v82 + 10)] * v90) >> 16)
           + (v77[(v82 + 9)] >> 16) * v92
           + (((unsigned __int16)v77[(v82 + 9)] * v92) >> 16)
           + (v77[(v82 + 8)] >> 16) * v93
           + (((unsigned __int16)v77[(v82 + 8)] * v93) >> 16)
           + (v77[(v82 + 7)] >> 16) * v97
           + (((unsigned __int16)v77[(v82 + 7)] * v97) >> 16)
           + (v77[(v82 + 6)] >> 16) * v98
           + (((unsigned __int16)v77[(v82 + 6)] * v98) >> 16);
      if ((int)v130 >= 11)
      {
        v102 = v96;
        v103 = v132;
        v104 = (int *)v95;
        do
        {
          v106 = *v104--;
          v105 = v106;
          v107 = *v103++;
          v101 += (v105 >> 16) * v107 + (((unsigned __int16)v105 * v107) >> 16);
          --v102;
        }
        while (v102);
      }
      v108 = v77[(v82 + 16)] + 16 * v101;
      v77[(v82 + 16)] = v108;
      v109 = v108 * v94 + (v108 >> 16) * v91 + (((unsigned __int16)v108 * v91) >> 16);
      v110 = ((v109 >> 7) + 1) >> 1;
      if (v109 < -8388736)
        LOWORD(v110) = 0x8000;
      if (v109 <= 8388479)
        v111 = v110;
      else
        v111 = 0x7FFF;
      *(_WORD *)(v129 + 2 * v82++) = v111;
      v95 += 4;
    }
    while (v82 != v81);
  }
  v112 = &v77[(int)v81];
  v113 = *((_OWORD *)v112 + 1);
  v114 = v128;
  *v128 = *(_OWORD *)v112;
  v114[1] = v113;
  v115 = *((_OWORD *)v112 + 3);
  v114[2] = *((_OWORD *)v112 + 2);
  v114[3] = v115;
  v116 = v131;
  *(_DWORD *)(v131 + 4244) = v37;
  *(_WORD *)(v116 + 4248) = v27;
  result = vdupq_n_s32(v38);
  *v122 = result;
  return result;
}

unsigned int *silk_PLC_glue_frames(unsigned int *result, uint64_t a2, int a3)
{
  __int16 *v4;
  unsigned int *v5;
  int v6;
  int v7;
  signed int v8;
  unsigned int v9;
  signed int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  signed int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = (__int16 *)a2;
  v5 = result;
  if (result[1046])
  {
    result = silk_sum_sqr_shift(result + 1063, (int *)result + 1064, a2, a3);
    v5[1060] = 1;
  }
  else
  {
    if (result[1060])
    {
      v20 = 0;
      result = silk_sum_sqr_shift((unsigned int *)&v20, (int *)&v20 + 1, a2, a3);
      v6 = v5[1064];
      if (SHIDWORD(v20) <= v6)
      {
        v7 = SHIDWORD(v20) < v6 ? (int)v20 >> (v6 - BYTE4(v20)) : v20;
      }
      else
      {
        v5[1063] = (int)v5[1063] >> (BYTE4(v20) - v6);
        v7 = v20;
      }
      v8 = v5[1063];
      if (v7 > v8)
      {
        v9 = __clz(v8);
        v10 = v8 << (v9 - 1);
        v5[1063] = v10;
        v11 = v7 >> ((25 - v9) & ~((int)(25 - v9) >> 31));
        if (v11 <= 1)
          v11 = 1;
        v12 = v10 / v11;
        if ((int)v12 < 1)
        {
          v16 = 0;
        }
        else
        {
          v13 = __clz(v12);
          if (v13 != 24)
          {
            if (v12 <= 0x7F)
              LOBYTE(v12) = (v12 >> (56 - v13)) | ((_BYTE)v12 << (v13 - 24));
            else
              LOBYTE(v12) = ((_BYTE)v12 << (v13 + 8)) | (v12 >> (24 - v13));
          }
          v14 = v12 & 0x7F;
          if ((v13 & 1) != 0)
            v15 = 0x8000;
          else
            v15 = 46214;
          v16 = 16 * ((v15 >> (v13 >> 1)) + ((213 * (v15 >> (v13 >> 1)) * v14) >> 16));
        }
        if (a3 >= 1)
        {
          v17 = 4 * ((0x10000 - v16) / a3);
          v18 = a3 - 1;
          do
          {
            v19 = v18;
            *v4 = HIWORD(v16) * *v4 + (((v16 & 0xFFFCu) * *v4) >> 16);
            ++v4;
            v16 += v17;
            if (v16 > 0x10000)
              break;
            --v18;
          }
          while (v19);
        }
      }
    }
    v5[1060] = 0;
  }
  return result;
}

uint64_t silk_quant_LTP_gains(uint64_t result, char *a2, _BYTE *a3, int *a4, int *a5, __int16 a6, int a7, int a8)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  int v16;
  int *v17;
  _WORD *v18;
  int v19;
  int v20;
  _WORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  int v29;
  _WORD *v32;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v40;
  _BYTE __src[4];

  v32 = (_WORD *)result;
  v8 = 0;
  v29 = 0;
  v40 = 0;
  v27 = a8;
  v36 = a8;
  v37 = 0x7FFFFFFF;
  do
  {
    v9 = *a4;
    v38 = v8;
    v10 = 0;
    if (a8 >= 1)
    {
      v11 = (uint64_t)*(&silk_LTP_gain_BITS_Q5_ptrs + v8);
      v12 = (char *)*(&silk_LTP_vq_ptrs_Q7 + v8);
      v13 = (uint64_t)*(&silk_LTP_vq_gain_ptrs_Q7 + v8);
      v14 = __src;
      v15 = v36;
      v16 = silk_LTP_vq_sizes[v8];
      v17 = a5;
      v18 = v32;
      do
      {
        v19 = silk_log2lin(6229 - v9);
        silk_VQ_WMat_EC(v14, (int *)&v40 + 1, &v40, v18, v17, v12, v13, v11, a6, v19 - 51, v16);
        if (HIDWORD(v40) + v10 < 0 != __OFADD__(HIDWORD(v40), v10))
          v10 = 0x7FFFFFFF;
        else
          v10 += HIDWORD(v40);
        result = silk_lin2log((int)v40 + 51);
        if ((int)result + v9 >= 896)
        {
          result = silk_lin2log((int)v40 + 51);
          v9 = v9 + result - 896;
        }
        else
        {
          v9 = 0;
        }
        v18 += 5;
        v17 += 25;
        ++v14;
        --v15;
      }
      while (v15);
    }
    if (v10 >= 2147483646)
      v20 = 2147483646;
    else
      v20 = v10;
    if (v20 < v37)
    {
      *a3 = v38;
      result = (uint64_t)memcpy(a2, __src, v27);
      v37 = v20;
      v29 = v9;
    }
    if (v20 < silk_LTP_gain_middle_avg_RD_Q14 && a7 != 0)
      break;
    v8 = v38 + 1;
  }
  while (v38 != 2);
  v22 = v32;
  if (a8 >= 1)
  {
    v23 = 0;
    v24 = (uint64_t)*(&silk_LTP_vq_ptrs_Q7 + (char)*a3);
    do
    {
      v25 = 0;
      v26 = 0;
      do
      {
        v22[v25] = *(char *)(v24 + ((v26 + 0x500000000 * a2[v23]) >> 32)) << 7;
        v26 += 0x100000000;
        ++v25;
      }
      while (v25 != 5);
      ++v23;
      v22 += 5;
    }
    while (v23 != v36);
  }
  *a4 = v29;
  return result;
}

void *silk_NSQ(_DWORD *a1, int32x2_t *a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, __int16 a14, __int16 a15, __int16 a16)
{
  _DWORD *v19;
  int v20;
  unsigned int v21;
  int v22;
  __int32 v23;
  int v24;
  size_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int32x4_t v33;
  _DWORD *v34;
  int v35;
  __int16 *v36;
  int v37;
  int v38;
  char v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  char v45;
  int v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  char v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  signed int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  uint64_t v72;
  int v73;
  int v74;
  int v75;
  int *v76;
  _DWORD *v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  char *v85;
  char *v86;
  int v87;
  int v88;
  unsigned int v89;
  int32x2_t *v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  int *v95;
  uint64_t v96;
  int32x4_t v97;
  int32x4_t v98;
  int32x4_t v99;
  int32x2_t *v100;
  int32x4_t v101;
  int32x4_t v102;
  uint64_t v103;
  int32x2_t *v104;
  int32x4_t v105;
  int32x4_t v106;
  uint64_t v107;
  int v108;
  int v109;
  __int16 *v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  int v114;
  int v115;
  int *v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  uint64_t v131;
  _DWORD *v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  unsigned int v142;
  int *v143;
  __int16 *v144;
  uint64_t i;
  int v146;
  int v147;
  int v148;
  int v149;
  uint64_t v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  int v163;
  int v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  int v168;
  int v169;
  unsigned int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  unsigned int v175;
  __int16 v176;
  int v177;
  int32x2_t v178;
  _OWORD *v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  int32x2_t *v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  _BYTE v188[12];
  int v189;
  char *v190;
  int32x2_t *v191;
  int32x2_t *v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  int *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int32x2_t *v204;
  uint64_t v205;
  uint64_t v206;
  _DWORD *v207;
  int *v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  unsigned int v212;
  int32x2_t *v213;
  unsigned int v214;
  int v215;
  unsigned int v216;
  __int16 *v217;
  __int16 *v218;
  __int16 *v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  unsigned int v225;
  uint64_t v226;
  int v227;
  int v228;
  int v229;
  int v230;
  int *v231;
  uint64_t v232;
  int v233;
  int v234;
  int *v235;
  int v236;
  _BYTE *v237;
  char *v238;
  int v239;
  char *v240;
  _DWORD *v241;
  uint64_t v242;

  v199 = a7;
  v202 = a6;
  v241 = a5;
  v19 = a1;
  v205 = a13;
  v242 = *MEMORY[0x24BDAC8D0];
  a2[546].i32[0] = *(char *)(a3 + 34);
  v20 = a2[544].i32[1];
  v21 = silk_Quantization_Offsets_Q10[2 * (*(char *)(a3 + 29) >> 1) + *(char *)(a3 + 30)];
  v203 = a3;
  v22 = *(unsigned __int8 *)(a3 + 31);
  v23 = a1[1154];
  v24 = a1[1152];
  v25 = 4 * (v24 + v23);
  v238 = &v188[-((v25 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v238, v25);
  v26 = 2 * (v24 + v23);
  v190 = &v188[-((v26 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v190, v26);
  v27 = (int)v19[1153];
  v237 = &v188[-((4 * v27 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v237, 4 * v27);
  a2[545].i32[1] = v23;
  a2[545].i32[0] = v23;
  LODWORD(v28) = v19[1151];
  if ((int)v28 >= 1)
  {
    v240 = (char *)a2 + 2 * v23;
    v29 = v22 == 4;
    v30 = 0;
    v31 = v29;
    v201 = v31;
    v206 = a12;
    v197 = a11;
    if (v29)
      v32 = 3;
    else
      v32 = 1;
    v193 = v32;
    v189 = a16;
    v196 = (int *)&a2[495] + 1;
    v204 = a2 + 480;
    v195 = a10;
    v200 = a9;
    v212 = v21 - 944;
    v211 = (__int16)(944 - v21) * a14;
    v223 = a14 * v21;
    v216 = v21 + 944;
    v224 = a14;
    v215 = (__int16)(v21 + 944) * a14;
    v225 = v21;
    v214 = v21 - 80;
    v192 = a2 + 160;
    v191 = a2 + 536;
    v194 = a8 + 4;
    v213 = a2 + 537;
    v33.i64[0] = 0x100000001;
    v33.i64[1] = 0x100000001;
    v34 = v241;
    v35 = v20;
    v207 = v19;
    v198 = a8;
    do
    {
      v36 = (__int16 *)(v202 + 32 * (v201 | (v30 >> 1)));
      v37 = *(_DWORD *)(v200 + 4 * v30);
      a2[547].i32[0] = 0;
      v239 = *(unsigned __int8 *)(v203 + 29);
      if (v239 == 2)
      {
        v38 = *(_DWORD *)(v205 + 4 * v30);
        v220 = v38;
        if ((v193 & v30) != 0)
        {
          v239 = 2;
          v39 = 1;
        }
        else
        {
          v40 = v19[1166];
          v41 = v19[1154] - v40 - v38 - 2;
          silk_LPC_analysis_filter(&v190[2 * v41], (uint64_t)a2 + 2 * v41 + 2 * (int)v27 * (int)v30, (uint64_t)v36, 2 - (-v40 - v38), v40);
          v33.i64[0] = 0x100000001;
          v33.i64[1] = 0x100000001;
          v39 = 0;
          a2[547].i32[0] = 1;
          a2[545].i32[0] = v19[1154];
          v239 = *(unsigned __int8 *)(v203 + 29);
        }
      }
      else
      {
        v220 = v35;
        v39 = 1;
      }
      v42 = *(_DWORD *)(v205 + 4 * v30);
      v43 = *(_DWORD *)(v206 + 4 * v30);
      if (v43 <= 1)
        v44 = 1;
      else
        v44 = *(_DWORD *)(v206 + 4 * v30);
      v45 = __clz(v44);
      v46 = v44 << (v45 - 1);
      v47 = 0x1FFFFFFF / (v46 >> 16);
      v48 = (v46 >> 16) * (__int16)v47 + (((unsigned __int16)v46 * (__int16)v47) >> 16);
      v49 = (v47 << 16)
          - 8 * v48 * (((v47 >> 15) + 1) >> 1)
          + ((-8 * v48) >> 16) * (__int16)v47
          + ((((-8 * v48) & 0xFFF8) * (__int16)v47) >> 16);
      v50 = v44 >> 17;
      v51 = v49 >> (15 - v45);
      v52 = v45 - 15;
      v53 = (int)0x80000000 >> v52;
      if (v49 > (int)0x80000000 >> v52)
        v53 = v49;
      if (v49 <= (int)(0x7FFFFFFFu >> v52))
        v54 = v53;
      else
        v54 = 0x7FFFFFFFu >> v52;
      v55 = v54 << v52;
      if (v50)
        v55 = v51;
      v56 = a2[546].i32[1];
      if (v43 == v56)
      {
        v57 = 0x10000;
      }
      else
      {
        if (v56 >= 0)
          v58 = a2[546].u32[1];
        else
          v58 = -v56;
        v59 = __clz(v58);
        v60 = v56 << (v59 - 1);
        if (v43 >= 0)
          v61 = *(_DWORD *)(v206 + 4 * v30);
        else
          v61 = -v43;
        v62 = __clz(v61);
        v63 = v43 << (v62 - 1);
        v64 = 0x1FFFFFFF / (v63 >> 16);
        v65 = v64 * (v60 >> 16) + ((v64 * (unsigned __int16)v60) >> 16);
        v66 = v60 - (((unint64_t)(v65 * (uint64_t)v63) >> 29) & 0xFFFFFFF8);
        v67 = v65 + (v66 >> 16) * v64 + (((unsigned __int16)v66 * v64) >> 16);
        v68 = v59 - v62;
        if ((v68 + 29) >= 0x30)
          v69 = 0;
        else
          v69 = v67 >> (v68 + 13);
        v70 = (int)0x80000000 >> (-13 - v68);
        if (v67 > v70)
          v70 = v67;
        if (v67 <= (int)(0x7FFFFFFFu >> (-13 - v68)))
          v71 = v70;
        else
          v71 = 0x7FFFFFFFu >> (-13 - v68);
        v57 = v71 << (-13 - v68);
        if (v68 > -14)
          v57 = v69;
      }
      v72 = v19[1153];
      if ((int)v72 >= 1)
      {
        v73 = (v55 >> 7) + 1;
        v74 = (__int16)(v73 >> 1);
        v75 = ((v73 >> 16) + 1) >> 1;
        v76 = a4;
        v77 = v237;
        v78 = v19[1153];
        do
        {
          v79 = *v76++;
          *v77++ = v79 * v75 + (v79 >> 16) * v74 + (((unsigned __int16)v79 * v74) >> 16);
          --v78;
        }
        while (v78);
      }
      a2[546].i32[1] = v43;
      v35 = v220;
      if ((v39 & 1) == 0)
      {
        if (!v30)
          v55 = 4 * ((v55 >> 16) * v189 + (((unsigned __int16)v55 * v189) >> 16));
        v80 = a2[545].i32[0];
        v81 = v80 - v42 - 2;
        if (v81 < (int)v80)
        {
          v82 = v55 >> 16;
          v83 = (unsigned __int16)v55;
          v84 = v80 - v81;
          v85 = &v238[4 * v81];
          v86 = &v190[2 * v81];
          do
          {
            v87 = *(__int16 *)v86;
            v86 += 2;
            *(_DWORD *)v85 = v82 * v87 + ((v83 * v87) >> 16);
            v85 += 4;
            --v84;
          }
          while (v84);
        }
      }
      v210 = v30;
      v208 = a4;
      if (v57 != 0x10000)
      {
        v88 = v19[1154];
        v89 = v57 >> 16;
        v90 = v192;
        if (v88 >= 1)
        {
          v91 = a2[545].i32[1] - v88;
          do
          {
            v90->i32[v91] = (__int16)v90->i32[v91] * v89
                          + (((__int16)v90->i32[v91] * (unsigned __int16)v57) >> 16)
                          + (((v90->i32[v91] >> 15) + 1) >> 1) * v57;
            ++v91;
          }
          while (v91 < a2[545].i32[1]);
        }
        if (v239 == 2 && !a2[547].i32[0])
        {
          v92 = a2[545].i32[0];
          v93 = v92 - v42 - 2;
          if (v93 < (int)v92)
          {
            v94 = v92 - v93;
            v95 = (int *)&v238[4 * v93];
            do
            {
              *v95 = (__int16)*v95 * v89
                   + (((__int16)*v95 * (unsigned __int16)v57) >> 16)
                   + (((*v95 >> 15) + 1) >> 1) * v57;
              ++v95;
              --v94;
            }
            while (v94);
          }
        }
        v96 = 0;
        a2[544].i32[0] = (__int16)a2[544].i32[0] * v89
                       + (((__int16)a2[544].i32[0] * (unsigned __int16)v57) >> 16)
                       + (((a2[544].i32[0] >> 15) + 1) >> 1) * v57;
        v97 = vdupq_n_s32(v89);
        v98 = vdupq_n_s32((unsigned __int16)v57);
        v99 = vdupq_n_s32(v57);
        v100 = v204;
        do
        {
          v101 = *(int32x4_t *)v100[v96].i8;
          v102 = vshrq_n_s32(vshlq_n_s32(v101, 0x10uLL), 0x10uLL);
          *(int32x4_t *)v100[v96].i8 = vmlaq_s32(vsraq_n_s32(vmulq_s32(v102, v97), vmulq_s32(v102, v98), 0x10uLL), vhaddq_s32(vshrq_n_s32(v101, 0xFuLL), v33), v99);
          v96 += 2;
        }
        while (v96 != 16);
        v103 = 0;
        v104 = v191;
        do
        {
          v105 = *(int32x4_t *)v104[v103].i8;
          v106 = vshrq_n_s32(vshlq_n_s32(v105, 0x10uLL), 0x10uLL);
          *(int32x4_t *)v104[v103].i8 = vmlaq_s32(vsraq_n_s32(vmulq_s32(v106, v97), vmulq_s32(v106, v98), 0x10uLL), vhaddq_s32(vshrq_n_s32(v105, 0xFuLL), v33), v99);
          v103 += 2;
        }
        while (v103 != 8);
        v72 = v19[1153];
      }
      v209 = v72;
      if ((int)v72 >= 1)
      {
        v107 = 0;
        v219 = (__int16 *)(v194 + 32 * (v210 & 0xFFFFFFF));
        v218 = (__int16 *)(v199 + 2 * (5 * v210));
        v108 = v37 >> 2;
        v109 = (v37 >> 2) | (v37 << 15);
        v110 = (__int16 *)(v198 + 2 * (16 * v210));
        v111 = v207[1166];
        v112 = (int)v207[1165];
        v113 = *(_DWORD *)(v206 + 4 * v210);
        v114 = *(_DWORD *)(v197 + 4 * v210);
        v236 = *(__int16 *)(v195 + 4 * v210);
        v235 = (int *)&v238[4 * (a2[545].i32[0] - v35) + 8];
        v241 = (_DWORD *)&a2[160] + a2[545].i32[1] - v35 + 1;
        v233 = (int)v112 >> 1;
        v234 = (int)v111 >> 1;
        v232 = v112 - 1;
        v231 = (int *)&a2[535] + v112 + 1;
        v229 = v114 >> 16;
        v230 = (__int16)v114;
        v222 = (__int16)v108;
        v221 = v109 >> 16;
        v227 = ((v113 >> 21) + 1) >> 1;
        v228 = (__int16)(v113 >> 6);
        v115 = a2[546].i32[0];
        v116 = v196;
        v226 = v209;
        v217 = v110;
        do
        {
          a2[546].i32[0] = 196314165 * v115 + 907633515;
          v117 = *v116;
          v118 = *v116 >> 16;
          v119 = (unsigned __int16)*v116;
          v120 = v36[1];
          v121 = (unsigned __int16)*(v116 - 1) * v120;
          v122 = v234 + v118 * *v36 + ((v119 * *v36) >> 16) + (*(v116 - 1) >> 16) * v120;
          v123 = v36[3];
          v124 = (unsigned __int16)*(v116 - 3) * v123;
          v125 = v122
               + (v121 >> 16)
               + (*(v116 - 2) >> 16) * v36[2]
               + (((unsigned __int16)*(v116 - 2) * v36[2]) >> 16)
               + (*(v116 - 3) >> 16) * v123;
          v126 = v36[5];
          v127 = (unsigned __int16)*(v116 - 5) * v126;
          v128 = v125
               + (v124 >> 16)
               + (*(v116 - 4) >> 16) * v36[4]
               + (((unsigned __int16)*(v116 - 4) * v36[4]) >> 16)
               + (*(v116 - 5) >> 16) * v126;
          v129 = v36[7];
          v130 = v128
               + (v127 >> 16)
               + (*(v116 - 6) >> 16) * v36[6]
               + (((unsigned __int16)*(v116 - 6) * v36[6]) >> 16)
               + (*(v116 - 7) >> 16) * v129
               + (((unsigned __int16)*(v116 - 7) * v129) >> 16)
               + (*(v116 - 8) >> 16) * v36[8]
               + (((unsigned __int16)*(v116 - 8) * v36[8]) >> 16)
               + (*(v116 - 9) >> 16) * v36[9]
               + (((unsigned __int16)*(v116 - 9) * v36[9]) >> 16);
          if ((_DWORD)v111 == 16)
          {
            v131 = v111;
            v132 = v34;
            v133 = v36[13];
            v134 = (unsigned __int16)*(v116 - 13) * v133;
            v135 = v130
                 + (*(v116 - 10) >> 16) * v36[10]
                 + (((unsigned __int16)*(v116 - 10) * v36[10]) >> 16)
                 + (*(v116 - 11) >> 16) * v36[11]
                 + (((unsigned __int16)*(v116 - 11) * v36[11]) >> 16)
                 + (*(v116 - 12) >> 16) * v36[12]
                 + (((unsigned __int16)*(v116 - 12) * v36[12]) >> 16)
                 + (*(v116 - 13) >> 16) * v133;
            v34 = v132;
            v35 = v220;
            v136 = v135 + (v134 >> 16);
            v110 = v217;
            v111 = v131;
            v130 = v136
                 + (*(v116 - 14) >> 16) * v36[14]
                 + (((unsigned __int16)*(v116 - 14) * v36[14]) >> 16)
                 + (*(v116 - 15) >> 16) * v36[15]
                 + (((unsigned __int16)*(v116 - 15) * v36[15]) >> 16);
          }
          if (v239 == 2)
          {
            v137 = *v218;
            v138 = v218[1];
            v139 = (*v235 >> 16) * v137
                 + (((unsigned __int16)*v235 * v137) >> 16)
                 + (*(v235 - 1) >> 16) * v138
                 + (((unsigned __int16)*(v235 - 1) * v138) >> 16)
                 + (*(v235 - 2) >> 16) * v218[2]
                 + (((unsigned __int16)*(v235 - 2) * v218[2]) >> 16)
                 + (*(v235 - 3) >> 16) * v218[3]
                 + (((unsigned __int16)*(v235 - 3) * v218[3]) >> 16)
                 + (*(v235 - 4) >> 16) * v218[4]
                 + (((unsigned __int16)*(v235 - 4) * v218[4]) >> 16)
                 + 2;
            ++v235;
          }
          else
          {
            v139 = 0;
          }
          v140 = a2[536].i32[0];
          a2[536].i32[0] = v117;
          v141 = v233 + v118 * *v110 + ((v119 * *v110) >> 16);
          v142 = v225;
          if ((int)v112 >= 3)
          {
            v143 = (int *)v213;
            v144 = v219;
            for (i = 2; i < v112; i += 2)
            {
              v146 = *(v143 - 1);
              *(v143 - 1) = v140;
              v147 = v140 >> 16;
              v148 = *(v144 - 1);
              v149 = (unsigned __int16)v140 * v148;
              v140 = *v143;
              *v143 = v146;
              v143 += 2;
              v141 += v147 * v148 + (v149 >> 16) + (v146 >> 16) * *v144 + (((unsigned __int16)v146 * *v144) >> 16);
              v144 += 2;
            }
          }
          v150 = v232;
          *v231 = v140;
          v151 = v141 + (v140 >> 16) * v110[v150] + (((unsigned __int16)v140 * v110[v150]) >> 16);
          v152 = a2[544].i32[0] >> 16;
          LODWORD(v150) = (unsigned __int16)a2[544].i32[0];
          v153 = v152 * v236 + (((int)v150 * v236) >> 16) + 2 * v151;
          v154 = v152 * v229
               + (((int)v150 * v229) >> 16)
               + (a2[159].i32[a2[545].i32[1] + 1] >> 16) * v230
               + (((unsigned __int16)a2[159].i32[a2[545].i32[1] + 1] * v230) >> 16);
          v155 = 4 * v130 - v154 - v153;
          if (v35 < 1)
          {
            v157 = v155 >> 1;
          }
          else
          {
            v156 = ((*(v241 - 2) + *v241) >> 16) * v222
                 + ((int)*(v241 - 1) >> 16) * v221
                 + (((unsigned __int16)(*((_WORD *)v241 - 4) + *(_WORD *)v241) * v222) >> 16)
                 + (((unsigned __int16)*(v241 - 1) * v221) >> 16);
            ++v241;
            v157 = (v139 + 2 * v155 - 2 * v156) >> 2;
          }
          v158 = *(_DWORD *)&v237[4 * v107] - ((v157 + 1) >> 1);
          if (a2[546].i32[0] < 0)
            v158 = ((v157 + 1) >> 1) - *(_DWORD *)&v237[4 * v107];
          if (v158 <= -31744)
            v158 = -31744;
          if (v158 >= 30720)
            v159 = 30720;
          else
            v159 = v158;
          v160 = v159 - v142;
          if ((int)(v159 - v142) < 1024)
          {
            v161 = v142;
            v162 = v216;
            v163 = v223;
            v164 = v215;
            if (v160 >= 0x400)
            {
              v165 = v142 + (v160 & 0xFFFFFC00);
              v166 = v165 + 80;
              v167 = v165 + 1104;
              v168 = (__int16)(-80 - v165) * v224;
              v169 = (__int16)(-1104 - v165) * v224;
              if (v160 <= 0xFFFFFBFF)
                v161 = v166;
              else
                v161 = v212;
              if (v160 <= 0xFFFFFBFF)
                v162 = v167;
              else
                v162 = v142;
              if (v160 <= 0xFFFFFBFF)
                v163 = v168;
              else
                v163 = v211;
              if (v160 <= 0xFFFFFBFF)
                v164 = v169;
              else
                v164 = v223;
            }
          }
          else
          {
            v161 = v214 + (v160 & 0xFFFFFC00);
            v162 = v161 + 1024;
            v163 = (__int16)(v214 + (v160 & 0xFC00)) * v224;
            v164 = (__int16)(v214 + (v160 & 0xFC00) + 1024) * v224;
          }
          if (v164 + (__int16)(v159 - v162) * (__int16)(v159 - v162) >= v163
                                                                       + (__int16)(v159 - v161) * (__int16)(v159 - v161))
            v170 = v161;
          else
            v170 = v162;
          *((_BYTE *)v34 + v107) = ((v170 >> 9) + 1) >> 1;
          v171 = 16 * v170;
          if (a2[546].i32[0] < 0)
            v171 = -v171;
          v172 = v171 + 2 * v139;
          v173 = v172 + 16 * v130;
          v174 = v173 * v227 + (v173 >> 16) * v228 + (((v173 & 0xFFFE) * v228) >> 16);
          v175 = ((v174 >> 7) + 1) >> 1;
          if (v174 < -8388736)
            LOWORD(v175) = 0x8000;
          if (v174 <= 8388479)
            v176 = v175;
          else
            v176 = 0x7FFF;
          *(_WORD *)&v240[2 * v107] = v176;
          v116[1] = v173;
          ++v116;
          v177 = v173 - 4 * v153;
          a2[544].i32[0] = v177;
          a2[160].i32[a2[545].i32[1]] = v177 - 4 * v154;
          v178 = vadd_s32(a2[545], (int32x2_t)0x100000001);
          *(_DWORD *)&v238[4 * (int)*(_QWORD *)&a2[545]] = 2 * v172;
          a2[545] = v178;
          v115 = a2[546].i32[0] + *((char *)v34 + v107);
          a2[546].i32[0] = v115;
          ++v107;
        }
        while (v107 != v226);
      }
      v179 = (_OWORD *)((char *)a2 + 4 * (int)v209);
      v180 = v179[240];
      v181 = v179[241];
      v182 = v179[243];
      v183 = v204;
      *(_OWORD *)v204[4].i8 = v179[242];
      *(_OWORD *)v183[6].i8 = v182;
      *(_OWORD *)v183->i8 = v180;
      *(_OWORD *)v183[2].i8 = v181;
      v184 = v179[244];
      v185 = v179[245];
      v186 = v179[247];
      *(_OWORD *)v183[12].i8 = v179[246];
      *(_OWORD *)v183[14].i8 = v186;
      *(_OWORD *)v183[8].i8 = v184;
      *(_OWORD *)v183[10].i8 = v185;
      v19 = v207;
      v27 = (int)v207[1153];
      a4 = &v208[v27];
      v34 = (_DWORD *)((char *)v34 + v27);
      v240 += 2 * v27;
      v30 = v210 + 1;
      v28 = (int)v207[1151];
    }
    while (v210 + 1 < v28);
    v24 = v207[1152];
    v23 = v207[1154];
  }
  a2[544].i32[1] = *(_DWORD *)(v205 + 4 * ((int)v28 - 1));
  memmove(a2, (char *)a2 + 2 * v24, 2 * v23);
  return memmove(&a2[160], (char *)&a2[160] + 4 * v19[1152], 4 * (int)v19[1154]);
}

uint64_t silk_decode_indices(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  unsigned int v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  char v20;
  uint64_t result;
  _BYTE v22[16];
  _WORD v23[16];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (a4 || *(_DWORD *)(a1 + 4 * a3 + 2416))
    v8 = ec_dec_icdf(a2, silk_type_offset_VAD_iCDF, 8) + 2;
  else
    v8 = ec_dec_icdf(a2, silk_type_offset_no_VAD_iCDF, 8);
  *(_BYTE *)(a1 + 2789) = v8 >> 1;
  *(_BYTE *)(a1 + 2790) = v8 & 1;
  if (a5 == 2)
  {
    v9 = ec_dec_icdf(a2, silk_delta_gain_iCDF, 8);
  }
  else
  {
    *(_BYTE *)(a1 + 2760) = 8 * ec_dec_icdf(a2, &silk_gain_iCDF[8 * (char)(v8 >> 1)], 8);
    v9 = *(_BYTE *)(a1 + 2760) + ec_dec_icdf(a2, silk_uniform8_iCDF, 8);
  }
  *(_BYTE *)(a1 + 2760) = v9;
  if (*(int *)(a1 + 2324) > 1)
  {
    v10 = 2761;
    do
    {
      *(_BYTE *)(a1 + v10) = ec_dec_icdf(a2, silk_delta_gain_iCDF, 8);
      v11 = v10 - 2759;
      ++v10;
    }
    while (v11 < *(int *)(a1 + 2324));
  }
  v12 = ec_dec_icdf(a2, (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 2752) + 16)+ **(__int16 **)(a1 + 2752) * (uint64_t)(*(char *)(a1 + 2789) >> 1)), 8);
  *(_BYTE *)(a1 + 2768) = v12;
  silk_NLSF_unpack((uint64_t)v23, (uint64_t)v22, *(_QWORD *)(a1 + 2752), v12);
  v13 = *(_QWORD *)(a1 + 2752);
  if (*(__int16 *)(v13 + 2) >= 1)
  {
    v14 = 0;
    do
    {
      v15 = ec_dec_icdf(a2, (unsigned __int8 *)(*(_QWORD *)(v13 + 40) + (__int16)v23[v14]), 8);
      if (v15 == 8)
      {
        LOBYTE(v15) = ec_dec_icdf(a2, silk_NLSF_EXT_iCDF, 8) + 8;
      }
      else if (!v15)
      {
        v15 = -(int)ec_dec_icdf(a2, silk_NLSF_EXT_iCDF, 8);
      }
      *(_BYTE *)(a1 + 2769 + v14) = v15 - 4;
      v13 = *(_QWORD *)(a1 + 2752);
      ++v14;
    }
    while (v14 < *(__int16 *)(v13 + 2));
  }
  if (*(_DWORD *)(a1 + 2324) == 4)
    v16 = ec_dec_icdf(a2, silk_NLSF_interpolation_factor_iCDF, 8);
  else
    v16 = 4;
  *(_BYTE *)(a1 + 2791) = v16;
  if (*(_BYTE *)(a1 + 2789) == 2)
  {
    if (a5 == 2 && *(_DWORD *)(a1 + 2408) == 2 && (v17 = ec_dec_icdf(a2, silk_pitch_delta_iCDF, 8), v17 << 16 >= 1))
    {
      v18 = v17 + *(_WORD *)(a1 + 2412) - 9;
    }
    else
    {
      *(_WORD *)(a1 + 2786) = (*(_DWORD *)(a1 + 2316) >> 1) * ec_dec_icdf(a2, silk_pitch_lag_iCDF, 8);
      v18 = *(_WORD *)(a1 + 2786) + ec_dec_icdf(a2, *(unsigned __int8 **)(a1 + 2384), 8);
    }
    *(_WORD *)(a1 + 2786) = v18;
    *(_WORD *)(a1 + 2412) = v18;
    *(_BYTE *)(a1 + 2788) = ec_dec_icdf(a2, *(unsigned __int8 **)(a1 + 2392), 8);
    *(_BYTE *)(a1 + 2792) = ec_dec_icdf(a2, silk_LTP_per_index_iCDF, 8);
    if (*(int *)(a1 + 2324) >= 1)
    {
      v19 = 0;
      do
        *(_BYTE *)(a1 + 2764 + v19++) = ec_dec_icdf(a2, (unsigned __int8 *)*(&silk_LTP_gain_iCDF_ptrs + *(char *)(a1 + 2792)), 8);
      while (v19 < *(int *)(a1 + 2324));
    }
    if (a5)
      v20 = 0;
    else
      v20 = ec_dec_icdf(a2, silk_LTPscale_iCDF, 8);
    *(_BYTE *)(a1 + 2793) = v20;
  }
  *(_DWORD *)(a1 + 2408) = *(char *)(a1 + 2789);
  result = ec_dec_icdf(a2, silk_uniform4_iCDF, 8);
  *(_BYTE *)(a1 + 2794) = result;
  return result;
}

uint64_t silk_NLSF_unpack(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned int v6;
  _WORD *v7;
  _BYTE *v8;

  if (*(__int16 *)(a3 + 2) >= 1)
  {
    v4 = 0;
    v5 = (unsigned __int8 *)(*(_QWORD *)(a3 + 32) + *(unsigned __int16 *)(a3 + 2) * a4 / 2);
    do
    {
      v6 = *v5++;
      v7 = (_WORD *)(result + 2 * v4);
      *v7 = (v6 >> 1) & 7 | (8 * ((v6 >> 1) & 7));
      v8 = (_BYTE *)(a2 + v4);
      *v8 = *(_BYTE *)(*(_QWORD *)(a3 + 24) + (((int)(v6 << 31) >> 31) & (*(__int16 *)(a3 + 2) - 1)) + (int)v4);
      v7[1] = (v6 >> 5) | (8 * (v6 >> 5));
      v8[1] = *(_BYTE *)(*(_QWORD *)(a3 + 24) + ((*(__int16 *)(a3 + 2) - 1) & ((int)(v6 << 27) >> 31)) + (int)v4 + 1);
      v4 += 2;
    }
    while (v4 < *(__int16 *)(a3 + 2));
  }
  return result;
}

uint64_t silk_stereo_find_predictor(int *a1, unint64_t a2, __int16 *a3, int *a4, int a5, int a6)
{
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  uint64_t result;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  char v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  unsigned int v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v82;

  v81 = 0;
  v82 = 0;
  silk_sum_sqr_shift((unsigned int *)&v81 + 1, (int *)&v82 + 1, a2, a5);
  silk_sum_sqr_shift((unsigned int *)&v81, (int *)&v82, (uint64_t)a3, a5);
  if (SHIDWORD(v82) <= (int)v82)
    v12 = v82;
  else
    v12 = HIDWORD(v82);
  v13 = (v12 & 1) + v12;
  v14 = SHIDWORD(v81) >> (v13 - BYTE4(v82));
  if (v14 <= 1)
    v14 = 1;
  LODWORD(v81) = (int)v81 >> (v13 - v82);
  HIDWORD(v81) = v14;
  v15 = silk_inner_prod_aligned_scale(a2, a3, v13, a5);
  v16 = v15;
  v17 = HIDWORD(v81);
  if (v15 >= 0)
    v18 = v15;
  else
    v18 = -v15;
  v19 = __clz(v18);
  if (v81 >= 0)
    v20 = HIDWORD(v81);
  else
    v20 = -HIDWORD(v81);
  v21 = __clz(v20);
  v22 = HIDWORD(v81) << (v21 - 1);
  v23 = 0x1FFFFFFF / (v22 >> 16);
  v24 = (v15 << (v19 - 1) >> 16) * v23 + (((unsigned __int16)(v15 << (v19 - 1)) * v23) >> 16);
  v25 = (v15 << (v19 - 1)) - (((unint64_t)(v24 * (uint64_t)v22) >> 29) & 0xFFFFFFF8);
  v26 = v24 + (v25 >> 16) * v23 + (((unsigned __int16)v25 * v23) >> 16);
  v27 = v19 - v21;
  if ((v27 + 16) >= 0x20)
    v28 = 0;
  else
    v28 = v26 >> (v27 + 16);
  v29 = (int)0x80000000 >> (-16 - v27);
  if (v26 > v29)
    v29 = v26;
  if (v26 <= (int)(0x7FFFFFFFu >> (-16 - v27)))
    v30 = v29;
  else
    v30 = 0x7FFFFFFFu >> (-16 - v27);
  v31 = v30 << (-16 - v27);
  if (v27 <= -17)
    v32 = v31;
  else
    v32 = v28;
  if (v32 <= -16384)
    v32 = -16384;
  if (v32 >= 0x4000)
    result = 0x4000;
  else
    result = v32;
  v34 = ((int)result >> 16) * result + (((unsigned __int16)result * (int)result) >> 16);
  if (v34 >= 0)
    v35 = ((int)result >> 16) * result + (((unsigned __int16)result * (int)result) >> 16);
  else
    v35 = -v34;
  if (a6 <= v35)
    LOWORD(v36) = v35;
  else
    LOWORD(v36) = a6;
  v37 = v13 >> 1;
  v38 = *a4;
  if (v81 <= 0)
  {
    v50 = 0;
    v36 = (__int16)v36;
    v46 = (__int16)v36 * (-v38 >> 16);
  }
  else
  {
    v39 = __clz(HIDWORD(v81));
    v40 = HIDWORD(v81) >> (24 - v39);
    LOBYTE(v41) = BYTE4(v81);
    v42 = HIDWORD(v81) << (v39 - 24);
    if (v39 != 24)
    {
      v41 = (HIDWORD(v81) << (v39 + 8)) | v40;
      if (HIDWORD(v81) <= 0x7F)
        LOBYTE(v41) = (HIDWORD(v81) >> (56 - v39)) | v42;
    }
    v43 = v41 & 0x7F;
    if ((v39 & 1) != 0)
      v44 = 0x8000;
    else
      v44 = 46214;
    v45 = v44 >> (v39 >> 1);
    v36 = (__int16)v36;
    v46 = ((int)(((v45 + ((213 * v45 * v43) >> 16)) << v37) - v38) >> 16) * (__int16)v36;
    v47 = (HIDWORD(v81) << (v39 + 8)) | v40;
    v48 = (HIDWORD(v81) >> (56 - v39)) | v42;
    if (HIDWORD(v81) > 0x7F)
      LOBYTE(v48) = v47;
    if (v39 == 24)
      v49 = BYTE4(v81);
    else
      v49 = v48;
    v50 = v45 + ((213 * v45 * (v49 & 0x7F)) >> 16);
  }
  v51 = v46 + v38 + (((unsigned __int16)((v50 << v37) - v38) * v36) >> 16);
  *a4 = v51;
  v52 = v81
      - 16 * (result * (v16 >> 16) + ((int)(result * (unsigned __int16)v16) >> 16))
      + ((v34 * (v17 >> 16) + ((v34 * (unsigned __int16)v17) >> 16)) << 6);
  if ((int)v52 < 1)
  {
    v60 = 0;
    v63 = 0;
  }
  else
  {
    v53 = __clz(v52);
    v54 = v52 >> (24 - v53);
    LOBYTE(v55) = v52;
    v56 = v52 << (v53 - 24);
    if (v53 != 24)
    {
      v55 = (v52 << (v53 + 8)) | v54;
      if (v52 <= 0x7F)
        LOBYTE(v55) = (v52 >> (56 - v53)) | v56;
    }
    v57 = v55 & 0x7F;
    if ((v53 & 1) != 0)
      v58 = 0x8000;
    else
      v58 = 46214;
    v59 = v58 >> (v53 >> 1);
    v60 = (v59 + ((213 * v59 * v57) >> 16)) << v37;
    v61 = (v52 << (v53 + 8)) | v54;
    v62 = (v52 >> (56 - v53)) | v56;
    if (v52 > 0x7F)
      LOBYTE(v62) = v61;
    if (v53 != 24)
      LOBYTE(v52) = v62;
    v63 = v59 + ((213 * v59 * (v52 & 0x7F)) >> 16);
  }
  v64 = a4[1] + ((int)(v60 - a4[1]) >> 16) * v36 + (((unsigned __int16)((v63 << v37) - a4[1]) * v36) >> 16);
  a4[1] = v64;
  if (v51 <= 1)
    v65 = 1;
  else
    v65 = v51;
  if (v64 >= 0)
    v66 = v64;
  else
    v66 = -v64;
  v67 = __clz(v66);
  v68 = v64 << (v67 - 1);
  v69 = __clz(v65);
  v70 = v65 << (v69 - 1);
  v71 = 0x1FFFFFFF / (v70 >> 16);
  v72 = (v68 >> 16) * v71 + (((unsigned __int16)v68 * v71) >> 16);
  v73 = v68 - (((unint64_t)(v72 * (uint64_t)v70) >> 29) & 0xFFFFFFF8);
  v74 = v72 + (v73 >> 16) * v71 + (((unsigned __int16)v73 * v71) >> 16);
  v75 = v67 - v69;
  if (v67 - v69 + 15 >= 0x20)
    v76 = 0;
  else
    v76 = v74 >> (v75 + 15);
  v77 = (int)0x80000000 >> (-15 - v75);
  if (v74 > v77)
    v77 = v74;
  if (v74 <= (int)(0x7FFFFFFFu >> (-15 - v75)))
    v78 = v77;
  else
    v78 = 0x7FFFFFFFu >> (-15 - v75);
  v79 = v78 << (-15 - v75);
  if (v75 > -16)
    v79 = v76;
  v80 = v79 & ~(v79 >> 31);
  if (v80 >= 0x7FFF)
    v80 = 0x7FFF;
  *a1 = v80;
  return result;
}

uint64_t *silk_shell_encoder(uint64_t *result, int *a2)
{
  uint64_t *v3;
  uint64_t v4;
  const float *v5;
  const float *v6;
  int32x4_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  float32x4x2_t v28;
  float32x4x2_t v29;

  v3 = result;
  v4 = 0;
  v27 = *MEMORY[0x24BDAC8D0];
  v5 = (const float *)a2;
  do
  {
    v28 = vld2q_f32(v5);
    v5 += 8;
    *(int32x4_t *)((char *)&v19 + v4) = vaddq_s32((int32x4_t)v28.val[1], (int32x4_t)v28.val[0]);
    v4 += 16;
  }
  while (v4 != 32);
  v6 = (const float *)&v19;
  v29 = vld2q_f32(v6);
  v7 = vaddq_s32((int32x4_t)v29.val[1], (int32x4_t)v29.val[0]);
  v8 = v7.i32[1];
  v9 = v7.i32[2];
  v10 = v7.i32[0];
  v11 = v7.i32[1] + v7.i32[0];
  v18 = v7.i32[3];
  v12 = v7.i32[3] + v7.i32[2];
  v13 = v7.i32[3] + v7.i32[2] + v7.i32[1] + v7.i32[0];
  if (v13 >= 1)
    result = ec_enc_icdf(result, v7.i32[1] + v7.i32[0], (uint64_t)&silk_shell_code_table3[silk_shell_code_table_offsets[v13]], 8);
  if (v11 >= 1)
    result = ec_enc_icdf(v3, v10, (uint64_t)&silk_shell_code_table2[silk_shell_code_table_offsets[v11]], 8);
  v14 = v19;
  if (v10 >= 1)
    result = ec_enc_icdf(v3, v19, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v10]], 8);
  if ((int)v14 >= 1)
    result = ec_enc_icdf(v3, *a2, (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v14]], 8);
  if (v20 >= 1)
    result = ec_enc_icdf(v3, a2[2], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v20]], 8);
  v15 = v21;
  if (v8 >= 1)
    result = ec_enc_icdf(v3, v21, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v8]], 8);
  if ((int)v15 >= 1)
    result = ec_enc_icdf(v3, a2[4], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v15]], 8);
  if (v22 >= 1)
    result = ec_enc_icdf(v3, a2[6], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v22]], 8);
  if (v12 >= 1)
    result = ec_enc_icdf(v3, v9, (uint64_t)&silk_shell_code_table2[silk_shell_code_table_offsets[v12]], 8);
  v16 = v23;
  if (v9 >= 1)
    result = ec_enc_icdf(v3, v23, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v9]], 8);
  if ((int)v16 >= 1)
    result = ec_enc_icdf(v3, a2[8], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v16]], 8);
  if (v24 >= 1)
    result = ec_enc_icdf(v3, a2[10], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v24]], 8);
  v17 = v25;
  if (v18 >= 1)
    result = ec_enc_icdf(v3, v25, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v18]], 8);
  if ((int)v17 >= 1)
    result = ec_enc_icdf(v3, a2[12], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v17]], 8);
  if (v26 >= 1)
    return ec_enc_icdf(v3, a2[14], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v26]], 8);
  return result;
}

uint64_t silk_shell_decoder(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t result;
  int v42;

  if (a3 < 1)
  {
    v10 = 0;
    v7 = 0;
  }
  else
  {
    v6 = ec_dec_icdf(a2, &silk_shell_code_table3[silk_shell_code_table_offsets[a3]], 8);
    v7 = a3 - v6;
    if (v6 < 1)
    {
      v10 = 0;
    }
    else
    {
      v8 = v6;
      v9 = ec_dec_icdf(a2, &silk_shell_code_table2[silk_shell_code_table_offsets[v6]], 8);
      v10 = v8 - v9;
      if (v9 > 0)
      {
        v11 = v9;
        v12 = ec_dec_icdf(a2, &silk_shell_code_table1[silk_shell_code_table_offsets[v9]], 8);
        v13 = v11 - v12;
        if (v12 < 1)
        {
          v15 = 0;
          v16 = 0;
        }
        else
        {
          v14 = v12;
          v15 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v12]], 8);
          v16 = v14 - v15;
        }
        *(_DWORD *)a1 = v15;
        *(_DWORD *)(a1 + 4) = v16;
        if (v13 < 1)
        {
          v17 = 0;
          v18 = 0;
        }
        else
        {
          v17 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v13]], 8);
          v18 = v13 - v17;
        }
        goto LABEL_9;
      }
    }
  }
  v17 = 0;
  v18 = 0;
  *(_QWORD *)a1 = 0;
LABEL_9:
  *(_DWORD *)(a1 + 8) = v17;
  *(_DWORD *)(a1 + 12) = v18;
  if (v10 <= 0)
  {
    v24 = 0;
    v25 = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    v19 = ec_dec_icdf(a2, &silk_shell_code_table1[silk_shell_code_table_offsets[v10]], 8);
    v20 = v10 - v19;
    if (v19 < 1)
    {
      v22 = 0;
      v23 = 0;
    }
    else
    {
      v21 = v19;
      v22 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v19]], 8);
      v23 = v21 - v22;
    }
    *(_DWORD *)(a1 + 16) = v22;
    *(_DWORD *)(a1 + 20) = v23;
    if (v20 < 1)
    {
      v24 = 0;
      v25 = 0;
    }
    else
    {
      v24 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v20]], 8);
      v25 = v20 - v24;
    }
  }
  *(_DWORD *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 28) = v25;
  if (v7 < 1)
  {
    v27 = 0;
  }
  else
  {
    v26 = ec_dec_icdf(a2, &silk_shell_code_table2[silk_shell_code_table_offsets[v7]], 8);
    v27 = v7 - v26;
    if (v26 > 0)
    {
      v28 = v26;
      v29 = ec_dec_icdf(a2, &silk_shell_code_table1[silk_shell_code_table_offsets[v26]], 8);
      v30 = v28 - v29;
      if (v29 < 1)
      {
        v32 = 0;
        v33 = 0;
      }
      else
      {
        v31 = v29;
        v32 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v29]], 8);
        v33 = v31 - v32;
      }
      *(_DWORD *)(a1 + 32) = v32;
      *(_DWORD *)(a1 + 36) = v33;
      if (v30 < 1)
      {
        v34 = 0;
        v35 = 0;
      }
      else
      {
        v34 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v30]], 8);
        v35 = v30 - v34;
      }
      goto LABEL_27;
    }
  }
  v34 = 0;
  v35 = 0;
  *(_QWORD *)(a1 + 32) = 0;
LABEL_27:
  *(_DWORD *)(a1 + 40) = v34;
  *(_DWORD *)(a1 + 44) = v35;
  if (v27 <= 0)
  {
    result = 0;
    v42 = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
  else
  {
    v36 = ec_dec_icdf(a2, &silk_shell_code_table1[silk_shell_code_table_offsets[v27]], 8);
    v37 = v27 - v36;
    if (v36 < 1)
    {
      v39 = 0;
      v40 = 0;
    }
    else
    {
      v38 = v36;
      v39 = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v36]], 8);
      v40 = v38 - v39;
    }
    *(_DWORD *)(a1 + 48) = v39;
    *(_DWORD *)(a1 + 52) = v40;
    if (v37 < 1)
    {
      result = 0;
      v42 = 0;
    }
    else
    {
      result = ec_dec_icdf(a2, &silk_shell_code_table0[silk_shell_code_table_offsets[v37]], 8);
      v42 = v37 - result;
    }
  }
  *(_DWORD *)(a1 + 56) = result;
  *(_DWORD *)(a1 + 60) = v42;
  return result;
}

int *silk_LP_variable_cutoff(int *result, uint64_t a2, int a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  char *v14;
  char *v15;
  char v16;
  uint64_t *v17;
  char *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char v25;
  char *v26;
  char *v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v3 = result[3];
  if (!v3)
    return result;
  v4 = result[2];
  v5 = 0x40000 - (v4 << 10);
  if (v5 >= 0x40000)
  {
    v30 = 0xAA4FADA0552B622;
    v31 = 89306658;
    v17 = &qword_214F96AAC;
LABEL_12:
    v29 = *v17;
    goto LABEL_13;
  }
  v6 = v5 >> 16;
  v7 = (unsigned __int16)(-1024 * v4);
  if (!(-1024 * (_WORD)v4))
  {
    v18 = (char *)&silk_Transition_LP_B_Q28 + 12 * v6;
    v30 = *(_QWORD *)v18;
    v31 = *((_DWORD *)v18 + 2);
    v17 = (uint64_t *)((char *)&silk_Transition_LP_A_Q28 + 8 * v6);
    goto LABEL_12;
  }
  if (v7 >= 0x8000)
  {
    v20 = 0;
    v21 = v6;
    v22 = v6 + 1;
    v23 = (char *)&silk_Transition_LP_B_Q28 + 12 * v6;
    do
    {
      *(_DWORD *)((char *)&v30 + v20) = *(_DWORD *)&v23[v20 + 12]
                                      + ((*(_DWORD *)&v23[v20 + 12] - *(_DWORD *)&v23[v20]) >> 16) * (__int16)v7
                                      + (((unsigned __int16)(*(_DWORD *)&v23[v20 + 12] - *(_WORD *)&v23[v20])
                                        * (__int16)v7) >> 16);
      v20 += 4;
    }
    while (v20 != 12);
    v24 = 0;
    v25 = 1;
    v26 = (char *)&silk_Transition_LP_A_Q28 + 8 * v22;
    v27 = (char *)&silk_Transition_LP_A_Q28 + 8 * v21;
    do
    {
      v28 = v25;
      *((_DWORD *)&v29 + v24) = *(_DWORD *)&v26[4 * v24]
                              + ((*(_DWORD *)&v26[4 * v24] - *(_DWORD *)&v27[4 * v24]) >> 16) * (__int16)v7
                              + (((unsigned __int16)(*(_DWORD *)&v26[4 * v24] - *(_WORD *)&v27[4 * v24]) * (__int16)v7) >> 16);
      v24 = 1;
      v25 = 0;
    }
    while ((v28 & 1) != 0);
  }
  else
  {
    v8 = 0;
    v9 = v6;
    v10 = v6 + 1;
    v11 = (char *)&silk_Transition_LP_B_Q28 + 12 * v6;
    do
    {
      *(_DWORD *)((char *)&v30 + v8) = *(_DWORD *)&v11[v8]
                                     + ((*(_DWORD *)&v11[v8 + 12] - *(_DWORD *)&v11[v8]) >> 16) * v7
                                     + (((unsigned __int16)(*(_WORD *)&v11[v8 + 12] - *(_DWORD *)&v11[v8]) * v7) >> 16);
      v8 += 4;
    }
    while (v8 != 12);
    v12 = 0;
    v13 = 1;
    v14 = (char *)&silk_Transition_LP_A_Q28 + 8 * v9;
    v15 = (char *)&silk_Transition_LP_A_Q28 + 8 * v10;
    do
    {
      v16 = v13;
      *((_DWORD *)&v29 + v12) = *(_DWORD *)&v14[4 * v12]
                              + ((*(_DWORD *)&v15[4 * v12] - *(_DWORD *)&v14[4 * v12]) >> 16) * v7
                              + (((unsigned __int16)(*(_WORD *)&v15[4 * v12] - *(_DWORD *)&v14[4 * v12]) * v7) >> 16);
      v12 = 1;
      v13 = 0;
    }
    while ((v16 & 1) != 0);
  }
LABEL_13:
  v19 = (v4 + v3) & ~((v4 + v3) >> 31);
  if (v19 >= 256)
    v19 = 256;
  result[2] = v19;
  return (int *)silk_biquad_alt(a2, (int *)&v30, &v29, result, a2, a3, 1);
}

void *silk_process_NLSFs(uint64_t a1, __int16 *a2, __int16 *a3, __int16 *a4)
{
  char *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  unsigned __int16 *v16;
  __int16 *v17;
  int v18;
  _WORD v20[16];
  __int16 v21[16];
  __int16 v22[16];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v8 = (char *)(a1 + 4813);
  v9 = ((59246 * *(__int16 *)(a1 + 4556)) >> 16) - 5 * *(__int16 *)(a1 + 4556) + 3146;
  if (*(_DWORD *)(a1 + 4604) == 2)
    v10 = v9 >> 1;
  else
    v10 = 0;
  v11 = v10 + v9;
  silk_NLSF_VQ_weights_laroia(v21, a3, *(_DWORD *)(a1 + 4664));
  v12 = 0;
  if (*(_DWORD *)(a1 + 4656) == 1)
  {
    v13 = v8[2];
    if (v13 > 3)
    {
      v12 = 0;
    }
    else
    {
      silk_interpolate(v22, a4, a3, v13, *(_DWORD *)(a1 + 4664));
      silk_NLSF_VQ_weights_laroia(v20, v22, *(_DWORD *)(a1 + 4664));
      v14 = *(unsigned int *)(a1 + 4664);
      if ((int)v14 >= 1)
      {
        v15 = (__int16)((v8[2] * (unsigned __int16)v8[2]) << 11);
        v16 = v20;
        v17 = v21;
        do
        {
          v18 = *v16++;
          *v17 = ((__int16)v18 >> 15) * v15 + ((v18 * v15) >> 16) + (*v17 >> 1);
          ++v17;
          --v14;
        }
        while (v14);
      }
      v12 = 1;
    }
  }
  silk_NLSF_encode((char *)(a1 + 4792), a3, *(__int16 **)(a1 + 4736), v21, v11, *(unsigned int *)(a1 + 4692), *v8);
  silk_NLSF2A(a2 + 16, a3, *(_DWORD *)(a1 + 4664));
  if (!v12)
    return memcpy(a2, a2 + 16, 2 * *(int *)(a1 + 4664));
  silk_interpolate(v22, a4, a3, v8[2], *(_DWORD *)(a1 + 4664));
  return (void *)silk_NLSF2A(a2, v22, *(_DWORD *)(a1 + 4664));
}

__n128 silk_decode_core(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  int v9;
  size_t v10;
  char *v11;
  size_t v12;
  char *v13;
  size_t v14;
  __n128 *v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  uint64_t v26;
  int64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  _WORD *v47;
  uint64_t v48;
  signed int v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  signed int v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int32x4_t v67;
  __int16 *v68;
  int v69;
  int v70;
  BOOL v71;
  BOOL v72;
  uint64_t v73;
  _WORD *v74;
  int v75;
  _BOOL4 v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  uint64_t v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  char *v95;
  int *v96;
  int *v97;
  int v98;
  int v99;
  uint64_t v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int *v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  uint64_t v129;
  int v130;
  unsigned int v131;
  __int16 v132;
  int v133;
  __n128 *v134;
  __n128 v135;
  __n128 v136;
  __n128 v137;
  __n128 v138;
  __n128 *v139;
  __n128 result;
  __n128 v141;
  uint64_t v142;
  __n128 *v143;
  char *v144;
  char *v145;
  char *v146;
  uint64_t v147;
  int v148;
  char *v149;
  char *v150;
  int v151;
  uint64_t v152;
  char *v153;
  uint64_t v154;
  unint64_t v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  _WORD *v175;
  char *v176;
  __int16 v177;
  __int16 v178;
  __int16 v179;
  __int16 v180;
  __int16 v181;
  __int16 v182;
  __int16 v183;
  __int16 v184;
  __int16 v185;
  __int16 v186;
  __int16 v187;
  __int16 v188;
  __int16 v189;
  __int16 v190;
  __int16 v191;
  __int16 v192;
  uint64_t v193;

  v144 = a3;
  v6 = a1;
  v193 = *MEMORY[0x24BDAC8D0];
  v7 = *(int *)(a1 + 2336);
  v8 = (char *)&v142 - ((2 * v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v8, 2 * v7);
  v9 = *(_DWORD *)(v6 + 2328);
  v10 = 4 * (v9 + (int)v7);
  v11 = (char *)&v142 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v11, v10);
  v12 = 4 * *(int *)(v6 + 2332);
  v13 = (char *)&v142 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  v14 = v12 + 64;
  v15 = (__n128 *)((char *)&v142 - ((v12 + 79) & 0xFFFFFFFFFFFFFFF0));
  v148 = *(char *)(v6 + 2791);
  if (v9 >= 1)
  {
    v16 = 0;
    v17 = *(char *)(v6 + 2794);
    v18 = 16 * silk_Quantization_Offsets_Q10[2 * (*(char *)(v6 + 2789) >> 1) + *(char *)(v6 + 2790)];
    do
    {
      v19 = 196314165 * v17 + 907633515;
      v20 = *(_DWORD *)(a4 + 4 * v16) << 14;
      v21 = (v20 | 0x500) & (v20 >> 31);
      if (v20 > 0)
        v21 = v20 - 1280;
      v22 = v21 + v18;
      if (v19 < 0)
        v22 = -v22;
      *(_DWORD *)(v6 + 4 + 4 * v16) = v22;
      v17 = *(_DWORD *)(a4 + 4 * v16++) + v19;
    }
    while (v16 < *(int *)(v6 + 2328));
  }
  bzero(v15, v14);
  v23 = *(__n128 *)(v6 + 1300);
  *v15 = *(__n128 *)(v6 + 1284);
  v15[1] = v23;
  v24 = *(__n128 *)(v6 + 1316);
  v25 = *(__n128 *)(v6 + 1332);
  v143 = (__n128 *)(v6 + 1284);
  v15[2] = v24;
  v15[3] = v25;
  if (*(int *)(v6 + 2324) >= 1)
  {
    v26 = a2;
    v27 = 0;
    v28 = (char *)(v6 + 4);
    v151 = *(_DWORD *)(v6 + 2336);
    v145 = v11 - 8;
    v29 = v144;
    v150 = v11;
    v149 = v13;
    v152 = v26;
    v147 = v6;
    v146 = v8;
    do
    {
      v155 = v27;
      v30 = v26 + 32 * (v27 >> 1) + 32;
      __memcpy_chk();
      v26 = v152;
      v31 = v155;
      v32 = *(_DWORD *)(v152 + 4 * v155 + 16);
      if (v32 >= 0)
        v33 = *(_DWORD *)(v152 + 4 * v155 + 16);
      else
        v33 = -v32;
      v34 = __clz(v33);
      v35 = v32 << (v34 - 1);
      v36 = 0x1FFFFFFF / (v35 >> 16);
      v37 = (__int16)v36;
      v38 = (v35 >> 16) * v37 + (((unsigned __int16)v35 * v37) >> 16);
      v39 = (v36 << 16)
          - 8 * v38 * (((v36 >> 15) + 1) >> 1)
          + ((-8 * v38) >> 16) * v37
          + ((((-8 * v38) & 0xFFF8) * v37) >> 16);
      v40 = v33 >> 17;
      v41 = v39 >> (15 - v34);
      v42 = (int)0x80000000 >> (v34 - 15);
      if (v39 > v42)
        v42 = v39;
      if (v39 <= (int)(0x7FFFFFFFu >> (v34 - 15)))
        v43 = v42;
      else
        v43 = 0x7FFFFFFFu >> (v34 - 15);
      v44 = v43 << (v34 - 15);
      if (v40)
        v45 = v41;
      else
        v45 = v44;
      v46 = *(_DWORD *)v6;
      v47 = v29;
      if (v32 == *(_DWORD *)v6)
      {
        v48 = v30;
        v49 = 0x10000;
      }
      else
      {
        v50 = 0;
        if (v46 >= 0)
          v51 = *(_DWORD *)v6;
        else
          v51 = -v46;
        v52 = __clz(v51);
        v53 = v46 << (v52 - 1);
        v54 = (v53 >> 16) * v37 + (((unsigned __int16)v53 * v37) >> 16);
        v55 = v53 - (((unint64_t)(v54 * (uint64_t)v35) >> 29) & 0xFFFFFFF8);
        v56 = v54 + (v55 >> 16) * v37 + (((unsigned __int16)v55 * v37) >> 16);
        v57 = v52 - v34;
        if ((v57 + 29) >= 0x30)
          v58 = 0;
        else
          v58 = v56 >> (v57 + 13);
        v59 = (int)0x80000000 >> (-13 - v57);
        if (v56 > v59)
          v59 = v56;
        if (v56 <= (int)(0x7FFFFFFFu >> (-13 - v57)))
          v60 = v59;
        else
          v60 = 0x7FFFFFFFu >> (-13 - v57);
        v61 = v60 << (-13 - v57);
        if (v57 <= -14)
          v49 = v61;
        else
          v49 = v58;
        v62 = vdupq_n_s32(v49 >> 16);
        v63 = vdupq_n_s32((unsigned __int16)v49);
        v64 = vdupq_n_s32(v49);
        v65.i64[0] = 0x100000001;
        v65.i64[1] = 0x100000001;
        do
        {
          v66 = (int32x4_t)v15[v50];
          v67 = vshrq_n_s32(vshlq_n_s32(v66, 0x10uLL), 0x10uLL);
          v15[v50++] = (__n128)vmlaq_s32(vsraq_n_s32(vmulq_s32(v67, v62), vmulq_s32(v67, v63), 0x10uLL), vhaddq_s32(vshrq_n_s32(v66, 0xFuLL), v65), v64);
        }
        while (v50 != 4);
        v48 = v30;
      }
      v68 = (__int16 *)(v152 + 2 * (5 * v31) + 96);
      v69 = *(unsigned __int8 *)(v6 + 2789);
      *(_DWORD *)v6 = v32;
      v70 = *(_DWORD *)(v6 + 4184);
      v153 = v28;
      if (!v70 || (*(_DWORD *)(v6 + 4188) == 2 ? (v71 = v31 > 1) : (v71 = 1), !v71 ? (v72 = v69 == 2) : (v72 = 1), v72))
      {
        if (v69 != 2)
        {
          v73 = *(unsigned int *)(v6 + 2332);
          v176 = v28;
          v74 = v47;
          goto LABEL_78;
        }
        v175 = v47;
        v75 = *(_DWORD *)(v152 + 4 * v31);
      }
      else
      {
        v175 = v47;
        *(_QWORD *)v68 = 0;
        *(_WORD *)(v152 + 2 * (5 * v31) + 104) = 0;
        *(_WORD *)(v152 + 2 * (5 * v31) + 100) = 4096;
        v75 = *(_DWORD *)(v6 + 2308);
        *(_DWORD *)(v152 + 4 * v31) = v75;
      }
      v77 = v148 < 4 && v31 == 2;
      if (!v31 || v77)
      {
        v80 = *(_DWORD *)(v6 + 2336);
        v81 = *(_DWORD *)(v6 + 2340);
        v82 = *(_DWORD *)(v6 + 2332);
        if (v31 == 2)
        {
          memcpy((void *)(v6 + 2 * v80 + 1348), v144, 4 * v82);
          LODWORD(v31) = v155;
          v82 = *(_DWORD *)(v6 + 2332);
          v83 = *(_DWORD *)(v6 + 2336);
          v84 = *(_DWORD *)(v6 + 2340);
        }
        else
        {
          v84 = *(_DWORD *)(v6 + 2340);
          v83 = *(_DWORD *)(v6 + 2336);
        }
        silk_LPC_analysis_filter(&v8[2 * (v80 - v75 - v81) - 4], v6 + 2 * (v80 - v75 - v81 - 2 + v82 * (int)v31) + 1348, v48, v83 - (v80 - v75 - v81 - 2), v84);
        v31 = v155;
        if (v155)
        {
          v11 = v150;
          v13 = v149;
          v26 = v152;
        }
        else
        {
          v26 = v152;
          v45 = 4
              * (*(__int16 *)(v152 + 136) * (v45 >> 16) + ((*(__int16 *)(v152 + 136) * (unsigned __int16)v45) >> 16));
          v11 = v150;
          v13 = v149;
        }
        if (v75 >= -1)
        {
          v85 = (v75 + 2);
          v86 = v151 - 1;
          v87 = *(_DWORD *)(v6 + 2336) - 1;
          do
          {
            v88 = *(__int16 *)&v8[2 * v87];
            *(_DWORD *)&v11[4 * v86--] = (v45 >> 16) * v88 + (((unsigned __int16)v45 * v88) >> 16);
            --v87;
            --v85;
          }
          while (v85);
        }
      }
      else if (v49 != 0x10000 && v75 >= -1)
      {
        v78 = (v75 + 2);
        v79 = v151 - 1;
        do
        {
          *(_DWORD *)&v11[4 * v79] = (__int16)*(_DWORD *)&v11[4 * v79] * (v49 >> 16)
                                   + (((__int16)*(_DWORD *)&v11[4 * v79] * (unsigned __int16)v49) >> 16)
                                   + (((*(int *)&v11[4 * v79] >> 15) + 1) >> 1) * v49;
          --v79;
          --v78;
        }
        while (v78);
      }
      v154 = *(unsigned int *)(v6 + 2332);
      if ((int)v154 >= 1)
      {
        v89 = 0;
        v90 = *v68;
        v91 = v68[1];
        v92 = v68[2];
        v93 = v68[3];
        v94 = v68[4];
        v95 = &v11[4 * v151];
        v96 = (int *)&v145[4 * (v151 - v75) + 8];
        v97 = v96;
        v28 = v153;
        v73 = v154;
        do
        {
          v98 = v97[1];
          ++v97;
          v99 = *(_DWORD *)&v28[4 * v89]
              + 2
              * ((v96[2] >> 16) * v90
               + (((unsigned __int16)v96[2] * v90) >> 16)
               + (v98 >> 16) * v91
               + (((unsigned __int16)v98 * v91) >> 16)
               + (*v96 >> 16) * v92
               + (((unsigned __int16)*v96 * v92) >> 16)
               + (*(v96 - 1) >> 16) * v93
               + (((unsigned __int16)*(v96 - 1) * v93) >> 16)
               + (*(v96 - 2) >> 16) * v94
               + (((unsigned __int16)*(v96 - 2) * v94) >> 16))
              + 4;
          *(_DWORD *)&v13[4 * v89] = v99;
          *(_DWORD *)&v95[4 * v89++] = 2 * v99;
          v96 = v97;
        }
        while (v73 != v89);
        v151 += v89;
        v176 = v13;
        v31 = v155;
        v74 = v175;
LABEL_78:
        v154 = v73;
        if ((int)v73 >= 1)
        {
          v100 = 0;
          v172 = *(_DWORD *)(v6 + 2340);
          v170 = v178;
          v171 = v177;
          v168 = v180;
          v169 = v179;
          v101 = v181;
          LODWORD(v175) = v182;
          v173 = v172 >> 1;
          v174 = v183;
          v102 = v184;
          v103 = v185;
          v104 = v186;
          v164 = v187;
          v162 = v188;
          v163 = v185;
          v159 = v190;
          v160 = v189;
          v156 = v192;
          v157 = v191;
          v105 = v15[3].n128_i32[3];
          v106 = v15[3].n128_i32[1];
          v107 = v15[2].n128_i32[3];
          v108 = v15[2].n128_i32[1];
          v109 = v15[1].n128_i32[3];
          v165 = v186;
          v161 = v184;
          v158 = v181;
          do
          {
            v110 = v105 >> 16;
            v111 = (unsigned __int16)v105 * v171;
            v112 = (int *)v15 + v100;
            v113 = v112[14];
            v114 = (unsigned __int16)v106 * v169;
            v115 = v173
                 + v110 * v171
                 + (v111 >> 16)
                 + (v113 >> 16) * v170
                 + (((unsigned __int16)v113 * v170) >> 16)
                 + (v106 >> 16) * v169;
            v116 = v112[12];
            v117 = v115 + (v114 >> 16) + (v116 >> 16) * v168 + (((unsigned __int16)v116 * v168) >> 16);
            v118 = (unsigned __int16)v107 * v101;
            v119 = v117 + (v107 >> 16) * v101;
            v120 = v112[10];
            v121 = v119 + (v118 >> 16) + (v120 >> 16) * (_DWORD)v175 + (((unsigned __int16)v120 * (int)v175) >> 16);
            v122 = (unsigned __int16)v108 * v174;
            v123 = v121 + (v108 >> 16) * v174;
            v124 = v112[8];
            v125 = v123
                 + (v122 >> 16)
                 + (v124 >> 16) * v102
                 + (((unsigned __int16)v124 * v102) >> 16)
                 + (v109 >> 16) * v103
                 + (((unsigned __int16)v109 * v103) >> 16)
                 + (v112[6] >> 16) * v104
                 + (((unsigned __int16)v112[6] * v104) >> 16);
            if (v172 == 16)
            {
              v126 = v112[4];
              v127 = v112[5] >> 16;
              v128 = (unsigned __int16)v112[5] * v164;
              v166 = (unsigned __int16)v126 * v162;
              v167 = v126 >> 16;
              v129 = v100 + 1;
              v101 = v158;
              v102 = v161;
              v103 = v163;
              v104 = v165;
              v125 += v127 * v164
                    + (v128 >> 16)
                    + v167 * v162
                    + (v166 >> 16)
                    + (v112[3] >> 16) * v160
                    + (((unsigned __int16)v112[3] * v160) >> 16)
                    + (v112[2] >> 16) * v159
                    + (((unsigned __int16)v112[2] * v159) >> 16)
                    + (v15->n128_i32[v100 + 1] >> 16) * v157
                    + (((unsigned __int16)v15->n128_u32[v100 + 1] * v157) >> 16)
                    + (*v112 >> 16) * v156
                    + (((unsigned __int16)*v112 * v156) >> 16);
            }
            else
            {
              v129 = v100 + 1;
            }
            v105 = *(_DWORD *)&v176[4 * v100] + 16 * v125;
            v15[4].n128_u32[v100] = v105;
            v130 = v105 * (((v32 >> 21) + 1) >> 1)
                 + (v105 >> 16) * (__int16)(v32 >> 6)
                 + (((unsigned __int16)v105 * (__int16)(v32 >> 6)) >> 16);
            v131 = ((v130 >> 7) + 1) >> 1;
            if (v130 < -8388736)
              LOWORD(v131) = 0x8000;
            if (v130 <= 8388479)
              v132 = v131;
            else
              v132 = 0x7FFF;
            v74[v100] = v132;
            v109 = v124;
            v108 = v120;
            v107 = v116;
            v106 = v113;
            v100 = v129;
          }
          while (v129 != v73);
          v26 = v152;
          v28 = v153;
          v6 = v147;
          v8 = v146;
          v11 = v150;
          v13 = v149;
          v31 = v155;
        }
        goto LABEL_91;
      }
      v28 = v153;
      v74 = v175;
LABEL_91:
      v133 = v154;
      v134 = (__n128 *)((char *)v15 + 4 * (int)v154);
      v135 = *v134;
      v136 = v134[1];
      v137 = v134[3];
      v15[2] = v134[2];
      v15[3] = v137;
      *v15 = v135;
      v15[1] = v136;
      v28 += 4 * v133;
      v29 = (char *)&v74[v133];
      v27 = v31 + 1;
    }
    while (v27 < *(int *)(v6 + 2324));
  }
  v138 = v15[1];
  v139 = v143;
  *v143 = *v15;
  v139[1] = v138;
  result = v15[2];
  v141 = v15[3];
  v139[2] = result;
  v139[3] = v141;
  return result;
}

_DWORD *silk_stereo_quant_pred(_DWORD *result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  char v4;
  uint64_t v5;
  char v6;
  _BYTE *v7;
  _BYTE *v8;
  unsigned int v9;
  __int16 *v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;

  v2 = 0;
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = 0;
    v6 = v4;
    v7 = (_BYTE *)(a2 + 3 * v2);
    v8 = v7 + 1;
    v9 = 0x7FFFFFFF;
    while (1)
    {
      v10 = (__int16 *)((char *)&silk_stereo_pred_quant_Q13 + 2 * v5);
      v11 = *v10;
      v12 = 6554 * ((v10[1] - v11) >> 16) + ((6554 * (unsigned __int16)(v10[1] - *v10)) >> 16);
      v13 = v12 + v11;
      v14 = result[v2] - (v12 + v11);
      if (v14 < 0)
        v14 = v13 - result[v2];
      if (v14 >= v9)
      {
        LOBYTE(v5) = *v7;
        goto LABEL_27;
      }
      *v7 = v5;
      *v8 = 0;
      v3 = 3 * v12 + v11;
      if (result[v2] - v3 >= 0)
        v15 = result[v2] - v3;
      else
        v15 = v3 - result[v2];
      if (v15 >= v14)
      {
LABEL_24:
        v3 = v13;
        goto LABEL_27;
      }
      *v7 = v5;
      *v8 = 1;
      if ((int)(result[v2] - (5 * v12 + v11)) >= 0)
        v16 = result[v2] - (5 * v12 + v11);
      else
        v16 = 5 * v12 + v11 - result[v2];
      if (v16 >= v15)
        goto LABEL_27;
      *v7 = v5;
      *v8 = 2;
      v13 = v11 - v12 + 8 * v12;
      v17 = result[v2] - v13 >= 0 ? result[v2] - v13 : v13 - result[v2];
      if (v17 >= v16)
        break;
      *v7 = v5;
      *v8 = 3;
      v3 = 9 * v12 + v11;
      if (result[v2] - v3 >= 0)
        v9 = result[v2] - v3;
      else
        v9 = v3 - result[v2];
      if (v9 >= v17)
        goto LABEL_24;
      *v7 = v5;
      *v8 = 4;
      if (++v5 == 15)
      {
        LOBYTE(v5) = 14;
        goto LABEL_27;
      }
    }
    v3 = 5 * v12 + v11;
LABEL_27:
    v4 = 0;
    v18 = (((86 * (char)v5) >> 15) & 1) + ((86 * (char)v5) >> 8);
    *(_BYTE *)(a2 + 3 * v2 + 2) = v18;
    *v7 = -3 * v18 + v5;
    result[v2] = v3;
    v2 = 1;
  }
  while ((v6 & 1) != 0);
  *result -= result[1];
  return result;
}

int *silk_resampler_down2(int *result, __int16 *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  __int16 *v5;
  unsigned int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  __int16 v15;

  if (a4 >= 2)
  {
    v4 = a4 >> 1;
    v5 = (__int16 *)(a3 + 2);
    v7 = *result;
    v6 = result[1];
    do
    {
      v8 = *(v5 - 1);
      v9 = (v8 << 10) - v7;
      v10 = -25727 * (v9 >> 16) + ((-25727 * (unsigned __int16)v9) >> 16) + (v8 << 10);
      v7 = v10 + v9;
      v11 = *v5;
      v12 = 9872 * ((int)((v11 << 10) - v6) >> 16)
          + ((9872 * (unsigned __int16)(((_WORD)v11 << 10) - v6)) >> 16);
      v13 = v10 + v6 + v12;
      v6 = v12 + (v11 << 10);
      v5 += 2;
      v14 = ((v13 >> 10) + 1) >> 1;
      if (v14 <= -32768)
        LOWORD(v14) = 0x8000;
      if (v13 <= 67107839)
        v15 = v14;
      else
        v15 = 0x7FFF;
      *a2++ = v15;
      --v4;
    }
    while (v4);
    *result = v7;
    result[1] = v6;
  }
  return result;
}

__int16 *silk_ana_filt_bank_1(__int16 *result, int32x2_t *a2, __int16 *a3, __int16 *a4, int a5)
{
  uint64_t v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  __int32 v14;
  __int32 v15;
  unsigned int v16;
  __int16 v17;
  int v18;
  unsigned int v19;
  __int16 v20;

  if (a5 >= 2)
  {
    v5 = a5 >> 1;
    v6 = *a2;
    do
    {
      v7.i32[0] = *result;
      v7.i32[1] = result[1];
      v8 = vshl_n_s32(v7, 0xAuLL);
      v9 = vsub_s32(v8, v6);
      v10 = vmul_s32((int32x2_t)vand_s8((int8x8_t)v9, (int8x8_t)0xFFFF0000FFFFLL), (int32x2_t)0x2A24FFFFA11ELL);
      v11 = vshr_n_u32((uint32x2_t)v10, 0x10uLL);
      v10.i32[0] = vshr_n_s32(v10, 0x10uLL).u32[0];
      v10.i32[1] = v11.i32[1];
      v12 = vmla_s32(v10, vshr_n_s32(v9, 0x10uLL), (int32x2_t)0x2A24FFFFA11ELL);
      v9.i32[1] = v8.i32[1];
      v8.i32[1] = v6.i32[1];
      v13 = vadd_s32(v12, v8);
      v14 = v13.i32[1];
      v15 = v13.i32[0];
      v6 = vadd_s32((int32x2_t)__PAIR64__(v12.u32[1], v13.u32[0]), v9);
      v16 = (((v14 + v15) >> 10) + 1) >> 1;
      if (v14 + v15 < -67109888)
        LOWORD(v16) = 0x8000;
      if (v14 + v15 <= 67107839)
        v17 = v16;
      else
        v17 = 0x7FFF;
      *a3++ = v17;
      v18 = v14 - v15;
      v19 = ((v18 >> 10) + 1) >> 1;
      if (v18 < -67109888)
        LOWORD(v19) = 0x8000;
      if (v18 <= 67107839)
        v20 = v19;
      else
        v20 = 0x7FFF;
      *a4++ = v20;
      result += 2;
      --v5;
    }
    while (v5);
    *a2 = v6;
  }
  return result;
}

uint64_t silk_A2NLSF(_WORD *a1, int *a2, int a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  int v24;
  _BYTE *v25;
  unint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t result;
  unint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int v43;
  __int16 v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  uint64_t v57;
  int *v58;
  uint64_t v59;
  unint64_t v60;
  int v61;
  int v62;
  int v63;
  unsigned int v65;
  unsigned int v66;
  _BYTE *v67;
  _BYTE *v68;
  _DWORD v69[9];
  _DWORD v70[9];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v67 = v70;
  v68 = v69;
  v5 = a3 >> 1;
  v70[v5] = 0x10000;
  v6 = (uint64_t)a3 >> 1;
  v69[v5] = 0x10000;
  if (a3 <= 1)
  {
    v24 = 0;
    v20 = silk_LSFCosTab_FIX_Q12[0];
    v25 = v70;
    v19 = 0x10000;
  }
  else
  {
    v7 = 0;
    v8 = (a3 >> 1);
    v9 = v8;
    do
    {
      v10 = a2[(int)--v9];
      v11 = a2[v6 + v7];
      v70[v7] = -v11 - v10;
      v69[v7++] = v11 - v10;
    }
    while (v9);
    v12 = (a3 >> 1);
    do
    {
      v70[(v12 - 1)] -= v70[v12];
      v69[(v12 - 1)] += v69[v12];
      v13 = v12-- > 1;
    }
    while (v13);
    if (a3 >= 4)
    {
      v14 = (v6 + 1);
      v15 = 2;
      do
      {
        if (v15 < v8)
        {
          v16 = (a3 >> 1);
          do
          {
            v69[v16 + 7] -= v70[v16];
            --v16;
          }
          while (v16 > v15);
        }
        v69[v15 + 7] -= 2 * v70[v15];
        ++v15;
      }
      while (v15 != v14);
      v17 = 2;
      do
      {
        if (v17 < v8)
        {
          v18 = (a3 >> 1);
          do
          {
            v69[v18 - 2] -= v69[v18];
            --v18;
          }
          while (v18 > v17);
        }
        v69[v17 - 2] -= 2 * v69[v17];
        ++v17;
      }
      while (v17 != v14);
    }
    LODWORD(v19) = v70[v6];
    v20 = silk_LSFCosTab_FIX_Q12[0];
    v21 = (__int16)(16 * silk_LSFCosTab_FIX_Q12[0]);
    v22 = ((silk_LSFCosTab_FIX_Q12[0] >> 11) + 1) >> 1;
    v23 = v8 + 1;
    do
      v19 = (v70[(v23-- - 2)]
                         + v19 * v22
                         + ((int)v19 >> 16) * v21
                         + (((unsigned __int16)v19 * v21) >> 16));
    while (v23 > 1);
    if ((v19 & 0x80000000) != 0)
    {
      *a1 = 0;
      v25 = v69;
      LODWORD(v19) = v69[v6];
      v26 = v8 + 1;
      do
        v19 = (v69[(v26-- - 2)]
                           + v19 * v22
                           + ((int)v19 >> 16) * v21
                           + (((unsigned __int16)v19 * v21) >> 16));
      while (v26 > 1);
      v24 = 1;
    }
    else
    {
      v24 = 0;
      v25 = v70;
    }
  }
  v27 = 0;
  v59 = (v6 + 1);
  v60 = (a3 >> 1);
  v62 = (__int16)(16 * v20);
  v63 = v20;
  v61 = ((v20 >> 11) + 1) >> 1;
  v58 = &a2[v6];
  while (1)
  {
    v65 = v27;
    v28 = 1;
    v29 = v20;
    do
    {
      v30 = 0;
      v31 = v29;
      v29 = silk_LSFCosTab_FIX_Q12[v28];
      v32 = (__int16)(16 * silk_LSFCosTab_FIX_Q12[v28]);
      v33 = v28 << 8;
      v66 = v28;
      for (result = v19; ; result = 4096 - ((v24 << 12) & 0x2000u))
      {
        v19 = *(unsigned int *)&v25[4 * v6];
        if (a3 > 1)
        {
          v35 = v6 + 1;
          LODWORD(v19) = *(_DWORD *)&v25[4 * v6];
          do
            v19 = (*(_DWORD *)&v25[4 * (v35-- - 2)]
                               + v19 * (((v29 >> 11) + 1) >> 1)
                               + ((int)v19 >> 16) * v32
                               + (((unsigned __int16)v19 * v32) >> 16));
          while (v35 > 1);
        }
        if (((int)result >= 1 || (int)v19 < v30) && ((result & 0x80000000) != 0 || (int)v19 > -v30))
          break;
        v36 = 0;
        v37 = -256;
        v38 = v19;
        v39 = v29;
        do
        {
          v41 = *(unsigned int *)&v25[4 * v6];
          if (a3 > 1)
          {
            v42 = v6 + 1;
            LODWORD(v41) = *(_DWORD *)&v25[4 * v6];
            do
            {
              v40 = ((v39 + v31) & 1) + ((v39 + v31) >> 1);
              v41 = (*(_DWORD *)&v25[4 * (v42-- - 2)]
                                 + v41 * ((((16 * v40) >> 15) + 1) >> 1)
                                 + ((int)v41 >> 16) * (__int16)(16 * v40)
                                 + (((unsigned __int16)v41 * (__int16)(16 * v40)) >> 16));
            }
            while (v42 > 1);
          }
          if (((int)result >= 1 || (v41 & 0x80000000) != 0) && ((result & 0x80000000) != 0 || (int)v41 >= 1))
          {
            v37 += 0x80u >> v36;
            v31 = ((v39 + v31) & 1) + ((v39 + v31) >> 1);
            result = v41;
          }
          else
          {
            v39 = ((v39 + v31) & 1) + ((v39 + v31) >> 1);
            v38 = v41;
          }
          ++v36;
        }
        while (v36 != 3);
        v30 = v19 == 0;
        if ((int)result >= 0)
          v43 = result;
        else
          v43 = -(int)result;
        if (HIWORD(v43))
        {
          v37 += (int)result / (((int)result - v38) >> 5);
        }
        else if ((_DWORD)result != v38)
        {
          v37 += ((((int)result - v38) >> 1) + 32 * (int)result) / ((int)result - v38);
        }
        v44 = v37 + v33;
        if (v37 + v33 >= 0x7FFF)
          v44 = 0x7FFF;
        a1[v24++] = v44;
        if (v24 >= a3)
          return result;
        v25 = (&v67)[v24 & 1];
        v31 = silk_LSFCosTab_FIX_Q12[v28 - 1];
      }
      ++v28;
    }
    while (v66 < 0x80);
    if (v65 >= 0x1E)
      break;
    v19 = 0x10000;
    silk_bwexpander_32(a2, a3, 0x10000 - (__int16)(v65 + 11) * (__int16)(v65 + 1));
    v24 = 0;
    v25 = v70;
    v70[v6] = 0x10000;
    v69[v6] = 0x10000;
    v27 = v65 + 1;
    v20 = v63;
    if (a3 >= 2)
    {
      v45 = 0;
      v46 = v60;
      do
      {
        v47 = a2[(int)--v46];
        v48 = v58[v45];
        v70[v45] = -v48 - v47;
        v69[v45++] = v48 - v47;
      }
      while (v46);
      v49 = v60;
      do
      {
        v70[(v49 - 1)] -= v70[v49];
        v69[(v49 - 1)] += v69[v49];
        v13 = v49-- > 1;
      }
      while (v13);
      if (a3 >= 4)
      {
        v50 = 2;
        do
        {
          if (v50 < v60)
          {
            v51 = v60;
            do
            {
              v69[v51 + 7] -= v70[v51];
              --v51;
            }
            while (v51 > v50);
          }
          v69[v50 + 7] -= 2 * v70[v50];
          ++v50;
        }
        while (v50 != v59);
        v52 = 2;
        do
        {
          if (v52 < v60)
          {
            v53 = v60;
            do
            {
              v69[v53 - 2] -= v69[v53];
              --v53;
            }
            while (v53 > v52);
          }
          v69[v52 - 2] -= 2 * v69[v52];
          ++v52;
        }
        while (v52 != v59);
      }
      LODWORD(v19) = v70[v6];
      v54 = v6 + 1;
      do
        v19 = (v70[(v54-- - 2)]
                           + v19 * v61
                           + ((int)v19 >> 16) * v62
                           + (((unsigned __int16)v19 * v62) >> 16));
      while (v54 > 1);
      v24 = 0;
      v25 = v70;
      v27 = v65 + 1;
      if ((v19 & 0x80000000) != 0)
      {
        *a1 = 0;
        LODWORD(v19) = v69[v6];
        v55 = v6 + 1;
        do
        {
          v25 = v69;
          v19 = (v69[(v55-- - 2)]
                             + v19 * v61
                             + ((int)v19 >> 16) * v62
                             + (((unsigned __int16)v19 * v62) >> 16));
          v24 = 1;
        }
        while (v55 > 1);
        v27 = v65 + 1;
      }
    }
  }
  v56 = 0x8000 / (a3 + 1);
  *a1 = v56;
  if (a3 >= 2)
  {
    v57 = 1;
    do
    {
      a1[v57] = (v57 + 1) * v56;
      ++v57;
    }
    while (a3 != v57);
  }
  return result;
}

uint64_t silk_insertion_sort_increasing(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t i;
  uint64_t j;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  signed int v18;

  if (a4 < 1)
    goto LABEL_12;
  for (i = 0; i != a4; ++i)
    *(_DWORD *)(a2 + 4 * i) = i;
  if (a4 < 2)
  {
LABEL_12:
    v11 = 0;
  }
  else
  {
    for (j = 1; j != a4; *(_DWORD *)(a2 + v10) = j++)
    {
      v6 = *(_DWORD *)(result + 4 * j);
      v7 = j;
      while (1)
      {
        v8 = v7 - 1;
        v9 = *(_DWORD *)(result + 4 * (v7 - 1));
        if (v6 >= v9)
          break;
        *(_DWORD *)(result + 4 * v7) = v9;
        *(_DWORD *)(a2 + 4 * v7) = *(_DWORD *)(a2 + 4 * (v7 - 1));
        --v7;
        if (v8 + 1 <= 1)
        {
          LODWORD(v7) = 0;
          break;
        }
      }
      v10 = 4 * (int)v7;
      *(_DWORD *)(result + v10) = v6;
    }
    v11 = 1;
  }
  if (a4 < a3)
  {
    v12 = a4;
    do
    {
      v13 = *(_DWORD *)(result + 4 * v12);
      if (v13 < *(_DWORD *)(result + 4 * (a4 - 1)))
      {
        v14 = a4 - 2;
        if (v11)
        {
          v14 = a4 - 2;
          while (1)
          {
            v15 = *(_DWORD *)(result + 4 * v14);
            if (v13 >= v15)
              break;
            v16 = v14 + 1;
            *(_DWORD *)(result + 4 * v16) = v15;
            *(_DWORD *)(a2 + 4 * v16) = *(_DWORD *)(a2 + 4 * v14);
            if ((int)v14-- <= 0)
            {
              v14 = -1;
              break;
            }
          }
        }
        v18 = v14 + 1;
        *(_DWORD *)(result + 4 * v18) = v13;
        *(_DWORD *)(a2 + 4 * v18) = v12;
      }
      ++v12;
    }
    while (v12 != a3);
  }
  return result;
}

uint64_t silk_insertion_sort_decreasing_int16(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t i;
  uint64_t j;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  signed int v17;

  if (a4 < 1)
    goto LABEL_12;
  for (i = 0; i != a4; ++i)
    *(_DWORD *)(a2 + 4 * i) = i;
  if (a4 < 2)
  {
LABEL_12:
    v10 = 0;
  }
  else
  {
    for (j = 1; j != a4; *(_DWORD *)(a2 + 4 * (int)v7) = j++)
    {
      v6 = *(__int16 *)(result + 2 * j);
      v7 = j;
      while (1)
      {
        v8 = v7 - 1;
        v9 = *(__int16 *)(result + 2 * (v7 - 1));
        if (v6 <= v9)
          break;
        *(_WORD *)(result + 2 * v7) = v9;
        *(_DWORD *)(a2 + 4 * v7) = *(_DWORD *)(a2 + 4 * (v7 - 1));
        --v7;
        if (v8 + 1 <= 1)
        {
          LODWORD(v7) = 0;
          break;
        }
      }
      *(_WORD *)(result + 2 * (int)v7) = v6;
    }
    v10 = 1;
  }
  if (a4 < a3)
  {
    v11 = a4;
    do
    {
      v12 = *(__int16 *)(result + 2 * v11);
      if (v12 > *(__int16 *)(result + 2 * (a4 - 1)))
      {
        v13 = a4 - 2;
        if (v10)
        {
          v13 = a4 - 2;
          while (1)
          {
            v14 = *(__int16 *)(result + 2 * v13);
            if (v12 <= v14)
              break;
            v15 = v13 + 1;
            *(_WORD *)(result + 2 * v15) = v14;
            *(_DWORD *)(a2 + 4 * v15) = *(_DWORD *)(a2 + 4 * v13);
            if ((int)v13-- <= 0)
            {
              v13 = -1;
              break;
            }
          }
        }
        v17 = v13 + 1;
        *(_WORD *)(result + 2 * v17) = v12;
        *(_DWORD *)(a2 + 4 * v17) = v11;
      }
      ++v11;
    }
    while (v11 != a3);
  }
  return result;
}

uint64_t silk_insertion_sort_increasing_all_values_int16(uint64_t result, int a2)
{
  uint64_t i;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  if (a2 >= 2)
  {
    for (i = 1; i != a2; ++i)
    {
      v3 = *(__int16 *)(result + 2 * i);
      v4 = i;
      while (1)
      {
        v5 = v4 - 1;
        v6 = *(__int16 *)(result + 2 * (v4 - 1));
        if (v3 >= v6)
          break;
        *(_WORD *)(result + 2 * v4--) = v6;
        if (v5 + 1 <= 1)
        {
          LODWORD(v4) = 0;
          break;
        }
      }
      *(_WORD *)(result + 2 * (int)v4) = v3;
    }
  }
  return result;
}

uint64_t silk_decode_pulses(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  unsigned __int8 *v16;
  int v17;
  int *v18;
  uint64_t v19;
  int v20;
  int v21;
  _OWORD *v22;
  uint64_t i;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v31;
  uint64_t v33;
  _DWORD v34[20];
  _DWORD v35[20];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v8 = ec_dec_icdf(a1, &silk_rate_levels_iCDF[9 * (a3 >> 1)], 8);
  v9 = a5 >> 4;
  v31 = a5;
  if ((int)(a5 & 0xFFFFFFF0) >= a5)
    v10 = v9;
  else
    v10 = v9 + 1;
  if ((int)v10 >= 1)
  {
    v33 = a2;
    v11 = 0;
    v12 = (unsigned __int8 *)&silk_pulses_per_block_iCDF + 18 * v8;
    do
    {
      v34[v11] = 0;
      v13 = ec_dec_icdf(a1, v12, 8);
      if (v13 == 17)
      {
        v14 = 0;
        do
        {
          if (v14++ == 9)
            v16 = (unsigned __int8 *)&unk_214F95787;
          else
            v16 = (unsigned __int8 *)&silk_pulses_per_block_iCDF;
          v13 = ec_dec_icdf(a1, v16 + 162, 8);
        }
        while (v13 == 17);
        v34[v11] = v14;
      }
      v35[v11++] = v13;
    }
    while (v11 != v10);
    v17 = 0;
    v18 = v35;
    v19 = v10;
    a2 = v33;
    do
    {
      v21 = *v18++;
      v20 = v21;
      v22 = (_OWORD *)(v33 + 4 * (v17 >> 12));
      if (v21 < 1)
      {
        v22[2] = 0u;
        v22[3] = 0u;
        *v22 = 0u;
        v22[1] = 0u;
      }
      else
      {
        silk_shell_decoder((uint64_t)v22, a1, v20);
      }
      v17 += 0x10000;
      --v19;
    }
    while (v19);
    for (i = 0; i != v10; ++i)
    {
      v24 = v34[i];
      if (v24 >= 1)
      {
        v25 = 0;
        v26 = a2 + 64 * (__int16)i;
        do
        {
          v27 = *(_DWORD *)(v26 + 4 * v25);
          v28 = v24;
          do
          {
            v27 = ec_dec_icdf(a1, silk_lsb_iCDF, 8) + 2 * v27;
            --v28;
          }
          while (v28);
          *(_DWORD *)(v26 + 4 * v25++) = v27;
        }
        while (v25 != 16);
        v35[i] |= 32 * v24;
        a2 = v33;
      }
    }
  }
  return silk_decode_signs(a1, a2, v31, a3, a4, (uint64_t)v35);
}

__int16 *silk_NLSF_stabilize(__int16 *result, __int16 *a2, int a3)
{
  __int16 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  uint64_t i;
  __int16 v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  __int16 *v29;
  int v30;
  int v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 *v35;
  __int16 *v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;

  v5 = result;
  v6 = 0;
  v7 = a3;
  v8 = a3 - 1;
  v9 = a3;
  while (1)
  {
    v10 = *a2;
    v11 = *result - v10;
    if (a3 < 2)
    {
      LODWORD(v12) = 0;
    }
    else
    {
      LODWORD(v12) = 0;
      v13 = *result;
      for (i = 1; i != a3; ++i)
      {
        v15 = result[i];
        v16 = v15 - (a2[i] + v13);
        if (v16 < v11)
        {
          LODWORD(v12) = i;
          v11 = v16;
        }
        v13 = v15;
      }
    }
    v17 = a2[a3];
    v18 = 0x8000 - (result[v8] + v17);
    if (v18 >= v11)
      v12 = v12;
    else
      v12 = a3;
    if (v18 < v11)
      v11 = 0x8000 - (result[v8] + v17);
    if ((v11 & 0x80000000) == 0)
      break;
    if ((_DWORD)v12)
    {
      if ((_DWORD)v12 == a3)
      {
        result[v8] = 0x8000 - v17;
      }
      else
      {
        if ((int)v12 < 1)
        {
          v19 = 0;
        }
        else
        {
          v19 = 0;
          v20 = v12;
          v21 = a2;
          do
          {
            v22 = *v21++;
            v19 += v22;
            --v20;
          }
          while (v20);
        }
        v23 = (int)v12;
        v24 = 0x8000;
        if ((int)v12 < a3)
        {
          v25 = a3;
          do
            v24 -= a2[v25--];
          while (v25 > (int)v12);
        }
        v26 = a2[(int)v12] >> 1;
        v27 = v19 + v26;
        v28 = v24 - v26;
        v29 = &result[v23];
        v30 = *v29 + *(v29 - 1);
        v31 = (v30 & 1) + (v30 >> 1);
        if (v27 <= v28)
          v32 = v28;
        else
          v32 = v27;
        if (v27 >= v28)
          v27 = v28;
        if (v31 > v27)
          LOWORD(v27) = v31;
        if (v31 > v32)
          LOWORD(v27) = v32;
        v33 = v27 - v26;
        *(v29 - 1) = v33;
        *v29 = v33 + a2[v23];
      }
    }
    else
    {
      *result = v10;
    }
    if (++v6 == 20)
    {
      result = (__int16 *)silk_insertion_sort_increasing_all_values_int16((uint64_t)result, a3);
      v34 = *a2;
      if (*v5 > v34)
        LOWORD(v34) = *v5;
      *v5 = v34;
      if (a3 < 2)
      {
        v42 = v5[v8];
        if (v42 >= 0x8000 - a2[v7])
          LOWORD(v42) = 0x8000 - a2[v7];
        v5[v8] = v42;
      }
      else
      {
        v35 = a2 + 1;
        v36 = v5 + 1;
        v37 = v9 - 1;
        do
        {
          v38 = *v35++;
          v34 = v38 + (__int16)v34;
          if (*v36 > v34)
            LOWORD(v34) = *v36;
          *v36++ = v34;
          --v37;
        }
        while (v37);
        v39 = v5[v8];
        if (v39 >= 0x8000 - a2[v7])
          LOWORD(v39) = 0x8000 - a2[v7];
        v5[v8] = v39;
        v40 = (a3 - 2);
        LOWORD(v41) = v5[v40 + 1];
        do
        {
          v41 = (__int16)v41 - a2[v40 + 1];
          if (v5[v40] < v41)
            LOWORD(v41) = v5[v40];
          v5[v40--] = v41;
        }
        while (v40 != -1);
      }
      return result;
    }
  }
  return result;
}

int *silk_resampler_private_AR2(int *result, int *a2, __int16 *a3, __int16 *a4, int a5)
{
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a5 >= 1)
  {
    v5 = *a4;
    v6 = a4[1];
    v7 = a5;
    v8 = *result;
    do
    {
      v9 = *a3++;
      v10 = v8 + (v9 << 8);
      *a2++ = v10;
      v11 = (__int16)(v10 >> 14);
      v12 = 4 * (v10 & 0x3FFF);
      v8 = result[1] + v11 * v5 + ((v12 * v5) >> 16);
      *result = v8;
      result[1] = v11 * v6 + ((v12 * v6) >> 16);
      --v7;
    }
    while (v7);
  }
  return result;
}

__n128 silk_resampler_private_IIR_FIR(uint64_t a1, _WORD *a2, __int16 *a3, int a4)
{
  uint64_t v8;
  size_t v9;
  _OWORD *v10;
  unsigned int *v11;
  int v12;
  int v13;
  int8x16_t v14;
  int v15;
  int v16;
  int v17;
  __n128 result;
  __n128 *v19;
  unsigned int *i;
  _OWORD *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  LODWORD(v8) = *(_DWORD *)(a1 + 268);
  v9 = 2 * (2 * (int)v8 + 8);
  v10 = (_OWORD *)((char *)&v19 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v10, v9);
  v11 = (unsigned int *)a1;
  v19 = (__n128 *)(a1 + 24);
  *v10 = *(_OWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 272);
  v21 = v10 + 1;
  for (i = (unsigned int *)a1; ; LODWORD(v8) = i[67])
  {
    if (a4 >= (int)v8)
      v8 = v8;
    else
      v8 = a4;
    silk_resampler_private_up2_HQ(v11, (uint64_t)v21, a3, v8);
    if ((int)((_DWORD)v8 << 17) >= 1)
    {
      v13 = 0;
      do
      {
        v14 = *(int8x16_t *)((char *)v10 + 2 * (v13 >> 16));
        v15 = vaddvq_s32(vmlal_s16(vmull_s16(silk_resampler_frac_FIR_12[(unsigned __int16)((3 * (unsigned __int16)v13) >> 14)], *(int16x4_t *)v14.i8), vrev64_s16(silk_resampler_frac_FIR_12[11 - ((12 * (unsigned __int16)v13) >> 16)]), (int16x4_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)));
        if (v15 <= 1073725439)
        {
          v16 = ((v15 >> 14) + 1) >> 1;
          if (v16 <= -32768)
            LOWORD(v16) = 0x8000;
        }
        else
        {
          LOWORD(v16) = 0x7FFF;
        }
        *a2++ = v16;
        v13 += v12;
      }
      while (v13 < (_DWORD)v8 << 17);
    }
    a4 -= v8;
    v17 = 2 * v8;
    if (a4 < 1)
      break;
    a3 += (int)v8;
    *v10 = *(_OWORD *)((char *)v10 + 2 * v17);
    v11 = i;
  }
  result = *(__n128 *)((char *)v10 + 2 * v17);
  *v19 = result;
  return result;
}

uint64_t silk_Get_Decoder_Size(_DWORD *a1)
{
  *a1 = 8600;
  return 0;
}

uint64_t silk_InitDecoder(uint64_t a1)
{
  uint64_t v2;
  char v3;
  char v4;
  uint64_t result;

  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    result = silk_init_decoder((_DWORD *)(a1 + 4288 * v2));
    v3 = 0;
    v2 = 1;
  }
  while ((v4 & 1) != 0);
  *(_DWORD *)(a1 + 8584) = 0;
  *(_QWORD *)(a1 + 8576) = 0;
  *(_DWORD *)(a1 + 8596) = 0;
  return result;
}

uint64_t silk_Decode(_DWORD *a1, int *a2, int a3, int a4, uint64_t a5, _WORD *a6, int *a7)
{
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t inited;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t result;
  int v20;
  BOOL v21;
  int v22;
  unsigned int v23;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int *v36;
  int v37;
  int64x2_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64x2_t v42;
  int64x2_t v43;
  int32x2_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  _BOOL4 v56;
  uint64_t v57;
  size_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  _WORD *v67;
  int v68;
  uint64_t v69;
  int v70;
  int v71;
  size_t v72;
  unint64_t v73;
  _WORD *v74;
  __int16 *v75;
  int v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  __int16 *v81;
  _WORD *v82;
  __int16 v83;
  int v84;
  uint64_t v85;
  _WORD *v86;
  __int16 v87;
  uint64_t v88;
  _WORD *v89;
  int v90;
  uint64_t v91;
  _BYTE *v92;
  __int128 v93;
  int64x2_t v94;
  _BOOL4 v95;
  _WORD *v96;
  int *v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  _QWORD v103[3];

  v96 = a6;
  v97 = a7;
  v10 = (uint64_t)a1;
  v103[1] = *MEMORY[0x24BDAC8D0];
  v100 = 0;
  v103[0] = 0;
  LODWORD(v11) = a2[1];
  if (a4 && (int)v11 >= 1)
  {
    v12 = a1 + 600;
    v13 = a2[1];
    do
    {
      *v12 = 0;
      v12 += 1072;
      --v13;
    }
    while (v13);
  }
  if ((int)v11 <= a1[2148])
  {
    inited = 0;
  }
  else
  {
    inited = silk_init_decoder(a1 + 1072);
    LODWORD(v11) = a2[1];
  }
  v95 = (_DWORD)v11 == 1 && *(_DWORD *)(v10 + 8592) == 2 && a2[3] == 1000 * *(_DWORD *)(v10 + 2316);
  v15 = *(_DWORD *)(v10 + 2400);
  v99 = a3;
  if (!v15 && (int)v11 >= 1)
  {
    v16 = 0;
    v17 = v10;
    while (1)
    {
      v18 = a2[4];
      result = 4294967093;
      if (v18 <= 19)
      {
        if (v18)
          v21 = v18 == 10;
        else
          v21 = 1;
        if (!v21)
          return result;
        v20 = 2;
      }
      else
      {
        if (v18 == 60)
        {
          v20 = 4;
          v22 = 3;
          goto LABEL_29;
        }
        if (v18 == 40)
        {
          v20 = 4;
          v22 = 2;
          goto LABEL_29;
        }
        if (v18 != 20)
          return result;
        v20 = 4;
      }
      v22 = 1;
LABEL_29:
      *(_DWORD *)(v17 + 2404) = v22;
      *(_DWORD *)(v17 + 2324) = v20;
      v23 = a2[3] >> 10;
      if (v23 > 0xF || ((1 << v23) & 0x8880) == 0)
        return 4294967096;
      inited = silk_decoder_set_fs(v17, v23 + 1, a2[2]) + inited;
      ++v16;
      v11 = a2[1];
      v17 += 4288;
      if (v16 >= v11)
      {
        a3 = v99;
        break;
      }
    }
  }
  v25 = *a2;
  if (*a2 != 2)
    goto LABEL_42;
  if ((_DWORD)v11 != 2)
    goto LABEL_41;
  if (*(_DWORD *)(v10 + 8588) != 1 && *(_DWORD *)(v10 + 8592) != 1)
  {
    LODWORD(v11) = 2;
LABEL_41:
    v25 = 2;
    goto LABEL_42;
  }
  *(_DWORD *)(v10 + 8576) = 0;
  *(_DWORD *)(v10 + 8584) = 0;
  memcpy((void *)(v10 + 6736), (const void *)(v10 + 2448), 0x130uLL);
  v25 = *a2;
  LODWORD(v11) = a2[1];
LABEL_42:
  *(_DWORD *)(v10 + 8588) = v25;
  *(_DWORD *)(v10 + 8592) = v11;
  if ((a2[2] - 48001) < 0xFFFF63BF)
    return 4294967096;
  v98 = v10;
  if (a3 == 1 || *(_DWORD *)(v10 + 2400))
    goto LABEL_83;
  if ((int)v11 >= 1)
  {
    v26 = 0;
    v27 = v10 + 2416;
    do
    {
      v28 = v10 + 4288 * v26;
      if (*(int *)(v28 + 2404) >= 1)
      {
        v29 = 0;
        v30 = (int *)(v28 + 2404);
        do
          *(_DWORD *)(v27 + 4 * v29++) = ec_dec_bit_logp(a5, 1);
        while (v29 < *v30);
      }
      *(_DWORD *)(v10 + 4288 * v26++ + 2428) = ec_dec_bit_logp(a5, 1);
      v11 = a2[1];
      v27 += 4288;
    }
    while (v26 < v11);
    if ((int)v11 >= 1)
    {
      v31 = 0;
      v32 = v10;
      v93 = xmmword_214F962F0;
      v94 = vdupq_n_s64(2uLL);
      do
      {
        v33 = v10 + 4288 * v31;
        *(_DWORD *)(v33 + 2440) = 0;
        *(_QWORD *)(v33 + 2432) = 0;
        if (*(_DWORD *)(v33 + 2428))
        {
          v34 = v10 + 4288 * v31;
          v35 = *(_DWORD *)(v34 + 2404);
          if (v35 == 1)
          {
            *(_DWORD *)(v33 + 2432) = 1;
          }
          else
          {
            v36 = (int *)(v34 + 2404);
            v37 = ec_dec_icdf(a5, (unsigned __int8 *)*(&silk_LBRR_flags_iCDF_ptr + v35 - 2), 8);
            v38 = v94;
            v39 = *v36;
            v10 = v98;
            if ((int)v39 >= 1)
            {
              v40 = 0;
              v41 = v37 + 1;
              v42 = (uint64x2_t)vdupq_n_s64(v39 - 1);
              v43 = (int64x2_t)v93;
              do
              {
                v44 = vmovn_s64((int64x2_t)vcgeq_u64(v42, (uint64x2_t)v43));
                if ((v44.i8[0] & 1) != 0)
                  *(_DWORD *)(v32 + 4 * v40 + 2432) = (v41 >> v40) & 1;
                if ((v44.i8[4] & 1) != 0)
                  *(_DWORD *)(v32 + 4 * v40 + 2436) = (v41 >> (v40 + 1)) & 1;
                v40 += 2;
                v43 = vaddq_s64(v43, v38);
              }
              while (((v39 + 1) & 0xFFFFFFFFFFFFFFFELL) != v40);
            }
          }
        }
        ++v31;
        v11 = a2[1];
        v32 += 4288;
      }
      while (v31 < v11);
    }
  }
  if (v99)
    goto LABEL_83;
  v45 = *(_DWORD *)(v10 + 2404);
  if (v45 < 1)
    goto LABEL_83;
  v46 = 0;
  v47 = 0xFFFFFFFFLL;
  v48 = 2432;
  do
  {
    if ((int)v11 < 1)
      goto LABEL_82;
    v49 = 0;
    v94.i64[0] = v47;
    v50 = 4 * v47 + 2432;
    v51 = (_DWORD *)(v10 + 4 * v46 + 6720);
    do
    {
      if (!*(_DWORD *)(v10 + v48))
        goto LABEL_80;
      if (v49 || (_DWORD)v11 != 2 || (silk_stereo_decode_pred(a5, v103), *v51))
      {
        if (!v46)
          goto LABEL_78;
      }
      else
      {
        silk_stereo_decode_mid_only(a5, (_DWORD *)&v100 + 1);
        if (!v46)
        {
LABEL_78:
          v52 = 0;
          goto LABEL_79;
        }
      }
      if (!*(_DWORD *)(v10 + v50))
        goto LABEL_78;
      v52 = 2;
LABEL_79:
      silk_decode_indices(v10, a5, v46, 1, v52);
      silk_decode_pulses(a5, (uint64_t)&v101, *(char *)(v10 + 2789), *(char *)(v10 + 2790), *(_DWORD *)(v10 + 2328));
      LODWORD(v11) = a2[1];
LABEL_80:
      ++v49;
      v10 += 4288;
    }
    while (v49 < (int)v11);
    v10 = v98;
    v45 = *(_DWORD *)(v98 + 2404);
    LODWORD(v47) = v94.i32[0];
LABEL_82:
    ++v46;
    v48 += 4;
    v47 = (v47 + 1);
  }
  while (v46 < v45);
LABEL_83:
  v53 = v99;
  if ((_DWORD)v11 == 2)
  {
    if (v99)
    {
      if (v99 == 2 && *(_DWORD *)(v10 + 4 * *(int *)(v10 + 2400) + 2432) == 1)
      {
        silk_stereo_decode_pred(a5, v103);
        if (!*(_DWORD *)(v10 + 4 * *(int *)(v10 + 2400) + 6720))
          goto LABEL_88;
LABEL_91:
        HIDWORD(v100) = 0;
      }
      else
      {
        v54 = *(__int16 *)(v10 + 8578);
        LODWORD(v103[0]) = *(__int16 *)(v10 + 8576);
        HIDWORD(v103[0]) = v54;
      }
    }
    else
    {
      silk_stereo_decode_pred(a5, v103);
      if (*(_DWORD *)(v10 + 4 * *(int *)(v10 + 2400) + 6704))
        goto LABEL_91;
LABEL_88:
      silk_stereo_decode_mid_only(a5, (_DWORD *)&v100 + 1);
    }
  }
  v55 = a2[1];
  v56 = HIDWORD(v100) == 0;
  if (v55 == 2 && !HIDWORD(v100))
  {
    if (*(_DWORD *)(v10 + 8596) == 1)
    {
      bzero((void *)(v10 + 5636), 0x3C0uLL);
      *(_OWORD *)(v10 + 5604) = 0u;
      *(_OWORD *)(v10 + 5620) = 0u;
      *(_OWORD *)(v10 + 5572) = 0u;
      *(_OWORD *)(v10 + 5588) = 0u;
      *(_DWORD *)(v10 + 6596) = 100;
      *(_BYTE *)(v10 + 6600) = 10;
      *(_DWORD *)(v10 + 8476) = 0;
      *(_DWORD *)(v10 + 6664) = 1;
      v55 = a2[1];
    }
    else
    {
      v55 = 2;
    }
  }
  v101 = 0;
  v102 = 0;
  v57 = *(int *)(v10 + 2328);
  v58 = 2 * ((int)v57 + 2) * v55;
  v59 = (char *)&v93 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v59, v58);
  v94.i64[0] = (uint64_t)v59;
  v101 = v59;
  v102 = (uint64_t)&v59[2 * v57 + 4];
  if (!v53)
    goto LABEL_103;
  if (!*(_DWORD *)(v10 + 8596))
  {
    v56 = 1;
LABEL_103:
    if (v55 >= 1)
      goto LABEL_104;
    v67 = v96;
    goto LABEL_125;
  }
  v56 = 0;
  if (v53 != 2 || v55 != 2)
    goto LABEL_103;
  v56 = *(_DWORD *)(v10 + 4 * *(int *)(v10 + 6688) + 6720) == 1;
LABEL_104:
  *(_QWORD *)&v93 = &v59[2 * v57 + 4];
  v60 = 0;
  v61 = v10 + 2432;
  v62 = -1;
  do
  {
    if (v60)
      v63 = v56;
    else
      v63 = 1;
    if (v63 == 1)
    {
      v64 = *(_DWORD *)(v98 + 2400);
      if (v62 + v64 + 1 < 1)
      {
        v65 = 0;
      }
      else if (v99 == 2)
      {
        v65 = 2 * (*(_DWORD *)(v61 + 4 * (v64 + v62)) != 0);
      }
      else if (v60 && *(_DWORD *)(v98 + 8596))
      {
        v65 = 1;
      }
      else
      {
        v65 = 2;
      }
      inited = silk_decode_frame(v61 - 2432, a5, (&v101)[v60] + 4, (int *)&v100, v99, v65)
             + inited;
    }
    else
    {
      bzero((&v101)[v60] + 4, 2 * (int)v100);
    }
    ++*(_DWORD *)(v61 - 32);
    ++v60;
    v66 = a2[1];
    --v62;
    v61 += 4288;
  }
  while (v60 < v66);
  v67 = v96;
  if ((_DWORD)v66 == 2)
  {
    v10 = v98;
    v53 = v99;
    if (*a2 == 2)
    {
      silk_stereo_MS_to_LR((unsigned __int16 *)(v98 + 8576), v94.i64[0], (_DWORD *)v93, (int *)v103, *(_DWORD *)(v98 + 2316), v100);
      v68 = v100;
      goto LABEL_126;
    }
  }
  else
  {
    v10 = v98;
    v53 = v99;
  }
LABEL_125:
  v69 = v94.i64[0];
  *(_DWORD *)v94.i64[0] = *(_DWORD *)(v10 + 8580);
  v68 = v100;
  *(_DWORD *)(v10 + 8580) = *(_DWORD *)(v69 + 2 * (int)v100);
LABEL_126:
  v70 = a2[2] * v68 / (1000 * *(__int16 *)(v10 + 2316));
  *v97 = v70;
  v71 = *a2;
  if (*a2 != 2)
    v70 = 0;
  v72 = 2 * v70;
  v73 = (v72 + 15) & 0xFFFFFFFFFFFFFFF0;
  v74 = v67;
  if (v71 == 2)
    v75 = (__int16 *)((char *)&v93 - v73);
  else
    v75 = v67;
  bzero((char *)&v93 - v73, v72);
  v76 = a2[1];
  if (v71 >= v76)
    v77 = a2[1];
  else
    v77 = v71;
  if (v77 >= 1)
  {
    v78 = 0;
    do
    {
      v79 = silk_resampler((_DWORD *)(v10 + 4288 * v78 + 2448), v75, (&v101)[v78] + 2, v100);
      v71 = *a2;
      if (*a2 == 2)
      {
        v80 = *v97;
        if ((int)v80 >= 1)
        {
          v81 = v75;
          v82 = v74;
          do
          {
            v83 = *v81++;
            *v82 = v83;
            v82 += 2;
            --v80;
          }
          while (v80);
        }
      }
      inited = (v79 + inited);
      ++v78;
      v76 = a2[1];
      if (v71 >= v76)
        v84 = a2[1];
      else
        v84 = v71;
      ++v74;
    }
    while (v78 < v84);
    v53 = v99;
  }
  if (v71 != 2 || v76 != 1)
    goto LABEL_155;
  if (!v95)
  {
    v88 = *v97;
    if ((int)v88 >= 1)
    {
      v89 = v96 + 1;
      do
      {
        *v89 = *(v89 - 1);
        v89 += 2;
        --v88;
      }
      while (v88);
    }
LABEL_155:
    result = inited;
    goto LABEL_156;
  }
  result = silk_resampler((_DWORD *)(v10 + 6736), v75, (char *)(v94.i64[0] + 2), v100)
         + inited;
  v85 = *v97;
  if ((int)v85 >= 1)
  {
    v86 = v96 + 1;
    do
    {
      v87 = *v75++;
      *v86 = v87;
      v86 += 2;
      --v85;
    }
    while (v85);
  }
LABEL_156:
  if (*(_DWORD *)(v10 + 4188) == 2)
    v90 = dword_214F96300[(*(_DWORD *)(v10 + 2316) - 8) >> 2] * *(_DWORD *)(v10 + 2308);
  else
    v90 = 0;
  a2[5] = v90;
  if (v53 == 1)
  {
    v91 = *(unsigned int *)(v10 + 8592);
    if ((int)v91 >= 1)
    {
      v92 = (_BYTE *)(v10 + 2312);
      do
      {
        *v92 = 10;
        v92 += 4288;
        --v91;
      }
      while (v91);
    }
  }
  else
  {
    *(_DWORD *)(v10 + 8596) = HIDWORD(v100);
  }
  return result;
}

unint64_t silk_LPC_inverse_pred_gain(__int16 *a1, int a2)
{
  int v2;
  _DWORD *v3;
  uint64_t v4;
  int v5;
  _BYTE v7[128];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a2 < 1)
    return LPC_inverse_pred_gain_QA((uint64_t)v7, a2);
  v2 = 0;
  v3 = &v7[64 * (unint64_t)(a2 & 1)];
  v4 = a2;
  do
  {
    v5 = *a1++;
    v2 += v5;
    *v3++ = v5 << 12;
    --v4;
  }
  while (v4);
  if (v2 <= 4095)
    return LPC_inverse_pred_gain_QA((uint64_t)v7, a2);
  else
    return 0;
}

unint64_t LPC_inverse_pred_gain_QA(uint64_t a1, int a2)
{
  int *v2;
  int v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  int v7;
  char v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;

  v2 = (int *)(a1 + ((unint64_t)(a2 & 1) << 6));
  v3 = 0x40000000;
  if (a2 >= 2)
  {
    v4 = a2;
    v5 = ((unint64_t)a2 << 32) - 0x200000000;
    v6 = a2 - 1;
    v7 = 0x40000000;
    while (1)
    {
      v8 = v4 - 1;
      v9 = v2[(v4 - 1)];
      if ((v9 - 16773023) < 0xFE0020C3)
        return 0;
      v10 = (_DWORD *)(a1 + ((unint64_t)(v6 & 1) << 6));
      v11 = 0x40000000 - ((unint64_t)-((v9 << 7) * -128 * v9) >> 32);
      v12 = (unint64_t)(v11 * (uint64_t)v7) >> 30;
      if (v11 >= 0)
        v13 = 0x40000000 - ((unint64_t)-((v9 << 7) * -128 * v9) >> 32);
      else
        v13 = ((unint64_t)-((v9 << 7) * -128 * v9) >> 32) - 0x40000000;
      v14 = __clz(v13);
      v15 = v11 << (v14 - 1);
      v16 = 0x1FFFFFFF / (v15 >> 16);
      v17 = (__int16)v16 * (v15 >> 16) + (((__int16)v16 * (unsigned __int16)v15) >> 16);
      v7 = v12 & 0xFFFFFFFC;
      v18 = (v16 << 16)
          - 8 * v17 * (((v16 >> 15) + 1) >> 1)
          + ((-8 * v17) >> 16) * (__int16)v16
          + ((((-8 * v17) & 0xFFF8) * (__int16)v16) >> 16);
      v19 = v6;
      v20 = v2;
      v21 = v5;
      do
      {
        v22 = *v20++;
        v23 = (v22 - (int)((((unint64_t)(*(int *)((char *)v2 + (v21 >> 30)) * -128 * v9) >> 30) + 1) >> 1)) * v18;
        v24 = ((v23 >> (31 - v14)) + 1) >> 1;
        v25 = (v23 & 1) + (v23 >> 1);
        if (v14 != 31)
          LODWORD(v25) = v24;
        *v10++ = v25;
        v21 -= 0x100000000;
        --v19;
      }
      while (v19);
      v5 -= 0x100000000;
      --v6;
      v2 = (int *)(a1 + ((unint64_t)(v8 & 1) << 6));
      if (v4-- < 3)
      {
        v3 = v7;
        v2 = (int *)(a1 + ((unint64_t)(v8 & 1) << 6));
        break;
      }
    }
  }
  v27 = *v2;
  if ((v27 - 16773023) < 0xFE0020C3)
    return 0;
  return ((unint64_t)((int)((0x4000000000000000 - (-((v27 << 7) * -128 * v27) & 0x7FFFFFFF00000000uLL)) >> 32)
                           * (uint64_t)v3) >> 30) & 0xFFFFFFFC;
}

unint64_t silk_LPC_inverse_pred_gain_Q24(void *__src, int a2)
{
  _BYTE v4[128];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  if (a2 >= 1)
    memcpy(&v4[64 * (unint64_t)(a2 & 1)], __src, 4 * a2);
  return LPC_inverse_pred_gain_QA((uint64_t)v4, a2);
}

uint64_t silk_sigm_Q15(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0)
  {
    if (a1 >= 0xFFFFFF41)
      return sigm_LUT_neg_Q15[-a1 >> 5] - sigm_LUT_slope_Q10[2 * (-a1 >> 5)] * (-a1 & 0x1F);
    else
      return 0;
  }
  else if (a1 <= 0xBF)
  {
    return sigm_LUT_pos_Q15[a1 >> 5] + sigm_LUT_slope_Q10[2 * (a1 >> 5)] * (a1 & 0x1F);
  }
  else
  {
    return 0x7FFFLL;
  }
}

void *silk_NSQ_del_dec(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int *a13, int a14, __int16 a15)
{
  int v17;
  size_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int32x2_t *v31;
  int32x2_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int *v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  size_t v43;
  size_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  int32x4_t v50;
  uint64_t v51;
  int *v52;
  __int16 *v53;
  int v54;
  _DWORD *v55;
  int v56;
  uint64_t v57;
  char v58;
  int v59;
  uint64_t v60;
  int v61;
  unsigned int v62;
  char v63;
  int v64;
  int v65;
  int v66;
  int v67;
  unsigned int v68;
  int v69;
  char v70;
  int v71;
  unsigned int v72;
  int v73;
  int v74;
  signed int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  int *v95;
  _DWORD *v96;
  int v97;
  uint64_t v98;
  int v99;
  int v100;
  int v101;
  uint64_t v102;
  _DWORD *v103;
  char *v104;
  int v105;
  int v106;
  int v107;
  unsigned int v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  int32x4_t v114;
  int32x4_t v115;
  int32x4_t v116;
  char *v117;
  uint64_t v118;
  int32x4_t v119;
  int32x4_t v120;
  uint64_t i;
  int32x4_t v122;
  int32x4_t v123;
  uint64_t j;
  int32x4_t *v125;
  int32x4_t v126;
  int32x4_t v127;
  int32x4_t v128;
  int32x4_t v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  uint64_t v135;
  int v136;
  unsigned int v137;
  uint64_t v138;
  uint64_t v139;
  unsigned int v140;
  int v141;
  char *v142;
  uint64_t v143;
  int v144;
  uint64_t v145;
  char *v146;
  unsigned int v147;
  unsigned int v148;
  _BYTE *v149;
  __int16 *v150;
  uint64_t v151;
  int v152;
  char *v153;
  int v154;
  unsigned int v155;
  __int16 v156;
  int v157;
  int v158;
  int v159;
  int v160;
  uint64_t v161;
  int v162;
  int v163;
  int *v164;
  uint64_t k;
  uint64_t v166;
  int v167;
  int v168;
  uint64_t v169;
  int v170;
  char *v171;
  int v172;
  unsigned int v173;
  __int16 v174;
  char *v176;
  char *v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  uint64_t v192;
  char *v193;
  uint64_t v194;
  uint64_t v195;
  int v196;
  char *v197;
  uint64_t v198;
  int v199;
  int *v200;
  char *v201;
  int v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  _BOOL8 v206;
  uint64_t v207;
  uint64_t *v208;
  int v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  int v214;
  char *v215;
  uint64_t v216;
  int *v217;
  char *v218;
  int v219;
  int v220;
  uint64_t v221;
  int v222;
  uint64_t v223;

  v211 = a7;
  v212 = a8;
  v210 = a6;
  v221 = a5;
  v200 = a4;
  v216 = a3;
  v217 = a13;
  v223 = *MEMORY[0x24BDAC8D0];
  v219 = *(_DWORD *)(a2 + 4356);
  v17 = *(_DWORD *)(a1 + 4652);
  v18 = 1168 * v17;
  v19 = (char *)&v192 - v18;
  bzero((char *)&v192 - v18, v18);
  bzero((char *)&v192 - v18, v18);
  if (v17 >= 1)
  {
    v20 = v17;
    v21 = *(unsigned __int8 *)(v216 + 34);
    v22 = *(_DWORD *)(a2 + 4352);
    v23 = *(_DWORD *)(a2 + 4 * *(int *)(a1 + 4616) + 1276);
    v24 = (char *)&v192 - v18;
    do
    {
      v25 = *(_OWORD *)(a2 + 3920);
      *((_OWORD *)v24 + 4) = *(_OWORD *)(a2 + 3904);
      *((_OWORD *)v24 + 5) = v25;
      v26 = *(_OWORD *)(a2 + 3952);
      *((_OWORD *)v24 + 6) = *(_OWORD *)(a2 + 3936);
      *((_OWORD *)v24 + 7) = v26;
      v27 = *(_OWORD *)(a2 + 3856);
      *(_OWORD *)v24 = *(_OWORD *)(a2 + 3840);
      *((_OWORD *)v24 + 1) = v27;
      v28 = *(_OWORD *)(a2 + 3888);
      *((_OWORD *)v24 + 2) = *(_OWORD *)(a2 + 3872);
      *((_OWORD *)v24 + 3) = v28;
      v29 = *(_OWORD *)(a2 + 4320);
      *((_OWORD *)v24 + 71) = *(_OWORD *)(a2 + 4336);
      *((_OWORD *)v24 + 70) = v29;
      v30 = *(_OWORD *)(a2 + 4288);
      *((_OWORD *)v24 + 69) = *(_OWORD *)(a2 + 4304);
      v31 = (int32x2_t *)(v24 + 1156);
      *((_OWORD *)v24 + 68) = v30;
      v32 = vdup_n_s32(v21 & 3);
      *((_DWORD *)v24 + 291) = 0;
      *((_DWORD *)v24 + 288) = v22;
      *((_DWORD *)v24 + 240) = v23;
      ++v21;
      v24 += 1168;
      *v31 = v32;
      --v20;
    }
    while (v20);
  }
  v213 = a12;
  v33 = *(unsigned __int8 *)(v216 + 29);
  v209 = silk_Quantization_Offsets_Q10[2 * ((char)v33 >> 1) + *(char *)(v216 + 30)];
  v222 = 0;
  v34 = *(_DWORD *)(a1 + 4612);
  if (v34 >= 32)
    v35 = 32;
  else
    v35 = *(_DWORD *)(a1 + 4612);
  if (v33 == 2)
  {
    v36 = *(unsigned int *)(a1 + 4604);
    if ((int)v36 >= 1)
    {
      v37 = v217;
      do
      {
        v38 = *v37++;
        v39 = v38 - 3;
        if (v35 >= v38 - 3)
          v35 = v39;
        --v36;
      }
      while (v36);
    }
  }
  else if (v219 >= 1 && v35 >= v219 - 3)
  {
    v35 = v219 - 3;
  }
  v214 = v35;
  v40 = *(unsigned __int8 *)(v216 + 31);
  v41 = *(int *)(a1 + 4616);
  v42 = *(_DWORD *)(a1 + 4608) + v41;
  v43 = 4 * v42;
  v215 = (char *)&v192 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v215, v43);
  v44 = 2 * v42;
  v201 = (char *)&v192 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v201, v44);
  v218 = (char *)&v192 - ((4 * v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v218, 4 * v34);
  v208 = &v192 - 16;
  v190 = 0u;
  v191 = 0u;
  v188 = 0u;
  v189 = 0u;
  v186 = 0u;
  v187 = 0u;
  *((_OWORD *)&v192 - 8) = 0u;
  *((_OWORD *)&v192 - 7) = 0u;
  v45 = a2 + 2 * v41;
  *(_DWORD *)(a2 + 4364) = v41;
  *(_DWORD *)(a2 + 4360) = v41;
  LODWORD(v46) = *(_DWORD *)(a1 + 4604);
  if ((int)v46 >= 1)
  {
    v47 = 0;
    v48 = 0;
    v206 = v40 == 4;
    v207 = a11;
    if (v40 == 4)
      v49 = 3;
    else
      v49 = 1;
    v202 = v49;
    v205 = a14;
    v199 = a15;
    v198 = v214;
    v203 = a9;
    v204 = a10;
    v193 = v19 + 2332;
    v197 = v19 + 1164;
    v196 = -v214;
    v50.i64[0] = 0x100000001;
    v50.i64[1] = 0x100000001;
    LODWORD(v51) = v34;
    v195 = -(uint64_t)v214;
    v194 = -2 * v214;
    v52 = v200;
    while (1)
    {
      v53 = (__int16 *)(v210 + 32 * (v206 | (v47 >> 1)));
      v54 = *(_DWORD *)(v203 + 4 * v47);
      *(_DWORD *)(a2 + 4376) = 0;
      v55 = v215;
      v56 = *(unsigned __int8 *)(v216 + 29);
      v57 = v213;
      v220 = v54;
      if (v56 == 2)
      {
        v219 = v217[v47];
        if ((v202 & v47) == 0)
        {
          v200 = v52;
          if (v47 == 2)
          {
            v139 = *(unsigned int *)(a1 + 4652);
            if ((int)v139 <= 1)
            {
              v140 = 0;
              v144 = v214;
            }
            else
            {
              v140 = 0;
              v141 = *((_DWORD *)v19 + 291);
              v142 = v193;
              v143 = 1;
              v144 = v214;
              do
              {
                if (*(_DWORD *)v142 < v141)
                {
                  v140 = v143;
                  v141 = *(_DWORD *)v142;
                }
                ++v143;
                v142 += 1168;
              }
              while (v139 != v143);
            }
            if ((int)v139 >= 1)
            {
              v145 = v140;
              v146 = v197;
              do
              {
                if (v145)
                  *(_DWORD *)v146 += 0x7FFFFFF;
                --v145;
                v146 += 1168;
                --v139;
              }
              while (v139);
            }
            if (v144 < 1)
            {
              v48 = 0;
            }
            else
            {
              v147 = v140;
              LOBYTE(v148) = v222 + v144;
              v149 = (_BYTE *)(v221 + v195);
              v150 = (__int16 *)(v45 + v194);
              v151 = v198;
              v152 = v196;
              do
              {
                v148 = ((_BYTE)v148 - 1) & 0x1F;
                v153 = &v19[1168 * v147 + 4 * v148];
                *v149++ = ((*((_DWORD *)v153 + 144) >> 9) + 1) >> 1;
                v154 = (__int16)*(_DWORD *)(v57 + 4) * (*((int *)v153 + 176) >> 16)
                     + (((__int16)*(_DWORD *)(v57 + 4) * (unsigned __int16)*((_DWORD *)v153 + 176)) >> 16)
                     + (((*(int *)(v57 + 4) >> 15) + 1) >> 1) * *((_DWORD *)v153 + 176);
                v155 = ((v154 >> 13) + 1) >> 1;
                if (v154 < -536879104)
                  LOWORD(v155) = 0x8000;
                if (v154 <= 536862719)
                  v156 = v155;
                else
                  v156 = 0x7FFF;
                v157 = *((_DWORD *)v153 + 240);
                *v150++ = v156;
                *(_DWORD *)(a2 + 4 * (v152 + *(_DWORD *)(a2 + 4364)) + 1280) = v157;
                ++v152;
                --v151;
              }
              while (v151);
              v48 = 0;
              LODWORD(v51) = *(_DWORD *)(a1 + 4612);
            }
          }
          v158 = *(_DWORD *)(a1 + 4664);
          v159 = *(_DWORD *)(a1 + 4616) - (v219 + v158) - 2;
          silk_LPC_analysis_filter(&v201[2 * v159], a2 + 2 * (v159 + (int)v51 * (int)v47), (uint64_t)v53, v219 + v158 + 2, v158);
          v58 = 0;
          *(_DWORD *)(a2 + 4360) = *(_DWORD *)(a1 + 4616);
          *(_DWORD *)(a2 + 4376) = 1;
          v55 = v215;
          LOBYTE(v56) = *(_BYTE *)(v216 + 29);
          v52 = v200;
          v50.i64[0] = 0x100000001;
          v50.i64[1] = 0x100000001;
          goto LABEL_26;
        }
        LOBYTE(v56) = 2;
      }
      v58 = 1;
LABEL_26:
      v59 = v217[v47];
      v60 = *(unsigned int *)(a1 + 4652);
      v61 = *(_DWORD *)(v57 + 4 * v47);
      if (v61 <= 1)
        v62 = 1;
      else
        v62 = *(_DWORD *)(v57 + 4 * v47);
      v63 = __clz(v62);
      v64 = v62 << (v63 - 1);
      v65 = 0x1FFFFFFF / (v64 >> 16);
      v66 = (v64 >> 16) * (__int16)v65 + (((unsigned __int16)v64 * (__int16)v65) >> 16);
      v67 = (v65 << 16)
          - 8 * v66 * (((v65 >> 15) + 1) >> 1)
          + ((-8 * v66) >> 16) * (__int16)v65
          + ((((-8 * v66) & 0xFFF8) * (__int16)v65) >> 16);
      v68 = v62 >> 17;
      v69 = v67 >> (15 - v63);
      v70 = v63 - 15;
      v71 = (int)0x80000000 >> v70;
      if (v67 > (int)0x80000000 >> v70)
        v71 = v67;
      if (v67 <= (int)(0x7FFFFFFFu >> v70))
        v72 = v71;
      else
        v72 = 0x7FFFFFFFu >> v70;
      v73 = v72 << v70;
      if (v68)
        v73 = v69;
      v74 = *(_DWORD *)(a2 + 4372);
      if (v61 == v74)
      {
        v75 = 0x10000;
      }
      else
      {
        if (v74 >= 0)
          v76 = *(_DWORD *)(a2 + 4372);
        else
          v76 = -v74;
        v77 = __clz(v76);
        v78 = v74 << (v77 - 1);
        if (v61 >= 0)
          v79 = *(_DWORD *)(v57 + 4 * v47);
        else
          v79 = -v61;
        v80 = __clz(v79);
        v81 = v61 << (v80 - 1);
        v82 = 0x1FFFFFFF / (v81 >> 16);
        v83 = v82 * (v78 >> 16) + ((v82 * (unsigned __int16)v78) >> 16);
        v84 = v78 - (((unint64_t)(v83 * (uint64_t)v81) >> 29) & 0xFFFFFFF8);
        v85 = v83 + (v84 >> 16) * v82 + (((unsigned __int16)v84 * v82) >> 16);
        v86 = v77 - v80;
        if ((v86 + 29) >= 0x30)
          v87 = 0;
        else
          v87 = v85 >> (v86 + 13);
        v88 = (int)0x80000000 >> (-13 - v86);
        if (v85 > v88)
          v88 = v85;
        if (v85 <= (int)(0x7FFFFFFFu >> (-13 - v86)))
          v89 = v88;
        else
          v89 = 0x7FFFFFFFu >> (-13 - v86);
        v75 = v89 << (-13 - v86);
        if (v86 > -14)
          v75 = v87;
      }
      v90 = v214;
      v91 = *(unsigned int *)(a1 + 4612);
      if ((int)v91 >= 1)
      {
        v92 = (v73 >> 7) + 1;
        v93 = (__int16)(v92 >> 1);
        v94 = ((v92 >> 16) + 1) >> 1;
        v95 = v52;
        v96 = v218;
        do
        {
          v97 = *v95++;
          *v96++ = v97 * v94 + (v97 >> 16) * v93 + (((unsigned __int16)v97 * v93) >> 16);
          --v91;
        }
        while (v91);
      }
      *(_DWORD *)(a2 + 4372) = v61;
      if ((v58 & 1) == 0)
      {
        if (!v47)
          v73 = 4 * ((v73 >> 16) * v199 + (((unsigned __int16)v73 * v199) >> 16));
        v98 = *(int *)(a2 + 4360);
        v99 = v98 - v59 - 2;
        if (v99 < (int)v98)
        {
          v100 = v73 >> 16;
          v101 = (unsigned __int16)v73;
          v102 = v98 - v99;
          v103 = &v55[v99];
          v104 = &v201[2 * v99];
          do
          {
            v105 = *(__int16 *)v104;
            v104 += 2;
            *v103++ = v100 * v105 + ((v101 * v105) >> 16);
            --v102;
          }
          while (v102);
        }
      }
      v106 = (char)v56;
      if (v75 != 0x10000)
      {
        v107 = *(_DWORD *)(a1 + 4616);
        v108 = v75 >> 16;
        if (v107 >= 1)
        {
          v109 = *(_DWORD *)(a2 + 4364) - v107;
          do
          {
            *(_DWORD *)(a2 + 1280 + 4 * v109) = (__int16)*(_DWORD *)(a2 + 1280 + 4 * v109) * v108
                                              + (((__int16)*(_DWORD *)(a2 + 1280 + 4 * v109) * (unsigned __int16)v75) >> 16)
                                              + (((*(int *)(a2 + 1280 + 4 * v109) >> 15) + 1) >> 1) * v75;
            ++v109;
          }
          while (v109 < *(int *)(a2 + 4364));
        }
        if (v106 == 2 && !*(_DWORD *)(a2 + 4376))
        {
          v110 = *(_DWORD *)(a2 + 4360);
          LODWORD(v111) = v110 - v59 - 2;
          v112 = v110 - v90;
          if ((int)v111 < v112)
          {
            v111 = (int)v111;
            do
            {
              v55[v111] = (__int16)v55[v111] * v108
                        + (((__int16)v55[v111] * (unsigned __int16)v75) >> 16)
                        + ((((int)v55[v111] >> 15) + 1) >> 1) * v75;
              ++v111;
            }
            while (v111 < v112);
          }
        }
        if ((int)v60 >= 1)
        {
          v113 = 0;
          v114 = vdupq_n_s32(v108);
          v115 = vdupq_n_s32((unsigned __int16)v75);
          v116 = vdupq_n_s32(v75);
          v117 = v19;
          do
          {
            v118 = 0;
            *(_DWORD *)&v19[1168 * v113 + 1152] = (__int16)*(_DWORD *)&v19[1168 * v113 + 1152] * v108
                                                + (((__int16)*(_DWORD *)&v19[1168 * v113 + 1152] * (unsigned __int16)v75) >> 16)
                                                + (((*(int *)&v19[1168 * v113 + 1152] >> 15) + 1) >> 1) * v75;
            do
            {
              v119 = *(int32x4_t *)&v117[v118];
              v120 = vshrq_n_s32(vshlq_n_s32(v119, 0x10uLL), 0x10uLL);
              *(int32x4_t *)&v117[v118] = vmlaq_s32(vsraq_n_s32(vmulq_s32(v120, v114), vmulq_s32(v120, v115), 0x10uLL), vhaddq_s32(vshrq_n_s32(v119, 0xFuLL), v50), v116);
              v118 += 16;
            }
            while (v118 != 128);
            for (i = 1088; i != 1152; i += 16)
            {
              v122 = *(int32x4_t *)&v117[i];
              v123 = vshrq_n_s32(vshlq_n_s32(v122, 0x10uLL), 0x10uLL);
              *(int32x4_t *)&v117[i] = vmlaq_s32(vsraq_n_s32(vmulq_s32(v123, v114), vmulq_s32(v123, v115), 0x10uLL), vhaddq_s32(vshrq_n_s32(v122, 0xFuLL), v50), v116);
            }
            for (j = 0; j != 128; j += 16)
            {
              v125 = (int32x4_t *)&v117[j];
              v126 = *(int32x4_t *)&v117[j + 832];
              v127 = vshrq_n_s32(vshlq_n_s32(v126, 0x10uLL), 0x10uLL);
              v125[52] = vmlaq_s32(vsraq_n_s32(vmulq_s32(v127, v114), vmulq_s32(v127, v115), 0x10uLL), vhaddq_s32(vshrq_n_s32(v126, 0xFuLL), v50), v116);
              v128 = *(int32x4_t *)&v117[j + 960];
              v129 = vshrq_n_s32(vshlq_n_s32(v128, 0x10uLL), 0x10uLL);
              v125[60] = vmlaq_s32(vsraq_n_s32(vmulq_s32(v129, v114), vmulq_s32(v129, v115), 0x10uLL), vhaddq_s32(vshrq_n_s32(v128, 0xFuLL), v50), v116);
            }
            ++v113;
            v117 += 1168;
          }
          while (v113 != v60);
        }
      }
      v130 = *(_DWORD *)(v204 + 4 * v47);
      v131 = *(_DWORD *)(v207 + 4 * v47);
      v132 = *(_DWORD *)(v57 + 4 * v47);
      v133 = *(_DWORD *)(a1 + 4612);
      v134 = v48 + 1;
      v135 = *(_QWORD *)(a1 + 4660);
      v136 = *(_DWORD *)(a1 + 4704);
      v137 = *(_DWORD *)(a1 + 4652);
      DWORD2(v189) = v48;
      HIDWORD(v187) = (v220 << 15) & 0xFFFF0000 | (v220 >> 2);
      *((_QWORD *)&v186 + 1) = v211 + 2 * (5 * v47);
      *(_QWORD *)&v187 = v212 + 2 * (16 * v47);
      v138 = v221;
      silk_noise_shape_quantizer_del_dec((int32x2_t *)a2, v19, v106, (uint64_t)v218, v221, v45, (uint64_t)v55, (uint64_t)v208, v53, *((__int16 **)&v186 + 1), (__int16 *)v187, v219, SHIDWORD(v187), v130, v131, v132, v205, v209, v133,
        SDWORD2(v189),
        v135,
        SHIDWORD(v135),
        v136,
        v137,
        &v222,
        v90);
      v50.i64[0] = 0x100000001;
      v50.i64[1] = 0x100000001;
      v51 = *(int *)(a1 + 4612);
      v52 += v51;
      v221 = v138 + v51;
      v45 += 2 * v51;
      ++v47;
      v46 = *(int *)(a1 + 4604);
      v48 = v134;
      if (v47 >= v46)
      {
        v17 = *(_DWORD *)(a1 + 4652);
        v34 = v51;
        break;
      }
    }
  }
  v160 = v214;
  v161 = v221;
  if (v17 <= 1)
  {
    v162 = 0;
  }
  else
  {
    v162 = 0;
    v163 = *((_DWORD *)v19 + 291);
    v164 = (int *)(v19 + 2332);
    for (k = 1; k != v17; ++k)
    {
      if (*v164 < v163)
      {
        v162 = k;
        v163 = *v164;
      }
      v164 += 292;
    }
  }
  v166 = v213;
  *(_BYTE *)(v216 + 34) = *(_DWORD *)&v19[1168 * v162 + 1160];
  if (v160 >= 1)
  {
    v167 = *(_DWORD *)(v166 + 4 * ((int)v46 - 1));
    LOBYTE(v46) = v222 + v160;
    v168 = (__int16)(v167 >> 6);
    v169 = -(uint64_t)v160;
    v170 = ((v167 >> 21) + 1) >> 1;
    do
    {
      LODWORD(v46) = ((_BYTE)v46 - 1) & 0x1F;
      v171 = &v19[1168 * v162 + 4 * v46];
      *(_BYTE *)(v161 + v169) = ((*((_DWORD *)v171 + 144) >> 9) + 1) >> 1;
      v172 = *((_DWORD *)v171 + 176) * v170
           + (*((int *)v171 + 176) >> 16) * v168
           + (((unsigned __int16)*((_DWORD *)v171 + 176) * v168) >> 16);
      v173 = ((v172 >> 7) + 1) >> 1;
      if (v172 < -8388736)
        LOWORD(v173) = 0x8000;
      if (v172 <= 8388479)
        v174 = v173;
      else
        v174 = 0x7FFF;
      *(_WORD *)(v45 + 2 * v169) = v174;
      *(_DWORD *)(a2 + 4 * ((int)v169 + *(_DWORD *)(a2 + 4364)) + 1280) = *((_DWORD *)v171 + 240);
    }
    while (!__CFADD__(v169++, 1));
    v34 = *(_DWORD *)(a1 + 4612);
  }
  v176 = &v19[1168 * v162];
  v177 = &v176[4 * v34];
  v178 = *((_OWORD *)v177 + 5);
  *(_OWORD *)(a2 + 3904) = *((_OWORD *)v177 + 4);
  *(_OWORD *)(a2 + 3920) = v178;
  v179 = *((_OWORD *)v177 + 7);
  *(_OWORD *)(a2 + 3936) = *((_OWORD *)v177 + 6);
  *(_OWORD *)(a2 + 3952) = v179;
  v180 = *((_OWORD *)v177 + 1);
  *(_OWORD *)(a2 + 3840) = *(_OWORD *)v177;
  *(_OWORD *)(a2 + 3856) = v180;
  v181 = *((_OWORD *)v177 + 3);
  *(_OWORD *)(a2 + 3872) = *((_OWORD *)v177 + 2);
  *(_OWORD *)(a2 + 3888) = v181;
  v182 = *((_OWORD *)v176 + 68);
  v183 = *((_OWORD *)v176 + 69);
  v184 = *((_OWORD *)v176 + 70);
  *(_OWORD *)(a2 + 4336) = *((_OWORD *)v176 + 71);
  *(_OWORD *)(a2 + 4320) = v184;
  *(_OWORD *)(a2 + 4304) = v183;
  *(_OWORD *)(a2 + 4288) = v182;
  *(_DWORD *)(a2 + 4352) = *((_DWORD *)v176 + 288);
  *(_DWORD *)(a2 + 4356) = v217[*(int *)(a1 + 4604) - 1];
  memmove((void *)a2, (const void *)(a2 + 2 * *(int *)(a1 + 4608)), 2 * *(int *)(a1 + 4616));
  return memmove((void *)(a2 + 1280), (const void *)(a2 + 1280 + 4 * *(int *)(a1 + 4608)), 4 * *(int *)(a1 + 4616));
}

int32x2_t *silk_noise_shape_quantizer_del_dec(int32x2_t *result, _OWORD *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 *a9, __int16 *a10, __int16 *a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20,int a21,int a22,int a23,unsigned int a24,int *a25,unsigned int a26)
{
  int v27;
  char *v29;
  int v30;
  __int32 v31;
  int v32;
  uint64_t v33;
  _OWORD *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int32x2_t *v39;
  int v40;
  int v41;
  char *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  _OWORD *v48;
  int *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int *v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  _OWORD *v71;
  int v72;
  int v73;
  int v74;
  int v75;
  __int16 *v76;
  int *v77;
  uint64_t v78;
  int *v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int *v86;
  int v87;
  _OWORD *v88;
  int v89;
  int v90;
  int v91;
  uint64_t v92;
  int v93;
  int v94;
  int v95;
  int v96;
  unsigned int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  char *v106;
  int v107;
  int v108;
  int v109;
  int v110;
  BOOL v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  char *v122;
  uint64_t v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  char v129;
  uint64_t v130;
  int v131;
  int v132;
  int v133;
  _DWORD *v134;
  int32x2_t *v135;
  char *v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  char *v142;
  char *v143;
  _DWORD *v144;
  uint64_t v145;
  int v146;
  unsigned int v147;
  __int16 v148;
  int32x2_t *v149;
  uint64_t v150;
  _OWORD *v151;
  unint64_t v152;
  char *v153;
  _DWORD *v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  uint64_t v160;
  uint64_t v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int16 *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  char *v172;
  char *v173;
  _OWORD *v174;
  char *v175;
  char *v176;
  int v177;
  int v178;
  uint64_t v179;
  __int16 *v180;
  uint64_t v181;
  uint64_t v182;
  int *v183;
  int v184;
  int v185;
  int v186;
  int v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  _DWORD *v191;
  int32x2_t *v192;
  _OWORD *v193;
  int v194;
  int v195;
  __int16 *v196;
  int v197;
  int v198;
  int v199;
  int v200;
  char *v201;
  __int16 *v202;
  int32x2_t *v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  uint64_t v212;
  int v213;
  uint64_t v214;
  int v215;
  int v216;
  int v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  uint64_t v225;
  __int16 **v226;
  uint64_t v227;
  int *v228;
  uint64_t v229;

  v171 = a7;
  v170 = a6;
  v169 = a5;
  v214 = a4;
  v187 = a3;
  v192 = result;
  v27 = a24;
  v229 = *MEMORY[0x24BDAC8D0];
  v226 = &v168 - 6 * (int)a24;
  v188 = a19;
  if (a19 >= 1)
  {
    v181 = a26;
    LODWORD(v228) = a23;
    v186 = a20;
    v204 = a18;
    v224 = a14;
    v180 = a11;
    v223 = a17;
    v184 = a16 >> 6;
    v168 = a10;
    v202 = a9;
    v29 = (char *)v226;
    bzero(v226, 48 * (int)a24);
    v30 = v204;
    v227 = 0;
    v183 = (int *)(v171 + 4 * (v192[545].i32[0] - a12 + 2));
    v31 = v192[545].i32[1];
    v185 = a12;
    v191 = (_DWORD *)&v192[160] + v31 - a12 + 1;
    v178 = (__int16)a13;
    v177 = a13 >> 16;
    v213 = a22;
    v32 = (__int16)v228;
    v210 = a21 >> 1;
    v211 = a22 >> 1;
    v212 = a21;
    v225 = a21 - 1;
    v208 = (__int16)a15;
    v209 = (__int16)v224;
    v207 = a15 >> 16;
    v195 = v204 - 944;
    v194 = (__int16)(944 - v204) * (__int16)v223;
    v205 = (__int16)v204 * (__int16)v223;
    v199 = v204 + 944;
    v206 = (__int16)v223;
    v198 = (__int16)(v204 + 944) * (__int16)v223;
    v197 = v204 - 80;
    v33 = v181;
    v190 = (int)v181;
    v176 = (char *)a2 + 1092;
    v196 = v180 + 2;
    v175 = v29 + 52;
    v174 = a2 + 28;
    v173 = v29 + 28;
    v34 = a2 + 8;
    v172 = v29 + 12;
    result = (int32x2_t *)a24;
    v203 = (int32x2_t *)a24;
    v189 = (int)a24;
    v179 = a8;
    v182 = 1168 * a24;
    do
    {
      if (v187 == 2)
      {
        v35 = *v168;
        v36 = v168[4];
        result = v203;
        v30 = v204;
        v37 = 2
            * ((*v183 >> 16) * v35
             + (((unsigned __int16)*v183 * v35) >> 16)
             + (*(v183 - 1) >> 16) * v168[1]
             + (((unsigned __int16)*(v183 - 1) * v168[1]) >> 16)
             + (*(v183 - 2) >> 16) * v168[2]
             + (((unsigned __int16)*(v183 - 2) * v168[2]) >> 16)
             + (*(v183 - 3) >> 16) * v168[3]
             + (((unsigned __int16)*(v183 - 3) * v168[3]) >> 16)
             + (*(v183 - 4) >> 16) * v36
             + (((unsigned __int16)*(v183 - 4) * v36) >> 16))
            + 4;
        ++v183;
      }
      else
      {
        v37 = 0;
      }
      if (v185 < 1)
      {
        v38 = 0;
      }
      else
      {
        v38 = v37
            - 4
            * (((*(v191 - 2) + *v191) >> 16) * v178
             + ((int)*(v191 - 1) >> 16) * v177
             + (((unsigned __int16)(*((_WORD *)v191 - 4) + *(_WORD *)v191) * v178) >> 16)
             + (((unsigned __int16)*(v191 - 1) * v177) >> 16));
        ++v191;
      }
      v193 = v34;
      if (v27 <= 0)
      {
        v126 = 0;
        v127 = 0;
        v128 = 0;
        v129 = *a25 + 31;
        *a25 = v129 & 0x1F;
        v130 = (v129 + (_BYTE)v33) & 0x1F;
        v131 = *((_DWORD *)v226 + 1);
        v132 = *((_DWORD *)v226 + 7);
      }
      else
      {
        v39 = 0;
        v40 = *v202;
        v41 = v202[1];
        v42 = (char *)a2 + 4 * (v227 + 31);
        v43 = v202[2];
        v223 = v202[3];
        v224 = v43;
        v44 = v202[4];
        v221 = v202[5];
        v222 = v44;
        v45 = v202[6];
        v219 = v202[7];
        v220 = v45;
        v46 = v202[8];
        v217 = v202[9];
        v218 = v46;
        v228 = (int *)v176;
        v47 = *v180;
        v215 = v180[v225];
        v216 = v47;
        v201 = v42;
        v200 = v38;
        do
        {
          v48 = &a2[73 * (_QWORD)v39];
          *((_DWORD *)v48 + 289) = 196314165 * *((_DWORD *)v48 + 289) + 907633515;
          v49 = (int *)&v42[1168 * (_QWORD)v39];
          v50 = *v49;
          v51 = v211
              + (*v49 >> 16) * v40
              + (((unsigned __int16)*v49 * v40) >> 16)
              + (*(v49 - 1) >> 16) * v41
              + (((unsigned __int16)*(v49 - 1) * v41) >> 16)
              + (*(v49 - 2) >> 16) * v224
              + (((unsigned __int16)*(v49 - 2) * v224) >> 16)
              + (*(v49 - 3) >> 16) * v223
              + (((unsigned __int16)*(v49 - 3) * v223) >> 16)
              + (*(v49 - 4) >> 16) * v222
              + (((unsigned __int16)*(v49 - 4) * v222) >> 16)
              + (*(v49 - 5) >> 16) * v221
              + (((unsigned __int16)*(v49 - 5) * v221) >> 16)
              + (*(v49 - 6) >> 16) * v220
              + (((unsigned __int16)*(v49 - 6) * v220) >> 16)
              + (*(v49 - 7) >> 16) * v219
              + (((unsigned __int16)*(v49 - 7) * v219) >> 16)
              + (*(v49 - 8) >> 16) * v218
              + (((unsigned __int16)*(v49 - 8) * v218) >> 16)
              + (*(v49 - 9) >> 16) * v217
              + (((unsigned __int16)*(v49 - 9) * v217) >> 16);
          if (v213 == 16)
          {
            v52 = *(v49 - 10) >> 16;
            v53 = v202[10];
            v54 = (unsigned __int16)*(v49 - 10) * v53;
            v55 = *(v49 - 11) >> 16;
            v56 = v202[11];
            v57 = (unsigned __int16)*(v49 - 11) * v56;
            v58 = *(v49 - 12) >> 16;
            v59 = v202[12];
            v60 = (unsigned __int16)*(v49 - 12) * v59;
            v61 = *(v49 - 13) >> 16;
            v62 = v202[13];
            v63 = (unsigned __int16)*(v49 - 13) * v62;
            v65 = v49 - 15;
            v64 = *(v49 - 15);
            v66 = v64 >> 16;
            v67 = v202[15];
            v68 = (unsigned __int16)v64 * v67;
            v69 = v51 + v52 * v53 + (v54 >> 16) + v55 * v56 + (v57 >> 16) + v58 * v59 + (v60 >> 16) + v61 * v62;
            v30 = v204;
            result = v203;
            v70 = v69
                + (v63 >> 16)
                + (v65[1] >> 16) * v202[14]
                + (((unsigned __int16)v65[1] * v202[14]) >> 16)
                + v66 * v67;
            v38 = v200;
            v42 = v201;
            v51 = v70 + (v68 >> 16);
          }
          v71 = &a2[73 * (_QWORD)v39];
          v72 = *((_DWORD *)v71 + 272);
          v73 = v50 + (v72 >> 16) * v32 + (((unsigned __int16)v72 * v32) >> 16);
          v74 = v72
              + ((*((_DWORD *)v71 + 273) - v73) >> 16) * v32
              + (((unsigned __int16)(*((_WORD *)v71 + 546) - v73) * v32) >> 16);
          *((_DWORD *)v71 + 272) = v73;
          v75 = v210 + (v73 >> 16) * v216 + (((unsigned __int16)v73 * v216) >> 16);
          if ((int)v212 >= 3)
          {
            v76 = v196;
            v77 = v228;
            v78 = 2;
            v79 = v228;
            do
            {
              v80 = v77[1];
              v81 = *v77 + ((v80 - v74) >> 16) * v32 + (((unsigned __int16)(v80 - v74) * v32) >> 16);
              v82 = v74 >> 16;
              v83 = *(v76 - 1);
              v84 = v79[2];
              v79 += 2;
              v85 = (unsigned __int16)v74 * v83;
              *v77 = v74;
              v77[1] = v81;
              v74 = v80 + ((v84 - v81) >> 16) * v32 + (((unsigned __int16)(v84 - v81) * v32) >> 16);
              v75 += v82 * v83 + (v85 >> 16) + (v81 >> 16) * *v76 + (((unsigned __int16)v81 * *v76) >> 16);
              v78 += 2;
              v76 += 2;
              v77 = v79;
            }
            while (v78 < a21);
          }
          v86 = (int *)v48 + 289;
          v87 = 16 * v51;
          v88 = &a2[73 * (_QWORD)v39];
          *((_DWORD *)v88 + v225 + 272) = v74;
          v89 = *((int *)v88 + 288) >> 16;
          v90 = (unsigned __int16)*((_DWORD *)v88 + 288);
          v91 = 8 * (v75 + (v74 >> 16) * v215 + (((unsigned __int16)v74 * v215) >> 16))
              + 4 * (v89 * v209 + ((v90 * v209) >> 16));
          v92 = *a25;
          v93 = v89 * v207
              + ((v90 * v207) >> 16)
              + (*((int *)v88 + v92 + 240) >> 16) * v208
              + (((unsigned __int16)*((_DWORD *)v88 + v92 + 240) * v208) >> 16);
          v94 = *v86;
          if (*v86 >= 0)
            v95 = *(_DWORD *)(v214 + 4 * v227) - ((((16 * v51 + v38 - (v91 + 4 * v93)) >> 3) + 1) >> 1);
          else
            v95 = ((((16 * v51 + v38 - (v91 + 4 * v93)) >> 3) + 1) >> 1) - *(_DWORD *)(v214 + 4 * v227);
          if (v95 <= -31744)
            v95 = -31744;
          if (v95 >= 30720)
            v96 = 30720;
          else
            v96 = v95;
          v97 = v96 - v30;
          if (v96 - v30 < 1024)
          {
            v100 = v205;
            v101 = v198;
            v98 = v30;
            v99 = v199;
            if (v97 >= 0x400)
            {
              v102 = v30 + (v97 & 0xFFFFFC00);
              v103 = v102 + 80;
              v104 = v102 + 1104;
              v100 = (__int16)(-80 - v102) * v206;
              v105 = (__int16)(-1104 - v102) * v206;
              if (v97 <= 0xFFFFFBFF)
              {
                v101 = v105;
              }
              else
              {
                v100 = v194;
                v101 = v205;
              }
              if (v97 <= 0xFFFFFBFF)
                v98 = v103;
              else
                v98 = v195;
              if (v97 <= 0xFFFFFBFF)
                v99 = v104;
              else
                v99 = v30;
            }
          }
          else
          {
            v98 = v197 + (v97 & 0xFFFFFC00);
            v99 = v98 + 1024;
            v100 = (__int16)(v197 + (v97 & 0xFC00)) * v206;
            v101 = (__int16)(v197 + (v97 & 0xFC00) + 1024) * v206;
          }
          v106 = (char *)&v226[6 * (_QWORD)v39];
          v107 = 4 * v93;
          v108 = (v100 + (__int16)(v96 - v98) * (__int16)(v96 - v98)) >> 10;
          v109 = (v101 + (__int16)(v96 - v99) * (__int16)(v96 - v99)) >> 10;
          v110 = HIDWORD(a2[73 * (_QWORD)v39 + 72]);
          v111 = v108 <= v109;
          if (v108 >= v109)
            v112 = (v101 + (__int16)(v96 - v99) * (__int16)(v96 - v99)) >> 10;
          else
            v112 = (v100 + (__int16)(v96 - v98) * (__int16)(v96 - v98)) >> 10;
          if (v108 <= v109)
            v108 = (v101 + (__int16)(v96 - v99) * (__int16)(v96 - v99)) >> 10;
          if (v111)
            v113 = v98;
          else
            v113 = v99;
          if (v111)
            v98 = v99;
          *(_DWORD *)v106 = v113;
          *((_DWORD *)v106 + 1) = v110 + v112;
          *((_DWORD *)v106 + 6) = v98;
          *((_DWORD *)v106 + 7) = v110 + v108;
          v114 = 16 * v113;
          if (v94 < 0)
            v114 = -16 * v113;
          v115 = v114 + v37;
          v116 = v115 + v87;
          v117 = 16 * v98;
          if (v94 < 0)
            v117 = -v117;
          *((_DWORD *)v106 + 4) = v116 - v91 - v107;
          *((_DWORD *)v106 + 5) = v115;
          *((_DWORD *)v106 + 2) = v116;
          *((_DWORD *)v106 + 3) = v116 - v91;
          v118 = v117 + v37;
          v119 = v118 + v87 - v91;
          *((_DWORD *)v106 + 10) = v119 - v107;
          *((_DWORD *)v106 + 11) = v118;
          *((_DWORD *)v106 + 8) = v118 + v87;
          *((_DWORD *)v106 + 9) = v119;
          v39 = (int32x2_t *)((char *)v39 + 1);
          v228 += 292;
        }
        while (v39 != result);
        *a25 = ((_BYTE)v92 + 31) & 0x1F;
        v27 = v189;
        if ((int)v189 < 2)
        {
          v120 = 0;
          a8 = v179;
          v33 = v181;
        }
        else
        {
          v120 = 0;
          v121 = *((_DWORD *)v226 + 1);
          v122 = v175;
          v123 = 1;
          a8 = v179;
          v33 = v181;
          do
          {
            v125 = *(_DWORD *)v122;
            v122 += 48;
            v124 = v125;
            if (v125 < v121)
            {
              v120 = v123;
              v121 = v124;
            }
            ++v123;
          }
          while (result != (int32x2_t *)v123);
        }
        v130 = ((_BYTE)v92 + 31 + (_BYTE)v33) & 0x1F;
        v126 = v120;
        v133 = *((_DWORD *)&a2[73 * v120 + 28] + v130);
        v134 = (_DWORD *)v174 + v130;
        v135 = result;
        v136 = v173;
        do
        {
          if (*v134 != v133)
          {
            *((_DWORD *)v136 - 6) += 0x7FFFFFF;
            *(_DWORD *)v136 += 0x7FFFFFF;
          }
          v134 += 292;
          v136 += 48;
          v135 = (int32x2_t *)((char *)v135 - 1);
        }
        while (v135);
        v131 = *((_DWORD *)v226 + 1);
        v132 = *((_DWORD *)v226 + 7);
        if (v27 < 2)
        {
          v127 = 0;
          v128 = 0;
        }
        else
        {
          v128 = 0;
          v127 = 0;
          v137 = v175;
          v138 = 1;
          do
          {
            if (*(_DWORD *)v137 > v131)
            {
              v128 = v138;
              v131 = *(_DWORD *)v137;
            }
            if (*((_DWORD *)v137 + 6) < v132)
            {
              v127 = v138;
              v132 = *((_DWORD *)v137 + 6);
            }
            ++v138;
            v137 += 48;
          }
          while (result != (int32x2_t *)v138);
        }
      }
      if (v132 < v131)
      {
        v139 = a8;
        v140 = v126;
        v141 = v33;
        memcpy((char *)&a2[73 * v128] + 4 * v227, (char *)&a2[73 * v127] + 4 * v227, 1168 - 4 * v227);
        v33 = v141;
        v27 = v189;
        v126 = v140;
        a8 = v139;
        result = v203;
        v30 = v204;
        v142 = (char *)&v226[6 * v128];
        v143 = (char *)&v226[6 * v127];
        *(_OWORD *)v142 = *(_OWORD *)(v143 + 24);
        *((_QWORD *)v142 + 2) = *((_QWORD *)v143 + 5);
      }
      if (v186 > 0 || v227 >= v190)
      {
        v144 = (_DWORD *)&a2[73 * v126] + v130;
        v145 = v227 - v190;
        *(_BYTE *)(v169 + v227 - v190) = ((v144[144] >> 9) + 1) >> 1;
        v146 = (__int16)*(_DWORD *)(a8 + 4 * v130) * ((int)v144[176] >> 16)
             + (((__int16)*(_DWORD *)(a8 + 4 * v130) * (unsigned __int16)v144[176]) >> 16)
             + (((*(int *)(a8 + 4 * v130) >> 15) + 1) >> 1) * v144[176];
        v147 = ((v146 >> 7) + 1) >> 1;
        if (v146 < -8388736)
          LOWORD(v147) = 0x8000;
        if (v146 <= 8388479)
          v148 = v147;
        else
          v148 = 0x7FFF;
        *(_WORD *)(v170 + 2 * v145) = v148;
        v149 = v192;
        v192[160].i32[v192[545].i32[1] - (int)v33] = v144[240];
        *(_DWORD *)(v171 + 4 * (v149[545].i32[0] - (int)v33)) = v144[208];
      }
      v192[545] = vadd_s32(v192[545], (int32x2_t)0x100000001);
      v150 = v182;
      v151 = v193;
      if (v27 >= 1)
      {
        v152 = 0;
        v153 = v172;
        do
        {
          v154 = &a2[v152 / 0x10];
          v155 = *((_DWORD *)v153 - 1);
          v154[288] = *(_DWORD *)v153;
          LODWORD(v151[v152 / 0x10]) = v155;
          *((_DWORD *)&a2[v152 / 0x10 + 44] + *a25) = v155;
          v156 = *((_DWORD *)v153 - 3);
          v157 = *((_DWORD *)v153 - 2);
          *((_DWORD *)&a2[v152 / 0x10 + 36] + *a25) = v156;
          v158 = *((_DWORD *)v153 + 1);
          *((_DWORD *)&a2[v152 / 0x10 + 52] + *a25) = 2 * *((_DWORD *)v153 + 2);
          *((_DWORD *)&a2[v152 / 0x10 + 60] + *a25) = v158;
          v159 = DWORD1(a2[v152 / 0x10 + 72]) + (((v156 >> 9) + 1) >> 1);
          v154[289] = v159;
          *((_DWORD *)&a2[v152 / 0x10 + 28] + *a25) = v159;
          v154[291] = v157;
          v152 += 1168;
          v153 += 48;
        }
        while (v150 != v152);
      }
      *(_DWORD *)(a8 + 4 * *a25) = v184;
      v34 = (_OWORD *)((char *)v151 + 4);
      ++v227;
    }
    while (v227 != v188);
  }
  if (v27 >= 1)
  {
    v160 = 4 * (int)v188;
    v161 = v27;
    do
    {
      v162 = *(_OWORD *)((char *)a2 + v160);
      v163 = *(_OWORD *)((char *)a2 + v160 + 16);
      v164 = *(_OWORD *)((char *)a2 + v160 + 48);
      a2[2] = *(_OWORD *)((char *)a2 + v160 + 32);
      a2[3] = v164;
      *a2 = v162;
      a2[1] = v163;
      v165 = *(_OWORD *)((char *)a2 + v160 + 64);
      v166 = *(_OWORD *)((char *)a2 + v160 + 80);
      v167 = *(_OWORD *)((char *)a2 + v160 + 112);
      a2[6] = *(_OWORD *)((char *)a2 + v160 + 96);
      a2[7] = v167;
      a2[4] = v165;
      a2[5] = v166;
      a2 += 73;
      --v161;
    }
    while (v161);
  }
  return result;
}

__int16 *silk_bwexpander(__int16 *result, int a2, int a3)
{
  int v3;
  uint64_t v4;
  __int16 *v5;

  if (a2 >= 2)
  {
    v3 = a3 - 0x10000;
    v4 = (a2 - 1);
    v5 = result;
    do
    {
      *v5 = (((a3 * *v5) >> 15) + 1) >> 1;
      ++v5;
      a3 += (((a3 * v3) >> 15) + 1) >> 1;
      --v4;
    }
    while (v4);
  }
  result[a2 - 1] = (((a3 * result[a2 - 1]) >> 15) + 1) >> 1;
  return result;
}

uint64_t silk_decode_frame(uint64_t a1, uint64_t a2, char *a3, int *a4, int a5, int a6)
{
  int v12;
  size_t v13;
  __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int32x4_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v12 = *(_DWORD *)(a1 + 2328);
  memset(&v19, 0, 128);
  v20 = 0;
  v13 = 4 * (int)((v12 + 15) & 0xFFFFFFF0);
  v14 = &v19.i8[-v13];
  bzero((char *)&v19 - v13, v13);
  v21 = 0;
  if (a5 == 2)
  {
    v15 = *(int *)(a1 + 2400);
    if (*(_DWORD *)(a1 + 4 * v15 + 2432) == 1)
      goto LABEL_5;
LABEL_6:
    silk_PLC(a1, &v19, (uint64_t)a3, 1);
    goto LABEL_7;
  }
  if (a5)
    goto LABEL_6;
  LODWORD(v15) = *(_DWORD *)(a1 + 2400);
LABEL_5:
  silk_decode_indices(a1, a2, v15, a5, a6);
  silk_decode_pulses(a2, (uint64_t)v14, *(char *)(a1 + 2789), *(char *)(a1 + 2790), *(_DWORD *)(a1 + 2328));
  silk_decode_parameters(a1, (uint64_t)&v19, a6);
  silk_decode_core(a1, (uint64_t)&v19, a3, (uint64_t)v14);
  silk_PLC(a1, &v19, (uint64_t)a3, 0);
  *(_DWORD *)(a1 + 4184) = 0;
  *(_DWORD *)(a1 + 4188) = *(char *)(a1 + 2789);
  *(_DWORD *)(a1 + 2376) = 0;
LABEL_7:
  v16 = *(int *)(a1 + 2328);
  v17 = *(_DWORD *)(a1 + 2336) - v16;
  memmove((void *)(a1 + 1348), (const void *)(a1 + 1348 + 2 * v16), 2 * v17);
  memcpy((void *)(a1 + 1348 + 2 * v17), a3, 2 * *(int *)(a1 + 2328));
  silk_PLC_glue_frames((unsigned int *)a1, (uint64_t)a3, v12);
  silk_CNG(a1, (uint64_t)&v19, (uint64_t)a3, v12);
  *(_DWORD *)(a1 + 2308) = v19.i32[*(int *)(a1 + 2324) - 1];
  *a4 = v12;
  return 0;
}

uint64_t silk_control_SNR(uint64_t a1, int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  int v10;

  if (a2 <= 5000)
    v2 = 5000;
  else
    v2 = a2;
  if (v2 >= 80000)
    v3 = 80000;
  else
    v3 = v2;
  if (v3 != *(_DWORD *)(a1 + 4632))
  {
    v4 = 0;
    *(_DWORD *)(a1 + 4632) = v3;
    v5 = *(_DWORD *)(a1 + 4600);
    v6 = &silk_TargetRate_table_WB;
    if (v5 == 12)
      v6 = &silk_TargetRate_table_MB;
    if (v5 == 8)
      v7 = &silk_TargetRate_table_NB;
    else
      v7 = v6;
    if (*(_DWORD *)(a1 + 4604) == 2)
      v8 = v3 - 2200;
    else
      v8 = v3;
    v9 = 1;
    while (1)
    {
      v10 = v7[v9];
      if (v8 <= v10)
        break;
      ++v9;
      v4 += 0x100000000;
      if (v9 == 8)
        goto LABEL_21;
    }
    *(_DWORD *)(a1 + 4764) = (silk_SNR_table_Q1[v9] - *(__int16 *)((char *)silk_SNR_table_Q1 + (v4 >> 31)))
                           * (((v8 - *(_DWORD *)((char *)v7 + (v4 >> 30))) << 6)
                            / (v10 - *(_DWORD *)((char *)v7 + (v4 >> 30))))
                           + (*(__int16 *)((char *)silk_SNR_table_Q1 + (v4 >> 31)) << 6);
LABEL_21:
    if (*(_DWORD *)(a1 + 6144))
      *(_DWORD *)(a1 + 4764) += -31 * (__int16)(12 - *(_WORD *)(a1 + 6148));
  }
  return 0;
}

uint64_t silk_Get_Encoder_Size(_DWORD *a1)
{
  *a1 = 19688;
  return 0;
}

uint64_t silk_InitEncoder(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  int inited;
  int v11;
  __int128 v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _BOOL4 v17;

  bzero((void *)a1, 0x4CE8uLL);
  v6 = 0;
  LODWORD(v7) = 0;
  v8 = 1;
  do
  {
    v9 = v8;
    inited = silk_init_encoder((_DWORD *)(a1 + 9800 * v6), a2);
    v8 = 0;
    v7 = (inited + v7);
    v6 = 1;
  }
  while ((v9 & 1) != 0);
  *(_QWORD *)(a1 + 19660) = 0x100000001;
  *(_QWORD *)a3 = 0x100000001;
  v11 = *(_DWORD *)(a1 + 4588);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 4580);
  *(_DWORD *)(a3 + 12) = v11;
  *(_QWORD *)&v12 = *(_QWORD *)(a1 + 4592);
  *((int32x2_t *)&v12 + 1) = vrev64_s32(*(int32x2_t *)(a1 + 4632));
  *(_OWORD *)(a3 + 16) = v12;
  v13 = *(_DWORD *)(a1 + 4648);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 4640);
  *(_DWORD *)(a3 + 36) = v13;
  v14 = *(_DWORD *)(a1 + 6128);
  *(_DWORD *)(a3 + 40) = *(_DWORD *)(a1 + 6140);
  *(_DWORD *)(a3 + 44) = v14;
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(a1 + 4708);
  v15 = *(_DWORD *)(a1 + 4600);
  v16 = *(_DWORD *)(a1 + 4560);
  *(_DWORD *)(a3 + 68) = 1000 * (__int16)v15;
  *(_DWORD *)(a3 + 72) = v16;
  v17 = v15 == 16 && *(_DWORD *)(a1 + 28) == 0;
  *(_DWORD *)(a3 + 76) = v17;
  return v7;
}

uint64_t silk_Encode(_DWORD *a1, _DWORD *a2, __int16 *a3, int a4, uint64_t *a5, int *a6, int a7)
{
  _DWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  int v18;
  _BOOL4 v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  _DWORD *v24;
  int inited;
  uint64_t v26;
  _DWORD *v27;
  int v29;
  uint64_t v30;
  signed int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  size_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  __int16 *v50;
  __int16 *v51;
  __int16 v52;
  int v54;
  int v55;
  int v56;
  __int16 *v57;
  uint64_t v58;
  _WORD *v59;
  __int16 v60;
  int v61;
  size_t v62;
  __int16 *v63;
  uint64_t v64;
  int v65;
  char *v66;
  int v67;
  int v68;
  char *v69;
  __int16 *v70;
  uint64_t v71;
  _WORD *v72;
  unsigned int v73;
  int v74;
  uint64_t v75;
  int v76;
  int v77;
  int v78;
  __int16 *v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  unsigned int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  int v103;
  uint64_t v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  _DWORD *v113;
  uint64_t v114;
  int v115;
  _BOOL4 v117;
  _DWORD *v118;
  int *v119;
  int v120;
  int v121;
  signed int v122;
  BOOL v123;
  int v124;
  int v125;
  int v126;
  uint64_t v131;
  int v132;
  int v133;
  int v134;
  uint64_t v135;
  int v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  char *v140;
  int v141;
  int v142;
  uint64_t v143;
  int v144;
  int v145;
  int v146;
  int v147;
  _QWORD *v148;
  _OWORD *v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  int v154;
  _BOOL4 v155;
  int v156;
  _DWORD *v157;
  uint64_t v158;
  _OWORD *v159;
  void *v160;
  void *v161;
  _BYTE *v162;
  _QWORD *v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  _DWORD *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  __int16 *v173;
  unsigned __int16 *v174;
  int v175;
  _DWORD *v176;
  int v177;
  char *v178;
  int *v179;
  int v180;
  unsigned int v181;
  uint64_t v182;
  int v183;
  __int16 *v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  unsigned int v188;
  int v189;
  int v190;
  int v191;
  char *v192;
  _DWORD *v193;
  char *v194;
  _DWORD *v195;
  uint64_t *v196;
  __int16 v197;
  int v198[2];
  uint64_t v199;

  v179 = a6;
  v196 = a5;
  v10 = a2;
  v11 = (uint64_t)a1;
  v199 = *MEMORY[0x24BDAC8D0];
  if (a2[16])
  {
    a1[1174] = 1;
    a1[3624] = 1;
  }
  a1[3899] = 0;
  a1[1449] = 0;
  v12 = check_control_input(a2);
  if (v12)
    return 1;
  v14 = v11 + 19600;
  v10[21] = 0;
  LODWORD(v15) = v10[1];
  v16 = (int)v15 <= *(_DWORD *)(v11 + 19664);
  v170 = v11 + 9800;
  if (v16)
  {
    v17 = 0;
  }
  else
  {
    v17 = silk_init_encoder((_DWORD *)(v11 + 9800), *(_DWORD *)(v11 + 5140)) + (v12 != 0);
    *(_DWORD *)v14 = 0;
    *(_OWORD *)(v11 + 19608) = xmmword_214F962F0;
    *(_QWORD *)(v11 + 19624) = 0x400000000001;
    if (*(_DWORD *)(v11 + 19660) == 2)
    {
      memcpy((void *)(v11 + 15624), (const void *)(v11 + 5824), 0x130uLL);
      *(_QWORD *)(v11 + 9800) = *(_QWORD *)v11;
    }
    LODWORD(v15) = v10[1];
  }
  v18 = *(_DWORD *)(v11 + 4636);
  v168 = v10[6];
  v19 = v168 != v18 || *(_DWORD *)(v11 + 19664) != v15;
  *(_DWORD *)(v11 + 19660) = *v10;
  *(_DWORD *)(v11 + 19664) = v15;
  v20 = v10[2];
  v21 = 100 * a4 / v20;
  v22 = v21 >> 1;
  if (v21 <= 1)
    v22 = 1;
  v189 = v22;
  v195 = v10;
  if (a7)
  {
    if (v21 != 1)
      return 4294967195;
    if ((int)v15 < 1)
    {
      v10[6] = 10;
      HIDWORD(v158) = v10[9];
      v10[9] = 0;
      goto LABEL_48;
    }
    v184 = a3;
    v183 = a4;
    v23 = 0;
    v24 = (_DWORD *)v11;
    do
    {
      inited = silk_init_encoder(v24, v24[1285]);
      ++v23;
      v15 = (int)v10[1];
      v24 += 2450;
    }
    while (v23 < v15);
    v17 = inited;
    v168 = v10[6];
    v10[6] = 10;
    HIDWORD(v158) = v10[9];
    v10[9] = 0;
    if ((int)v15 < 1)
      goto LABEL_44;
    v26 = v15;
    v27 = (_DWORD *)(v11 + 4712);
    a4 = v183;
    do
    {
      *(v27 - 3) = 0;
      *v27 = 1;
      v27 += 2450;
      --v26;
    }
    while (v26);
  }
  else
  {
    result = 4294967195;
    if (a4 < 0 || v21 * v20 != 100 * a4 || 1000 * a4 > v20 * v168)
      return result;
    v184 = a3;
    v168 = 0;
    HIDWORD(v158) = 0;
  }
  _VF = __OFSUB__((_DWORD)v15, 1);
  v29 = v15 - 1;
  if (v29 < 0 == _VF)
  {
    v183 = a4;
    v30 = 0;
    v31 = (int)v10[7] >> v29;
    v32 = v11 + 4772;
    do
    {
      if (v30 == 1)
      {
        v33 = v11;
        v34 = *(_DWORD *)(v11 + 4600);
      }
      else
      {
        v34 = 0;
        v33 = v11;
      }
      v35 = (_DWORD *)(v33 + 9800 * v30);
      result = silk_control_encoder((uint64_t)v35, (uint64_t)v195, v31, *(_DWORD *)(v11 + 19676), v30, v34);
      if ((_DWORD)result)
        return result;
      if (v35[1174])
        v36 = 1;
      else
        v36 = v19;
      if (v36 == 1 && *(int *)(v11 + 5792) >= 1)
      {
        v37 = 0;
        do
          *(_DWORD *)(v32 + 4 * v37++) = 0;
        while (v37 < *(int *)(v11 + 5792));
      }
      v35[1533] = v35[1532];
      ++v30;
      v32 += 9800;
    }
    while (v30 < (int)v195[1]);
    v17 = 0;
    v10 = v195;
LABEL_44:
    a4 = v183;
  }
  a3 = v184;
LABEL_48:
  v163 = (_QWORD *)(v11 + 17024);
  v162 = (_BYTE *)(v11 + 14365);
  v38 = *(_DWORD *)(v11 + 4600);
  v164 = 10 * v21;
  v39 = *(_DWORD *)(v11 + 4580);
  v175 = v38 * 10 * v21;
  v40 = 2 * (v175 * v39 / (1000 * v38));
  v178 = (char *)&v158 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v178, v40);
  v41 = 0;
  v176 = (_DWORD *)(v11 + 5824);
  v169 = (_DWORD *)(v11 + 15624);
  v174 = (unsigned __int16 *)(v11 + 19600);
  v173 = (__int16 *)(v11 + 5148);
  v172 = v11 + 14948;
  v161 = (void *)(v11 + 17040);
  v160 = (void *)(v11 + 9944);
  v159 = (_OWORD *)(v11 + 14324);
  v191 = v189 - 1;
  v185 = 2 * v189;
  v187 = v11 + 4772;
  v167 = v11 + 6260;
  v166 = v11 + 6181;
  v165 = v11 + 4768;
  LODWORD(result) = v17;
  v171 = v11 + 19652;
  v42 = a7;
  v177 = a7;
  v186 = v11 + 19600;
  while (1)
  {
    v190 = v41;
    v183 = a4;
    v43 = *(_DWORD *)(v11 + 5788);
    if (*(_DWORD *)(v11 + 4608) - v43 >= v175)
      v44 = v175;
    else
      v44 = *(_DWORD *)(v11 + 4608) - v43;
    v45 = (v44 * *(_DWORD *)(v11 + 4580) / (1000 * *(_DWORD *)(v11 + 4600)));
    v46 = *v10;
    v184 = a3;
    v182 = v45;
    if (v46 != 2)
    {
LABEL_71:
      v62 = 2 * (int)v45;
      v63 = a3;
      v64 = v14;
      v65 = v42;
      v66 = v178;
      v67 = v45;
      v68 = result;
      memcpy(v178, v63, v62);
      v69 = v66;
      v42 = v65;
      v14 = v64;
      result = silk_resampler(v176, (_WORD *)(v11 + 2 * (v43 + 2) + 5144), v69, v67) + v68;
      v61 = *(_DWORD *)(v11 + 5788) + v44;
LABEL_81:
      *(_DWORD *)(v11 + 5788) = v61;
      goto LABEL_82;
    }
    v47 = v10[1];
    if (v47 == 1)
    {
      if ((int)v45 >= 1)
      {
        v70 = a3 + 1;
        v71 = v45;
        v72 = v178;
        do
        {
          v73 = *v70 + *(v70 - 1);
          *v72++ = (v73 & 1) + (v73 >> 1);
          v70 += 2;
          --v71;
        }
        while (v71);
      }
      result = silk_resampler(v176, (_WORD *)(v11 + 2 * (v43 + 2) + 5144), v178, v45)
             + result;
      v74 = *(_DWORD *)(v14 + 68);
      LODWORD(v194) = v44;
      if (v74 == 2 && !*(_DWORD *)(v11 + 5796))
      {
        result = silk_resampler(v169, (_WORD *)(v11 + 2 * *(int *)(v11 + 15588) + 14948), v178, v45)
               + result;
        v75 = *(unsigned int *)(v11 + 4608);
        if ((int)v75 >= 1)
        {
          v76 = *(_DWORD *)(v11 + 5788) + 2;
          v77 = *(_DWORD *)(v11 + 15588) + 2;
          do
          {
            *(_WORD *)(v11 + 2 * v76 + 5144) = (*(__int16 *)(v11 + 2 * v77 + 14944)
                                                              + *(__int16 *)(v11 + 2 * v76 + 5144)) >> 1;
            ++v76;
            ++v77;
            --v75;
          }
          while (v75);
        }
      }
      v61 = *(_DWORD *)(v11 + 5788) + (_DWORD)v194;
      goto LABEL_81;
    }
    if (v47 != 2)
      goto LABEL_71;
    v48 = result;
    if ((int)v45 >= 1)
    {
      v49 = v45;
      v50 = (__int16 *)v178;
      v51 = a3;
      do
      {
        v52 = *v51;
        v51 += 2;
        *v50++ = v52;
        --v49;
      }
      while (v49);
    }
    if (*(_DWORD *)(v14 + 68) == 1 && *(_DWORD *)(v11 + 5796) == 0)
      memcpy(v169, v176, 0x130uLL);
    v54 = silk_resampler(v176, (_WORD *)(v11 + 2 * (v43 + 2) + 5144), v178, v45);
    *(_DWORD *)(v11 + 5788) += v44;
    v55 = *(_DWORD *)(v11 + 15588);
    if (*(_DWORD *)(v11 + 14408) - v55 >= *(_DWORD *)(v11 + 14400) * v164)
      v56 = *(_DWORD *)(v11 + 14400) * v164;
    else
      v56 = *(_DWORD *)(v11 + 14408) - v55;
    if ((int)v45 >= 1)
    {
      v57 = a3 + 1;
      v58 = v45;
      v59 = v178;
      do
      {
        v60 = *v57;
        v57 += 2;
        *v59++ = v60;
        --v58;
      }
      while (v58);
    }
    result = v54 + v48 + silk_resampler(v169, (_WORD *)(v11 + 2 * (v55 + 2) + 14944), v178, v45);
    *(_DWORD *)(v11 + 15588) += v56;
    v61 = *(_DWORD *)(v11 + 5788);
    v42 = v177;
LABEL_82:
    v78 = *v10;
    *(_DWORD *)(v14 + 76) = 0;
    if (v61 < *(_DWORD *)(v11 + 4608))
      break;
    v180 = v78;
    v181 = result;
    v79 = v184;
    if (*(_DWORD *)(v11 + 5796) | v42)
      goto LABEL_116;
    v197 = 0;
    LOBYTE(v197) = -(0x100u >> (v10[1] + v10[1] * *(_DWORD *)(v11 + 5792)));
    ec_enc_icdf(v196, 0, (uint64_t)&v197, 8);
    v80 = v10[1];
    if (v80 >= 1)
    {
      v81 = 0;
      v82 = v187;
      do
      {
        v83 = v11 + 9800 * v81;
        v84 = *(unsigned int *)(v83 + 5792);
        if ((int)v84 < 1)
        {
          v86 = 0;
        }
        else
        {
          v85 = 0;
          v86 = 0;
          do
          {
            v86 |= *(_DWORD *)(v82 + 4 * v85) << v85;
            ++v85;
          }
          while (v84 != v85);
        }
        *(_BYTE *)(v83 + 4771) = v86 > 0;
        if (v86 && (int)v84 >= 2)
        {
          ec_enc_icdf(v196, v86 - 1, (uint64_t)*(&silk_LBRR_flags_iCDF_ptr + (v84 - 2)), 8);
          v80 = v10[1];
        }
        ++v81;
        v82 += 9800;
      }
      while (v81 < v80);
    }
    v87 = *(_DWORD *)(v11 + 5792);
    if (v87 < 1)
      goto LABEL_112;
    v88 = 0;
    v89 = -1;
    v90 = v187;
    v91 = v166;
    v92 = v167;
    do
    {
      if (v80 < 1)
        goto LABEL_111;
      v93 = 0;
      v94 = 0;
      v188 = v89;
      v95 = v187 + 4 * v89;
      v194 = (char *)(v11 + 19600 + 6 * v88 + 34);
      v96 = v11;
      v192 = (char *)(v11 + 19600 + v88 + 52);
      v193 = (_DWORD *)(v11 + 4 * v88 + 14572);
      do
      {
        if (!*(_DWORD *)(v90 + v93))
          goto LABEL_109;
        if (v93 || v80 != 2 || (silk_stereo_encode_pred(v196, v194), *v193))
        {
          if (!v88)
            goto LABEL_107;
        }
        else
        {
          silk_stereo_encode_mid_only(v196, *v192);
          if (!v88)
          {
LABEL_107:
            v97 = 0;
            goto LABEL_108;
          }
        }
        if (!*(_DWORD *)(v95 + v93))
          goto LABEL_107;
        v97 = 2;
LABEL_108:
        v98 = v196;
        silk_encode_indices(v96 + v93, v196, v88, 1, v97);
        silk_encode_pulses(v98, *(char *)(v91 + v93), *(char *)(v91 + v93 + 1), v92 + v93, *(_DWORD *)(v96 + v93 + 4608));
        v80 = v195[1];
LABEL_109:
        ++v94;
        v93 += 9800;
      }
      while (v94 < v80);
      v11 = v96;
      v87 = *(_DWORD *)(v96 + 5792);
      v10 = v195;
      v89 = v188;
LABEL_111:
      ++v88;
      ++v89;
      v92 += 320;
      v91 += 36;
      v90 += 4;
    }
    while (v88 < v87);
LABEL_112:
    if (v80 >= 1)
    {
      v99 = 0;
      v100 = v187;
      do
      {
        *(_DWORD *)(v100 + 8) = 0;
        *(_QWORD *)v100 = 0;
        ++v99;
        v100 += 9800;
      }
      while (v99 < (int)v10[1]);
    }
    v42 = v177;
    v14 = v186;
    v79 = v184;
LABEL_116:
    silk_HP_variable_cutoff(v11);
    v102 = v10[6];
    v101 = v10[7];
    v103 = v102 * v101 / 1000;
    if (!v42)
      v103 -= (int)(*((_DWORD *)v196 + 6) + __clz(*((_DWORD *)v196 + 8)) - 32) >> 1;
    v104 = *(int *)(v11 + 5796);
    v105 = (__int16)(v103 / (*(_DWORD *)(v11 + 5792) - (int)v104));
    if (v102 == 10)
      v106 = 100;
    else
      v106 = 50;
    v107 = v105 * v106 - 2 * *(_DWORD *)(v14 + 56);
    if (v101 <= 5000)
      v108 = 5000;
    else
      v108 = v10[7];
    if (v101 >= 5000)
      v101 = 5000;
    if (v107 > v101)
      v101 = v107;
    if (v107 <= v108)
      v109 = v101;
    else
      v109 = v108;
    if (v10[1] == 2)
    {
      v110 = v171;
      silk_stereo_LR_to_MS(v174, v173, v172, v11 + 6 * (int)v104 + 19634, (_BYTE *)(v171 + v104), v198, v109, *(_DWORD *)(v11 + 4556), v10[14], *(_DWORD *)(v11 + 4600), *(_DWORD *)(v11 + 4608));
      v111 = *(int *)(v11 + 5796);
      if (*(_BYTE *)(v110 + v111))
      {
        *(_BYTE *)(v11 + v111 + 14568) = 0;
        if (!v42)
          goto LABEL_195;
      }
      else
      {
        if (*(_DWORD *)(v14 + 80) == 1)
        {
          v148 = v163;
          *v163 = 0;
          v148[1] = 0;
          bzero(v161, 0x45CuLL);
          bzero(v160, 0x111CuLL);
          v149 = v159;
          *v159 = 0u;
          v149[1] = 0u;
          *(_QWORD *)(v11 + 9816) = 0;
          *(_DWORD *)(v11 + 14368) = 100;
          *(_DWORD *)(v11 + 14300) = 100;
          *(_BYTE *)v148 = 10;
          *v162 = 0;
          *(_DWORD *)(v11 + 14316) = 0x10000;
          *(_DWORD *)(v11 + 14496) = 1;
        }
        silk_encode_do_VAD_FIX(v170);
        if (!v42)
        {
LABEL_195:
          silk_stereo_encode_pred(v196, (char *)(v11 + 6 * *(int *)(v11 + 5796) + 19634));
          v150 = v11 + *(int *)(v11 + 5796);
          if (!*(_BYTE *)(v150 + 14568))
            silk_stereo_encode_mid_only(v196, *(char *)(v150 + 19652));
        }
      }
    }
    else
    {
      *(_DWORD *)(v11 + 5144) = *(_DWORD *)(v14 + 4);
      *(_DWORD *)(v14 + 4) = *(_DWORD *)(v11 + 5144 + 2 * *(int *)(v11 + 4608));
    }
    silk_encode_do_VAD_FIX(v11);
    v112 = v10[1];
    v113 = (_DWORD *)v11;
    if (v112 >= 1)
    {
      v114 = 0;
      v115 = v190;
      v117 = v189 == 2 && v190 == 0;
      v118 = v113;
      v119 = v179;
      result = v181;
      while (1)
      {
        v120 = v10[13];
        if (v117)
          break;
        v122 = v10[13];
        if (v189 != 3)
          goto LABEL_152;
        if (!v115)
        {
          v121 = 2 * v120;
          goto LABEL_146;
        }
        if (v115 == 1)
          v122 = 3 * v120 / 4;
        else
          v122 = v10[13];
LABEL_152:
        if (v10[12])
          v123 = v115 == v191;
        else
          v123 = 0;
        v124 = v123;
        if (v112 == 1)
        {
          v125 = v109;
        }
        else
        {
          v125 = v198[v114];
          if (!v114 && v198[1] >= 1)
          {
            v124 = 0;
            v122 -= v120 / v185;
          }
        }
        if (v125 >= 1)
        {
          silk_control_SNR((uint64_t)v113, v125);
          if (v114 >= (int)v118[1449])
          {
            v126 = 0;
          }
          else if (v114 && *(_DWORD *)(v186 + 80))
          {
            v126 = 1;
          }
          else
          {
            v126 = 2;
          }
          result = silk_encode_frame_FIX((uint64_t)v113, v119, v196, v126, v122, v124);
          v112 = v10[1];
          v115 = v190;
        }
        _X9 = v113 + 8799;
        v113[1175] = 0;
        v113[1447] = 0;
        __asm { PRFM            #0, [X9] }
        ++v113[1449];
        ++v114;
        v113 += 2450;
        if (v114 >= v112)
          goto LABEL_175;
      }
      v121 = 3 * v120;
LABEL_146:
      v122 = v121 / 5;
      goto LABEL_152;
    }
    v118 = (_DWORD *)v11;
    v119 = v179;
    v115 = v190;
    result = v181;
LABEL_175:
    v11 = (uint64_t)v118;
    v131 = (int)v118[1449];
    v14 = v186;
    *(_DWORD *)(v186 + 80) = *((char *)v118 + v131 + 19651);
    v132 = *v119;
    v42 = v177;
    v133 = v183;
    v134 = v182;
    if (v132 >= 1 && (_DWORD)v131 == *(_DWORD *)(v11 + 5792))
    {
      if (v112 < 1)
      {
        v136 = 0;
        if (v177)
          goto LABEL_184;
      }
      else
      {
        v135 = 0;
        v136 = 0;
        v137 = (char *)v165;
        do
        {
          v138 = v11 + 9800 * v135;
          v139 = *(unsigned int *)(v138 + 5792);
          if ((int)v139 >= 1)
          {
            v140 = v137;
            do
            {
              v141 = *v140++;
              v136 = v141 | (2 * v136);
              --v139;
            }
            while (v139);
          }
          v136 = *(char *)(v138 + 4771) | (2 * v136);
          ++v135;
          v137 += 9800;
        }
        while (v135 != v112);
        if (v177)
        {
LABEL_184:
          if (*(_DWORD *)(v11 + 6132) && (v10[1] == 1 || *(_DWORD *)(v11 + 15932)))
            *v179 = 0;
          v142 = v10[6];
          v143 = -274877907 * v142 * v10[7];
          v144 = (v143 >> 38) + ((unint64_t)v143 >> 63) + *(_DWORD *)(v14 + 56) + 8 * *v179;
          v145 = v144 & ~(v144 >> 31);
          if (v145 >= 10000)
            v145 = 10000;
          *(_DWORD *)(v14 + 56) = v145;
          v146 = *(_DWORD *)(v14 + 72);
          if (*(_DWORD *)(v11 + 4556) >= ((3188 * (__int16)v146) >> 16) + 13)
          {
            *(_DWORD *)(v14 + 76) = 0;
            v147 = v146 + v142;
          }
          else
          {
            v147 = 0;
            *(_DWORD *)(v14 + 76) = 1;
          }
          *(_DWORD *)(v14 + 72) = v147;
          goto LABEL_199;
        }
      }
      v151 = result;
      ec_enc_patch_initial_bits((uint64_t)v196, v136, v112 + v112 * v131);
      result = v151;
      v115 = v190;
      goto LABEL_184;
    }
LABEL_199:
    a3 = &v79[v180 * v134];
    v41 = v115 + 1;
    a4 = v133 - v134;
    if (!a4)
    {
      v152 = *(_DWORD *)(v14 + 76);
      goto LABEL_204;
    }
  }
  v152 = 0;
LABEL_204:
  v153 = v10[1];
  *(_DWORD *)(v14 + 68) = v153;
  v10[18] = v152;
  v154 = *(_DWORD *)(v11 + 4600);
  v155 = v154 == 16 && *(_DWORD *)(v11 + 28) == 0;
  v10[19] = v155;
  v10[17] = 1000 * (__int16)v154;
  if (v10[14])
    v156 = 0;
  else
    v156 = *(__int16 *)(v14 + 28);
  v10[20] = v156;
  if (v42)
  {
    v10[6] = v168;
    v10[9] = HIDWORD(v158);
    if ((int)v153 >= 1)
    {
      v157 = (_DWORD *)(v11 + 4712);
      do
      {
        *(v157 - 3) = 0;
        *v157 = 0;
        v157 += 2450;
        --v153;
      }
      while (v153);
    }
  }
  return result;
}

uint64_t silk_stereo_decode_pred(uint64_t a1, _DWORD *a2)
{
  int v4;
  int v5;
  uint64_t v6;
  char v7;
  char v8;
  int *v9;
  uint64_t v10;
  __int16 *v11;
  int v12;
  uint64_t result;
  _DWORD v14[6];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = ec_dec_icdf(a1, silk_stereo_pred_joint_iCDF, 8);
  v14[2] = v4 / 5;
  v14[5] = v4 % 5;
  v14[0] = ec_dec_icdf(a1, silk_uniform3_iCDF, 8);
  v14[1] = ec_dec_icdf(a1, "͚f3", 8);
  v14[3] = ec_dec_icdf(a1, silk_uniform3_iCDF, 8);
  v5 = ec_dec_icdf(a1, "͚f3", 8);
  v6 = 0;
  v14[4] = v5;
  v7 = 1;
  do
  {
    v8 = v7;
    v9 = &v14[3 * v6];
    v10 = *v9 + 3 * v9[2];
    *v9 = v10;
    v11 = (__int16 *)((char *)&silk_stereo_pred_quant_Q13 + 2 * v10);
    v12 = *v11;
    LODWORD(v11) = v11[1] - v12;
    result = (6554 * ((int)v11 >> 16));
    a2[v6] = v12
           + (result + ((6554 * (unsigned __int16)v11) >> 16)) * (__int16)((2 * *((_WORD *)v9 + 2)) | 1);
    v6 = 1;
    v7 = 0;
  }
  while ((v8 & 1) != 0);
  *a2 -= a2[1];
  return result;
}

uint64_t silk_stereo_decode_mid_only(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  result = ec_dec_icdf(a1, silk_stereo_only_code_mid_iCDF, 8);
  *a2 = result;
  return result;
}

uint64_t *silk_encode_indices(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  char *v8;
  int v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int v17;
  int v18;
  uint64_t *v19;
  unsigned __int8 *v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  _BYTE v31[16];
  _WORD v32[16];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (a4)
    v8 = (char *)(a1 + 36 * a3 + 6152);
  else
    v8 = (char *)(a1 + 4784);
  v9 = v8[30] + 2 * v8[29];
  if (a4 || v9 >= 2)
  {
    v9 -= 2;
    v10 = silk_type_offset_VAD_iCDF;
  }
  else
  {
    v10 = silk_type_offset_no_VAD_iCDF;
  }
  ec_enc_icdf(a2, v9, (uint64_t)v10, 8);
  v11 = *v8;
  if (a5 == 2)
  {
    v12 = silk_delta_gain_iCDF;
  }
  else
  {
    ec_enc_icdf(a2, v11 >> 3, (uint64_t)&silk_gain_iCDF[8 * v8[29]], 8);
    v11 = *v8 & 7;
    v12 = silk_uniform8_iCDF;
  }
  ec_enc_icdf(a2, v11, (uint64_t)v12, 8);
  if (*(int *)(a1 + 4604) > 1)
  {
    v13 = 1;
    do
      ec_enc_icdf(a2, v8[v13++], (uint64_t)silk_delta_gain_iCDF, 8);
    while (v13 < *(int *)(a1 + 4604));
  }
  ec_enc_icdf(a2, v8[8], *(_QWORD *)(*(_QWORD *)(a1 + 4736) + 16) + **(__int16 **)(a1 + 4736) * (uint64_t)(v8[29] >> 1), 8);
  silk_NLSF_unpack((uint64_t)v32, (uint64_t)v31, *(_QWORD *)(a1 + 4736), v8[8]);
  v14 = *(_QWORD *)(a1 + 4736);
  if (*(__int16 *)(v14 + 2) >= 1)
  {
    v15 = 0;
    v16 = v8 + 9;
    do
    {
      v17 = v16[v15];
      if (v17 < 4)
      {
        if (v17 > -4)
        {
          v18 = v17 + 4;
          v20 = (unsigned __int8 *)(*(_QWORD *)(v14 + 40) + (__int16)v32[v15]);
          v19 = a2;
          goto LABEL_22;
        }
        ec_enc_icdf(a2, 0, *(_QWORD *)(v14 + 40) + (__int16)v32[v15], 8);
        v18 = -4 - v16[v15];
      }
      else
      {
        ec_enc_icdf(a2, 8, *(_QWORD *)(v14 + 40) + (__int16)v32[v15], 8);
        v18 = v16[v15] - 4;
      }
      v19 = a2;
      v20 = silk_NLSF_EXT_iCDF;
LABEL_22:
      ec_enc_icdf(v19, v18, (uint64_t)v20, 8);
      ++v15;
      v14 = *(_QWORD *)(a1 + 4736);
    }
    while (v15 < *(__int16 *)(v14 + 2));
  }
  if (*(_DWORD *)(a1 + 4604) == 4)
    ec_enc_icdf(a2, v8[31], (uint64_t)silk_NLSF_interpolation_factor_iCDF, 8);
  if (v8[29] == 2)
  {
    if (a5 != 2
      || *(_DWORD *)(a1 + 5816) != 2
      || ((v21 = *((__int16 *)v8 + 13) - *(__int16 *)(a1 + 5820), v22 = v21 - 12, v23 = v21 + 9, v22 >= 0xFFFFFFEC)
        ? (v24 = v23)
        : (v24 = 0),
          ec_enc_icdf(a2, v24, (uint64_t)silk_pitch_delta_iCDF, 8),
          v22 <= 0xFFFFFFEB))
    {
      v25 = *((__int16 *)v8 + 13);
      v26 = *(_DWORD *)(a1 + 4600);
      v27 = v25 / (v26 >> 1);
      v28 = v25 - (__int16)v27 * (__int16)(v26 >> 1);
      ec_enc_icdf(a2, v27, (uint64_t)silk_pitch_lag_iCDF, 8);
      ec_enc_icdf(a2, v28, *(_QWORD *)(a1 + 4720), 8);
    }
    *(_WORD *)(a1 + 5820) = *((_WORD *)v8 + 13);
    ec_enc_icdf(a2, v8[28], *(_QWORD *)(a1 + 4728), 8);
    ec_enc_icdf(a2, v8[32], (uint64_t)silk_LTP_per_index_iCDF, 8);
    if (*(int *)(a1 + 4604) >= 1)
    {
      v29 = 0;
      do
        ec_enc_icdf(a2, v8[v29++ + 4], (uint64_t)*(&silk_LTP_gain_iCDF_ptrs + v8[32]), 8);
      while (v29 < *(int *)(a1 + 4604));
    }
    if (!a5)
      ec_enc_icdf(a2, v8[33], (uint64_t)silk_LTPscale_iCDF, 8);
  }
  *(_DWORD *)(a1 + 5816) = v8[29];
  return ec_enc_icdf(a2, v8[34], (uint64_t)silk_uniform4_iCDF, 8);
}

uint64_t silk_HP_variable_cutoff(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  __int16 v5;
  int v6;
  int v7;
  signed int v8;
  int v9;
  signed int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;

  if (*(_BYTE *)(result + 4565) == 2)
  {
    v1 = result;
    v2 = silk_lin2log(65536000 * *(_DWORD *)(result + 4600) / *(_DWORD *)(result + 4568));
    v3 = ((-4 * *(_DWORD *)(v1 + 4744)) >> 16) * (__int16)*(_DWORD *)(v1 + 4744)
       + (((unsigned __int16)(-4 * *(_DWORD *)(v1 + 4744)) * (__int16)*(_DWORD *)(v1 + 4744)) >> 16);
    v4 = (__int16)(v2 - silk_lin2log(0x3C0000u));
    v5 = silk_lin2log(0x3C0000u);
    v6 = *(_DWORD *)(v1 + 8);
    v7 = v2 - (v6 >> 8) + (v3 >> 16) * v4 + (((unsigned __int16)v3 * (__int16)(v2 - v5)) >> 16) - 2048;
    if (v7 < 0)
      v7 *= 3;
    if (v7 <= -51)
      v7 = -51;
    if (v7 >= 51)
      v7 = 51;
    *(_DWORD *)(v1 + 8) = v6
                        + 6554 * ((v7 * *(__int16 *)(v1 + 4556)) >> 16)
                        + ((6554 * (unsigned __int16)(v7 * *(_WORD *)(v1 + 4556))) >> 16);
    v8 = silk_lin2log(0x3Cu) << 8;
    v9 = silk_lin2log(0x64u);
    v10 = *(_DWORD *)(v1 + 8);
    if (v8 <= v9 << 8)
    {
      if (v10 > (int)(silk_lin2log(0x64u) << 8))
      {
LABEL_13:
        v12 = 100;
LABEL_16:
        result = silk_lin2log(v12);
        v14 = (_DWORD)result << 8;
LABEL_18:
        *(_DWORD *)(v1 + 8) = v14;
        return result;
      }
      v13 = *(_DWORD *)(v1 + 8);
      result = silk_lin2log(0x3Cu);
      if (v13 >= (_DWORD)result << 8)
      {
LABEL_17:
        v14 = *(_DWORD *)(v1 + 8);
        goto LABEL_18;
      }
    }
    else if (v10 <= (int)(silk_lin2log(0x3Cu) << 8))
    {
      v11 = *(_DWORD *)(v1 + 8);
      result = silk_lin2log(0x64u);
      if (v11 >= (_DWORD)result << 8)
        goto LABEL_17;
      goto LABEL_13;
    }
    v12 = 60;
    goto LABEL_16;
  }
  return result;
}

uint64_t *silk_encode_signs(uint64_t *result, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  _BYTE v14[2];

  v14[1] = 0;
  if (a3 >= 8)
  {
    v8 = result;
    v9 = 0;
    v10 = (char *)&silk_sign_iCDF + 8 * (((a5 << 16) + (a4 << 17)) >> 16) - (((a5 << 16) + (a4 << 17)) >> 16);
    v11 = (a3 + 8) >> 4;
    do
    {
      if (*(int *)(a6 + 4 * v9) >= 1)
      {
        v12 = 0;
        v13 = *(_DWORD *)(a6 + 4 * v9) & 0x1F;
        if (v13 >= 6)
          v13 = 6;
        v14[0] = v10[v13];
        do
        {
          if (*(_BYTE *)(a2 + v12))
            result = ec_enc_icdf(v8, (*(_BYTE *)(a2 + v12) & 0x80) == 0, (uint64_t)v14, 8);
          ++v12;
        }
        while (v12 != 16);
      }
      a2 += 16;
      ++v9;
    }
    while (v9 != v11);
  }
  return result;
}

uint64_t silk_decode_signs(uint64_t result, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned __int8 v14[2];

  v14[1] = 0;
  if (a3 >= 8)
  {
    v8 = result;
    v9 = 0;
    v10 = (char *)&silk_sign_iCDF + 8 * (((a5 << 16) + (a4 << 17)) >> 16) - (((a5 << 16) + (a4 << 17)) >> 16);
    v11 = (a3 + 8) >> 4;
    do
    {
      if (*(int *)(a6 + 4 * v9) >= 1)
      {
        v12 = 0;
        v13 = *(_DWORD *)(a6 + 4 * v9) & 0x1F;
        if (v13 >= 6)
          v13 = 6;
        v14[0] = v10[v13];
        do
        {
          if (*(int *)(a2 + v12) >= 1)
          {
            result = ec_dec_icdf(v8, v14, 8);
            *(_DWORD *)(a2 + v12) *= 2 * (_DWORD)result - 1;
          }
          v12 += 4;
        }
        while (v12 != 64);
      }
      a2 += 64;
      ++v9;
    }
    while (v9 != v11);
  }
  return result;
}

uint64_t silk_log2lin(unsigned int a1)
{
  unsigned int v2;
  int v3;
  int v4;

  if ((a1 & 0x80000000) != 0)
    return 0;
  if (a1 > 0xF7E)
    return 0x7FFFFFFFLL;
  v2 = 1 << (a1 >> 7);
  v3 = (a1 & 0x7F) + ((int)(-174 * (a1 & 0x7F) * (128 - (a1 & 0x7F))) >> 16);
  v4 = v3 << (a1 >> 7) >> 7;
  if (a1 > 0x7FF)
    v4 = v3 * (v2 >> 7);
  return v4 + v2;
}

uint64_t silk_biquad_alt(uint64_t result, int *a2, _DWORD *a3, int *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;

  if (a6 >= 1)
  {
    v7 = 0;
    v8 = -*a3 & 0x3FFF;
    v9 = (-4 * *a3) >> 16;
    v10 = -a3[1] & 0x3FFF;
    v11 = (-4 * a3[1]) >> 16;
    v12 = a6;
    v13 = *a4;
    v14 = a4[1];
    v15 = 2 * a7;
    do
    {
      v16 = *(__int16 *)(result + v7);
      v17 = v13 + (*a2 >> 16) * v16 + (((unsigned __int16)*a2 * v16) >> 16);
      v18 = (__int16)(v17 >> 14);
      v19 = v14
          + v18 * v9
          + (((unsigned __int16)(4 * v17) * v9) >> 16)
          + ((((int)(v18 * v8 + (((unsigned __int16)(4 * v17) * v8) >> 16)) >> 13) + 1) >> 1);
      *a4 = v19;
      v13 = (a2[1] >> 16) * v16 + (((unsigned __int16)a2[1] * v16) >> 16) + v19;
      v20 = v18 * v11
          + (((unsigned __int16)(4 * v17) * v11) >> 16)
          + ((((int)(v18 * v10 + (((unsigned __int16)(4 * v17) * v10) >> 16)) >> 13) + 1) >> 1);
      *a4 = v13;
      a4[1] = v20;
      v14 = (a2[2] >> 16) * v16 + (((unsigned __int16)a2[2] * v16) >> 16) + v20;
      a4[1] = v14;
      v21 = (4 * v17 + 0x3FFF) >> 14;
      if (v21 <= -32768)
        LOWORD(v21) = 0x8000;
      if (4 * v17 > 536854528)
        LOWORD(v21) = 0x7FFF;
      *(_WORD *)(a5 + v7) = v21;
      v7 += v15;
      --v12;
    }
    while (v12);
  }
  return result;
}

unsigned int *silk_resampler_private_up2_HQ(unsigned int *result, uint64_t a2, __int16 *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  __int16 *v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int v23;
  BOOL v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;

  if ((int)a4 >= 1)
  {
    v4 = *result;
    v5 = result[1];
    v6 = (__int16 *)(a2 + 2);
    v8 = result[2];
    v7 = result[3];
    v10 = result[4];
    v9 = result[5];
    a4 = a4;
    do
    {
      v11 = *a3++;
      v12 = 1746 * ((int)((v11 << 10) - v4) >> 16)
          + ((1746 * (unsigned __int16)(((_WORD)v11 << 10) - v4)) >> 16);
      v13 = v12 + v4;
      v4 = v12 + (v11 << 10);
      v14 = 14986 * ((int)(v13 - v5) >> 16) + ((14986 * (unsigned __int16)(v13 - v5)) >> 16);
      v15 = v14 + v5;
      v5 = v14 + v13;
      v16 = v15 - v8;
      v17 = 6854 * ((int)((v11 << 10) - v7) >> 16)
          + ((6854 * (unsigned __int16)(((_WORD)v11 << 10) - v7)) >> 16);
      v18 = v17 + v7;
      v19 = -26453 * (v16 >> 16) + ((-26453 * (unsigned __int16)v16) >> 16) + v15;
      v7 = v17 + (v11 << 10);
      v8 = v19 + v16;
      v20 = 25769 * ((int)(v18 - v10) >> 16) + ((25769 * (unsigned __int16)(v18 - v10)) >> 16);
      v21 = ((v19 >> 9) + 1) >> 1;
      if (v21 <= -32768)
        LOWORD(v21) = 0x8000;
      v22 = v20 + v10;
      v10 = v20 + v18;
      v23 = v22 - v9;
      v24 = v19 <= 33553919;
      v25 = -9994 * (v23 >> 16) + ((-9994 * (unsigned __int16)v23) >> 16) + v22;
      if (v24)
        v26 = v21;
      else
        v26 = 0x7FFF;
      v9 = v25 + v23;
      *(v6 - 1) = v26;
      if (((v25 >> 9) + 1) >> 1 <= -32768)
        LOWORD(v27) = 0x8000;
      else
        v27 = ((v25 >> 9) + 1) >> 1;
      if (v25 <= 33553919)
        v28 = v27;
      else
        v28 = 0x7FFF;
      *v6 = v28;
      v6 += 2;
      --a4;
    }
    while (a4);
    *result = v4;
    result[1] = v5;
    result[2] = v8;
    result[3] = v7;
    result[4] = v10;
    result[5] = v9;
  }
  return result;
}

uint64_t silk_NLSF_del_dec_quant(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, __int16 a9, __int16 a10, unsigned __int16 a11)
{
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int16 v20;
  int v21;
  _BYTE *v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  int v32;
  BOOL v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  _WORD *v43;
  int *v44;
  int v45;
  int v46;
  int v47;
  __int16 v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  _BYTE *v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  uint64_t v76;
  _DWORD v77[8];
  _DWORD v78[4];
  uint64_t v79;
  _WORD v80[4];
  _BYTE v81[104];

  *(_QWORD *)&v81[88] = *MEMORY[0x24BDAC8D0];
  v11 = a8 >> 16;
  v12 = (unsigned __int16)a8;
  v78[0] = 0;
  v13 = (__int16)a11;
  v80[0] = 0;
  v14 = 1;
LABEL_2:
  v15 = v14;
  while (1)
  {
    v16 = v13--;
    if ((int)v15 < 1)
      goto LABEL_54;
    v17 = 0;
    v18 = a6 + *(__int16 *)(a5 + 2 * v13);
    v19 = *(unsigned __int8 *)(a4 + v13) << 8;
    v20 = *(_WORD *)(a2 + 2 * v13);
    v76 = v13;
    v21 = *(__int16 *)(a3 + 2 * v13);
    v22 = &v81[7];
    v23 = v15;
    do
    {
      v24 = v19 * (__int16)v80[v17];
      v25 = v24 >> 16;
      v26 = v11 * (__int16)(v20 - HIWORD(v24)) + ((v12 * (__int16)(v20 - HIWORD(v24))) >> 16);
      if (v26 <= -10)
        v26 = -10;
      if (v26 >= 9)
        v27 = 9;
      else
        v27 = v26;
      v22[v16] = v27;
      v28 = v27 << 10;
      v29 = (v27 << 10) + 1024;
      v30 = (v27 << 10) | 0x66;
      if (v27 == -1)
        v30 = -922;
      else
        v29 = (v27 << 10) + 1126;
      if (!v27)
      {
        v30 = 0;
        v29 = 922;
      }
      v31 = v28 - 102;
      v32 = v28 | 0x39A;
      v33 = v26 < 1;
      if (v26 >= 1)
        v34 = v31;
      else
        v34 = v30;
      if (!v33)
        v29 = v32;
      v35 = HIWORD(v29);
      v36 = (unsigned __int16)v29 * (__int16)a7;
      v37 = v25 + HIWORD(v34) * a7 + (((unsigned __int16)v34 * (__int16)a7) >> 16);
      v38 = v25 + v35 * a7 + HIWORD(v36);
      v80[v17] = v37;
      v80[v23] = v25 + v35 * a7 + HIWORD(v36);
      if (v27 < 3)
      {
        if (v27 > -4)
        {
          v39 = *(unsigned __int8 *)(v18 + (v27 + 4));
          v40 = *(unsigned __int8 *)(v18 + (v27 + 5));
        }
        else if (v27 == -4)
        {
          v40 = *(unsigned __int8 *)(v18 + 1);
          v39 = 280;
        }
        else
        {
          v39 = -43 * v27 + 108;
          v40 = -43 * v27 + 65;
        }
      }
      else if (v27 == 3)
      {
        v39 = *(unsigned __int8 *)(v18 + 7);
        v40 = 280;
      }
      else
      {
        v39 = 43 * v27 + 108;
        v40 = 43 * v27 + 151;
      }
      v41 = v78[v17];
      v78[v17] = v41 + v39 * a9 + (__int16)(v20 - v37) * (__int16)(v20 - v37) * v21;
      v78[v23] = v41 + v40 * a9 + (__int16)(v20 - v38) * (__int16)(v20 - v38) * v21;
      ++v17;
      ++v23;
      v22 += 16;
    }
    while (v15 != v17);
    if ((int)v15 <= 2)
    {
      v60 = 0;
      v13 = v76;
      do
      {
        v81[16 * v15 + 7 + v16 + v60] = v81[v16 + 7 + v60] + 1;
        v60 += 16;
      }
      while (16 * v15 != v60);
LABEL_54:
      v14 = 2 * v15;
      if (v15 <= 1)
      {
        v61 = (int)v14;
        if (v14 <= 3)
          v62 = 3;
        else
          v62 = 2 * v15;
        v63 = v62 + 1;
        v64 = &v81[7];
        do
        {
          v81[16 * v61++ + 8 + v13] = v64[v16];
          v64 += 16;
        }
        while (v63 != v61);
      }
      goto LABEL_2;
    }
    if (v16 < 2)
      break;
    v42 = 0;
    v43 = v81;
    v44 = (int *)&v79;
    v13 = v76;
    do
    {
      v45 = *(v44 - 4);
      v46 = *v44;
      if (v45 <= *v44)
      {
        v49 = *v44;
        v46 = *(v44 - 4);
        v47 = v42;
      }
      else
      {
        v47 = v42 + 4;
        *(v44 - 4) = v46;
        *v44 = v45;
        v48 = *(v43 - 4);
        *(v43 - 4) = *v43;
        *v43 = v48;
        v49 = v45;
      }
      v77[v42] = v49;
      v77[v42 + 4] = v46;
      *(_DWORD *)&v81[4 * v42++ + 72] = v47;
      ++v44;
      ++v43;
    }
    while (v42 != 4);
    v50 = 0;
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 0x7FFFFFFF;
    while (1)
    {
      do
      {
        v55 = v77[v50];
        if (v54 > v55)
          v53 = v50;
        v56 = v77[v50 + 4];
        if (v54 >= v55)
          v54 = v77[v50];
        if (v51 < v56)
          v52 = v50;
        if (v51 <= v56)
          v51 = v77[v50 + 4];
        ++v50;
      }
      while (v50 != 4);
      if (v54 >= v51)
        break;
      v50 = 0;
      v51 = 0;
      *(_DWORD *)&v81[4 * v52 + 72] = *(_DWORD *)&v81[4 * v53 + 72] ^ 4;
      v57 = v53 + 4;
      v78[v52] = v78[v57];
      v80[v52] = v80[v57];
      v77[v52 + 4] = 0;
      v54 = 0x7FFFFFFF;
      v77[v53] = 0x7FFFFFFF;
      *(_OWORD *)&v81[16 * v52 + 8] = *(_OWORD *)&v81[16 * v53 + 8];
      v52 = 0;
      v53 = 0;
    }
    v58 = 0;
    v59 = &v81[7];
    do
    {
      v59[v16] += *(_DWORD *)&v81[v58 + 72] >> 2;
      v58 += 4;
      v59 += 16;
    }
    while (v58 != 16);
  }
  v65 = 0;
  v66 = 0;
  LODWORD(v67) = 0x7FFFFFFF;
  do
  {
    v68 = v78[v65];
    if ((int)v67 > v68)
      v66 = v65;
    if ((int)v67 >= v68)
      v67 = v68;
    else
      v67 = v67;
    ++v65;
  }
  while (v65 != 8);
  if ((__int16)a11 >= 1)
    memcpy(a1, &v81[16 * (v66 & 3) + 8], a11);
  *a1 += v66 >> 2;
  return v67;
}

int *silk_bwexpander_32(int *result, int a2, int a3)
{
  int v3;
  int v4;
  uint64_t v5;
  int *v6;

  if (a2 >= 2)
  {
    v4 = a3 - 0x10000;
    v5 = (a2 - 1);
    v6 = result;
    do
    {
      *v6 = (__int16)*v6 * (a3 >> 16) + (((__int16)*v6 * (unsigned __int16)a3) >> 16) + (((*v6 >> 15) + 1) >> 1) * a3;
      ++v6;
      a3 += (((a3 * v4) >> 15) + 1) >> 1;
      --v5;
    }
    while (v5);
  }
  v3 = a2 - 1;
  result[v3] = (__int16)result[v3] * (a3 >> 16)
             + (((__int16)result[v3] * (unsigned __int16)a3) >> 16)
             + (((result[v3] >> 15) + 1) >> 1) * a3;
  return result;
}

void *silk_resampler_private_down_FIR(uint64_t a1, _WORD *a2, __int16 *a3, int a4)
{
  int v8;
  uint64_t v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int16 *i;
  int32x4_t v16;
  int32x4_t v17;
  int v18;
  int v19;
  BOOL v20;
  int8x16_t v21;
  int v22;
  char *v23;
  int32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int32x4_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int8x16_t v46;
  char *v47;
  int v48;
  int16x8_t *v49;
  int32x4_t v50;
  uint64_t v51;
  int32x4_t v52;
  int16x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int8x16_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int v62;
  int v63;
  int8x16_t v64;
  int j;
  int32x4_t *v66;
  int8x16_t v67;
  int8x16_t v68;
  int32x4_t v69;
  int32x4_t v70;
  int16x8_t v71;
  int32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  int32x4_t v75;
  int8x16_t v76;
  int32x4_t v77;
  int32x4_t v78;
  int v79;
  int v80;
  size_t v81;
  void *v83[2];

  v83[1] = *(void **)MEMORY[0x24BDAC8D0];
  v8 = *(_DWORD *)(a1 + 268);
  v9 = *(int *)(a1 + 276);
  v10 = 4 * ((int)v9 + v8);
  v11 = (char *)v83 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v11, v10);
  v83[0] = (void *)(a1 + 24);
  memcpy(v11, (const void *)(a1 + 24), 4 * v9);
  v12 = *(_QWORD *)(a1 + 296);
  v13 = v12 + 4;
  v14 = *(_DWORD *)(a1 + 272);
  for (i = (__int16 *)v12; ; i = *(__int16 **)(a1 + 296))
  {
    if (a4 < v8)
      v8 = a4;
    silk_resampler_private_AR2((int *)a1, (int *)&v11[4 * (int)v9], a3, i, v8);
    v18 = v8 << 16;
    v19 = *(_DWORD *)(a1 + 276);
    if (v19 == 18)
    {
      if (v18 >= 1)
      {
        v44 = 0;
        v45 = *(_DWORD *)(a1 + 280);
        v46.i64[0] = 0xFFFF0000FFFFLL;
        v46.i64[1] = 0xFFFF0000FFFFLL;
        do
        {
          v47 = &v11[4 * (v44 >> 16)];
          v48 = (unsigned __int16)v44 * (__int16)v45;
          v49 = (int16x8_t *)(v13 + 18 * (v48 >> 16));
          v50 = *((int32x4_t *)v47 + 1);
          v51 = v13 + 18 * (v45 + ~(v48 >> 16));
          v52 = *(int32x4_t *)(v47 + 56);
          v16.i64[0] = *((_QWORD *)v47 + 6);
          v53.i16[0] = v49[1].i16[0];
          v53.i16[1] = *(_WORD *)v51;
          v53.i32[1] = *(_DWORD *)(v51 + 2);
          v54 = vmovl_s16(v53);
          v55 = vmovl_high_s16(*v49);
          v56 = vmovl_s16(*(int16x4_t *)v49->i8);
          v57 = vmovl_s16(*(int16x4_t *)(v51 + 6));
          v17.i32[0] = *((_DWORD *)v47 + 8);
          v58 = (int8x16_t)vrev64q_s32((int32x4_t)vextq_s8((int8x16_t)v52, (int8x16_t)v17, 4uLL));
          v59 = vuzp1q_s32(v52, v16);
          v59.i32[1] = v16.i32[1];
          v59.i32[3] = *((_DWORD *)v47 + 11);
          v60 = (int32x4_t)vextq_s8(v58, v58, 8uLL);
          v61 = vmulq_s32(vshrq_n_s32(v60, 0x10uLL), v54);
          v16 = vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v60, v46), v54);
          v17 = vmlaq_s32(vmulq_s32(vshrq_n_s32(v59, 0x10uLL), v57), vshrq_n_s32(v50, 0x10uLL), v55);
          v62 = vaddvq_s32(vaddq_s32(vaddq_s32(vsraq_n_s32(vshrq_n_s32(vmulq_s32((int32x4_t)vandq_s8(*(int8x16_t *)v47, v46), v56), 0x10uLL), v16, 0x10uLL), vsraq_n_s32(vshrq_n_s32(vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v50, v46), v55), 0x10uLL), vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v59, v46), v57), 0x10uLL)), vaddq_s32(vmlaq_s32(v61, vshrq_n_s32(*(int32x4_t *)v47, 0x10uLL), v56), v17)))+ (((unsigned __int16)*((_DWORD *)v47 + 10) * *(__int16 *)(v51 + 14)) >> 16)+ (*((int *)v47 + 10) >> 16) * *(__int16 *)(v51 + 14)+ (((unsigned __int16)*((_DWORD *)v47 + 9) * *(__int16 *)(v51 + 16)) >> 16)+ (*((int *)v47 + 9) >> 16) * *(__int16 *)(v51 + 16);
          if (v62 <= 2097119)
          {
            v63 = ((v62 >> 5) + 1) >> 1;
            if (v63 <= -32768)
              LOWORD(v63) = 0x8000;
          }
          else
          {
            LOWORD(v63) = 0x7FFF;
          }
          *a2++ = v63;
          v44 += v14;
        }
        while (v44 < v18);
      }
    }
    else if (v19 == 24)
    {
      v64.i64[0] = 0xFFFF0000FFFFLL;
      v64.i64[1] = 0xFFFF0000FFFFLL;
      if (v18 >= 1)
      {
        for (j = 0; j < v18; j += v14)
        {
          v66 = (int32x4_t *)&v11[4 * (j >> 16)];
          v67 = (int8x16_t)vrev64q_s32(v66[5]);
          v68 = (int8x16_t)vrev64q_s32(v66[4]);
          v69 = vaddq_s32((int32x4_t)vextq_s8(v68, v68, 8uLL), v66[1]);
          v70 = vaddq_s32((int32x4_t)vextq_s8(v67, v67, 8uLL), *v66);
          v71 = *(int16x8_t *)(v12 + 4);
          v72 = vmovl_s16(*(int16x4_t *)v71.i8);
          v73 = vmovl_high_s16(v71);
          v74 = vmulq_s32(vshrq_n_s32(v69, 0x10uLL), v73);
          v75 = vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v69, v64), v73);
          v76 = (int8x16_t)vrev64q_s32(v66[3]);
          v77 = vaddq_s32((int32x4_t)vextq_s8(v76, v76, 8uLL), v66[2]);
          v78 = vmovl_s16(*(int16x4_t *)(v12 + 20));
          v79 = vaddvq_s32(vaddq_s32(vaddq_s32(vsraq_n_s32(vmulq_s32(vshrq_n_s32(v77, 0x10uLL), v78), vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v77, v64), v78), 0x10uLL), vmlaq_s32(v74, vshrq_n_s32(v70, 0x10uLL), v72)), vsraq_n_s32(vshrq_n_s32(vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v70, v64), v72), 0x10uLL), v75, 0x10uLL)));
          if (v79 <= 2097119)
          {
            v80 = ((v79 >> 5) + 1) >> 1;
            if (v80 <= -32768)
              LOWORD(v80) = 0x8000;
          }
          else
          {
            LOWORD(v80) = 0x7FFF;
          }
          *a2++ = v80;
        }
      }
    }
    else
    {
      v20 = v19 != 36 || v18 < 1;
      v21.i64[0] = 0xFFFF0000FFFFLL;
      v21.i64[1] = 0xFFFF0000FFFFLL;
      if (!v20)
      {
        v22 = 0;
        do
        {
          v23 = &v11[4 * (v22 >> 16)];
          v24.i64[0] = *((_QWORD *)v23 + 6);
          v24.i32[2] = *((_DWORD *)v23 + 14);
          v24.i32[3] = *((_DWORD *)v23 + 20);
          v25 = (int8x16_t)vrev64q_s32(*((int32x4_t *)v23 + 8));
          v26 = (int8x16_t)vrev64q_s32(*((int32x4_t *)v23 + 7));
          v27 = (int8x16_t)vrev64q_s32(*((int32x4_t *)v23 + 6));
          *(int32x2_t *)v28.i8 = vrev64_s32(*(int32x2_t *)(v23 + 88));
          v28.i32[2] = *((_DWORD *)v23 + 21);
          v28.i32[3] = *((_DWORD *)v23 + 15);
          v29 = vaddq_s32(v24, v28);
          v30 = vaddq_s32(*((int32x4_t *)v23 + 1), (int32x4_t)vextq_s8(v26, v26, 8uLL));
          v31 = vaddq_s32(*((int32x4_t *)v23 + 2), (int32x4_t)vextq_s8(v27, v27, 8uLL));
          v32 = vaddq_s32(*(int32x4_t *)v23, (int32x4_t)vextq_s8(v25, v25, 8uLL));
          v33 = *(int16x8_t *)(v12 + 20);
          v34 = *(int16x8_t *)(v12 + 4);
          v35 = vmovl_s16(*(int16x4_t *)v34.i8);
          v36 = vmovl_s16(*(int16x4_t *)v33.i8);
          v37 = vmovl_high_s16(v34);
          v38 = vmovl_high_s16(v33);
          v39 = *(__int16 *)(v12 + 36);
          v40 = ((*((_DWORD *)v23 + 19) + *((_DWORD *)v23 + 16)) >> 16) * v39;
          v41 = (unsigned __int16)(*((_WORD *)v23 + 38) + *((_WORD *)v23 + 32)) * v39;
          LODWORD(v23) = *((_DWORD *)v23 + 18) + *((_DWORD *)v23 + 17);
          v42 = vaddvq_s32(vaddq_s32(vaddq_s32(vsraq_n_s32(vshrq_n_s32(vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v32, v21), v35), 0x10uLL), vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v31, v21), v36), 0x10uLL), vsraq_n_s32(vshrq_n_s32(vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v30, v21), v37), 0x10uLL), vmulq_s32((int32x4_t)vandq_s8((int8x16_t)v29, v21), v38), 0x10uLL)), vaddq_s32(vmlaq_s32(vmulq_s32(vshrq_n_s32(v31, 0x10uLL), v36), vshrq_n_s32(v32, 0x10uLL), v35), vmlaq_s32(vmulq_s32(vshrq_n_s32(v29, 0x10uLL), v38), vshrq_n_s32(v30, 0x10uLL), v37))))+ (v41 >> 16)+ v40+ (((unsigned __int16)v23 * *(__int16 *)(v12 + 38)) >> 16)+ ((int)v23 >> 16) * *(__int16 *)(v12 + 38);
          if (v42 <= 2097119)
          {
            v43 = ((v42 >> 5) + 1) >> 1;
            if (v43 <= -32768)
              LOWORD(v43) = 0x8000;
          }
          else
          {
            LOWORD(v43) = 0x7FFF;
          }
          *a2++ = v43;
          v22 += v14;
        }
        while (v22 < v18);
      }
    }
    a4 -= v8;
    v81 = 4 * v19;
    if (a4 <= 1)
      break;
    a3 += v8;
    memcpy(v11, &v11[4 * v8], v81);
    v8 = *(_DWORD *)(a1 + 268);
    LODWORD(v9) = *(_DWORD *)(a1 + 276);
  }
  return memcpy(v83[0], &v11[4 * v8], v81);
}

_WORD *silk_NLSF_VQ_weights_laroia(_WORD *result, __int16 *a2, int a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  unint64_t v9;
  __int16 *v10;
  _WORD *v11;
  unint64_t v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;

  v3 = *a2;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = *a2;
  v5 = 0x20000 / v4;
  v6 = a2[1] - v3;
  if (v6 <= 1)
    v6 = 1;
  v7 = 0x20000u / v6;
  v8 = 0x20000u / v6 + v5;
  if (v8 >= 0x7FFF)
    LOWORD(v8) = 0x7FFF;
  *result = v8;
  v9 = (a3 - 1);
  if (a3 <= 2)
  {
    v9 = (int)v9;
  }
  else
  {
    v10 = a2 + 2;
    v11 = result + 2;
    v12 = 1;
    do
    {
      v13 = *v10 - *(v10 - 1);
      if (v13 <= 1)
        v13 = 1;
      v14 = 0x20000u / v13;
      v15 = v14 + v7;
      if (v15 >= 0x7FFF)
        LOWORD(v15) = 0x7FFF;
      *(v11 - 1) = v15;
      v12 += 2;
      v16 = v10[1] - *v10;
      if (v16 <= 1)
        v16 = 1;
      v7 = 0x20000u / v16;
      v17 = v7 + v14;
      if (v17 >= 0x7FFF)
        LOWORD(v17) = 0x7FFF;
      *v11 = v17;
      v11 += 2;
      v10 += 2;
    }
    while (v12 < v9);
  }
  v18 = 0x20000u / (0x8000 - a2[v9]) + v7;
  if (v18 >= 0x7FFF)
    LOWORD(v18) = 0x7FFF;
  result[v9] = v18;
  return result;
}

__n128 silk_resampler_down2_3(__n128 *a1, __int16 *a2, __int16 *a3, int a4)
{
  __int16 *v8;
  int v9;
  int v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 *v23;
  uint64_t v24;
  __n128 result;
  __int16 *v26;
  int v27;
  __n128 i;
  int v29[480];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  bzero(v29, 0x780uLL);
  v8 = a3;
  for (i = *a1; ; i = *(__n128 *)((char *)&i + 4 * v24))
  {
    v27 = a4;
    if (a4 >= 480)
      a4 = 480;
    v26 = v8;
    silk_resampler_private_AR2((int *)&a1[1], v29, v8, silk_Resampler_2_3_COEFS_LQ, a4);
    if (a4 >= 3)
    {
      v9 = i.n128_u32[0];
      v10 = a4 + 3;
      v11 = v29;
      do
      {
        v12 = 4697 * (v9 >> 16);
        v13 = 4697 * (unsigned __int16)v9;
        v14 = *(v11 - 3) >> 16;
        v15 = (unsigned __int16)*(v11 - 3);
        v16 = 8276 * (*(v11 - 2) >> 16) + ((8276 * (unsigned __int16)*(v11 - 2)) >> 16);
        v9 = *(v11 - 1);
        v17 = v12
            + (v13 >> 16)
            + 10739 * v14
            + ((10739 * v15) >> 16)
            + v16
            + 1567 * (v9 >> 16)
            + ((1567 * (unsigned __int16)v9) >> 16);
        v18 = ((v17 >> 5) + 1) >> 1;
        if (v18 <= -32768)
          LOWORD(v18) = 0x8000;
        if (v17 <= 2097119)
          v19 = v18;
        else
          v19 = 0x7FFF;
        *a2 = v19;
        v20 = 10739 * (v9 >> 16)
            + ((10739 * (unsigned __int16)v9) >> 16)
            + 1567 * v14
            + v16
            + ((1567 * v15) >> 16)
            + 4697 * (*v11 >> 16)
            + ((4697 * (unsigned __int16)*v11) >> 16);
        if (v20 <= 2097119)
        {
          v22 = ((v20 >> 5) + 1) >> 1;
          if (v22 <= -32768)
            v21 = 0x8000;
          else
            v21 = v22;
        }
        else
        {
          v21 = 0x7FFF;
        }
        v11 += 3;
        v23 = a2 + 2;
        a2[1] = v21;
        v10 -= 3;
        a2 += 2;
      }
      while (v10 > 5);
      a2 = v23;
    }
    v24 = a4;
    a4 = v27 - a4;
    if (a4 < 1)
      break;
    v8 = &v26[v24];
  }
  result = *(__n128 *)((char *)&i + 4 * v24);
  *a1 = result;
  return result;
}

uint64_t silk_CNG_Reset(uint64_t result)
{
  uint64_t v1;
  int v2;
  _WORD *v3;
  int v4;

  v1 = *(unsigned int *)(result + 2340);
  if ((int)v1 >= 1)
  {
    v2 = 0x7FFF / ((int)v1 + 1);
    v3 = (_WORD *)(result + 4076);
    v4 = v2;
    do
    {
      *v3++ = v4;
      v4 += v2;
      --v1;
    }
    while (v1);
  }
  *(_QWORD *)(result + 4172) = 0x30788000000000;
  return result;
}

void silk_CNG(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  char *v7;
  int v8;
  uint64_t v9;
  int v10;
  _WORD *v11;
  int v12;
  uint64_t v13;
  __int16 *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int *v21;
  int v22;
  size_t v23;
  int *v24;
  int v25;
  unsigned int v26;
  signed int v27;
  unsigned int v28;
  int *v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  int v73;
  int v74;
  int *v75;
  __int128 v76;
  _OWORD *v77;
  __int128 v78;
  uint64_t v79;
  _OWORD *v80;
  unsigned int v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  uint64_t v98;
  __int16 v99[5];
  __int16 v100;
  __int16 v101;
  __int16 v102;
  __int16 v103;
  __int16 v104;
  __int16 v105;
  __int16 v106;
  __int16 v107;
  __int16 v108;
  __int16 v109;
  __int16 v110;
  uint64_t v111;

  v98 = a3;
  v111 = *MEMORY[0x24BDAC8D0];
  v7 = (char *)(a1 + 2796);
  v8 = *(_DWORD *)(a1 + 2316);
  if (v8 != *(_DWORD *)(a1 + 4180))
  {
    v9 = *(unsigned int *)(a1 + 2340);
    if ((int)v9 >= 1)
    {
      v10 = 0x7FFF / ((int)v9 + 1);
      v11 = (_WORD *)(a1 + 4076);
      v12 = v10;
      do
      {
        *v11++ = v12;
        v12 += v10;
        --v9;
      }
      while (v9);
    }
    *(_QWORD *)(a1 + 4172) = 0x30788000000000;
    *(_DWORD *)(a1 + 4180) = v8;
  }
  if (*(_DWORD *)(a1 + 4184))
    goto LABEL_22;
  if (!*(_DWORD *)(a1 + 4188))
  {
    v13 = *(unsigned int *)(a1 + 2340);
    if ((int)v13 >= 1)
    {
      v14 = (__int16 *)(a1 + 2344);
      do
      {
        v14[866] += 16348 * ((*v14 - v14[866]) >> 16)
                  + ((16348 * (unsigned __int16)(*v14 - v14[866])) >> 16);
        ++v14;
        --v13;
      }
      while (v13);
    }
    v15 = *(unsigned int *)(a1 + 2324);
    if ((int)v15 < 1)
    {
      v18 = 0;
    }
    else
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
      do
      {
        if (*(_DWORD *)(a2 + 16 + 4 * v16) > v17)
        {
          v18 = v16;
          v17 = *(_DWORD *)(a2 + 16 + 4 * v16);
        }
        ++v16;
      }
      while (v15 != v16);
    }
    memmove(&v7[4 * *(int *)(a1 + 2332)], v7, 4 * *(_DWORD *)(a1 + 2332) * ((int)v15 - 1));
    memcpy(v7, (const void *)(a1 + 4 * *(_DWORD *)(a1 + 2332) * v18 + 4), 4 * *(int *)(a1 + 2332));
    v19 = *(unsigned int *)(a1 + 2324);
    if ((int)v19 >= 1)
    {
      v20 = *(_DWORD *)(a1 + 4172);
      v21 = (int *)(a2 + 16);
      do
      {
        v22 = *v21++;
        v20 += 4634 * ((v22 - v20) >> 16) + ((4634 * (unsigned __int16)(v22 - v20)) >> 16);
        *(_DWORD *)(a1 + 4172) = v20;
        --v19;
      }
      while (v19);
    }
  }
  if (*(_DWORD *)(a1 + 4184))
  {
LABEL_22:
    v23 = 4 * (a4 + 16);
    v24 = (int *)((char *)&v79 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v24, v23);
    v25 = *(_DWORD *)(a1 + 4172);
    v26 = 255;
    do
    {
      v27 = v26;
      v26 >>= 1;
    }
    while (v27 > a4);
    v28 = *(_DWORD *)(a1 + 4176);
    if (a4 >= 1)
    {
      v29 = v24 + 16;
      v30 = (__int16)(v25 >> 4);
      v31 = v25 >> 19;
      v32 = a4;
      v33 = (v31 + 1) >> 1;
      do
      {
        v28 = 196314165 * v28 + 907633515;
        v34 = *(_DWORD *)&v7[4 * (v27 & HIBYTE(v28))];
        v35 = v34 * v33 + (v34 >> 16) * v30 + (((unsigned __int16)v34 * v30) >> 16);
        if (v35 <= -32768)
          v35 = -32768;
        if (v35 >= 0x7FFF)
          v35 = 0x7FFF;
        *v29++ = v35;
        --v32;
      }
      while (v32);
    }
    *(_DWORD *)(a1 + 4176) = v28;
    silk_NLSF2A(v99, (__int16 *)(a1 + 4076), *(_DWORD *)(a1 + 2340));
    v80 = (_OWORD *)(a1 + 4108);
    v36 = *(_OWORD *)(a1 + 4124);
    *(_OWORD *)v24 = *(_OWORD *)(a1 + 4108);
    *((_OWORD *)v24 + 1) = v36;
    v37 = *(_OWORD *)(a1 + 4156);
    *((_OWORD *)v24 + 2) = *(_OWORD *)(a1 + 4140);
    *((_OWORD *)v24 + 3) = v37;
    v81 = a4;
    if (a4 >= 1)
    {
      v38 = 0;
      v39 = *(_DWORD *)(a1 + 2340);
      v40 = v99[0];
      v96 = v99[1];
      v97 = v39 >> 1;
      v41 = v99[2];
      v95 = v99[3];
      v42 = v99[4];
      v43 = v100;
      v44 = v101;
      v45 = v102;
      v46 = v103;
      v47 = v104;
      v90 = v105;
      v88 = v106;
      v89 = v102;
      v85 = v108;
      v86 = v107;
      v83 = v110;
      v84 = v109;
      v48 = v81;
      v49 = v24[15];
      v50 = v24[13];
      v51 = v24[11];
      v52 = v24[9];
      v53 = v24[7];
      v91 = v104;
      v92 = v103;
      v87 = v100;
      v82 = v81;
      do
      {
        v54 = v49 >> 16;
        v55 = (unsigned __int16)v49 * v40;
        v56 = &v24[v38];
        v57 = v56[14];
        v58 = (unsigned __int16)v50 * v41;
        v59 = v97
            + v54 * v40
            + (v55 >> 16)
            + (v57 >> 16) * v96
            + (((unsigned __int16)v57 * v96) >> 16)
            + (v50 >> 16) * v41;
        v60 = v56[12];
        v61 = (unsigned __int16)v51 * v42;
        v62 = v59 + (v58 >> 16) + (v60 >> 16) * v95 + (((unsigned __int16)v60 * v95) >> 16) + (v51 >> 16) * v42;
        v63 = v56[10];
        v64 = v62 + (v61 >> 16) + (v63 >> 16) * v43 + (((unsigned __int16)v63 * v43) >> 16);
        v65 = (unsigned __int16)v52 * v44;
        v66 = v64 + (v52 >> 16) * v44;
        v67 = v56[8];
        v68 = v66
            + (v65 >> 16)
            + (v67 >> 16) * v45
            + (((unsigned __int16)v67 * v45) >> 16)
            + (v53 >> 16) * v46
            + (((unsigned __int16)v53 * v46) >> 16)
            + (v56[6] >> 16) * v47
            + (((unsigned __int16)v56[6] * v47) >> 16);
        if (v39 == 16)
        {
          v69 = v56[4];
          v70 = v56[5] >> 16;
          v71 = (unsigned __int16)v56[5] * v90;
          v93 = (unsigned __int16)v69 * v88;
          v94 = v69 >> 16;
          v72 = v38 + 1;
          v73 = v68 + v70 * v90 + (v71 >> 16) + (v69 >> 16) * v88;
          v46 = v92;
          v48 = v82;
          v43 = v87;
          v45 = v89;
          v47 = v91;
          v68 = v73
              + (v93 >> 16)
              + (v56[3] >> 16) * v86
              + (((unsigned __int16)v56[3] * v86) >> 16)
              + (v56[2] >> 16) * v85
              + (((unsigned __int16)v56[2] * v85) >> 16)
              + (v24[v38 + 1] >> 16) * v84
              + (((unsigned __int16)v24[v38 + 1] * v84) >> 16)
              + (*v56 >> 16) * v83
              + (((unsigned __int16)*v56 * v83) >> 16);
        }
        else
        {
          v72 = v38 + 1;
        }
        v49 = v24[v38 + 16] + 16 * v68;
        v24[v38 + 16] = v49;
        v74 = *(__int16 *)(v98 + 2 * v38) + (((v68 >> 5) + 1) >> 1);
        if (v74 <= -32768)
          v74 = -32768;
        if (v74 >= 0x7FFF)
          LOWORD(v74) = 0x7FFF;
        *(_WORD *)(v98 + 2 * v38) = v74;
        v53 = v67;
        v52 = v63;
        v51 = v60;
        v50 = v57;
        v38 = v72;
      }
      while (v72 != v48);
    }
    v75 = &v24[v81];
    v76 = *((_OWORD *)v75 + 1);
    v77 = v80;
    *v80 = *(_OWORD *)v75;
    v77[1] = v76;
    v78 = *((_OWORD *)v75 + 3);
    v77[2] = *((_OWORD *)v75 + 2);
    v77[3] = v78;
  }
  else
  {
    bzero((void *)(a1 + 4108), 4 * *(int *)(a1 + 2340));
  }
}

uint64_t silk_NLSF_VQ(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t i;
  uint64_t v6;
  int v7;
  _WORD *v8;
  int v9;

  if (a4 >= 1)
  {
    for (i = 0; i != a4; *(_DWORD *)(result + 4 * i++) = v7)
    {
      if (a5 < 1)
      {
        v7 = 0;
      }
      else
      {
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = (_WORD *)(a2 + 2 * v6);
          v9 = (__int16)(v8[1] - (*(unsigned __int8 *)(a3 + v6 + 1) << 7));
          v7 += ((__int16)(*v8 - (*(unsigned __int8 *)(a3 + v6) << 7))
                             * (__int16)(*v8 - (*(unsigned __int8 *)(a3 + v6) << 7))
                             + v9 * v9) >> 4;
          v6 += 2;
        }
        while (v6 < a5);
        a3 += v6;
      }
    }
  }
  return result;
}

uint64_t silk_lin2log(unsigned int a1)
{
  unsigned int v1;

  v1 = __clz(a1);
  if (v1 != 24)
  {
    if (a1 <= 0x7F)
      LOBYTE(a1) = (a1 >> (56 - v1)) | ((_BYTE)a1 << (v1 - 24));
    else
      LOBYTE(a1) = ((_BYTE)a1 << (v1 + 8)) | (a1 >> (24 - v1));
  }
  return (a1 & 0x7F) - (v1 << 7) + ((179 * (a1 & 0x7F) * (128 - (a1 & 0x7F))) >> 16) + 3968;
}

uint64_t *silk_stereo_encode_pred(uint64_t *a1, char *a2)
{
  ec_enc_icdf(a1, 5 * a2[2] + a2[5], (uint64_t)silk_stereo_pred_joint_iCDF, 8);
  ec_enc_icdf(a1, *a2, (uint64_t)silk_uniform3_iCDF, 8);
  ec_enc_icdf(a1, a2[1], (uint64_t)"͚f3", 8);
  ec_enc_icdf(a1, a2[3], (uint64_t)silk_uniform3_iCDF, 8);
  return ec_enc_icdf(a1, a2[4], (uint64_t)"͚f3", 8);
}

uint64_t *silk_stereo_encode_mid_only(uint64_t *a1, int a2)
{
  return ec_enc_icdf(a1, a2, (uint64_t)silk_stereo_only_code_mid_iCDF, 8);
}

unint64_t silk_NLSF2A(__int16 *a1, __int16 *a2, int a3)
{
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int *v27;
  int *v28;
  int *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int *v41;
  uint64_t v42;
  __int16 *v43;
  int v44;
  __int16 v45;
  int *v46;
  uint64_t v47;
  __int16 *v48;
  unsigned int v49;
  int i;
  unint64_t result;
  int *v52;
  uint64_t v53;
  __int16 *v54;
  unsigned int v55;
  int v56[16];
  int v57;
  _DWORD v58[8];
  int v59;
  _DWORD v60[8];
  int v61;
  _QWORD v62[9];

  v5 = (unsigned __int8 *)&silk_NLSF2A_ordering10;
  *(_QWORD *)((char *)&v62[7] + 4) = *MEMORY[0x24BDAC8D0];
  if (a3 == 16)
    v5 = (unsigned __int8 *)&silk_NLSF2A_ordering16;
  v6 = a3;
  v7 = (a3 >> 1);
  if (a3 <= 0)
  {
    v59 = 0x10000;
  }
  else
  {
    v8 = a3;
    do
    {
      v9 = *a2++;
      v10 = ((((silk_LSFCosTab_FIX_Q12[(v9 >> 8) + 1] - silk_LSFCosTab_FIX_Q12[v9 >> 8]) * v9
             + (silk_LSFCosTab_FIX_Q12[v9 >> 8] << 8)) >> 3)
           + 1) >> 1;
      v11 = *v5++;
      *(&v61 + v11) = v10;
      --v8;
    }
    while (v8);
    v59 = 0x10000;
    v60[0] = -v61;
    if (a3 > 3)
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = *(&v61 + 2 * v13);
        v15 = v13 + 1;
        v60[v13] = 2 * v60[v13 - 2] - ((((unint64_t)(v60[v13 - 1] * (uint64_t)v14) >> 15) + 1) >> 1);
        if (v13 >= 2)
        {
          v16 = v12;
          do
          {
            v60[v16] = v60[v16]
                     + v60[(v16 - 1) - 1]
                     - ((((unint64_t)(v60[v16 - 1] * (uint64_t)v14) >> 15) + 1) >> 1);
            v17 = v16-- + 1;
          }
          while (v17 > 2);
        }
        v60[0] -= v14;
        ++v12;
        v13 = v15;
      }
      while (v15 != v7);
      v18 = 0;
      v57 = 0x10000;
      v58[0] = -LODWORD(v62[0]);
      v19 = 1;
      do
      {
        v20 = v62[v19];
        v21 = v19 + 1;
        v58[v19] = 2 * v58[v19 - 2] - ((((unint64_t)(v58[v19 - 1] * (uint64_t)v20) >> 15) + 1) >> 1);
        if (v19 >= 2)
        {
          v22 = v18;
          do
          {
            v58[v22] = v58[v22]
                     + v58[(v22 - 1) - 1]
                     - ((((unint64_t)(v58[v22 - 1] * (uint64_t)v20) >> 15) + 1) >> 1);
            v23 = v22-- + 1;
          }
          while (v23 > 2);
        }
        v58[0] -= v20;
        ++v18;
        v19 = v21;
      }
      while (v21 != v7);
      goto LABEL_20;
    }
  }
  v57 = 0x10000;
  v58[0] = -LODWORD(v62[0]);
LABEL_20:
  if (a3 >= 2)
  {
    if ((int)v7 <= 1)
      v7 = 1;
    else
      v7 = v7;
    v24 = v59;
    v25 = v57;
    v26 = a3 - 1;
    v27 = v58;
    v28 = v60;
    v29 = v56;
    do
    {
      v31 = *v28++;
      v30 = v31;
      v32 = v24 + v31;
      v33 = *v27++;
      v34 = v33 - v25;
      *v29++ = -(v32 + v34);
      v56[v26--] = v34 - v32;
      v25 = v33;
      v24 = v30;
      --v7;
    }
    while (v7);
  }
  v35 = 0;
  v36 = 0;
  while (a3 >= 1)
  {
    v37 = 0;
    v38 = 0;
    do
    {
      v39 = v56[v37];
      if (v39 < 0)
        v39 = -v39;
      if (v39 > (int)v38)
      {
        v38 = v39;
        v35 = v37;
      }
      ++v37;
    }
    while (v6 != v37);
    if (v38 <= 0xFFFEF)
    {
      v46 = v56;
      v47 = v6;
      v48 = a1;
      do
      {
        v49 = *v46++;
        *v48++ = ((v49 >> 4) + 1) >> 1;
        --v47;
      }
      while (v47);
      break;
    }
    v40 = ((v38 >> 4) + 1) >> 1;
    if (v40 >= 0x27FFE)
      v40 = 163838;
    silk_bwexpander_32(v56, v6, 65470 - (int)((v40 << 14) - 536854528) / ((int)(v40 + v40 * v35) >> 2));
    if (++v36 == 10)
    {
      v41 = v56;
      v42 = v6;
      v43 = a1;
      do
      {
        v44 = ((*v41 >> 4) + 1) >> 1;
        if (*v41 < -1048592)
          LOWORD(v44) = 0x8000;
        if (*v41 <= 1048559)
          v45 = v44;
        else
          v45 = 0x7FFF;
        *v43++ = v45;
        *v41++ = 32 * v45;
        --v42;
      }
      while (v42);
      break;
    }
  }
  for (i = 0; i != 16; ++i)
  {
    result = silk_LPC_inverse_pred_gain(a1, a3);
    if ((int)result > 107373)
      break;
    result = (unint64_t)silk_bwexpander_32(v56, a3, (-2 << i) + 0x10000);
    if (a3 >= 1)
    {
      v52 = v56;
      v53 = v6;
      v54 = a1;
      do
      {
        v55 = *v52++;
        *v54++ = ((v55 >> 4) + 1) >> 1;
        --v53;
      }
      while (v53);
    }
  }
  return result;
}

unsigned __int16 *silk_stereo_MS_to_LR(unsigned __int16 *result, _DWORD *a2, _DWORD *a3, int *a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  __int16 *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  __int16 *v27;
  __int16 *v28;
  uint64_t v29;
  __int16 *v30;
  int v31;
  int v32;
  int v33;
  __int16 *v34;
  __int16 *v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;

  *a2 = *((_DWORD *)result + 1);
  *a3 = *((_DWORD *)result + 2);
  v6 = 2 * a6;
  *((_DWORD *)result + 1) = *(_DWORD *)((char *)a2 + v6);
  *((_DWORD *)result + 2) = *(_DWORD *)((char *)a3 + v6);
  v7 = 8 * a5;
  v8 = *a4;
  v9 = a4[1];
  if (a5 >= 1)
  {
    v10 = *result;
    v11 = result[1];
    v12 = (__int16)(0x10000 / v7);
    v13 = (((v12 * (__int16)(v8 - v10)) >> 15) + 1) >> 1;
    v14 = (((v12 * (__int16)(v9 - v11)) >> 15) + 1) >> 1;
    if (v7 <= 1)
      v15 = 1;
    else
      v15 = v7;
    v16 = (__int16 *)(a2 + 1);
    v17 = (__int16 *)a3 + 1;
    v18 = (v14 + v11) << 16;
    v19 = v14 << 16;
    v20 = (v13 + v10) << 16;
    v21 = v13 << 16;
    do
    {
      v22 = *(v16 - 1);
      v23 = (v22 << 10) + ((*v16 + *(v16 - 2)) << 9);
      v24 = (v22 >> 5) * (v18 >> 16)
          + (*v17 << 8)
          + ((((v22 & 0x1F) << 11) * (v18 >> 16)) >> 16)
          + (v23 >> 16) * (v20 >> 16)
          + (((v23 & 0xFE00) * (v20 >> 16)) >> 16);
      if (v24 <= 8388479)
      {
        v25 = ((v24 >> 7) + 1) >> 1;
        if (v25 <= -32768)
          LOWORD(v25) = 0x8000;
      }
      else
      {
        LOWORD(v25) = 0x7FFF;
      }
      ++v16;
      *v17++ = v25;
      v18 += v19;
      v20 += v21;
      --v15;
    }
    while (v15);
  }
  if (v7 < a6)
  {
    v26 = 2 * v7 + 2;
    v27 = (__int16 *)((char *)a3 + v26);
    v28 = (__int16 *)((char *)a2 + v26);
    v29 = a6 - (uint64_t)v7;
    v30 = (__int16 *)((char *)a2 + v26);
    do
    {
      v31 = v30[1];
      ++v30;
      v32 = (*v28 >> 5) * (__int16)v9
          + (*v27 << 8)
          + ((((*v28 & 0x1F) << 11) * (__int16)v9) >> 16)
          + (((*v28 << 10) + ((v31 + *(v28 - 1)) << 9)) >> 16) * (__int16)v8
          + (((((*v28 << 10) + ((v31 + *(v28 - 1)) << 9)) & 0xFE00) * (__int16)v8) >> 16);
      if (v32 <= 8388479)
      {
        v33 = ((v32 >> 7) + 1) >> 1;
        if (v33 <= -32768)
          LOWORD(v33) = 0x8000;
      }
      else
      {
        LOWORD(v33) = 0x7FFF;
      }
      *v27++ = v33;
      v28 = v30;
      --v29;
    }
    while (v29);
  }
  *result = v8;
  result[1] = v9;
  if (a6 >= 1)
  {
    v34 = (__int16 *)a3 + 1;
    v35 = (__int16 *)a2 + 1;
    v36 = a6;
    do
    {
      v37 = *v35;
      v38 = *v34;
      v39 = v37 + v38;
      if (v37 + v38 >= 0x7FFF)
        v39 = 0x7FFF;
      if (v39 <= -32768)
        LOWORD(v39) = 0x8000;
      *v35++ = v39;
      v40 = v37 - v38;
      if (v40 >= 0x7FFF)
        v40 = 0x7FFF;
      if (v40 <= -32768)
        LOWORD(v40) = 0x8000;
      *v34++ = v40;
      --v36;
    }
    while (v36);
  }
  return result;
}

uint64_t silk_VAD_Init(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;

  v1 = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 92) = xmmword_214F96AD0;
  do
  {
    v2 = a1 + v1;
    v3 = 100 * *(_DWORD *)(a1 + v1 + 92);
    *(_DWORD *)(v2 + 60) = v3;
    *(_DWORD *)(v2 + 76) = 0x7FFFFFFF / v3;
    v1 += 4;
  }
  while (v1 != 16);
  *(_DWORD *)(a1 + 108) = 15;
  memset_pattern16((void *)(a1 + 40), &unk_214F96AF0, 0x10uLL);
  return 0;
}

uint64_t silk_VAD_GetSA_Q8(uint64_t a1, __int16 *a2)
{
  int32x2_t *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  size_t v10;
  _WORD *v11;
  int v12;
  _WORD *v13;
  __int16 *v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  char v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  unsigned int *v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  BOOL v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  int32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  int32x4_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int32x4_t v52;
  int8x16_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int v56;
  __int32 v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  char v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  int v80;
  int v81;
  int v82;
  char v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  unsigned int v87;
  unsigned int v88;
  unint64_t v89;
  int v90;
  char v91;
  int v92;
  unsigned int v93;
  int v94;
  uint64_t v96;
  int v97;
  _DWORD v98[8];
  int32x4_t v99;
  uint64_t v100;

  v100 = *MEMORY[0x24BDAC8D0];
  v4 = (int32x2_t *)(a1 + 32);
  v5 = *(_DWORD *)(a1 + 4608);
  v97 = v5 >> 2;
  v98[0] = 0;
  v6 = v5 >> 3;
  v7 = (v5 >> 3) + (v5 >> 2);
  v8 = v7 + (v5 >> 3);
  v9 = v8 + (v5 >> 2);
  v98[1] = v7;
  v98[2] = v8;
  v98[3] = v9;
  v10 = 2 * (v9 + (v5 >> 1));
  v11 = (_WORD *)((char *)&v96 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v11, v10);
  silk_ana_filt_bank_1(a2, v4, v11, &v11[v9], v5);
  silk_ana_filt_bank_1(v11, (int32x2_t *)(a1 + 40), v11, &v11[v8], v5 >> 1);
  silk_ana_filt_bank_1(v11, (int32x2_t *)(a1 + 48), v11, &v11[v7], v97);
  v12 = (__int16)v11[(v5 >> 3) - 1] >> 1;
  v11[(v5 >> 3) - 1] = (__int16)v11[(v5 >> 3) - 1] >> 1;
  if (v5 >= 16)
  {
    v13 = &v11[v6 - 1];
    v14 = &v11[v6 - 2];
    do
    {
      v15 = *v14;
      *v14-- >>= 1;
      *v13-- -= v15 >> 1;
      --v6;
    }
    while (v6 > 1);
  }
  v16 = 0;
  *v11 -= *(_WORD *)(a1 + 88);
  *(_WORD *)(a1 + 88) = v12;
  do
  {
    v17 = 0;
    v18 = 0;
    v19 = 4 - v16;
    if (4 - (int)v16 >= 3)
      v19 = 3;
    v20 = *(int *)(a1 + 4608) >> v19;
    v21 = v20 >> 2;
    v22 = a1 + 4 * v16;
    v25 = *(_DWORD *)(v22 + 56);
    v24 = (unsigned int *)(v22 + 56);
    v23 = v25;
    if (v20 >> 2 <= 1)
      v26 = 1;
    else
      v26 = v21;
    do
    {
      if (v20 < 4)
      {
        v27 = 0;
      }
      else
      {
        v27 = 0;
        v28 = v98[v16] + v17;
        v29 = v26;
        do
        {
          v30 = (__int16)v11[v28] >> 3;
          v27 += v30 * v30;
          ++v28;
          --v29;
        }
        while (v29);
      }
      v31 = v27 >> (v18 > 2);
      v32 = __OFADD__(v23, v31);
      v23 += v31;
      if (v23 < 0 != v32)
        v23 = 0x7FFFFFFF;
      ++v18;
      v17 += v21;
    }
    while (v18 != 4);
    v99.i32[v16] = v23;
    *v24 = v27;
    ++v16;
  }
  while (v16 != 4);
  v33 = *(_DWORD *)(a1 + 140);
  if (v33 > 999)
    v34 = 0;
  else
    v34 = 0x7FFF / ((v33 >> 4) + 1);
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = *(int32x4_t *)(a1 + 92);
  v39 = *(int32x4_t *)(a1 + 108);
  v40 = (int8x16_t)vaddq_s32(*(int32x4_t *)(a1 + 124), v99);
  v41.i64[0] = -1;
  v41.i64[1] = -1;
  v42 = (int8x16_t)vcgtq_s32((int32x4_t)v40, v41);
  v43 = vorrq_s8(vandq_s8(v40, v42), (int8x16_t)(*(_OWORD *)&vmvnq_s8(v42) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
  v44 = (int8x16_t)vcgtq_s32((int32x4_t)v43, vshlq_n_s32(v38, 3uLL));
  v45 = (int8x16_t)vcgtq_s32(v38, (int32x4_t)v43);
  v43.i32[0] = 0x7FFFFFFF / v43.i32[0];
  v43.i32[1] = 0x7FFFFFFF / v43.i32[1];
  v43.i32[2] = 0x7FFFFFFF / v43.i32[2];
  v43.i32[3] = 0x7FFFFFFF / v43.i32[3];
  v46 = (int8x16_t)vshrq_n_s32(vshlq_n_s32(v38, 0x10uLL), 0x10uLL);
  v47.i64[0] = 0xFFFF0000FFFFLL;
  v47.i64[1] = 0xFFFF0000FFFFLL;
  v48.i64[0] = 0x100000001;
  v48.i64[1] = 0x100000001;
  v49 = vsraq_n_s32(vmlaq_s32(vmulq_s32((int32x4_t)v43, vhaddq_s32(vshrq_n_s32(v38, 0xFuLL), v48)), vshrq_n_s32((int32x4_t)v43, 0x10uLL), (int32x4_t)v46), vmulq_s32((int32x4_t)vandq_s8(v43, v47), (int32x4_t)v46), 0x10uLL);
  v46.i64[0] = 0x700000007;
  v46.i64[1] = 0x700000007;
  v50.i64[0] = 0x40000000400;
  v50.i64[1] = 0x40000000400;
  v51 = vbslq_s8(v45, v50, vbslq_s8(v46, (int8x16_t)vshrq_n_s32(v49, 5uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v49, 5uLL)));
  v45.i64[0] = 0x8000000080;
  v45.i64[1] = 0x8000000080;
  v52 = vmaxq_s32((int32x4_t)vbslq_s8(v44, v45, v51), vdupq_n_s32(v34));
  v53 = (int8x16_t)vsubq_s32((int32x4_t)v43, v39);
  v54 = vshrq_n_s32(vshlq_n_s32(v52, 0x10uLL), 0x10uLL);
  v55 = vsraq_n_s32(vmlaq_s32(v39, vshrq_n_s32((int32x4_t)v53, 0x10uLL), v54), vmulq_s32((int32x4_t)vandq_s8(v53, v47), v54), 0x10uLL);
  v54.i32[0] = 0x7FFFFFFF / v55.i32[0];
  v54.i32[1] = 0x7FFFFFFF / v55.i32[1];
  v54.i32[2] = 0x7FFFFFFF / v55.i32[2];
  v54.i32[3] = 0x7FFFFFFF / v55.i32[3];
  v53.i64[0] = 0xFFFFFF00FFFFFFLL;
  v53.i64[1] = 0xFFFFFF00FFFFFFLL;
  v56 = *(_DWORD *)(a1 + 140) + 1;
  *(int32x4_t *)(a1 + 92) = vminq_s32(v54, (int32x4_t)v53);
  *(int32x4_t *)(a1 + 108) = v55;
  *(_DWORD *)(a1 + 140) = v56;
  do
  {
    v57 = v99.i32[v35];
    v58 = *(_DWORD *)(a1 + 92 + v35 * 4);
    v59 = v57 - v58;
    if (v57 - v58 < 1)
    {
      v98[v35 + 4] = 256;
    }
    else
    {
      if (v57 < 0x800000)
        v57 <<= 8;
      else
        v58 >>= 8;
      v60 = v57 / (v58 + 1);
      v98[v35 + 4] = v60;
      v61 = (__int16)(silk_lin2log(v60) - 1024);
      v62 = v61;
      if (!(v59 >> 20))
      {
        v63 = __clz(v59);
        v64 = v59 >> (24 - v63);
        LOBYTE(v65) = v59;
        v66 = v59 << (v63 - 24);
        if (v63 != 24)
        {
          v65 = (v59 << (v63 + 8)) | v64;
          if (v59 <= 0x7F)
            LOBYTE(v65) = (v59 >> (56 - v63)) | v66;
        }
        v67 = v65 & 0x7F;
        if ((v63 & 1) != 0)
          v68 = 0x8000;
        else
          v68 = 46214;
        v69 = v68 >> (v63 >> 1);
        v70 = ((v69 + ((213 * v69 * v67) >> 16)) >> 10) * v61;
        v71 = (v59 << (v63 + 8)) | v64;
        v72 = (v59 >> (56 - v63)) | v66;
        if (v59 > 0x7F)
          LOBYTE(v72) = v71;
        if (v63 == 24)
          v73 = v59;
        else
          v73 = v72;
        v62 = (int)(((((_WORD)v69 + ((213 * v69 * (v73 & 0x7F)) >> 16)) & 0x3FF) << 6) * v61 + (v70 << 16)) >> 16;
      }
      v36 += v61 * v61;
      v37 += (tiltWeights[v35] >> 16) * v62 + (((unsigned __int16)tiltWeights[v35] * v62) >> 16);
    }
    ++v35;
  }
  while (v35 != 4);
  v74 = v36 + 3;
  if (v36 >= 0)
    v74 = v36;
  if (v36 >= 4)
  {
    v76 = v74 >> 2;
    v77 = __clz(v74 >> 2);
    if (v77 != 24)
    {
      if (v76 <= 0x7F)
        LOBYTE(v76) = (v76 >> (56 - v77)) | ((_BYTE)v76 << (v77 - 24));
      else
        LOBYTE(v76) = ((_BYTE)v76 << (v77 + 8)) | (v76 >> (24 - v77));
    }
    v78 = v76 & 0x7F;
    if ((v77 & 1) != 0)
      v79 = 0x8000;
    else
      v79 = 46214;
    v75 = ((45000 * (__int16)(3 * ((v79 >> (v77 >> 1)) + ((213 * (v79 >> (v77 >> 1)) * v78) >> 16)))) >> 16) - 128;
  }
  else
  {
    v75 = -128;
  }
  v80 = silk_sigm_Q15(v75);
  *(_DWORD *)(a1 + 4760) = 2 * silk_sigm_Q15(v37) - 0x8000;
  v81 = vaddvq_s32(vmulq_s32(vshrq_n_s32(vsubq_s32(v99, *(int32x4_t *)(a1 + 92)), 4uLL), (int32x4_t)xmmword_214F96AE0));
  v82 = *(_DWORD *)(a1 + 4608);
  if (v81 <= 0)
  {
    v80 >>= 1;
  }
  else if (!(v81 >> 15))
  {
    if (v82 == 10 * *(_DWORD *)(a1 + 4600))
      v83 = 16;
    else
      v83 = 15;
    v84 = v81 << v83;
    v85 = __clz(v84);
    v86 = __ROR4__(v84, 24 - v85) & 0x7F;
    if ((v85 & 1) != 0)
      v87 = 0x8000;
    else
      v87 = 46214;
    v88 = (v87 >> (v85 >> 1)) + ((213 * (v87 >> (v85 >> 1)) * v86) >> 16) + 0x8000;
    v80 = HIWORD(v88) * (__int16)v80 + (((unsigned __int16)v88 * (__int16)v80) >> 16);
  }
  v89 = 0;
  v90 = v80 >> 7;
  if (v80 >> 7 >= 255)
    v90 = 255;
  *(_DWORD *)(a1 + 4556) = v90;
  if (v82 == 10 * *(_DWORD *)(a1 + 4600))
    v91 = 21;
  else
    v91 = 20;
  v92 = (int)((__int16)v80 * (unsigned __int16)v80 + ((v80 * HIWORD(v80)) << 16)) >> v91;
  do
  {
    v93 = *(_DWORD *)(a1 + v89 + 72)
        + ((v98[v89 / 4 + 4] - *(_DWORD *)(a1 + v89 + 72)) >> 16) * v92
        + (((unsigned __int16)(LOWORD(v98[v89 / 4 + 4]) - *(_DWORD *)(a1 + v89 + 72)) * v92) >> 16);
    *(_DWORD *)(a1 + v89 + 72) = v93;
    v94 = silk_lin2log(v93);
    *(_DWORD *)(a1 + v89 + 4744) = silk_sigm_Q15((3 * v94 - 5120) >> 4);
    v89 += 4;
  }
  while (v89 != 16);
  return 0;
}

uint64_t silk_decode_pitch(uint64_t result, int a2, int *a3, int a4, int a5)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  char *v15;
  int v16;
  int v17;
  int v18;

  v5 = 3;
  if (a5 == 4)
    v5 = 11;
  v6 = (char *)&silk_CB_lags_stage2_10_ms;
  if (a5 == 4)
    v6 = (char *)&silk_CB_lags_stage2;
  v7 = 12;
  if (a5 == 4)
  {
    v7 = 34;
    v8 = &silk_CB_lags_stage3;
  }
  else
  {
    v8 = (char *)&silk_CB_lags_stage3_10_ms;
  }
  if (a4 == 8)
  {
    v9 = v6;
  }
  else
  {
    v5 = v7;
    v9 = v8;
  }
  if (a5 >= 1)
  {
    v10 = 2 * (__int16)a4;
    v11 = 18 * (__int16)a4;
    v13 = a5;
    if (v10 <= v11)
      v14 = 18 * (__int16)a4;
    else
      v14 = 2 * (__int16)a4;
    if (v10 >= v11)
      v10 = 18 * (__int16)a4;
    v15 = &v9[a2];
    do
    {
      v12 = result + 2 * (__int16)a4;
      v16 = v12 + *v15;
      if (v16 <= v10)
        v17 = v10;
      else
        v17 = v12 + *v15;
      if (v16 <= v14)
        v18 = v17;
      else
        v18 = v14;
      *a3++ = v18;
      v15 += v5;
      --v13;
    }
    while (v13);
  }
  return result;
}

uint64_t silk_decoder_set_fs(uint64_t a1, int a2, unsigned int a3)
{
  int v6;
  int v7;
  uint64_t v8;
  char v9;
  int v10;
  BOOL v11;
  void *v12;
  void *v13;
  void *v14;
  int v15;
  unsigned __int8 *v16;

  v6 = (__int16)a2;
  *(_DWORD *)(a1 + 2332) = 5 * (__int16)a2;
  v7 = *(__int16 *)(a1 + 2324) * (__int16)(5 * a2);
  if (*(_DWORD *)(a1 + 2316) == a2 && *(_DWORD *)(a1 + 2320) == a3)
  {
    v8 = 0;
  }
  else
  {
    v8 = silk_resampler_init(a1 + 2448, 1000 * (__int16)a2, a3, 0);
    v9 = 0;
    *(_DWORD *)(a1 + 2320) = a3;
    if (*(_DWORD *)(a1 + 2316) != a2)
      goto LABEL_7;
  }
  if (v7 != *(_DWORD *)(a1 + 2328))
  {
    v9 = 1;
LABEL_7:
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = v10 == 4;
    if (v10 == 4)
      v12 = &silk_pitch_contour_NB_iCDF;
    else
      v12 = &silk_pitch_contour_10_ms_NB_iCDF;
    v13 = &silk_pitch_contour_10_ms_iCDF;
    if (v11)
      v13 = &silk_pitch_contour_iCDF;
    if (a2 != 8)
      v12 = v13;
    *(_QWORD *)(a1 + 2392) = v12;
    if ((v9 & 1) != 0)
      goto LABEL_26;
    *(_DWORD *)(a1 + 2336) = 20 * v6;
    if ((a2 | 4) == 0xC)
    {
      v14 = &silk_NLSF_CB_NB_MB;
      v15 = 10;
    }
    else
    {
      v14 = &silk_NLSF_CB_WB;
      v15 = 16;
    }
    *(_DWORD *)(a1 + 2340) = v15;
    *(_QWORD *)(a1 + 2752) = v14;
    switch(a2)
    {
      case 16:
        v16 = silk_uniform8_iCDF;
        break;
      case 12:
        v16 = (unsigned __int8 *)&silk_uniform6_iCDF;
        break;
      case 8:
        v16 = silk_uniform4_iCDF;
        break;
      default:
LABEL_25:
        *(_DWORD *)(a1 + 2376) = 1;
        *(_DWORD *)(a1 + 2308) = 100;
        *(_BYTE *)(a1 + 2312) = 10;
        *(_DWORD *)(a1 + 4188) = 0;
        bzero((void *)(a1 + 1348), 0x3C0uLL);
        *(_OWORD *)(a1 + 1316) = 0u;
        *(_OWORD *)(a1 + 1332) = 0u;
        *(_OWORD *)(a1 + 1284) = 0u;
        *(_OWORD *)(a1 + 1300) = 0u;
LABEL_26:
        *(_DWORD *)(a1 + 2316) = a2;
        *(_DWORD *)(a1 + 2328) = v7;
        return v8;
    }
    *(_QWORD *)(a1 + 2384) = v16;
    goto LABEL_25;
  }
  return v8;
}

uint64_t *silk_encode_pulses(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v8;
  _QWORD *v9;
  uint64_t v10;
  char *v11;
  int8x16_t v12;
  uint64_t v13;
  int8x16_t v14;
  int8x16_t *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  int v21;
  uint64_t v22;
  char *v23;
  int v24;
  int v25;
  uint64_t v26;
  int *v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int *v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  char *v42;
  uint64_t v43;
  int *v44;
  int *v45;
  int v46;
  char *v47;
  uint64_t v48;
  char *v49;
  int *v50;
  int v51;
  void *v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unsigned int v61;
  int v62;
  uint64_t v64;
  int v65;
  int v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD v71[2];
  uint64_t v72;

  v66 = a3;
  v68 = a2;
  v72 = *MEMORY[0x24BDAC8D0];
  memset(v71, 0, sizeof(v71));
  v8 = a5 >> 4;
  if ((int)(a5 & 0xFFFFFFF0) < a5)
  {
    ++v8;
    v9 = (_QWORD *)(a4 + a5);
    *v9 = 0;
    v9[1] = 0;
  }
  v10 = 16 * v8;
  v11 = (char *)&v64 - 4 * v10;
  bzero(v11, 4 * v10);
  if (v8 >= 1)
  {
    v13 = 0;
    v14.i64[0] = 0xFF000000FFLL;
    v14.i64[1] = 0xFF000000FFLL;
    v15 = (int8x16_t *)((char *)&v64 - 4 * v10);
    do
    {
      v12.i32[0] = *(_DWORD *)(a4 + v13);
      v12 = vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vabs_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)v12.i8))), v14);
      *v15++ = v12;
      v13 += 4;
    }
    while (v13 < v10);
  }
  v65 = a5;
  v16 = (4 * v8 + 15) & 0xFFFFFFFFFFFFFFF0;
  bzero((char *)&v64 - v16, 4 * v8);
  v17 = (char *)&v64 - v16;
  bzero((char *)&v64 - v16, 4 * v8);
  if (v8 >= 1)
  {
    v18 = 0;
    v19 = v11 + 4;
    v20 = v11;
    do
    {
      v21 = 0;
      *(_DWORD *)&v17[4 * v18] = 0;
      while (1)
      {
        v22 = 0;
        v23 = v19;
        while (1)
        {
          v24 = *(_DWORD *)v23 + *((_DWORD *)v23 - 1);
          if (v24 > silk_max_pulses_table)
            break;
          v23 += 8;
          *(_DWORD *)((char *)v71 + v22) = v24;
          v22 += 4;
          if (v22 == 32)
          {
            v25 = 0;
            goto LABEL_14;
          }
        }
        v25 = 1;
LABEL_14:
        v26 = 0;
        v27 = (int *)v71;
        while (1)
        {
          v28 = *(_DWORD *)((char *)v71 + v26 + 4) + *(_DWORD *)((char *)v71 + v26);
          if (v28 > 10)
            break;
          *v27++ = v28;
          v26 += 8;
          if (v26 == 32)
          {
            v29 = 0;
            goto LABEL_19;
          }
        }
        v29 = 1;
LABEL_19:
        v30 = 0;
        v31 = v29 + v25;
        v32 = (int *)v71;
        while (1)
        {
          v33 = *(_DWORD *)((char *)v71 + v30 + 4) + *(_DWORD *)((char *)v71 + v30);
          if (v33 > 12)
            break;
          *v32++ = v33;
          v30 += 8;
          if (v30 == 16)
          {
            v34 = 0;
            goto LABEL_24;
          }
        }
        v34 = -1;
LABEL_24:
        if (DWORD1(v71[0]) + LODWORD(v71[0]) <= 16)
        {
          *(_DWORD *)((char *)&v64 + 4 * v18 - v16) = DWORD1(v71[0]) + LODWORD(v71[0]);
          if (v31 == v34)
            break;
        }
        v35 = 0;
        *(_DWORD *)&v17[4 * v18] = ++v21;
        do
        {
          *(int32x4_t *)&v20[v35] = vshrq_n_s32(*(int32x4_t *)&v20[v35], 1uLL);
          v35 += 16;
        }
        while (v35 != 64);
      }
      v20 += 64;
      ++v18;
      v19 += 64;
    }
    while (v18 != v8);
  }
  v69 = a4;
  v36 = 0;
  v37 = 0;
  v38 = (uint64_t)(int)v68 >> 1;
  v39 = 0x7FFFFFFF;
  v40 = v8;
  do
  {
    v41 = silk_rate_levels_BITS_Q5[9 * v38 + v36];
    if (v8 >= 1)
    {
      v42 = (char *)&silk_pulses_per_block_BITS_Q5 + 18 * v36;
      v43 = v8;
      v44 = (int *)((char *)&v64 - v16);
      v45 = (int *)((char *)&v64 - v16);
      do
      {
        v46 = *v44++;
        v47 = v42 + 17;
        if (v46 <= 0)
          v47 = &v42[*v45];
        v41 += *v47;
        ++v45;
        --v43;
      }
      while (v43);
    }
    if (v41 < v39)
    {
      v37 = v36;
      v39 = v41;
    }
    ++v36;
  }
  while (v36 != 9);
  v67 = (int *)((char *)&v64 - v16);
  ec_enc_icdf(a1, v37, (uint64_t)&silk_rate_levels_iCDF[9 * v38], 8);
  if (v8 >= 1)
  {
    v48 = 0;
    v49 = (char *)&silk_pulses_per_block_iCDF + 18 * v37;
    v50 = v67;
    do
    {
      v51 = *(_DWORD *)&v17[4 * v48];
      v52 = v49;
      if (v51)
      {
        ec_enc_icdf(a1, 17, (uint64_t)v49, 8);
        if (v51 < 2)
        {
          v52 = &unk_214F95828;
        }
        else
        {
          v53 = v51 - 1;
          do
          {
            v52 = &unk_214F95828;
            ec_enc_icdf(a1, 17, (uint64_t)&unk_214F95828, 8);
            --v53;
          }
          while (v53);
        }
      }
      ec_enc_icdf(a1, v50[v48++], (uint64_t)v52, 8);
    }
    while (v48 != v40);
    v54 = v40;
    do
    {
      v55 = *v50++;
      if (v55 >= 1)
        silk_shell_encoder(a1, (int *)v11);
      v11 += 64;
      --v54;
    }
    while (v54);
    v56 = 0;
    v70 = v40;
    do
    {
      v57 = *(_DWORD *)&v17[4 * v56];
      if (v57 >= 1)
      {
        v58 = 0;
        v59 = v69 + 16 * v56;
        do
        {
          v60 = *(char *)(v59 + v58);
          if (v60 < 0)
            v60 = -v60;
          v61 = (char)v60;
          if (v57 != 1)
          {
            v62 = v57 + 1;
            do
              ec_enc_icdf(a1, (v61 >> (v62-- - 2)) & 1, (uint64_t)silk_lsb_iCDF, 8);
            while (v62 > 2);
          }
          ec_enc_icdf(a1, v61 & 1, (uint64_t)silk_lsb_iCDF, 8);
          ++v58;
        }
        while (v58 != 16);
      }
      ++v56;
    }
    while (v56 != v70);
  }
  return silk_encode_signs(a1, v69, v65, v68, v66, (uint64_t)v67);
}

unint64_t silk_inner_prod_aligned_scale(unint64_t result, __int16 *a2, char a3, int a4)
{
  __int16 *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;

  if (a4 < 1)
    return 0;
  v4 = (__int16 *)result;
  LODWORD(result) = 0;
  v5 = a4;
  do
  {
    v7 = *v4++;
    v6 = v7;
    v8 = *a2++;
    result = (((v8 * v6) >> a3) + result);
    --v5;
  }
  while (v5);
  return result;
}

uint64_t silk_init_decoder(_DWORD *a1)
{
  bzero(a1, 0x10C0uLL);
  a1[594] = 1;
  *a1 = 0x10000;
  silk_CNG_Reset((uint64_t)a1);
  silk_PLC_Reset((uint64_t)a1);
  return 0;
}

unsigned int *silk_sum_sqr_shift(unsigned int *result, int *a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;

  v4 = a4 - 1;
  if (a4 < 2)
  {
    LODWORD(v5) = 0;
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v6 += *(__int16 *)(a3 + 2 * v5) * *(__int16 *)(a3 + 2 * v5)
          + *(__int16 *)(a3 + 2 * v5 + 2) * *(__int16 *)(a3 + 2 * v5 + 2);
      if ((v6 & 0x80000000) != 0)
        break;
      v5 += 2;
      if (v4 <= (int)v5)
      {
        v7 = 0;
        goto LABEL_8;
      }
    }
    v6 >>= 2;
    v7 = 2;
  }
LABEL_8:
  if ((int)v5 < v4)
  {
    v8 = 0;
    v9 = v5;
    v10 = a3 + 2 * v5;
    do
    {
      v11 = *(__int16 *)(a3 + 2 * ((v9 + (_DWORD)v8) & 0xFFFFFFFE) + 2);
      v6 += (*(__int16 *)(v10 + 2 * v8) * *(__int16 *)(v10 + 2 * v8) + v11 * v11) >> v7;
      if ((v6 & 0x80000000) != 0)
      {
        v7 += 2;
        v6 >>= 2;
      }
      v8 += 2;
    }
    while (v4 > v9 + (int)v8);
    LODWORD(v5) = v9 + v8;
  }
  if ((_DWORD)v5 == v4)
  {
    v12 = *(__int16 *)(a3 + 2 * v4);
    v6 += (v12 * v12) >> v7;
  }
  v13 = v6 >> 2;
  if (v6 >> 30)
    v7 += 2;
  else
    v13 = v6;
  *a2 = v7;
  *result = v13;
  return result;
}

uint64_t silk_pitch_analysis_core(__int16 *a1, void *a2, _WORD *a3, _BYTE *a4, __int16 *a5, signed int a6, int a7, int a8, int a9, int a10, unsigned int a11)
{
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __int16 *v18;
  size_t v19;
  __int16 *v20;
  char *v21;
  int v22;
  char *v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  __int16 *v29;
  int v30;
  size_t v31;
  __int16 *v32;
  int v33;
  size_t v34;
  uint64_t v35;
  __int16 *v36;
  uint64_t v37;
  char *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  __int16 *v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  __int16 v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  __int16 v61;
  __int16 *v62;
  int v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  char v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  _BOOL4 v82;
  uint64_t v83;
  int v84;
  __int16 *v85;
  int v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  size_t v93;
  uint64_t v94;
  signed int v95;
  int *v96;
  uint64_t v97;
  uint64_t v98;
  int *v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  __int16 v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  __int16 v108;
  __int16 v109;
  __int16 v110;
  char *v111;
  unint64_t v112;
  uint64_t v113;
  int v114;
  unsigned int v115;
  uint64_t v116;
  __int16 *v117;
  uint64_t v118;
  int v119;
  __int16 *v120;
  int v121;
  int v122;
  int v123;
  size_t v124;
  __int16 *v125;
  int v126;
  uint64_t v127;
  __int16 *v128;
  int v129;
  unsigned int v130;
  int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  __int16 v141;
  int v142;
  unsigned int v143;
  unsigned int v144;
  int v145;
  int v146;
  __int16 *v147;
  uint64_t v148;
  BOOL v149;
  _BOOL4 v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unsigned int v155;
  char *v156;
  unsigned int v157;
  uint64_t v158;
  char *v159;
  unsigned int v160;
  uint64_t v161;
  int v162;
  int v163;
  __int16 v164;
  int v165;
  unsigned int v166;
  BOOL v167;
  int v168;
  int v169;
  uint64_t v170;
  int v171;
  int v172;
  int v173;
  size_t v174;
  char *v175;
  uint64_t v176;
  uint64_t v177;
  int v178;
  uint64_t result;
  int *v180;
  char *v181;
  int v182;
  __int16 v183;
  int v184;
  int v185;
  int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  char *v192;
  uint64_t v193;
  _DWORD *v194;
  int v195;
  uint64_t v196;
  int v197;
  uint64_t v198;
  char *v199;
  char *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int v204;
  uint64_t v205;
  __int16 *v206;
  int v207;
  uint64_t v208;
  uint64_t v209;
  signed int v210;
  uint64_t v211;
  char *v212;
  char *v213;
  uint64_t v214;
  signed int v215;
  uint64_t v216;
  int v217;
  unsigned int v218;
  int v219;
  unsigned int v220;
  unsigned int v221;
  int v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  int v229;
  unsigned int v230;
  int v231;
  int v232;
  int *v233;
  uint64_t v234;
  int v235;
  int v236;
  char *v237;
  int v238;
  int v239;
  int v240;
  int v241;
  unsigned int v242;
  int v243;
  _BOOL4 v244;
  uint64_t v245;
  __int16 *v246;
  int v247;
  _WORD *v248;
  _BYTE *v249;
  void *v250;
  int v251;
  uint64_t v252;
  char *v253;
  int v254;
  int v255;
  __int16 *v256;
  size_t v257;
  char *v258;
  uint64_t v259;
  uint64_t v260;
  __int16 *v261;
  uint64_t v262;
  uint64_t v263;
  unsigned int v264;
  unsigned int v265[12];
  _DWORD v266[10];
  __n128 v267;
  uint64_t v268;
  uint64_t v269;

  v254 = a8;
  v255 = a7;
  v256 = a5;
  v249 = a4;
  v248 = a3;
  v250 = a2;
  v13 = a9;
  v269 = *MEMORY[0x24BDAC8D0];
  v265[0] = 0;
  v264 = 0;
  v260 = a11;
  v14 = 5 * a11 + 20;
  v15 = 4 * v14;
  v16 = (8 * v14);
  v17 = (v14 * a9);
  v18 = (__int16 *)&v241 - (int)v16;
  bzero(v18, 2 * (int)v16);
  v246 = a1;
  v245 = v17;
  if (a9 == 16)
  {
    v267.n128_u64[0] = 0;
    silk_resampler_down2((int *)&v267, (__int16 *)&v241 - (int)v16, (uint64_t)a1, v17);
  }
  else if (a9 == 12)
  {
    v267 = 0uLL;
    v268 = 0;
    silk_resampler_down2_3(&v267, (__int16 *)&v241 - (int)v16, a1, v17);
  }
  else
  {
    memcpy((char *)&v241 - 2 * (int)v16, a1, 2 * (int)v16);
  }
  v267.n128_u64[0] = 0;
  v19 = 2 * v15;
  v20 = (__int16 *)((char *)&v241 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v20, v19);
  silk_resampler_down2((int *)&v267, v20, (uint64_t)&v241 - 2 * (int)v16, v16);
  if ((int)v260 >= -3)
  {
    v21 = (char *)&v20[(20 * v260 + 76) + 3];
    v22 = 20 * v260 + 81;
    v23 = v21;
    do
    {
      v24 = *((__int16 *)v23 - 1);
      v23 -= 2;
      v25 = *(__int16 *)v21 + v24;
      if (v25 >= 0x7FFF)
        v25 = 0x7FFF;
      if (v25 <= -32768)
        LOWORD(v25) = 0x8000;
      *(_WORD *)v21 = v25;
      --v22;
      v21 = v23;
    }
    while (v22 > 2);
  }
  silk_sum_sqr_shift(v265, (int *)&v264, (uint64_t)v20, v15);
  v26 = v260;
  if ((int)v264 >= 1)
  {
    v27 = v264 >> 1;
    v264 >>= 1;
    if ((int)v260 >= -3)
    {
      if (v15 <= 1)
        v28 = 1;
      else
        v28 = v15;
      v29 = v20;
      do
      {
        *v29++ >>= v27;
        --v28;
      }
      while (v28);
    }
  }
  v30 = a10;
  v31 = 264 * v26;
  v32 = (__int16 *)((char *)&v241 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0));
  v257 = v31;
  bzero(v32, v31);
  *(&v241 - 4) = 0;
  *((_OWORD *)&v241 - 3) = 0u;
  *((_OWORD *)&v241 - 2) = 0u;
  *((_OWORD *)&v241 - 5) = 0u;
  *((_OWORD *)&v241 - 4) = 0u;
  *((_OWORD *)&v241 - 7) = 0u;
  *((_OWORD *)&v241 - 6) = 0u;
  *((_OWORD *)&v241 - 9) = 0u;
  *((_OWORD *)&v241 - 8) = 0u;
  *((_OWORD *)&v241 - 11) = 0u;
  *((_OWORD *)&v241 - 10) = 0u;
  *((_OWORD *)&v241 - 13) = 0u;
  *((_OWORD *)&v241 - 12) = 0u;
  v33 = (int)v260 >> 1;
  *((_OWORD *)&v241 - 15) = 0u;
  *((_OWORD *)&v241 - 14) = 0u;
  *((_OWORD *)&v241 - 16) = 0u;
  v34 = 2 * ((v33 << 6) + ((int)v260 >> 1));
  *((_OWORD *)&v241 - 17) = 0u;
  bzero(v32, v34);
  v251 = v13;
  v247 = a10;
  if ((int)v260 <= 1)
    goto LABEL_63;
  v252 = v16;
  v253 = (char *)&v241 - 2 * (int)v16;
  LODWORD(v258) = a6;
  v35 = 0;
  v36 = v20 + 80;
  v37 = v33 <= 1 ? 1 : v33;
  v259 = v37;
  v38 = (char *)(v20 + 111);
  v39 = 1;
  do
  {
    LODWORD(v261) = v39;
    v262 = (uint64_t)v38;
    v263 = v35;
    celt_pitch_xcorr_c(v36, (uint64_t)(v36 - 72), (uint64_t)(&v241 - 68), 40, 65);
    v40 = *(&v241 - 4);
    v41 = silk_inner_prod_aligned((unint64_t)v36, v36, 40);
    v42 = silk_inner_prod_aligned((unint64_t)(v36 - 8), v36 - 8, 40);
    v43 = (int)v261;
    v44 = (__int16 *)v262;
    v45 = v263;
    v46 = v41 + v42 + 160000;
    if (v40 >= 0)
      v47 = v40;
    else
      v47 = -v40;
    v48 = __clz(v47);
    v49 = -160000 - (v41 + v42);
    if (v46 >= 0)
      v49 = v41 + v42 + 160000;
    v50 = __clz(v49);
    v51 = v46 << (v50 - 1);
    v52 = 0x1FFFFFFF / (v51 >> 16);
    v53 = v52 * (v40 << (v48 - 1) >> 16) + ((v52 * (unsigned __int16)(v40 << (v48 - 1))) >> 16);
    v54 = (v40 << (v48 - 1)) - (((unint64_t)(v53 * (uint64_t)v51) >> 29) & 0xFFFFFFF8);
    v55 = v53 + (v54 >> 16) * v52 + (((unsigned __int16)v54 * v52) >> 16);
    v56 = v48 - v50;
    if ((v56 + 29) >= 0x2E)
      v57 = 0;
    else
      v57 = v55 >> (v56 + 15);
    v58 = (int)0x80000000 >> (-15 - v56);
    if (v55 > v58)
      v58 = v55;
    if (v55 <= (int)(0x7FFFFFFFu >> (-15 - v56)))
      v59 = v58;
    else
      v59 = 0x7FFFFFFFu >> (-15 - v56);
    v60 = v59 << (-15 - v56);
    if (v56 <= -16)
      v61 = v60;
    else
      v61 = v57;
    v32[(65 * v263)] = v61;
    v62 = v44;
    v63 = v43;
    v64 = 252;
    do
    {
      v65 = *(int *)((char *)&v241 + v64 - 272);
      v46 += (*v62 + *(v62 - 40)) * (*(v62 - 40) - *v62);
      if (v65 >= 0)
        v66 = *(int *)((char *)&v241 + v64 - 272);
      else
        v66 = -v65;
      v67 = __clz(v66);
      if (v46 >= 0)
        v68 = v46;
      else
        v68 = -v46;
      v69 = v65 << (v67 - 1);
      v70 = __clz(v68);
      v71 = v46 << (v70 - 1);
      v72 = 0x1FFFFFFF / (v71 >> 16);
      v73 = v72 * (v69 >> 16) + ((v72 * (unsigned __int16)v69) >> 16);
      v74 = v69 - (((unint64_t)(v71 * (uint64_t)v73) >> 29) & 0xFFFFFFF8);
      v75 = v73 + (v74 >> 16) * v72 + (((unsigned __int16)v74 * v72) >> 16);
      v76 = v67 - v70;
      v64 -= 4;
      --v62;
      v77 = v75 >> (v76 + 15);
      v78 = -15 - v76;
      v79 = (int)0x80000000 >> (-15 - v76);
      if ((v76 + 29) >= 0x2E)
        LOWORD(v77) = 0;
      if (v75 > v79)
        v79 = v75;
      if (v75 <= (int)(0x7FFFFFFFu >> v78))
        v80 = v79;
      else
        v80 = 0x7FFFFFFFu >> v78;
      v81 = v80 << v78;
      if (v76 > -16)
        LOWORD(v81) = v77;
      v32[v63++] = v81;
    }
    while (v64 != -4);
    v36 += 40;
    v35 = v45 + 1;
    v39 = v43 + 65;
    v38 = (char *)(v44 + 40);
  }
  while (v35 != v259);
  v82 = v260 == 4;
  v13 = v251;
  v30 = v247;
  a6 = (int)v258;
  v18 = (__int16 *)v253;
  LODWORD(v16) = v252;
  if ((_DWORD)v260 == 4)
  {
    v83 = 0;
    v84 = -75497472;
    do
    {
      v85 = &v32[v83];
      v86 = v85[129] + v85[64];
      v85[64] = v86
              + HIWORD(v86) * HIWORD(v84)
              + (((unsigned __int16)(v85[129] + v85[64]) * (v84 >> 16)) >> 16);
      v84 += 0x100000;
      v87 = v83 + 72;
      --v83;
    }
    while (v87 > 8);
  }
  else
  {
LABEL_63:
    v88 = 64;
    v89 = -75497472;
    do
    {
      v32[v88] = (v32[v88] >> 15) * HIWORD(v89)
               + 2 * v32[v88]
               + ((2 * (v32[v88] & 0x7FFFu) * (v89 >> 16)) >> 16);
      v89 += 0x100000;
      v90 = v88 + 8;
      --v88;
    }
    while (v90 > 8);
    v82 = 0;
  }
  v91 = (2 * v30 + 4);
  silk_insertion_sort_decreasing_int16((uint64_t)v32, (uint64_t)v266, 65, 2 * v30 + 4);
  v92 = *v32;
  if (v92 <= 3276)
  {
    v93 = 4 * (int)v260;
LABEL_176:
    bzero(v250, v93);
    LOBYTE(v178) = 0;
    *(_DWORD *)v256 = 0;
    *v248 = 0;
    result = 1;
    goto LABEL_177;
  }
  v242 = 5 * v13;
  LODWORD(v263) = 18 * v13;
  if (2 * v30 <= -4)
  {
    v96 = &v241 - 68;
    LOWORD(v97) = 0;
    *(_OWORD *)(&v241 - 5) = 0u;
    *((_OWORD *)&v241 - 3) = 0u;
    *((_OWORD *)&v241 - 2) = 0u;
    *((_OWORD *)&v241 - 5) = 0u;
    *((_OWORD *)&v241 - 4) = 0u;
    *((_OWORD *)&v241 - 7) = 0u;
    *((_OWORD *)&v241 - 6) = 0u;
    *((_OWORD *)&v241 - 9) = 0u;
    *((_OWORD *)&v241 - 8) = 0u;
    *((_OWORD *)&v241 - 11) = 0u;
    *((_OWORD *)&v241 - 10) = 0u;
    *((_OWORD *)&v241 - 13) = 0u;
    *((_OWORD *)&v241 - 12) = 0u;
    *((_OWORD *)&v241 - 15) = 0u;
    *((_OWORD *)&v241 - 14) = 0u;
    *((_OWORD *)&v241 - 16) = 0u;
    *((_OWORD *)&v241 - 17) = 0u;
  }
  else
  {
    v94 = 0;
    v95 = (v255 >> 16) * (unsigned __int16)v92 + (((unsigned __int16)v255 * (unsigned __int16)v92) >> 16);
    while (v95 < v32[v94])
    {
      v266[v94] = 2 * v266[v94] + 16;
      if (v91 == ++v94)
        goto LABEL_75;
    }
    LODWORD(v91) = v94;
LABEL_75:
    v96 = &v241 - 68;
    *(_OWORD *)(&v241 - 5) = 0u;
    *((_OWORD *)&v241 - 3) = 0u;
    *((_OWORD *)&v241 - 2) = 0u;
    *((_OWORD *)&v241 - 5) = 0u;
    *((_OWORD *)&v241 - 4) = 0u;
    *((_OWORD *)&v241 - 7) = 0u;
    *((_OWORD *)&v241 - 6) = 0u;
    *((_OWORD *)&v241 - 9) = 0u;
    *((_OWORD *)&v241 - 8) = 0u;
    *((_OWORD *)&v241 - 11) = 0u;
    *((_OWORD *)&v241 - 10) = 0u;
    *((_OWORD *)&v241 - 13) = 0u;
    *((_OWORD *)&v241 - 12) = 0u;
    *((_OWORD *)&v241 - 15) = 0u;
    *((_OWORD *)&v241 - 14) = 0u;
    *((_OWORD *)&v241 - 16) = 0u;
    *((_OWORD *)&v241 - 17) = 0u;
    if ((int)v91 < 1)
    {
      LOWORD(v97) = 0;
    }
    else
    {
      v98 = v91;
      v99 = v266;
      do
      {
        v100 = *v99++;
        *((_WORD *)v96 + v100 - 13) = 1;
        --v98;
      }
      while (v98);
      v97 = *((unsigned __int16 *)&v241 - 4);
    }
  }
  v101 = 0;
  v243 = 2 * v13;
  v241 = v263 - 1;
  do
  {
    v102 = (char *)v96 + 2 * v101;
    v103 = *((_WORD *)v102 + 131);
    *((_WORD *)v102 + 133) += v103 + v97;
    v104 = v101 + 146;
    --v101;
    LOWORD(v97) = v103;
  }
  while (v104 > 0x10);
  v105 = 0;
  v106 = 0;
  do
  {
    if (*((__int16 *)v96 + v105 + 4) >= 1)
      v266[v106++] = v105 + 16;
    ++v105;
  }
  while (v105 != 128);
  v107 = 0;
  v108 = *((_WORD *)v96 + 132);
  v109 = *((_WORD *)v96 + 131);
  do
  {
    v110 = v109 + v108;
    v111 = (char *)v96 + 2 * v107;
    v108 = v109;
    v109 = *((_WORD *)v111 + 130);
    *((_WORD *)v111 + 133) += v110 + v109;
    v112 = v107 + 146;
    --v107;
  }
  while (v112 > 0x10);
  v113 = 0;
  v114 = 0;
  do
  {
    if (*((__int16 *)v96 + v113 + 3) >= 1)
      *((_WORD *)v96 + v114++) = v113 + 14;
    ++v113;
  }
  while (v113 != 131);
  silk_sum_sqr_shift(v265, (int *)&v264, (uint64_t)v18, v16);
  v244 = v82;
  if ((int)v264 >= 1)
  {
    v115 = v264 >> 1;
    v264 >>= 1;
    if ((int)v260 <= -4)
    {
      bzero(v32, v257);
      v145 = 0;
      v118 = v260;
      goto LABEL_124;
    }
    if ((int)v16 <= 1)
      v116 = 1;
    else
      v116 = v16;
    v117 = v18;
    do
    {
      *v117++ >>= v115;
      --v116;
    }
    while (v116);
  }
  bzero(v32, v257);
  v118 = v260;
  if ((int)v260 < 1)
  {
    v145 = 0;
  }
  else
  {
    v255 = v106;
    v261 = (__int16 *)v96;
    LODWORD(v258) = a6;
    v119 = 0;
    v120 = v18 + 160;
    LODWORD(v259) = -14;
    v257 = v114;
    LODWORD(v262) = v114;
    do
    {
      v121 = silk_inner_prod_aligned((unint64_t)v120, v120, 40);
      if (v114 >= 1)
      {
        v122 = v121 + 1;
        v123 = v259 + 132 * v119;
        v124 = v257;
        v125 = v261;
        do
        {
          v127 = *v125++;
          v126 = v127;
          v128 = &v120[-v127];
          v129 = silk_inner_prod_aligned((unint64_t)v120, v128, 40);
          if (v129 < 1)
          {
            LOWORD(v144) = 0;
          }
          else
          {
            v130 = v129;
            v131 = v122 + silk_inner_prod_aligned((unint64_t)v128, v128, 40);
            v132 = __clz(v130);
            if (v131 >= 0)
              v133 = v131;
            else
              v133 = -v131;
            v134 = __clz(v133);
            v135 = v131 << (v134 - 1);
            v136 = 0x1FFFFFFF / (v135 >> 16);
            v137 = v136 * ((int)(v130 << (v132 - 1)) >> 16) + ((v136 * (unsigned __int16)(v130 << (v132 - 1))) >> 16);
            v138 = (v130 << (v132 - 1)) - (((unint64_t)(v137 * (uint64_t)v135) >> 29) & 0xFFFFFFF8);
            v139 = v137 + (v138 >> 16) * v136 + (((unsigned __int16)v138 * v136) >> 16);
            v140 = v132 - v134;
            if ((v140 + 29) >= 0x2E)
              v141 = 0;
            else
              v141 = v139 >> (v140 + 15);
            v142 = (int)0x80000000 >> (-15 - v140);
            if (v139 > v142)
              v142 = v139;
            if (v139 <= (int)(0x7FFFFFFFu >> (-15 - v140)))
              v143 = v142;
            else
              v143 = 0x7FFFFFFFu >> (-15 - v140);
            v144 = v143 << (-15 - v140);
            if (v140 > -16)
              LOWORD(v144) = v141;
          }
          v32[v123 + v126] = v144;
          --v124;
        }
        while (v124);
      }
      v120 += 40;
      ++v119;
      v118 = v260;
      v114 = v262;
    }
    while (v119 != (_DWORD)v260);
    v145 = 1;
    v13 = v251;
    a6 = (int)v258;
    v82 = v244;
    v106 = v255;
  }
LABEL_124:
  if (a6 < 1)
  {
    v255 = 0;
  }
  else
  {
    if (v13 == 12)
      a6 = 2 * a6 / 3;
    else
      a6 = a6 >> (v13 == 16);
    v146 = silk_lin2log(a6);
    v118 = v260;
    v255 = v146;
  }
  v147 = (__int16 *)&silk_CB_lags_stage2_10_ms;
  if (v82)
    v147 = (__int16 *)silk_CB_lags_stage2;
  v261 = v147;
  if (v106 < 1)
    goto LABEL_175;
  LODWORD(v258) = a6;
  v148 = 0;
  LODWORD(v252) = 0;
  v149 = v13 != 8 || v247 <= 0;
  v150 = !v149;
  v151 = (__int16)(1638 * v118);
  LODWORD(v259) = (__int16)v118 * (__int16)v254;
  v152 = v82 ? 11 : 3;
  v257 = v106;
  v153 = v82 && v150 ? 11 : 3;
  v254 = -1;
  LODWORD(v262) = 0x80000000;
  LODWORD(v253) = 0x80000000;
  do
  {
    v154 = 0;
    v155 = v266[v148];
    v156 = (char *)v261;
    do
    {
      v265[v154 + 1] = 0;
      if (v145)
      {
        v157 = 0;
        v158 = v118;
        v159 = v156;
        v160 = v155 - 14;
        do
        {
          v157 += v32[v160 + *v159];
          v160 += 132;
          v159 += v152;
          --v158;
        }
        while (v158);
        v265[v154 + 1] = v157;
      }
      ++v154;
      ++v156;
    }
    while (v154 != v153);
    v161 = 0;
    v162 = 0;
    v163 = 0x80000000;
    do
    {
      if ((int)v265[v161 + 1] > v163)
      {
        v162 = v161;
        v163 = v265[v161 + 1];
      }
      ++v161;
    }
    while (v153 != v161);
    v164 = silk_lin2log(v155);
    v165 = v163 - ((v164 * v151) >> 7);
    if ((int)v258 >= 1)
    {
      v166 = ((__int16)(v164 - v255) * (__int16)(v164 - v255)) >> 7;
      v165 -= (int)(((*v256 * v151) >> 15) * v166) / (int)(v166 + 64);
    }
    v167 = v165 <= (int)v262 || v163 <= (int)v259;
    v118 = v260;
    if (!v167 && silk_CB_lags_stage2[v162] <= 16)
    {
      LODWORD(v252) = v162;
      v254 = v155;
      LODWORD(v253) = v163;
      LODWORD(v262) = v165;
    }
    ++v148;
  }
  while (v148 != v257);
  v168 = v254;
  v169 = v251;
  if (v254 == -1)
  {
LABEL_175:
    v93 = 4 * (int)v118;
    goto LABEL_176;
  }
  *(_DWORD *)v256 = 4 * ((int)v253 / (int)v260);
  if (v169 <= 8)
  {
    v180 = (int *)v250;
    LOBYTE(v178) = v252;
    if (v145)
    {
      v181 = (char *)v261 + (int)v252;
      do
      {
        v182 = v168 + *v181;
        if (v182 <= 16)
          v182 = 16;
        if (v182 >= 144)
          v182 = 144;
        *v180++ = v182;
        v181 += v152;
        --v118;
      }
      while (v118);
    }
    v183 = v168 - 16;
  }
  else
  {
    v170 = (uint64_t)v246;
    v171 = v245;
    silk_sum_sqr_shift(v265, (int *)&v264, (uint64_t)v246, v245);
    v172 = v264;
    if ((int)v264 <= 0)
      v173 = 0;
    else
      v173 = v171;
    v174 = 2 * v173;
    v175 = (char *)&v241 - ((v174 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v175, v174);
    if (v172 < 1)
    {
      v176 = v260;
    }
    else
    {
      v264 = v172 >> 1;
      v176 = v260;
      if (v171 >= 1)
      {
        v177 = 0;
        do
        {
          *(_WORD *)&v175[v177] = *(__int16 *)(v170 + v177) >> (v172 >> 1);
          v177 += 2;
        }
        while (2 * v171 != v177);
      }
      v170 = (uint64_t)v175;
    }
    v184 = 2 * v168;
    if (v169 != 16)
      v184 = 3 * (__int16)v168;
    v185 = (3 * (__int16)v168) >> 1;
    if (v169 != 12)
      v185 = v184;
    if (v185 <= v243)
      v186 = v243;
    else
      v186 = v185;
    if (v185 >= (int)v263)
      v186 = v241;
    if (v185 <= v241)
      v187 = v241;
    else
      v187 = v185;
    if (v185 <= v243)
      v188 = v187;
    else
      v188 = v243;
    if (v243 >= (int)v263)
      v189 = v188;
    else
      v189 = v186;
    if (v189 - 2 <= v243)
      v190 = v243;
    else
      v190 = v189 - 2;
    v191 = v189 + 2;
    if (v189 + 2 >= v241)
      v191 = v241;
    LODWORD(v261) = v191;
    if (v145)
    {
      v192 = &silk_CB_lags_stage2[(int)v252];
      v193 = v176;
      v194 = v250;
      do
      {
        v195 = *v192;
        v192 += 11;
        *v194++ = v189 + 2 * v195;
        --v193;
      }
      while (v193);
    }
    v196 = v170;
    if (v244)
    {
      v197 = v247;
      v198 = silk_nb_cbk_searchs_stage3[v247];
      v258 = silk_CB_lags_stage3;
      v259 = 34;
    }
    else
    {
      v258 = (char *)&silk_CB_lags_stage3_10_ms;
      v198 = 12;
      v259 = 12;
      v197 = v247;
    }
    v199 = (char *)&v241 - ((20 * (int)v198 * (int)v176 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v199, 20 * (int)v198 * (int)v176);
    v200 = v199;
    bzero(v199, 20 * (int)v198 * (int)v176);
    v201 = v196;
    v202 = v196;
    v203 = v242;
    silk_P_Ana_calc_corr_st3((uint64_t)v199, v202, v190, v242, v176, v197);
    silk_P_Ana_calc_energy_st3((unint64_t)v199, v201, v190, v203, v176, v197);
    v204 = silk_inner_prod_aligned(v201 + 40 * v251, (__int16 *)(v201 + 40 * v251), (int)v203 * (int)v176);
    if (v190 <= (int)v261)
    {
      v206 = 0;
      v178 = 0;
      v207 = (1638 / v189) << 16;
      v261 = (__int16 *)((_DWORD)v261 - v190 + 1);
      v208 = v198;
      v209 = 20 * (int)v198;
      v210 = 0x80000000;
      v205 = v260;
      v262 = v198;
      do
      {
        if ((int)v198 >= 1)
        {
          v211 = 0;
          v212 = v199;
          v213 = v200;
          do
          {
            if (!v145)
              goto LABEL_239;
            v214 = 0;
            v215 = 0;
            v216 = v260;
            v217 = v204 + 1;
            do
            {
              v215 += *(_DWORD *)&v213[v214];
              v217 += *(_DWORD *)&v212[v214];
              v214 += v209;
              --v216;
            }
            while (v216);
            if (v215 >= 1)
            {
              v218 = __clz(v215);
              v219 = v215 << (v218 - 1);
              if (v217 >= 0)
                v220 = v217;
              else
                v220 = -v217;
              v221 = __clz(v220);
              v222 = v217 << (v221 - 1);
              v223 = 0x1FFFFFFF / (v222 >> 16);
              v224 = v223 * (v219 >> 16) + ((v223 * (unsigned __int16)v219) >> 16);
              v225 = v219 - (((unint64_t)(v224 * (uint64_t)v222) >> 29) & 0xFFFFFFF8);
              v226 = v224 + (v225 >> 16) * v223 + (((unsigned __int16)v225 * v223) >> 16);
              v227 = v218 - v221;
              if (v218 - v221 + 29 >= 0x2E)
                v228 = 0;
              else
                v228 = v226 >> (v227 + 15);
              v229 = (int)0x80000000 >> (-15 - v227);
              if (v226 > v229)
                v229 = v226;
              if (v226 <= (int)(0x7FFFFFFFu >> (-15 - v227)))
                v230 = v229;
              else
                v230 = 0x7FFFFFFFu >> (-15 - v227);
              v231 = v230 << (-15 - v227);
              if (v227 > -16)
                v231 = v228;
              v232 = (v231 >> 16) * ((2147418112 - v207 * (int)v211) >> 16)
                   + (((unsigned __int16)v231 * ((2147418112 - v207 * (int)v211) >> 16)) >> 16);
            }
            else
            {
LABEL_239:
              v232 = 0;
            }
            if (v232 > v210 && v190 + silk_CB_lags_stage3[v211] < (int)v263)
            {
              v178 = v211;
              v189 = v190;
              v210 = v232;
            }
            ++v211;
            v213 += 20;
            v212 += 20;
          }
          while (v211 != v208);
        }
        v206 = (__int16 *)((char *)v206 + 1);
        ++v190;
        v200 += 4;
        v199 += 4;
        LODWORD(v198) = v262;
      }
      while (v206 != v261);
    }
    else
    {
      v178 = 0;
      v205 = v260;
    }
    v233 = (int *)v250;
    v234 = v259;
    if (v145)
    {
      v235 = v263;
      if (v243 <= (int)v263)
        v236 = v263;
      else
        v236 = v243;
      if (v243 < (int)v263)
        v235 = v243;
      v237 = &v258[v178];
      do
      {
        v238 = v189 + *v237;
        if (v238 <= v235)
          v239 = v235;
        else
          v239 = v189 + *v237;
        if (v238 <= v236)
          v240 = v239;
        else
          v240 = v236;
        *v233++ = v240;
        v237 += v234;
        --v205;
      }
      while (v205);
    }
    v183 = v189 - v243;
  }
  result = 0;
  *v248 = v183;
LABEL_177:
  *v249 = v178;
  return result;
}

uint64_t silk_P_Ana_calc_corr_st3(uint64_t result, uint64_t a2, int a3, uint64_t a4, int a5, int a6)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  uint64_t v16;
  int *v17;
  _DWORD *v18;
  int v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  _BYTE v25[80];
  uint64_t v26;
  _DWORD v27[20];
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;

  v36 = a4;
  v31 = result;
  v37 = *MEMORY[0x24BDAC8D0];
  if (a5 == 4)
  {
    v35 = (char *)&silk_Lag_range_stage3 + 8 * a6;
    v6 = silk_nb_cbk_searchs_stage3[a6];
    v30 = &silk_CB_lags_stage3;
    v7 = 34;
  }
  else
  {
    v30 = (char *)&silk_CB_lags_stage3_10_ms;
    v35 = (char *)&silk_Lag_range_stage3_10_ms;
    v6 = 12;
    v7 = 12;
  }
  v34 = v7;
  v28 = 0;
  memset(v27, 0, sizeof(v27));
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  if (a5 >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = (__int16 *)(a2 + 8 * (_DWORD)v36);
    v32 = (int)v36;
    v33 = -(uint64_t)a3;
    v11 = a5;
    v12 = 0;
    v29 = v6;
    do
    {
      v13 = &v35[2 * v12];
      v14 = *v13;
      v15 = v13[1];
      result = celt_pitch_xcorr_c(v10, (uint64_t)&v10[v33 - v13[1]], (uint64_t)v25, v36, v15 - v14 + 1);
      if (v15 >= v14)
      {
        v16 = (v15 - v14 + 1);
        v17 = (int *)&v25[4 * v15 + -4 * v14];
        v18 = v27;
        do
        {
          v19 = *v17--;
          *v18++ = v19;
          --v16;
        }
        while (v16);
      }
      if (v6 >= 1)
      {
        v20 = v31 + 20 * v9;
        v21 = &v30[v8 & 0xFFFFFFFE];
        v22 = v29;
        do
        {
          v23 = *v21++;
          v24 = &v27[v23 - v14];
          *(_OWORD *)v20 = *(_OWORD *)v24;
          *(_DWORD *)(v20 + 16) = v24[4];
          v20 += 20;
          --v22;
        }
        while (v22);
      }
      v10 += v32;
      ++v12;
      v9 += v6;
      v8 += v34;
    }
    while (v12 != v11);
  }
  return result;
}

unint64_t silk_P_Ana_calc_energy_st3(unint64_t result, uint64_t a2, int a3, uint64_t a4, int a5, int a6)
{
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  int v23;
  int v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;

  v47 = a4;
  v46 = a3;
  v40 = result;
  v48 = *MEMORY[0x24BDAC8D0];
  if (a5 == 4)
  {
    v45 = (char *)&silk_Lag_range_stage3 + 8 * a6;
    v6 = silk_nb_cbk_searchs_stage3[a6];
    v36 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    v44 = 34;
    v39 = &silk_CB_lags_stage3;
  }
  else
  {
    v36 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    if (a5 < 1)
      return result;
    v44 = 12;
    v45 = (char *)&silk_Lag_range_stage3_10_ms;
    v39 = (char *)&silk_CB_lags_stage3_10_ms;
    v6 = 12;
  }
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = a2 + 8 * (_DWORD)v47;
  v43 = 2 * (int)v47;
  v37 = (char *)&v31 + 4;
  v38 = v43 - 2;
  v41 = v6;
  v42 = a5;
  do
  {
    v11 = &v45[2 * v9];
    v12 = *v11;
    v13 = v12 + v46;
    result = silk_inner_prod_aligned(v10 - 2 * v13, (__int16 *)(v10 - 2 * v13), v47);
    LODWORD(v31) = result;
    v14 = v11[1];
    v15 = __OFSUB__(v14, v12);
    v16 = v14 - v12;
    if (!((v16 < 0) ^ v15 | (v16 == 0)))
    {
      v17 = (v16 + 1);
      v18 = (2 * v13) ^ 0xFFFFFFFFFFFFFFFELL;
      v19 = v38 - 2 * v13;
      v20 = v17 - 1;
      v21 = v37;
      do
      {
        v22 = result - *(__int16 *)(v10 + v19) * *(__int16 *)(v10 + v19);
        v23 = v22 + *(__int16 *)(v10 + v18) * *(__int16 *)(v10 + v18);
        if (v23 >= 0 || v22 <= -1)
          result = v23;
        else
          result = 0x7FFFFFFFLL;
        *v21++ = result;
        v18 -= 2;
        v19 -= 2;
        --v20;
      }
      while (v20);
    }
    v25 = v41;
    if ((int)v41 >= 1)
    {
      v26 = v40 + 20 * v8;
      v27 = &v39[v7 & 0xFFFFFFFE];
      v28 = v41;
      do
      {
        v29 = *v27++;
        v30 = (char *)&v31 + 4 * (v29 - v12);
        *(_OWORD *)v26 = *(_OWORD *)v30;
        *(_DWORD *)(v26 + 16) = *((_DWORD *)v30 + 4);
        v26 += 20;
        --v28;
      }
      while (v28);
    }
    v10 += v43;
    ++v9;
    v8 += v25;
    v7 += v44;
  }
  while (v9 != v42);
  return result;
}

uint64_t silk_noise_shape_analysis_FIX(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v7;
  int *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  signed int v27;
  int v28;
  BOOL v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  char v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  size_t v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  int v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  signed int v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  unsigned int v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  BOOL v77;
  int v78;
  uint64_t v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  char v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  char v89;
  int v90;
  unsigned int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  uint64_t v99;
  unsigned int v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  int v104;
  unsigned int v105;
  unsigned int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  unsigned int v115;
  int v116;
  uint64_t v117;
  unint64_t v118;
  int v119;
  int v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  unsigned int v133;
  int v134;
  int v135;
  int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  unsigned int v148;
  int v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  __int16 *v153;
  int v154;
  int v155;
  uint64_t v156;
  unsigned int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int *v162;
  int *v163;
  uint64_t v164;
  int v165;
  int v166;
  int v167;
  uint64_t v168;
  unsigned int v169;
  char v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  char v176;
  int v177;
  unsigned int v178;
  int v179;
  unsigned int v180;
  char v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  char v187;
  int v188;
  unsigned int v189;
  int v190;
  unsigned int v191;
  int v192;
  unsigned int v193;
  int v194;
  unsigned int v195;
  unsigned int v196;
  int v197;
  int v198;
  int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  unsigned int v205;
  int v206;
  int v207;
  uint64_t v208;
  int v209;
  int v210;
  int v211;
  unsigned int v212;
  unsigned int v213;
  unsigned int v214;
  int v215;
  int v216;
  int v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  unsigned int v223;
  int v224;
  int v225;
  unsigned int v226;
  unsigned int v227;
  unsigned int v228;
  int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  int v235;
  signed int v236;
  unsigned int v237;
  int v238;
  int *v239;
  int *v240;
  uint64_t v241;
  uint64_t v242;
  int *v243;
  int *v244;
  int v245;
  int v246;
  unsigned int v247;
  __int16 v248;
  int v249;
  int v250;
  unsigned int v251;
  __int16 v252;
  int v253;
  int v254;
  uint64_t v255;
  uint64_t v256;
  int v257;
  uint64_t v258;
  int v259;
  int v260;
  int v261;
  signed int v262;
  int v263;
  int v264;
  uint64_t v265;
  int v266;
  int v267;
  int v268;
  uint64_t v269;
  int v270;
  unsigned int v271;
  uint64_t v272;
  uint64_t v273;
  int32x2_t *v274;
  int v275;
  int v276;
  int v277;
  unsigned int v278;
  int v279;
  uint64_t result;
  int v281;
  signed int v282;
  signed int v283;
  unsigned int v284;
  unsigned int v285;
  BOOL v286;
  int v287;
  int v288;
  int v289;
  uint64_t v290;
  int v291;
  int32x2_t v292;
  int32x2_t v293;
  uint32x2_t v294;
  _DWORD *v295;
  uint64_t v296;
  unsigned __int8 *v297;
  int v298;
  uint64_t v299;
  unsigned int v300;
  int v301;
  int v302;
  char *v303;
  int *v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  int *v309;
  int *v310;
  uint64_t v311;
  unint64_t v312;
  unsigned int v313;
  int v314;
  int v315;
  uint64_t v316;
  uint64_t v317;
  signed int v318;
  int v319;
  int v320;
  uint64_t v321;
  int v322;
  uint64_t v323;
  char v324[64];
  unsigned int v325[17];
  uint64_t v326;

  v298 = a5;
  v7 = a2;
  v8 = a1;
  v326 = *MEMORY[0x24BDAC8D0];
  v9 = (unsigned __int8 *)a1 + 4813;
  v319 = 0;
  v10 = a1[1156];
  v11 = a1[1191];
  *(_DWORD *)(a2 + 480) = (a1[1187] + a1[1186]) >> 2;
  v12 = (int)silk_sigm_Q15((((v11 - 2560) >> 3) + 1) >> 1) >> 1;
  *(_DWORD *)(v7 + 484) = v12;
  if (!v8[1177])
  {
    v13 = -8
        * ((int)((-*((_BYTE *)v8 + 4556) << 8) * (__int16)(256 - *((_WORD *)v8 + 2278))
               + (((256 - v8[1139]) * ((256 - v8[1139]) >> 8)) << 16)) >> 16);
    v14 = (int)((unsigned __int16)(*(_WORD *)(v7 + 480) + 0x4000) * (__int16)v12
              + ((v12 * ((*(_DWORD *)(v7 + 480) + 0x4000) >> 16)) << 16)) >> 16;
    v11 += (v13 >> 16) * v14 + (((v13 & 0xFFF8) * v14) >> 16);
  }
  v318 = 0;
  v15 = *v9;
  v305 = v7;
  v297 = v9;
  if (v15 == 2)
  {
    HIDWORD(v296) = v11 + (v8[2449] << 16 >> 23);
    v9[1] = 0;
    *(_DWORD *)(v7 + 488) = 0;
  }
  else
  {
    v316 = v10;
    v317 = a4;
    v16 = ((26214 * (__int16)v8[1191]) >> 16) - 2 * (__int16)v8[1191] + 3072;
    v17 = (__int16)(0x4000 - *(_WORD *)(v7 + 480));
    v315 = (v16 >> 16) * v17;
    v18 = ((unsigned __int16)v16 * v17) >> 16;
    if (v8[1151] << 16 < 1)
    {
      v20 = 0;
    }
    else
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 2 * v8[1150];
      do
      {
        silk_sum_sqr_shift((unsigned int *)&v318, &v319, a3, v22);
        v318 += v22 >> v319;
        v23 = silk_lin2log(v318);
        v24 = v23 - v21;
        if (v23 - v21 < 0)
          v24 = v21 - v23;
        v25 = v24 + v20;
        if (v19)
          v20 = v25;
        ++v19;
        a3 += 2 * v22;
        v21 = v23;
      }
      while (v19 < 5 * *((__int16 *)v8 + 2302) / 2);
    }
    v26 = silk_sigm_Q15(6554 * ((v20 - 640) >> 16) + ((6554 * (unsigned __int16)(v20 - 640)) >> 16));
    v7 = v305;
    *(_DWORD *)(v305 + 488) = v26 >> 7;
    v297[1] = v26 < 24704;
    HIDWORD(v296) = v315 + v11 + v18 + (__int16)((v26 >> 7) - 128);
    v10 = v316;
    a4 = v317;
  }
  v27 = 66 * (*(int *)(v7 + 492) >> 16) + ((66 * (unsigned __int16)*(_DWORD *)(v7 + 492)) >> 16);
  v28 = (__int16)v27 * (v27 >> 16)
      + (((__int16)v27
        * (unsigned __int16)(66 * HIWORD(*(_DWORD *)(v7 + 492))
                           + ((66 * (unsigned __int16)*(_DWORD *)(v7 + 492)) >> 16))) >> 16)
      + (((v27 >> 15) + 1) >> 1) * v27;
  v30 = v28 + 0x10000;
  v29 = v28 + 0x10000 < 0;
  v31 = -65536 - v28;
  if (!v29)
    v31 = v30;
  v32 = __clz(v31);
  v33 = v30 << (v32 - 1);
  v34 = 0x1FFFFFFF / (v33 >> 16);
  v35 = 31129 * (__int16)v34 + ((__int16)v34 >> 1);
  v36 = 2040102912 - (((unint64_t)(v33 * (uint64_t)v35) >> 29) & 0xFFFFFFF8);
  v37 = v35 + (v36 >> 16) * (__int16)v34 + (((v36 & 0xFFF8) * (__int16)v34) >> 16);
  v38 = v37 >> (29 - v32);
  v39 = v32 - 29;
  v40 = (int)0x80000000 >> v39;
  if (v37 > (int)0x80000000 >> v39)
    v40 = v37;
  if (v37 <= (int)(0x7FFFFFFFu >> v39))
    v41 = v40;
  else
    v41 = 0x7FFFFFFFu >> v39;
  v42 = v41 << v39;
  if (v31 <= 3)
    v43 = v42;
  else
    v43 = v38;
  v44 = *(_DWORD *)(v7 + 484);
  v45 = v8[1176];
  if (v45 < 1)
    v300 = 0;
  else
    v300 = v45
         + 2621 * (*(int *)(v7 + 484) >> 16)
         + ((2621 * (unsigned __int16)*(_DWORD *)(v7 + 484)) >> 16);
  v46 = 2 * v8[1157];
  v303 = (char *)&v296 - ((v46 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v303, v46);
  if (v8[1151] >= 1)
  {
    v47 = 0;
    v48 = 655 * ((-3 * (__int16)v44 + 0x10000) >> 16) + ((655 * (unsigned __int16)(-3 * v44)) >> 16);
    v49 = a4 - 2 * v10;
    v301 = (int)((v43 - v48) << 14) / ((int)(v48 + v43) >> 2);
    v302 = v48 + v43;
    v50 = (__int16)v300;
    v51 = v50 * ((signed int)-v300 >> 16) + ((v50 * (unsigned __int16)-(__int16)v300) >> 16);
    v52 = (__int16)-(__int16)v300;
    v53 = v51 + 0x10000;
    v29 = v51 + 0x10000 < 0;
    v54 = -65536 - v51;
    if (!v29)
      v54 = v53;
    v55 = __clz(v54);
    v56 = v53 << (v55 - 1);
    v315 = v56 >> 16;
    LODWORD(v316) = v56;
    v313 = v55 + 4;
    v314 = (unsigned __int16)v56;
    v309 = (int *)&v321;
    v310 = (int *)&v323;
    v299 = v7 + 268;
    v304 = v8;
    do
    {
      v308 = v47;
      v57 = 3 * v8[1150];
      v58 = (v8[1157] - (int)v57) >> 1;
      v59 = v303;
      v60 = v49;
      silk_apply_sine_window((uint64_t)v303, v49, 1, v58);
      memcpy(&v59[2 * v58], (const void *)(v60 + 2 * v58), 2 * v57);
      v307 = v60;
      v61 = v60 + 2 * ((int)v57 + v58);
      v8 = v304;
      silk_apply_sine_window((uint64_t)&v59[2 * (int)v57 + 2 * v58], v61, 2, v58);
      v62 = v8[1176];
      v63 = v8[1157];
      v64 = v8[1165];
      v306 = v8[1153];
      if (v62 < 1)
        silk_autocorr(v325, &v319, v59, v63, v64 + 1);
      else
        silk_warped_autocorrelation_FIX(v325, &v319, (uint64_t)v59, v300, v63, v64);
      v65 = 52 * ((int)v325[0] >> 20) + ((52 * (unsigned __int16)(v325[0] >> 4)) >> 16);
      if (v65 <= 1)
        v65 = 1;
      v325[0] += v65;
      v318 = silk_schur64(v324, (const float *)v325, v8[1165]);
      silk_k2a_Q16(&v320, (uint64_t)v324, v8[1165]);
      v66 = -v319;
      v7 = v305;
      if ((-v319 & 1) != 0)
      {
        v66 = ~v319;
        v67 = v318 >> 1;
        v318 >>= 1;
      }
      else
      {
        v67 = v318;
      }
      v68 = v308;
      if ((int)v67 < 1)
      {
        v72 = 0;
      }
      else
      {
        v69 = __clz(v67);
        if (v69 != 24)
        {
          if (v67 <= 0x7F)
            LOBYTE(v67) = (v67 >> (56 - v69)) | ((_BYTE)v67 << (v69 - 24));
          else
            LOBYTE(v67) = ((_BYTE)v67 << (v69 + 8)) | (v67 >> (24 - v69));
        }
        v70 = v67 & 0x7F;
        if ((v69 & 1) != 0)
          v71 = 0x8000;
        else
          v71 = 46214;
        v72 = (v71 >> (v69 >> 1)) + ((213 * (v71 >> (v69 >> 1)) * v70) >> 16);
      }
      v73 = 16 - (v66 >> 1);
      if (v72 >= 0x7FFFFFFFu >> v73)
        v72 = 0x7FFFFFFFu >> v73;
      v74 = v72 << v73;
      *(_DWORD *)(v305 + 4 * v308) = v74;
      if (v8[1176] >= 1)
      {
        v75 = v8[1165];
        v76 = *(&v320 + v75 - 1);
        v77 = __OFSUB__(v75, 2);
        v78 = v75 - 2;
        if (v78 < 0 == v77)
        {
          v79 = 4 * v78;
          do
          {
            v76 = *(int *)((char *)&v320 + v79) + (v76 >> 16) * v52 + (((unsigned __int16)v76 * v52) >> 16);
            v79 -= 4;
          }
          while (v79 != -4);
        }
        v80 = (v76 >> 16) * v50 + (((unsigned __int16)v76 * v50) >> 16);
        v81 = v80 + 0x1000000;
        v29 = v80 + 0x1000000 < 0;
        v82 = -16777216 - v80;
        if (!v29)
          v82 = v81;
        v83 = __clz(v82);
        v84 = v81 << (v83 - 1);
        v85 = 0x1FFFFFFF / (v84 >> 16);
        v86 = (v84 >> 16) * (__int16)v85 + (((unsigned __int16)v84 * (__int16)v85) >> 16);
        v87 = (v85 << 16)
            - 8 * v86 * (((v85 >> 15) + 1) >> 1)
            + ((-8 * v86) >> 16) * (__int16)v85
            + ((((-8 * v86) & 0xFFF8) * (__int16)v85) >> 16);
        v88 = v87 >> (22 - v83);
        v89 = v83 - 22;
        v90 = (int)0x80000000 >> v89;
        if (v87 > (int)0x80000000 >> v89)
          v90 = v87;
        if (v87 <= (int)(0x7FFFFFFFu >> v89))
          v91 = v90;
        else
          v91 = 0x7FFFFFFFu >> v89;
        v92 = v91 << v89;
        if (v82 > 0x3FF)
          v92 = v88;
        v93 = (__int16)v92;
        v94 = ((v92 >> 15) + 1) >> 1;
        if (v93 * (((v74 & 1) + (v74 >> 1)) >> 16)
           + ((v93 * (unsigned __int16)((v74 & 1) + (v74 >> 1))) >> 16)
           + v94 * ((v74 & 1) + (v74 >> 1)) <= 1073741822)
          v95 = v93 * (v74 >> 16) + ((v93 * (unsigned __int16)v74) >> 16) + v94 * v74;
        else
          v95 = 0x7FFFFFFF;
        *(_DWORD *)(v7 + 4 * v68) = v95;
      }
      silk_bwexpander_32(&v320, v8[1165], v302);
      v96 = v8[1165];
      __memcpy_chk();
      silk_bwexpander_32(&v322, v96, v301);
      v97 = silk_LPC_inverse_pred_gain_Q24(&v320, v8[1165]);
      v98 = silk_LPC_inverse_pred_gain_Q24(&v322, v8[1165]);
      v99 = v308;
      v318 = v98;
      v100 = 22938 * (unsigned __int16)v97;
      v101 = 2 * (22938 * (v97 >> 16) + HIWORD(v100));
      if (((22938 * (v97 >> 16) + HIWORD(v100)) & 0x40000000) != 0)
        v102 = -2 * (22938 * (v97 >> 16) + HIWORD(v100));
      else
        v102 = 2 * (22938 * (v97 >> 16) + HIWORD(v100));
      v103 = __clz(v102);
      v104 = v101 << (v103 - 1);
      if (v98 >= 0)
        v105 = v98;
      else
        v105 = -v98;
      v106 = __clz(v105);
      v107 = v98 << (v106 - 1);
      v108 = 0x1FFFFFFF / (v107 >> 16);
      v109 = (v104 >> 16) * v108 + (((v104 & 0xFFFE) * v108) >> 16);
      v110 = v104 - (((unint64_t)(v109 * (uint64_t)v107) >> 29) & 0xFFFFFFF8);
      v111 = v109 + (v110 >> 16) * v108 + (((v110 & 0xFFFE) * v108) >> 16);
      v112 = v103 - v106;
      if ((v112 + 15) >= 0x20)
        v113 = 0;
      else
        v113 = v111 >> (v112 + 15);
      v114 = (int)0x80000000 >> (-15 - v112);
      if (v111 > v114)
        v114 = v111;
      if (v111 <= (int)(0x7FFFFFFFu >> (-15 - v112)))
        v115 = v114;
      else
        v115 = 0x7FFFFFFFu >> (-15 - v112);
      v116 = v115 << (-15 - v112);
      if (v112 > -16)
        v116 = v113;
      *(_DWORD *)(v7 + 4 * v308 + 412) = v116 + 4915;
      v117 = v8[1165];
      v312 = (v117 - 1);
      if ((int)v117 >= 2)
      {
        v118 = v312;
        do
        {
          v119 = *(&v320 + v118);
          v120 = *(&v322 + v118);
          v286 = v118-- > 1;
          *(&v320 + v118) += (v119 >> 16) * v52 + (((unsigned __int16)v119 * v52) >> 16);
          *(&v322 + v118) += (v120 >> 16) * v52 + (((unsigned __int16)v120 * v52) >> 16);
        }
        while (v286);
      }
      v121 = (v320 >> 16) * v50 + (((unsigned __int16)v320 * v50) >> 16);
      v122 = v121 + 0x1000000;
      v29 = v121 + 0x1000000 < 0;
      v123 = -16777216 - v121;
      if (!v29)
        v123 = v122;
      v124 = __clz(v123);
      v125 = v122 << (v124 - 1);
      v126 = 0x1FFFFFFF / (v125 >> 16);
      v127 = v126 * v315 + ((v126 * v314) >> 16);
      v128 = v316 - (((unint64_t)(v125 * (uint64_t)v127) >> 29) & 0xFFFFFFF8);
      v129 = v127 + (v128 >> 16) * v126 + (((unsigned __int16)v128 * v126) >> 16);
      v130 = v313 - v124;
      if ((v130 + 1) >= 0x20)
        v131 = 0;
      else
        v131 = v129 >> (v130 + 1);
      v132 = (int)0x80000000 >> ~(_BYTE)v130;
      if (v129 > v132)
        v132 = v129;
      if (v129 <= (int)(0x7FFFFFFFu >> ~(_BYTE)v130))
        v133 = v132;
      else
        v133 = 0x7FFFFFFFu >> ~(_BYTE)v130;
      v134 = v133 << ~(_BYTE)v130;
      if (v130 <= -2)
        v135 = v134;
      else
        v135 = v131;
      v136 = (v322 >> 16) * v50 + (((unsigned __int16)v322 * v50) >> 16);
      v137 = v136 + 0x1000000;
      v29 = v136 + 0x1000000 < 0;
      v138 = -16777216 - v136;
      if (!v29)
        v138 = v137;
      v139 = __clz(v138);
      v140 = v137 << (v139 - 1);
      v141 = 0x1FFFFFFF / (v140 >> 16);
      v142 = v141 * v315 + ((v141 * v314) >> 16);
      v143 = v316 - (((unint64_t)(v140 * (uint64_t)v142) >> 29) & 0xFFFFFFF8);
      v144 = v142 + (v143 >> 16) * v141 + (((unsigned __int16)v143 * v141) >> 16);
      v145 = v313 - v139;
      if ((v145 + 1) >= 0x20)
        v146 = 0;
      else
        v146 = v144 >> (v145 + 1);
      v147 = (int)0x80000000 >> ~(_BYTE)v145;
      if (v144 > v147)
        v147 = v144;
      if (v144 <= (int)(0x7FFFFFFFu >> ~(_BYTE)v145))
        v148 = v147;
      else
        v148 = 0x7FFFFFFFu >> ~(_BYTE)v145;
      v149 = v148 << ~(_BYTE)v145;
      if (v145 <= -2)
        v150 = v149;
      else
        v150 = v146;
      if ((int)v117 >= 1)
      {
        v151 = 0;
        v152 = 4 * v117;
        v153 = (__int16 *)(v299 + 32 * (v99 & 0xFFFFFFF));
        do
        {
          *(int *)((char *)&v320 + v151) = (__int16)*(int *)((char *)&v320 + v151) * (v135 >> 16)
                                         + (((__int16)*(int *)((char *)&v320 + v151) * (unsigned __int16)v135) >> 16)
                                         + (((*(int *)((char *)&v320 + v151) >> 15) + 1) >> 1) * v135;
          *(int *)((char *)&v322 + v151) = (__int16)*(int *)((char *)&v322 + v151) * (v150 >> 16)
                                         + (((__int16)*(int *)((char *)&v322 + v151) * (unsigned __int16)v150) >> 16)
                                         + (((*(int *)((char *)&v322 + v151) >> 15) + 1) >> 1) * v150;
          v151 += 4;
        }
        while (v152 != v151);
        v154 = 0;
        v155 = 0;
        v311 = v117 - 1;
        do
        {
          v156 = 0;
          v157 = -1;
          do
          {
            v158 = *(&v320 + v156);
            if (v158 < 0)
              v158 = -v158;
            v159 = *(&v322 + v156);
            if (v159 < 0)
              v159 = -v159;
            if (v158 <= v159)
              v158 = v159;
            if (v158 > (int)v157)
            {
              v154 = v156;
              v157 = v158;
            }
            ++v156;
          }
          while (v117 != v156);
          if (v157 < 0x3FFBE78)
            break;
          if ((int)v117 >= 2)
          {
            v160 = v320;
            v161 = v322;
            v162 = v309;
            v163 = v310;
            v164 = v311;
            do
            {
              v165 = *v162;
              v166 = v160 + (*v162 >> 16) * v50 + (((unsigned __int16)*v162 * v50) >> 16);
              v167 = *v163;
              *(v163 - 1) = v161 + (*v163 >> 16) * v50 + (((unsigned __int16)*v163 * v50) >> 16);
              ++v163;
              *(v162++ - 1) = v166;
              v161 = v167;
              v160 = v165;
              --v164;
            }
            while (v164);
          }
          v168 = 0;
          if (v135 >= 0)
            v169 = v135;
          else
            v169 = -v135;
          v170 = __clz(v169);
          v171 = v135 << (v170 - 1);
          v172 = 0x1FFFFFFF / (v171 >> 16);
          v173 = (__int16)v172 * (v171 >> 16) + (((__int16)v172 * (unsigned __int16)v171) >> 16);
          v174 = (v172 << 16)
               - 8 * v173 * (((v172 >> 15) + 1) >> 1)
               + ((-8 * v173) >> 16) * (__int16)v172
               + ((((-8 * v173) & 0xFFF8) * (__int16)v172) >> 16);
          v175 = v174 >> (30 - v170);
          v176 = v170 - 30;
          v177 = (int)0x80000000 >> v176;
          if (v174 > (int)0x80000000 >> v176)
            v177 = v174;
          if (v174 <= (int)(0x7FFFFFFFu >> v176))
            v178 = v177;
          else
            v178 = 0x7FFFFFFFu >> v176;
          v179 = v178 << v176;
          if (v169 > 3)
            v179 = v175;
          if (v150 >= 0)
            v180 = v150;
          else
            v180 = -v150;
          v181 = __clz(v180);
          v182 = v150 << (v181 - 1);
          v183 = 0x1FFFFFFF / (v182 >> 16);
          v184 = (__int16)v183 * (v182 >> 16) + (((__int16)v183 * (unsigned __int16)v182) >> 16);
          v185 = (v183 << 16)
               - 8 * v184 * (((v183 >> 15) + 1) >> 1)
               + ((-8 * v184) >> 16) * (__int16)v183
               + ((((-8 * v184) & 0xFFF8) * (__int16)v183) >> 16);
          v186 = v185 >> (30 - v181);
          v187 = v181 - 30;
          v188 = (int)0x80000000 >> v187;
          if (v185 > (int)0x80000000 >> v187)
            v188 = v185;
          if (v185 <= (int)(0x7FFFFFFFu >> v187))
            v189 = v188;
          else
            v189 = 0x7FFFFFFFu >> v187;
          v190 = v189 << v187;
          if (v180 > 3)
            v190 = v186;
          do
          {
            *(int *)((char *)&v320 + v168) = (__int16)*(int *)((char *)&v320 + v168) * (v179 >> 16)
                                           + (((__int16)*(int *)((char *)&v320 + v168) * (unsigned __int16)v179) >> 16)
                                           + (((*(int *)((char *)&v320 + v168) >> 15) + 1) >> 1) * v179;
            *(int *)((char *)&v322 + v168) = (__int16)*(int *)((char *)&v322 + v168) * (v190 >> 16)
                                           + (((__int16)*(int *)((char *)&v322 + v168) * (unsigned __int16)v190) >> 16)
                                           + (((*(int *)((char *)&v322 + v168) >> 15) + 1) >> 1) * v190;
            v168 += 4;
          }
          while (v152 != v168);
          LODWORD(v317) = v155;
          v191 = ((v157 - 67092087) >> 16) * ((6684672 * v155 + 53673984) >> 16)
               + (((unsigned __int16)(v157 + 16777) * ((6684672 * v155 + 53673984) >> 16)) >> 16);
          v192 = v157 + v157 * v154;
          v193 = __clz(v191);
          v194 = v191 << (v193 - 1);
          if (v192 >= 0)
            v195 = v192;
          else
            v195 = -v192;
          v196 = __clz(v195);
          v197 = v192 << (v196 - 1);
          v198 = 0x1FFFFFFF / (v197 >> 16);
          v199 = v198 * (v194 >> 16) + ((v198 * (unsigned __int16)v194) >> 16);
          v200 = v194 - (((unint64_t)(v199 * (uint64_t)v197) >> 29) & 0xFFFFFFF8);
          v201 = v199 + (v200 >> 16) * v198 + (((unsigned __int16)v200 * v198) >> 16);
          v202 = v193 - v196;
          if (v193 - v196 + 7 >= 0x20)
            v203 = 0;
          else
            v203 = v201 >> (v202 + 7);
          v204 = (int)0x80000000 >> (-7 - v202);
          if (v201 > v204)
            v204 = v201;
          if (v201 <= (int)(0x7FFFFFFFu >> (-7 - v202)))
            v205 = v204;
          else
            v205 = 0x7FFFFFFFu >> (-7 - v202);
          v206 = v205 << (-7 - v202);
          if (v202 > -8)
            v206 = v203;
          v207 = 64881 - v206;
          silk_bwexpander_32(&v320, v117, 64881 - v206);
          silk_bwexpander_32(&v322, v117, v207);
          if ((int)v117 >= 2)
          {
            v208 = v312;
            do
            {
              v209 = *(&v320 + v208);
              v210 = *(&v322 + v208);
              v286 = v208-- <= 1;
              *(&v320 + v208) += (v209 >> 16) * v52 + (((unsigned __int16)v209 * v52) >> 16);
              *(&v322 + v208) += (v210 >> 16) * v52 + (((unsigned __int16)v210 * v52) >> 16);
            }
            while (!v286);
          }
          v211 = (v320 >> 16) * v50 + (((unsigned __int16)v320 * v50) >> 16);
          v212 = v211 + 0x1000000;
          v29 = v211 + 0x1000000 < 0;
          v213 = -16777216 - v211;
          if (!v29)
            v213 = v212;
          v214 = __clz(v213);
          v215 = v212 << (v214 - 1);
          v216 = 0x1FFFFFFF / (v215 >> 16);
          v217 = v216 * v315 + ((v216 * v314) >> 16);
          v218 = v316 - (((unint64_t)(v215 * (uint64_t)v217) >> 29) & 0xFFFFFFF8);
          v219 = v217 + (v218 >> 16) * v216 + (((unsigned __int16)v218 * v216) >> 16);
          v220 = v313 - v214;
          if ((v220 + 1) >= 0x20)
            v221 = 0;
          else
            v221 = v219 >> (v220 + 1);
          v222 = (int)0x80000000 >> ~(_BYTE)v220;
          if (v219 > v222)
            v222 = v219;
          if (v219 <= (int)(0x7FFFFFFFu >> ~(_BYTE)v220))
            v223 = v222;
          else
            v223 = 0x7FFFFFFFu >> ~(_BYTE)v220;
          v224 = v223 << ~(_BYTE)v220;
          if (v220 <= -2)
            v135 = v224;
          else
            v135 = v221;
          v225 = (v322 >> 16) * v50 + (((unsigned __int16)v322 * v50) >> 16);
          v226 = v225 + 0x1000000;
          v29 = v225 + 0x1000000 < 0;
          v227 = -16777216 - v225;
          if (!v29)
            v227 = v226;
          v228 = __clz(v227);
          v229 = v226 << (v228 - 1);
          v230 = 0x1FFFFFFF / (v229 >> 16);
          v231 = v230 * v315 + ((v230 * v314) >> 16);
          v232 = v316 - (((unint64_t)(v229 * (uint64_t)v231) >> 29) & 0xFFFFFFF8);
          v233 = v231 + (v232 >> 16) * v230 + (((unsigned __int16)v232 * v230) >> 16);
          v234 = v313 - v228;
          if ((v234 + 1) >= 0x20)
            v235 = 0;
          else
            v235 = v233 >> (v234 + 1);
          v236 = (int)0x80000000 >> ~(_BYTE)v234;
          if (v233 > v236)
            v236 = v233;
          v237 = v233 <= (int)(0x7FFFFFFFu >> ~(_BYTE)v234) ? v236 : 0x7FFFFFFFu >> ~(_BYTE)v234;
          v238 = v237 << ~(_BYTE)v234;
          v150 = v234 <= -2 ? v238 : v235;
          v239 = &v322;
          v240 = &v320;
          v241 = v117;
          do
          {
            *v240 = (__int16)*v240 * (v135 >> 16)
                  + (((__int16)*v240 * (unsigned __int16)v135) >> 16)
                  + (((*v240 >> 15) + 1) >> 1) * v135;
            ++v240;
            *v239 = (__int16)*v239 * (v150 >> 16)
                  + (((__int16)*v239 * (unsigned __int16)v150) >> 16)
                  + (((*v239 >> 15) + 1) >> 1) * v150;
            ++v239;
            --v241;
          }
          while (v241);
          v155 = v317 + 1;
        }
        while ((_DWORD)v317 != 9);
        v8 = v304;
        v7 = v305;
        v242 = v304[1165];
        v99 = v308;
        if ((int)v242 >= 1)
        {
          v243 = &v320;
          v244 = &v322;
          do
          {
            v246 = *v244++;
            v245 = v246;
            v247 = ((v246 >> 10) + 1) >> 1;
            if (v246 < -67109888)
              LOWORD(v247) = 0x8000;
            if (v245 <= 67107839)
              v248 = v247;
            else
              v248 = 0x7FFF;
            *(v153 - 64) = v248;
            v250 = *v243++;
            v249 = v250;
            v251 = ((v250 >> 10) + 1) >> 1;
            if (v250 < -67109888)
              LOWORD(v251) = 0x8000;
            if (v249 <= 67107839)
              v252 = v251;
            else
              v252 = 0x7FFF;
            *v153++ = v252;
            --v242;
          }
          while (v242);
        }
      }
      v49 = v307 + 2 * v306;
      v47 = v99 + 1;
    }
    while (v47 < v8[1151]);
  }
  v253 = silk_log2lin(-10486 * (SHIDWORD(v296) >> 16) - ((10486 * WORD2(v296)) >> 16) + 2048);
  v254 = silk_log2lin(0x828u);
  LODWORD(v255) = v8[1151];
  if ((int)v255 >= 1)
  {
    v256 = 0;
    do
    {
      v257 = v254
           + *(_DWORD *)(v7 + 4 * v256) * (((v253 >> 15) + 1) >> 1)
           + (*(int *)(v7 + 4 * v256) >> 16) * (__int16)v253
           + (((unsigned __int16)*(_DWORD *)(v7 + 4 * v256) * (__int16)v253) >> 16);
      if (v257 < 0)
        v257 = 0x7FFFFFFF;
      *(_DWORD *)(v7 + 4 * v256++) = v257;
      v255 = v8[1151];
    }
    while (v256 < v255);
    if ((int)v255 >= 1)
    {
      v258 = 0;
      v259 = (((((410 * *(_DWORD *)(v7 + 484) + 3355443) >> 9) + 1) >> 1) + 0x10000) >> 16;
      v260 = (unsigned __int16)((((410 * *(_DWORD *)(v7 + 484) + 3355443) >> 9) + 1) >> 1);
      do
      {
        *(_DWORD *)(v7 + 412 + 4 * v258) = *(__int16 *)(v7 + 412 + 4 * v258) * v259
                                         + ((*(__int16 *)(v7 + 412 + 4 * v258) * v260) >> 16);
        ++v258;
      }
      while (v258 < v8[1151]);
      LODWORD(v255) = v8[1151];
    }
  }
  v261 = v8[1139];
  v262 = (((v8[1186] << 16 >> 14) & 0xFFFFFFC0 ^ 0xFFFE0000) + 0x40000) * v261;
  v263 = *v297;
  v264 = v8[1150];
  if (v263 == 2)
  {
    if ((int)v255 >= 1)
    {
      v265 = 0;
      v266 = (unsigned __int16)(v262 >> 8);
      v267 = (v262 >> 24) + 1;
      v268 = 3277 / v264;
      do
      {
        v269 = v7 + 4 * v265;
        *(_DWORD *)(v269 + 396) = (unsigned __int16)(49152 / *(_DWORD *)(v269 + 124) + v268 - 0x4000)
                                - (((__int16)(49152 / *(_DWORD *)(v269 + 124) + v268) * v266
                                  + (((49152 / *(_DWORD *)(v269 + 124) + v268) * v267) << 16)) & 0xFFFF0000)
                                + 0x40000000;
        ++v265;
      }
      while (v265 < v8[1151]);
      v261 = v8[1139];
    }
    v270 = -16384 - ((49152 * ((5832704 * v261 + 39322 * (__int16)v261) >> 16)) >> 16);
  }
  else
  {
    v271 = (unsigned __int16)(21299 / v264 - 0x4000)
         - ((((39322 * (21299 / v264)) >> 16) * (unsigned __int16)(v262 >> 8)
           + ((21299 / v264 + ((39322 * (21299 / v264)) >> 16) * (v262 >> 24)) << 16)) & 0xFFFF0000)
         + 0x40000000;
    *(_DWORD *)(v7 + 396) = v271;
    if (v8[1151] >= 2)
    {
      v272 = 100;
      do
      {
        *(_DWORD *)(v7 + 4 * v272) = v271;
        v273 = v272 - 98;
        ++v272;
      }
      while (v273 < v8[1151]);
    }
    v270 = -16384;
  }
  v274 = (int32x2_t *)(v8 + 1807);
  v275 = *(_DWORD *)(v7 + 484);
  v276 = v8[2449];
  v277 = (((0x20000 - 8 * v275) >> 16) * (__int16)v276 + ((((0x20000 - 8 * v275) & 0xFFF8) * (__int16)v276) >> 16)) >> 16;
  v278 = (6554
        * (unsigned __int16)(((0x20000 - 8 * v275) >> 16) * v276
                                         + ((((0x20000 - 8 * v275) & 0xFFF8u) * (__int16)v276) >> 16))) >> 16;
  v279 = *(_DWORD *)(v7 + 480);
  result = 0x10000;
  if (v263 == 2)
  {
    v281 = 0x10000
         - ((__int16)v279 * ((0x40000 - 16 * v275) >> 16)
          + (((__int16)v279 * ((0x40000 - 16 * v275) & 0xFFF0)) >> 16));
    v282 = 2 * (13107 * (v281 >> 16) + ((13107 * (unsigned __int16)v281) >> 16)) + 39322;
    v283 = v276 << 15;
    v284 = __clz(v283);
    if ((v284 & 1) != 0)
      v285 = 0x8000;
    else
      v285 = 46214;
    result = ((int)(((213 * ((v283 >> (24 - v284)) & 0x7F)) | 0x10000)
                                * (v285 >> (v284 >> 1))) >> 16);
    v286 = v283 < 1;
    if (v283 >= 1)
      v287 = (v282 >> 16) * result;
    else
      v287 = 0;
    if (v286)
      v288 = 0;
    else
      v288 = result;
    v289 = v287 + ((v288 * (v282 & 0xFFFE)) >> 16);
  }
  else
  {
    v289 = 0;
  }
  v290 = 0;
  v291 = 6554 * (v277 + ((0x10000 - 4 * v279) >> 16));
  v292 = vdup_n_s32(0x6666u);
  do
  {
    v293.i32[0] = v278 + ((6554 * (unsigned __int16)(-4 * v279)) >> 16) - *(_QWORD *)v274 + v291;
    v293.i32[1] = v289 - HIDWORD(*(unint64_t *)v274);
    v294 = vsra_n_u32((uint32x2_t)vmla_s32(*v274, vshr_n_s32(v293, 0x10uLL), v292), (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v293, (int8x8_t)0xFFFF0000FFFFLL), v292), 0x10uLL);
    v8[1809] += 26214 * ((v270 - v8[1809]) >> 16) + ((26214 * (unsigned __int16)(v270 - v8[1809])) >> 16);
    *v274 = (int32x2_t)v294;
    v295 = (_DWORD *)(v7 + v290);
    v295[107] = ((v294.i32[0] >> 1) + 1) >> 1;
    v295[115] = ((v8[1808] >> 1) + 1) >> 1;
    v295[111] = ((v8[1809] >> 1) + 1) >> 1;
    v290 += 4;
  }
  while (v290 != 16);
  return result;
}

unint64_t silk_corrVector_FIX(unint64_t result, __int16 *a2, int a3, int a4, _DWORD *a5, int a6)
{
  _DWORD *v6;
  unint64_t v9;
  uint64_t i;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v6 = a5;
  v9 = result + 2 * (a4 - 1);
  if (a6 <= 0)
  {
    if (a4 >= 1)
    {
      v13 = a4;
      do
      {
        result = silk_inner_prod_aligned(v9, a2, a3);
        *v6++ = result;
        v9 -= 2;
        --v13;
      }
      while (v13);
    }
  }
  else if (a4 >= 1)
  {
    for (i = 0; i != a4; ++i)
    {
      if (a3 < 1)
      {
        v12 = 0;
      }
      else
      {
        v11 = 0;
        v12 = 0;
        do
        {
          v12 += (a2[v11] * *(__int16 *)(v9 + v11 * 2)) >> a6;
          ++v11;
        }
        while (a3 != v11);
      }
      a5[i] = v12;
      v9 -= 2;
    }
  }
  return result;
}

unint64_t silk_corrMatrix_FIX(uint64_t a1, int a2, unsigned int a3, int a4, int *a5, int *a6)
{
  uint64_t v12;
  unint64_t result;
  unsigned int v14;
  BOOL v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v23;
  signed int v24;
  unint64_t v25;
  uint64_t v26;
  __int16 *v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  __int16 *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _DWORD *v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  _DWORD *v50;
  int v51;
  uint64_t v52;
  int *v53;
  int v54;
  unsigned int v55;
  _DWORD *v56;
  uint64_t v57;

  v57 = 0;
  v12 = a3 - 1;
  result = (unint64_t)silk_sum_sqr_shift((unsigned int *)&v57, (int *)&v57 + 1, a1, (int)v12 + a2);
  v14 = __clz(v57);
  v15 = __OFSUB__(a4, v14);
  v16 = a4 - v14;
  if ((v16 < 0) ^ v15 | (v16 == 0))
    v17 = 0;
  else
    v17 = v16;
  v18 = (int)v57 >> v17;
  v19 = v17 + HIDWORD(v57);
  HIDWORD(v57) += v17;
  if ((int)a3 >= 2)
  {
    v20 = v12;
    v21 = (__int16 *)a1;
    do
    {
      v22 = *v21++;
      v18 -= (v22 * v22) >> v19;
      --v20;
    }
    while (v20);
  }
  v23 = *a6;
  if (*a6 > v19)
  {
    v18 >>= *a6 - v19;
    HIDWORD(v57) = *a6;
    v19 = v23;
  }
  *a5 = v18;
  v24 = a3 - 2;
  if ((int)a3 >= 2)
  {
    v25 = a1 + 2 * (int)v12;
    v26 = a2;
    v27 = (__int16 *)(v25 - 2);
    v28 = a3 - 1;
    v29 = a3 + 1;
    do
    {
      v18 = ((*v27 * *v27) >> v19) + v18 - ((v27[a2] * v27[a2]) >> v19);
      a5[v29] = v18;
      --v27;
      v29 += a3 + 1;
      --v28;
    }
    while (v28);
    LODWORD(v57) = v18;
    v30 = v24;
    v31 = (__int16 *)(a1 + 2 * v24);
    if (v19 <= 0)
    {
      v54 = a2;
      v53 = a6;
      v42 = 2 * a3;
      v43 = (uint64_t)&a5[a3 + 2];
      v44 = a1 + 2 * (int)v12 - 2;
      v45 = 2 * v26 + 2 * v24 + a1 - 2;
      v46 = 1;
      v47 = v12;
      v48 = v44 + 2 * v26;
      do
      {
        v55 = v47;
        v56 = (_DWORD *)v43;
        result = silk_inner_prod_aligned(v25, v31, v54);
        LODWORD(v57) = result;
        a5[v46 * a3] = result;
        a5[v46] = result;
        if (v46 < a3 - 1)
        {
          v49 = 0;
          v50 = v56;
          v51 = v42;
          v52 = 1;
          do
          {
            result = (result
                                  - *(__int16 *)(v45 + v49) * *(__int16 *)(v48 + v49)
                                  + v31[v49 / 2 - 1] * *(__int16 *)(v44 + v49));
            a5[v52 + v51] = result;
            *v50 = result;
            ++v52;
            v51 += a3;
            v50 += a3 + 1;
            v49 -= 2;
          }
          while (2 * v55 - 2 + v49);
          LODWORD(v57) = result;
        }
        --v31;
        ++v46;
        v47 = v55 - 1;
        v42 += a3;
        v43 = (uint64_t)(v56 + 1);
        v45 -= 2;
      }
      while (v46 != a3);
      v19 = HIDWORD(v57);
      a6 = v53;
    }
    else
    {
      v32 = 2 * a3;
      v33 = (uint64_t)&a5[a3 + 2];
      v34 = a1 + 2 * (int)v12 - 2;
      v35 = 2 * a2 + 2 * v30 + a1 - 2;
      v36 = 1;
      do
      {
        if (a2 < 1)
        {
          v38 = 0;
        }
        else
        {
          v37 = 0;
          v38 = 0;
          do
          {
            v38 += (v31[v37] * *(__int16 *)(v25 + v37 * 2)) >> v19;
            ++v37;
          }
          while (a2 != v37);
        }
        result = v36 * a3;
        a5[result] = v38;
        a5[v36] = v38;
        if (v36 < a3 - 1)
        {
          result = 0;
          v39 = (_DWORD *)v33;
          v40 = v32;
          v41 = 1;
          do
          {
            v38 = ((*(__int16 *)((char *)v31 + result - 2) * *(__int16 *)(v34 + result)) >> v19)
                + v38
                - ((*(__int16 *)(v35 + result) * *(__int16 *)(v34 + 2 * a2 + result)) >> v19);
            a5[v41 + v40] = v38;
            *v39 = v38;
            ++v41;
            v40 += a3;
            v39 += a3 + 1;
            result -= 2;
          }
          while (2 * v12 - 2 + result);
        }
        --v31;
        ++v36;
        LODWORD(v12) = v12 - 1;
        v32 += a3;
        v33 += 4;
        v35 -= 2;
      }
      while (v36 != a3);
    }
  }
  *a6 = v19;
  return result;
}

uint64_t silk_schur64(char *a1, const float *a2, int a3)
{
  uint64_t v3;
  float32x2_t *v4;
  float32x2_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  signed int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  int v30;
  int v32;
  _BYTE v33[4];
  int v34;
  _QWORD v35[17];

  v35[16] = *MEMORY[0x24BDAC8D0];
  if (*(int *)a2 < 1)
  {
    bzero(a1, 4 * a3);
    return 0;
  }
  else
  {
    if (a3 < 0)
      goto LABEL_26;
    v3 = (a3 + 1);
    v4 = (float32x2_t *)v33;
    do
    {
      v5 = vld1_dup_f32(a2++);
      *v4++ = v5;
      --v3;
    }
    while (v3);
    if (a3 < 1)
    {
LABEL_26:
      LODWORD(v7) = 0;
    }
    else
    {
      v6 = 0;
      v7 = 0;
      v8 = a3;
      while (1)
      {
        v9 = v7++;
        v10 = *(_DWORD *)&v33[8 * v7];
        v11 = v10 >= 0 ? *(_DWORD *)&v33[8 * v7] : -v10;
        if (v11 >= v34)
          break;
        v12 = __clz(v11);
        v13 = -v10 << (v12 - 1);
        if (v34 >= 0)
          v14 = v34;
        else
          v14 = -v34;
        v15 = __clz(v14);
        v16 = v34 << (v15 - 1);
        v17 = 0x1FFFFFFF / (v16 >> 16);
        v18 = v17 * (v13 >> 16) + ((v17 * (unsigned __int16)v13) >> 16);
        v19 = v13 - (((unint64_t)(v18 * (uint64_t)v16) >> 29) & 0xFFFFFFF8);
        v20 = v18 + (v19 >> 16) * v17 + (((unsigned __int16)v19 * v17) >> 16);
        v21 = v12 - v15;
        v22 = v20 >> (v12 - v15 - 2);
        v23 = (int)0x80000000 >> (2 - v21);
        if (v20 > v23)
          v23 = v20;
        if (v20 <= (int)(0x7FFFFFFFu >> (2 - v21)))
          v24 = v23;
        else
          v24 = 0x7FFFFFFFu >> (2 - v21);
        v25 = v24 << (2 - v21);
        if (v21 > 1)
          v25 = v22;
        *(_DWORD *)&a1[4 * v9] = ((v25 >> 14) + 1) >> 1;
        if ((int)v9 < a3)
        {
          v26 = v25;
          v27 = v8;
          v28 = v35;
          do
          {
            v29 = v28[v6];
            v30 = *((_DWORD *)v28 - 1);
            LODWORD(v28[v6]) = v29 + ((unint64_t)(v26 * (uint64_t)(2 * v30)) >> 32);
            *((_DWORD *)v28++ - 1) = v30 + ((unint64_t)(v26 * (uint64_t)(2 * v29)) >> 32);
            --v27;
          }
          while (v27);
        }
        --v8;
        ++v6;
        if (v7 == a3)
          goto LABEL_34;
      }
      if (v10 > 0)
        v32 = -64881;
      else
        v32 = 64881;
      *(_DWORD *)&a1[4 * v9] = v32;
    }
    if ((int)v7 < a3)
      bzero(&a1[4 * v7], 4 * (~(_DWORD)v7 + a3) + 4);
LABEL_34:
    if (v34 <= 1)
      return 1;
    else
      return v34;
  }
}

uint64_t silk_LTP_scale_ctrl_FIX(uint64_t result, uint64_t a2, int a3)
{
  unsigned int v3;
  signed int v4;

  if (a3)
  {
    LOBYTE(v3) = 0;
  }
  else
  {
    v4 = 51 * (((__int16)(*(_DWORD *)(result + 5792) + *(_DWORD *)(result + 4640)) * *(__int16 *)(a2 + 496)) >> 16)
       + ((51
         * (unsigned __int16)((*(_DWORD *)(result + 5792) + *(_DWORD *)(result + 4640))
                                          * *(_WORD *)(a2 + 496))) >> 16);
    v3 = v4 & ~(v4 >> 31);
    if (v3 >= 2)
      LOBYTE(v3) = 2;
  }
  *(_BYTE *)(result + 4817) = v3;
  *(_DWORD *)(a2 + 120) = silk_LTPScales_table_Q14[v3];
  return result;
}

void silk_burg_modified(_DWORD *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  __int16 *v17;
  __int128 *v18;
  uint64_t v19;
  __int16 *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  __int16 *v32;
  __int16 *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int *v39;
  __int128 *v40;
  uint64_t v41;
  int v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  __int16 *v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  __int16 *v59;
  __int16 *v60;
  uint64_t v61;
  __int16 *v62;
  int v63;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  __int16 *v72;
  int v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;
  __int16 *v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  __int16 *v82;
  __int16 *v83;
  uint64_t v84;
  __int16 *v85;
  int v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  int v91;
  int v92;
  __int16 *v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  int v98;
  int v99;
  __int16 *v100;
  uint64_t v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  int v113;
  unsigned int v114;
  int v115;
  uint64_t v116;
  char v117;
  uint64_t v118;
  signed int v119;
  int v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  uint64_t v130;
  char v131;
  unsigned int v132;
  unsigned int v133;
  int v134;
  unint64_t v135;
  int v136;
  unsigned int v137;
  unsigned int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  unsigned int v147;
  int v148;
  unsigned int v149;
  signed int v150;
  unsigned int v151;
  char v152;
  unsigned int v153;
  unsigned int v154;
  unint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  uint64_t v159;
  int *v160;
  uint64_t v161;
  int v162;
  int v163;
  int *v164;
  int v165;
  int *v166;
  _DWORD *v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  unint64_t v173;
  int v174;
  _DWORD *v175;
  _DWORD *v176;
  int *v177;
  _DWORD *v178;
  uint64_t v179;
  int v180;
  int v181;
  int v182;
  uint64_t v183;
  int v184;
  unint64_t v185;
  int v186;
  _DWORD *v188;
  _DWORD *v189;
  unsigned int v190;
  uint64_t v191;
  int v192;
  uint64_t v195;
  int *v196;
  uint64_t v197;
  int v198;
  int v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  char v203;
  int v204;
  char v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v209;
  uint64_t v210;
  _DWORD v211[16];
  _DWORD v212[17];
  int v213;
  int v214;
  _BYTE v215[64];
  int v216[16];
  _OWORD v217[3];
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  uint64_t v223;

  v223 = *MEMORY[0x24BDAC8D0];
  v210 = 0;
  silk_sum_sqr_shift((unsigned int *)&v210, (int *)&v210 + 1, a4, a7 * a6);
  if (SHIDWORD(v210) < 8)
  {
    v13 = 3 - __clz(v210);
    v14 = -16 - HIDWORD(v210);
    if (v13 > -16 - HIDWORD(v210))
      v14 = v13;
    if (v13 >= 7 - HIDWORD(v210))
      v13 = 7 - HIDWORD(v210);
    v15 = (int)v210 >> v13;
    if (!(v210 >> 29))
    {
      v15 = (_DWORD)v210 << -(char)v14;
      v13 = v14;
    }
    LODWORD(v210) = v15;
    v12 = v13 + HIDWORD(v210);
  }
  else
  {
    LODWORD(v210) = (_DWORD)v210 << (BYTE4(v210) - 7);
    v12 = 7;
  }
  v188 = a1;
  v189 = a2;
  HIDWORD(v210) = v12;
  v219 = 0u;
  v220 = 0u;
  v221 = 0u;
  v222 = 0u;
  v199 = a8;
  if (v12 <= 0)
  {
    if (a7 >= 1)
    {
      v23 = 0;
      v24 = a6 - a8;
      v25 = (a8 + 1);
      v26 = a4;
      do
      {
        celt_pitch_xcorr_c((__int16 *)(a4 + 2 * v23 * a6), a4 + 2 * v23 * a6 + 2, (uint64_t)v211, a6 - a8, a8);
        if (a8 >= 1)
        {
          v27 = -1;
          v28 = a8 - 1;
          v29 = 1;
          v30 = v24 + 1;
          do
          {
            if (v24 + (int)v29 >= a6)
            {
              v31 = 0;
            }
            else
            {
              v31 = 0;
              v32 = (__int16 *)(v26 + 2 * (v27 + v30));
              v33 = (__int16 *)(v26 + 2 * v30);
              v34 = v28;
              do
              {
                v36 = *v33++;
                v35 = v36;
                v37 = *v32++;
                v31 += v37 * v35;
                --v34;
              }
              while (v34);
            }
            v211[v29++ - 1] += v31;
            ++v30;
            --v27;
            --v28;
          }
          while (v29 != v25);
          v38 = -HIDWORD(v210);
          v39 = v211;
          v40 = &v219;
          v41 = v25 - 1;
          do
          {
            v42 = *v39++;
            *(_DWORD *)v40 += v42 << v38;
            v40 = (__int128 *)((char *)v40 + 4);
            --v41;
          }
          while (v41);
        }
        ++v23;
        v26 += 2 * a6;
      }
      while (v23 != a7);
    }
  }
  else if (a7 >= 1)
  {
    v16 = 0;
    v17 = (__int16 *)(a4 + 2);
    v206 = (a8 + 1) - 1;
    do
    {
      if (a8 >= 1)
      {
        v18 = &v219;
        v19 = v206;
        v20 = v17;
        v21 = a6 - 1;
        do
        {
          v22 = silk_inner_prod16_aligned_64((__int16 *)(a4 + 2 * v16 * a6), v20, v21);
          *(_DWORD *)v18 += v22 >> SBYTE4(v210);
          v18 = (__int128 *)((char *)v18 + 4);
          --v21;
          ++v20;
          --v19;
        }
        while (v19);
      }
      ++v16;
      v17 += a6;
      a8 = v199;
    }
    while (v16 != a7);
  }
  v217[0] = v219;
  v217[1] = v220;
  v217[2] = v221;
  v218 = v222;
  v43 = (unint64_t)(42950 * (int)v210) >> 32;
  v44 = ((unint64_t)(0x10000A7C6 * (int)v210) >> 32) + 1;
  v214 = v44;
  v212[0] = v44;
  if (a8 >= 1)
  {
    v185 = (unint64_t)(42950 * (int)v210) >> 32;
    v186 = v210;
    v45 = 0;
    v46 = HIDWORD(v210);
    v204 = -HIDWORD(v210);
    v47 = ~BYTE4(v210);
    v203 = 16 - BYTE4(v210);
    v205 = 7 - BYTE4(v210);
    if (a5 >= 0)
      v48 = a5;
    else
      v48 = -a5;
    v190 = __clz(v48);
    v49 = a6;
    v50 = 2 * a6;
    v51 = (__int16 *)a4;
    v201 = a4 - 2;
    v202 = a4 + v50;
    v52 = &v213;
    v53 = -4;
    v200 = a4;
    v54 = 1;
    v55 = 2;
    v56 = 0x40000000;
    v57 = a7;
    v207 = v49;
    v209 = (v49 << 32) - 0x100000000;
    v191 = a8;
    v192 = HIDWORD(v210);
    while (1)
    {
      v198 = v56;
      v195 = v55;
      v196 = v52;
      v197 = v53;
      if (v46 <= -2)
      {
        if (a7 >= 1)
        {
          v81 = 0;
          v82 = (__int16 *)v200;
          v83 = (__int16 *)v201;
          v84 = v202;
          do
          {
            v85 = &v51[v81 * v207];
            v86 = v85[v45];
            v87 = v85[~v45 + v207];
            v88 = v86 << 17;
            v89 = v87 << 17;
            if (v45)
            {
              v90 = 0;
              v91 = v86 << v204;
              v92 = v87 << v204;
              v93 = v83;
              do
              {
                v94 = *v93--;
                *((_DWORD *)&v219 + v90) -= v91 * v94;
                v95 = *(__int16 *)(v84 + 2 * v90);
                *((_DWORD *)v217 + v90) -= v92 * v95;
                v96 = ((v216[v90] >> 7) + 1) >> 1;
                v88 += v96 * v94;
                v89 += v96 * v95;
                ++v90;
              }
              while (v45 != v90);
            }
            v97 = 0;
            v98 = -v88;
            v99 = -v89;
            v100 = v82;
            v101 = v209;
            do
            {
              v102 = *v100--;
              *(_DWORD *)&v215[4 * v97 - 4] += (__int16)(v102 << v47) * (v98 >> 16)
                                             + (((__int16)(v102 << v47) * (unsigned __int16)v98) >> 16)
                                             + (((v102 << v47 >> 15) + 1) >> 1) * v98;
              v103 = *(__int16 *)((char *)v85 + (v101 >> 31)) << v47;
              v212[v97++] += (__int16)v103 * (v99 >> 16)
                           + (((__int16)v103 * (unsigned __int16)v99) >> 16)
                           + (((v103 >> 15) + 1) >> 1) * v99;
              v101 += 0x100000000;
            }
            while (v54 != v97);
            ++v81;
            v84 += v50;
            v83 = (__int16 *)((char *)v83 + v50);
            v82 = (__int16 *)((char *)v82 + v50);
            v57 = a7;
            v51 = (__int16 *)a4;
          }
          while (v81 != a7);
        }
      }
      else if (a7 >= 1)
      {
        v58 = 0;
        v60 = (__int16 *)v200;
        v59 = (__int16 *)v201;
        v61 = v202;
        do
        {
          v62 = &v51[v58 * v207];
          v63 = v62[v45];
          v64 = v62[~v45 + v207];
          v65 = v63 << 9;
          v66 = v64 << 9;
          if (v45)
          {
            v67 = 0;
            v68 = -(v64 << v203);
            v69 = -(v63 << v203);
            v70 = v69 >> 16;
            v71 = (unsigned __int16)v69;
            v72 = v59;
            do
            {
              v73 = *v72--;
              *((_DWORD *)&v219 + v67) += v70 * v73 + ((v71 * v73) >> 16);
              v74 = *(__int16 *)(v61 + 2 * v67);
              *((_DWORD *)v217 + v67) += (v68 >> 16) * v74 + (((unsigned __int16)v68 * v74) >> 16);
              v75 = v216[v67] >> 16;
              v76 = (unsigned __int16)v216[v67];
              v65 += v75 * v73 + ((v76 * v73) >> 16);
              v66 += v75 * v74 + ((v76 * v74) >> 16);
              ++v67;
            }
            while (v45 != v67);
          }
          v77 = 0;
          v78 = v60;
          v79 = v209;
          do
          {
            v80 = *v78--;
            *(_DWORD *)&v215[4 * v77 - 4] += (-v65 << v205 >> 16) * v80
                                           + (((unsigned __int16)(-v65 << v205) * v80) >> 16);
            v212[v77++] += (-v66 << v205 >> 16) * *(__int16 *)((char *)v62 + (v79 >> 31))
                         + (((unsigned __int16)(-v66 << v205) * *(__int16 *)((char *)v62 + (v79 >> 31))) >> 16);
            v79 += 0x100000000;
          }
          while (v54 != v77);
          ++v58;
          v61 += v50;
          v59 = (__int16 *)((char *)v59 + v50);
          v60 = (__int16 *)((char *)v60 + v50);
          v57 = a7;
          v51 = (__int16 *)a4;
        }
        while (v58 != a7);
      }
      v104 = *((_DWORD *)&v219 + v45);
      v105 = *((_DWORD *)v217 + v45);
      v106 = v214 + v212[0];
      v107 = 0;
      if (v45)
      {
        v108 = 4;
        v109 = v45;
        v111 = v198;
        v110 = v199;
        v112 = a5;
        do
        {
          v113 = *(_DWORD *)&v215[v108 + 60];
          if (v113 >= 0)
            v114 = *(_DWORD *)&v215[v108 + 60];
          else
            v114 = -v113;
          v115 = __clz(v114);
          if (v115 >= 8)
            LOBYTE(v115) = 8;
          v116 = v113 << (v115 - 1);
          v117 = 8 - v115;
          v104 += (unint64_t)(v216[v109 + 15] * v116) >> 32 << v117;
          v105 += (unint64_t)(*((int *)&v218 + v109 + 3) * v116) >> 32 << v117;
          v107 += (unint64_t)((int)v212[v109] * v116) >> 32 << v117;
          v106 += (unint64_t)((*(_DWORD *)&v215[v108 - 4] + (uint64_t)(int)v212[v108 / 4]) * v116) >> 32 << v117;
          v108 += 4;
          --v109;
        }
        while (v109);
      }
      else
      {
        v111 = v198;
        v110 = v199;
        v112 = a5;
      }
      v118 = v45 + 1;
      *(_DWORD *)&v215[4 * v45] = v104;
      v212[v45 + 1] = v105;
      v119 = 2 * (v105 + v107);
      v120 = -2 * (v105 + v107);
      if (v120 >= 0)
        v119 = -2 * (v105 + v107);
      if (v119 >= v106)
      {
        v134 = v120 > 0 ? 0x7FFFFFFF : 0x80000000;
        v130 = v197;
      }
      else
      {
        v121 = __clz(v119);
        v122 = v106 >= 0 ? v106 : -v106;
        v123 = __clz(v122);
        v124 = v106 << (v123 - 1);
        v125 = 0x1FFFFFFF / (v124 >> 16);
        v126 = v125 * (v120 << (v121 - 1) >> 16) + ((v125 * ((v120 << (v121 - 1)) & 0xFFFE)) >> 16);
        v127 = (v120 << (v121 - 1)) - (((unint64_t)(v126 * (uint64_t)v124) >> 29) & 0xFFFFFFF8);
        v128 = v126 + (v127 >> 16) * v125 + (((v127 & 0xFFFE) * v125) >> 16);
        v129 = v121 - v123;
        v130 = v197;
        if (v129 > 1)
        {
          v134 = v128 >> (v129 - 2);
        }
        else
        {
          v131 = 2 - v129;
          v132 = (int)0x80000000 >> v131;
          if (v128 > (int)0x80000000 >> v131)
            v132 = v128;
          v133 = v128 <= (int)(0x7FFFFFFFu >> v131) ? v132 : 0x7FFFFFFFu >> v131;
          v134 = v133 << v131;
        }
      }
      v135 = ((unint64_t)((int)((0x4000000000000000 - ((v134 * (uint64_t)v134) & 0x7FFFFFFF00000000uLL)) >> 32)
                               * (uint64_t)v111) >> 30) & 0xFFFFFFFC;
      v136 = v135;
      if ((int)v135 <= v112)
      {
        if (v111 >= 0)
          v137 = v111;
        else
          v137 = -v111;
        v138 = __clz(v137);
        v139 = v111 << (v138 - 1);
        v140 = 0x1FFFFFFF / (v139 >> 16);
        v141 = v140 * (a5 << (v190 - 1) >> 16) + ((v140 * (unsigned __int16)(a5 << (v190 - 1))) >> 16);
        v142 = (a5 << (v190 - 1)) - (((unint64_t)(v141 * (uint64_t)v139) >> 29) & 0xFFFFFFF8);
        v143 = v141 + (v142 >> 16) * v140 + (((unsigned __int16)v142 * v140) >> 16);
        v144 = v190 - v138;
        v145 = v143 >> (v144 - 1);
        v146 = (int)0x80000000 >> (1 - v144);
        if (v143 > v146)
          v146 = v143;
        if (v143 <= (int)(0x7FFFFFFFu >> (1 - v144)))
          v147 = v146;
        else
          v147 = 0x7FFFFFFFu >> (1 - v144);
        v148 = v147 << (1 - v144);
        if (v144 > 0)
          v148 = v145;
        v149 = 0x40000000 - v148;
        if (v148 <= 0x3FFFFFFF)
        {
          v151 = __clz(v149);
          v152 = v149;
          if (v151 != 24)
          {
            if (v149 <= 0x7F)
              v152 = (v149 >> (56 - v151)) | ((_BYTE)v149 << (v151 - 24));
            else
              v152 = ((_BYTE)v149 << (v151 + 8)) | (v149 >> (24 - v151));
          }
          if ((v151 & 1) != 0)
            v153 = 0x8000;
          else
            v153 = 46214;
          v150 = (v153 >> (v151 >> 1)) + ((213 * (v153 >> (v151 >> 1)) * (v152 & 0x7F)) >> 16);
        }
        else
        {
          v150 = 0;
        }
        v154 = (((int)v149 / v150 + v150) << 15) & 0xFFFF0000;
        if (v120 >= 0)
          v134 = v154;
        else
          v134 = -v154;
        v136 = v112;
      }
      if (v45)
      {
        v155 = 0;
        v156 = v130;
        do
        {
          v157 = v216[v155];
          v158 = *(int *)((char *)v216 + v156);
          v216[v155] = (((unint64_t)(v158 * (uint64_t)v134) >> 31) & 0xFFFFFFFE) + v157;
          *(int *)((char *)v216 + v156) = (((unint64_t)(v157 * (uint64_t)v134) >> 31) & 0xFFFFFFFE) + v158;
          ++v155;
          v156 -= 4;
        }
        while (v155 < v118 >> 1);
      }
      v216[v45] = v134 >> 6;
      if ((int)v135 <= v112)
        break;
      v159 = 0;
      v160 = v196;
      v161 = v191;
      do
      {
        v162 = *(_DWORD *)&v215[4 * v159 - 4];
        v163 = *v160;
        *(_DWORD *)&v215[4 * v159 - 4] = (((unint64_t)(*v160 * (uint64_t)v134) >> 31) & 0xFFFFFFFE) + v162;
        *v160-- = (((unint64_t)(v162 * (uint64_t)v134) >> 31) & 0xFFFFFFFE) + v163;
        ++v159;
      }
      while (v195 != v159);
      ++v54;
      v55 = v195 + 1;
      v201 += 2;
      v202 -= 2;
      v209 -= 0x100000000;
      v200 += 2;
      v53 = v130 + 4;
      v52 = v196 + 1;
      v45 = v118;
      v56 = v136;
      v46 = v192;
      if (v118 == v191)
      {
        v44 = v214;
        v164 = (int *)v215;
        v165 = 0x10000;
        v166 = v216;
        v167 = a3;
        LODWORD(v43) = v185;
        do
        {
          v168 = *v166++;
          v169 = (v168 >> 8) + 1;
          v170 = *v164++;
          v171 = (__int16)(v169 >> 1);
          v172 = ((v169 >> 16) + 1) >> 1;
          v44 += v171 * (v170 >> 16) + v172 * v170 + ((v171 * (unsigned __int16)v170) >> 16);
          v165 += v171 * (v169 >> 17) + v172 * (v169 >> 1) + ((v171 * (unsigned __int16)(v169 >> 1)) >> 16);
          *v167++ = -(v169 >> 1);
          --v161;
        }
        while (v161);
        goto LABEL_118;
      }
    }
    if ((int)v118 < v110)
      bzero(&v216[v45 + 1], 4 * (v110 - v45 - 2) + 4);
    v177 = v216;
    v176 = v188;
    v175 = v189;
    v178 = a3;
    v179 = v191;
    do
    {
      v180 = *v177++;
      *v178++ = -(((v180 >> 8) + 1) >> 1);
      --v179;
    }
    while (v179);
    v174 = v192;
    if (v192 <= 0)
    {
      v181 = v186;
      if (a7 >= 1)
      {
        v182 = v136;
        do
        {
          v184 = silk_inner_prod_aligned((unint64_t)v51, v51, v110);
          v174 = HIDWORD(v210);
          v181 = v210 - (v184 << -BYTE4(v210));
          LODWORD(v210) = v181;
          v51 += v207;
          --v57;
        }
        while (v57);
        goto LABEL_131;
      }
    }
    else
    {
      v181 = v186;
      if (a7 >= 1)
      {
        v182 = v136;
        do
        {
          v183 = silk_inner_prod16_aligned_64(v51, v51, v110);
          v174 = HIDWORD(v210);
          v181 = v210 - (v183 >> SBYTE4(v210));
          LODWORD(v210) = v181;
          v51 += v207;
          --v57;
        }
        while (v57);
LABEL_131:
        v136 = v182;
      }
    }
    v173 = ((unint64_t)(v181 * (uint64_t)v136) >> 30) & 0xFFFFFFFC;
    goto LABEL_133;
  }
  v165 = 0x10000;
LABEL_118:
  LODWORD(v173) = v44
                + (__int16)-(__int16)v165 * ((int)v43 >> 16)
                + (((__int16)-(__int16)v165 * (unsigned __int16)v43) >> 16)
                + (((-v165 >> 15) + 1) >> 1) * v43;
  v174 = HIDWORD(v210);
  v176 = v188;
  v175 = v189;
LABEL_133:
  *v176 = v173;
  *v175 = -v174;
}

_WORD *silk_scale_copy_vector16(_WORD *result, __int16 *a2, int a3, int a4)
{
  uint64_t v4;
  int v5;

  if (a4 >= 1)
  {
    v4 = a4;
    do
    {
      v5 = *a2++;
      *result++ = HIWORD(a3) * v5 + (((unsigned __int16)a3 * v5) >> 16);
      --v4;
    }
    while (v4);
  }
  return result;
}

int *silk_scale_vector32_Q26_lshift_18(int *result, int a2, int a3)
{
  uint64_t v3;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      *result = (unint64_t)(*result * (uint64_t)a2) >> 8;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

unint64_t silk_inner_prod_aligned(unint64_t result, __int16 *a2, int a3)
{
  __int16 *v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;

  if (a3 < 1)
    return 0;
  v3 = (__int16 *)result;
  LODWORD(result) = 0;
  v4 = a3;
  do
  {
    v6 = *v3++;
    v5 = v6;
    v7 = *a2++;
    result = (result + v7 * v5);
    --v4;
  }
  while (v4);
  return result;
}

uint64_t silk_inner_prod16_aligned_64(__int16 *a1, __int16 *a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  int v7;
  int v8;

  if (a3 < 1)
    return 0;
  result = 0;
  v5 = a3;
  do
  {
    v7 = *a1++;
    v6 = v7;
    v8 = *a2++;
    result += v8 * (uint64_t)v6;
    --v5;
  }
  while (v5);
  return result;
}

uint64_t silk_residual_energy16_covar_FIX(__int16 *a1, int *a2, int *a3, int a4, int a5, int a6)
{
  signed int v6;
  unint64_t v7;
  signed int v8;
  uint64_t v9;
  __int16 *v10;
  int v11;
  int v12;
  signed int v13;
  int v14;
  signed int v15;
  int v16;
  __int16 *v17;
  uint64_t v18;
  int v19;
  char v20;
  __int16 *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  char v27;
  int v28;
  __int16 *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unint64_t v34;
  int *v35;
  __int16 *v36;
  unsigned __int16 v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  signed int v44;
  unsigned int v45;
  __int16 v47[2];
  _BYTE v48[68];

  *(_QWORD *)&v48[60] = *MEMORY[0x24BDAC8D0];
  v6 = 16 - a6;
  v7 = a5;
  if (a5 < 1)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = a5;
    v10 = a1;
    do
    {
      v12 = *v10++;
      v11 = v12;
      if (v12 < 0)
        v11 = -v11;
      if (v8 <= v11)
        v8 = v11;
      --v9;
    }
    while (v9);
  }
  v13 = __clz(v8) - 17;
  if (v6 < v13)
    v13 = 16 - a6;
  v14 = *a2;
  if (*a2 <= a2[a5 * a5 - 1])
    v14 = a2[a5 * a5 - 1];
  v15 = __clz((((v14 >> 16) * (__int16)v8 + (((unsigned __int16)v14 * (__int16)v8) >> 16)) >> 4) * a5) - 5;
  if (v13 < v15)
    v15 = v13;
  v16 = v15 & ~(v15 >> 31);
  if (a5 <= 0)
  {
    LODWORD(v22) = 0;
    v20 = v6 - v16;
    v27 = v20 + 1;
    v28 = a4 >> (v20 + 1);
  }
  else
  {
    v17 = v47;
    v18 = a5;
    do
    {
      v19 = *a1++;
      *(_DWORD *)v17 = v19 << v16;
      v17 += 2;
      --v18;
    }
    while (v18);
    v20 = v6 - v16;
    v21 = v47;
    v22 = a5;
    do
    {
      v24 = *a3++;
      v23 = v24;
      v25 = *v21;
      v21 += 2;
      LODWORD(v18) = v18 + v25 * (v23 >> 16) + ((v25 * (unsigned __int16)v23) >> 16);
      --v22;
    }
    while (v22);
    v26 = 0;
    v27 = v20 + 1;
    v28 = (a4 >> (v20 + 1)) - v18;
    v29 = (__int16 *)v48;
    v30 = a2 + 1;
    v31 = 1;
    do
    {
      v32 = v26 + 1;
      if (v26 + 1 >= v7)
      {
        v33 = 0;
      }
      else
      {
        v33 = 0;
        v34 = v7;
        v35 = v30;
        v36 = v29;
        do
        {
          v38 = *v35++;
          v37 = v38;
          v39 = v38 >> 16;
          v40 = *v36;
          v36 += 2;
          v33 += v40 * v39 + ((v40 * v37) >> 16);
          --v34;
        }
        while (v31 != v34);
      }
      v41 = a2[v26 * v7 + v26];
      v42 = v47[2 * v26];
      v43 = v33 + v42 * (v41 >> 17) + ((v42 * (unsigned __int16)(v41 >> 1)) >> 16);
      LODWORD(v22) = v22 + (v43 >> 16) * v42 + (((unsigned __int16)v43 * v42) >> 16);
      ++v31;
      v29 += 2;
      v30 += v7 + 1;
      v26 = v32;
    }
    while (v32 != v7);
  }
  v44 = ((_DWORD)v22 << v20) + v28;
  if (v44 < 1)
    return 1;
  v45 = v44 << v27;
  if (v44 <= 0x7FFFFFFFu >> (v20 + 2))
    return v45;
  else
    return 0x3FFFFFFFLL;
}

void *silk_k2a(void *__src, __int16 *a2, int a3)
{
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  _BYTE v11[4];
  _BYTE __dst[64];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a3 >= 1)
  {
    v4 = __src;
    v5 = 0;
    v6 = 0;
    v7 = a3;
    do
    {
      if (v6)
      {
        __src = memcpy(__dst, v4, 4 * v6);
        v8 = a2[v6];
        v9 = v5;
        v10 = v4;
        do
        {
          *v10++ += (__int16)(*(int *)&v11[v9] >> 15) * v8 + ((2 * (*(_DWORD *)&v11[v9] & 0x7FFF) * v8) >> 16);
          v9 -= 4;
        }
        while (v9);
      }
      else
      {
        v8 = *a2;
      }
      *((_DWORD *)v4 + v6++) = -512 * v8;
      v5 += 4;
    }
    while (v6 != v7);
  }
  return __src;
}

void silk_find_LPC_FIX(uint64_t a1, __int16 *a2, uint64_t a3, int a4)
{
  int v8;
  int v9;
  _BYTE *v10;
  unsigned int v11;
  char *v12;
  int i;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  __int16 v28[16];
  __int16 v29[16];
  int v30[16];
  int v31[16];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v8 = *(_DWORD *)(a1 + 4664);
  v9 = v8 + *(_DWORD *)(a1 + 4612);
  v10 = (_BYTE *)(a1 + 4815);
  *(_BYTE *)(a1 + 4815) = 4;
  silk_burg_modified(&v23, &v21, v31, a3, a4, v9, *(_DWORD *)(a1 + 4604), v8);
  if (*(_DWORD *)(a1 + 4656) && !*(_DWORD *)(a1 + 4696) && *(_DWORD *)(a1 + 4604) == 4)
  {
    silk_burg_modified(&v22, &v20, v30, a3 + 4 * v9, a4, v9, 2, *(_DWORD *)(a1 + 4664));
    v11 = v20 - v21;
    if (v20 - v21 < 0)
    {
      v23 = (v23 >> (v21 - v20)) - v22;
      v21 = v20;
    }
    else if (v11 <= 0x1F)
    {
      v23 -= v22 >> v11;
    }
    silk_A2NLSF(a2, v30, *(_DWORD *)(a1 + 4664));
    v12 = (char *)&v20 - ((4 * v9 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v12, 4 * v9);
    for (i = 3; i != -1; --i)
    {
      silk_interpolate(v28, (__int16 *)(a1 + 4524), a2, i, *(_DWORD *)(a1 + 4664));
      silk_NLSF2A(v29, v28, *(_DWORD *)(a1 + 4664));
      silk_LPC_analysis_filter((char *)&v20 - ((4 * v9 + 15) & 0xFFFFFFFFFFFFFFF0), a3, (uint64_t)v29, 2 * v9, *(_DWORD *)(a1 + 4664));
      silk_sum_sqr_shift((unsigned int *)&v27, &v25, (uint64_t)&v12[2 * *(int *)(a1 + 4664)], v9 - *(_DWORD *)(a1 + 4664));
      silk_sum_sqr_shift((unsigned int *)&v26, &v24, (uint64_t)&v12[2 * v9 + 2 * *(int *)(a1 + 4664)], v9 - *(_DWORD *)(a1 + 4664));
      v14 = v25;
      if (v25 - v24 < 0)
      {
        v16 = v27 >> (v24 - v25);
        v27 = v16;
        v15 = v26;
        v14 = v24;
      }
      else
      {
        v15 = v26 >> (v25 - v24);
        v26 = v15;
        v16 = v27;
      }
      v17 = -v14;
      v18 = v15 + v16;
      v19 = v17 - v21;
      if (v17 - v21 < 0)
      {
        if (v19 < 0xFFFFFFE1 || v18 >= v23 >> (v21 - v17))
          continue;
      }
      else if (v18 >> v19 >= v23)
      {
        continue;
      }
      v23 = v18;
      v21 = v17;
      *v10 = i;
    }
  }
  if (*v10 == 4)
    silk_A2NLSF(a2, v31, *(_DWORD *)(a1 + 4664));
}

void silk_solve_LDL_FIX(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v8;
  char *v9;
  int v10;
  int v11;
  signed int v12;
  unint64_t v13;
  int v14;
  char *v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  char v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  char v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int *v47;
  uint64_t v48;
  int *v49;
  uint64_t v50;
  int v51;
  int v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  char *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int *v68;
  int *v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  int v74;
  uint64_t v76;
  int v77;
  char *v78;
  char *v79;
  uint64_t v80;
  int v81;
  _BYTE v82[4];
  _BYTE v83[188];
  _DWORD v84[16];
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  v8 = 4 * (a2 * a2);
  v9 = (char *)&v76 - ((v8 + 15) & 0x3FFFFFFF0);
  bzero(v9, v8);
  v10 = *a1;
  v11 = a1[(__int16)a2 * (__int16)a2 - 1];
  if (v11 + *a1 < 0)
  {
    if ((v11 | v10) < 0)
      v12 = v11 + *a1;
    else
      v12 = 0x7FFFFFFF;
  }
  else if ((v11 & v10) < 0 != __OFADD__(v11, v10))
  {
    v12 = 0x80000000;
  }
  else
  {
    v12 = v11 + *a1;
  }
  v13 = (unint64_t)(21475 * v12) >> 32;
  if ((int)v13 <= 512)
    v14 = 512;
  else
    v14 = v13;
  if ((int)a2 > 0)
  {
    v76 = a3;
    v77 = (__int16)a2;
    v81 = 0;
    v15 = v9;
    v16 = a2 + 1;
    v17 = 4 * a2;
    v18 = a2;
    v78 = v9;
    v79 = &v9[v17];
    v80 = a2;
    do
    {
      v19 = 0;
      v20 = v79;
      v21 = v15;
      v22 = 1;
      while (1)
      {
        if (v19)
        {
          v23 = 0;
          v24 = 0;
          do
          {
            v25 = *(_DWORD *)&v21[4 * v23];
            v26 = (__int16)v25;
            v27 = ((v25 >> 15) + 1) >> 1;
            v28 = v26 * (*(int *)&v83[4 * v23 + 124] >> 16)
                + ((v26 * (unsigned __int16)*(_DWORD *)&v83[4 * v23 + 124]) >> 16)
                + v27 * *(_DWORD *)&v83[4 * v23 + 124];
            v84[v23] = v28;
            v24 += v28 * v27 + (v28 >> 16) * v26 + (((unsigned __int16)v28 * v26) >> 16);
            ++v23;
          }
          while (v19 != v23);
        }
        else
        {
          v24 = 0;
        }
        v29 = v19 * v18 + v19;
        v30 = a1[v29] - v24;
        if (v30 < v14)
          break;
        *(_DWORD *)&v83[4 * v19 + 124] = v30;
        if (v30 >= 0)
          v31 = v30;
        else
          v31 = -v30;
        v32 = __clz(v31);
        v33 = v30 << (v32 - 1);
        v34 = 0x1FFFFFFF / (v33 >> 16);
        v35 = (__int16)v34;
        v36 = v35 * (v33 >> 16) + ((v35 * (unsigned __int16)v33) >> 16);
        v37 = (v34 << 16)
            - 8 * v36 * (((v34 >> 15) + 1) >> 1)
            + ((-8 * v36) >> 16) * v35
            + ((((-8 * v36) & 0xFFF8) * v35) >> 16);
        v38 = v37 >> (26 - v32);
        v39 = v32 - 26;
        v40 = (int)0x80000000 >> v39;
        if (v37 > (int)0x80000000 >> v39)
          v40 = v37;
        if (v37 <= (int)(0x7FFFFFFFu >> v39))
          v41 = v40;
        else
          v41 = 0x7FFFFFFFu >> v39;
        v42 = v41 << v39;
        if (v31 <= 0x3F)
          v38 = v42;
        v43 = (__int16)(16 * v38);
        v44 = (((16 * v38) >> 15) + 1) >> 1;
        v45 = 0x1000000 - (v43 * (v30 >> 16) + v44 * v30 + ((v43 * (unsigned __int16)v30) >> 16));
        v46 = v45 * v44
            + (v45 >> 16) * v43
            + (((unsigned __int16)-(__int16)(v43 * HIWORD(v30)
                                           + v44 * v30
                                           + ((v43 * (unsigned __int16)v30) >> 16))
              * v43) >> 16);
        v47 = (int *)&v82[8 * v19];
        *v47 = v38;
        v47[1] = v46;
        *(_DWORD *)&v15[4 * v29] = 0x10000;
        v48 = v19 + 1;
        if (v19 + 1 < v18)
        {
          v49 = &a1[v19 * v18];
          v50 = v46;
          v51 = (__int16)v38;
          v52 = ((v38 >> 15) + 1) >> 1;
          v53 = v20;
          v54 = v22;
          do
          {
            if (v19)
            {
              v55 = 0;
              v56 = 0;
              do
              {
                v56 += (__int16)*(_DWORD *)&v53[4 * v55] * ((int)v84[v55] >> 16)
                     + (((__int16)*(_DWORD *)&v53[4 * v55] * (unsigned __int16)v84[v55]) >> 16)
                     + (((*(int *)&v53[4 * v55] >> 15) + 1) >> 1) * v84[v55];
                ++v55;
              }
              while (v19 != v55);
            }
            else
            {
              v56 = 0;
            }
            v57 = v49[v54] - (uint64_t)v56;
            *(_DWORD *)&v15[4 * v19 + 4 * v54 * v18] = ((unint64_t)(v57 * v50) >> 32)
                                                     + (((int)v57 * v52
                                                       + ((int)v57 >> 16) * v51
                                                       + (((unsigned __int16)(LOWORD(v49[v54]) - v56) * v51) >> 16)) >> 4);
            ++v54;
            v53 += v17;
          }
          while (v54 != v18);
        }
        ++v22;
        v21 += v17;
        v20 += v17;
        ++v19;
        if (v48 == v18)
          goto LABEL_42;
      }
      v58 = 0;
      v59 = (__int16)(v81 + 1) * v14 - v30;
      v60 = v18;
      do
      {
        a1[v58] += v59;
        v58 += v16;
        --v60;
      }
      while (v60);
LABEL_42:
      v61 = v80;
      ++v81;
    }
    while (v81 < (int)v80 && v30 < v14);
    v62 = 0;
    v63 = v78;
    v64 = v77;
    v65 = v76;
    do
    {
      if (v62)
      {
        v66 = 0;
        v67 = 0;
        do
        {
          v67 += (__int16)v84[v66] * (*(int *)&v15[4 * v66] >> 16)
               + (((__int16)v84[v66] * (unsigned __int16)*(_DWORD *)&v15[4 * v66]) >> 16)
               + ((((int)v84[v66] >> 15) + 1) >> 1) * *(_DWORD *)&v15[4 * v66];
          ++v66;
        }
        while (v62 != v66);
      }
      else
      {
        v67 = 0;
      }
      v84[v62] = *(_DWORD *)(v65 + 4 * v62) - v67;
      ++v62;
      v15 += 4 * v18;
    }
    while (v62 != v18);
    v68 = (int *)v83;
    v69 = v84;
    do
    {
      *v69 = ((unint64_t)(*v69 * (uint64_t)*v68) >> 32)
           + (((*v69 >> 16) * (__int16)*(v68 - 1)
             + (((*(v68 - 1) >> 15) + 1) >> 1) * *v69
             + (((unsigned __int16)*v69 * (__int16)*(v68 - 1)) >> 16)) >> 4);
      ++v69;
      v68 += 2;
      --v18;
    }
    while (v18);
    v70 = (v61 - 1);
    do
    {
      if (v70 >= (v61 - 1))
      {
        v71 = 0;
      }
      else
      {
        v71 = 0;
        v72 = (v61 << 16) - 0x10000;
        v73 = v61 - 1;
        do
        {
          v74 = *(_DWORD *)&v63[4 * v70 + 4 * (v72 >> 16) * v64];
          v71 += (__int16)*(_DWORD *)(a4 + 4 * v73) * (v74 >> 16)
               + (((__int16)*(_DWORD *)(a4 + 4 * v73) * (unsigned __int16)v74) >> 16)
               + (((*(int *)(a4 + 4 * v73) >> 15) + 1) >> 1) * v74;
          --v73;
          v72 -= 0x10000;
        }
        while (v70 < v73);
      }
      *(_DWORD *)(a4 + 4 * v70) = v84[v70] - v71;
    }
    while (v70-- > 0);
  }
}

unsigned int *silk_residual_energy_FIX(unsigned int *result, _DWORD *a2, uint64_t a3, uint64_t a4, unsigned int *a5, int a6, int a7, int a8)
{
  unsigned int *v9;
  int v10;
  int v11;
  size_t v12;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  unsigned int *v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int *v31;
  int v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  int v38;
  int v39;
  uint64_t v40;

  v31 = a5;
  v36 = a4;
  v9 = result;
  v40 = *MEMORY[0x24BDAC8D0];
  v38 = a8;
  v10 = a8 + a6;
  v11 = 2 * (a8 + a6);
  v12 = 2 * v11;
  v37 = (char *)&v30 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v32 = a7;
  if (a7 > 1)
  {
    v15 = v11;
    v39 = 0;
    v16 = v37;
    bzero(v37, v12);
    v17 = 0;
    v34 = v32 >> 1;
    v35 = v15;
    v18 = 2 * v10;
    v33 = &v16[2 * v38];
    do
    {
      silk_LPC_analysis_filter(v37, a3, v36 + 32 * v17, v15, v38);
      v19 = 0;
      v20 = 2 * v17;
      v21 = 1;
      v22 = (uint64_t)v33;
      do
      {
        v23 = v21;
        v24 = v19 | v20;
        result = silk_sum_sqr_shift(&v9[v19 | v20], &v39, v22, a6);
        v21 = 0;
        a2[v24] = -v39;
        v22 += v18;
        v19 = 1;
      }
      while ((v23 & 1) != 0);
      LODWORD(v15) = v35;
      a3 += 2 * v35;
      ++v17;
    }
    while (v17 != v34);
  }
  v25 = v31;
  if (v32 >= 1)
  {
    v26 = v32;
    do
    {
      v27 = __clz(*v9);
      v28 = *v25++;
      v29 = __clz(v28) - 1;
      *v9 = (unint64_t)((int)((unint64_t)((int)(v28 << v29) * (uint64_t)(int)(v28 << v29)) >> 32)
                             * (uint64_t)(int)(*v9 << (v27 - 1))) >> 32;
      ++v9;
      *a2 = v27 + *a2 + 2 * v29 - 65;
      ++a2;
      --v26;
    }
    while (v26);
  }
  return result;
}

double silk_find_pred_coefs_FIX(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10;
  int v11;
  uint64_t v12;
  int *v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int *v19;
  __int16 *v20;
  int *v21;
  uint64_t v22;
  int *v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  int v37;
  int v38;
  size_t v39;
  char *v40;
  size_t v41;
  char *v42;
  uint64_t v43;
  __int16 *v44;
  uint64_t v45;
  _WORD *v46;
  int v47;
  int v48;
  signed int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  char v60;
  int v61;
  unsigned int v62;
  double result;
  __int128 v64;
  int v66[4];
  _OWORD v67[2];
  __int16 v68[8];
  unsigned int v69[4];
  _DWORD v70[4];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *(_DWORD *)(a1 + 4604);
  if (v10 >= 1)
  {
    v11 = 0x1FFFFFF;
    v12 = *(unsigned int *)(a1 + 4604);
    v13 = (int *)a2;
    do
    {
      v15 = *v13++;
      v14 = v15;
      if (v11 >= v15)
        v11 = v14;
      --v12;
    }
    while (v12);
    if (v11 >= 0)
      v16 = v11;
    else
      v16 = -v11;
    v17 = __clz(v16);
    v18 = v11 << (v17 - 1);
    v19 = v69;
    v20 = v68;
    v21 = v70;
    v22 = *(unsigned int *)(a1 + 4604);
    v23 = (int *)a2;
    do
    {
      v25 = *v23++;
      v24 = v25;
      if (v25 >= 0)
        v26 = v24;
      else
        v26 = -v24;
      v27 = __clz(v26);
      v28 = v24 << (v27 - 1);
      v29 = 0x1FFFFFFF / (v28 >> 16);
      v30 = v29 * (v18 >> 16) + ((v29 * (unsigned __int16)v18) >> 16);
      v31 = v18 - (((unint64_t)(v30 * (uint64_t)v28) >> 29) & 0xFFFFFFF8);
      v32 = v30 + (v31 >> 16) * v29 + (((unsigned __int16)v31 * v29) >> 16);
      v33 = v17 - v27;
      v34 = v32 >> (v33 + 15);
      v35 = (int)0x80000000 >> (-15 - v33);
      if ((v33 + 29) >= 0x2E)
        v34 = 0;
      if (v32 > v35)
        v35 = v32;
      if (v32 <= (int)(0x7FFFFFFFu >> (-15 - v33)))
        v36 = v35;
      else
        v36 = 0x7FFFFFFFu >> (-15 - v33);
      v37 = v36 << (-15 - v33);
      if (v33 > -16)
        v37 = v34;
      if (v37 <= 363)
        v37 = 363;
      *v21++ = v37;
      *(_DWORD *)v20 = (int)((__int16)v37 * HIWORD(v37) + (((__int16)v37 * (unsigned __int16)v37) >> 16)) >> 1;
      v20 += 2;
      *v19++ = 0x10000u / v37;
      --v22;
    }
    while (v22);
  }
  v38 = *(_DWORD *)(a1 + 4664);
  v39 = 2 * (*(_DWORD *)(a1 + 4608) + v38 * v10);
  v40 = (char *)&v66[-2] - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v40, v39);
  if (*(_BYTE *)(a1 + 4813) == 2)
  {
    v41 = 100 * v10;
    v42 = (char *)&v66[-2] - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v42, v41);
    silk_find_LTP_FIX(a2 + 80, (int *)v42, (_DWORD *)(a2 + 496), a3, a2 + 124, v68, *(_DWORD *)(a1 + 4612), v10, *(_DWORD *)(a1 + 4616), v66);
    silk_quant_LTP_gains(a2 + 80, (char *)(a1 + 4788), (_BYTE *)(a1 + 4816), (int *)(a1 + 4688), (int *)v42, *(_DWORD *)(a1 + 4684), *(_DWORD *)(a1 + 4680), *(_DWORD *)(a1 + 4604));
    silk_LTP_scale_ctrl_FIX(a1, a2, a5);
    silk_LTP_analysis_filter_FIX((uint64_t)v40, a4 - 2 * *(int *)(a1 + 4664), a2 + 80, a2 + 124, (uint64_t)v70, *(_DWORD *)(a1 + 4612), *(_DWORD *)(a1 + 4604), *(_DWORD *)(a1 + 4664));
  }
  else
  {
    if (v10 >= 1)
    {
      v43 = 0;
      v44 = (__int16 *)(a4 - 2 * v38);
      LODWORD(v45) = *(_DWORD *)(a1 + 4612);
      v46 = v40;
      do
      {
        silk_scale_copy_vector16(v46, v44, v70[v43], v38 + v45);
        v45 = *(int *)(a1 + 4612);
        v38 = *(_DWORD *)(a1 + 4664);
        v46 += v38 + (int)v45;
        v44 += v45;
        ++v43;
      }
      while (v43 < *(int *)(a1 + 4604));
      v10 = *(_DWORD *)(a1 + 4604);
    }
    bzero((void *)(a2 + 80), 10 * v10);
    *(_DWORD *)(a2 + 496) = 0;
    *(_DWORD *)(a1 + 4688) = 0;
  }
  if (*(_DWORD *)(a1 + 4696))
  {
    v47 = 10737418;
  }
  else
  {
    v48 = silk_log2lin(21845 * (*(int *)(a2 + 496) >> 16)+ ((21845 * (unsigned __int16)*(_DWORD *)(a2 + 496)) >> 16)+ 2048);
    v49 = 10000 * ((((3 * *(__int16 *)(a2 + 484) + 0x10000) >> 15) + 1) >> 1)
        + ((10000 * (__int16)(3 * *(_WORD *)(a2 + 484))) >> 16);
    if (v48 >= 0)
      v50 = v48;
    else
      v50 = -v48;
    v51 = __clz(v50);
    if (v49 >= 0)
      v52 = 10000 * ((((3 * *(__int16 *)(a2 + 484) + 0x10000) >> 15) + 1) >> 1)
          + ((10000 * (__int16)(3 * *(_WORD *)(a2 + 484))) >> 16);
    else
      v52 = -v49;
    v53 = __clz(v52);
    v54 = v49 << (v53 - 1);
    v55 = 0x1FFFFFFF / (v54 >> 16);
    v56 = (v48 << (v51 - 1) >> 16) * v55 + (((unsigned __int16)(v48 << (v51 - 1)) * v55) >> 16);
    v57 = (v48 << (v51 - 1)) - (((unint64_t)(v54 * (uint64_t)v56) >> 29) & 0xFFFFFFF8);
    v58 = v56 + (v57 >> 16) * v55 + (((unsigned __int16)v57 * v55) >> 16);
    v59 = v51 - v53;
    if (v59 > -16)
    {
      v47 = v58 >> (v59 + 15);
    }
    else
    {
      v60 = -15 - v59;
      v61 = (int)0x80000000 >> v60;
      if (v58 > (int)0x80000000 >> v60)
        v61 = v58;
      if (v58 <= (int)(0x7FFFFFFFu >> v60))
        v62 = v61;
      else
        v62 = 0x7FFFFFFFu >> v60;
      v47 = v62 << v60;
    }
  }
  silk_find_LPC_FIX(a1, (__int16 *)v67, (uint64_t)v40, v47);
  silk_process_NLSFs(a1, (__int16 *)(a2 + 16), (__int16 *)v67, (__int16 *)(a1 + 4524));
  silk_residual_energy_FIX((unsigned int *)(a2 + 500), (_DWORD *)(a2 + 516), (uint64_t)v40, a2 + 16, v69, *(_DWORD *)(a1 + 4612), *(_DWORD *)(a1 + 4604), *(_DWORD *)(a1 + 4664));
  result = *(double *)v67;
  v64 = v67[1];
  *(_OWORD *)(a1 + 4524) = v67[0];
  *(_OWORD *)(a1 + 4540) = v64;
  return result;
}

uint64_t silk_process_gains_FIX(uint64_t a1, uint64_t a2, int a3)
{
  _BYTE *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;
  int v25;
  int v26;
  signed int v27;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  signed int v37;
  signed int v38;
  uint64_t result;
  int v40;
  uint64_t v41;

  v6 = (_BYTE *)(a1 + 7224);
  v7 = (unsigned __int8 *)(a1 + 4813);
  v8 = a1 + 4784;
  if (*(_BYTE *)(a1 + 4813) == 2)
  {
    v9 = silk_sigm_Q15((((*(_DWORD *)(a2 + 496) - 1536) >> 3) + 1) >> 1);
    if (*(int *)(a1 + 4604) >= 1)
    {
      v10 = 0;
      do
      {
        *(_DWORD *)(a2 + 4 * v10) += (*(int *)(a2 + 4 * v10) >> 16) * (__int16)-v9
                                   + (((unsigned __int16)*(_DWORD *)(a2 + 4 * v10) * (__int16)-v9) >> 16);
        ++v10;
      }
      while (v10 < *(int *)(a1 + 4604));
    }
  }
  v11 = silk_log2lin(21627 * ((8894 - *(_DWORD *)(a1 + 4764)) >> 16)+ ((21627 * (unsigned __int16)(8894 - *(_WORD *)(a1 + 4764))) >> 16));
  v12 = *(int *)(a1 + 4604);
  if ((int)v12 > 0)
  {
    v13 = 0;
    v14 = v11 / *(_DWORD *)(a1 + 4612);
    v15 = (__int16)v14;
    v16 = ((v14 >> 15) + 1) >> 1;
    do
    {
      v17 = a2 + 4 * v13;
      v18 = *(_DWORD *)(v17 + 500) * v16
          + (*(int *)(v17 + 500) >> 16) * v15
          + (((unsigned __int16)*(_DWORD *)(v17 + 500) * v15) >> 16);
      v19 = *(_DWORD *)(v17 + 516);
      v20 = v18 << -(char)v19;
      if (v18 >= (int)(0x7FFFFFFFu >> -(char)v19))
        v20 = 0x7FFFFFFF;
      v21 = ((v18 >> (v19 - 1)) + 1) >> 1;
      v22 = (v18 & 1) + (v18 >> 1);
      v23 = v19 < 1;
      if (v19 == 1)
        v24 = v22;
      else
        v24 = v21;
      if (v23)
        v25 = v20;
      else
        v25 = v24;
      v26 = *(_DWORD *)(a2 + 4 * v13);
      v27 = v25 + ((unint64_t)(v26 * (uint64_t)v26) >> 32);
      if (v27 < 0 && v25 > -1)
        v27 = 0x7FFFFFFF;
      if (v27 > 32766)
      {
        v34 = __clz(v27);
        v35 = __ROR4__(v27, 24 - v34) & 0x7F;
        if ((v34 & 1) != 0)
          v36 = 0x8000;
        else
          v36 = 46214;
        v37 = (v36 >> (v34 >> 1)) + ((213 * (v36 >> (v34 >> 1)) * v35) >> 16);
        if (v37 >= 0x7FFF)
          v37 = 0x7FFF;
        v38 = v37 << 16;
      }
      else
      {
        v29 = (__int16)v26 * (v26 >> 16)
            + (v25 << 16)
            + (((__int16)v26 * (unsigned __int16)v26) >> 16)
            + (((v26 >> 15) + 1) >> 1) * v26;
        if ((int)v29 < 1)
        {
          v33 = 0;
        }
        else
        {
          v30 = __clz(v29);
          if (v30 != 24)
          {
            if (v29 <= 0x7F)
              LOBYTE(v29) = (v29 >> (56 - v30)) | ((_BYTE)v29 << (v30 - 24));
            else
              LOBYTE(v29) = ((_BYTE)v29 << (v30 + 8)) | (v29 >> (24 - v30));
          }
          v31 = v29 & 0x7F;
          if ((v30 & 1) != 0)
            v32 = 0x8000;
          else
            v32 = 46214;
          v33 = (v32 >> (v30 >> 1)) + ((213 * (v32 >> (v30 >> 1)) * v31) >> 16);
        }
        v38 = v33 << 8;
      }
      *(_DWORD *)(a2 + 4 * v13++) = v38;
      v12 = *(int *)(a1 + 4604);
    }
    while (v13 < v12);
  }
  memcpy((void *)(a2 + 532), (const void *)a2, 4 * v12);
  *(_BYTE *)(a2 + 548) = *v6;
  result = silk_gains_quant(v8, a2, v6, a3 == 2, *(_DWORD *)(a1 + 4604));
  v40 = *v7;
  if (v40 == 2)
  {
    if (*(_DWORD *)(a2 + 496) + (*(int *)(a1 + 4760) >> 8) < 129)
    {
      v41 = 1;
      v7[1] = 1;
    }
    else
    {
      v41 = 0;
      v7[1] = 0;
    }
  }
  else
  {
    v41 = (char)v7[1];
  }
  *(_DWORD *)(a2 + 476) = -50 * *(__int16 *)(a1 + 4652)
                        + ((52429 * silk_Quantization_Offsets_Q10[2 * ((char)v40 >> 1) + v41]) >> 16)
                        + ((13108 * *(__int16 *)(a1 + 4556)) >> 16)
                        - (*(__int16 *)(a1 + 4556)
                         + *(__int16 *)(a2 + 480)
                         + *(__int16 *)(a2 + 484))
                        + ((65127 * *(__int16 *)(a2 + 480)) >> 16)
                        + ((64718 * *(__int16 *)(a2 + 484)) >> 16)
                        + 1229;
  return result;
}

uint64_t silk_encode_do_VAD_FIX(uint64_t a1)
{
  uint64_t result;
  int v3;
  char v4;

  result = silk_VAD_GetSA_Q8(a1, (__int16 *)(a1 + 5146));
  if (*(int *)(a1 + 4556) > 12)
  {
    *(_QWORD *)(a1 + 6132) = 0;
    v4 = 1;
    *(_BYTE *)(a1 + 4813) = 1;
  }
  else
  {
    *(_BYTE *)(a1 + 4813) = 0;
    v3 = *(_DWORD *)(a1 + 6136);
    *(_DWORD *)(a1 + 6136) = v3 + 1;
    if (v3 >= 9)
    {
      if (v3 < 0x1E)
      {
        v4 = 0;
        goto LABEL_8;
      }
      *(_DWORD *)(a1 + 6136) = 10;
    }
    v4 = 0;
    *(_DWORD *)(a1 + 6132) = 0;
  }
LABEL_8:
  *(_BYTE *)(a1 + *(int *)(a1 + 5796) + 4768) = v4;
  return result;
}

uint64_t silk_encode_frame_FIX(uint64_t a1, int *a2, uint64_t *a3, int a4, signed int a5, int a6)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  size_t v12;
  _BYTE *v13;
  size_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  int v20;
  int v21;
  int v22;
  int v23;
  __int128 v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  int v29;
  signed int v30;
  uint64_t v31;
  __int128 v32;
  int32x2_t *v33;
  uint64_t *v34;
  _DWORD *v35;
  uint64_t *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  signed int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  __int128 *v46;
  uint64_t v47;
  int v48;
  _BYTE *v49;
  unint64_t v50;
  _BOOL4 v53;
  uint64_t *v54;
  const void *v55;
  unsigned int v56;
  _BYTE v57[12];
  int v58;
  int v59;
  int v60;
  uint64_t *v61;
  void *v62;
  int *v63;
  int v64;
  uint64_t v65;
  _BYTE *v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _OWORD *v72;
  _OWORD *v73;
  _DWORD *v74;
  int *v75;
  int v76;
  int v77;
  int v78;
  signed int v79;
  _BYTE *v80;
  int32x2_t *v81;
  uint64_t *v82;
  _BOOL4 v83;
  int v84;
  int v85;
  _BYTE *v86;
  unint64_t v87;
  signed int v88;
  int v89;
  int v90;
  signed int v91;
  signed int v92;
  _OWORD v93[274];
  __int128 v94;
  __int128 v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  _OWORD v99[4];
  _OWORD v100[22];
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  char v106;
  _BYTE v107[4380];
  __int128 v108;
  uint64_t v109;
  _OWORD v110[2];
  uint64_t v111;

  v76 = a6;
  v92 = a5;
  v78 = a4;
  v82 = a3;
  v63 = a2;
  v111 = *MEMORY[0x24BDAC8D0];
  v105 = 0u;
  v104 = 0u;
  v103 = 0u;
  v102 = 0u;
  v101 = 0u;
  memset(v100, 0, sizeof(v100));
  memset(v99, 0, sizeof(v99));
  v98 = 0u;
  memset(v110, 0, 28);
  v109 = 0;
  v108 = 0uLL;
  memset(v93, 0, 512);
  v7 = *(_DWORD *)(a1 + 4644);
  *(_DWORD *)(a1 + 4644) = v7 + 1;
  v8 = *(int *)(a1 + 4616);
  v62 = (void *)(a1 + 8356);
  v9 = a1 + 8356 + 2 * v8;
  v80 = (_BYTE *)(a1 + 4564);
  *(_BYTE *)(a1 + 4818) = v7 & 3;
  silk_LP_variable_cutoff((int *)(a1 + 16), a1 + 5146, *(_DWORD *)(a1 + 4608));
  memcpy((void *)(v9 + 10 * *(int *)(a1 + 4600)), (const void *)(a1 + 5146), 2 * *(int *)(a1 + 4608));
  if (!*(_DWORD *)(a1 + 4712))
  {
    v86 = (_BYTE *)(a1 + 7224);
    v87 = a1 + 4784;
    v11 = *(int *)(a1 + 4616);
    v12 = 2 * (*(_DWORD *)(a1 + 4608) + *(_DWORD *)(a1 + 4620) + (int)v11);
    v13 = &v57[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v13, v12);
    silk_find_pitch_lags_FIX(a1, (uint64_t)&v98, (__int16 *)v13, v9);
    silk_noise_shape_analysis_FIX((int *)a1, (uint64_t)&v98, (uint64_t)&v13[2 * v11], v9, *(_DWORD *)(a1 + 5140));
    LODWORD(v11) = v78;
    silk_find_pred_coefs_FIX(a1, (uint64_t)&v98, (uint64_t)v13, v9, v78);
    silk_process_gains_FIX(a1, (uint64_t)&v98, v11);
    v14 = 4 * *(int *)(a1 + 4608);
    v15 = &v57[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v15, v14);
    v75 = (int *)v15;
    silk_prefilter_FIX(a1, (uint64_t)&v98, (int *)v15, v9);
    if (*(_DWORD *)(a1 + 6144) && *(int *)(a1 + 4556) >= 78)
    {
      v16 = *(int *)(a1 + 5796);
      v17 = a1 + 36 * (int)v16 + 6152;
      *(_DWORD *)(a1 + 4 * v16 + 4772) = 1;
      memcpy(v107, (const void *)(a1 + 144), sizeof(v107));
      v19 = *(_OWORD *)v87;
      v18 = *(_OWORD *)(v87 + 16);
      *(_DWORD *)(v17 + 32) = *(_DWORD *)(v87 + 32);
      *(_OWORD *)v17 = v19;
      *(_OWORD *)(v17 + 16) = v18;
      v20 = *(_DWORD *)(a1 + 4604);
      __memcpy_chk();
      v21 = *(_DWORD *)(a1 + 5796);
      if (!v21 || !*(_DWORD *)(a1 + 4 * (v21 - 1) + 4772))
      {
        *v80 = *v86;
        v22 = (char)(*(_BYTE *)v17 + *(_BYTE *)(a1 + 6148));
        if (v22 >= 63)
          LOBYTE(v22) = 63;
        *(_BYTE *)v17 = v22;
        v20 = *(_DWORD *)(a1 + 4604);
      }
      silk_gains_dequant((uint64_t)&v98, (char *)v17, (_BYTE *)(a1 + 4564), v78 == 2, v20);
      if (*(int *)(a1 + 4652) <= 1 && *(int *)(a1 + 4704) < 1)
        silk_NSQ((_DWORD *)a1, (int32x2_t *)v107, v17, v75, (_DWORD *)(a1 + 320 * *(int *)(a1 + 5796) + 6260), (uint64_t)v99, (uint64_t)v100, (uint64_t)&v100[11] + 12, (uint64_t)&v102 + 12, (uint64_t)&v101 + 12, (uint64_t)&v100[19] + 12, (uint64_t)&v98, (uint64_t)&v100[2] + 12, SWORD6(v103), SHIWORD(v103), SWORD4(v100[2]));
      else
        silk_NSQ_del_dec(a1, (uint64_t)v107, v17, v75, a1 + 320 * *(int *)(a1 + 5796) + 6260, (uint64_t)v99, (uint64_t)v100, (uint64_t)&v100[11] + 12, (uint64_t)&v102 + 12, (uint64_t)&v101 + 12, (uint64_t)&v100[19] + 12, (uint64_t)&v98, (int *)&v100[2] + 3, SHIDWORD(v103), SWORD4(v100[2]));
      __memcpy_chk();
    }
    v97 = 0;
    v96 = 0u;
    v95 = 0u;
    v94 = 0u;
    v23 = silk_gains_ID(v87, *(_DWORD *)(a1 + 4604));
    v24 = *((_OWORD *)v82 + 1);
    v94 = *(_OWORD *)v82;
    v95 = v24;
    v96 = *((_OWORD *)v82 + 2);
    v97 = v82[6];
    v61 = v82 + 4;
    v81 = (int32x2_t *)(a1 + 144);
    memcpy(v107, (const void *)(a1 + 144), sizeof(v107));
    v25 = v80[254];
    v59 = *(unsigned __int16 *)(a1 + 5820);
    v60 = v25;
    v58 = *(_DWORD *)(a1 + 5816);
    v66 = &v57[-1280];
    bzero(&v57[-1280], 0x4FBuLL);
    v65 = 0;
    v26 = 0;
    v88 = 0;
    v89 = 0;
    v27 = 0;
    v91 = 0;
    v28 = 0;
    v85 = 0;
    v64 = 0;
    v74 = (_DWORD *)(a1 + 4820);
    v72 = v100;
    v73 = v99;
    v70 = (uint64_t)&v102 + 12;
    v71 = (uint64_t)&v100[11] + 12;
    v68 = (uint64_t)&v100[19] + 12;
    v69 = (uint64_t)&v101 + 12;
    v67 = (int *)&v100[2] + 3;
    v79 = v92 - 5;
    LOWORD(v29) = 256;
    v90 = -1;
    v83 = v78 == 2;
    v84 = -1;
    while (1)
    {
      v30 = v91;
      if (v23 != v90)
      {
        v30 = v88;
        if (v23 != v84)
        {
          v31 = v27;
          if (v26)
          {
            v32 = v95;
            v33 = v81;
            v34 = v82;
            *(_OWORD *)v82 = v94;
            *((_OWORD *)v34 + 1) = v32;
            *((_OWORD *)v34 + 2) = v96;
            v34[6] = v97;
            memcpy(v33, v107, 0x111CuLL);
            v80[254] = v60;
            *(_WORD *)(a1 + 5820) = v59;
            *(_DWORD *)(a1 + 5816) = v58;
          }
          v77 = v28;
          v35 = v74;
          if (*(int *)(a1 + 4652) <= 1 && *(int *)(a1 + 4704) < 1)
            silk_NSQ((_DWORD *)a1, v81, v87, v75, v74, (uint64_t)v73, (uint64_t)v72, v71, v70, v69, v68, (uint64_t)&v98, (uint64_t)v67, SWORD6(v103), SHIWORD(v103), SWORD4(v100[2]));
          else
            silk_NSQ_del_dec(a1, (uint64_t)v81, v87, v75, (uint64_t)v74, (uint64_t)v73, (uint64_t)v72, v71, v70, v69, v68, (uint64_t)&v98, v67, SHIDWORD(v103), SWORD4(v100[2]));
          v36 = v82;
          silk_encode_indices(a1, v82, *(_DWORD *)(a1 + 5796), 0, v78);
          silk_encode_pulses(v36, (char)v80[249], (char)v80[250], (uint64_t)v35, *(_DWORD *)(a1 + 4608));
          v30 = *((_DWORD *)v36 + 6) + __clz(*((_DWORD *)v36 + 8)) - 32;
          if (v26 | v76)
          {
            v28 = v77;
            v27 = v31;
          }
          else
          {
            v28 = v77;
            v27 = v31;
            if (v30 <= v92)
              goto LABEL_2;
          }
        }
      }
      if (v26 == 6)
        break;
      if (v30 <= v92)
      {
        if (v30 >= v79)
          goto LABEL_2;
        v28 = (__int16)v29;
        if (v23 != v90)
        {
          v110[0] = *(_OWORD *)v82;
          *(_OWORD *)((char *)v110 + 12) = *(_OWORD *)((char *)v82 + 12);
          v38 = *((unsigned int *)v82 + 7);
          v108 = *(_OWORD *)v61;
          v109 = v61[2];
          v65 = v38;
          __memcpy_chk();
          memcpy(v93, v81, 0x111CuLL);
          v64 = *v86;
        }
        v27 = 1;
        v90 = v23;
        v91 = v30;
        v37 = v89;
      }
      else if ((_DWORD)v27 || v26 < 2)
      {
        v84 = v23;
        v85 = (__int16)v29;
        v37 = 1;
        v88 = v30;
      }
      else
      {
        v37 = 0;
        v27 = 0;
        HIDWORD(v103) += SHIDWORD(v103) >> 1;
        v84 = -1;
      }
      v89 = v37;
      v39 = v27;
      if ((v27 & v37) != 0)
      {
        v40 = (__int16)((v85 - v28) * (v92 - v91) / (v88 - v91) + v28);
        v29 = v28 + ((v85 - v28) >> 2);
        if (v40 <= v29)
        {
          if (v40 >= v85 - ((v85 - v28) >> 2))
            LOWORD(v29) = (v85 - v28) * (v92 - v91) / (v88 - v91) + v28;
          else
            LOWORD(v29) = v85 - ((v85 - v28) >> 2);
        }
      }
      else
      {
        v41 = v92;
        v42 = silk_log2lin(((v30 - v92) << 7) / *(_DWORD *)(a1 + 4608) + 2048);
        if (v42 >= 0x20000)
          v43 = 0x20000;
        else
          v43 = v42;
        if (v43 <= 85197)
          v44 = 85197;
        else
          v44 = v43;
        if (v30 > v41)
          v43 = v44;
        v29 = (v43 >> 16) * (__int16)v29 + (((unsigned __int16)v43 * (__int16)v29) >> 16);
      }
      v45 = *(_DWORD *)(a1 + 4604);
      if (v45 >= 1)
      {
        v46 = &v98;
        v47 = *(unsigned int *)(a1 + 4604);
        do
        {
          v48 = (*((int *)v46 + 133) >> 16) * (__int16)v29
              + (((unsigned __int16)*((_DWORD *)v46 + 133) * (__int16)v29) >> 16);
          if (v48 <= -8388608)
            v48 = -8388608;
          if (v48 >= 0x7FFFFF)
            v48 = 0x7FFFFF;
          *(_DWORD *)v46 = v48 << 8;
          v46 = (__int128 *)((char *)v46 + 4);
          --v47;
        }
        while (v47);
      }
      v49 = v86;
      v50 = v87;
      *v86 = v106;
      silk_gains_quant(v50, (uint64_t)&v98, v49, v83, v45);
      v23 = silk_gains_ID(v50, *(_DWORD *)(a1 + 4604));
      ++v26;
      v27 = v39;
    }
    v53 = v23 == v90 || v30 > v92;
    if ((_DWORD)v27 && v53)
    {
      v54 = v82;
      *(_OWORD *)v82 = v110[0];
      *(_OWORD *)((char *)v54 + 12) = *(_OWORD *)((char *)v110 + 12);
      v56 = v65;
      v55 = v66;
      *((_DWORD *)v54 + 7) = v65;
      *((_OWORD *)v54 + 2) = v108;
      v54[6] = v109;
      memcpy((void *)*v54, v55, v56);
      memcpy(v81, v93, 0x111CuLL);
      *v86 = v64;
    }
  }
LABEL_2:
  memmove(v62, (const void *)(a1 + 2 * *(int *)(a1 + 4608) + 8356), 2 * (5 * *(_DWORD *)(a1 + 4600) + *(_DWORD *)(a1 + 4616)));
  if (*(_DWORD *)(a1 + 4712))
  {
    v10 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 4568) = *((_DWORD *)&v100[2] + *(int *)(a1 + 4604) + 2);
    v80[1] = v80[249];
    *(_DWORD *)(a1 + 4696) = 0;
    v10 = (int)(*((_DWORD *)v82 + 6) + __clz(*((_DWORD *)v82 + 8)) - 25) >> 3;
  }
  *v63 = v10;
  return 0;
}

uint64_t silk_LTP_analysis_filter_FIX(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int16 *v13;
  int16x4_t v14;
  int v15;
  int v16;
  int v17;
  int32x4_t v18;
  uint64_t v19;
  int v20;

  if (a7 >= 1)
  {
    v8 = 0;
    v9 = (a8 + a6);
    v10 = 2 * a6;
    v11 = a7;
    do
    {
      if ((int)v9 >= 1)
      {
        v12 = 0;
        v13 = (__int16 *)(a3 + 10 * v8);
        v14 = *(int16x4_t *)(v13 + 1);
        v15 = *v13;
        v16 = HIWORD(*(_DWORD *)(a5 + 4 * v8));
        v17 = (unsigned __int16)*(_DWORD *)(a5 + 4 * v8);
        v18 = vmovl_s16(v14);
        v19 = -2 * *(int *)(a4 + 4 * v8);
        do
        {
          *(_WORD *)(result + 2 * v12) = *(_WORD *)(a2 + 2 * v12);
          v20 = *(__int16 *)(a2 + 2 * v12)
              - (((vaddvq_s32(vmlaq_s32((int32x4_t)(v15 * *(__int16 *)(a2 + v19 + 4)), v18, vmovl_s16(vrev64_s16(*(int16x4_t *)(a2 + v19 - 4))))) >> 13)+ 1) >> 1);
          if (v20 <= -32768)
            v20 = -32768;
          if (v20 >= 0x7FFF)
            v20 = 0x7FFF;
          *(_WORD *)(result + 2 * v12++) = v20 * v16 + ((v20 * v17) >> 16);
          v19 += 2;
        }
        while (v9 != v12);
      }
      ++v8;
      result += 2 * (int)v9;
      a2 += v10;
    }
    while (v8 != v11);
  }
  return result;
}

uint64_t silk_regularize_correlations_FIX(uint64_t result, _DWORD *a2, int a3, int a4)
{
  int v4;
  uint64_t v5;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = a4;
    do
    {
      *(_DWORD *)(result + 4 * v4) += a3;
      v4 += a4 + 1;
      --v5;
    }
    while (v5);
  }
  *a2 += a3;
  return result;
}

uint64_t silk_autocorr(unsigned int *a1, _DWORD *a2, char *a3, int a4, int a5)
{
  int v6;
  uint64_t result;

  if (a4 >= a5)
    v6 = a5;
  else
    v6 = a4;
  result = _celt_autocorr(a3, a1, 0, 0, v6 - 1, a4);
  *a2 = result;
  return result;
}

uint64_t silk_find_LTP_FIX(uint64_t result, int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, __int16 *a6, int a7, int a8, int a9, int *a10)
{
  _DWORD *v10;
  uint64_t v11;
  int *v12;
  uint64_t v14;
  uint64_t v15;
  __int16 *v16;
  uint64_t v17;
  unsigned int *v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  int *v26;
  int v27;
  uint64_t i;
  int v29;
  unsigned int v30;
  __int16 v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  char v36;
  int v37;
  int v38;
  int v39;
  int v40;
  char v41;
  int v42;
  char v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int *v49;
  int v50;
  int v51;
  signed int v52;
  int v53;
  int *v54;
  int *v55;
  int *v56;
  int v57;
  uint64_t v58;
  __int16 *v59;
  unsigned __int16 v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  int v70;
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  signed int v89;
  unsigned int *v90;
  int *v91;
  int *v92;
  int v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  int v97;
  int v98;
  int v99;
  unsigned int v100;
  int v101;
  signed int v102;
  int v103;
  int *v104;
  int *v105;
  int *v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  unsigned int v113;
  unsigned int v114;
  int v115;
  unsigned int v116;
  unsigned int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  int v132;
  char v133;
  unsigned int v134;
  int v135;
  int v136;
  unsigned int v137;
  BOOL v138;
  int v139;
  BOOL v140;
  uint64_t v141;
  int v142;
  int v143;
  int v144;
  uint64_t v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v152;
  signed int v153;
  uint64_t v154;
  uint64_t v155;
  __int16 *v159;
  int v160;
  _DWORD v161[4];
  int v162[5];
  _DWORD v163[4];
  _DWORD v164[4];
  _DWORD v165[9];
  _DWORD v166[5];
  uint64_t v167;

  v10 = a3;
  v11 = result;
  v12 = a10;
  v167 = *MEMORY[0x24BDAC8D0];
  v160 = 0;
  if (a8 < 1)
  {
    v48 = 0;
    if (!a3)
      goto LABEL_66;
    goto LABEL_44;
  }
  v14 = 0;
  v15 = a4 + 2 * a9;
  v16 = (__int16 *)result;
  v152 = a8;
  v153 = 655 * (a7 >> 16) + ((655 * (unsigned __int16)a7) >> 16);
  v154 = a8;
  v155 = a7;
  do
  {
    v17 = *(int *)(a5 + 4 * v14);
    v18 = &v161[v14];
    v159 = (__int16 *)v15;
    silk_sum_sqr_shift(v18, &v160, v15, a7);
    v19 = *v18;
    if (*v18 >> 30)
    {
      v20 = __clz(v19);
      v21 = v19 >> 1;
      v22 = (*v18 & 1) + ((int)*v18 >> 1);
      v23 = (v21 + 1) >> 1;
      if (v20 != 1)
        v22 = v23;
      *v18 = v22;
      v24 = v160 - v20 + 2;
      v160 = v24;
    }
    else
    {
      v24 = v160;
    }
    v25 = (unint64_t)&v159[-2 - v17];
    v26 = &a10[v14];
    *v26 = v24;
    silk_corrMatrix_FIX(v25, a7, 5u, 2, a2, v26);
    silk_corrVector_FIX(v25, v159, a7, 5, v162, *v26);
    v27 = v161[v14];
    if (*v26 > v160)
    {
      v27 >>= *(_BYTE *)v26 - v160;
      *v18 = v27;
    }
    silk_regularize_correlations_FIX((uint64_t)a2, v18, ((1092 * (unsigned __int16)v27) >> 16)+ ((1092 * (unsigned __int16)*a2) >> 16)+ ((1092 * (unsigned __int16)a2[24]) >> 16)+ 1092 * ((*a2 >> 16) + (v27 >> 16) + (a2[24] >> 16))+ 1, 5);
    silk_solve_LDL_FIX(a2, 5, (uint64_t)v162, (uint64_t)v166);
    for (i = 0; i != 5; ++i)
    {
      v29 = v166[i];
      v30 = ((v29 >> 1) + 1) >> 1;
      if (v29 < -131074)
        LOWORD(v30) = 0x8000;
      if (v29 <= 131069)
        v31 = v30;
      else
        v31 = 0x7FFF;
      v16[i] = v31;
    }
    v32 = silk_residual_energy16_covar_FIX(v16, a2, v162, v161[v14], 5, 14);
    v33 = 0;
    v34 = 0;
    v164[v14] = v32;
    if (*v26 >= 2)
      LOBYTE(v35) = 2;
    else
      v35 = *v26;
    v36 = v35 + 1;
    v37 = *(_DWORD *)&a6[2 * v14];
    v38 = (__int16)v37 * (v32 >> 16) + (((__int16)v37 * (unsigned __int16)v32) >> 16);
    v39 = v37 << 16;
    if (v38 <= (int)0x80000000 >> (v35 + 1))
      v40 = (int)0x80000000 >> (v35 + 1);
    else
      v40 = (__int16)v37 * (v32 >> 16) + (((__int16)v37 * (unsigned __int16)v32) >> 16);
    if (v38 > (int)(0x7FFFFFFFu >> (v35 + 1)))
      v40 = 0x7FFFFFFFu >> (v35 + 1);
    v41 = *v26 - v35;
    v42 = (v40 << v36) + (v153 >> v41);
    if (v42 <= 1)
      v42 = 1;
    v43 = v41 + 5;
    do
    {
      if (a2[v33] > (int)v34)
        v34 = a2[v33];
      ++v33;
    }
    while (v33 != 25);
    v44 = (v39 / v42) >> v43;
    v45 = 16 << __clz(v34);
    if (v44 < v45)
      v45 = v44;
    if (v34 <= 0x1F)
      v46 = v44;
    else
      v46 = v45;
    result = (uint64_t)silk_scale_vector32_Q26_lshift_18(a2, v46, 25);
    v163[v14] = a2[12];
    v47 = v154;
    v15 = (uint64_t)&v159[v155];
    v16 += 5;
    a2 += 25;
    ++v14;
  }
  while (v14 != v154);
  v48 = 0;
  v12 = a10;
  v49 = a10;
  a8 = v152;
  v10 = a3;
  do
  {
    v51 = *v49++;
    v50 = v51;
    if (v51 > v48)
      v48 = v50;
    --v47;
  }
  while (v47);
  if (a3)
  {
LABEL_44:
    if (a8 < 1)
    {
      v57 = a8;
      v53 = 0;
      v52 = 0;
    }
    else
    {
      v52 = 0;
      v53 = 0;
      v54 = v164;
      v55 = v161;
      v56 = v12;
      v57 = a8;
      v58 = a8;
      v59 = a6;
      do
      {
        v61 = *v55++;
        v60 = v61;
        v62 = v61 >> 16;
        v64 = *v59;
        v59 += 2;
        v63 = v64;
        v65 = v64 * v62 + ((v64 * v60) >> 16) + 1;
        v66 = *v56++;
        LOBYTE(v62) = v48 - v66 + 1;
        v53 += v65 >> v62;
        v67 = *v54++;
        v52 += ((v67 >> 16) * v63 + (((unsigned __int16)v67 * v63) >> 16) + 1) >> v62;
        --v58;
      }
      while (v58);
    }
    if (v52 <= 1)
      v52 = 1;
    if (v53 >= 0)
      v68 = v53;
    else
      v68 = -v53;
    v69 = __clz(v68);
    v70 = v53 << (v69 - 1);
    v71 = __clz(v52);
    v72 = v52 << (v71 - 1);
    v73 = 0x1FFFFFFF / (v72 >> 16);
    v74 = v73 * (v70 >> 16) + ((v73 * (unsigned __int16)v70) >> 16);
    v75 = v70 - (((unint64_t)(v74 * (uint64_t)v72) >> 29) & 0xFFFFFFF8);
    v76 = v74 + (v75 >> 16) * v73 + (((unsigned __int16)v75 * v73) >> 16);
    v77 = v69 - v71;
    if (v69 - v71 + 13 >= 0x20)
      v78 = 0;
    else
      v78 = v76 >> (v77 + 13);
    v79 = (int)0x80000000 >> (-13 - v77);
    if (v76 > v79)
      v79 = v76;
    if (v76 <= (int)(0x7FFFFFFFu >> (-13 - v77)))
      v80 = v79;
    else
      v80 = 0x7FFFFFFFu >> (-13 - v77);
    v81 = v80 << (-13 - v77);
    if (v77 <= -14)
      v82 = v81;
    else
      v82 = v78;
    result = silk_lin2log(v82);
    *v10 = (((int)result - 2048) << 16 >> 15) + (__int16)(result - 2048);
    a8 = v57;
  }
LABEL_66:
  if (a8 < 1)
  {
    v89 = 0;
    v99 = -11;
  }
  else
  {
    v83 = 0;
    v84 = v11;
    v85 = a8;
    do
    {
      v86 = 0;
      v87 = 0;
      do
      {
        v87 += *(__int16 *)(v84 + v86);
        v86 += 2;
      }
      while (v86 != 10);
      v165[v83] = v87;
      v84 += 10;
      ++v83;
    }
    while (v83 != a8);
    v88 = 0;
    v89 = 0;
    v90 = v163;
    v91 = v165;
    v92 = v12;
    do
    {
      v94 = *v91++;
      v93 = v94;
      if (v94 < 0)
        v93 = -v93;
      if (v89 <= v93)
        v89 = v93;
      v95 = *v90++;
      v96 = __clz(v95);
      v97 = *v92++;
      v98 = v97 - v48 - v96 + 32;
      if (v88 <= v98)
        v88 = v98;
      --v85;
    }
    while (v85);
    v99 = v88 - 11;
  }
  v100 = __clz(v89);
  v101 = ((v99 - v48 - v100) & ~((int)(v99 - v48 - v100) >> 31)) + v48;
  v102 = (0x106u >> (((v99 - v48 - v100) & ~((int)(v99 - v48 - v100) >> 31)) + v48)) + 1;
  if (a8 < 1)
  {
    v103 = 0;
  }
  else
  {
    v103 = 0;
    v104 = v165;
    v105 = v163;
    v106 = v12;
    v107 = a8;
    do
    {
      v109 = *v105++;
      v108 = v109;
      v110 = *v106++;
      v111 = v108 >> (v101 - v110);
      v102 += v111;
      v112 = *v104++;
      result = (unsigned __int16)v111 * (__int16)v112;
      v103 += 4 * ((v111 >> 16) * (__int16)v112 + ((int)result >> 16) + (((v112 >> 15) + 1) >> 1) * v111);
      --v107;
    }
    while (v107);
  }
  if (v103 >= 0)
    v113 = v103;
  else
    v113 = -v103;
  v114 = __clz(v113);
  v115 = v103 << (v114 - 1);
  if (v102 >= 0)
    v116 = v102;
  else
    v116 = -v102;
  v117 = __clz(v116);
  v118 = v102 << (v117 - 1);
  v119 = 0x1FFFFFFF / (v118 >> 16);
  v120 = v119 * (v115 >> 16) + ((v119 * (v115 & 0xFFFC)) >> 16);
  v121 = v115 - (((unint64_t)(v120 * (uint64_t)v118) >> 29) & 0xFFFFFFF8);
  v122 = v120 + (v121 >> 16) * v119 + (((v121 & 0xFFFC) * v119) >> 16);
  v123 = v114 - v117;
  if ((v123 + 17) >= 0x20)
    v124 = 0;
  else
    v124 = v122 >> (v123 + 17);
  v125 = (int)0x80000000 >> (-17 - v123);
  if (v122 > v125)
    v125 = v122;
  if (v122 <= (int)(0x7FFFFFFFu >> (-17 - v123)))
    v126 = v125;
  else
    v126 = 0x7FFFFFFFu >> (-17 - v123);
  v127 = v126 << (-17 - v123);
  if (v123 <= -18)
    v128 = v127;
  else
    v128 = v124;
  if (a8 >= 1)
  {
    v129 = 0;
    result = 0x7FFFFFFLL;
    v130 = a8;
    do
    {
      v131 = v12[v129];
      if (v131 > 1)
      {
        v133 = v131 - 2;
        v134 = (int)0x80000000 >> v133;
        v135 = v163[v129];
        if (v135 > (int)0x80000000 >> v133)
          v134 = v163[v129];
        if (v135 > (int)(0x7FFFFFFFu >> v133))
          v134 = 0x7FFFFFFFu >> v133;
        v132 = v134 << v133;
      }
      else
      {
        v132 = (int)v163[v129] >> (2 - v131);
      }
      v136 = (int)v165[v129] >> 2;
      v137 = v128 - v136;
      if (v128 - v136 < 0)
      {
        v140 = __OFSUB__(v137, -134217728);
        if (v137 <= 0xF8000000)
          v137 = -134217728;
        if ((v136 & ~v128) < 0 != v140)
          v139 = 0x7FFFFFF;
        else
          v139 = v137;
      }
      else
      {
        v138 = __OFSUB__(v137, 0x7FFFFFF);
        if (v137 >= 0x7FFFFFF)
          v137 = 0x7FFFFFF;
        if ((v128 & ~v136) < 0 != v138)
          v139 = -134217728;
        else
          v139 = v137;
      }
      v141 = 0;
      v142 = 0;
      v143 = 16 * (6710887 / (v132 + 6553));
      do
      {
        v144 = *(__int16 *)(v11 + 2 * v141);
        if (v144 <= 1638)
          v144 = 1638;
        v165[v141 + 4] = v144;
        v142 += v144;
        ++v141;
      }
      while (v141 != 5);
      v145 = 0;
      v146 = v143 * v139 / v142;
      if (v146 <= -134217728)
        v146 = -134217728;
      if (v146 >= 0x7FFFFFF)
        v147 = 0x7FFFFFF;
      else
        v147 = v146;
      v148 = v147 >> 12;
      v149 = 16 * (v147 & 0xFFF);
      do
      {
        v150 = *(__int16 *)(v11 + 2 * v145) + SLOWORD(v165[v145 + 4]) * v148 + ((SLOWORD(v165[v145 + 4]) * v149) >> 16);
        if (v150 <= -16000)
          v150 = -16000;
        if (v150 >= 28000)
          LOWORD(v150) = 28000;
        *(_WORD *)(v11 + 2 * v145++) = v150;
      }
      while (v145 != 5);
      v11 += 10;
      ++v129;
    }
    while (v129 != v130);
  }
  return result;
}

uint64_t silk_fit_LTP(uint64_t result, uint64_t a2)
{
  uint64_t i;
  int v3;
  unsigned int v4;
  __int16 v5;

  for (i = 0; i != 5; ++i)
  {
    v3 = *(_DWORD *)(result + 4 * i);
    v4 = ((v3 >> 1) + 1) >> 1;
    if (v3 < -131074)
      LOWORD(v4) = 0x8000;
    if (v3 <= 131069)
      v5 = v4;
    else
      v5 = 0x7FFF;
    *(_WORD *)(a2 + 2 * i) = v5;
  }
  return result;
}

_DWORD *silk_warped_LPC_analysis_filter_FIX(_DWORD *result, uint64_t a2, __int16 *a3, uint64_t a4, int a5, int a6, int a7)
{
  uint64_t v7;
  __int16 *v8;
  __int16 *v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  __int16 *v20;
  int *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;

  if (a6 >= 1)
  {
    v7 = 0;
    v8 = &a3[a7];
    v11 = *a3;
    v9 = a3 + 2;
    v10 = v11;
    v12 = *(v8 - 1);
    v13 = a6;
    do
    {
      v14 = result[1];
      v15 = *result + (v14 >> 16) * a5 + (((unsigned __int16)v14 * a5) >> 16);
      v16 = *(__int16 *)(a4 + 2 * v7);
      v17 = result[2];
      v18 = v14 + ((v17 - v15) >> 16) * a5 + (((unsigned __int16)(v17 - v15) * a5) >> 16);
      *result = v16 << 14;
      result[1] = v15;
      v19 = (a7 >> 1) + (v15 >> 16) * v10 + (((unsigned __int16)v15 * v10) >> 16);
      if (a7 >= 3)
      {
        v20 = v9;
        v21 = result + 4;
        v22 = 2;
        do
        {
          v23 = *(v21 - 1);
          v24 = v17 + ((v23 - v18) >> 16) * a5 + (((unsigned __int16)(v23 - v18) * a5) >> 16);
          v25 = v18 >> 16;
          v26 = *(v20 - 1);
          v17 = *v21;
          v27 = (unsigned __int16)v18 * v26;
          v22 += 2;
          *(v21 - 2) = v18;
          *(v21 - 1) = v24;
          v18 = v23 + ((v17 - v24) >> 16) * a5 + (((unsigned __int16)(v17 - v24) * a5) >> 16);
          v19 += v25 * v26 + (v27 >> 16) + (v24 >> 16) * *v20 + (((unsigned __int16)v24 * *v20) >> 16);
          v21 += 2;
          v20 += 2;
        }
        while (v22 < a7);
      }
      result[a7] = v18;
      *(_DWORD *)(a2 + 4 * v7++) = 4 * v16
                                 - ((((v19 + (v18 >> 16) * v12 + (((unsigned __int16)v18 * v12) >> 16)) >> 8) + 1) >> 1);
    }
    while (v7 != v13);
  }
  return result;
}

void silk_prefilter_FIX(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int *v24;
  uint64_t v25;
  int *v26;
  _DWORD *v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  int *v32;
  int v33;
  int v34;
  int v35;
  int *v36;
  int *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  int *v43;
  char *v44;
  _DWORD *v45;
  _BYTE *v46;
  int *v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;

  v53 = a4;
  v48 = a2;
  v54 = *MEMORY[0x24BDAC8D0];
  v6 = *(_DWORD *)(a1 + 8352);
  v7 = *(int *)(a1 + 4612);
  v8 = (4 * v7 + 15) & 0xFFFFFFFFFFFFFFF0;
  bzero((char *)&v42 - v8, 4 * v7);
  v9 = (int *)((char *)&v42 - v8);
  bzero((char *)&v42 - v8, 4 * v7);
  LODWORD(v10) = *(_DWORD *)(a1 + 4604);
  if ((int)v10 >= 1)
  {
    v11 = 0;
    v12 = a1 + 7240;
    v46 = (_BYTE *)(a1 + 4813);
    v47 = (int *)((char *)&v42 - v8);
    v45 = (_DWORD *)(a1 + 8264);
    v43 = v9 + 1;
    v44 = (char *)&v42 - v8 + 4;
    LODWORD(v13) = v7;
    v14 = v53;
    do
    {
      v52 = a3;
      if (*v46 == 2)
        v6 = *(_DWORD *)(v48 + 4 * v11 + 124);
      v15 = v48;
      v16 = v48 + 4 * v11;
      v17 = (__int16)(0x4000 - *(_WORD *)(v16 + 428)) * (*(int *)(v16 + 460) >> 16)
          + (((__int16)(0x4000 - *(_WORD *)(v16 + 428)) * (unsigned __int16)*(_DWORD *)(v16 + 460)) >> 16);
      v18 = *(_DWORD *)(v16 + 396);
      v49 = *(_DWORD *)(v16 + 444);
      v50 = v18;
      v51 = v11;
      v19 = *(__int16 *)(a1 + 4704);
      v20 = *(_DWORD *)(a1 + 4660);
      v53 = v14;
      silk_warped_LPC_analysis_filter_FIX(v45, (uint64_t)v9, (__int16 *)(v48 + 2 * (16 * v11) + 140), v14, v19, v13, v20);
      v21 = (((((410 * *(__int16 *)(v15 + 484) + *(__int16 *)(v16 + 428) * (__int16)v17 + 3355443) >> 16)
             * (__int16)-*(_WORD *)(v16 + 412)
             + (((unsigned __int16)(410 * *(_WORD *)(v15 + 484) + *(_WORD *)(v16 + 428) * v17 + 13107)
               * (__int16)-*(_WORD *)(v16 + 412)) >> 16)) >> 13)
           + 1) >> 1;
      if (v21 <= -32768)
        v21 = -32768;
      if (v21 >= 0x7FFF)
        v21 = 0x7FFF;
      v22 = *v9;
      v23 = ((*(_DWORD *)(v16 + 412) << 12) + 0x8000) >> 16;
      v24 = v47;
      *v47 = *v9 * v23 + v21 * *(_DWORD *)(a1 + 8344);
      v13 = *(unsigned int *)(a1 + 4612);
      if ((int)v13 >= 2)
      {
        v25 = v13 - 1;
        v26 = v43;
        v27 = v44;
        do
        {
          v28 = *v26++;
          *v27++ = v28 * v23 + v22 * v21;
          v22 = v28;
          --v25;
        }
        while (v25);
      }
      v29 = *(_DWORD *)(a1 + 8332);
      v30 = *(_DWORD *)(a1 + 8336);
      v31 = *(_DWORD *)(a1 + 8340);
      *(_DWORD *)(a1 + 8344) = v9[(int)v13 - 1];
      v32 = v52;
      if ((int)v13 >= 1)
      {
        v33 = (__int16)v49;
        v34 = v50 >> 16;
        v35 = (__int16)v50;
        v36 = v24;
        v37 = v52;
        do
        {
          if (v6 < 1)
            v38 = 0;
          else
            v38 = (((v17 >> 2) | (v17 << 15)) >> 16) * *(__int16 *)(v12 + 2 * (((_WORD)v29 + (_WORD)v6 - 1) & 0x1FF))
                + (*(__int16 *)(v12 + 2 * (((_WORD)v29 + (_WORD)v6) & 0x1FF))
                 + *(__int16 *)(v12 + 2 * (((_WORD)v29 + (_WORD)v6 + 510) & 0x1FF)))
                * (__int16)(v17 >> 2);
          v39 = (v30 >> 16) * v34
              + (v31 >> 16) * v35
              + (((unsigned __int16)v30 * v34) >> 16)
              + (((unsigned __int16)v31 * v35) >> 16);
          v40 = *v36++;
          v30 = v40 - 4 * ((v30 >> 16) * v33 + (((unsigned __int16)v30 * v33) >> 16));
          v31 = v30 - 4 * v39;
          v29 = ((_WORD)v29 - 1) & 0x1FF;
          v41 = ((v31 >> 11) + 1) >> 1;
          if (v41 <= -32768)
            LOWORD(v41) = 0x8000;
          if (v31 > 134215679)
            LOWORD(v41) = 0x7FFF;
          *(_WORD *)(v12 + 2 * v29) = v41;
          *v37++ = (((v31 - v38) >> 8) + 1) >> 1;
          --v13;
        }
        while (v13);
        LODWORD(v13) = *(_DWORD *)(a1 + 4612);
      }
      *(_DWORD *)(a1 + 8336) = v30;
      *(_DWORD *)(a1 + 8340) = v31;
      *(_DWORD *)(a1 + 8332) = v29;
      v14 = v53 + 2 * (int)v13;
      a3 = &v32[(int)v13];
      v11 = v51 + 1;
      v10 = *(int *)(a1 + 4604);
    }
    while (v51 + 1 < v10);
  }
  *(_DWORD *)(a1 + 8352) = *(_DWORD *)(v48 + 4 * (int)v10 + 120);
}

uint64_t silk_apply_sine_window(uint64_t result, uint64_t a2, int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  __int16 *v9;
  _WORD *v10;
  int v11;

  v4 = freq_table_Q16[(a4 >> 2) - 4];
  v5 = ((__int16)v4 >> 16) * (__int16)-(__int16)v4 + ((v4 * (__int16)-(__int16)v4) >> 16);
  v6 = (a4 >> 4) + (v5 >> 1) + 0x10000;
  if (a3 == 1)
    v7 = 0;
  else
    v7 = 0x10000;
  if (a3 == 1)
    v6 = (__int16)v4 + (a4 >> 3);
  if (a4 >= 1)
  {
    v8 = 0;
    v9 = (__int16 *)(a2 + 4);
    v10 = (_WORD *)(result + 4);
    do
    {
      *(v10 - 2) = (__PAIR32__((v6 + v7) >> 17, (v6 + v7) >> 1) * *(v9 - 2)) >> 16;
      *(v10 - 1) = (v6 * (unsigned __int16)*(v9 - 1)) >> 16;
      v11 = (v6 >> 16) * (__int16)v5 - v7 + 2 * v6 + (((unsigned __int16)v6 * (__int16)v5) >> 16);
      if (v11 >= 0xFFFF)
        v11 = 0xFFFF;
      v7 = v11 + 1;
      *v10 = (__PAIR32__((v7 + v6) >> 17, (v7 + v6) >> 1) * *v9) >> 16;
      v10[1] = (v7 * (unsigned __int16)v9[1]) >> 16;
      result = (unsigned __int16)v7 * (__int16)v5;
      v6 = (v7 >> 16) * (__int16)v5 - v6 + 2 * v7 + ((int)result >> 16);
      if (v6 >= 0x10000)
        v6 = 0x10000;
      v8 += 4;
      v9 += 4;
      v10 += 4;
    }
    while (v8 < a4);
  }
  return result;
}

void *silk_k2a_Q16(void *__src, uint64_t a2, int a3)
{
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  _BYTE v10[4];
  _BYTE __dst[64];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a3 >= 1)
  {
    v4 = __src;
    v5 = 0;
    v6 = 0;
    v7 = a3;
    do
    {
      if (v6)
      {
        __src = memcpy(__dst, v4, 4 * v6);
        v8 = v5;
        v9 = v4;
        do
        {
          *v9++ += (__int16)*(_DWORD *)(a2 + 4 * v6) * (*(int *)&v10[v8] >> 16)
                 + (((__int16)*(_DWORD *)(a2 + 4 * v6) * (unsigned __int16)*(_DWORD *)&v10[v8]) >> 16)
                 + (((*(int *)(a2 + 4 * v6) >> 15) + 1) >> 1) * *(_DWORD *)&v10[v8];
          v8 -= 4;
        }
        while (v8);
      }
      *((_DWORD *)v4 + v6) = -256 * *(_DWORD *)(a2 + 4 * v6);
      ++v6;
      v5 += 4;
    }
    while (v6 != v7);
  }
  return __src;
}

uint64_t silk_schur(uint64_t a1, unsigned int *a2, int a3)
{
  uint64_t v3;
  int32x2_t *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  float32x2_t *v8;
  float32x2_t v9;
  uint64_t v10;
  int32x2_t *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  _QWORD *v23;
  int v24;
  int v25;
  __int16 v26;
  _BYTE v28[4];
  int v29;
  _QWORD v30[17];

  v30[16] = *MEMORY[0x24BDAC8D0];
  if (*a2 >> 30)
  {
    if ((a3 & 0x80000000) == 0)
    {
      v3 = (a3 + 1);
      v4 = (int32x2_t *)v28;
      do
      {
        v5 = *a2++;
        *v4++ = vdup_n_s32(v5 >> 1);
        --v3;
      }
      while (v3);
      goto LABEL_14;
    }
LABEL_32:
    LODWORD(v14) = 0;
    goto LABEL_37;
  }
  v6 = __clz(*a2) - 2;
  if (v6)
  {
    if (a3 < 0)
      goto LABEL_32;
    v10 = (a3 + 1);
    v11 = (int32x2_t *)v28;
    do
    {
      v12 = *a2++;
      *v11++ = vdup_n_s32(v12 << v6);
      --v10;
    }
    while (v10);
  }
  else
  {
    if (a3 < 0)
      goto LABEL_32;
    v7 = (a3 + 1);
    v8 = (float32x2_t *)v28;
    do
    {
      v9 = vld1_dup_f32((const float *)a2++);
      *v8++ = v9;
      --v7;
    }
    while (v7);
  }
LABEL_14:
  if (a3 < 1)
    goto LABEL_32;
  v13 = 0;
  v14 = 0;
  v15 = a3;
  while (1)
  {
    v16 = v14++;
    v17 = *(_DWORD *)&v28[8 * v14];
    v18 = v17 >= 0 ? *(_DWORD *)&v28[8 * v14] : -v17;
    if (v18 >= v29)
      break;
    v19 = v29 >> 15;
    if (v29 >> 15 <= 1)
      v19 = 1;
    v20 = v17 / v19;
    if (-v20 < -32768 || v20 == 0x8000)
      v21 = -32768;
    else
      v21 = -v20;
    if (v21 >= 0x7FFF)
      v21 = 0x7FFF;
    *(_WORD *)(a1 + 2 * v16) = v21;
    if ((int)v16 < a3)
    {
      v22 = v15;
      v23 = v30;
      do
      {
        v24 = v23[v13];
        v25 = *((_DWORD *)v23 - 1);
        LODWORD(v23[v13]) = v24 + (__int16)(v25 >> 15) * v21 + ((2 * (v25 & 0x7FFF) * v21) >> 16);
        *((_DWORD *)v23++ - 1) = v25 + (__int16)(v24 >> 15) * v21 + ((2 * (v24 & 0x7FFF) * v21) >> 16);
        --v22;
      }
      while (v22);
    }
    --v15;
    ++v13;
    if (v14 == a3)
      goto LABEL_39;
  }
  if (v17 > 0)
    v26 = -32440;
  else
    v26 = 32440;
  *(_WORD *)(a1 + 2 * v16) = v26;
LABEL_37:
  if ((int)v14 < a3)
    bzero((void *)(a1 + 2 * v14), 2 * (~(_DWORD)v14 + a3) + 2);
LABEL_39:
  if (v29 <= 1)
    return 1;
  else
    return v29;
}

void silk_find_pitch_lags_FIX(uint64_t a1, uint64_t a2, __int16 *a3, uint64_t a4)
{
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  __int16 *v32;
  int *v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  __int16 v38;
  __int16 *v39;
  char *v40;
  int v41;
  int v42;
  char v43;
  uint64_t v44;
  __int16 *v45;
  char *v46;
  int v47;
  __int16 v48[16];
  _BYTE __src[64];
  __int16 v50[16];
  unsigned int v51[17];
  uint64_t v52;

  v45 = a3;
  v52 = *MEMORY[0x24BDAC8D0];
  v46 = (char *)(a1 + 4565);
  v47 = 0;
  v6 = *(_DWORD *)(a1 + 4620);
  v7 = *(int *)(a1 + 4616);
  v8 = *(_DWORD *)(a1 + 4608) + v6 + v7;
  v9 = a4 - 2 * v7;
  v10 = *(int *)(a1 + 4572);
  v11 = (char *)&v44 - ((2 * v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v11, 2 * v10);
  v12 = v9 + 2 * v8 - 2 * v10;
  silk_apply_sine_window((uint64_t)v11, v12, 1, v6);
  v13 = *(int *)(a1 + 4620);
  v14 = (const void *)(v12 + 2 * v13);
  v15 = *(_DWORD *)(a1 + 4572) - 2 * v13;
  memcpy(&v11[2 * v13], v14, 2 * v15);
  silk_apply_sine_window((uint64_t)&v11[2 * v13 + 2 * v15], (uint64_t)v14 + 2 * v15, 2, v13);
  silk_autocorr(v51, &v47, v11, *(_DWORD *)(a1 + 4572), *(_DWORD *)(a1 + 4672) + 1);
  v51[0] += 66 * ((int)v51[0] >> 16) + ((66 * LOWORD(v51[0])) >> 16) + 1;
  v16 = silk_schur((uint64_t)v50, v51, *(_DWORD *)(a1 + 4672));
  if (v16 <= 1)
    v17 = 1;
  else
    v17 = v16;
  if ((v51[0] & 0x80000000) == 0)
    v18 = v51[0];
  else
    v18 = -v51[0];
  v19 = __clz(v18);
  v20 = __clz(v17);
  v21 = v17 << (v20 - 1);
  v22 = 0x1FFFFFFF / (v21 >> 16);
  v23 = ((int)(v51[0] << (v19 - 1)) >> 16) * v22 + (((unsigned __int16)(v51[0] << (v19 - 1)) * v22) >> 16);
  v24 = (v51[0] << (v19 - 1)) - (((unint64_t)(v23 * (uint64_t)v21) >> 29) & 0xFFFFFFF8);
  v25 = v23 + (v24 >> 16) * v22 + (((unsigned __int16)v24 * v22) >> 16);
  v26 = v19 - v20;
  if (v19 - v20 + 29 >= 0x30)
    v27 = 0;
  else
    v27 = v25 >> (v26 + 13);
  v28 = (int)0x80000000 >> (-13 - v26);
  if (v25 > v28)
    v28 = v25;
  if (v25 <= (int)(0x7FFFFFFFu >> (-13 - v26)))
    v29 = v28;
  else
    v29 = 0x7FFFFFFFu >> (-13 - v26);
  v30 = v29 << (-13 - v26);
  if (v26 > -14)
    v30 = v27;
  *(_DWORD *)(a2 + 492) = v30;
  silk_k2a(__src, v50, *(_DWORD *)(a1 + 4672));
  v31 = *(_DWORD *)(a1 + 4672);
  if (v31 >= 1)
  {
    v32 = v48;
    v33 = (int *)__src;
    v34 = *(unsigned int *)(a1 + 4672);
    do
    {
      v36 = *v33++;
      v35 = v36;
      v37 = v36 >> 12;
      if (v36 < -134217728)
        LOWORD(v37) = 0x8000;
      if (v35 <= 0x7FFFFFF)
        v38 = v37;
      else
        v38 = 0x7FFF;
      *v32++ = v38;
      --v34;
    }
    while (v34);
  }
  silk_bwexpander(v48, v31, 64881);
  v39 = v45;
  silk_LPC_analysis_filter(v45, v9, (uint64_t)v48, v8, *(_DWORD *)(a1 + 4672));
  v40 = v46;
  if (v46[248] && !*(_DWORD *)(a1 + 4696))
  {
    v41 = -1228 * (*v46 >> 1)
        - (((int)(*(_DWORD *)(a1 + 4672) << 16) >> 11)
         + 4 * (__int16)*(_DWORD *)(a1 + 4556))
        + ((52430 * (__int16)*(_DWORD *)(a1 + 4556)) >> 16)
        - *(__int16 *)(a1 + 4760)
        + ((63899 * *(__int16 *)(a1 + 4760)) >> 16)
        + 4915;
    if (v41 <= -32768)
      v41 = -32768;
    if (v41 >= 0x7FFF)
      v42 = 0x7FFF;
    else
      v42 = v41;
    if (silk_pitch_analysis_core(v39, (void *)(a2 + 124), (_WORD *)(a1 + 4810), (_BYTE *)(a1 + 4812), (__int16 *)(a1 + 9796), *(_DWORD *)(a1 + 4568), *(_DWORD *)(a1 + 4676), v42, *(_DWORD *)(a1 + 4600), *(_DWORD *)(a1 + 4668), *(_DWORD *)(a1 + 4604)))v43 = 1;
    else
      v43 = 2;
    v40[248] = v43;
  }
  else
  {
    *(_QWORD *)(a2 + 132) = 0;
    *(_QWORD *)(a2 + 124) = 0;
    *(_WORD *)(a1 + 4810) = 0;
    v40[247] = 0;
    *(_DWORD *)(a1 + 9796) = 0;
  }
}

_DWORD *silk_warped_autocorrelation_FIX(_DWORD *result, _DWORD *a2, uint64_t a3, __int16 a4, int a5, int a6)
{
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  signed int v19;
  unsigned int v20;
  char v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  _OWORD v29[8];
  uint64_t v30;
  _OWORD v31[4];
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v30 = 0;
  memset(v29, 0, sizeof(v29));
  if (a5 < 1)
  {
    v17 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = a4;
    v9 = a5;
    do
    {
      v10 = *(__int16 *)(a3 + 2 * v7) << 14;
      if (a6 >= 1)
      {
        v11 = 0;
        v12 = (int *)v31 + 1;
        v13 = (_QWORD *)v29 + 1;
        do
        {
          v14 = *v12;
          v15 = v6 + ((*v12 - v10) >> 16) * v8 + (((unsigned __int16)(*(_WORD *)v12 - v10) * v8) >> 16);
          *(v12 - 1) = v10;
          v16 = v31[0];
          *(v13 - 1) += (SLODWORD(v31[0]) * (uint64_t)v10) >> 18;
          v11 += 2;
          v6 = v12[1];
          v10 = v14 + ((v6 - v15) >> 16) * v8 + (((unsigned __int16)(v6 - v15) * v8) >> 16);
          *v12 = v15;
          v12 += 2;
          *v13 += (v16 * (uint64_t)v15) >> 18;
          v13 += 2;
        }
        while (v11 < a6);
      }
      *((_DWORD *)v31 + a6) = v10;
      v6 = v31[0];
      *((_QWORD *)v29 + a6) += (SLODWORD(v31[0]) * (uint64_t)v10) >> 18;
      ++v7;
    }
    while (v7 != v9);
    v17 = *(_QWORD *)&v29[0];
  }
  v18 = HIDWORD(v17);
  v19 = __clz(v17) + 32;
  v20 = __clz(v18);
  if ((_DWORD)v18)
    v19 = v20;
  if (v19 <= 13)
    v19 = 13;
  if (v19 >= 55)
    v19 = 55;
  *a2 = 25 - v19;
  if (v19 <= 0x22)
  {
    if ((a6 & 0x80000000) == 0)
    {
      v25 = 35 - v19;
      v26 = (a6 + 1);
      v27 = (uint64_t *)v29;
      do
      {
        v28 = *v27++;
        *result++ = v28 >> v25;
        --v26;
      }
      while (v26);
    }
  }
  else if ((a6 & 0x80000000) == 0)
  {
    v21 = v19 - 35;
    v22 = (a6 + 1);
    v23 = (uint64_t *)v29;
    do
    {
      v24 = *v23++;
      *result++ = v24 << v21;
      --v22;
    }
    while (v22);
  }
  return result;
}

uint64_t BET3FLT__InitTreeSet(int a1, void *__b)
{
  cstdlib_memset(__b, 0, 0xD0uLL);
  return 0;
}

void *BET3FLT__DeInitTreeSet(void *result, char *__b)
{
  uint64_t v3;
  uint64_t i;
  uint64_t v5;

  if (__b)
  {
    v3 = (uint64_t)result;
    for (i = 104; i != 184; i += 8)
    {
      v5 = *(_QWORD *)&__b[i];
      if (v5)
        heap_Free(*(_QWORD **)(v3 + 8), v5);
    }
    return cstdlib_memset(__b, 0, 0xD0uLL);
  }
  return result;
}

uint64_t BET3FLT__LoadTreesFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  _WORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  unsigned __int16 v30;

  v8 = a1;
  v30 = 0;
  v9 = *a4;
  if (a4[4] - v9 >= 8 && *(_BYTE *)(*((_QWORD *)a4 + 1) + v9) == 48)
  {
    *a4 = v9 + 2;
    v12 = a3;
    v13 = (_WORD *)(a2 + 2 * a3 + 184);
    if (BET3FLT__xfread_BET3(v13, 2u, 1, a4) == 1
      && BET3FLT__xfread_BET3(&v30, 2u, 1, a4) == 1
      && BET3FLT__xfread_BET3((void *)(a2 + 2 * v12), 2u, 1, a4) == 1)
    {
      v14 = BET3FLT__xfread2ptr_BET3((_QWORD *)(a2 + 8 * v12 + 24), 1u, v30, a4);
      if (v14 == v30)
      {
        if ((*a4 & 1) != 0)
          ++*a4;
        v15 = heap_Calloc(*(_QWORD **)(v8 + 8), 16, (unsigned __int16)*v13);
        v21 = a2 + 8 * v12;
        *(_QWORD *)(v21 + 104) = v15;
        v22 = (uint64_t *)(v21 + 104);
        if (!v15)
        {
          BET3FLT__log_select_Error(v8, 55000, (uint64_t)"LoadTreesFile : out of memory for type %s\n", v16, v17, v18, v19, v20);
          return 2229280778;
        }
        if (!*v13)
          return 0;
        v23 = 0;
        v24 = 0;
        while (BET3FLT__xfread_BET3((void *)(v15 + v23), 2u, 1, a4) == 1)
        {
          if (BET3FLT__xfread_BET3((void *)(*v22 + v23 + 2), 2u, 1, a4) != 1)
            break;
          v25 = BET3FLT__xfread2ptr_BET3((_QWORD *)(*v22 + v23 + 8), 2u, 3 * *(unsigned __int16 *)(*v22 + v23 + 2), a4);
          v15 = *v22;
          if (v25 != 3 * *(unsigned __int16 *)(*v22 + v23 + 2))
            break;
          v26 = 0;
          ++v24;
          v23 += 16;
          if (v24 >= (unsigned __int16)*v13)
            return v26;
        }
        v26 = 2229280772;
        v27 = "LoadTreesFile : corrupt tree nodes for type %s, state %u\n";
        a1 = v8;
        v28 = 55015;
      }
      else
      {
        v26 = 2229280772;
        v27 = "LoadTreesFile : corrupt tree questions for type %s\n";
        a1 = v8;
        v28 = 55013;
      }
    }
    else
    {
      v26 = 2229280772;
      v27 = "LoadTreesFile : corrupt tree header for type %s\n";
      a1 = v8;
      v28 = 55012;
    }
  }
  else
  {
    v26 = 2229280772;
    v27 = "LoadTreesFile : invalid tree data version for type %s\n";
    v28 = 55011;
  }
  BET3FLT__log_select_Error(a1, v28, (uint64_t)v27, (uint64_t)a4, a5, a6, a7, a8);
  return v26;
}

uint64_t BET3FLT__TreeSearch(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  unsigned __int8 v16;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;

  LOWORD(v5) = 0;
  v6 = a3 + 8 * a4;
  v7 = *(_QWORD *)(v6 + 24);
  v8 = *(_QWORD *)(*(_QWORD *)(v6 + 104) + 16 * a5 + 8);
  v9 = a2 + 2;
  v10 = a2 + 1;
  while (2)
  {
    v11 = -(uint64_t)(__int16)v5;
    v12 = (unsigned __int16 *)(v8 + 6 * (int)v11);
    v13 = (unsigned __int8 *)(v7 + *v12);
    v14 = *v13;
    v15 = v13[1];
    v5 = v12[1];
    switch(*v13)
    {
      case 0xFCu:
        if (a2 < 2)
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + (a2 - 2));
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFDu:
        if (a2 < 1)
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + (a2 - 1));
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFEu:
        if ((int)v10 >= *(__int16 *)(a1 + 10))
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v10);
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFFu:
        if ((int)v9 >= *(__int16 *)(a1 + 10))
        {
LABEL_20:
          v16 = -1;
          if (v13[1])
            goto LABEL_24;
        }
        else
        {
          v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v9);
          if (v13[1])
            goto LABEL_24;
        }
        goto LABEL_39;
      default:
        if ((_DWORD)v14 == 3)
        {
          v17 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 1784) + 2 * a2);
          v18 = v17 > 0x19;
          v16 = 10 * v17;
          if (v18)
            v16 = -1;
          if (!v13[1])
            goto LABEL_39;
        }
        else
        {
          v19 = *(_QWORD *)(a1 + 8 * v14 + 16);
          if (!v19)
            goto LABEL_39;
          v16 = *(_BYTE *)(v19 + a2);
          if (!v13[1])
            goto LABEL_39;
        }
LABEL_24:
        v20 = v13 + 2;
        if (v15 == 255)
        {
          if (*v20 <= v16 && v20[1] >= v16)
            goto LABEL_30;
        }
        else
        {
          v21 = v15 - 1;
          if (v21)
          {
            v22 = 0;
            while (1)
            {
              v23 = v21 + v22;
              if (v21 + v22 < 0 != __OFADD__(v21, v22))
                ++v23;
              v24 = v23 >> 1;
              v25 = v20[v24];
              if (v25 == v16)
                break;
              if (v16 < v25)
                v21 = v24 - 1;
              else
                v22 = v24 + 1;
              if (v22 > v21)
                goto LABEL_39;
            }
LABEL_30:
            v5 = *(unsigned __int16 *)(v8 + 6 * (int)v11 + 4);
            goto LABEL_39;
          }
          if (*v20 == v16)
            goto LABEL_30;
        }
LABEL_39:
        if ((v5 & 0x8000) != 0)
          continue;
        return v5;
    }
  }
}

uint64_t BET3FLT__select_bet3_FeatureExtractObjOpen(_WORD *a1, int a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t inited;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v15;
  uint64_t v16;

  v16 = 0;
  *a5 = 0;
  inited = InitRsrcFunction(a1, a2, &v16);
  if ((inited & 0x80000000) == 0)
  {
    v9 = (_QWORD *)heap_Calloc(*(_QWORD **)(v16 + 8), 1, 24);
    if (v9)
    {
      *v9 = v16;
      v9[1] = a3;
      v9[2] = a4;
      *a5 = v9;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v10, v11, v12, v13, v15);
      return 2229280778;
    }
  }
  return inited;
}

uint64_t BET3FLT__select_bet3_FeatureExtractObjClose(uint64_t a1)
{
  if (a1)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), a1);
  return 0;
}

uint64_t BET3FLT__select_bet3_FeatureExtractProcessStart(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *__b, _DWORD *a6)
{
  char *__s1;

  __s1 = 0;
  cstdlib_memset(__b, 0, 0xE48uLL);
  *__b = a2;
  if ((paramc_ParamGetStr(*(_QWORD *)(*a1 + 40), (uint64_t)"voicemodel", &__s1) & 0x80000000) == 0
    && !cstdlib_strcmp(__s1, "bet3"))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1[2] + 272))(a3, a4, 128, 3, 0, 0);
  }
  return usextract_ProcessStart(*a1, (uint64_t)"SELECT_BET3", a1[2], a3, a4, (uint64_t)__b, a6);
}

uint64_t BET3FLT__select_bet3_FeatureExtractProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, uint64_t a10, uint64_t *a11, _DWORD *a12)
{
  uint64_t v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int GenericFeatureLayers;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  const char **v58;
  size_t v59;
  unsigned int Index;
  unsigned int v61;
  uint64_t v62;
  const char *v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t j;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unsigned int v80;
  unint64_t v81;
  uint64_t v82;
  _OWORD *v83;
  _OWORD *v84;
  __int128 v85;
  _DWORD *v86;
  _OWORD *v87;
  _OWORD *v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t result;
  unsigned int v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  uint64_t v107;
  uint64_t v108;
  char v109;
  char v110;
  unsigned int v111[4];
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  v15 = *a1;
  if (a11)
    v16 = a12 == 0;
  else
    v16 = 1;
  v17 = !v16;
  if (!v16)
  {
    *a11 = 0;
    *a12 = 0;
  }
  v18 = 0;
  v19 = 0;
  v20 = *(__int16 *)(a10 + 10);
  do
  {
    if (*(_BYTE *)(*(_QWORD *)a10 + 2748 + v18) == 1)
      ++v19;
    ++v18;
  }
  while (v18 != 218);
  v21 = heap_Calloc(*(_QWORD **)(v15 + 8), (v19 * v20), 1);
  if (!v21)
    goto LABEL_119;
  v26 = v21;
  v105 = v17;
  v107 = a4;
  v108 = a3;
  for (i = 0; i != 218; ++i)
  {
    v28 = *(_QWORD *)a10;
    v29 = *(unsigned __int8 *)(*(_QWORD *)a10 + i + 2748);
    if (*(_BYTE *)(*(_QWORD *)a10 + i + 2748))
    {
      if (v29 == 2)
      {
        v30 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 2);
        *(_QWORD *)(a10 + 8 * i + 1760) = v30;
        if (!v30)
          goto LABEL_43;
      }
      else if (v29 == 1)
      {
        *(_QWORD *)(a10 + 8 * i + 16) = v26;
        v26 += v20;
      }
      else
      {
        switch((int)i)
        {
          case '.':
            v31 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 9);
            *(_QWORD *)(a10 + 3560) = v31;
            if (!v31)
              goto LABEL_43;
            continue;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_28;
          case '3':
            v33 = *(unsigned __int16 *)(v28 + 2966);
            if (v33)
            {
              v34 = heap_Calloc(*(_QWORD **)(v15 + 8), (v33 * v20), 4);
              *(_QWORD *)(a10 + 3568) = v34;
              if (!v34)
                goto LABEL_43;
            }
            continue;
          case '4':
            v35 = *(unsigned __int16 *)(v28 + 2966);
            if (v35)
            {
              v36 = heap_Calloc(*(_QWORD **)(v15 + 8), (v35 * v20), 4);
              *(_QWORD *)(a10 + 3576) = v36;
              if (!v36)
                goto LABEL_43;
            }
            continue;
          case '5':
            v37 = *(unsigned __int16 *)(v28 + 3360);
            if (v37)
            {
              v38 = heap_Calloc(*(_QWORD **)(v15 + 8), (v37 * v20), 4);
              *(_QWORD *)(a10 + 3584) = v38;
              if (!v38)
                goto LABEL_43;
            }
            continue;
          case '6':
            v39 = *(unsigned __int16 *)(v28 + 3360);
            if (v39)
            {
              v40 = heap_Calloc(*(_QWORD **)(v15 + 8), (v39 * v20), 4);
              *(_QWORD *)(a10 + 3592) = v40;
              if (!v40)
                goto LABEL_43;
            }
            continue;
          case '8':
            v41 = *(unsigned __int16 *)(v28 + 2966);
            if (v41)
            {
              v42 = heap_Calloc(*(_QWORD **)(v15 + 8), (v41 * v20), 1);
              *(_QWORD *)(a10 + 3600) = v42;
              if (!v42)
                goto LABEL_43;
            }
            continue;
          default:
            if ((_DWORD)i == 24)
            {
              v32 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 8);
              *(_QWORD *)(a10 + 3552) = v32;
              if (!v32)
              {
LABEL_43:
                v43 = -2065686518;
                log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v22, v23, v24, v25, v101);
                goto LABEL_44;
              }
            }
            else
            {
LABEL_28:
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"SELECT_BET3", 55007, (uint64_t)"%s%u", v22, v23, v24, v25, "feature");
            }
            break;
        }
      }
    }
  }
  v44 = *(unsigned __int16 *)(*(_QWORD *)a10 + 3578);
  if (v44 >= 4)
  {
    log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, (uint64_t)"Invalid number of states per phoneme", v22, v23, v24, v25, "%s%u");
    v43 = -2065686513;
    goto LABEL_122;
  }
  v45 = (void *)heap_Calloc(*(_QWORD **)(v15 + 8), v44 * v20, 4);
  *(_QWORD *)(a10 + 3608) = v45;
  if (!v45)
  {
    v43 = -2065686518;
    log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v46, v47, v48, v49, v101);
LABEL_122:
    if (!a12)
      goto LABEL_127;
    goto LABEL_123;
  }
  if (*(unsigned __int16 *)(*(_QWORD *)a10 + 3578) * (_DWORD)v20)
    memset(v45, 255, 4 * *(unsigned __int16 *)(*(_QWORD *)a10 + 3578) * v20);
  GenericFeatureLayers = usextract_allocateGenericFeatureLayers(*a1, (uint64_t)"SELECT_BET3", (_QWORD *)a10, v20);
  if (GenericFeatureLayers < 0)
  {
    v43 = GenericFeatureLayers;
    if (!a12)
      goto LABEL_127;
    goto LABEL_123;
  }
  v43 = usextract_Process(*a1, (uint64_t)"SELECT_BET3", a1[2], a3, a4, a10, v51, v52);
  if (v43 < 0)
    goto LABEL_122;
  if (*(_QWORD *)(a10 + 3504))
  {
    v53 = **(const char ***)(*(_QWORD *)a10 + 3336);
    if (v53)
    {
      v54 = 0;
      v55 = 1;
      do
      {
        v56 = cstdlib_strncmp(v53, "INNO_", 5uLL);
        v57 = *(_QWORD *)a10;
        if (v56)
        {
          v58 = *(const char ***)(*(_QWORD *)(v57 + 3344) + 8 * v54);
          v59 = cstdlib_strlen("FEATIDX");
          Index = usextract_getIndex(v58, "FEATIDX", (unint64_t)&aFeatidx[v59]);
          if (Index == -1)
          {
            if (cstdlib_strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v54), "POS"))
            {
              if (!cstdlib_strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v54), "PHR"))
                *(_QWORD *)(a10 + 512) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
            }
            else
            {
              *(_QWORD *)(a10 + 504) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
            }
          }
          else
          {
            *(_QWORD *)(a10
                      + 8 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a10 + 3352) + 8 * v54) + Index)
                      + 16) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
          }
        }
        else
        {
          v61 = cstdlib_atoi((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v57 + 3336) + 8 * v54) + 5)) + 79;
          if (v61 <= 0x5E)
            *(_QWORD *)(a10 + 8 * v61 + 16) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
        }
        v54 = v55;
        v53 = *(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v55++);
      }
      while (v53);
    }
  }
  v102 = *(__int16 *)(a10 + 10);
  v104 = v102 & ~(v102 >> 31);
  if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v15 + 32)) >= 6)
  {
    LH_itoa(0x4Eu, (char *)v111, 0xAu);
    v62 = 0;
    v103 = v43;
    do
    {
      v63 = "application/x-realspeak-usplosives;version=4.0";
      switch((int)v62)
      {
        case 2:
          v110 = 5;
          v109 = 0;
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            (uint64_t)&v110,
            1u,
            0);
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            *(_QWORD *)(a10 + 8 * v62 + 16),
            v104,
            0);
          v43 = v103;
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            (uint64_t)&v109,
            1u,
            0);
          break;
        case 3:
          v63 = "application/x-realspeak-usdurs;version=4.0";
          goto LABEL_72;
        case 4:
          goto LABEL_72;
        case 5:
          v63 = "application/x-realspeak-usmarkers-u16;version=4.0";
LABEL_72:
          v64 = *(unsigned __int8 *)(*(_QWORD *)a10 + v62 + 2748);
          if (v64 == 2)
          {
            log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)v63, *(_QWORD *)(a10 + 8 * v62 + 1760), 2 * v104, 0);
          }
          else if (v64 == 1)
          {
            log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)v63, *(_QWORD *)(a10 + 8 * v62 + 16), v104, 0);
          }
          break;
        default:
          break;
      }
      ++v62;
    }
    while (v62 != 218);
  }
  v65 = *(unsigned int *)(a10 + 3520);
  if ((_DWORD)v65)
  {
    v66 = 0;
    for (j = 0; j < v65; ++j)
    {
      if (*(_DWORD *)(*(_QWORD *)(a10 + 3512) + v66) == 25)
      {
        v111[0] = 0;
        paramc_ParamGetUInt(*(_QWORD *)(v15 + 40), (uint64_t)"finalsentencefound", v111);
        v68 = *(_DWORD *)(*(_QWORD *)(a10 + 3512) + v66 + 24);
        *a9 = v68;
        v43 = paramc_ParamSetInt(*(_QWORD *)(v15 + 40), (uint64_t)"waitfactor", v68);
        if (v43 < 0)
        {
          log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%d%s%x", v69, v70, v71, v72, "parameter");
          goto LABEL_44;
        }
        v65 = *(unsigned int *)(a10 + 3520);
      }
      v66 += 32;
    }
  }
  featextract_adjustSilAudioOrder(a10);
  a4 = v107;
  a3 = v108;
  if (v105)
  {
    v73 = *(_DWORD *)(a10 + 3520);
    v74 = v73 + v104;
    *a12 = v74;
    if (v73 + v104)
    {
      v75 = heap_Calloc(*(_QWORD **)(v15 + 8), v74, 32);
      *a11 = v75;
      if (v75)
      {
        v76 = (void *)heap_Calloc(*(_QWORD **)(v15 + 8), *(__int16 *)(a10 + 10), 2);
        if (v76)
        {
          v77 = (uint64_t)v76;
          cstdlib_memcpy(v76, *(const void **)(a10 + 1800), 2 * *(__int16 *)(a10 + 10));
          if (*a12)
          {
            v78 = 0;
            v79 = 0;
            v80 = 0;
            v81 = 0;
            while (v81 < *(unsigned int *)(a10 + 3520))
            {
              if (v80 >= v104)
              {
                v87 = (_OWORD *)(*a11 + v78);
                v88 = (_OWORD *)(*(_QWORD *)(a10 + 3512) + 32 * v81);
                v89 = v88[1];
                *v87 = *v88;
                v87[1] = v89;
                ++v81;
                goto LABEL_96;
              }
              v82 = v80;
              if (!*(_WORD *)(v77 + 2 * v80))
                goto LABEL_94;
              v83 = (_OWORD *)(*a11 + v78);
              v84 = (_OWORD *)(*(_QWORD *)(a10 + 3512) + 32 * v81);
              v85 = v84[1];
              *v83 = *v84;
              v83[1] = v85;
              ++v81;
              --*(_WORD *)(v77 + 2 * v80);
LABEL_96:
              ++v79;
              v78 += 32;
              if (v79 >= *a12)
                goto LABEL_97;
            }
            v82 = v80;
LABEL_94:
            v86 = (_DWORD *)(*a11 + v78);
            *v86 = 33;
            v86[6] = *(unsigned __int8 *)(*(_QWORD *)(a10 + 32) + v82);
            ++v80;
            goto LABEL_96;
          }
LABEL_97:
          heap_Free(*(_QWORD **)(v15 + 8), v77);
          goto LABEL_98;
        }
      }
LABEL_119:
      v43 = -2065686518;
      log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v22, v23, v24, v25, v101);
      if (!a12)
        goto LABEL_127;
      goto LABEL_123;
    }
  }
LABEL_98:
  if (v102 < 1)
    goto LABEL_122;
  v90 = 0;
  if (v104 <= 1)
    v91 = 1;
  else
    v91 = v104;
  v92 = a2;
  do
  {
    v93 = *(_QWORD *)(a10 + 248);
    if (!*(_BYTE *)(v93 + v90))
      *(_BYTE *)(v93 + v90) = -1;
    v94 = *(_QWORD *)(a10 + 192);
    if (*(_BYTE *)(*(_QWORD *)(a10 + 32) + v90) == 35)
      v95 = 1;
    else
      v95 = 2 * *(_BYTE *)(v94 + v90);
    *(_BYTE *)(v94 + v90) = v95;
    v96 = *(_QWORD *)(a10 + 32);
    if ((unsigned __int16)(v102 & ~(unsigned __int16)(v102 >> 31)) - 1 == v90 && *(_BYTE *)(v96 + v90) == 35)
    {
      v111[0] = 0;
      paramc_ParamGetUInt(*(_QWORD *)(v15 + 40), (uint64_t)"finalsentencefound", v111);
      v97 = 0;
      v98 = *(_QWORD *)(a10 + 1784);
      if (v111[0] != 1)
        v97 = *(unsigned __int16 *)(v98 + 2 * v90) + 200 * *a9;
      if (v97 <= 1)
        v97 = 1;
      if (v97 >= 0xFFFF)
        LOWORD(v97) = -1;
      *(_WORD *)(v98 + 2 * v90) = v97;
      v96 = *(_QWORD *)(a10 + 32);
      v92 = a2;
    }
    *(_BYTE *)(v96 + v90) = *(_BYTE *)(v92 + *(unsigned __int8 *)(v96 + v90) + 7356);
    ++v90;
  }
  while (v91 != v90);
LABEL_44:
  a4 = v107;
  a3 = v108;
  if (a12)
  {
LABEL_123:
    if (a11 && v43 < 0 && *a11)
    {
      heap_Free(*(_QWORD **)(v15 + 8), *a11);
      *a11 = 0;
      *a12 = 0;
    }
  }
LABEL_127:
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(a1[2] + 64))(a3, a4);
  if ((int)result >= 0 || v43 <= -1)
    return v43;
  else
    return result;
}

uint64_t BET3FLT__select_bet3_FeatureExtractProcessEnd(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!*a2)
    return 0;
  v4 = *a1;
  v5 = usextract_ProcessEnd(*a1, (uint64_t)"SELECT_BET3", (uint64_t)a2);
  usextract_freeGenericFeatureLayers((_QWORD *)*a1, (uint64_t)"SELECT_BET3", a2);
  v10 = 0;
  v11 = 1;
  do
  {
    v12 = *(unsigned __int8 *)(*a2 + v10 + 2748);
    if (*(_BYTE *)(*a2 + v10 + 2748))
    {
      if (v12 == 2)
      {
        v14 = a2[v10 + 220];
        if (v14)
LABEL_11:
          heap_Free(*(_QWORD **)(v4 + 8), v14);
      }
      else if (v12 == 1)
      {
        if (v11)
        {
          v13 = a2[v10 + 2];
          if (v13)
            heap_Free(*(_QWORD **)(v4 + 8), v13);
          v11 = 0;
        }
      }
      else
      {
        switch((int)v10)
        {
          case '.':
            v14 = a2[445];
            if (v14)
              goto LABEL_11;
            break;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_20;
          case '3':
            v14 = a2[446];
            if (v14)
              goto LABEL_11;
            break;
          case '4':
            v14 = a2[447];
            if (v14)
              goto LABEL_11;
            break;
          case '5':
            v14 = a2[448];
            if (v14)
              goto LABEL_11;
            break;
          case '6':
            v14 = a2[449];
            if (v14)
              goto LABEL_11;
            break;
          case '8':
            v14 = a2[450];
            if (v14)
              goto LABEL_11;
            break;
          default:
            if ((_DWORD)v10 == 24)
            {
              v14 = a2[444];
              if (v14)
                goto LABEL_11;
            }
            else
            {
LABEL_20:
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"SELECT_BET3", 55010, (uint64_t)"%s%u", v6, v7, v8, v9, "feature");
            }
            break;
        }
      }
    }
    ++v10;
  }
  while (v10 != 218);
  v15 = a2[451];
  if (v15)
    heap_Free(*(_QWORD **)(v4 + 8), v15);
  cstdlib_memset(a2, 0, 8uLL);
  return v5;
}

float BET3FLT__mul_int32_Q8_24_to_int32(float a1, float a2)
{
  return a1 * a2;
}

float BET3FLT__mul_int32_Q8_24_to_Q8_24(float a1, float a2)
{
  return a1 * a2;
}

float BET3FLT__mul_Q18_14_Q1_15_to_Q18_14(float a1, float a2)
{
  return a1 * a2;
}

float BET3FLT__div_int32_int32_to_Q8_24(float a1, float a2)
{
  return a1 / a2;
}

float BET3FLT__div_Q8_24_Q12_20_to_Q8_24(float a1, float a2)
{
  return a1 / a2;
}

float BET3FLT__div_Q18_14_Q18_14_to_Q18_14(float a1, float a2)
{
  return a1 / a2;
}

uint64_t BET3FLT__LoadModelFile(uint64_t a1, unsigned int *a2, int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  int *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int *v28;
  int *v29;
  uint64_t v30;
  unsigned int *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  BOOL v46;
  unsigned int *v47;
  int *v48;
  unsigned int v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  unsigned int *v56;
  unsigned int *v57;
  unsigned int *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;

  v5 = a1;
  v6 = a3;
  if (a2[a3 + 84])
  {
    v7 = &a2[a3];
    v9 = v7[32];
    v8 = (int *)(v7 + 32);
    v10 = heap_Calloc(*(_QWORD **)(a1 + 8), v9, 8);
    *((_QWORD *)a2 + 21) = v10;
    if (!v10)
      return 2229280778;
    if (*v8 >= 1)
    {
      v11 = 0;
      v12 = 0;
      v13 = (int *)(a2 + 11);
      while (1)
      {
        v14 = (unsigned int *)(a4 + 24 * v11);
        if (BET3FLT__xfread_BET3(a2, 4u, 1, v14) != 1 || (*a2 & 0x80000000) != 0)
        {
          v67 = "LoadModelFile: the number of HMM states is illegal for %s %d\n";
          v68 = v5;
          v69 = 55020;
          goto LABEL_67;
        }
        if (BET3FLT__xfread_BET3(a2 + 11, 4u, 1, v14) != 1 || (v20 = *v13, *v13 < 0))
        {
          v67 = "LoadModelFile: the number of PDFs is illegal for %s %d\n";
          v68 = v5;
          v69 = 55021;
          goto LABEL_67;
        }
        if (!v12)
        {
          v21 = heap_Calloc(*(_QWORD **)(v5 + 8), (*v8 * v20), 8);
          if (!v21)
            return 2229280778;
          v12 = v21;
          v20 = *v13;
        }
        v22 = v6;
        *(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) = v12 + 8 * v20 * (int)v11;
        *(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) -= 8;
        if (v20 >= 1)
          break;
LABEL_16:
        ++v11;
        v6 = v22;
        if (v11 >= *v8)
          goto LABEL_17;
      }
      v23 = 0;
      v24 = *a2;
      v25 = 8;
      while (1)
      {
        v26 = BET3FLT__xfread2ptr_BET3((_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) + v25), 4u, (2 * v24), v14);
        v24 = *a2;
        if (v26 != 2 * *a2)
          break;
        v27 = *(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) + 8 * v23;
        *(_QWORD *)(v27 + 8) -= 8;
        ++v23;
        v25 += 8;
        if (v23 >= (int)a2[11])
          goto LABEL_16;
      }
      v67 = "LoadModelFile: PDF read failed for %s %d\n";
      v68 = v5;
      v69 = 55022;
      goto LABEL_67;
    }
  }
LABEL_17:
  v28 = &a2[v6];
  if (v28[94])
  {
    v29 = (int *)(v28 + 32);
    v30 = heap_Calloc(*(_QWORD **)(v5 + 8), v28[32], 8);
    v31 = &a2[2 * v6];
    *((_QWORD *)v31 + 22) = v30;
    v32 = v31 + 44;
    v33 = 2229280778;
    if (!v30)
      return v33;
    v73 = heap_Calloc(*(_QWORD **)(v5 + 8), *a2 * *v29, 8);
    if (!v73)
      return v33;
    if (*v29 >= 1)
    {
      v34 = 0;
      v35 = &a2[v6 + 1];
      v36 = &a2[2 * v6 + 12];
      v71 = v5;
      v74 = v6;
      while (1)
      {
        v37 = (unsigned int *)(a4 + 24 * v34);
        if (BET3FLT__xfread_BET3(v35, 4u, 1, v37) != 1 || (*v35 & 0x80000000) != 0)
        {
          v67 = "LoadModelFile: the vector size is illegal for %s %d\n";
          v68 = v5;
          v69 = 55023;
          goto LABEL_67;
        }
        v38 = BET3FLT__xfread2ptr_BET3(v36, 4u, *a2, v37);
        if (v38 != *a2)
        {
          v67 = "LoadModelFile: reading the number of PDFs failed for %s %d\n";
          v68 = v5;
          v69 = 55024;
          goto LABEL_67;
        }
        v39 = *(_QWORD *)v36;
        *(_QWORD *)v36 -= 8;
        if (v38 > 0)
          break;
        *(_QWORD *)(*v32 + 8 * v34) = v73 + 8 * v38 * (int)v34;
        *(_QWORD *)(*v32 + 8 * v34) -= 16;
LABEL_34:
        ++v34;
        v5 = v71;
        v6 = v74;
        if (v34 >= *v29)
          goto LABEL_35;
      }
      v40 = 0;
      do
      {
        if ((*(_DWORD *)(v39 + 4 * v40) & 0x80000000) != 0)
        {
          v67 = "LoadModelFile: the number of PDFs for %s at state %d is illegal\n";
          v68 = v5;
          v69 = 55025;
          goto LABEL_67;
        }
        ++v40;
      }
      while ((v38 + 2) - 2 != v40);
      *(_QWORD *)(*v32 + 8 * v34) = v73 + 8 * v38 * (int)v34;
      *(_QWORD *)(*v32 + 8 * v34) -= 16;
      v41 = *(_QWORD *)v36;
      v42 = *v35;
      v43 = 16;
      v44 = 2;
      while (1)
      {
        v45 = BET3FLT__xfread2ptr_BET3((_QWORD *)(*(_QWORD *)(*v32 + 8 * v34) + v43), 4u, 2 * *(_DWORD *)(v41 + 4 * v44) * v42, v37);
        v41 = *(_QWORD *)v36;
        v42 = *v35;
        if (v45 != 2 * *(_DWORD *)(*(_QWORD *)v36 + 4 * v44) * *v35)
          break;
        v43 += 8;
        v46 = v44++ <= (int)*a2;
        if (!v46)
          goto LABEL_34;
      }
      v67 = "LoadModelFile: PDF read failed for %s %d\n";
      v68 = v71;
      v69 = 55026;
      goto LABEL_67;
    }
  }
LABEL_35:
  if (!v28[104])
    return 0;
  v47 = &a2[v6];
  v49 = v47[32];
  v48 = (int *)(v47 + 32);
  v50 = heap_Calloc(*(_QWORD **)(v5 + 8), v49, 8);
  v75 = v6;
  v51 = &a2[2 * v6];
  *((_QWORD *)v51 + 32) = v50;
  v33 = 2229280778;
  if (v50)
  {
    v52 = heap_Calloc(*(_QWORD **)(v5 + 8), *a2 * *v48, 8);
    if (v52)
    {
      if (*v48 >= 1)
      {
        v53 = v52;
        v54 = 0;
        v55 = v51 + 64;
        v56 = &a2[v75 + 1];
        v57 = &a2[2 * v75 + 12];
        v72 = v5;
        while (1)
        {
          v58 = (unsigned int *)(a4 + 24 * v54);
          if (BET3FLT__xfread_BET3(v56, 4u, 1, v58) != 1 || (*v56 & 0x80000000) != 0)
          {
            v67 = "LoadModelFile: the vector size is illegal for %s %d\n";
            v68 = v5;
            v69 = 55027;
            goto LABEL_67;
          }
          v59 = BET3FLT__xfread2ptr_BET3(v57, 4u, *a2, v58);
          if (v59 != *a2)
          {
            v67 = "LoadModelFile: reading the number of PDFs failed for %s %d\n";
            v68 = v5;
            v69 = 55028;
            goto LABEL_67;
          }
          v60 = *(_QWORD *)v57;
          *(_QWORD *)v57 -= 8;
          if (v59 > 0)
            break;
          *(_QWORD *)(*v55 + 8 * v54) = v53 + 8 * v59 * (int)v54;
          *(_QWORD *)(*v55 + 8 * v54) -= 16;
LABEL_52:
          v33 = 0;
          ++v54;
          v5 = v72;
          if (v54 >= *v48)
            return v33;
        }
        v61 = 0;
        do
        {
          if ((*(_DWORD *)(v60 + 4 * v61) & 0x80000000) != 0)
          {
            v67 = "LoadModelFile: the number of PDFs for %s at state %d is illegal\n";
            v68 = v5;
            v69 = 55029;
            goto LABEL_67;
          }
          ++v61;
        }
        while ((v59 + 2) - 2 != v61);
        *(_QWORD *)(*v55 + 8 * v54) = v53 + 8 * v59 * (int)v54;
        *(_QWORD *)(*v55 + 8 * v54) -= 16;
        v62 = *(_QWORD *)v57;
        v63 = *v56;
        v64 = 16;
        v65 = 2;
        while (1)
        {
          v66 = BET3FLT__xfread2ptr_BET3((_QWORD *)(*(_QWORD *)(*v55 + 8 * v54) + v64), 4u, 4 * *(_DWORD *)(v62 + 4 * v65) * v63, v58);
          v62 = *(_QWORD *)v57;
          v63 = *v56;
          if (v66 != 4 * *(_DWORD *)(*(_QWORD *)v57 + 4 * v65) * *v56)
            break;
          v64 += 8;
          v46 = v65++ <= (int)*a2;
          if (!v46)
            goto LABEL_52;
        }
        v67 = "LoadModelFile: PDF read failed for %s %d\n";
        v68 = v72;
        v69 = 55030;
LABEL_67:
        BET3FLT__log_select_Error(v68, v69, (uint64_t)v67, v15, v16, v17, v18, v19);
        return 2229280772;
      }
      return 0;
    }
  }
  return v33;
}

uint64_t BET3FLT__FindDurPDF(int32x2_t *a1, int *a2, int a3, int a4, int a5, float a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  float v24;
  float64x2_t v25;
  int32x2_t v26;
  int32x2_t v27;
  float64x2_t v30;

  v6 = a1[1].i32[0];
  a1[3] = 0;
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    v13 = a4;
    v14 = 2;
    __asm { FMOV            V0.2D, #0.5 }
    v30 = _Q0;
    v20 = 0.0;
    do
    {
      v21 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v13) + 8 * v6);
      v22 = *(float *)(v21 + 4 * v14);
      v23 = *(float *)(v21 + 4 * ((int)v14 + (int)v7));
      if (a5)
        v23 = BET3FLT__bet3_finv(v23);
      v24 = v22 + (float)(v23 * a6);
      if (v24 < 0.0)
        v24 = 0.0;
      if (a2[115])
      {
        if (v24 > 4000.0)
          v24 = 4000.0;
      }
      else if (v24 > 4000.0)
      {
        v24 = v20 * 0.5;
      }
      v25.f64[0] = (float)(v24 + (float)a3);
      v26 = a1[2];
      v25.f64[1] = sqrt(v23);
      v27 = vmovn_s64(vcvtq_s64_f64(vaddq_f64(v25, v30)));
      *(_DWORD *)(*(_QWORD *)&v26 + 4 * v14) = v27.i32[0];
      a1[3] = vadd_s32(a1[3], v27);
      a3 += (int)(float)(v24 - (float)*(int *)(*(_QWORD *)&v26 + 4 * v14));
      v7 = *a2;
      v20 = v24;
    }
    while (v14++ <= v7);
  }
  return 0;
}

uint64_t BET3FLT__FindContPDF(int a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = (_QWORD *)(a3 + 8 * a1);
  v6 = *(int *)(a4 + 4 * a1 + 4);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 8 * a1 + 176) + 8 * a5) + 8 * a2)
     + 4 * (2 * *(_DWORD *)(v5[9] + 4 * a2) - 2) * (int)v6;
  *(_QWORD *)(v5[19] + 8 * a2) = v7;
  *(_QWORD *)(v5[29] + 8 * a2) = v7 + 4 * v6;
  return 0;
}

uint64_t BET3FLT__FindMsdPDF(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  int *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  int *v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  float v23;
  int v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  v6 = a4 + 4 * a1;
  v9 = *(_DWORD *)(v6 + 4);
  v7 = (int *)(v6 + 4);
  v8 = v9;
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = a2;
    v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 8 * a1 + 256) + 8 * a6) + 8 * a2)
        + 4 * (4 * *(_DWORD *)(*(_QWORD *)(a3 + 8 * a1 + 72) + 4 * a2) - 4) * v8;
    v13 = a3 + 8 * a1;
    v14 = a5 + 4 * a1;
    v15 = (_QWORD *)(v13 + 152);
    v16 = (_QWORD *)(v13 + 232);
    v17 = (int *)(v14 + 224);
    v18 = (float *)(v14 + 2104);
    v19 = 1;
    do
    {
      v20 = v12 + 4 * v10;
      v21 = *(_QWORD *)(*v15 + 8 * v11);
      *(_DWORD *)(v21 + 4 * v19) = *(_DWORD *)v20;
      v22 = *(float *)(v20 + 4);
      *(float *)(*(_QWORD *)(*v16 + 8 * v11) + 4 * v19) = v22;
      v23 = *(float *)(a5 + 44);
      if (v23 != 0.0 && *v17 == 2)
        *(float *)(v21 + 4 * v19) = *(float *)(v21 + 4 * v19) + (float)(v22 * v23);
      if (v19 == 1)
      {
        v24 = *v17;
        if (*v17 == 2)
          *(_DWORD *)(*(_QWORD *)(a3 + 320) + 4 * v11) = *(_DWORD *)(v20 + 8);
        v25 = *(float *)(v20 + 8);
        v26 = 1 << v24;
        v27 = *(_QWORD *)(a3 + 312);
        if (v25 <= *v18)
          v28 = *(_BYTE *)(v27 + v11) & ~(_BYTE)v26;
        else
          v28 = *(_BYTE *)(v27 + v11) | v26;
        *(_BYTE *)(v27 + v11) = v28;
      }
      v10 += 4;
    }
    while (v19++ < *v7);
  }
  return 0;
}

uint64_t BET3FLT__FindDurPDF_PerStateRho(uint64_t a1, int *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  double v20;
  float v21;
  float v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;

  v6 = *(int *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = 0;
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    v13 = 0;
    v14 = a5;
    v15 = 0.0;
    do
    {
      v16 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v14) + 8 * v6);
      v17 = *(float *)(v16 + 4 * v13 + 8);
      v18 = *(float *)(a3 + 4 * v13);
      v19 = *(float *)(v16 + 4 * (v13 + (int)v7) + 8);
      if (a6)
        v19 = BET3FLT__bet3_finv(v19);
      v20 = sqrt(v19);
      v21 = v20;
      v22 = v17 + (float)(v18 * v21);
      if (v22 < 0.0)
        v22 = 0.0;
      if (a2[115])
      {
        if (v22 > 4000.0)
          v22 = 4000.0;
      }
      else if (v22 > 4000.0)
      {
        v22 = v15 * 0.5;
      }
      v23 = (int)((float)(v22 + (float)a4) + 0.5);
      v24 = *(_QWORD *)(a1 + 16) + 4 * v13;
      if (v23 <= 1)
        v23 = 1;
      *(_DWORD *)(v24 + 8) = v23;
      v25 = *(_DWORD *)(a1 + 28) + (int)(v20 + 0.5);
      *(_DWORD *)(a1 + 24) += v23;
      *(_DWORD *)(a1 + 28) = v25;
      a4 += (int)(float)(v22 - (float)*(int *)(v24 + 8));
      v7 = *a2;
      v26 = v13 + 2;
      ++v13;
      v15 = v22;
    }
    while (v26 <= v7);
  }
  return 0;
}

uint64_t BET3FLT__FindLF0PDF_PerStateRho(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, float a8)
{
  uint64_t v8;
  int v9;
  int *v10;
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  double v20;
  float *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  float v26;
  double v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  char v31;

  v8 = a4 + 4 * a1;
  v11 = *(_DWORD *)(v8 + 4);
  v10 = (int *)(v8 + 4);
  v9 = v11;
  if (v11 >= 1)
  {
    v14 = a2;
    v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 8 * a1 + 256) + 8 * a6) + 8 * a2)
        + 4 * (4 * *(_DWORD *)(*(_QWORD *)(a3 + 8 * a1 + 72) + 4 * a2) - 4) * v9;
    v16 = a3 + 8 * a1;
    v17 = (_QWORD *)(v16 + 152);
    v18 = (_QWORD *)(v16 + 232);
    v19 = a5 + 4 * a1;
    v20 = a8;
    v21 = (float *)(v19 + 2104);
    v22 = (_DWORD *)(v19 + 224);
    v23 = 1;
    do
    {
      v24 = v15 + 4 * (4 * (int)v23 - 4);
      v25 = (float *)(*(_QWORD *)(*v17 + 8 * v14) + 4 * v23);
      *v25 = *(float *)v24;
      v26 = *(float *)(v24 + 4);
      *(float *)(*(_QWORD *)(*v18 + 8 * v14) + 4 * v23) = v26;
      if (a8 != 0.0)
      {
        if (a7)
        {
          v27 = sqrt(BET3FLT__bet3_finv(v26));
          v25 = (float *)(*(_QWORD *)(*v17 + 8 * v14) + 4 * v23);
        }
        else
        {
          v27 = sqrt(v26);
        }
        v28 = v27 * v20;
        *v25 = *v25 + v28;
      }
      if (v23 == 1)
      {
        *(_DWORD *)(*(_QWORD *)(a3 + 320) + 4 * v14) = *(_DWORD *)(v24 + 8);
        v29 = 1 << *v22;
        v30 = *(_QWORD *)(a3 + 312);
        if (*(float *)(v24 + 8) <= *v21)
          v31 = *(_BYTE *)(v30 + v14) & ~(_BYTE)v29;
        else
          v31 = *(_BYTE *)(v30 + v14) | v29;
        *(_BYTE *)(v30 + v14) = v31;
      }
    }
    while (v23++ < *v10);
  }
  return 0;
}

void *BET3FLT__DeInitModelSet(uint64_t a1, char *__b)
{
  uint64_t v4;
  uint64_t **v5;
  _DWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t *v9;

  if (*((int *)__b + 114) >= 1)
  {
    v4 = 0;
    v5 = (uint64_t **)(__b + 256);
    v6 = __b + 416;
    do
    {
      if (*(v6 - 20))
      {
        v7 = (_QWORD *)*((_QWORD *)__b + 21);
        if (v7)
        {
          if (*v7)
          {
            *v7 += 8;
            heap_Free(*(_QWORD **)(a1 + 8), **((_QWORD **)__b + 21));
            v7 = (_QWORD *)*((_QWORD *)__b + 21);
          }
          heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v7);
          *((_QWORD *)__b + 21) = 0;
        }
      }
      if (*(v6 - 10))
      {
        v8 = *(v5 - 10);
        if (v8)
        {
          if (*v8)
          {
            *v8 += 16;
            heap_Free(*(_QWORD **)(a1 + 8), **(v5 - 10));
            v8 = *(v5 - 10);
          }
          heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v8);
        }
      }
      if (*v6)
      {
        v9 = *v5;
        if (*v5)
        {
          if (*v9)
          {
            *v9 += 16;
            heap_Free(*(_QWORD **)(a1 + 8), **v5);
            v9 = *v5;
          }
          heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v9);
        }
      }
      ++v4;
      ++v5;
      ++v6;
    }
    while (v4 < *((int *)__b + 114));
  }
  return cstdlib_memset(__b, 0, 0x1D0uLL);
}

uint64_t BET3FLT__InitUttModel(uint64_t a1, char *__b, int *a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v8 = 2229280778;
  cstdlib_memset(__b, 0, 0x240uLL);
  *(_QWORD *)__b = a1;
  *((_QWORD *)__b + 1) = a3;
  *((_DWORD *)__b + 138) = a4;
  *((_DWORD *)__b + 141) = *a3 * a4;
  v9 = heap_Calloc(*(_QWORD **)(a1 + 8), a4, 528);
  *((_QWORD *)__b + 68) = v9;
  if (v9)
  {
    v10 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
    *((_QWORD *)__b + 4) = v10;
    if (v10)
    {
      v11 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 1);
      *((_QWORD *)__b + 41) = v11;
      if (v11)
      {
        v12 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
        *((_QWORD *)__b + 42) = v12;
        if (v12)
        {
          v13 = a3[114];
          if (v13 >= 1)
          {
            v14 = 0;
            v15 = __b + 168;
            v16 = a3;
            do
            {
              if (!v16[84])
              {
                v17 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
                *(v15 - 10) = v17;
                if (!v17)
                  return v8;
                v18 = *(_QWORD **)(a1 + 8);
                v19 = *((_DWORD *)__b + 138);
                v20 = v16[104]
                    ? BET3FLT__int32_ccalloc(v18, 2 * v19 * *a3, v16[1] + 1)
                    : (_QWORD *)heap_Calloc(v18, (2 * v19 * *a3), 8);
                *v15 = v20;
                if (!v20)
                  return v8;
                v15[10] = &v20[*a3 * *((_DWORD *)__b + 138)];
                v13 = a3[114];
              }
              ++v14;
              ++v16;
              ++v15;
            }
            while (v14 < v13);
          }
          v21 = *((unsigned int *)__b + 138);
          if ((int)v21 >= 1)
          {
            v22 = 0;
            v23 = *a3;
            v24 = 152;
            do
            {
              v25 = *((_QWORD *)__b + 68);
              v26 = v25 + 528 * v22;
              *(_DWORD *)v26 = v22;
              v27 = v22 * v23;
              v28 = *((_QWORD *)__b + 41) + v22 * v23;
              v29 = *((_QWORD *)__b + 42) + 4 * v22 * v23;
              *(_QWORD *)(v26 + 16) = *((_QWORD *)__b + 4) + 4 * v22 * v23 - 8;
              *(_QWORD *)(v26 + 312) = v28 - 2;
              *(_QWORD *)(v26 + 320) = v29 - 8;
              if (v13 >= 1)
              {
                v30 = (uint64_t *)(v25 + v24);
                v31 = __b + 168;
                v32 = v13;
                v33 = a3 + 84;
                do
                {
                  if (!*v33++)
                  {
                    v35 = *(v31 - 10) + 4 * v27;
                    *(v30 - 10) = v35;
                    v36 = *v31 + 8 * v27;
                    *v30 = v36;
                    v37 = v31[10] + 8 * v27;
                    *(v30 - 10) = v35 - 8;
                    *v30 = v36 - 16;
                    v30[10] = v37 - 16;
                  }
                  ++v30;
                  ++v31;
                  --v32;
                }
                while (v32);
              }
              ++v22;
              v24 += 528;
            }
            while (v22 != v21);
          }
          return 0;
        }
      }
    }
  }
  return v8;
}

_QWORD *BET3FLT__DeInitUttModel(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v1 = result;
  if (*result && result[68])
  {
    v2 = result[1];
    v3 = result[4];
    if (v3)
    {
      heap_Free(*(_QWORD **)(*result + 8), v3);
      v1[4] = 0;
    }
    v4 = v1[41];
    if (v4)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v4);
      v1[41] = 0;
    }
    v5 = v1[42];
    if (v5)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v5);
      v1[42] = 0;
    }
    if (*(int *)(v2 + 456) >= 1)
    {
      v6 = 0;
      do
      {
        if (!*(_DWORD *)(v2 + 336 + 4 * v6))
        {
          v7 = &v1[v6];
          v8 = v7[11];
          if (v8)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v8);
            v7[11] = 0;
          }
          v9 = v7[21];
          if (v9)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v9);
            v7[21] = 0;
          }
        }
        ++v6;
      }
      while (v6 < *(int *)(v2 + 456));
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), v1[68]);
  }
  v1[68] = 0;
  *((_DWORD *)v1 + 138) = 0;
  *v1 = 0;
  return result;
}

_QWORD *BET3FLT__DeInitMSDUttModel(_QWORD *result, int a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t **v8;
  _QWORD *v9;

  v2 = result[1];
  if (!*(_DWORD *)(v2 + 4 * a2 + 336))
  {
    v3 = result;
    v4 = a2;
    v5 = &result[a2];
    v6 = v5[11];
    if (v6)
    {
      result = heap_Free(*(_QWORD **)(*result + 8), v6);
      v5[11] = 0;
    }
    v9 = (_QWORD *)v5[21];
    v8 = (uint64_t **)(v5 + 21);
    v7 = v9;
    if (v9)
    {
      if (*(_DWORD *)(v2 + 4 * v4 + 416))
      {
        *v7 += 4;
        result = BET3FLT__int32_free(*(_QWORD **)(*v3 + 8), *v8);
      }
      else
      {
        result = heap_Free(*(_QWORD **)(*v3 + 8), (uint64_t)v7);
      }
      *v8 = 0;
    }
  }
  return result;
}

uint64_t BET3FLT__InitModelSet(int a1, char *__b, _DWORD *a3)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;

  cstdlib_memset(__b, 0, 0x1D0uLL);
  v5 = a3[33];
  *((_DWORD *)__b + 114) = v5;
  if (v5 >= 1)
  {
    v6 = 0;
    v7 = __b + 376;
    v8 = 536;
    do
    {
      *((_DWORD *)v7 - 62) = a3[86];
      v9 = __b + 336;
      if (v8 != 536)
      {
        if (a3[536])
          v9 = &__b[4 * v6 + 416];
        else
          v9 = v7;
      }
      ++a3;
      *(_DWORD *)v9 = 1;
      ++v6;
      v10 = v8 - 535;
      ++v8;
      v7 += 4;
    }
    while (v10 < *((int *)__b + 114));
  }
  return 0;
}

uint64_t BET3FLT__meancpy(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        v4 = *(uint64_t **)(result + 72);
        v5 = *(uint64_t **)(result + 40);
        v6 = v3;
        do
        {
          v7 = *v4++;
          v8 = *(_DWORD *)(v7 + 4 * v2);
          v9 = *v5++;
          *(_DWORD *)(v9 + 4 * v2) = v8;
          --v6;
        }
        while (v6);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

float BET3FLT__ConstW_Calc_R_and_r(uint64_t a1, int a2)
{
  float *v2;
  float **v3;
  uint64_t *v4;
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  float *v22;
  uint64_t v23;
  float **v24;
  float *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  float v29;
  float v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float *v46;
  float v47;
  float v48;
  uint64_t v49;
  float v50;
  uint64_t v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float *v56;
  float result;

  v3 = *(float ***)(a1 + 96);
  v2 = *(float **)(a1 + 104);
  v4 = *(uint64_t **)(a1 + 72);
  v5 = *(uint64_t **)(a1 + 80);
  v6 = *(_DWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a1 + 20);
  v8 = a2;
  v9 = *v5;
  v10 = v5[1];
  v11 = *(float *)(*v5 + 4 * a2);
  v12 = *v4;
  v13 = v4[1];
  v14 = v11 * *(float *)(*v4 + 4 * a2);
  *v2 = v14;
  v15 = *(float *)(v10 + 4 * (v6 + a2));
  v16 = v6 + a2;
  v17 = v14 + (float)((float)(v15 * -0.5) * *(float *)(v13 + 4 * v16));
  *v2 = v17;
  v18 = a2 + 2 * v6;
  v19 = *(float *)(v9 + 4 * v18);
  v20 = v17 + (float)((float)(v19 * -2.0) * *(float *)(v12 + 4 * v18));
  *v2 = v20;
  v21 = *(float *)(v10 + 4 * v18);
  *v2 = v20 + (float)(v21 * *(float *)(v13 + 4 * v18));
  v22 = *v3;
  *v22 = v11 + (float)((float)((float)(v19 * 4.0) + (float)(v15 * 0.25)) + v21);
  v22[1] = (float)(v19 * -2.0) + (float)(v21 * -2.0);
  v22[2] = v21 + (float)(v15 * -0.25);
  if (v7 < 3)
  {
    LODWORD(v23) = 1;
  }
  else
  {
    v23 = (v7 - 1);
    v24 = v3 + 1;
    v25 = v2 + 1;
    v26 = v5 + 2;
    v27 = v4 + 2;
    v28 = v23 - 1;
    do
    {
      v29 = *(float *)(v10 + 4 * v8);
      v30 = v29 * *(float *)(v13 + 4 * v8);
      *v25 = v30;
      v31 = *(v26 - 2);
      v32 = *(float *)(v31 + 4 * v16);
      v33 = *(v27 - 2);
      v34 = v30 + (float)((float)(v32 * 0.5) * *(float *)(v33 + 4 * v16));
      *v25 = v34;
      v36 = *v26++;
      v35 = v36;
      v37 = *(float *)(v36 + 4 * v16);
      v39 = *v27++;
      v38 = v39;
      v40 = v34 + (float)((float)(v37 * -0.5) * *(float *)(v39 + 4 * v16));
      *v25 = v40;
      v41 = *(float *)(v31 + 4 * v18);
      v42 = v40 + (float)(v41 * *(float *)(v33 + 4 * v18));
      *v25 = v42;
      v43 = *(float *)(v10 + 4 * v18);
      v44 = v42 + (float)((float)(v43 * -2.0) * *(float *)(v13 + 4 * v18));
      *v25 = v44;
      v45 = *(float *)(v35 + 4 * v18);
      *v25++ = v44 + (float)(v45 * *(float *)(v39 + 4 * v18));
      v46 = *v24++;
      *v46 = (float)((float)((float)((float)(v29 + (float)(v32 * 0.25)) + (float)(v37 * 0.25)) + v41) + v45)
           + (float)(v43 * 4.0);
      v46[1] = (float)(v45 * -2.0) + (float)(v43 * -2.0);
      v46[2] = v45 + (float)(v37 * -0.25);
      v13 = v38;
      v10 = v35;
      --v28;
    }
    while (v28);
    v10 = v5[v23];
    v13 = v4[v23];
  }
  v47 = *(float *)(v10 + 4 * v8);
  v48 = v47 * *(float *)(v13 + 4 * v8);
  v2[v23] = v48;
  v49 = v5[(int)v23 - 1];
  v50 = *(float *)(v49 + 4 * v16);
  v51 = v4[(int)v23 - 1];
  v52 = v48 + (float)((float)(v50 * 0.5) * *(float *)(v51 + 4 * v16));
  v2[v23] = v52;
  v53 = *(float *)(v49 + 4 * v18);
  v54 = v52 + (float)(v53 * *(float *)(v51 + 4 * v18));
  v2[v23] = v54;
  v55 = *(float *)(v10 + 4 * v18);
  v2[v23] = v54 + (float)((float)(v55 * -2.0) * *(float *)(v13 + 4 * v18));
  v56 = v3[v23];
  result = v47 + (float)((float)(v53 + (float)(v50 * 0.25)) + (float)(v55 * 4.0));
  *v56 = result;
  v56[1] = 0.0;
  v56[2] = 0.0;
  return result;
}

float BET3FLT__ConstW_Cholesky(uint64_t a1, double a2)
{
  uint64_t v2;
  float *v3;
  _DWORD *v4;
  float32x2_t v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  float **v10;
  uint64_t v11;
  float *v12;
  float v13;
  float v14;
  float v15;

  v2 = *(_QWORD *)(a1 + 96);
  v4 = *(_DWORD **)v2;
  v3 = *(float **)(v2 + 8);
  LODWORD(a2) = **(_DWORD **)v2;
  v5 = vdiv_f32(*(float32x2_t *)(*(_QWORD *)v2 + 4), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0));
  *(float32x2_t *)(v4 + 1) = v5;
  v6 = v3[1];
  *(float *)&a2 = *v3 + (float)((float)((float)-v5.f32[0] * v5.f32[0]) * *(float *)&a2);
  *v3 = *(float *)&a2;
  v7 = (float)(v6 + (float)((float)-(float)(*((float *)v4 + 1) * *((float *)v4 + 2)) * *(float *)v4)) / *(float *)&a2;
  v8 = v3[2] / *(float *)&a2;
  v3[1] = v7;
  v3[2] = v8;
  v9 = *(unsigned int *)(a1 + 20);
  if ((int)v9 >= 3)
  {
    v10 = (float **)(v2 + 16);
    v11 = v9 - 2;
    do
    {
      v12 = *v10;
      v13 = (*v10)[1];
      v14 = **v10 + (float)((float)-(float)(v7 * v7) * *(float *)&a2);
      *v12 = v14;
      *(float *)&a2 = v14 + (float)((float)-(float)((*(v10 - 2))[2] * (*(v10 - 2))[2]) * **(v10 - 2));
      *v12 = *(float *)&a2;
      v7 = (float)(v13 + (float)((float)-(float)(v3[1] * v3[2]) * *v3)) / *(float *)&a2;
      v15 = v12[2] / *(float *)&a2;
      v12[1] = v7;
      v12[2] = v15;
      ++v10;
      v3 = v12;
      --v11;
    }
    while (v11);
  }
  return *(float *)&a2;
}

float BET3FLT__ConstW_Cholesky_forward(uint64_t a1)
{
  float *v1;
  uint64_t *v2;
  float *v3;
  float v4;
  uint64_t v5;
  float result;
  uint64_t v7;
  float *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;

  v2 = *(uint64_t **)(a1 + 96);
  v1 = *(float **)(a1 + 104);
  v3 = *(float **)(a1 + 88);
  v4 = *v1;
  *v3 = *v1;
  v5 = *v2;
  result = v1[1] - (float)(*(float *)(*v2 + 4) * v4);
  v3[1] = result;
  v7 = *(unsigned int *)(a1 + 20);
  if ((int)v7 >= 3)
  {
    v8 = v3 + 2;
    v9 = v1 + 2;
    v10 = v2 + 1;
    v11 = v7 - 2;
    do
    {
      v12 = *v9++;
      v13 = v12;
      v14 = *(float *)(v5 + 8);
      v15 = *v10++;
      v5 = v15;
      result = v13 - (float)((float)(v14 * *(v8 - 2)) + (float)(*(float *)(v15 + 4) * result));
      *v8++ = result;
      --v11;
    }
    while (v11);
  }
  return result;
}

float BET3FLT__ConstW_Cholesky_backward(uint64_t a1, int a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  float *v7;
  float result;
  BOOL v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 20);
  v3 = *(_QWORD *)(a1 + 88);
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *(float *)(v3 + 4 * (v2 - 1)) / **(float **)(v4 + 8 * (v2 - 1));
  *(float *)(*(_QWORD *)(v5 + 8 * (v2 - 1)) + 4 * a2) = v6;
  v7 = *(float **)(v4 + 8 * (v2 - 2));
  result = (float)(*(float *)(v3 + 4 * (v2 - 2)) / *v7) - (float)(v7[1] * v6);
  *(float *)(*(_QWORD *)(v5 + 8 * (v2 - 2)) + 4 * a2) = result;
  v9 = __OFSUB__(v2, 3);
  v10 = (v2 - 3);
  if ((int)v10 < 0 == v9)
  {
    v11 = (_QWORD *)(v5 + 8 * v10 + 16);
    v12 = v11;
    do
    {
      v13 = *--v12;
      result = (float)((float)(*(float *)(v3 + 4 * v10) / **(float **)(v4 + 8 * v10))
                     - (float)(*(float *)(*(_QWORD *)(v4 + 8 * v10) + 4) * *(float *)(v13 + 4 * a2)))
             - (float)(*(float *)(*(_QWORD *)(v4 + 8 * v10) + 8) * *(float *)(*v11 + 4 * a2));
      *(float *)(*(v11 - 2) + 4 * a2) = result;
      --v10;
      v11 = v12;
    }
    while (v10 != -1);
  }
  return result;
}

void BET3FLT__mlpg2(uint64_t a1, int a2)
{
  double v4;

  if (*(int *)(a1 + 20) < 2)
  {
    BET3FLT__meancpy(a1);
  }
  else
  {
    *(float *)&v4 = BET3FLT__ConstW_Calc_R_and_r(a1, a2);
    BET3FLT__ConstW_Cholesky(a1, v4);
    BET3FLT__ConstW_Cholesky_forward(a1);
    BET3FLT__ConstW_Cholesky_backward(a1, a2);
  }
}

char *BET3FLT__heap_StrDup(_QWORD *a1, char *__s)
{
  int v4;
  char *v5;
  char *v6;

  if (!__s)
    return 0;
  v4 = cstdlib_strlen(__s);
  v5 = (char *)heap_Calloc(a1, (v4 + 1), 1);
  v6 = v5;
  if (v5)
    cstdlib_strcpy(v5, __s);
  return v6;
}

uint64_t BET3FLT__xfread_BET3(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  size_t v8;

  v5 = a3;
  v6 = *a4;
  v7 = a4[4];
  if (v6 + (_DWORD)a3 * a2 > v7)
    v5 = (v7 - v6) / a2;
  if ((_DWORD)v5)
  {
    v8 = v5 * a2;
    cstdlib_memcpy(a1, (const void *)(*((_QWORD *)a4 + 1) + v6), v8);
    *a4 += v8;
  }
  return v5;
}

uint64_t BET3FLT__xfread2ptr_BET3(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;

  v4 = *a4;
  if (a2 >= 2 && v4 % a2)
    return 0;
  v5 = a4[4];
  if (v4 + (_DWORD)a3 * a2 > v5)
    a3 = (v5 - v4) / a2;
  if ((_DWORD)a3)
  {
    *a1 = *((_QWORD *)a4 + 1) + v4;
    *a4 = v4 + a3 * a2;
  }
  return a3;
}

uint64_t BET3FLT__log_out_Event(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9;
  int v10;

  v9 = a3 - 1;
  do
    v10 = *(unsigned __int8 *)++v9;
  while (v10 == 10);
  return log_VOutEvent(*(uint64_t ***)(a1 + 32), a2, v9, &a9);
}

uint64_t BET3FLT__log_select_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  v3 = a3 - 1;
  do
    v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", (a2 + 2), 0, v3);
}

uint64_t BET3FLT__log_select_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;

  return log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", a2, 0, a5, a6, a7, a8, v9);
}

uint64_t BET3FLT__log_select_GetLogLevel(uint64_t a1)
{
  unsigned int LogLevel;

  LogLevel = log_GetLogLevel(a1);
  if (LogLevel >= 3)
    return LogLevel - 2;
  else
    return 0;
}

float BET3FLT__bet3_finv(float a1)
{
  float v1;

  v1 = 0.0;
  if (a1 < 1.0e19 && a1 > -1.0e19)
  {
    if (a1 > 1.0e-19 || a1 < 0.0)
    {
      if (a1 < -1.0e-19 || a1 >= 0.0)
        return 1.0 / a1;
      else
        return -1.0e38;
    }
    else
    {
      return 1.0e38;
    }
  }
  return v1;
}

_QWORD *BET3FLT__ddcalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FLT__ddcalloc_64(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FLT__dd_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FLT__dd_free_64(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FLT__ffcalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FLT__ff_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FLT__int32_ccalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FLT__int32_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FLT__iicalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FLT__ii_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

uint64_t BET3FLT__InitDWinSet(int a1, void *__b, uint64_t a3)
{
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  int v8;
  int v9;
  int *v10;

  cstdlib_memset(__b, 0, 0x190uLL);
  v5 = *(unsigned int *)(a3 + 132);
  if ((int)v5 >= 1)
  {
    for (i = 0; i != v5; ++i)
    {
      v7 = a3 + 4 * i;
      v8 = *(_DWORD *)(v7 + 304);
      if (v8 >= 1)
      {
        v9 = 0;
        v10 = (int *)(v7 + 304);
        do
        {
          *((_DWORD *)__b + 10 * i) = v8 + 1;
          ++v9;
          v8 = *v10;
        }
        while (v9 < *v10);
      }
    }
  }
  return 0;
}

_QWORD **BET3FLT__DeInitDWinSet(_QWORD **result, char *a2)
{
  _QWORD **v3;
  uint64_t i;
  char *v5;
  uint64_t *v6;

  if (a2)
  {
    v3 = result;
    for (i = 0; i != 400; i += 40)
    {
      v5 = &a2[i];
      BET3FLT__ii_free(v3[1], *(uint64_t **)&a2[i + 8]);
      v6 = *(uint64_t **)&a2[i + 16];
      if (v6)
      {
        if (!*v6 || (heap_Free(v3[1], *v6), **((_QWORD **)v5 + 2) = 0, (v6 = (uint64_t *)*((_QWORD *)v5 + 2)) != 0))
        {
          heap_Free(v3[1], (uint64_t)v6);
          *((_QWORD *)v5 + 2) = 0;
        }
      }
    }
    return (_QWORD **)cstdlib_memset(a2, 0, 0x190uLL);
  }
  return result;
}

uint64_t BET3FLT__LoadDWinFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  unsigned int *v5;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int ***v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  int v30;
  int **v31;
  int *v32;
  int v33;
  int v34;

  v5 = (unsigned int *)(a2 + 40 * a3);
  if (!*v5)
    return 0;
  v9 = 2229280778;
  v10 = BET3FLT__iicalloc(*(_QWORD **)(a1 + 8), *v5, 2);
  v11 = a2 + 40 * a3;
  *(_QWORD *)(v11 + 8) = v10;
  v12 = (int ***)(v11 + 8);
  if (v10)
  {
    v13 = heap_Calloc(*(_QWORD **)(a1 + 8), *v5, 8);
    v14 = a2 + 40 * a3;
    *(_QWORD *)(v14 + 16) = v13;
    v15 = (uint64_t **)(v14 + 16);
    if (v13)
    {
      *(_QWORD *)**v12 = 0;
      **v15 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 4);
      v16 = (_DWORD *)**v15;
      if (v16)
      {
        *v16 = 1065353216;
        LODWORD(v17) = *v5;
        if ((int)*v5 <= 1)
        {
LABEL_9:
          v27 = a2 + 40 * a3;
          *(_DWORD *)(v27 + 24) = 0;
          v28 = (_DWORD *)(v27 + 24);
          v28[1] = 0;
          if ((int)v17 < 1)
          {
            v30 = 0;
          }
          else
          {
            v29 = 0;
            v30 = 0;
            v31 = *v12;
            v17 = v17;
            do
            {
              v32 = *v31;
              v33 = **v31;
              if (v30 > v33)
              {
                *v28 = v33;
                v30 = v33;
              }
              v34 = v32[1];
              if (v29 < v34)
              {
                v28[1] = v34;
                v29 = v34;
              }
              ++v31;
              --v17;
            }
            while (v17);
            if (v30 < v29)
            {
              v9 = 0;
              *(_DWORD *)(a2 + 40 * a3 + 32) = v29;
              return v9;
            }
          }
          v9 = 0;
          *(_DWORD *)(a2 + 40 * a3 + 32) = v30;
          return v9;
        }
        v18 = 1;
        v19 = 1;
        while (1)
        {
          v20 = BET3FLT__xfread2ptr_BET3(&(*v15)[v19], 4u, 0xFFFFFFFFLL, a4);
          if (!v20)
            break;
          (*v15)[v19] += 4 * (v20 >> 1);
          v26 = (*v12)[v19];
          *v26 = -(v20 >> 1);
          v26[1] = (v20 & 1) + (v20 >> 1) - 1;
          ++v18;
          v17 = (int)*v5;
          ++v19;
          a4 += 6;
          if (v18 >= v17)
            goto LABEL_9;
        }
        BET3FLT__log_select_Error(a1, 55019, (uint64_t)"InitDWin: illegal data\n", v21, v22, v23, v24, v25);
        return 2229280772;
      }
    }
  }
  return v9;
}

void *BET3FLT__InitSMatrices(uint64_t a1, _QWORD *__b)
{
  void *result;

  result = cstdlib_memset(__b, 0, 0x40uLL);
  *__b = a1;
  return result;
}

double BET3FLT__FreeSMatrices(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  double result;

  if (a1)
  {
    if (*(_QWORD *)a1)
    {
      v2 = *(uint64_t **)(a1 + 24);
      if (v2)
      {
        if (!*(_DWORD *)(a1 + 8))
        {
          BET3FLT__dd_free(*(_QWORD **)(*(_QWORD *)a1 + 8), v2);
          BET3FLT__dd_free_64(*(_QWORD **)(*(_QWORD *)a1 + 8), *(uint64_t **)(a1 + 48));
          v3 = *(_QWORD *)(a1 + 40);
          if (v3)
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v3);
        }
        *(_DWORD *)(a1 + 60) = 0;
        result = 0.0;
        *(_OWORD *)(a1 + 44) = 0u;
        *(_OWORD *)(a1 + 28) = 0u;
        *(_OWORD *)(a1 + 12) = 0u;
      }
    }
  }
  return result;
}

uint64_t BET3FLT__InitPStreamSM(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 *v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v4 = *a1;
  if (a2
    && *(_QWORD *)(a2 + 24)
    && *((_DWORD *)a1 + 3) == *(_DWORD *)(a2 + 12)
    && *((_DWORD *)a1 + 5) == *(_DWORD *)(a2 + 16)
    && *((_DWORD *)a1 + 6) == *(_DWORD *)(a2 + 20))
  {
    result = 0;
    v6 = *(_OWORD *)(a2 + 48);
    v8 = *(_OWORD *)a2;
    v7 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)a1 + 5) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)a1 + 6) = v6;
    *((_OWORD *)a1 + 3) = v8;
    *((_OWORD *)a1 + 4) = v7;
LABEL_12:
    *((_DWORD *)a1 + 14) = 1;
    return result;
  }
  a1[6] = v4;
  v9 = (__int128 *)(a1 + 6);
  v10 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 14) = 0;
  *((_DWORD *)a1 + 15) = v10;
  v11 = *(uint64_t *)((char *)a1 + 20);
  a1[8] = v11;
  v12 = BET3FLT__ddcalloc(*(_QWORD **)(v4 + 8), 2 * (int)v11, v10);
  a1[9] = (uint64_t)v12;
  if (v12
    && (v13 = *((_DWORD *)a1 + 6),
        v14 = *((int *)a1 + 5),
        a1[10] = (uint64_t)&v12[v14],
        v15 = BET3FLT__ddcalloc_64(*(_QWORD **)(v4 + 8), v14, v13),
        (a1[12] = (uint64_t)v15) != 0)
    && (v16 = heap_Calloc(*(_QWORD **)(v4 + 8), (2 * *((_DWORD *)a1 + 5)), 4), (a1[11] = v16) != 0))
  {
    a1[13] = v16 + 4 * *((int *)a1 + 5);
    if (a2)
    {
      BET3FLT__FreeSMatrices(a2);
      result = 0;
      v17 = *v9;
      v18 = *((_OWORD *)a1 + 4);
      v19 = *((_OWORD *)a1 + 6);
      *(_OWORD *)(a2 + 32) = *((_OWORD *)a1 + 5);
      *(_OWORD *)(a2 + 48) = v19;
      *(_OWORD *)a2 = v17;
      *(_OWORD *)(a2 + 16) = v18;
      goto LABEL_12;
    }
    return 0;
  }
  else
  {
    BET3FLT__FreeSMatrices((uint64_t)(a1 + 6));
    return 2229280778;
  }
}

double BET3FLT__FreePStreamSM(uint64_t a1)
{
  return BET3FLT__FreeSMatrices(a1 + 48);
}

uint64_t BET3FLT__InitPStreamParam(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _QWORD *v7;
  uint64_t result;

  v4 = *(_QWORD *)a1;
  a1[6] = (2 * *(_DWORD *)(*((_QWORD *)a1 + 4) + 32)) | 1;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 40);
    if (v5)
    {
      if (a1[5] == *(_DWORD *)(a2 + 20) && a1[4] == *(_DWORD *)(a2 + 16))
      {
        *((_QWORD *)a1 + 5) = v5;
        v6 = a1 + 2;
LABEL_12:
        result = 0;
        *v6 = 1;
        return result;
      }
    }
  }
  a1[2] = 0;
  v6 = a1 + 2;
  v7 = BET3FLT__int32_ccalloc(*(_QWORD **)(v4 + 8), a1[5], a1[4]);
  *((_QWORD *)a1 + 5) = v7;
  if (v7)
    result = 0;
  else
    result = 2229280778;
  if (a2 && v7)
  {
    BET3FLT__FreePStreamParam((_QWORD *)a2);
    memcpy((void *)a2, a1, 0x2D8uLL);
    goto LABEL_12;
  }
  return result;
}

_QWORD *BET3FLT__FreePStreamParam(_QWORD *result)
{
  _QWORD *v1;
  uint64_t *v2;

  if (*result)
  {
    v1 = result;
    v2 = (uint64_t *)result[5];
    if (v2)
    {
      if (!*((_DWORD *)result + 2))
        result = BET3FLT__int32_free(*(_QWORD **)(*result + 8), v2);
      v1[5] = 0;
      *((_DWORD *)v1 + 2) = 0;
    }
  }
  return result;
}

uint64_t select_float_bet3_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2229280769;
  result = 0;
  *a2 = &ISelect_Bet3;
  return result;
}

uint64_t select_bet3_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2229280775;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 25957;
  }
  return result;
}

uint64_t select_bet3_ClassClose()
{
  return 0;
}

uint64_t select_bet3_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t Object;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t ObjOpen;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v43;
  unsigned int v44;
  _QWORD *v45;
  __int128 v46;
  uint64_t v47;
  int v48[2];
  unsigned int v49;
  char __dst[16];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v49 = 0;
  v47 = 0;
  *(_QWORD *)v48 = 0;
  v5 = 2229280775;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  *(_OWORD *)__dst = 0u;
  v51 = 0u;
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, v48);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else if ((safeh_HandleCheck(a1, a2, 25957, 408) & 0x80000000) != 0)
    {
      return 2229280776;
    }
    else
    {
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      log_OutText(*(_QWORD *)(*(_QWORD *)v48 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Entering select_bet3_ObjOpen", v12, v13, v14, v43);
      v15 = (_QWORD *)heap_Calloc(*(_QWORD **)(*(_QWORD *)v48 + 8), 1, 6584);
      if (v15)
      {
        v20 = v15;
        *v15 = a3;
        v15[1] = a4;
        v21 = *(_QWORD *)v48;
        v15[2] = *(_QWORD *)v48;
        v15[3] = a1;
        Object = objc_GetObject(*(_QWORD *)(v21 + 48), (uint64_t)"SYNTHSTREAM", &v47);
        if ((Object & 0x80000000) != 0
          || (v20[4] = *(_QWORD *)(v47 + 8),
              Object = objc_GetObject(*(_QWORD *)(*(_QWORD *)v48 + 48), (uint64_t)"LINGDB", &v47),
              (Object & 0x80000000) != 0))
        {
          v5 = Object;
          log_OutPublic(*(_QWORD *)(v20[2] + 32), (uint64_t)"SELECT_BET3", 55001, 0, v23, v24, v25, v26, v44);
        }
        else
        {
          v27 = *(_QWORD *)(v47 + 8);
          v20[5] = v27;
          ObjOpen = BET3FLT__select_bet3_FeatureExtractObjOpen(a3, a4, v20[4], v27, v20 + 7);
          if ((ObjOpen & 0x80000000) != 0)
            goto LABEL_27;
          ObjOpen = select_bet3_loc_CreateDataBrkString(*(uint64_t *)v48, __dst);
          if ((ObjOpen & 0x80000000) != 0)
            goto LABEL_27;
          v29 = v20[3];
          if (!v29 || (v30 = *(_QWORD *)(v29 + 48)) == 0)
            v30 = *(_QWORD *)(v20[2] + 48);
          ObjOpen = objc_GetAddRefCountedObject(v30, (uint64_t)__dst, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))select_bet3_loc_ObjcVoiceOpen, (void (*)(_QWORD, _QWORD, _OWORD *))select_bet3_loc_ObjcVoiceClose, *(uint64_t *)v48, &v47);
          if ((ObjOpen & 0x80000000) != 0
            || (v31 = *(_QWORD *)v48,
                v32 = *(_QWORD *)(v47 + 32),
                v20[6] = v32,
                ObjOpen = select_bet3_loc_SetSynthParams(v31, v32),
                (ObjOpen & 0x80000000) != 0))
          {
LABEL_27:
            v5 = ObjOpen;
          }
          else
          {
            v33 = *(_QWORD *)(*(_QWORD *)v48 + 40);
            v45 = v20;
            v46 = xmmword_24D2943F0;
            v34 = paramc_ListenerAdd(v33, "frequencyhz", &v45);
            if ((v34 & 0x80000000) == 0)
            {
              v39 = 0;
              while (1)
              {
                v40 = off_24D2943C8[v39];
                if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)v48 + 40), (uint64_t)v40, &v49) & 0x80000000) != 0)
                {
                  v49 = dword_214F96BC8[v39];
                  v34 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)v48 + 40), (uint64_t)v40, v49);
                  if ((v34 & 0x80000000) != 0)
                    break;
                }
                v34 = select_bet3_loc_ParamSet((uint64_t)v20, v40, v49);
                if ((v34 & 0x80000000) != 0)
                  break;
                v41 = *(_QWORD *)(*(_QWORD *)v48 + 40);
                v45 = v20;
                v46 = xmmword_24D2943F0;
                v5 = paramc_ListenerAdd(v41, v40, &v45);
                if ((v5 & 0x80000000) != 0)
                  goto LABEL_32;
                if (++v39 == 3)
                {
                  *(_QWORD *)a5 = v20;
                  *(_DWORD *)(a5 + 8) = 25958;
                  goto LABEL_29;
                }
              }
            }
            v5 = v34;
LABEL_32:
            log_OutPublic(*(_QWORD *)(v20[2] + 32), (uint64_t)"SELECT_BET3", 55002, (uint64_t)"%s%s", v35, v36, v37, v38, "param");
          }
        }
        *(_QWORD *)a5 = v20;
        *(_DWORD *)(a5 + 8) = 25958;
        select_bet3_ObjClose(v20, *(_QWORD *)(a5 + 8));
        *(_QWORD *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
      }
      else
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)v48 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v16, v17, v18, v19, v44);
        v5 = 2229280778;
      }
LABEL_29:
      log_OutText(*(_QWORD *)(*(_QWORD *)v48 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Leaving select_bet3_ObjOpen: %x", v36, v37, v38, v5);
    }
  }
  return v5;
}

uint64_t select_bet3_ObjClose(_QWORD *a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  char *v10;
  uint64_t v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v19;
  int ObjClose;
  int v22;
  int v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  _QWORD *v31;
  __int128 v32;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 25958, 6584);
  if (v3 < 0)
    return 2229280776;
  LODWORD(v7) = v3;
  v8 = a1[2];
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Entering select_bet3_ObjClose", v4, v5, v6, v30);
  for (i = 0; i != 4; ++i)
  {
    v10 = off_24D294400[i];
    v11 = *(_QWORD *)(v8 + 40);
    v31 = a1;
    v32 = xmmword_24D2943F0;
    v12 = paramc_ListenerRemove(v11, v10, (__int128 *)&v31);
    if ((int)v7 > -1 && v12 < 0)
      v7 = v12;
    else
      v7 = v7;
  }
  v14 = a1[6];
  if (v14)
  {
    v15 = a1[3];
    if (!v15 || (v16 = *(_QWORD *)(v15 + 48)) == 0)
      v16 = *(_QWORD *)(a1[2] + 48);
    v17 = objc_ReleaseObject(v16, v14);
    a1[6] = 0;
    if ((int)v7 > -1 && v17 < 0)
      v7 = v17;
    else
      v7 = v7;
  }
  v19 = a1[7];
  if (v19)
  {
    ObjClose = BET3FLT__select_bet3_FeatureExtractObjClose(v19);
    if ((int)v7 > -1 && ObjClose < 0)
      v7 = ObjClose;
    else
      v7 = v7;
  }
  if (a1[5])
  {
    v22 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"LINGDB");
    if ((int)v7 > -1 && v22 < 0)
      v7 = v22;
    else
      v7 = v7;
  }
  if (a1[4])
  {
    v24 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if ((int)v7 > -1 && v24 < 0)
      v7 = v24;
    else
      v7 = v7;
  }
  heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Leaving select_bet3_ObjClose: %x", v26, v27, v28, v7);
  return v7;
}

uint64_t select_bet3_ObjReopen(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t DataBrkString;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  char __dst[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)__dst = 0u;
  v22 = 0u;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 25958, 6584) & 0x80000000) != 0)
    return 2229280776;
  v6 = a1[2];
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Entering select_bet3_ObjReopen", v3, v4, v5, v19);
  DataBrkString = select_bet3_loc_CreateDataBrkString(v6, __dst);
  if ((DataBrkString & 0x80000000) == 0)
  {
    v11 = a1[3];
    if (!v11 || (v12 = *(_QWORD *)(v11 + 48)) == 0)
      v12 = *(_QWORD *)(a1[2] + 48);
    DataBrkString = objc_GetAddRefCountedObject(v12, (uint64_t)__dst, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))select_bet3_loc_ObjcVoiceOpen, (void (*)(_QWORD, _QWORD, _OWORD *))select_bet3_loc_ObjcVoiceClose, v6, &v20);
    if ((DataBrkString & 0x80000000) == 0)
    {
      v13 = a1[6];
      if (v13)
      {
        v14 = a1[3];
        if (!v14 || (v15 = *(_QWORD *)(v14 + 48)) == 0)
          v15 = *(_QWORD *)(a1[2] + 48);
        objc_ReleaseObject(v15, v13);
      }
      v16 = *(_QWORD *)(v20 + 32);
      a1[6] = v16;
      DataBrkString = select_bet3_loc_SetSynthParams(v6, v16);
    }
  }
  v17 = DataBrkString;
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Leaving select_bet3_ObjReopen: %x", v8, v9, v10, DataBrkString);
  return v17;
}

uint64_t select_bet3_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;

  if ((safeh_HandleCheck(a1, a2, 25958, 6584) & 0x80000000) != 0)
    return 2229280776;
  synstrmaux_InitStreamOpener(a1 + 72, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-cspp-sptchk;version=4.0",
    1,
    a1 + 928);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-cspp-sgt;version=4.0", 1, a1 + 944);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-bet3-speech-frames;version=5.0",
    a1 + 896);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-markers-pp;version=4.0", a1 + 912);
  v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 72), *(_QWORD *)(a1 + 32), a3, a4);
  if ((v8 & 0x80000000) != 0)
    select_bet3_ProcessEnd(a1, a2);
  *(_DWORD *)(a1 + 6576) = 0;
  return v8;
}

uint64_t select_bet3_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  _DWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  _DWORD *v20;
  unsigned int v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v37;
  int v39;
  int v40;
  uint64_t inited;
  int v43;
  unsigned int v44;
  int v45;
  _DWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int ProcessEnd;
  uint64_t v57;
  uint64_t v59;
  int v60;

  v60 = 0;
  if ((safeh_HandleCheck(a1, a2, 25958, 6584) & 0x80000000) != 0)
    return 2229280776;
  *a5 = 1;
  v9 = (_DWORD *)(a1 + 6544);
  v10 = *(_DWORD *)(a1 + 6544);
  if (*(_QWORD *)(a1 + 4616))
  {
    if (!v10)
    {
      v11 = BET3FLT__ParamGenFrames((uint64_t *)(a1 + 4616), (int *)(*(_QWORD *)(a1 + 48) + 8112), (_DWORD *)(a1 + 6544));
      if ((v11 & 0x80000000) != 0)
      {
        v25 = v11;
      }
      else
      {
        v12 = *(_QWORD *)(a1 + 6552);
        if (!v12)
          goto LABEL_65;
        v13 = *(unsigned int *)(a1 + 6564);
        v14 = *(_DWORD *)(a1 + 6560);
        if (v14 <= v13)
          goto LABEL_65;
        v15 = v12 + 32 * v13;
        v16 = *(_DWORD *)(a1 + 5228);
        v17 = *(_DWORD *)(a1 + 5232);
        if (v17 >= v16)
        {
          v23 = 0;
          v20 = (_DWORD *)(v12 + 32 * v13);
        }
        else
        {
          v18 = 0;
          v19 = *(_DWORD *)(a1 + 6576);
          v20 = (_DWORD *)(v12 + 32 * v13);
          do
          {
            if (*v20 == 33)
            {
              v21 = *(_DWORD *)(a1 + 6572);
              v22 = *(_DWORD *)(*(_QWORD *)(a1 + 5216) + 528 * v17 + 24);
              v20[4] = v22;
              *(_DWORD *)(a1 + 6572) = v22 + v21;
              *(_DWORD *)(a1 + 5232) = ++v17;
            }
            else
            {
              if (*v20 == 8)
              {
                v19 = v20[6] / *(_DWORD *)(*(_QWORD *)(a1 + 48) + 152);
                *(_DWORD *)(a1 + 6576) = v19;
              }
              v21 = *(_DWORD *)(a1 + 6572);
              v20[4] = 0;
            }
            if (v19 > v21)
            {
              *(_DWORD *)(a1 + 6576) = v21;
              v19 = v21;
            }
            v20[3] = v21 - v19;
            v20 += 8;
            v23 = v18 + 1;
            if (v17 >= v16)
              break;
            v24 = v13 + 1 + v18++;
          }
          while (v24 < v14);
        }
        if (*v9)
        {
          v44 = v23 + v13;
          if (v23 + (int)v13 < v14)
          {
            v45 = *(_DWORD *)(a1 + 6572);
            v46 = v20 + 4;
            do
            {
              *(v46 - 1) = v45;
              *v46 = 0;
              v46 += 8;
              ++v44;
            }
            while (v44 < v14);
            v23 = v14 - v13;
          }
        }
        if (!v23)
        {
LABEL_65:
          v59 = a1 + 4616;
          v25 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, uint64_t))(*(_QWORD *)(a1 + 32) + 104))(*(_QWORD *)(a1 + 896), *(_QWORD *)(a1 + 904), &v59, 8);
          if ((v25 & 0x80000000) != 0)
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55008, (uint64_t)"%s%s%s%x", v52, v53, v54, v55, "contentType");
          }
          else if (*v9)
          {
            ProcessEnd = BET3FLT__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
            if (ProcessEnd >= 0)
              v25 = v25;
            else
              v25 = ProcessEnd;
            v57 = *(_QWORD *)(a1 + 6552);
            if (v57)
            {
              heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v57);
              *(_QWORD *)(a1 + 6552) = 0;
              *(_QWORD *)(a1 + 6560) = 0;
              *(_DWORD *)(a1 + 6568) = 0;
            }
            v43 = 1;
            goto LABEL_75;
          }
          goto LABEL_74;
        }
        v47 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 104))(*(_QWORD *)(a1 + 912), *(_QWORD *)(a1 + 920), v15, (32 * v23));
        if ((v47 & 0x80000000) == 0)
        {
          *(_DWORD *)(a1 + 6564) += v23;
          goto LABEL_65;
        }
        v25 = v47;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55008, (uint64_t)"%s%s%s%x", v48, v49, v50, v51, "contentType");
        *(_DWORD *)(a1 + 6564) += v23;
      }
LABEL_74:
      v43 = 2;
      goto LABEL_75;
    }
  }
  else if (!v10)
  {
    goto LABEL_22;
  }
  BET3FLT__DeInitVStream((_QWORD *)(a1 + 4616));
  *v9 = 0;
LABEL_22:
  v25 = BET3FLT__select_bet3_FeatureExtractProcessStart(*(uint64_t **)(a1 + 56), *(_QWORD *)(a1 + 48) + 9184, a3, a4, (_QWORD *)(a1 + 960), &v60);
  if ((v25 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55005, (uint64_t)"%s%x", v26, v27, v28, v29, "lhError");
  }
  else if (*(__int16 *)(a1 + 970) > 1)
  {
    *(_DWORD *)(a1 + 6564) = 0;
    inited = BET3FLT__InitVStream(*(_QWORD *)(a1 + 16), (char *)(a1 + 4616), (_DWORD *)(*(_QWORD *)(a1 + 48) + 128));
    if ((inited & 0x80000000) != 0
      || (*(_QWORD *)(a1 + 4624) = a1 + 960,
          inited = BET3FLT__LoadVStream((uint64_t *)(a1 + 4616), *(_QWORD *)(a1 + 48) + 8112, *(_QWORD *)(a1 + 48) + 128), (inited & 0x80000000) != 0)|| (inited = BET3FLT__select_bet3_FeatureExtractProcess(*(uint64_t **)(a1 + 56), *(_QWORD *)(a1 + 48) + 128, a3, a4, *(_QWORD *)(a1 + 928), *(_QWORD *)(a1 + 936), *(_QWORD *)(a1 + 944), *(_QWORD *)(a1 + 952), (unsigned int *)(a1 + 64), a1 + 960, (uint64_t *)(a1 + 6552), (_DWORD *)(a1 + 6560)), (inited & 0x80000000) != 0))
    {
      v25 = inited;
    }
    else
    {
      v25 = BET3FLT__ParamGenStart(a1 + 4616, (int *)(*(_QWORD *)(a1 + 48) + 8112), (int *)(*(_QWORD *)(a1 + 48) + 128));
      if ((v25 & 0x80000000) == 0)
      {
        v43 = 4;
LABEL_75:
        *a5 = v43;
        return v25;
      }
    }
    BET3FLT__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
    BET3FLT__DeInitVStream((_QWORD *)(a1 + 4616));
  }
  else
  {
    v30 = v60;
    if (v60)
    {
      if (*(_QWORD *)(a1 + 912))
      {
        if (*(_DWORD *)(a1 + 4480))
        {
          LODWORD(v25) = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 104))();
          if ((v25 & 0x80000000) != 0)
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55008, (uint64_t)"%s%s%s%x", v31, v32, v33, v34, "contentType");
        }
      }
      v35 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 72), *(_QWORD *)(a1 + 32));
      if (v35 < 0 && (int)v25 > -1)
        LODWORD(v25) = v35;
      v30 = 1;
    }
    *a5 = v30;
    v37 = BET3FLT__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
    if (v37 >= 0 || (int)v25 <= -1)
      v39 = v25;
    else
      v39 = v37;
    v40 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4);
    if (v39 > -1 && v40 < 0)
      return v40;
    else
      return v39;
  }
  return v25;
}

uint64_t select_bet3_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;

  if ((safeh_HandleCheck(a1, a2, 25958, 6584) & 0x80000000) != 0)
    return 2229280776;
  BET3FLT__DeInitVStream((_QWORD *)(a1 + 4616));
  *(_DWORD *)(a1 + 6544) = 0;
  BET3FLT__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
  v3 = *(_QWORD *)(a1 + 6552);
  if (v3)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v3);
    *(_QWORD *)(a1 + 6552) = 0;
    *(_QWORD *)(a1 + 6560) = 0;
    *(_DWORD *)(a1 + 6568) = 0;
  }
  *(_DWORD *)(a1 + 6572) = 0;
  return synstrmaux_CloseStreams((_WORD *)(a1 + 72), *(_QWORD *)(a1 + 32));
}

uint64_t select_bet3_loc_ObjcVoiceOpen(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t VData;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  const char *v43;
  unsigned int v45;
  _OWORD __dst[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  void *__src;
  _QWORD *v72;
  char __s1[256];
  char __b[80];
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v70 = 0;
  __src = 0;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v47 = 0u;
  memset(__dst, 0, sizeof(__dst));
  inited = InitRsrcFunction(a1, a2, &__src);
  if ((inited & 0x80000000) != 0)
    return inited;
  cstdlib_memcpy(__dst, __src, 0x198uLL);
  v47 = *(_OWORD *)(a5 + 32);
  v72 = 0;
  *(_QWORD *)(a4 + 32) = 0;
  v11 = ssftriff_reader_ObjOpen(a1, a2, 0, a3, "FLT3", 1031, (uint64_t *)&v72);
  if (v11 < 0)
    return (v11 & 0x1FFFu) - 2065686528;
  v12 = (char *)heap_Calloc(*((_QWORD **)&__dst[0] + 1), 1, 37800);
  v17 = (uint64_t)v12;
  if (v12)
  {
    cstdlib_strcpy(v12, a3);
    cstdlib_strcpy((char *)(v17 + 9336), a3);
    cstdlib_memset((void *)(v17 + 11328), 255, 0x100uLL);
    cstdlib_memset((void *)(v17 + 12232), 255, 0x11CuLL);
    cstdlib_memset((void *)(v17 + 12560), 255, 0x20uLL);
    *(_DWORD *)(v17 + 11708) = 1;
    BET3FLT__InitVParam((_DWORD *)(v17 + 128));
    cstdlib_memset((void *)(v17 + 7808), -1, 0x12CuLL);
    cstdlib_strcpy((char *)(v17 + 7792), "mlsa");
    cstdlib_memset(__b, 0, 0x50uLL);
    v19 = select_bet3_ParseRiff((uint64_t)__dst, v17, (uint64_t)v72, 0, __b, 0, 0, v18);
    if ((v19 & 0x80000000) != 0)
    {
      VData = v19;
      cstdlib_strcpy(__s1, "");
      if (__b[0])
      {
        v42 = 0;
        v43 = __b;
        do
        {
          cstdlib_strcat(__s1, "/");
          cstdlib_strcat(__s1, v43);
          v43 = &__b[5 * (unsigned __int16)++v42];
        }
        while (*v43);
      }
      log_OutPublic(v47, (uint64_t)"SELECT_BET3", 55003, (uint64_t)"%s%s%s%s%s%x", v38, v39, v40, v41, "file");
    }
    else if (*(_BYTE *)(v17 + 7519) && *(int *)(v17 + 260) > 0)
    {
      v24 = *(uint64_t **)(v17 + 11648);
      if (v24)
      {
        v25 = *v24;
        if (v25)
        {
          v26 = 0;
          v27 = 0;
          do
          {
            *(_QWORD *)(v17 + 8 * v26 + 5432) = v25;
            v26 = (unsigned __int16)++v27;
            v25 = *(_QWORD *)(*(_QWORD *)(v17 + 11648) + 8 * (unsigned __int16)v27);
          }
          while (v25);
        }
      }
      v28 = BET3FLT__InitVData((int)__dst, (char *)(v17 + 8112), (_DWORD *)(v17 + 128));
      if ((v28 & 0x80000000) != 0)
      {
        VData = v28;
      }
      else
      {
        VData = BET3FLT__LoadVData((uint64_t)__dst, v17 + 8112, v17 + 128);
        if ((VData & 0x80000000) == 0)
        {
          *(_WORD *)(v17 + 12762) = 1;
          *(_QWORD *)&v37 = 0x100000001;
          *((_QWORD *)&v37 + 1) = 0x100000001;
          *(_OWORD *)(v17 + 12352) = v37;
          *(_OWORD *)(v17 + 12368) = v37;
          *(_QWORD *)(v17 + 12384) = 0x100000001;
          *(_DWORD *)(v17 + 12396) = 1;
          *(_OWORD *)(v17 + 12412) = v37;
          *(_OWORD *)(v17 + 12428) = v37;
          *(_OWORD *)(v17 + 12444) = v37;
          *(_OWORD *)(v17 + 12460) = v37;
          *(_OWORD *)(v17 + 12476) = v37;
          *(_DWORD *)(v17 + 12492) = 1;
          *(_QWORD *)(v17 + 12496) = 0x100000001;
          *(_DWORD *)(v17 + 11934) = 33620481;
          *(_BYTE *)(v17 + 11961) = 1;
          *(_QWORD *)(v17 + 11939) = 0x101010101010101;
          *(_DWORD *)(v17 + 11983) = -1;
          *(_WORD *)(v17 + 11987) = -255;
          *(_QWORD *)(v17 + 11997) = 0x101010101010101;
          *(_QWORD *)(v17 + 11947) = 0x101010101010101;
          *(_QWORD *)(v17 + 12002) = 0x101010101010101;
          *(_QWORD *)(v17 + 12105) = 0x101010101010101;
          *(_QWORD *)(v17 + 12113) = 0x101010101010101;
          *(_QWORD *)(v17 + 12121) = 0x101010101010101;
          if ((*(_DWORD *)(v17 + 12288) & 0x80000000) == 0)
            *(_WORD *)(v17 + 11963) = 257;
          if ((*(_DWORD *)(v17 + 12304) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11965) = 1;
          if ((*(_DWORD *)(v17 + 12320) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11966) = 1;
          if ((*(_DWORD *)(v17 + 12324) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11967) = 1;
          if ((*(_DWORD *)(v17 + 12328) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11968) = 1;
          if ((*(_DWORD *)(v17 + 12332) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11969) = 1;
          if ((*(_DWORD *)(v17 + 12252) & 0x80000000) == 0)
            *(_WORD *)(v17 + 11957) = 257;
          if ((*(_DWORD *)(v17 + 12576) & 0x80000000) == 0 || (*(_DWORD *)(v17 + 12580) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11956) = 8;
          if ((*(_DWORD *)(v17 + 12256) & 0x80000000) == 0)
            *(_WORD *)(v17 + 11959) = 257;
          if (*(_DWORD *)(v17 + 11744))
            *(_BYTE *)(v17 + 11978) = 9;
          if ((*(_DWORD *)(v17 + 12352) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11997) = 1;
          if ((*(_DWORD *)(v17 + 12356) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11998) = 1;
          if ((*(_DWORD *)(v17 + 12360) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 11999) = 1;
          *(_WORD *)(v17 + 12008) = 257;
          *(_DWORD *)(v17 + 12000) = 16843009;
          *(_DWORD *)(v17 + 12003) = 16843009;
        }
      }
    }
    else
    {
      VData = 2229280772;
      log_OutPublic(v47, (uint64_t)"SELECT_BET3", 55006, (uint64_t)"%s%s", v20, v21, v22, v23, "file");
    }
  }
  else
  {
    log_OutPublic(v47, (uint64_t)"SELECT_BET3", 55000, 0, v13, v14, v15, v16, v45);
    VData = 2229280778;
  }
  if (v72)
  {
    ssftriff_reader_ObjClose(v72, v29, v30, v31, v32, v33, v34, v35);
    v72 = 0;
  }
  if ((VData & 0x80000000) != 0)
  {
    if ((VData & 0x7FF01FFF) == 0xA200014)
      VData = 2229280772;
    else
      VData = VData;
    select_bet3_loc_VoiceClose(__dst, v17);
  }
  else
  {
    *(_QWORD *)(a4 + 32) = v17;
  }
  return VData;
}

uint64_t select_bet3_loc_ObjcVoiceClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  _QWORD *v6;

  v6 = 0;
  inited = InitRsrcFunction(a1, a2, &v6);
  if ((inited & 0x80000000) == 0)
    select_bet3_loc_VoiceClose(v6, *(_QWORD *)(a3 + 32));
  return inited;
}

uint64_t select_bet3_loc_ParamCheckChange(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;

  *a4 = 1;
  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (!cstdlib_strcmp(__s1, "waitfactor") && (LH_atoi(a3) & 0x80000000) != 0)
    {
      result = 2229280783;
LABEL_7:
      *a4 = 0;
      return result;
    }
  }
  else if (*(_QWORD *)(a1 + 896))
  {
    result = 2229280785;
    goto LABEL_7;
  }
  return 0;
}

uint64_t select_bet3_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  unsigned int v11;

  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (cstdlib_strcmp(__s1, "rate") && cstdlib_strcmp(__s1, "waitfactor"))
    {
      if (!cstdlib_strcmp(__s1, "finalsentencefound"))
      {
        if ((unsigned __int16)LH_atou(a3) == 1)
        {
          paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"waitfactorbackup", *(_DWORD *)(a1 + 64));
          return select_bet3_loc_ParamSet(a1, "waitfactor", 0);
        }
        v10 = 0;
        paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"waitfactorbackup", &v10);
        v7 = v10;
        v9 = "waitfactor";
        v8 = a1;
        return select_bet3_loc_ParamSet(v8, v9, v7);
      }
    }
    else
    {
      v11 = 0;
      if (cstdlib_strcmp(__s1, "waitfactor")
        || (paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"finalsentencefound", &v11), v11 != 1))
      {
        v7 = (uint64_t)LH_atoi(a3);
        v8 = a1;
        v9 = __s1;
        return select_bet3_loc_ParamSet(v8, v9, v7);
      }
    }
    return 0;
  }
  if (*(_QWORD *)(a1 + 896))
    return 2229280785;
  else
    return 0;
}

uint64_t select_bet3_loc_CreateDataBrkString(uint64_t a1, char *__dst)
{
  int Str;
  unsigned int v5;
  size_t v6;
  uint64_t v7;
  char *__s2;
  int v10;
  char __src[128];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  __s2 = 0;
  cstdlib_strcpy(__dst, "select");
  Str = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voice", &__s2);
  if (Str < 0)
    return Str & 0x1FFF | 0x84E02000;
  cstdlib_strcat(__dst, "/");
  cstdlib_strcat(__dst, __s2);
  Str = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voicemodel", &__s2);
  if (Str < 0)
    return Str & 0x1FFF | 0x84E02000;
  cstdlib_strcat(__dst, "/");
  cstdlib_strcat(__dst, __s2);
  Str = paramc_ParamGetInt(*(_QWORD *)(a1 + 40), (uint64_t)"frequencyhz", &v10);
  if (Str < 0)
    return Str & 0x1FFF | 0x84E02000;
  cstdlib_strcat(__dst, "f");
  v5 = v10 / 1000;
  v6 = cstdlib_strlen(__dst);
  LH_itoa(v5, &__dst[v6], 0xAu);
  v7 = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"datapackagename", &__s2);
  if ((v7 & 0x80000000) == 0)
  {
    if (__s2)
    {
      if (*__s2)
      {
        v7 = brokeraux_ComposeBrokerString(a1, __dst, 0, 0, 0, 0, 0, __src, 0x80uLL);
        if ((v7 & 0x80000000) == 0)
          cstdlib_strcpy(__dst, __src);
      }
    }
  }
  return v7;
}

uint64_t select_bet3_loc_SetSynthParams(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  v12 = a2 + 7808;
  v4 = paramc_ParamSetStr(*(_QWORD *)(a1 + 40), (uint64_t)"synth_type", (char *)(a2 + 7792));
  if ((v4 & 0x80000000) != 0)
  {
    v10 = v4;
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%s%s%x", v5, v6, v7, v8, "parameter");
  }
  else
  {
    v9 = paramc_ParamSetPermanent(*(_QWORD *)(a1 + 40), (uint64_t)"mrcc_synthparam_ref_ptr", &v12, 8uLL);
    if ((v9 & 0x80000000) == 0)
    {
      v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicealpha", *(float *)(a2 + 128));
      if ((v9 & 0x80000000) == 0)
      {
        v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicebeta", *(float *)(a2 + 132));
        if ((v9 & 0x80000000) == 0)
        {
          v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicevol", *(float *)(a2 + 164));
          if ((v9 & 0x80000000) == 0)
          {
            v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicevuvrelamp", *(float *)(a2 + 140));
            if ((v9 & 0x80000000) == 0)
            {
              v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicemvfboost", *(float *)(a2 + 168));
              if ((v9 & 0x80000000) == 0)
              {
                v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicef0std", *(float *)(a2 + 176));
                if ((v9 & 0x80000000) == 0)
                {
                  v9 = select_bet3_loc_SetSynthParamFloat(a1, (uint64_t)"bet2voicef0mean", *(float *)(a2 + 180));
                  if ((v9 & 0x80000000) == 0)
                  {
                    v9 = select_bet3_loc_SetSynthParamInt(a1, (uint64_t)"bet2voiceframesize", *(_DWORD *)(a2 + 152));
                    if ((v9 & 0x80000000) == 0)
                    {
                      v9 = select_bet3_loc_SetSynthParamInt(a1, (uint64_t)"bet2voiceorder", *(_DWORD *)(a2 + 144));
                      if ((v9 & 0x80000000) == 0)
                      {
                        v9 = select_bet3_loc_SetSynthParamArrayOfBet3_int32(a1, *(void **)(a2 + 7784), *(_DWORD *)(a2 + 144) + 1);
                        if ((v9 & 0x80000000) == 0)
                          return select_bet3_loc_SetSynthParamInt(a1, (uint64_t)"voicepitchavghz", *(_DWORD *)(a2 + 184));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return v9;
  }
  return v10;
}

uint64_t select_bet3_loc_ParamSet(uint64_t a1, char *__s1, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (cstdlib_strcmp(__s1, "waitfactor"))
    return 0;
  if ((a3 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 64) = a3;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Set wait factor %d", v5, v6, v7, a3);
    return 0;
  }
  return 2229280783;
}

uint64_t select_bet3_ParseRiff(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t StringZ;
  _WORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t Position;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  uint64_t ChunkData;
  unsigned int v109;
  int v110;
  uint64_t v111;
  _WORD *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  size_t v118;
  int v119;
  unsigned __int8 *v120;
  unsigned int v121;
  size_t v122;
  uint64_t v123;
  size_t v124;
  void *v125;
  int *v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  unsigned int v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  char *v135;
  _QWORD *v136;
  uint64_t v137;
  _QWORD *v138;
  _QWORD *v139;
  int v140;
  void *v141;
  unsigned int v142;
  uint64_t v143;
  _BYTE *v144;
  uint64_t v145;
  int v146;
  unsigned __int16 v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  char *v152;
  unsigned __int16 v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  char *v157;
  uint64_t v158;
  uint64_t v159;
  char *v160;
  uint64_t v161;
  int v162;
  int RiffStringTable;
  int v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  uint64_t v170;
  int v172;
  int *v173;
  uint64_t *v174;
  uint64_t *v175;
  uint64_t *v176;
  uint64_t *v177;
  uint64_t *v178;
  _BYTE *v179;
  _BYTE *v180;
  _BYTE *v181;
  char *v182;
  _BYTE *v183;
  void *v184;
  _BYTE *v185;
  void *v186;
  unsigned int v187;
  _QWORD *v188;
  char *__s1;
  unsigned __int8 *v190;
  char *__s;
  char *__dst;
  int v195[2];
  char *v196;
  unsigned int v197;
  char __src[4];
  char v199;
  int v200;
  void *v201[32];
  char v202[4];
  char __s2[8];
  uint64_t v204;

  v8 = a7;
  StringZ = 0;
  v204 = *MEMORY[0x24BDAC8D0];
  v14 = (_WORD *)(a2 + 37792);
  v190 = (unsigned __int8 *)(a2 + 11680);
  v200 = 0;
  v199 = 0;
  *(_DWORD *)__src = 0;
  __dst = (char *)&a5[5 * a4];
  v182 = (char *)(a2 + 7792);
  v184 = (void *)(a2 + 7484);
  v186 = (void *)(a2 + 11684);
  v188 = (_QWORD *)(a2 + 7784);
  __s1 = (char *)(a5 + 5);
  v174 = (uint64_t *)(a2 + 11656);
  v175 = (uint64_t *)(a2 + 11648);
  v178 = (uint64_t *)(a2 + 12520);
  v177 = (uint64_t *)(a2 + 12528);
  v176 = (uint64_t *)(a2 + 12536);
  v179 = (_BYTE *)(a2 + 11584);
  v180 = (_BYTE *)(a2 + 10557);
  v181 = (_BYTE *)(a2 + 10814);
  v183 = (_BYTE *)(a2 + 10300);
  v185 = (_BYTE *)(a2 + 10043);
  __s = (char *)(a2 + 9786);
  while ((StringZ & 0x80000000) == 0)
  {
    v15 = ssftriff_reader_OpenChunk(a3, (__int32 *)__src, (unsigned int *)&v200, 0, (uint64_t)a5, a6, a7, a8);
    LODWORD(v16) = v15;
    if ((v15 & 0x80000000) != 0)
    {
      StringZ = v15;
      break;
    }
    cstdlib_strcpy(__dst, __src);
    if (a4 == 1)
    {
      if (cstdlib_strcmp(a5, "FEEX"))
      {
        if (cstdlib_strcmp(a5, "STM3"))
        {
          if (cstdlib_strcmp(__src, "SYNC"))
            goto LABEL_366;
          *(_DWORD *)v202 = 0;
          *(_QWORD *)__s2 = 0;
          if (a6)
          {
            v36 = a6 + ssftriff_reader_GetPosition(a3) - v8;
            *(_QWORD *)__s2 = v36;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v200, __s2, v31, v32, v33, v34, v35);
            if ((ChunkData & 0x80000000) != 0)
              goto LABEL_343;
            v36 = *(_QWORD *)__s2;
          }
          LOBYTE(v201[0]) = 0;
          *(_DWORD *)v202 = 256;
          StringZ = ssftriff_reader_ReadStringZ(a3, v36, v200, 0, v201, (unsigned int *)v202);
          if ((StringZ & 0x80000000) != 0)
          {
LABEL_249:
            v110 = 3;
            goto LABEL_382;
          }
          if (!cstdlib_strcmp((const char *)v201, "SYNTH_TYPE"))
          {
            v109 = *(_DWORD *)v202;
            *(_DWORD *)v202 = 256;
            StringZ = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v200, v109, v201, (unsigned int *)v202);
            if ((StringZ & 0x80000000) != 0)
              goto LABEL_249;
            cstdlib_strcpy(v182, (const char *)v201);
          }
          LODWORD(v16) = StringZ;
        }
        else
        {
          *(_DWORD *)v202 = 0;
          v68 = *(int *)(a2 + 260);
          if (!cstdlib_strcmp(__src, "STC3"))
          {
            LODWORD(v196) = 0;
            *(_QWORD *)__s2 = 0;
            if (a6)
            {
              v172 = v8;
              v107 = a6 + ssftriff_reader_GetPosition(a3) - v8;
              *(_QWORD *)__s2 = v107;
            }
            else
            {
              v16 = ssftriff_reader_GetChunkData(a3, v200, __s2, v69, v70, v71, v72, v73);
              if ((v16 & 0x80000000) != 0)
              {
LABEL_306:
                v110 = 1;
                StringZ = v16;
                goto LABEL_326;
              }
              v172 = v8;
              v107 = *(_QWORD *)__s2;
            }
            v126 = (int *)(a2 + 4 * v68);
            cstdlib_memcpy(v126 + 88, (const void *)(v107 + *(unsigned int *)v202), 4uLL);
            *(_DWORD *)v202 += 4;
            v173 = v126 + 98;
            cstdlib_memcpy(v126 + 98, (const void *)(*(_QWORD *)__s2 + *(unsigned int *)v202), 4uLL);
            v127 = *(_DWORD *)v202;
            *(_DWORD *)v202 += 4;
            v128 = *(_QWORD *)__s2;
            v126[568] = *(_BYTE *)(*(_QWORD *)__s2 + *(unsigned int *)v202) != 0;
            v129 = (v127 + 5);
            *(_DWORD *)v202 = v129;
            cstdlib_memcpy(v126 + 558, (const void *)(v128 + v129), 4uLL);
            v130 = *(_DWORD *)v202 + 4;
            *(_DWORD *)v202 += 4;
            v131 = v126[98];
            if ((int)v131 < 1)
              goto LABEL_296;
            v132 = heap_Calloc(*(_QWORD **)(a1 + 8), v131, 8);
            v133 = a2 + 8 * v68;
            *(_QWORD *)(v133 + 2472) = v132;
            if (!v132)
              LODWORD(v16) = -2065686518;
            if ((v16 & 0x80000000) == 0)
            {
              v134 = heap_Calloc(*(_QWORD **)(a1 + 8), *v173, 8);
              *(_QWORD *)(v133 + 2312) = v134;
              LODWORD(v16) = -2065686518;
              if (v134)
              {
                v130 = *(_DWORD *)v202;
LABEL_296:
                LOBYTE(v201[0]) = 0;
                LODWORD(v196) = 256;
                LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v200, v130, v201, (unsigned int *)&v196);
                if ((v16 & 0x80000000) == 0)
                {
                  v135 = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v201);
                  v136 = (_QWORD *)(a2 + 8 * v68);
                  v136[34] = v135;
                  if (!v135)
                  {
                    v110 = 3;
                    StringZ = 2229280778;
                    goto LABEL_382;
                  }
                  *(_DWORD *)v202 += (_DWORD)v196;
                  if (*v173 >= 1)
                  {
                    v137 = 0;
                    v138 = v136 + 309;
                    v139 = v136 + 289;
                    while (1)
                    {
                      LOBYTE(v201[0]) = 0;
                      LODWORD(v196) = 256;
                      v140 = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v200, *(unsigned int *)v202, v201, (unsigned int *)&v196);
                      if (v140 < 0)
                        break;
                      *(_QWORD *)(*v138 + 8 * v137) = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v201);
                      if (!*(_QWORD *)(*v138 + 8 * v137))
                        goto LABEL_376;
                      *(_DWORD *)v202 += (_DWORD)v196;
                      LOBYTE(v201[0]) = 0;
                      LODWORD(v196) = 256;
                      LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v200, *(unsigned int *)v202, v201, (unsigned int *)&v196);
                      if ((v16 & 0x80000000) != 0)
                        goto LABEL_379;
                      *(_QWORD *)(*v139 + 8 * v137) = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v201);
                      if (!*(_QWORD *)(*v139 + 8 * v137))
                      {
LABEL_376:
                        LODWORD(v16) = -2065686518;
                        goto LABEL_379;
                      }
                      *(_DWORD *)v202 += (_DWORD)v196;
                      if (++v137 >= *v173)
                        goto LABEL_379;
                    }
                    LODWORD(v16) = v140;
                  }
                }
              }
            }
LABEL_379:
            v8 = v172;
            goto LABEL_369;
          }
          if (cstdlib_strcmp(__src, "TRE3"))
          {
            if (cstdlib_strcmp(__src, "PDF3"))
            {
              if (cstdlib_strcmp(__src, "WIN3"))
              {
                if (cstdlib_strcmp(__src, "CBK3"))
                  goto LABEL_366;
                v111 = a2 + 24 * (int)v68 + 5192;
              }
              else
              {
                v145 = a2 + 128 + 4 * v68;
                v146 = *(_DWORD *)(v145 + 304);
                v111 = a2 + 128 + 120 * (int)v68 + 24 * v146 + 3864;
                *(_DWORD *)(v145 + 304) = v146 + 1;
              }
            }
            else
            {
              *(_QWORD *)__s2 = 0;
              if (a6)
              {
                v123 = a6 + ssftriff_reader_GetPosition(a3) - v8;
                *(_QWORD *)__s2 = v123;
              }
              else
              {
                ChunkData = ssftriff_reader_GetChunkData(a3, v200, __s2, v79, v80, v81, v82, v83);
                if ((ChunkData & 0x80000000) != 0)
                {
LABEL_343:
                  StringZ = ChunkData;
                  v110 = 1;
                  v187 = ChunkData;
                  goto LABEL_382;
                }
                v123 = *(_QWORD *)__s2;
              }
              *(_DWORD *)v202 = 256;
              LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, v123, v200, 0, v201, (unsigned int *)v202);
              if ((v16 & 0x80000000) != 0)
              {
                v111 = 0;
              }
              else
              {
                v157 = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v201);
                v158 = a2 + 128 + 4 * v68;
                v159 = *(int *)(v158 + 344);
                *(_QWORD *)(a2 + 128 + 40 * (int)v68 + 8 * v159 + 1304) = v157;
                if ((v202[0] & 3) != 0)
                  *(_DWORD *)v202 -= *(_DWORD *)v202 | 0xFFFFFFFC;
                v111 = a2 + 120 * (int)v68 + 24 * (int)v159 + 2792;
                *(_DWORD *)(v158 + 344) = v159 + 1;
              }
            }
          }
          else
          {
            v111 = a2 + 24 * (int)v68 + 2552;
          }
          if ((v16 & 0x80000000) == 0 && v111)
          {
            v201[0] = 0;
            if (a6)
            {
              v160 = (char *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
            }
            else
            {
              v161 = ssftriff_reader_GetChunkData(a3, v200, v201, v74, v75, v76, v77, v78);
              LODWORD(v16) = v161;
              if ((v161 & 0x80000000) != 0)
              {
                v110 = 1;
                v187 = v161;
                StringZ = v161;
                goto LABEL_382;
              }
              v160 = (char *)v201[0];
            }
            v162 = *(_DWORD *)v202;
            *(_QWORD *)(v111 + 8) = &v160[*(unsigned int *)v202];
            *(_DWORD *)(v111 + 16) = v200 - v162;
          }
        }
      }
      else
      {
        if (!cstdlib_strcmp(__src, "VCAT"))
        {
          v201[0] = 0;
          if (a6)
          {
            v201[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
          }
          else
          {
            v117 = ssftriff_reader_GetChunkData(a3, v200, v201, v42, v43, v44, v45, v46);
            if ((v117 & 0x80000000) != 0)
              return v117;
          }
          v27 = a1;
          v28 = a2;
          v29 = a3;
          v30 = 2;
LABEL_266:
          v106 = select_bet3_ParseRiff(v27, v28, v29, v30, a5, 0, 0);
LABEL_267:
          LODWORD(v16) = v106;
          goto LABEL_369;
        }
        if (!cstdlib_strcmp(__src, "VBOP"))
        {
          v201[0] = 0;
          if (a6)
          {
            v67 = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
            v201[0] = v67;
          }
          else
          {
            v16 = ssftriff_reader_GetChunkData(a3, v200, v201, v47, v48, v49, v50, v51);
            if ((v16 & 0x80000000) != 0)
              return v16;
            v67 = v201[0];
          }
          if (v200 >= 0xF8)
            v124 = 248;
          else
            v124 = v200;
          v125 = v186;
LABEL_287:
          cstdlib_memcpy(v125, v67, v124);
          goto LABEL_369;
        }
        if (cstdlib_strcmp(__src, "PRE3"))
        {
          if (cstdlib_strcmp(__src, "TRA3"))
          {
            if (cstdlib_strcmp(__src, "PHM3"))
              goto LABEL_366;
            v201[0] = 0;
            if (a6)
            {
              v67 = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
              v201[0] = v67;
            }
            else
            {
              v16 = ssftriff_reader_GetChunkData(a3, v200, v201, v62, v63, v64, v65, v66);
              if ((v16 & 0x80000000) != 0)
                return v16;
              v67 = v201[0];
            }
            if (v200 >= 0x100)
              v124 = 256;
            else
              v124 = v200;
            v125 = v184;
            goto LABEL_287;
          }
          *(_WORD *)__s2 = 0;
          v201[0] = 0;
          if (a6)
          {
            v201[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
          }
          else
          {
            v16 = ssftriff_reader_GetChunkData(a3, v200, v201, v57, v58, v59, v60, v61);
            if ((v16 & 0x80000000) != 0)
              return v16;
          }
          if (v200 >= 2)
          {
            v153 = 0;
            do
            {
              cstdlib_memcpy(__s2, (char *)v201[0] + 2 * v153, 2uLL);
              if (*(unsigned __int16 *)__s2 < 8u)
                *(_DWORD *)(a2 + 4 * *(unsigned __int16 *)__s2 + 12560) = 1;
              else
                log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Unknown transition feature: %u for %s", v154, v155, v156, *(unsigned __int16 *)__s2);
              ++v153;
            }
            while (v200 >> 1 > v153);
          }
        }
        else
        {
          *(_WORD *)__s2 = 0;
          v201[0] = 0;
          if (a6)
          {
            v201[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
          }
          else
          {
            v16 = ssftriff_reader_GetChunkData(a3, v200, v201, v52, v53, v54, v55, v56);
            if ((v16 & 0x80000000) != 0)
              return v16;
          }
          if (v200 >= 2)
          {
            v147 = 0;
            do
            {
              cstdlib_memcpy(__s2, (char *)v201[0] + 2 * v147, 2uLL);
              if (*(unsigned __int16 *)__s2 < 0x47u)
                *(_DWORD *)(a2 + 4 * *(unsigned __int16 *)__s2 + 12232) = 1;
              else
                log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Unknown preselection feature: %u for %s", v148, v149, v150, *(unsigned __int16 *)__s2);
              ++v147;
            }
            while (v200 >> 1 > v147);
          }
        }
      }
    }
    else if (a4)
    {
      if (cstdlib_strcmp(a5, "FEEX") || cstdlib_strcmp(__s1, "VCAT"))
      {
LABEL_366:
        cstdlib_strcpy((char *)v201, "");
        v164 = 0;
        do
        {
          cstdlib_strcat((char *)v201, "/");
          cstdlib_strcat((char *)v201, &a5[5 * (unsigned __int16)v164++]);
        }
        while (a4 >= (unsigned __int16)v164);
        log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Unknown data: %s for %s", v165, v166, v167, (uint64_t)v201);
        goto LABEL_369;
      }
      v201[0] = 0;
      if (a6)
      {
        v201[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
      }
      else
      {
        v16 = ssftriff_reader_GetChunkData(a3, v200, v201, v37, v38, v39, v40, v41);
        if ((v16 & 0x80000000) != 0)
          return v16;
      }
      if (cstdlib_strcmp(__src, "ALPH"))
      {
        if (cstdlib_strcmp(__src, "VOIC"))
        {
          if (cstdlib_strcmp(__src, "COVO"))
          {
            if (cstdlib_strcmp(__src, "SAFE"))
            {
              if (cstdlib_strcmp(__src, "PLOS"))
              {
                if (cstdlib_strcmp(__src, "DIFF"))
                {
                  if (cstdlib_strcmp(__src, "GENF"))
                  {
                    if (cstdlib_strcmp(__src, "TAGA"))
                    {
                      if (cstdlib_strcmp(__src, "BTOA"))
                        goto LABEL_366;
                      v112 = v201[0];
                      v113 = v200;
                      v114 = a1;
                      v115 = a3;
                      v116 = v174;
                    }
                    else
                    {
                      v112 = v201[0];
                      v113 = v200;
                      v114 = a1;
                      v115 = a3;
                      v116 = v175;
                    }
                    RiffStringTable = uselect_LoadRiffStringTable(v114, v115, v112, v113, v116);
                  }
                  else
                  {
                    RiffStringTable = select_bet3_LoadRiffGenericFeatureMap(a1, a3, (unsigned __int16 *)v201[0], v200, v178, v177, v176);
                  }
                  goto LABEL_364;
                }
                *(_DWORD *)__s2 = 64;
                v141 = v201[0];
                v142 = v200;
                v143 = a3;
                v144 = v179;
              }
              else
              {
                *(_DWORD *)__s2 = 257;
                v141 = v201[0];
                v142 = v200;
                v143 = a3;
                v144 = v180;
              }
            }
            else
            {
              *(_DWORD *)__s2 = 257;
              v141 = v201[0];
              v142 = v200;
              v143 = a3;
              v144 = v181;
            }
          }
          else
          {
            *(_DWORD *)__s2 = 257;
            v141 = v201[0];
            v142 = v200;
            v143 = a3;
            v144 = v183;
          }
        }
        else
        {
          *(_DWORD *)__s2 = 257;
          v141 = v201[0];
          v142 = v200;
          v143 = a3;
          v144 = v185;
        }
        RiffStringTable = ssftriff_reader_ReadStringZ(v143, (uint64_t)v141, v142, 0, v144, (unsigned int *)__s2);
LABEL_364:
        LODWORD(v16) = RiffStringTable;
        goto LABEL_369;
      }
      *(_DWORD *)__s2 = 257;
      LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v201[0], v200, 0, __s, (unsigned int *)__s2);
      if ((v16 & 0x80000000) == 0)
      {
        *(_WORD *)v190 = 255;
        if (cstdlib_strlen(__s))
        {
          v118 = 0;
          v119 = 0;
          do
          {
            v120 = (unsigned __int8 *)(a2 + v118 + 9786);
            v121 = *v120;
            if (v121 < *v190)
            {
              *v190 = v121;
              v121 = *v120;
            }
            if (v121 > v190[1])
            {
              v190[1] = v121;
              v121 = *v120;
            }
            *(_BYTE *)(a2 + v121 + 11328) = v119;
            v118 = (v119 + 1);
            v122 = cstdlib_strlen(__s);
            v119 = v118;
          }
          while (v122 > v118);
        }
      }
    }
    else if (cstdlib_strcmp(__src, "VCFG"))
    {
      if (cstdlib_strcmp(__src, "EQUA"))
      {
        if (cstdlib_strcmp(__src, "FEEX"))
        {
          if (!cstdlib_strcmp(__src, "STM3"))
          {
            Position = ssftriff_reader_GetPosition(a3);
            v201[0] = 0;
            v106 = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * (unsigned __int16)*v14 + 37584), v201, v101, v102, v103, v104, v105);
            if ((v106 & 0x80000000) == 0)
            {
              ++*v14;
              LODWORD(v16) = select_bet3_ParseRiff(a1, a2, a3, 1, a5, v201[0], Position);
              ++*(_DWORD *)(a2 + 260);
              goto LABEL_369;
            }
            goto LABEL_267;
          }
          if (cstdlib_strcmp(__src, "SYNT"))
            goto LABEL_366;
        }
        v27 = a1;
        v28 = a2;
        v29 = a3;
        v30 = 1;
        goto LABEL_266;
      }
      LODWORD(v16) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * (unsigned __int16)*v14 + 37584), v188, v22, v23, v24, v25, v26);
      if ((v16 & 0x80000000) == 0)
        ++*v14;
    }
    else
    {
      v197 = 0;
      *(_QWORD *)v195 = 0;
      v196 = 0;
      if (a6)
      {
        *(_QWORD *)v195 = a6 + ssftriff_reader_GetPosition(a3) - v8;
      }
      else
      {
        v16 = ssftriff_reader_GetChunkData(a3, v200, v195, v17, v18, v19, v20, v21);
        if ((v16 & 0x80000000) != 0)
          goto LABEL_306;
      }
      v84 = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), "PHRASE");
      *(_QWORD *)(a2 + 208) = v84;
      if (!v84)
        goto LABEL_325;
      *(_DWORD *)(a2 + 216) = 1000;
      v85 = v200;
      if (v200)
      {
        v86 = 0;
        do
        {
          LOBYTE(v201[0]) = 0;
          __s2[0] = 0;
          v197 = 64;
          LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v195, v85, v86, __s2, &v197);
          if ((v16 & 0x80000000) == 0 && v86 < v200)
          {
            v86 += v197;
            v197 = 256;
            LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v195, v200, v86, v201, &v197);
          }
          if ((v16 & 0x80000000) != 0)
            break;
          v87 = v197;
          cstdlib_strcpy(v202, "bet3voiceoverride.");
          cstdlib_strcat(v202, __s2);
          if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)v202, &v196) & 0x80000000) != 0 || !v196 || !*v196)
            v196 = (char *)v201;
          if (!cstdlib_strcmp(__s2, "ALPHA"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v88 = v88;
            *(_DWORD *)(a2 + 128) = LODWORD(v88);
          }
          if (!cstdlib_strcmp(__s2, "BETA"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v89 = v89;
            *(_DWORD *)(a2 + 132) = LODWORD(v89);
          }
          if (!cstdlib_strcmp(__s2, "VUV_REL_AMP"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v90 = v90;
            *(_DWORD *)(a2 + 140) = LODWORD(v90);
          }
          if (!cstdlib_strcmp(__s2, "RHO"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v91 = v91;
            *(_DWORD *)(a2 + 160) = LODWORD(v91);
          }
          if (!cstdlib_strcmp(__s2, "VOL"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v92 = v92;
            *(_DWORD *)(a2 + 164) = LODWORD(v92);
          }
          if (!cstdlib_strcmp(__s2, "MVF_BOOST"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v93 = v93;
            *(_DWORD *)(a2 + 168) = LODWORD(v93);
          }
          if (!cstdlib_strcmp(__s2, "F0_RHO"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v94 = v94;
            *(_DWORD *)(a2 + 172) = LODWORD(v94);
          }
          if (!cstdlib_strcmp(__s2, "F0_STD"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v95 = v95;
            *(_DWORD *)(a2 + 176) = LODWORD(v95);
          }
          if (!cstdlib_strcmp(__s2, "F0_MEAN"))
          {
            cstdlib_atof((unsigned __int8 *)v196);
            *(float *)&v96 = v96;
            *(_DWORD *)(a2 + 180) = LODWORD(v96);
          }
          if (!cstdlib_strcmp(__s2, "FS"))
            *(_DWORD *)(a2 + 136) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "ORDER"))
            *(_DWORD *)(a2 + 144) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE"))
            *(_DWORD *)(a2 + 152) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SPEECH_F0_MEAN"))
            *(_DWORD *)(a2 + 184) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "PDF_VARIANCE_TYPE"))
            *(_DWORD *)(a2 + 200) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "BREAKER"))
          {
            v97 = *(_QWORD *)(a2 + 208);
            v98 = a1;
            if (v97)
            {
              heap_Free(*(_QWORD **)(a1 + 8), v97);
              v98 = a1;
            }
            v99 = BET3FLT__heap_StrDup(*(_QWORD **)(v98 + 8), v196);
            *(_QWORD *)(a2 + 208) = v99;
            if (!v99)
            {
              LODWORD(v16) = -2065686518;
              break;
            }
          }
          if (!cstdlib_strcmp(__s2, "BRK_LENGTH"))
            *(_DWORD *)(a2 + 216) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "BRK_TC"))
            *(_DWORD *)(a2 + 220) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "BRK_ZPAD"))
            *(_DWORD *)(a2 + 224) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "ALGN_ST"))
            *(_DWORD *)(a2 + 240) = LH_atoi(v196) != 0;
          if (!cstdlib_strcmp(__s2, "ALGN_PH"))
            *(_DWORD *)(a2 + 244) = LH_atoi(v196) != 0;
          if (!cstdlib_strcmp(__s2, "VSYNTH"))
            *(_QWORD *)(a2 + 7776) = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), v196);
          if (!cstdlib_strcmp(__s2, "FFTSZ"))
            *(_DWORD *)(a2 + 7808) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "EN_MEAN"))
            *(_DWORD *)(a2 + 7812) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "FEED_EN_MEAN_LOOKAHEAD"))
            *(_DWORD *)(a2 + 7820) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "COUNT_UV_DISTANCE"))
            *(_DWORD *)(a2 + 7816) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SAMPLE_RATE"))
            *(_DWORD *)(a2 + 7824) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENERGY"))
            *(_DWORD *)(a2 + 7828) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_SIZE"))
            *(_DWORD *)(a2 + 7832) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SPCPAR_FREQWARP"))
            *(_DWORD *)(a2 + 7836) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENHANCE_ALPHA"))
            *(_DWORD *)(a2 + 7840) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENHANCE_ALPHA_UNVOICED"))
            *(_DWORD *)(a2 + 7844) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE_MRCC"))
            *(_DWORD *)(a2 + 7848) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_PHS_EXTRAP_USE"))
            *(_DWORD *)(a2 + 7852) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_NOISE_FREQ_TH"))
            *(_DWORD *)(a2 + 7856) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_USE"))
            *(_DWORD *)(a2 + 7860) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_MVF_USE"))
            *(_DWORD *)(a2 + 7864) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_LO"))
            *(_DWORD *)(a2 + 7868) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_HI"))
            *(_DWORD *)(a2 + 7872) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_UNIFORM"))
            *(_DWORD *)(a2 + 7876) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_USE"))
            *(_DWORD *)(a2 + 7880) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_MVF_USE"))
            *(_DWORD *)(a2 + 7884) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_MIXHARM_LO"))
            *(_DWORD *)(a2 + 7888) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_MIXHARM_HI"))
            *(_DWORD *)(a2 + 7892) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_RES_LO"))
            *(_DWORD *)(a2 + 7896) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_RES_HI"))
            *(_DWORD *)(a2 + 7900) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_ALIGN_CUTOFF_FREQ"))
            *(_DWORD *)(a2 + 7904) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF"))
            *(_DWORD *)(a2 + 7908) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ATTENUATE_UV"))
            *(_DWORD *)(a2 + 7912) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_SKIP_WEAK_HARM_RATIO"))
            *(_DWORD *)(a2 + 7916) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_SMOOTH_WIN"))
            *(_DWORD *)(a2 + 7940) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_THR"))
            *(_DWORD *)(a2 + 7944) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_RATIO_EN_THR"))
            *(_DWORD *)(a2 + 7948) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_MVF_THR"))
            *(_DWORD *)(a2 + 7952) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_BY_LOW_EN"))
            *(_DWORD *)(a2 + 7956) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_BY_RATIO_EN"))
            *(_DWORD *)(a2 + 7960) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_0"))
            *(_DWORD *)(a2 + 7964) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_1"))
            *(_DWORD *)(a2 + 7968) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_2"))
            *(_DWORD *)(a2 + 7972) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_3"))
            *(_DWORD *)(a2 + 7976) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_BITS"))
            *(_DWORD *)(a2 + 7980) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "PHSPAR_USE"))
            *(_DWORD *)(a2 + 7984) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_USE"))
            *(_DWORD *)(a2 + 7988) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "USE_LOG2"))
            *(_DWORD *)(a2 + 7992) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENHANCE_POWSPC"))
            *(_DWORD *)(a2 + 7996) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_ATTENUATE"))
            *(_DWORD *)(a2 + 8000) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_ATTENUATE_LO"))
            *(_DWORD *)(a2 + 8004) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_ATTENUATE_HI"))
            *(_DWORD *)(a2 + 8008) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_APPLY_DEEMP"))
            *(_DWORD *)(a2 + 8012) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_HI_RES_ALIGN"))
            *(_DWORD *)(a2 + 8016) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_FAST_AUX_HARM"))
            *(_DWORD *)(a2 + 8020) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_FIX_OLA"))
            *(_DWORD *)(a2 + 8024) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DC_GUARD_VOICED"))
            *(_DWORD *)(a2 + 8028) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DC_GUARD_UNVOICED"))
            *(_DWORD *)(a2 + 8032) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_NYQUIST_GUARD"))
            *(_DWORD *)(a2 + 8036) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "PHSPAR_SIZE"))
            *(_DWORD *)(a2 + 8040) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "PHSPAR_FLIP"))
            *(_DWORD *)(a2 + 8044) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENERGY_NORM_TH"))
            *(_DWORD *)(a2 + 8048) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SPCPAR_FREQWARP_ALPHA"))
            *(_DWORD *)(a2 + 8052) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_PHS_ALIGN_WITH_CONST"))
            *(_DWORD *)(a2 + 8056) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_NORM_GLOBAL"))
            *(_DWORD *)(a2 + 8060) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_DEEMP_COEF"))
            *(_DWORD *)(a2 + 8064) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_USE_NOISE_MODULATION"))
            *(_DWORD *)(a2 + 8068) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "SYN_NOISE_MODULATION_FACTOR"))
            *(_DWORD *)(a2 + 8072) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "MAX_FRAME_SIZE"))
            *(_DWORD *)(a2 + 8076) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "MIN_FRAME_SIZE"))
            *(_DWORD *)(a2 + 8080) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "MIN_FFT_SIZE"))
            *(_DWORD *)(a2 + 8084) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE_INC_NUM"))
            *(_DWORD *)(a2 + 8088) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE_DEC_NUM"))
            *(_DWORD *)(a2 + 8092) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "ANAL_FFT_SIZE"))
            *(_DWORD *)(a2 + 8096) = LH_atoi(v196);
          if (!cstdlib_strcmp(__s2, "FFT_SIZE"))
            *(_DWORD *)(a2 + 8100) = LH_atoi(v196);
          v86 += v87;
          v85 = v200;
        }
        while (v86 < v200);
      }
      cstdlib_strcpy(v202, "bet3voiceoverride.");
      cstdlib_strcat(v202, "BREAKER");
      if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)v202, &v196) & 0x80000000) == 0)
      {
        v151 = *(_QWORD *)(a2 + 208);
        if (v151)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v151);
          *(_QWORD *)(a2 + 208) = 0;
        }
        v152 = BET3FLT__heap_StrDup(*(_QWORD **)(a1 + 8), v196);
        *(_QWORD *)(a2 + 208) = v152;
        if (!v152)
        {
LABEL_325:
          v110 = 3;
          LODWORD(v16) = v187;
          StringZ = 2229280778;
LABEL_326:
          v187 = v16;
LABEL_382:
          if (v110 != 3)
            return v187;
          break;
        }
      }
      cstdlib_strcpy(v202, "bet3voiceoverride.");
      cstdlib_strcat(v202, "BRK_LENGTH");
      if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)v202, &v196) & 0x80000000) == 0)
        *(_DWORD *)(a2 + 216) = LH_atoi(v196);
    }
LABEL_369:
    v168 = ssftriff_reader_CloseChunk(a3);
    if ((int)v16 > -1 && v168 < 0)
      StringZ = v168;
    else
      StringZ = v16;
  }
  if ((StringZ & 0x1FFF) == 0x14)
    v170 = 0;
  else
    v170 = StringZ;
  v16 = StringZ;
  if ((v170 & 0x80000000) == 0)
  {
    *__dst = 0;
    return v170;
  }
  return v16;
}

_QWORD *select_bet3_loc_VoiceClose(_QWORD *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t **v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _WORD *v27;
  unint64_t v28;

  if (a2)
  {
    v3 = (uint64_t)result;
    v4 = *(uint64_t **)(a2 + 11648);
    if (v4 && *v4)
    {
      v5 = 0;
      v6 = 1;
      do
      {
        *(_QWORD *)(a2 + 8 * v5 + 5432) = 0;
        v4 = *(uint64_t **)(a2 + 11648);
        v5 = v6;
      }
      while (v4[v6++]);
    }
    uselect_FreeRiffStringTable(result, v4);
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)(a2 + 11656));
    v8 = *(uint64_t **)(a2 + 12520);
    v9 = *(uint64_t ***)(a2 + 12528);
    v10 = *(uint64_t **)(a2 + 12536);
    if (v8)
    {
      v11 = *v8;
      if (*v8)
      {
        v12 = 0;
        do
        {
          heap_Free(*(_QWORD **)(v3 + 8), v11);
          v11 = v8[(unsigned __int16)++v12];
        }
        while (v11);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v8);
    }
    if (v9)
    {
      v13 = *v9;
      if (*v9)
      {
        v14 = 0;
        v15 = v9;
        do
        {
          v16 = *v13;
          if (*v13)
          {
            v17 = 0;
            do
            {
              heap_Free(*(_QWORD **)(v3 + 8), v16);
              ++v17;
              v13 = *v15;
              v16 = (*v15)[(unsigned __int16)v17];
            }
            while (v16);
          }
          heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v13);
          v15 = &v9[(unsigned __int16)++v14];
          v13 = *v15;
        }
        while (*v15);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v9);
    }
    if (v10)
    {
      v18 = *v10;
      if (*v10)
      {
        v19 = 0;
        do
        {
          heap_Free(*(_QWORD **)(v3 + 8), v18);
          v18 = v10[(unsigned __int16)++v19];
        }
        while (v18);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v10);
    }
    BET3FLT__DeInitVData((void *)v3, (char *)(a2 + 8112));
    BET3FLT__DeInitVParam(v3, (_QWORD *)(a2 + 128));
    v27 = (_WORD *)(a2 + 37792);
    if (*(_WORD *)(a2 + 37792))
    {
      v28 = 0;
      do
        ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a2 + 37584 + 8 * v28++), v20, v21, v22, v23, v24, v25, v26);
      while (v28 < (unsigned __int16)*v27);
    }
    *v27 = 0;
    *(_BYTE *)a2 = 0;
    return heap_Free(*(_QWORD **)(v3 + 8), a2);
  }
  return result;
}

uint64_t select_bet3_LoadRiffGenericFeatureMap(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t i;
  uint64_t *v28;
  uint64_t *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v34;
  char __dst[256];
  uint64_t v36;

  v11 = a1;
  v36 = *MEMORY[0x24BDAC8D0];
  v12 = *a3;
  v13 = heap_Calloc(*(_QWORD **)(a1 + 8), v12 + 1, 8);
  *a5 = v13;
  if (v13)
  {
    v14 = heap_Calloc(*(_QWORD **)(v11 + 8), v12 + 1, 8);
    *a6 = v14;
    if (v14)
    {
      v15 = heap_Calloc(*(_QWORD **)(v11 + 8), v12 + 1, 8);
      *a7 = v15;
      if (v15)
      {
        if (!(_DWORD)v12)
          return 0;
        v16 = 0;
        v17 = 2;
        v28 = a5;
        v29 = a7;
        v30 = v12;
        while (1)
        {
          __dst[0] = 0;
          v34 = 256;
          v18 = ssftriff_reader_ReadStringZ(a2, (uint64_t)a3, a4, v17, __dst, &v34);
          v19 = v34;
          *(_QWORD *)(*a5 + 8 * v16) = BET3FLT__heap_StrDup(*(_QWORD **)(v11 + 8), __dst);
          if (!*(_QWORD *)(*a5 + 8 * v16))
            break;
          v20 = v16;
          v21 = v19 + v17;
          v31 = *(unsigned __int16 *)((char *)a3 + v21);
          *(_QWORD *)(*a6 + 8 * v16) = heap_Calloc(*(_QWORD **)(v11 + 8), v31 + 1, 8);
          if (!*(_QWORD *)(*a6 + 8 * v16))
            break;
          *(_QWORD *)(*a7 + 8 * v16) = heap_Calloc(*(_QWORD **)(v11 + 8), v31 + 1, 1);
          if (!*(_QWORD *)(*a7 + 8 * v16))
            break;
          v17 = v21 + 2;
          if ((_DWORD)v31)
          {
            v22 = v11;
            v23 = 0;
            while (1)
            {
              v24 = v17;
              __dst[0] = 0;
              v34 = 256;
              v18 = ssftriff_reader_ReadStringZ(a2, (uint64_t)a3, a4, v17, __dst, &v34);
              v25 = v34;
              *(_QWORD *)(*(_QWORD *)(*a6 + 8 * v20) + v23) = BET3FLT__heap_StrDup(*(_QWORD **)(v22 + 8), __dst);
              if (!*(_QWORD *)(*(_QWORD *)(*a6 + 8 * v20) + v23))
                return 2229280778;
              v17 += v25;
              v23 += 8;
              if (8 * v31 == v23)
              {
                a5 = v28;
                a7 = v29;
                for (i = 0; i != v31; ++i)
                  *(_BYTE *)(*(_QWORD *)(*v29 + 8 * v20) + i) = *((_BYTE *)a3 + v24 + v25 + i);
                v17 = v24 + v25 + i;
                v11 = v22;
                break;
              }
            }
          }
          v16 = v20 + 1;
          if ((int)v20 + 1 >= v30)
            return v18;
        }
      }
    }
  }
  return 2229280778;
}

uint64_t select_bet3_loc_SetSynthParamFloat(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v11[32];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  __sprintf_chk(v11, 0, 0x20uLL, "%f", a3);
  v9 = paramc_ParamSetStr(*(_QWORD *)(a1 + 40), a2, v11);
  if ((v9 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%f%s%x", v5, v6, v7, v8, "parameter");
  return v9;
}

uint64_t select_bet3_loc_SetSynthParamInt(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = paramc_ParamSetInt(*(_QWORD *)(a1 + 40), a2, a3);
  if ((v8 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%d%s%x", v4, v5, v6, v7, "parameter");
  return v8;
}

uint64_t select_bet3_loc_SetSynthParamArrayOfBet3_int32(uint64_t a1, void *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (!a2)
    return 0;
  v8 = paramc_ParamSet(*(_QWORD *)(a1 + 40), (uint64_t)"bet3cepstralequalizer", a2, (4 * a3));
  if ((v8 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%p%s%d%s%d", v4, v5, v6, v7, "parameter");
  return v8;
}

uint64_t BET3FLT__ParamGenStart(uint64_t a1, int *a2, int *a3)
{
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  int32x2_t *v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int v24;
  uint64_t v25;
  int *v26;
  const char **v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  BOOL v41;
  float v42;
  float v43;
  uint64_t v44;
  _DWORD *v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  float v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int *v57;
  uint64_t v58;
  float *v59;
  uint64_t v60;
  uint64_t i;
  uint64_t v62;
  uint64_t v63;
  int v64;
  char *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  float v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  int32x2_t *v80;
  int *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int *v88;
  uint64_t v89;
  unsigned __int16 *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int32x2_t *v94;

  v4 = a2;
  v5 = a1;
  v6 = *(_QWORD *)a1;
  result = BET3FLT__InitUttModel(*(_QWORD *)a1, (char *)(a1 + 56), a2, *(__int16 *)(*(_QWORD *)(a1 + 8) + 10));
  if ((result & 0x80000000) == 0)
  {
    *(_DWORD *)(v5 + 16) = a3[8];
    v13 = a3[7];
    if (v13 >= 1 && v13 < *(_DWORD *)(v5 + 620))
    {
      BET3FLT__log_select_Error(v6, 55018, (uint64_t)"Specified length of generated speech is too short (this sentence is composed from %d states), specify more than %d milliseconds\n", v8, v9, v10, v11, v12);
      return 2229280775;
    }
    if (*(int *)(v5 + 608) >= 1)
    {
      v14 = 0;
      v85 = 0;
      v86 = 0;
      v92 = v5;
      v93 = (uint64_t)(v4 + 116);
      v15 = *(_DWORD *)(v5 + 32);
      v81 = a3 + 326;
      v82 = *(_QWORD *)(*(_QWORD *)(v5 + 8) + 1784);
      v16 = -0.5;
      v17 = 0.0;
      v18 = 0.0;
      v84 = (uint64_t)a3;
      v89 = (uint64_t)v4;
      v91 = v6;
      while (1)
      {
        v19 = *(_QWORD *)(v5 + 600);
        v20 = (int32x2_t *)(v19 + 528 * v14);
        v87 = v19;
        v94 = v20;
        if (v15 >= 1)
        {
          v21 = 0;
          v22 = v81;
          do
          {
            v23 = &a3[v21];
            v24 = v23[86];
            if (v24 < 1)
            {
              LODWORD(v25) = 0;
            }
            else
            {
              v25 = 0;
              v26 = v23 + 86;
              v27 = (const char **)&a3[2 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 248) + v20->i32[0])
                                     + 1326];
              do
              {
                v28 = *(const char **)&v22[2 * v25];
                if (v28 && *v27)
                {
                  if (!cstdlib_strcmp(v28, *v27))
                    goto LABEL_18;
                  v24 = *v26;
                }
                ++v25;
              }
              while (v25 < v24);
              LODWORD(v25) = 0;
LABEL_18:
              v19 = v87;
              v20 = v94;
            }
            *(_DWORD *)(v19 + 528 * v14 + 4 * v21++ + 32) = v25;
            v22 += 10;
          }
          while (v21 < *(int *)(v5 + 32));
        }
        BET3FLT__log_select_Diag(v6, 21, (uint64_t)"[phoneme %d]\n");
        if (!v82)
          break;
        if (a3[29])
        {
          v34 = v19 + 528 * v14;
          *(_DWORD *)(v34 + 8) = BET3FLT__TreeSearch(*(_QWORD *)(v5 + 8), v14, v93, 0, 0);
          BET3FLT__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
          result = BET3FLT__FindDurPDF(v94, v4, 0, *(_DWORD *)(v34 + 32), 0, *(float *)(v5 + 16));
          if ((result & 0x80000000) != 0)
            return result;
          LOWORD(v35) = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 1784) + 2 * v94->i32[0]);
          v36 = BET3FLT__div_int32_int32_to_Q8_24((float)v35, (float)a3[6]);
          if (v36 != 0.0)
          {
            v37 = v36;
            v38 = 0.0;
            v39 = 0.0;
            if (*v4 >= 1)
            {
              v40 = 2;
              do
              {
                v39 = v39 + BET3FLT__int32_to_Q12_20((float)*(int *)(*(_QWORD *)(v19 + 528 * v14 + 16) + 4 * v40));
                v41 = v40++ <= *v4;
              }
              while (v41);
            }
            v42 = v16 + v37;
            v43 = BET3FLT__div_Q8_24_Q12_20_to_Q8_24(v42, v39);
            v44 = v19 + 528 * v14;
            *(_DWORD *)(v44 + 24) = 0;
            v45 = (_DWORD *)(v44 + 24);
            if (*v4 >= 1)
            {
              v46 = v43;
              v47 = v19 + 528 * v14;
              v50 = *(_QWORD *)(v47 + 16);
              v49 = (uint64_t *)(v47 + 16);
              v48 = v50;
              v51 = 2;
              do
              {
                v52 = BET3FLT__mul_int32_Q8_24_to_Q8_24((float)*(int *)(v48 + 4 * v51), v46);
                v53 = (int)BET3FLT__Q8_24_to_int32(v52 + 0.5);
                if (v53 <= 1)
                  v54 = 1;
                else
                  v54 = v53;
                v48 = *v49;
                *(_DWORD *)(*v49 + 4 * v51) = v54;
                v55 = *v45 + v54;
                *v45 = v55;
                v41 = v51++ <= *v4;
              }
              while (v41);
              v38 = (float)v55;
            }
            v16 = v42 - BET3FLT__int32_to_Q8_24(v38);
          }
LABEL_45:
          *(_DWORD *)(v5 + 624) += *(_DWORD *)(v19 + 528 * v14 + 24);
          goto LABEL_46;
        }
        if (!a3[28])
          break;
        result = BET3FLT__log_select_Error(v6, 55017, (uint64_t)"State level segmentation is not currently supported\n", v29, v30, v31, v32, v33);
LABEL_46:
        v83 = v14;
        v15 = *(_DWORD *)(v5 + 32);
        if (v15 >= 1)
        {
          for (i = 0; i < v15; ++i)
          {
            v62 = *(_QWORD *)(v5 + 24);
            if (!*(_DWORD *)(v62 + 1528 * i + 1480))
            {
              if (*(_DWORD *)(v62 + 1528 * i + 1488))
              {
                v63 = v5 + 8 * i;
                v64 = *v4 * v83;
                v85 = *(_QWORD *)(*(_QWORD *)(v63 + 304) + 8 * v64);
                v86 = *(_QWORD *)(*(_QWORD *)(v63 + 224) + 8 * v64);
              }
              v65 = (char *)v4 + 2 * i;
              if (*((_WORD *)v65 + 324))
              {
                v66 = 0;
                v67 = 0;
                v90 = (unsigned __int16 *)(v65 + 648);
                v68 = v19 + 528 * v83;
                v69 = (_QWORD *)(v68 + 8 * i);
                v70 = v69 + 9;
                v71 = v69 + 19;
                v72 = v69 + 29;
                v88 = (int *)(v68 + 4 * i + 32);
                do
                {
                  v73 = *(unsigned __int16 *)(*(_QWORD *)&v4[2 * i + 142] + v66);
                  *(_DWORD *)(*v70 + 4 * v73) = BET3FLT__TreeSearch(*(_QWORD *)(v92 + 8), v94->i32[0], v93, i, v67);
                  result = BET3FLT__log_select_Diag(v91, 6, (uint64_t)"%s pdf state %d id %d\n");
                  v74 = *(_QWORD *)(v92 + 24);
                  if (*(_DWORD *)(v74 + 1528 * i + 1488))
                  {
                    v75 = v73 - 2 + (v73 - 2) * v4[i + 1];
                    *(_QWORD *)(*v71 + 8 * v73) = v86 + 4 * v75;
                    *(_QWORD *)(*v71 + 8 * v73) -= 4;
                    *(_QWORD *)(*v72 + 8 * v73) = v85 + 4 * v75;
                    *(_QWORD *)(*v72 + 8 * v73) -= 4;
                    result = BET3FLT__FindMsdPDF(i, v73, (uint64_t)v94, v89, v84, *v88);
                    if ((result & 0x80000000) != 0)
                      return result;
                  }
                  else if (*(_DWORD *)(v74 + 1528 * i + 1484))
                  {
                    result = BET3FLT__FindContPDF(i, v73, (uint64_t)v94, v89, *v88);
                    if ((result & 0x80000000) != 0)
                      return result;
                  }
                  ++v67;
                  v66 += 16;
                }
                while (v67 < *v90);
                v5 = v92;
                v15 = *(_DWORD *)(v92 + 32);
                a3 = (int *)v84;
                v4 = (int *)v89;
                v19 = v87;
              }
            }
          }
        }
        v14 = v83 + 1;
        v6 = v91;
        if (v83 + 1 >= *(int *)(v5 + 608))
        {
          v13 = a3[7];
          goto LABEL_65;
        }
      }
      v56 = v19 + 528 * v14;
      *(_DWORD *)(v56 + 8) = BET3FLT__TreeSearch(*(_QWORD *)(v5 + 8), v14, v93, 0, 0);
      v57 = (int *)(v56 + 8);
      result = BET3FLT__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
      if (a3[7])
      {
        v58 = *v4;
        if ((int)v58 >= 1)
        {
          v59 = (float *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v4 + 21) + 8 * *(int *)(v19 + 528 * v14 + 32))
                                    + 8 * *v57)
                        + 8);
          v60 = (v58 + 2) - 2;
          do
          {
            v18 = v18 + *v59;
            v17 = v17 + v59[v58];
            ++v59;
            --v60;
          }
          while (v60);
        }
        goto LABEL_46;
      }
      result = BET3FLT__FindDurPDF(v94, v4, 0, *(_DWORD *)(v19 + 528 * v14 + 32), 0, *(float *)(v5 + 16));
      if ((result & 0x80000000) != 0)
        return result;
      SetSilenceDuration(v5, v4, (uint64_t)a3, (int *)v94);
      goto LABEL_45;
    }
    v18 = 0.0;
    v17 = 0.0;
LABEL_65:
    if (v13 < 1
      || (v76 = BET3FLT__int32_to_Q18_14(result, (float)v13),
          v77 = BET3FLT__div_Q18_14_Q18_14_to_Q18_14(v76 - v18, v17),
          *(float *)(v5 + 16) = BET3FLT__Q18_14_to_Q1_15(v77),
          *(int *)(v5 + 608) < 1))
    {
LABEL_70:
      if (BET3FLT__log_select_GetLogLevel(*(_QWORD *)(v6 + 32)) >= 0x15)
        OutLabel(v5);
      BET3FLT__log_select_Diag(v6, 2, (uint64_t)">> tree search done\n");
      AddBreakMarks(v5, v4, (uint64_t)a3);
      return ParamGenLT(v5, v4);
    }
    else
    {
      v78 = 0;
      v79 = 0;
      while (1)
      {
        v80 = (int32x2_t *)(*(_QWORD *)(v5 + 600) + v78);
        result = BET3FLT__FindDurPDF(v80, v4, 0, v80[4].i32[0], 0, *(float *)(v5 + 16));
        if ((result & 0x80000000) != 0)
          break;
        SetSilenceDuration(v5, v4, (uint64_t)a3, (int *)v80);
        *(_DWORD *)(v5 + 624) += v80[3].i32[0];
        ++v79;
        v78 += 528;
        if (v79 >= *(int *)(v5 + 608))
          goto LABEL_70;
      }
    }
  }
  return result;
}

void SetSilenceDuration(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  int v20;
  float v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  int v25;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *a4;
  if (*(_BYTE *)(*(_QWORD *)(v4 + 32) + v5) == 1)
  {
    v8 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 1784) + 2 * v5) / *(int *)(a3 + 24);
    LODWORD(v4) = *a2;
    if (v8 <= *a2)
    {
      if ((int)v4 >= 1)
      {
        v14 = *((_QWORD *)a4 + 2);
        v15 = 2;
        do
        {
          *(_DWORD *)(v14 + 4 * v15) = 1;
          v11 = v15++ <= *a2;
        }
        while (v11);
        LODWORD(v4) = *a2;
      }
      a4[6] = v4;
    }
    else
    {
      if (v8 >= a4[6])
      {
        if ((int)v4 < 1)
        {
          v12 = 0;
          v13 = 0;
        }
        else
        {
          v13 = 0;
          v12 = 0;
          v16 = *((_QWORD *)a4 + 2);
          v17 = 2;
          do
          {
            v18 = *(_DWORD *)(v16 + 4 * v17);
            if (v18 <= 0)
            {
              v18 = 1;
              *(_DWORD *)(v16 + 4 * v17) = 1;
              LODWORD(v4) = *a2;
            }
            v19 = v17 == 2 || v17 == (_DWORD)v4 + 1;
            if (v19)
              v20 = 0;
            else
              v20 = v18;
            v12 += v20;
            if (!v19)
              v18 = 0;
            v13 += v18;
            v11 = v17++ <= (int)v4;
          }
          while (v11);
        }
      }
      else
      {
        if ((int)v4 >= 1)
        {
          v9 = *((_QWORD *)a4 + 2);
          v10 = 2;
          do
          {
            *(_DWORD *)(v9 + 4 * v10) = 1;
            v4 = *a2;
            v11 = v10++ <= v4;
          }
          while (v11);
        }
        v12 = v4 - 2;
        v13 = 2;
      }
      v21 = BET3FLT__div_int32_int32_to_Q8_24((float)(v8 - v13), (float)v12);
      a4[6] = v13;
      LODWORD(v22) = *a2;
      if (*a2 >= 3)
      {
        v23 = v21;
        v24 = 3;
        do
        {
          if (v24 >= (int)v22)
            v25 = v8 - v13;
          else
            v25 = (int)BET3FLT__mul_int32_Q8_24_to_int32((float)*(int *)(*((_QWORD *)a4 + 2) + 4 * v24), v23);
          if (v25 <= 1)
            v25 = 1;
          *(_DWORD *)(*((_QWORD *)a4 + 2) + 4 * v24) = v25;
          v13 = a4[6] + v25;
          a4[6] = v13;
          v22 = *a2;
          v11 = v24++ < v22;
        }
        while (v11);
      }
    }
  }
}

uint64_t OutLabel(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  if (*(int *)(result + 608) >= 1)
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v1 + 600) + v2;
      result = BET3FLT__log_select_Diag(*(_QWORD *)v1, 21, (uint64_t)"%d %d %d [%d]\n");
      v4 += *(_DWORD *)(v5 + 24);
      ++v3;
      v2 += 528;
    }
    while (v3 < *(int *)(v1 + 608));
  }
  return result;
}

uint64_t AddBreakMarks(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int *v22;
  uint64_t v23;
  int v24;
  int v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;

  result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE_TIME");
  if ((_DWORD)result)
  {
    result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE");
    if ((_DWORD)result)
    {
      result = cstdlib_strcmp(*(const char **)(a3 + 80), "WORD");
      if ((_DWORD)result)
      {
        result = cstdlib_strcmp(*(const char **)(a3 + 80), "SYLLABLE");
        if ((_DWORD)result)
        {
          result = cstdlib_strcmp(*(const char **)(a3 + 80), "TIME");
          if ((_DWORD)result)
          {
            result = cstdlib_strcmp(*(const char **)(a3 + 80), "NONE");
            if ((_DWORD)result)
              return BET3FLT__log_select_Error(*(_QWORD *)a1, 55036, (uint64_t)"valid breaker is required\n", v7, v8, v9, v10, v11);
          }
          else
          {
            v38 = *(unsigned int *)(a1 + 608);
            if ((int)v38 >= 1)
            {
              v39 = 0;
              v40 = 0;
              v41 = *(_DWORD *)(a3 + 88);
              v42 = *a2;
              v43 = *(_QWORD *)(a1 + 600);
              v44 = v41;
              v45 = 0;
              do
              {
                if (v42 >= 1)
                {
                  result = *(_QWORD *)(v43 + 528 * v39 + 16) + 8;
                  v46 = (v42 + 2) - 2;
                  v45 = v40;
                  do
                  {
                    v47 = *(_DWORD *)result;
                    result += 4;
                    v45 += v47;
                    --v46;
                  }
                  while (v46);
                }
                if (v45 > v44)
                {
                  v44 = v40 + v41;
                  v48 = v43 + 528 * v39;
                  result = *(_DWORD *)(v48 + 4) | 2u;
                  *(_DWORD *)(v48 + 4) = result;
                }
                ++v39;
                v40 = v45;
              }
              while (v39 != v38);
            }
          }
        }
        else
        {
          v34 = *(_DWORD *)(a1 + 608);
          if (v34 >= 3)
          {
            v35 = (v34 - 2);
            v36 = *(int **)(a1 + 600);
            v37 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
            do
            {
              if (*(_BYTE *)(v37 + *v36))
                v36[133] |= 2u;
              v36 += 132;
              --v35;
            }
            while (v35);
          }
        }
      }
      else
      {
        v30 = *(_DWORD *)(a1 + 608);
        if (v30 >= 3)
        {
          v31 = (v30 - 2);
          v32 = *(int **)(a1 + 600);
          v33 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
          do
          {
            if ((*(_BYTE *)(v33 + *v32) & 0xFE) == 2)
              v32[133] |= 2u;
            v32 += 132;
            --v31;
          }
          while (v31);
        }
      }
    }
    else
    {
      v26 = *(_DWORD *)(a1 + 608);
      if (v26 >= 3)
      {
        v27 = (v26 - 2);
        v28 = *(int **)(a1 + 600);
        v29 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
        do
        {
          if (*(_BYTE *)(v29 + *v28) == 3)
            v28[133] |= 2u;
          v28 += 132;
          --v27;
        }
        while (v27);
      }
    }
  }
  else
  {
    v12 = *(int *)(a1 + 608);
    if ((int)v12 >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = *(_QWORD *)(a1 + 600);
      v16 = *a2;
      v17 = *(_DWORD *)(a3 + 88);
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
      v19 = v12 - 2;
      v20 = *(unsigned int *)(a1 + 608);
      do
      {
        if (v16 < 1)
        {
          v21 = 0;
        }
        else
        {
          v21 = 0;
          v22 = (int *)(*(_QWORD *)(v15 + 528 * v13 + 16) + 8);
          v23 = (v16 + 2) - 2;
          do
          {
            v24 = *v22++;
            v21 += v24;
            --v23;
          }
          while (v23);
        }
        v14 += v21;
        if (v14 > v17)
        {
          *(_DWORD *)(v15 + 528 * v13 + 4) |= 2u;
          v14 = v21;
        }
        result = v15 + 528 * v13;
        if (*(_BYTE *)(v18 + *(int *)result) == 3 && v13 < v19)
        {
          v14 = 0;
          *(_DWORD *)(result + 532) |= 2u;
        }
        ++v13;
      }
      while (v13 != v20);
    }
  }
  return result;
}

uint64_t ParamGenLT(uint64_t a1, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  BOOL v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t inited;
  uint64_t v29;
  _QWORD *v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  float v61;
  _QWORD *v62;
  uint64_t v63;
  _QWORD *v64;
  float v65;
  uint64_t *v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t *v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _OWORD v77[4];
  _OWORD v78[4];
  _OWORD __b[46];

  v3 = *(_QWORD *)a1;
  v4 = 2229280778;
  memset(__b, 0, 512);
  memset(v78, 0, sizeof(v78));
  memset(v77, 0, sizeof(v77));
  cstdlib_memset(__b, 0, 0x2D8uLL);
  BET3FLT__InitSMatrices(v3, v78);
  BET3FLT__InitSMatrices(v3, v77);
  v5 = heap_Calloc(*(_QWORD **)(v3 + 8), (*(_DWORD *)(a1 + 624) + 1), 1);
  *(_QWORD *)(a1 + 48) = v5;
  if (!v5)
    return v4;
  v6 = heap_Calloc(*(_QWORD **)(v3 + 8), (*(_DWORD *)(a1 + 624) + 1), 4);
  *(_QWORD *)(a1 + 40) = v6;
  if (!v6)
    return v4;
  v7 = *(_DWORD *)(a1 + 608);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    LODWORD(v10) = *a2;
    do
    {
      if ((int)v10 >= 1)
      {
        v11 = *(_QWORD *)(a1 + 600) + 528 * v8;
        v14 = *(_QWORD *)(v11 + 16);
        v12 = (uint64_t *)(v11 + 16);
        v13 = v14;
        v15 = v12 + 37;
        v16 = 2;
        do
        {
          if (*(int *)(v13 + 4 * v16) >= 1)
          {
            v17 = 0;
            v18 = v9;
            do
            {
              *(_BYTE *)(*(_QWORD *)(a1 + 48) + v18) = *(_BYTE *)(*v15 + v16);
              *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v18++) = *(_DWORD *)(v12[38] + 4 * v16);
              v13 = *v12;
              ++v17;
            }
            while (v17 < *(_DWORD *)(*v12 + 4 * v16));
            v9 += v17;
          }
          v19 = *(unsigned int *)(a1 + 32);
          if ((int)v19 >= 1)
          {
            v20 = *(_DWORD **)(a1 + 24);
            do
            {
              if (v20[372] && ((1 << v20[3]) & (unint64_t)*(unsigned __int8 *)(*v15 + v16)) >> v20[3])
                v20[11] += *(_DWORD *)(v13 + 4 * v16);
              v20 += 382;
              --v19;
            }
            while (v19);
          }
          v10 = *a2;
          v21 = v16++ <= v10;
        }
        while (v21);
        v7 = *(_DWORD *)(a1 + 608);
      }
      ++v8;
    }
    while (v8 < v7);
  }
  if (*(int *)(a1 + 32) < 1)
  {
    v4 = 0;
    goto LABEL_65;
  }
  v22 = 0;
  v23 = 0;
  v4 = 0;
  v24 = (_QWORD *)(a1 + 56);
  while (1)
  {
    v25 = *(_QWORD *)(a1 + 24);
    v26 = v25 + 1528 * v22;
    if (*(_DWORD *)(v26 + 1488))
      break;
LABEL_61:
    if (++v22 >= *(int *)(a1 + 32))
      goto LABEL_65;
  }
  if (!*(_DWORD *)(v25 + 1528 * v22 + 44))
  {
LABEL_60:
    BET3FLT__DeInitMSDUttModel(v24, v22);
    goto LABEL_61;
  }
  v27 = (uint64_t *)(v26 + 24);
  inited = BET3FLT__InitPStreamParam((_DWORD *)(v26 + 24), 0);
  if ((inited & 0x80000000) == 0)
  {
    v29 = BET3FLT__InitPStreamSM(v27, (uint64_t)v78);
    v4 = v29;
    if ((v29 & 0x80000000) != 0)
      goto LABEL_65;
    v31 = *(_DWORD *)(a1 + 608);
    if (v31 >= 1)
    {
      v67 = v27;
      v68 = v29;
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = v25 + 1528 * v22;
      v36 = v35 + 56;
      v37 = (_QWORD *)(v35 + 96);
      v38 = (_QWORD *)(v35 + 104);
      v39 = *a2;
      v74 = v22;
      do
      {
        if (v39 >= 1)
        {
          v69 = v32;
          v40 = *(_QWORD *)(a1 + 600) + 528 * v32;
          v41 = v40 + 8 * v22;
          v42 = *(_QWORD *)(v40 + 16);
          v71 = (uint64_t *)(v40 + 16);
          v30 = (_QWORD *)(v41 + 152);
          v43 = (_QWORD *)(v41 + 232);
          v44 = 2;
          do
          {
            if (*(int *)(v42 + 4 * v44) >= 1)
            {
              v45 = v34;
              v46 = *(_QWORD *)(a1 + 24);
              v47 = 1;
              v75 = v44;
              do
              {
                if (*(int *)(v46 + 1528 * v22 + 36) >= 1)
                {
                  v72 = v47;
                  v48 = 0;
                  v73 = v33;
                  v49 = v33;
                  v76 = v33;
                  do
                  {
                    v50 = *(_DWORD *)(v46 + 1528 * v22 + 12);
                    v51 = 1 << v50;
                    v52 = (1 << v50);
                    v23 |= v52;
                    v53 = *(int **)(*(_QWORD *)(*(_QWORD *)v36 + 8) + 8 * v48);
                    v55 = *v53;
                    v54 = v53[1];
                    if (v55 <= v54)
                    {
                      v56 = v52 ^ 0xFF;
                      v57 = v54 - v55 + 1;
                      v58 = v34 + v55;
                      do
                      {
                        v59 = v56;
                        if ((v58 & 0x80000000) == 0)
                        {
                          v59 = v56;
                          if (*(_DWORD *)(a1 + 624) >= (signed int)v58)
                            v59 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + v58);
                        }
                        v23 &= v59;
                        ++v58;
                        --v57;
                      }
                      while (v57);
                    }
                    if ((unint64_t)(v51 & *(_BYTE *)(*(_QWORD *)(a1 + 48) + v45)) >> v50)
                    {
                      if (!v48 || (v51 & v23) >> v50)
                      {
                        v60 = 4 * v48 + 4;
                        *(_DWORD *)(*(_QWORD *)(*v37 + 8 * v49) + 4 * v48) = *(_DWORD *)(*(_QWORD *)(*v30 + 8 * v44)
                                                                                       + v60);
                        v61 = *(float *)(*(_QWORD *)(*v43 + 8 * v44) + v60);
                        if (*(_DWORD *)(v46 + 1528 * v22 + 1492))
                        {
                          *(float *)(*(_QWORD *)(*v38 + 8 * v49) + 4 * v48) = v61;
                        }
                        else
                        {
                          v62 = v38;
                          v63 = v36;
                          v64 = v30;
                          v65 = BET3FLT__bet3_finv(v61);
                          v30 = v64;
                          v44 = v75;
                          v49 = v76;
                          v36 = v63;
                          v22 = v74;
                          v38 = v62;
                          *(float *)(*(_QWORD *)(*v62 + 8 * v76) + 4 * v48) = v65;
                          v46 = *(_QWORD *)(a1 + 24);
                        }
                      }
                      else
                      {
                        *(_DWORD *)(*(_QWORD *)(*v37 + 8 * v49) + 4 * v48) = 0;
                        *(_DWORD *)(*(_QWORD *)(*v38 + 8 * v49) + 4 * v48) = 0;
                      }
                    }
                    ++v48;
                  }
                  while (v48 < *(int *)(v46 + 1528 * v22 + 36));
                  v42 = *v71;
                  v33 = v73;
                  v47 = v72;
                }
                if (((1 << *(_DWORD *)(v46 + 1528 * v22 + 12)) & (unint64_t)*(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + v45)) >> *(_DWORD *)(v46 + 1528 * v22 + 12))
                  ++v33;
                ++v45;
                ++v34;
                v21 = v47++ < *(_DWORD *)(v42 + 4 * v44);
              }
              while (v21);
              v39 = *a2;
              v34 = v45;
            }
            v21 = v44++ <= v39;
          }
          while (v21);
          v31 = *(_DWORD *)(a1 + 608);
          v32 = v69;
        }
        ++v32;
      }
      while (v32 < v31);
      v24 = (_QWORD *)(a1 + 56);
      if (v33 < 1)
      {
        v4 = v68;
        v27 = v67;
      }
      else
      {
        v27 = v67;
        (**(void (***)(uint64_t *, _QWORD, uint64_t, _QWORD *))(*(_QWORD *)(a1 + 24) + 1528 * v22 + 1504))(v67, 0, v36, v30);
        v4 = v68;
      }
    }
    BET3FLT__FreePStreamSM((uint64_t)v27);
    goto LABEL_60;
  }
  v4 = inited;
LABEL_65:
  BET3FLT__FreePStreamParam(__b);
  BET3FLT__FreeSMatrices((uint64_t)v78);
  BET3FLT__FreeSMatrices((uint64_t)v77);
  return v4;
}

uint64_t BET3FLT__ParamGenFrames(uint64_t *a1, int *a2, _DWORD *a3)
{
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  int v31;
  uint64_t v33;
  int v34;
  int *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD **v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  _DWORD *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  _DWORD *v88;
  _DWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t *v93;
  int **v94;
  int *v95;
  int v96;
  uint64_t v97;
  signed int v98;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  int *v106;
  _QWORD **v107;
  uint64_t v108;
  unsigned int *v109;
  unsigned int inited;
  uint64_t v111;
  int *v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t *v115;
  uint64_t v116;
  _DWORD *v117;
  uint64_t v118;
  int v119;
  _OWORD v120[4];
  _OWORD v121[4];
  _OWORD __b[46];

  v4 = a1;
  v5 = *a1;
  memset(__b, 0, 512);
  memset(v121, 0, sizeof(v121));
  memset(v120, 0, sizeof(v120));
  *a3 = 0;
  cstdlib_memset(__b, 0, 0x2D8uLL);
  BET3FLT__InitSMatrices(v5, v121);
  v103 = v5;
  BET3FLT__InitSMatrices(v5, v120);
  v6 = *((_DWORD *)v4 + 153);
  v7 = v4[75] + 528 * v6;
  *(_DWORD *)(v7 + 4) &= ~2u;
  v8 = *((_DWORD *)v4 + 152);
  v9 = __OFSUB__(v8, v6);
  v10 = v8 - v6;
  if ((v10 < 0) ^ v9 | (v10 == 0))
  {
    LODWORD(v12) = 0;
    v11 = 0;
  }
  else
  {
    v11 = 0;
    LODWORD(v12) = 0;
    while ((*(_BYTE *)(v7 + 4) & 2) == 0)
    {
      v13 = *a2;
      if ((int)v13 >= 1)
      {
        v14 = (int *)(*(_QWORD *)(v7 + 16) + 8);
        do
        {
          v15 = *v14++;
          LODWORD(v12) = v15 + v12;
          --v13;
        }
        while (v13);
      }
      v7 += 528;
      if (++v11 == v10)
      {
        v11 = v10;
        break;
      }
    }
  }
  BET3FLT__log_select_Diag(v5, 2, (uint64_t)"| processing %d models %d frames <=> ");
  if (*((int *)v4 + 8) >= 1)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v119 = 0;
    v19 = 0;
    inited = 0;
    v101 = -(uint64_t)v11;
    v102 = v11;
    v115 = v4;
    v106 = a2;
    while (1)
    {
      v20 = v4[3];
      if (*(_DWORD *)(v20 + 1528 * v16 + 1484))
      {
        v21 = v20 + 1528 * v16;
        v107 = (_QWORD **)(v21 + 64);
        v116 = v16;
        v117 = (_DWORD *)(v21 + 24);
        if (*(_QWORD *)(v21 + 64))
        {
          BET3FLT__FreePStreamParam((_QWORD *)(v21 + 24));
          v16 = v116;
        }
        v22 = v4[3] + 1528 * v16;
        v23 = *(_DWORD *)(v22 + 1496);
        v111 = *(unsigned int *)(v22 + 1500);
        v24 = *((_DWORD *)v4 + 153);
        v25 = *((_DWORD *)v4 + 152);
        if ((int)(v17 + v11 + v24) < v25 && v18 < v23)
        {
          v27 = *a2;
          v28 = v7;
          do
          {
            if (v27 >= 1)
            {
              v29 = (int *)(*(_QWORD *)(v28 + 16) + 8);
              v30 = (v27 + 2) - 2;
              do
              {
                v31 = *v29++;
                v18 += v31;
                --v30;
              }
              while (v30);
            }
            v28 += 528;
            v17 = (v17 + 1);
          }
          while ((int)(v17 + v11 + v24) < v25 && v18 < v23);
        }
        if (v24 > v119 && v19 < v23)
        {
          v33 = v7 + 528 * v101;
          v34 = *a2;
          do
          {
            if (v34 >= 1)
            {
              v35 = (int *)(*(_QWORD *)(v33 - 512) + 8);
              v36 = (v34 + 2) - 2;
              do
              {
                v37 = *v35++;
                v19 += v37;
                --v36;
              }
              while (v36);
            }
            if (v24 <= ++v119)
              break;
            v33 -= 528;
          }
          while (v19 < v23);
        }
        v108 = v7;
        v104 = v17;
        BET3FLT__log_select_Diag(v103, 3, (uint64_t)"L: %d %d  R: %d %d\n");
        v38 = v20 + 1528 * v116;
        *(_DWORD *)(v38 + 44) = v12;
        v109 = (unsigned int *)(v38 + 44);
        *(_DWORD *)(v38 + 772) = v111 + v12 + v18 + v19 + v111;
        inited = BET3FLT__InitPStreamParam(v117, 0);
        if ((inited & 0x80000000) != 0)
          goto LABEL_96;
        v39 = v20 + 1528 * v116;
        v42 = *(_DWORD *)(v39 + 40);
        v41 = (int *)(v39 + 40);
        v40 = v42;
        v16 = v116;
        if (v42 >= 1)
        {
          v43 = 0;
          v114 = (uint64_t *)(v107 + 86);
          v112 = (int *)(v109 + 182);
          v44 = v20 + 1528 * v116;
          v45 = (_DWORD **)(v44 + 784);
          v46 = (_QWORD *)(v44 + 824);
          v47 = (_QWORD *)(v44 + 832);
          v118 = v17 + v102 + v119;
          v105 = (_QWORD *)(v44 + 792);
          v48 = 0;
          while (1)
          {
            if (*(_DWORD *)(*(_QWORD *)(v115[3] + 1528 * v116 + 1520) + 4 * v48) == 1)
            {
              v49 = BET3FLT__InitPStreamParam(v114, (uint64_t)__b);
              if ((v49 & 0x80000000) != 0)
              {
                v51 = v49;
                goto LABEL_98;
              }
              v50 = BET3FLT__InitPStreamSM(v114, (uint64_t)v120);
              v51 = v50;
              if ((v50 & 0x80000000) != 0)
                goto LABEL_98;
              inited = v50;
              v113 = v48;
              if ((int)v111 < 1)
              {
                LODWORD(v52) = 0;
              }
              else
              {
                v52 = 0;
                v53 = *v112 & ~(*v112 >> 31);
                do
                {
                  if (v52 == v53)
                    break;
                  v54 = **v45;
                  if ((int)v54 >= 1)
                  {
                    v55 = *(_DWORD **)(*v46 + 8 * v52);
                    v56 = *(_DWORD **)(*v47 + 8 * v52);
                    do
                    {
                      *v55++ = 0;
                      *v56++ = 1065353216;
                      --v54;
                    }
                    while (v54);
                  }
                  ++v52;
                }
                while (v52 != v111);
              }
              LODWORD(v12) = v52;
              if ((int)v118 >= 1)
              {
                v57 = 0;
                v58 = v115[75];
                v59 = *((_DWORD *)v115 + 153);
                v60 = *v106;
                v61 = (*v106 + 2);
                LODWORD(v12) = v52;
                do
                {
                  v62 = v57 - v119 + v59;
                  if (v60 >= 1)
                  {
                    v63 = v58 + 528 * v62;
                    v64 = *(_QWORD *)(v63 + 16);
                    v65 = v63 + 8 * v116;
                    v66 = (_QWORD *)(v65 + 152);
                    v67 = (_QWORD *)(v65 + 232);
                    v68 = 2;
                    do
                    {
                      v69 = *(_DWORD *)(v64 + 4 * v68);
                      if (v69 >= 1)
                      {
                        v70 = **v45;
                        v12 = (int)v12;
                        v71 = 1;
                        do
                        {
                          if ((int)v70 >= 1)
                          {
                            v72 = *(_QWORD *)(*v66 + 8 * v68);
                            v73 = *(_DWORD **)(*v46 + 8 * v12);
                            v74 = *(_QWORD *)(*v67 + 8 * v68);
                            v75 = *(_DWORD **)(*v47 + 8 * v12);
                            v76 = 4 * *v41;
                            v77 = v70;
                            v78 = v43;
                            do
                            {
                              *v73++ = *(_DWORD *)(v72 + v78);
                              *v75++ = *(_DWORD *)(v74 + v78);
                              v78 += v76;
                              --v77;
                            }
                            while (v77);
                          }
                          ++v12;
                        }
                        while (v71++ != v69);
                      }
                      ++v68;
                    }
                    while (v68 != v61);
                  }
                  ++v57;
                }
                while (v57 != v118);
                v108 = v58 + 528 * v62;
              }
              if (*(_DWORD *)(v115[3] + 1528 * v116 + 1492))
                v80 = 0;
              else
                v80 = (int)v52 < (int)v12;
              if (v80)
              {
                v81 = v52;
                LODWORD(v52) = **v45;
                do
                {
                  if ((int)v52 >= 1)
                  {
                    v82 = 0;
                    v83 = *(_QWORD *)(*v47 + 8 * v81);
                    do
                    {
                      v84 = BET3FLT__bet3_finv(*(float *)(v83 + 4 * v82));
                      v83 = *(_QWORD *)(*v47 + 8 * v81);
                      *(float *)(v83 + 4 * v82++) = v84;
                      v52 = (int)**v45;
                    }
                    while (v82 < v52);
                  }
                  ++v81;
                }
                while (v81 != v12);
              }
              v85 = *v112;
              if ((int)v12 >= *v112)
              {
                v91 = v116;
                v48 = v113;
              }
              else
              {
                v86 = **v45;
                v87 = (int)v12;
                v48 = v113;
                do
                {
                  if ((int)v86 >= 1)
                  {
                    v88 = *(_DWORD **)(*v46 + 8 * v87);
                    v89 = *(_DWORD **)(*v47 + 8 * v87);
                    v90 = v86;
                    do
                    {
                      *v88++ = 0;
                      *v89++ = 1065353216;
                      --v90;
                    }
                    while (v90);
                  }
                  ++v87;
                }
                while (v87 != v85);
                LODWORD(v12) = v85;
                v91 = v116;
              }
              (*(void (**)(uint64_t *, _QWORD))(*(_QWORD *)(v115[3] + 1528 * v91 + 1504) + 8 * v48))(v114, 0);
              v92 = *v109;
              if ((int)v92 >= 1)
              {
                v93 = *v107;
                v94 = (int **)(*v105 + 8 * (v19 + (int)v111));
                do
                {
                  v95 = *v94++;
                  v96 = *v95;
                  v97 = *v93++;
                  *(_DWORD *)(v97 + 4 * v48) = v96;
                  --v92;
                }
                while (v92);
              }
              BET3FLT__FreePStreamSM((uint64_t)v114);
              BET3FLT__FreePStreamParam(v114);
              v40 = *v41;
            }
            ++v48;
            v43 += 4;
            if (v48 >= v40)
            {
              v4 = v115;
              a2 = v106;
              v11 = v102;
              v16 = v116;
              goto LABEL_90;
            }
          }
        }
        v11 = v102;
LABEL_90:
        v17 = v104;
        v7 = v108;
      }
      if (++v16 >= *((int *)v4 + 8))
        goto LABEL_94;
    }
  }
  inited = 0;
LABEL_94:
  v98 = *((_DWORD *)v4 + 153) + v11;
  *((_DWORD *)v4 + 153) = v98;
  if (v98 >= *((_DWORD *)v4 + 152))
    *a3 = 1;
LABEL_96:
  v51 = inited;
LABEL_98:
  BET3FLT__FreePStreamParam(__b);
  BET3FLT__FreeSMatrices((uint64_t)v121);
  BET3FLT__FreeSMatrices((uint64_t)v120);
  return v51;
}

uint64_t BET3FLT__InitVData(int a1, char *__b, _DWORD *a3)
{
  uint64_t result;

  cstdlib_memset(__b, 0, 0x430uLL);
  result = BET3FLT__InitModelSet(a1, __b, a3);
  if ((result & 0x80000000) == 0)
  {
    result = BET3FLT__InitTreeSet(a1, __b + 464);
    if ((result & 0x80000000) == 0)
      return BET3FLT__InitDWinSet(a1, __b + 672, (uint64_t)a3);
  }
  return result;
}

void *BET3FLT__DeInitVData(void *a1, char *a2)
{
  BET3FLT__DeInitModelSet((uint64_t)a1, a2);
  BET3FLT__DeInitTreeSet(a1, a2 + 464);
  BET3FLT__DeInitDWinSet((_QWORD **)a1, a2 + 672);
  return cstdlib_memset(a2, 0, 0x430uLL);
}

uint64_t BET3FLT__LoadVData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t ModelFile;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  char v30;
  uint64_t v31;
  const char *v33;
  uint64_t v34;
  uint64_t v35;

  if (*(int *)(a2 + 456) < 1)
    return 0;
  v6 = 0;
  v7 = a2 + 464;
  v8 = a2 + 672;
  v9 = a3 + 2664;
  v10 = (unsigned int *)(a3 + 2424);
  do
  {
    ModelFile = BET3FLT__LoadModelFile(a1, (unsigned int *)a2, v6, v9);
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ModelFile = BET3FLT__LoadTreesFile(a1, v7, v6, v10, a3, v12, v13, v14);
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ModelFile = BET3FLT__LoadDWinFile(a1, v8, v6, (unsigned int *)(v9 + 1200));
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ++v6;
    v20 = *(int *)(a2 + 456);
    v9 += 120;
    v10 += 6;
  }
  while (v6 < v20);
  if ((int)v20 < 1)
    return 0;
  v21 = 0;
  while (1)
  {
    if (!*(_QWORD *)(a2 + 8 * v21 + 568))
    {
      v31 = 2229280775;
      v33 = "%s tree is required\n";
      v34 = a1;
      v35 = 55032;
      goto LABEL_37;
    }
    v22 = a2 + 4 * v21;
    if (*(_DWORD *)(v22 + 336) && !*(_QWORD *)(a2 + 168))
    {
LABEL_38:
      v31 = 2229280775;
      v33 = "%s PDF is required\n";
      v34 = a1;
      v35 = 55033;
      goto LABEL_37;
    }
    v23 = *(_DWORD *)(v22 + 376);
    if (v23)
    {
      if (!*(_QWORD *)(a2 + 8 * v21 + 176))
        goto LABEL_38;
      if (!*(_DWORD *)(a2 + 4 * v21 + 416))
      {
        v24 = 1;
        goto LABEL_19;
      }
    }
    else if (!*(_DWORD *)(a2 + 4 * v21 + 416))
    {
      goto LABEL_31;
    }
    if (!*(_QWORD *)(a2 + 8 * v21 + 256))
      goto LABEL_38;
    v24 = 0;
LABEL_19:
    v25 = *(unsigned int *)(a2 + 4 * v21 + 128);
    if ((int)v25 >= 1)
      break;
LABEL_26:
    if (v23)
      v30 = 0;
    else
      v30 = v24;
    if ((v30 & 1) == 0 && *(_DWORD *)(a2 + 4 * v21 + 4) % *(_DWORD *)(v8 + 40 * v21))
    {
      v31 = 2229280775;
      v33 = "The number of dynamic windows for %s is not correct %d %d\n";
      v34 = a1;
      v35 = 55035;
      goto LABEL_37;
    }
LABEL_31:
    v31 = 0;
    if (++v21 == *(_DWORD *)(a2 + 456))
      return v31;
  }
  v26 = 0;
  v27 = a2 + 8 * v21;
  v28 = (_QWORD *)(v27 + 176);
  v29 = (_QWORD *)(v27 + 256);
  while ((!v23 || *(_QWORD *)(*v28 + 8 * v26)) && ((v24 & 1) != 0 || *(_QWORD *)(*v29 + 8 * v26)))
  {
    if (v25 == ++v26)
      goto LABEL_26;
  }
  v31 = 2229280775;
  v33 = "%s PDF layer %d is required\n";
  v34 = a1;
  v35 = 55034;
LABEL_37:
  BET3FLT__log_select_Error(v34, v35, (uint64_t)v33, v15, v16, v17, v18, v19);
  return v31;
}

uint64_t BET3FLT__InitVStream(uint64_t a1, char *__b, _DWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;

  cstdlib_memset(__b, 0, 0x788uLL);
  *(_QWORD *)__b = a1;
  v6 = a3[33];
  *((_DWORD *)__b + 8) = v6;
  v7 = heap_Calloc(*(_QWORD **)(a1 + 8), v6, 1528);
  *((_QWORD *)__b + 3) = v7;
  if (!v7)
    return 2229280778;
  if (*((int *)__b + 8) >= 1)
  {
    v8 = 0;
    v9 = __b + 648;
    v10 = a3 + 36;
    do
    {
      cstdlib_strcpy(v9, "");
      if (cstdlib_strlen(*(const char **)&v10[2 * v8]))
        cstdlib_strcpy(v9, *(const char **)&v10[2 * v8]);
      ++v8;
      v11 = *((int *)__b + 8);
      v9 += 128;
    }
    while (v8 < v11);
    if ((int)v11 >= 1)
    {
      v12 = 0;
      v13 = *((_QWORD *)__b + 3);
      v14 = a3[18];
      v15 = 1528 * *((unsigned int *)__b + 8);
      do
      {
        v16 = v13 + v12;
        *(_DWORD *)(v16 + 12) = a3[56];
        *(_QWORD *)(v16 + 24) = a1;
        *(_QWORD *)(v16 + 752) = a1;
        if (v12)
        {
          if (a3[536])
            *(_DWORD *)(v13 + v12 + 1488) = 1;
          else
            *(_DWORD *)(v13 + v12 + 1484) = 1;
        }
        else
        {
          *(_DWORD *)(v13 + 1480) = 1;
        }
        if (v14 == 1)
          *(_DWORD *)(v13 + v12 + 1492) = 1;
        ++a3;
        v12 += 1528;
      }
      while (v15 != v12);
    }
  }
  return 0;
}

uint64_t BET3FLT__LoadVStream(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v32;
  const char *v33;

  if (*((int *)a1 + 8) < 1)
    return 0;
  v3 = a3;
  v6 = 0;
  v7 = a2 + 672;
  v8 = a1[3];
  while (1)
  {
    v9 = (_DWORD *)(v7 + 40 * v6);
    v10 = v8 + 1528 * v6;
    *(_QWORD *)(v10 + 56) = v9;
    v11 = *(_DWORD *)(v10 + 1484);
    if (v11)
      *(_QWORD *)(v8 + 1528 * v6 + 784) = v9;
    if (!*(_DWORD *)(v8 + 1528 * v6 + 1480))
      break;
    if (v11)
      goto LABEL_7;
LABEL_8:
    if (++v6 >= *((int *)a1 + 8))
      return 0;
  }
  v13 = a2 + 4 * v6;
  v14 = v8 + 1528 * v6;
  *(_DWORD *)(v14 + 36) = *(_DWORD *)(v13 + 4);
  v15 = (*(_DWORD *)(v13 + 4) / *v9);
  *(_DWORD *)(v14 + 40) = v15;
  *(_QWORD *)(v14 + 1496) = *(_QWORD *)(v3 + 92);
  v16 = heap_Calloc(*(_QWORD **)(*a1 + 8), v15, 8);
  v17 = a1[3];
  *(_QWORD *)(v17 + 1528 * v6 + 1504) = v16;
  if (!v16)
    return 2229280778;
  LODWORD(v17) = *(_DWORD *)(v17 + 1528 * v6 + 40);
  if ((int)v17 >= 1)
  {
    v18 = 0;
    v19 = (_QWORD *)(v3 + 8 * v6 + 2184);
    do
    {
      if (cstdlib_strcmp(*(const char **)(*v19 + 8 * v18), "MLPG2"))
      {
        v32 = *a1;
        v33 = "invalid solver for stream %d: %s\n";
        goto LABEL_30;
      }
      *(_QWORD *)(*(_QWORD *)(a1[3] + 1528 * v6 + 1504) + 8 * v18++) = BET3FLT__mlpg2;
      v17 = *(int *)(a1[3] + 1528 * v6 + 40);
    }
    while (v18 < v17);
    v3 = a3;
  }
  v25 = heap_Calloc(*(_QWORD **)(*a1 + 8), v17, 4);
  v26 = a1[3];
  *(_QWORD *)(v26 + 1528 * v6 + 1520) = v25;
  if (!v25)
    return 2229280778;
  if (*(int *)(v26 + 1528 * v6 + 40) < 1)
  {
LABEL_25:
    BET3FLT__log_select_Diag(*a1, 1, (uint64_t)"%s: vSize = %d, order = %d, nLayer = %d\n");
    v8 = a1[3];
    if (!*(_DWORD *)(v8 + 1528 * v6 + 1484))
      goto LABEL_8;
LABEL_7:
    v12 = v8 + 1528 * v6;
    *(_DWORD *)(v12 + 764) = *(_DWORD *)(a2 + 4 * v6 + 4);
    *(_DWORD *)(v12 + 768) = 1;
    goto LABEL_8;
  }
  v27 = 0;
  v28 = (_QWORD *)(v3 + 8 * v6 + 2344);
  while (1)
  {
    if (!cstdlib_strcmp(*(const char **)(*v28 + 8 * v27), "OFF"))
    {
      v29 = 0;
      goto LABEL_23;
    }
    if (cstdlib_strcmp(*(const char **)(*v28 + 8 * v27), "ON"))
      break;
    v29 = 1;
LABEL_23:
    v30 = a1[3] + 1528 * v6;
    *(_DWORD *)(*(_QWORD *)(v30 + 1520) + 4 * v27++) = v29;
    if (v27 >= *(int *)(v30 + 40))
    {
      v3 = a3;
      goto LABEL_25;
    }
  }
  v32 = *a1;
  v33 = "valid breaker setting is required for stream %d\n";
LABEL_30:
  BET3FLT__log_select_Error(v32, 55036, (uint64_t)v33, v20, v21, v22, v23, v24);
  return 2229280775;
}

_QWORD *BET3FLT__DeInitVStream(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result)
  {
    v1 = result;
    if (*result)
    {
      if (*((int *)result + 8) >= 1)
      {
        v2 = 0;
        v3 = result[3];
        v4 = 1520;
        do
        {
          if (!v3)
            break;
          BET3FLT__FreePStreamSM(v3 + v4 - 1496);
          BET3FLT__FreePStreamParam((_QWORD *)(v1[3] + v4 - 1496));
          BET3FLT__FreePStreamSM(v1[3] + v4 - 768);
          BET3FLT__FreePStreamParam((_QWORD *)(v1[3] + v4 - 768));
          v3 = v1[3];
          v5 = *(_QWORD *)(v3 + v4 - 16);
          if (v5)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v5);
            v3 = v1[3];
            *(_QWORD *)(v3 + v4 - 16) = 0;
          }
          v6 = *(_QWORD *)(v3 + v4);
          if (v6)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v6);
            v3 = v1[3];
            *(_QWORD *)(v3 + v4) = 0;
          }
          ++v2;
          v4 += 1528;
        }
        while (v2 < *((int *)v1 + 8));
      }
      v7 = v1[6];
      if (v7)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v7);
        v1[6] = 0;
      }
      v8 = v1[5];
      if (v8)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v8);
        v1[5] = 0;
      }
      v9 = v1[3];
      if (v9)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v9);
        v1[3] = 0;
      }
      BET3FLT__DeInitUttModel(v1 + 7);
      return cstdlib_memset(v1, 0, 0x788uLL);
    }
  }
  return result;
}

void *BET3FLT__InitVParam(_DWORD *a1)
{
  void *result;

  result = cstdlib_memset(a1, 0, 0x1F30uLL);
  a1[32] = 1;
  return result;
}

void *BET3FLT__DeInitVParam(uint64_t a1, _QWORD *__b)
{
  uint64_t i;
  uint64_t j;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t k;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t m;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  unsigned int *v29;
  char *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t n;
  uint64_t v44;
  uint64_t ii;
  uint64_t v46;

  if (__b[954])
  {
    for (i = 0; i != 20; ++i)
    {
      if (*(_QWORD *)(__b[954] + 8 * i))
      {
        for (j = 0; j != 800; j += 8)
        {
          v6 = *(_QWORD *)(*(_QWORD *)(__b[954] + 8 * i) + j);
          if (v6)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v6);
            *(_QWORD *)(*(_QWORD *)(__b[954] + 8 * i) + j) = 0;
          }
        }
        v7 = *(_QWORD *)(__b[954] + 8 * i);
        if (v7)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v7);
          *(_QWORD *)(__b[954] + 8 * i) = 0;
        }
      }
      v8 = *(_QWORD *)(__b[955] + 8 * i);
      if (v8)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v8);
        *(_QWORD *)(__b[955] + 8 * i) = 0;
      }
      v9 = *(_QWORD *)(__b[953] + 8 * i);
      if (v9)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v9);
        *(_QWORD *)(__b[953] + 8 * i) = 0;
      }
    }
    v10 = __b[954];
    if (v10)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v10);
      __b[954] = 0;
    }
    v11 = __b[955];
    if (v11)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v11);
      __b[955] = 0;
    }
    v12 = __b[953];
    if (v12)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v12);
      __b[953] = 0;
    }
  }
  v13 = __b[10];
  if (v13)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v13);
    __b[10] = 0;
  }
  v14 = __b[15];
  if (v14)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v14);
    __b[15] = 0;
  }
  v15 = __b[956];
  if (v15)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v15);
    __b[956] = 0;
  }
  v16 = 0;
  v17 = __b;
  do
  {
    v18 = (char *)&__b[v16];
    v19 = *((_QWORD *)v18 + 18);
    if (v19)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v19);
      *((_QWORD *)v18 + 18) = 0;
    }
    v20 = *((_QWORD *)v18 + 53);
    if (v20)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v20);
      *((_QWORD *)v18 + 53) = 0;
    }
    for (k = 0; k != 5; ++k)
    {
      v22 = &v17[k];
      v23 = v17[k + 63];
      if (v23)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v23);
        v22[63] = 0;
      }
      v24 = v22[163];
      if (v24)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v24);
        v22[163] = 0;
      }
    }
    for (m = 213; m != 218; ++m)
    {
      v26 = v17[m];
      if (v26)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v26);
        v17[m] = 0;
      }
    }
    v27 = (char *)__b + 4 * v16;
    if (*((_DWORD *)v27 + 66))
    {
      v28 = 0;
      v29 = (unsigned int *)(v27 + 264);
      v30 = (char *)&__b[v16];
      v31 = v30 + 2344;
      v32 = v30 + 2184;
      v33 = v30 + 2264;
      do
      {
        if (*v31)
        {
          v34 = *(_QWORD *)(*v31 + 8 * v28);
          if (v34)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v34);
            *(_QWORD *)(*v31 + 8 * v28) = 0;
          }
        }
        if (*v32)
        {
          v35 = *(_QWORD *)(*v32 + 8 * v28);
          if (v35)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v35);
            *(_QWORD *)(*v32 + 8 * v28) = 0;
          }
        }
        if (*v33)
        {
          v36 = *(_QWORD *)(*v33 + 8 * v28);
          if (v36)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v36);
            *(_QWORD *)(*v33 + 8 * v28) = 0;
          }
        }
        ++v28;
      }
      while (v28 < *v29);
    }
    v37 = (char *)&__b[v16];
    v38 = *((_QWORD *)v37 + 293);
    if (v38)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v38);
      *((_QWORD *)v37 + 293) = 0;
    }
    v39 = *((_QWORD *)v37 + 273);
    if (v39)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v39);
      *((_QWORD *)v37 + 273) = 0;
    }
    v40 = (char *)&__b[v16];
    v41 = *((_QWORD *)v40 + 283);
    if (v41)
    {
      v42 = v40 + 2264;
      heap_Free(*(_QWORD **)(a1 + 8), v41);
      *v42 = 0;
    }
    ++v16;
    v17 += 5;
  }
  while (v16 != 10);
  for (n = 663; n != 919; ++n)
  {
    v44 = __b[n];
    if (v44)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v44);
      __b[n] = 0;
    }
  }
  if (__b[952])
  {
    for (ii = 0; ii != 2048; ii += 8)
    {
      v46 = *(_QWORD *)(__b[952] + ii);
      if (v46)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v46);
        *(_QWORD *)(__b[952] + ii) = 0;
      }
    }
    heap_Free(*(_QWORD **)(a1 + 8), __b[952]);
  }
  return cstdlib_memset(__b, 0, 0x1F30uLL);
}

uint64_t synth_float_bet3_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2164269057;
  result = 0;
  *a2 = &ISynth_Bet3;
  return result;
}

uint64_t synth_bet3_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t Object;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Listen;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  __int128 v37;
  uint64_t (*v38)(uint64_t, char *, const char *);
  char *__s1;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;

  Object = 2164269063;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  __s1 = 0;
  v37 = xmmword_24D2944A0;
  v38 = synth_bet3_loc_ParamLearnChange;
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, &v42);
    if ((inited & 0x80000000) != 0)
      return inited;
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    log_OutText(*(_QWORD *)(v42 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Entering synth_bet3_ObjOpen", v10, v11, v12, v34);
    v13 = (_QWORD *)heap_Calloc(*(_QWORD **)(v42 + 8), 1, 1904);
    if (v13)
    {
      v18 = (uint64_t)v13;
      *v13 = a3;
      v13[1] = a4;
      v19 = v42;
      v13[2] = v42;
      Listen = critsec_ObjOpen(*(_QWORD *)(v19 + 16), *(_QWORD **)(v19 + 8), v13 + 3);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      *(_QWORD *)&v37 = v18;
      Listen = synth_bet3_loc_ParamGetListen(v18, "volume", 0, 100, 0x50u, &v37, &v40);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      Listen = synth_bet3_loc_ParamGetListen(v18, "rate", 50, 400, 0x64u, &v37, &v40);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      Listen = synth_bet3_loc_ParamGetListen(v18, "pitch", 50, 200, 0x64u, &v37, &v40);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      Listen = synth_bet3_loc_ParamGetListen(v18, "rate_baseline", 50, 400, 0x64u, &v37, &v40);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      Listen = synth_bet3_loc_ParamGetListen(v18, "pitch_baseline", 50, 200, 0x64u, &v37, &v40);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      Listen = synth_bet3_loc_ParamGetListen(v18, "audiooutputbufsamples", 1, 0x7FFFFFFF, 0x100u, &v37, &v40);
      if ((Listen & 0x80000000) != 0)
        goto LABEL_21;
      *(_DWORD *)(v18 + 40) = v40;
      if ((paramc_ParamGetStr(*(_QWORD *)(v42 + 40), (uint64_t)"synth_type", &__s1) & 0x80000000) == 0)
      {
        if (cstdlib_strcmp(__s1, "mlsa") && cstdlib_strcmp(__s1, "mfs"))
        {
          log_OutText(*(_QWORD *)(v42 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Unknown synthesizer: %s", v21, v22, v23, (uint64_t)__s1);
          return 7;
        }
        log_OutText(*(_QWORD *)(v42 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Setting up MLSA synthesizer", v21, v22, v23, v35);
      }
      *(_DWORD *)(v18 + 1896) = 0;
      Listen = synth_bet3_loc_SynthInit_MLSA(v18);
      if ((Listen & 0x80000000) != 0)
      {
LABEL_21:
        Object = Listen;
      }
      else
      {
        Object = objc_GetObject(*(_QWORD *)(v42 + 48), (uint64_t)"SYNTHSTREAM", &v41);
        if ((Object & 0x80000000) == 0)
        {
          *(_QWORD *)(v18 + 32) = *(_QWORD *)(v41 + 8);
          *(_QWORD *)a5 = v18;
          *(_DWORD *)(a5 + 8) = 9346;
          goto LABEL_23;
        }
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(v18 + 16) + 32), (uint64_t)"SYNTH_BET3", 56001, 0, v27, v24, v25, v26, v35);
      }
      *(_QWORD *)a5 = v18;
      *(_DWORD *)(a5 + 8) = 9346;
      synth_bet3_ObjClose(v18, *(_QWORD *)(a5 + 8));
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      goto LABEL_23;
    }
    log_OutPublic(*(_QWORD *)(v42 + 32), (uint64_t)"SYNTH_BET3", 56000, 0, v14, v15, v16, v17, v35);
    Object = 2164269066;
LABEL_23:
    log_OutText(*(_QWORD *)(v42 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"synth_bet3_ObjOpen: %x", v24, v25, v26, Object);
    log_OutEvent(*(uint64_t ***)(v42 + 32), 22, (uint64_t)"", v28, v29, v30, v31, v32, v36);
  }
  return Object;
}

uint64_t synth_bet3_ObjClose(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  int v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  int v24;
  int v26;
  uint64_t v28;
  int v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;

  v3 = safeh_HandleCheck(a1, a2, 9346, 1904);
  if (v3 < 0)
    return 2164269064;
  LODWORD(v7) = v3;
  v8 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Entering synth_bet3_ObjClose", v4, v5, v6, v35);
  v9 = *(_QWORD *)(v8 + 40);
  v36 = a1;
  v37 = *(__int128 *)((char *)&xmmword_24D2944A0 + 8);
  v10 = paramc_ListenerRemove(v9, "volume", (__int128 *)&v36);
  v11 = *(_QWORD *)(v8 + 40);
  if (v10 < 0)
    LODWORD(v7) = v10;
  v36 = a1;
  v37 = *(__int128 *)((char *)&xmmword_24D2944A0 + 8);
  v12 = paramc_ListenerRemove(v11, "rate", (__int128 *)&v36);
  v13 = *(_QWORD *)(v8 + 40);
  if (v12 < 0 && (int)v7 > -1)
    LODWORD(v7) = v12;
  v36 = a1;
  v37 = *(__int128 *)((char *)&xmmword_24D2944A0 + 8);
  v15 = paramc_ListenerRemove(v13, "pitch", (__int128 *)&v36);
  v16 = *(_QWORD *)(v8 + 40);
  if (v15 < 0 && (int)v7 > -1)
    LODWORD(v7) = v15;
  v36 = a1;
  v37 = *(__int128 *)((char *)&xmmword_24D2944A0 + 8);
  v18 = paramc_ListenerRemove(v16, "rate_baseline", (__int128 *)&v36);
  v19 = *(_QWORD *)(v8 + 40);
  if (v18 < 0 && (int)v7 > -1)
    LODWORD(v7) = v18;
  v36 = a1;
  v37 = *(__int128 *)((char *)&xmmword_24D2944A0 + 8);
  v21 = paramc_ListenerRemove(v19, "pitch_baseline", (__int128 *)&v36);
  v22 = *(_QWORD *)(v8 + 40);
  if (v21 < 0 && (int)v7 > -1)
    LODWORD(v7) = v21;
  v36 = a1;
  v37 = *(__int128 *)((char *)&xmmword_24D2944A0 + 8);
  v24 = paramc_ListenerRemove(v22, "audiooutputbufsamples", (__int128 *)&v36);
  if (v24 >= 0 || (int)v7 <= -1)
    v7 = v7;
  else
    v7 = v24;
  if (*(_QWORD *)(a1 + 32))
  {
    v26 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if (v26 >= 0 || (int)v7 <= -1)
      v7 = v7;
    else
      v7 = v26;
  }
  if (!*(_DWORD *)(a1 + 1896))
    MFVSyn__deinit__MVF_Synthesis((_QWORD *)(a1 + 72));
  v28 = *(_QWORD *)(a1 + 24);
  if (v28)
  {
    v29 = critsec_ObjClose(v28);
    if ((int)v7 > -1 && v29 < 0)
      v7 = v29;
    else
      v7 = v7;
  }
  heap_Free(*(_QWORD **)(v8 + 8), a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"synth_bet3_ObjClose: %x", v31, v32, v33, v7);
  return v7;
}

uint64_t synth_bet3_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t inited;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  if ((safeh_HandleCheck(a1, a2, 9346, 1904) & 0x80000000) != 0)
    return 2164269064;
  v6 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Entering synth_bet3_ObjReopen", v3, v4, v5, v12);
  inited = synth_bet3_loc_SynthInit_MLSA(a1);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"synth_bet3_ObjReopen: %x", v8, v9, v10, inited);
  return inited;
}

uint64_t synth_bet3_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  char __dst[64];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if ((safeh_HandleCheck(a1, a2, 9346, 1904) & 0x80000000) != 0)
    return 2164269064;
  cstdlib_strcpy(__dst, "audio/L16;rate=");
  v8 = *(_DWORD *)(a1 + 48);
  v9 = cstdlib_strlen(__dst);
  LH_itoa(v8, &__dst[v9], 0xAu);
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 64))(a3, a4, 16, "application/x-realspeak-bet3-speech-frames;version=5.0",
          0,
          0,
          a1 + 1792);
  if ((v10 & 0x80000000) != 0
    || (v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 64))(a3, a4, 16, "application/x-realspeak-markers-pp;version=4.0",
                0,
                0,
                a1 + 1808),
        (v10 & 0x80000000) != 0))
  {
    v23 = v10;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56002, (uint64_t)"%s%s", v11, v12, v13, v14, "contentType");
LABEL_12:
    *(_DWORD *)(a1 + 1856) = 0;
LABEL_13:
    synth_bet3_ProcessEnd((_QWORD *)a1, a2);
    return v23;
  }
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32)
                                                                                               + 64))(a3, a4, 16, __dst, 0, 1, a1 + 1824);
  if ((v15 & 0x80000000) != 0)
  {
    v23 = v15;
    goto LABEL_11;
  }
  v20 = *(_QWORD *)(a1 + 32);
  v21 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t))(v20 + 64);
  v22 = (*(uint64_t (**)(void))(v20 + 152))();
  v23 = v21(a3, a4, 16, "application/x-realspeak-markers-pp;version=4.0", v22, 1, a1 + 1840);
  if ((v23 & 0x80000000) != 0)
  {
LABEL_11:
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56003, (uint64_t)"%s%s", v16, v17, v18, v19, "contentType");
    goto LABEL_12;
  }
  if (!*(_DWORD *)(a1 + 1896))
  {
    v23 = BET3FLT__MFVSyn__reset__MVF_Synthesis(a1 + 72);
    *(_DWORD *)(a1 + 1856) = 0;
    if ((v23 & 0x80000000) == 0)
      return v23;
    goto LABEL_13;
  }
  *(_DWORD *)(a1 + 1856) = 0;
  return v23;
}

uint64_t synth_bet3_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  int *v36;
  int *v37;
  int *v38;
  int v39;
  int *v40;
  int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t i;
  int v49;
  _DWORD *v50;
  BOOL v51;
  unsigned int v52;
  int v53;
  unint64_t v54;
  uint64_t v55;
  unsigned int v56;
  const char *v57;
  int v58;
  unsigned int v59;
  int v60;
  int v62;
  unint64_t v63;
  int v64;
  unint64_t v65;
  unsigned int v66;
  char *v67;
  unsigned int v68;
  char *v69;
  float v70;
  float v71;
  float v72;
  uint64_t v73;
  float v74;
  uint64_t v75;
  uint64_t v76;
  int *v77;
  uint64_t v78;
  _DWORD *v79;
  uint64_t v80;
  int v81;
  float *v82;
  float *v83;
  float v84;
  int v85;
  int v86;
  unsigned int v87;
  _BOOL4 v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  uint64_t v118;
  unint64_t v119;
  int v120;
  char *v121;
  char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  unsigned int v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unsigned int v143;
  uint64_t __b;
  uint64_t v145;
  void *__dst;
  void *__src;
  uint64_t *v148;
  int v149;
  size_t __n;
  _BYTE v151[200];
  uint64_t v152;

  v152 = *MEMORY[0x24BDAC8D0];
  v8 = -2130698234;
  v9 = safeh_HandleCheck(a1, a2, 9346, 1904);
  if (v9 < 0)
    return 2164269064;
  v10 = 1;
  if (v9 || !a1)
    return v10;
  __n = 0;
  v149 = 0;
  __src = 0;
  v148 = 0;
  v145 = 0;
  __dst = 0;
  if ((safeh_HandleCheck(a1, a2, 9346, 1904) & 0x80000000) != 0)
    return 2164269064;
  *a5 = 1;
  v11 = *(_DWORD *)(a1 + 40);
  v12 = *(_DWORD *)(a1 + 44);
  if (v11 >= v12)
  {
    if (v12)
      v12 *= v11 / v12;
    else
      v12 = *(_DWORD *)(a1 + 40);
  }
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, char *, int *))(*(_QWORD *)(a1 + 32) + 144))(*(_QWORD *)(a1 + 1792), *(_QWORD *)(a1 + 1800), (char *)&__n + 4, &v149);
  if ((v10 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56004, (uint64_t)"%s%x", v14, v15, v16, v17, "lhError");
    return v10;
  }
  if (HIDWORD(__n))
  {
    v18 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t **, char *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 1792), *(_QWORD *)(a1 + 1800), &v148, (char *)&__n + 4);
    if ((v18 & 0x80000000) != 0)
    {
      v10 = v18;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v19, v20, v21, v22, "contentType");
      return v10;
    }
    v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **, size_t *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 1808), *(_QWORD *)(a1 + 1816), &__src, &__n);
    if ((v10 & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v23, v24, v25, v26, "contentType");
      return v10;
    }
    if (HIDWORD(__n) >= 8)
    {
      v27 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1824), *(_QWORD *)(a1 + 1832), &v145, 2 * v12);
      if ((v27 & 0x80000000) != 0)
      {
        v10 = v27;
        v116 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_184:
        log_OutPublic(v116, (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v28, v29, v30, v31, "stream");
        return v10;
      }
      if (!(_DWORD)__n
        || (v32 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1840), *(_QWORD *)(a1 + 1848), &__dst), (v32 & 0x80000000) == 0))
      {
        v10 = critsec_Enter(*(_QWORD **)(a1 + 24));
        if ((v10 & 0x80000000) != 0)
          return v10;
        v33 = *v148;
        __b = 0;
        v143 = 0;
        v139 = *(_QWORD *)(v33 + 40);
        v140 = *(_QWORD *)(v33 + 48);
        if ((_DWORD)__n && __src && __dst)
        {
          cstdlib_memcpy(__dst, __src, __n);
          LODWORD(__n) = __n >> 5;
        }
        v34 = *(unsigned int *)(v33 + 32);
        if ((int)v34 < 1)
          goto LABEL_201;
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = *(int **)(v33 + 24);
        do
        {
          v39 = v38[3];
          if (v39 == 1)
            v40 = v38;
          else
            v40 = v37;
          if (v39 == 2)
          {
            v40 = v37;
            v41 = v38;
          }
          else
          {
            v41 = v36;
          }
          if (v39 == 3)
            v35 = v38;
          v38 += 382;
          if (v39 != 3)
          {
            v37 = v40;
            v36 = v41;
          }
          --v34;
        }
        while (v34);
        if (!v37 || !v36)
          goto LABEL_201;
        v42 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v37[11], 1);
        if (!v42)
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56000, 0, v43, v44, v45, v46, v137);
          v8 = -2130698230;
          goto LABEL_201;
        }
        v47 = v42;
        v141 = 0;
        v142 = 0;
        LODWORD(i) = 0;
        v138 = v42;
        v49 = *(_DWORD *)(a1 + 1856);
        v8 = v10;
        while (1)
        {
          if (v49 >= v37[11] || *(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 44) + HIDWORD(v141) > v12)
          {
LABEL_149:
            heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v47);
            if (HIDWORD(v141)
              && (v8 & 0x80000000) == 0
              && (v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1824), *(_QWORD *)(a1 + 1832), (2 * HIDWORD(v141))), v8 < 0))
            {
              v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_198:
              log_OutPublic(v105, (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v101, v102, v103, v104, "stream");
            }
            else if (v8 < 0 || !(_DWORD)i)
            {
              if ((v8 & 0x80000000) == 0)
                goto LABEL_188;
            }
            else
            {
              v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1840), *(_QWORD *)(a1 + 1848), (32 * i));
              if (v8 < 0)
              {
                v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                goto LABEL_198;
              }
LABEL_188:
              if (*(_DWORD *)(a1 + 1856) < v37[11])
              {
                v129 = 2;
                goto LABEL_194;
              }
              v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 1792), *(_QWORD *)(a1 + 1800), 8);
              if (v8 < 0)
              {
                v134 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_200:
                log_OutPublic(v134, (uint64_t)"SYNTH_BET3", 56006, (uint64_t)"%s%s%s%x", v130, v131, v132, v133, "contentType");
              }
              else
              {
                *(_DWORD *)(a1 + 1856) = 0;
                if (HIDWORD(__n) <= 8)
                  v129 = 1;
                else
                  v129 = 2;
LABEL_194:
                *a5 = v129;
                if ((_DWORD)i)
                {
                  v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 1808), *(_QWORD *)(a1 + 1816), (32 * i));
                  if (v8 < 0)
                  {
                    v134 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                    goto LABEL_200;
                  }
                }
              }
            }
LABEL_201:
            v135 = critsec_Leave(*(_QWORD **)(a1 + 24));
            if (v135 >= 0 || v8 <= -1)
              return v8;
            else
              return v135;
          }
          v50 = __dst;
          if (__dst)
            v51 = i >= __n;
          else
            v51 = 1;
          if (!v51)
          {
            for (i = i; v50 && i < __n; ++i)
            {
              v52 = v50[8 * i + 3];
              v53 = *(_DWORD *)(a1 + 52);
              if (v52 > *(_DWORD *)(a1 + 1860))
              {
                if (v53)
                  break;
LABEL_57:
                v58 = v50[3];
                v59 = v52 - v58;
                v60 = v50[8 * i];
                if (v60 == 8 || v60 == 26)
                {
                  if (v59 < v37[11])
                  {
                    *(_BYTE *)(v47 + v59) = 1;
                    v50 = __dst;
                  }
                }
                else if (v60 == 33)
                {
                  v62 = v50[8 * v142 + 3] - v58;
                  if (v50[8 * i + 6] == 35)
                  {
                    if ((v52 == v58 || v59 < v37[11] && *(_BYTE *)(v47 + v59) || v50[8 * v142 + 4] + v62 == v59)
                      && v50[8 * i + 4])
                    {
                      v63 = 0;
                      do
                      {
                        if (v59 + v63 < v37[11])
                        {
                          *(_BYTE *)(v47 + v59 + v63) = 2;
                          v50 = __dst;
                        }
                        ++v63;
                      }
                      while (v63 < v50[8 * i + 4]);
                    }
                    v142 = i;
                  }
                  else if (v59 < v37[11] && !*(_BYTE *)(v47 + v59))
                  {
                    v64 = v50[8 * v142 + 4];
                    if (v64)
                    {
                      if (v64 + v62 == v59)
                      {
                        v65 = 0;
                        do
                        {
                          if (v62 + (int)v65 < v37[11])
                          {
                            *(_BYTE *)(v47 + (v62 + v65)) = 0;
                            v50 = __dst;
                          }
                          ++v65;
                        }
                        while (v65 < v50[8 * v142 + 4]);
                      }
                    }
                  }
                }
                continue;
              }
              if (!v53)
                goto LABEL_57;
              if (!i)
                LODWORD(v141) = v50[3];
              HIDWORD(v54) = 0;
              *(_QWORD *)(a1 + 1880) = 0;
              switch(v50[8 * i])
              {
                case 0x10:
                  critsec_Leave(*(_QWORD **)(a1 + 24));
                  v55 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                  v56 = *((_DWORD *)__dst + 8 * i + 6);
                  v57 = "pitch";
                  goto LABEL_88;
                case 0x11:
                  critsec_Leave(*(_QWORD **)(a1 + 24));
                  v55 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                  v56 = *((_DWORD *)__dst + 8 * i + 6);
                  v57 = "timbre";
                  goto LABEL_88;
                case 0x12:
                  critsec_Leave(*(_QWORD **)(a1 + 24));
                  v55 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                  v56 = *((_DWORD *)__dst + 8 * i + 6);
                  v57 = "rate";
                  goto LABEL_88;
                case 0x18:
                  critsec_Leave(*(_QWORD **)(a1 + 24));
                  v55 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                  v56 = *((_DWORD *)__dst + 8 * i + 6);
                  v57 = "volume";
LABEL_88:
                  paramc_ParamSetUInt(v55, (uint64_t)v57, v56);
                  critsec_Enter(*(_QWORD **)(a1 + 24));
                  break;
                default:
                  break;
              }
              v50 = __dst;
              *((_DWORD *)__dst + 8 * i + 3) = *(_DWORD *)(a1 + 1864);
              if (i + 1 >= __n)
              {
                v66 = *(_DWORD *)(a1 + 44);
              }
              else
              {
                v66 = *(_DWORD *)(a1 + 44);
                if (v50[8 * i + 8] == 8)
                {
                  *(_DWORD *)(a1 + 1880) = v52 - v141;
                  v67 = (char *)&v50[8 * i];
                  v68 = *((_DWORD *)v67 + 4);
                  *(_DWORD *)(a1 + 1884) = v68 + v52 - v141;
                  *((_DWORD *)v67 + 4) = ((double)v68 * (double)v66 + 0.5);
                  continue;
                }
              }
              v69 = (char *)&v50[8 * i];
              LODWORD(v54) = *((_DWORD *)v69 + 4);
              *((_DWORD *)v69 + 4) = ((double)v54 * ceil((double)v66 * *(float *)(a1 + 132)) + 0.5);
            }
          }
          v70 = 0.0;
          v71 = 0.0;
          if ((*(_BYTE *)(v140 + *v37) & 4) != 0)
          {
            v72 = *(float *)(a1 + 64);
            v73 = *v36;
            v74 = exp(**(float **)(*((_QWORD *)v36 + 8) + 8 * v73));
            v71 = *(float *)(a1 + 68) + (float)(v72 * v74);
            *v36 = v73 + 1;
          }
          if (v35 && ((1 << v35[3]) & (unint64_t)*(unsigned __int8 *)(v140 + *v37)) >> v35[3])
          {
            v75 = *v35;
            v70 = exp(**(float **)(*((_QWORD *)v35 + 8) + 8 * v75));
            *v35 = v75 + 1;
          }
          v76 = *(unsigned int *)(a1 + 272);
          if ((v76 & 0x80000000) == 0)
          {
            v77 = *(int **)(*((_QWORD *)v37 + 8) + 8 * *(int *)(a1 + 1856));
            v78 = v76 + 1;
            v79 = v151;
            v80 = v78;
            do
            {
              v81 = *v77++;
              *v79++ = v81;
              --v80;
            }
            while (v80);
            v82 = *(float **)(a1 + 1872);
            if (v82)
            {
              v83 = (float *)v151;
              do
              {
                v84 = *v82++;
                *v83 = *v83 + v84;
                ++v83;
                --v78;
              }
              while (v78);
            }
          }
          cstdlib_memset(&__b, 0, 8uLL);
          v85 = *(_DWORD *)(a1 + 52);
          v49 = *(_DWORD *)(a1 + 1856);
          if (!v85
            && (**(float **)(*((_QWORD *)v37 + 8) + 8 * v49) == 0.0 || v49 >= v37[11] || *(_BYTE *)(v47 + v49) == 2))
          {
            v143 = vcvtps_u32_f32(*(float *)(a1 + 132) * (float)*(int *)(a1 + 552));
          }
          else
          {
            v86 = *(_DWORD *)(a1 + 132);
            v87 = *(_DWORD *)(a1 + 1880);
            if (v87 <= v49 && *(_DWORD *)(a1 + 1884) > v49)
              *(_DWORD *)(a1 + 132) = 1065353216;
            if (v85 || !v49 || !*(_DWORD *)(a1 + 56))
            {
              v8 = BET3FLT__MFVSyn__SynthesisOneFrame(a1 + 72, v151, (int *)&v143, &__b, v71, 0.0, *(float *)(v139 + 4 * *v37), v70);
              v87 = *(_DWORD *)(a1 + 1880);
              v49 = *(_DWORD *)(a1 + 1856);
            }
            if (v87 <= v49 && *(_DWORD *)(a1 + 1884) > v49)
              *(_DWORD *)(a1 + 132) = v86;
          }
          v88 = 0;
          if ((v8 & 0x80000000) == 0)
          {
            v89 = v143;
            if (v143)
              break;
          }
LABEL_147:
          if (v88 || v8 < 0)
            goto LABEL_149;
        }
        ++*(_DWORD *)(a1 + 1860);
        *(_DWORD *)(a1 + 1864) += v89;
        if (v89 + HIDWORD(v141) <= v12)
        {
          v88 = 0;
          goto LABEL_137;
        }
        if (HIDWORD(v141))
        {
          v90 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1824), *(_QWORD *)(a1 + 1832), (2 * HIDWORD(v141)));
          if (v90 < 0)
          {
            v8 = v90;
            goto LABEL_145;
          }
          v89 = v143;
        }
        if (v89 <= v12)
          v95 = v12;
        else
          v95 = v89;
        if (!*(_DWORD *)(a1 + 52))
          v89 = v95;
        v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1824), *(_QWORD *)(a1 + 1832), &v145, 2 * v89);
        if ((v8 & 0x80000000) == 0)
        {
          HIDWORD(v141) = 0;
          v88 = *(_DWORD *)(a1 + 52) != 0;
LABEL_137:
          v96 = __b;
          if (__b)
          {
            v97 = v143;
            if (v143)
            {
              v98 = 0;
              v99 = v145;
              do
              {
                *(_WORD *)(v99 + 2 * (HIDWORD(v141) + v98)) = (int)*(float *)(v96 + 4 * v98);
                ++v98;
              }
              while (v97 != v98);
            }
            v100 = HIDWORD(v141);
          }
          else
          {
            v100 = HIDWORD(v141);
            cstdlib_memset((void *)(v145 + 2 * HIDWORD(v141)), 0, v143 + 2);
            LODWORD(v97) = v143;
          }
          HIDWORD(v141) = v97 + v100;
          v47 = v138;
          goto LABEL_146;
        }
LABEL_145:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v91, v92, v93, v94, "stream");
        HIDWORD(v141) = 0;
        v88 = *(_DWORD *)(a1 + 52) != 0;
LABEL_146:
        ++*v37;
        v49 = *(_DWORD *)(a1 + 1856) + 1;
        *(_DWORD *)(a1 + 1856) = v49;
        goto LABEL_147;
      }
LABEL_183:
      v10 = v32;
      v116 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      goto LABEL_184;
    }
  }
  else
  {
    if (!v149)
    {
      *a5 = 0;
      return v10;
    }
    v106 = *(_QWORD *)(a1 + 1824);
    if (!v106
      || (v10 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 72))(v106, *(_QWORD *)(a1 + 1832)),
          *(_QWORD *)(a1 + 1824) = safeh_GetNullHandle(),
          *(_QWORD *)(a1 + 1832) = v107,
          (v10 & 0x80000000) == 0))
    {
      if (*(_QWORD *)(a1 + 1840))
      {
        v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **, size_t *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 1808), *(_QWORD *)(a1 + 1816), &__src, &__n);
        if ((v10 & 0x80000000) != 0)
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v108, v109, v110, v111, "contentType");
        }
        else if ((_DWORD)__n)
        {
          v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1840), *(_QWORD *)(a1 + 1848), &__dst);
          if ((v10 & 0x80000000) != 0)
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v112, v113, v114, v115, "stream");
        }
        if ((v10 & 0x80000000) == 0 && (_DWORD)__n && __src && __dst)
        {
          cstdlib_memcpy(__dst, __src, __n);
          v117 = __n;
          LODWORD(__n) = __n >> 5;
          if (v117 >= 0x20)
          {
            v118 = 0;
            v119 = 0;
            v120 = *(_DWORD *)(a1 + 1864);
            v121 = (char *)__dst;
            do
            {
              v122 = &v121[v118];
              *((_DWORD *)v122 + 3) = v120;
              *((_DWORD *)v122 + 4) = 0;
              ++v119;
              v118 += 32;
            }
            while (v119 < __n);
          }
          else
          {
            v118 = 0;
          }
          v32 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1840), *(_QWORD *)(a1 + 1848), v118);
          if ((v32 & 0x80000000) != 0)
            goto LABEL_183;
          v123 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 1808), *(_QWORD *)(a1 + 1816), v118);
          if ((v123 & 0x80000000) != 0)
          {
            v10 = v123;
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56006, (uint64_t)"%s%s%s%x", v124, v125, v126, v127, "contentType");
            return v10;
          }
        }
        else if ((v10 & 0x80000000) != 0)
        {
          return v10;
        }
        v10 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 72))(*(_QWORD *)(a1 + 1840), *(_QWORD *)(a1 + 1848));
        *(_QWORD *)(a1 + 1840) = safeh_GetNullHandle();
        *(_QWORD *)(a1 + 1848) = v128;
      }
    }
  }
  return v10;
}

uint64_t synth_bet3_ProcessEnd(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v18;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 9346, 1904);
  if ((v3 & 0x80000000) != 0)
    return 2164269064;
  v4 = v3;
  *(_QWORD *)((char *)a1 + 1860) = 0;
  v5 = a1[224];
  if (v5)
  {
    v4 = (*(uint64_t (**)(uint64_t, _QWORD))(a1[4] + 72))(v5, a1[225]);
    a1[224] = safeh_GetNullHandle();
    a1[225] = v6;
  }
  v7 = a1[226];
  if (v7)
  {
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(a1[4] + 72))(v7, a1[227]);
    if ((int)v4 > -1 && v8 < 0)
      v4 = v8;
    else
      v4 = v4;
    a1[226] = safeh_GetNullHandle();
    a1[227] = v10;
  }
  v11 = a1[228];
  if (v11)
  {
    v12 = (*(uint64_t (**)(uint64_t, _QWORD))(a1[4] + 72))(v11, a1[229]);
    if ((int)v4 > -1 && v12 < 0)
      v4 = v12;
    else
      v4 = v4;
    a1[228] = safeh_GetNullHandle();
    a1[229] = v14;
  }
  v15 = a1[230];
  if (v15)
  {
    v16 = (*(uint64_t (**)(uint64_t, _QWORD))(a1[4] + 72))(v15, a1[231]);
    if ((int)v4 > -1 && v16 < 0)
      v4 = v16;
    else
      v4 = v4;
    a1[230] = safeh_GetNullHandle();
    a1[231] = v18;
  }
  return v4;
}

uint64_t synth_bet3_loc_ParamCheckChange(int a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;

  if (cstdlib_strcmp(__s1, "audiooutputbufsamples"))
  {
    if (cstdlib_strcmp(__s1, "volume"))
    {
      if (cstdlib_strcmp(__s1, "rate") && cstdlib_strcmp(__s1, "rate_baseline"))
      {
        if (cstdlib_strcmp(__s1, "ratewpm"))
        {
          if (cstdlib_strcmp(__s1, "pitch") && cstdlib_strcmp(__s1, "pitch_baseline"))
          {
            result = 0;
          }
          else if (LH_atoi(a3) - 201 >= 0xFFFFFF69)
          {
            result = 0;
          }
          else
          {
            result = 2164269071;
          }
        }
        else
        {
          result = 2164269057;
        }
      }
      else if (LH_atoi(a3) - 401 >= 0xFFFFFEA1)
      {
        result = 0;
      }
      else
      {
        result = 2164269071;
      }
    }
    else if (LH_atoi(a3) <= 0x64)
    {
      result = 0;
    }
    else
    {
      result = 2164269071;
    }
  }
  else if ((int)LH_atoi(a3) <= 0)
  {
    result = 2164269071;
  }
  else
  {
    result = 0;
  }
  *a4 = (int)result >= 0;
  return result;
}

uint64_t synth_bet3_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  const char *v7;

  if (cstdlib_strcmp(__s1, "audiooutputbufsamples")
    && cstdlib_strcmp(__s1, "volume")
    && cstdlib_strcmp(__s1, "rate")
    && cstdlib_strcmp(__s1, "rate_baseline")
    && cstdlib_strcmp(__s1, "ratewpm")
    && cstdlib_strcmp(__s1, "pitch")
    && cstdlib_strcmp(__s1, "pitch_baseline"))
  {
    return 0;
  }
  v7 = LH_atoi(a3);
  return synth_bet3_loc_ParamSet(a1, __s1, (uint64_t)v7);
}

uint64_t synth_bet3_loc_ParamGetListen(uint64_t a1, _BYTE *a2, signed int a3, signed int a4, unsigned int a5, __int128 *a6, unsigned int *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  const char *v25;
  __int128 v26;
  uint64_t v27;

  if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)a2, a7) & 0x80000000) != 0
    || (a5 = a3, (int)*a7 < a3)
    || (a5 = a4, (int)*a7 > a4))
  {
    v14 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)a2, a5);
    *a7 = a5;
    if ((v14 & 0x80000000) != 0)
    {
      v20 = v14;
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v25 = "parameter";
      v23 = "%s%s";
      v22 = 56009;
      goto LABEL_8;
    }
  }
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
  v26 = *a6;
  v27 = *((_QWORD *)a6 + 2);
  v20 = paramc_ListenerAdd(v19, a2, &v26);
  if ((v20 & 0x80000000) != 0)
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    v22 = 56010;
    v23 = 0;
LABEL_8:
    log_OutPublic(v21, (uint64_t)"SYNTH_BET3", v22, (uint64_t)v23, v15, v16, v17, v18, v25);
  }
  return v20;
}

uint64_t synth_bet3_loc_SynthInit_MLSA(uint64_t a1)
{
  uint64_t v2;
  uint64_t Int;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  uint64_t Str;
  uint64_t v10;
  _BOOL4 v11;
  double v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float v32;
  uint64_t inited;
  float v34;
  unsigned int v36;
  __int128 __b[2];
  __int128 v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  char *v42;

  v42 = 0;
  v2 = *(_QWORD *)(a1 + 16);
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0u;
  memset(__b, 0, sizeof(__b));
  v36 = 0;
  Int = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"frequencyhz", &v41);
  if ((Int & 0x80000000) != 0)
  {
    Str = Int;
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_55:
    log_OutPublic(v10, (uint64_t)"SYNTH_BET3", 56008, (uint64_t)"%s%s", v4, v5, v6, v7, "parameter");
    return Str;
  }
  MFVSyn__deinit__MVF_Synthesis((_QWORD *)(a1 + 72));
  *(_DWORD *)(a1 + 48) = v41;
  v8 = (paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"voicemodel", &v42) & 0x80000000) == 0
    && cstdlib_strcmp(v42, "bet3") == 0;
  *(_DWORD *)(a1 + 52) = v8;
  v11 = (paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"voicemodel", &v42) & 0x80000000) == 0
     && !cstdlib_strcmp(v42, "bet4")
     && (paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet4suppressbet3pcm", &v42) & 0x80000000) == 0
     && cstdlib_strcmp(v42, "yes") == 0;
  *(_DWORD *)(a1 + 56) = v11;
  cstdlib_memset(__b, 0, 0x30uLL);
  *(__int128 *)((char *)__b + 8) = xmmword_214F96C20;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)&__b[1] + 1) = _D0;
  BYTE4(v38) = 1;
  *(_WORD *)((char *)&v38 + 5) = *(_DWORD *)(a1 + 52) != 0;
  DWORD2(v38) = 4;
  LODWORD(__b[0]) = vcvtps_s32_f32(wave_t__convertFromF0ToTp__SR((float)v41, 700.0));
  DWORD1(__b[0]) = vcvtms_s32_f32(wave_t__convertFromF0ToTp__SR((float)v41, 40.0));
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicealpha", &v42);
  if ((Str & 0x80000000) != 0
    || !v42
    || !*v42
    || (cstdlib_atof((unsigned __int8 *)v42),
        v18 = v17,
        paramc_ParamRelease(*(_QWORD *)(v2 + 40)),
        Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicebeta", &v42),
        (Str & 0x80000000) != 0)
    || !v42
    || !*v42)
  {
LABEL_54:
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_55;
  }
  cstdlib_atof((unsigned __int8 *)v42);
  v20 = v19;
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  v21 = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voiceframesize", (_DWORD *)&v39 + 1);
  if ((v21 & 0x80000000) != 0)
    goto LABEL_53;
  *(_DWORD *)(a1 + 44) = HIDWORD(v39) * *(_DWORD *)(a1 + 48) / 0x3E8u;
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicevol", &v42);
  if ((Str & 0x80000000) != 0)
    goto LABEL_54;
  if (!v42)
    goto LABEL_54;
  if (!*v42)
    goto LABEL_54;
  cstdlib_atof((unsigned __int8 *)v42);
  *(float *)&v22 = v22;
  *(_DWORD *)(a1 + 60) = LODWORD(v22);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicevuvrelamp", &v42);
  if ((Str & 0x80000000) != 0)
    goto LABEL_54;
  if (!v42)
    goto LABEL_54;
  if (!*v42)
    goto LABEL_54;
  cstdlib_atof((unsigned __int8 *)v42);
  *(float *)&v23 = v23;
  DWORD2(__b[0]) = LODWORD(v23);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicemvfboost", &v42);
  if ((Str & 0x80000000) != 0 || !v42 || !*v42)
    goto LABEL_54;
  cstdlib_atof((unsigned __int8 *)v42);
  v25 = v24;
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  v21 = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voiceorder", &v39);
  if ((v21 & 0x80000000) != 0)
  {
LABEL_53:
    Str = v21;
    goto LABEL_54;
  }
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicef0std", &v42);
  if ((Str & 0x80000000) != 0)
    goto LABEL_54;
  if (!v42)
    goto LABEL_54;
  if (!*v42)
    goto LABEL_54;
  cstdlib_atof((unsigned __int8 *)v42);
  *(float *)&v26 = v26;
  *(_DWORD *)(a1 + 64) = LODWORD(v26);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicef0mean", &v42);
  if ((Str & 0x80000000) != 0 || !v42 || !*v42)
    goto LABEL_54;
  cstdlib_atof((unsigned __int8 *)v42);
  *(float *)&v27 = v27;
  *(_DWORD *)(a1 + 68) = LODWORD(v27);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  if ((paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2cpupower", &v40) & 0x80000000) == 0
    && (int)v40 >= 1
    && (int)v40 < 5)
  {
    DWORD2(v38) = v40;
  }
  if (paramc_ParamGet(*(_QWORD *)(v2 + 40), (uint64_t)"bet3cepstralequalizer", (_QWORD *)(a1 + 1872), &v36)|| (_DWORD)v39 + 1 == v36 >> 2)
  {
    v31 = v18;
    v32 = v20;
    inited = BET3FLT__MFVSyn__init__MVF_Synthesis(*(_QWORD *)(a1 + 16), a1 + 72, __b, 0, SHIDWORD(v39), v39, v31, v32, (float)v41);
    if ((inited & 0x80000000) == 0)
    {
      v34 = v25;
      inited = BET3FLT__MFVSyn__setMVFBoost(a1 + 72, v34);
      if ((inited & 0x80000000) == 0)
      {
        inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"volume", &v40);
        if ((inited & 0x80000000) == 0)
        {
          inited = synth_bet3_loc_ParamSet(a1, "volume", v40);
          if ((inited & 0x80000000) == 0)
          {
            inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate_baseline", &v40);
            if ((inited & 0x80000000) == 0)
            {
              inited = synth_bet3_loc_ParamSet(a1, "rate_baseline", v40);
              if ((inited & 0x80000000) == 0)
              {
                inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch_baseline", &v40);
                if ((inited & 0x80000000) == 0)
                {
                  inited = synth_bet3_loc_ParamSet(a1, "pitch_baseline", v40);
                  if ((inited & 0x80000000) == 0)
                  {
                    inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", &v40);
                    if ((inited & 0x80000000) == 0)
                    {
                      inited = synth_bet3_loc_ParamSet(a1, "rate", v40);
                      if ((inited & 0x80000000) == 0)
                      {
                        inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", &v40);
                        if ((inited & 0x80000000) == 0)
                          return synth_bet3_loc_ParamSet(a1, "pitch", v40);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return inited;
  }
  else
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56008, (uint64_t)"%s%s", v28, v39, v29, v30, "parameter");
    return 0;
  }
}

uint64_t synth_bet3_loc_ParamSet(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  float v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  unsigned int v25;
  unsigned int v26;

  if (cstdlib_strcmp(a2, "audiooutputbufsamples"))
  {
    v6 = critsec_Enter(*(_QWORD **)(a1 + 24));
    if ((v6 & 0x80000000) == 0)
    {
      if (cstdlib_strcmp(a2, "volume"))
      {
        if (cstdlib_strcmp(a2, "rate_baseline"))
        {
          if (!cstdlib_strcmp(a2, "rate"))
          {
            v18 = MapProsodyValue_Scaling(50, 100, 400, *(_DWORD *)(a1 + 1892), a3);
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 3, 0, (uint64_t)"Set rate %d", v19, v20, v21, a3);
            if (!*(_DWORD *)(a1 + 1896))
            {
              v10 = v6;
              if (*(_DWORD *)(a1 + 52))
              {
                if (MFVSyn__setRateTtsEg(a1 + 72, v18))
                  v10 = 2164269071;
                else
                  v10 = v6;
              }
              goto LABEL_38;
            }
            goto LABEL_26;
          }
          if (!cstdlib_strcmp(a2, "ratewpm"))
          {
            v10 = 2164269057;
            goto LABEL_38;
          }
          if (cstdlib_strcmp(a2, "pitch_baseline"))
          {
            if (!cstdlib_strcmp(a2, "pitch"))
            {
              v10 = 2164269071;
              if ((a3 - 201) >= 0xFFFFFF69)
              {
                if (*(_DWORD *)(a1 + 52))
                {
                  v11 = (float)(int)MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 1888), a3);
                  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 3, 0, (uint64_t)"Set pitch %d (synth %f)", v12, v13, v14, a3);
                  v10 = v6;
                  if (!*(_DWORD *)(a1 + 1896))
                  {
                    BET3FLT__MFVSyn__setPitchLevelPercent(a1 + 72, v11);
                    if (v15)
                      v10 = 2164269071;
                    else
                      v10 = v6;
                  }
                  goto LABEL_38;
                }
                goto LABEL_26;
              }
LABEL_38:
              critsec_Leave(*(_QWORD **)(a1 + 24));
              return v10;
            }
LABEL_26:
            v10 = v6;
            goto LABEL_38;
          }
          v10 = 2164269071;
          if ((a3 - 201) < 0xFFFFFF69)
            goto LABEL_38;
          v26 = 0;
          *(_DWORD *)(a1 + 1888) = a3;
          v22 = "pitch";
          paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", &v26);
          v23 = v26;
LABEL_28:
          synth_bet3_loc_ParamSet(a1, v22, v23);
          v10 = 0;
          goto LABEL_38;
        }
        if ((a3 - 401) >= 0xFFFFFEA1)
        {
          v25 = 0;
          *(_DWORD *)(a1 + 1892) = a3;
          v22 = "rate";
          paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", &v25);
          v23 = v25;
          goto LABEL_28;
        }
      }
      else if (a3 <= 0x64)
      {
        v10 = v6;
        if (!*(_DWORD *)(a1 + 1896))
        {
          if (a3 > 0x50)
            v17 = *(float *)(a1 + 60) + (float)((float)((float)(2.0 - *(float *)(a1 + 60)) * (float)(a3 - 80)) / 20.0);
          else
            v17 = (float)(*(float *)(a1 + 60) * (float)(int)a3) / 80.0;
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 3, 0, (uint64_t)"Set volume %d (synth %f)", v7, v8, v9, a3);
          v10 = BET3FLT__MFVSyn__setVolumeBoost(a1 + 72, v17);
        }
        goto LABEL_38;
      }
      v10 = 2164269071;
      goto LABEL_38;
    }
  }
  else
  {
    v6 = 0;
    if (a3 <= 1)
      v16 = 1;
    else
      v16 = a3;
    *(_DWORD *)(a1 + 40) = v16;
  }
  return v6;
}

void rand_num(unint64_t *a1, float *a2, int a3, float a4)
{
  float v6;
  uint64_t v7;

  if (a3 >= 1)
  {
    v6 = a4 + a4;
    v7 = a3;
    do
    {
      *a2++ = v6 * (float)((float)(rand31pmc_ranf(a1) * 4.6566e-10) + -0.5);
      --v7;
    }
    while (v7);
  }
}

uint64_t *BET3FLT__rand_num_init(uint64_t *a1)
{
  return BET3FLT__rand31pmc_seedi(a1, 0);
}

void BET3FLT__MFVSyn__constructExcitationShapingFilter(uint64_t a1, float a2)
{
  float v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  float v9;
  int v10;
  float v11;
  float v12;
  BOOL v13;
  float v14;
  unsigned int v15;
  float v16;
  float v17;

  v2 = a2;
  if (a2 <= 0.0)
  {
    vect_t__fillZero(a1 + 576);
  }
  else
  {
    v17 = 0.0;
    rand_num((unint64_t *)(a1 + 88), &v17, 1, 1.0);
    v4 = *(_QWORD *)(a1 + 584);
    v5 = *(int *)(a1 + 592);
    *(float *)(v4 + 4 * (v5 - 1)) = (float)((float)(v17 * 25.0) + 25.0) + v2;
    v_equ((void *)v4, (const void *)(v4 + 4), v5 - 1);
    v17 = 0.0;
    v6 = *(_QWORD *)(a1 + 584);
    v7 = *(_DWORD *)(a1 + 592);
    v8 = *(float *)(v6 + 4 * (v7 - 2));
    if (v8 <= 0.0)
    {
      v10 = 0;
      v9 = 0.0;
    }
    else
    {
      v9 = (float)(v8 * 4.0) + 0.0;
      v17 = v9;
      v10 = 4;
    }
    v11 = *(float *)(v6 + 4 * (v7 - 3));
    if (v11 > 0.0)
    {
      v10 |= 2u;
      v9 = v9 + (float)(v11 * 2.0);
      v17 = v9;
    }
    v12 = *(float *)(v6 + 4 * (v7 - 4));
    v13 = v12 <= 0.0;
    if (v12 <= 0.0)
      v12 = -0.0;
    v14 = v9 + v12;
    if (v13)
      v15 = v10;
    else
      v15 = v10 + 1;
    v2 = v14 * invDiv[v15];
  }
  v16 = (float)*(int *)(a1 + 168) * 0.5;
  if (v16 >= (float)(v2 * *(float *)(a1 + 52)))
    v16 = v2 * *(float *)(a1 + 52);
  *(float *)(a1 + 552) = v16;
}

float MFVSyn__filterExcitationWithShapingFilterFast(uint64_t a1, int a2, uint64_t a3, float a4)
{
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  unsigned int v13;
  float v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v7 = *(float *)(a1 + 552);
  if (v7 > 0.0)
  {
    v8 = *(float *)(a1 + 556);
    if (v8 > 0.0)
      v7 = (float)((float)(1.0 - a4) * v8) + (float)(a4 * v7);
  }
  v9 = *(unsigned int *)(a1 + 792);
  v10 = a1 + 808;
  if ((int)v9 < 1)
  {
LABEL_8:
    LODWORD(v11) = 0;
  }
  else
  {
    v11 = 0;
    v12 = (float *)(a1 + 824);
    while (*v12 < (float)(v7 / (float)*(int *)(a1 + 168)))
    {
      ++v11;
      v12 += 6;
      if (v9 == v11)
        goto LABEL_8;
    }
  }
  v13 = v11;
  v_equ(*(void **)(a3 + 8), *(const void **)(v10 + 24 * v11), *(unsigned __int16 *)(a1 + 796));
  v14 = sqrt((double)a2);
  v_scale(*(float **)(a3 + 8), *(unsigned __int16 *)(a1 + 796), *(float *)(a1 + 56) * v14);
  v15 = *(_DWORD *)(a1 + 672);
  if (v15 >= 1)
  {
    if (v15 >= a2)
      v15 = a2;
    if (*(_DWORD *)(a3 + 16) >= v15)
      v16 = v15;
    else
      v16 = *(_DWORD *)(a3 + 16);
    v_add(*(float **)(a3 + 8), *(float **)(a1 + 664), v16);
    v17 = *(_DWORD *)(a1 + 672);
    if (v17 > v16)
    {
      v_equ(*(void **)(a1 + 664), (const void *)(*(_QWORD *)(a1 + 664) + 4 * v16), v17 - v16);
      *(_DWORD *)(a1 + 672) = (*(_DWORD *)(a1 + 672) - v16) & ~((*(_DWORD *)(a1 + 672) - v16) >> 31);
    }
  }
  vect_t__fillZero(a1 + 656);
  v18 = *(unsigned __int16 *)(a1 + 796);
  if (v18 <= a2)
  {
    v19 = a2;
  }
  else
  {
    v19 = a2;
    v_equ(*(void **)(a1 + 664), (const void *)(*(_QWORD *)(a3 + 8) + 4 * a2), v18 - a2);
    v20 = *(unsigned __int16 *)(a1 + 796) - a2;
    if (v20 <= *(_DWORD *)(a1 + 672))
      v20 = *(_DWORD *)(a1 + 672);
    *(_DWORD *)(a1 + 672) = v20;
  }
  v21 = *(unsigned __int16 *)(a1 + 800);
  rand_num((unint64_t *)(a1 + 88), (float *)(*(_QWORD *)(a1 + 464) + 4 * v21), a2, (float)(*(float *)(a1 + 44) * 1.15) * *(float *)(a1 + 56));
  v_equ(*(void **)(a1 + 464), *(const void **)(a1 + 688), v21);
  v_equ(*(void **)(a1 + 688), (const void *)(*(_QWORD *)(a1 + 464) + 4 * v19), v21);
  zerflt(*(_QWORD *)(a1 + 464) + 4 * v21, *(float **)(v10 + 24 * v13 + 8), *(_QWORD *)(a1 + 464) + 4 * v21, *(unsigned __int16 *)(a1 + 800), a2);
  v_equ(*(void **)(a1 + 464), (const void *)(*(_QWORD *)(a1 + 464) + 4 * v21), a2);
  return v_add(*(float **)(a3 + 8), *(float **)(a1 + 464), a2);
}

uint64_t BET3FLT__vect_t__createVect(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  void *v6;

  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = a1;
  v5 = 4 * a3;
  v6 = (void *)heap_Alloc(a1, v5);
  *(_QWORD *)(a2 + 8) = v6;
  if (!v6)
    return 2164269066;
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = a3;
  if (a3 >= 1)
    bzero(v6, v5);
  return 0;
}

_QWORD *BET3FLT__vect_t__deleteVect(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;

  if (result)
  {
    v2 = result + 1;
    v1 = result[1];
    if (v1)
      result = heap_Free((_QWORD *)*result, v1);
    *v2 = 0;
    v2[1] = 0;
  }
  return result;
}

void vect_t__fillZero(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned int *)(a1 + 20);
  if ((int)v1 >= 1)
    bzero(*(void **)(a1 + 8), 4 * v1);
}

uint64_t vect_t__scale(uint64_t result, float a2)
{
  uint64_t v2;
  float *v3;

  v2 = *(unsigned int *)(result + 16);
  if ((int)v2 >= 1)
  {
    v3 = *(float **)(result + 8);
    do
    {
      *v3 = *v3 * a2;
      ++v3;
      --v2;
    }
    while (v2);
  }
  return result;
}

void vect_t__mulByHanning(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float v4;

  v1 = *(unsigned int *)(a1 + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(a1 + 8);
    do
    {
      v4 = cos((float)((float)(6.2832 / (float)(v1 - 1)) * (float)(int)v2));
      *(float *)(v3 + 4 * v2) = (float)((float)(1.0 - v4) * 0.5) * *(float *)(v3 + 4 * v2);
      ++v2;
    }
    while (v1 != v2);
  }
}

void vect_t__mulByHamming(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float v4;

  v1 = *(unsigned int *)(a1 + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(a1 + 8);
    do
    {
      v4 = cos((float)((float)(6.2832 / (float)(v1 - 1)) * (float)(int)v2));
      *(float *)(v3 + 4 * v2) = (float)((float)(v4 * -0.46) + 0.54) * *(float *)(v3 + 4 * v2);
      ++v2;
    }
    while (v1 != v2);
  }
}

void vect_t__mulByBlackman(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  float v7;

  v1 = *(unsigned int *)(a1 + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(a1 + 8);
    do
    {
      v4 = (float)(6.2832 / (float)(v1 - 1)) * (float)(int)v2;
      v5 = cos(v4);
      v6 = (float)(v5 * -0.5) + 0.42;
      v7 = cos((float)(v4 + v4));
      *(float *)(v3 + 4 * v2) = (float)(v6 + (float)(v7 * 0.08)) * *(float *)(v3 + 4 * v2);
      ++v2;
    }
    while (v1 != v2);
  }
}

uint64_t BET3FLT__MFVSyn__SynthesisOneFrame(uint64_t a1, const void *a2, int *a3, _QWORD *a4, float a5, float a6, float a7, float a8)
{
  int v15;
  _BOOL4 v16;
  _BOOL4 v17;
  float v18;
  float v19;
  float v20;
  int v21;
  int v22;
  uint64_t v23;
  float v24;
  float v25;
  int v26;
  float v27;
  int v28;
  int v29;
  uint64_t v30;
  float v31;
  float *v32;
  float *v33;
  float *v34;
  uint64_t v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  float v40;
  float *v41;
  float *v42;
  float *v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  signed int v48;
  void *v49;
  const void *v50;
  int i;
  float v52;
  float v53;
  float v54;
  int v55;
  int v56;
  uint64_t v57;
  int v58;
  int v59;
  float v61;

  *a3 = 0;
  v15 = *(_DWORD *)(a1 + 604);
  v16 = a5 == 0.0;
  if (v15 != 1)
    v16 = 0;
  if (v15)
    v17 = 0;
  else
    v17 = a5 > 0.0;
  *a4 = 0;
  *(_DWORD *)(a1 + 600) = v17 || v16;
  if (a5 != 0.0)
  {
    a5 = *(float *)(a1 + 64) * a5;
    if (a5 < 40.0)
      a5 = 40.0;
  }
  *(_DWORD *)(a1 + 604) = a5 > 0.0;
  v18 = (float)*(int *)(a1 + 480);
  v19 = *(float *)(a1 + 60);
  v20 = BET3FLT__wave_t__convertFromF0ToTp((float *)(a1 + 32), a5);
  *(float *)(a1 + 704) = v20;
  if (v20 == 0.0)
  {
    v21 = *(_DWORD *)(a1 + 544);
    *(_DWORD *)(a1 + 544) = v21 + 1;
    v22 = *(_DWORD *)(a1 + 536);
    v23 = *(_QWORD *)(a1 + 528);
    if (v21 >= v22)
    {
      v_equ((void *)v23, (const void *)(v23 + 4), v22 - 1);
      v23 = *(_QWORD *)(a1 + 528);
      v22 = *(_DWORD *)(a1 + 536);
      *(float *)(v23 + 4 * (v22 - 1)) = (float)*(int *)(a1 + 512);
    }
    *(float *)(a1 + 704) = v_sum((float *)v23, v22) / (float)*(int *)(a1 + 536);
  }
  else
  {
    *(_DWORD *)(a1 + 544) = 0;
    v_equ(*(void **)(a1 + 528), (const void *)(*(_QWORD *)(a1 + 528) + 4), *(_DWORD *)(a1 + 536) - 1);
    *(_DWORD *)(*(_QWORD *)(a1 + 528) + 4 * *(int *)(a1 + 536) - 4) = *(_DWORD *)(a1 + 704);
  }
  v24 = v19 * v18;
  v_equ(*(void **)(a1 + 728), a2, *(_DWORD *)(a1 + 200) + 1);
  v25 = 0.0;
  if (a6 > 0.0)
    v25 = 0.25;
  *(float *)(a1 + 708) = v25;
  *(float *)(a1 + 712) = a8;
  v26 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 560) = 1065353216;
  *(_DWORD *)(a1 + 568) = v26;
  BET3FLT__MFVSyn__mc2mlsa(a1, *(_QWORD *)(a1 + 728), *(_QWORD *)(a1 + 384));
  MFVSyn__postFilter(a1, *(float **)(a1 + 728), *(float **)(a1 + 384));
  v_equ(*(void **)(a1 + 728), *(const void **)(a1 + 384), *(_DWORD *)(a1 + 200) + 1);
  BET3FLT__MFVSyn__constructExcitationShapingFilter(a1, *(float *)(a1 + 712));
  if (*(_DWORD *)(a1 + 600)
    || (v27 = vabds_f32(*(float *)(a1 + 704), *(float *)(a1 + 744)),
        v27 >= BET3FLT__wave_t__convertFromTpToF0((float *)(a1 + 32), 60.0)))
  {
    *(_DWORD *)(a1 + 744) = *(_DWORD *)(a1 + 704);
  }
  v28 = vcvtps_s32_f32(v24);
  v29 = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(a1 + 84) = (v29 + 1) >> 1;
  if (*(_BYTE *)(a1 + 244))
  {
    v30 = *(unsigned int *)(a1 + 240);
    if ((v30 & 0x80000000) == 0)
    {
      v31 = 1.0 / (float)(1 << *(_BYTE *)(a1 + 244));
      v32 = *(float **)(a1 + 728);
      v33 = *(float **)(a1 + 768);
      v34 = *(float **)(a1 + 224);
      v35 = v30 + 1;
      do
      {
        v36 = *v32++;
        v37 = v36;
        v38 = *v33++;
        *v34++ = v31 * (float)(v37 - v38);
        --v35;
      }
      while (v35);
    }
  }
  else
  {
    v39 = *(unsigned int *)(a1 + 240);
    if ((v39 & 0x80000000) == 0)
    {
      v40 = (float)v29 / (float)v28;
      v41 = *(float **)(a1 + 728);
      v42 = *(float **)(a1 + 768);
      v43 = *(float **)(a1 + 224);
      v44 = v39 + 1;
      do
      {
        v45 = *v41++;
        v46 = v45;
        v47 = *v42++;
        *v43++ = v40 * (float)(v46 - v47);
        --v44;
      }
      while (v44);
    }
  }
  v_equ(*(void **)(a1 + 184), *(const void **)(a1 + 768), *(_DWORD *)(a1 + 200) + 1);
  v48 = *(_DWORD *)(a1 + 784);
  if (v48 >= 1)
  {
    v49 = *(void **)(a1 + 440);
    v50 = *(const void **)(a1 + 416);
    if (v48 <= v28)
    {
      v_equ(v49, v50, v48);
      BET3FLT__MFVSyn__mlsa_filter(a1, *(_QWORD *)(a1 + 440), *(_QWORD *)(a1 + 496), *(_DWORD *)(a1 + 784));
    }
    else
    {
      v_equ(v49, v50, v28);
      BET3FLT__MFVSyn__mlsa_filter(a1, *(_QWORD *)(a1 + 440), *(_QWORD *)(a1 + 496), v28);
      v_equ(*(void **)(a1 + 416), (const void *)(*(_QWORD *)(a1 + 416) + 4 * v28), *(_DWORD *)(a1 + 784) - v28);
    }
  }
  for (i = *(_DWORD *)(a1 + 784); i < v28; *(_DWORD *)(a1 + 784) = i)
  {
    v52 = (float)i / (float)v28;
    v53 = *(float *)(a1 + 704);
    if (*(_DWORD *)(a1 + 76) < 4u)
    {
      v54 = *(float *)(a1 + 708);
    }
    else
    {
      v53 = (float)((float)(1.0 - v52) * *(float *)(a1 + 744)) + (float)(v52 * v53);
      v54 = (float)((float)(1.0 - v52) * *(float *)(a1 + 748)) + (float)(v52 * *(float *)(a1 + 708));
    }
    v61 = 0.0;
    rand_num((unint64_t *)(a1 + 88), &v61, 1, 1.0);
    v55 = (int)(v53 * (1.0 - (float)(v54 * v61)) + 0.5);
    if (*(_DWORD *)(a1 + 36) > v55)
      v55 = *(_DWORD *)(a1 + 36);
    if (v55 >= *(_DWORD *)(a1 + 40))
      v56 = *(_DWORD *)(a1 + 40);
    else
      v56 = v55;
    if (*(_BYTE *)(a1 + 74))
      MFVSyn__filterExcitationWithShapingFilterFast(a1, v56, a1 + 432, v52);
    else
      MFVSyn__filterExcitationWithShapingFilterHQ(a1, v56, *(_DWORD *)(a1 + 604), a1 + 432, v53, v52, a7);
    v57 = *(int *)(a1 + 784);
    v58 = v57 + v56;
    if ((int)v57 + v56 >= v28)
      v58 = v28;
    BET3FLT__MFVSyn__mlsa_filter(a1, *(_QWORD *)(a1 + 440), *(_QWORD *)(a1 + 496) + 4 * v57, v58 - v57);
    v59 = *(_DWORD *)(a1 + 784);
    i = v59 + v56;
    if (v59 + v56 > v28)
    {
      v_equ(*(void **)(a1 + 416), (const void *)(*(_QWORD *)(a1 + 440) + 4 * (v28 - v59)), v56 - (v28 - v59));
      i = *(_DWORD *)(a1 + 784) + v56;
    }
  }
  *(_DWORD *)(a1 + 556) = *(_DWORD *)(a1 + 552);
  *(_DWORD *)(a1 + 564) = *(_DWORD *)(a1 + 560);
  *(_DWORD *)(a1 + 572) = *(_DWORD *)(a1 + 568);
  *(_DWORD *)(a1 + 752) = *(_DWORD *)(a1 + 712);
  *(_QWORD *)(a1 + 744) = *(_QWORD *)(a1 + 704);
  v_equ(*(void **)(a1 + 768), *(const void **)(a1 + 728), *(_DWORD *)(a1 + 200) + 1);
  if (*(_BYTE *)(a1 + 73))
    MFVSyn__disperse(a1, a1 + 488, 0, v28);
  *(_DWORD *)(a1 + 784) -= v28;
  *a3 = v28;
  *a4 = *(_QWORD *)(a1 + 496);
  return 0;
}

unint64_t BET3FLT__rand31pmc_next(unint64_t *a1)
{
  unint64_t v1;

  v1 = ((1101463552 * (*a1 >> 16)) & 0x7FFF0000)
     + 16807 * (unsigned __int16)*a1
     + ((16807 * (*a1 >> 16)) >> 15);
  if (v1 >> 31)
    v1 -= 0x7FFFFFFFLL;
  *a1 = v1;
  return v1;
}

uint64_t *BET3FLT__rand31pmc_seedi(uint64_t *result, unint64_t a2)
{
  uint64_t v2;

  if (a2 <= 1)
    v2 = 1;
  else
    v2 = a2;
  *result = v2;
  return result;
}

unint64_t rand31pmc_ranlui(unint64_t *a1)
{
  unint64_t v1;

  v1 = ((1101463552 * (*a1 >> 16)) & 0x7FFF0000)
     + 16807 * (unsigned __int16)*a1
     + ((16807 * (*a1 >> 16)) >> 15);
  if (v1 >> 31)
    v1 -= 0x7FFFFFFFLL;
  *a1 = v1;
  return v1;
}

float rand31pmc_ranf(unint64_t *a1)
{
  unint64_t v1;

  v1 = ((1101463552 * (*a1 >> 16)) & 0x7FFF0000)
     + 16807 * (unsigned __int16)*a1
     + ((16807 * (*a1 >> 16)) >> 15);
  if (v1 >> 31)
    v1 -= 0x7FFFFFFFLL;
  *a1 = v1;
  return (float)v1;
}

uint64_t BET3FLT__MFVSyn__setSpectralOrder(uint64_t a1, int a2)
{
  uint64_t result;

  result = 2164269071;
  if (a2 >= 6 && *(_DWORD *)(a1 + 204) >= a2)
  {
    result = 0;
    *(_DWORD *)(a1 + 200) = a2;
  }
  return result;
}

uint64_t BET3FLT__MFVSyn__getSpectralOrder(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 200);
  return 0;
}

uint64_t BET3FLT__MFVSyn__setVolumeBoost(uint64_t a1, float a2)
{
  BOOL v2;
  BOOL v3;
  uint64_t result;

  if (a2 >= 0.0)
  {
    v3 = a2 == 2.0;
    v2 = a2 >= 2.0;
  }
  else
  {
    v2 = 1;
    v3 = 0;
  }
  if (!v3 && v2)
    return 2164269071;
  result = 0;
  *(float *)(a1 + 56) = a2;
  return result;
}

uint64_t BET3FLT__MFVSyn__getVolumeBoost(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 56);
  return 0;
}

uint64_t BET3FLT__MFVSyn__setMVFBoost(uint64_t a1, float a2)
{
  BOOL v2;
  BOOL v3;
  uint64_t result;

  if (a2 >= 0.0)
  {
    v3 = a2 == 2.0;
    v2 = a2 >= 2.0;
  }
  else
  {
    v2 = 1;
    v3 = 0;
  }
  if (!v3 && v2)
    return 2164269071;
  result = 0;
  *(float *)(a1 + 52) = a2;
  return result;
}

uint64_t BET3FLT__MFVSyn__getMVFBoost(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 52);
  return 0;
}

uint64_t BET3FLT__MFVSyn__setRate(uint64_t a1, float a2)
{
  BOOL v2;
  BOOL v3;
  uint64_t result;

  if (a2 > 0.0)
  {
    v3 = a2 == 4.0;
    v2 = a2 >= 4.0;
  }
  else
  {
    v2 = 1;
    v3 = 0;
  }
  if (!v3 && v2)
    return 2164269071;
  result = 0;
  *(float *)(a1 + 60) = a2;
  return result;
}

uint64_t BET3FLT__MFVSyn__getRate(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 60);
  return 0;
}

uint64_t MFVSyn__setRateTtsEg(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  float v6;
  float v7;

  v2 = 2164269071;
  if (a2 >= 400)
    v3 = 400;
  else
    v3 = a2;
  if (v3 <= 50)
    v4 = 50;
  else
    v4 = v3;
  if ((a2 - 401) >= 0xFFFFFEA1)
    v5 = 0;
  else
    v5 = 2164269071;
  v6 = 100.0 / (float)v4;
  v7 = 0.01;
  if (v6 >= 0.01)
  {
    v7 = 100.0 / (float)v4;
    if (v6 > 4.0)
      v7 = 4.0;
  }
  if (v7 > 0.0 && v7 <= 4.0)
  {
    *(float *)(a1 + 60) = v7;
    return v5;
  }
  return v2;
}

float BET3FLT__MFVSyn__setPitchLevelPercent(uint64_t a1, float result)
{
  if (result >= 50.0 && result <= 200.0)
  {
    result = result / 100.0;
    *(float *)(a1 + 64) = result;
  }
  return result;
}

uint64_t MFVSyn__getPitchLevelHz(uint64_t a1, float *a2)
{
  *a2 = *(float *)(a1 + 64) * 100.0;
  return 0;
}

uint64_t MFVSyn__EnableDispersionFilter(uint64_t a1)
{
  *(_BYTE *)(a1 + 73) = 1;
  return 0;
}

uint64_t MFVSyn__DisableDispersionFilter(uint64_t a1)
{
  *(_BYTE *)(a1 + 73) = 0;
  return 0;
}

uint64_t *BET3FLT__MFVSyn__construct(uint64_t a1)
{
  uint64_t *result;

  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 604) = 0;
  *(_QWORD *)(a1 + 584) = 0;
  result = BET3FLT__rand_num_init((uint64_t *)(a1 + 88));
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  if (!*(_BYTE *)(a1 + 74))
  {
    *(_QWORD *)(a1 + 688) = 0;
    *(_QWORD *)(a1 + 664) = 0;
    *(_QWORD *)(a1 + 640) = 0;
    *(_QWORD *)(a1 + 616) = 0;
  }
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  return result;
}

_QWORD *BET3FLT__MFVSyn__deconstruct(uint64_t a1)
{
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 760));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 720));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 520));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 576));
  BET3FLT__MFVSyn__mlsa_filter_deinit(a1);
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 176));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 216));
  if (!*(_BYTE *)(a1 + 74))
  {
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 608));
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 632));
  }
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 656));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 680));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 144));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 96));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 120));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 408));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 432));
  BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 456));
  return BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 488));
}

uint64_t BET3FLT__MFVSyn__init__MVF_Synthesis(uint64_t a1, uint64_t a2, __int128 *a3, char *a4, int a5, int a6, float a7, float a8, float a9)
{
  __int128 v14;
  __int128 v15;
  float *v16;
  uint64_t ExcTable;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  float v32;
  uint64_t Vect;

  *(_QWORD *)a2 = a1;
  v14 = *a3;
  v15 = a3[1];
  *(_OWORD *)(a2 + 68) = a3[2];
  *(_OWORD *)(a2 + 52) = v15;
  *(_OWORD *)(a2 + 36) = v14;
  *(_DWORD *)(a2 + 200) = a6;
  *(_DWORD *)(a2 + 204) = a6;
  v16 = (float *)(a2 + 32);
  BET3FLT__wave_t__setSampleRateHz((float *)(a2 + 32), a9);
  BET3FLT__MFVSyn__construct(a2);
  *(float *)(a2 + 68) = BET3FLT__wave_t__convertFromMsecToTp(v16, (float)a5);
  if (*(_BYTE *)(a2 + 74))
  {
    ExcTable = BET3FLT__MFVSyn__loadExcTable((_QWORD *)a2, a4);
    if ((ExcTable & 0x80000000) != 0)
      return ExcTable;
  }
  *(_DWORD *)(a2 + 600) = 0;
  *(_DWORD *)(a2 + 512) = (int)BET3FLT__wave_t__convertFromF0ToTp(v16, 250.0);
  ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 520, 4);
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  v_set(*(float **)(a2 + 528), *(_DWORD *)(a2 + 540), 1.0);
  v_scale(*(float **)(a2 + 528), *(_DWORD *)(a2 + 540), (float)*(int *)(a2 + 512));
  *(_DWORD *)(a2 + 544) = 0;
  *(_DWORD *)(a2 + 168) = (int)BET3FLT__wave_t__sampleRateHz((uint64_t)v16);
  ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 576, 5);
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  if (*(_BYTE *)(a2 + 74))
  {
    v18 = *(unsigned __int16 *)(a2 + 796);
    if (v18 <= *(unsigned __int16 *)(a2 + 800))
      v18 = *(unsigned __int16 *)(a2 + 800);
  }
  else
  {
    *(_QWORD *)(a2 + 808) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    v18 = 89;
  }
  *(_DWORD *)(a2 + 172) = v18;
  ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 176, *(_DWORD *)(a2 + 200) + 1);
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  v19 = *(_QWORD *)(*(_QWORD *)a2 + 8);
  v20 = *(_DWORD *)(a2 + 172);
  if (*(_BYTE *)(a2 + 74))
  {
    ExcTable = BET3FLT__vect_t__createVect(v19, a2 + 656, v20);
    if ((ExcTable & 0x80000000) == 0)
    {
      *(_DWORD *)(a2 + 672) = 0;
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 680, *(_DWORD *)(a2 + 172));
      if ((ExcTable & 0x80000000) == 0)
      {
        *(_DWORD *)(a2 + 136) = 0;
        goto LABEL_14;
      }
    }
    return ExcTable;
  }
  ExcTable = BET3FLT__vect_t__createVect(v19, a2 + 608, v20);
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 632, *(_DWORD *)(a2 + 172));
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 656, *(_DWORD *)(a2 + 172));
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 680, *(_DWORD *)(a2 + 172));
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
  ExcTable = MFVSyn__setDispersion(a2, *(_DWORD *)(a2 + 168));
  if ((ExcTable & 0x80000000) != 0)
    return ExcTable;
LABEL_14:
  *(_DWORD *)(a2 + 556) = 0;
  *(_DWORD *)(a2 + 564) = 0;
  *(_DWORD *)(a2 + 572) = 0;
  *(_DWORD *)(a2 + 784) = 0;
  v21 = (int)*(float *)(a2 + 68);
  *(_DWORD *)(a2 + 480) = v21;
  switch(*(_DWORD *)(a2 + 76))
  {
    case 1:
      v22 = *(_DWORD *)(a2 + 200);
      if (v22 < 4)
        v23 = 1;
      else
        v23 = v22 >> 2;
      *(_DWORD *)(a2 + 240) = v23;
      *(_BYTE *)(a2 + 244) = 1;
      *(_DWORD *)(a2 + 208) = v21 >> 1;
      *(_DWORD *)(a2 + 80) = 0;
      goto LABEL_32;
    case 2:
      v24 = *(_DWORD *)(a2 + 200);
      if (v24 <= 24)
        v24 = 24;
      v23 = v24 >> 1;
      *(_DWORD *)(a2 + 240) = v23;
      *(_BYTE *)(a2 + 244) = 0;
      if (v21 <= 67)
        v25 = v21 >> 2;
      else
        v25 = 16;
      *(_DWORD *)(a2 + 208) = v25;
      *(_DWORD *)(a2 + 80) = 1;
LABEL_32:
      v26 = 3;
      goto LABEL_36;
    case 3:
      v23 = *(_DWORD *)(a2 + 200);
      *(_DWORD *)(a2 + 240) = v23;
      *(_BYTE *)(a2 + 244) = 0;
      *(_DWORD *)(a2 + 208) = 1;
      *(_DWORD *)(a2 + 80) = 2;
      v26 = 4;
      goto LABEL_36;
    case 4:
      v23 = *(_DWORD *)(a2 + 200);
      *(_DWORD *)(a2 + 240) = v23;
      *(_BYTE *)(a2 + 244) = 0;
      *(_DWORD *)(a2 + 208) = 1;
      *(_DWORD *)(a2 + 80) = 3;
      goto LABEL_35;
    default:
      v23 = *(_DWORD *)(a2 + 240);
LABEL_35:
      v26 = 5;
LABEL_36:
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 216, v23 + 1);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      ExcTable = BET3FLT__MFVSyn__mlsa_filter_init(a2, v26, a7, a8);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      if (*(float *)(a2 + 1628) == 0.0)
        *(_DWORD *)(a2 + 80) = 0;
      ExcTable = MFVSyn__init__postFilter((_DWORD *)a2);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      v27 = *(_DWORD *)(a2 + 172);
      if (v27 <= 2 * *(_DWORD *)(a2 + 40))
        v27 = 2 * *(_DWORD *)(a2 + 40);
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 432, 2 * v27);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      v28 = *(_DWORD *)(a2 + 172);
      if (v28 <= *(_DWORD *)(a2 + 40))
        v28 = *(_DWORD *)(a2 + 40);
      v29 = *(_DWORD *)(a2 + 480) <= v28 ? v28 : *(_DWORD *)(a2 + 480);
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 408, v29);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      v30 = *(_DWORD *)(a2 + 172);
      if (v30 <= 2 * *(_DWORD *)(a2 + 40))
        v30 = 2 * *(_DWORD *)(a2 + 40);
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 456, 2 * v30);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      v31 = *(_DWORD *)(a2 + 40);
      if (v31 <= *(_DWORD *)(a2 + 480))
        v31 = *(_DWORD *)(a2 + 480);
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 488, *(_DWORD *)(a2 + 136) + v31 + 1);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      v32 = (float)*(int *)(a2 + 512);
      *(float *)(a2 + 744) = v32;
      *(float *)(a2 + 752) = v32;
      ExcTable = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 760, *(_DWORD *)(a2 + 200) + 1);
      if ((ExcTable & 0x80000000) != 0)
        return ExcTable;
      Vect = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a2 + 8), a2 + 720, *(_DWORD *)(a2 + 200) + 1);
      if ((Vect & 0x80000000) == 0)
      {
        BET3FLT__MFVSyn__mc2mlsa(a2, *(_QWORD *)(a2 + 768), *(_QWORD *)(a2 + 768));
        *(_DWORD *)(a2 + 748) = 0;
      }
      break;
  }
  return Vect;
}

uint64_t BET3FLT__MFVSyn__reset__MVF_Synthesis(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 2164269063;
  BET3FLT__rand_num_init((uint64_t *)(a1 + 88));
  *(_DWORD *)(a1 + 784) = 0;
  *(_DWORD *)(a1 + 604) = 0;
  *(_DWORD *)(a1 + 556) = 0;
  v_zap(*(void **)(a1 + 128), *(_DWORD *)(a1 + 140));
  v_zap(*(void **)(a1 + 1656), *(_DWORD *)(a1 + 1668));
  v_zap(*(void **)(a1 + 384), *(_DWORD *)(a1 + 396));
  *(float *)(a1 + 744) = (float)*(int *)(a1 + 512);
  *(_DWORD *)(a1 + 752) = 0;
  v_zap(*(void **)(a1 + 768), *(_DWORD *)(a1 + 776));
  BET3FLT__MFVSyn__mc2mlsa(a1, *(_QWORD *)(a1 + 768), *(_QWORD *)(a1 + 768));
  v_zap(*(void **)(a1 + 440), *(_DWORD *)(a1 + 452));
  v_zap(*(void **)(a1 + 416), *(_DWORD *)(a1 + 428));
  v_zap(*(void **)(a1 + 664), *(_DWORD *)(a1 + 676));
  v_zap(*(void **)(a1 + 688), *(_DWORD *)(a1 + 700));
  v_zap(*(void **)(a1 + 464), *(_DWORD *)(a1 + 476));
  v_zap(*(void **)(a1 + 224), *(_DWORD *)(a1 + 236));
  v_set(*(float **)(a1 + 528), *(_DWORD *)(a1 + 540), 1.0);
  v_scale(*(float **)(a1 + 528), *(_DWORD *)(a1 + 540), (float)*(int *)(a1 + 512));
  *(_DWORD *)(a1 + 544) = 0;
  v_zap(*(void **)(a1 + 584), *(_DWORD *)(a1 + 596));
  result = 0;
  *(_QWORD *)(a1 + 552) = 0;
  *(_QWORD *)(a1 + 568) = 0;
  *(_QWORD *)(a1 + 560) = 0;
  return result;
}

void *MFVSyn__deinit__MVF_Synthesis(_QWORD *a1)
{
  BET3FLT__MFVSyn__releaseExcTable(a1);
  MFVSyn__deinit__postFilter((uint64_t)a1);
  BET3FLT__MFVSyn__deconstruct((uint64_t)a1);
  return cstdlib_memset(a1, 0, 0x6B8uLL);
}

uint64_t MFVSyn__disperse(uint64_t a1, uint64_t a2, int a3, signed int a4)
{
  uint64_t v8;

  v8 = *(int *)(a1 + 160);
  v_equ((void *)(*(_QWORD *)(a1 + 104) + 4 * v8), (const void *)(*(_QWORD *)(a2 + 8) + 4 * a3), a4);
  v_equ(*(void **)(a1 + 104), *(const void **)(a1 + 128), v8);
  v_equ(*(void **)(a1 + 128), (const void *)(*(_QWORD *)(a1 + 104) + 4 * a4), v8);
  return zerflt(*(_QWORD *)(a1 + 104) + 4 * v8, *(float **)(a1 + 152), *(_QWORD *)(a2 + 8) + 4 * a3, v8, a4);
}

uint64_t MFVSyn__setDispersion(uint64_t a1, int a2)
{
  void *v3;
  int v4;
  void *v5;
  const void *v6;
  int v7;
  uint64_t result;
  int v9;

  v3 = &dispersion_22kHz;
  if (a2 == 22050)
  {
    v4 = 179;
  }
  else
  {
    v3 = &dispersion_16kHz;
    v4 = 129;
  }
  if (a2 == 11025)
    v5 = &dispersion_8kHz;
  else
    v5 = v3;
  if (a2 == 11025)
    v4 = 65;
  if (a2 == 8000)
    v6 = &dispersion_8kHz;
  else
    v6 = v5;
  if (a2 == 8000)
    v7 = 65;
  else
    v7 = v4;
  result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 144, v7);
  if ((result & 0x80000000) == 0)
  {
    v_equ(*(void **)(a1 + 152), v6, v7);
    v9 = *(_DWORD *)(a1 + 40);
    if (v9 <= v7)
      v9 = v7;
    result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 96, v9 + 5 * v7);
    if ((result & 0x80000000) == 0)
      return BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 120, v7);
  }
  return result;
}

void *MFVSyn__pickLowPassFilter(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  int v7;
  void **v8;
  int v9;
  void **v10;
  void *v11;
  void *result;
  float v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float *v24;
  uint64_t v25;
  float *v26;
  float v27;

  v7 = *(_DWORD *)(a1 + 24);
  v8 = (void **)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 16);
  v_zap(*(void **)(a2 + 8), *(_DWORD *)(a2 + 20));
  v11 = *(void **)(a3 + 8);
  v10 = (void **)(a3 + 8);
  result = v_zap(v11, *((_DWORD *)v10 + 3));
  v13 = ceilf(a4 / 250.0) * 250.0;
  if (v13 < 1000.0)
    goto LABEL_4;
  v14 = *(_DWORD *)(a1 + 168);
  if ((double)v14 * 0.5 + -1000.0 < v13)
  {
    v10 = v8;
LABEL_4:
    *((_DWORD *)*v10 + (v9 >> 1)) = 1065353216;
    return result;
  }
  v15 = v7 - 1;
  v16 = *(unsigned int *)(a1 + 24);
  v17 = *(_QWORD *)(a1 + 16);
  if ((int)v16 < 1)
  {
LABEL_10:
    LODWORD(v18) = 0;
  }
  else
  {
    v18 = 0;
    v19 = v13 / (float)v14;
    v20 = (float *)(v17 + 20);
    while (*v20 < v19)
    {
      ++v18;
      v20 += 10;
      if (v16 == v18)
        goto LABEL_10;
    }
  }
  v_equ(*v8, *(const void **)(v17 + 40 * v18), *(_DWORD *)(v17 + 40 * v18 + 16));
  v21 = *(unsigned int *)(a1 + 24);
  v22 = *(_QWORD *)(a1 + 16);
  if ((int)v21 >= 1)
  {
    v23 = 0;
    v24 = (float *)(v22 + 20);
    while (*v24 < (float)(0.5 - (float)(v13 / (float)*(int *)(a1 + 168))))
    {
      ++v23;
      v24 += 10;
      if (v21 == v23)
        goto LABEL_17;
    }
    v15 = v23;
  }
LABEL_17:
  result = v_equ(*v10, *(const void **)(v22 + 40 * v15), *(_DWORD *)(v22 + 40 * v15 + 16));
  v25 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 40 * v15 + 16);
  if ((int)v25 >= 1)
  {
    v26 = (float *)*v10;
    v27 = 1.0;
    do
    {
      *v26 = v27 * *v26;
      ++v26;
      if (v27 == 1.0)
        v27 = -1.0;
      else
        v27 = 1.0;
      --v25;
    }
    while (v25);
  }
  return result;
}

void MFVSyn__lowPassFilterCoeffGenerator(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  int v16;
  int v17;
  uint64_t v18;
  float v19;
  double v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  float v25;
  uint64_t v26;
  float v27;
  double v28;
  double v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  long double v34;

  v11 = (_QWORD *)(a2 + 8);
  v12 = *(unsigned int *)(a2 + 16);
  v13 = ((int)v12 >> 1);
  v_zap(*(void **)(a2 + 8), *(_DWORD *)(a2 + 20));
  v15 = *(void **)(a3 + 8);
  v14 = (_QWORD *)(a3 + 8);
  v_zap(v15, *((_DWORD *)v14 + 3));
  if (a4 <= 600.0)
    goto LABEL_17;
  v16 = *(_DWORD *)(a1 + 168);
  if (v16 >= 0)
    v17 = *(_DWORD *)(a1 + 168);
  else
    v17 = v16 + 1;
  if ((float)((v17 >> 1) - 600) <= a4)
  {
    v14 = v11;
LABEL_17:
    *(_DWORD *)(*v14 + 4 * (int)v13) = 1065353216;
    return;
  }
  if ((int)v12 >= 1)
  {
    v18 = 0;
    v19 = a4 / (float)v16;
    v20 = a5;
    v21 = (float)(v19 * 6.2832);
    v22 = *v11;
    do
    {
      v23 = ((int)v12 >> 1);
      v24 = v21 / 3.14159265 * v20;
      if (v13 != v18)
      {
        v24 = sin(v21 * (double)((int)v18 - (int)v13)) * (1.0 / ((double)((int)v18 - (int)v13) * 3.14159265) * v20);
        v23 = v18;
      }
      v25 = v24;
      *(float *)(v22 + 4 * v23) = v25;
      ++v18;
    }
    while (v12 != v18);
    v26 = 0;
    v27 = v19 * -6.28318531 + 3.14159265;
    v28 = a6;
    v29 = v27;
    v30 = (float)(v27 / 3.1416) * a6;
    v31 = *v14;
    do
    {
      v32 = ((int)v12 >> 1);
      v33 = v30;
      if (v13 != v26)
      {
        v34 = pow(-1.0, (double)(int)v26) * v28;
        v33 = v34 * (sin(v29 * (double)((int)v26 - (int)v13)) * (1.0 / (float)((float)(v26 - v13) * 3.1416)));
        v32 = v26;
      }
      *(float *)(v31 + 4 * v32) = v33;
      ++v26;
    }
    while (v12 != v26);
  }
}

void MFVSyn__fillExcPulse(uint64_t a1, uint64_t a2, int a3, int a4, float a5, float a6)
{
  int v11;
  double v12;
  float v13;
  float *v14;
  float v15;
  unint64_t *v16;
  float v17;
  uint64_t v18;
  double v19;
  float v20;
  float v21;
  double v23;
  double v24;
  float v25;
  unint64_t *v26;
  float *v27;
  float v28;
  double v29;
  float v30;
  float *v31;
  float v32;
  float *v33;
  uint64_t v34;
  float v35;
  float v36;

  v11 = *(unsigned __int8 *)(a1 + 72);
  if (*(_BYTE *)(a1 + 72))
  {
    if (v11 != 2)
    {
      if (v11 == 1)
      {
        vect_t__fillZero(a2);
        **(float **)(a2 + 8) = sqrtf(a5);
      }
      return;
    }
    v23 = a6;
    if (a6 > 1.0)
      v23 = 1.0;
    if (v23 >= 0.0)
      v24 = 1.0 - v23;
    else
      v24 = 1.0;
    vect_t__fillZero(a2);
    if (a4)
    {
      v25 = v24;
      if (v25 >= 0.1)
      {
        if (v25 > 0.8)
          v25 = 0.8;
      }
      else
      {
        v25 = 0.3;
      }
      v29 = sqrt(a5);
      v30 = v29;
      v31 = *(float **)(a2 + 8);
      *v31 = v30;
      v32 = v30 + 0.0;
      if (a3 >= 2)
      {
        v33 = v31 + 1;
        v34 = a3 - 1;
        do
        {
          v30 = v25 * v30;
          *v33++ = v30;
          v32 = v32 + v30;
          --v34;
        }
        while (v34);
      }
      v35 = v29 / v32;
      v_scale(v31, a3, v35);
      return;
    }
    v26 = (unint64_t *)(a1 + 88);
    v27 = *(float **)(a2 + 8);
    v28 = *(float *)(a1 + 44) * 1.25 + *(float *)(a1 + 44) * 1.25;
LABEL_21:
    rand_num(v26, v27, a3, v28);
    return;
  }
  vect_t__fillZero(a2);
  if (a6 <= 0.3)
  {
    v26 = (unint64_t *)(a1 + 88);
    v27 = *(float **)(a2 + 8);
    v28 = 2.25;
    goto LABEL_21;
  }
  v12 = sqrt(a5);
  v13 = v12;
  v14 = *(float **)(a2 + 8);
  *v14 = v13;
  v15 = v13 + 0.0;
  if (a3 >= 2)
  {
    v16 = (unint64_t *)(a1 + 88);
    v17 = fmin((float)(1.0 - a6) * 10.0, 1.0);
    v18 = 1;
    do
    {
      v36 = 0.0;
      rand_num(v16, &v36, 1, 2.0);
      v19 = v13 * 0.4;
      v20 = v19 * (v36 * 0.1 + 1.0);
      *(float *)(*(_QWORD *)(a2 + 8) + v18 * 4) = v20;
      rand_num(v16, &v36, 1, 2.0);
      v13 = v19 * (float)((float)(v17 * v36) + 1.0);
      v14 = *(float **)(a2 + 8);
      v15 = v15 + v14[v18++];
    }
    while (a3 != v18);
  }
  v21 = v12 / v15;
  v_scale(v14, a3, v21);
}

float *MFVSyn__filterExcitationWithShapingFilterHQ(uint64_t a1, signed int a2, int a3, uint64_t a4, float a5, float a6, float a7)
{
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  uint64_t v20;

  v13 = *(float *)(a1 + 552);
  if (v13 > 0.0)
  {
    v14 = *(float *)(a1 + 556);
    if (v14 > 0.0)
      v13 = (float)((float)(1.0 - a6) * v14) + (float)(a6 * v13);
  }
  if (*(_DWORD *)(a1 + 8))
  {
    MFVSyn__pickLowPassFilter(a1, a1 + 608, a1 + 632, v13);
  }
  else
  {
    v15 = (float)((float)(1.0 - a6) * *(float *)(a1 + 564)) + (float)(a6 * *(float *)(a1 + 560));
    v16 = (float)((float)(1.0 - a6) * *(float *)(a1 + 572)) + (float)(a6 * *(float *)(a1 + 568));
    if (v13 > 0.0)
    {
      v17 = (float)(int)(float)(v13 / BET3FLT__wave_t__convertFromTpToF0((float *)(a1 + 32), a5));
      v18 = BET3FLT__wave_t__convertFromTpToF0((float *)(a1 + 32), a5) * v17;
      v13 = v18 + (float)(BET3FLT__wave_t__convertFromTpToF0((float *)(a1 + 32), a5) * 0.5);
    }
    MFVSyn__lowPassFilterCoeffGenerator(a1, a1 + 608, a1 + 632, v13, v15, v16);
  }
  vect_t__mulByHanning(a1 + 608);
  vect_t__mulByHanning(a1 + 632);
  v_zap(*(void **)(a4 + 8), *(_DWORD *)(a4 + 20));
  v_zap(*(void **)(a1 + 464), *(_DWORD *)(a1 + 476));
  MFVSyn__fillExcPulse(a1, a4, a2, a3, a5, a7);
  v_equ((void *)(*(_QWORD *)(a1 + 464) + 4 * *(int *)(a1 + 172)), *(const void **)(a4 + 8), a2);
  v_equ(*(void **)(a1 + 464), *(const void **)(a1 + 664), *(_DWORD *)(a1 + 172));
  v_equ(*(void **)(a1 + 664), (const void *)(*(_QWORD *)(a1 + 464) + 4 * a2), *(_DWORD *)(a1 + 172));
  v19 = *(_QWORD *)(a1 + 464) + 4 * *(int *)(a1 + 172);
  zerflt(v19, *(float **)(a1 + 616), v19, *(_DWORD *)(a1 + 624), a2);
  v_equ(*(void **)(a4 + 8), (const void *)(*(_QWORD *)(a1 + 464) + 4 * *(int *)(a1 + 172)), a2);
  v_zap(*(void **)(a1 + 464), *(_DWORD *)(a1 + 476));
  rand_num((unint64_t *)(a1 + 88), (float *)(*(_QWORD *)(a1 + 464) + 4 * *(int *)(a1 + 172)), a2, *(float *)(a1 + 44) * 1.15);
  v_equ(*(void **)(a1 + 464), *(const void **)(a1 + 688), *(_DWORD *)(a1 + 172));
  v_equ(*(void **)(a1 + 688), (const void *)(*(_QWORD *)(a1 + 464) + 4 * a2), *(_DWORD *)(a1 + 172));
  v20 = *(_QWORD *)(a1 + 464) + 4 * *(int *)(a1 + 172);
  zerflt(v20, *(float **)(a1 + 640), v20, *(_DWORD *)(a1 + 648), a2);
  v_equ(*(void **)(a1 + 464), (const void *)(*(_QWORD *)(a1 + 464) + 4 * *(int *)(a1 + 172)), a2);
  v_add(*(float **)(a4 + 8), *(float **)(a1 + 464), a2);
  return v_scale(*(float **)(a4 + 8), a2, *(float *)(a1 + 56));
}

uint64_t BET3FLT__MFVSyn__mc2mlsa(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  float v4;
  float v5;
  float v6;
  BOOL v7;

  v3 = *(int *)(result + 200);
  v4 = *(float *)(result + 1624);
  *(_DWORD *)(a3 + 4 * v3) = *(_DWORD *)(a2 + 4 * v3);
  if ((int)v3 >= 1)
  {
    v3 = v3;
    v5 = -v4;
    do
    {
      v6 = *(float *)(a3 + 4 * v3);
      v7 = v3-- > 1;
      *(float *)(a3 + 4 * v3) = *(float *)(a2 + 4 * v3) + (float)(v5 * v6);
    }
    while (v7);
  }
  return result;
}

void MFVSyn__postFilter(uint64_t a1, float *a2, float *a3)
{
  int v3;
  double v7;
  uint64_t v8;
  float *v9;
  float v10;
  float v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  unint64_t v18;
  float v19;
  uint64_t v20;
  float *v21;
  float v22;
  float v23;
  double v24;
  float v25;
  float v26;
  float v27;

  v3 = *(_DWORD *)(a1 + 80);
  if (v3)
  {
    v7 = 1.0;
    if (v3 != 1)
    {
      v_equ(*(void **)(a1 + 264), a2, *(_DWORD *)(a1 + 200) + 1);
      MFVSyn__freqt__postFilter(a1);
      MFVSyn__c2ir__postFilter(a1);
      v8 = *(unsigned int *)(a1 + 400);
      if ((int)v8 < 1)
      {
        v7 = 0.0;
      }
      else
      {
        v9 = *(float **)(a1 + 312);
        v10 = 0.0;
        do
        {
          v11 = *v9++;
          v10 = v10 + (float)(v11 * v11);
          --v8;
        }
        while (v8);
        v7 = v10;
      }
    }
    a3[1] = a3[1] - (float)(*(float *)(a1 + 1632) * a2[2]);
    v12 = *(unsigned int *)(a1 + 200);
    if ((int)v12 > 1)
    {
      v13 = a3 + 2;
      v14 = v12 - 1;
      do
      {
        *v13 = *v13 * (float)(*(float *)(a1 + 1628) + 1.0);
        ++v13;
        --v14;
      }
      while (v14);
    }
    if (*(_DWORD *)(a1 + 80) >= 2u)
    {
      v15 = *(float *)(a1 + 1624);
      v16 = *(_QWORD *)(a1 + 264);
      v17 = a3[(int)v12];
      *(float *)(v16 + 4 * (int)v12) = v17;
      if ((int)v12 >= 1)
      {
        v18 = v12 + 1;
        do
        {
          v19 = a3[(v18 - 2)];
          *(float *)(v16 + 4 * (v18-- - 2)) = v19 + (float)(v15 * v17);
          v17 = v19;
        }
        while (v18 > 1);
      }
      MFVSyn__freqt__postFilter(a1);
      MFVSyn__c2ir__postFilter(a1);
      v20 = *(unsigned int *)(a1 + 400);
      if ((int)v20 < 1)
      {
        v24 = 0.0;
      }
      else
      {
        v21 = *(float **)(a1 + 312);
        v22 = 0.0;
        do
        {
          v23 = *v21++;
          v22 = v22 + (float)(v23 * v23);
          --v20;
        }
        while (v20);
        v24 = v22;
      }
      v25 = *a3;
      v26 = log(v7);
      v27 = log(v24);
      *a3 = v25 + (float)((float)(v26 - v27) * 0.5);
    }
  }
}

uint64_t MFVSyn__init__postFilter(_DWORD *a1)
{
  uint64_t result;
  unsigned int v3;
  int v4;

  result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), (uint64_t)(a1 + 94), a1[50] + 1);
  if ((result & 0x80000000) == 0)
  {
    v3 = a1[20];
    if (v3 >= 2)
    {
      if (v3 == 2)
        v4 = 32;
      else
        v4 = 64;
      a1[100] = v4;
      result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), (uint64_t)(a1 + 70), v4);
      if ((result & 0x80000000) == 0)
      {
        result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), (uint64_t)(a1 + 64), a1[50] + 1);
        if ((result & 0x80000000) == 0)
        {
          result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), (uint64_t)(a1 + 76), a1[100]);
          if ((result & 0x80000000) == 0)
          {
            result = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), (uint64_t)(a1 + 82), a1[100]);
            if ((result & 0x80000000) == 0)
              return BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), (uint64_t)(a1 + 88), a1[100]);
          }
        }
      }
    }
  }
  return result;
}

_QWORD *MFVSyn__deinit__postFilter(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) >= 2u)
  {
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 280));
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 256));
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 304));
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 328));
    BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 352));
  }
  return BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 376));
}

void BET3FLT__MFVSyn__mlsa_filter(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  float *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  uint64_t v23;
  float v24;
  float v25;
  float v26;
  float v27;
  BOOL v28;
  float v29;
  float *v30;
  float v31;
  uint64_t v32;
  float v33;
  uint64_t v34;
  float *v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  uint64_t v40;
  float *v41;
  float v42;
  float v43;
  _DWORD *v44;
  int v45;
  int *v46;
  int v47;
  float v48;
  float v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float *v54;
  float v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v61;
  uint64_t v63;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *(float **)(a1 + 184);
    v61 = *(float **)(a1 + 224);
    v6 = *(unsigned int *)(a1 + 1644);
    v7 = *(_QWORD *)(a1 + 1656);
    v8 = (int)v6 + 1;
    v9 = (float *)(v7 + 4 * v8);
    v57 = v8;
    LODWORD(v8) = 2 * v8;
    v10 = *(unsigned int *)(a1 + 200);
    v11 = v7 + 4 * (int)v8;
    v12 = a1 + 1688;
    v13 = (v10 + 1);
    v58 = a4;
    v14 = v7 + 4 * (int)v8 + 4 * v13;
    v15 = v7 + 4 * v10 + 4 * (int)v8;
    v56 = v13 - 2;
    do
    {
      v63 = v4;
      v16 = *(float *)(a2 + 4 * v4);
      v17 = exp(*v5);
      v18 = fminf(fmaxf(v16 * v17, -32768.0), 32767.0);
      if ((int)v6 <= 0)
      {
        *v9 = v18;
        v31 = 0.0;
        v29 = v18 + 0.0;
        v30 = (float *)(v11 + 4 * *(int *)(v12 + 4 * v57));
      }
      else
      {
        v19 = *(float *)(a1 + 1624);
        v20 = *(float *)(a1 + 1672);
        v21 = 0.0;
        v22 = v6;
        v23 = *(_QWORD *)(a1 + 1680);
        do
        {
          v24 = (float)(v19 * *(float *)(v7 + 4 * v22)) + (float)(v20 * v9[(v22 - 1)]);
          *(float *)(v7 + 4 * v22) = v24;
          v25 = v24 * v5[1];
          v9[v22] = v25;
          v26 = v25 * *(float *)(v23 + 4 * v22);
          v27 = -v26;
          if ((v22 & 1) != 0)
            v27 = v26;
          v18 = v18 + v27;
          v21 = v21 + v26;
          v28 = v22-- > 1;
        }
        while (v28);
        *v9 = v18;
        v29 = v21 + v18;
        v30 = (float *)(v11 + 4 * *(int *)(v12 + 4 * v57));
        v31 = 0.0;
        v32 = v6;
        do
        {
          v33 = v30[(v32 - 1)];
          v34 = *(int *)(v12 + 4 * v32);
          v35 = (float *)(v11 + 4 * v34);
          v36 = (float)(v19 * v35[1]) + (float)(v20 * v33);
          *v35 = v33;
          v35[1] = v36;
          v37 = 0.0;
          if ((int)v10 > 1)
          {
            v38 = v35[2];
            v39 = (float *)(v11 + 12 + 4 * v34);
            v40 = v56;
            v41 = v5 + 2;
            do
            {
              v42 = *v39;
              v36 = v38 + (float)(v19 * (float)(*v39 - v36));
              *(v39 - 1) = v36;
              v43 = *v41++;
              v37 = v37 + (float)(v36 * v43);
              ++v39;
              v38 = v42;
              --v40;
            }
            while (v40);
          }
          if ((int)v10 >= 1)
          {
            v44 = (_DWORD *)(v14 + 4 * v34);
            v45 = v10 + 2;
            v46 = (int *)(v15 + 4 * v34);
            do
            {
              v47 = *v46--;
              *v44-- = v47;
              --v45;
            }
            while (v45 > 2);
          }
          v30[v32] = v37;
          v48 = v37 * *(float *)(v23 + 4 * v32);
          v49 = -v48;
          if ((v32 & 1) != 0)
            v49 = v48;
          v29 = v29 + v49;
          v31 = v31 + v48;
          v28 = v32-- <= 1;
        }
        while (!v28);
      }
      *v30 = v29;
      *(float *)(a3 + 4 * v63) = fminf(fmaxf(v31 + v29, -32768.0), 32767.0);
      if (v61)
      {
        v50 = *(_DWORD *)(a1 + 84) - 1;
        *(_DWORD *)(a1 + 84) = v50;
        if (!v50)
        {
          v51 = *(unsigned int *)(a1 + 240);
          if ((v51 & 0x80000000) == 0)
          {
            v52 = v51 + 1;
            v53 = v5;
            v54 = v61;
            do
            {
              v55 = *v54++;
              *v53 = *v53 + v55;
              ++v53;
              --v52;
            }
            while (v52);
          }
          *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 208);
        }
      }
      v4 = v63 + 1;
    }
    while (v63 + 1 != v58);
  }
}

uint64_t BET3FLT__MFVSyn__mlsa_filter_init(uint64_t a1, int a2, float a3, float a4)
{
  int v4;
  uint64_t Vect;
  float v7;
  float v8;
  int v9;
  int v10;
  int v11;
  int *v12;
  int v13;
  int v14;

  *(float *)(a1 + 1624) = a3;
  *(float *)(a1 + 1628) = a4;
  v4 = *(_DWORD *)(a1 + 200);
  if (v4 < 4)
    return 0;
  *(_DWORD *)(a1 + 1644) = a2;
  Vect = BET3FLT__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 1648, (v4 + 5) * a2 + 3);
  if ((Vect & 0x80000000) == 0)
  {
    v_zap(*(void **)(a1 + 1656), *(_DWORD *)(a1 + 1668));
    v7 = *(float *)(a1 + 1624);
    *(float *)(a1 + 1636) = -v7;
    *(float *)(a1 + 1632) = v7 * *(float *)(a1 + 1628);
    v8 = 1.0 - (float)(v7 * v7);
    *(float *)(a1 + 1672) = v8;
    *(float *)(a1 + 1676) = v8;
    v9 = *(_DWORD *)(a1 + 1644);
    *(_QWORD *)(a1 + 1680) = (char *)&g_pade + 24 * v9;
    if (v9 >= -1)
    {
      v10 = *(_DWORD *)(a1 + 200);
      v11 = v9 + 2;
      v12 = (int *)(a1 + 4 * (v9 + 1) + 1688);
      v13 = v9 * (v10 + 2);
      v14 = -2 - v10;
      do
      {
        *v12-- = v13;
        --v11;
        v13 += v14;
      }
      while (v11 > 0);
    }
  }
  return Vect;
}

_QWORD *BET3FLT__MFVSyn__mlsa_filter_deinit(uint64_t a1)
{
  return BET3FLT__vect_t__deleteVect((_QWORD *)(a1 + 1648));
}

void *MFVSyn__freqt__postFilter(uint64_t a1)
{
  float v2;
  float v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int v8;
  float *v9;
  float *v10;
  int v11;
  int v12;
  uint64_t v13;
  float *v14;
  float *v15;

  v2 = *(float *)(a1 + 1636);
  v3 = *(float *)(a1 + 1676);
  v4 = *(_DWORD *)(a1 + 200);
  v5 = *(unsigned int *)(a1 + 400);
  v6 = *(_QWORD *)(a1 + 264);
  v7 = *(void **)(a1 + 288);
  if ((int)v5 >= 1)
    bzero(*(void **)(a1 + 360), 4 * v5);
  if (v4 < 0)
  {
    v9 = *(float **)(a1 + 360);
  }
  else
  {
    v8 = -v4;
    v9 = *(float **)(a1 + 360);
    v10 = *(float **)(a1 + 336);
    do
    {
      v11 = v8;
      *v10 = *v9;
      v12 = *((_DWORD *)v9 + 1);
      *v9 = *(float *)(v6 + 4 * -v8) + (float)(v2 * *v9);
      *((_DWORD *)v10 + 1) = v12;
      v9[1] = (float)(v2 * v9[1]) + (float)(v3 * *v10);
      if ((int)v5 >= 3)
      {
        v13 = v5 - 2;
        v14 = v9 + 2;
        v15 = v10 + 2;
        do
        {
          *v15 = *v14;
          *v14 = *(v15 - 1) + (float)(v2 * (float)(*v14 - *(v14 - 1)));
          ++v14;
          ++v15;
          --v13;
        }
        while (v13);
      }
      v8 = v11 + 1;
    }
    while (v11);
  }
  return v_equ(v7, v9, v5);
}

float MFVSyn__c2ir__postFilter(uint64_t a1)
{
  uint64_t v1;
  float *v2;
  float *v3;
  float result;
  uint64_t v5;
  float *v6;
  uint64_t v7;
  float v8;
  float *v9;
  float v10;

  v1 = *(unsigned int *)(a1 + 400);
  v2 = *(float **)(a1 + 288);
  v3 = *(float **)(a1 + 312);
  result = exp(*v2);
  *v3 = result;
  if ((int)v1 >= 2)
  {
    v5 = 1;
    v6 = v3;
    do
    {
      v7 = 0;
      v8 = 0.0;
      v9 = v6;
      do
      {
        v10 = *v9--;
        v8 = v8 + (float)((float)(v2[v7 + 1] * (float)(v7 + 1)) * v10);
        ++v7;
      }
      while (v5 != v7);
      result = v8 * g_oneOver[v5];
      v3[v5++] = result;
      ++v6;
    }
    while (v5 != v1);
  }
  return result;
}

float v_equ_fistp(_WORD *a1, float *a2, int a3)
{
  uint64_t v3;
  float v5;
  float result;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      v5 = *a2++;
      result = v5;
      *a1++ = (int)v5;
      --v3;
    }
    while (v3);
  }
  return result;
}

float v_equ_fild(float *a1, __int16 *a2, int a3)
{
  uint64_t v3;
  int v5;
  float result;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      v5 = *a2++;
      result = (float)v5;
      *a1++ = (float)v5;
      --v3;
    }
    while (v3);
  }
  return result;
}

float v_add(float *a1, float *a2, int a3)
{
  uint64_t v3;
  float v5;
  float result;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      v5 = *a2++;
      result = v5 + *a1;
      *a1++ = result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *v_scale_and_add(float *result, float *a2, int a3, float a4)
{
  uint64_t v4;
  float *v5;
  float v6;

  if (a3 >= 1)
  {
    v4 = a3;
    v5 = result;
    do
    {
      v6 = *a2++;
      *v5 = *v5 + (float)(a4 * v6);
      ++v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

void *v_equ(void *a1, const void *a2, unsigned int a3)
{
  cstdlib_memcpy(a1, a2, 4 * a3);
  return a1;
}

_DWORD *v_equ_circ(_DWORD *result, uint64_t a2, unsigned int *a3, int a4, int a5)
{
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;

  v5 = *a3;
  if (a5 >= 1)
  {
    v6 = a5;
    v7 = result;
    do
    {
      v5 = (v5 + 1) & a4;
      *v7++ = *(_DWORD *)(a2 + 4 * v5);
      --v6;
    }
    while (v6);
  }
  *a3 = v5;
  return result;
}

_DWORD *v_equ_int(_DWORD *result, int *a2, int a3)
{
  uint64_t v3;
  _DWORD *v4;
  int v5;

  if (a3 >= 1)
  {
    v3 = a3;
    v4 = result;
    do
    {
      v5 = *a2++;
      *v4++ = v5;
      --v3;
    }
    while (v3);
  }
  return result;
}

float v_inner(float *a1, float *a2, int a3)
{
  uint64_t v3;
  float result;
  float v5;
  float v6;
  float v7;

  if (a3 < 1)
    return 0.0;
  v3 = a3;
  result = 0.0;
  do
  {
    v5 = *a1++;
    v6 = v5;
    v7 = *a2++;
    result = result + (float)(v6 * v7);
    --v3;
  }
  while (v3);
  return result;
}

float v_magsq(float *a1, int a2)
{
  uint64_t v2;
  float result;
  float v4;

  if (a2 < 1)
    return 0.0;
  v2 = a2;
  result = 0.0;
  do
  {
    v4 = *a1++;
    result = result + (float)(v4 * v4);
    --v2;
  }
  while (v2);
  return result;
}

float v_sum(float *a1, int a2)
{
  uint64_t v2;
  float result;
  float v4;

  if (a2 < 1)
    return 0.0;
  v2 = a2;
  result = 0.0;
  do
  {
    v4 = *a1++;
    result = result + v4;
    --v2;
  }
  while (v2);
  return result;
}

float *v_scale(float *result, int a2, float a3)
{
  uint64_t v4;
  float *v5;

  if (a3 != 1.0 && a2 >= 1)
  {
    v4 = a2;
    v5 = result;
    do
    {
      *v5 = *v5 * a3;
      ++v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

float *v_set(float *result, int a2, float a3)
{
  uint64_t v3;
  float *v4;

  if (a2 >= 1)
  {
    v3 = a2;
    v4 = result;
    do
    {
      *v4++ = a3;
      --v3;
    }
    while (v3);
  }
  return result;
}

float v_sub(float *a1, float *a2, int a3)
{
  uint64_t v3;
  float v5;
  float result;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      v5 = *a2++;
      result = *a1 - v5;
      *a1++ = result;
      --v3;
    }
    while (v3);
  }
  return result;
}

void *v_zap(void *a1, int a2)
{
  if (a2 >= 1)
    bzero(a1, 4 * a2);
  return a1;
}

void *v_zap_int(void *a1, int a2)
{
  if (a2 >= 1)
    bzero(a1, 4 * a2);
  return a1;
}

float *v_fill(float *result, int a2, float a3)
{
  uint64_t v3;

  if (a2 >= 1)
  {
    v3 = a2;
    do
    {
      *result++ = a3;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *interp_array(float *result, float *a2, float *a3, int a4, float a5)
{
  uint64_t v5;
  float v6;
  float v7;
  float v8;

  if (a4 >= 1)
  {
    v5 = a4;
    do
    {
      v6 = *a2++;
      v7 = v6;
      v8 = *result++;
      *a3++ = (float)((float)(1.0 - a5) * v8) + (float)(a5 * v7);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t zerflt(uint64_t result, float *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  float v7;
  uint64_t v8;
  float *v9;
  float *v10;
  float v11;
  float v12;
  float v13;

  if (a5 >= 1)
  {
    v5 = a5;
    v6 = result + 4 * a5 - 4;
    do
    {
      v7 = 0.0;
      if (a4 >= 1)
      {
        v8 = a4;
        v9 = a2;
        v10 = (float *)v6;
        do
        {
          v11 = *v10--;
          v12 = v11;
          v13 = *v9++;
          v7 = v7 + (float)(v12 * v13);
          --v8;
        }
        while (v8);
      }
      *(float *)(a3 + 4 * (v5 - 1)) = v7;
      v6 -= 4;
    }
    while (v5-- > 1);
  }
  return result;
}

float wave_t__convertFromTpToMsec(float *a1, float a2)
{
  return (float)(a2 * 1000.0) / *a1;
}

float BET3FLT__wave_t__convertFromF0ToTp(float *a1, float a2)
{
  if (a2 == 0.0)
    return 0.0;
  else
    return (float)(1.0 / a2) * *a1;
}

float BET3FLT__wave_t__convertFromTpToF0(float *a1, float a2)
{
  return (float)(1.0 / a2) * *a1;
}

float BET3FLT__wave_t__convertFromMsecToTp(float *a1, float a2)
{
  return (float)(a2 * 0.001) * *a1;
}

float BET3FLT__wave_t__sampleRateHz(uint64_t a1)
{
  return *(float *)a1;
}

float *BET3FLT__wave_t__setSampleRateHz(float *result, float a2)
{
  if (result)
  {
    if (a2 > 0.0)
      *result = a2;
  }
  return result;
}

float wave_t__convertFromTpToMsec__SR(float a1, float a2)
{
  return a2 * 1000.0 / a1;
}

float wave_t__convertFromF0ToTp__SR(float a1, float a2)
{
  if (a2 == 0.0)
    return 0.0;
  else
    return 1.0 / a2 * a1;
}

float wave_t__convertFromTpToF0__SR(float a1, float a2)
{
  return 1.0 / a2 * a1;
}

float wave_t__convertFromMsecToTp__SR(float a1, float a2)
{
  return (float)(a2 * 0.001) * a1;
}

uint64_t BET3FLT__MFVSyn__loadExcTable(_QWORD *a1, char *a2)
{
  int *v4;
  _WORD *v5;
  _WORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  char *v28;
  float v29;
  double v31;
  double v32[300];
  char __dst[49];
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v31 = 0.0;
  cstdlib_memcpy(__dst, a2, 0x30uLL);
  v4 = (int *)(a1 + 99);
  cstdlib_memcpy(a1 + 99, a2 + 48, 4uLL);
  v5 = (_WORD *)a1 + 398;
  cstdlib_memcpy((char *)a1 + 796, a2 + 52, 2uLL);
  cstdlib_memcpy((char *)a1 + 798, a2 + 54, 2uLL);
  v6 = a1 + 100;
  cstdlib_memcpy(a1 + 100, a2 + 56, 2uLL);
  cstdlib_memcpy((char *)a1 + 802, a2 + 58, 2uLL);
  cstdlib_memcpy((char *)a1 + 804, a2 + 60, 2uLL);
  cstdlib_memcpy((char *)a1 + 806, a2 + 62, 2uLL);
  v7 = heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * (*((unsigned __int16 *)a1 + 400) + *((unsigned __int16 *)a1 + 398)) * *((_DWORD *)a1 + 198));
  a1[101] = v7;
  v8 = *((unsigned int *)a1 + 198);
  if ((int)v8 > 1)
  {
    v9 = *((unsigned __int16 *)a1 + 398);
    v10 = a1 + 104;
    v11 = v8 - 1;
    v12 = v9;
    do
    {
      *v10 = v7 + 4 * v12;
      v10 += 3;
      v12 += v9;
      --v11;
    }
    while (v11);
  }
  if ((int)v8 >= 1)
  {
    v13 = 0;
    v14 = a2 + 64;
    v15 = a1 + 101;
    v16 = &a1[3 * (v8 - 1) + 101];
    v17 = *((unsigned __int16 *)a1 + 400);
    v18 = *((unsigned __int16 *)a1 + 398);
    v19 = a1 + 102;
    do
    {
      *v19 = *v16 + 4 * v13 + 4 * v18;
      v19 += 3;
      v13 += v17;
      --v8;
    }
    while (v8);
    v20 = 0;
    do
    {
      cstdlib_memcpy(v32, v14, 8 * (unsigned __int16)*v5);
      v21 = (unsigned __int16)*v5;
      if (*v5)
      {
        v22 = 0;
        do
        {
          v23 = v32[v22];
          *(float *)(v15[3 * v20] + 4 * v22++) = v23;
        }
        while (v21 != v22);
      }
      v24 = &v14[8 * v21];
      cstdlib_memcpy(v32, v24, 8 * (unsigned __int16)*v6);
      v25 = (unsigned __int16)*v6;
      if (*v6)
      {
        v26 = 0;
        do
        {
          v27 = v32[v26];
          *(float *)(v15[3 * v20 + 1] + 4 * v26++) = v27;
        }
        while (v25 != v26);
      }
      v28 = &v24[8 * v25];
      cstdlib_memcpy(&v31, v28, 8uLL);
      v14 = v28 + 8;
      v29 = v31;
      *(float *)&v15[3 * v20++ + 2] = v29;
    }
    while (v20 < *v4);
  }
  return 0;
}

_QWORD *BET3FLT__MFVSyn__releaseExcTable(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = result[101];
  if (v1)
  {
    v2 = result;
    result = heap_Free(*(_QWORD **)(*result + 8), v1);
    v2[101] = 0;
  }
  return result;
}

uint64_t BET3FXD__InitTreeSet(int a1, void *__b)
{
  cstdlib_memset(__b, 0, 0xD0uLL);
  return 0;
}

void *BET3FXD__DeInitTreeSet(void *result, char *__b)
{
  uint64_t v3;
  uint64_t i;
  uint64_t v5;

  if (__b)
  {
    v3 = (uint64_t)result;
    for (i = 104; i != 184; i += 8)
    {
      v5 = *(_QWORD *)&__b[i];
      if (v5)
        heap_Free(*(_QWORD **)(v3 + 8), v5);
    }
    return cstdlib_memset(__b, 0, 0xD0uLL);
  }
  return result;
}

uint64_t BET3FXD__LoadTreesFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  _WORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  unsigned __int16 v30;

  v8 = a1;
  v30 = 0;
  v9 = *a4;
  if (a4[4] - v9 >= 8 && *(_BYTE *)(*((_QWORD *)a4 + 1) + v9) == 48)
  {
    *a4 = v9 + 2;
    v12 = a3;
    v13 = (_WORD *)(a2 + 2 * a3 + 184);
    if (BET3FXD__xfread_BET3(v13, 2u, 1, a4) == 1
      && BET3FXD__xfread_BET3(&v30, 2u, 1, a4) == 1
      && BET3FXD__xfread_BET3((void *)(a2 + 2 * v12), 2u, 1, a4) == 1)
    {
      v14 = BET3FXD__xfread2ptr_BET3((_QWORD *)(a2 + 8 * v12 + 24), 1u, v30, a4);
      if (v14 == v30)
      {
        if ((*a4 & 1) != 0)
          ++*a4;
        v15 = heap_Calloc(*(_QWORD **)(v8 + 8), 16, (unsigned __int16)*v13);
        v21 = a2 + 8 * v12;
        *(_QWORD *)(v21 + 104) = v15;
        v22 = (uint64_t *)(v21 + 104);
        if (!v15)
        {
          BET3FXD__log_select_Error(v8, 55000, (uint64_t)"LoadTreesFile : out of memory for type %s\n", v16, v17, v18, v19, v20);
          return 2229280778;
        }
        if (!*v13)
          return 0;
        v23 = 0;
        v24 = 0;
        while (BET3FXD__xfread_BET3((void *)(v15 + v23), 2u, 1, a4) == 1)
        {
          if (BET3FXD__xfread_BET3((void *)(*v22 + v23 + 2), 2u, 1, a4) != 1)
            break;
          v25 = BET3FXD__xfread2ptr_BET3((_QWORD *)(*v22 + v23 + 8), 2u, 3 * *(unsigned __int16 *)(*v22 + v23 + 2), a4);
          v15 = *v22;
          if (v25 != 3 * *(unsigned __int16 *)(*v22 + v23 + 2))
            break;
          v26 = 0;
          ++v24;
          v23 += 16;
          if (v24 >= (unsigned __int16)*v13)
            return v26;
        }
        v26 = 2229280772;
        v27 = "LoadTreesFile : corrupt tree nodes for type %s, state %u\n";
        a1 = v8;
        v28 = 55015;
      }
      else
      {
        v26 = 2229280772;
        v27 = "LoadTreesFile : corrupt tree questions for type %s\n";
        a1 = v8;
        v28 = 55013;
      }
    }
    else
    {
      v26 = 2229280772;
      v27 = "LoadTreesFile : corrupt tree header for type %s\n";
      a1 = v8;
      v28 = 55012;
    }
  }
  else
  {
    v26 = 2229280772;
    v27 = "LoadTreesFile : invalid tree data version for type %s\n";
    v28 = 55011;
  }
  BET3FXD__log_select_Error(a1, v28, (uint64_t)v27, (uint64_t)a4, a5, a6, a7, a8);
  return v26;
}

uint64_t BET3FXD__TreeSearch(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  unsigned __int8 v16;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;

  LOWORD(v5) = 0;
  v6 = a3 + 8 * a4;
  v7 = *(_QWORD *)(v6 + 24);
  v8 = *(_QWORD *)(*(_QWORD *)(v6 + 104) + 16 * a5 + 8);
  v9 = a2 + 2;
  v10 = a2 + 1;
  while (2)
  {
    v11 = -(uint64_t)(__int16)v5;
    v12 = (unsigned __int16 *)(v8 + 6 * (int)v11);
    v13 = (unsigned __int8 *)(v7 + *v12);
    v14 = *v13;
    v15 = v13[1];
    v5 = v12[1];
    switch(*v13)
    {
      case 0xFCu:
        if (a2 < 2)
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + (a2 - 2));
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFDu:
        if (a2 < 1)
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + (a2 - 1));
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFEu:
        if ((int)v10 >= *(__int16 *)(a1 + 10))
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v10);
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFFu:
        if ((int)v9 >= *(__int16 *)(a1 + 10))
        {
LABEL_20:
          v16 = -1;
          if (v13[1])
            goto LABEL_24;
        }
        else
        {
          v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v9);
          if (v13[1])
            goto LABEL_24;
        }
        goto LABEL_39;
      default:
        if ((_DWORD)v14 == 3)
        {
          v17 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 1784) + 2 * a2);
          v18 = v17 > 0x19;
          v16 = 10 * v17;
          if (v18)
            v16 = -1;
          if (!v13[1])
            goto LABEL_39;
        }
        else
        {
          v19 = *(_QWORD *)(a1 + 8 * v14 + 16);
          if (!v19)
            goto LABEL_39;
          v16 = *(_BYTE *)(v19 + a2);
          if (!v13[1])
            goto LABEL_39;
        }
LABEL_24:
        v20 = v13 + 2;
        if (v15 == 255)
        {
          if (*v20 <= v16 && v20[1] >= v16)
            goto LABEL_30;
        }
        else
        {
          v21 = v15 - 1;
          if (v21)
          {
            v22 = 0;
            while (1)
            {
              v23 = v21 + v22;
              if (v21 + v22 < 0 != __OFADD__(v21, v22))
                ++v23;
              v24 = v23 >> 1;
              v25 = v20[v24];
              if (v25 == v16)
                break;
              if (v16 < v25)
                v21 = v24 - 1;
              else
                v22 = v24 + 1;
              if (v22 > v21)
                goto LABEL_39;
            }
LABEL_30:
            v5 = *(unsigned __int16 *)(v8 + 6 * (int)v11 + 4);
            goto LABEL_39;
          }
          if (*v20 == v16)
            goto LABEL_30;
        }
LABEL_39:
        if ((v5 & 0x8000) != 0)
          continue;
        return v5;
    }
  }
}

uint64_t BET3FXD__select_bet3_FeatureExtractObjOpen(_WORD *a1, int a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t inited;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v15;
  uint64_t v16;

  v16 = 0;
  *a5 = 0;
  inited = InitRsrcFunction(a1, a2, &v16);
  if ((inited & 0x80000000) == 0)
  {
    v9 = (_QWORD *)heap_Calloc(*(_QWORD **)(v16 + 8), 1, 24);
    if (v9)
    {
      *v9 = v16;
      v9[1] = a3;
      v9[2] = a4;
      *a5 = v9;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v10, v11, v12, v13, v15);
      return 2229280778;
    }
  }
  return inited;
}

uint64_t BET3FXD__select_bet3_FeatureExtractObjClose(uint64_t a1)
{
  if (a1)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), a1);
  return 0;
}

uint64_t BET3FXD__select_bet3_FeatureExtractProcessStart(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *__b, _DWORD *a6)
{
  char *__s1;

  __s1 = 0;
  cstdlib_memset(__b, 0, 0xE48uLL);
  *__b = a2;
  if ((paramc_ParamGetStr(*(_QWORD *)(*a1 + 40), (uint64_t)"voicemodel", &__s1) & 0x80000000) == 0
    && !cstdlib_strcmp(__s1, "bet3"))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1[2] + 272))(a3, a4, 128, 3, 0, 0);
  }
  return usextract_ProcessStart(*a1, (uint64_t)"SELECT_BET3", a1[2], a3, a4, (uint64_t)__b, a6);
}

uint64_t BET3FXD__select_bet3_FeatureExtractProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, uint64_t a10, uint64_t *a11, _DWORD *a12)
{
  uint64_t v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int GenericFeatureLayers;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  const char **v58;
  size_t v59;
  unsigned int Index;
  unsigned int v61;
  uint64_t v62;
  const char *v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t j;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unsigned int v80;
  unint64_t v81;
  uint64_t v82;
  _OWORD *v83;
  _OWORD *v84;
  __int128 v85;
  _DWORD *v86;
  _OWORD *v87;
  _OWORD *v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t result;
  unsigned int v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  uint64_t v107;
  uint64_t v108;
  char v109;
  char v110;
  unsigned int v111[4];
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  v15 = *a1;
  if (a11)
    v16 = a12 == 0;
  else
    v16 = 1;
  v17 = !v16;
  if (!v16)
  {
    *a11 = 0;
    *a12 = 0;
  }
  v18 = 0;
  v19 = 0;
  v20 = *(__int16 *)(a10 + 10);
  do
  {
    if (*(_BYTE *)(*(_QWORD *)a10 + 2748 + v18) == 1)
      ++v19;
    ++v18;
  }
  while (v18 != 218);
  v21 = heap_Calloc(*(_QWORD **)(v15 + 8), (v19 * v20), 1);
  if (!v21)
    goto LABEL_119;
  v26 = v21;
  v105 = v17;
  v107 = a4;
  v108 = a3;
  for (i = 0; i != 218; ++i)
  {
    v28 = *(_QWORD *)a10;
    v29 = *(unsigned __int8 *)(*(_QWORD *)a10 + i + 2748);
    if (*(_BYTE *)(*(_QWORD *)a10 + i + 2748))
    {
      if (v29 == 2)
      {
        v30 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 2);
        *(_QWORD *)(a10 + 8 * i + 1760) = v30;
        if (!v30)
          goto LABEL_43;
      }
      else if (v29 == 1)
      {
        *(_QWORD *)(a10 + 8 * i + 16) = v26;
        v26 += v20;
      }
      else
      {
        switch((int)i)
        {
          case '.':
            v31 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 9);
            *(_QWORD *)(a10 + 3560) = v31;
            if (!v31)
              goto LABEL_43;
            continue;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_28;
          case '3':
            v33 = *(unsigned __int16 *)(v28 + 2966);
            if (v33)
            {
              v34 = heap_Calloc(*(_QWORD **)(v15 + 8), (v33 * v20), 4);
              *(_QWORD *)(a10 + 3568) = v34;
              if (!v34)
                goto LABEL_43;
            }
            continue;
          case '4':
            v35 = *(unsigned __int16 *)(v28 + 2966);
            if (v35)
            {
              v36 = heap_Calloc(*(_QWORD **)(v15 + 8), (v35 * v20), 4);
              *(_QWORD *)(a10 + 3576) = v36;
              if (!v36)
                goto LABEL_43;
            }
            continue;
          case '5':
            v37 = *(unsigned __int16 *)(v28 + 3360);
            if (v37)
            {
              v38 = heap_Calloc(*(_QWORD **)(v15 + 8), (v37 * v20), 4);
              *(_QWORD *)(a10 + 3584) = v38;
              if (!v38)
                goto LABEL_43;
            }
            continue;
          case '6':
            v39 = *(unsigned __int16 *)(v28 + 3360);
            if (v39)
            {
              v40 = heap_Calloc(*(_QWORD **)(v15 + 8), (v39 * v20), 4);
              *(_QWORD *)(a10 + 3592) = v40;
              if (!v40)
                goto LABEL_43;
            }
            continue;
          case '8':
            v41 = *(unsigned __int16 *)(v28 + 2966);
            if (v41)
            {
              v42 = heap_Calloc(*(_QWORD **)(v15 + 8), (v41 * v20), 1);
              *(_QWORD *)(a10 + 3600) = v42;
              if (!v42)
                goto LABEL_43;
            }
            continue;
          default:
            if ((_DWORD)i == 24)
            {
              v32 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 8);
              *(_QWORD *)(a10 + 3552) = v32;
              if (!v32)
              {
LABEL_43:
                v43 = -2065686518;
                log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v22, v23, v24, v25, v101);
                goto LABEL_44;
              }
            }
            else
            {
LABEL_28:
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"SELECT_BET3", 55007, (uint64_t)"%s%u", v22, v23, v24, v25, "feature");
            }
            break;
        }
      }
    }
  }
  v44 = *(unsigned __int16 *)(*(_QWORD *)a10 + 3578);
  if (v44 >= 4)
  {
    log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, (uint64_t)"Invalid number of states per phoneme", v22, v23, v24, v25, "%s%u");
    v43 = -2065686513;
    goto LABEL_122;
  }
  v45 = (void *)heap_Calloc(*(_QWORD **)(v15 + 8), v44 * v20, 4);
  *(_QWORD *)(a10 + 3608) = v45;
  if (!v45)
  {
    v43 = -2065686518;
    log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v46, v47, v48, v49, v101);
LABEL_122:
    if (!a12)
      goto LABEL_127;
    goto LABEL_123;
  }
  if (*(unsigned __int16 *)(*(_QWORD *)a10 + 3578) * (_DWORD)v20)
    memset(v45, 255, 4 * *(unsigned __int16 *)(*(_QWORD *)a10 + 3578) * v20);
  GenericFeatureLayers = usextract_allocateGenericFeatureLayers(*a1, (uint64_t)"SELECT_BET3", (_QWORD *)a10, v20);
  if (GenericFeatureLayers < 0)
  {
    v43 = GenericFeatureLayers;
    if (!a12)
      goto LABEL_127;
    goto LABEL_123;
  }
  v43 = usextract_Process(*a1, (uint64_t)"SELECT_BET3", a1[2], a3, a4, a10, v51, v52);
  if (v43 < 0)
    goto LABEL_122;
  if (*(_QWORD *)(a10 + 3504))
  {
    v53 = **(const char ***)(*(_QWORD *)a10 + 3336);
    if (v53)
    {
      v54 = 0;
      v55 = 1;
      do
      {
        v56 = cstdlib_strncmp(v53, "INNO_", 5uLL);
        v57 = *(_QWORD *)a10;
        if (v56)
        {
          v58 = *(const char ***)(*(_QWORD *)(v57 + 3344) + 8 * v54);
          v59 = cstdlib_strlen("FEATIDX");
          Index = usextract_getIndex(v58, "FEATIDX", (unint64_t)&aFeatidx[v59]);
          if (Index == -1)
          {
            if (cstdlib_strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v54), "POS"))
            {
              if (!cstdlib_strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v54), "PHR"))
                *(_QWORD *)(a10 + 512) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
            }
            else
            {
              *(_QWORD *)(a10 + 504) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
            }
          }
          else
          {
            *(_QWORD *)(a10
                      + 8 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a10 + 3352) + 8 * v54) + Index)
                      + 16) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
          }
        }
        else
        {
          v61 = cstdlib_atoi((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v57 + 3336) + 8 * v54) + 5)) + 79;
          if (v61 <= 0x5E)
            *(_QWORD *)(a10 + 8 * v61 + 16) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
        }
        v54 = v55;
        v53 = *(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v55++);
      }
      while (v53);
    }
  }
  v102 = *(__int16 *)(a10 + 10);
  v104 = v102 & ~(v102 >> 31);
  if (BET3FXD__log_select_GetLogLevel(*(_QWORD *)(v15 + 32)) >= 6)
  {
    LH_itoa(0x4Eu, (char *)v111, 0xAu);
    v62 = 0;
    v103 = v43;
    do
    {
      v63 = "application/x-realspeak-usplosives;version=4.0";
      switch((int)v62)
      {
        case 2:
          v110 = 5;
          v109 = 0;
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            (uint64_t)&v110,
            1u,
            0);
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            *(_QWORD *)(a10 + 8 * v62 + 16),
            v104,
            0);
          v43 = v103;
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            (uint64_t)&v109,
            1u,
            0);
          break;
        case 3:
          v63 = "application/x-realspeak-usdurs;version=4.0";
          goto LABEL_72;
        case 4:
          goto LABEL_72;
        case 5:
          v63 = "application/x-realspeak-usmarkers-u16;version=4.0";
LABEL_72:
          v64 = *(unsigned __int8 *)(*(_QWORD *)a10 + v62 + 2748);
          if (v64 == 2)
          {
            log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)v63, *(_QWORD *)(a10 + 8 * v62 + 1760), 2 * v104, 0);
          }
          else if (v64 == 1)
          {
            log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)v63, *(_QWORD *)(a10 + 8 * v62 + 16), v104, 0);
          }
          break;
        default:
          break;
      }
      ++v62;
    }
    while (v62 != 218);
  }
  v65 = *(unsigned int *)(a10 + 3520);
  if ((_DWORD)v65)
  {
    v66 = 0;
    for (j = 0; j < v65; ++j)
    {
      if (*(_DWORD *)(*(_QWORD *)(a10 + 3512) + v66) == 25)
      {
        v111[0] = 0;
        paramc_ParamGetUInt(*(_QWORD *)(v15 + 40), (uint64_t)"finalsentencefound", v111);
        v68 = *(_DWORD *)(*(_QWORD *)(a10 + 3512) + v66 + 24);
        *a9 = v68;
        v43 = paramc_ParamSetInt(*(_QWORD *)(v15 + 40), (uint64_t)"waitfactor", v68);
        if (v43 < 0)
        {
          log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%d%s%x", v69, v70, v71, v72, "parameter");
          goto LABEL_44;
        }
        v65 = *(unsigned int *)(a10 + 3520);
      }
      v66 += 32;
    }
  }
  featextract_adjustSilAudioOrder(a10);
  a4 = v107;
  a3 = v108;
  if (v105)
  {
    v73 = *(_DWORD *)(a10 + 3520);
    v74 = v73 + v104;
    *a12 = v74;
    if (v73 + v104)
    {
      v75 = heap_Calloc(*(_QWORD **)(v15 + 8), v74, 32);
      *a11 = v75;
      if (v75)
      {
        v76 = (void *)heap_Calloc(*(_QWORD **)(v15 + 8), *(__int16 *)(a10 + 10), 2);
        if (v76)
        {
          v77 = (uint64_t)v76;
          cstdlib_memcpy(v76, *(const void **)(a10 + 1800), 2 * *(__int16 *)(a10 + 10));
          if (*a12)
          {
            v78 = 0;
            v79 = 0;
            v80 = 0;
            v81 = 0;
            while (v81 < *(unsigned int *)(a10 + 3520))
            {
              if (v80 >= v104)
              {
                v87 = (_OWORD *)(*a11 + v78);
                v88 = (_OWORD *)(*(_QWORD *)(a10 + 3512) + 32 * v81);
                v89 = v88[1];
                *v87 = *v88;
                v87[1] = v89;
                ++v81;
                goto LABEL_96;
              }
              v82 = v80;
              if (!*(_WORD *)(v77 + 2 * v80))
                goto LABEL_94;
              v83 = (_OWORD *)(*a11 + v78);
              v84 = (_OWORD *)(*(_QWORD *)(a10 + 3512) + 32 * v81);
              v85 = v84[1];
              *v83 = *v84;
              v83[1] = v85;
              ++v81;
              --*(_WORD *)(v77 + 2 * v80);
LABEL_96:
              ++v79;
              v78 += 32;
              if (v79 >= *a12)
                goto LABEL_97;
            }
            v82 = v80;
LABEL_94:
            v86 = (_DWORD *)(*a11 + v78);
            *v86 = 33;
            v86[6] = *(unsigned __int8 *)(*(_QWORD *)(a10 + 32) + v82);
            ++v80;
            goto LABEL_96;
          }
LABEL_97:
          heap_Free(*(_QWORD **)(v15 + 8), v77);
          goto LABEL_98;
        }
      }
LABEL_119:
      v43 = -2065686518;
      log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v22, v23, v24, v25, v101);
      if (!a12)
        goto LABEL_127;
      goto LABEL_123;
    }
  }
LABEL_98:
  if (v102 < 1)
    goto LABEL_122;
  v90 = 0;
  if (v104 <= 1)
    v91 = 1;
  else
    v91 = v104;
  v92 = a2;
  do
  {
    v93 = *(_QWORD *)(a10 + 248);
    if (!*(_BYTE *)(v93 + v90))
      *(_BYTE *)(v93 + v90) = -1;
    v94 = *(_QWORD *)(a10 + 192);
    if (*(_BYTE *)(*(_QWORD *)(a10 + 32) + v90) == 35)
      v95 = 1;
    else
      v95 = 2 * *(_BYTE *)(v94 + v90);
    *(_BYTE *)(v94 + v90) = v95;
    v96 = *(_QWORD *)(a10 + 32);
    if ((unsigned __int16)(v102 & ~(unsigned __int16)(v102 >> 31)) - 1 == v90 && *(_BYTE *)(v96 + v90) == 35)
    {
      v111[0] = 0;
      paramc_ParamGetUInt(*(_QWORD *)(v15 + 40), (uint64_t)"finalsentencefound", v111);
      v97 = 0;
      v98 = *(_QWORD *)(a10 + 1784);
      if (v111[0] != 1)
        v97 = *(unsigned __int16 *)(v98 + 2 * v90) + 200 * *a9;
      if (v97 <= 1)
        v97 = 1;
      if (v97 >= 0xFFFF)
        LOWORD(v97) = -1;
      *(_WORD *)(v98 + 2 * v90) = v97;
      v96 = *(_QWORD *)(a10 + 32);
      v92 = a2;
    }
    *(_BYTE *)(v96 + v90) = *(_BYTE *)(v92 + *(unsigned __int8 *)(v96 + v90) + 7356);
    ++v90;
  }
  while (v91 != v90);
LABEL_44:
  a4 = v107;
  a3 = v108;
  if (a12)
  {
LABEL_123:
    if (a11 && v43 < 0 && *a11)
    {
      heap_Free(*(_QWORD **)(v15 + 8), *a11);
      *a11 = 0;
      *a12 = 0;
    }
  }
LABEL_127:
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(a1[2] + 64))(a3, a4);
  if ((int)result >= 0 || v43 <= -1)
    return v43;
  else
    return result;
}

uint64_t BET3FXD__select_bet3_FeatureExtractProcessEnd(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!*a2)
    return 0;
  v4 = *a1;
  v5 = usextract_ProcessEnd(*a1, (uint64_t)"SELECT_BET3", (uint64_t)a2);
  usextract_freeGenericFeatureLayers((_QWORD *)*a1, (uint64_t)"SELECT_BET3", a2);
  v10 = 0;
  v11 = 1;
  do
  {
    v12 = *(unsigned __int8 *)(*a2 + v10 + 2748);
    if (*(_BYTE *)(*a2 + v10 + 2748))
    {
      if (v12 == 2)
      {
        v14 = a2[v10 + 220];
        if (v14)
LABEL_11:
          heap_Free(*(_QWORD **)(v4 + 8), v14);
      }
      else if (v12 == 1)
      {
        if (v11)
        {
          v13 = a2[v10 + 2];
          if (v13)
            heap_Free(*(_QWORD **)(v4 + 8), v13);
          v11 = 0;
        }
      }
      else
      {
        switch((int)v10)
        {
          case '.':
            v14 = a2[445];
            if (v14)
              goto LABEL_11;
            break;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_20;
          case '3':
            v14 = a2[446];
            if (v14)
              goto LABEL_11;
            break;
          case '4':
            v14 = a2[447];
            if (v14)
              goto LABEL_11;
            break;
          case '5':
            v14 = a2[448];
            if (v14)
              goto LABEL_11;
            break;
          case '6':
            v14 = a2[449];
            if (v14)
              goto LABEL_11;
            break;
          case '8':
            v14 = a2[450];
            if (v14)
              goto LABEL_11;
            break;
          default:
            if ((_DWORD)v10 == 24)
            {
              v14 = a2[444];
              if (v14)
                goto LABEL_11;
            }
            else
            {
LABEL_20:
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"SELECT_BET3", 55010, (uint64_t)"%s%u", v6, v7, v8, v9, "feature");
            }
            break;
        }
      }
    }
    ++v10;
  }
  while (v10 != 218);
  v15 = a2[451];
  if (v15)
    heap_Free(*(_QWORD **)(v4 + 8), v15);
  cstdlib_memset(a2, 0, 8uLL);
  return v5;
}

uint64_t BET3FXD__mul_int32_Q8_24_to_int32(int a1, int a2)
{
  return ((a2 * a1) >> 24);
}

uint64_t BET3FXD__mul_int32_Q8_24_to_Q8_24(int a1, int a2)
{
  return (a2 * a1);
}

uint64_t BET3FXD__mul_Q18_14_Q1_15_to_Q18_14(uint64_t result, int a2)
{
  if (a2 == 0x7FFF)
    return result;
  else
    return ((unint64_t)(a2 * (uint64_t)(int)result) >> 15);
}

uint64_t BET3FXD__div_int32_int32_to_Q8_24(int a1, int a2)
{
  return (((a1 << 16) / a2) << 8);
}

uint64_t BET3FXD__div_Q8_24_Q12_20_to_Q8_24(int a1, int a2)
{
  return ((a1 / (a2 >> 8)) << 12);
}

uint64_t BET3FXD__div_Q18_14_Q18_14_to_Q18_14(int a1, int a2)
{
  return ((16 * a1 / (a2 >> 4)) << 6);
}

uint64_t BET3FXD__Q8_24_to_int32(int a1)
{
  return (a1 >> 24);
}

uint64_t BET3FXD__Q10_22_to_Q8_24(int a1)
{
  return (4 * a1);
}

uint64_t BET3FXD__int32_to_Q8_24(int a1)
{
  return (a1 << 24);
}

uint64_t BET3FXD__int32_to_Q12_20(int a1)
{
  return (a1 << 20);
}

uint64_t BET3FXD__int32_to_Q18_14(int a1)
{
  return (a1 << 14);
}

uint64_t BET3FXD__Q18_14_to_Q1_15(__int16 a1)
{
  return (__int16)(2 * a1);
}

uint64_t BET3FXD__LoadModelFile(uint64_t a1, unsigned int *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  unsigned int *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  int v18;
  unsigned int v19;

  if (a2[a3 + 120])
  {
    result = loadQuantizedDurFile(a1, (uint64_t)(a2 + 42), a4, 0xFu);
    if ((_DWORD)result)
      return result;
    *a2 = a2[43];
  }
  v13 = &a2[a3];
  if (v13[130])
  {
    v14 = heap_Calloc(*(_QWORD **)(a1 + 8), (*(_DWORD *)(a6 + 268) - 1), 4);
    *((_QWORD *)a2 + 53) = v14;
    if (!v14)
      return 2229280778;
    result = loadVQQuantizedCepFile(a1, (unsigned __int16 *)a2 + 196, a4);
    if ((_DWORD)result)
      return result;
    *a2 = *((unsigned __int16 *)a2 + 199);
    a2[a3 + 1] = *((unsigned __int16 *)a2 + 198) + *((unsigned __int16 *)a2 + 198) * *((unsigned __int16 *)a2 + 201);
    result = loadCodebookSet(a1, (uint64_t)(a2 + 116), a5, 0x10u);
    if ((_DWORD)result)
      return result;
  }
  if (!v13[140])
    return 0;
  v15 = (uint64_t *)&a2[2 * a3 + 78];
  if (*v15)
    heap_Free(*(_QWORD **)(a1 + 8), *v15);
  v16 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 128);
  *v15 = v16;
  if (!v16)
    return 2229280778;
  v17 = *(_DWORD *)(a6 + 4 * a3 + 224);
  if (v17 == 2)
  {
    v18 = 3774880;
    v19 = 20;
  }
  else if (v17 == 3)
  {
    v18 = 1310720;
    v19 = 18;
  }
  else
  {
    v19 = 0;
    v18 = 0;
  }
  result = loadQuantizedMsdFile(a1, v16, *a2, a4, v19, v18);
  if (!(_DWORD)result)
    a2[a3 + 1] = *(_DWORD *)(*v15 + 8);
  return result;
}

uint64_t BET3FXD__FindDurPDF(uint64_t a1, int *a2, int a3, int a4)
{
  int v4;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 24) = 0;
  if (*a2 < 1)
    return 0;
  v9 = 0;
  v10 = 0;
  v11 = (uint64_t)(a2 + 42);
  v12 = v4 - 1;
  while (1)
  {
    v20 = 0;
    result = dequantDur(v11, v12, v9, (_DWORD *)&v20 + 1, &v20, 15);
    if ((result & 0x80000000) != 0)
      break;
    v14 = HIDWORD(v20);
    v15 = BET3FXD__mul_Q18_14_Q1_15_to_Q18_14(((int)v20 >> 1), a3);
    v16 = (v15 + (v14 >> 1)) & ~((v15 + (v14 >> 1)) >> 31);
    if (a2[151])
    {
      if (v16 >= 0x3E7F060)
        v10 = 65532000;
      else
        v10 = (v15 + (v14 >> 1)) & ~((v15 + (v14 >> 1)) >> 31);
    }
    else if (v16 <= 0x3E7F060)
    {
      v10 = (v15 + (v14 >> 1)) & ~((v15 + (v14 >> 1)) >> 31);
    }
    else
    {
      v10 >>= 1;
    }
    v17 = a4 + ((v10 + 0x2000) >> 14);
    v18 = *(_QWORD *)(a1 + 16) + 4 * v9;
    *(_DWORD *)(v18 + 8) = v17;
    *(_DWORD *)(a1 + 24) += v17;
    a4 = (v10 + 0x2000 - (*(_DWORD *)(v18 + 8) << 14)) >> 14;
    v19 = v9 + 2;
    ++v9;
    if (v19 > *a2)
      return 0;
  }
  return result;
}

uint64_t BET3FXD__FindContPDF(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;
  unsigned int v16;
  int v17;
  unsigned __int16 *v18;
  uint64_t v19;
  int v20;
  uint64_t result;
  int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v31;
  _DWORD *v32;
  int v33;
  unint64_t v35;

  v35 = 0;
  v10 = a1;
  v11 = *a8;
  v12 = *a8 * *(unsigned __int16 *)(a4 + 396);
  LODWORD(v13) = *(unsigned __int16 *)(a4 + 402);
  v14 = v12 + v12 * v13;
  if (*(_WORD *)(a4 + 396))
  {
    v31 = a3;
    v32 = a8;
    v16 = 0;
    v17 = *(_DWORD *)(*(_QWORD *)(a3 + 8 * a1 + 72) + 4 * a2);
    v18 = (unsigned __int16 *)(a4 + 392);
    v19 = a4 + 464;
    v20 = v14 + 1;
    v33 = v12 + v12 * v13;
    while (1)
    {
      result = dequantEnergy(v18, a2, (unsigned __int16)v17, v16, (_DWORD *)&v35 + 1, &v35, 0x10u);
      if ((result & 0x80000000) != 0)
        break;
      v22 = v16 + v16 * v13 + v14;
      LODWORD(v35) = (int)v35 >> 4;
      v23 = v35;
      HIDWORD(v35) <<= 8;
      *(_DWORD *)(a6 + 4 * v22) = HIDWORD(v35);
      *(_DWORD *)(a7 + 4 * v22) = v23;
      LODWORD(v13) = *(unsigned __int16 *)(a4 + 402);
      if (*(_WORD *)(a4 + 402))
      {
        v24 = 0;
        do
        {
          v25 = *(int *)(*(_QWORD *)(a4 + 424) + 4 * v24);
          result = deVQSpectrum(v18, v19, a2, (unsigned __int16)v17, v25, v24 - *(unsigned __int16 *)(*(_QWORD *)(a4 + 416) + 2 * v25), v16, (_DWORD *)&v35 + 1, &v35, 0x10u);
          if ((result & 0x80000000) != 0)
            return result;
          v26 = v20 + v24 + v16 + v16 * v13;
          v27 = HIDWORD(v35) << 8;
          v28 = (int)v35 >> 4;
          *(_DWORD *)(a6 + 4 * v26) = HIDWORD(v35) << 8;
          v35 = __PAIR64__(v27, v28);
          *(_DWORD *)(a7 + 4 * v26) = v28;
          ++v24;
          v13 = *(unsigned __int16 *)(a4 + 402);
        }
        while (v24 < v13);
      }
      ++v16;
      v14 = v33;
      if (v16 >= *(unsigned __int16 *)(a4 + 396))
      {
        a3 = v31;
        a8 = v32;
        v11 = *v32;
        v10 = a1;
        goto LABEL_11;
      }
    }
  }
  else
  {
    result = 0;
LABEL_11:
    v29 = a3 + 8 * v10;
    *(_QWORD *)(*(_QWORD *)(v29 + 152) + 8 * a2) = a6 + 4 * v14;
    *(_QWORD *)(*(_QWORD *)(v29 + 232) + 8 * a2) = a7 + 4 * v14;
    *a8 = v11 + 1;
  }
  return result;
}

uint64_t BET3FXD__FindMsdPDF(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  int v6;
  _DWORD *v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  int *v32;
  int *v33;
  _QWORD *v34;
  char v35;
  _QWORD *v36;
  int v37;
  int v38;
  uint64_t v39;

  v39 = 0;
  v38 = 0;
  v5 = a5 + 4 * a1;
  v8 = *(_DWORD *)(v5 + 224);
  v7 = (_DWORD *)(v5 + 224);
  v6 = v8;
  if (v8 == 3)
    v9 = 18;
  else
    v9 = 0;
  if (v6 == 2)
    v10 = 20;
  else
    v10 = v9;
  v11 = a4 + 4 * a1;
  v13 = *(_DWORD *)(v11 + 4);
  v12 = (int *)(v11 + 4);
  if (v13 < 1)
    return 0;
  v14 = a3;
  v15 = 0;
  v16 = a2;
  v17 = (uint64_t *)(a4 + 8 * a1 + 312);
  v18 = (_QWORD *)(a3 + 8 * a1);
  v19 = (a2 - 2);
  v37 = *(_DWORD *)(v18[9] + 4 * a2) - 1;
  v20 = 24 - v10;
  v36 = v18 + 19;
  v35 = v10 - 12;
  v33 = (int *)(a5 + 4 * a1 + 2104);
  v34 = v18 + 29;
  v32 = v12;
  do
  {
    v21 = dequantMsd(*v17, v19, v37, v15, (_DWORD *)&v39 + 1, &v39, &v38, v10);
    if ((v21 & 0x80000000) != 0)
      break;
    v38 <<= v20;
    *(_DWORD *)(*(_QWORD *)(*v36 + 8 * v16) + 4 * v15 + 4) = HIDWORD(v39) << v20;
    if ((*v7 & 0xFFFFFFFE) == 2)
      *(_DWORD *)(*(_QWORD *)(*v34 + 8 * v16) + 4 * v15 + 4) = (int)v39 >> v35;
    if (!v15)
    {
      v22 = v10;
      v23 = v19;
      v24 = v17;
      if (*v7 == 2)
        *(_DWORD *)(*(_QWORD *)(v14 + 320) + 4 * v16) = v38;
      v25 = v14;
      v26 = v38;
      v27 = BET3FXD__Q10_22_to_Q8_24(*v33);
      v28 = 1 << *v7;
      if (v26 <= v27)
      {
        v14 = v25;
        v29 = *(_QWORD *)(v25 + 312);
        v30 = *(_BYTE *)(v29 + v16) & ~(_BYTE)v28;
      }
      else
      {
        v14 = v25;
        v29 = *(_QWORD *)(v25 + 312);
        v30 = *(_BYTE *)(v29 + v16) | v28;
      }
      *(_BYTE *)(v29 + v16) = v30;
      v17 = v24;
      v19 = v23;
      v10 = v22;
      v12 = v32;
    }
    ++v15;
  }
  while (v15 < *v12);
  return v21;
}

void *BET3FXD__DeInitModelSet(uint64_t a1, _QWORD *__b)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = __b[59];
  if (v4)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v4);
    __b[59] = 0;
  }
  for (i = 39; i != 49; ++i)
  {
    v6 = __b[i];
    if (v6)
    {
      if (*(_QWORD *)(v6 + 120))
      {
        heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)(v6 + 120));
        *(_QWORD *)(__b[i] + 120) = 0;
        v6 = __b[i];
      }
      heap_Free(*(_QWORD **)(a1 + 8), v6);
      __b[i] = 0;
    }
  }
  if (*((_WORD *)__b + 198))
  {
    v7 = 0;
    v8 = 0;
    v9 = __b[54];
    v10 = v9;
    do
    {
      if (v10)
      {
        v11 = *(_QWORD *)(v10 + v7 + 8);
        if (v11)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v11);
          v9 = __b[54];
          *(_QWORD *)(v9 + v7 + 8) = 0;
        }
        v12 = *(_QWORD *)(v9 + v7 + 24);
        if (v12)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v12);
          v9 = __b[54];
          *(_QWORD *)(v9 + v7 + 24) = 0;
        }
        v13 = *(_QWORD *)(v9 + v7 + 32);
        v10 = v9;
        if (v13)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v13);
          v9 = __b[54];
          *(_QWORD *)(v9 + v7 + 32) = 0;
          v10 = v9;
        }
      }
      ++v8;
      v7 += 40;
    }
    while (v8 < 2 * (unint64_t)*((unsigned __int16 *)__b + 198));
  }
  v14 = __b[52];
  if (v14)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v14);
    __b[52] = 0;
  }
  v15 = __b[53];
  if (v15)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v15);
    __b[53] = 0;
  }
  v16 = __b[54];
  if (v16)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v16);
    __b[54] = 0;
  }
  v17 = __b[56];
  if (v17)
  {
    __b[56] = v17 + 32;
    heap_Free(*(_QWORD **)(a1 + 8), v17 + 32);
    __b[56] = 0;
  }
  return cstdlib_memset(__b, 0, 0x260uLL);
}

uint64_t BET3FXD__InitUttModel(uint64_t a1, char *__b, int *a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v8 = 2229280778;
  cstdlib_memset(__b, 0, 0x240uLL);
  *(_QWORD *)__b = a1;
  *((_QWORD *)__b + 1) = a3;
  *((_DWORD *)__b + 138) = a4;
  *((_DWORD *)__b + 141) = *a3 * a4;
  v9 = heap_Calloc(*(_QWORD **)(a1 + 8), a4, 528);
  *((_QWORD *)__b + 68) = v9;
  if (v9)
  {
    v10 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
    *((_QWORD *)__b + 4) = v10;
    if (v10)
    {
      v11 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 1);
      *((_QWORD *)__b + 41) = v11;
      if (v11)
      {
        v12 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
        *((_QWORD *)__b + 42) = v12;
        if (v12)
        {
          v13 = a3[150];
          if (v13 >= 1)
          {
            v14 = 0;
            v15 = __b + 168;
            v16 = a3;
            do
            {
              if (!v16[120])
              {
                v17 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
                *(v15 - 10) = v17;
                if (!v17)
                  return v8;
                v18 = *(_QWORD **)(a1 + 8);
                v19 = *((_DWORD *)__b + 138);
                v20 = v16[140]
                    ? BET3FXD__int32_ccalloc(v18, 2 * v19 * *a3, v16[1] + 1)
                    : (_QWORD *)heap_Calloc(v18, (2 * v19 * *a3), 8);
                *v15 = v20;
                if (!v20)
                  return v8;
                v15[10] = &v20[*a3 * *((_DWORD *)__b + 138)];
                v13 = a3[150];
              }
              ++v14;
              ++v16;
              ++v15;
            }
            while (v14 < v13);
          }
          v21 = *((unsigned int *)__b + 138);
          if ((int)v21 >= 1)
          {
            v22 = 0;
            v23 = *a3;
            v24 = 152;
            do
            {
              v25 = *((_QWORD *)__b + 68);
              v26 = v25 + 528 * v22;
              *(_DWORD *)v26 = v22;
              v27 = v22 * v23;
              v28 = *((_QWORD *)__b + 41) + v22 * v23;
              v29 = *((_QWORD *)__b + 42) + 4 * v22 * v23;
              *(_QWORD *)(v26 + 16) = *((_QWORD *)__b + 4) + 4 * v22 * v23 - 8;
              *(_QWORD *)(v26 + 312) = v28 - 2;
              *(_QWORD *)(v26 + 320) = v29 - 8;
              if (v13 >= 1)
              {
                v30 = (uint64_t *)(v25 + v24);
                v31 = __b + 168;
                v32 = v13;
                v33 = a3 + 120;
                do
                {
                  if (!*v33++)
                  {
                    v35 = *(v31 - 10) + 4 * v27;
                    *(v30 - 10) = v35;
                    v36 = *v31 + 8 * v27;
                    *v30 = v36;
                    v37 = v31[10] + 8 * v27;
                    *(v30 - 10) = v35 - 8;
                    *v30 = v36 - 16;
                    v30[10] = v37 - 16;
                  }
                  ++v30;
                  ++v31;
                  --v32;
                }
                while (v32);
              }
              ++v22;
              v24 += 528;
            }
            while (v22 != v21);
          }
          return 0;
        }
      }
    }
  }
  return v8;
}

_QWORD *BET3FXD__DeInitUttModel(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v1 = result;
  if (*result && result[68])
  {
    v2 = result[1];
    v3 = result[4];
    if (v3)
    {
      heap_Free(*(_QWORD **)(*result + 8), v3);
      v1[4] = 0;
    }
    v4 = v1[41];
    if (v4)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v4);
      v1[41] = 0;
    }
    v5 = v1[42];
    if (v5)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v5);
      v1[42] = 0;
    }
    if (*(int *)(v2 + 600) >= 1)
    {
      v6 = 0;
      do
      {
        if (!*(_DWORD *)(v2 + 480 + 4 * v6))
        {
          v7 = &v1[v6];
          v8 = v7[11];
          if (v8)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v8);
            v7[11] = 0;
          }
          v9 = v7[21];
          if (v9)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v9);
            v7[21] = 0;
          }
        }
        ++v6;
      }
      while (v6 < *(int *)(v2 + 600));
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), v1[68]);
  }
  v1[68] = 0;
  *((_DWORD *)v1 + 138) = 0;
  *v1 = 0;
  return result;
}

_QWORD *BET3FXD__DeInitMSDUttModel(_QWORD *result, int a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t **v8;
  _QWORD *v9;

  v2 = result[1];
  if (!*(_DWORD *)(v2 + 4 * a2 + 480))
  {
    v3 = result;
    v4 = a2;
    v5 = &result[a2];
    v6 = v5[11];
    if (v6)
    {
      result = heap_Free(*(_QWORD **)(*result + 8), v6);
      v5[11] = 0;
    }
    v9 = (_QWORD *)v5[21];
    v8 = (uint64_t **)(v5 + 21);
    v7 = v9;
    if (v9)
    {
      if (*(_DWORD *)(v2 + 4 * v4 + 560))
      {
        *v7 += 4;
        result = BET3FXD__int32_free(*(_QWORD **)(*v3 + 8), *v8);
      }
      else
      {
        result = heap_Free(*(_QWORD **)(*v3 + 8), (uint64_t)v7);
      }
      *v8 = 0;
    }
  }
  return result;
}

uint64_t BET3FXD__InitModelSet(int a1, char *__b, _DWORD *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;

  cstdlib_memset(__b, 0, 0x260uLL);
  v5 = a3[33];
  *((_DWORD *)__b + 150) = v5;
  if (v5 >= 1)
  {
    v6 = 0;
    v7 = 536;
    v8 = __b;
    do
    {
      *((_DWORD *)v8 + 32) = a3[86];
      v9 = __b + 480;
      if (v7 != 536)
      {
        if (a3[536])
          v9 = &__b[4 * v6 + 560];
        else
          v9 = v8 + 520;
      }
      ++a3;
      *(_DWORD *)v9 = 1;
      ++v6;
      v10 = v7 - 535;
      ++v7;
      v8 += 4;
    }
    while (v10 < *((int *)__b + 150));
  }
  return 0;
}

uint64_t BET3FXD__meancpy(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_DWORD *)(result + 16);
  if (v1 >= 1)
  {
    v2 = 0;
    LODWORD(v3) = *(_DWORD *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        v4 = 0;
        v5 = *(_QWORD *)(result + 72);
        v6 = *(_QWORD *)(result + 40);
        do
        {
          *(_DWORD *)(*(_QWORD *)(v6 + 8 * v4) + 4 * v2) = *(_DWORD *)(*(_QWORD *)(v5 + 8 * v4) + 4 * v2);
          ++v4;
          v3 = *(int *)(result + 20);
        }
        while (v4 < v3);
        v1 = *(_DWORD *)(result + 16);
      }
      ++v2;
    }
    while (v2 < v1);
  }
  return result;
}

uint64_t BET3FXD__ConstW_Calc_R_and_r(uint64_t a1, int a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t result;
  int v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD **v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 20);
  v4 = a2 + 2 * v2;
  v5 = a2;
  v6 = *(_QWORD **)(a1 + 72);
  v7 = *(_QWORD **)(a1 + 80);
  v8 = v7[1];
  v9 = *(int *)(*v7 + 4 * a2);
  v10 = v2 + a2;
  v11 = *(int *)(v8 + 4 * v10);
  v12 = v6[1];
  v13 = *(_DWORD *)(*v6 + 4 * a2);
  v14 = v10;
  v15 = ((int)((unint64_t)(-2147483392 * v11) >> 32) * (uint64_t)*(int *)(v12 + 4 * v10)) >> 12;
  v16 = *(_QWORD ***)(a1 + 96);
  v17 = *(_QWORD **)(a1 + 104);
  v18 = v15 + ((v13 * (uint64_t)(int)v9) >> 12);
  v19 = v4;
  v20 = *(int *)(*v7 + 4 * v4);
  v21 = (uint64_t)(0xFFFFFFFE00000200 * v20) >> 32;
  v22 = v18 + (((int)v21 * (uint64_t)*(int *)(*v6 + 4 * v4)) >> 12);
  v23 = *(_DWORD *)(v8 + 4 * v4);
  result = v23;
  v25 = *(_DWORD *)(v12 + 4 * v4);
  *v17 = v22 + ((v25 * (uint64_t)v23) >> 12);
  v26 = *v16;
  v27 = (0xFFFFFFLL * v23) >> 12;
  *v26 = ((0x3FFFFF * v11) >> 12) + (v9 << 12) + ((67108860 * v20) >> 12) + v27;
  v26[1] = ((-33554430 * v23) >> 12) + (v21 << 12);
  v26[2] = v27 + ((-4194303 * v11) >> 12);
  if (v3 < 3)
  {
    v48 = v25;
    LODWORD(v28) = 1;
  }
  else
  {
    v28 = (v3 - 1);
    v29 = v16 + 1;
    v30 = v17 + 1;
    v31 = v7 + 2;
    v32 = v6 + 2;
    v33 = v28 - 1;
    do
    {
      v34 = *(int *)(v8 + 4 * v5);
      v35 = *(v31 - 2);
      v36 = *(int *)(v35 + 4 * v14);
      v37 = *(v32 - 2);
      v38 = (((int)((unint64_t)(2147483392 * v36) >> 32) * (uint64_t)*(int *)(v37 + 4 * v14)) >> 12)
          + ((*(int *)(v12 + 4 * v5) * (uint64_t)(int)v34) >> 12);
      v39 = *v31++;
      v8 = v39;
      v40 = *(int *)(v39 + 4 * v14);
      v41 = *v32++;
      v12 = v41;
      v42 = *(int *)(v35 + 4 * v19);
      v43 = v38
          + (((int)((unint64_t)(-2147483392 * (int)v40) >> 32) * (uint64_t)*(int *)(v41 + 4 * v14)) >> 12)
          + ((*(int *)(v37 + 4 * v19) * (uint64_t)(int)v42) >> 12);
      v44 = (uint64_t)(0xFFFFFFFE00000200 * v23) >> 32;
      v45 = v43 + (((int)v44 * (uint64_t)v25) >> 12);
      v46 = *(int *)(v8 + 4 * v19);
      v25 = *(_DWORD *)(v41 + 4 * v19);
      *v30++ = v45 + ((v25 * (uint64_t)(int)v46) >> 12);
      v47 = *v29++;
      *v47 = ((0x3FFFFF * v40) >> 12)
           + ((0x3FFFFF * v36) >> 12)
           + ((67108860 * v23) >> 12)
           + ((v42 + v34 + v46) << 12);
      v47[1] = ((-33554430 * (int)v46) >> 12) + (v44 << 12);
      v47[2] = ((0xFFFFFF * v46) >> 12) + ((-4194303 * v40) >> 12);
      v23 = v46;
      --v33;
    }
    while (v33);
    v8 = v7[v28];
    v12 = v6[v28];
    result = *(int *)(v8 + 4 * v19);
    v48 = *(_DWORD *)(v12 + 4 * v19);
  }
  v49 = *(int *)(v8 + 4 * v5);
  v50 = v7[(int)v28 - 1];
  v51 = *(int *)(v50 + 4 * v14);
  v52 = v6[(int)v28 - 1];
  v53 = *(int *)(v50 + 4 * v19);
  v17[v28] = (((int)((unint64_t)(2147483392 * v51) >> 32) * (uint64_t)*(int *)(v52 + 4 * v14)) >> 12)
                         + ((*(int *)(v12 + 4 * v5) * (uint64_t)(int)v49) >> 12)
                         + ((*(int *)(v52 + 4 * v19) * (uint64_t)(int)v53) >> 12)
                         + (((int)((0xFFFFFFFE00000200 * result) >> 32) * (uint64_t)v48) >> 12);
  v54 = v16[v28];
  v54[1] = 0;
  v54[2] = 0;
  *v54 = ((v53 + v49) << 12) + ((0x3FFFFF * v51) >> 12) + ((67108860 * result) >> 12);
  return result;
}

uint64_t BET3FXD__ConstW_Cholesky(uint64_t result)
{
  uint64_t **v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v1 = *(uint64_t ***)(result + 96);
  v3 = *v1;
  v2 = v1[1];
  v4 = **v1;
  v5 = v4 >> 4;
  if ((unint64_t)v4 < 0x10)
    v5 = 1;
  v6 = ((*v1)[1] << 16) / v5;
  v7 = 16 * ((v3[2] << 16) / v5);
  v3[1] = 16 * v6;
  v3[2] = v7;
  v8 = v2[1];
  v9 = *v2 - ((uint64_t)(((unint64_t)(((16 * v6) >> 3) * ((16 * v6) >> 3)) >> 21) * (v4 >> 3)) >> 18);
  *v2 = v9;
  v10 = v8 - (((((v3[2] >> 3) * (v3[1] >> 3)) >> 21) * (*v3 >> 3)) >> 18);
  if ((unint64_t)v9 < 0x10)
    v11 = 1;
  else
    v11 = v9 >> 4;
  v12 = 16 * ((v10 << 16) / v11);
  v13 = 16 * ((v2[2] << 16) / v11);
  v2[1] = v12;
  v2[2] = v13;
  v14 = *(unsigned int *)(result + 20);
  if ((int)v14 >= 3)
  {
    v15 = v1 + 2;
    v16 = v14 - 2;
    do
    {
      v17 = *v15;
      v18 = (*v15)[1];
      v19 = **v15 - ((uint64_t)(((unint64_t)((v12 >> 3) * (v12 >> 3)) >> 21) * (v9 >> 3)) >> 18);
      *v17 = v19;
      v9 = v19
         - ((uint64_t)(((unint64_t)(((*(v15 - 2))[2] >> 3) * ((*(v15 - 2))[2] >> 3)) >> 21) * (**(v15 - 2) >> 3)) >> 18);
      *v17 = v9;
      v20 = v18 - (((((v2[2] >> 3) * (v2[1] >> 3)) >> 21) * (*v2 >> 3)) >> 18);
      if ((unint64_t)v9 < 0x10)
        v21 = 1;
      else
        v21 = v9 >> 4;
      v12 = 16 * ((v20 << 16) / v21);
      v22 = 16 * ((v17[2] << 16) / v21);
      v17[1] = v12;
      v17[2] = v22;
      ++v15;
      v2 = v17;
      --v16;
    }
    while (v16);
  }
  return result;
}

uint64_t BET3FXD__ConstW_Cholesky_forward(uint64_t result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v1 = *(uint64_t **)(result + 96);
  v2 = *(uint64_t **)(result + 104);
  v3 = *(uint64_t **)(result + 88);
  v4 = *v2;
  *v3 = *v2;
  v5 = *v1;
  v6 = v2[1] - ((*(_QWORD *)(*v1 + 8) * v4) >> 24);
  v3[1] = v6;
  v7 = *(unsigned int *)(result + 20);
  if ((int)v7 >= 3)
  {
    v8 = v1 + 1;
    v9 = v3 + 2;
    v10 = v2 + 2;
    v11 = v7 - 2;
    do
    {
      v13 = *v8++;
      v12 = v13;
      v14 = ((v6 >> 3) * (*(uint64_t *)(v13 + 8) >> 3)) >> 18;
      v15 = *v10++;
      v6 = v15 - (v14 + (((*(v9 - 2) >> 3) * (*(uint64_t *)(v5 + 16) >> 3)) >> 18));
      *v9++ = v6;
      v5 = v12;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t BET3FXD__ConstW_Cholesky_backward(uint64_t result, int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;

  v2 = *(_DWORD *)(result + 20);
  v3 = v2 - 1;
  v4 = *(_QWORD *)(result + 88);
  v5 = *(_QWORD *)(result + 96);
  v6 = **(_QWORD **)(v5 + 8 * (v2 - 1));
  if ((unint64_t)v6 <= 1)
    v6 = 1;
  v7 = (*(_QWORD *)(v4 + 8 * v3) << 24) / v6;
  v8 = *(_QWORD *)(result + 40);
  *(_DWORD *)(*(_QWORD *)(v8 + 8 * v3) + 4 * a2) = v7;
  v9 = v2 - 2;
  v10 = *(uint64_t **)(v5 + 8 * v9);
  v12 = *v10;
  v11 = v10[1];
  if ((unint64_t)v12 < 0x10)
    v13 = 1;
  else
    v13 = v12 >> 4;
  *(_DWORD *)(*(_QWORD *)(v8 + 8 * v9) + 4 * a2) = 16 * ((*(_QWORD *)(v4 + 8 * v9) << 16) / v13)
                                                     - ((unint64_t)(v11 * (int)v7) >> 24);
  v14 = *(_DWORD *)(result + 20);
  if (v14 >= 3)
  {
    v15 = 8 * (v14 - 3);
    v16 = v8 + 16;
    do
    {
      v17 = *(uint64_t **)(v5 + v15);
      if ((unint64_t)*v17 < 0x10)
        v18 = 1;
      else
        v18 = *v17 >> 4;
      result = *(_QWORD *)(v16 + v15 - 16);
      *(_DWORD *)(result + 4 * a2) = 16 * ((*(_QWORD *)(v4 + v15) << 16) / v18)
                                     - (((unint64_t)(v17[1] * *(int *)(*(_QWORD *)(v16 + v15 - 8) + 4 * a2)) >> 24)
                                      + ((unint64_t)(v17[2] * *(int *)(*(_QWORD *)(v16 + v15) + 4 * a2)) >> 24));
      v15 -= 8;
    }
    while (v15 != -8);
  }
  return result;
}

uint64_t BET3FXD__mlpg2(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 20) < 2)
    return BET3FXD__meancpy(a1);
  BET3FXD__ConstW_Calc_R_and_r(a1, a2);
  BET3FXD__ConstW_Cholesky(a1);
  BET3FXD__ConstW_Cholesky_forward(a1);
  return BET3FXD__ConstW_Cholesky_backward(a1, a2);
}

char *BET3FXD__heap_StrDup(_QWORD *a1, char *__s)
{
  int v4;
  char *v5;
  char *v6;

  if (!__s)
    return 0;
  v4 = cstdlib_strlen(__s);
  v5 = (char *)heap_Calloc(a1, (v4 + 1), 1);
  v6 = v5;
  if (v5)
    cstdlib_strcpy(v5, __s);
  return v6;
}

uint64_t BET3FXD__xfread_BET3(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  size_t v8;

  v5 = a3;
  v6 = *a4;
  v7 = a4[4];
  if (v6 + (_DWORD)a3 * a2 > v7)
    v5 = (v7 - v6) / a2;
  if ((_DWORD)v5)
  {
    v8 = v5 * a2;
    cstdlib_memcpy(a1, (const void *)(*((_QWORD *)a4 + 1) + v6), v8);
    *a4 += v8;
  }
  return v5;
}

uint64_t BET3FXD__xfread2ptr_BET3(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;

  v4 = *a4;
  if (a2 >= 2 && v4 % a2)
    return 0;
  v5 = a4[4];
  if (v4 + (_DWORD)a3 * a2 > v5)
    a3 = (v5 - v4) / a2;
  if ((_DWORD)a3)
  {
    *a1 = *((_QWORD *)a4 + 1) + v4;
    *a4 = v4 + a3 * a2;
  }
  return a3;
}

uint64_t BET3FXD__log_out_Event(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9;
  int v10;

  v9 = a3 - 1;
  do
    v10 = *(unsigned __int8 *)++v9;
  while (v10 == 10);
  return log_VOutEvent(*(uint64_t ***)(a1 + 32), a2, v9, &a9);
}

uint64_t BET3FXD__log_select_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  v3 = a3 - 1;
  do
    v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", (a2 + 2), 0, v3);
}

uint64_t BET3FXD__log_select_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;

  return log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", a2, 0, a5, a6, a7, a8, v9);
}

uint64_t BET3FXD__log_select_GetLogLevel(uint64_t a1)
{
  unsigned int LogLevel;

  LogLevel = log_GetLogLevel(a1);
  if (LogLevel >= 3)
    return LogLevel - 2;
  else
    return 0;
}

_QWORD *BET3FXD__ddcalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FXD__ddcalloc_64(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 8);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 8 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 8 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FXD__dd_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FXD__dd_free_64(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FXD__int32_ccalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FXD__int32_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *BET3FXD__iicalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *BET3FXD__ii_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

uint64_t BET3FXD__InitDWinSet(int a1, void *__b, uint64_t a3)
{
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  int v8;
  int v9;
  int *v10;

  cstdlib_memset(__b, 0, 0x190uLL);
  v5 = *(unsigned int *)(a3 + 132);
  if ((int)v5 >= 1)
  {
    for (i = 0; i != v5; ++i)
    {
      v7 = a3 + 4 * i;
      v8 = *(_DWORD *)(v7 + 304);
      if (v8 >= 1)
      {
        v9 = 0;
        v10 = (int *)(v7 + 304);
        do
        {
          *((_DWORD *)__b + 10 * i) = v8 + 1;
          ++v9;
          v8 = *v10;
        }
        while (v9 < *v10);
      }
    }
  }
  return 0;
}

_QWORD **BET3FXD__DeInitDWinSet(_QWORD **result, char *a2)
{
  _QWORD **v3;
  uint64_t i;
  char *v5;
  uint64_t *v6;

  if (a2)
  {
    v3 = result;
    for (i = 0; i != 400; i += 40)
    {
      v5 = &a2[i];
      BET3FXD__ii_free(v3[1], *(uint64_t **)&a2[i + 8]);
      v6 = *(uint64_t **)&a2[i + 16];
      if (v6)
      {
        if (!*v6 || (heap_Free(v3[1], *v6), **((_QWORD **)v5 + 2) = 0, (v6 = (uint64_t *)*((_QWORD *)v5 + 2)) != 0))
        {
          heap_Free(v3[1], (uint64_t)v6);
          *((_QWORD *)v5 + 2) = 0;
        }
      }
    }
    return (_QWORD **)cstdlib_memset(a2, 0, 0x190uLL);
  }
  return result;
}

uint64_t BET3FXD__LoadDWinFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  unsigned int *v5;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int ***v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  int v30;
  int **v31;
  int *v32;
  int v33;
  int v34;

  v5 = (unsigned int *)(a2 + 40 * a3);
  if (!*v5)
    return 0;
  v9 = 2229280778;
  v10 = BET3FXD__iicalloc(*(_QWORD **)(a1 + 8), *v5, 2);
  v11 = a2 + 40 * a3;
  *(_QWORD *)(v11 + 8) = v10;
  v12 = (int ***)(v11 + 8);
  if (v10)
  {
    v13 = heap_Calloc(*(_QWORD **)(a1 + 8), *v5, 8);
    v14 = a2 + 40 * a3;
    *(_QWORD *)(v14 + 16) = v13;
    v15 = (uint64_t **)(v14 + 16);
    if (v13)
    {
      *(_QWORD *)**v12 = 0;
      **v15 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 4);
      v16 = (_DWORD *)**v15;
      if (v16)
      {
        *v16 = 1;
        LODWORD(v17) = *v5;
        if ((int)*v5 <= 1)
        {
LABEL_9:
          v27 = a2 + 40 * a3;
          *(_DWORD *)(v27 + 24) = 0;
          v28 = (_DWORD *)(v27 + 24);
          v28[1] = 0;
          if ((int)v17 < 1)
          {
            v30 = 0;
          }
          else
          {
            v29 = 0;
            v30 = 0;
            v31 = *v12;
            v17 = v17;
            do
            {
              v32 = *v31;
              v33 = **v31;
              if (v30 > v33)
              {
                *v28 = v33;
                v30 = v33;
              }
              v34 = v32[1];
              if (v29 < v34)
              {
                v28[1] = v34;
                v29 = v34;
              }
              ++v31;
              --v17;
            }
            while (v17);
            if (v30 < v29)
            {
              v9 = 0;
              *(_DWORD *)(a2 + 40 * a3 + 32) = v29;
              return v9;
            }
          }
          v9 = 0;
          *(_DWORD *)(a2 + 40 * a3 + 32) = v30;
          return v9;
        }
        v18 = 1;
        v19 = 1;
        while (1)
        {
          v20 = BET3FXD__xfread2ptr_BET3(&(*v15)[v19], 4u, 0xFFFFFFFFLL, a4);
          if (!v20)
            break;
          (*v15)[v19] += 4 * (v20 >> 1);
          v26 = (*v12)[v19];
          *v26 = -(v20 >> 1);
          v26[1] = (v20 & 1) + (v20 >> 1) - 1;
          ++v18;
          v17 = (int)*v5;
          ++v19;
          a4 += 6;
          if (v18 >= v17)
            goto LABEL_9;
        }
        BET3FXD__log_select_Error(a1, 55019, (uint64_t)"InitDWin: illegal data\n", v21, v22, v23, v24, v25);
        return 2229280772;
      }
    }
  }
  return v9;
}

void *BET3FXD__InitSMatrices(uint64_t a1, _QWORD *__b)
{
  void *result;

  result = cstdlib_memset(__b, 0, 0x40uLL);
  *__b = a1;
  return result;
}

double BET3FXD__FreeSMatrices(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  double result;

  if (a1)
  {
    if (*(_QWORD *)a1)
    {
      v2 = *(uint64_t **)(a1 + 24);
      if (v2)
      {
        if (!*(_DWORD *)(a1 + 8))
        {
          BET3FXD__dd_free(*(_QWORD **)(*(_QWORD *)a1 + 8), v2);
          BET3FXD__dd_free_64(*(_QWORD **)(*(_QWORD *)a1 + 8), *(uint64_t **)(a1 + 48));
          v3 = *(_QWORD *)(a1 + 40);
          if (v3)
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v3);
        }
        *(_DWORD *)(a1 + 60) = 0;
        result = 0.0;
        *(_OWORD *)(a1 + 44) = 0u;
        *(_OWORD *)(a1 + 28) = 0u;
        *(_OWORD *)(a1 + 12) = 0u;
      }
    }
  }
  return result;
}

uint64_t BET3FXD__InitPStreamSM(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 *v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v4 = *a1;
  if (a2
    && *(_QWORD *)(a2 + 24)
    && *((_DWORD *)a1 + 3) == *(_DWORD *)(a2 + 12)
    && *((_DWORD *)a1 + 5) == *(_DWORD *)(a2 + 16)
    && *((_DWORD *)a1 + 6) == *(_DWORD *)(a2 + 20))
  {
    result = 0;
    v6 = *(_OWORD *)(a2 + 48);
    v8 = *(_OWORD *)a2;
    v7 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)a1 + 5) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)a1 + 6) = v6;
    *((_OWORD *)a1 + 3) = v8;
    *((_OWORD *)a1 + 4) = v7;
LABEL_12:
    *((_DWORD *)a1 + 14) = 1;
    return result;
  }
  a1[6] = v4;
  v9 = (__int128 *)(a1 + 6);
  v10 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 14) = 0;
  *((_DWORD *)a1 + 15) = v10;
  v11 = *(uint64_t *)((char *)a1 + 20);
  a1[8] = v11;
  v12 = BET3FXD__ddcalloc(*(_QWORD **)(v4 + 8), 2 * (int)v11, v10);
  a1[9] = (uint64_t)v12;
  if (v12
    && (v13 = *((_DWORD *)a1 + 6),
        v14 = *((int *)a1 + 5),
        a1[10] = (uint64_t)&v12[v14],
        v15 = BET3FXD__ddcalloc_64(*(_QWORD **)(v4 + 8), v14, v13),
        (a1[12] = (uint64_t)v15) != 0)
    && (v16 = heap_Calloc(*(_QWORD **)(v4 + 8), (2 * *((_DWORD *)a1 + 5)), 8), (a1[11] = v16) != 0))
  {
    a1[13] = v16 + 8 * *((int *)a1 + 5);
    if (a2)
    {
      BET3FXD__FreeSMatrices(a2);
      result = 0;
      v17 = *v9;
      v18 = *((_OWORD *)a1 + 4);
      v19 = *((_OWORD *)a1 + 6);
      *(_OWORD *)(a2 + 32) = *((_OWORD *)a1 + 5);
      *(_OWORD *)(a2 + 48) = v19;
      *(_OWORD *)a2 = v17;
      *(_OWORD *)(a2 + 16) = v18;
      goto LABEL_12;
    }
    return 0;
  }
  else
  {
    BET3FXD__FreeSMatrices((uint64_t)(a1 + 6));
    return 2229280778;
  }
}

double BET3FXD__FreePStreamSM(uint64_t a1)
{
  return BET3FXD__FreeSMatrices(a1 + 48);
}

uint64_t BET3FXD__InitPStreamParam(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _QWORD *v7;
  uint64_t result;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v4 = *a1;
  *((_DWORD *)a1 + 6) = (2 * *(_DWORD *)(a1[4] + 32)) | 1;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 40);
    if (v5)
    {
      if (*((_DWORD *)a1 + 5) == *(_DWORD *)(a2 + 20) && *((_DWORD *)a1 + 4) == *(_DWORD *)(a2 + 16))
      {
        a1[5] = v5;
        v6 = a1 + 1;
LABEL_12:
        result = 0;
        *v6 = 1;
        return result;
      }
    }
  }
  *((_DWORD *)a1 + 2) = 0;
  v6 = a1 + 1;
  v7 = BET3FXD__int32_ccalloc(*(_QWORD **)(v4 + 8), *((_DWORD *)a1 + 5), *((_DWORD *)a1 + 4));
  a1[5] = (uint64_t)v7;
  if (v7)
    result = 0;
  else
    result = 2229280778;
  if (a2 && v7)
  {
    BET3FXD__FreePStreamParam((_QWORD *)a2);
    v9 = *(_OWORD *)a1;
    v10 = *((_OWORD *)a1 + 1);
    v11 = *((_OWORD *)a1 + 3);
    *(_OWORD *)(a2 + 32) = *((_OWORD *)a1 + 2);
    *(_OWORD *)(a2 + 48) = v11;
    *(_OWORD *)a2 = v9;
    *(_OWORD *)(a2 + 16) = v10;
    v12 = *((_OWORD *)a1 + 4);
    v13 = *((_OWORD *)a1 + 5);
    v14 = *((_OWORD *)a1 + 6);
    *(_QWORD *)(a2 + 112) = a1[14];
    *(_OWORD *)(a2 + 80) = v13;
    *(_OWORD *)(a2 + 96) = v14;
    *(_OWORD *)(a2 + 64) = v12;
    goto LABEL_12;
  }
  return result;
}

_QWORD *BET3FXD__FreePStreamParam(_QWORD *result)
{
  _QWORD *v1;
  uint64_t *v2;

  if (*result)
  {
    v1 = result;
    v2 = (uint64_t *)result[5];
    if (v2)
    {
      if (!*((_DWORD *)result + 2))
        result = BET3FXD__int32_free(*(_QWORD **)(*result + 8), v2);
      v1[5] = 0;
      *((_DWORD *)v1 + 2) = 0;
    }
  }
  return result;
}

uint64_t select_bet3_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2229280769;
  result = 0;
  *a2 = &ISelect_Bet3_0;
  return result;
}

uint64_t select_bet3_ClassOpen_0(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2229280775;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 25957;
  }
  return result;
}

uint64_t select_bet3_ClassClose_0()
{
  return 0;
}

uint64_t select_bet3_ObjOpen_0(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t Object;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t ObjOpen;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v43;
  unsigned int v44;
  _QWORD *v45;
  __int128 v46;
  uint64_t v47;
  int v48[2];
  unsigned int v49;
  char __dst[16];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v49 = 0;
  v47 = 0;
  *(_QWORD *)v48 = 0;
  v5 = 2229280775;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  *(_OWORD *)__dst = 0u;
  v51 = 0u;
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, v48);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else if ((safeh_HandleCheck(a1, a2, 25957, 408) & 0x80000000) != 0)
    {
      return 2229280776;
    }
    else
    {
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      log_OutText(*(_QWORD *)(*(_QWORD *)v48 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Entering select_bet3_ObjOpen", v12, v13, v14, v43);
      v15 = (_QWORD *)heap_Calloc(*(_QWORD **)(*(_QWORD *)v48 + 8), 1, 6608);
      if (v15)
      {
        v20 = v15;
        *v15 = a3;
        v15[1] = a4;
        v21 = *(_QWORD *)v48;
        v15[2] = *(_QWORD *)v48;
        v15[3] = a1;
        Object = objc_GetObject(*(_QWORD *)(v21 + 48), (uint64_t)"SYNTHSTREAM", &v47);
        if ((Object & 0x80000000) != 0
          || (v20[4] = *(_QWORD *)(v47 + 8),
              Object = objc_GetObject(*(_QWORD *)(*(_QWORD *)v48 + 48), (uint64_t)"LINGDB", &v47),
              (Object & 0x80000000) != 0))
        {
          v5 = Object;
          log_OutPublic(*(_QWORD *)(v20[2] + 32), (uint64_t)"SELECT_BET3", 55001, 0, v23, v24, v25, v26, v44);
        }
        else
        {
          v27 = *(_QWORD *)(v47 + 8);
          v20[5] = v27;
          ObjOpen = BET3FXD__select_bet3_FeatureExtractObjOpen(a3, a4, v20[4], v27, v20 + 7);
          if ((ObjOpen & 0x80000000) != 0)
            goto LABEL_27;
          ObjOpen = select_bet3_loc_CreateDataBrkString(*(uint64_t *)v48, __dst);
          if ((ObjOpen & 0x80000000) != 0)
            goto LABEL_27;
          v29 = v20[3];
          if (!v29 || (v30 = *(_QWORD *)(v29 + 48)) == 0)
            v30 = *(_QWORD *)(v20[2] + 48);
          ObjOpen = objc_GetAddRefCountedObject(v30, (uint64_t)__dst, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))select_bet3_loc_ObjcVoiceOpen_0, (void (*)(_QWORD, _QWORD, _OWORD *))select_bet3_loc_ObjcVoiceClose_0, *(uint64_t *)v48, &v47);
          if ((ObjOpen & 0x80000000) != 0
            || (v31 = *(_QWORD *)v48,
                v32 = *(_QWORD *)(v47 + 32),
                v20[6] = v32,
                ObjOpen = select_bet3_loc_SetSynthParams_0(v31, v32),
                (ObjOpen & 0x80000000) != 0))
          {
LABEL_27:
            v5 = ObjOpen;
          }
          else
          {
            v33 = *(_QWORD *)(*(_QWORD *)v48 + 40);
            v45 = v20;
            v46 = xmmword_24D294558;
            v34 = paramc_ListenerAdd(v33, "frequencyhz", &v45);
            if ((v34 & 0x80000000) == 0)
            {
              v39 = 0;
              while (1)
              {
                v40 = off_24D294530[v39];
                if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)v48 + 40), (uint64_t)v40, &v49) & 0x80000000) != 0)
                {
                  v49 = dword_214F97790[v39];
                  v34 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)v48 + 40), (uint64_t)v40, v49);
                  if ((v34 & 0x80000000) != 0)
                    break;
                }
                v34 = select_bet3_loc_ParamSet_0((uint64_t)v20, v40, v49);
                if ((v34 & 0x80000000) != 0)
                  break;
                v41 = *(_QWORD *)(*(_QWORD *)v48 + 40);
                v45 = v20;
                v46 = xmmword_24D294558;
                v5 = paramc_ListenerAdd(v41, v40, &v45);
                if ((v5 & 0x80000000) != 0)
                  goto LABEL_32;
                if (++v39 == 3)
                {
                  *(_QWORD *)a5 = v20;
                  *(_DWORD *)(a5 + 8) = 25958;
                  goto LABEL_29;
                }
              }
            }
            v5 = v34;
LABEL_32:
            log_OutPublic(*(_QWORD *)(v20[2] + 32), (uint64_t)"SELECT_BET3", 55002, (uint64_t)"%s%s", v35, v36, v37, v38, "param");
          }
        }
        *(_QWORD *)a5 = v20;
        *(_DWORD *)(a5 + 8) = 25958;
        select_bet3_ObjClose_0(v20, *(_QWORD *)(a5 + 8));
        *(_QWORD *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
      }
      else
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)v48 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v16, v17, v18, v19, v44);
        v5 = 2229280778;
      }
LABEL_29:
      log_OutText(*(_QWORD *)(*(_QWORD *)v48 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Leaving select_bet3_ObjOpen: %x", v36, v37, v38, v5);
    }
  }
  return v5;
}

uint64_t select_bet3_ObjClose_0(_QWORD *a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  char *v10;
  uint64_t v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v19;
  int ObjClose;
  int v22;
  int v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  _QWORD *v31;
  __int128 v32;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 25958, 6608);
  if (v3 < 0)
    return 2229280776;
  LODWORD(v7) = v3;
  v8 = a1[2];
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Entering select_bet3_ObjClose", v4, v5, v6, v30);
  for (i = 0; i != 4; ++i)
  {
    v10 = off_24D294568[i];
    v11 = *(_QWORD *)(v8 + 40);
    v31 = a1;
    v32 = xmmword_24D294558;
    v12 = paramc_ListenerRemove(v11, v10, (__int128 *)&v31);
    if ((int)v7 > -1 && v12 < 0)
      v7 = v12;
    else
      v7 = v7;
  }
  v14 = a1[6];
  if (v14)
  {
    v15 = a1[3];
    if (!v15 || (v16 = *(_QWORD *)(v15 + 48)) == 0)
      v16 = *(_QWORD *)(a1[2] + 48);
    v17 = objc_ReleaseObject(v16, v14);
    a1[6] = 0;
    if ((int)v7 > -1 && v17 < 0)
      v7 = v17;
    else
      v7 = v7;
  }
  v19 = a1[7];
  if (v19)
  {
    ObjClose = BET3FXD__select_bet3_FeatureExtractObjClose(v19);
    if ((int)v7 > -1 && ObjClose < 0)
      v7 = ObjClose;
    else
      v7 = v7;
  }
  if (a1[5])
  {
    v22 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"LINGDB");
    if ((int)v7 > -1 && v22 < 0)
      v7 = v22;
    else
      v7 = v7;
  }
  if (a1[4])
  {
    v24 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if ((int)v7 > -1 && v24 < 0)
      v7 = v24;
    else
      v7 = v7;
  }
  heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Leaving select_bet3_ObjClose: %x", v26, v27, v28, v7);
  return v7;
}

uint64_t select_bet3_ObjReopen_0(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t DataBrkString;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  char __dst[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)__dst = 0u;
  v22 = 0u;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 25958, 6608) & 0x80000000) != 0)
    return 2229280776;
  v6 = a1[2];
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Entering select_bet3_ObjReopen", v3, v4, v5, v19);
  DataBrkString = select_bet3_loc_CreateDataBrkString(v6, __dst);
  if ((DataBrkString & 0x80000000) == 0)
  {
    v11 = a1[3];
    if (!v11 || (v12 = *(_QWORD *)(v11 + 48)) == 0)
      v12 = *(_QWORD *)(a1[2] + 48);
    DataBrkString = objc_GetAddRefCountedObject(v12, (uint64_t)__dst, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))select_bet3_loc_ObjcVoiceOpen_0, (void (*)(_QWORD, _QWORD, _OWORD *))select_bet3_loc_ObjcVoiceClose_0, v6, &v20);
    if ((DataBrkString & 0x80000000) == 0)
    {
      v13 = a1[6];
      if (v13)
      {
        v14 = a1[3];
        if (!v14 || (v15 = *(_QWORD *)(v14 + 48)) == 0)
          v15 = *(_QWORD *)(a1[2] + 48);
        objc_ReleaseObject(v15, v13);
      }
      v16 = *(_QWORD *)(v20 + 32);
      a1[6] = v16;
      DataBrkString = select_bet3_loc_SetSynthParams_0(v6, v16);
    }
  }
  v17 = DataBrkString;
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SELECT_BET3", 4, 0, (uint64_t)"Leaving select_bet3_ObjReopen: %x", v8, v9, v10, DataBrkString);
  return v17;
}

uint64_t select_bet3_ProcessStart_0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;

  if ((safeh_HandleCheck(a1, a2, 25958, 6608) & 0x80000000) != 0)
    return 2229280776;
  synstrmaux_InitStreamOpener(a1 + 72, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-cspp-sptchk;version=4.0",
    1,
    a1 + 928);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-cspp-sgt;version=4.0", 1, a1 + 944);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-bet3-speech-frames;version=5.0",
    a1 + 896);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"application/x-realspeak-markers-pp;version=4.0", a1 + 912);
  v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 72), *(_QWORD *)(a1 + 32), a3, a4);
  if ((v8 & 0x80000000) != 0)
    select_bet3_ProcessEnd_0(a1, a2);
  *(_DWORD *)(a1 + 6600) = 0;
  return v8;
}

uint64_t select_bet3_Process_0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  _DWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  _DWORD *v20;
  unsigned int v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v37;
  int v39;
  int v40;
  uint64_t inited;
  int v43;
  unsigned int v44;
  int v45;
  _DWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int ProcessEnd;
  uint64_t v57;
  uint64_t v59;
  int v60;

  v60 = 0;
  if ((safeh_HandleCheck(a1, a2, 25958, 6608) & 0x80000000) != 0)
    return 2229280776;
  *a5 = 1;
  v9 = (_DWORD *)(a1 + 6568);
  v10 = *(_DWORD *)(a1 + 6568);
  if (*(_QWORD *)(a1 + 4616))
  {
    if (!v10)
    {
      v11 = BET3FXD__ParamGenFrames(a1 + 4616, (int *)(*(_QWORD *)(a1 + 48) + 8112), (_DWORD *)(a1 + 6568));
      if ((v11 & 0x80000000) != 0)
      {
        v25 = v11;
      }
      else
      {
        v12 = *(_QWORD *)(a1 + 6576);
        if (!v12)
          goto LABEL_65;
        v13 = *(unsigned int *)(a1 + 6588);
        v14 = *(_DWORD *)(a1 + 6584);
        if (v14 <= v13)
          goto LABEL_65;
        v15 = v12 + 32 * v13;
        v16 = *(_DWORD *)(a1 + 5228);
        v17 = *(_DWORD *)(a1 + 5232);
        if (v17 >= v16)
        {
          v23 = 0;
          v20 = (_DWORD *)(v12 + 32 * v13);
        }
        else
        {
          v18 = 0;
          v19 = *(_DWORD *)(a1 + 6600);
          v20 = (_DWORD *)(v12 + 32 * v13);
          do
          {
            if (*v20 == 33)
            {
              v21 = *(_DWORD *)(a1 + 6596);
              v22 = *(_DWORD *)(*(_QWORD *)(a1 + 5216) + 528 * v17 + 24);
              v20[4] = v22;
              *(_DWORD *)(a1 + 6596) = v22 + v21;
              *(_DWORD *)(a1 + 5232) = ++v17;
            }
            else
            {
              if (*v20 == 8)
              {
                v19 = v20[6] / *(_DWORD *)(*(_QWORD *)(a1 + 48) + 152);
                *(_DWORD *)(a1 + 6600) = v19;
              }
              v21 = *(_DWORD *)(a1 + 6596);
              v20[4] = 0;
            }
            if (v19 > v21)
            {
              *(_DWORD *)(a1 + 6600) = v21;
              v19 = v21;
            }
            v20[3] = v21 - v19;
            v20 += 8;
            v23 = v18 + 1;
            if (v17 >= v16)
              break;
            v24 = v13 + 1 + v18++;
          }
          while (v24 < v14);
        }
        if (*v9)
        {
          v44 = v23 + v13;
          if (v23 + (int)v13 < v14)
          {
            v45 = *(_DWORD *)(a1 + 6596);
            v46 = v20 + 4;
            do
            {
              *(v46 - 1) = v45;
              *v46 = 0;
              v46 += 8;
              ++v44;
            }
            while (v44 < v14);
            v23 = v14 - v13;
          }
        }
        if (!v23)
        {
LABEL_65:
          v59 = a1 + 4616;
          v25 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, uint64_t))(*(_QWORD *)(a1 + 32) + 104))(*(_QWORD *)(a1 + 896), *(_QWORD *)(a1 + 904), &v59, 8);
          if ((v25 & 0x80000000) != 0)
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55008, (uint64_t)"%s%s%s%x", v52, v53, v54, v55, "contentType");
          }
          else if (*v9)
          {
            ProcessEnd = BET3FXD__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
            if (ProcessEnd >= 0)
              v25 = v25;
            else
              v25 = ProcessEnd;
            v57 = *(_QWORD *)(a1 + 6576);
            if (v57)
            {
              heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v57);
              *(_QWORD *)(a1 + 6576) = 0;
              *(_QWORD *)(a1 + 6584) = 0;
              *(_DWORD *)(a1 + 6592) = 0;
            }
            v43 = 1;
            goto LABEL_75;
          }
          goto LABEL_74;
        }
        v47 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 104))(*(_QWORD *)(a1 + 912), *(_QWORD *)(a1 + 920), v15, (32 * v23));
        if ((v47 & 0x80000000) == 0)
        {
          *(_DWORD *)(a1 + 6588) += v23;
          goto LABEL_65;
        }
        v25 = v47;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55008, (uint64_t)"%s%s%s%x", v48, v49, v50, v51, "contentType");
        *(_DWORD *)(a1 + 6588) += v23;
      }
LABEL_74:
      v43 = 2;
      goto LABEL_75;
    }
  }
  else if (!v10)
  {
    goto LABEL_22;
  }
  BET3FXD__DeInitVStream((_QWORD *)(a1 + 4616));
  *v9 = 0;
LABEL_22:
  v25 = BET3FXD__select_bet3_FeatureExtractProcessStart(*(uint64_t **)(a1 + 56), *(_QWORD *)(a1 + 48) + 9328, a3, a4, (_QWORD *)(a1 + 960), &v60);
  if ((v25 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55005, (uint64_t)"%s%x", v26, v27, v28, v29, "lhError");
  }
  else if (*(__int16 *)(a1 + 970) > 1)
  {
    *(_DWORD *)(a1 + 6588) = 0;
    inited = BET3FXD__InitVStream(*(_QWORD *)(a1 + 16), (char *)(a1 + 4616), (_DWORD *)(*(_QWORD *)(a1 + 48) + 128));
    if ((inited & 0x80000000) != 0
      || (*(_QWORD *)(a1 + 4624) = a1 + 960,
          inited = BET3FXD__LoadVStream((uint64_t *)(a1 + 4616), *(_QWORD *)(a1 + 48) + 8112, *(_QWORD *)(a1 + 48) + 128), (inited & 0x80000000) != 0)|| (inited = BET3FXD__select_bet3_FeatureExtractProcess(*(uint64_t **)(a1 + 56), *(_QWORD *)(a1 + 48) + 128, a3, a4, *(_QWORD *)(a1 + 928), *(_QWORD *)(a1 + 936), *(_QWORD *)(a1 + 944), *(_QWORD *)(a1 + 952), (unsigned int *)(a1 + 64), a1 + 960, (uint64_t *)(a1 + 6576), (_DWORD *)(a1 + 6584)), (inited & 0x80000000) != 0))
    {
      v25 = inited;
    }
    else
    {
      v25 = BET3FXD__ParamGenStart(a1 + 4616, (int *)(*(_QWORD *)(a1 + 48) + 8112), *(_QWORD *)(a1 + 48) + 128);
      if ((v25 & 0x80000000) == 0)
      {
        v43 = 4;
LABEL_75:
        *a5 = v43;
        return v25;
      }
    }
    BET3FXD__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
    BET3FXD__DeInitVStream((_QWORD *)(a1 + 4616));
  }
  else
  {
    v30 = v60;
    if (v60)
    {
      if (*(_QWORD *)(a1 + 912))
      {
        if (*(_DWORD *)(a1 + 4480))
        {
          LODWORD(v25) = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 104))();
          if ((v25 & 0x80000000) != 0)
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 55008, (uint64_t)"%s%s%s%x", v31, v32, v33, v34, "contentType");
        }
      }
      v35 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 72), *(_QWORD *)(a1 + 32));
      if (v35 < 0 && (int)v25 > -1)
        LODWORD(v25) = v35;
      v30 = 1;
    }
    *a5 = v30;
    v37 = BET3FXD__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
    if (v37 >= 0 || (int)v25 <= -1)
      v39 = v25;
    else
      v39 = v37;
    v40 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4);
    if (v39 > -1 && v40 < 0)
      return v40;
    else
      return v39;
  }
  return v25;
}

uint64_t select_bet3_ProcessEnd_0(uint64_t a1, int a2)
{
  uint64_t v3;

  if ((safeh_HandleCheck(a1, a2, 25958, 6608) & 0x80000000) != 0)
    return 2229280776;
  BET3FXD__DeInitVStream((_QWORD *)(a1 + 4616));
  *(_DWORD *)(a1 + 6568) = 0;
  BET3FXD__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 56), (_QWORD *)(a1 + 960));
  v3 = *(_QWORD *)(a1 + 6576);
  if (v3)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v3);
    *(_QWORD *)(a1 + 6576) = 0;
    *(_QWORD *)(a1 + 6584) = 0;
    *(_DWORD *)(a1 + 6592) = 0;
  }
  *(_DWORD *)(a1 + 6596) = 0;
  return synstrmaux_CloseStreams((_WORD *)(a1 + 72), *(_QWORD *)(a1 + 32));
}

uint64_t select_bet3_loc_ObjcVoiceOpen_0(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t VData;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  const char *v43;
  unsigned int v45;
  _OWORD __dst[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  void *__src;
  _QWORD *v72;
  char __s1[256];
  char __b[80];
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v70 = 0;
  __src = 0;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v47 = 0u;
  memset(__dst, 0, sizeof(__dst));
  inited = InitRsrcFunction(a1, a2, &__src);
  if ((inited & 0x80000000) != 0)
    return inited;
  cstdlib_memcpy(__dst, __src, 0x198uLL);
  v47 = *(_OWORD *)(a5 + 32);
  v72 = 0;
  *(_QWORD *)(a4 + 32) = 0;
  v11 = ssftriff_reader_ObjOpen(a1, a2, 0, a3, "FIX3", 1031, (uint64_t *)&v72);
  if (v11 < 0)
    return (v11 & 0x1FFFu) - 2065686528;
  v12 = (char *)heap_Calloc(*((_QWORD **)&__dst[0] + 1), 1, 37944);
  v17 = (uint64_t)v12;
  if (v12)
  {
    cstdlib_strcpy(v12, a3);
    cstdlib_strcpy((char *)(v17 + 9480), a3);
    cstdlib_memset((void *)(v17 + 11472), 255, 0x100uLL);
    cstdlib_memset((void *)(v17 + 12376), 255, 0x11CuLL);
    cstdlib_memset((void *)(v17 + 12704), 255, 0x20uLL);
    *(_DWORD *)(v17 + 11852) = 1;
    BET3FXD__InitVParam((_DWORD *)(v17 + 128));
    cstdlib_memset((void *)(v17 + 7808), -1, 0x12CuLL);
    cstdlib_strcpy((char *)(v17 + 7792), "mlsa");
    cstdlib_memset(__b, 0, 0x50uLL);
    v19 = select_bet3_ParseRiff_0((uint64_t)__dst, v17, (uint64_t)v72, 0, __b, 0, 0, v18);
    if ((v19 & 0x80000000) != 0)
    {
      VData = v19;
      cstdlib_strcpy(__s1, "");
      if (__b[0])
      {
        v42 = 0;
        v43 = __b;
        do
        {
          cstdlib_strcat(__s1, "/");
          cstdlib_strcat(__s1, v43);
          v43 = &__b[5 * (unsigned __int16)++v42];
        }
        while (*v43);
      }
      log_OutPublic(v47, (uint64_t)"SELECT_BET3", 55003, (uint64_t)"%s%s%s%s%s%x", v38, v39, v40, v41, "file");
    }
    else if (*(_BYTE *)(v17 + 7519) && *(int *)(v17 + 260) > 0)
    {
      v24 = *(uint64_t **)(v17 + 11792);
      if (v24)
      {
        v25 = *v24;
        if (v25)
        {
          v26 = 0;
          v27 = 0;
          do
          {
            *(_QWORD *)(v17 + 8 * v26 + 5432) = v25;
            v26 = (unsigned __int16)++v27;
            v25 = *(_QWORD *)(*(_QWORD *)(v17 + 11792) + 8 * (unsigned __int16)v27);
          }
          while (v25);
        }
      }
      v28 = BET3FXD__InitVData((int)__dst, (char *)(v17 + 8112), (_DWORD *)(v17 + 128));
      if ((v28 & 0x80000000) != 0)
      {
        VData = v28;
      }
      else
      {
        VData = BET3FXD__LoadVData((uint64_t)__dst, (_DWORD *)(v17 + 8112), v17 + 128);
        if ((VData & 0x80000000) == 0)
        {
          *(_WORD *)(v17 + 12906) = 1;
          *(_QWORD *)&v37 = 0x100000001;
          *((_QWORD *)&v37 + 1) = 0x100000001;
          *(_OWORD *)(v17 + 12496) = v37;
          *(_OWORD *)(v17 + 12512) = v37;
          *(_QWORD *)(v17 + 12528) = 0x100000001;
          *(_DWORD *)(v17 + 12540) = 1;
          *(_OWORD *)(v17 + 12556) = v37;
          *(_OWORD *)(v17 + 12572) = v37;
          *(_OWORD *)(v17 + 12588) = v37;
          *(_OWORD *)(v17 + 12604) = v37;
          *(_OWORD *)(v17 + 12620) = v37;
          *(_DWORD *)(v17 + 12636) = 1;
          *(_QWORD *)(v17 + 12640) = 0x100000001;
          *(_DWORD *)(v17 + 12078) = 33620481;
          *(_BYTE *)(v17 + 12105) = 1;
          *(_QWORD *)(v17 + 12083) = 0x101010101010101;
          *(_DWORD *)(v17 + 12127) = -1;
          *(_WORD *)(v17 + 12131) = -255;
          *(_QWORD *)(v17 + 12141) = 0x101010101010101;
          *(_QWORD *)(v17 + 12091) = 0x101010101010101;
          *(_QWORD *)(v17 + 12146) = 0x101010101010101;
          *(_QWORD *)(v17 + 12249) = 0x101010101010101;
          *(_QWORD *)(v17 + 12257) = 0x101010101010101;
          *(_QWORD *)(v17 + 12265) = 0x101010101010101;
          if ((*(_DWORD *)(v17 + 12432) & 0x80000000) == 0)
            *(_WORD *)(v17 + 12107) = 257;
          if ((*(_DWORD *)(v17 + 12448) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12109) = 1;
          if ((*(_DWORD *)(v17 + 12464) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12110) = 1;
          if ((*(_DWORD *)(v17 + 12468) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12111) = 1;
          if ((*(_DWORD *)(v17 + 12472) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12112) = 1;
          if ((*(_DWORD *)(v17 + 12476) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12113) = 1;
          if ((*(_DWORD *)(v17 + 12396) & 0x80000000) == 0)
            *(_WORD *)(v17 + 12101) = 257;
          if ((*(_DWORD *)(v17 + 12720) & 0x80000000) == 0 || (*(_DWORD *)(v17 + 12724) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12100) = 8;
          if ((*(_DWORD *)(v17 + 12400) & 0x80000000) == 0)
            *(_WORD *)(v17 + 12103) = 257;
          if (*(_DWORD *)(v17 + 11888))
            *(_BYTE *)(v17 + 12122) = 9;
          if ((*(_DWORD *)(v17 + 12496) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12141) = 1;
          if ((*(_DWORD *)(v17 + 12500) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12142) = 1;
          if ((*(_DWORD *)(v17 + 12504) & 0x80000000) == 0)
            *(_BYTE *)(v17 + 12143) = 1;
          *(_WORD *)(v17 + 12152) = 257;
          *(_DWORD *)(v17 + 12144) = 16843009;
          *(_DWORD *)(v17 + 12147) = 16843009;
        }
      }
    }
    else
    {
      VData = 2229280772;
      log_OutPublic(v47, (uint64_t)"SELECT_BET3", 55006, (uint64_t)"%s%s", v20, v21, v22, v23, "file");
    }
  }
  else
  {
    log_OutPublic(v47, (uint64_t)"SELECT_BET3", 55000, 0, v13, v14, v15, v16, v45);
    VData = 2229280778;
  }
  if (v72)
  {
    ssftriff_reader_ObjClose(v72, v29, v30, v31, v32, v33, v34, v35);
    v72 = 0;
  }
  if ((VData & 0x80000000) != 0)
  {
    if ((VData & 0x7FF01FFF) == 0xA200014)
      VData = 2229280772;
    else
      VData = VData;
    select_bet3_loc_VoiceClose_0(__dst, v17);
  }
  else
  {
    *(_QWORD *)(a4 + 32) = v17;
  }
  return VData;
}

uint64_t select_bet3_loc_ObjcVoiceClose_0(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  _QWORD *v6;

  v6 = 0;
  inited = InitRsrcFunction(a1, a2, &v6);
  if ((inited & 0x80000000) == 0)
    select_bet3_loc_VoiceClose_0(v6, *(_QWORD *)(a3 + 32));
  return inited;
}

uint64_t select_bet3_loc_ParamCheckChange_0(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;

  *a4 = 1;
  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (!cstdlib_strcmp(__s1, "waitfactor") && (LH_atoi(a3) & 0x80000000) != 0)
    {
      result = 2229280783;
LABEL_7:
      *a4 = 0;
      return result;
    }
  }
  else if (*(_QWORD *)(a1 + 896))
  {
    result = 2229280785;
    goto LABEL_7;
  }
  return 0;
}

uint64_t select_bet3_loc_ParamLearnChange_0(uint64_t a1, char *__s1, const char *a3)
{
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  unsigned int v11;

  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (cstdlib_strcmp(__s1, "rate") && cstdlib_strcmp(__s1, "waitfactor"))
    {
      if (!cstdlib_strcmp(__s1, "finalsentencefound"))
      {
        if ((unsigned __int16)LH_atou(a3) == 1)
        {
          paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"waitfactorbackup", *(_DWORD *)(a1 + 64));
          return select_bet3_loc_ParamSet_0(a1, "waitfactor", 0);
        }
        v10 = 0;
        paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"waitfactorbackup", &v10);
        v7 = v10;
        v9 = "waitfactor";
        v8 = a1;
        return select_bet3_loc_ParamSet_0(v8, v9, v7);
      }
    }
    else
    {
      v11 = 0;
      if (cstdlib_strcmp(__s1, "waitfactor")
        || (paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"finalsentencefound", &v11), v11 != 1))
      {
        v7 = (uint64_t)LH_atoi(a3);
        v8 = a1;
        v9 = __s1;
        return select_bet3_loc_ParamSet_0(v8, v9, v7);
      }
    }
    return 0;
  }
  if (*(_QWORD *)(a1 + 896))
    return 2229280785;
  else
    return 0;
}

uint64_t select_bet3_loc_SetSynthParams_0(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  v5 = a2 + 7808;
  result = select_bet3_loc_SetSynthParamString(a1, (uint64_t)"synth_type", (char *)(a2 + 7792));
  if ((result & 0x80000000) == 0)
  {
    result = paramc_ParamSetPermanent(*(_QWORD *)(a1 + 40), (uint64_t)"mrcc_synthparam_ref_ptr", &v5, 8uLL);
    if ((result & 0x80000000) == 0)
    {
      result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voicealpha", *(_DWORD *)(a2 + 128));
      if ((result & 0x80000000) == 0)
      {
        result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voicebeta", *(_DWORD *)(a2 + 132));
        if ((result & 0x80000000) == 0)
        {
          result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voicevol", *(_DWORD *)(a2 + 164));
          if ((result & 0x80000000) == 0)
          {
            result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voicevuvrelamp", *(_DWORD *)(a2 + 140));
            if ((result & 0x80000000) == 0)
            {
              result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voicemvfboost", *(_DWORD *)(a2 + 168));
              if ((result & 0x80000000) == 0)
              {
                result = select_bet3_loc_SetSynthParamString(a1, (uint64_t)"bet2voicevsynthinit", *(char **)(a2 + 7776));
                if ((result & 0x80000000) == 0)
                {
                  result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voiceframesize", *(_DWORD *)(a2 + 152));
                  if ((result & 0x80000000) == 0)
                  {
                    result = select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"bet2voiceorder", *(_DWORD *)(a2 + 144));
                    if ((result & 0x80000000) == 0)
                    {
                      result = select_bet3_loc_SetSynthParamArrayOfBet3_int32_0(a1, *(void **)(a2 + 7784), *(_DWORD *)(a2 + 144) + 1);
                      if ((result & 0x80000000) == 0)
                        return select_bet3_loc_SetSynthParamInt_0(a1, (uint64_t)"voicepitchavghz", *(_DWORD *)(a2 + 184));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t select_bet3_loc_ParamSet_0(uint64_t a1, char *__s1, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (cstdlib_strcmp(__s1, "waitfactor"))
    return 0;
  if ((a3 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 64) = a3;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Set wait factor %d", v5, v6, v7, a3);
    return 0;
  }
  return 2229280783;
}

uint64_t select_bet3_ParseRiff_0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t StringZ;
  _WORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  uint64_t Position;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t ChunkData;
  unsigned int v100;
  int v101;
  uint64_t v102;
  _WORD *v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  size_t v109;
  int v110;
  unsigned __int8 *v111;
  unsigned int v112;
  size_t v113;
  uint64_t v114;
  size_t v115;
  void *v116;
  int *v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  _QWORD *v127;
  uint64_t v128;
  _QWORD *v129;
  _QWORD *v130;
  int v131;
  void *v132;
  unsigned int v133;
  uint64_t v134;
  _BYTE *v135;
  uint64_t v136;
  int v137;
  unsigned __int16 v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  char *v143;
  unsigned __int16 v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  uint64_t v149;
  uint64_t v150;
  char *v151;
  uint64_t v152;
  int v153;
  int RiffStringTable;
  int v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  int v159;
  uint64_t v161;
  int v163;
  int *v164;
  uint64_t *v165;
  uint64_t *v166;
  uint64_t *v167;
  uint64_t *v168;
  uint64_t *v169;
  _BYTE *v170;
  _BYTE *v171;
  _BYTE *v172;
  char *v173;
  _BYTE *v174;
  void *v175;
  _BYTE *v176;
  void *v177;
  unsigned int v178;
  _QWORD *v179;
  char *__s1;
  unsigned __int8 *v181;
  char *__s;
  char *__dst;
  int v186[2];
  char *v187;
  unsigned int v188;
  char __src[4];
  char v190;
  int v191;
  void *v192[32];
  char v193[4];
  char __s2[8];
  uint64_t v195;

  v8 = a7;
  StringZ = 0;
  v195 = *MEMORY[0x24BDAC8D0];
  v14 = (_WORD *)(a2 + 37936);
  v181 = (unsigned __int8 *)(a2 + 11824);
  v191 = 0;
  v190 = 0;
  *(_DWORD *)__src = 0;
  __dst = (char *)&a5[5 * a4];
  v173 = (char *)(a2 + 7792);
  v175 = (void *)(a2 + 7484);
  v177 = (void *)(a2 + 11828);
  v179 = (_QWORD *)(a2 + 7784);
  __s1 = (char *)(a5 + 5);
  v165 = (uint64_t *)(a2 + 11800);
  v166 = (uint64_t *)(a2 + 11792);
  v169 = (uint64_t *)(a2 + 12664);
  v168 = (uint64_t *)(a2 + 12672);
  v167 = (uint64_t *)(a2 + 12680);
  v170 = (_BYTE *)(a2 + 11728);
  v171 = (_BYTE *)(a2 + 10701);
  v172 = (_BYTE *)(a2 + 10958);
  v174 = (_BYTE *)(a2 + 10444);
  v176 = (_BYTE *)(a2 + 10187);
  __s = (char *)(a2 + 9930);
  while ((StringZ & 0x80000000) == 0)
  {
    v15 = ssftriff_reader_OpenChunk(a3, (__int32 *)__src, (unsigned int *)&v191, 0, (uint64_t)a5, a6, a7, a8);
    LODWORD(v16) = v15;
    if ((v15 & 0x80000000) != 0)
    {
      StringZ = v15;
      break;
    }
    cstdlib_strcpy(__dst, __src);
    if (a4 == 1)
    {
      if (cstdlib_strcmp(a5, "FEEX"))
      {
        if (cstdlib_strcmp(a5, "STM3"))
        {
          if (cstdlib_strcmp(__src, "SYNC"))
            goto LABEL_358;
          *(_DWORD *)v193 = 0;
          *(_QWORD *)__s2 = 0;
          if (a6)
          {
            v36 = a6 + ssftriff_reader_GetPosition(a3) - v8;
            *(_QWORD *)__s2 = v36;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v191, __s2, v31, v32, v33, v34, v35);
            if ((ChunkData & 0x80000000) != 0)
              goto LABEL_335;
            v36 = *(_QWORD *)__s2;
          }
          LOBYTE(v192[0]) = 0;
          *(_DWORD *)v193 = 256;
          StringZ = ssftriff_reader_ReadStringZ(a3, v36, v191, 0, v192, (unsigned int *)v193);
          if ((StringZ & 0x80000000) != 0)
          {
LABEL_241:
            v101 = 3;
            goto LABEL_374;
          }
          if (!cstdlib_strcmp((const char *)v192, "SYNTH_TYPE"))
          {
            v100 = *(_DWORD *)v193;
            *(_DWORD *)v193 = 256;
            StringZ = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v191, v100, v192, (unsigned int *)v193);
            if ((StringZ & 0x80000000) != 0)
              goto LABEL_241;
            cstdlib_strcpy(v173, (const char *)v192);
          }
          LODWORD(v16) = StringZ;
        }
        else
        {
          *(_DWORD *)v193 = 0;
          v68 = *(int *)(a2 + 260);
          if (!cstdlib_strcmp(__src, "STC3"))
          {
            LODWORD(v187) = 0;
            *(_QWORD *)__s2 = 0;
            if (a6)
            {
              v163 = v8;
              v98 = a6 + ssftriff_reader_GetPosition(a3) - v8;
              *(_QWORD *)__s2 = v98;
            }
            else
            {
              v16 = ssftriff_reader_GetChunkData(a3, v191, __s2, v69, v70, v71, v72, v73);
              if ((v16 & 0x80000000) != 0)
              {
LABEL_298:
                v101 = 1;
                StringZ = v16;
                goto LABEL_318;
              }
              v163 = v8;
              v98 = *(_QWORD *)__s2;
            }
            v117 = (int *)(a2 + 4 * v68);
            cstdlib_memcpy(v117 + 88, (const void *)(v98 + *(unsigned int *)v193), 4uLL);
            *(_DWORD *)v193 += 4;
            v164 = v117 + 98;
            cstdlib_memcpy(v117 + 98, (const void *)(*(_QWORD *)__s2 + *(unsigned int *)v193), 4uLL);
            v118 = *(_DWORD *)v193;
            *(_DWORD *)v193 += 4;
            v119 = *(_QWORD *)__s2;
            v117[568] = *(_BYTE *)(*(_QWORD *)__s2 + *(unsigned int *)v193) != 0;
            v120 = (v118 + 5);
            *(_DWORD *)v193 = v120;
            cstdlib_memcpy(v117 + 558, (const void *)(v119 + v120), 4uLL);
            v121 = *(_DWORD *)v193 + 4;
            *(_DWORD *)v193 += 4;
            v122 = v117[98];
            if ((int)v122 < 1)
              goto LABEL_288;
            v123 = heap_Calloc(*(_QWORD **)(a1 + 8), v122, 8);
            v124 = a2 + 8 * v68;
            *(_QWORD *)(v124 + 2472) = v123;
            if (!v123)
              LODWORD(v16) = -2065686518;
            if ((v16 & 0x80000000) == 0)
            {
              v125 = heap_Calloc(*(_QWORD **)(a1 + 8), *v164, 8);
              *(_QWORD *)(v124 + 2312) = v125;
              LODWORD(v16) = -2065686518;
              if (v125)
              {
                v121 = *(_DWORD *)v193;
LABEL_288:
                LOBYTE(v192[0]) = 0;
                LODWORD(v187) = 256;
                LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v191, v121, v192, (unsigned int *)&v187);
                if ((v16 & 0x80000000) == 0)
                {
                  v126 = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v192);
                  v127 = (_QWORD *)(a2 + 8 * v68);
                  v127[34] = v126;
                  if (!v126)
                  {
                    v101 = 3;
                    StringZ = 2229280778;
                    goto LABEL_374;
                  }
                  *(_DWORD *)v193 += (_DWORD)v187;
                  if (*v164 >= 1)
                  {
                    v128 = 0;
                    v129 = v127 + 309;
                    v130 = v127 + 289;
                    while (1)
                    {
                      LOBYTE(v192[0]) = 0;
                      LODWORD(v187) = 256;
                      v131 = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v191, *(unsigned int *)v193, v192, (unsigned int *)&v187);
                      if (v131 < 0)
                        break;
                      *(_QWORD *)(*v129 + 8 * v128) = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v192);
                      if (!*(_QWORD *)(*v129 + 8 * v128))
                        goto LABEL_368;
                      *(_DWORD *)v193 += (_DWORD)v187;
                      LOBYTE(v192[0]) = 0;
                      LODWORD(v187) = 256;
                      LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v191, *(unsigned int *)v193, v192, (unsigned int *)&v187);
                      if ((v16 & 0x80000000) != 0)
                        goto LABEL_371;
                      *(_QWORD *)(*v130 + 8 * v128) = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v192);
                      if (!*(_QWORD *)(*v130 + 8 * v128))
                      {
LABEL_368:
                        LODWORD(v16) = -2065686518;
                        goto LABEL_371;
                      }
                      *(_DWORD *)v193 += (_DWORD)v187;
                      if (++v128 >= *v164)
                        goto LABEL_371;
                    }
                    LODWORD(v16) = v131;
                  }
                }
              }
            }
LABEL_371:
            v8 = v163;
            goto LABEL_361;
          }
          if (cstdlib_strcmp(__src, "TRE3"))
          {
            if (cstdlib_strcmp(__src, "PDF3"))
            {
              if (cstdlib_strcmp(__src, "WIN3"))
              {
                if (cstdlib_strcmp(__src, "CBK3"))
                  goto LABEL_358;
                v102 = a2 + 24 * (int)v68 + 5192;
              }
              else
              {
                v136 = a2 + 128 + 4 * v68;
                v137 = *(_DWORD *)(v136 + 304);
                v102 = a2 + 128 + 120 * (int)v68 + 24 * v137 + 3864;
                *(_DWORD *)(v136 + 304) = v137 + 1;
              }
            }
            else
            {
              *(_QWORD *)__s2 = 0;
              if (a6)
              {
                v114 = a6 + ssftriff_reader_GetPosition(a3) - v8;
                *(_QWORD *)__s2 = v114;
              }
              else
              {
                ChunkData = ssftriff_reader_GetChunkData(a3, v191, __s2, v79, v80, v81, v82, v83);
                if ((ChunkData & 0x80000000) != 0)
                {
LABEL_335:
                  StringZ = ChunkData;
                  v101 = 1;
                  v178 = ChunkData;
                  goto LABEL_374;
                }
                v114 = *(_QWORD *)__s2;
              }
              *(_DWORD *)v193 = 256;
              LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, v114, v191, 0, v192, (unsigned int *)v193);
              if ((v16 & 0x80000000) != 0)
              {
                v102 = 0;
              }
              else
              {
                v148 = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), (char *)v192);
                v149 = a2 + 128 + 4 * v68;
                v150 = *(int *)(v149 + 344);
                *(_QWORD *)(a2 + 128 + 40 * (int)v68 + 8 * v150 + 1304) = v148;
                if ((v193[0] & 3) != 0)
                  *(_DWORD *)v193 -= *(_DWORD *)v193 | 0xFFFFFFFC;
                v102 = a2 + 120 * (int)v68 + 24 * (int)v150 + 2792;
                *(_DWORD *)(v149 + 344) = v150 + 1;
              }
            }
          }
          else
          {
            v102 = a2 + 24 * (int)v68 + 2552;
          }
          if ((v16 & 0x80000000) == 0 && v102)
          {
            v192[0] = 0;
            if (a6)
            {
              v151 = (char *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
            }
            else
            {
              v152 = ssftriff_reader_GetChunkData(a3, v191, v192, v74, v75, v76, v77, v78);
              LODWORD(v16) = v152;
              if ((v152 & 0x80000000) != 0)
              {
                v101 = 1;
                v178 = v152;
                StringZ = v152;
                goto LABEL_374;
              }
              v151 = (char *)v192[0];
            }
            v153 = *(_DWORD *)v193;
            *(_QWORD *)(v102 + 8) = &v151[*(unsigned int *)v193];
            *(_DWORD *)(v102 + 16) = v191 - v153;
          }
        }
      }
      else
      {
        if (!cstdlib_strcmp(__src, "VCAT"))
        {
          v192[0] = 0;
          if (a6)
          {
            v192[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
          }
          else
          {
            v108 = ssftriff_reader_GetChunkData(a3, v191, v192, v42, v43, v44, v45, v46);
            if ((v108 & 0x80000000) != 0)
              return v108;
          }
          v27 = a1;
          v28 = a2;
          v29 = a3;
          v30 = 2;
LABEL_258:
          v97 = select_bet3_ParseRiff_0(v27, v28, v29, v30, a5, 0, 0);
LABEL_259:
          LODWORD(v16) = v97;
          goto LABEL_361;
        }
        if (!cstdlib_strcmp(__src, "VBOP"))
        {
          v192[0] = 0;
          if (a6)
          {
            v67 = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
            v192[0] = v67;
          }
          else
          {
            v16 = ssftriff_reader_GetChunkData(a3, v191, v192, v47, v48, v49, v50, v51);
            if ((v16 & 0x80000000) != 0)
              return v16;
            v67 = v192[0];
          }
          if (v191 >= 0xF8)
            v115 = 248;
          else
            v115 = v191;
          v116 = v177;
LABEL_279:
          cstdlib_memcpy(v116, v67, v115);
          goto LABEL_361;
        }
        if (cstdlib_strcmp(__src, "PRE3"))
        {
          if (cstdlib_strcmp(__src, "TRA3"))
          {
            if (cstdlib_strcmp(__src, "PHM3"))
              goto LABEL_358;
            v192[0] = 0;
            if (a6)
            {
              v67 = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
              v192[0] = v67;
            }
            else
            {
              v16 = ssftriff_reader_GetChunkData(a3, v191, v192, v62, v63, v64, v65, v66);
              if ((v16 & 0x80000000) != 0)
                return v16;
              v67 = v192[0];
            }
            if (v191 >= 0x100)
              v115 = 256;
            else
              v115 = v191;
            v116 = v175;
            goto LABEL_279;
          }
          *(_WORD *)__s2 = 0;
          v192[0] = 0;
          if (a6)
          {
            v192[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
          }
          else
          {
            v16 = ssftriff_reader_GetChunkData(a3, v191, v192, v57, v58, v59, v60, v61);
            if ((v16 & 0x80000000) != 0)
              return v16;
          }
          if (v191 >= 2)
          {
            v144 = 0;
            do
            {
              cstdlib_memcpy(__s2, (char *)v192[0] + 2 * v144, 2uLL);
              if (*(unsigned __int16 *)__s2 < 8u)
                *(_DWORD *)(a2 + 4 * *(unsigned __int16 *)__s2 + 12704) = 1;
              else
                log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Unknown transition feature: %u for %s", v145, v146, v147, *(unsigned __int16 *)__s2);
              ++v144;
            }
            while (v191 >> 1 > v144);
          }
        }
        else
        {
          *(_WORD *)__s2 = 0;
          v192[0] = 0;
          if (a6)
          {
            v192[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
          }
          else
          {
            v16 = ssftriff_reader_GetChunkData(a3, v191, v192, v52, v53, v54, v55, v56);
            if ((v16 & 0x80000000) != 0)
              return v16;
          }
          if (v191 >= 2)
          {
            v138 = 0;
            do
            {
              cstdlib_memcpy(__s2, (char *)v192[0] + 2 * v138, 2uLL);
              if (*(unsigned __int16 *)__s2 < 0x47u)
                *(_DWORD *)(a2 + 4 * *(unsigned __int16 *)__s2 + 12376) = 1;
              else
                log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Unknown preselection feature: %u for %s", v139, v140, v141, *(unsigned __int16 *)__s2);
              ++v138;
            }
            while (v191 >> 1 > v138);
          }
        }
      }
    }
    else if (a4)
    {
      if (cstdlib_strcmp(a5, "FEEX") || cstdlib_strcmp(__s1, "VCAT"))
      {
LABEL_358:
        cstdlib_strcpy((char *)v192, "");
        v155 = 0;
        do
        {
          cstdlib_strcat((char *)v192, "/");
          cstdlib_strcat((char *)v192, &a5[5 * (unsigned __int16)v155++]);
        }
        while (a4 >= (unsigned __int16)v155);
        log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"Unknown data: %s for %s", v156, v157, v158, (uint64_t)v192);
        goto LABEL_361;
      }
      v192[0] = 0;
      if (a6)
      {
        v192[0] = (void *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
      }
      else
      {
        v16 = ssftriff_reader_GetChunkData(a3, v191, v192, v37, v38, v39, v40, v41);
        if ((v16 & 0x80000000) != 0)
          return v16;
      }
      if (cstdlib_strcmp(__src, "ALPH"))
      {
        if (cstdlib_strcmp(__src, "VOIC"))
        {
          if (cstdlib_strcmp(__src, "COVO"))
          {
            if (cstdlib_strcmp(__src, "SAFE"))
            {
              if (cstdlib_strcmp(__src, "PLOS"))
              {
                if (cstdlib_strcmp(__src, "DIFF"))
                {
                  if (cstdlib_strcmp(__src, "GENF"))
                  {
                    if (cstdlib_strcmp(__src, "TAGA"))
                    {
                      if (cstdlib_strcmp(__src, "BTOA"))
                        goto LABEL_358;
                      v103 = v192[0];
                      v104 = v191;
                      v105 = a1;
                      v106 = a3;
                      v107 = v165;
                    }
                    else
                    {
                      v103 = v192[0];
                      v104 = v191;
                      v105 = a1;
                      v106 = a3;
                      v107 = v166;
                    }
                    RiffStringTable = uselect_LoadRiffStringTable(v105, v106, v103, v104, v107);
                  }
                  else
                  {
                    RiffStringTable = select_bet3_LoadRiffGenericFeatureMap_0(a1, a3, (unsigned __int16 *)v192[0], v191, v169, v168, v167);
                  }
                  goto LABEL_356;
                }
                *(_DWORD *)__s2 = 64;
                v132 = v192[0];
                v133 = v191;
                v134 = a3;
                v135 = v170;
              }
              else
              {
                *(_DWORD *)__s2 = 257;
                v132 = v192[0];
                v133 = v191;
                v134 = a3;
                v135 = v171;
              }
            }
            else
            {
              *(_DWORD *)__s2 = 257;
              v132 = v192[0];
              v133 = v191;
              v134 = a3;
              v135 = v172;
            }
          }
          else
          {
            *(_DWORD *)__s2 = 257;
            v132 = v192[0];
            v133 = v191;
            v134 = a3;
            v135 = v174;
          }
        }
        else
        {
          *(_DWORD *)__s2 = 257;
          v132 = v192[0];
          v133 = v191;
          v134 = a3;
          v135 = v176;
        }
        RiffStringTable = ssftriff_reader_ReadStringZ(v134, (uint64_t)v132, v133, 0, v135, (unsigned int *)__s2);
LABEL_356:
        LODWORD(v16) = RiffStringTable;
        goto LABEL_361;
      }
      *(_DWORD *)__s2 = 257;
      LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v192[0], v191, 0, __s, (unsigned int *)__s2);
      if ((v16 & 0x80000000) == 0)
      {
        *(_WORD *)v181 = 255;
        if (cstdlib_strlen(__s))
        {
          v109 = 0;
          v110 = 0;
          do
          {
            v111 = (unsigned __int8 *)(a2 + v109 + 9930);
            v112 = *v111;
            if (v112 < *v181)
            {
              *v181 = v112;
              v112 = *v111;
            }
            if (v112 > v181[1])
            {
              v181[1] = v112;
              v112 = *v111;
            }
            *(_BYTE *)(a2 + v112 + 11472) = v110;
            v109 = (v110 + 1);
            v113 = cstdlib_strlen(__s);
            v110 = v109;
          }
          while (v113 > v109);
        }
      }
    }
    else if (cstdlib_strcmp(__src, "VCFG"))
    {
      if (cstdlib_strcmp(__src, "EQUA"))
      {
        if (cstdlib_strcmp(__src, "FEEX"))
        {
          if (!cstdlib_strcmp(__src, "STM3"))
          {
            Position = ssftriff_reader_GetPosition(a3);
            v192[0] = 0;
            v97 = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * (unsigned __int16)*v14 + 37728), v192, v92, v93, v94, v95, v96);
            if ((v97 & 0x80000000) == 0)
            {
              ++*v14;
              LODWORD(v16) = select_bet3_ParseRiff_0(a1, a2, a3, 1, a5, v192[0], Position);
              ++*(_DWORD *)(a2 + 260);
              goto LABEL_361;
            }
            goto LABEL_259;
          }
          if (cstdlib_strcmp(__src, "SYNT"))
            goto LABEL_358;
        }
        v27 = a1;
        v28 = a2;
        v29 = a3;
        v30 = 1;
        goto LABEL_258;
      }
      LODWORD(v16) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * (unsigned __int16)*v14 + 37728), v179, v22, v23, v24, v25, v26);
      if ((v16 & 0x80000000) == 0)
        ++*v14;
    }
    else
    {
      v188 = 0;
      *(_QWORD *)v186 = 0;
      v187 = 0;
      if (a6)
      {
        *(_QWORD *)v186 = a6 + ssftriff_reader_GetPosition(a3) - v8;
      }
      else
      {
        v16 = ssftriff_reader_GetChunkData(a3, v191, v186, v17, v18, v19, v20, v21);
        if ((v16 & 0x80000000) != 0)
          goto LABEL_298;
      }
      v84 = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), "PHRASE");
      *(_QWORD *)(a2 + 208) = v84;
      if (!v84)
        goto LABEL_317;
      *(_DWORD *)(a2 + 216) = 1000;
      v85 = v191;
      if (v191)
      {
        v86 = 0;
        do
        {
          LOBYTE(v192[0]) = 0;
          __s2[0] = 0;
          v188 = 64;
          LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v186, v85, v86, __s2, &v188);
          if ((v16 & 0x80000000) == 0 && v86 < v191)
          {
            v86 += v188;
            v188 = 256;
            LODWORD(v16) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v186, v191, v86, v192, &v188);
          }
          if ((v16 & 0x80000000) != 0)
            break;
          v87 = v188;
          cstdlib_strcpy(v193, "bet3voiceoverride.");
          cstdlib_strcat(v193, __s2);
          if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)v193, &v187) & 0x80000000) != 0 || !v187 || !*v187)
            v187 = (char *)v192;
          if (!cstdlib_strcmp(__s2, "ALPHA"))
            *(_DWORD *)(a2 + 128) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "BETA"))
            *(_DWORD *)(a2 + 132) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "VUV_REL_AMP"))
            *(_DWORD *)(a2 + 140) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "VOL"))
            *(_DWORD *)(a2 + 164) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "MVF_BOOST"))
            *(_DWORD *)(a2 + 168) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FS"))
            *(_DWORD *)(a2 + 136) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "ORDER"))
            *(_DWORD *)(a2 + 144) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE"))
            *(_DWORD *)(a2 + 152) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SPEECH_F0_MEAN"))
            *(_DWORD *)(a2 + 184) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "PDF_VARIANCE_TYPE"))
            *(_DWORD *)(a2 + 200) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "BREAKER"))
          {
            v88 = *(_QWORD *)(a2 + 208);
            v89 = a1;
            if (v88)
            {
              heap_Free(*(_QWORD **)(a1 + 8), v88);
              v89 = a1;
            }
            v90 = BET3FXD__heap_StrDup(*(_QWORD **)(v89 + 8), v187);
            *(_QWORD *)(a2 + 208) = v90;
            if (!v90)
            {
              LODWORD(v16) = -2065686518;
              break;
            }
          }
          if (!cstdlib_strcmp(__s2, "BRK_LENGTH"))
            *(_DWORD *)(a2 + 216) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "BRK_TC"))
            *(_DWORD *)(a2 + 220) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "BRK_ZPAD"))
            *(_DWORD *)(a2 + 224) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "ALGN_ST"))
            *(_DWORD *)(a2 + 240) = LH_atoi(v187) != 0;
          if (!cstdlib_strcmp(__s2, "ALGN_PH"))
            *(_DWORD *)(a2 + 244) = LH_atoi(v187) != 0;
          if (!cstdlib_strcmp(__s2, "VSYNTH"))
            *(_QWORD *)(a2 + 7776) = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), v187);
          if (!cstdlib_strcmp(__s2, "FFTSZ"))
            *(_DWORD *)(a2 + 7808) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "EN_MEAN"))
            *(_DWORD *)(a2 + 7812) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FEED_EN_MEAN_LOOKAHEAD"))
            *(_DWORD *)(a2 + 7820) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "COUNT_UV_DISTANCE"))
            *(_DWORD *)(a2 + 7816) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SAMPLE_RATE"))
            *(_DWORD *)(a2 + 7824) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENERGY"))
            *(_DWORD *)(a2 + 7828) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_SIZE"))
            *(_DWORD *)(a2 + 7832) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SPCPAR_FREQWARP"))
            *(_DWORD *)(a2 + 7836) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENHANCE_ALPHA"))
            *(_DWORD *)(a2 + 7840) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENHANCE_ALPHA_UNVOICED"))
            *(_DWORD *)(a2 + 7844) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE_MRCC"))
            *(_DWORD *)(a2 + 7848) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_PHS_EXTRAP_USE"))
            *(_DWORD *)(a2 + 7852) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_NOISE_FREQ_TH"))
            *(_DWORD *)(a2 + 7856) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_USE"))
            *(_DWORD *)(a2 + 7860) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_MVF_USE"))
            *(_DWORD *)(a2 + 7864) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_LO"))
            *(_DWORD *)(a2 + 7868) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_FREQNOISE_HI"))
            *(_DWORD *)(a2 + 7872) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_UNIFORM"))
            *(_DWORD *)(a2 + 7876) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_USE"))
            *(_DWORD *)(a2 + 7880) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_MVF_USE"))
            *(_DWORD *)(a2 + 7884) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_MIXHARM_LO"))
            *(_DWORD *)(a2 + 7888) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_MIXHARM_HI"))
            *(_DWORD *)(a2 + 7892) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_RES_LO"))
            *(_DWORD *)(a2 + 7896) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_RES_HI"))
            *(_DWORD *)(a2 + 7900) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_ALIGN_CUTOFF_FREQ"))
            *(_DWORD *)(a2 + 7904) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF"))
            *(_DWORD *)(a2 + 7908) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ATTENUATE_UV"))
            *(_DWORD *)(a2 + 7912) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_SKIP_WEAK_HARM_RATIO"))
            *(_DWORD *)(a2 + 7916) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_SMOOTH_WIN"))
            *(_DWORD *)(a2 + 7940) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_THR"))
            *(_DWORD *)(a2 + 7944) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_RATIO_EN_THR"))
            *(_DWORD *)(a2 + 7948) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_MVF_THR"))
            *(_DWORD *)(a2 + 7952) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_BY_LOW_EN"))
            *(_DWORD *)(a2 + 7956) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_BY_RATIO_EN"))
            *(_DWORD *)(a2 + 7960) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_0"))
            *(_DWORD *)(a2 + 7964) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_1"))
            *(_DWORD *)(a2 + 7968) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_2"))
            *(_DWORD *)(a2 + 7972) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEBUZZ_PROCESS_MVF_3"))
            *(_DWORD *)(a2 + 7976) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_BITS"))
            *(_DWORD *)(a2 + 7980) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "PHSPAR_USE"))
            *(_DWORD *)(a2 + 7984) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_USE"))
            *(_DWORD *)(a2 + 7988) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "USE_LOG2"))
            *(_DWORD *)(a2 + 7992) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENHANCE_POWSPC"))
            *(_DWORD *)(a2 + 7996) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_ATTENUATE"))
            *(_DWORD *)(a2 + 8000) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_ATTENUATE_LO"))
            *(_DWORD *)(a2 + 8004) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_ATTENUATE_HI"))
            *(_DWORD *)(a2 + 8008) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_APPLY_DEEMP"))
            *(_DWORD *)(a2 + 8012) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_HI_RES_ALIGN"))
            *(_DWORD *)(a2 + 8016) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_FAST_AUX_HARM"))
            *(_DWORD *)(a2 + 8020) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_FIX_OLA"))
            *(_DWORD *)(a2 + 8024) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DC_GUARD_VOICED"))
            *(_DWORD *)(a2 + 8028) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DC_GUARD_UNVOICED"))
            *(_DWORD *)(a2 + 8032) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_NYQUIST_GUARD"))
            *(_DWORD *)(a2 + 8036) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "PHSPAR_SIZE"))
            *(_DWORD *)(a2 + 8040) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "PHSPAR_FLIP"))
            *(_DWORD *)(a2 + 8044) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "AMPPAR_ENERGY_NORM_TH"))
            *(_DWORD *)(a2 + 8048) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SPCPAR_FREQWARP_ALPHA"))
            *(_DWORD *)(a2 + 8052) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_PHS_ALIGN_WITH_CONST"))
            *(_DWORD *)(a2 + 8056) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_AUXNOISE_NORM_GLOBAL"))
            *(_DWORD *)(a2 + 8060) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_DEEMP_COEF"))
            *(_DWORD *)(a2 + 8064) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_USE_NOISE_MODULATION"))
            *(_DWORD *)(a2 + 8068) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "SYN_NOISE_MODULATION_FACTOR"))
            *(_DWORD *)(a2 + 8072) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "MAX_FRAME_SIZE"))
            *(_DWORD *)(a2 + 8076) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "MIN_FRAME_SIZE"))
            *(_DWORD *)(a2 + 8080) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "MIN_FFT_SIZE"))
            *(_DWORD *)(a2 + 8084) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE_INC_NUM"))
            *(_DWORD *)(a2 + 8088) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FRAME_SIZE_DEC_NUM"))
            *(_DWORD *)(a2 + 8092) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "ANAL_FFT_SIZE"))
            *(_DWORD *)(a2 + 8096) = LH_atoi(v187);
          if (!cstdlib_strcmp(__s2, "FFT_SIZE"))
            *(_DWORD *)(a2 + 8100) = LH_atoi(v187);
          v86 += v87;
          v85 = v191;
        }
        while (v86 < v191);
      }
      *(_WORD *)(a2 + 160) = 0;
      *(_WORD *)(a2 + 172) = 0;
      *(_QWORD *)(a2 + 176) = 0;
      cstdlib_strcpy(v193, "bet3voiceoverride.");
      cstdlib_strcat(v193, "BREAKER");
      if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)v193, &v187) & 0x80000000) == 0)
      {
        v142 = *(_QWORD *)(a2 + 208);
        if (v142)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v142);
          *(_QWORD *)(a2 + 208) = 0;
        }
        v143 = BET3FXD__heap_StrDup(*(_QWORD **)(a1 + 8), v187);
        *(_QWORD *)(a2 + 208) = v143;
        if (!v143)
        {
LABEL_317:
          v101 = 3;
          LODWORD(v16) = v178;
          StringZ = 2229280778;
LABEL_318:
          v178 = v16;
LABEL_374:
          if (v101 != 3)
            return v178;
          break;
        }
      }
      cstdlib_strcpy(v193, "bet3voiceoverride.");
      cstdlib_strcat(v193, "BRK_LENGTH");
      if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)v193, &v187) & 0x80000000) == 0)
        *(_DWORD *)(a2 + 216) = LH_atoi(v187);
    }
LABEL_361:
    v159 = ssftriff_reader_CloseChunk(a3);
    if ((int)v16 > -1 && v159 < 0)
      StringZ = v159;
    else
      StringZ = v16;
  }
  if ((StringZ & 0x1FFF) == 0x14)
    v161 = 0;
  else
    v161 = StringZ;
  v16 = StringZ;
  if ((v161 & 0x80000000) == 0)
  {
    *__dst = 0;
    return v161;
  }
  return v16;
}

_QWORD *select_bet3_loc_VoiceClose_0(_QWORD *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t **v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _WORD *v27;
  unint64_t v28;

  if (a2)
  {
    v3 = (uint64_t)result;
    v4 = *(uint64_t **)(a2 + 11792);
    if (v4 && *v4)
    {
      v5 = 0;
      v6 = 1;
      do
      {
        *(_QWORD *)(a2 + 8 * v5 + 5432) = 0;
        v4 = *(uint64_t **)(a2 + 11792);
        v5 = v6;
      }
      while (v4[v6++]);
    }
    uselect_FreeRiffStringTable(result, v4);
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)(a2 + 11800));
    v8 = *(uint64_t **)(a2 + 12664);
    v9 = *(uint64_t ***)(a2 + 12672);
    v10 = *(uint64_t **)(a2 + 12680);
    if (v8)
    {
      v11 = *v8;
      if (*v8)
      {
        v12 = 0;
        do
        {
          heap_Free(*(_QWORD **)(v3 + 8), v11);
          v11 = v8[(unsigned __int16)++v12];
        }
        while (v11);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v8);
    }
    if (v9)
    {
      v13 = *v9;
      if (*v9)
      {
        v14 = 0;
        v15 = v9;
        do
        {
          v16 = *v13;
          if (*v13)
          {
            v17 = 0;
            do
            {
              heap_Free(*(_QWORD **)(v3 + 8), v16);
              ++v17;
              v13 = *v15;
              v16 = (*v15)[(unsigned __int16)v17];
            }
            while (v16);
          }
          heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v13);
          v15 = &v9[(unsigned __int16)++v14];
          v13 = *v15;
        }
        while (*v15);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v9);
    }
    if (v10)
    {
      v18 = *v10;
      if (*v10)
      {
        v19 = 0;
        do
        {
          heap_Free(*(_QWORD **)(v3 + 8), v18);
          v18 = v10[(unsigned __int16)++v19];
        }
        while (v18);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v10);
    }
    BET3FXD__DeInitVData((void *)v3, a2 + 8112);
    BET3FXD__DeInitVParam(v3, (_QWORD *)(a2 + 128));
    v27 = (_WORD *)(a2 + 37936);
    if (*(_WORD *)(a2 + 37936))
    {
      v28 = 0;
      do
        ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a2 + 37728 + 8 * v28++), v20, v21, v22, v23, v24, v25, v26);
      while (v28 < (unsigned __int16)*v27);
    }
    *v27 = 0;
    *(_BYTE *)a2 = 0;
    return heap_Free(*(_QWORD **)(v3 + 8), a2);
  }
  return result;
}

uint64_t select_bet3_LoadRiffGenericFeatureMap_0(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t i;
  uint64_t *v28;
  uint64_t *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v34;
  char __dst[256];
  uint64_t v36;

  v11 = a1;
  v36 = *MEMORY[0x24BDAC8D0];
  v12 = *a3;
  v13 = heap_Calloc(*(_QWORD **)(a1 + 8), v12 + 1, 8);
  *a5 = v13;
  if (v13)
  {
    v14 = heap_Calloc(*(_QWORD **)(v11 + 8), v12 + 1, 8);
    *a6 = v14;
    if (v14)
    {
      v15 = heap_Calloc(*(_QWORD **)(v11 + 8), v12 + 1, 8);
      *a7 = v15;
      if (v15)
      {
        if (!(_DWORD)v12)
          return 0;
        v16 = 0;
        v17 = 2;
        v28 = a5;
        v29 = a7;
        v30 = v12;
        while (1)
        {
          __dst[0] = 0;
          v34 = 256;
          v18 = ssftriff_reader_ReadStringZ(a2, (uint64_t)a3, a4, v17, __dst, &v34);
          v19 = v34;
          *(_QWORD *)(*a5 + 8 * v16) = BET3FXD__heap_StrDup(*(_QWORD **)(v11 + 8), __dst);
          if (!*(_QWORD *)(*a5 + 8 * v16))
            break;
          v20 = v16;
          v21 = v19 + v17;
          v31 = *(unsigned __int16 *)((char *)a3 + v21);
          *(_QWORD *)(*a6 + 8 * v16) = heap_Calloc(*(_QWORD **)(v11 + 8), v31 + 1, 8);
          if (!*(_QWORD *)(*a6 + 8 * v16))
            break;
          *(_QWORD *)(*a7 + 8 * v16) = heap_Calloc(*(_QWORD **)(v11 + 8), v31 + 1, 1);
          if (!*(_QWORD *)(*a7 + 8 * v16))
            break;
          v17 = v21 + 2;
          if ((_DWORD)v31)
          {
            v22 = v11;
            v23 = 0;
            while (1)
            {
              v24 = v17;
              __dst[0] = 0;
              v34 = 256;
              v18 = ssftriff_reader_ReadStringZ(a2, (uint64_t)a3, a4, v17, __dst, &v34);
              v25 = v34;
              *(_QWORD *)(*(_QWORD *)(*a6 + 8 * v20) + v23) = BET3FXD__heap_StrDup(*(_QWORD **)(v22 + 8), __dst);
              if (!*(_QWORD *)(*(_QWORD *)(*a6 + 8 * v20) + v23))
                return 2229280778;
              v17 += v25;
              v23 += 8;
              if (8 * v31 == v23)
              {
                a5 = v28;
                a7 = v29;
                for (i = 0; i != v31; ++i)
                  *(_BYTE *)(*(_QWORD *)(*v29 + 8 * v20) + i) = *((_BYTE *)a3 + v24 + v25 + i);
                v17 = v24 + v25 + i;
                v11 = v22;
                break;
              }
            }
          }
          v16 = v20 + 1;
          if ((int)v20 + 1 >= v30)
            return v18;
        }
      }
    }
  }
  return 2229280778;
}

uint64_t select_bet3_loc_SetSynthParamString(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = paramc_ParamSetStr(*(_QWORD *)(a1 + 40), a2, a3);
  if ((v8 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%s%s%x", v4, v5, v6, v7, "parameter");
  return v8;
}

uint64_t select_bet3_loc_SetSynthParamInt_0(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = paramc_ParamSetInt(*(_QWORD *)(a1 + 40), a2, a3);
  if ((v8 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%d%s%x", v4, v5, v6, v7, "parameter");
  return v8;
}

uint64_t select_bet3_loc_SetSynthParamArrayOfBet3_int32_0(uint64_t a1, void *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (!a2)
    return 0;
  v8 = paramc_ParamSet(*(_QWORD *)(a1 + 40), (uint64_t)"bet3cepstralequalizer", a2, (4 * a3));
  if ((v8 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%p%s%d%s%d", v4, v5, v6, v7, "parameter");
  return v8;
}

uint64_t BET3FXD__ParamGenStart(uint64_t a1, int *a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int *v26;
  const char **v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  BOOL v38;
  int v39;
  int v40;
  uint64_t v41;
  _DWORD *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t i;
  uint64_t v54;
  uint64_t v55;
  int v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  __int16 v75;
  uint64_t v76;
  uint64_t v77;
  int *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int *v89;
  uint64_t v90;
  _QWORD *v91;
  int *v92;
  int v93;
  unsigned __int16 *v94;
  uint64_t v95;
  int *v96;

  v6 = (char *)(a1 + 56);
  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(a1 + 632);
  if (v8)
  {
    heap_Free(*(_QWORD **)(v7 + 8), v8);
    *(_QWORD *)(a1 + 632) = 0;
  }
  v9 = *(_QWORD *)(a1 + 640);
  if (v9)
  {
    heap_Free(*(_QWORD **)(v7 + 8), v9);
    *(_QWORD *)(a1 + 640) = 0;
  }
  result = BET3FXD__InitUttModel(v7, v6, a2, *(__int16 *)(*(_QWORD *)(a1 + 8) + 10));
  if ((result & 0x80000000) != 0)
    return result;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a3 + 32);
  v16 = *(_DWORD *)(a3 + 28);
  if (v16 >= 1 && v16 < *(_DWORD *)(a1 + 620))
  {
    BET3FXD__log_select_Error(v7, 55018, (uint64_t)"Specified length of generated speech is too short (this sentence is composed from %d states), specify more than %d milliseconds\n", v11, v12, v13, v14, v15);
    return 2229280775;
  }
  if (*(int *)(a1 + 608) < 1)
    goto LABEL_75;
  v17 = 0;
  v86 = 0;
  v87 = 0;
  v82 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 1784);
  v95 = (uint64_t)(a2 + 152);
  v18 = *(_DWORD *)(a1 + 32);
  v80 = v7;
  v81 = a3 + 1304;
  v79 = -8388608;
  v85 = a3;
  v90 = (uint64_t)a2;
  do
  {
    v19 = *(_QWORD *)(a1 + 600);
    v20 = (int *)(v19 + 528 * v17);
    v88 = v19;
    v96 = v20;
    if (v18 >= 1)
    {
      v21 = 0;
      v22 = v81;
      do
      {
        v23 = a3 + 4 * v21;
        v24 = *(_DWORD *)(v23 + 344);
        if (v24 < 1)
        {
          LODWORD(v25) = 0;
        }
        else
        {
          v25 = 0;
          v26 = (int *)(v23 + 344);
          v27 = (const char **)(a3 + 8 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 248) + *v20) + 5304);
          do
          {
            v28 = *(const char **)(v22 + 8 * v25);
            if (v28 && *v27)
            {
              if (!cstdlib_strcmp(v28, *v27))
                goto LABEL_22;
              v24 = *v26;
            }
            ++v25;
          }
          while (v25 < v24);
          LODWORD(v25) = 0;
LABEL_22:
          v19 = v88;
          v20 = v96;
        }
        *(_DWORD *)(v19 + 528 * v17 + 4 * v21++ + 32) = v25;
        v22 += 40;
      }
      while (v21 < *(int *)(a1 + 32));
    }
    BET3FXD__log_select_Diag(v7, 21, (uint64_t)"[phoneme %d]\n");
    v83 = v17;
    if (v82)
    {
      if (*(_DWORD *)(a3 + 116))
      {
        *(_DWORD *)(v19 + 528 * v17 + 8) = BET3FXD__TreeSearch(*(_QWORD *)(a1 + 8), v17, v95, 0, 0);
        BET3FXD__log_select_Diag(v7, 6, (uint64_t)"DUR pdf id %d\n");
        result = BET3FXD__FindDurPDF((uint64_t)v96, a2, *(__int16 *)(a1 + 16), 0);
        if ((result & 0x80000000) != 0)
          return result;
        v34 = BET3FXD__div_int32_int32_to_Q8_24(*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1784) + 2 * *v96), *(_DWORD *)(a3 + 24));
        if (v34)
        {
          v35 = v34;
          if (*a2 < 1)
          {
            v36 = 0;
          }
          else
          {
            v36 = 0;
            v37 = 2;
            do
            {
              v36 += BET3FXD__int32_to_Q12_20(*(_DWORD *)(*(_QWORD *)(v88 + 528 * v83 + 16) + 4 * v37));
              v38 = v37++ <= *a2;
            }
            while (v38);
          }
          v39 = v35 + v79;
          v40 = BET3FXD__div_Q8_24_Q12_20_to_Q8_24(v35 + v79, v36);
          v19 = v88;
          v41 = v88 + 528 * v83;
          *(_DWORD *)(v41 + 24) = 0;
          v42 = (_DWORD *)(v41 + 24);
          if (*a2 < 1)
          {
            v52 = 0;
          }
          else
          {
            v43 = v40;
            v93 = v39;
            v44 = v88 + 528 * v83;
            v47 = *(_QWORD *)(v44 + 16);
            v46 = (uint64_t *)(v44 + 16);
            v45 = v47;
            v48 = 2;
            do
            {
              v49 = BET3FXD__mul_int32_Q8_24_to_Q8_24(*(_DWORD *)(v45 + 4 * v48), v43);
              v50 = BET3FXD__Q8_24_to_int32(v49 + 0x7FFFFF);
              if (v50 <= 1)
                v51 = 1;
              else
                v51 = v50;
              v45 = *v46;
              *(_DWORD *)(*v46 + 4 * v48) = v51;
              v52 = *v42 + v51;
              *v42 = v52;
              v38 = v48++ <= *a2;
            }
            while (v38);
            v19 = v88;
            v39 = v93;
          }
          v79 = v39 - BET3FXD__int32_to_Q8_24(v52);
          v17 = v83;
        }
        else
        {
          v19 = v88;
        }
        *(_DWORD *)(a1 + 624) += *(_DWORD *)(v19 + 528 * v17 + 24);
        goto LABEL_51;
      }
      if (*(_DWORD *)(a3 + 112))
      {
        BET3FXD__log_select_Error(v7, 55017, (uint64_t)"State level segmentation is not currently supported\n", v29, v30, v31, v32, v33);
        goto LABEL_51;
      }
    }
    *(_DWORD *)(v19 + 528 * v17 + 8) = BET3FXD__TreeSearch(*(_QWORD *)(a1 + 8), v17, v95, 0, 0);
    BET3FXD__log_select_Diag(v7, 6, (uint64_t)"DUR pdf id %d\n");
    if (!*(_DWORD *)(a3 + 28))
    {
      result = BET3FXD__FindDurPDF((uint64_t)v96, a2, *(__int16 *)(a1 + 16), 0);
      if ((result & 0x80000000) != 0)
        return result;
      SetSilenceDuration_0(a1, a2, a3, v96);
      *(_DWORD *)(a1 + 624) += *(_DWORD *)(v19 + 528 * v17 + 24);
    }
LABEL_51:
    v18 = *(_DWORD *)(a1 + 32);
    if (v18 >= 1)
    {
      for (i = 0; i < v18; ++i)
      {
        v54 = *(_QWORD *)(a1 + 24);
        if (!*(_DWORD *)(v54 + 312 * i + 264))
        {
          if (*(_DWORD *)(v54 + 312 * i + 272))
          {
            v55 = a1 + 8 * i;
            v56 = *a2 * v83;
            v86 = *(_QWORD *)(*(_QWORD *)(v55 + 304) + 8 * v56);
            v87 = *(_QWORD *)(*(_QWORD *)(v55 + 224) + 8 * v56);
          }
          v57 = (char *)a2 + 2 * i;
          if (*((_WORD *)v57 + 396))
          {
            v58 = v7;
            v59 = 0;
            v60 = 0;
            v94 = (unsigned __int16 *)(v57 + 792);
            v61 = v19 + 528 * v83;
            v62 = (_QWORD *)(v61 + 8 * i);
            v92 = &a2[2 * i + 178];
            v91 = v62 + 9;
            v84 = &a2[i + 1];
            v63 = v62 + 19;
            v64 = v62 + 29;
            v89 = (unsigned int *)(v61 + 4 * i + 32);
            while (1)
            {
              v65 = *(unsigned __int16 *)(*(_QWORD *)v92 + v59);
              *(_DWORD *)(*v91 + 4 * v65) = BET3FXD__TreeSearch(*(_QWORD *)(a1 + 8), *v96, v95, i, v60);
              BET3FXD__log_select_Diag(v58, 6, (uint64_t)"%s pdf state %d id %d\n");
              v66 = *(_QWORD *)(a1 + 24);
              if (*(_DWORD *)(v66 + 312 * i + 272))
              {
                v67 = v65 - 2 + (v65 - 2) * *v84;
                *(_QWORD *)(*v63 + 8 * v65) = v87 + 4 * v67;
                *(_QWORD *)(*v63 + 8 * v65) -= 4;
                *(_QWORD *)(*v64 + 8 * v65) = v86 + 4 * v67;
                *(_QWORD *)(*v64 + 8 * v65) -= 4;
                result = BET3FXD__FindMsdPDF(i, v65, (uint64_t)v96, v90, v85);
                if ((result & 0x80000000) != 0)
                  return result;
              }
              else if (*(_DWORD *)(v66 + 312 * i + 268))
              {
                v68 = *(_QWORD *)(a1 + 632);
                v69 = *(_QWORD *)(a1 + 640);
                if (!v68)
                {
                  if (v69)
                  {
                    v68 = 0;
                  }
                  else
                  {
                    v70 = *(_DWORD *)(a1 + 608) * *v94 * *(unsigned __int16 *)(v90 + 396);
                    v71 = v70 + v70 * *(unsigned __int16 *)(v90 + 402);
                    v72 = heap_Calloc(*(_QWORD **)(v58 + 8), v71, 4);
                    *(_QWORD *)(a1 + 632) = v72;
                    if (!v72)
                      return 2229280778;
                    v73 = heap_Calloc(*(_QWORD **)(v80 + 8), v71, 4);
                    *(_QWORD *)(a1 + 640) = v73;
                    if (!v73)
                      return 2229280778;
                    v69 = v73;
                    *(_DWORD *)(a1 + 648) = 0;
                    v68 = *(_QWORD *)(a1 + 632);
                  }
                }
                result = BET3FXD__FindContPDF(i, v65, (uint64_t)v96, v90, *v89, v68, v69, (_DWORD *)(a1 + 648));
                if ((result & 0x80000000) != 0)
                  return result;
              }
              ++v60;
              v59 += 16;
              if (v60 >= *v94)
              {
                v18 = *(_DWORD *)(a1 + 32);
                a3 = v85;
                a2 = (int *)v90;
                v7 = v58;
                v19 = v88;
                break;
              }
            }
          }
        }
      }
    }
    v17 = v83 + 1;
  }
  while (v83 + 1 < *(int *)(a1 + 608));
  v16 = *(_DWORD *)(a3 + 28);
LABEL_75:
  if (v16 < 1
    || (v74 = BET3FXD__int32_to_Q18_14(v16),
        v75 = BET3FXD__div_Q18_14_Q18_14_to_Q18_14(v74, 0),
        *(_WORD *)(a1 + 16) = BET3FXD__Q18_14_to_Q1_15(v75),
        *(int *)(a1 + 608) < 1))
  {
LABEL_80:
    if (BET3FXD__log_select_GetLogLevel(*(_QWORD *)(v7 + 32)) >= 0x15)
      OutLabel_0(a1);
    BET3FXD__log_select_Diag(v7, 2, (uint64_t)">> tree search done\n");
    AddBreakMarks_0(a1, a2, a3);
    return ParamGenLT_0(a1, a2);
  }
  else
  {
    v76 = 0;
    v77 = 0;
    while (1)
    {
      v78 = (int *)(*(_QWORD *)(a1 + 600) + v76);
      result = BET3FXD__FindDurPDF((uint64_t)v78, a2, *(__int16 *)(a1 + 16), 0);
      if ((result & 0x80000000) != 0)
        break;
      SetSilenceDuration_0(a1, a2, a3, v78);
      *(_DWORD *)(a1 + 624) += v78[6];
      ++v77;
      v76 += 528;
      if (v77 >= *(int *)(a1 + 608))
        goto LABEL_80;
    }
  }
  return result;
}

uint64_t SetSilenceDuration_0(uint64_t result, int *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;

  v4 = *(_QWORD *)(result + 8);
  v5 = *a4;
  if (*(_BYTE *)(*(_QWORD *)(v4 + 32) + v5) == 1)
  {
    v8 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 1784) + 2 * v5) / *(int *)(a3 + 24);
    LODWORD(v4) = *a2;
    if (v8 <= *a2)
    {
      if ((int)v4 >= 1)
      {
        v14 = *((_QWORD *)a4 + 2);
        v15 = 2;
        do
        {
          *(_DWORD *)(v14 + 4 * v15) = 1;
          v11 = v15++ <= *a2;
        }
        while (v11);
        LODWORD(v4) = *a2;
      }
      a4[6] = v4;
    }
    else
    {
      if (v8 >= a4[6])
      {
        if ((int)v4 < 1)
        {
          v12 = 0;
          v13 = 0;
        }
        else
        {
          v13 = 0;
          v12 = 0;
          v16 = *((_QWORD *)a4 + 2);
          v17 = 2;
          do
          {
            v18 = *(_DWORD *)(v16 + 4 * v17);
            if (v18 <= 0)
            {
              v18 = 1;
              *(_DWORD *)(v16 + 4 * v17) = 1;
              LODWORD(v4) = *a2;
            }
            v19 = v17 == 2 || v17 == (_DWORD)v4 + 1;
            if (v19)
              v20 = 0;
            else
              v20 = v18;
            v12 += v20;
            if (!v19)
              v18 = 0;
            v13 += v18;
            v11 = v17++ <= (int)v4;
          }
          while (v11);
        }
      }
      else
      {
        if ((int)v4 >= 1)
        {
          v9 = *((_QWORD *)a4 + 2);
          v10 = 2;
          do
          {
            *(_DWORD *)(v9 + 4 * v10) = 1;
            v4 = *a2;
            v11 = v10++ <= v4;
          }
          while (v11);
        }
        v12 = v4 - 2;
        v13 = 2;
      }
      result = BET3FXD__div_int32_int32_to_Q8_24(v8 - v13, v12);
      a4[6] = v13;
      LODWORD(v21) = *a2;
      if (*a2 >= 3)
      {
        v22 = result;
        v23 = 3;
        do
        {
          if (v23 >= (int)v21)
            result = (v8 - v13);
          else
            result = BET3FXD__mul_int32_Q8_24_to_int32(*(_DWORD *)(*((_QWORD *)a4 + 2) + 4 * v23), v22);
          if ((int)result <= 1)
            v24 = 1;
          else
            v24 = result;
          *(_DWORD *)(*((_QWORD *)a4 + 2) + 4 * v23) = v24;
          v13 = a4[6] + v24;
          a4[6] = v13;
          v21 = *a2;
          v11 = v23++ < v21;
        }
        while (v11);
      }
    }
  }
  return result;
}

uint64_t OutLabel_0(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  if (*(int *)(result + 608) >= 1)
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v1 + 600) + v2;
      result = BET3FXD__log_select_Diag(*(_QWORD *)v1, 21, (uint64_t)"%d %d %d [%d]\n");
      v4 += *(_DWORD *)(v5 + 24);
      ++v3;
      v2 += 528;
    }
    while (v3 < *(int *)(v1 + 608));
  }
  return result;
}

uint64_t AddBreakMarks_0(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int *v22;
  uint64_t v23;
  int v24;
  int v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;

  result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE_TIME");
  if ((_DWORD)result)
  {
    result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE");
    if ((_DWORD)result)
    {
      result = cstdlib_strcmp(*(const char **)(a3 + 80), "WORD");
      if ((_DWORD)result)
      {
        result = cstdlib_strcmp(*(const char **)(a3 + 80), "SYLLABLE");
        if ((_DWORD)result)
        {
          result = cstdlib_strcmp(*(const char **)(a3 + 80), "TIME");
          if ((_DWORD)result)
          {
            result = cstdlib_strcmp(*(const char **)(a3 + 80), "NONE");
            if ((_DWORD)result)
              return BET3FXD__log_select_Error(*(_QWORD *)a1, 55036, (uint64_t)"valid breaker is required\n", v7, v8, v9, v10, v11);
          }
          else
          {
            v38 = *(unsigned int *)(a1 + 608);
            if ((int)v38 >= 1)
            {
              v39 = 0;
              v40 = 0;
              v41 = *(_DWORD *)(a3 + 88);
              v42 = *a2;
              v43 = *(_QWORD *)(a1 + 600);
              v44 = v41;
              v45 = 0;
              do
              {
                if (v42 >= 1)
                {
                  result = *(_QWORD *)(v43 + 528 * v39 + 16) + 8;
                  v46 = (v42 + 2) - 2;
                  v45 = v40;
                  do
                  {
                    v47 = *(_DWORD *)result;
                    result += 4;
                    v45 += v47;
                    --v46;
                  }
                  while (v46);
                }
                if (v45 > v44)
                {
                  v44 = v40 + v41;
                  v48 = v43 + 528 * v39;
                  result = *(_DWORD *)(v48 + 4) | 2u;
                  *(_DWORD *)(v48 + 4) = result;
                }
                ++v39;
                v40 = v45;
              }
              while (v39 != v38);
            }
          }
        }
        else
        {
          v34 = *(_DWORD *)(a1 + 608);
          if (v34 >= 3)
          {
            v35 = (v34 - 2);
            v36 = *(int **)(a1 + 600);
            v37 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
            do
            {
              if (*(_BYTE *)(v37 + *v36))
                v36[133] |= 2u;
              v36 += 132;
              --v35;
            }
            while (v35);
          }
        }
      }
      else
      {
        v30 = *(_DWORD *)(a1 + 608);
        if (v30 >= 3)
        {
          v31 = (v30 - 2);
          v32 = *(int **)(a1 + 600);
          v33 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
          do
          {
            if ((*(_BYTE *)(v33 + *v32) & 0xFE) == 2)
              v32[133] |= 2u;
            v32 += 132;
            --v31;
          }
          while (v31);
        }
      }
    }
    else
    {
      v26 = *(_DWORD *)(a1 + 608);
      if (v26 >= 3)
      {
        v27 = (v26 - 2);
        v28 = *(int **)(a1 + 600);
        v29 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
        do
        {
          if (*(_BYTE *)(v29 + *v28) == 3)
            v28[133] |= 2u;
          v28 += 132;
          --v27;
        }
        while (v27);
      }
    }
  }
  else
  {
    v12 = *(int *)(a1 + 608);
    if ((int)v12 >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = *(_QWORD *)(a1 + 600);
      v16 = *a2;
      v17 = *(_DWORD *)(a3 + 88);
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
      v19 = v12 - 2;
      v20 = *(unsigned int *)(a1 + 608);
      do
      {
        if (v16 < 1)
        {
          v21 = 0;
        }
        else
        {
          v21 = 0;
          v22 = (int *)(*(_QWORD *)(v15 + 528 * v13 + 16) + 8);
          v23 = (v16 + 2) - 2;
          do
          {
            v24 = *v22++;
            v21 += v24;
            --v23;
          }
          while (v23);
        }
        v14 += v21;
        if (v14 > v17)
        {
          *(_DWORD *)(v15 + 528 * v13 + 4) |= 2u;
          v14 = v21;
        }
        result = v15 + 528 * v13;
        if (*(_BYTE *)(v18 + *(int *)result) == 3 && v13 < v19)
        {
          v14 = 0;
          *(_DWORD *)(result + 532) |= 2u;
        }
        ++v13;
      }
      while (v13 != v20);
    }
  }
  return result;
}

uint64_t ParamGenLT_0(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  BOOL v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  unsigned int inited;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  int v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int *v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  _OWORD v70[4];
  _OWORD v71[4];
  _OWORD __b[7];
  uint64_t v73;

  v4 = *(_QWORD *)a1;
  v67 = -2065686518;
  v73 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v71, 0, sizeof(v71));
  memset(v70, 0, sizeof(v70));
  cstdlib_memset(__b, 0, 0x78uLL);
  BET3FXD__InitSMatrices(v4, v71);
  BET3FXD__InitSMatrices(v4, v70);
  v5 = heap_Calloc(*(_QWORD **)(v4 + 8), (*(_DWORD *)(a1 + 624) + 1), 1);
  *(_QWORD *)(a1 + 48) = v5;
  if (!v5)
    return v67;
  v6 = heap_Calloc(*(_QWORD **)(v4 + 8), (*(_DWORD *)(a1 + 624) + 1), 4);
  *(_QWORD *)(a1 + 40) = v6;
  if (!v6)
    return v67;
  v7 = *(_DWORD *)(a1 + 608);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    LODWORD(v10) = *a2;
    do
    {
      if ((int)v10 >= 1)
      {
        v11 = *(_QWORD *)(a1 + 600) + 528 * v8;
        v14 = *(_QWORD *)(v11 + 16);
        v12 = (uint64_t *)(v11 + 16);
        v13 = v14;
        v15 = v12 + 37;
        v16 = 2;
        do
        {
          if (*(int *)(v13 + 4 * v16) >= 1)
          {
            v17 = 0;
            v18 = v9;
            do
            {
              *(_BYTE *)(*(_QWORD *)(a1 + 48) + v18) = *(_BYTE *)(*v15 + v16);
              *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v18++) = *(_DWORD *)(v12[38] + 4 * v16);
              v13 = *v12;
              ++v17;
            }
            while (v17 < *(_DWORD *)(*v12 + 4 * v16));
            v9 += v17;
          }
          v19 = *(unsigned int *)(a1 + 32);
          if ((int)v19 >= 1)
          {
            v20 = *(_DWORD **)(a1 + 24);
            do
            {
              if (v20[68] && ((1 << v20[3]) & (unint64_t)*(unsigned __int8 *)(*v15 + v16)) >> v20[3])
                v20[11] += *(_DWORD *)(v13 + 4 * v16);
              v20 += 78;
              --v19;
            }
            while (v19);
          }
          v10 = *a2;
          v21 = v16++ <= v10;
        }
        while (v21);
        v7 = *(_DWORD *)(a1 + 608);
      }
      ++v8;
    }
    while (v8 < v7);
  }
  if (*(int *)(a1 + 32) < 1)
  {
    v67 = 0;
    goto LABEL_64;
  }
  v22 = 0;
  v23 = 0;
  v67 = 0;
  while (1)
  {
    v24 = *(_QWORD *)(a1 + 24);
    v25 = v24 + 312 * v22;
    if (*(_DWORD *)(v25 + 272))
      break;
LABEL_60:
    if (++v22 >= *(int *)(a1 + 32))
      goto LABEL_64;
  }
  if (!*(_DWORD *)(v24 + 312 * v22 + 44))
  {
LABEL_59:
    BET3FXD__DeInitMSDUttModel((_QWORD *)(a1 + 56), v22);
    goto LABEL_60;
  }
  v26 = (uint64_t *)(v25 + 24);
  inited = BET3FXD__InitPStreamParam((uint64_t *)(v25 + 24), 0);
  if ((inited & 0x80000000) == 0)
  {
    v66 = v26;
    v67 = BET3FXD__InitPStreamSM(v26, (uint64_t)v71);
    if ((v67 & 0x80000000) != 0)
      goto LABEL_64;
    v28 = *(_DWORD *)(a1 + 608);
    if (v28 < 1)
      goto LABEL_57;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v68 = *(_QWORD *)(a1 + 600);
    v32 = v24 + 312 * v22;
    v33 = v32 + 56;
    v34 = (_QWORD *)(v32 + 96);
    v35 = (_QWORD *)(v32 + 104);
    v36 = *a2;
    do
    {
      if (v36 >= 1)
      {
        v69 = v29;
        v37 = v68 + 528 * v29;
        v38 = *(_QWORD *)(v37 + 16);
        v39 = v37 + 8 * v22;
        v40 = (_QWORD *)(v39 + 152);
        v41 = (_QWORD *)(v39 + 232);
        v42 = 2;
        do
        {
          v43 = *(_DWORD *)(v38 + 4 * v42);
          if (v43 >= 1)
          {
            v44 = *(_QWORD *)(a1 + 24) + 312 * v22;
            v47 = *(_DWORD *)(v44 + 36);
            v45 = (int *)(v44 + 36);
            LODWORD(v46) = v47;
            v48 = v45 - 6;
            v49 = *(_QWORD *)(a1 + 48);
            v50 = v31;
            v51 = 1;
            do
            {
              if ((int)v46 >= 1)
              {
                v52 = 0;
                v53 = *(_QWORD *)(*(_QWORD *)v33 + 8);
                do
                {
                  v54 = *v48;
                  v55 = 1 << *v48;
                  v23 |= v55;
                  v56 = *(int **)(v53 + 8 * v52);
                  v57 = *v56;
                  v58 = v56[1];
                  if (v57 <= v58)
                  {
                    v59 = v58 - v57 + 1;
                    v60 = v31 + v57;
                    do
                    {
                      v61 = v55 ^ 0xFFLL;
                      if ((v60 & 0x80000000) == 0)
                      {
                        v61 = v55 ^ 0xFFLL;
                        if (*(_DWORD *)(a1 + 624) >= (signed int)v60)
                          v61 = *(unsigned __int8 *)(v49 + v60);
                      }
                      v23 &= v61;
                      ++v60;
                      --v59;
                    }
                    while (v59);
                  }
                  if ((unint64_t)(v55 & *(_BYTE *)(v49 + v50)) >> v54)
                  {
                    if (!v52 || (v55 & v23) >> v54)
                    {
                      v63 = 4 * v52 + 4;
                      *(_DWORD *)(*(_QWORD *)(*v34 + 8 * v30) + 4 * v52) = *(_DWORD *)(*(_QWORD *)(*v40 + 8 * v42)
                                                                                       + v63);
                      v62 = *(_DWORD *)(*(_QWORD *)(*v41 + 8 * v42) + v63);
                    }
                    else
                    {
                      v62 = 0;
                      *(_DWORD *)(*(_QWORD *)(*v34 + 8 * v30) + 4 * v52) = 0;
                    }
                    *(_DWORD *)(*(_QWORD *)(*v35 + 8 * v30) + 4 * v52) = v62;
                  }
                  ++v52;
                  v46 = *v45;
                }
                while (v52 < v46);
                v43 = *(_DWORD *)(v38 + 4 * v42);
              }
              if (((1 << *v48) & (unint64_t)*(unsigned __int8 *)(v49 + v50)) >> *v48)
                ++v30;
              ++v50;
              ++v31;
              v21 = v51++ < v43;
            }
            while (v21);
            v36 = *a2;
            v31 = v50;
          }
          v21 = v42++ <= v36;
        }
        while (v21);
        v28 = *(_DWORD *)(a1 + 608);
        v29 = v69;
      }
      ++v29;
    }
    while (v29 < v28);
    if (v30 < 1)
    {
LABEL_57:
      v64 = (uint64_t)v66;
    }
    else
    {
      (**(void (***)(uint64_t *, _QWORD))(*(_QWORD *)(a1 + 24) + 312 * v22 + 288))(v66, 0);
      v64 = (uint64_t)v66;
    }
    BET3FXD__FreePStreamSM(v64);
    goto LABEL_59;
  }
  v67 = inited;
LABEL_64:
  BET3FXD__FreePStreamParam(__b);
  BET3FXD__FreeSMatrices((uint64_t)v71);
  BET3FXD__FreeSMatrices((uint64_t)v70);
  return v67;
}

uint64_t BET3FXD__ParamGenFrames(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t v36;
  int v37;
  int *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int *v44;
  int v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  unsigned int v49;
  int **v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int *v57;
  int v58;
  int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  int v73;
  int *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  int *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  signed int v93;
  unsigned int v95;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  uint64_t *v101;
  uint64_t v102;
  int *v103;
  unsigned int inited;
  uint64_t v105;
  int *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t *v111;
  int v112;
  _OWORD v113[4];
  _OWORD v114[4];
  _OWORD __b[7];
  uint64_t v116;

  v5 = *(_QWORD *)a1;
  v116 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v114, 0, sizeof(v114));
  memset(v113, 0, sizeof(v113));
  *a3 = 0;
  cstdlib_memset(__b, 0, 0x78uLL);
  BET3FXD__InitSMatrices(v5, v114);
  v98 = v5;
  BET3FXD__InitSMatrices(v5, v113);
  v109 = a1;
  v6 = *(_DWORD *)(a1 + 612);
  v7 = *(_QWORD *)(a1 + 600) + 528 * v6;
  *(_DWORD *)(v7 + 4) &= ~2u;
  v8 = *(_DWORD *)(a1 + 608);
  v9 = __OFSUB__(v8, v6);
  v10 = v8 - v6;
  if ((v10 < 0) ^ v9 | (v10 == 0))
  {
    LODWORD(v12) = 0;
    v11 = 0;
  }
  else
  {
    v11 = 0;
    LODWORD(v12) = 0;
    while ((*(_BYTE *)(v7 + 4) & 2) == 0)
    {
      v13 = *a2;
      if ((int)v13 >= 1)
      {
        v14 = (int *)(*(_QWORD *)(v7 + 16) + 8);
        do
        {
          v15 = *v14++;
          LODWORD(v12) = v15 + v12;
          --v13;
        }
        while (v13);
      }
      v7 += 528;
      if (++v11 == v10)
      {
        v11 = v10;
        break;
      }
    }
  }
  BET3FXD__log_select_Diag(v5, 2, (uint64_t)"| processing %d models %d frames <=> ");
  v16 = a1;
  if (*(int *)(a1 + 32) < 1)
  {
    inited = 0;
LABEL_83:
    v93 = *(_DWORD *)(v16 + 612) + v11;
    *(_DWORD *)(v16 + 612) = v93;
    if (v93 >= *(_DWORD *)(v16 + 608))
      *a3 = 1;
LABEL_85:
    v92 = inited;
    goto LABEL_86;
  }
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  inited = 0;
  v97 = -(uint64_t)v11;
  v95 = v11;
  while (1)
  {
    v22 = *(_QWORD *)(v16 + 24);
    if (*(_DWORD *)(v22 + 312 * v17 + 268))
      break;
LABEL_79:
    if (++v17 >= *(int *)(v16 + 32))
      goto LABEL_83;
  }
  v23 = v22 + 312 * v17;
  v101 = (uint64_t *)(v23 + 64);
  v108 = v17;
  v111 = (uint64_t *)(v23 + 24);
  if (*(_QWORD *)(v23 + 64))
  {
    v24 = v20;
    BET3FXD__FreePStreamParam((_QWORD *)(v23 + 24));
    v20 = v24;
    v17 = v108;
    v16 = v109;
    v25 = *(_QWORD *)(v109 + 24);
  }
  else
  {
    v25 = *(_QWORD *)(v16 + 24);
  }
  v26 = v25 + 312 * v17;
  v27 = *(_DWORD *)(v26 + 280);
  v105 = *(unsigned int *)(v26 + 284);
  v28 = *(_DWORD *)(v16 + 612);
  v29 = *(_DWORD *)(v16 + 608);
  if ((int)(v18 + v11 + v28) < v29 && v19 < v27)
  {
    v30 = *a2;
    v31 = v7;
    do
    {
      if (v30 >= 1)
      {
        v32 = (int *)(*(_QWORD *)(v31 + 16) + 8);
        v33 = (v30 + 2) - 2;
        do
        {
          v34 = *v32++;
          v19 += v34;
          --v33;
        }
        while (v33);
      }
      v31 += 528;
      v18 = (v18 + 1);
      v35 = (int)(v18 + v11 + v28) < v29 && v19 < v27;
    }
    while (v35);
  }
  if (v28 > (int)v20 && v21 < v27)
  {
    v36 = v7 + 528 * v97;
    v37 = *a2;
    do
    {
      if (v37 >= 1)
      {
        v38 = (int *)(*(_QWORD *)(v36 - 512) + 8);
        v39 = (v37 + 2) - 2;
        do
        {
          v40 = *v38++;
          v21 += v40;
          --v39;
        }
        while (v39);
      }
      v20 = (v20 + 1);
      if (v28 <= (int)v20)
        break;
      v36 -= 528;
    }
    while (v21 < v27);
  }
  v102 = v7;
  v107 = v20;
  BET3FXD__log_select_Diag(v98, 3, (uint64_t)"L: %d %d  R: %d %d\n");
  v41 = v22 + 312 * v108;
  *(_DWORD *)(v41 + 164) = v105 + v12 + v19 + v21 + v105;
  v106 = (int *)(v41 + 164);
  *(_DWORD *)(v41 + 44) = v12;
  v103 = (int *)(v41 + 44);
  inited = BET3FXD__InitPStreamParam(v111, 0);
  if ((inited & 0x80000000) != 0)
    goto LABEL_85;
  v99 = v18;
  v42 = v22 + 312 * v108;
  v45 = *(_DWORD *)(v42 + 40);
  v44 = (int *)(v42 + 40);
  v43 = v45;
  v17 = v108;
  if (v45 < 1)
  {
    v16 = v109;
    v18 = v99;
    v20 = v107;
LABEL_78:
    v7 = v102;
    goto LABEL_79;
  }
  v46 = 0;
  v47 = v101 + 10;
  v48 = v22 + 312 * v108;
  v49 = v11;
  v50 = (int **)(v48 + 176);
  v51 = (_QWORD *)(v48 + 216);
  v52 = (_QWORD *)(v48 + 224);
  v20 = v107;
  v112 = v99 + v49 + v107;
  v100 = (_QWORD *)(v48 + 184);
  v16 = v109;
  v110 = v101 + 10;
  while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v16 + 24) + 312 * v17 + 304) + 4 * v46) != 1)
  {
LABEL_75:
    if (++v46 >= v43)
    {
      v11 = v95;
      v18 = v99;
      goto LABEL_78;
    }
  }
  v53 = v47;
  v54 = BET3FXD__InitPStreamParam(v47, (uint64_t)__b);
  if ((v54 & 0x80000000) == 0)
  {
    v54 = BET3FXD__InitPStreamSM(v53, (uint64_t)v113);
    if ((v54 & 0x80000000) == 0)
    {
      inited = v54;
      if ((int)v105 < 1)
      {
        LODWORD(v12) = 0;
        v56 = v108;
        v55 = v109;
        v57 = v106;
        v58 = v107;
      }
      else
      {
        v12 = 0;
        v56 = v108;
        v55 = v109;
        v57 = v106;
        v58 = v107;
        while (v12 < *v106)
        {
          v59 = *v50;
          if (**v50 >= 1)
          {
            v60 = 0;
            v61 = *(_QWORD *)(*v51 + 8 * v12);
            v62 = *(_QWORD *)(*v52 + 8 * v12);
            do
            {
              *(_DWORD *)(v61 + 4 * v60) = 0;
              *(_DWORD *)(v62 + 4 * v60++) = 4095;
            }
            while (v60 < *v59);
          }
          if (++v12 == v105)
          {
            LODWORD(v12) = v105;
            break;
          }
        }
      }
      if (v112 >= 1)
      {
        v63 = 0;
        v64 = *(_QWORD *)(v55 + 600);
        v65 = *a2;
        do
        {
          v66 = v63 - v58 + *(_DWORD *)(v55 + 612);
          if (v65 >= 1)
          {
            v67 = v64 + 528 * v66;
            v68 = *(_QWORD *)(v67 + 16);
            v69 = v67 + 8 * v56;
            v70 = (_QWORD *)(v69 + 152);
            v71 = (_QWORD *)(v69 + 232);
            v72 = 2;
            do
            {
              v73 = *(_DWORD *)(v68 + 4 * v72);
              if (v73 >= 1)
              {
                v74 = *v50;
                v12 = (int)v12;
                LODWORD(v75) = **v50;
                v76 = 1;
                do
                {
                  if ((int)v75 >= 1)
                  {
                    v77 = 0;
                    v78 = *(_QWORD *)(*v70 + 8 * v72);
                    v79 = *(_QWORD *)(*v51 + 8 * v12);
                    v80 = *(_QWORD *)(*v71 + 8 * v72);
                    v81 = *(_QWORD *)(*v52 + 8 * v12);
                    do
                    {
                      v82 = v46 + *v44 * v77;
                      *(_DWORD *)(v79 + 4 * v77) = *(_DWORD *)(v78 + 4 * v82);
                      *(_DWORD *)(v81 + 4 * v77++) = *(_DWORD *)(v80 + 4 * v82);
                      v75 = *v74;
                    }
                    while (v77 < v75);
                    v73 = *(_DWORD *)(v68 + 4 * v72);
                  }
                  ++v12;
                  v35 = v76++ < v73;
                }
                while (v35);
                v65 = *a2;
              }
              v35 = v72++ <= v65;
            }
            while (v35);
          }
          ++v63;
        }
        while (v63 != v112);
        v102 = v64 + 528 * v66;
        v57 = v106;
      }
      v83 = *v57;
      if ((int)v12 < *v57)
      {
        v84 = *v50;
        v12 = (int)v12;
        LODWORD(v85) = **v50;
        do
        {
          if ((int)v85 >= 1)
          {
            v86 = 0;
            v87 = *(_QWORD *)(*v51 + 8 * v12);
            v88 = *(_QWORD *)(*v52 + 8 * v12);
            do
            {
              *(_DWORD *)(v87 + 4 * v86) = 0;
              *(_DWORD *)(v88 + 4 * v86++) = 4095;
              v85 = *v84;
            }
            while (v86 < v85);
            v83 = *v57;
          }
          ++v12;
        }
        while (v12 < v83);
      }
      (*(void (**)(_QWORD *, _QWORD))(*(_QWORD *)(*(_QWORD *)(v55 + 24) + 312 * v56 + 288) + 8 * v46))(v110, 0);
      if (*v103 >= 1)
      {
        v89 = 0;
        v90 = *v101;
        v91 = *v100 + 8 * (v21 + (int)v105);
        do
        {
          *(_DWORD *)(*(_QWORD *)(v90 + 8 * v89) + 4 * v46) = **(_DWORD **)(v91 + 8 * v89);
          ++v89;
        }
        while (v89 < *v103);
      }
      BET3FXD__FreePStreamSM((uint64_t)v110);
      BET3FXD__FreePStreamParam(v110);
      v16 = v109;
      v47 = v101 + 10;
      v43 = *v44;
      v20 = v107;
      v17 = v108;
      goto LABEL_75;
    }
  }
  v92 = v54;
LABEL_86:
  BET3FXD__FreePStreamParam(__b);
  BET3FXD__FreeSMatrices((uint64_t)v114);
  BET3FXD__FreeSMatrices((uint64_t)v113);
  return v92;
}

uint64_t BET3FXD__InitVData(int a1, char *__b, _DWORD *a3)
{
  uint64_t result;

  cstdlib_memset(__b, 0, 0x4C0uLL);
  result = BET3FXD__InitModelSet(a1, __b, a3);
  if ((result & 0x80000000) == 0)
  {
    result = BET3FXD__InitTreeSet(a1, __b + 608);
    if ((result & 0x80000000) == 0)
      return BET3FXD__InitDWinSet(a1, __b + 816, (uint64_t)a3);
  }
  return result;
}

void *BET3FXD__DeInitVData(void *a1, uint64_t a2)
{
  BET3FXD__DeInitModelSet((uint64_t)a1, (_QWORD *)a2);
  BET3FXD__DeInitTreeSet(a1, (char *)(a2 + 608));
  BET3FXD__DeInitDWinSet((_QWORD **)a1, (char *)(a2 + 816));
  return cstdlib_memset((void *)a2, 0, 0x4C0uLL);
}

uint64_t BET3FXD__LoadVData(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  _DWORD *v4;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t ModelFile;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  const char *v26;
  uint64_t v27;
  uint64_t v28;

  if ((int)a2[150] < 1)
    return 0;
  v4 = a2;
  v6 = 0;
  v7 = (uint64_t)(a2 + 152);
  v8 = a2 + 204;
  v9 = a3 + 2664;
  v10 = a3 + 5064;
  do
  {
    ModelFile = BET3FXD__LoadModelFile(a1, v4, v6, v9, v10, a3);
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ModelFile = BET3FXD__LoadTreesFile(a1, v7, v6, (unsigned int *)(v10 - 2640), a3, v12, v13, v14);
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ModelFile = BET3FXD__LoadDWinFile(a1, (uint64_t)v8, v6, (unsigned int *)(v9 + 1200));
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ++v6;
    v20 = (int)v4[150];
    v9 += 120;
    v10 += 24;
  }
  while (v6 < v20);
  v21 = v4[150];
  if ((int)v20 < 1)
    return 0;
  v22 = a3 + 144;
  v23 = v4 + 178;
  while (1)
  {
    if (!*v23)
    {
      v24 = 2229280775;
      v26 = "%s tree is required\n";
      v27 = a1;
      v28 = 55032;
      goto LABEL_19;
    }
    if ((v4[130] || v4[140]) && v4[1] % *v8)
      break;
    v22 += 8;
    ++v23;
    v8 += 10;
    ++v4;
    if (!--v21)
      return 0;
  }
  v24 = 2229280775;
  v26 = "The number of dynamic windows for %s is not correct %d %d\n";
  v27 = a1;
  v28 = 55035;
LABEL_19:
  BET3FXD__log_select_Error(v27, v28, (uint64_t)v26, v15, v16, v17, v18, v19);
  return v24;
}

uint64_t BET3FXD__InitVStream(uint64_t a1, char *__b, _DWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;

  cstdlib_memset(__b, 0, 0x7A0uLL);
  *(_QWORD *)__b = a1;
  v6 = a3[33];
  *((_DWORD *)__b + 8) = v6;
  v7 = heap_Calloc(*(_QWORD **)(a1 + 8), v6, 312);
  *((_QWORD *)__b + 3) = v7;
  if (!v7)
    return 2229280778;
  if (*((int *)__b + 8) >= 1)
  {
    v8 = 0;
    v9 = __b + 672;
    v10 = a3 + 36;
    do
    {
      cstdlib_strcpy(v9, "");
      if (cstdlib_strlen(*(const char **)&v10[2 * v8]))
        cstdlib_strcpy(v9, *(const char **)&v10[2 * v8]);
      ++v8;
      v11 = *((int *)__b + 8);
      v9 += 128;
    }
    while (v8 < v11);
    if ((int)v11 >= 1)
    {
      v12 = 0;
      v13 = *((_QWORD *)__b + 3);
      v14 = a3[18];
      v15 = 312 * *((unsigned int *)__b + 8);
      do
      {
        v16 = v13 + v12;
        *(_DWORD *)(v16 + 12) = a3[56];
        *(_QWORD *)(v16 + 24) = a1;
        *(_QWORD *)(v16 + 144) = a1;
        if (v12)
        {
          if (a3[536])
            *(_DWORD *)(v13 + v12 + 272) = 1;
          else
            *(_DWORD *)(v13 + v12 + 268) = 1;
        }
        else
        {
          *(_DWORD *)(v13 + 264) = 1;
        }
        if (v14 == 1)
          *(_DWORD *)(v13 + v12 + 276) = 1;
        ++a3;
        v12 += 312;
      }
      while (v15 != v12);
    }
  }
  result = 0;
  *((_DWORD *)__b + 162) = 0;
  *(_OWORD *)(__b + 632) = 0u;
  return result;
}

uint64_t BET3FXD__LoadVStream(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v32;
  const char *v33;

  if (*((int *)a1 + 8) < 1)
    return 0;
  v3 = a3;
  v6 = 0;
  v7 = a2 + 816;
  v8 = a1[3];
  while (1)
  {
    v9 = (_DWORD *)(v7 + 40 * v6);
    v10 = v8 + 312 * v6;
    *(_QWORD *)(v10 + 56) = v9;
    v11 = *(_DWORD *)(v10 + 268);
    if (v11)
      *(_QWORD *)(v8 + 312 * v6 + 176) = v9;
    if (!*(_DWORD *)(v8 + 312 * v6 + 264))
      break;
    if (v11)
      goto LABEL_7;
LABEL_8:
    if (++v6 >= *((int *)a1 + 8))
      return 0;
  }
  v13 = a2 + 4 * v6;
  v14 = v8 + 312 * v6;
  *(_DWORD *)(v14 + 36) = *(_DWORD *)(v13 + 4);
  v15 = (*(_DWORD *)(v13 + 4) / *v9);
  *(_DWORD *)(v14 + 40) = v15;
  *(_QWORD *)(v14 + 280) = *(_QWORD *)(v3 + 92);
  v16 = heap_Calloc(*(_QWORD **)(*a1 + 8), v15, 8);
  v17 = a1[3];
  *(_QWORD *)(v17 + 312 * v6 + 288) = v16;
  if (!v16)
    return 2229280778;
  LODWORD(v17) = *(_DWORD *)(v17 + 312 * v6 + 40);
  if ((int)v17 >= 1)
  {
    v18 = 0;
    v19 = (_QWORD *)(v3 + 8 * v6 + 2184);
    do
    {
      if (cstdlib_strcmp(*(const char **)(*v19 + 8 * v18), "MLPG2"))
      {
        v32 = *a1;
        v33 = "invalid solver for stream %d: %s\n";
        goto LABEL_30;
      }
      *(_QWORD *)(*(_QWORD *)(a1[3] + 312 * v6 + 288) + 8 * v18++) = BET3FXD__mlpg2;
      v17 = *(int *)(a1[3] + 312 * v6 + 40);
    }
    while (v18 < v17);
    v3 = a3;
  }
  v25 = heap_Calloc(*(_QWORD **)(*a1 + 8), v17, 4);
  v26 = a1[3];
  *(_QWORD *)(v26 + 312 * v6 + 304) = v25;
  if (!v25)
    return 2229280778;
  if (*(int *)(v26 + 312 * v6 + 40) < 1)
  {
LABEL_25:
    BET3FXD__log_select_Diag(*a1, 1, (uint64_t)"%s: vSize = %d, order = %d, nLayer = %d\n");
    v8 = a1[3];
    if (!*(_DWORD *)(v8 + 312 * v6 + 268))
      goto LABEL_8;
LABEL_7:
    v12 = v8 + 312 * v6;
    *(_DWORD *)(v12 + 156) = *(_DWORD *)(a2 + 4 * v6 + 4);
    *(_DWORD *)(v12 + 160) = 1;
    goto LABEL_8;
  }
  v27 = 0;
  v28 = (_QWORD *)(v3 + 8 * v6 + 2344);
  while (1)
  {
    if (!cstdlib_strcmp(*(const char **)(*v28 + 8 * v27), "OFF"))
    {
      v29 = 0;
      goto LABEL_23;
    }
    if (cstdlib_strcmp(*(const char **)(*v28 + 8 * v27), "ON"))
      break;
    v29 = 1;
LABEL_23:
    v30 = a1[3] + 312 * v6;
    *(_DWORD *)(*(_QWORD *)(v30 + 304) + 4 * v27++) = v29;
    if (v27 >= *(int *)(v30 + 40))
    {
      v3 = a3;
      goto LABEL_25;
    }
  }
  v32 = *a1;
  v33 = "valid breaker setting is required for stream %d\n";
LABEL_30:
  BET3FXD__log_select_Error(v32, 55036, (uint64_t)v33, v20, v21, v22, v23, v24);
  return 2229280775;
}

_QWORD *BET3FXD__DeInitVStream(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (result)
  {
    v1 = result;
    if (*result)
    {
      if (*((int *)result + 8) >= 1)
      {
        v2 = 0;
        v3 = result[3];
        v4 = 304;
        do
        {
          if (!v3)
            break;
          BET3FXD__FreePStreamSM(v3 + v4 - 280);
          BET3FXD__FreePStreamParam((_QWORD *)(v1[3] + v4 - 280));
          BET3FXD__FreePStreamSM(v1[3] + v4 - 160);
          BET3FXD__FreePStreamParam((_QWORD *)(v1[3] + v4 - 160));
          v3 = v1[3];
          v5 = *(_QWORD *)(v3 + v4 - 16);
          if (v5)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v5);
            v3 = v1[3];
            *(_QWORD *)(v3 + v4 - 16) = 0;
          }
          v6 = *(_QWORD *)(v3 + v4);
          if (v6)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v6);
            v3 = v1[3];
            *(_QWORD *)(v3 + v4) = 0;
          }
          ++v2;
          v4 += 312;
        }
        while (v2 < *((int *)v1 + 8));
      }
      v7 = v1[6];
      if (v7)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v7);
        v1[6] = 0;
      }
      v8 = v1[5];
      if (v8)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v8);
        v1[5] = 0;
      }
      v9 = v1[3];
      if (v9)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v9);
        v1[3] = 0;
      }
      v10 = v1[79];
      if (v10)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v10);
        v1[79] = 0;
      }
      v11 = v1[80];
      if (v11)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v11);
        v1[80] = 0;
      }
      BET3FXD__DeInitUttModel(v1 + 7);
      return cstdlib_memset(v1, 0, 0x7A0uLL);
    }
  }
  return result;
}

void *BET3FXD__InitVParam(_DWORD *a1)
{
  void *result;

  result = cstdlib_memset(a1, 0, 0x1F30uLL);
  a1[32] = 1;
  return result;
}

void *BET3FXD__DeInitVParam(uint64_t a1, _QWORD *__b)
{
  uint64_t i;
  uint64_t j;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t k;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t m;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  unsigned int *v29;
  char *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t n;
  uint64_t v44;
  uint64_t ii;
  uint64_t v46;

  if (__b[954])
  {
    for (i = 0; i != 20; ++i)
    {
      if (*(_QWORD *)(__b[954] + 8 * i))
      {
        for (j = 0; j != 800; j += 8)
        {
          v6 = *(_QWORD *)(*(_QWORD *)(__b[954] + 8 * i) + j);
          if (v6)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v6);
            *(_QWORD *)(*(_QWORD *)(__b[954] + 8 * i) + j) = 0;
          }
        }
        v7 = *(_QWORD *)(__b[954] + 8 * i);
        if (v7)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v7);
          *(_QWORD *)(__b[954] + 8 * i) = 0;
        }
      }
      v8 = *(_QWORD *)(__b[955] + 8 * i);
      if (v8)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v8);
        *(_QWORD *)(__b[955] + 8 * i) = 0;
      }
      v9 = *(_QWORD *)(__b[953] + 8 * i);
      if (v9)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v9);
        *(_QWORD *)(__b[953] + 8 * i) = 0;
      }
    }
    v10 = __b[954];
    if (v10)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v10);
      __b[954] = 0;
    }
    v11 = __b[955];
    if (v11)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v11);
      __b[955] = 0;
    }
    v12 = __b[953];
    if (v12)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v12);
      __b[953] = 0;
    }
  }
  v13 = __b[10];
  if (v13)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v13);
    __b[10] = 0;
  }
  v14 = __b[15];
  if (v14)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v14);
    __b[15] = 0;
  }
  v15 = __b[956];
  if (v15)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v15);
    __b[956] = 0;
  }
  v16 = 0;
  v17 = __b;
  do
  {
    v18 = (char *)&__b[v16];
    v19 = *((_QWORD *)v18 + 18);
    if (v19)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v19);
      *((_QWORD *)v18 + 18) = 0;
    }
    v20 = *((_QWORD *)v18 + 53);
    if (v20)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v20);
      *((_QWORD *)v18 + 53) = 0;
    }
    for (k = 0; k != 5; ++k)
    {
      v22 = &v17[k];
      v23 = v17[k + 63];
      if (v23)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v23);
        v22[63] = 0;
      }
      v24 = v22[163];
      if (v24)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v24);
        v22[163] = 0;
      }
    }
    for (m = 213; m != 218; ++m)
    {
      v26 = v17[m];
      if (v26)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v26);
        v17[m] = 0;
      }
    }
    v27 = (char *)__b + 4 * v16;
    if (*((_DWORD *)v27 + 66))
    {
      v28 = 0;
      v29 = (unsigned int *)(v27 + 264);
      v30 = (char *)&__b[v16];
      v31 = v30 + 2344;
      v32 = v30 + 2184;
      v33 = v30 + 2264;
      do
      {
        if (*v31)
        {
          v34 = *(_QWORD *)(*v31 + 8 * v28);
          if (v34)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v34);
            *(_QWORD *)(*v31 + 8 * v28) = 0;
          }
        }
        if (*v32)
        {
          v35 = *(_QWORD *)(*v32 + 8 * v28);
          if (v35)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v35);
            *(_QWORD *)(*v32 + 8 * v28) = 0;
          }
        }
        if (*v33)
        {
          v36 = *(_QWORD *)(*v33 + 8 * v28);
          if (v36)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v36);
            *(_QWORD *)(*v33 + 8 * v28) = 0;
          }
        }
        ++v28;
      }
      while (v28 < *v29);
    }
    v37 = (char *)&__b[v16];
    v38 = *((_QWORD *)v37 + 293);
    if (v38)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v38);
      *((_QWORD *)v37 + 293) = 0;
    }
    v39 = *((_QWORD *)v37 + 273);
    if (v39)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v39);
      *((_QWORD *)v37 + 273) = 0;
    }
    v40 = (char *)&__b[v16];
    v41 = *((_QWORD *)v40 + 283);
    if (v41)
    {
      v42 = v40 + 2264;
      heap_Free(*(_QWORD **)(a1 + 8), v41);
      *v42 = 0;
    }
    ++v16;
    v17 += 5;
  }
  while (v16 != 10);
  for (n = 663; n != 919; ++n)
  {
    v44 = __b[n];
    if (v44)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v44);
      __b[n] = 0;
    }
  }
  if (__b[952])
  {
    for (ii = 0; ii != 2048; ii += 8)
    {
      v46 = *(_QWORD *)(__b[952] + ii);
      if (v46)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v46);
        *(_QWORD *)(__b[952] + ii) = 0;
      }
    }
    heap_Free(*(_QWORD **)(a1 + 8), __b[952]);
  }
  return cstdlib_memset(__b, 0, 0x1F30uLL);
}

uint64_t XFREAD_XTRA_bound(unsigned int a1, unsigned int *a2)
{
  uint64_t result;
  unsigned int v3;

  result = (a1 + *a2 / a1 * a1 - *a2) % a1;
  v3 = result + *a2;
  if (v3 >= a2[4])
    v3 = a2[4];
  *a2 = v3;
  return result;
}

uint64_t dequantDur(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5, int a6)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;

  v10 = *(int *)(a1 + 4);
  v11 = *(_QWORD *)(a1 + 128) + *(unsigned int *)(a1 + 136) + (2 * a2 * *(_DWORD *)a1 * v10);
  if (*(_DWORD *)a1 == 1)
  {
    v12 = *(unsigned __int8 *)(v11 + a3);
    v13 = *(unsigned __int8 *)(v11 + v10 + a3);
  }
  else
  {
    v12 = *(unsigned __int16 *)(v11 + 2 * a3);
    v13 = *(unsigned __int16 *)(v11 + 2 * ((int)v10 + a3));
  }
  *a4 = dequantValueToU32(v12, *(_DWORD *)(a1 + 12 + 4 * a3), *(unsigned __int16 *)(a1 + 68), *(unsigned __int16 *)(a1 + 70 + 2 * a3), *(unsigned __int16 *)(a1 + 98 + 2 * a3), a6);
  *a5 = dequantValueToU32(v13, *(_DWORD *)(a1 + 12 + 4 * (*(_DWORD *)(a1 + 4) + a3)), *(unsigned __int16 *)(a1 + 68), *(unsigned __int16 *)(a1 + 70 + 2 * (*(_DWORD *)(a1 + 4) + a3)), *(unsigned __int16 *)(a1 + 98 + 2 * (*(_DWORD *)(a1 + 4) + a3)), a6);
  return 0;
}

uint64_t dequantValueToU32(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  __int16 v8;
  char v9;
  unsigned int v10;
  char v11;
  int v12;
  __int16 v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;

  v8 = a6 + 2 - a4;
  if (a6 + 2 > a4)
  {
    v9 = a6 + 2 - a4;
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  v10 = (unsigned __int16)(a6 - v8);
  v11 = a6 - v8 + 16 - a4;
  if (v10 + 16 <= a4)
  {
    v13 = a4 - v10;
    v12 = a5;
  }
  else
  {
    a1 <<= v11;
    v12 = a5;
    v13 = 16;
  }
  v14 = fxd_S32ShMultRndS32S32(a1, v12, v13);
  if (v10 >= a3)
  {
    v16 = 0x7FFFFFFFLL;
    if (0x7FFFFFFFu >> (v10 - a3) <= a2)
      return v16;
    v15 = a2 << (v10 - a3);
  }
  else
  {
    v15 = a2 >> (a3 - v10);
  }
  v17 = v15 + v14;
  if (v17 >= 0x7FFFFFFFu >> v9)
    return 0x7FFFFFFFLL;
  else
    return v17 << v9;
}

uint64_t dequantMsd(uint64_t a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, unsigned int a8)
{
  unsigned __int8 *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  unsigned __int16 *v17;

  v12 = (unsigned __int8 *)(*(_QWORD *)(a1 + 112)
                          + *(unsigned int *)(*(_QWORD *)(a1 + 120) + 4 * a2)
                          + *(unsigned __int16 *)(a1 + 12) * (uint64_t)a3
                          + 3 * a4 * *(_DWORD *)a1);
  if (*(_DWORD *)a1 == 1)
  {
    v13 = *v12;
    v14 = v12[1];
    v15 = v12[2];
  }
  else
  {
    v13 = *(unsigned __int16 *)v12;
    v14 = *((unsigned __int16 *)v12 + 1);
    v15 = *((unsigned __int16 *)v12 + 2);
  }
  v16 = a1 + 12 * a4;
  v17 = (unsigned __int16 *)(a1 + 6 * a4);
  *a5 = dequantValueToS32(v13, *(_DWORD *)(v16 + 64), *(unsigned __int16 *)(a1 + 100), v17[14], v17[23], a8);
  *a6 = dequantValueToS32(v14, *(_DWORD *)(v16 + 68), *(unsigned __int16 *)(a1 + 100), v17[15], v17[24], a8);
  *a7 = dequantValueToU32(v15, *(_DWORD *)(v16 + 72), *(unsigned __int16 *)(a1 + 100), v17[16], v17[25], a8);
  return 0;
}

uint64_t dequantValueToS32(int a1, int a2, unsigned int a3, unsigned int a4, int a5, unsigned int a6)
{
  int v9;
  __int16 v10;
  int v11;
  unsigned int v12;

  if (a6 + 16 <= a4)
  {
    v10 = a4 - a6;
    v9 = a5;
  }
  else
  {
    a1 <<= a6 + 16 - a4;
    v9 = a5;
    v10 = 16;
  }
  v11 = fxd_S32ShMultRndS32S32(a1, v9, v10);
  v12 = v11 + (a2 << (a6 - a3));
  if ((int)(0x7FFFFFFFu >> (a6 - a3)) <= a2)
    v12 = 0x7FFFFFFF;
  if (a3 > a6)
    return (v11 + (a2 >> (a3 - a6)));
  else
    return v12;
}

uint64_t dequantEnergy(unsigned __int16 *a1, int a2, int a3, __int16 a4, _DWORD *a5, _DWORD *a6, unsigned int a7)
{
  uint64_t result;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;

  result = 2229280793;
  v11 = *((_DWORD *)a1 + 16);
  if (v11)
  {
    if (v11 != 1)
      return result;
    v12 = *((_QWORD *)a1 + 7) + 16 * a2;
    v13 = *(_QWORD *)v12 + *(unsigned int *)(v12 + 8);
    v14 = *a1;
    v15 = a1[1] + a1[2] * v14;
    v16 = 2 * a3 - 2;
  }
  else
  {
    v17 = *((_QWORD *)a1 + 7) + 16 * a2;
    v13 = *(_QWORD *)v17 + *(unsigned int *)(v17 + 8);
    v15 = a3 - 1;
    v14 = *a1;
    v16 = a1[1] + 2 * v14 * a1[2];
  }
  v18 = v13 + (v16 * v15);
  if (v18)
  {
    v19 = 2 * a4;
    v20 = (unsigned __int16)(2 * a4);
    if (v14 == 1)
      v21 = *(unsigned __int8 *)(v18 + v20);
    else
      v21 = *(unsigned __int16 *)(v18 + 2 * v20);
    v22 = *((_QWORD *)a1 + 5) + 40 * (unsigned __int16)(2 * a4);
    *a5 = dequantValueToS32(v21, **(_DWORD **)(v22 + 8), *(unsigned __int16 *)(v22 + 16), **(unsigned __int16 **)(v22 + 24), **(unsigned __int16 **)(v22 + 32), a7);
    if (a6)
    {
      v23 = v19 | 1u;
      if (*a1 == 1)
        v24 = *(unsigned __int8 *)(v18 + v23);
      else
        v24 = *(unsigned __int16 *)(v18 + 2 * v23);
      v25 = *((_QWORD *)a1 + 5) + 40 * (v19 | 1u);
      v26 = dequantValueToS32(v24, **(_DWORD **)(v25 + 8), *(unsigned __int16 *)(v25 + 16), **(unsigned __int16 **)(v25 + 24), **(unsigned __int16 **)(v25 + 32), a7);
      result = 0;
      *a6 = v26;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t deVQSpectrum(unsigned __int16 *a1, uint64_t a2, int a3, int a4, int a5, int a6, __int16 a7, _DWORD *a8, _DWORD *a9, unsigned __int16 a10)
{
  unsigned __int16 v12;
  uint64_t v13;
  int v14;
  unsigned __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  v12 = a1[4];
  v13 = (unsigned __int16)(v12 * a7);
  v14 = a1[2];
  v15 = (v14 + a7) * v12;
  v16 = *((_DWORD *)a1 + 16);
  if (v16)
  {
    if (v16 == 1)
    {
      v17 = *((_QWORD *)a1 + 7) + 16 * a3;
      v18 = *(_QWORD *)v17
          + *(unsigned int *)(v17 + 8)
          + (2 * a4 - 2) * (*a1 * v14 + a1[1])
          + 2 * *a1 * v14;
      v19 = v13 + a5;
      v20 = *(unsigned __int16 *)(v18 + 2 * v19);
      v21 = v15 + (uint64_t)a5;
      v22 = *(unsigned __int16 *)(v18 + 2 * v21);
    }
    else
    {
      v20 = 0;
      v22 = 0;
      v19 = (int)v13 + a5;
      v21 = a5 + v15;
    }
  }
  else
  {
    v23 = *((_QWORD *)a1 + 7) + 16 * a3;
    v24 = *(_QWORD *)v23
        + *(unsigned int *)(v23 + 8)
        + 2 * v14 * *a1
        + (a1[1] + 2 * v14 * *a1) * (a4 - 1);
    v19 = v13 + a5;
    v20 = *(unsigned __int8 *)(v24 + v19);
    v21 = v15 + (uint64_t)a5;
    v22 = *(unsigned __int8 *)(v24 + v21);
  }
  dequantCbkVectorElem((unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 168 * v19), v20, a6, a8, a10);
  dequantCbkVectorElem((unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 168 * v21), v22, a6, a9, a10);
  return 0;
}

uint64_t dequantCbkVectorElem(unsigned __int16 *a1, int a2, int a3, _DWORD *a4, unsigned int a5)
{
  int v6;
  uint64_t v7;
  int v8;
  uint64_t result;

  v6 = a1[2];
  v7 = *((_QWORD *)a1 + 18) + *((unsigned int *)a1 + 38) + *a1 * (uint64_t)(v6 * a2);
  if (v6 == 1)
    v8 = *(unsigned __int8 *)(v7 + a3);
  else
    v8 = *(unsigned __int16 *)(v7 + 2 * a3);
  result = dequantValueToS32(v8, *(_DWORD *)&a1[2 * a3 + 38], a1[36], a1[a3 + 4], a1[a3 + 20], a5);
  *a4 = result;
  return result;
}

uint64_t loadQuantizedDurFile(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  int v15;
  uint64_t v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  char *v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  char v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v34 = 0;
  BET3FXD__xfread_BET3((char *)&v34 + 2, 2u, 1, (unsigned int *)a3);
  if (HIWORD(v34) != 1)
  {
    v12 = 2229280772;
    v13 = *(_QWORD *)(a1 + 32);
    v14 = "LoadQuantizedDurFile: invalid quantization format";
    goto LABEL_7;
  }
  BET3FXD__xfread_BET3((char *)&v34 + 2, 2u, 1, (unsigned int *)a3);
  BET3FXD__xfread_BET3((char *)&v34 + 2, 2u, 1, (unsigned int *)a3);
  v11 = HIWORD(v34);
  *(_DWORD *)a2 = HIWORD(v34);
  if ((v11 - 3) <= 0xFFFFFFFD)
  {
    v12 = 2229280772;
    v13 = *(_QWORD *)(a1 + 32);
    v14 = "LoadQuantizedDurFile: invalid value for code length";
LABEL_7:
    log_OutText(v13, (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)v14, v8, v9, v10, v33);
    return v12;
  }
  BET3FXD__xfread_BET3((char *)&v34 + 2, 2u, 1, (unsigned int *)a3);
  v15 = HIWORD(v34);
  *(_DWORD *)(a2 + 4) = HIWORD(v34);
  if ((v15 - 8) <= 0xFFFFFFF8)
  {
    v12 = 2229280772;
    v13 = *(_QWORD *)(a1 + 32);
    v14 = "LoadDurFile : the number of HMM states is illegal";
    goto LABEL_7;
  }
  v17 = 0;
  v18 = 4 - (*(_DWORD *)a3 & 3);
  if ((*(_DWORD *)a3 & 3) == 0)
    v18 = 0;
  v19 = v18 + *(_DWORD *)a3;
  if (v19 >= *(_DWORD *)(a3 + 16))
    v19 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)a3 = v19;
  v20 = a2 + 70;
  do
  {
    BET3FXD__xfread_BET3((void *)v20, 2u, 1, (unsigned int *)a3);
    BET3FXD__xfread_BET3((void *)(v20 + 28), 2u, 1, (unsigned int *)a3);
    ++v17;
    v20 += 2;
  }
  while (v17 < 2 * *(int *)(a2 + 4));
  BET3FXD__xfread_BET3(&v34, 2u, 1, (unsigned int *)a3);
  v21 = 4 - (*(_DWORD *)a3 & 3);
  if ((*(_DWORD *)a3 & 3) == 0)
    v21 = 0;
  v22 = v21 + *(_DWORD *)a3;
  if (v22 >= *(_DWORD *)(a3 + 16))
    v22 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)a3 = v22;
  if (*(int *)(a2 + 4) >= 1)
  {
    v23 = &v35;
    v24 = 3;
    do
    {
      BET3FXD__xfread_BET3(v23, 2u, 1, (unsigned int *)a3);
      v25 = *(unsigned __int16 *)v23;
      v23 += 2;
      v26 = v25 >> (v34 - a4);
      v27 = v25 << (a4 - v34);
      if ((unsigned __int16)v34 <= a4)
        v28 = v27;
      else
        v28 = v26;
      *(_DWORD *)(a2 + 4 * v24) = v28;
      v29 = v24 - 2;
      ++v24;
    }
    while (v29 < 2 * *(int *)(a2 + 4));
  }
  *(_WORD *)(a2 + 68) = a4;
  BET3FXD__xfread_BET3((char *)&v34 + 2, 2u, 1, (unsigned int *)a3);
  v12 = 0;
  v30 = *(_DWORD *)a3;
  v31 = 4 - (*(_DWORD *)a3 & 3);
  *(_DWORD *)(a2 + 8) = HIWORD(v34);
  if ((v30 & 3) == 0)
    v31 = 0;
  v32 = v31 + v30;
  if (v32 >= *(_DWORD *)(a3 + 16))
    v32 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)a3 = v32;
  *(_QWORD *)(a2 + 128) = *(_QWORD *)(a3 + 8);
  *(_DWORD *)(a2 + 136) = v32;
  return v12;
}

uint64_t loadQuantizedMsdFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t i;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  unsigned __int16 v46;
  int v47;

  v47 = 0;
  v12 = 2229280772;
  v46 = 0;
  *(_DWORD *)(a2 + 4) = a3;
  BET3FXD__xfread_BET3((char *)&v47 + 2, 2u, 1, (unsigned int *)a4);
  if (HIWORD(v47) != 1)
  {
    v17 = "LoadQuantizedFreqFile: invalid quantization format";
    goto LABEL_5;
  }
  BET3FXD__xfread_BET3((char *)&v47 + 2, 2u, 1, (unsigned int *)a4);
  BET3FXD__xfread_BET3((char *)&v47 + 2, 2u, 1, (unsigned int *)a4);
  v16 = HIWORD(v47);
  *(_DWORD *)(a2 + 8) = HIWORD(v47);
  if ((v16 - 4) < 0xFFFFFFFD)
  {
    v17 = "LoadQuantizedFreqFile: invalid value for number of streams";
LABEL_5:
    log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)v17, v13, v14, v15, v45);
    return v12;
  }
  BET3FXD__xfread_BET3((char *)&v47 + 2, 2u, 1, (unsigned int *)a4);
  v19 = HIWORD(v47);
  *(_DWORD *)a2 = HIWORD(v47);
  if ((v19 - 3) < 0xFFFFFFFE)
  {
    v17 = "LoadQuantizedFreqFile: invalid value for code length";
    goto LABEL_5;
  }
  v20 = 4 - (*(_DWORD *)a4 & 3);
  if ((*(_DWORD *)a4 & 3) == 0)
    v20 = 0;
  v21 = v20 + *(_DWORD *)a4;
  if (v21 >= *(_DWORD *)(a4 + 16))
    v21 = *(_DWORD *)(a4 + 16);
  *(_DWORD *)a4 = v21;
  BET3FXD__xfread_BET3((void *)(a2 + 14), 2u, a3, (unsigned int *)a4);
  v22 = 4 - (*(_DWORD *)a4 & 3);
  if ((*(_DWORD *)a4 & 3) == 0)
    v22 = 0;
  v23 = v22 + *(_DWORD *)a4;
  if (v23 >= *(_DWORD *)(a4 + 16))
    v23 = *(_DWORD *)(a4 + 16);
  *(_DWORD *)a4 = v23;
  if (*(int *)(a2 + 8) >= 1)
  {
    v24 = 0;
    v25 = a2;
    do
    {
      v26 = -6;
      do
      {
        BET3FXD__xfread_BET3((void *)(v25 + v26 + 34), 2u, 1, (unsigned int *)a4);
        BET3FXD__xfread_BET3((void *)(v25 + v26 + 52), 2u, 1, (unsigned int *)a4);
        v26 += 2;
      }
      while (v26);
      ++v24;
      v25 += 6;
    }
    while (v24 < *(int *)(a2 + 8));
  }
  BET3FXD__xfread_BET3(&v46, 2u, 1, (unsigned int *)a4);
  v30 = 4 - (*(_DWORD *)a4 & 3);
  if ((*(_DWORD *)a4 & 3) == 0)
    v30 = 0;
  v31 = v30 + *(_DWORD *)a4;
  if (v31 >= *(_DWORD *)(a4 + 16))
    v31 = *(_DWORD *)(a4 + 16);
  *(_DWORD *)a4 = v31;
  if (*(int *)(a2 + 8) >= 1)
  {
    v32 = 0;
    v33 = a2 + 64;
    do
    {
      for (i = 0; i != 12; i += 4)
      {
        BET3FXD__xfread_BET3(&v47, 2u, 1, (unsigned int *)a4);
        if (v46 <= a5)
          v35 = (__int16)v47 << (a5 - v46);
        else
          v35 = (__int16)v47 >> (v46 - a5);
        *(_DWORD *)(v33 + i) = v35;
      }
      ++v32;
      v33 += 12;
    }
    while (v32 < *(int *)(a2 + 8));
  }
  *(_WORD *)(a2 + 100) = a5;
  v36 = *(unsigned int *)(a2 + 64);
  if ((int)v36 >= a6)
    a6 = (13 * ((int)v36 >> 2)) >> 2;
  else
    log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"LoadQuantizedFreqFile : minimum Log pitch value is too small (%d in Q%d), clamping to minimum (%d)\n", v27, v28, v29, v36);
  *(_DWORD *)(a2 + 104) = a6;
  *(_QWORD *)(a2 + 112) = *(_QWORD *)(a4 + 8);
  v37 = heap_Calloc(*(_QWORD **)(a1 + 8), a3, 4);
  *(_QWORD *)(a2 + 120) = v37;
  if (!v37)
    return 2229280778;
  v38 = *(_DWORD *)(a2 + 4);
  v39 = (-3 * *(_DWORD *)a2 * *(_DWORD *)(a2 + 8)) & 3;
  v40 = v39 + 3 * *(_DWORD *)a2 * *(_DWORD *)(a2 + 8);
  *(_WORD *)(a2 + 12) = ((-3 * *(_WORD *)a2 * *(_WORD *)(a2 + 8)) & 3) + 3 * *(_WORD *)a2 * *(_WORD *)(a2 + 8);
  if (v38 >= 1)
  {
    v41 = 0;
    v42 = *(_DWORD *)a4;
    do
    {
      v43 = 4 - (v42 & 3);
      if ((v42 & 3) == 0)
        v43 = 0;
      v44 = v43 + v42;
      if (v44 >= *(_DWORD *)(a4 + 16))
        v44 = *(_DWORD *)(a4 + 16);
      *(_DWORD *)a4 = v44;
      *(_DWORD *)(v37 + 4 * v41) = v44;
      v42 = *(_DWORD *)a4 - v39 + (unsigned __int16)v40 * *(unsigned __int16 *)(a2 + 14 + 2 * v41);
      *(_DWORD *)a4 = v42;
      ++v41;
    }
    while (v41 < *(int *)(a2 + 4));
  }
  return 0;
}

uint64_t loadVQQuantizedCepFile(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int16 v9;
  uint64_t v10;
  unsigned __int16 v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _WORD *v18;
  uint64_t v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  void *v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  unint64_t v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  unsigned int *v55;
  uint64_t v56;
  int v57;
  uint64_t v59;
  _WORD *v60;
  uint64_t v61;
  uint64_t v62;
  __int16 v63;

  v63 = 0;
  *((_DWORD *)a2 + 16) = 0;
  BET3FXD__xfread_BET3(&v63, 2u, 1, (unsigned int *)a3);
  if (v63 != 1)
  {
    if (v63 != 2)
    {
      log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"LoadVQQuantizedCepFile: invalid quantization format", v6, v7, v8, v59);
      return 2229280772;
    }
    *((_DWORD *)a2 + 16) = 1;
  }
  BET3FXD__xfread_BET3(&v63, 2u, 1, (unsigned int *)a3);
  BET3FXD__xfread_BET3(a2 + 3, 2u, 1, (unsigned int *)a3);
  BET3FXD__xfread_BET3(a2 + 2, 2u, 1, (unsigned int *)a3);
  v9 = a2[2];
  BET3FXD__xfread_BET3(a2 + 5, 2u, 1, (unsigned int *)a3);
  a2[6] = a2[5] + 1;
  *((_DWORD *)a2 + 4) = 2;
  BET3FXD__xfread_BET3(&v63, 2u, 1, (unsigned int *)a3);
  v10 = 2229280772;
  if (v63 == 1)
  {
    v10 = 2229280778;
    v11 = 2 * v9;
    BET3FXD__xfread_BET3(a2 + 1, 2u, 1, (unsigned int *)a3);
    BET3FXD__xfread_BET3(a2, 2u, 1, (unsigned int *)a3);
    v12 = 4 - (*(_DWORD *)a3 & 3);
    if ((*(_DWORD *)a3 & 3) == 0)
      v12 = 0;
    v13 = v12 + *(_DWORD *)a3;
    if (v13 >= *(_DWORD *)(a3 + 16))
      v13 = *(_DWORD *)(a3 + 16);
    *(_DWORD *)a3 = v13;
    v62 = v11;
    v14 = heap_Calloc(*(_QWORD **)(a1 + 8), v11, 40);
    *((_QWORD *)a2 + 5) = v14;
    if (v14)
    {
      v60 = a2 + 5;
      if (v11)
      {
        v15 = 0;
        v61 = a1;
        do
        {
          v16 = *((_QWORD *)a2 + 5);
          v17 = v16 + 40 * v15;
          v18 = (_WORD *)(v17 + 2);
          BET3FXD__xfread_BET3((void *)(v17 + 2), 2u, 1, (unsigned int *)a3);
          v19 = heap_Calloc(*(_QWORD **)(a1 + 8), *(unsigned __int16 *)(v17 + 2), 4);
          *(_QWORD *)(v17 + 8) = v19;
          v20 = (void **)(v17 + 8);
          if (!v19)
            return 2229280778;
          v21 = heap_Calloc(*(_QWORD **)(a1 + 8), (unsigned __int16)*v18, 2);
          v22 = v16 + 40 * v15;
          *(_QWORD *)(v22 + 24) = v21;
          v23 = (_QWORD *)(v22 + 24);
          if (!v21)
            return 2229280778;
          v24 = heap_Calloc(*(_QWORD **)(a1 + 8), (unsigned __int16)*v18, 2);
          v28 = v16 + 40 * v15;
          *(_QWORD *)(v28 + 32) = v24;
          v29 = (_QWORD *)(v28 + 32);
          if (!v24)
            return 2229280778;
          if (!*v18)
          {
            log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)"ReadQuantDescr: number of streams is wrong\n", v25, v26, v27, v59);
            return 2229280772;
          }
          v30 = 0;
          v31 = 0;
          v32 = 4 - (*(_DWORD *)a3 & 3);
          if ((*(_DWORD *)a3 & 3) == 0)
            v32 = 0;
          v33 = v32 + *(_DWORD *)a3;
          if (v33 >= *(_DWORD *)(a3 + 16))
            v33 = *(_DWORD *)(a3 + 16);
          *(_DWORD *)a3 = v33;
          do
          {
            BET3FXD__xfread_BET3((void *)(*v23 + v30), 2u, 1, (unsigned int *)a3);
            BET3FXD__xfread_BET3((void *)(*v29 + v30), 2u, 1, (unsigned int *)a3);
            ++v31;
            v30 += 2;
          }
          while (v31 < (unsigned __int16)*v18);
          BET3FXD__xfread_BET3((void *)(v16 + 40 * v15 + 16), 2u, 1, (unsigned int *)a3);
          v34 = 4 - (*(_DWORD *)a3 & 3);
          if ((*(_DWORD *)a3 & 3) == 0)
            v34 = 0;
          v35 = v34 + *(_DWORD *)a3;
          if (v35 >= *(_DWORD *)(a3 + 16))
            v35 = *(_DWORD *)(a3 + 16);
          *(_DWORD *)a3 = v35;
          BET3FXD__xfread_BET3(*v20, 4u, (unsigned __int16)*v18, (unsigned int *)a3);
          ++v15;
          a1 = v61;
        }
        while (v15 != v62);
      }
      BET3FXD__xfread_BET3(a2 + 4, 2u, 1, (unsigned int *)a3);
      v36 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), a2[4], 2);
      *((_QWORD *)a2 + 3) = v36;
      if (!v36)
        return 2229280778;
      v37 = 4 - (*(_DWORD *)a3 & 3);
      if ((*(_DWORD *)a3 & 3) == 0)
        v37 = 0;
      v38 = v37 + *(_DWORD *)a3;
      if (v38 >= *(_DWORD *)(a3 + 16))
        v38 = *(_DWORD *)(a3 + 16);
      *(_DWORD *)a3 = v38;
      BET3FXD__xfread_BET3(v36, 2u, a2[4], (unsigned int *)a3);
      v39 = (unsigned __int16)*v60;
      v10 = 2229280778;
      if (*v60)
      {
        v40 = 0;
        v41 = 0;
        v42 = a2[4];
        v43 = *((_QWORD *)a2 + 4);
        do
        {
          v44 = v40 + 1;
          if (v41 + 1 < v42 && v44 > *(unsigned __int16 *)(*((_QWORD *)a2 + 3) + 2 * (v41 + 1)))
            ++v41;
          *(_DWORD *)(v43 + 4 * v40++) = v41;
        }
        while (v39 != v44);
      }
      v45 = 4 - (*(_DWORD *)a3 & 3);
      if ((*(_DWORD *)a3 & 3) == 0)
        v45 = 0;
      v46 = v45 + *(_DWORD *)a3;
      if (v46 >= *(_DWORD *)(a3 + 16))
        v46 = *(_DWORD *)(a3 + 16);
      *(_DWORD *)a3 = v46;
      BET3FXD__xfread2ptr_BET3((_QWORD *)a2 + 6, 2u, a2[3], (unsigned int *)a3);
      *((_QWORD *)a2 + 6) -= 4;
      v47 = heap_Calloc(*(_QWORD **)(a1 + 8), a2[3], 16);
      *((_QWORD *)a2 + 7) = v47;
      if (v47)
      {
        v48 = *(_DWORD *)a3;
        v49 = 4 - (*(_DWORD *)a3 & 3);
        if ((*(_DWORD *)a3 & 3) == 0)
          v49 = 0;
        *((_QWORD *)a2 + 7) = v47 - 32;
        v50 = v49 + v48;
        v51 = *(_DWORD *)(a3 + 16);
        if (v50 >= v51)
          v50 = *(_DWORD *)(a3 + 16);
        *(_DWORD *)a3 = v50;
        if (a2[3])
        {
          v52 = *(_QWORD *)(a3 + 8);
          v53 = *((_DWORD *)a2 + 16);
          v54 = -(uint64_t)a2[3];
          v55 = (unsigned int *)(v47 + 8);
          v56 = 2;
          do
          {
            v57 = 4 - (v50 & 3);
            if ((v50 & 3) == 0)
              v57 = 0;
            v50 += v57;
            if (v50 >= v51)
              v50 = v51;
            *((_QWORD *)v55 - 1) = v52;
            *v55 = v50;
            if (v53)
            {
              if (v53 == 1)
                v50 += 2 * *(unsigned __int16 *)(*((_QWORD *)a2 + 6) + 2 * v56) * (a2[1] + a2[2] * *a2);
            }
            else
            {
              v50 += (a2[1] + 2 * *a2 * a2[2]) * *(unsigned __int16 *)(*((_QWORD *)a2 + 6) + 2 * v56);
            }
            ++v56;
            v55 += 4;
          }
          while (v54 + v56 != 2);
          v10 = 0;
          *(_DWORD *)a3 = v50;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v10;
}

uint64_t loadCodebookSet(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v15;
  unsigned int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _WORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  char *v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  unint64_t v37;
  unsigned __int16 v38;
  unsigned int v39;
  int v40;
  unint64_t v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 v49;
  unsigned __int16 *v50;
  _OWORD v51[38];
  __int16 v52[6];

  v8 = 2229280772;
  memset(v51, 0, 512);
  v52[1] = 0;
  BET3FXD__xfread_BET3(&v52[1], 2u, 1, (unsigned int *)a3);
  if (v52[1] != 1)
  {
    v13 = "ReadQCodeBookSetHdr: invalid quantization format";
    goto LABEL_5;
  }
  BET3FXD__xfread_BET3(&v52[1], 2u, 1, (unsigned int *)a3);
  BET3FXD__xfread_BET3(v51, 2u, 1, (unsigned int *)a3);
  v12 = LOWORD(v51[0]);
  if (LOWORD(v51[0]) >= 0x97u)
  {
    v13 = "ReadQCodeBookSetHdr : Number of codebooks is too high, aborting\n";
LABEL_5:
    log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)v13, v9, v10, v11, v46);
    return v8;
  }
  v15 = 4 - (*(_DWORD *)a3 & 3);
  if ((*(_DWORD *)a3 & 3) == 0)
    v15 = 0;
  v16 = v15 + *(_DWORD *)a3;
  if (v16 >= *(_DWORD *)(a3 + 16))
    v16 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)a3 = v16;
  BET3FXD__xfread_BET3((char *)v51 + 4, 4u, v12, (unsigned int *)a3);
  v17 = v51[0];
  v18 = heap_Calloc(*(_QWORD **)(a1 + 8), LOWORD(v51[0]), 168);
  *(_QWORD *)(a2 + 8) = v18;
  if (!v18)
    return 2229280778;
  *(_WORD *)(a2 + 2) = v17;
  *(_WORD *)a2 = 0;
  v19 = v51[0];
  if (LOWORD(v51[0]))
  {
    v49 = a4;
    v47 = a1;
    v48 = a2;
    v20 = 0;
    v21 = 40;
    v22 = 76;
    while (1)
    {
      v23 = *(_QWORD *)(a2 + 8);
      v24 = (_WORD *)(v23 + 168 * v20);
      *(_DWORD *)v52 = 0;
      BET3FXD__xfread_BET3(v24, 2u, 1, (unsigned int *)a3);
      if ((unsigned __int16)*v24 > 0x10u)
      {
        v45 = "LoadQuantizedCodebook: invalid value for codebook vector length\n";
        goto LABEL_49;
      }
      v28 = v23 + 168 * v20;
      BET3FXD__xfread_BET3((void *)(v28 + 2), 2u, 1, (unsigned int *)a3);
      v29 = (unsigned __int16 *)(v28 + 4);
      BET3FXD__xfread_BET3((void *)(v28 + 4), 2u, 1, (unsigned int *)a3);
      if (*(unsigned __int16 *)(v28 + 4) - 3 < 0xFFFFFFFE)
        break;
      v50 = (unsigned __int16 *)(v28 + 2);
      v30 = 4 - (*(_DWORD *)a3 & 3);
      if ((*(_DWORD *)a3 & 3) == 0)
        v30 = 0;
      v31 = v30 + *(_DWORD *)a3;
      if (v31 >= *(_DWORD *)(a3 + 16))
        v31 = *(_DWORD *)(a3 + 16);
      *(_DWORD *)a3 = v31;
      if (*v24)
      {
        v32 = 0;
        v33 = (char *)(v23 + v21);
        do
        {
          BET3FXD__xfread_BET3(v33 - 32, 2u, 1, (unsigned int *)a3);
          BET3FXD__xfread_BET3(v33, 2u, 1, (unsigned int *)a3);
          ++v32;
          v33 += 2;
        }
        while (v32 < (unsigned __int16)*v24);
      }
      BET3FXD__xfread_BET3(&v52[1], 2u, 1, (unsigned int *)a3);
      v34 = 4 - (*(_DWORD *)a3 & 3);
      if ((*(_DWORD *)a3 & 3) == 0)
        v34 = 0;
      v35 = *(_DWORD *)(a3 + 16);
      if (v34 + *(_DWORD *)a3 >= v35)
        v36 = *(_DWORD *)(a3 + 16);
      else
        v36 = v34 + *(_DWORD *)a3;
      *(_DWORD *)a3 = v36;
      if (*v24)
      {
        v37 = 0;
        v38 = v49;
        do
        {
          BET3FXD__xfread_BET3(v52, 2u, 1, (unsigned int *)a3);
          v39 = (unsigned __int16)v52[1];
          if ((unsigned __int16)v52[1] <= v38)
          {
            if ((unsigned __int16)v52[1] + 16 < v38)
              v38 = v52[1] + 16;
            v40 = v52[0] << (v38 - LOBYTE(v52[1]));
          }
          else
          {
            v40 = v52[0];
          }
          *(_DWORD *)(v23 + v22 + 4 * v37++) = v40;
          v41 = (unsigned __int16)*v24;
        }
        while (v37 < v41);
        v36 = *(_DWORD *)a3;
        v35 = *(_DWORD *)(a3 + 16);
        a2 = v48;
      }
      else
      {
        LODWORD(v41) = 0;
        v39 = (unsigned __int16)v52[1];
        v38 = v49;
      }
      v42 = 4 - (v36 & 3);
      if ((v36 & 3) == 0)
        v42 = 0;
      if (v39 <= v38)
        LOWORD(v39) = v38;
      v43 = v23 + 168 * v20;
      *(_WORD *)(v43 + 72) = v39;
      v44 = v42 + v36;
      if (v42 + v36 >= v35)
        v44 = v35;
      *(_QWORD *)(v43 + 144) = *(_QWORD *)(a3 + 8);
      *(_DWORD *)(v43 + 152) = v44;
      *(_DWORD *)a3 = v44 + v41 * *v29 * *v50;
      ++v20;
      v19 = v51[0];
      v21 += 168;
      v22 += 168;
      if (v20 >= LOWORD(v51[0]))
        goto LABEL_45;
    }
    v45 = "LoadQuantizedCodebook: invalid value for code length\n";
LABEL_49:
    log_OutText(*(_QWORD *)(v47 + 32), (uint64_t)"SELECT_BET3", 3, 0, (uint64_t)v45, v25, v26, v27, v47);
    return 2229280772;
  }
  else
  {
LABEL_45:
    v8 = 0;
    *(_WORD *)a2 = v19;
  }
  return v8;
}

uint64_t synth_bet3_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2164269057;
  result = 0;
  *a2 = &ISynth_Bet3_0;
  return result;
}

uint64_t synth_bet3_ObjOpen_0(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t Object;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  __int128 v40;
  uint64_t (*v41)(uint64_t, char *, const char *);
  char *__s1;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;

  Object = 2164269063;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  __s1 = 0;
  v40 = xmmword_24D294608;
  v41 = synth_bet3_loc_ParamLearnChange_0;
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, &v45);
    if ((inited & 0x80000000) != 0)
      return inited;
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Entering synth_bet3_ObjOpen", v10, v11, v12, v37);
    v13 = (_QWORD *)heap_Calloc(*(_QWORD **)(v45 + 8), 1, 1344);
    if (!v13)
    {
      log_OutPublic(*(_QWORD *)(v45 + 32), (uint64_t)"SYNTH_BET3", 56000, 0, v14, v15, v16, v17, v38);
      Object = 2164269066;
LABEL_27:
      log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"synth_bet3_ObjOpen: %x", v26, v27, v28, Object);
      log_OutEvent(*(uint64_t ***)(v45 + 32), 22, (uint64_t)"", v31, v32, v33, v34, v35, v39);
      return Object;
    }
    v18 = (uint64_t)v13;
    *v13 = a3;
    v13[1] = a4;
    v19 = v45;
    v13[2] = v45;
    if ((critsec_ObjOpen(*(_QWORD *)(v19 + 16), *(_QWORD **)(v19 + 8), v13 + 3) & 0x80000000) == 0)
    {
      *(_QWORD *)&v40 = v18;
      if ((synth_bet3_loc_ParamGetListen_0(v18, "volume", 0, 100, 0x50u, &v40, &v43) & 0x80000000) == 0
        && (synth_bet3_loc_ParamGetListen_0(v18, "rate", 50, 400, 0x64u, &v40, &v43) & 0x80000000) == 0
        && (synth_bet3_loc_ParamGetListen_0(v18, "rate_baseline", 50, 400, 0x64u, &v40, &v43) & 0x80000000) == 0
        && (synth_bet3_loc_ParamGetListen_0(v18, "pitch", 50, 200, 0x64u, &v40, &v43) & 0x80000000) == 0
        && (synth_bet3_loc_ParamGetListen_0(v18, "pitch_baseline", 50, 200, 0x64u, &v40, &v43) & 0x80000000) == 0
        && (synth_bet3_loc_ParamGetListen_0(v18, "audiooutputbufsamples", 1, 0x7FFFFFFF, 0x100u, &v40, &v43) & 0x80000000) == 0)
      {
        *(_DWORD *)(v18 + 40) = v43;
      }
    }
    if ((paramc_ParamGetStr(*(_QWORD *)(v45 + 40), (uint64_t)"synth_type", &__s1) & 0x80000000) == 0)
    {
      if (!cstdlib_strcmp(__s1, "rcc"))
      {
        log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Setting up MRCC synthesizer", v20, v21, v22, v38);
        *(_DWORD *)(v18 + 1036) = 1;
        v29 = synth_bet3_loc_SynthInit_MRCC(v18);
LABEL_22:
        Object = v29;
        if ((v29 & 0x80000000) == 0)
        {
          Object = objc_GetObject(*(_QWORD *)(v45 + 48), (uint64_t)"SYNTHSTREAM", &v44);
          if ((Object & 0x80000000) == 0)
          {
            *(_QWORD *)(v18 + 32) = *(_QWORD *)(v44 + 8);
            *(_QWORD *)a5 = v18;
            *(_DWORD *)(a5 + 8) = 9346;
            goto LABEL_27;
          }
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(v18 + 16) + 32), (uint64_t)"SYNTH_BET3", 56001, 0, v30, v26, v27, v28, v38);
        }
        *(_QWORD *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 9346;
        synth_bet3_ObjClose_0(v18, *(_QWORD *)(a5 + 8));
        *(_QWORD *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        goto LABEL_27;
      }
      if (cstdlib_strcmp(__s1, "mlsa") && cstdlib_strcmp(__s1, "mfs"))
      {
        log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Unknown synthesizer: %s", v23, v24, v25, (uint64_t)__s1);
        return 7;
      }
      log_OutText(*(_QWORD *)(v45 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Setting up MLSA synthesizer", v23, v24, v25, v38);
    }
    *(_DWORD *)(v18 + 1036) = 0;
    v29 = synth_bet3_loc_SynthInit_MLSA_0(v18);
    goto LABEL_22;
  }
  return Object;
}

uint64_t synth_bet3_ObjClose_0(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  int v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  int v24;
  int v26;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;

  v3 = safeh_HandleCheck(a1, a2, 9346, 1344);
  if (v3 < 0)
    return 2164269064;
  LODWORD(v7) = v3;
  v8 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Entering synth_bet3_ObjClose", v4, v5, v6, v36);
  v9 = *(_QWORD *)(v8 + 40);
  v37 = a1;
  v38 = *(__int128 *)((char *)&xmmword_24D294608 + 8);
  v10 = paramc_ListenerRemove(v9, "volume", (__int128 *)&v37);
  v11 = *(_QWORD *)(v8 + 40);
  if (v10 < 0)
    LODWORD(v7) = v10;
  v37 = a1;
  v38 = *(__int128 *)((char *)&xmmword_24D294608 + 8);
  v12 = paramc_ListenerRemove(v11, "rate", (__int128 *)&v37);
  v13 = *(_QWORD *)(v8 + 40);
  if (v12 < 0 && (int)v7 > -1)
    LODWORD(v7) = v12;
  v37 = a1;
  v38 = *(__int128 *)((char *)&xmmword_24D294608 + 8);
  v15 = paramc_ListenerRemove(v13, "rate_baseline", (__int128 *)&v37);
  v16 = *(_QWORD *)(v8 + 40);
  if (v15 < 0 && (int)v7 > -1)
    LODWORD(v7) = v15;
  v37 = a1;
  v38 = *(__int128 *)((char *)&xmmword_24D294608 + 8);
  v18 = paramc_ListenerRemove(v16, "pitch", (__int128 *)&v37);
  v19 = *(_QWORD *)(v8 + 40);
  if (v18 < 0 && (int)v7 > -1)
    LODWORD(v7) = v18;
  v37 = a1;
  v38 = *(__int128 *)((char *)&xmmword_24D294608 + 8);
  v21 = paramc_ListenerRemove(v19, "pitch_baseline", (__int128 *)&v37);
  v22 = *(_QWORD *)(v8 + 40);
  if (v21 < 0 && (int)v7 > -1)
    LODWORD(v7) = v21;
  v37 = a1;
  v38 = *(__int128 *)((char *)&xmmword_24D294608 + 8);
  v24 = paramc_ListenerRemove(v22, "audiooutputbufsamples", (__int128 *)&v37);
  if (v24 >= 0 || (int)v7 <= -1)
    v7 = v7;
  else
    v7 = v24;
  if (*(_QWORD *)(a1 + 32))
  {
    v26 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if (v26 >= 0 || (int)v7 <= -1)
      v7 = v7;
    else
      v7 = v26;
  }
  v28 = *(_DWORD *)(a1 + 1036);
  if (v28 == 1)
  {
    RccSyn__deinit_Synthesis(a1 + 1048);
  }
  else if (!v28)
  {
    MFVSyn__denit__MVF_Synthesis((_QWORD **)(a1 + 64));
  }
  v29 = *(_QWORD *)(a1 + 24);
  if (v29)
  {
    v30 = critsec_ObjClose(v29);
    if ((int)v7 > -1 && v30 < 0)
      v7 = v30;
    else
      v7 = v7;
  }
  heap_Free(*(_QWORD **)(v8 + 8), a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"synth_bet3_ObjClose: %x", v32, v33, v34, v7);
  return v7;
}

uint64_t synth_bet3_ObjReopen_0(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t inited;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  char *__s1;

  __s1 = 0;
  if ((safeh_HandleCheck(a1, a2, 9346, 1344) & 0x80000000) != 0)
    return 2164269064;
  v6 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Entering synth_bet3_ObjReopen", v3, v4, v5, v19);
  if ((paramc_ParamGetStr(*(_QWORD *)(v6 + 40), (uint64_t)"synth_type", &__s1) & 0x80000000) != 0)
    goto LABEL_10;
  if (!cstdlib_strcmp(__s1, "rcc"))
  {
    log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Setting up MRCC synthesizer", v7, v8, v9, v20);
    MFVSyn__denit__MVF_Synthesis((_QWORD **)(a1 + 64));
    *(_DWORD *)(a1 + 1036) = 1;
    inited = synth_bet3_loc_SynthInit_MRCC(a1);
LABEL_11:
    v13 = inited;
    log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"synth_bet3_ObjReopen: %x", v15, v16, v17, inited);
    return v13;
  }
  if (!cstdlib_strcmp(__s1, "mlsa") || !cstdlib_strcmp(__s1, "mfs"))
  {
    log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Setting up MLSA synthesizer", v10, v11, v12, v20);
LABEL_10:
    RccSyn__deinit_Synthesis(a1 + 1048);
    *(_DWORD *)(a1 + 1036) = 0;
    inited = synth_bet3_loc_SynthInit_MLSA_0(a1);
    goto LABEL_11;
  }
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET3", 4, 0, (uint64_t)"Unknown synthesizer: %s", v10, v11, v12, (uint64_t)__s1);
  return 7;
}

uint64_t synth_bet3_ProcessStart_0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  int v9;
  uint64_t inited;

  if ((safeh_HandleCheck(a1, a2, 9346, 1344) & 0x80000000) != 0)
    return 2164269064;
  synstrmaux_InitStreamOpener(a1 + 128, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3");
  if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 48), (char *)(a1 + 80), 0x30uLL) > 0x2F)
    return 9;
  synstrmaux_RegisterInStream((_WORD *)(a1 + 128), (uint64_t)"application/x-realspeak-bet3-speech-frames;version=5.0",
    0,
    a1 + 952);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 128), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    0,
    a1 + 968);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 128), a1 + 80, a1 + 984);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 128), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    a1 + 1000);
  v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 128), *(_QWORD *)(a1 + 32), a3, a4);
  if ((v8 & 0x80000000) != 0)
  {
    *(_DWORD *)(a1 + 1016) = 0;
    *(_QWORD *)(a1 + 1028) = 0;
LABEL_12:
    synth_bet3_ProcessEnd_0(a1, a2);
    return v8;
  }
  v9 = *(_DWORD *)(a1 + 1036);
  if (v9)
  {
    if (v9 != 1)
    {
      *(_DWORD *)(a1 + 1016) = 0;
      *(_QWORD *)(a1 + 1028) = 0;
      return v8;
    }
    RccSyn__reset_Synthesis(a1 + 1048);
    inited = synth_bet3_loc_SynthInit_MRCC(a1);
  }
  else
  {
    inited = BET3FXD__MFVSyn__reset__MVF_Synthesis((uint64_t *)(a1 + 64));
  }
  v8 = inited;
  *(_DWORD *)(a1 + 1016) = 0;
  *(_QWORD *)(a1 + 1028) = 0;
  if ((inited & 0x80000000) != 0)
    goto LABEL_12;
  return v8;
}

uint64_t synth_bet3_Process_0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __n128 v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  int *v41;
  int v42;
  int *v43;
  int *v44;
  uint64_t v45;
  int v46;
  int v47;
  unint64_t v48;
  char *v49;
  unsigned int v50;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  const char *v55;
  int v56;
  char *v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  _DWORD *v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  BOOL v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int Data;
  uint64_t v82;
  int *v83;
  unsigned int *v84;
  unsigned int v85;
  int v86;
  BOOL v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  _BOOL4 v98;
  __int16 *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BOOL4 v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int *v117;
  int *v118;
  int *v119;
  int *v120;
  int v121;
  int *v122;
  int *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unsigned int v133;
  uint64_t v134;
  unint64_t v135;
  int v136;
  char *v137;
  char *v138;
  unsigned int v139;
  unint64_t v140;
  int v141;
  char *v142;
  char *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  BOOL v149;
  int v151;
  unsigned int v152;
  unint64_t v153;
  char *v154;
  BOOL v155;
  unsigned int v156;
  uint64_t v157;
  char *v158;
  uint64_t v159;
  unsigned int v160;
  const char *v161;
  char *v162;
  char v163;
  int v164;
  int v165;
  int v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _BOOL4 v174;
  unsigned int v175;
  int v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int v181;
  unsigned int v182;
  unsigned int v183;
  uint64_t v184;
  unsigned int v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  _BOOL4 v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  int v200;
  int v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  uint64_t v211;
  __int16 v212;
  int v213;
  _BOOL4 v214;
  uint64_t v215;
  uint64_t v216;
  int v217;
  unsigned int v218;
  __int16 v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  void *v223;
  void *__dst;
  void *__src;
  unsigned int v226;
  size_t __n;
  _QWORD v228[27];

  v228[25] = *MEMORY[0x24BDAC8D0];
  v8 = -2130698234;
  v9 = safeh_HandleCheck(a1, a2, 9346, 1344);
  if (v9 < 0)
    return 2164269064;
  v10 = 1;
  if (v9 || !a1)
    return v10;
  if (*(_DWORD *)(a1 + 1036) == 1)
  {
    LODWORD(v221) = 0;
    __n = 0;
    v228[0] = 0;
    __dst = 0;
    __src = 0;
    v223 = 0;
    if ((safeh_HandleCheck(a1, a2, 9346, 1344) & 0x80000000) == 0)
    {
      *a5 = 1;
      v11 = *(_DWORD *)(a1 + 40);
      v12 = *(_DWORD *)(a1 + 44);
      if (v11 >= v12)
      {
        if (v12)
          v12 *= v11 / v12;
        else
          v12 = *(_DWORD *)(a1 + 40);
      }
      v10 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, size_t *))(*(_QWORD *)(a1 + 32) + 144))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), &v221, &__n);
      if ((v10 & 0x80000000) == 0)
      {
        if ((_DWORD)v221)
        {
          v20 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), v228, &v221);
          if ((v20 & 0x80000000) == 0)
          {
            v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **, char *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), &__src, (char *)&__n + 4);
            if ((v10 & 0x80000000) == 0)
            {
              if (v221 < 8)
                return v10;
              v29 = (*(uint64_t (**)(_QWORD, _QWORD, void **, _QWORD))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), &v223, 2 * v12);
              if ((v29 & 0x80000000) == 0)
              {
                if (!HIDWORD(__n)
                  || (v34 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), &__dst), (v34 & 0x80000000) == 0))
                {
                  v10 = critsec_Enter(*(_QWORD **)(a1 + 24));
                  if ((v10 & 0x80000000) != 0)
                    return v10;
                  v36 = *(_QWORD *)v228[0];
                  v222 = 0;
                  v226 = 0;
                  v215 = *(_QWORD *)(v36 + 48);
                  LOWORD(v220) = 0;
                  if (HIDWORD(__n) && __src && __dst)
                  {
                    cstdlib_memcpy(__dst, __src, HIDWORD(__n));
                    HIDWORD(__n) >>= 5;
                  }
                  v37 = *(unsigned int *)(v36 + 32);
                  if ((int)v37 < 1)
                    goto LABEL_338;
                  v38 = 0;
                  v39 = 0;
                  v40 = 0;
                  v213 = *(_DWORD *)(a1 + 1324);
                  v41 = *(int **)(v36 + 24);
                  do
                  {
                    v42 = v41[3];
                    if (v42 == 1)
                      v43 = v41;
                    else
                      v43 = v40;
                    if (v42 == 2)
                    {
                      v43 = v40;
                      v44 = v41;
                    }
                    else
                    {
                      v44 = v39;
                    }
                    if (v42 == 3)
                      v38 = v41;
                    v41 += 78;
                    if (v42 != 3)
                    {
                      v40 = v43;
                      v39 = v44;
                    }
                    --v37;
                  }
                  while (v37);
                  v45 = v215;
                  if (!v40 || !v39 || !v38)
                  {
LABEL_338:
                    v209 = critsec_Leave(*(_QWORD **)(a1 + 24));
                    if (v209 >= 0 || v8 <= -1)
                      return v8;
                    else
                      return v209;
                  }
                  v46 = *(_DWORD *)(a1 + 1016);
                  if (v46 >= v40[11])
                  {
                    *(_QWORD *)(a1 + 1028) = 0;
                    if ((v10 & 0x80000000) != 0)
                    {
                      v8 = v10;
                      goto LABEL_338;
                    }
                    v106 = 0;
                    LODWORD(v48) = 0;
                    v8 = v10;
                    goto LABEL_324;
                  }
                  v47 = 0;
                  LODWORD(v48) = 0;
                  v211 = a1 + 1096;
                  v8 = v10;
                  while (1)
                  {
                    if (*(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 44) + v47 > v12)
                    {
LABEL_144:
                      *(_QWORD *)(a1 + 1028) = 0;
                      if ((v8 & 0x80000000) == 0)
                      {
                        if (v47)
                        {
                          v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, __n128))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), (2 * v47), v35);
                          if (v8 < 0)
                          {
                            v208 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_337:
                            log_OutPublic(v208, (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v102, v103, v104, v105, "stream");
                            goto LABEL_338;
                          }
                        }
                      }
                      v106 = v48 != 0;
                      if ((v8 & 0x80000000) == 0 && (_DWORD)v48)
                      {
                        v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, __n128))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), (32 * v48), v35);
                        if ((v8 & 0x80000000) == 0)
                        {
                          v106 = 1;
                          goto LABEL_324;
                        }
                        v208 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                        goto LABEL_337;
                      }
                      if (v8 < 0)
                        goto LABEL_338;
LABEL_324:
                      if (*(_DWORD *)(a1 + 1016) < v40[11])
                      {
                        v202 = 2;
                        goto LABEL_330;
                      }
                      v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), 8);
                      if (v8 < 0)
                      {
                        v207 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                      }
                      else
                      {
                        *(_DWORD *)(a1 + 1016) = 0;
                        if (v221 <= 8)
                          v202 = 1;
                        else
                          v202 = 2;
LABEL_330:
                        *a5 = v202;
                        if (!v106)
                          goto LABEL_338;
                        v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), (32 * v48));
                        if ((v8 & 0x80000000) == 0)
                          goto LABEL_338;
                        v207 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                      }
                      log_OutPublic(v207, (uint64_t)"SYNTH_BET3", 56006, (uint64_t)"%s%s%s%x", v203, v204, v205, v206, "contentType");
                      goto LABEL_338;
                    }
                    v49 = (char *)__dst;
                    v50 = HIDWORD(__n);
                    if (__dst)
                      v51 = v48 >= HIDWORD(__n);
                    else
                      v51 = 1;
                    v217 = v47;
                    if (!v51)
                    {
                      v48 = v48;
                      v52 = (32 * v48) | 0x18;
                      do
                      {
                        if (*(_DWORD *)&v49[v52 - 12] > *(_DWORD *)(a1 + 1020))
                          break;
                        switch(*(_DWORD *)&v49[v52 - 24])
                        {
                          case 0x10:
                            critsec_Leave(*(_QWORD **)(a1 + 24));
                            v53 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                            v54 = *(_DWORD *)((char *)__dst + v52);
                            v55 = "pitch";
                            goto LABEL_61;
                          case 0x11:
                            critsec_Leave(*(_QWORD **)(a1 + 24));
                            v53 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                            v54 = *(_DWORD *)((char *)__dst + v52);
                            v55 = "timbre";
                            goto LABEL_61;
                          case 0x12:
                            critsec_Leave(*(_QWORD **)(a1 + 24));
                            v53 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                            v54 = *(_DWORD *)((char *)__dst + v52);
                            v55 = "rate";
                            goto LABEL_61;
                          case 0x18:
                            critsec_Leave(*(_QWORD **)(a1 + 24));
                            v53 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
                            v54 = *(_DWORD *)((char *)__dst + v52);
                            v55 = "volume";
LABEL_61:
                            paramc_ParamSetUInt(v53, (uint64_t)v55, v54);
                            critsec_Enter(*(_QWORD **)(a1 + 24));
                            v50 = HIDWORD(__n);
                            break;
                          default:
                            break;
                        }
                        v49 = (char *)__dst;
                        if (v48 < v50 && *(_DWORD *)((char *)__dst + v52 - 24) == 8)
                        {
                          v56 = *(_DWORD *)(a1 + 1016);
                          *(_DWORD *)(a1 + 1028) = v56;
                          *(_DWORD *)(a1 + 1032) = *(_DWORD *)&v49[v52 + 24] + v56;
                        }
                        v57 = &v49[v52];
                        *((_DWORD *)v57 - 3) = *(_DWORD *)(a1 + 1024);
                        *((_DWORD *)v57 - 2) = *(_DWORD *)(a1 + 44)
                                             * *(_DWORD *)&v49[v52 - 8]
                                             * *(unsigned __int16 *)(a1 + 1340)
                                             / 0x64;
                        ++v48;
                        if (!v49)
                          break;
                        v50 = HIDWORD(__n);
                        v52 += 32;
                      }
                      while (v48 < HIDWORD(__n));
                      v46 = *(_DWORD *)(a1 + 1016);
                    }
                    v226 = 0;
                    v212 = *(_WORD *)(a1 + 1340);
                    if (v46 >= *(_DWORD *)(a1 + 1028) && v46 <= *(_DWORD *)(a1 + 1032))
                      *(_WORD *)(a1 + 1340) = 100;
                    v58 = *v40;
                    v59 = *(unsigned __int8 *)(v45 + *v40);
                    if ((v59 & 4) != 0)
                    {
                      v62 = *v39;
                      v63 = v39[11];
                      if (*v39 >= v63)
                      {
                        v62 = v63 - 1;
                        *v39 = v63 - 1;
                      }
                      v64 = exp_S7_25(2 * **(_DWORD **)(*((_QWORD *)v39 + 8) + 8 * v62), &v220);
                      v65 = 1374389535 * (v64 >> (24 - v220)) * *(_DWORD *)(a1 + 1328);
                      v60 = (v65 >> 37) + ((unint64_t)v65 >> 63);
                      ++*v39;
                      v58 = *v40;
                      v61 = *v40;
                      v59 = *(unsigned __int8 *)(v45 + v61);
                    }
                    else
                    {
                      v60 = 0;
                      v61 = v58;
                    }
                    if ((v59 & 8) != 0)
                    {
                      v67 = *v38;
                      v68 = v38[11];
                      if (*v38 >= v68)
                      {
                        v67 = v68 - 1;
                        *v38 = v68 - 1;
                      }
                      v69 = exp_S7_25(2 * **(_DWORD **)(*((_QWORD *)v38 + 8) + 8 * v67), &v220);
                      v66 = *(_DWORD **)(a1 + 1056);
                      if (v66)
                      {
                        v70 = v69 >> ~(__int16)v220;
                        if (v70)
                        {
                          v71 = v66[1];
                          v72 = __OFSUB__(v70, v71);
                          v73 = v70 - v71;
                          if (v73 < 0 != v72)
                          {
                            LODWORD(v66) = v66[3];
                          }
                          else if (v66[2] >= v70)
                          {
                            LODWORD(v66) = v66[3] + *v66 * v73;
                          }
                          else
                          {
                            LODWORD(v66) = v66[4];
                          }
                        }
                        else
                        {
                          LODWORD(v66) = 0;
                        }
                      }
                      ++*v38;
                      v58 = *v40;
                      v61 = *v40;
                      v59 = *(unsigned __int8 *)(v45 + v61);
                    }
                    else
                    {
                      LODWORD(v66) = 0;
                    }
                    if ((~v59 & 0xC) != 0)
                    {
                      v78 = 0;
                      *(_QWORD *)(a1 + 1332) = 0;
                    }
                    else
                    {
                      v74 = v40[11];
                      v75 = *(_DWORD *)(a1 + 1332) + 1;
                      *(_DWORD *)(a1 + 1332) = v75;
                      v76 = *(_DWORD *)(a1 + 1336);
                      if (v76)
                      {
                        v77 = v76 - 1;
                      }
                      else
                      {
                        v72 = __OFSUB__(v74, v58);
                        v77 = v74 - v58;
                        if ((v77 < 0) ^ v72 | (v77 == 0))
                        {
                          v77 = 0;
                        }
                        else
                        {
                          v79 = 0;
                          v80 = v45 + v61;
                          while ((~*(unsigned __int8 *)(v80 + v79) & 0xC) == 0)
                          {
                            if (v77 == (_DWORD)++v79)
                              goto LABEL_101;
                          }
                          v77 = v79;
                        }
                      }
LABEL_101:
                      *(_DWORD *)(a1 + 1336) = v77;
                      if (v77 >= v75)
                        v78 = v75;
                      else
                        v78 = v77;
                    }
                    if ((*(_BYTE *)(v45 + *v40) & 0xC) != 0xC)
                    {
                      v60 = 0;
                      LODWORD(v66) = 0;
                    }
                    *(_DWORD *)(a1 + 1136) = v78;
                    *(_DWORD *)(a1 + 1140) = 0;
                    *(_DWORD *)(a1 + 1124) = (_DWORD)v66;
                    *(_DWORD *)(a1 + 1120) = 0;
                    *(_DWORD *)(a1 + 1128) = (42949673 * (unint64_t)(*(unsigned __int16 *)(a1 + 1340) << 10)) >> 32;
                    MrccInput_AllocateData(v211, v40[10]);
                    *(_DWORD *)(a1 + 1116) = v60;
                    if (v213)
                    {
                      *(_QWORD *)(a1 + 1104) = *(_QWORD *)(*((_QWORD *)v40 + 8) + 8 * *v40);
                    }
                    else
                    {
                      Data = MrccInput_AllocateData(v211, v40[10]);
                      if (Data < 0)
                      {
                        v8 = Data;
                        goto LABEL_338;
                      }
                      v82 = *(unsigned int *)(a1 + 1112);
                      if ((int)v82 >= 1)
                      {
                        v83 = *(int **)(*((_QWORD *)v40 + 8) + 8 * *(int *)(a1 + 1016));
                        v84 = *(unsigned int **)(a1 + 1104);
                        do
                        {
                          v86 = *v83++;
                          v85 = v86;
                          v87 = v86 < 0;
                          if (v86 < 0)
                            v85 = -v85;
                          v88 = v85 + 14506 * (v85 >> 15) + ((14506 * (v85 & 0x7FFF) + 0x4000) >> 15);
                          if (v87)
                            v88 = -v88;
                          *v84++ = v88;
                          --v82;
                        }
                        while (v82);
                      }
                    }
                    v8 = RccSyn__SynthesisOneFrame(a1 + 1048, &v226, &v222);
                    if (v8 < 0)
                      goto LABEL_338;
                    v35.n128_f64[0] = RrInput_Reset(a1 + 1208);
                    v46 = *(_DWORD *)(a1 + 1016);
                    if (v46 >= *(_DWORD *)(a1 + 1028) && v46 <= *(_DWORD *)(a1 + 1032))
                      *(_WORD *)(a1 + 1340) = v212;
                    v89 = v226;
                    v47 = v217;
                    if (!v226)
                    {
                      v98 = 0;
                      goto LABEL_141;
                    }
                    ++*(_DWORD *)(a1 + 1020);
                    *(_DWORD *)(a1 + 1024) += v89;
                    if (v89 + v217 <= v12)
                      break;
                    if (v217)
                    {
                      v90 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, __n128))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), (2 * v217), v35);
                      if (v90 < 0)
                      {
                        v8 = v90;
LABEL_139:
                        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v91, v92, v93, v94, "stream");
                        v47 = 0;
                        v98 = *(_DWORD *)(a1 + 52) != 0;
                        goto LABEL_140;
                      }
                      v89 = v226;
                    }
                    if (v89 <= v12)
                      v95 = v12;
                    else
                      v95 = v89;
                    if (!*(_DWORD *)(a1 + 52))
                      v89 = v95;
                    v8 = (*(uint64_t (**)(_QWORD, _QWORD, void **, _QWORD, __n128))(*(_QWORD *)(a1 + 32)
                                                                                            + 112))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), &v223, 2 * v89, v35);
                    if (v8 < 0)
                      goto LABEL_139;
                    v47 = 0;
                    v96 = 0;
                    v97 = 0;
                    v98 = *(_DWORD *)(a1 + 52) != 0;
                    v89 = v226;
                    v99 = (__int16 *)v223;
                    if (v226)
                      goto LABEL_135;
LABEL_137:
                    vol_ScaleToLevel(&v99[v96], v97, *(unsigned __int16 *)(a1 + 60));
                    v47 = v226 + v96;
                    v45 = v215;
LABEL_140:
                    ++*v40;
                    v46 = *(_DWORD *)(a1 + 1016) + 1;
                    *(_DWORD *)(a1 + 1016) = v46;
LABEL_141:
                    if (v8 < 0 || v98 || v46 >= v40[11])
                      goto LABEL_144;
                  }
                  v98 = 0;
                  v99 = (__int16 *)v223;
LABEL_135:
                  v100 = 0;
                  v96 = v47;
                  v101 = v222;
                  v97 = v89;
                  do
                  {
                    v99[(v96 + v100)] = *(_WORD *)(v101 + 2 * v100);
                    ++v100;
                  }
                  while (v89 != v100);
                  goto LABEL_137;
                }
                goto LABEL_219;
              }
LABEL_195:
              v10 = v29;
              v132 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_220:
              log_OutPublic(v132, (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v30, v31, v32, v33, "stream");
              return v10;
            }
LABEL_193:
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v25, v26, v27, v28, "contentType");
            return v10;
          }
LABEL_186:
          v10 = v20;
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v21, v22, v23, v24, "contentType");
          return v10;
        }
        if ((_DWORD)__n)
        {
          if (*(_QWORD *)(a1 + 1000))
          {
            v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **, char *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), &__src, (char *)&__n + 4);
            if ((v10 & 0x80000000) != 0)
            {
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v107, v108, v109, v110, "contentType");
            }
            else if (HIDWORD(__n))
            {
              v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), &__dst);
              if ((v10 & 0x80000000) != 0)
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v111, v112, v113, v114, "stream");
            }
            if ((v10 & 0x80000000) == 0 && HIDWORD(__n) && __src && __dst)
            {
              cstdlib_memcpy(__dst, __src, HIDWORD(__n));
              v133 = HIDWORD(__n);
              HIDWORD(__n) >>= 5;
              if (v133 >= 0x20)
              {
                v134 = 0;
                v135 = 0;
                v136 = *(_DWORD *)(a1 + 1024);
                v137 = (char *)__dst;
                do
                {
                  v138 = &v137[v134];
                  *((_DWORD *)v138 + 3) = v136;
                  *((_DWORD *)v138 + 4) = 0;
                  ++v135;
                  v134 += 32;
                }
                while (v135 < HIDWORD(__n));
                goto LABEL_216;
              }
              goto LABEL_211;
            }
LABEL_212:
            if ((v10 & 0x80000000) != 0)
              return v10;
            return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 128), *(_QWORD *)(a1 + 32));
          }
          return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 128), *(_QWORD *)(a1 + 32));
        }
        goto LABEL_194;
      }
LABEL_185:
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56004, (uint64_t)"%s%x", v16, v17, v18, v19, "lhError");
      return v10;
    }
    return 2164269064;
  }
  __n = 0;
  v226 = 0;
  __dst = 0;
  __src = 0;
  v222 = 0;
  v223 = 0;
  if ((safeh_HandleCheck(a1, a2, 9346, 1344) & 0x80000000) != 0)
    return 2164269064;
  *a5 = 1;
  v13 = *(_DWORD *)(a1 + 40);
  v14 = *(_DWORD *)(a1 + 44);
  if (v13 >= v14)
  {
    if (v14)
      v14 *= v13 / v14;
    else
      v14 = *(_DWORD *)(a1 + 40);
  }
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, char *, unsigned int *))(*(_QWORD *)(a1 + 32) + 144))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), (char *)&__n + 4, &v226);
  if ((v10 & 0x80000000) != 0)
    goto LABEL_185;
  if (!HIDWORD(__n))
  {
    if (v226)
    {
      if (*(_QWORD *)(a1 + 1000))
      {
        v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **, size_t *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), &__dst, &__n);
        if ((v10 & 0x80000000) != 0)
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56005, (uint64_t)"%s%s%s%x", v124, v125, v126, v127, "contentType");
        }
        else if ((_DWORD)__n)
        {
          v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), &v223);
          if ((v10 & 0x80000000) != 0)
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v128, v129, v130, v131, "stream");
        }
        if ((v10 & 0x80000000) == 0 && (_DWORD)__n && __dst && v223)
        {
          cstdlib_memcpy(v223, __dst, __n);
          v139 = __n;
          LODWORD(__n) = __n >> 5;
          if (v139 >= 0x20)
          {
            v134 = 0;
            v140 = 0;
            v141 = *(_DWORD *)(a1 + 1024);
            v142 = (char *)v223;
            do
            {
              v143 = &v142[v134];
              *((_DWORD *)v143 + 3) = v141;
              *((_DWORD *)v143 + 4) = 0;
              ++v140;
              v134 += 32;
            }
            while (v140 < __n);
LABEL_216:
            v34 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), v134);
            if ((v34 & 0x80000000) == 0)
            {
              v144 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), v134);
              if ((v144 & 0x80000000) != 0)
              {
                v10 = v144;
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56006, (uint64_t)"%s%s%s%x", v145, v146, v147, v148, "contentType");
                return v10;
              }
              return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 128), *(_QWORD *)(a1 + 32));
            }
LABEL_219:
            v10 = v34;
            v132 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
            goto LABEL_220;
          }
LABEL_211:
          v134 = 0;
          goto LABEL_216;
        }
        goto LABEL_212;
      }
      return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 128), *(_QWORD *)(a1 + 32));
    }
LABEL_194:
    *a5 = 0;
    return v10;
  }
  v20 = (*(uint64_t (**)(_QWORD, _QWORD, void **, char *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), &__src, (char *)&__n + 4);
  if ((v20 & 0x80000000) != 0)
    goto LABEL_186;
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, void **, size_t *))(*(_QWORD *)(a1 + 32) + 88))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), &__dst, &__n);
  if ((v10 & 0x80000000) != 0)
    goto LABEL_193;
  if (HIDWORD(__n) < 8)
    return v10;
  v29 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), &v222, 2 * v14);
  if ((v29 & 0x80000000) != 0)
    goto LABEL_195;
  if ((_DWORD)__n)
  {
    v34 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), &v223);
    if ((v34 & 0x80000000) != 0)
      goto LABEL_219;
  }
  v10 = critsec_Enter(*(_QWORD **)(a1 + 24));
  if ((v10 & 0x80000000) != 0)
    return v10;
  v115 = *(_QWORD *)__src;
  v221 = 0;
  v220 = 0;
  v219 = 0;
  v216 = *(_QWORD *)(v115 + 48);
  if ((_DWORD)__n && __dst && v223)
  {
    cstdlib_memcpy(v223, __dst, __n);
    LODWORD(__n) = __n >> 5;
  }
  v116 = *(unsigned int *)(v115 + 32);
  if ((int)v116 < 1)
  {
    v119 = 0;
    v118 = 0;
    v117 = 0;
  }
  else
  {
    v117 = 0;
    v118 = 0;
    v119 = 0;
    v120 = *(int **)(v115 + 24);
    do
    {
      v121 = v120[3];
      if (v121 == 1)
        v122 = v120;
      else
        v122 = v119;
      if (v121 == 2)
      {
        v122 = v119;
        v123 = v120;
      }
      else
      {
        v123 = v118;
      }
      if (v121 == 3)
        v117 = v120;
      v120 += 78;
      if (v121 != 3)
      {
        v119 = v122;
        v118 = v123;
      }
      --v116;
    }
    while (v116);
  }
  if (v117)
    v149 = v118 == 0;
  else
    v149 = 1;
  if (v149 || v119 == 0)
    v151 = -2130698234;
  else
    v151 = v10;
  if (v151 < 0)
  {
    LODWORD(v10) = v151;
    goto LABEL_317;
  }
  if (*(_DWORD *)(a1 + 1016) >= v119[11])
  {
    v192 = 0;
    LODWORD(v153) = 0;
    goto LABEL_302;
  }
  v152 = 0;
  LODWORD(v153) = 0;
  while (!*(_DWORD *)(a1 + 52) || *(_DWORD *)(a1 + 44) + v152 <= v14)
  {
    v154 = (char *)v223;
    if (v223)
      v155 = v153 >= __n;
    else
      v155 = 1;
    if (!v155)
    {
      v156 = v152;
      v153 = v153;
      v157 = (32 * v153) | 0x18;
      do
      {
        v158 = &v154[v157];
        if (*((_DWORD *)v158 - 3) > *(_DWORD *)(a1 + 1020))
          break;
        switch(*((_DWORD *)v158 - 6))
        {
          case 0x10:
            critsec_Leave(*(_QWORD **)(a1 + 24));
            v159 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
            v160 = *(_DWORD *)((char *)v223 + v157);
            v161 = "pitch";
            goto LABEL_248;
          case 0x11:
            critsec_Leave(*(_QWORD **)(a1 + 24));
            v159 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
            v160 = *(_DWORD *)((char *)v223 + v157);
            v161 = "timbre";
            goto LABEL_248;
          case 0x12:
            critsec_Leave(*(_QWORD **)(a1 + 24));
            v159 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
            v160 = *(_DWORD *)((char *)v223 + v157);
            v161 = "rate";
            goto LABEL_248;
          case 0x18:
            critsec_Leave(*(_QWORD **)(a1 + 24));
            v159 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
            v160 = *(_DWORD *)((char *)v223 + v157);
            v161 = "volume";
LABEL_248:
            paramc_ParamSetUInt(v159, (uint64_t)v161, v160);
            critsec_Enter(*(_QWORD **)(a1 + 24));
            break;
          default:
            break;
        }
        v154 = (char *)v223;
        v162 = (char *)v223 + v157;
        *((_DWORD *)v162 - 3) = *(_DWORD *)(a1 + 1024);
        *((_DWORD *)v162 - 2) *= (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 40) * *(_DWORD *)(a1 + 44)) >> 14;
        ++v153;
        if (!v154)
          break;
        v157 += 32;
      }
      while (v153 < __n);
      v152 = v156;
    }
    v220 = 0;
    v163 = *(_BYTE *)(v216 + *v119);
    v218 = v152;
    if ((v163 & 4) != 0)
    {
      v165 = exp_S7_25(2 * **(_DWORD **)(*((_QWORD *)v118 + 8) + 8 * *v118), &v219);
      v164 = v165 >> (25 - v219);
      ++*v118;
      v163 = *(_BYTE *)(v216 + *v119);
    }
    else
    {
      LOWORD(v164) = 0;
    }
    if ((v163 & 8) != 0)
    {
      v167 = exp_S7_25(2 * **(_DWORD **)(*((_QWORD *)v117 + 8) + 8 * *v117), &v219);
      v166 = v167 >> ~(_BYTE)v219;
      ++*v117;
    }
    else
    {
      LOWORD(v166) = 0;
    }
    v168 = *(_QWORD *)(a1 + 64);
    if ((*(_DWORD *)(v168 + 120) & 0x80000000) == 0)
    {
      v169 = 0;
      v170 = *(_QWORD *)(*((_QWORD *)v119 + 8) + 8 * *(int *)(a1 + 1016));
      do
      {
        *((_DWORD *)v228 + v169) = *(int *)(v170 + 4 * v169) >> 2;
        v171 = *(int *)(v168 + 120);
        v87 = v169++ < v171;
      }
      while (v87);
      if ((v171 & 0x80000000) == 0)
      {
        v172 = *(_QWORD *)(a1 + 72);
        if (v172)
        {
          v173 = 0;
          do
          {
            *((_DWORD *)v228 + v173) += *(_DWORD *)(v172 + 4 * v173);
            v87 = v173++ < *(int *)(v168 + 120);
          }
          while (v87);
        }
      }
    }
    LODWORD(v10) = BET3FXD__MFVSyn__SynthesisOneFrame(v168, (unsigned __int16)v164, v228, v166, (int *)&v220, &v221);
    v174 = 0;
    if ((v10 & 0x80000000) != 0)
    {
      v152 = v218;
      goto LABEL_287;
    }
    v175 = v220;
    v152 = v218;
    if (!v220)
      goto LABEL_287;
    ++*(_DWORD *)(a1 + 1020);
    *(_DWORD *)(a1 + 1024) += v175;
    if (v175 + v218 <= v14)
    {
      v214 = 0;
      v184 = v222;
LABEL_281:
      v185 = v152;
      v186 = 0;
      v182 = v185;
      v187 = v221;
      v183 = v175;
      do
      {
        *(_WORD *)(v184 + 2 * (v182 + v186)) = *(_WORD *)(v187 + 2 * v186);
        ++v186;
      }
      while (v175 != v186);
      goto LABEL_283;
    }
    if (v218)
    {
      v176 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), 2 * v218);
      if (v176 < 0)
      {
        LODWORD(v10) = v176;
LABEL_285:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v177, v178, v179, v180, "stream");
        v152 = 0;
        v174 = *(_DWORD *)(a1 + 52) != 0;
        goto LABEL_286;
      }
      v175 = v220;
    }
    if (v175 <= v14)
      v181 = v14;
    else
      v181 = v175;
    if (!*(_DWORD *)(a1 + 52))
      v175 = v181;
    LODWORD(v10) = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 32) + 112))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), &v222, 2 * v175);
    if ((v10 & 0x80000000) != 0)
      goto LABEL_285;
    v152 = 0;
    v182 = 0;
    v183 = 0;
    v214 = *(_DWORD *)(a1 + 52) != 0;
    v175 = v220;
    v184 = v222;
    if (v220)
      goto LABEL_281;
LABEL_283:
    vol_ScaleToLevel((__int16 *)(v184 + 2 * v182), v183, *(unsigned __int16 *)(a1 + 60));
    v152 = v220 + v182;
    v174 = v214;
LABEL_286:
    ++*v119;
    ++*(_DWORD *)(a1 + 1016);
LABEL_287:
    if ((v10 & 0x80000000) != 0 || v174 || *(_DWORD *)(a1 + 1016) >= v119[11])
      break;
  }
  if ((v10 & 0x80000000) == 0)
  {
    if (v152)
    {
      LODWORD(v10) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 984), *(_QWORD *)(a1 + 992), 2 * v152);
      if ((v10 & 0x80000000) != 0)
      {
        v199 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
        goto LABEL_316;
      }
    }
  }
  v192 = v153 != 0;
  if ((v10 & 0x80000000) != 0 || !(_DWORD)v153)
  {
    if ((v10 & 0x80000000) != 0)
      goto LABEL_317;
LABEL_302:
    if (*(_DWORD *)(a1 + 1016) >= v119[11])
    {
      LODWORD(v10) = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 952), *(_QWORD *)(a1 + 960), 8);
      if ((v10 & 0x80000000) != 0)
      {
        v198 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_312:
        log_OutPublic(v198, (uint64_t)"SYNTH_BET3", 56006, (uint64_t)"%s%s%s%x", v194, v195, v196, v197, "contentType");
        goto LABEL_317;
      }
      *(_DWORD *)(a1 + 1016) = 0;
      if (HIDWORD(__n) <= 8)
        v193 = 1;
      else
        v193 = 2;
    }
    else
    {
      v193 = 2;
    }
    *a5 = v193;
    if (!v192)
      goto LABEL_317;
    LODWORD(v10) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 96))(*(_QWORD *)(a1 + 968), *(_QWORD *)(a1 + 976), (32 * v153));
    if ((v10 & 0x80000000) == 0)
      goto LABEL_317;
    v198 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_312;
  }
  LODWORD(v10) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 120))(*(_QWORD *)(a1 + 1000), *(_QWORD *)(a1 + 1008), (32 * v153));
  if ((v10 & 0x80000000) == 0)
  {
    v192 = 1;
    goto LABEL_302;
  }
  v199 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_316:
  log_OutPublic(v199, (uint64_t)"SYNTH_BET3", 56007, (uint64_t)"%s%s%s%x", v188, v189, v190, v191, "stream");
LABEL_317:
  v200 = critsec_Leave(*(_QWORD **)(a1 + 24));
  if (v200 >= 0 || (int)v10 <= -1)
    return v10;
  else
    return v200;
}

uint64_t synth_bet3_ProcessEnd_0(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 9346, 1344) & 0x80000000) != 0)
    return 2164269064;
  *(_QWORD *)(a1 + 1020) = 0;
  return synstrmaux_CloseStreams((_WORD *)(a1 + 128), *(_QWORD *)(a1 + 32));
}

uint64_t synth_bet3_loc_ParamCheckChange_0(int a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;
  BOOL v8;

  if (cstdlib_strcmp(__s1, "audiooutputbufsamples"))
  {
    if (cstdlib_strcmp(__s1, "volume"))
    {
      if (cstdlib_strcmp(__s1, "rate"))
      {
        if (!cstdlib_strcmp(__s1, "ratewpm"))
        {
          result = 2164269057;
          goto LABEL_19;
        }
        if (cstdlib_strcmp(__s1, "pitch"))
        {
          result = 0;
          goto LABEL_19;
        }
        v8 = __CFADD__(LH_atoi(a3) - 201, 151);
      }
      else
      {
        v8 = __CFADD__(LH_atoi(a3) - 401, 351);
      }
      if (v8)
        result = 0;
      else
        result = 2164269071;
    }
    else if (LH_atoi(a3) <= 0x64)
    {
      result = 0;
    }
    else
    {
      result = 2164269071;
    }
  }
  else if ((int)LH_atoi(a3) <= 0)
  {
    result = 2164269071;
  }
  else
  {
    result = 0;
  }
LABEL_19:
  *a4 = (int)result >= 0;
  return result;
}

uint64_t synth_bet3_loc_ParamLearnChange_0(uint64_t a1, char *__s1, const char *a3)
{
  unsigned int v7;

  if (cstdlib_strcmp(__s1, "audiooutputbufsamples")
    && cstdlib_strcmp(__s1, "volume")
    && cstdlib_strcmp(__s1, "rate")
    && cstdlib_strcmp(__s1, "rate_baseline")
    && cstdlib_strcmp(__s1, "pitch_baseline")
    && cstdlib_strcmp(__s1, "ratewpm")
    && cstdlib_strcmp(__s1, "pitch"))
  {
    return 0;
  }
  v7 = LH_atoi(a3);
  return synth_bet3_loc_ParamSet_0(a1, __s1, v7);
}

uint64_t synth_bet3_loc_ParamGetListen_0(uint64_t a1, _BYTE *a2, signed int a3, signed int a4, unsigned int a5, __int128 *a6, unsigned int *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  const char *v25;
  __int128 v26;
  uint64_t v27;

  if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)a2, a7) & 0x80000000) != 0
    || (a5 = a3, (int)*a7 < a3)
    || (a5 = a4, (int)*a7 > a4))
  {
    v14 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)a2, a5);
    *a7 = a5;
    if ((v14 & 0x80000000) != 0)
    {
      v20 = v14;
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v25 = "parameter";
      v23 = "%s%s";
      v22 = 56009;
      goto LABEL_8;
    }
  }
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
  v26 = *a6;
  v27 = *((_QWORD *)a6 + 2);
  v20 = paramc_ListenerAdd(v19, a2, &v26);
  if ((v20 & 0x80000000) != 0)
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    v22 = 56010;
    v23 = 0;
LABEL_8:
    log_OutPublic(v21, (uint64_t)"SYNTH_BET3", v22, (uint64_t)v23, v15, v16, v17, v18, v25);
  }
  return v20;
}

uint64_t synth_bet3_loc_SynthInit_MRCC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t inited;
  uint64_t v5;
  int v6;
  _BOOL4 v7;
  uint64_t Int;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t Str;
  uint64_t v19;
  char *__s1;
  uint64_t *v21;
  int v22;

  v19 = 0;
  __s1 = 0;
  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 1332) = 0;
  *(_WORD *)(a1 + 1340) = 100;
  v3 = a1 + 1048;
  RccSyn__deinit_Synthesis(a1 + 1048);
  v22 = 0;
  v21 = 0;
  inited = paramc_ParamGet(*(_QWORD *)(v2 + 40), (uint64_t)"mrcc_synthparam_ref_ptr", &v21, &v22);
  if ((inited & 0x80000000) == 0)
  {
    v5 = *v21;
    *(_DWORD *)(v5 + 128) = 4000;
    *(_OWORD *)(v5 + 112) = xmmword_214F97840;
    *(_QWORD *)(a1 + 1056) = v5 + 112;
    *(_QWORD *)(a1 + 1320) = 0;
    inited = RccSyn__init_Synthesis(v2, v3, (_DWORD *)v5);
    if ((inited & 0x80000000) == 0)
    {
      v6 = *(_DWORD *)(v5 + 16);
      if (v6 == 22000)
      {
        v6 = 22050;
        *(_DWORD *)(v5 + 16) = 22050;
      }
      *(_DWORD *)(a1 + 48) = v6;
      v7 = (paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"voicemodel", &__s1) & 0x80000000) == 0
        && cstdlib_strcmp(__s1, "bet3") == 0;
      *(_DWORD *)(a1 + 52) = v7;
      Int = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voiceframesize", &v19);
      if ((Int & 0x80000000) != 0)
      {
        Str = Int;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56008, (uint64_t)"%s%s", v9, v10, v11, v12, "parameter");
        return Str;
      }
      *(_DWORD *)(a1 + 44) = (int)v19 * *(_DWORD *)(a1 + 48) / 0x3E8u;
      Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicevol", &__s1);
      if ((Str & 0x80000000) != 0 || !__s1 || !*__s1)
      {
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 26011, (uint64_t)"%s%s", v13, v14, v15, v16, "parameter");
        return Str;
      }
      *(_DWORD *)(a1 + 56) = LH_atoi(__s1);
      paramc_ParamRelease(*(_QWORD *)(v2 + 40));
      inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"volume", (_DWORD *)&v19 + 1);
      if ((inited & 0x80000000) == 0)
      {
        inited = synth_bet3_loc_ParamSet_0(a1, "volume", HIDWORD(v19));
        if ((inited & 0x80000000) == 0)
        {
          inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", (_DWORD *)&v19 + 1);
          if ((inited & 0x80000000) == 0)
          {
            inited = synth_bet3_loc_ParamSet_0(a1, "rate", HIDWORD(v19));
            if ((inited & 0x80000000) == 0)
            {
              inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate_baseline", (_DWORD *)&v19 + 1);
              if ((inited & 0x80000000) == 0)
              {
                inited = synth_bet3_loc_ParamSet_0(a1, "rate_baseline", HIDWORD(v19));
                if ((inited & 0x80000000) == 0)
                {
                  inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch_baseline", (_DWORD *)&v19 + 1);
                  if ((inited & 0x80000000) == 0)
                  {
                    inited = synth_bet3_loc_ParamSet_0(a1, "pitch_baseline", HIDWORD(v19));
                    if ((inited & 0x80000000) == 0)
                    {
                      inited = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", (_DWORD *)&v19 + 1);
                      if ((inited & 0x80000000) == 0)
                        return synth_bet3_loc_ParamSet_0(a1, "pitch", HIDWORD(v19));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return inited;
}

uint64_t synth_bet3_loc_SynthInit_MLSA_0(uint64_t a1)
{
  uint64_t v2;
  uint64_t Int;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  _BOOL4 v9;
  uint64_t Str;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _BYTE *v40;
  unsigned int v41;
  __int128 __b;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *__s1;
  char __dst[64];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v46 = 0;
  __s1 = 0;
  v2 = *(_QWORD *)(a1 + 16);
  v45 = 0;
  v44 = 0;
  __b = 0u;
  v43 = 0u;
  v41 = 0;
  v39 = 0;
  v40 = 0;
  Int = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"frequencyhz", (_DWORD *)&v46 + 1);
  if ((Int & 0x80000000) != 0)
  {
    Str = Int;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_37:
    log_OutPublic(v11, (uint64_t)"SYNTH_BET3", 56008, (uint64_t)"%s%s", v4, v5, v6, v7, "parameter");
    return Str;
  }
  v8 = (uint64_t *)(a1 + 64);
  MFVSyn__denit__MVF_Synthesis((_QWORD **)(a1 + 64));
  *(_DWORD *)(a1 + 48) = HIDWORD(v46);
  v9 = (paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"voicemodel", &__s1) & 0x80000000) == 0
    && cstdlib_strcmp(__s1, "bet3") == 0;
  *(_DWORD *)(a1 + 52) = v9;
  cstdlib_memset(&__b, 0, 0x28uLL);
  v43 = xmmword_214F97850;
  LODWORD(__b) = wave_t__convertFromF0ToTp_SR(0xAF00u, SHIDWORD(v46)) >> 6;
  DWORD1(__b) = wave_t__convertFromF0ToTp_SR(0xA00u, SHIDWORD(v46)) >> 6;
  v12 = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voiceframesize", (_DWORD *)&v45 + 1);
  if ((v12 & 0x80000000) != 0)
  {
    Str = v12;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_37;
  }
  *(_DWORD *)(a1 + 44) = HIDWORD(v45) * *(_DWORD *)(a1 + 48) / 0x3E8u;
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicevol", &__s1);
  if ((Str & 0x80000000) != 0
    || !__s1
    || !*__s1
    || (*(_DWORD *)(a1 + 56) = LH_atoi(__s1),
        paramc_ParamRelease(*(_QWORD *)(v2 + 40)),
        Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicemvfboost", &__s1),
        (Str & 0x80000000) != 0)
    || !__s1
    || !*__s1)
  {
    v27 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_35:
    log_OutPublic(v27, (uint64_t)"SYNTH_BET3", 26011, (uint64_t)"%s%s", v13, v14, v15, v16, "parameter");
    return Str;
  }
  v17 = LH_atoi(__s1);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicealpha", &__s1);
  if ((Str & 0x80000000) != 0 || !__s1 || !*__s1)
  {
    v27 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_35;
  }
  v18 = LH_atoi(__s1);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicevuvrelamp", &__s1);
  if ((Str & 0x80000000) != 0 || !__s1 || !*__s1)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_37;
  }
  v19 = LH_atoi(__s1);
  paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  v20 = paramc_ParamGetInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voiceorder", &v45);
  if ((v20 & 0x80000000) != 0
    || (v20 = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicevsynthinit", &v40), (v20 & 0x80000000) != 0))
  {
    Str = v20;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_37;
  }
  v21 = 1;
  if ((paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2cpupower", &__s1) & 0x80000000) == 0 && __s1 && *__s1)
  {
    v22 = LH_atoi(__s1);
    if (v22 >= 5)
      v21 = 1;
    else
      v21 = v22;
    paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  }
  if (!paramc_ParamGet(*(_QWORD *)(v2 + 40), (uint64_t)"bet3cepstralequalizer", (_QWORD *)(a1 + 72), &v41)
    && (_DWORD)v45 + 1 != v41 >> 2)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 56008, (uint64_t)"%s%s", v23, v24, v25, v26, "parameter");
    return 0;
  }
  cstdlib_strcpy(__dst, "synth");
  if ((paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voicequality", &__s1) & 0x80000000) == 0 && __s1 && *__s1)
  {
    cstdlib_strcat(__dst, "/");
    cstdlib_strcat(__dst, __s1);
    paramc_ParamRelease(*(_QWORD *)(v2 + 40));
  }
  else
  {
    cstdlib_strcat(__dst, "/med");
  }
  cstdlib_strcat(__dst, "/fxd");
  cstdlib_strcat(__dst, "/bet3f");
  v29 = SHIDWORD(v46) / 1000;
  v30 = cstdlib_strlen(__dst);
  LH_itoa(v29, &__dst[v30], 0xAu);
  v31 = ssftriff_reader_ObjOpen(*(_WORD **)a1, *(_QWORD *)(a1 + 8), 0, __dst, "HMEX", 1031, (uint64_t *)&v39);
  if ((v31 & 0x80000000) != 0)
    return v31;
  Str = BET3FXD__MFVSyn__init__MVF_Synthesis((uint64_t *)(a1 + 64), *(_QWORD *)(a1 + 16), &__b, (uint64_t)v39, SHIDWORD(v45), v45, v18, HIDWORD(v46), v21, v40);
  if ((Str & 0x80000000) == 0)
  {
    if (!v39 || (Str = ssftriff_reader_ObjClose(v39, v32, v33, v34, v35, v36, v37, v38), (Str & 0x80000000) == 0))
    {
      if (MFVSyn__setRelativeUVBoost((_DWORD *)*v8, v19))
        LODWORD(Str) = -2130698240;
      if ((Str & 0x80000000) == 0 && BET3FXD__MFVSyn__setMVFBoost(*v8, v17))
        LODWORD(Str) = -2130698240;
      Str = BET3FXD__MFVSyn__setVolumeBoost(*(_DWORD **)(a1 + 64), *(_DWORD *)(a1 + 56))
          ? 2164269056
          : Str;
      if ((Str & 0x80000000) == 0)
      {
        v31 = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"volume", &v46);
        if ((v31 & 0x80000000) == 0)
        {
          v31 = synth_bet3_loc_ParamSet_0(a1, "volume", v46);
          if ((v31 & 0x80000000) == 0)
          {
            v31 = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate_baseline", &v46);
            if ((v31 & 0x80000000) == 0)
            {
              v31 = synth_bet3_loc_ParamSet_0(a1, "rate_baseline", v46);
              if ((v31 & 0x80000000) == 0)
              {
                v31 = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", &v46);
                if ((v31 & 0x80000000) == 0)
                {
                  v31 = synth_bet3_loc_ParamSet_0(a1, "rate", v46);
                  if ((v31 & 0x80000000) == 0)
                  {
                    v31 = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch_baseline", &v46);
                    if ((v31 & 0x80000000) == 0)
                    {
                      v31 = synth_bet3_loc_ParamSet_0(a1, "pitch_baseline", v46);
                      if ((v31 & 0x80000000) == 0)
                      {
                        v31 = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", &v46);
                        if ((v31 & 0x80000000) == 0)
                          return synth_bet3_loc_ParamSet_0(a1, "pitch", v46);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return v31;
      }
    }
  }
  return Str;
}

uint64_t synth_bet3_loc_ParamSet_0(uint64_t a1, const char *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v24;
  unsigned int v25;
  unsigned int v26;

  if (cstdlib_strcmp(a2, "audiooutputbufsamples"))
  {
    v6 = critsec_Enter(*(_QWORD **)(a1 + 24));
    if ((v6 & 0x80000000) == 0)
    {
      if (cstdlib_strcmp(a2, "volume"))
      {
        if (cstdlib_strcmp(a2, "rate_baseline"))
        {
          if (cstdlib_strcmp(a2, "rate"))
          {
            if (!cstdlib_strcmp(a2, "ratewpm"))
            {
              v11 = 2164269057;
              goto LABEL_27;
            }
            if (cstdlib_strcmp(a2, "pitch_baseline"))
            {
              if (!cstdlib_strcmp(a2, "pitch"))
              {
                v7 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 1044), a3);
                v11 = 2164269071;
                if ((v7 - 201) < 0xFFFFFF69)
                  goto LABEL_27;
                if (*(_DWORD *)(a1 + 52))
                {
                  v12 = v7;
                  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 3, 0, (uint64_t)"Set pitch %d (synth %d)", v8, v9, v10, v7);
                  v13 = *(_DWORD *)(a1 + 1036);
                  if (v13 != 1)
                  {
                    v11 = v6;
                    if (!v13)
                    {
                      v14 = BET3FXD__MFVSyn__setPitchLevelPercent(*(_QWORD *)(a1 + 64), v12);
                      goto LABEL_35;
                    }
                    goto LABEL_27;
                  }
                  *(_DWORD *)(a1 + 1328) = v12;
                }
              }
              goto LABEL_23;
            }
            v11 = 2164269071;
            if (a3 - 201 < 0xFFFFFF69)
              goto LABEL_27;
            v25 = 0;
            *(_DWORD *)(a1 + 1044) = a3;
            v16 = "pitch";
            paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", &v25);
            v17 = v25;
LABEL_22:
            synth_bet3_loc_ParamSet_0(a1, v16, v17);
            goto LABEL_23;
          }
          v18 = MapProsodyValue_Scaling(50, 100, 400, *(_DWORD *)(a1 + 1040), a3);
          if ((_DWORD)v18)
          {
            v22 = ((int)v18 + 9999) / (int)v18;
            if (((v22 << 16) - 13107201) >= 0xFF50FFFF)
            {
              log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET3", 3, 0, (uint64_t)"Set rate %d", v19, v20, v21, v18);
              v24 = *(_DWORD *)(a1 + 1036);
              if (v24 != 1)
              {
                v11 = v6;
                if (!v24)
                {
                  v14 = BET3FXD__MFVSyn__setRate(*(_QWORD *)(a1 + 64), (__int16)v22);
LABEL_35:
                  if (v14)
                    v11 = 2164269071;
                  else
                    v11 = v6;
                }
LABEL_27:
                critsec_Leave(*(_QWORD **)(a1 + 24));
                return v11;
              }
              v11 = 2164269071;
              if ((unsigned __int16)v22 - 25 > 0xAF)
                goto LABEL_27;
              *(_WORD *)(a1 + 1340) = v22;
LABEL_23:
              v11 = v6;
              goto LABEL_27;
            }
          }
        }
        else if (a3 - 401 >= 0xFFFFFEA1)
        {
          v26 = 0;
          *(_DWORD *)(a1 + 1040) = a3;
          v16 = "rate";
          paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", &v26);
          v17 = v26;
          goto LABEL_22;
        }
      }
      else if (a3 <= 0x64)
      {
        *(_WORD *)(a1 + 60) = a3;
        goto LABEL_23;
      }
      v11 = 2164269071;
      goto LABEL_27;
    }
  }
  else
  {
    v6 = 0;
    if (a3 <= 1)
      v15 = 1;
    else
      v15 = a3;
    *(_DWORD *)(a1 + 40) = v15;
  }
  return v6;
}

uint64_t BET3FXD__rand31pmc_next(_DWORD *a1)
{
  unsigned int v1;
  uint64_t v2;

  v1 = ((1101463552 * HIWORD(*a1)) & 0x7FFF0000)
     + 16807 * (unsigned __int16)*a1
     + ((16807 * HIWORD(*a1)) >> 15);
  v2 = (v1 + (v1 >> 31)) & 0x7FFFFFFF;
  *a1 = v2;
  return v2;
}

int *BET3FXD__rand31pmc_seedi(int *result, unsigned int a2)
{
  int v2;

  if (a2 <= 1)
    v2 = 1;
  else
    v2 = a2;
  *result = v2;
  return result;
}

unsigned int *rand_num_qs(unsigned int *result, _WORD *a2, int a3, int a4)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;

  if (a4 >= 1)
  {
    v4 = *result;
    v5 = a4;
    do
    {
      v6 = ((1101463552 * HIWORD(v4)) & 0x7FFF0000)
         + 16807 * (unsigned __int16)v4
         + ((16807 * HIWORD(v4)) >> 15);
      v4 = (v6 + (v6 >> 31)) & 0x7FFFFFFF;
      *a2++ = (((int)(0x40000000 - v4) >> 16) * (__int16)(a3 >> 2)) >> 14;
      --v5;
    }
    while (v5);
    *result = v4;
  }
  return result;
}

_DWORD *BET3FXD__rand_num_init(_DWORD *result)
{
  *result = 1;
  return result;
}

_QWORD *BET3FXD__MFVSyn__constructExcitationShapingFilter(_QWORD *result, unsigned int a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  BOOL v8;
  _BOOL4 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;

  v2 = result;
  if (*((_DWORD *)result + 14) >= *((_DWORD *)result + 96))
  {
    v3 = result[46];
    if (a2)
    {
      v4 = *((int *)v2 + 94) - 1;
      *(_WORD *)(v3 + 2 * v4) = a2;
      result = cstdlib_memmove((void *)v3, (const void *)(v3 + 2), 2 * v4);
      v5 = v2[46];
      v6 = *((_DWORD *)v2 + 94);
      v7 = *(__int16 *)(v5 + 2 * (v6 - 2));
      v8 = v7 <= 0;
      v9 = v7 > 0;
      v10 = 4 * v7;
      v11 = 4 * v9;
      if (v8)
        v10 = 0;
      v12 = *(__int16 *)(v5 + 2 * (v6 - 3));
      v13 = (4 * v9) | 2;
      v14 = 2 * v12;
      if (v12 <= 0)
        v14 = 0;
      else
        v11 = v13;
      v15 = *(__int16 *)(v5 + 2 * (v6 - 4));
      a2 = ((v14 + v10 + (v15 & ~(v15 >> 31))) * g_invDiv[v11 | (v15 > 0)]) >> 16;
    }
    else
    {
      result = cstdlib_memset((void *)v3, 0, 2 * *((unsigned int *)v2 + 95));
      a2 = 0;
    }
  }
  v16 = *((_DWORD *)v2 + 3);
  if (v16 >= (*((_DWORD *)v2 + 12) * a2) >> 14)
    LOWORD(v16) = (*((_DWORD *)v2 + 12) * a2) >> 14;
  *((_WORD *)v2 + 176) = v16;
  return result;
}

uint64_t MFVSyn__filterExcitationWithShapingFilter(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  int v12;
  uint64_t result;
  int v14;
  uint64_t v15;
  __int16 *v16;
  _WORD *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  __int16 v31;
  BOOL v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int16 v46;

  v6 = a1;
  v7 = *(_DWORD *)(a1 + 16) * a3;
  if (v7 < 0x7AE149)
  {
    cstdlib_memset(*(void **)(a4 + 8), 0, 2 * *(unsigned int *)(a4 + 16));
    result = (uint64_t)rand_num_qs((unsigned int *)(v6 + 60), *(_WORD **)(v6 + 208), *(_DWORD *)(v6 + 32), a2);
    *(_QWORD *)(v6 + 508) = 0xFFFFFFFFLL;
    goto LABEL_46;
  }
  v8 = *(unsigned int *)(a1 + 472);
  if ((int)v8 < 1)
  {
LABEL_6:
    LODWORD(v9) = 0;
  }
  else
  {
    v9 = 0;
    v10 = (unsigned int *)(*(_QWORD *)(a1 + 480) + 16);
    while (1)
    {
      v11 = *v10;
      v10 += 6;
      if (v11 >= v7)
        break;
      if (v8 == ++v9)
        goto LABEL_6;
    }
  }
  if (*(_DWORD *)(a1 + 504) == a2)
  {
    v12 = *(__int16 *)(a1 + 500);
    LOWORD(a1) = *(_WORD *)(a1 + 500);
    *(_DWORD *)(v6 + 504) = a2;
  }
  else
  {
    LODWORD(a1) = fxd_U16SqrtS32(a2 << 6);
    v14 = *(unsigned __int16 *)(v6 + 500);
    *(_DWORD *)(v6 + 504) = a2;
    v12 = (__int16)a1;
    if ((_DWORD)a1 != v14)
      goto LABEL_16;
  }
  if ((_DWORD)v9 != *(_DWORD *)(v6 + 508))
  {
LABEL_16:
    if (*(__int16 *)(v6 + 488) >= 1)
    {
      v46 = a1;
      v19 = 0;
      v20 = *(_QWORD *)(v6 + 480) + 24 * v9;
      v21 = (((unsigned __int16)((((unsigned __int16)*(_DWORD *)(v6 + 28) * *(__int16 *)(v20 + 20)) >> 14)
                               + 4 * *(_WORD *)(v20 + 20) * HIWORD(*(_DWORD *)(v6 + 28)))
            * v12) >> 14)
          + 4
          * v12
          * (((((unsigned __int16)*(_DWORD *)(v6 + 28) * *(__int16 *)(v20 + 20)) >> 14)
            + 4 * *(__int16 *)(v20 + 20) * (*(int *)(v6 + 28) >> 16)) >> 16);
      v22 = *(_QWORD *)v20;
      v23 = 2 * *(unsigned __int16 *)(v6 + 488);
      do
      {
        v24 = fxd_S32ShMultRndS32S16(v21, *(__int16 *)(v22 + v19), 7);
        if (v24 <= -32768)
          v25 = -32768;
        else
          v25 = v24;
        if (v25 >= 0x7FFF)
          LOWORD(v25) = 0x7FFF;
        *(_WORD *)(*(_QWORD *)(a4 + 8) + v19) = v25;
        *(_WORD *)(*(_QWORD *)(v6 + 528) + v19) = v25;
        v19 += 2;
      }
      while (v23 != v19);
      LOWORD(a1) = v46;
    }
    goto LABEL_25;
  }
  if (*(__int16 *)(v6 + 488) >= 1)
  {
    v15 = *(unsigned __int16 *)(v6 + 488);
    v16 = *(__int16 **)(v6 + 528);
    v17 = *(_WORD **)(a4 + 8);
    do
    {
      v18 = *v16++;
      *v17++ = v18;
      --v15;
    }
    while (v15);
  }
LABEL_25:
  *(_WORD *)(v6 + 500) = a1;
  v26 = *(_DWORD *)(v6 + 264);
  if (v26 >= 1)
  {
    if (v26 >= a2)
      v27 = a2;
    else
      v27 = *(_DWORD *)(v6 + 264);
    if (*(_DWORD *)(a4 + 16) >= v27)
      v28 = v27;
    else
      v28 = *(_DWORD *)(a4 + 16);
    if (v28 >= 1)
    {
      v29 = 0;
      v30 = *(_QWORD *)(a4 + 8);
      do
      {
        v31 = fxd_S16SatAddS16S16(*(__int16 *)(v30 + v29), *(__int16 *)(*(_QWORD *)(v6 + 256) + v29));
        v30 = *(_QWORD *)(a4 + 8);
        *(_WORD *)(v30 + v29) = v31;
        v29 += 2;
      }
      while (2 * v28 != v29);
      v26 = *(_DWORD *)(v6 + 264);
    }
    v32 = __OFSUB__(v26, v28);
    v33 = v26 - v28;
    if (!((v33 < 0) ^ v32 | (v33 == 0)))
    {
      cstdlib_memmove(*(void **)(v6 + 256), (const void *)(*(_QWORD *)(v6 + 256) + 2 * v28), 2 * v33);
      *(_DWORD *)(v6 + 264) = (*(_DWORD *)(v6 + 264) - v28) & ~((*(_DWORD *)(v6 + 264) - v28) >> 31);
    }
  }
  cstdlib_memset(*(void **)(v6 + 256), 0, 2 * *(unsigned int *)(v6 + 268));
  v34 = *(__int16 *)(v6 + 488);
  v32 = __OFSUB__(v34, a2);
  v35 = v34 - a2;
  if ((v35 < 0) ^ v32 | (v35 == 0))
  {
    v36 = a2;
  }
  else
  {
    v36 = a2;
    cstdlib_memmove(*(void **)(v6 + 256), (const void *)(*(_QWORD *)(a4 + 8) + 2 * a2), 2 * v35);
    v37 = *(__int16 *)(v6 + 488) - a2;
    if (v37 <= *(_DWORD *)(v6 + 264))
      v37 = *(_DWORD *)(v6 + 264);
    *(_DWORD *)(v6 + 264) = v37;
  }
  v38 = *(__int16 *)(v6 + 492);
  v39 = *(__int16 *)(*(_QWORD *)(v6 + 480) + 24 * v9 + 22);
  rand_num_qs((unsigned int *)(v6 + 60), (_WORD *)(*(_QWORD *)(v6 + 208) + 2 * v38), (((unsigned __int16)*(_DWORD *)(v6 + 32) * v39) >> 14) + 4 * v39 * (*(int *)(v6 + 32) >> 16), a2);
  cstdlib_memmove(*(void **)(v6 + 208), *(const void **)(v6 + 280), 2 * v38);
  cstdlib_memmove(*(void **)(v6 + 280), (const void *)(*(_QWORD *)(v6 + 208) + 2 * v36), 2 * v38);
  zerflt_qs(*(_QWORD *)(v6 + 208) + 2 * v38, *(__int16 **)(*(_QWORD *)(v6 + 480) + 24 * v9 + 8), *(_QWORD *)(v6 + 208) + 2 * v38, *(__int16 *)(v6 + 492), a2);
  result = (uint64_t)cstdlib_memmove(*(void **)(v6 + 208), (const void *)(*(_QWORD *)(v6 + 208) + 2 * v38), 2 * a2);
  v40 = *(_DWORD *)(v6 + 512);
  v41 = *(_DWORD *)(v6 + 516);
  v32 = __OFSUB__(v40, v41);
  v42 = v40 - v41;
  if (!((v42 < 0) ^ v32 | (v42 == 0)))
    *(_DWORD *)(v6 + 512) = v42;
  *(_DWORD *)(v6 + 508) = v9;
LABEL_46:
  if (a2 >= 1)
  {
    v43 = 0;
    v44 = *(_QWORD *)(a4 + 8);
    v45 = 2 * a2;
    do
    {
      result = fxd_S16SatAddS16S16(*(__int16 *)(v44 + v43), *(__int16 *)(*(_QWORD *)(v6 + 208) + v43));
      v44 = *(_QWORD *)(a4 + 8);
      *(_WORD *)(v44 + v43) = result;
      v43 += 2;
    }
    while (v45 != v43);
  }
  return result;
}

uint64_t MFVSyn__MVFExcitation_construct(uint64_t a1)
{
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 512) = 0;
  *(_QWORD *)(a1 + 504) = 0xFFFFFFFF00000004;
  *(_WORD *)(a1 + 500) = 2;
  *(_QWORD *)(a1 + 528) = 0;
  *(_DWORD *)(a1 + 516) = BET3FXD__wave_t__convertFromMsecToTp((_DWORD *)(a1 + 8), 4);
  return 0;
}

uint64_t MFVSyn__createMVFExcitation_(uint64_t a1)
{
  unsigned int v2;

  if (*(__int16 *)(a1 + 488) <= *(__int16 *)(a1 + 492))
    v2 = *(__int16 *)(a1 + 492);
  else
    v2 = *(__int16 *)(a1 + 488);
  *(_DWORD *)(a1 + 68) = v2;
  if (vect_t__createVect_qs(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 248, v2))
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 264) = 0;
  if (vect_t__createVect_qs(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 272, *(_DWORD *)(a1 + 68)))
    return 0xFFFFFFFFLL;
  if (vect_t__createVect_qs(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 520, *(_DWORD *)(a1 + 68)))
    return 0xFFFFFFFFLL;
  return 0;
}

uint64_t MFVSyn__deleteMVFExcitation_(uint64_t a1)
{
  int v2;
  int v3;

  v2 = vect_t__deleteVect_qs(a1 + 248);
  v3 = vect_t__deleteVect_qs(a1 + 272);
  if (vect_t__deleteVect_qs(a1 + 520) | v3 | v2)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t vect_t__createVect_qs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *v5;

  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = a1;
  v5 = (void *)heap_Alloc(a1, 2 * a3);
  *(_QWORD *)(a2 + 8) = v5;
  if (!v5)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = a3;
  cstdlib_memset(v5, 0, 2 * a3);
  return 0;
}

uint64_t vect_t__deleteVect_qs(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  heap_Free(*(_QWORD **)a1, v1);
  result = 0;
  *v2 = 0;
  v2[1] = 0;
  return result;
}

uint64_t BET3FXD__vect_t__createVect(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *v5;

  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = a1;
  v5 = (void *)heap_Alloc(a1, 4 * a3);
  *(_QWORD *)(a2 + 8) = v5;
  if (!v5)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = a3;
  cstdlib_memset(v5, 0, 4 * a3);
  return 0;
}

uint64_t BET3FXD__vect_t__deleteVect(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  heap_Free(*(_QWORD **)a1, v1);
  result = 0;
  *v2 = 0;
  v2[1] = 0;
  return result;
}

uint64_t exp_S7_25(int a1, _WORD *a2)
{
  int v2;
  uint64_t result;
  int v4;
  uint64_t i;

  v2 = a1 >> 10;
  result = 0x40000000;
  v4 = 1;
  for (i = 10; i != 32; ++i)
  {
    if ((v2 & 1) != 0)
    {
      result = (exp_mantissa_lut[i] * (((int)result + 0x4000) >> 15));
      v4 += exp_scale_lut[i];
      if ((int)result <= 1073733631)
      {
        result = (2 * result);
        --v4;
      }
    }
    v2 >>= 1;
  }
  if ((int)result <= 0x3FFFFFFF)
  {
    do
    {
      result = (2 * result);
      LOWORD(v4) = v4 - 1;
    }
    while ((int)result < 0x40000000);
  }
  *a2 = v4;
  return result;
}

uint64_t BET3FXD__MFVSyn__SynthesisOneFrame(uint64_t a1, int a2, void *__src, __int16 a4, int *a5, _QWORD *a6)
{
  int v9;
  _BOOL4 v10;
  _BOOL4 v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t i;
  int v31;
  unsigned int *v32;
  _WORD *v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  void *v37;
  const void *v38;
  int j;
  int v40;
  unsigned int v41;
  signed int v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  int v47;

  *a5 = 0;
  *a6 = 0;
  v9 = *(_DWORD *)(a1 + 396);
  v10 = a2 == 0;
  if (v9 != 1)
    v10 = 0;
  if (v9)
    v11 = 0;
  else
    v11 = a2 != 0;
  *(_DWORD *)(a1 + 392) = v11 || v10;
  if (a2)
  {
    v12 = *(_DWORD *)(a1 + 36) * a2;
    v13 = v12 >> 25;
    v14 = HIWORD(v12);
    if (v13 < 5)
      v14 = 2560;
  }
  else
  {
    v14 = 0;
  }
  *(_DWORD *)(a1 + 396) = v14 != 0;
  v15 = *(_DWORD *)(a1 + 296);
  v16 = *(_DWORD *)(a1 + 300);
  *a5 = v15;
  v17 = *(_DWORD *)(a1 + 40);
  if (v17 != 0x4000)
  {
    v15 = (*(_DWORD *)(a1 + 296) * v17 + 0x2000) >> 14;
    v16 = (unsigned __int16)(0x10000u / (unsigned __int16)v15);
    *a5 = v15;
  }
  if (!v14 || (v18 = (*(_DWORD *)(a1 + 8) << 12) / v14, (*(_WORD *)(a1 + 400) = v18) == 0))
    *(_WORD *)(a1 + 400) = *(_WORD *)(a1 + 344);
  cstdlib_memmove(*(void **)(a1 + 416), __src, 4 * (*(_DWORD *)(a1 + 120) + 1));
  *(_WORD *)(a1 + 402) = a4;
  BET3FXD__MFVSyn__mc2mlsa(a1, *(_QWORD *)(a1 + 416), *(int32x2_t **)(a1 + 576));
  cstdlib_memmove(*(void **)(a1 + 416), *(const void **)(a1 + 576), 4 * (*(_DWORD *)(a1 + 120) + 1));
  BET3FXD__MFVSyn__constructExcitationShapingFilter((_QWORD *)a1, *(unsigned __int16 *)(a1 + 402));
  v19 = *(unsigned __int16 *)(a1 + 400);
  if (*(_DWORD *)(a1 + 392))
    goto LABEL_20;
  v20 = v19 - *(unsigned __int16 *)(a1 + 432);
  if (v20 < 0)
    v20 = *(unsigned __int16 *)(a1 + 432) - v19;
  if (v20 >= *(_DWORD *)(a1 + 340))
LABEL_20:
    *(_WORD *)(a1 + 432) = v19;
  LODWORD(v21) = *(_DWORD *)(a1 + 120);
  if ((v21 & 0x80000000) != 0)
  {
    v24 = *(_DWORD **)(a1 + 448);
  }
  else
  {
    v22 = 0;
    v23 = *(_QWORD *)(a1 + 416);
    v24 = *(_DWORD **)(a1 + 448);
    v25 = *(_QWORD *)(a1 + 136);
    do
    {
      *(_DWORD *)(v25 + 4 * v22) = ((*(_DWORD *)(v23 + 4 * v22) - v24[v22]) >> 16) * (__int16)v16
                                 + (((unsigned __int16)(*(_WORD *)(v23 + 4 * v22) - LOWORD(v24[v22])) * (__int16)v16
                                   + 0x8000) >> 16);
      v21 = *(int *)(a1 + 120);
    }
    while (v22++ < v21);
  }
  cstdlib_memmove(*(void **)(a1 + 80), v24, 4 * (v21 + 1));
  v27 = 0;
  v28 = *(_QWORD *)(a1 + 448);
  v29 = *(_QWORD *)(a1 + 104);
  do
  {
    *(_WORD *)(v29 + 2 * v27) = *(_DWORD *)(v28 + 4 * v27) >> 10;
    ++v27;
  }
  while (v27 != 5);
  for (i = 0; i != 6; ++i)
    *(_WORD *)(v29 + 10 + 2 * i) = *(_DWORD *)(v28 + 20 + 4 * i) >> 9;
  v31 = *(_DWORD *)(a1 + 120);
  if (v31 >= 11)
  {
    v32 = (unsigned int *)(v28 + 44);
    v33 = (_WORD *)(v29 + 22);
    v34 = (v31 - 10);
    do
    {
      v35 = *v32++;
      *v33++ = v35 >> 8;
      --v34;
    }
    while (v34);
  }
  v36 = *(unsigned int *)(a1 + 464);
  if ((int)v36 >= 1)
  {
    v37 = *(void **)(a1 + 184);
    v38 = *(const void **)(a1 + 160);
    if ((int)v36 <= v15)
    {
      cstdlib_memmove(v37, v38, 2 * v36);
      BET3FXD__MFVSyn__mlsa_filter((_QWORD *)a1, *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 232), *(_DWORD *)(a1 + 464));
    }
    else
    {
      cstdlib_memmove(v37, v38, 2 * v15);
      BET3FXD__MFVSyn__mlsa_filter((_QWORD *)a1, *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 232), v15);
      cstdlib_memmove(*(void **)(a1 + 160), (const void *)(*(_QWORD *)(a1 + 160) + 2 * v15), 2 * (*(_DWORD *)(a1 + 464) - v15));
    }
  }
  for (j = *(_DWORD *)(a1 + 464); j < v15; *(_DWORD *)(a1 + 464) = j)
  {
    v40 = j * v16;
    v41 = *(unsigned __int16 *)(a1 + 400);
    if (*(_DWORD *)(a1 + 56) >= 3u)
      v41 = (v40 * v41 + (0x10000 - v40) * *(unsigned __int16 *)(a1 + 432)) >> 16;
    v42 = v41 >> 6;
    if (v42 <= *(_DWORD *)(a1 + 20))
      v42 = *(_DWORD *)(a1 + 20);
    if (v42 >= *(_DWORD *)(a1 + 24))
      v43 = *(_DWORD *)(a1 + 24);
    else
      v43 = v42;
    v44 = *(unsigned __int16 *)(a1 + 352);
    if (*(_WORD *)(a1 + 352) && *(_WORD *)(a1 + 354))
      v44 = (v40 * v44 + (0x10000 - v40) * *(unsigned __int16 *)(a1 + 354)) >> 16;
    MFVSyn__filterExcitationWithShapingFilter(a1, v43, v44, a1 + 176);
    v45 = *(int *)(a1 + 464);
    v46 = v45 + v43;
    if ((int)v45 + v43 >= v15)
      v46 = v15;
    BET3FXD__MFVSyn__mlsa_filter((_QWORD *)a1, *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 232) + 2 * v45, v46 - v45);
    v47 = *(_DWORD *)(a1 + 464);
    j = v47 + v43;
    if (v47 + v43 > v15)
    {
      cstdlib_memmove(*(void **)(a1 + 160), (const void *)(*(_QWORD *)(a1 + 184) + 2 * (v15 - v47)), 2 * (v43 - (v15 - v47)));
      j = *(_DWORD *)(a1 + 464) + v43;
    }
  }
  *(_WORD *)(a1 + 354) = *(_WORD *)(a1 + 352);
  *(_DWORD *)(a1 + 432) = *(_DWORD *)(a1 + 400);
  cstdlib_memmove(*(void **)(a1 + 448), *(const void **)(a1 + 416), 4 * (*(_DWORD *)(a1 + 120) + 1));
  *(_DWORD *)(a1 + 464) -= v15;
  *a6 = *(_QWORD *)(a1 + 232);
  return 0;
}

uint64_t BET3FXD__MFVSyn__setSpectralOrder(uint64_t a1, int a2)
{
  uint64_t result;

  if (a2 < 10 || *(_DWORD *)(a1 + 124) < a2)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_DWORD *)(a1 + 120) = a2;
  return result;
}

uint64_t BET3FXD__MFVSyn__getSpectralOrder(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 120);
  return 0;
}

uint64_t BET3FXD__MFVSyn__setVolumeBoost(_DWORD *a1, unsigned int a2)
{
  int v3;
  int v4;
  uint64_t result;

  if (a2 > 0xC8)
    return 0xFFFFFFFFLL;
  if (a2 == 100)
    v3 = 0x4000;
  else
    v3 = 164 * a2;
  a1[7] = v3;
  v4 = fxd_S32ShMultRndS32S32(v3, 4 * a1[11], 16);
  result = 0;
  a1[8] = v4;
  return result;
}

uint64_t MFVSyn__setRelativeUVBoost(_DWORD *a1, unsigned int a2)
{
  int v2;

  if (a2 > 0xC8)
    return 0xFFFFFFFFLL;
  v2 = 164 * a2;
  if (a2 == 100)
    v2 = 0x4000;
  a1[11] = v2;
  BET3FXD__MFVSyn__setVolumeBoost(a1, (100 * a1[7]) >> 14);
  return 0;
}

uint64_t BET3FXD__MFVSyn__setMVFBoost(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  int v4;

  if (a2 > 0xC8)
    return 0xFFFFFFFFLL;
  result = 0;
  v4 = 164 * a2;
  if (a2 == 100)
    v4 = 0x4000;
  *(_DWORD *)(a1 + 48) = v4;
  return result;
}

uint64_t BET3FXD__MFVSyn__setPitchLevelPercent(uint64_t a1, int a2)
{
  uint64_t result;

  if ((a2 - 50) > 0x96)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_DWORD *)(a1 + 36) = (a2 << 16) / 0x64u;
  return result;
}

uint64_t BET3FXD__MFVSyn__setRate(uint64_t a1, int a2)
{
  int v3;
  uint64_t result;

  if ((a2 - 11) > 0xBD)
    return 0xFFFFFFFFLL;
  if (a2 == 100)
    v3 = 0x4000;
  else
    v3 = fxd_S32ShMultRndS32S32(10737418, a2, 16);
  result = 0;
  *(_DWORD *)(a1 + 40) = v3;
  return result;
}

uint64_t BET3FXD__MFVSyn__getVolumeBoost(uint64_t a1, _DWORD *a2)
{
  *a2 = 100 * (*(int *)(a1 + 28) >> 14);
  return 0;
}

uint64_t MFVSyn__getRelativeUVBoost(uint64_t a1, _DWORD *a2)
{
  *a2 = 100 * (*(int *)(a1 + 44) >> 14);
  return 0;
}

uint64_t BET3FXD__MFVSyn__getMVFBoost(uint64_t a1, _DWORD *a2)
{
  *a2 = 100 * (*(_DWORD *)(a1 + 48) >> 14);
  return 0;
}

uint64_t MFVSyn__getPitchLevelPercent(uint64_t a1, unsigned int *a2)
{
  *a2 = (100 * *(_DWORD *)(a1 + 36)) >> 16;
  return 0;
}

uint64_t BET3FXD__MFVSyn__getRate(uint64_t a1, _DWORD *a2)
{
  *a2 = 100 * (*(int *)(a1 + 40) >> 14);
  return 0;
}

uint64_t BET3FXD__MFVSyn__construct(uint64_t a1)
{
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 396) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  BET3FXD__rand_num_init((_DWORD *)(a1 + 60));
  MFVSyn__mlsa_filter_construct((_QWORD *)a1);
  MFVSyn__MVFExcitation_construct(a1);
  *(_DWORD *)(a1 + 20) = BET3FXD__wave_t__convertFromF0ToTp((_DWORD *)(a1 + 8), 0xAF00u) >> 6;
  *(_DWORD *)(a1 + 24) = BET3FXD__wave_t__convertFromF0ToTp((_DWORD *)(a1 + 8), 0xA00u) >> 6;
  *(_WORD *)(a1 + 52) = BET3FXD__wave_t__convertFromMsecToTp((_DWORD *)(a1 + 8), 4) >> 6;
  *(_QWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 40) = 0x4000;
  *(_DWORD *)(a1 + 28) = 0x4000;
  *(_DWORD *)(a1 + 32) = fxd_S32ShMultRndS32S32(0x4000, 4 * *(_DWORD *)(a1 + 44), 16);
  *(_QWORD *)(a1 + 44) = 0x400000004000;
  BET3FXD__MFVSyn__setVolumeBoost((_DWORD *)a1, (100 * *(_DWORD *)(a1 + 28)) >> 14);
  *(_DWORD *)(a1 + 36) = 0x10000;
  return 0;
}

uint64_t BET3FXD__MFVSyn__deconstruct(_DWORD *a1)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;

  v2 = BET3FXD__vect_t__deleteVect((uint64_t)(a1 + 110));
  if (BET3FXD__vect_t__deleteVect((uint64_t)(a1 + 102)) | v2)
    v3 = -1;
  else
    v3 = 0;
  v4 = a1[14];
  if (v4 >= a1[84])
  {
    if (vect_t__deleteVect_qs((uint64_t)(a1 + 76)))
      v3 = -1;
    v4 = a1[14];
  }
  if (v4 >= a1[96] && vect_t__deleteVect_qs((uint64_t)(a1 + 90)))
    v3 = -1;
  v5 = BET3FXD__MFVSyn__mlsa_filter_deinit((uint64_t)a1);
  v6 = BET3FXD__vect_t__deleteVect((uint64_t)(a1 + 18));
  v7 = BET3FXD__vect_t__deleteVect((uint64_t)(a1 + 32));
  v8 = vect_t__deleteVect_qs((uint64_t)(a1 + 38));
  v9 = vect_t__deleteVect_qs((uint64_t)(a1 + 44));
  v10 = vect_t__deleteVect_qs((uint64_t)(a1 + 50));
  v11 = vect_t__deleteVect_qs((uint64_t)(a1 + 56));
  if (MFVSyn__deleteMVFExcitation(a1) | v11 | v10 | v9 | v8 | v7 | v6 | v5)
    return 0xFFFFFFFFLL;
  else
    return v3;
}

uint64_t BET3FXD__MFVSyn__reset__MVF_Synthesis(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v1 = *a1;
  if (!*a1)
    return 0xFFFFFFFFLL;
  BET3FXD__rand_num_init((_DWORD *)(v1 + 60));
  *(_DWORD *)(v1 + 464) = 0;
  *(_DWORD *)(v1 + 396) = 0;
  *(_WORD *)(v1 + 354) = 0;
  cstdlib_memset(*(void **)(v1 + 552), 0, 4 * *(unsigned int *)(v1 + 564));
  cstdlib_memset(*(void **)(v1 + 576), 0, 4 * *(unsigned int *)(v1 + 588));
  *(_WORD *)(v1 + 432) = *(_WORD *)(v1 + 344);
  *(_WORD *)(v1 + 434) = 0;
  cstdlib_memset(*(void **)(v1 + 448), 0, 4 * *(unsigned int *)(v1 + 456));
  BET3FXD__MFVSyn__mc2mlsa(v1, *(_QWORD *)(v1 + 448), *(int32x2_t **)(v1 + 448));
  cstdlib_memset(*(void **)(v1 + 184), 0, 2 * *(unsigned int *)(v1 + 196));
  cstdlib_memset(*(void **)(v1 + 160), 0, 2 * *(unsigned int *)(v1 + 172));
  cstdlib_memset(*(void **)(v1 + 256), 0, 2 * *(unsigned int *)(v1 + 268));
  cstdlib_memset(*(void **)(v1 + 280), 0, 2 * *(unsigned int *)(v1 + 292));
  cstdlib_memset(*(void **)(v1 + 208), 0, 2 * *(unsigned int *)(v1 + 220));
  cstdlib_memset(*(void **)(v1 + 528), 0, 2 * *(unsigned int *)(v1 + 540));
  *(_DWORD *)(v1 + 512) = 0;
  *(_QWORD *)(v1 + 504) = 0xFFFFFFFF00000004;
  *(_WORD *)(v1 + 500) = 2;
  cstdlib_memset(*(void **)(v1 + 136), 0, 4 * *(unsigned int *)(v1 + 148));
  v_set_qs(*(_WORD **)(v1 + 312), *(_WORD *)(v1 + 344), *(_DWORD *)(v1 + 324));
  result = 0;
  if (*(_DWORD *)(v1 + 56) >= *(_DWORD *)(v1 + 384))
  {
    cstdlib_memset(*(void **)(v1 + 368), 0, 2 * *(unsigned int *)(v1 + 380));
    return 0;
  }
  return result;
}

uint64_t BET3FXD__MFVSyn__init__MVF_Synthesis(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, int a9, _BYTE *a10)
{
  uint64_t v18;
  uint64_t *v19;
  __int128 v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v31;
  uint64_t v32;
  int v33;
  __int128 v34;
  int v35;
  __int128 v36;
  int v37;
  _QWORD *v38;

  v18 = heap_Calloc(*(_QWORD **)(a2 + 8), 1, 704);
  v38 = (_QWORD *)v18;
  *a1 = v18;
  if (!v18)
    return 0xFFFFFFFFLL;
  v19 = (uint64_t *)v18;
  v36 = 0uLL;
  v37 = 0;
  *(_QWORD *)v18 = a2;
  v20 = *a3;
  v21 = *((_DWORD *)a3 + 8);
  *(_OWORD *)(v18 + 36) = a3[1];
  *(_OWORD *)(v18 + 20) = v20;
  *(_DWORD *)(v18 + 52) = v21;
  *(_DWORD *)(v18 + 56) = a9;
  *(_DWORD *)(v18 + 120) = a6;
  *(_DWORD *)(v18 + 124) = a6;
  if ((int)a8 > 15999)
  {
    if ((_DWORD)a8 == 22050)
      goto LABEL_8;
    v22 = 16000;
  }
  else
  {
    if ((_DWORD)a8 == 8000)
      goto LABEL_8;
    v22 = 11025;
  }
  if ((_DWORD)a8 != v22)
    goto LABEL_16;
LABEL_8:
  BET3FXD__wave_t__setSampleRateHz((_DWORD *)(v18 + 8), a8);
  if (BET3FXD__MFVSyn__construct((uint64_t)v19))
    goto LABEL_16;
  *((_DWORD *)v19 + 7) = 0x4000;
  *((_DWORD *)v19 + 8) = fxd_S32ShMultRndS32S32(0x4000, 4 * *((_DWORD *)v19 + 11), 16);
  *((_DWORD *)v19 + 10) = 0x4000;
  if ((int)a8 > 15999)
  {
    if ((_DWORD)a8 != 22050)
    {
      v23 = 16000;
LABEL_14:
      if ((_DWORD)a8 != v23)
        goto LABEL_16;
    }
  }
  else if ((_DWORD)a8 != 8000)
  {
    v23 = 11025;
    goto LABEL_14;
  }
  *((_WORD *)v19 + 26) = BET3FXD__wave_t__convertFromMsecToTp((_DWORD *)v19 + 2, a5) >> 6;
  if (!BET3FXD__MFVSyn__loadExcTable(v19, a4, v24, v25, v26, v27, v28, v29))
  {
    *((_DWORD *)v19 + 98) = 0;
    *((_WORD *)v19 + 172) = BET3FXD__wave_t__convertFromF0ToTp((_DWORD *)v19 + 2, 0x3E80u);
    *((_DWORD *)v19 + 85) = BET3FXD__wave_t__convertFromF0ToTp((_DWORD *)v19 + 2, 0xF00u);
    *((_DWORD *)v19 + 84) = 3;
    if (*((_DWORD *)v19 + 14) >= 3u)
    {
      if (vect_t__createVect_qs(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 38), 4u))
        goto LABEL_16;
      v_set_qs((_WORD *)v19[39], *((_WORD *)v19 + 172), *((_DWORD *)v19 + 81));
      *((_DWORD *)v19 + 83) = 0x10000 / *((_DWORD *)v19 + 80);
      *((_DWORD *)v19 + 82) = 0;
    }
    *((_DWORD *)v19 + 16) = BET3FXD__wave_t__sampleRateHz((unsigned int *)v19 + 2);
    *((_DWORD *)v19 + 96) = 3;
    if ((*((_DWORD *)v19 + 14) < 3u
       || !vect_t__createVect_qs(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 45), 5u))
      && !MFVSyn__createMVFExcitation(v19)
      && !BET3FXD__vect_t__createVect(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 9), *((_DWORD *)v19 + 30) + 1))
    {
      *((_WORD *)v19 + 177) = 0;
      *((_DWORD *)v19 + 116) = 0;
      v31 = *((unsigned __int16 *)v19 + 26);
      *((_DWORD *)v19 + 74) = v31;
      *((_DWORD *)v19 + 75) = (unsigned __int16)(0x10000 / v31);
      if (v31)
      {
        if ((unsigned __int16)(0x10000 / v31))
        {
          v32 = *((int *)v19 + 14);
          if (v32 <= 4)
          {
            v33 = dword_214F979A4[v32];
            if (!BET3FXD__vect_t__createVect(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 16), *((_DWORD *)v19 + 30) + 1))
            {
              *((_DWORD *)v19 + 129) = BET3FXD__wave_t__convertFromMsecToTp((_DWORD *)v19 + 2, v33) >> 6;
              if (!MFVSyn__mlsa_filter_consult((uint64_t)v19, *((_DWORD *)v19 + 14), a8, a7, a10, (uint64_t)&v36))
              {
                v34 = v36;
                v35 = v37;
                if (!BET3FXD__MFVSyn__mlsa_filter_init((uint64_t)v19, (uint64_t)&v34)
                  && !vect_t__createVect_qs(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 22), *((_DWORD *)v19 + 74) + *((_DWORD *)v19 + 17) + *((_DWORD *)v19 + 6) + 1)&& !vect_t__createVect_qs(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 19), *((_DWORD *)v19 + 74) + *((_DWORD *)v19 + 17) + *((_DWORD *)v19 + 6) + 1)&& !vect_t__createVect_qs(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 25), *((_DWORD *)v19 + 74) + *((_DWORD *)v19 + 17) + *((_DWORD *)v19 + 6) + 1)&& !vect_t__createVect_qs(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 28), 2 * *((_DWORD *)v19 + 74)))
                {
                  *((_WORD *)v19 + 216) = *((_WORD *)v19 + 172);
                  *((_WORD *)v19 + 217) = 0;
                  if (!BET3FXD__vect_t__createVect(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 55), *((_DWORD *)v19 + 30) + 1)&& !BET3FXD__vect_t__createVect(*(_QWORD *)(*v19 + 8), (uint64_t)(v19 + 51), *((_DWORD *)v19 + 30) + 1))
                  {
                    BET3FXD__MFVSyn__mc2mlsa((uint64_t)v19, v19[56], (int32x2_t *)v19[56]);
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_16:
  MFVSyn__denit__MVF_Synthesis(&v38);
  *a1 = 0;
  return 0xFFFFFFFFLL;
}

uint64_t MFVSyn__denit__MVF_Synthesis(_QWORD **a1)
{
  _DWORD *v2;
  int v3;
  uint64_t v4;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *a1;
  if (!*a1)
    return 0;
  v3 = BET3FXD__MFVSyn__releaseExcTable(*a1);
  if (BET3FXD__MFVSyn__deconstruct(v2) | v3)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = 0;
  if (*(_QWORD *)v2)
    heap_Free(*(_QWORD **)(*(_QWORD *)v2 + 8), (uint64_t)v2);
  *a1 = 0;
  return v4;
}

uint64_t MFVSyn__logStateMachine__MVF_Synthesis()
{
  return 0;
}

uint64_t getAlpha(int a1)
{
  if (a1 > 11999)
  {
    switch(a1)
    {
      case 12000:
        return 6207570;
      case 22050:
        return 7381975;
      case 16000:
        return 7046431;
    }
  }
  else
  {
    switch(a1)
    {
      case 8000:
        return 5200937;
      case 10000:
        return 5872026;
      case 11025:
        return 6039798;
    }
  }
  return 0;
}

int32x2_t BET3FXD__MFVSyn__mc2mlsa(uint64_t a1, uint64_t a2, int32x2_t *a3)
{
  unint64_t v3;
  int v4;
  int v5;
  int32x2_t result;

  v3 = *(int *)(a1 + 120);
  v4 = *(_DWORD *)(a1 + 608);
  a3->i32[v3] = *(_DWORD *)(a2 + 4 * v3);
  if ((int)v3 >= 1)
  {
    v3 = v3;
    v5 = (__int16)(v4 >> 8);
    do
      a3->i32[(v3 - 1)] = *(_DWORD *)(a2 + 4 * (v3 - 1))
                                      - ((a3->i32[v3] >> 16) * v5
                                       + (((unsigned __int16)a3->i32[v3] * v5 + 0x8000) >> 16));
    while (v3-- > 1);
  }
  result = vmin_s32(vmax_s32(*a3, (int32x2_t)0xFF09999A00000000), (int32x2_t)0xF6666601F9999ALL);
  *a3 = result;
  return result;
}

uint64_t MFVSyn__mlsadf_fxd(uint64_t a1, int a2, __int16 *a3)
{
  int v5;
  uint64_t v6;
  int v7;
  __int16 *v8;
  uint64_t v9;
  int *v10;
  int *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  __int16 *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  __int16 *v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  __int16 *v51;
  int v52;
  int v53;
  _DWORD *v54;
  uint64_t v55;
  int *v56;
  __int16 *v57;
  int v58;
  int v59;
  int *v60;
  uint64_t v61;
  int v62;
  BOOL v63;
  __int16 *v64;
  int v65;
  int v66;
  char v67;
  int v68;
  int v69;
  uint64_t v70;
  int *v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  int v77;
  __int16 *v78;
  int v79;
  uint64_t v80;
  __int16 *v81;
  int v82;
  int v83;
  uint64_t v84;
  int *v85;
  uint64_t v86;
  _DWORD *v87;
  int v88;
  int v89;
  uint64_t v90;
  _DWORD *v91;
  _DWORD *v92;
  int v93;
  uint64_t v94;
  int *v95;
  int v96;
  int v97;
  int v98;
  uint64_t v99;
  int v100;
  int v101;
  __int16 *v102;
  int v103;
  uint64_t v104;
  __int16 *v105;
  int v106;
  int v107;
  int *v108;
  uint64_t v109;
  _DWORD *v110;
  int v111;
  int v112;
  int *v113;
  uint64_t v114;
  int v115;
  int v116;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int *v123;
  uint64_t v125;
  __int16 *v126;
  uint64_t v127;
  int v128;
  uint64_t v129;
  int v130;
  int v131;
  __int16 *v132;
  int v133;

  v5 = 0;
  v6 = *(_QWORD *)(a1 + 552);
  v128 = *(_DWORD *)(a1 + 120);
  v7 = *(__int16 *)(a1 + 616);
  v133 = *(__int16 *)(a1 + 618);
  v8 = *(__int16 **)(a1 + 600);
  v9 = *(unsigned __int8 *)(a1 + 621);
  v10 = (int *)(v6 + 4 * v9 + 4);
  v127 = v6;
  v11 = (int *)(v6 + 8 * v9);
  v12 = v6;
  do
  {
    v13 = *v11--;
    v14 = fxd_S32ShMultRndS32S16(v13, v133, 14);
    v15 = fxd_S32ShMultRndS32S16(*(_DWORD *)(v12 + 4 * v9), v7, 14);
    *(_DWORD *)(v12 + 4 * v9) = v15 + v14;
    v16 = (((v15 + v14) >> 12) & 0xFFFFFFF0) * a3[1] + (((unsigned __int16)(v15 + v14) * a3[1]) >> 12);
    v10[v9] = v16;
    if (v9 == 3)
      v17 = (v10[3] * v8[3]) >> 16;
    else
      v17 = (int)(v16 * v8[v9]) >> 18;
    if ((v9-- & 1) == 0)
      v19 = -v17;
    else
      v19 = v17;
    a2 += 2 * v19;
    v5 += v17;
  }
  while ((unint64_t)(v9 + 1) > 3);
  v20 = fxd_S32ShMultRndS32S16(v10[1], v133, 14);
  v21 = fxd_S32ShMultRndS32S16(*(_DWORD *)(v127 + 8), v7, 14);
  *(_DWORD *)(v127 + 8) = v21 + v20;
  v22 = (((v21 + v20) >> 12) & 0xFFFFFFF0) * a3[1] + (((unsigned __int16)(v21 + v20) * a3[1]) >> 12);
  v10[2] = v22;
  v23 = fxd_S32ShMultRndS32S16(v22, v8[2], 15);
  v24 = a2 - 2 * v23;
  v25 = v23 + v5;
  v26 = (*v10 >> 14) & 0xFFFFFFFC;
  v27 = (unsigned __int16)*v10 * v133 + 0x2000;
  v28 = fxd_S32ShMultRndS32S16(*(_DWORD *)(v127 + 4), v7, 14);
  v29 = v28 + v26 * v133 + (v27 >> 14);
  *(_DWORD *)(v127 + 4) = v29;
  v30 = (((unsigned __int16)(v28 + v26 * v133 + (v27 >> 14)) * a3[1]) >> 12) + 16 * a3[1] * (v29 >> 16);
  v10[1] = v30;
  v31 = fxd_S32ShMultRndS32S16(v30, v8[1], 15);
  v32 = v31 + (v24 >> 1);
  *v10 = v32;
  v130 = v25 + v31 + v32;
  v131 = 0;
  v33 = a1;
  v34 = *(unsigned __int8 *)(a1 + 620);
  v119 = *(unsigned __int16 *)(a1 + 642);
  v35 = v127 + 4 * v119;
  v36 = (int *)(v35 + 4 * *(unsigned __int16 *)(a1 + 2 * v34 + 624));
  v37 = a3 + 2;
  v125 = v35;
  v126 = a3 + 5;
  if (v128 <= 11)
    v38 = 11;
  else
    v38 = v128;
  v122 = (v38 + 1);
  v123 = (int *)(v35 + 4 * *(unsigned __int16 *)(a1 + 2 * v34 + 624));
  v121 = v35 + 44;
  v118 = v38;
  v120 = v38 - 10;
  v132 = a3 + 11;
  do
  {
    v39 = v34;
    v40 = *(unsigned __int16 *)(v33 + 2 * v34 + 622);
    v41 = (int *)(v125 + 4 * v40);
    v129 = v34 - 1;
    v42 = v36[v34 - 1];
    *v41 = v42;
    v43 = fxd_S32ShMultRndS32S16(v42, v133, 14);
    v44 = 0;
    v45 = 0;
    v41[1] = fxd_S32ShMultRndS32S16(v41[1], v7, 14) + v43;
    v46 = v37;
    do
    {
      v47 = v41[v44 + 2];
      v48 = fxd_S32ShMultRndS32S16(v41[v44 + 3] - v41[v44 + 1], v7, 14);
      v41[v44 + 2] = v48 + v47;
      v49 = *v46++;
      v45 += (((v48 + v47) >> 12) & 0xFFFFFFF0) * v49 + (((unsigned __int16)(v48 + v47) * v49 + 2048) >> 12);
      ++v44;
    }
    while (v44 != 3);
    v50 = 0;
    v51 = v126;
    do
    {
      v52 = v41[v50 + 5] + (((v41[v50 + 6] - v41[v50 + 4]) * v7) >> 14);
      v41[v50 + 5] = v52;
      v53 = *v51++;
      v45 += ((v52 >> 13) & 0xFFFFFFF8) * v53 + (((unsigned __int16)v52 * v53 + 4096) >> 13);
      ++v50;
    }
    while (v50 != 6);
    v54 = v41 + 12;
    v55 = v120;
    v56 = (int *)(v121 + 4 * v40);
    v57 = v132;
    do
    {
      v58 = *v56 + (((*v54 - *(v54 - 2)) * v7) >> 14);
      *v56++ = v58;
      v59 = *v57++;
      v45 += fxd_S32ShMultRndS32S16(v58, v59, 14);
      ++v54;
      --v55;
    }
    while (v55);
    v60 = v54 - 2;
    v61 = v122;
    v36 = v123;
    do
    {
      v62 = *v60--;
      v41[v61] = v62;
      v63 = v61-- <= 2;
    }
    while (!v63);
    v123[v39] = v45;
    v33 = a1;
    v64 = v132;
    if (v39 == 3)
    {
      v65 = v123[3];
      v66 = *(__int16 *)(*(_QWORD *)(a1 + 592) + 6);
      v67 = 16;
    }
    else
    {
      v66 = *(__int16 *)(*(_QWORD *)(a1 + 592) + 2 * v39);
      v65 = v45;
      v67 = 18;
    }
    v68 = fxd_S32ShMultRndS32S16(v65, v66, v67);
    v34 = v129;
    if ((v39 & 1) != 0)
      v69 = v68;
    else
      v69 = -v68;
    v130 += v69;
    v131 += v68;
  }
  while (v39 > 3);
  v70 = *(unsigned __int16 *)(a1 + 626);
  v71 = (int *)(v125 + 4 * v70);
  v72 = v123[1];
  *v71 = v72;
  v73 = fxd_S32ShMultRndS32S16(v72, v133, 14);
  v74 = fxd_S32ShMultRndS32S16(v71[1], v7, 14);
  v75 = 0;
  v76 = 0;
  v77 = v74 + v73;
  v71[1] = v74 + v73;
  v78 = v37;
  do
  {
    v77 = v71[v75 + 2] + (((v71[v75 + 3] - v77) * v7) >> 14);
    v71[v75 + 2] = v77;
    v79 = *v78++;
    v76 += (v77 * v79) >> 12;
    ++v75;
  }
  while (v75 != 3);
  v80 = 0;
  v81 = v126;
  do
  {
    v82 = v71[v80 + 5] + (((v71[v80 + 6] - v71[v80 + 4]) * v7) >> 14);
    v71[v80 + 5] = v82;
    v83 = *v81++;
    v76 += (v82 * v83) >> 13;
    ++v80;
  }
  while (v80 != 6);
  v84 = 4 * v70;
  v85 = (int *)(4 * v70 + 4 * v119 + v127 + 44);
  v86 = v118 - 10;
  v87 = v71 + 12;
  do
  {
    v88 = *v85 + (((*v87 - *(v87 - 2)) * v7) >> 14);
    *v85++ = v88;
    v89 = *v64++;
    v76 += fxd_S32ShMultRndS32S16(v88, v89, 14);
    ++v87;
    --v86;
  }
  while (v86);
  v90 = v118 + 3;
  v91 = (_DWORD *)(v84 + 4 * v119 + 4 * v118 + v127 + 4);
  v92 = v87 - 2;
  do
  {
    *v91 = *v92;
    *(v91 - 1) = *(v92 - 1);
    v90 -= 2;
    v91 -= 2;
    v92 -= 2;
  }
  while (v90 > 3);
  v123[2] = v76;
  v93 = fxd_S32ShMultRndS32S16(v76, *(__int16 *)(*(_QWORD *)(a1 + 592) + 4), 15);
  v94 = *(unsigned __int16 *)(a1 + 624);
  v95 = (int *)(v125 + 4 * v94);
  v96 = *v123;
  *v95 = *v123;
  v97 = fxd_S32ShMultRndS32S16(v96, v133, 14);
  v98 = fxd_S32ShMultRndS32S16(v95[1], v7, 14);
  v99 = 0;
  v100 = 0;
  v101 = v98 + v97;
  v95[1] = v98 + v97;
  v102 = v132;
  do
  {
    v101 = v95[v99 + 2] + (((v95[v99 + 3] - v101) * v7) >> 14);
    v95[v99 + 2] = v101;
    v103 = *v37++;
    v100 += (v101 * v103) >> 12;
    ++v99;
  }
  while (v99 != 3);
  v104 = 0;
  v105 = v126;
  do
  {
    v106 = v95[v104 + 5] + (((v95[v104 + 6] - v95[v104 + 4]) * v7) >> 14);
    v95[v104 + 5] = v106;
    v107 = *v105++;
    v100 += (v106 * v107) >> 13;
    ++v104;
  }
  while (v104 != 6);
  v108 = (int *)(4 * v94 + 4 * v119 + v127 + 44);
  v109 = v118 - 10;
  v110 = v95 + 12;
  do
  {
    v111 = *v108 + (((*v110 - *(v110 - 2)) * v7) >> 14);
    *v108++ = v111;
    v112 = *v102++;
    v100 += fxd_S32ShMultRndS32S16(v111, v112, 14);
    ++v110;
    --v109;
  }
  while (v109);
  v113 = v110 - 2;
  v114 = v122;
  do
  {
    v115 = *v113--;
    v95[v114] = v115;
    v63 = v114-- <= 2;
  }
  while (!v63);
  v123[1] = v100;
  v116 = fxd_S32ShMultRndS32S16(v100, *(__int16 *)(*(_QWORD *)(a1 + 592) + 2), 15);
  *v123 = v116 + v130 - v93;
  return (v131 + v116 + v116 + v130);
}

_QWORD *BET3FXD__MFVSyn__mlsa_filter(_QWORD *result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t i;
  unsigned int v13;
  uint64_t j;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;

  if (a4 >= 1)
  {
    v5 = (uint64_t)result;
    v6 = 0;
    v7 = result[17];
    v8 = (__int16 *)result[13];
    v9 = result[10];
    v10 = v9 + 20;
    do
    {
      v11 = *(__int16 *)(a2 + 2 * v6);
      result = (_QWORD *)MFVSyn__mlsadf_fxd(v5, ((((unsigned __int16)g_expTable[**(__int16 **)(v5 + 104) >> 7] * v11) >> 12)+ 16 * v11 * (g_expTable[**(__int16 **)(v5 + 104) >> 7] >> 16)) >> 14, v8);
      for (i = 0; i != 5; ++i)
      {
        v13 = *(_DWORD *)(v7 + 4 * i) + *(_DWORD *)(v9 + 4 * i);
        *(_DWORD *)(v9 + 4 * i) = v13;
        v8[i] = v13 >> 10;
      }
      if (*v8 < 0)
        *v8 = 0;
      for (j = 0; j != 6; ++j)
      {
        v15 = *(_DWORD *)(v7 + 20 + 4 * j) + *(_DWORD *)(v10 + 4 * j);
        *(_DWORD *)(v10 + 4 * j) = v15;
        v8[j + 5] = v15 >> 9;
      }
      v16 = 11;
      do
      {
        v17 = *(_DWORD *)(v7 + 4 * v16) + *(_DWORD *)(v9 + 4 * v16);
        *(_DWORD *)(v9 + 4 * v16) = v17;
        v8[v16] = v17 >> 8;
        v18 = v16++ < *(int *)(v5 + 120);
      }
      while (v18);
      if (((_DWORD)result + 62258) > 0x1E664)
      {
        v19 = (_DWORD)result + 59638 + (((int)result + 59638) >> 2);
        v20 = (v19 >> 1) - 59638;
        v18 = v19 > 0xFFFFEB85;
        v21 = (((v19 >> 1) + 2621 + (((v19 >> 1) + 2621) >> 2)) >> 2) - 62259;
        if (v18)
          v21 = v20;
        if (v21 <= -65536)
          v21 = -65536;
        v22 = (_DWORD)result - 59638 + (((_DWORD)result - 59638) >> 2);
        if (v22 >> 2 >= 0x51F)
          v23 = (((v22 >> 1) - 2621 + (((v22 >> 1) - 2621) >> 2)) >> 2) + 62259;
        else
          v23 = (v22 >> 1) + 59638;
        if (v23 >= 0xFFFF)
          v23 = 0xFFFF;
        if ((int)result >= 59639)
          v21 = v23;
        *(_WORD *)(a3 + 2 * v6) = v21 >> 1;
      }
      else
      {
        *(_WORD *)(a3 + 2 * v6++) = result >> 1;
        if (v6 < a4)
          continue;
      }
      ++v6;
    }
    while (v6 < a4);
  }
  return result;
}

_QWORD *MFVSyn__mlsa_filter_construct(_QWORD *result)
{
  result[69] = 0;
  result[72] = 0;
  result[13] = 0;
  return result;
}

uint64_t BET3FXD__MFVSyn__mlsa_filter_init(uint64_t a1, uint64_t a2)
{
  int v4;
  int Alpha;
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t result;
  __int16 v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  __int16 v14;
  uint64x2_t v15;
  __int16 v16;
  __int16 v17;
  __int16 v18;
  uint64_t v19;
  _WORD *v20;
  int32x2_t v21;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (!*(_DWORD *)(a1 + 120))
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 608) = *(_DWORD *)a2;
  v4 = BET3FXD__wave_t__sampleRateHz((unsigned int *)(a1 + 8));
  Alpha = getAlpha(v4);
  *(_DWORD *)(a1 + 608) = Alpha;
  v6 = fxd_S32ShMultRndS32S32(Alpha, Alpha, 24);
  *(_DWORD *)(a1 + 612) = 0x1000000 - v6;
  v7 = *(_DWORD *)(a1 + 608);
  *(_WORD *)(a1 + 616) = v7 >> 10;
  *(_WORD *)(a1 + 618) = (0x1000000 - v6) >> 10;
  if (!v7)
    return 0xFFFFFFFFLL;
  if (vect_t__createVect_qs(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 96, *(_DWORD *)(a1 + 120) + 1))
    return 0xFFFFFFFFLL;
  if (*(int *)(a1 + 120) < 4)
    return 0xFFFFFFFFLL;
  v8 = *(unsigned __int8 *)(a2 + 4);
  *(_BYTE *)(a1 + 621) = v8;
  *(_BYTE *)(a1 + 620) = *(_BYTE *)(a2 + 5);
  *(_WORD *)(a1 + 642) = 2 * v8 + 2;
  if (MFVSyn__mlsa_pickPadeApproximation(a1, *(_DWORD *)(a2 + 8), v8, *(unsigned __int8 *)(a2 + 16), (char **)(a1 + 600))|| MFVSyn__mlsa_pickPadeApproximation(a1, *(_DWORD *)(a2 + 12), *(unsigned __int8 *)(a1 + 620), *(unsigned __int8 *)(a2 + 17), (char **)(a1 + 592))|| BET3FXD__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 544, *(unsigned __int8 *)(a1 + 620)+ 2 * *(unsigned __int8 *)(a1 + 621)+ (*(_DWORD *)(a1 + 120) + 2) * *(unsigned __int8 *)(a1 + 620)+ 3)|| BET3FXD__vect_t__createVect(*(_QWORD *)(*(_QWORD *)a1 + 8), a1 + 568, *(_DWORD *)(a1 + 120) + 1))
  {
    return 0xFFFFFFFFLL;
  }
  v10 = 0;
  v11 = 0;
  v12 = *(unsigned __int8 *)(a1 + 620);
  v13 = *(_DWORD *)(a1 + 120);
  v14 = v13 + 2;
  v15 = (uint64x2_t)vdupq_n_s64(v12 + 1);
  v16 = v12 * (v13 + 2);
  v17 = -4 - 2 * v13;
  v18 = (v12 - 1) * v14;
  v19 = ((_WORD)v12 + 3) & 0x1FE;
  v20 = (_WORD *)(a1 + 2 * *(unsigned __int8 *)(a1 + 620) + 624);
  do
  {
    v21 = vmovn_s64((int64x2_t)vcgeq_u64(v15, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v11), (int8x16_t)xmmword_214F962F0)));
    if ((v21.i8[0] & 1) != 0)
      *v20 = v16 + v10;
    if ((v21.i8[4] & 1) != 0)
      *(v20 - 1) = v18 + v10;
    result = 0;
    v11 += 2;
    v20 -= 2;
    v10 += v17;
  }
  while (v19 != v11);
  return result;
}

uint64_t BET3FXD__MFVSyn__mlsa_filter_deinit(uint64_t a1)
{
  int v2;
  int v3;

  v2 = vect_t__deleteVect_qs(a1 + 96);
  v3 = BET3FXD__vect_t__deleteVect(a1 + 544);
  if (BET3FXD__vect_t__deleteVect(a1 + 568) | v3 | v2)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t MFVSyn__mlsa_pickPadeApproximation(uint64_t a1, int a2, unsigned int a3, int a4, char **a5)
{
  char *v5;
  uint64_t result;
  char *v7;

  if (a2 == 1)
  {
    if (a3 - 2 <= 5)
    {
      result = 0xFFFFFFFFLL;
      switch(a4)
      {
        case 2:
          v7 = (char *)&g_ChebyPade_R2;
          goto LABEL_15;
        case 3:
          v7 = (char *)&g_ChebyPade_R3;
          goto LABEL_15;
        case 4:
          v7 = (char *)&g_ChebyPade_R4;
          goto LABEL_15;
        case 5:
          v7 = (char *)&g_ChebyPade_R5;
          goto LABEL_15;
        case 6:
          v7 = (char *)&g_ChebyPade_R6;
          goto LABEL_15;
        case 8:
          v7 = (char *)&g_ChebyPade_R8;
LABEL_15:
          v5 = &v7[16 * a3];
          goto LABEL_16;
        default:
          return result;
      }
    }
    return 0;
  }
  else if (a2 || a3 - 3 > 2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    v5 = (char *)&g_pade_0 + 12 * a3;
LABEL_16:
    result = 0;
    *a5 = v5;
  }
  return result;
}

uint64_t mlsa_strcpy(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int v3;

  v2 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a2 + v2);
    *(_BYTE *)(result + v2++) = v3;
  }
  while (v3);
  return result;
}

unint64_t mlsa_strlen(unint64_t result)
{
  unsigned __int8 *v1;
  int v2;

  v1 = (unsigned __int8 *)result;
  LODWORD(result) = -1;
  do
  {
    v2 = *v1++;
    result = (result + 1);
  }
  while (v2);
  return result;
}

uint64_t MFVSyn__mlsa_filter_mlp_fill(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t result;
  const char *v13;
  unsigned __int8 v14;
  _DWORD v15[2];
  _BYTE v16[128];
  uint64_t v17;

  v7 = 0;
  v17 = *MEMORY[0x24BDAC8D0];
  do
  {
    v8 = *(unsigned __int8 *)(a5 + v7);
    v16[v7++] = v8;
  }
  while (v8);
  qmemcpy(v15, "XLMHU", 5);
  *(_DWORD *)a6 = a4;
  if (!v16[0])
    return 0xFFFFFFFFLL;
  v9 = 0;
  while (v16[++v9])
    ;
  if ((_DWORD)v9 != 80)
    return 0xFFFFFFFFLL;
  v11 = 0;
  while (v16[v11] != *((_BYTE *)v15 + a2))
  {
    v11 += 16;
    if ((_DWORD)v11 == 80)
      return 0;
  }
  v13 = &v16[v11];
  *((_BYTE *)v13 + 14) = 0;
  *((_BYTE *)v13 + 12) = 0;
  *((_BYTE *)v13 + 10) = 0;
  *((_BYTE *)v13 + 8) = 0;
  *((_BYTE *)v13 + 6) = 0;
  *((_BYTE *)v13 + 4) = 0;
  *((_BYTE *)v13 + 2) = 0;
  *(_DWORD *)(a6 + 8) = LH_atoi(&v16[v11 + 7]);
  *(_DWORD *)(a6 + 12) = LH_atoi(v13 + 13);
  *(_BYTE *)(a6 + 4) = LH_atoi(v13 + 3);
  *(_BYTE *)(a6 + 5) = LH_atoi(v13 + 9);
  *(_BYTE *)(a6 + 16) = LH_atoi(v13 + 5);
  v14 = LH_atoi(v13 + 11);
  result = 0;
  *(_BYTE *)(a6 + 17) = v14;
  return result;
}

uint64_t MFVSyn__mlsa_filter_consult(uint64_t a1, unsigned int a2, uint64_t a3, int a4, _BYTE *a5, uint64_t a6)
{
  uint64_t result;
  int v7;
  int v8;
  char v9;
  char v10;
  char v11;
  __int16 v12;

  if (!a1 || !*(_DWORD *)(a1 + 120))
    return 0xFFFFFFFFLL;
  if (a5 && *a5)
    return MFVSyn__mlsa_filter_mlp_fill(a1, a2, a3, a4, (uint64_t)a5, a6);
  v7 = 0;
  v8 = 1;
  v9 = 3;
  v10 = 5;
  switch(a2)
  {
    case 0u:
      v8 = 0;
      v7 = 1;
      v9 = 2;
      goto LABEL_9;
    case 2u:
      v10 = 4;
      goto LABEL_15;
    case 3u:
LABEL_15:
      result = 0;
      *(_DWORD *)a6 = a4;
      *(_QWORD *)(a6 + 8) = 0;
      *(_BYTE *)(a6 + 4) = 3;
      *(_BYTE *)(a6 + 5) = v10;
      v12 = 2056;
      goto LABEL_17;
    case 4u:
      result = 0;
      *(_DWORD *)a6 = a4;
      *(_QWORD *)(a6 + 8) = 0x100000001;
      *(_WORD *)(a6 + 4) = 1795;
      v12 = 1284;
LABEL_17:
      *(_WORD *)(a6 + 16) = v12;
      return result;
    default:
LABEL_9:
      *(_DWORD *)a6 = a4;
      *(_QWORD *)(a6 + 8) = 0x100000001;
      if ((_DWORD)a3 == 8000)
        v11 = 4;
      else
        v11 = 5;
      *(_BYTE *)(a6 + 4) = 3;
      *(_BYTE *)(a6 + 5) = v9;
      result = 0;
      if (v8)
      {
        *(_BYTE *)(a6 + 16) = 4;
      }
      else
      {
        if (!v7)
          return result;
        *(_BYTE *)(a6 + 16) = 4;
      }
      *(_BYTE *)(a6 + 17) = v11;
      break;
  }
  return result;
}

unint64_t zerflt_qs(unint64_t result, __int16 *a2, uint64_t a3, int a4, int a5)
{
  _WORD *v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  __int16 *v9;
  int v10;

  v5 = (_WORD *)(a3 + 2 * (a5 - 1));
  v6 = result + 2 * (a5 - 1);
  do
  {
    v7 = 0;
    LOWORD(v8) = 0;
    v9 = a2;
    do
    {
      v10 = *v9++;
      v8 = ((*(__int16 *)(v6 + v7) * v10) >> 16) + (__int16)v8;
      v7 -= 2;
    }
    while (v9 < &a2[a4]);
    v6 -= 2;
    *v5-- = v8;
  }
  while (v6 >= result);
  return result;
}

uint64_t v_sum_qs(__int16 *a1, int a2)
{
  __int16 v2;
  uint64_t v3;
  __int16 v4;

  if (a2 < 1)
  {
    return 0;
  }
  else
  {
    v2 = 0;
    v3 = a2;
    do
    {
      v4 = *a1++;
      v2 += v4;
      --v3;
    }
    while (v3);
  }
  return v2;
}

_WORD *v_set_qs(_WORD *result, __int16 a2, int a3)
{
  uint64_t v3;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      *result++ = a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t BET3FXD__wave_t__convertFromF0ToTp(_DWORD *a1, unsigned int a2)
{
  int v2;

  if (a2)
    return (unsigned __int16)((*a1 << 12) / a2);
  else
    LOWORD(v2) = 0;
  return (unsigned __int16)v2;
}

uint64_t wave_t__convertFromF0ToTp_SR(unsigned int a1, int a2)
{
  int v2;

  if (a1)
    return (unsigned __int16)((a2 << 12) / a1);
  else
    LOWORD(v2) = 0;
  return (unsigned __int16)v2;
}

uint64_t BET3FXD__wave_t__convertFromTpToF0(_DWORD *a1, unsigned int a2)
{
  int v2;

  if (a2)
    return (unsigned __int16)((*a1 << 12) / a2);
  else
    LOWORD(v2) = 0;
  return (unsigned __int16)v2;
}

uint64_t BET3FXD__wave_t__convertFromMsecToTp(_DWORD *a1, int a2)
{
  return (unsigned __int16)((1049 * a2 * *a1) >> 14);
}

uint64_t BET3FXD__wave_t__sampleRateHz(unsigned int *a1)
{
  return *a1;
}

uint64_t BET3FXD__wave_t__setSampleRateHz(_DWORD *a1, uint64_t a2)
{
  int v2;
  unsigned __int16 v3;

  if (!a1 || (int)a2 < 1)
    return a2;
  *a1 = a2;
  a1[1] = a2 >> 1;
  if ((int)a2 <= 11999)
  {
    if ((_DWORD)a2 == 8000)
    {
      v2 = 268435;
      goto LABEL_15;
    }
    if ((_DWORD)a2 != 11025)
      return a2;
    v3 = -1825;
LABEL_13:
    v2 = v3 | 0x20000;
    goto LABEL_15;
  }
  switch((_DWORD)a2)
  {
    case 0x2EE0:
      v3 = -17651;
      goto LABEL_13;
    case 0x3E80:
      v3 = 3146;
      goto LABEL_13;
    case 0x5622:
      v2 = 97392;
LABEL_15:
      a1[2] = v2;
      break;
  }
  return a2;
}

uint64_t BET3FXD__MFVSyn__loadExcTable(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char *v29;
  __int16 v30;
  char *v31;
  int i;
  unsigned int v33;
  uint64_t v34;
  __int16 v35;
  __int16 v36;
  char *v37;
  int j;
  unsigned int v39;
  uint64_t v40;
  __int16 v41;
  void *v42;
  uint64_t v43;
  int __dst;
  void *__src;
  unsigned int v46;
  int v47;
  char __s1[4];
  char v49;
  _OWORD v50[4];
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v49 = 0;
  v47 = 0;
  *(_DWORD *)__s1 = 0;
  memset(v50, 0, sizeof(v50));
  __src = 0;
  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    if ((ssftriff_reader_OpenChunk(a2, (__int32 *)__s1, (unsigned int *)&v47, &__src, a5, a6, a7, a8) & 0x80000000) == 0
      && !cstdlib_strcmp(__s1, "EXHD"))
    {
      v46 = 64;
      if ((ssftriff_reader_ReadStringZ(a2, (uint64_t)__src, v47, 0, v50, &v46) & 0x80000000) == 0
        && (unint64_t)v46 + 16 >= v47)
      {
        __src = (char *)__src + v46;
        cstdlib_memmove(a1 + 59, __src, 4uLL);
        __src = (char *)__src + 4;
        v11 = (__int16 *)(a1 + 61);
        cstdlib_memmove(a1 + 61, __src, 2uLL);
        __src = (char *)__src + 2;
        cstdlib_memmove((char *)a1 + 490, __src, 2uLL);
        __src = (char *)__src + 2;
        cstdlib_memmove((char *)a1 + 492, __src, 2uLL);
        __src = (char *)__src + 2;
        cstdlib_memmove((char *)a1 + 494, __src, 2uLL);
        __src = (char *)__src + 2;
        cstdlib_memmove(a1 + 62, __src, 2uLL);
        __src = (char *)__src + 2;
        cstdlib_memmove((char *)a1 + 498, __src, 2uLL);
        __src = (char *)__src + 2;
        if ((ssftriff_reader_CloseChunk(a2) & 0x80000000) == 0
          && (ssftriff_reader_OpenChunk(a2, (__int32 *)__s1, (unsigned int *)&v47, &__src, v12, v13, v14, v15) & 0x80000000) == 0
          && !cstdlib_strcmp(__s1, "EXDT"))
        {
          if ((*((_WORD *)a1 + 249) & 1) != 0)
          {
            __dst = 0;
            v17 = heap_Calloc(*(_QWORD **)(*a1 + 8), *((unsigned int *)a1 + 118), 24);
            a1[60] = v17;
            if (v17)
            {
              v18 = heap_Calloc(*(_QWORD **)(*a1 + 8), ((*((__int16 *)a1 + 246) + *((__int16 *)a1 + 244)) * *((_DWORD *)a1 + 118)), 2);
              v19 = (uint64_t *)a1[60];
              *v19 = v18;
              if (v18)
              {
                v20 = *((unsigned int *)a1 + 118);
                if ((int)v20 > 1)
                {
                  v21 = 2 * *v11;
                  v22 = v18 + v21;
                  v23 = v19 + 3;
                  v24 = v20 - 1;
                  do
                  {
                    *v23 = v22;
                    v23 += 3;
                    v22 += v21;
                    --v24;
                  }
                  while (v24);
                }
                if ((int)v20 < 1)
                  return ((int)ssftriff_reader_CloseChunk(a2) >> 31);
                v25 = v19[3 * (v20 - 1)] + 2 * *v11;
                v26 = 2 * *((__int16 *)a1 + 246);
                v27 = v19 + 1;
                do
                {
                  *v27 = v25;
                  v27 += 3;
                  v25 += v26;
                  --v20;
                }
                while (v20);
                v28 = 0;
                v29 = (char *)__src;
LABEL_24:
                cstdlib_memmove(*(void **)(a1[60] + 24 * v28), v29, 2 * (a1[61] & 0x7FFF));
                v30 = *((_WORD *)a1 + 244);
                v31 = (char *)__src + 2 * (v30 & 0x7FFF);
                __src = v31;
                for (i = v30 & 0x7FFF; ; i = v33)
                {
                  v33 = i - 1;
                  if (i == 1)
                  {
                    v35 = 0;
                    v34 = *(_QWORD *)(a1[60] + 24 * v28);
                  }
                  else
                  {
                    if (!i)
                    {
                      cstdlib_memmove(*(void **)(a1[60] + 24 * v28 + 8), v31, 2 * (*((_WORD *)a1 + 246) & 0x7FFF));
                      v36 = *((_WORD *)a1 + 246);
                      v37 = (char *)__src + 2 * (v36 & 0x7FFF);
                      __src = v37;
                      for (j = v36 & 0x7FFF; ; j = v39)
                      {
                        v39 = j - 1;
                        if (j == 1)
                        {
                          v41 = 0;
                          v40 = *(_QWORD *)(a1[60] + 24 * v28 + 8);
                        }
                        else
                        {
                          if (!j)
                          {
                            cstdlib_memmove(&__dst, v37, 4uLL);
                            __src = (char *)__src + 4;
                            v42 = __src;
                            v43 = a1[60] + 24 * v28;
                            *(_DWORD *)(v43 + 16) = __dst;
                            cstdlib_memmove((void *)(v43 + 20), v42, 2uLL);
                            __src = (char *)__src + 2;
                            cstdlib_memmove((void *)(a1[60] + 24 * v28 + 22), __src, 2uLL);
                            v29 = (char *)__src + 2;
                            __src = (char *)__src + 2;
                            if (++v28 >= *((int *)a1 + 118))
                              return ((int)ssftriff_reader_CloseChunk(a2) >> 31);
                            goto LABEL_24;
                          }
                          v40 = *(_QWORD *)(a1[60] + 24 * v28 + 8);
                          v41 = *(_WORD *)(v40 + 2 * (j - 2));
                        }
                        *(_WORD *)(v40 + 2 * v39) ^= v41;
                      }
                    }
                    v34 = *(_QWORD *)(a1[60] + 24 * v28);
                    v35 = *(_WORD *)(v34 + 2 * (i - 2));
                  }
                  *(_WORD *)(v34 + 2 * v33) ^= v35;
                }
              }
            }
          }
          else
          {
            v16 = *(_QWORD *)a1[60];
            if (v16)
            {
              heap_Free(0, v16);
              heap_Free(0, a1[60]);
            }
          }
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t BET3FXD__MFVSyn__releaseExcTable(_QWORD *a1)
{
  uint64_t *v2;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (uint64_t *)a1[60];
  if (!v2)
    return 0xFFFFFFFFLL;
  if (*v2)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), *v2);
    v2 = (uint64_t *)a1[60];
  }
  heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)v2);
  return 0;
}

uint64_t RccSyn__init_Synthesis(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v5 = 2164269062;
  v12 = xmmword_24D294630;
  v13 = xmmword_24D294620;
  *(_QWORD *)a2 = a1;
  if (!PRMBLK_CreateFromMRCC_Param(a1, 2, (_QWORD *)(a2 + 32), (uint64_t)&v13, (uint64_t)&v12, 0, a3, 1))
  {
    v6 = *(uint64_t **)(a2 + 32);
    v7 = *(uint64_t **)(a2 + 40);
    *v7 = a1;
    *v6 = a1;
    v8 = v7[1];
    if (!Mrcc2Rr_InitByProps(0, v6) && !Rr2Pcm_InitByProps(0, v7))
    {
      MrccInput_Init(a1, a2 + 48);
      v9 = *(_DWORD *)(v8 + 24);
      if (v9 <= *(_DWORD *)(v8 + 28))
        v9 = *(_DWORD *)(v8 + 28);
      *(_DWORD *)(a2 + 260) = v9;
      RrInput_Init(a1, a2 + 160);
      *(_DWORD *)(a2 + 256) = *(_DWORD *)(v8 + 24);
      v10 = heap_Alloc(*(_QWORD *)(a1 + 8), 2 * *(unsigned int *)(a2 + 260));
      *(_QWORD *)(a2 + 264) = v10;
      if (v10)
        return 0;
      else
        return 2164269062;
    }
  }
  return v5;
}

uint64_t *Mrcc2Rr_alloc_callback(uint64_t a1, uint64_t a2)
{
  return Mrcc2Rr_AllocateAndInit(a1, a2, 1);
}

uint64_t *Rr2Pcm_alloc_callback(uint64_t a1, int *a2)
{
  return Rr2Pcm_AllocateAndInit(a1, a2, 1);
}

uint64_t Mrcc2Rr_set_callback(int a1, uint64_t a2, char *__s1, unsigned __int8 *a4, char *a5)
{
  return Mrcc2Rr_SetProperty(*(_DWORD **)(a2 + 8), __s1, a4, a5);
}

BOOL Rr2Pcm_set_callback(int a1, uint64_t a2, char *a3, unsigned __int8 *a4)
{
  return Rr2Pcm_SetProperty(a1, *(_QWORD *)(a2 + 8), a3, a4);
}

uint64_t RccSyn__GetEnergy(uint64_t a1)
{
  return Mrcc2Rr_GetEnergy(*(_QWORD *)(a1 + 16), a1 + 48);
}

uint64_t RccSyn__SynthesisOneFrame(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v7 = *(_QWORD **)(a1 + 32);
  v6 = *(_QWORD **)(a1 + 40);
  *(_QWORD *)(a1 + 16) = v7;
  *(_QWORD *)(a1 + 24) = v6;
  v8 = v6[1];
  v9 = a1 + 160;
  RrInput_Reset(a1 + 160);
  if (Mrcc2Rr_ProcessFrame(v7, a1 + 48, v9))
    return 7;
  *(_DWORD *)(a1 + 256) = *(_DWORD *)(v8 + 24);
  if (Rr2Pcm_ProcessFrame(v6, v9, a1 + 248))
    return 10;
  result = 2164269062;
  if (a2)
  {
    if (a3)
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 256);
      *a3 = *(_QWORD *)(a1 + 264);
    }
  }
  return result;
}

_QWORD *RccSyn__deinit_Synthesis(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *result;
  uint64_t v5;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2)
  {
    Mrcc2Rr_Deallocate(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(_QWORD **)(a1 + 40);
  if (v3)
  {
    Rr2Pcm_Deallocate(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
  RrInput_DeallocateData((int *)(a1 + 160));
  MrccInput_DeallocateData((_QWORD *)(a1 + 48));
  result = MrccInput_DeallocateData((_QWORD *)(a1 + 104));
  v5 = *(_QWORD *)(a1 + 264);
  if (v5)
  {
    result = heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v5);
    *(_QWORD *)(a1 + 264) = 0;
  }
  return result;
}

uint64_t RccSyn__reset_Synthesis(uint64_t a1)
{
  uint64_t v1;
  double v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = Rr2Pcm_Reset(*(_QWORD *)(a1 + 40));
  return Mrcc2Rr_Reset(v1, v2);
}

uint64_t PRMBLK_ReadParameters(uint64_t a1, _QWORD *a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v9;
  int v10;
  uint64_t result;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  void *v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  char v84[3];
  uint64_t v85;
  uint64_t v86;

  if (a3 != 2)
    return 3;
  v85 = v4;
  v86 = v5;
  v9 = *(_DWORD **)(*a2 + 8);
  v10 = a4[4];
  if ((v10 & 0x80000000) == 0)
  {
    result = 1;
    if (v10 <= 11024)
    {
      if (!v10)
      {
        v9[2] = 0;
        v9[4] = 0;
        goto LABEL_22;
      }
      if (v10 == 8000)
      {
LABEL_13:
        v10 = v9[4];
        if (v10 <= 0)
        {
          v10 = 256;
LABEL_20:
          v9[4] = v10;
        }
LABEL_22:
        v9[5] = (v10 >> 1) + 1;
        goto LABEL_23;
      }
      if (v10 != 11000)
        return result;
    }
    else
    {
      if (v10 > 21999)
      {
        if (v10 != 22050 && v10 != 22000)
          return result;
        v9[2] = 22000;
LABEL_18:
        v10 = v9[4];
        if (v10 <= 0)
        {
          v10 = 512;
          goto LABEL_20;
        }
        goto LABEL_22;
      }
      if (v10 != 11025)
      {
        if (v10 != 16000)
          return result;
        goto LABEL_18;
      }
    }
    v9[2] = 11000;
    goto LABEL_13;
  }
LABEL_23:
  v12 = a4[73];
  if ((v12 & 0x80000000) == 0 && Mrcc2Rr_SetSampleRateDependentParams(v9, v9[2], v12))
    return 1;
  v13 = a4[6];
  if ((v13 & 0x80000000) == 0)
    v9[3] = v13;
  v14 = a4[43];
  if ((v14 & 0x80000000) == 0)
    v9[14] = v14;
  v15 = a4[44];
  if ((v15 & 0x80000000) == 0)
    v9[6] = v15;
  v16 = a4[45];
  if ((v16 & 0x80000000) == 0)
    v9[7] = v16;
  v17 = a4[5];
  if ((v17 & 0x80000000) == 0)
    v9[8] = v17;
  v18 = a4[46];
  if ((v18 & 0x80000000) == 0)
    v9[15] = v18;
  v19 = a4[8];
  if ((v19 & 0x80000000) == 0)
    v9[9] = v19;
  v20 = a4[9];
  if ((v20 & 0x80000000) == 0)
    v9[10] = v20;
  v21 = a4[47];
  if ((v21 & 0x80000000) == 0)
    v9[11] = v21;
  v22 = a4[26];
  if ((v22 & 0x80000000) == 0)
    v9[12] = v22;
  v23 = a4[7];
  if ((v23 & 0x80000000) == 0)
    v9[13] = v23;
  v24 = *(_QWORD *)(a2[1] + 8);
  v25 = a4[4];
  if (v25 < 0)
    goto LABEL_84;
  result = 1;
  if (v25 > 15999)
  {
    v26 = 16000;
    if (v25 == 16000)
    {
      *(_DWORD *)(v24 + 8) = 16000;
      v27 = *(_DWORD *)(v24 + 12);
      v28 = 512;
      if (v27 > 0)
      {
        v29 = 0;
        v30 = 160;
        v31 = 80;
        goto LABEL_70;
      }
      v29 = 0;
      *(_DWORD *)(v24 + 12) = 512;
      v30 = 160;
      v31 = 80;
    }
    else
    {
      if (v25 != 22050 && v25 != 22000)
        return result;
      v26 = 22000;
      *(_DWORD *)(v24 + 8) = 22000;
      v27 = *(_DWORD *)(v24 + 12);
      v28 = 512;
      if (v27 > 0)
      {
        v29 = 1;
        v30 = 220;
        v31 = 110;
        goto LABEL_70;
      }
      *(_DWORD *)(v24 + 12) = 512;
      v29 = 1;
      v30 = 220;
      v31 = 110;
    }
    v27 = 512;
    goto LABEL_70;
  }
  v26 = 8000;
  if (v25 == 8000)
  {
    *(_DWORD *)(v24 + 8) = 8000;
    v27 = *(_DWORD *)(v24 + 12);
    v28 = 256;
    if (v27 > 0)
    {
      v29 = 0;
      v30 = 80;
      v31 = 40;
      goto LABEL_70;
    }
    v29 = 0;
    *(_DWORD *)(v24 + 12) = 256;
    v30 = 80;
    v31 = 40;
LABEL_67:
    v27 = 256;
    goto LABEL_70;
  }
  v26 = 11000;
  if (v25 != 11000 && v25 != 11025)
    return result;
  *(_DWORD *)(v24 + 8) = 11000;
  v27 = *(_DWORD *)(v24 + 12);
  v28 = 256;
  if (v27 <= 0)
  {
    v29 = 0;
    *(_DWORD *)(v24 + 12) = 256;
    v30 = 110;
    v31 = 55;
    goto LABEL_67;
  }
  v29 = 0;
  v30 = 110;
  v31 = 55;
LABEL_70:
  *(_DWORD *)(v24 + 44) = v30;
  v32 = v27 >> 1;
  v33 = *(_DWORD *)(v24 + 32);
  if (*(_DWORD *)(v24 + 28) < (signed int)(v27 >> 1))
    v32 = *(_DWORD *)(v24 + 28);
  *(_DWORD *)(v24 + 24) = v31;
  *(_DWORD *)(v24 + 28) = v32;
  if (v31 >= v33)
    v34 = v33;
  else
    v34 = v31;
  *(_DWORD *)(v24 + 32) = v34;
  if (*(_DWORD *)(v24 + 16) < v27)
    v27 = *(_DWORD *)(v24 + 16);
  *(_DWORD *)(v24 + 16) = v27;
  *(_DWORD *)(v24 + 20) = v28;
  if (v29)
    v35 = 4;
  else
    v35 = 0;
  if (v29)
    v36 = 968;
  else
    v36 = 1024;
  *(_DWORD *)(v24 + 168) = v35;
  *(_DWORD *)(v24 + 172) = v36;
  Rr2Pcm_ProcessMvf_SetHbThr(v24 + 200, *(_DWORD *)(v24 + 136), v26);
LABEL_84:
  v37 = *(_DWORD *)(v24 + 12);
  *(int8x8_t *)(v24 + 168) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*(_DWORD *)(v24 + 8) == 22000), 0x1FuLL)), (int8x8_t)0x3C800000004, (int8x8_t)0x40000000000);
  *(_DWORD *)(v24 + 44) = 2 * *(_DWORD *)(v24 + 24);
  if (v37 >= 0)
    v38 = v37;
  else
    v38 = v37 + 1;
  *(_DWORD *)(v24 + 288) = v38 >> 1;
  *(_DWORD *)(v24 + 284) = PositiveShortLog2((__int16)v37);
  v39 = *(_DWORD *)(v24 + 12);
  *(_DWORD *)(v24 + 292) = v39;
  *(_DWORD *)(v24 + 296) = 440 * v39 / *(_DWORD *)(v24 + 44) / 256;
  Rr2Pcm_SetDerivedParams((int *)v24);
  v40 = *(int *)(v24 + 8);
  v41 = *(int *)(v24 + 12);
  *(_DWORD *)(v24 + 300) = 32 * v40 / v41;
  *(_DWORD *)(v24 + 304) = (v41 << 20) / (32 * v40);
  *(_DWORD *)(v24 + 308) = ((int)v40 + 860160 * *(_DWORD *)(v24 + 24)) / (2 * (int)v40);
  Rr2Pcm_ProcessMvf_SetHbThr(v24 + 200, *(_DWORD *)(v24 + 136), v40);
  v42 = a4[10];
  if ((v42 & 0x80000000) == 0)
  {
    *(_DWORD *)(v24 + 24) = v42;
    Rr2Pcm_SetDerivedParams((int *)v24);
  }
  v43 = a4[72];
  if ((v43 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 20) = v43;
  v44 = a4[11];
  if ((v44 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 184) = v44;
  v45 = a4[25];
  if ((v45 & 0x80000000) == 0)
  {
    *(_DWORD *)(v24 + 196) = v45;
    if (v45)
    {
      if (!*(_DWORD *)(v24 + 248))
      {
        __sprintf_chk(v84, 0, 3uLL, "%d", 3);
        if (Rr2Pcm_ProcessMvf_SetProperty(a1, v24 + 200, "SYN_DEBUZZ_PROCESS_MVF_SMOOTH_WIN", (unsigned __int8 *)v84))return 2;
      }
    }
  }
  v46 = a4[74];
  if ((v46 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 64) = v46;
  v47 = a4[13];
  if ((v47 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 76) = v47;
  v48 = a4[18];
  if ((v48 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 80) = v48;
  v49 = a4[17];
  if ((v49 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 84) = v49;
  v50 = a4[14];
  if ((v50 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 96) = v50;
  v51 = a4[19];
  if ((v51 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 100) = v51;
  v52 = a4[22];
  if ((v52 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 104) = 32 * v52;
  v53 = a4[23];
  if ((v53 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 108) = 32 * v53;
  v54 = a4[20];
  if ((v54 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 112) = 32 * v54;
  v55 = a4[21];
  if ((v55 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 116) = 32 * v55;
  v56 = a4[48];
  if ((v56 & 0x80000000) == 0)
  {
    *(_DWORD *)(v24 + 120) = v56;
    *(_DWORD *)(v24 + 124) = v56;
  }
  v57 = a4[49];
  if ((v57 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 120) = v57;
  v58 = a4[50];
  if ((v58 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 124) = v58;
  v59 = a4[15];
  if ((v59 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 128) = v59;
  v60 = a4[16];
  if ((v60 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 132) = v60;
  v61 = a4[12];
  if ((v61 & 0x80000000) == 0)
  {
    *(_DWORD *)(v24 + 136) = v61;
    Rr2Pcm_ProcessMvf_SetHbThr(v24 + 200, v61, *(_DWORD *)(v24 + 8));
  }
  v62 = a4[51];
  if ((v62 & 0x80000000) == 0)
  {
    *(_DWORD *)(v24 + 156) = v62;
    if (v62)
      *(_WORD *)(v24 + 164) = 31785;
  }
  v63 = a4[52];
  if ((v63 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 268) = v63;
  v64 = a4[53];
  if ((v64 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 272) = v64;
  v65 = a4[46];
  if ((v65 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 280) = v65;
  v66 = a4[54];
  if ((v66 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 160) = v66;
  v67 = a4[55];
  if ((v67 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 144) = *(int *)(v24 + 12) * (uint64_t)v67 / (32 * *(int *)(v24 + 8));
  v68 = a4[56];
  if ((v68 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 148) = *(int *)(v24 + 12) * (uint64_t)v68 / (32 * *(int *)(v24 + 8));
  v69 = a4[57];
  if ((v69 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 140) = *(int *)(v24 + 12) * (uint64_t)v69 / (32 * *(int *)(v24 + 8));
  v70 = a4[24];
  if ((v70 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 60) = v70;
  v71 = a4[27];
  if ((v71 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 276) = v71;
  if ((a4[33] & 0x80000000) == 0)
  {
    v72 = *(_QWORD *)(v24 + 232);
    if (v72)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v72);
      *(_QWORD *)(v24 + 232) = 0;
    }
    v73 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 12);
    *(_QWORD *)(v24 + 232) = v73;
    if (!v73)
      return 2;
    cstdlib_memset(v73, 0, 0xCuLL);
    *(_DWORD *)(v24 + 248) = 3;
  }
  v74 = a4[34];
  if ((v74 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 220) = v74;
  v75 = a4[35];
  if ((v75 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 216) = v75;
  v76 = a4[36];
  if ((v76 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 208) = v76;
  v77 = a4[37];
  if ((v77 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 252) = v77;
  v78 = a4[38];
  if ((v78 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 256) = v78;
  v79 = a4[67];
  if ((v79 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 28) = v79;
  v80 = a4[68];
  if ((v80 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 32) = v80;
  v81 = a4[69];
  if ((v81 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 16) = v81;
  v82 = a4[70];
  if ((v82 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 36) = v82;
  v83 = a4[71];
  result = 0;
  if ((v83 & 0x80000000) == 0)
    *(_DWORD *)(v24 + 40) = v83;
  return result;
}

uint64_t PRMBLK_CreateFromMRCC_Param(uint64_t a1, int a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t (**a6)(_QWORD, _DWORD *), _DWORD *a7, int a8)
{
  _QWORD *v9;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  int v20;
  BOOL v21;

  v9 = a3;
  if (a2 <= 0)
    return PRMBLK_ReadParameters(a1, a3, a2, a7);
  v15 = 0;
  v16 = 8 * a2;
  v17 = a2;
  do
  {
    v18 = (*(uint64_t (**)(uint64_t, _DWORD *))(a4 + v15))(a1, a7);
    v9[v15 / 8] = v18;
    if (!v18)
      return 4;
    v15 += 8;
  }
  while (v16 != v15);
  result = PRMBLK_ReadParameters(a1, v9, a2, a7);
  if (a6)
  {
    do
    {
      v20 = (*a6)(*v9, a7);
      if (v20)
        v21 = a8 == 0;
      else
        v21 = 0;
      if (v21)
        return 3;
      ++v9;
      ++a6;
      --v17;
    }
    while (v17);
    if (v20)
      return 3;
    else
      return 0;
  }
  return result;
}

uint64_t Mrcc2Rr_SetProperty(_DWORD *a1, char *__s1, unsigned __int8 *a3, char *a4)
{
  int v8;

  if (!cstdlib_strcmp(__s1, "PROD_CODE"))
  {
    v8 = cstdlib_atoi(a3);
    if (Mrcc2Rr_SetSampleRateDependentParams(a1, v8, a1[4]))
      return 1;
  }
  cstdlib_strcpy(a4, "");
  return 0;
}

uint64_t Mrcc2Rr_SetSampleRateDependentParams(_DWORD *a1, int a2, unsigned int a3)
{
  uint64_t v3;
  BOOL v4;
  BOOL v5;
  int v6;
  unsigned int v7;

  v3 = 1;
  if (a2 <= 11024)
  {
    if (!a2)
    {
      v7 = 0;
      a1[2] = 0;
LABEL_20:
      v3 = 0;
      a1[4] = v7;
      a1[5] = (v7 >> 1) + 1;
      return v3;
    }
    if (a2 == 8000)
    {
      a1[2] = 8000;
      goto LABEL_16;
    }
    if (a2 != 11000)
      return v3;
LABEL_9:
    a1[2] = 11000;
LABEL_16:
    v5 = __OFSUB__(a3, 1);
    v4 = (int)(a3 - 1) < 0;
    v6 = 256;
LABEL_17:
    if (v4 != v5)
      v7 = v6;
    else
      v7 = a3;
    goto LABEL_20;
  }
  if (a2 <= 21999)
  {
    if (a2 != 11025)
    {
      if (a2 == 16000)
      {
        a1[2] = 16000;
LABEL_13:
        v5 = __OFSUB__(a3, 1);
        v4 = (int)(a3 - 1) < 0;
        v6 = 512;
        goto LABEL_17;
      }
      return v3;
    }
    goto LABEL_9;
  }
  if (a2 == 22050 || a2 == 22000)
  {
    a1[2] = 22000;
    goto LABEL_13;
  }
  return v3;
}

uint64_t *Mrcc2Rr_AllocateAndInit(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v6;
  int v7;

  v6 = (uint64_t *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 32);
  if (v6)
  {
    Mrcc2Rr_Init(a1, a2, v6, a3);
    if (v7)
    {
      heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v6);
      return 0;
    }
  }
  return v6;
}

void Mrcc2Rr_Init(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;

  *a3 = a1;
  v8 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 64);
  a3[1] = (uint64_t)v8;
  if (v8)
  {
    cstdlib_memset(v8, 0, 0x40uLL);
    v9 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 64);
    a3[2] = (uint64_t)v9;
    if (v9)
    {
      cstdlib_memset(v9, 0, 0x40uLL);
      v10 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 176);
      a3[3] = (uint64_t)v10;
      if (v10)
      {
        v11 = cstdlib_memset(v10, 0, 0xB0uLL);
        Mrcc2Rr_InitProps((uint64_t)v11, a2, a3[1]);
        if (!(v12 | a4))
          Mrcc2Rr_InitByProps((int *)a3[1], a3);
      }
    }
  }
}

double Mrcc2Rr_InitProps(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  if (a2)
    LODWORD(a2) = *(_DWORD *)(a2 + 16);
  if (!Mrcc2Rr_SetSampleRateDependentParams((_DWORD *)a3, a2, 0))
  {
    *(_DWORD *)(a3 + 12) = -1;
    *(_OWORD *)(a3 + 24) = xmmword_214F98240;
    *(_OWORD *)(a3 + 40) = xmmword_214F98250;
    *(_QWORD *)&result = 0x100000018;
    *(_QWORD *)(a3 + 56) = 0x100000018;
  }
  return result;
}

uint64_t Mrcc2Rr_InitByProps(int *a1, uint64_t *a2)
{
  int *v3;
  uint64_t v4;
  int *v5;
  uint64_t result;

  if (a1)
  {
    v3 = a1;
    a2[1] = (uint64_t)a1;
  }
  else
  {
    v3 = (int *)a2[1];
  }
  v4 = a2[2];
  v5 = (int *)a2[3];
  if (!v3[7] && !v3[6])
    return 1;
  if (!Init_SinTable(*a2, a2[2], 0))
    Init_MelTable(*a2, v4 + 32, 0, v3[2]);
  if (!v3[7])
    return 0;
  result = Mrcc_InitByProps(*a2, v5, v4, (uint64_t)v3, 0);
  if (!(_DWORD)result)
    return 0;
  return result;
}

double MrccInput_Init(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  result = 0.0;
  *(_DWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = xmmword_214F962F0;
  *(_OWORD *)(a2 + 32) = xmmword_214F98260;
  return result;
}

uint64_t MrccInput_AllocateData(uint64_t a1, unsigned int a2)
{
  int v2;
  BOOL v3;
  uint64_t v6;
  void *v7;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2)
    v3 = v2 < (int)a2;
  else
    v3 = 1;
  if (!v3)
    return 0;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v6);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v7 = (void *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * a2);
  *(_QWORD *)(a1 + 8) = v7;
  if (!v7)
    return 2;
  cstdlib_memset(v7, 0, 4 * a2);
  result = 0;
  *(_DWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

_QWORD *MrccInput_DeallocateData(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (*((_DWORD *)result + 12))
  {
    v1 = result;
    v2 = result[1];
    if (v2)
    {
      result = heap_Free(*(_QWORD **)(*result + 8), v2);
      v1[1] = 0;
    }
  }
  return result;
}

uint64_t Mrcc2Rr_GetEnergy(uint64_t a1, uint64_t a2)
{
  int v2;

  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56);
  if (v2 < 12)
    return ipow2(**(_DWORD **)(a2 + 8) << (11 - v2));
  else
    return ipow2((**(int **)(a2 + 8) >> (v2 - 11))+ (((unint64_t)**(int **)(a2 + 8) >> (v2 - 12)) & 1));
}

uint64_t Mrcc2Rr_ProcessFrame(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v6;
  int *v7;
  int v8;
  int v9;
  int v10;
  uint64_t result;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _DWORD *v21;
  int v22;
  int v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  int v27;
  void *v28;
  int v29;

  v6 = (_DWORD *)a1[1];
  v7 = (int *)a1[3];
  v8 = v6[7];
  v9 = v6[3];
  if (v9 < 1)
  {
    if (v8)
      goto LABEL_12;
    return 1;
  }
  v10 = *(_DWORD *)(a2 + 16);
  if (v10 != v9 && v10 > 0 || v8 == 0)
    return 1;
LABEL_12:
  v14 = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a3 + 76) = v14;
  *(_DWORD *)(a3 + 64) = -1;
  v15 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a3 + 44) = v15;
  *(_DWORD *)(a3 + 48) = v15;
  v16 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a3 + 56) = v16;
  *(_DWORD *)(a3 + 80) = *(_DWORD *)(a2 + 32);
  if (v15)
  {
    v17 = v6[6];
    *(_DWORD *)(a3 + 8) = 1;
    *(_DWORD *)(a3 + 12) = v17;
    if ((_DWORD)v16)
    {
      v18 = v6[2];
      v19 = v18 + (((v15 + 2097152000) / (2 * v15)) << 6);
LABEL_18:
      v20 = v19 / (2 * v18);
      goto LABEL_19;
    }
LABEL_17:
    v18 = v6[2];
    v19 = v18 + (v15 << 9);
    goto LABEL_18;
  }
  v17 = v6[6] & *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a3 + 8) = 1;
  *(_DWORD *)(a3 + 12) = v17;
  if (!(_DWORD)v16)
    goto LABEL_17;
  v20 = 0;
LABEL_19:
  v21 = *(_DWORD **)(a2 + 8);
  v22 = *(_DWORD *)(a2 + 16);
  v23 = *(_DWORD *)(a2 + 36);
  v7[7] = v14;
  v7[8] = v23;
  result = Mrcc_PutHarmFrqs((uint64_t)v7, v20, 0x4000, v6[13]);
  if (!(_DWORD)result)
  {
    result = Mrcc_PutCoefs(v7, v21, v22, 0);
    if (!(_DWORD)result)
    {
      v24 = *(_QWORD *)(a3 + 24);
      if (v24)
      {
        if (*(_DWORD *)(a3 + 72) >= v7[26])
          goto LABEL_27;
        heap_Free(*(_QWORD **)(*a1 + 8), v24);
        *(_QWORD *)(a3 + 24) = 0;
      }
      v25 = (void *)heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * v7[23]);
      *(_QWORD *)(a3 + 24) = v25;
      if (!v25)
        return 2;
      cstdlib_memset(v25, 0, 4 * v7[23]);
      *(_DWORD *)(a3 + 72) = v7[23];
LABEL_27:
      if (!v17)
      {
        *(_DWORD *)(a3 + 40) = v7[26];
        Mrcc_Enhance((uint64_t)v7);
        goto LABEL_37;
      }
      v26 = *(_QWORD *)(a3 + 32);
      if (v26)
      {
        v27 = v7[26];
        if (*(_DWORD *)(a3 + 68) >= v27)
          goto LABEL_33;
        heap_Free(*(_QWORD **)(*a1 + 8), v26);
        *(_QWORD *)(a3 + 32) = 0;
      }
      v28 = (void *)heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * v7[23]);
      *(_QWORD *)(a3 + 32) = v28;
      if (v28)
      {
        cstdlib_memset(v28, 0, 4 * v7[23]);
        *(_DWORD *)(a3 + 68) = v7[23];
        v27 = v7[26];
LABEL_33:
        *(_DWORD *)(a3 + 40) = v27;
        Mrcc_Enhance((uint64_t)v7);
        if (!*(_DWORD *)(a2 + 44))
        {
          v29 = 2;
          return Mrcc_Solve_AmpPhase((uint64_t)v7, (_QWORD **)a3, v29, 1);
        }
LABEL_37:
        v29 = 0;
        return Mrcc_Solve_AmpPhase((uint64_t)v7, (_QWORD **)a3, v29, 1);
      }
      return 2;
    }
  }
  return result;
}

_QWORD *Mrcc2Rr_Deallocate(_QWORD *a1)
{
  _QWORD *result;

  result = Mrcc2Rr_Clear(a1);
  if (a1)
    return heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)a1);
  return result;
}

_QWORD *Mrcc2Rr_Clear(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a1[1] + 28))
    Mrcc_Clear((_QWORD *)*a1, (_QWORD *)a1[3]);
  v2 = a1[2];
  Deinit_SinTable(*a1, v2);
  result = (_QWORD *)Deinit_MelTable(*a1, v2 + 32);
  v4 = a1[1];
  if (v4)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v4);
    a1[1] = 0;
  }
  v5 = a1[2];
  if (v5)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v5);
    a1[2] = 0;
  }
  v6 = a1[3];
  if (v6)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v6);
    a1[3] = 0;
  }
  return result;
}

uint64_t Init_MelTable(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v4;
  unsigned int v5;
  void *v6;
  uint64_t result;

  *(_DWORD *)(a2 + 24) = 0;
  if (a3)
    v4 = a3 + 1;
  else
    v4 = 1025;
  *(_DWORD *)(a2 + 16) = v4;
  v5 = a3 & 0xFFFFFBFF;
  if ((a3 & 0xFFFFFBFF) == 0 && a4 == 22000)
  {
    v6 = &alMelFrq_Q15_22000_1024;
LABEL_16:
    result = 0;
    *(_QWORD *)a2 = v6;
    *(_QWORD *)(a2 + 8) = &alNrmFrq_Q15_1024;
    *(_DWORD *)(a2 + 20) = 16;
    return result;
  }
  if (!v5 && a4 == 11000)
  {
    v6 = &alMelFrq_Q15_11000_1024;
    goto LABEL_16;
  }
  if (!v5 && a4 == 16000)
  {
    v6 = &alMelFrq_Q15_16000_1024;
    goto LABEL_16;
  }
  result = 7;
  if (!v5 && a4 == 8000)
  {
    v6 = &alMelFrq_Q15_8000_1024;
    goto LABEL_16;
  }
  return result;
}

uint64_t Get_MelValue(uint64_t a1, int a2)
{
  int v3;
  int v4;
  unsigned int *v5;
  uint64_t v6;

  v3 = *(_DWORD *)(a1 + 16);
  v4 = a2 / *(_DWORD *)(a1 + 20) + 1;
  v5 = *(unsigned int **)a1;
  v6 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 24) = v4;
  return GetInterpolatedValue(v6, v5, v3, a2, (_DWORD *)(a1 + 24), 0);
}

uint64_t Get_MelValues(uint64_t result, int *a2, _DWORD *a3, int a4)
{
  _DWORD *v4;
  uint64_t v7;
  uint64_t v8;
  int v9;

  *(_DWORD *)(result + 24) = 0;
  v4 = (_DWORD *)(result + 24);
  if (a4 >= 1)
  {
    v7 = result;
    v8 = a4;
    do
    {
      v9 = *a2++;
      result = GetInterpolatedValue(*(_QWORD *)(v7 + 8), *(unsigned int **)v7, *(_DWORD *)(v7 + 16), v9, v4, 0);
      *a3++ = result;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t Mrcc_SetProperty(int *a1, char *__s1, char *a3)
{
  uint64_t result;
  int v7;
  int v8;
  int v9;

  if (cstdlib_strcmp(__s1, "SIZE"))
  {
    if (!cstdlib_strcmp(__s1, "ENERGY_MODE"))
    {
      if (cstdlib_strcmp(a3, "EN_RR_ENV"))
      {
        if (cstdlib_strcmp(a3, "EN_RR"))
        {
          if (cstdlib_strcmp(a3, "EN_C0"))
            return 1;
          v7 = 2;
        }
        else
        {
          v7 = 1;
        }
      }
      else
      {
        v7 = 3;
      }
      a1[6] = v7;
    }
  }
  else
  {
    *a1 = cstdlib_atoi((unsigned __int8 *)a3);
  }
  v8 = a1[6];
  if (v8)
  {
    if (v8 == 3)
      v9 = *a1 - 2;
    else
      v9 = *a1 - 1;
  }
  else
  {
    v9 = *a1;
  }
  result = 0;
  a1[1] = v9;
  return result;
}

uint64_t Mrcc_InitByProps(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  double v14;
  double v15;
  double v16;
  signed int v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  int *v25;
  int v26;
  _DWORD *v27;
  uint64_t v28;

  a2[40] = *(_DWORD *)(a4 + 60);
  if (a5)
    return 1;
  v7 = *(_DWORD *)(a4 + 32);
  v8 = *(_DWORD *)(a4 + 52);
  a2[42] = *(_DWORD *)(a4 + 56);
  v9 = *(_OWORD *)(a4 + 36);
  v10 = *(unsigned int *)(a4 + 20);
  v12 = *(_DWORD *)(a4 + 8);
  v11 = *(_DWORD *)(a4 + 12);
  *((_QWORD *)a2 + 16) = a3;
  *((_QWORD *)a2 + 17) = a3 + 32;
  *a2 = v11;
  if (v11 < 1)
    return 8;
  *(_QWORD *)&v14 = v11 | 0xFFFFFFFF00000000;
  HIDWORD(v15) = 1;
  LODWORD(v15) = v11 - 2;
  HIDWORD(v16) = 0;
  if (v7 != 3)
  {
    LODWORD(v16) = v11 - 1;
    v15 = v16;
  }
  if (v7)
    v14 = v15;
  *(double *)(a2 + 1) = v14;
  a2[6] = v7;
  *(_OWORD *)(a2 + 9) = v9;
  a2[13] = 5;
  v17 = 2 * v10 - 2;
  a2[23] = v10;
  a2[24] = v17;
  a2[25] = PositiveShortLog2((__int16)(2 * v10 - 2));
  v18 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * *a2);
  *((_QWORD *)a2 + 2) = v18;
  if (!v18)
    return 2;
  cstdlib_memset(v18, 0, 4 * *a2);
  v19 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * v10);
  *((_QWORD *)a2 + 7) = v19;
  if (!v19)
    return 2;
  cstdlib_memset(v19, 0, 4 * v10);
  v20 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * v10);
  *((_QWORD *)a2 + 8) = v20;
  if (!v20)
    return 2;
  cstdlib_memset(v20, 0, 4 * v10);
  v21 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * v10);
  *((_QWORD *)a2 + 9) = v21;
  if (!v21)
    return 2;
  cstdlib_memset(v21, 0, 4 * v10);
  v22 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * v10);
  *((_QWORD *)a2 + 10) = v22;
  if (!v22)
    return 2;
  cstdlib_memset(v22, 0, 4 * v10);
  v23 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * (a2[24] + 2));
  *((_QWORD *)a2 + 18) = v23;
  if (!v23)
    return 2;
  cstdlib_memset(v23, 0, 4 * (a2[24] + 2));
  v24 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * (a2[24] + 2));
  *((_QWORD *)a2 + 19) = v24;
  if (!v24)
    return 2;
  cstdlib_memset(v24, 0, 4 * (a2[24] + 2));
  a2[28] = v12;
  a2[29] = 0x4000;
  a2[30] = v8;
  a2[31] = 0x8000;
  v25 = (int *)*((_QWORD *)a2 + 10);
  if ((int)v10 >= 1)
  {
    v26 = 0;
    v27 = (_DWORD *)*((_QWORD *)a2 + 10);
    v28 = v10;
    do
    {
      *v27++ = v26;
      v26 += ((int)v10 + 0x7FFF) / v17;
      --v28;
    }
    while (v28);
  }
  warpFreqs((uint64_t)a2, v25, *((_DWORD **)a2 + 9), v10, a2 + 22);
  return 0;
}

uint64_t Mrcc_PutCoefs(int *a1, _DWORD *a2, int a3, int a4)
{
  uint64_t result;
  int v6;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v20;

  result = 6;
  if (a2 && a3 >= 1)
  {
    v6 = *a1;
    if (*a1 < 1 || v6 == a3)
    {
      if (a4)
      {
        if (v6 >= 1)
        {
          v8 = 0;
          v9 = *((_QWORD *)a1 + 2);
          do
          {
            *(_DWORD *)(v9 + 4 * v8) = -a2[v8];
            ++v8;
          }
          while (v8 < *a1);
        }
      }
      else
      {
        cstdlib_memcpy(*((void **)a1 + 2), a2, 4 * v6);
      }
      v20 = 0;
      v10 = a1[42];
      LODWORD(v11) = a1[2];
      v12 = v10 - 13;
      if (v10 >= 13 && (v11 & 0x80000000) == 0)
      {
        v13 = 0;
        v14 = v10 - 12;
        v15 = *((_QWORD *)a1 + 2);
        v16 = 1 << v12;
        do
        {
          v17 = *(int *)(v15 + 4 * v13);
          if ((v16 & v17) != 0)
            v18 = ((int)v17 >> v14) + 1;
          else
            v18 = (int)v17 >> v14;
          *(_DWORD *)(v15 + 4 * v13) = v18;
          v11 = a1[2];
        }
        while (v13++ < v11);
      }
      ScaleTo16BitSignedRange((int *)(*((_QWORD *)a1 + 2) + 4 * (int)v11 + 4), a1[1], (int *)&v20 + 1, (int *)&v20, 0, 0);
      result = 0;
      a1[41] = v20 - HIDWORD(v20);
    }
    else
    {
      return 5;
    }
  }
  return result;
}

uint64_t Mrcc_PutFrqs(uint64_t a1, const void *a2, int a3, int a4, int a5)
{
  uint64_t v6;
  signed int v7;
  void *v8;

  v6 = *(int *)(a1 + 92);
  if ((int)v6 >= a3)
    v7 = a3;
  else
    v7 = v6 - 1;
  *(_DWORD *)(a1 + 104) = v7;
  *(_DWORD *)(a1 + 116) = a4;
  *(_DWORD *)(a1 + 120) = a5;
  v8 = *(void **)(a1 + 56);
  if ((_DWORD)v6 == v7)
  {
    cstdlib_memcpy(v8, *(const void **)(a1 + 80), 4 * v6);
    cstdlib_memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 72), 4 * *(int *)(a1 + 108));
  }
  else
  {
    cstdlib_memcpy(v8, a2, 4 * v7);
    warpFreqs(a1, 0, 0, v7, (_DWORD *)(a1 + 108));
  }
  return 0;
}

uint64_t warpFreqs(uint64_t result, int *a2, _DWORD *a3, unsigned int a4, _DWORD *a5)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v6 = result;
  v7 = *(_DWORD *)(result + 92);
  if ((int)v7 >= (int)a4)
    v8 = a4;
  else
    v8 = v7;
  if (a2)
  {
    if (a3)
      goto LABEL_6;
  }
  else
  {
    a2 = *(int **)(result + 56);
    if (a3)
      goto LABEL_6;
  }
  a3 = *(_DWORD **)(result + 64);
LABEL_6:
  if (*(_DWORD *)(result + 120) == 1)
  {
    v9 = *(_QWORD *)(result + 136);
    v10 = *(_DWORD *)(v6 + 116);
    if (v10 < 0x4000)
    {
      if ((int)v8 < 1)
      {
        LODWORD(v8) = 0;
      }
      else
      {
        v11 = 0;
        while (a2[v11] <= v10)
        {
          if (v8 == ++v11)
            goto LABEL_19;
        }
        LODWORD(v8) = v11;
      }
    }
LABEL_19:
    result = Get_MelValues(v9, a2, a3, v8);
    if (a5)
      goto LABEL_20;
  }
  else
  {
    LODWORD(v8) = 0;
    if (a5)
LABEL_20:
      *a5 = v8;
  }
  return result;
}

uint64_t Mrcc_PutHarmFrqs(uint64_t a1, int a2, int a3, int a4)
{
  int v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;

  if (a2)
  {
    v5 = *(_DWORD *)(a1 + 92) - 1;
    if (v5 >= a3 / a2 + 1)
      v6 = a3 / a2 + 1;
    else
      v6 = *(_DWORD *)(a1 + 92) - 1;
    *(_DWORD *)(a1 + 108) = v6;
    if (v5 >= 0x4000 / a2 + 1)
      v5 = 0x4000 / a2 + 1;
    *(_DWORD *)(a1 + 104) = v5;
    *(_DWORD *)(a1 + 116) = a3;
    *(_DWORD *)(a1 + 120) = a4;
    v7 = *(_DWORD **)(a1 + 56);
    *v7 = 0;
    LODWORD(v8) = *(_DWORD *)(a1 + 104);
    if ((int)v8 >= 2)
    {
      v9 = 1;
      v10 = a2;
      do
      {
        v7[v9++] = v10;
        v8 = *(int *)(a1 + 104);
        v10 += a2;
      }
      while (v9 < v8);
    }
    warpFreqs(a1, 0, 0, v8, (_DWORD *)(a1 + 108));
  }
  else
  {
    if (a3 == 0x4000)
    {
      v11 = *(_DWORD *)(a1 + 92);
      v12 = v11;
    }
    else
    {
      v11 = *(_DWORD *)(a1 + 92);
      v13 = 2 * a3 * (v11 - 1) + 0x7FFF;
      if (((a3 * (v11 - 1)) & 0x40000000) == 0)
        v13 = 2 * a3 * (v11 - 1);
      v12 = (v13 >> 15) + 1;
    }
    *(_DWORD *)(a1 + 104) = v11;
    *(_DWORD *)(a1 + 108) = v12;
    *(_DWORD *)(a1 + 116) = a3;
    *(_DWORD *)(a1 + 120) = a4;
    cstdlib_memcpy(*(void **)(a1 + 56), *(const void **)(a1 + 80), 4 * v11);
    cstdlib_memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 72), 4 * *(int *)(a1 + 88));
  }
  return 0;
}

_QWORD *Mrcc_Clear(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a2)
  {
    v3 = result;
    v4 = a2[2];
    if (v4)
    {
      result = heap_Free((_QWORD *)result[1], v4);
      a2[2] = 0;
    }
    v5 = a2[8];
    if (v5)
    {
      result = heap_Free((_QWORD *)v3[1], v5);
      a2[8] = 0;
    }
    v6 = a2[9];
    if (v6)
    {
      result = heap_Free((_QWORD *)v3[1], v6);
      a2[9] = 0;
    }
    v7 = a2[10];
    if (v7)
    {
      result = heap_Free((_QWORD *)v3[1], v7);
      a2[10] = 0;
    }
    v8 = a2[7];
    if (v8)
    {
      result = heap_Free((_QWORD *)v3[1], v8);
      a2[7] = 0;
    }
    v9 = a2[18];
    if (v9)
    {
      result = heap_Free((_QWORD *)v3[1], v9);
      a2[18] = 0;
    }
    v10 = a2[19];
    if (v10)
    {
      result = heap_Free((_QWORD *)v3[1], v10);
      a2[19] = 0;
    }
  }
  return result;
}

uint64_t Mrcc_Enhance(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  signed int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;

  if (*(_DWORD *)(result + 104) >= *(_DWORD *)(result + 92))
    v1 = 40;
  else
    v1 = 36;
  if (*(_DWORD *)(result + 24))
  {
    v2 = *(int *)(result + 8);
    if (*(_DWORD *)(result + 36) != 0x8000 && *(int *)(result + 4) >= 1)
    {
      v3 = 0;
      v4 = *(_DWORD *)(result + v1);
      if (v4 >= 0)
        v5 = v4;
      else
        v5 = -v4;
      v6 = v5 & 0x7FFF;
      v7 = v5 >> 15;
      v8 = *(_QWORD *)(result + 16) + 4 * v2 + 4;
      v9 = 0x8000;
      do
      {
        if (v9 >= 0)
          v10 = v9;
        else
          v10 = -v9;
        v11 = (v9 >> 31) | 1;
        if (v4 < 0)
          v11 = -v11;
        v9 = ((v10 >> 15) * v6 + (((v10 & 0x7FFF) * v6 + 0x4000) >> 15) + v10 * v7) * v11;
        v12 = *(_DWORD *)(v8 + 4 * v3);
        if (v12 >= 0)
          v13 = *(_DWORD *)(v8 + 4 * v3);
        else
          v13 = -v12;
        v14 = (v12 >> 31) | 1;
        if (v9 >= 0)
          v15 = v9;
        else
          v15 = -v9;
        if (v9 < 0)
          v14 = -v14;
        *(_DWORD *)(v8 + 4 * v3++) = ((v13 >> 15) * (v15 & 0x7FFF)
                                    + (((v13 & 0x7FFF) * (v15 & 0x7FFF) + 0x4000) >> 15)
                                    + v13 * (v15 >> 15))
                                   * v14;
      }
      while (v3 < *(int *)(result + 4));
    }
    if (*(_DWORD *)(result + 44) != 0x8000 && *(int *)(result + 4) >= 1)
    {
      v16 = 0;
      v17 = *(_QWORD *)(result + 16) + 4 * v2 + 4;
      do
      {
        v18 = *(_DWORD *)(v17 + 4 * v16);
        if (v18 >= 0)
          v19 = *(_DWORD *)(v17 + 4 * v16);
        else
          v19 = -v18;
        v20 = (v18 >> 31) | 1;
        v21 = *(_DWORD *)(result + 44);
        v22 = v21 < 0;
        if (v21 < 0)
          v21 = -v21;
        if (v22)
          v20 = -v20;
        *(_DWORD *)(v17 + 4 * v16++) = ((v21 & 0x7FFF) * (v19 >> 15)
                                      + (((v21 & 0x7FFF) * (v19 & 0x7FFF) + 0x4000) >> 15)
                                      + v19 * (v21 >> 15))
                                     * v20;
      }
      while (v16 < *(int *)(result + 4));
    }
    v23 = *(_DWORD *)(result + 48);
    if (v23 != 0x8000)
    {
      v24 = *(_DWORD *)(result + 104);
      v25 = *(_DWORD *)(result + 92);
      v26 = *(_DWORD *)(result + 28);
      if (v26 < 1 || (v27 = *(_DWORD *)(result + 52), v26 > v27) || v24 == v25)
      {
        if (v24 != v25)
          v23 = 0x8000;
      }
      else
      {
        v23 += v26 * (0x8000 - v23) / (v27 + 1);
      }
      *(_DWORD *)(result + 32) = v23;
    }
  }
  return result;
}

uint64_t Mrcc_Solve_AmpPhase(uint64_t a1, _QWORD **a2, int a3, int a4)
{
  signed int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t result;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  int v16;
  unsigned int v17;
  int v18;
  BOOL v19;
  int v20;
  _DWORD *v21;
  __int16 *v22;
  unsigned __int16 *v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  int *v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  BOOL v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  signed int v70;
  char v71;
  unsigned int v72;
  unsigned int v73;
  int v74;

  v7 = *((_DWORD *)a2 + 10);
  if (a3 == 1)
    v8 = 0;
  else
    v8 = *(_DWORD *)(a1 + 24);
  v9 = *(_DWORD *)(a1 + 108);
  if ((int)v9 >= v7)
    v10 = v7;
  else
    v10 = v9;
  result = 1;
  if (a4 && (v8 & 0xFFFFFFFD) == 1)
  {
    v12 = (int *)a2[3];
    v14 = *(int *)(a1 + 4);
    v13 = *(int *)(a1 + 8);
    if (*(_DWORD *)(a1 + 104) < v7)
      v7 = *(_DWORD *)(a1 + 104);
    v15 = 4 * v7;
    if (!a3 || (cstdlib_memset(a2[4], 0, 4 * v7), a3 != 1))
      cstdlib_memset(v12, 0, v15);
    result = 1;
    *((_DWORD *)a2 + 4) = 1;
    if (v8 != 2)
    {
      v16 = ipow2(**(_DWORD **)(a1 + 16) / 2);
      if (v16 >= 0)
        v17 = v16;
      else
        v17 = -v16;
      v18 = *(_DWORD *)(a1 + 32);
      v19 = v18 < 0;
      if (v18 < 0)
        v18 = -v18;
      if (v19)
        v20 = -((v16 >> 31) | 1);
      else
        v20 = (v16 >> 31) | 1;
      *((_DWORD *)a2 + 16) = ((v18 & 0x7FFF) * (v17 >> 15)
                            + (((v18 & 0x7FFF) * (v17 & 0x7FFF) + 0x4000) >> 15)
                            + v17 * (v18 >> 15))
                           * v20;
      if (*(_DWORD *)(a1 + 104) == *(_DWORD *)(a1 + 92))
      {
        v21 = *(_DWORD **)(a1 + 144);
        *v21 = 0;
        cstdlib_memcpy(v21 + 1, (const void *)(*(_QWORD *)(a1 + 16) + 4 * v13 + 4), 4 * *(int *)(a1 + 4));
        cstdlib_memset((void *)(*(_QWORD *)(a1 + 144) + 4 * (v14 + 1)), 0, 4 * (*(_DWORD *)(a1 + 96) - ((int)v14 + 1)));
        v22 = (__int16 *)call_cfsv_construct((uint64_t)*a2, *(_QWORD *)(a1 + 144), *(_WORD *)(a1 + 96), 15);
        if (v22)
        {
          v23 = (unsigned __int16 *)v22;
          call_cfsv_rfft(v22, *(__int16 *)(a1 + 96));
          call_cfsv_changeOutputSampleOrder(v23, *(_DWORD **)(a1 + 152));
          call_cfsv_destruct(*a2, (uint64_t)v23);
        }
        v24 = *(_QWORD *)(a1 + 144);
        *(_DWORD *)(v24 + 4 * *(int *)(a1 + 96)) = *(_DWORD *)(v24 + 4);
        if ((int)v10 < 1)
          return 0;
        v25 = *(int **)(a1 + 64);
        v26 = v10;
        v27 = v12;
        do
        {
          v28 = *v25++;
          *v27++ = 2
                 * *(_DWORD *)(v24
                             + 4
                             * (int)(2
                                   * (((1 << (14 - *(_DWORD *)(a1 + 100))) + v28) >> (15 - *(_DWORD *)(a1 + 100)))));
          --v26;
        }
        while (v26);
        v29 = *(_DWORD *)(a1 + 168) + *(_DWORD *)(a1 + 164) - 12;
        if (v29 >= 1)
        {
          v30 = 1 << (*(_BYTE *)(a1 + 168) + *(_BYTE *)(a1 + 164) - 13);
          do
          {
            *v12 = (v30 + *v12) >> v29;
            ++v12;
            --v10;
          }
          while (v10);
          return 0;
        }
        v74 = 12 - (*(_DWORD *)(a1 + 168) + *(_DWORD *)(a1 + 164));
        result = 0;
        do
        {
          *v12++ <<= v74;
          --v10;
        }
        while (v10);
      }
      else
      {
        v31 = *(int *)(a1 + 8);
        LODWORD(v32) = *((_DWORD *)a2 + 10);
        v34 = (int *)a2[3];
        v33 = (unsigned int *)a2[4];
        v35 = *(_DWORD *)(a1 + 108);
        if (v35 >= (int)v32)
          v32 = v32;
        else
          v32 = v35;
        v36 = *(_DWORD *)(a1 + 164) + *(_DWORD *)(a1 + 168);
        v37 = v36 - 12;
        if (a3 == 2)
        {
          if ((int)v32 >= 1)
          {
            v52 = 0;
            v53 = *(_QWORD *)(a1 + 64);
            v54 = 4 * v31 + 4;
            do
            {
              v34[v52] = 0;
              if (*(int *)(a1 + 4) >= 1)
              {
                v55 = 0;
                v56 = *(_DWORD *)(v53 + 4 * v52);
                v57 = *(_QWORD *)(a1 + 128);
                v58 = *(_QWORD *)(a1 + 16) + v54;
                v59 = v56;
                do
                {
                  v60 = (((v59 >> 5) & 1) + (v59 >> 6)) & *(_DWORD *)(v57 + 24);
                  v61 = *(_DWORD *)(v57 + 16);
                  v62 = v60 - v61;
                  if (v60 >= v61)
                  {
                    v63 = -*(__int16 *)(*(_QWORD *)v57 + 2 * v62);
                    v64 = -*(__int16 *)(*(_QWORD *)(v57 + 8) + 2 * v62);
                  }
                  else
                  {
                    v63 = *(__int16 *)(*(_QWORD *)v57 + 2 * v60);
                    v64 = *(__int16 *)(*(_QWORD *)(v57 + 8) + 2 * v60);
                  }
                  if (v63 == 0x7FFF)
                    v63 = 0x8000;
                  if (v64 == 0x7FFF)
                    v64 = 0x8000;
                  v33[v52] -= (*(_DWORD *)(v58 + 4 * v55) * v63) >> 14;
                  v34[v52] += (*(_DWORD *)(v58 + 4 * v55) * v64) >> 14;
                  v59 += v56;
                  ++v55;
                }
                while (v55 < *(int *)(a1 + 4));
              }
              ++v52;
            }
            while (v52 != v32);
          }
        }
        else if (!a3 && (int)v32 >= 1)
        {
          v38 = 0;
          v39 = *(_QWORD *)(a1 + 64);
          v40 = 4 * v31 + 4;
          do
          {
            v34[v38] = 0;
            if (*(int *)(a1 + 4) >= 1)
            {
              v41 = 0;
              v42 = 0;
              v43 = *(_DWORD *)(v39 + 4 * v38);
              v44 = *(_QWORD *)(a1 + 128);
              v45 = *(_QWORD *)(a1 + 16) + v40;
              v46 = v43;
              do
              {
                v47 = (((v46 >> 5) & 1) + (v46 >> 6)) & *(_DWORD *)(v44 + 24);
                v48 = *(_DWORD *)(v44 + 16);
                v49 = __OFSUB__(v47, v48);
                v50 = v47 - v48;
                if (v50 < 0 != v49)
                  v51 = *(__int16 *)(*(_QWORD *)(v44 + 8) + 2 * v47);
                else
                  v51 = -*(__int16 *)(*(_QWORD *)(v44 + 8) + 2 * v50);
                v42 += (*(_DWORD *)(v45 + 4 * v41) * v51) >> 14;
                v34[v38] = v42;
                v46 += v43;
                ++v41;
              }
              while (v41 < *(int *)(a1 + 4));
            }
            ++v38;
          }
          while (v38 != v32);
        }
        v65 = v36 - 9;
        if (v37 < 1)
        {
          if ((int)v32 >= 1)
          {
            v67 = v32;
            do
            {
              *v34++ <<= 12 - v36;
              --v67;
            }
            while (v67);
          }
        }
        else if ((int)v32 >= 1)
        {
          v66 = v32;
          do
          {
            *v34 = ((1 << (v36 - 13)) + *v34) >> v37;
            ++v34;
            --v66;
          }
          while (v66);
        }
        if (v65 >= 1)
        {
          if ((int)v32 >= 1)
          {
            v68 = 1 << (v36 - 10);
            do
            {
              v69 = *v33;
              if ((*v33 & 0x80000000) != 0)
                v69 = -v69;
              v70 = 3615 * (v69 >> 15) + ((3615 * (v69 & 0x7FFF) + 0x4000) >> 15);
              if ((*v33 & 0x80000000) != 0)
                v70 = -v70;
              *v33++ = (v68 + v70) >> v65;
              --v32;
            }
            while (v32);
          }
          return 0;
        }
        if ((int)v32 < 1)
          return 0;
        v71 = 9 - v36;
        do
        {
          result = 0;
          v72 = *v33;
          if ((*v33 & 0x80000000) != 0)
            v72 = -v72;
          v73 = 3615 * (v72 >> 15) + ((3615 * (v72 & 0x7FFF) + 0x4000) >> 15);
          if ((*v33 & 0x80000000) != 0)
            v73 = -v73;
          *v33++ = v73 << v71;
          --v32;
        }
        while (v32);
      }
    }
  }
  return result;
}

uint64_t Rr2Pcm_SetHarmonicInfo(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t v6;
  int v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  int v19;
  BOOL v20;
  int v21;
  _DWORD *v22;
  int v23;
  int v24;
  int *v25;
  int v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  unsigned int *v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  _QWORD *v34;
  int v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  _DWORD *v42;
  int v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  int v49;
  _QWORD *v50;
  uint64_t v51;
  int32x2_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  BOOL v58;
  int v59;
  int32x2_t v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  int8x8_t v64;
  int32x2_t v65;
  int v67;
  int v68;
  uint64_t v69;
  _DWORD *v70;
  int v71;
  int v72;
  int32x2_t v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  int8x8_t v77;
  int32x2_t v78;
  uint64_t v79;
  unsigned int *v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  int VoicedAmpAttenuation;
  int v87;
  int InterpolatedValue;
  signed int AuxUvHarmResolution;
  uint64_t v90;
  signed int v91;
  int v92;
  unsigned int v93;
  int NoiseAttenuation;
  int v95;
  int v96;
  int v97;
  uint64_t v98;
  int v99;
  signed int v100;
  int v101;
  int v102;
  int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  _DWORD *v110;
  int v111;

  v5 = a5;
  v6 = a4;
  v9 = *(unsigned __int16 *)(a3 + 48);
  v10 = *(_DWORD **)(a3 + 248);
  if (a5 && v10)
  {
    v11 = *(_QWORD *)(a3 + 16);
    v12 = *(_DWORD *)(a3 + 40);
    v13 = a1[3] / **(_DWORD **)(a4 + 64);
  }
  else
  {
    v11 = *(_QWORD *)(a3 + 8);
    v12 = *(_DWORD *)(a3 + 32);
    if (v10)
    {
      if (!*v10)
        return 1;
      v13 = a1[3] / *v10;
    }
    else
    {
      v13 = 1;
    }
  }
  v14 = *(_QWORD *)(a3 + 64);
  v15 = *(unsigned int *)(v14 + 64);
  v16 = *(unsigned int *)(v14 + 40);
  if (!v9)
  {
    if (((int)v16 - 1) / v13 >= v12)
      v26 = v12;
    else
      v26 = ((int)v16 - 1) / v13;
    if (*(_DWORD *)(v14 + 8) && !*(_DWORD *)(v14 + 12) && *(_DWORD *)(v14 + 16))
    {
      v27 = 0;
      if (a1[70] && v26 >= 1)
      {
        v106 = *(_DWORD *)(v14 + 64);
        v28 = 4 * v13;
        v29 = (_DWORD *)(*(_QWORD *)(v14 + 24) + v28);
        v30 = (unsigned int *)(*(_QWORD *)(a3 + 8) + 8);
        v31 = v26;
        do
        {
          v32 = *v29 + (*(_DWORD *)(a3 + 196) << 12);
          *v30 = v32;
          v33 = ipow2(v32);
          *(v30 - 1) = v33;
          v30[1] = v33;
          v30[2] = 0;
          v29 = (_DWORD *)((char *)v29 + v28);
          v30 += 9;
          --v31;
        }
        while (v31);
        v27 = v26;
        v6 = a4;
        LODWORD(v15) = v106;
      }
      if (v27 < v12)
      {
        v34 = (_QWORD *)(v11 + 36 * v27 + 4);
        do
        {
          *v34 = 0;
          v34[1] = 0;
          v34 = (_QWORD *)((char *)v34 + 36);
          ++v27;
        }
        while (v12 > v27);
      }
      scaleHarmEnergy(a3, v6, v15, 0, v5);
      goto LABEL_107;
    }
    return 1;
  }
  v111 = 0;
  if (a1[25])
    v17 = (int *)(a3 + 56);
  else
    v17 = a1 + 34;
  v18 = *(_DWORD *)(v14 + 16);
  v19 = a1[17];
  if (v18)
    v20 = v19 == 1;
  else
    v20 = 0;
  v21 = v20;
  if (a5)
  {
    v22 = *(_DWORD **)(a3 + 16);
    v24 = *(_DWORD *)(a3 + 40);
    v23 = *(_DWORD *)(a3 + 44);
    v25 = (int *)(*(_QWORD *)(a4 + 64) + 36);
  }
  else
  {
    v22 = *(_DWORD **)(a3 + 8);
    v24 = *(_DWORD *)(a3 + 32);
    v23 = *(_DWORD *)(a3 + 36);
    if (v10)
      v25 = v10 + 9;
    else
      v25 = a1 + 75;
  }
  if (v19)
    v35 = v21;
  else
    v35 = 1;
  if (v35 != 1 || !*(_WORD *)(a3 + 50) || !v18 || !*(_DWORD *)(v14 + 8) || !a1[70])
    return 1;
  v96 = *v17;
  v98 = *(_QWORD *)(a3 + 72);
  v105 = *v25;
  v99 = *(unsigned __int16 *)(a3 + 50);
  v101 = v23;
  if (*(_DWORD *)(a3 + 100))
  {
    LODWORD(v36) = 0;
    if (v24 >= 1 && (int)v16 >= 2)
    {
      v36 = 0;
      v37 = v22 + 4;
      v38 = 1;
      do
      {
        if (*(v37 - 4))
        {
          v39 = *(_DWORD *)(v14 + 12);
          v40 = *(_DWORD *)(*(_QWORD *)(a3 + 152) + 4 * v38 - 4);
          *(v37 - 3) = v40;
          if (v39)
          {
            v37[4] = *(_DWORD *)(*(_QWORD *)(v14 + 32) + 4 * v38);
          }
          else
          {
            *(v37 - 1) = v40;
            *v37 = 0;
          }
          ++v38;
        }
        if (++v36 >= (unint64_t)v24)
          break;
        v37 += 9;
      }
      while (v38 < (int)v16);
    }
  }
  else if (v24 < 1)
  {
    LODWORD(v36) = 0;
  }
  else
  {
    v41 = 0;
    v42 = v22 + 4;
    v43 = 1;
    v107 = v15;
    while (1)
    {
      v44 = *(_QWORD *)(a3 + 64);
      if (v43 >= *(_DWORD *)(v44 + 40))
        break;
      if (*(v42 - 4))
      {
        v45 = v22;
        v46 = v6;
        v47 = *(_DWORD *)(v44 + 12);
        v48 = *(_DWORD *)(*(_QWORD *)(v44 + 24) + 4 * v43) + (*(_DWORD *)(a3 + 196) << 12);
        *(v42 - 2) = v48;
        v49 = ipow2(v48);
        *(v42 - 3) = v49;
        if (v47)
        {
          v42[4] = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 64) + 32) + 4 * v43);
        }
        else
        {
          *(v42 - 1) = v49;
          *v42 = 0;
        }
        v6 = v46;
        v22 = v45;
        ++v43;
        v5 = a5;
        v15 = v107;
      }
      ++v41;
      v42 += 9;
      if (v24 == v41)
        goto LABEL_75;
    }
    LODWORD(v36) = v41;
  }
  if ((int)v36 < v24)
  {
    v50 = &v22[9 * v36 + 1];
    do
    {
      if (*((_DWORD *)v50 - 1))
      {
        *v50 = 0;
        v50[1] = 0;
      }
      LODWORD(v36) = v36 + 1;
      v50 = (_QWORD *)((char *)v50 + 36);
    }
    while (v24 > (int)v36);
  }
LABEL_75:
  v51 = a2;
  if (v24 == v101)
    goto LABEL_76;
  if (a1[17] != 1 || a1[23])
    return 1;
  if ((int)v16 > 1)
  {
    v79 = v16 - 1;
    v80 = (unsigned int *)v98;
    v81 = (13440 * v99) >> 15;
    do
    {
      *v80++ = v81;
      v81 += (13440 * v99) >> 15;
      --v79;
    }
    while (v79);
  }
  v100 = (13440 * v99) >> 15;
  if (v24 >= 1)
  {
    v82 = 32 * v96;
    v97 = v16 - 1;
    v83 = v24;
    v108 = v15;
    do
    {
      v84 = v22[7] * v105 / 16;
      if (v84 >= v82)
      {
        v85 = v15;
        v110 = v22;
        VoicedAmpAttenuation = GetVoicedAmpAttenuation(a1, v82, v22[7] * v105 / 16);
        v22 = v110;
        v87 = VoicedAmpAttenuation;
        if (*v110)
        {
          v110[1] = (v110[1] * VoicedAmpAttenuation) >> 10;
          v15 = v85;
        }
        else
        {
          InterpolatedValue = GetInterpolatedValue(v98, (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a3 + 64) + 24) + 4), v97, v84, &v111, 0);
          v102 = ipow2(InterpolatedValue + (*(_DWORD *)(a3 + 196) << 12));
          v110[2] = v102;
          AuxUvHarmResolution = GetAuxUvHarmResolution(a1, v82, v84);
          v90 = v51;
          if (AuxUvHarmResolution >= v100)
          {
            v92 = 1024;
          }
          else
          {
            if (a1[21])
              v91 = 0;
            else
              v91 = AuxUvHarmResolution;
            v92 = (AuxUvHarmResolution << 10) / (v100 - v91);
          }
          v93 = v87 * v87;
          NoiseAttenuation = GetNoiseAttenuation(a1, v82, v84);
          if (NoiseAttenuation * NoiseAttenuation <= v93)
            v95 = 0;
          else
            v95 = (int)(sqroot5((int *)(a3 + 220), ((int)(NoiseAttenuation * NoiseAttenuation - v93) / 4 * v92 / 256) >> 8)* v102) >> 10;
          v51 = v90;
          v15 = v108;
          v22 = v110;
          v110[1] = v95;
        }
      }
      v22 += 9;
      --v83;
    }
    while (v83);
  }
LABEL_76:
  scaleHarmEnergy(a3, v6, v15, 1, v5);
  v53 = *(_QWORD *)(a3 + 8);
  v54 = *(int *)(a3 + 32);
  if (*(_WORD *)(a3 + 48))
  {
    if ((_DWORD)v54)
    {
      v55 = 36 * v54;
      do
      {
        if (*(_DWORD *)v53)
        {
          v56 = *(_DWORD *)(v51 + 32) & *(_DWORD *)(v53 + 32);
          v57 = *(_DWORD *)(v51 + 24);
          v58 = __OFSUB__(v56, v57);
          v59 = v56 - v57;
          if (v59 < 0 != v58)
          {
            v52.i16[0] = *(_WORD *)(*(_QWORD *)(v51 + 16) + 2 * v56);
            v52.i16[2] = *(_WORD *)(*(_QWORD *)(v51 + 8) + 2 * v56);
            v60 = vshr_n_s32(vshl_n_s32(v52, 0x10uLL), 0x10uLL);
          }
          else
          {
            v52.i16[0] = *(_WORD *)(*(_QWORD *)(v51 + 16) + 2 * v59);
            v52.i16[2] = *(_WORD *)(*(_QWORD *)(v51 + 8) + 2 * v59);
            v60 = vneg_s32(vshr_n_s32(vshl_n_s32(v52, 0x10uLL), 0x10uLL));
          }
          v61 = *(_DWORD *)(v53 + 4);
          if (v61 >= 0)
            v62 = *(_DWORD *)(v53 + 4);
          else
            v62 = -v61;
          if (v61 >= 0)
            v63 = -1;
          else
            v63 = 1;
          v64 = (int8x8_t)vabs_s32(v60);
          v65 = (int32x2_t)vand_s8(v64, (int8x8_t)0x7F0000007FLL);
          v52 = vmul_s32((int32x2_t)vsra_n_u32((uint32x2_t)vmla_s32(vmul_s32(vdup_n_s32(v62), (int32x2_t)vshr_n_u32((uint32x2_t)v64, 0xFuLL)), vdup_n_s32(v62 >> 15), v65), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vdup_n_s32(v62 & 0x7FFF), v65), 0xFuLL), (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v60), (int8x8_t)vdup_n_s32(v63), (int8x8_t)vdup_n_s32((v61 >> 31) | 1u)));
          *(int32x2_t *)(v53 + 12) = v52;
        }
        v53 += 36;
        v55 -= 36;
      }
      while (v55);
    }
  }
  else if ((_DWORD)v54)
  {
    v67 = *(_DWORD *)(v51 + 32);
    v68 = *(_DWORD *)(v51 + 24);
    v69 = 36 * v54;
    v70 = (_DWORD *)(v53 + 32);
    do
    {
      v71 = *v70 & v67;
      v72 = v71 - v68;
      if (v71 >= v68)
      {
        v52.i16[0] = *(_WORD *)(*(_QWORD *)(v51 + 16) + 2 * v72);
        v52.i16[2] = *(_WORD *)(*(_QWORD *)(v51 + 8) + 2 * v72);
        v73 = vneg_s32(vshr_n_s32(vshl_n_s32(v52, 0x10uLL), 0x10uLL));
      }
      else
      {
        v52.i16[0] = *(_WORD *)(*(_QWORD *)(v51 + 16) + 2 * v71);
        v52.i16[2] = *(_WORD *)(*(_QWORD *)(v51 + 8) + 2 * v71);
        v73 = vshr_n_s32(vshl_n_s32(v52, 0x10uLL), 0x10uLL);
      }
      v74 = *(v70 - 7);
      if (v74 >= 0)
        v75 = *(v70 - 7);
      else
        v75 = -v74;
      if (v74 >= 0)
        v76 = -1;
      else
        v76 = 1;
      v77 = (int8x8_t)vabs_s32(v73);
      v78 = (int32x2_t)vand_s8(v77, (int8x8_t)0x7F0000007FLL);
      v52 = vmul_s32((int32x2_t)vsra_n_u32((uint32x2_t)vmla_s32(vmul_s32(vdup_n_s32(v75), (int32x2_t)vshr_n_u32((uint32x2_t)v77, 0xFuLL)), vdup_n_s32(v75 >> 15), v78), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vdup_n_s32(v75 & 0x7FFF), v78), 0xFuLL), (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v73), (int8x8_t)vdup_n_s32(v76), (int8x8_t)vdup_n_s32((v74 >> 31) | 1u)));
      *(int32x2_t *)(v70 - 5) = v52;
      v70 += 9;
      v69 -= 36;
    }
    while (v69);
  }
LABEL_107:
  FilterHarmonics(a1, a3, v6, v5);
  return 0;
}

uint64_t scaleHarmEnergy(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t result;
  int v20;
  int v21;
  uint64_t v22;
  int *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  char v28;
  uint64_t v29;
  int *v30;
  signed int v31;
  int v32;
  int v33;
  uint64_t v34;
  int *v35;
  int v36;
  int v37;
  uint64_t v38;

  v38 = 0;
  if (a5)
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(_DWORD *)(a1 + 40);
    v10 = *(_QWORD *)(a2 + 64);
    if (*(_WORD *)(a1 + 48))
      v11 = 1;
    else
      v11 = *(_DWORD *)(v10 + 52);
    v15 = (int *)(v10 + 56);
    v13 = (int *)(a1 + 216);
    v14 = (int *)(a1 + 212);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 248);
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(_DWORD *)(a1 + 32);
    v13 = (int *)(a1 + 208);
    v14 = (int *)(a1 + 204);
    if (v12)
    {
      if (*(_WORD *)(a1 + 48))
        v11 = 1;
      else
        v11 = *(_DWORD *)(v12 + 52);
      v15 = (int *)(v12 + 56);
    }
    else
    {
      if (*(_WORD *)(a1 + 48))
        v11 = 1;
      else
        v11 = *(_DWORD *)(a1 + 92);
      v15 = (int *)(a1 + 96);
    }
  }
  v37 = 0;
  v16 = *v15;
  v17 = v9;
  if ((int)a3 <= 0)
  {
    result = ScaleTo16BitSignedRangeWithSkip(v8 + 4, v9, 36, (int *)&v38 + 1, (int *)&v38, *(_DWORD *)(a1 + 200));
    v21 = HIDWORD(v38) - (v38 + *(_DWORD *)(a1 + 196));
    if (v11 > 1)
    {
      if ((_DWORD)v17)
      {
        v22 = 36 * v17;
        v23 = (int *)(v8 + 4);
        do
        {
          *v23 = (*v23 * v11) >> v16;
          v23 += 9;
          v22 -= 36;
        }
        while (v22);
      }
      v21 += v16;
    }
    if (v21 >= 1)
    {
      *v13 += v21;
      return result;
    }
    v24 = *v14 - v21;
    goto LABEL_61;
  }
  v18 = CalcSquareNormWthSkip(v8 + 4, v9, 36, 2896, &v37, a4);
  result = sqroot5(0, v18 >> 8);
  if (!(_DWORD)result)
    return result;
  if (a4)
    v20 = v37;
  else
    v20 = 0;
  while ((int)result > (int)(a3 + (a3 >> 1)))
  {
    result = ((int)result >> 1);
    ++v20;
  }
  if (!v20)
  {
    if ((int)result >= (int)(a3 >> 1))
    {
      v20 = 0;
    }
    else
    {
      v20 = 0;
      do
      {
        result = (2 * result);
        --v20;
      }
      while ((int)result < (int)(a3 >> 1));
    }
  }
  v25 = (int)(a3 << 10) / (int)result;
  v26 = 15 - v16;
  if (v11 <= 1)
    v26 = 10;
  v27 = v26 + v20;
  if (v11 <= 1)
    v28 = 0;
  else
    v28 = v16 - 5;
  if (v27 < 0)
  {
    v33 = -v27;
    if (!(_DWORD)v17)
    {
      v31 = -1;
      goto LABEL_59;
    }
    v34 = 36 * v17;
    v35 = (int *)(v8 + 4);
    v31 = -1;
    do
    {
      v36 = (((*v35 * v25) >> v28) * v11) << v33;
      *v35 = v36;
      v35 += 9;
      if (v36 > v31)
        v31 = v36;
      v34 -= 36;
    }
    while (v34);
  }
  else
  {
    if (!(_DWORD)v17)
    {
      v31 = -1;
      v33 = v27;
      goto LABEL_59;
    }
    v29 = 36 * v17;
    v30 = (int *)(v8 + 4);
    v31 = -1;
    do
    {
      v32 = ((*v30 * v25) >> v28) * v11;
      *v30 = v32;
      v30 += 9;
      if (v32 > v31)
        v31 = v32;
      v29 -= 36;
    }
    while (v29);
    v33 = v27;
  }
  if (!a4 || v31 < 0x4000)
  {
LABEL_59:
    result = ScaleTo16BitSignedRangeWithSkip(v8 + 4, v17, 36, v13, v14, v31);
    if (v27 < 0)
      return result;
    goto LABEL_60;
  }
  if ((v27 & 0x80000000) == 0)
  {
LABEL_60:
    v24 = *v14 + v33;
LABEL_61:
    *v14 = v24;
  }
  return result;
}

_DWORD *FilterHarmonics(_DWORD *result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  int *v8;
  int *v9;
  int v10;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  BOOL v15;
  uint64_t i;

  if (a4)
  {
    v4 = *(_QWORD *)(a2 + 16);
    v5 = v4 + 36 * *(int *)(a2 + 40);
    v6 = *(_DWORD **)(a3 + 64);
LABEL_4:
    v7 = v6[4] - v6[6];
    v8 = v6 + 8;
    v9 = v6 + 7;
    goto LABEL_5;
  }
  v6 = *(_DWORD **)(a2 + 248);
  v4 = *(_QWORD *)(a2 + 8);
  v5 = v4 + 36 * *(int *)(a2 + 32);
  if (v6)
    goto LABEL_4;
  v7 = result[72] - result[35];
  v8 = result + 37;
  v9 = result + 36;
LABEL_5:
  if (*(_WORD *)(a2 + 48))
    v8 = v9;
  v10 = *v8;
  if (*(_DWORD *)(v4 + 20) > *v8 || v4 == v5)
  {
    v12 = v4;
  }
  else
  {
    do
    {
      v12 = v4 + 36;
      *(_QWORD *)(v4 + 12) = 0;
      *(_QWORD *)(v4 + 4) = 0;
      v13 = *(_DWORD *)(v4 + 56) > v10 || v12 == v5;
      v4 += 36;
    }
    while (!v13);
  }
  do
  {
    v14 = v12 + 36;
    v15 = *(_DWORD *)(v12 + 20) >= v7 || v12 == v5;
    v12 += 36;
  }
  while (!v15);
  for (i = v14 - 36; i != v5; i += 36)
  {
    *(_QWORD *)(i + 12) = 0;
    *(_QWORD *)(i + 4) = 0;
  }
  return result;
}

uint64_t NormRand_create(uint64_t a1)
{
  *(_QWORD *)(a1 + 96) = RandNormTable();
  return 0;
}

uint64_t WindowTrans_Create_Base(_QWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  uint64_t v5;
  void *v6;
  BOOL v7;
  char v8;
  BOOL v10;
  char v11;
  BOOL v12;
  char v13;
  BOOL v14;
  char v15;
  BOOL v16;
  char v17;
  BOOL v18;
  char v19;
  char v20;
  BOOL v21;
  char v22;
  char v23;
  char v24;
  char v25;
  char v26;
  char v27;
  char v28;
  char v29;
  char v30;
  char v31;
  char v32;
  char v33;
  char v34;
  char v35;
  char v36;
  char v37;
  char v38;
  char v39;
  char v40;
  char v41;
  char v42;
  char v43;

  if (a3 == 3 && a4 == 128 && a5 == 80)
  {
    LODWORD(v5) = 9;
LABEL_5:
    v6 = &asHannTransSamples_B7_Fft512_Frm160;
LABEL_21:
    *a1 = v6;
    *a2 = v5;
    return 0;
  }
  v7 = a3 == 6 && a4 == 256;
  v8 = v7;
  if (v7 && a5 == 80)
  {
    LODWORD(v5) = 9;
LABEL_16:
    v6 = &asHannTransSamples_B13_Fft512_Frm80;
    goto LABEL_21;
  }
  if (a3 == 11 && a4 == 512 && a5 == 80)
  {
    LODWORD(v5) = 9;
    v6 = &asHannTransSamples_B23_Fft512_Frm40;
    goto LABEL_21;
  }
  if (a3 == 6 && a4 == 512 && a5 == 160)
  {
    LODWORD(v5) = 8;
    goto LABEL_16;
  }
  v10 = a3 == 3 && a4 == 256;
  v11 = v10;
  if (v10 && a5 == 160)
  {
    LODWORD(v5) = 8;
    goto LABEL_5;
  }
  v12 = a3 == 3 && a4 == 512;
  v13 = v12;
  if (v12 && a5 == 320)
  {
    LODWORD(v5) = 7;
    goto LABEL_5;
  }
  if (a3 == 4 && a4 == 512 && a5 == 220)
  {
    LODWORD(v5) = 8;
LABEL_51:
    v6 = &asHannTransSamples_B9_Fft512_Frm110;
    goto LABEL_21;
  }
  v14 = a3 == 2 && a4 == 256;
  v15 = v14;
  if (v14 && a5 == 220)
  {
    LODWORD(v5) = 8;
LABEL_72:
    v6 = &asHannTransSamples_B5_Fft256_Frm110;
    goto LABEL_21;
  }
  v16 = a3 == 2 && a4 == 512;
  v17 = v16;
  if (v16 && a5 == 440)
  {
    LODWORD(v5) = 7;
    goto LABEL_72;
  }
  if (a3 == 8 && a4 == 512 && a5 == 110)
  {
    LODWORD(v5) = 9;
    v6 = &asHannTransSamples_B17_Fft512_Frm55;
    goto LABEL_21;
  }
  v18 = a3 == 4 && a4 == 256;
  v19 = v18;
  if (v18 && a5 == 110)
  {
    LODWORD(v5) = 9;
    goto LABEL_51;
  }
  if (a3 == 2 && a4 == 128 && a5 == 110)
  {
    LODWORD(v5) = 9;
    goto LABEL_72;
  }
  if (a3 == 8 && a4 == 256 && a5 == 54)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B17_Fft256_Frm27;
    goto LABEL_21;
  }
  if (a4 == 256 && a3 == 7 && a5 == 62)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B15_Fft256_Frm31;
    goto LABEL_21;
  }
  if (a5 == 70)
    v20 = v8;
  else
    v20 = 0;
  if ((v20 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B13_Fft256_Frm35;
    goto LABEL_21;
  }
  if (a5 != 78)
    v8 = 0;
  if ((v8 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B13_Fft256_Frm39;
    goto LABEL_21;
  }
  v21 = a3 == 5 && a4 == 256;
  v22 = v21;
  if (v21 && a5 == 88)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B11_Fft256_Frm44;
    goto LABEL_21;
  }
  if (a5 != 96)
    v22 = 0;
  if ((v22 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B11_Fft256_Frm48;
    goto LABEL_21;
  }
  if (a5 == 104)
    v23 = v19;
  else
    v23 = 0;
  if ((v23 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B9_Fft256_Frm52;
    goto LABEL_21;
  }
  if (a5 == 112)
    v24 = v19;
  else
    v24 = 0;
  if ((v24 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B9_Fft256_Frm56;
    goto LABEL_21;
  }
  if (a5 == 120)
    v25 = v19;
  else
    v25 = 0;
  if ((v25 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B9_Fft256_Frm60;
    goto LABEL_21;
  }
  if (a5 == 128)
    v26 = v11;
  else
    v26 = 0;
  if ((v26 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B7_Fft256_Frm64;
    goto LABEL_21;
  }
  if (a5 == 138)
    v27 = v11;
  else
    v27 = 0;
  if ((v27 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B7_Fft256_Frm69;
    goto LABEL_21;
  }
  if (a5 == 146)
    v28 = v11;
  else
    v28 = 0;
  if ((v28 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B7_Fft256_Frm73;
    goto LABEL_21;
  }
  if (a5 == 154)
    v29 = v11;
  else
    v29 = 0;
  if ((v29 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B7_Fft256_Frm77;
    goto LABEL_21;
  }
  if (a5 == 162)
    v30 = v11;
  else
    v30 = 0;
  if ((v30 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B7_Fft256_Frm81;
    goto LABEL_21;
  }
  if (a5 != 170)
    v11 = 0;
  if ((v11 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B7_Fft256_Frm85;
    goto LABEL_21;
  }
  if (a5 == 178)
    v31 = v15;
  else
    v31 = 0;
  if ((v31 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B5_Fft256_Frm89;
    goto LABEL_21;
  }
  if (a5 == 186)
    v32 = v15;
  else
    v32 = 0;
  if ((v32 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B5_Fft256_Frm93;
    goto LABEL_21;
  }
  if (a5 == 196)
    v33 = v15;
  else
    v33 = 0;
  if ((v33 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B5_Fft256_Frm98;
    goto LABEL_21;
  }
  if (a5 == 204)
    v34 = v15;
  else
    v34 = 0;
  if ((v34 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B5_Fft256_Frm102;
    goto LABEL_21;
  }
  if (a5 == 212)
    v35 = v15;
  else
    v35 = 0;
  if ((v35 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B5_Fft256_Frm106;
    goto LABEL_21;
  }
  if (a5 == 242)
    v36 = v15;
  else
    v36 = 0;
  if ((v36 & 1) != 0)
  {
    LODWORD(v5) = 8;
    v6 = &asHannTransSamples_B5_Fft256_Frm121;
    goto LABEL_21;
  }
  if (a5 == 264)
    v37 = v13;
  else
    v37 = 0;
  if ((v37 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B7_Fft512_Frm132;
    goto LABEL_21;
  }
  if (a5 == 286)
    v38 = v13;
  else
    v38 = 0;
  if ((v38 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B7_Fft512_Frm143;
    goto LABEL_21;
  }
  if (a5 == 308)
    v39 = v13;
  else
    v39 = 0;
  if ((v39 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B7_Fft512_Frm154;
    goto LABEL_21;
  }
  if (a5 == 330)
    v40 = v13;
  else
    v40 = 0;
  if ((v40 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B7_Fft512_Frm165;
    goto LABEL_21;
  }
  if (a5 != 352)
    v13 = 0;
  if ((v13 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B7_Fft512_Frm176;
    goto LABEL_21;
  }
  if (a5 == 374)
    v41 = v17;
  else
    v41 = 0;
  if ((v41 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B5_Fft512_Frm187;
    goto LABEL_21;
  }
  if (a5 == 396)
    v42 = v17;
  else
    v42 = 0;
  if ((v42 & 1) != 0)
  {
    LODWORD(v5) = 7;
    v6 = &asHannTransSamples_B5_Fft512_Frm198;
    goto LABEL_21;
  }
  v43 = v17 ^ 1;
  v5 = 7;
  if (a5 != 418)
    v43 = 1;
  if ((v43 & 1) == 0)
  {
    v6 = &asHannTransSamples_B5_Fft512_Frm209;
    goto LABEL_21;
  }
  return v5;
}

uint64_t WindowTrans_Create(uint64_t a1, int *a2)
{
  return WindowTrans_Create_Base((_QWORD *)(a1 + 40), (_DWORD *)(a1 + 64), a2[74], a2[3], a2[11]);
}

uint64_t DeempFreqResponse_Create(uint64_t a1, uint64_t a2)
{
  void *v2;
  int v3;

  v2 = &alDeemphFilterFreqResponse;
  v3 = *(_DWORD *)(a2 + 156) != 0;
  if (!*(_DWORD *)(a2 + 156))
    v2 = 0;
  *(_QWORD *)(a1 + 72) = v2;
  *(_DWORD *)(a1 + 68) = v3 << 8;
  return 0;
}

uint64_t Window_Create_Base(_QWORD *a1, int a2)
{
  uint64_t v2;
  void *v3;

  v2 = 7;
  if (a2 > 109)
  {
    if (a2 > 164)
    {
      if (a2 > 197)
      {
        if (a2 == 198)
        {
          v3 = &asHannSamples_397;
          goto LABEL_69;
        }
        if (a2 == 209)
        {
          v3 = &asHannSamples_419;
          goto LABEL_69;
        }
        if (a2 != 220)
          return v2;
        v3 = &asHannSamples_441;
      }
      else
      {
        if (a2 == 165)
        {
          v3 = &asHannSamples_331;
          goto LABEL_69;
        }
        if (a2 == 176)
        {
          v3 = &asHannSamples_353;
          goto LABEL_69;
        }
        if (a2 != 187)
          return v2;
        v3 = &asHannSamples_375;
      }
    }
    else if (a2 > 142)
    {
      if (a2 == 143)
      {
        v3 = &asHannSamples_287;
        goto LABEL_69;
      }
      if (a2 == 154)
      {
        v3 = &asHannSamples_309;
        goto LABEL_69;
      }
      if (a2 != 160)
        return v2;
      v3 = &asHannSamples_321;
    }
    else
    {
      if (a2 == 110)
      {
        v3 = &asHannSamples_221;
        goto LABEL_69;
      }
      if (a2 == 121)
      {
        v3 = &asHannSamples_243;
        goto LABEL_69;
      }
      if (a2 != 132)
        return v2;
      v3 = &asHannSamples_265;
    }
LABEL_69:
    v2 = 0;
    *a1 = v3;
    return v2;
  }
  if (a2 <= 68)
  {
    if (a2 > 47)
    {
      switch(a2)
      {
        case '0':
          v3 = &asHannSamples_97;
          goto LABEL_69;
        case '1':
        case '2':
        case '3':
        case '5':
        case '6':
          return v2;
        case '4':
          v3 = &asHannSamples_105;
          goto LABEL_69;
        case '7':
          v3 = &asHannSamples_111;
          goto LABEL_69;
        case '8':
          v3 = &asHannSamples_113;
          goto LABEL_69;
        default:
          if (a2 == 60)
          {
            v3 = &asHannSamples_121;
          }
          else
          {
            if (a2 != 64)
              return v2;
            v3 = &asHannSamples_129;
          }
          break;
      }
    }
    else
    {
      switch(a2)
      {
        case '#':
          v3 = &asHannSamples_71;
          goto LABEL_69;
        case '$':
        case '%':
        case '&':
        case ')':
        case '*':
        case '+':
          return v2;
        case '\'':
          v3 = &asHannSamples_79;
          goto LABEL_69;
        case '(':
        case ',':
          v3 = &asHannSamples_89;
          goto LABEL_69;
        default:
          if (a2 == 27)
          {
            v3 = &asHannSamples_55;
          }
          else
          {
            if (a2 != 31)
              return v2;
            v3 = &asHannSamples_63;
          }
          break;
      }
    }
    goto LABEL_69;
  }
  if (a2 <= 88)
  {
    switch(a2)
    {
      case 'M':
        v3 = &asHannSamples_155;
        goto LABEL_69;
      case 'N':
      case 'O':
      case 'R':
      case 'S':
      case 'T':
        return v2;
      case 'P':
        v3 = &asHannSamples_161;
        goto LABEL_69;
      case 'Q':
        v3 = &asHannSamples_163;
        goto LABEL_69;
      case 'U':
        v3 = &asHannSamples_171;
        goto LABEL_69;
      default:
        if (a2 == 69)
        {
          v3 = &asHannSamples_139;
        }
        else
        {
          if (a2 != 73)
            return v2;
          v3 = &asHannSamples_147;
        }
        break;
    }
    goto LABEL_69;
  }
  if (a2 <= 97)
  {
    if (a2 == 89)
    {
      v3 = &asHannSamples_179;
      goto LABEL_69;
    }
    if (a2 == 93)
    {
      v3 = &asHannSamples_187;
      goto LABEL_69;
    }
  }
  else
  {
    switch(a2)
    {
      case 'b':
        v3 = &asHannSamples_197;
        goto LABEL_69;
      case 'f':
        v3 = &asHannSamples_205;
        goto LABEL_69;
      case 'j':
        v3 = &asHannSamples_213;
        goto LABEL_69;
    }
  }
  return v2;
}

uint64_t Window_Create(uint64_t a1, uint64_t a2)
{
  return Window_Create_Base((_QWORD *)(a1 + 48), *(_DWORD *)(a2 + 24));
}

double RrInput_Init(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)a2 = a1;
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(_OWORD *)(a2 + 44) = xmmword_214FA3290;
  *(_OWORD *)(a2 + 60) = xmmword_214FA32A0;
  *(_QWORD *)(a2 + 8) = 1;
  *(_QWORD *)&result = 0x400FFFFFFFFLL;
  *(_QWORD *)(a2 + 76) = 0x400FFFFFFFFLL;
  return result;
}

double RrInput_Reset(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 1;
  *(_DWORD *)(a1 + 64) = -1;
  *(_QWORD *)(a1 + 8) = 1;
  *(_QWORD *)&result = 0x400FFFFFFFFLL;
  *(_QWORD *)(a1 + 76) = 0x400FFFFFFFFLL;
  return result;
}

int *RrInput_DeallocateData(int *result)
{
  int *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = result;
  if (result[18] >= 1)
  {
    v2 = *((_QWORD *)result + 3);
    if (!v2)
      goto LABEL_5;
    result = (int *)heap_Free(*(_QWORD **)(*(_QWORD *)result + 8), v2);
  }
  *((_QWORD *)v1 + 3) = 0;
LABEL_5:
  if (v1[17] < 1)
  {
LABEL_8:
    *((_QWORD *)v1 + 4) = 0;
    goto LABEL_9;
  }
  v3 = *((_QWORD *)v1 + 4);
  if (v3)
  {
    result = (int *)heap_Free(*(_QWORD **)(*(_QWORD *)v1 + 8), v3);
    goto LABEL_8;
  }
LABEL_9:
  v1[17] = 0;
  v1[18] = 0;
  return result;
}

uint64_t RrInput_AllocateData(uint64_t a1, int a2, int a3)
{
  int v6;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v12;
  void *v13;
  uint64_t result;

  if (a2 >= 1)
  {
    v6 = *(_DWORD *)(a1 + 72);
    if (!v6 || v6 < a2)
    {
      v8 = *(_QWORD *)(a1 + 24);
      if (v8)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v8);
        *(_QWORD *)(a1 + 24) = 0;
      }
      v9 = (void *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * a2);
      *(_QWORD *)(a1 + 24) = v9;
      if (!v9)
        return 2;
      cstdlib_memset(v9, 0, 4 * a2);
      *(_DWORD *)(a1 + 72) = a2;
    }
  }
  if (a3 < 1)
    return 0;
  v10 = *(_DWORD *)(a1 + 68);
  if (v10 && v10 >= a3)
    return 0;
  v12 = *(_QWORD *)(a1 + 32);
  if (v12)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v12);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v13 = (void *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * a3);
  *(_QWORD *)(a1 + 32) = v13;
  if (v13)
  {
    cstdlib_memset(v13, 0, 4 * a3);
    result = 0;
    *(_DWORD *)(a1 + 68) = a3;
    return result;
  }
  return 2;
}

uint64_t Rr2Pcm_ProcessPhases(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  double v9;
  double v10;
  int PhaseAlignment;
  unsigned __int16 v12;
  __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  _WORD *v20;
  double v21;
  double v22;
  unsigned __int16 v24;

  v24 = 0;
  v8 = *(_DWORD *)(*(_QWORD *)(a3 + 64) + 12);
  ComparePitches(a1, a3, a4, &v24);
  if (*(_DWORD *)(a1 + 52))
    PhaseAlignment = findPhaseAlignment((_QWORD **)a1, a2, a3, a4);
  else
    PhaseAlignment = 0;
  if (*(_WORD *)(a3 + 48))
  {
    v12 = v24;
    if (!*(_DWORD *)(a1 + 56))
      v12 = 0;
    *(_WORD *)(a3 + 52) = v12;
    if (PhaseAlignment)
    {
      v13 = *(_WORD *)(a3 + 84);
      LOWORD(v14) = v13 + *(_WORD *)(a4 + 20) + v12;
    }
    else
    {
      v13 = 0;
      v14 = (*(_DWORD *)(a3 + 80) * v12 + *(_DWORD *)(a4 + 24) * *(unsigned __int16 *)(a4 + 20)) / *(_DWORD *)(a3 + 80);
    }
    *(_WORD *)(a3 + 52) = v14;
    *(_WORD *)(a3 + 86) = v13;
    AddLinearPhase(a2, a3, (unsigned __int16)v14, 0, v9, v10);
    AddRandomPhase(a2, a3, 0, v21, v22);
    v20 = (_WORD *)(a3 + 84);
  }
  else
  {
    if (v8 && (v15 = *(_QWORD *)(a3 + 64), v16 = *(unsigned int *)(v15 + 40), (int)v16 >= 2))
    {
      v17 = (_DWORD *)(*(_QWORD *)(v15 + 32) + 4);
      v18 = v16 - 1;
      while (!*v17++)
      {
        if (!--v18)
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      AddRandomPhase(a2, a3, 0, v9, v10);
    }
    *(_WORD *)(a3 + 86) = 0;
    v20 = (_WORD *)(a3 + 52);
  }
  *v20 = 0;
  return 0;
}

uint64_t AddLinearPhase(uint64_t result, uint64_t a2, int a3, int a4, double a5, double a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  BOOL v17;
  int v18;
  int32x2_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int8x8_t v23;
  int32x2_t v24;
  int v25;
  int v26;
  uint64_t v27;
  int *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int32x2_t v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int8x8_t v37;
  int32x2_t v38;

  v6 = 40;
  if (!a4)
    v6 = 32;
  v7 = 16;
  if (!a4)
    v7 = 8;
  if (a3)
  {
    v8 = *(_QWORD *)(a2 + v7);
    v9 = *(int *)(a2 + v6);
    v10 = ((a3 >> 6) & 1) + (a3 >> 7);
    if (*(_WORD *)(a2 + 48))
    {
      if ((_DWORD)v9)
      {
        v11 = 36 * v9;
        v12 = (int *)(v8 + 32);
        v13 = 1;
        do
        {
          if (*(v12 - 8))
          {
            v14 = *v12 + v13 * v10;
            *v12 = v14;
            v15 = *(_DWORD *)(result + 32) & v14;
            v16 = *(_DWORD *)(result + 24);
            v17 = __OFSUB__(v15, v16);
            v18 = v15 - v16;
            if (v18 < 0 != v17)
            {
              LOWORD(a6) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v15);
              WORD2(a6) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v15);
              v19 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a6, 0x10uLL), 0x10uLL);
            }
            else
            {
              LOWORD(a6) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v18);
              WORD2(a6) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v18);
              v19 = vneg_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a6, 0x10uLL), 0x10uLL));
            }
            v20 = *(v12 - 7);
            if (v20 >= 0)
              v21 = *(v12 - 7);
            else
              v21 = -v20;
            if (v20 >= 0)
              v22 = -1;
            else
              v22 = 1;
            v23 = (int8x8_t)vabs_s32(v19);
            v24 = (int32x2_t)vand_s8(v23, (int8x8_t)0x7F0000007FLL);
            a6 = COERCE_DOUBLE(vmul_s32(vmla_s32((int32x2_t)vsra_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v21 >> 15), v24), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vdup_n_s32(v21 & 0x7FFF), v24), 0xFuLL), vdup_n_s32(v21), (int32x2_t)vshr_n_u32((uint32x2_t)v23, 0xFuLL)), (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v19), (int8x8_t)vdup_n_s32(v22), (int8x8_t)vdup_n_s32((v20 >> 31) | 1u))));
            *(double *)(v12 - 5) = a6;
            ++v13;
          }
          v12 += 9;
          v11 -= 36;
        }
        while (v11);
      }
    }
    else if ((_DWORD)v9)
    {
      v25 = *(_DWORD *)(result + 32);
      v26 = *(_DWORD *)(result + 24);
      v27 = 36 * v9;
      v28 = (int *)(v8 + 32);
      v29 = ((a3 >> 6) & 1) + (a3 >> 7);
      do
      {
        v30 = v29 + *v28;
        *v28 = v30;
        v31 = v25 & v30;
        v32 = (v25 & v30) - v26;
        if (v31 >= v26)
        {
          LOWORD(a6) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v32);
          WORD2(a6) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v32);
          v33 = vneg_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a6, 0x10uLL), 0x10uLL));
        }
        else
        {
          LOWORD(a6) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v31);
          WORD2(a6) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v31);
          v33 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a6, 0x10uLL), 0x10uLL);
        }
        v34 = *(v28 - 7);
        if (v34 >= 0)
          v35 = *(v28 - 7);
        else
          v35 = -v34;
        if (v34 >= 0)
          v36 = -1;
        else
          v36 = 1;
        v37 = (int8x8_t)vabs_s32(v33);
        v38 = (int32x2_t)vand_s8(v37, (int8x8_t)0x7F0000007FLL);
        a6 = COERCE_DOUBLE(vmul_s32(vmla_s32((int32x2_t)vsra_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v35 >> 15), v38), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vdup_n_s32(v35 & 0x7FFF), v38), 0xFuLL), vdup_n_s32(v35), (int32x2_t)vshr_n_u32((uint32x2_t)v37, 0xFuLL)), (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v33), (int8x8_t)vdup_n_s32(v36), (int8x8_t)vdup_n_s32((v34 >> 31) | 1u))));
        *(double *)(v28 - 5) = a6;
        v28 += 9;
        v29 += v10;
        v27 -= 36;
      }
      while (v27);
    }
  }
  return result;
}

uint64_t AddRandomPhase(uint64_t result, uint64_t a2, int a3, double a4, double a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  int32x2_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int8x8_t v21;
  int32x2_t v22;
  uint64_t v23;
  int *v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int32x2_t v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int8x8_t v33;
  int32x2_t v34;

  v5 = 32;
  if (a3)
    v5 = 40;
  v6 = 16;
  if (!a3)
    v6 = 8;
  v7 = *(_QWORD *)(a2 + v6);
  v8 = *(int *)(a2 + v5);
  if (*(_WORD *)(a2 + 48))
  {
    v9 = 44;
    if (!a3)
      v9 = 36;
    if ((_DWORD)v8 != *(_DWORD *)(a2 + v9) && (_DWORD)v8 != 0)
    {
      v11 = 36 * v8;
      do
      {
        if (!*(_DWORD *)v7)
        {
          v12 = 1664525 * *(_DWORD *)a2 + 1013904223;
          *(_DWORD *)a2 = v12;
          v13 = (v12 + (v12 >> 11)) & *(_DWORD *)(result + 32);
          v14 = *(_DWORD *)(result + 24);
          v15 = __OFSUB__(v13, v14);
          v16 = v13 - v14;
          if (v16 < 0 != v15)
          {
            LOWORD(a5) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v13);
            WORD2(a5) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v13);
            v17 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a5, 0x10uLL), 0x10uLL);
          }
          else
          {
            LOWORD(a5) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v16);
            WORD2(a5) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v16);
            v17 = vneg_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a5, 0x10uLL), 0x10uLL));
          }
          *(_DWORD *)(v7 + 32) = v13;
          v18 = *(_DWORD *)(v7 + 4);
          if (v18 >= 0)
            v19 = *(_DWORD *)(v7 + 4);
          else
            v19 = -v18;
          if (v18 >= 0)
            v20 = -1;
          else
            v20 = 1;
          v21 = (int8x8_t)vabs_s32(v17);
          v22 = (int32x2_t)vand_s8(v21, (int8x8_t)0x7F0000007FLL);
          a5 = COERCE_DOUBLE(vmul_s32(vmla_s32((int32x2_t)vsra_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v19 >> 15), v22), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vdup_n_s32(v19 & 0x7FFF), v22), 0xFuLL), vdup_n_s32(v19), (int32x2_t)vshr_n_u32((uint32x2_t)v21, 0xFuLL)), (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v17), (int8x8_t)vdup_n_s32(v20), (int8x8_t)vdup_n_s32((v18 >> 31) | 1u))));
          *(double *)(v7 + 12) = a5;
        }
        v7 += 36;
        v11 -= 36;
      }
      while (v11);
    }
  }
  else if ((_DWORD)v8)
  {
    v23 = 36 * v8;
    v24 = (int *)(v7 + 32);
    do
    {
      v25 = 1664525 * *(_DWORD *)a2 + 1013904223;
      *(_DWORD *)a2 = v25;
      v26 = (v25 + (v25 >> 11)) & *(_DWORD *)(result + 32);
      v27 = *(_DWORD *)(result + 24);
      v15 = __OFSUB__(v26, v27);
      v28 = v26 - v27;
      if (v28 < 0 != v15)
      {
        LOWORD(a5) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v26);
        WORD2(a5) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v26);
        v29 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a5, 0x10uLL), 0x10uLL);
      }
      else
      {
        LOWORD(a5) = *(_WORD *)(*(_QWORD *)(result + 16) + 2 * v28);
        WORD2(a5) = *(_WORD *)(*(_QWORD *)(result + 8) + 2 * v28);
        v29 = vneg_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)&a5, 0x10uLL), 0x10uLL));
      }
      *v24 = v26;
      v30 = *(v24 - 7);
      if (v30 >= 0)
        v31 = *(v24 - 7);
      else
        v31 = -v30;
      if (v30 >= 0)
        v32 = -1;
      else
        v32 = 1;
      v33 = (int8x8_t)vabs_s32(v29);
      v34 = (int32x2_t)vand_s8(v33, (int8x8_t)0x7F0000007FLL);
      a5 = COERCE_DOUBLE(vmul_s32(vmla_s32((int32x2_t)vsra_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v31 >> 15), v34), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vdup_n_s32(v31 & 0x7FFF), v34), 0xFuLL), vdup_n_s32(v31), (int32x2_t)vshr_n_u32((uint32x2_t)v33, 0xFuLL)), (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v29), (int8x8_t)vdup_n_s32(v32), (int8x8_t)vdup_n_s32((v30 >> 31) | 1u))));
      *(double *)(v24 - 5) = a5;
      v24 += 9;
      v23 -= 36;
    }
    while (v23);
  }
  return result;
}

uint64_t *Rr2Pcm_AllocateAndInit(uint64_t a1, int *a2, int a3)
{
  uint64_t *v6;

  v6 = (uint64_t *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 40);
  if (v6 && Rr2Pcm_Init(a1, a2, v6, a3))
  {
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v6);
    return 0;
  }
  return v6;
}

uint64_t Rr2Pcm_Init(uint64_t a1, int *a2, uint64_t *a3, int a4)
{
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t result;

  *a3 = a1;
  v8 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 320);
  a3[1] = (uint64_t)v8;
  if (!v8)
    return 2;
  cstdlib_memset(v8, 0, 0x140uLL);
  v9 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 104);
  a3[2] = (uint64_t)v9;
  if (!v9)
    return 2;
  cstdlib_memset(v9, 0, 0x68uLL);
  v10 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 256);
  a3[3] = (uint64_t)v10;
  if (!v10)
    return 2;
  cstdlib_memset(v10, 0, 0x100uLL);
  v11 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 72);
  a3[4] = (uint64_t)v11;
  if (!v11)
    return 2;
  cstdlib_memset(v11, 0, 0x48uLL);
  result = Rr2Pcm_InitProps(a1, a2, a3[1]);
  if (!(result | a4))
    return Rr2Pcm_InitByProps((int *)a3[1], a3);
  return result;
}

uint64_t Rr2Pcm_InitProps(uint64_t a1, int *a2, uint64_t a3)
{
  int *v5;
  int v6;
  int v7;
  int v8;
  uint64_t result;
  int v10;

  *(_QWORD *)a3 = a1;
  if (a2)
  {
    v5 = a2;
    LODWORD(a2) = a2[4];
    v6 = v5[10];
    v7 = *v5;
    *(_DWORD *)(a3 + 312) = v5[1];
    *(_DWORD *)(a3 + 16) = 256;
    *(_QWORD *)(a3 + 28) = 0x1B000000DCLL;
    if (v7 > 0)
      v8 = -1;
    else
      v8 = v7;
  }
  else
  {
    v6 = 0;
    *(_DWORD *)(a3 + 312) = 0;
    *(_DWORD *)(a3 + 16) = 256;
    *(_QWORD *)(a3 + 28) = 0x1B000000DCLL;
    v8 = -1;
  }
  *(_QWORD *)(a3 + 36) = 0x140000000ALL;
  if (Rr2Pcm_SetSampleRateDependentParams(a3, (int)a2, v8))
    return 1;
  if (v6 != *(_DWORD *)(a3 + 24))
  {
    v10 = *(_DWORD *)(a3 + 12);
    if (v10 >= *(_DWORD *)(a3 + 28))
      v10 = *(_DWORD *)(a3 + 28);
    *(_DWORD *)(a3 + 24) = v6;
    *(_DWORD *)(a3 + 28) = v10;
    *(_DWORD *)(a3 + 32) = v6 / 4;
    Rr2Pcm_SetDerivedParams((int *)a3);
  }
  *(_OWORD *)(a3 + 48) = xmmword_214FA32F0;
  *(_OWORD *)(a3 + 64) = xmmword_214FA3300;
  *(_QWORD *)(a3 + 80) = 0x100000001;
  *(_OWORD *)(a3 + 96) = xmmword_214FA3310;
  *(_OWORD *)(a3 + 112) = xmmword_214FA3320;
  *(_QWORD *)(a3 + 128) = 0x40000000333;
  *(_DWORD *)(a3 + 136) = 4200;
  *(_WORD *)(a3 + 164) = 0;
  *(_QWORD *)(a3 + 152) = 0;
  *(_OWORD *)(a3 + 184) = xmmword_214FA3330;
  result = Rr2Pcm_initProcessMvf(a1, a3 + 200, 0);
  if ((_DWORD)result)
    return 2;
  *(_DWORD *)(a3 + 280) = 1;
  *(_DWORD *)(a3 + 160) = 1;
  *(_QWORD *)(a3 + 264) = 0;
  *(_QWORD *)(a3 + 272) = 0;
  return result;
}

uint64_t Rr2Pcm_InitByProps(int *a1, uint64_t *a2)
{
  uint64_t v3;
  int *v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  void *v17;
  void *v18;
  int v19;
  void *v20;
  int v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  int v26;
  void *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  void *v34;
  void *v35;
  _OWORD *v36;
  uint64_t v37;
  void *v38;
  int v39;
  int v40;

  v3 = a2[3];
  if (a1)
  {
    v4 = a1;
    a2[1] = (uint64_t)a1;
  }
  else
  {
    v4 = (int *)a2[1];
  }
  v5 = (uint64_t *)a2[2];
  v6 = a2[4];
  *(_DWORD *)v3 = 12345;
  v7 = v4[72];
  v8 = 2 * v7;
  v9 = v7 + 32 * v4[2] / (2 * v4[27]);
  if (v8 > v9)
    v9 = v8;
  *(_DWORD *)(v3 + 104) = v9;
  v10 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 36 * v9);
  *(_QWORD *)(v3 + 8) = v10;
  if (!v10)
    return 2;
  cstdlib_memset(v10, 0, 36 * *(unsigned int *)(v3 + 104));
  v11 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 36 * *(unsigned int *)(v3 + 104));
  *(_QWORD *)v6 = v11;
  if (!v11)
    return 2;
  cstdlib_memset(v11, 0, 36 * *(unsigned int *)(v3 + 104));
  v12 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * *(unsigned int *)(v3 + 104));
  *(_QWORD *)(v3 + 24) = v12;
  if (!v12)
    return 2;
  cstdlib_memset(v12, 0, 4 * *(unsigned int *)(v3 + 104));
  if (*(int *)(v3 + 104) >= 1)
  {
    v13 = 0;
    v14 = *(_QWORD *)(v3 + 24);
    do
    {
      *(_DWORD *)(v14 + 4 * v13) = v13;
      ++v13;
    }
    while (v13 < *(int *)(v3 + 104));
  }
  Init_SqrtSearch((_QWORD *)(v3 + 220));
  v15 = *a2;
  *v5 = *a2;
  result = Init_SinTable(v15, (uint64_t)(v5 + 1), 0);
  if (!(_DWORD)result)
  {
    result = WindowTrans_Create((uint64_t)v5, v4);
    if (!(_DWORD)result)
    {
      result = Window_Create((uint64_t)v5, (uint64_t)v4);
      if (!(_DWORD)result)
      {
        result = NormRand_create((uint64_t)v5);
        if (!(_DWORD)result)
        {
          v17 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 8 * (v4[3] / 2 + 1));
          *(_QWORD *)(v3 + 112) = v17;
          if (!v17)
            return 2;
          cstdlib_memset(v17, 0, 8 * (v4[3] / 2 + 1));
          v18 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 8 * (v4[3] / 2 + 1));
          *(_QWORD *)(v3 + 176) = v18;
          if (!v18)
            return 2;
          cstdlib_memset(v18, 0, 8 * (v4[3] / 2 + 1));
          v19 = *(_DWORD *)(v3 + 104) + 2;
          if (v19 <= 3 * v4[72])
            v19 = 3 * v4[72];
          v20 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * v19);
          *(_QWORD *)(v3 + 152) = v20;
          if (!v20)
            return 2;
          v21 = *(_DWORD *)(v3 + 104) + 2;
          if (v21 <= 3 * v4[72])
            v21 = 3 * v4[72];
          cstdlib_memset(v20, 0, 4 * v21);
          v22 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * *(unsigned int *)(v3 + 104));
          *(_QWORD *)(v3 + 136) = v22;
          if (!v22)
            return 2;
          cstdlib_memset(v22, 0, 4 * *(unsigned int *)(v3 + 104));
          v23 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * *(unsigned int *)(v3 + 104));
          *(_QWORD *)(v3 + 144) = v23;
          if (!v23)
            return 2;
          cstdlib_memset(v23, 0, 4 * *(unsigned int *)(v3 + 104));
          v24 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * (2 * *(_DWORD *)(v3 + 104)));
          *(_QWORD *)(v6 + 32) = v24;
          if (!v24)
            return 2;
          cstdlib_memset(v24, 0, 4 * (2 * *(_DWORD *)(v3 + 104)));
          v25 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * *(unsigned int *)(v3 + 104));
          *(_QWORD *)(v6 + 40) = v25;
          if (!v25)
            return 2;
          cstdlib_memset(v25, 0, 4 * *(unsigned int *)(v3 + 104));
          v26 = v4[73];
          if (v26 <= *(_DWORD *)(v3 + 104))
            v26 = *(_DWORD *)(v3 + 104);
          v27 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * (v26 + 2));
          *(_QWORD *)(v3 + 160) = v27;
          if (!v27)
            return 2;
          v28 = v4[73];
          if (v28 <= *(_DWORD *)(v3 + 104))
            v28 = *(_DWORD *)(v3 + 104);
          cstdlib_memset(v27, 0, 4 * (v28 + 2));
          result = DeempFreqResponse_Create((uint64_t)v5, (uint64_t)v4);
          if (!(_DWORD)result)
          {
            v29 = v4[72];
            v31 = v4[2];
            v30 = v4[3];
            if (v31 >= 0)
              v32 = v4[2];
            else
              v32 = v31 + 1;
            v33 = (v30 * v4[15] + (v32 >> 1)) / v31;
            if (v29 < v33)
              v33 = v4[72];
            *(_DWORD *)(v3 + 192) = v33;
            if (v4[10] + v4[9] < 1)
            {
              *(_QWORD *)(v3 + 16) = 0;
              *(_QWORD *)(v3 + 120) = 0;
              *(_QWORD *)(v3 + 240) = 0;
              *(_QWORD *)(v3 + 248) = 0;
              *(_QWORD *)(v6 + 64) = 0;
            }
            else
            {
              result = FrameRateModificationSupport(v4, a2);
              if ((_DWORD)result)
                return result;
              v30 = v4[3];
              v29 = v4[72];
            }
            v34 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * (v30 + v29 + 2));
            *(_QWORD *)(v3 + 184) = v34;
            if (!v34)
              return 2;
            cstdlib_memset(v34, 0, 4 * (v4[3] + v4[72] + 2));
            *(_QWORD *)(v3 + 184) += 8;
            if (v4[38] && v4[42])
            {
              v35 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 56);
              v5[10] = (uint64_t)v35;
              if (!v35)
                return 2;
              cstdlib_memset(v35, 0, 0x38uLL);
              v36 = (_OWORD *)v5[10];
              *v36 = TD_HP_FILTER_CASCADE_22;
              *(_OWORD *)((char *)v36 + 12) = *(__int128 *)((char *)&TD_HP_FILTER_CASCADE_22 + 12);
              v37 = v5[10];
              *(_OWORD *)(v37 + 40) = unk_214FA3368;
              *(_OWORD *)(v37 + 28) = *(_OWORD *)&algn_214FA3350[12];
            }
            v38 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 4 * *(unsigned int *)(v3 + 104));
            *(_QWORD *)(v3 + 72) = v38;
            if (v38)
            {
              cstdlib_memset(v38, 0, 4 * *(unsigned int *)(v3 + 104));
              *(_WORD *)(v3 + 84) = 0;
              *(_WORD *)(v3 + 52) = 0;
              *(_WORD *)(v6 + 20) = 0;
              *(_DWORD *)(v3 + 86) = 0x4000000;
              *(_DWORD *)(v3 + 80) = 1;
              *(_DWORD *)(v6 + 24) = 1;
              v39 = 10 * v4[2] * v4[3] / (474 * v4[5]);
              *(_DWORD *)(v3 + 92) = v39;
              v40 = PositiveShortLog2((__int16)v39);
              *(_DWORD *)(v3 + 96) = v40;
              if (*(_DWORD *)(v3 + 92) > 1 << v40)
                *(_DWORD *)(v3 + 96) = v40 + 1;
              result = 0;
              *(_QWORD *)(v6 + 8) = 0;
              *(_DWORD *)(v6 + 28) = 0;
              *(_DWORD *)(v6 + 56) = 0;
              *(_DWORD *)(v6 + 48) = 0;
              *(_DWORD *)(v3 + 228) = 0;
              return result;
            }
            return 2;
          }
        }
      }
    }
  }
  return result;
}

uint64_t Rr2Pcm_GetMvf(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 24) + 56);
}

BOOL Rr2Pcm_SetProperty(int a1, uint64_t a2, char *__s1, unsigned __int8 *a4)
{
  _BOOL8 result;
  int v7;

  result = 0;
  if (!cstdlib_strcmp(__s1, "PROD_CODE"))
  {
    v7 = cstdlib_atoi(a4);
    if (Rr2Pcm_SetSampleRateDependentParams(a2, v7, *(_DWORD *)(a2 + 12)))
      return 1;
  }
  return result;
}

uint64_t Rr2Pcm_SetSampleRateDependentParams(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;

  v4 = 1;
  if (a2 <= 11024)
  {
    if (a2)
    {
      v5 = 8000;
      if (a2 == 8000)
      {
        v6 = 0;
        *(_DWORD *)(a1 + 8) = 8000;
        *(_QWORD *)(a1 + 20) = 0x2800000100;
        *(_DWORD *)(a1 + 44) = 80;
        if (a3 < 1)
          a3 = 256;
        v7 = 40;
        goto LABEL_23;
      }
      if (a2 != 11000)
        return v4;
      goto LABEL_11;
    }
    v6 = 0;
    v5 = 0;
    v7 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    a3 &= ~(a3 >> 31);
    *(_QWORD *)(a1 + 28) = 0;
    *(_QWORD *)(a1 + 20) = 0;
  }
  else
  {
    if (a2 <= 21999)
    {
      if (a2 != 11025)
      {
        v5 = 16000;
        if (a2 != 16000)
          return v4;
        v6 = 0;
        *(_DWORD *)(a1 + 8) = 16000;
        *(_QWORD *)(a1 + 20) = 0x5000000200;
        *(_DWORD *)(a1 + 44) = 160;
        if (a3 < 1)
          a3 = 512;
        v7 = 80;
        goto LABEL_23;
      }
LABEL_11:
      v6 = 0;
      v5 = 11000;
      *(_DWORD *)(a1 + 8) = 11000;
      *(_QWORD *)(a1 + 20) = 0x3700000100;
      *(_DWORD *)(a1 + 44) = 110;
      if (a3 < 1)
        a3 = 256;
      v7 = 55;
      goto LABEL_23;
    }
    v5 = 22000;
    if (a2 != 22000 && a2 != 22050)
      return v4;
    *(_DWORD *)(a1 + 8) = 22000;
    *(_QWORD *)(a1 + 20) = 0x6E00000200;
    *(_DWORD *)(a1 + 44) = 220;
    if (a3 < 1)
      a3 = 512;
    v7 = 110;
    v6 = 1;
  }
LABEL_23:
  *(_DWORD *)(a1 + 12) = a3;
  v8 = a3 >> 1;
  if (*(_DWORD *)(a1 + 28) < (signed int)(a3 >> 1))
    v8 = *(_DWORD *)(a1 + 28);
  if (v7 >= *(_DWORD *)(a1 + 32))
    v7 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 28) = v8;
  *(_DWORD *)(a1 + 32) = v7;
  if (a3)
  {
    if (*(_DWORD *)(a1 + 16) < a3)
      a3 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = a3;
  }
  if (v6)
    v9 = 4;
  else
    v9 = 0;
  if (v6)
    v10 = 968;
  else
    v10 = 1024;
  *(_DWORD *)(a1 + 168) = v9;
  *(_DWORD *)(a1 + 172) = v10;
  if (a2)
    Rr2Pcm_ProcessMvf_SetHbThr(a1 + 200, *(_DWORD *)(a1 + 136), v5);
  return 0;
}

uint64_t Rr2Pcm_SetDerivedParams(int *a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  v2 = a1[3];
  v3 = 32 * a1[2];
  a1[35] = 3200 * (int)v2 / v3;
  a1[36] = 1280 * v2 / v3;
  a1[37] = 9600 * (int)v2 / v3;
  a1[11] = 2 * a1[6];
  if ((int)v2 >= 0)
    v4 = v2;
  else
    v4 = v2 + 1;
  a1[72] = v4 >> 1;
  result = PositiveShortLog2((__int16)v2);
  a1[71] = result;
  v7 = a1[2];
  v6 = a1[3];
  a1[73] = v6;
  a1[74] = (440 * (int)v6 + (a1[11] << 7)) / (a1[11] << 8);
  a1[75] = 32 * v7 / v6;
  a1[76] = (v6 << 20) / (32 * v7);
  a1[77] = ((int)v7 + 860160 * a1[6]) / (2 * (int)v7);
  return result;
}

uint64_t FrameRateModificationSupport(int *a1, _QWORD *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  void *v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64x2_t v15;
  int *v16;
  int v17;
  int v18;
  int64x2_t v19;
  int64x2_t v20;
  int32x2_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64x2_t v28;
  int v29;
  int v30;
  int *v31;
  int32x2_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  _DWORD *v36;
  int v37;
  int i;
  int v39;
  int *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t Base;
  uint64_t v47;
  _DWORD *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v55;
  void *v56;
  void *v57;
  _QWORD *v59;

  v4 = a2[3];
  v5 = 1;
  *(_DWORD *)(v4 + 232) = 1;
  v6 = a1[6];
  if (a1[7] > v6)
  {
    v5 = a1[9] + 1;
    *(_DWORD *)(v4 + 232) = v5;
  }
  if (a1[8] < v6)
  {
    v5 += a1[10];
    *(_DWORD *)(v4 + 232) = v5;
  }
  v7 = (void *)heap_Alloc(*(_QWORD *)(*a2 + 8), 88 * v5);
  *(_QWORD *)(v4 + 240) = v7;
  if (!v7)
    return 2;
  cstdlib_memset(v7, 0, 88 * *(unsigned int *)(v4 + 232));
  v8 = a1[10];
  v9 = *(_QWORD *)(v4 + 240);
  if ((v8 & 0x80000000) == 0)
  {
    v10 = a1[8];
    v11 = ((2 * v10) | 1) * v8;
    v12 = a1[6];
    v13 = 2 * v8;
    v14 = (v8 + 2) & 0x1FFFFFFFELL;
    v15 = (uint64x2_t)vdupq_n_s64(v8);
    v16 = (int *)(v9 + 92);
    v17 = 4 * v12 - 4 * v10;
    v18 = 2 * v12 - 2 * v10;
    v19 = (int64x2_t)xmmword_214F962F0;
    v20 = vdupq_n_s64(2uLL);
    do
    {
      v21 = vmovn_s64((int64x2_t)vcgeq_u64(v15, (uint64x2_t)v19));
      if ((v21.i8[0] & 1) != 0)
        *(v16 - 22) = v11 / v13;
      if ((v21.i8[4] & 1) != 0)
        *v16 = (v18 + v11) / v13;
      v19 = vaddq_s64(v19, v20);
      v16 += 44;
      v11 += v17;
      v14 -= 2;
    }
    while (v14);
  }
  v59 = a2;
  v22 = a1[9];
  if ((int)v22 >= 1)
  {
    v23 = 0;
    v24 = a1[6];
    v25 = a1[7];
    v26 = ((2 * v24) | 1) * v22;
    v27 = 2 * v22;
    v28 = (uint64x2_t)vdupq_n_s64(v22 - 1);
    v29 = 2 * v25 - 2 * v24;
    v30 = 4 * v25 - 4 * v24;
    v31 = (int *)(v9 + 88 * (int)v8 + 180);
    do
    {
      v32 = vmovn_s64((int64x2_t)vcgeq_u64(v28, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v23), (int8x16_t)xmmword_214F962F0)));
      if ((v32.i8[0] & 1) != 0)
        *(v31 - 22) = (v29 + v26) / v27;
      if ((v32.i8[4] & 1) != 0)
        *v31 = (v30 + v26) / v27;
      v23 += 2;
      v31 += 44;
      v26 += v30;
    }
    while (((v22 + 1) & 0x1FFFFFFFELL) != v23);
  }
  if ((int)v8 + (int)v22 < 0)
  {
    v55 = 0;
  }
  else
  {
    v33 = 0;
    while (1)
    {
      v34 = a1[3];
      v35 = v9 + 88 * v33;
      v37 = *(_DWORD *)(v35 + 4);
      v36 = (_DWORD *)(v35 + 4);
      for (i = 2 * v37; v34 >= i; v34 /= 2)
        ;
      v39 = 2 * v34;
      if (v39 <= a1[4])
        v39 = a1[4];
      v40 = (int *)(v9 + 88 * v33);
      *v40 = v39;
      v41 = 32 * a1[2];
      v40[6] = 3200 * v39 / v41;
      v40[7] = 1280 * v39 / v41;
      v40[8] = 9600 * v39 / v41;
      v40[2] = i;
      v42 = v39 >= 0 ? v39 : v39 + 1;
      v40[4] = v42 >> 1;
      v40[3] = PositiveShortLog2((__int16)v39);
      v43 = *v40;
      v40[5] = (440 * (int)v43 + (v40[2] << 7)) / (v40[2] << 8);
      v44 = a1[2];
      v40[9] = 32 * v44 / v43;
      v40[10] = (v43 << 20) / (32 * v44);
      v40[11] = ((int)v44 + 860160 * *v36) / (2 * (int)v44);
      v45 = *(_QWORD *)(v4 + 240) + 88 * v33;
      Base = WindowTrans_Create_Base((_QWORD *)(v45 + 64), (_DWORD *)(v45 + 80), *(_DWORD *)(v45 + 20), *(_DWORD *)v45, *(_DWORD *)(v45 + 8));
      v9 = *(_QWORD *)(v4 + 240);
      if ((_DWORD)Base)
        break;
      Base = Window_Create_Base((_QWORD *)(v9 + 88 * v33 + 72), *(_DWORD *)(v9 + 88 * v33 + 4));
      v9 = *(_QWORD *)(v4 + 240);
      if ((_DWORD)Base)
        break;
      v47 = 88 * v33;
      v48 = (_DWORD *)(v9 + 88 * v33);
      v49 = v48[4];
      v50 = a1[2];
      if (v50 >= 0)
        v51 = a1[2];
      else
        v51 = v50 + 1;
      if (v49 >= (*v48 * a1[15] + (v51 >> 1)) / v50)
        v49 = (*v48 * a1[15] + (v51 >> 1)) / v50;
      v52 = 10 * *v48 * v50 / (474 * a1[5]);
      v48[12] = v49;
      v48[13] = v52;
      v53 = PositiveShortLog2((__int16)v52);
      v9 = *(_QWORD *)(v4 + 240);
      *(_DWORD *)(v9 + v47 + 56) = v53;
      if (*(_DWORD *)(v9 + v47 + 52) > 1 << v53)
        *(_DWORD *)(v9 + v47 + 56) = v53 + 1;
      if (v33++ >= a1[10] + (uint64_t)a1[9])
      {
        v55 = 0;
        goto LABEL_41;
      }
    }
    v55 = Base;
LABEL_41:
    LODWORD(v8) = a1[10];
  }
  *(_QWORD *)(v4 + 248) = v9 + 88 * (int)v8;
  v56 = (void *)heap_Alloc(*(_QWORD *)(*v59 + 8), 36 * *(unsigned int *)(v4 + 104));
  *(_QWORD *)(v4 + 16) = v56;
  if (!v56)
    return 2;
  cstdlib_memset(v56, 0, 36 * *(unsigned int *)(v4 + 104));
  v57 = (void *)heap_Alloc(*(_QWORD *)(*v59 + 8), ((4 * a1[3]) & 0x3FFFFFFF8) + 8);
  *(_QWORD *)(v4 + 120) = v57;
  if (!v57)
    return 2;
  cstdlib_memset(v57, 0, ((4 * a1[3]) & 0x3FFFFFFF8) + 8);
  return v55;
}

_QWORD *Rr2Pcm_Deallocate(_QWORD *a1)
{
  _QWORD *result;

  result = Rr2Pcm_Clear(a1);
  if (a1)
    return heap_Free(*(_QWORD **)(*a1 + 8), (uint64_t)a1);
  return result;
}

_QWORD *Rr2Pcm_Clear(_QWORD *a1)
{
  uint64_t v2;
  _DWORD *v3;
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *result;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v3 = (_DWORD *)a1[1];
  v2 = a1[2];
  v4 = (_QWORD *)a1[3];
  v5 = (uint64_t *)a1[4];
  v6 = v4[9];
  if (v6)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v6);
    v4[9] = 0;
  }
  v7 = v4[3];
  if (v7)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v7);
    v4[3] = 0;
  }
  v8 = v4[1];
  if (v8)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v8);
    v4[1] = 0;
  }
  if (*v5)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), *v5);
    *v5 = 0;
  }
  Deinit_SinTable(*a1, v2 + 8);
  Window_Destroy(v2);
  WindowTrans_Destroy(v2);
  NormRand_destroy(v2);
  v9 = v4[14];
  if (v9)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v9);
    v4[14] = 0;
  }
  v10 = v4[22];
  if (v10)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v10);
    v4[22] = 0;
  }
  v11 = v4[19];
  if (v11)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v11);
    v4[19] = 0;
  }
  v12 = v4[17];
  if (v12)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v12);
    v4[17] = 0;
  }
  v13 = v4[18];
  if (v13)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v13);
    v4[18] = 0;
  }
  v14 = v5[4];
  if (v14)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v14);
    v5[4] = 0;
  }
  v15 = v5[5];
  if (v15)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v15);
    v5[5] = 0;
  }
  v16 = v4[20];
  if (v16)
  {
    heap_Free(*(_QWORD **)(*a1 + 8), v16);
    v4[20] = 0;
  }
  if (v3[10] + v3[9] > 0)
  {
    v17 = v4[2];
    if (v17)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v17);
      v4[2] = 0;
    }
    v18 = v4[15];
    if (v18)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v18);
      v4[15] = 0;
    }
    v19 = v4[30];
    if (v19)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v19);
      v4[30] = 0;
    }
  }
  v20 = v4[23];
  if (v20)
  {
    v4[23] = v20 - 8;
    heap_Free(*(_QWORD **)(*a1 + 8), v20 - 8);
    v4[23] = 0;
  }
  if (v3[38])
  {
    if (v3[42])
    {
      v21 = *(_QWORD *)(v2 + 80);
      if (v21)
      {
        heap_Free(*(_QWORD **)(*a1 + 8), v21);
        *(_QWORD *)(v2 + 80) = 0;
      }
    }
  }
  result = Rr2Pcm_clearProcessMvf((_QWORD *)*a1, a1[1] + 200);
  v23 = a1[1];
  if (v23)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v23);
    a1[1] = 0;
  }
  v24 = a1[2];
  if (v24)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v24);
    a1[2] = 0;
  }
  v25 = a1[3];
  if (v25)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v25);
    a1[3] = 0;
  }
  v26 = a1[4];
  if (v26)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v26);
    a1[4] = 0;
  }
  return result;
}

double Rr2Pcm_Reset(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  double result;

  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  *(_WORD *)(v1 + 84) = 0;
  *(_WORD *)(v1 + 52) = 0;
  *(_WORD *)(v2 + 20) = 0;
  *(_DWORD *)(v1 + 86) = 0x4000000;
  *(_DWORD *)(v1 + 80) = 1;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)&result = 1;
  *(_QWORD *)(v2 + 24) = 1;
  *(_DWORD *)(v2 + 56) = 0;
  return result;
}

uint64_t PcmOutput_Init(uint64_t result, _QWORD *a2)
{
  a2[1] = 0;
  a2[2] = 0;
  *a2 = result;
  return result;
}

uint64_t PcmOutput_Reset(uint64_t result)
{
  *(_DWORD *)(result + 8) = 0;
  return result;
}

int *PcmOutput_DeallocateData(int *result)
{
  int *v1;
  uint64_t v2;

  v1 = result;
  if (result[3] < 1)
    goto LABEL_4;
  v2 = *((_QWORD *)result + 2);
  if (v2)
  {
    result = (int *)heap_Free(*(_QWORD **)(*(_QWORD *)result + 8), v2);
LABEL_4:
    *((_QWORD *)v1 + 2) = 0;
  }
  *((_QWORD *)v1 + 1) = 0;
  return result;
}

uint64_t PcmOutput_AllocateData(uint64_t a1, int a2)
{
  int v4;
  BOOL v5;
  uint64_t v6;
  void *v7;
  uint64_t result;

  if (a2 < 1)
    return 0;
  v4 = *(_DWORD *)(a1 + 12);
  if (v4)
    v5 = v4 < a2;
  else
    v5 = 1;
  if (!v5)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (v6)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v6);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v7 = (void *)heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 2 * a2);
  *(_QWORD *)(a1 + 16) = v7;
  if (!v7)
    return 2;
  cstdlib_memset(v7, 0, 2 * a2);
  result = 0;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

uint64_t PcmOutput_SetLength(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 8) = a2;
  return PcmOutput_AllocateData(a1, a2);
}

uint64_t Rr2Pcm_ProcessFrame(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  int *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t result;
  _DWORD *v32;
  _DWORD *v33;
  unint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  _DWORD *v37;
  int v38;
  unint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  BOOL v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  uint64_t v62;
  _DWORD *v63;
  uint64_t v64;
  uint64_t v65;

  v5 = a1[3];
  v6 = a1[4];
  v7 = (_DWORD *)a1[1];
  v8 = a1[2];
  v9 = *(_DWORD *)(a2 + 56);
  if (v9 != 1)
  {
    if (v9)
      goto LABEL_18;
    v10 = *(_DWORD *)(a2 + 48);
    if (v10)
    {
      if (v10 >= 7040)
      {
        if (v10 <= 0xD200)
          v11 = (40904451 * (unint64_t)(((v10 & 0x1FFFF) << 6) | 0x34u)) >> 32;
        else
          LOWORD(v11) = 0x8000;
      }
      else
      {
        LOWORD(v11) = 4291;
      }
      *(_WORD *)(v5 + 50) = v11;
      *(_WORD *)(v5 + 48) = ((unsigned __int16)v11 | 0x10C30000u) / (2 * (unsigned __int16)v11);
      goto LABEL_18;
    }
LABEL_9:
    *(_DWORD *)(v5 + 48) = 0;
    goto LABEL_18;
  }
  v12 = *(_DWORD *)(a2 + 48);
  if (!v12)
    goto LABEL_9;
  if (v12 <= 18618)
  {
    if (v12 >= 2439)
      v13 = (55 * ((v12 << 15) / 0x1F40u)) >> 7;
    else
      LOWORD(v13) = 4291;
  }
  else
  {
    LOWORD(v13) = 0x8000;
  }
  *(_WORD *)(v5 + 48) = v13;
  *(_WORD *)(v5 + 50) = ((unsigned __int16)v13 | 0x10C30000u) / (2 * (unsigned __int16)v13);
LABEL_18:
  *(_QWORD *)(v5 + 64) = a2;
  v14 = *(int **)(a2 + 24);
  v15 = *(unsigned int *)(a2 + 40);
  *(_QWORD *)(v5 + 212) = 0;
  *(_QWORD *)(v5 + 204) = 0;
  v16 = -50;
  if ((int)v15 >= 1)
  {
    do
    {
      v18 = *v14++;
      v17 = v18;
      if (v18 > v16)
        v16 = v17;
      --v15;
    }
    while (v15);
  }
  v19 = 77824 - v16;
  if (v19 < 0)
    v19 = 81919 - v16;
  v20 = (unint64_t)v19 >> 12;
  *(_DWORD *)(v5 + 196) = v20;
  *(_DWORD *)(v5 + 200) = ipow2(v16 + ((_DWORD)v20 << 12));
  v21 = v7[9];
  v22 = v7[10];
  if (v21 + v22 >= 1)
  {
    v23 = *(_DWORD *)(a2 + 80);
    v24 = v23 - 1024;
    if (v23 < 1024)
    {
      v28 = v7[6];
      v29 = v28 - v7[8];
      if (v29)
        v29 = ((v29 << 10) + 2 * v22 * (1024 - v23) * v28) / (v29 << 11);
      if (v29 >= v22)
        v29 = v7[10];
      v27 = *(_QWORD *)(v5 + 240) + 88 * v22 - 88 * v29;
    }
    else
    {
      v25 = v7[6];
      v26 = v7[7] - v25;
      if (v26)
        v26 = ((v26 << 10) + 2 * v21 * v24 * v25) / (v26 << 11);
      if (v26 < v21)
        v21 = v26;
      v27 = *(_QWORD *)(v5 + 240) + 88 * v22 + 88 * v21;
    }
    *(_QWORD *)(v5 + 248) = v27;
  }
  if (v7[49])
  {
    *(_DWORD *)(v5 + 56) = Rr2Pcm_processMvf((uint64_t)v7, v5, *(_QWORD *)(v5 + 152), (_DWORD *)(v5 + 100));
  }
  else
  {
    v30 = *(_DWORD *)(a2 + 60);
    if (v30)
    {
      if (*(_WORD *)(v5 + 48))
      {
        if (v30 >= v7[34])
          v30 = v7[34];
      }
      else
      {
        v30 = 0;
      }
    }
    *(_DWORD *)(v5 + 56) = v30;
    *(_DWORD *)(v5 + 100) = 0;
  }
  Rr2Pcm_PrepareHarmonicInfo(v7, v8, v5, v6, 0);
  result = Rr2Pcm_SetHarmonicInfo(v7, v8, v5, v6, 0);
  if (!(_DWORD)result)
  {
    result = Rr2Pcm_ProcessPhases((uint64_t)v7, v8, v5, v6);
    if (!(_DWORD)result)
    {
      v32 = *(_DWORD **)(v5 + 248);
      if (v32)
      {
        v33 = *(_DWORD **)(v6 + 64);
        if (v33)
        {
          if (*v32 == *v33)
          {
            cstdlib_memcpy(*(void **)(v5 + 16), *(const void **)(v5 + 8), 36 * *(unsigned int *)(v5 + 32));
            *(_QWORD *)(v5 + 40) = *(_QWORD *)(v5 + 32);
          }
          else
          {
            Rr2Pcm_PrepareHarmonicInfo(v7, v8, v5, v6, 1);
            v34 = *(unsigned int *)(v5 + 40);
            v35 = *(unsigned int *)(v5 + 32);
            if (*(_QWORD *)(v5 + 40) == *(_QWORD *)(v5 + 32))
            {
              if ((int)v34 >= 1)
              {
                v36 = (_DWORD *)(*(_QWORD *)(v5 + 16) + 32);
                v37 = (_DWORD *)(*(_QWORD *)(v5 + 8) + 32);
                do
                {
                  *((_OWORD *)v36 - 2) = *((_OWORD *)v37 - 2);
                  *(v36 - 4) = *(v37 - 4);
                  v38 = *v37;
                  v37 += 9;
                  *v36 = v38;
                  v36 += 9;
                  --v34;
                }
                while (v34);
              }
            }
            else if (*(_WORD *)(v5 + 48))
            {
              if ((int)v34 >= 1 && (int)v35 >= 1)
              {
                v39 = 0;
                v40 = 0;
                v41 = *(_QWORD *)(v5 + 16);
                do
                {
                  v42 = *(_DWORD *)(v41 + 36 * v39);
                  if (v42)
                  {
                    v43 = v40;
                    v44 = (int *)(*(_QWORD *)(v5 + 8) + 36 * v40--);
                    do
                    {
                      ++v40;
                      if (v43 >= v35)
                        break;
                      v45 = *v44;
                      v44 += 9;
                      ++v43;
                    }
                    while (!v45);
                  }
                  if (v40 < (int)v35 && (v46 = *(_QWORD *)(v5 + 8), *(_DWORD *)(v46 + 36 * v40) == v42))
                  {
                    v47 = v46 + 36 * v40;
                    v48 = v41 + 36 * v39;
                    *(_OWORD *)(v48 + 4) = *(_OWORD *)(v47 + 4);
                    *(_DWORD *)(v48 + 32) = *(_DWORD *)(v47 + 32);
                    ++v40;
                  }
                  else
                  {
                    v49 = v41 + 36 * v39;
                    *(_QWORD *)(v49 + 12) = 0;
                    *(_QWORD *)(v49 + 4) = 0;
                  }
                  ++v39;
                }
                while (v39 < v34 && v40 < (int)v35);
              }
            }
            else
            {
              v50 = **(_DWORD **)(v6 + 64);
              v51 = **(_DWORD **)(v5 + 248);
              v52 = v50 <= v51;
              v53 = v51 / v50;
              v54 = v50 / v51;
              if (v52)
                v55 = 1;
              else
                v55 = v54;
              if (v52)
                v56 = v53;
              else
                v56 = 1;
              if (v55 <= (int)v34 && v56 <= (int)v35)
              {
                v57 = v56 - 1;
                v58 = v56;
                v59 = v55;
                v60 = v55 + (uint64_t)(v55 - 1);
                v61 = (_DWORD *)(*(_QWORD *)(v5 + 8) + 36 * (v56 - 1) + 32);
                v62 = 36 * v56;
                v63 = (_DWORD *)(*(_QWORD *)(v5 + 16) + 36 * (v55 - 1) + 16);
                v64 = 36 * v55;
                v65 = v58 + v57;
                do
                {
                  *((_OWORD *)v63 - 1) = *((_OWORD *)v61 - 2);
                  *v63 = *(v61 - 4);
                  v63[4] = *v61;
                  if (v60 >= (int)v34)
                    break;
                  v60 += v59;
                  v61 = (_DWORD *)((char *)v61 + v62);
                  v63 = (_DWORD *)((char *)v63 + v64);
                  v52 = v65 < (int)v35;
                  v65 += v58;
                }
                while (v52);
              }
            }
          }
          *(_QWORD *)(v5 + 212) = *(_QWORD *)(v5 + 204);
        }
      }
      Rr2Pcm_EnvLineSpectrumToPcm(v7, v8, v5, v6, a3);
      Rr2Pcm_UpdateState(v5, v6);
      return 0;
    }
  }
  return result;
}

double Rr2Pcm_UpdateState(uint64_t a1, uint64_t a2)
{
  double result;
  int v5;

  cstdlib_memcpy(*(void **)a2, *(const void **)(a1 + 8), 36 * *(unsigned int *)(a1 + 32));
  result = *(double *)(a1 + 32);
  *(double *)(a2 + 8) = result;
  *(_WORD *)(a2 + 16) = *(_WORD *)(a1 + 48);
  *(_DWORD *)(a2 + 18) = *(_DWORD *)(a1 + 50);
  v5 = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(a2 + 52) = v5;
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a1 + 248);
  return result;
}

_DWORD *Rr2Pcm_PrepareHarmonicInfo(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  _QWORD *v6;
  _DWORD *v7;
  BOOL v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  int *v13;
  int *v14;
  BOOL v15;
  int *v16;
  _DWORD *v17;
  int *v18;
  int v19;
  int *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  _DWORD *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  BOOL v42;
  int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  BOOL v54;
  int v55;
  int v56;
  int v57;

  v5 = *(_DWORD *)(a3 + 56);
  v6 = (_QWORD *)(a4 + 64);
  if (!a5)
    v6 = (_QWORD *)(a3 + 248);
  v7 = (_DWORD *)*v6;
  if (v7)
    v8 = a5 == 0;
  else
    v8 = 1;
  v9 = 8;
  if (!v8)
    v9 = 16;
  v10 = *(_DWORD *)(a3 + 56);
  if (!result[24])
    v10 = result[34];
  if (!result[25])
    v5 = result[34];
  v11 = *(_QWORD *)(a3 + v9);
  v12 = v7 + 3;
  v13 = v7 + 9;
  v14 = v7 + 10;
  v15 = v7 == 0;
  if (v7)
    v16 = v7 + 4;
  else
    v16 = result + 72;
  if (v15)
    v17 = result + 71;
  else
    v17 = v12;
  if (v15)
    v18 = result + 75;
  else
    v18 = v13;
  v19 = *v16;
  if (v15)
    v20 = result + 76;
  else
    v20 = v14;
  if (*(_WORD *)(a3 + 48))
  {
    v21 = *(unsigned __int16 *)(a3 + 50);
    v22 = 9 - *v17;
    v23 = (int)(((420 * v21) >> v22) + 2 * result[2]) / (4 * result[2]);
    v24 = v19 - 1;
    v25 = (unint64_t)(v23 + 8) >> 4;
    if (v19 - 1 <= (int)v25 || v19 < 1)
    {
      v33 = 0;
      v32 = 0;
      goto LABEL_31;
    }
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 32 * v10;
    v35 = 32 * v5;
    v57 = *v20;
    v36 = *v18;
    v37 = *(unsigned __int16 *)(a3 + 50);
    v38 = (int)(((420 * v21) >> v22) + 2 * result[2]) / (4 * result[2]);
    while (1)
    {
      v11 += 36;
      v37 += v21;
      v39 = 420 * v37;
      v40 = v32 + 1;
      while (1)
      {
        v32 = v40;
        v41 = v38 - 16 * v25 + 8;
        v42 = v41 == 16;
        if (v38 - 16 * (_DWORD)v25 == 8)
          v41 = 0;
        if (v42)
          LODWORD(v25) = v25 + 1;
        *(_DWORD *)(v11 - 16) = v25;
        *(_DWORD *)(v11 - 12) = v41;
        *(_QWORD *)(v11 - 36) = 0x7FFF00000001;
        *(_DWORD *)(v11 - 8) = v38;
        *(_DWORD *)(v11 - 4) = 0;
        *(_QWORD *)(v11 - 24) = 0x7FFFLL;
        v38 = (int)((v39 >> v22) + 2 * result[2]) / (4 * result[2]);
        if (result[19])
        {
          v43 = v38 * v36 / 16;
          if (v43 < v34)
            goto LABEL_58;
          v44 = result[33];
          v45 = 32 * result[34];
          if (v45 > v43)
          {
            if (v45 >= v34)
              v46 = v34;
            else
              v46 = 32 * result[34];
            v44 = (((v43 - v46) << 10) / (v45 - v46) * v44 + (1024 - ((v43 - v46) << 10) / (v45 - v46)) * result[32])
                / 1024;
          }
          if (v44)
          {
            v47 = 1664525 * *(_DWORD *)a3 + 1013904223;
            *(_DWORD *)a3 = v47;
            v44 = (*(_DWORD *)(*(_QWORD *)(a2 + 96) + 4 * (v47 + (v47 >> 11))) * v44) >> 14;
            if (v44 >= 501)
              v44 = 501;
            if (v44 <= -501)
              v44 = -501;
          }
          v38 += (v44 * v23) >> 10;
        }
        if (!result[20])
        {
          ++v33;
          goto LABEL_82;
        }
        if (*(_DWORD *)(v11 - 8) * v36 / 16 >= v35)
          break;
LABEL_58:
        v25 = (unint64_t)(v38 + 8) >> 4;
        v11 += 36;
        v39 += 420 * v21;
        v37 += v21;
        v40 = v32 + 1;
        ++v33;
        if (v24 <= (int)v25 || v32 >= v19)
          goto LABEL_31;
      }
      v49 = v38 * v36 / 16;
      v50 = 32 * result[34];
      if (v50 >= v35)
        v51 = v35;
      else
        v51 = 32 * result[34];
      if (v49 >= v51)
      {
        v52 = result[27];
        if (v50 > v49)
          v52 = (((v49 - v51) << 10) / (v50 - v51) * v52 + (1024 - ((v49 - v51) << 10) / (v50 - v51)) * result[26])
              / 1024;
      }
      else
      {
        v52 = 0;
      }
      v53 = result[21];
      if (v31)
        v54 = v53 == 0;
      else
        v54 = 1;
      if (v54)
        v55 = *(_DWORD *)(v11 - 8) * v36 / 16;
      else
        v55 = v31;
      if (!v53)
        v49 -= 7 * v52 / 8;
      ++v33;
      if (v55 + v52 < v49)
      {
        v56 = v57 * (v55 + v52);
        v31 = v55;
        do
        {
          *(_DWORD *)(v11 + 20) = (v56 / 0x10000 + 8) >> 4;
          *(_DWORD *)(v11 + 24) = 8;
          *(_QWORD *)v11 = 0x7FFF00000000;
          *(_DWORD *)(v11 + 28) = v56 / 0x10000;
          *(_DWORD *)(v11 + 32) = 0;
          *(_QWORD *)(v11 + 12) = 0x7FFFLL;
          v11 += 36;
          ++v33;
          v31 += v52;
          v56 += v57 * v52;
        }
        while (v52 + v31 < v49);
      }
LABEL_82:
      v25 = (unint64_t)(v38 + 8) >> 4;
      if (v24 <= (int)v25 || v32 >= v19)
      {
LABEL_31:
        if (a5)
        {
          *(_DWORD *)(a3 + 40) = v33;
          *(_DWORD *)(a3 + 44) = v32;
        }
        else
        {
          *(_DWORD *)(a3 + 32) = v33;
          *(_DWORD *)(a3 + 36) = v32;
        }
        return result;
      }
    }
  }
  if (v19 >= 2)
  {
    v27 = (_DWORD *)(v11 + 32);
    v28 = 1;
    v29 = 16;
    do
    {
      *(v27 - 3) = v28;
      *(v27 - 2) = 8;
      *(v27 - 1) = v29;
      *v27 = 0;
      *((_QWORD *)v27 - 4) = 0x7FFF00000000;
      ++v28;
      *(_QWORD *)(v27 - 5) = 0x7FFFLL;
      v27 += 9;
      v29 += 16;
    }
    while (v19 != v28);
  }
  v30 = v19 - 1;
  if (a5)
  {
    *(_DWORD *)(a3 + 40) = v30;
    *(_DWORD *)(a3 + 44) = 0;
  }
  else
  {
    *(_DWORD *)(a3 + 32) = v30;
    *(_DWORD *)(a3 + 36) = 0;
  }
  return result;
}

uint64_t GetAuxUvHarmResolution(_DWORD *a1, int a2, int a3)
{
  int v3;
  int v4;
  uint64_t result;

  v3 = 32 * a1[34];
  if (v3 >= a2)
    v4 = a2;
  else
    v4 = 32 * a1[34];
  if (a3 < v4)
    return 0;
  result = a1[27];
  if (v3 > a3)
    return ((((a3 - v4) << 10) / (v3 - v4) * (int)result + (1024 - ((a3 - v4) << 10) / (v3 - v4)) * a1[26])
                        / 1024);
  return result;
}

uint64_t GetVoicedAmpAttenuation(_DWORD *a1, int a2, int a3)
{
  int v3;
  int v4;
  uint64_t result;

  v3 = 32 * a1[34];
  if (v3 >= a2)
    v4 = a2;
  else
    v4 = 32 * a1[34];
  if (a3 < v4)
    return 1;
  result = a1[29];
  if (v3 > a3)
    return ((((a3 - v4) << 10) / (v3 - v4) * (int)result + (1024 - ((a3 - v4) << 10) / (v3 - v4)) * a1[28])
                        / 1024);
  return result;
}

uint64_t GetNoiseAttenuation(_DWORD *a1, int a2, int a3)
{
  int v3;
  int v4;
  uint64_t result;

  v3 = 32 * a1[34];
  if (v3 >= a2)
    v4 = a2;
  else
    v4 = 32 * a1[34];
  if (a3 < v4)
    return 1;
  result = a1[31];
  if (v3 > a3)
    return ((((a3 - v4) << 10) / (v3 - v4) * (int)result + (1024 - ((a3 - v4) << 10) / (v3 - v4)) * a1[30])
                        / 1024);
  return result;
}

uint64_t Rr2Pcm_ProcessMvf_SetProperty(uint64_t a1, uint64_t a2, char *__s1, unsigned __int8 *a4)
{
  uint64_t result;
  int v9;
  uint64_t v10;
  void *v11;
  int v12;
  int v13;
  int v14;
  int v15;

  if (!cstdlib_strcmp(__s1, "SYN_DEBUZZ_PROCESS_MVF_SMOOTH_WIN"))
  {
    v9 = cstdlib_atoi(a4);
    if (v9 < 1)
    {
      *(_QWORD *)(a2 + 32) = 0;
    }
    else
    {
      v10 = *(_QWORD *)(a2 + 32);
      if (v10)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v10);
        *(_QWORD *)(a2 + 32) = 0;
      }
      v11 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * v9);
      *(_QWORD *)(a2 + 32) = v11;
      if (!v11)
        return 2;
      cstdlib_memset(v11, 0, 4 * v9);
    }
    result = 0;
    *(_DWORD *)(a2 + 48) = v9;
    return result;
  }
  v15 = 0;
  if (cstdlib_strcmp(__s1, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_THR"))
  {
    if (cstdlib_strcmp(__s1, "SYN_DEBUZZ_PROCESS_MVF_RATIO_EN_THR"))
    {
      if (cstdlib_strcmp(__s1, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_MVF_THR"))
      {
        if (cstdlib_strcmp(__s1, "SYN_DEBUZZ_PROCESS_MVF_BY_LOW_EN"))
        {
          if (cstdlib_strcmp(__s1, "SYN_DEBUZZ_PROCESS_MVF_BY_RATIO_EN"))
          {
            return 1;
          }
          else
          {
            v14 = cstdlib_atoi(a4);
            result = 0;
            *(_DWORD *)(a2 + 56) = v14 != 0;
          }
        }
        else
        {
          v13 = cstdlib_atoi(a4);
          result = 0;
          *(_DWORD *)(a2 + 52) = v13 != 0;
        }
      }
      else
      {
        v12 = cstdlib_atoi(a4);
        result = 0;
        *(_DWORD *)(a2 + 8) = v12;
      }
    }
    else
    {
      result = string2fixed(a1, (char *)a4, 1024, &v15);
      if (!(_DWORD)result)
        *(_DWORD *)(a2 + 16) = v15;
    }
  }
  else
  {
    result = string2fixed(a1, (char *)a4, 1024, &v15);
    if (!(_DWORD)result)
      *(_DWORD *)(a2 + 20) = v15;
  }
  return result;
}

uint64_t Rr2Pcm_initProcessMvf(uint64_t a1, uint64_t a2, int a3)
{
  void *v5;
  uint64_t result;

  *(_QWORD *)(a2 + 16) = 0x33300000133;
  *(_OWORD *)a2 = xmmword_214FA3390;
  *(_DWORD *)(a2 + 28) = 768;
  if (a3 < 1)
  {
    *(_QWORD *)(a2 + 32) = 0;
    goto LABEL_5;
  }
  v5 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * a3);
  *(_QWORD *)(a2 + 32) = v5;
  if (v5)
  {
    cstdlib_memset(v5, 0, 4 * a3);
LABEL_5:
    result = 0;
    *(_QWORD *)(a2 + 40) = 0xFFFFFFFFLL;
    *(_DWORD *)(a2 + 48) = a3;
    *(_QWORD *)(a2 + 52) = 0x100000001;
    return result;
  }
  return 2;
}

_QWORD *Rr2Pcm_clearProcessMvf(_QWORD *result, uint64_t a2)
{
  uint64_t v3;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 32);
    if (v3)
    {
      result = heap_Free((_QWORD *)result[1], v3);
      *(_QWORD *)(a2 + 32) = 0;
    }
  }
  return result;
}

uint64_t Rr2Pcm_ProcessMvf_SetHbThr(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(result + 24) = (a2 << 11) / a3;
  return result;
}

uint64_t Rr2Pcm_processMvf(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v8;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;

  v4 = *(_QWORD *)(a2 + 64);
  v5 = *(unsigned int *)(v4 + 60);
  *a4 = 0;
  v6 = *(_DWORD *)(a1 + 200);
  if ((int)v5 <= v6)
    return v5;
  v8 = *(_DWORD *)(a1 + 204);
  if ((int)v5 >= v8)
    return v5;
  v11 = v5;
  if (*(_DWORD *)(a1 + 252))
  {
    v12 = *(_DWORD *)(v4 + 64);
    v11 = v5;
    if (v12 >= 1)
    {
      v13 = v12 << 10;
      v14 = *(_DWORD *)(a1 + 312);
      v11 = v5;
      if (v13 < *(_DWORD *)(a1 + 220) * v14)
      {
        v15 = *(_DWORD *)(a1 + 208);
        v11 = *(unsigned int *)(a1 + 200);
        if ((int)v5 < v15)
          return v11;
        v11 = (v6
                           + (((((int)v5 - v15) << 10)
                             / (v8 - v15)
                             * ((((int)v5 - v15) << 10)
                              / (v8 - v15))
                             * (v13
                              / v14)) >> 20)
                           * *(_DWORD *)(a1 + 212)
                           / 1024);
      }
    }
  }
  if (!*(_DWORD *)(a1 + 256))
    return v11;
  if (*(_DWORD *)(v4 + 8) && *(_DWORD *)(v4 + 16))
  {
    *a4 = 1;
    if (*(_DWORD *)(a1 + 280) && *(int *)(v4 + 40) >= 2)
    {
      v16 = 0;
      do
      {
        v17 = *(_DWORD *)(*(_QWORD *)(v4 + 24) + 4 * v16 + 4) + (*(_DWORD *)(a2 + 196) << 12);
        *(_DWORD *)(a3 + 4 * v16) = v17;
        *(_DWORD *)(a3 + 4 * v16) = ipow2(v17);
        v18 = v16 + 2;
        ++v16;
      }
      while (v18 < *(int *)(*(_QWORD *)(a2 + 64) + 40));
    }
  }
  else
  {
    a3 = *(_QWORD *)(v4 + 24) + 4;
  }
  v20 = *(_DWORD *)(v4 + 40) - 1;
  v21 = v20 * *(_DWORD *)(a1 + 224);
  if (v21 < 1024)
  {
    LODWORD(v23) = 0;
    v22 = 0;
  }
  else
  {
    v22 = 0;
    v23 = v21 >> 10;
    v24 = v23;
    v25 = (int *)a3;
    do
    {
      v26 = *v25++;
      v22 += v26;
      --v24;
    }
    while (v24);
  }
  if ((int)v23 >= v20)
  {
    v28 = 0;
    if (v22)
      goto LABEL_30;
    return v11;
  }
  v27 = 0;
  v23 = v23;
  do
    v27 += *(_DWORD *)(a3 + 4 * v23++);
  while (v20 > (int)v23);
  v28 = (uint64_t)v27 << 10;
  if (!v22)
    return v11;
LABEL_30:
  v29 = *(_QWORD *)(a1 + 232);
  v30 = v28 / v22;
  if (v29)
  {
    v31 = *(_DWORD *)(a1 + 248);
    v32 = *(_DWORD *)(a1 + 240);
    if (v32 < 0)
    {
      v34 = *(_DWORD *)(a1 + 244);
      v36 = v30;
    }
    else
    {
      v33 = 1;
      v34 = *(_DWORD *)(a1 + 240);
      v35 = v30;
      while (v33 == 1 || v34 != *(_DWORD *)(a1 + 244))
      {
        v35 += *(_DWORD *)(v29 + 4 * v34);
        v34 = (v34 + 1) % v31;
        ++v33;
      }
      v36 = v35 / v33;
    }
    if (v32 == v34)
      *(_DWORD *)(a1 + 240) = (v32 + 1) % v31;
    *(_DWORD *)(v29 + 4 * v34) = v30;
    v37 = *(_DWORD *)(a1 + 240);
    *(_DWORD *)(a1 + 244) = (*(_DWORD *)(a1 + 244) + 1) % v31;
    if (v37 < 0)
      *(_DWORD *)(a1 + 240) = 0;
  }
  else
  {
    v36 = v30;
  }
  if (v36 > *(_DWORD *)(a1 + 216))
  {
    v38 = 0x100000 / v36;
    if (0x100000 / v36 >= *(_DWORD *)(a1 + 228))
      v38 = *(_DWORD *)(a1 + 228);
    LODWORD(v5) = *(_DWORD *)(a1 + 200)
                + (((((int)v5 - *(_DWORD *)(a1 + 200)) << 10)
                  / *(_DWORD *)(a1 + 212)
                  * ((((int)v5 - *(_DWORD *)(a1 + 200)) << 10)
                   / *(_DWORD *)(a1 + 212))
                  * v38) >> 20)
                * *(_DWORD *)(a1 + 212)
                / 1024;
  }
  if ((int)v5 >= (int)v11)
    return v11;
  else
    return v5;
}

uint64_t FindBestRationalFactor(uint64_t result, int a2, _DWORD *a3, _DWORD *a4)
{
  unint64_t v4;
  int v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  BOOL v10;

  v4 = 0;
  v5 = 0x7FFFFFFF;
  do
  {
    v6 = (int *)((char *)&aiRationalFactors + 4 * v4);
    v7 = *v6;
    v8 = v6[1];
    v9 = v7 * result - v8 * a2;
    if (v9 < 0)
      v9 = v8 * a2 - v7 * result;
    if ((v7 * (int)result + (v9 << 12)) / (2 * v7 * (int)result) < v5)
    {
      *a3 = v7;
      *a4 = v8;
      v5 = (v7 * (int)result + (v9 << 12)) / (2 * v7 * (int)result);
    }
    v10 = v4 >= 0x14;
    v4 += 2;
  }
  while (!v10);
  return result;
}

_QWORD *Rr2Pcm_EnvLineSpectrumToPcm(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int *v13;
  int *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int *v20;
  int v21;
  _DWORD *v22;
  _DWORD *v23;
  int v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  int *v29;
  int v30;
  _DWORD *v31;
  _DWORD *v32;
  int v33;
  unint64_t v34;
  int v35;
  int *v36;
  int *v37;
  int *v38;
  int v39;
  _DWORD *v40;
  _WORD *v41;
  int *v42;
  int *v43;
  BOOL v44;
  unsigned int *v45;
  int *v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int16 *v50;
  __int16 *v51;
  int v52;
  unsigned __int16 *v53;
  uint64_t v54;
  _QWORD **v55;
  int *v56;
  __int16 *v57;
  uint64_t v58;
  uint64_t v59;
  _DWORD *v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  __int16 *v64;
  int *v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;
  unsigned int v70;
  uint64_t v71;
  int *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  int *v77;
  uint64_t v78;
  int *v79;
  int v80;
  int v81;
  uint64_t v82;
  int *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  BOOL v89;
  int v91;
  int v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  int *v98;
  uint64_t v99;
  int v100;
  int v101;
  int v104;
  int v105;
  int v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  int *v111;
  uint64_t v112;
  _DWORD *v113;
  int *v114;
  int v115;
  uint64_t v116;
  _DWORD *v117;
  int *v118;
  int v119;
  int *v120;
  int v121;
  int v122;
  int v123;
  uint64_t v124;
  int *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  _BYTE *v129;
  BOOL v130;
  int *v131;
  uint64_t v132;
  unsigned int *v133;
  uint64_t v134;
  unsigned int v135;
  unsigned int v136;
  uint64_t v137;
  _DWORD *v138;
  _DWORD *v139;
  int v140;
  int *v141;
  int v142;
  int v143;
  int *v144;
  uint64_t v145;
  int v146;
  uint64_t v147;
  int *v148;
  uint64_t v149;
  __int16 v150;
  int v151;
  int v152;
  _QWORD *result;
  char v154;
  int *v155;
  uint64_t v156;
  int *v157;
  int v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  int v163;
  uint64_t v164;
  _DWORD *__dst;
  uint64_t v166;
  int v167;
  int v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  uint64_t v173;
  int v174;
  uint64_t v175;

  v6 = a3;
  v8 = (_QWORD **)a1;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)(a3 + 16);
  v11 = *(unsigned int *)(a3 + 32);
  v12 = *(unsigned int *)(a3 + 40);
  v175 = 0;
  v13 = *(int **)(a3 + 248);
  if (!v13)
  {
    v18 = 0;
    v16 = 0;
    v15 = a1[3];
    v17 = *(_DWORD *)(a2 + 64);
    goto LABEL_8;
  }
  v14 = *(int **)(a4 + 64);
  v15 = *v13;
  if (!v14)
  {
    v18 = 0;
    v16 = 0;
    v17 = v13[20];
    goto LABEL_8;
  }
  v16 = *v14;
  if (v15 == *v14)
  {
    v17 = v13[20];
    if (v13[1] == v14[1])
    {
      v18 = 0;
      v16 = 0;
LABEL_8:
      v19 = -14;
      goto LABEL_11;
    }
  }
  else
  {
    v17 = v13[20];
  }
  v19 = v14[20] - 14;
  v18 = 1;
LABEL_11:
  if (*(_WORD *)(a3 + 48))
  {
    ReconstructDftFromHarmonies(a1, a2, a3, a4, v11 - 1, 0);
    *(_DWORD *)(v6 + 204) = v17 + *(_DWORD *)(v6 + 204) - 14;
    if (!v18)
      goto LABEL_35;
    ReconstructDftFromHarmonies(v8, a2, v6, a4, v12 - 1, 1);
    goto LABEL_34;
  }
  v20 = *(int **)(a3 + 112);
  *(_QWORD *)v20 = 0;
  v21 = 2;
  if ((int)v11 >= 1 && v15 >= 2)
  {
    v22 = (_DWORD *)(v9 + 16);
    v23 = v20 + 3;
    v24 = 4;
    v25 = 1;
    do
    {
      *(v23 - 1) = *(v22 - 1);
      *v23 = *v22;
      v26 = v24 + 2;
      if (v25 >= v11)
        break;
      v22 += 9;
      ++v25;
      v23 += 2;
      v89 = v15 < v24;
      v24 += 2;
    }
    while (!v89);
    v21 = v26 - 2;
  }
  v27 = v15 + 2;
  if (v21 < v15 + 2)
    bzero(&v20[v21], 4 * (v15 - v21 + 1) + 4);
  ScaleTo16BitSignedRange(v20, v27, (int *)&v175 + 1, (int *)&v175, 0, 0);
  v28 = *(_DWORD *)(v6 + 208) + HIDWORD(v175);
  *(_DWORD *)(v6 + 204) += v175;
  *(_DWORD *)(v6 + 208) = v28;
  if (v18)
  {
    v29 = *(int **)(v6 + 120);
    *(_QWORD *)v29 = 0;
    v30 = 2;
    if ((int)v12 >= 1 && v16 >= 2)
    {
      v31 = (_DWORD *)(v10 + 16);
      v32 = v29 + 3;
      v33 = 4;
      v34 = 1;
      do
      {
        *(v32 - 1) = *(v31 - 1);
        *v32 = *v31;
        v35 = v33 + 2;
        if (v34 >= v12)
          break;
        v31 += 9;
        ++v34;
        v32 += 2;
        v89 = v16 < v33;
        v33 += 2;
      }
      while (!v89);
      v30 = v35 - 2;
    }
    if (v30 < v16 + 2)
      bzero(&v29[v30], 4 * (v16 - v30 + 1) + 4);
    ScaleTo16BitSignedRange(v29, v16 + 2, (int *)&v175 + 1, (int *)&v175, 0, 0);
    v19 = v175;
    *(_DWORD *)(v6 + 216) += HIDWORD(v175);
LABEL_34:
    *(_DWORD *)(v6 + 212) += v19;
  }
LABEL_35:
  v36 = *(int **)(v6 + 112);
  v37 = *(int **)(v6 + 248);
  v174 = v18;
  v173 = a2;
  if (v18)
  {
    v38 = *(int **)(a4 + 64);
    v39 = v38[1];
    v170 = *v38;
    v40 = *(_DWORD **)(v6 + 120);
    v160 = *((_QWORD *)v38 + 9);
    v18 = *(_DWORD *)(v6 + 216);
    v163 = *(_DWORD *)(v6 + 212);
  }
  else
  {
    v40 = 0;
    v170 = 0;
    v39 = 0;
    v163 = 0;
    v160 = 0;
  }
  v164 = a5;
  v41 = *(_WORD **)(a5 + 16);
  __dst = *(_DWORD **)(v6 + 184);
  v167 = *(_DWORD *)(v6 + 208);
  v168 = *(_DWORD *)(v6 + 204);
  v42 = v37 + 2;
  v43 = v37 + 18;
  v44 = v37 == 0;
  if (v37)
  {
    v45 = (unsigned int *)(v37 + 1);
  }
  else
  {
    v37 = (int *)v8 + 3;
    v45 = (unsigned int *)(v8 + 3);
  }
  if (v44)
    v46 = (int *)v8 + 11;
  else
    v46 = v42;
  if (v44)
    v47 = (int *)(v173 + 48);
  else
    v47 = v43;
  v48 = *(_QWORD *)v47;
  v161 = *v46;
  v169 = *v45;
  v49 = *v37;
  v36[1] = v36[v49];
  v50 = (unsigned __int16 *)call_cfsv_construct((uint64_t)*v8, (uint64_t)v36, v49, 15);
  if (v50)
  {
    v51 = (__int16 *)v50;
    call_cfsv_changeInputSampleOrder(v50, *(_QWORD *)(v6 + 176));
    call_cfsv_rifft(v51, (__int16)v49);
    v50 = (unsigned __int16 *)v51;
  }
  v171 = v49;
  v52 = v167 - v168;
  v166 = (uint64_t)v50;
  if (v174)
  {
    v40[1] = v40[v170];
    v53 = (unsigned __int16 *)call_cfsv_construct((uint64_t)*v8, (uint64_t)v40, v170, 15);
    if (v53)
    {
      v54 = *(_QWORD *)(v6 + 176);
      v159 = v6;
      v55 = v8;
      v56 = v36;
      v57 = (__int16 *)v53;
      call_cfsv_changeInputSampleOrder(v53, v54);
      call_cfsv_rifft(v57, (__int16)v170);
      v53 = (unsigned __int16 *)v57;
      v36 = v56;
      v8 = v55;
      v6 = v159;
    }
    v18 -= v163;
    v162 = (uint64_t)v53;
    if (*(_WORD *)(v6 + 48))
    {
      v58 = v164;
      v59 = a4;
      v60 = __dst;
      v62 = v169;
      v61 = v170;
LABEL_70:
      if (v52 < 1)
      {
        v74 = v171;
        if (v167 != v168 && (v62 & 0x80000000) == 0)
        {
          v82 = v62 + 1;
          v83 = v36;
          do
          {
            *v83++ >>= v168 - v167;
            --v82;
          }
          while (v82);
        }
      }
      else
      {
        v74 = v171;
        if ((v62 & 0x80000000) == 0)
        {
          v75 = v62 + 1;
          v76 = v36;
          do
          {
            *v76++ <<= v52;
            --v75;
          }
          while (v75);
        }
      }
      if (v18 < 1)
      {
        if (v18 && v39 >= 1)
        {
          v85 = v61 - v39;
          do
          {
            v40[v85] = (int)v40[v85] >> -(char)v18;
            ++v85;
          }
          while (v85 < v61);
        }
      }
      else if (v39 >= 1)
      {
        v84 = v61 - v39;
        do
          v40[v84++] <<= v18;
        while (v84 < v61);
      }
      v80 = v174;
      goto LABEL_97;
    }
    v61 = v170;
    if (v39 >= 2)
    {
      v63 = v39 - 1;
      v64 = (__int16 *)(v160 + 2);
      v65 = &v40[v170 - v39 + 1];
      do
      {
        v66 = *v64++;
        *v65 = (*v65 * v66) >> 15;
        ++v65;
        --v63;
      }
      while (v63);
    }
    cstdlib_memset(v40, 0, 4 * (v171 - v39 + 1));
    v67 = (int)v169;
    if ((int)v169 > 1)
    {
      v68 = 2 * v169 - 2;
      v69 = v36 + 1;
      do
      {
        *v69 = (*v69 * *(__int16 *)(v48 + v68)) >> 15;
        ++v69;
        v68 -= 2;
      }
      while (v68);
      v67 = v169;
    }
    v70 = v171 - v169;
    v58 = v164;
  }
  else
  {
    v62 = v169;
    if (*(_WORD *)(v6 + 48))
    {
      v162 = 0;
      v58 = v164;
      v59 = a4;
      v60 = __dst;
      v61 = v170;
      goto LABEL_75;
    }
    v67 = (int)v169;
    if ((int)v169 > 1)
    {
      v71 = 2 * v169 - 2;
      v72 = v36 + 1;
      v73 = 2;
      do
      {
        v72[(int)v49 - (int)v169] = (v72[(int)v49 - (int)v169] * *(__int16 *)(v48 + v73)) >> 15;
        *v72 = (*v72 * *(__int16 *)(v48 + v71)) >> 15;
        ++v72;
        v73 += 2;
        v71 -= 2;
      }
      while (v71);
      v67 = v169;
    }
    v162 = 0;
    v70 = v49 - 2 * v169 + 1;
    v58 = v164;
    v61 = v170;
  }
  cstdlib_memset(&v36[v67], 0, 4 * v70);
  v59 = a4;
  v60 = __dst;
  v62 = v169;
  if ((v174 & 1) != 0)
    goto LABEL_70;
LABEL_75:
  if (v52 < 1)
  {
    if ((v52 & 0x80000000) == 0)
    {
      v80 = v174;
      v74 = v171;
      if (!*((_DWORD *)v8 + 40))
        goto LABEL_134;
      goto LABEL_114;
    }
    v154 = v168 - v167;
    *v36 >>= v168 - v167;
    v80 = v174;
    v74 = v171;
    if ((int)v62 >= 1)
    {
      v155 = v36;
      v156 = v62;
      v157 = v36;
      do
      {
        v158 = v157[1];
        *++v157 = v158 >> v154;
        v155[(int)v171 - (int)v62] >>= v154;
        v155 = v157;
        --v156;
      }
      while (v156);
    }
  }
  else
  {
    *v36 <<= v52;
    if ((int)v62 < 1)
    {
      v80 = v174;
      v74 = v171;
    }
    else
    {
      v74 = v171;
      v77 = v36;
      v78 = v62;
      v79 = v36;
      v80 = v174;
      do
      {
        v81 = v79[1];
        *++v79 = v81 << v52;
        v77[(int)v171 - (int)v62] <<= v52;
        v77 = v79;
        --v78;
      }
      while (v78);
    }
  }
LABEL_97:
  if (*((_DWORD *)v8 + 40))
  {
    if ((v80 & 1) != 0)
    {
      LODWORD(v86) = v61 - v39;
      v87 = v40[v61 - v39];
      v88 = v36[(int)v169];
      v89 = (v87 - 6) >= 0xFFFFFFF5 && v88 <= 5;
      if (v89 && v88 > -6)
      {
LABEL_130:
        if (v39 >= 2)
        {
          v112 = v39 - 1;
          v113 = v60 + 1;
          v114 = &v40[(int)v86 + 1];
          do
          {
            v115 = *v114++;
            *v113++ += v115;
            --v112;
          }
          while (v112);
        }
        goto LABEL_138;
      }
      v91 = (v88 - v87) << 10;
      v92 = v87 << 10;
      v93 = v91 / (v39 + (int)v62 - 1);
      if (v39 >= 1)
      {
        v86 = (int)v86;
        v94 = v92 + 512;
        do
        {
          v40[v86++] -= v94 >> 10;
          v92 += v93;
          v94 += v93;
        }
        while (v86 < v61);
      }
      if ((v62 & 0x80000000) == 0)
      {
        v95 = v92;
        v96 = v62 + 1;
        v97 = v95 + 512;
        v98 = v36;
        do
        {
          *v98++ -= v97 >> 10;
          v97 += v93;
          --v96;
        }
        while (v96);
      }
      goto LABEL_128;
    }
LABEL_114:
    LODWORD(v99) = v74 - v62;
    v100 = v36[(int)v74 - (int)v62];
    v101 = v36[(int)v169];
    if ((v100 - 6) >= 0xFFFFFFF5 && v101 <= 5 && v101 > -6)
      goto LABEL_134;
    v104 = (v101 - v100) << 10;
    v105 = v100 << 10;
    v106 = v104 / (v161 - 1);
    if ((int)v62 >= 1)
    {
      v99 = (int)v99;
      v107 = v105 + 512;
      do
      {
        v36[v99++] -= v107 >> 10;
        v105 += v106;
        v107 += v106;
      }
      while (v99 < v74);
    }
    if ((v62 & 0x80000000) == 0)
    {
      v108 = v105;
      v109 = v62 + 1;
      v110 = v108 + 512;
      v111 = v36;
      do
      {
        *v111++ -= v110 >> 10;
        v110 += v106;
        --v109;
      }
      while (v109);
    }
  }
LABEL_128:
  if (v80)
  {
    LODWORD(v86) = v61 - v39;
    goto LABEL_130;
  }
LABEL_134:
  if ((int)v62 >= 2)
  {
    v116 = v62 - 1;
    v117 = v60 + 1;
    v118 = &v36[(int)v74 - (int)v62 + 1];
    do
    {
      v119 = *v118++;
      *v117++ += v119;
      --v116;
    }
    while (v116);
  }
  v39 = v62;
LABEL_138:
  *(_DWORD *)(v58 + 8) = v39;
  v120 = *(int **)(v6 + 184);
  v121 = *((__int16 *)v8 + 82);
  v122 = *((_DWORD *)v8 + 42);
  if (*((_WORD *)v8 + 82))
  {
    v123 = *(_DWORD *)(v59 + 56);
    if (v39 >= 1)
    {
      v124 = v39;
      v125 = *(int **)(v6 + 184);
      do
      {
        v123 = *v125 + ((v123 * v121) >> 15);
        *v125++ = v123;
        --v124;
      }
      while (v124);
    }
    *(_DWORD *)(v59 + 56) = v123;
  }
  else
  {
    *(_DWORD *)(v59 + 56) = v120[v39 - 1];
  }
  if (!*((_DWORD *)v8 + 38) || !*((_DWORD *)v8 + 42))
    goto LABEL_171;
  if (v122 > 1)
  {
    v126 = 0;
    LODWORD(v127) = v122 >> 1;
    v128 = *(_QWORD *)(v173 + 80);
    if ((int)v127 <= 1)
      v127 = 1;
    else
      v127 = v127;
    do
    {
      v129 = (_BYTE *)(v128 + 28 * v126);
      if ((*(_DWORD *)v129 & 0x80000000) != 0)
      {
        if (v39 >= 1)
        {
          v133 = (unsigned int *)v120;
          v134 = v39;
          do
          {
            v135 = *v133;
            if ((int)*v133 < 1)
              v136 = -(-v135 >> -*v129);
            else
              v136 = v135 >> -*v129;
            *v133++ = v136;
            --v134;
          }
          while (v134);
        }
      }
      else
      {
        if (*(_DWORD *)v129)
          v130 = v39 < 1;
        else
          v130 = 1;
        if (!v130)
        {
          v131 = v120;
          v132 = v39;
          do
          {
            *v131++ <<= *(_DWORD *)v129;
            --v132;
          }
          while (v132);
        }
      }
      v137 = v128 + 28 * v126;
      v138 = (_DWORD *)(v137 + 12);
      *(v120 - 1) = *(_DWORD *)(v137 + 12);
      v140 = *(_DWORD *)(v137 + 16);
      v139 = (_DWORD *)(v137 + 16);
      *(v120 - 2) = v140;
      if (v39 >= 1)
      {
        v141 = v139 + 1;
        v143 = v139[1];
        v142 = v139[2];
        v144 = v120;
        v145 = v39;
        do
        {
          v146 = v142 - 2 * v143;
          v143 = *v144;
          *v144 = v146 + *v144 - (*(v144 - 1) * *(v139 - 3) + *(v144 - 2) * *(v139 - 2)) / 0x4000;
          ++v144;
          v142 = *v141;
          *v141 = v143;
          v139[2] = v142;
          --v145;
        }
        while (v145);
      }
      *v138 = v120[v39 - 1];
      *v139 = v120[v39 - 2];
      ++v126;
    }
    while (v126 != v127);
  }
  if (v39 >= 1)
  {
    v147 = v39;
    v148 = v120;
    do
    {
      *v148 = *v148 * *((_DWORD *)v8 + 43) / 1024;
      ++v148;
      --v147;
    }
    while (v147);
LABEL_171:
    if (v39 >= 1)
    {
      v149 = v39;
      do
      {
        v151 = *v120++;
        v150 = v151;
        v152 = (v151 >> 31) + 0x7FFF;
        if (((v151 >> 15) + 1) >= 2)
          v150 = v152;
        *v41++ = v150;
        --v149;
      }
      while (v149);
    }
  }
  *(_DWORD *)(v58 + 8) = v39;
  cstdlib_memcpy(v60, v36, 4 * v62);
  result = call_cfsv_destruct(*v8, v166);
  if (v80)
    return call_cfsv_destruct(*v8, v162);
  return result;
}

int *ReconstructDftFromHarmonies(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v10;
  uint64_t *v11;
  int *v12;
  int *v13;
  uint64_t v14;
  int32x2_t *v15;
  uint64_t v16;
  int *v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  int *v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  signed int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int32x2_t v38;
  uint64_t v39;
  int8x8_t v40;
  int v41;
  int32x2_t *v42;
  __int16 *v43;
  int8x8_t v44;
  int32x2_t v45;
  int32x2_t v46;
  int32x2_t v47;
  int v48;
  int v49;
  int v50;
  BOOL v51;
  unsigned int v52;
  unsigned int v53;
  int32x2_t v54;
  int32x2_t v55;
  int32x2_t v56;
  __int16 *v57;
  int8x8_t v58;
  int32x2_t v59;
  int32x2_t v60;
  int32x2_t v61;
  int v62;
  int32x2_t *v63;
  int v64;
  int v65;
  BOOL v66;
  unsigned int v67;
  int v68;
  int32x2_t v69;
  int32x2_t v70;
  int32x2_t v71;
  int *result;
  _DWORD *v73;
  uint64_t v74;

  v74 = 0;
  if (a6)
  {
    v10 = *(_QWORD *)(a4 + 64);
    v11 = (uint64_t *)(v10 + 64);
    v12 = (int *)(v10 + 20);
    v13 = (int *)(v10 + 16);
    v14 = *(_QWORD *)(a3 + 16);
    v15 = *(int32x2_t **)(a3 + 120);
  }
  else
  {
    v16 = *(_QWORD *)(a3 + 248);
    v14 = *(_QWORD *)(a3 + 8);
    v15 = *(int32x2_t **)(a3 + 112);
    v17 = (int *)(v16 + 20);
    v18 = (uint64_t *)(v16 + 64);
    v19 = v16 == 0;
    if (v16)
      v13 = (int *)(v16 + 16);
    else
      v13 = a1 + 72;
    if (v19)
      v12 = a1 + 74;
    else
      v12 = v17;
    if (v19)
      v11 = (uint64_t *)(a2 + 40);
    else
      v11 = v18;
  }
  v20 = *v11;
  v21 = *v12;
  v22 = *v13;
  cstdlib_memset(v15, 0, 8 * (*v13 + 1));
  v23 = 0;
  v24 = a1[69];
  if (v24 >= 1 && (a5 & 0x80000000) == 0)
  {
    v23 = 0;
    v25 = (a5 + 1);
    v26 = (int *)(v14 + 4);
    do
    {
      v28 = *v26;
      v26 += 9;
      v27 = v28;
      if ((int)v23 <= v28)
        v23 = v27;
      --v25;
    }
    while (v25);
  }
  if ((a5 & 0x80000000) == 0)
  {
    v29 = 0;
    v30 = 2 * v21;
    v31 = (v23 >> 15) * (a1[69] & 0x7FFF) + (((v23 & 0x7FFF) * (a1[69] & 0x7FFF) + 0x4000) >> 15) + v23 * (a1[69] >> 15);
    v32 = v21 + 1;
    do
    {
      if (v24 < 1 || *(_DWORD *)(v14 + 4) >= v31)
      {
        v33 = *(_DWORD *)(v14 + 20);
        v34 = v33 - v21;
        v35 = (v21 - v33) & ((v33 - v21) >> 31);
        v36 = v33 + v21;
        if (v33 + v21 >= v22)
          v37 = v22 + ~(v33 + v21);
        else
          v37 = 0;
        v38 = *(int32x2_t *)(v14 + 12);
        v39 = v20 + 2 * *(_DWORD *)(v14 + 24) * ((2 * v21) | 1);
        v40 = (int8x8_t)vcltz_s32(v38);
        if (v35 <= v37 + v30)
        {
          v41 = v35 + v34;
          v42 = &v15[v35 + v34];
          v43 = (__int16 *)(v39 + 2 * v35);
          v44 = (int8x8_t)vabs_s32(v38);
          v45 = (int32x2_t)vshr_n_u32((uint32x2_t)v44, 0xFuLL);
          v46 = (int32x2_t)vand_s8(v44, (int8x8_t)0x7F0000007FLL);
          v47 = vshl_n_s32(v45, 0x10uLL);
          v48 = v32 + v37 + v33 - v41;
          do
          {
            v50 = *v43++;
            v49 = v50;
            v51 = v50 < 0;
            if (v50 >= 0)
              v52 = v49;
            else
              v52 = -v49;
            if (v51)
              v53 = 1;
            else
              v53 = -1;
            v54 = vdup_n_s32(v52 & 0x7FFF);
            v55 = vdup_n_s32(v52 >> 15);
            v56 = vmla_s32(vmul_s32(v55, v46), v54, v45);
            *v42 = vmla_s32(*v42, (int32x2_t)vsra_n_u32((uint32x2_t)vmla_s32(vadd_s32(v56, v56), v47, v55), (uint32x2_t)vmla_s32((int32x2_t)0x200000002000, v54, v46), 0xEuLL), (int32x2_t)vbsl_s8(v40, (int8x8_t)vdup_n_s32(v53), (int8x8_t)vdup_n_s32((v49 >> 31) | 1u)));
            ++v42;
            --v48;
          }
          while (v48);
        }
        if (v35 < 0 && v36 <= v30)
        {
          v57 = (__int16 *)(v39 + 2 * v36);
          v58 = (int8x8_t)vabs_s32(v38);
          v59 = (int32x2_t)vand_s8(v58, (int8x8_t)0x7F0000007FLL);
          v60 = (int32x2_t)vshr_n_u32((uint32x2_t)v58, 0xFuLL);
          v61 = vshl_n_s32(v60, 0x10uLL);
          v62 = v32 - v33;
          v63 = v15;
          do
          {
            v65 = *v57++;
            v64 = v65;
            v66 = v65 < 0;
            if (v65 >= 0)
              v67 = v64;
            else
              v67 = -v64;
            if (v66)
              v68 = 1;
            else
              v68 = -1;
            v69 = vdup_n_s32(v67 & 0x7FFF);
            v70 = vdup_n_s32(v67 >> 15);
            v71 = vmla_s32(vmul_s32(v70, v59), v69, v60);
            *v63 = vmla_s32(*v63, (int32x2_t)vsra_n_u32((uint32x2_t)vmla_s32(vadd_s32(v71, v71), v61, v70), (uint32x2_t)vmla_s32((int32x2_t)0x200000002000, v69, v59), 0xEuLL), (int32x2_t)vbsl_s8(v40, (int8x8_t)__PAIR64__((v64 >> 31) | 1u, v68), (int8x8_t)vrev64_s32((int32x2_t)__PAIR64__((v64 >> 31) | 1u, v68))));
            ++v63;
            --v62;
          }
          while (v62);
        }
      }
      v14 += 36;
      v19 = v29++ == a5;
    }
    while (!v19);
  }
  result = ScaleTo16BitSignedRange((int *)v15, a1[3] + 2, (int *)&v74 + 1, (int *)&v74, 0, 0);
  if (a6)
  {
    *(_DWORD *)(a3 + 216) += HIDWORD(v74);
    v73 = (_DWORD *)(a3 + 212);
  }
  else
  {
    *(_DWORD *)(a3 + 208) += HIDWORD(v74);
    v73 = (_DWORD *)(a3 + 204);
  }
  *v73 += v74;
  return result;
}

uint64_t findPhaseAlignment(_QWORD **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v5;
  char *v6;
  int *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int *v24;
  int v25;
  int v26;
  uint64_t result;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  BOOL v36;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  signed int v52;
  unint64_t v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  int *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  char v71;
  uint64_t v72;
  unsigned __int16 *v73;
  __int16 *v74;
  int v75;
  int v76;
  int v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  int v82;
  BOOL v83;
  int v84;
  int v85;
  int v86;
  BOOL v87;
  char v89;
  int v90;
  int v91;
  int *v92;
  int *v93;
  uint64_t v94;
  _DWORD *i;
  uint64_t v96;
  int v97;
  uint64_t v98;
  int v100;
  int *v101;
  char *__dst;
  char *v103;
  _QWORD *v105;
  uint64_t v106;
  int v107;

  v6 = *(char **)(a4 + 32);
  v5 = *(char **)(a4 + 40);
  v8 = *(int **)(a3 + 136);
  v7 = *(int **)(a3 + 144);
  v9 = *(int *)(a4 + 28);
  v10 = *(_QWORD *)(a3 + 8);
  v11 = *(_DWORD *)(a3 + 32);
  v12 = *(_DWORD **)(a3 + 248);
  v13 = *(_QWORD **)(a3 + 160);
  v107 = 0;
  v14 = *(_DWORD *)(a3 + 192);
  if (v14 <= *(_DWORD *)(a4 + 52))
    v14 = *(_DWORD *)(a4 + 52);
  if (v12)
    v14 = *v12 * v14 / *((_DWORD *)a1 + 3);
  v15 = *((_DWORD *)a1 + 71);
  v16 = *((_DWORD *)a1 + 73);
  v17 = *(_QWORD *)(a2 + 72);
  v18 = *(_QWORD *)(a3 + 24);
  v106 = *(int *)(a3 + 80);
  v19 = *(int *)(a4 + 24);
  v20 = *(unsigned __int16 *)(a4 + 16);
  *(_WORD *)(a3 + 84) = 0;
  if (!*(_WORD *)(a3 + 48))
    return 0;
  v105 = v13;
  __dst = v6;
  v103 = v5;
  v100 = v20;
  if (v11 != *(_DWORD *)(a3 + 36))
  {
    if (v11)
    {
      v22 = 0;
      LODWORD(v21) = 0;
      v28 = 0;
      v29 = 36 * v11;
      v30 = (int *)(v10 + 20);
      do
      {
        if (*v30 > v14)
          break;
        if (*(v30 - 5))
        {
          *(_DWORD *)(v18 + 4 * (int)v21) = v28;
          v8[(int)v21] = *(v30 - 2);
          v31 = *(v30 - 1);
          v7[(int)v21] = v31;
          v32 = v8[(int)v21];
          if (v32 < 0)
            v32 = -v32;
          if (v22 > v32)
            v32 = v22;
          if (v31 < 0)
            v31 = -v31;
          if (v32 <= v31)
            v22 = v31;
          else
            v22 = v32;
          LODWORD(v21) = v21 + 1;
        }
        ++v28;
        v30 += 9;
        v29 -= 36;
      }
      while (v29);
      goto LABEL_39;
    }
LABEL_38:
    LODWORD(v21) = 0;
    v22 = 0;
    goto LABEL_39;
  }
  if (!v11)
    goto LABEL_38;
  v21 = 0;
  v22 = 0;
  v23 = 36 * v11;
  v24 = (int *)(v10 + 20);
  while (*v24 <= v14)
  {
    v8[v21] = *(v24 - 2);
    v25 = *(v24 - 1);
    v7[v21] = v25;
    v26 = v8[v21];
    if (v26 < 0)
      v26 = -v26;
    if (v22 > v26)
      v26 = v22;
    if (v25 < 0)
      v25 = -v25;
    if (v26 <= v25)
      v22 = v25;
    else
      v22 = v26;
    ++v21;
    v24 += 9;
    v23 -= 36;
    if (!v23)
    {
      LODWORD(v21) = v11;
      break;
    }
  }
LABEL_39:
  v96 = v18;
  v97 = v11;
  v98 = v10;
  ScaleTo16BitSignedRange(v8, v21, &v107, 0, 0, v22);
  ScaleTo16BitSignedRange(v7, v21, &v107, 0, 0, v22);
  if (!v100)
  {
    cstdlib_memcpy(__dst, v8, 4 * v21);
    cstdlib_memcpy(v103, v7, 4 * v21);
    result = 0;
    *(_DWORD *)(a4 + 28) = v21;
    *(_DWORD *)(a3 + 228) = 0;
    return result;
  }
  v101 = v7;
  v33 = (uint64_t)v105;
  v34 = v106;
  *v105 = 0;
  v35 = *((unsigned int *)a1 + 73);
  v36 = (int)v35 >= 4 && (int)v106 <= (int)v21;
  v38 = !v36 || (int)v19 > (int)v9;
  if (v17)
  {
    if ((v38 & 1) == 0)
    {
      v39 = 0;
      v40 = 0;
      v41 = *(_QWORD *)(a3 + 8);
      v42 = v35 >> 1;
      v43 = (_DWORD *)v105 + 3;
      v44 = 4 * v106 - 4;
      v45 = v96 + v44;
      v46 = (char *)v8 + v44;
      v47 = (char *)v101 + v44;
      v48 = 4 * v19 - 4;
      v49 = &__dst[v48];
      v50 = &v103[v48];
      v51 = 2;
      do
      {
        v52 = *(_DWORD *)(v41 + 36 * *(int *)(v45 + 4 * v39) + 20) * (0x100u >> (v15 - 1));
        v53 = v51;
        *(v43 - 1) = ((*(_DWORD *)&v49[4 * v40] * *(_DWORD *)&v46[4 * v39]
                     + *(_DWORD *)&v50[4 * v40] * *(_DWORD *)&v47[4 * v39]) >> 15)
                   * *(_DWORD *)(v17 + 4 * v52);
        v34 = v106;
        *v43 = ((*(_DWORD *)&v49[4 * v40] * *(_DWORD *)&v47[4 * v39]
               - *(_DWORD *)&v50[4 * v40] * *(_DWORD *)&v46[4 * v39]) >> 15)
             * *(_DWORD *)(v17 + 4 * v52);
        ++v51;
        if (v53 >= v42)
          break;
        if (2 * v106 + v39 > (int)v21)
          break;
        v54 = 2 * v19 + v40;
        v40 += v19;
        v43 += 2;
        v39 += v106;
      }
      while (v54 <= v9);
      v55 = v51 - 1;
      v33 = (uint64_t)v105;
      goto LABEL_64;
    }
LABEL_58:
    v55 = 1;
    goto LABEL_64;
  }
  if ((v38 & 1) != 0)
    goto LABEL_58;
  v56 = 0;
  v57 = 0;
  v58 = v35 >> 1;
  v59 = (int *)v105 + 3;
  v60 = 4 * v106 - 4;
  v61 = (char *)v8 + v60;
  v62 = (char *)v101 + v60;
  v63 = 4 * v19 - 4;
  v64 = &__dst[v63];
  v65 = &v103[v63];
  v66 = 2;
  do
  {
    *(v59 - 1) = (*(_DWORD *)&v64[4 * v57] * *(_DWORD *)&v61[4 * v56]
                + *(_DWORD *)&v65[4 * v57] * *(_DWORD *)&v62[4 * v56]) >> 15;
    v67 = v66;
    *v59 = (*(_DWORD *)&v64[4 * v57] * *(_DWORD *)&v62[4 * v56] - *(_DWORD *)&v65[4 * v57] * *(_DWORD *)&v61[4 * v56]) >> 15;
    ++v66;
    if (v67 >= v58)
      break;
    if (2 * v106 + v56 > (int)v21)
      break;
    v68 = 2 * v19 + v57;
    v57 += v19;
    v59 += 2;
    v56 += v106;
  }
  while (v68 <= v9);
  v55 = v66 - 1;
LABEL_64:
  if (v16 >= (int)(2 * v55))
  {
    do
    {
      LOBYTE(v15) = v15 - 1;
      if (v16 >= 0)
        v69 = v16;
      else
        v69 = v16 + 1;
      v16 = v69 >> 1;
    }
    while (v69 >> 1 >= (int)(2 * v55));
  }
  if (v16 <= 16)
    v70 = 16;
  else
    v70 = v16;
  if (v16 >= 16)
    v71 = v15;
  else
    v71 = 4;
  if (v16 >= 16)
    v72 = (2 * v16);
  else
    v72 = 32;
  if (v70 >= v55)
  {
    bzero((void *)(v33 + 8 * v55), 8 * (v70 - v55) + 8);
    v33 = (uint64_t)v105;
  }
  *(_DWORD *)(v33 + 4) = *(_DWORD *)(v33 + 8 * v70);
  v73 = (unsigned __int16 *)call_cfsv_construct((uint64_t)*a1, v33, v72, 15);
  v74 = (__int16 *)v73;
  if (v73)
  {
    call_cfsv_changeInputSampleOrder(v73, *(_QWORD *)(a3 + 176));
    call_cfsv_rifft(v74, (__int16)v72);
  }
  v75 = *(_DWORD *)v105;
  if ((int)v72 < 2)
  {
    v77 = 0;
    v76 = 0;
    v79 = *(_DWORD *)v105;
  }
  else
  {
    v76 = 0;
    v77 = 0;
    v78 = 1;
    v79 = *(_DWORD *)v105;
    do
    {
      v80 = *((_DWORD *)v105 + v78);
      if (v80 >= v79)
        v81 = v76;
      else
        v81 = v78;
      if (v80 >= v79)
        v82 = v79;
      else
        v82 = *((_DWORD *)v105 + v78);
      v83 = v80 <= v75;
      if (v80 <= v75)
      {
        v76 = v81;
      }
      else
      {
        v77 = v78;
        v75 = *((_DWORD *)v105 + v78);
      }
      if (v83)
        v79 = v82;
      ++v78;
    }
    while (v72 != v78);
  }
  if (v75 <= -v79)
    v84 = v76;
  else
    v84 = v77;
  if (v75 <= -v79)
    v85 = -v79;
  else
    v85 = v75;
  v86 = *((_DWORD *)a1 + 16);
  if (!*(_DWORD *)(a4 + 48))
  {
    if (v84 == v76 && v86 == 0)
    {
      v76 = v84;
    }
    else
    {
      v76 = v84;
      v84 = v77;
      if (v86 * v85 >= (v85 - v75) << 10)
        goto LABEL_116;
    }
LABEL_123:
    *(_DWORD *)(a3 + 228) = 1;
    v92 = v8;
    v93 = v101;
    if ((int)v21 >= 1)
    {
      v94 = v21;
      do
      {
        *v92 = -*v92;
        ++v92;
        *v93 = -*v93;
        ++v93;
        --v94;
      }
      while (v94);
    }
    for (i = *(_DWORD **)(a3 + 8); i != (_DWORD *)(v98 + 36 * v97); i += 9)
    {
      if (*i)
        i[8] += *((_DWORD *)a1 + 72);
    }
    goto LABEL_117;
  }
  v87 = v84 == v77 && v86 == 0;
  if (!v87 && v86 * v85 >= (v85 + v79) << 10)
    goto LABEL_123;
LABEL_116:
  *(_DWORD *)(a3 + 228) = 0;
  v76 = v84;
LABEL_117:
  v89 = 15 - v71;
  if (v34 == 1)
  {
    v90 = v76 << v89;
  }
  else
  {
    v91 = ((v76 << v89) + (v34 << 16) - 0x10000) / v34;
    v36 = v76 <= (int)(v72 >> 1);
    v90 = ((unsigned __int16)v76 << v89) / (unsigned __int16)v34;
    if (!v36)
      LOWORD(v90) = v91;
  }
  *(_WORD *)(a3 + 84) = v90;
  call_cfsv_destruct(*a1, (uint64_t)v74);
  cstdlib_memcpy(__dst, v8, 4 * v21);
  cstdlib_memcpy(v103, v101, 4 * v21);
  *(_DWORD *)(a4 + 28) = v21;
  return 1;
}

uint64_t ComparePitches(uint64_t result, uint64_t a2, uint64_t a3, _WORD *a4)
{
  uint64_t v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;

  v7 = *(_QWORD *)(a3 + 64);
  if (v7)
    v8 = (int *)(v7 + 44);
  else
    v8 = (int *)(result + 308);
  if (*(_WORD *)(a2 + 48) && *(_WORD *)(a3 + 16))
  {
    v9 = *v8;
    v13 = 0;
    result = FindBestRationalFactor(*(unsigned __int16 *)(a3 + 18), *(unsigned __int16 *)(a2 + 50), (_DWORD *)&v13 + 1, &v13);
    v11 = v13;
    v10 = HIDWORD(v13);
    *(_DWORD *)(a3 + 24) = HIDWORD(v13);
    *(_DWORD *)(a2 + 80) = v11;
    v12 = ((v10 * *(unsigned __int16 *)(a3 + 18) + v11 * *(unsigned __int16 *)(a2 + 50)) * v9 + (v11 << 9))
        / (v11 << 10);
  }
  else
  {
    LOWORD(v12) = 0;
    *(_DWORD *)(a3 + 24) = 1;
    *(_DWORD *)(a2 + 80) = 1;
  }
  *a4 = v12;
  return result;
}

void *RandNormTable()
{
  return &alfNormalNoise;
}

uint64_t RandNorm(unsigned int *a1)
{
  unsigned int v1;

  v1 = 1664525 * *a1 + 1013904223;
  *a1 = v1;
  return alfNormalNoise[(v1 + (v1 >> 11))];
}

uint64_t Init_SinTable(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  int v5;
  unint64_t v6;
  void *v7;
  void *v8;

  if (a3)
    v3 = a3;
  else
    v3 = 512;
  if (v3 >= 0)
    v4 = v3;
  else
    v4 = v3 + 1;
  v5 = v4 >> 1;
  *(_DWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 20) = v3;
  *(_DWORD *)(a2 + 24) = v3 - 1;
  HIDWORD(v6) = v5;
  LODWORD(v6) = v5 - 32;
  switch((v6 >> 5))
  {
    case 0u:
      v7 = &asCos32;
      v8 = &asSin32;
      goto LABEL_13;
    case 1u:
      v7 = &asCos64;
      v8 = &asSin64;
      goto LABEL_13;
    case 3u:
      v7 = &asCos128;
      v8 = &asSin128;
      goto LABEL_13;
    case 7u:
      v7 = &asCos256;
      v8 = &asSin256;
LABEL_13:
      *(_QWORD *)a2 = v8;
      *(_QWORD *)(a2 + 8) = v7;
      break;
    default:
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      break;
  }
  return 0;
}

uint64_t PositiveShortLog2(int a1)
{
  uint64_t result;
  int v2;
  __int16 v3;

  if (a1 < 2)
    return 0;
  v2 = a1;
  if ((a1 & 0x4000) != 0)
    return 14;
  LODWORD(result) = 14;
  do
  {
    result = (result - 1);
    if (!(_DWORD)result)
      break;
    v3 = v2;
    v2 *= 2;
  }
  while ((v3 & 0x2000) == 0);
  return result;
}

uint64_t ipow2(unsigned int a1)
{
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  int v7;
  unsigned int v8;
  int v9;

  if ((a1 & 0x80000000) != 0)
    return a1 > 0xFFFFEFFF;
  if (a1 >> 12 > 0x1E)
    return 0x7FFFFFFFLL;
  v2 = a1 & 0xFFF;
  if ((a1 & 0xFFF) != 0)
  {
    v3 = 0;
    v4 = 0;
    LODWORD(v5) = 0x8000;
    do
    {
      v5 = ((unint64_t)(ipow2Table[v3 + (v2 & 0xF)] * v5) + 0x4000) >> 15;
      if (v4 > 1)
        break;
      ++v4;
      v3 += 16;
      v6 = v2 > 0xF;
      v2 >>= 4;
    }
    while (v6);
  }
  else
  {
    LODWORD(v5) = 0x8000;
  }
  v7 = 15 - (a1 >> 12);
  if (a1 >= 0xF000)
    LOBYTE(v7) = 0;
  v8 = v5 >> v7;
  v9 = (a1 >> 12) - 15;
  if (!HIWORD(a1))
    LOBYTE(v9) = 0;
  return v8 << v9;
}

uint64_t string2fixed(uint64_t a1, char *__s, int a3, _DWORD *a4)
{
  size_t v8;
  char *v9;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  char *v13;
  char *v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  BOOL v20;
  BOOL v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  BOOL v31;
  int v32;
  int v33;
  const char *v34;

  v34 = 0;
  v8 = cstdlib_strlen(__s) + 1;
  v9 = (char *)heap_Alloc(*(_QWORD *)(a1 + 8), v8);
  if (!v9)
    return 2;
  v10 = v9;
  cstdlib_memset(v9, 0, v8);
  cstdlib_strcpy(v10, __s);
  v11 = extstdlib_strtok_r(v10, " \t\r\n", &v34);
  if (!v11)
    return 1;
  v12 = (unsigned __int8 *)v11;
  v13 = cstdlib_strchr(v11, 46);
  if (v13)
  {
    v14 = v13;
    *v13 = 0;
    v15 = cstdlib_atol(v12);
    v18 = v14[1];
    v17 = (unsigned __int8 *)(v14 + 1);
    v16 = v18;
    v19 = 0;
    if ((v18 - 48) <= 9)
    {
      v21 = __OFSUB__(a3, 1);
      v20 = a3 - 1 < 0;
    }
    else
    {
      v21 = 0;
      v20 = 1;
    }
    if (v20 != v21)
    {
      v28 = 1;
    }
    else
    {
      v27 = 10 * a3;
      v28 = 1;
      do
      {
        v19 = v16 + 10 * v19 - 48;
        v28 *= 10;
        v29 = *++v17;
        v16 = v29;
        if ((v29 - 48) <= 9)
        {
          v31 = __OFSUB__(v28, v27);
          v30 = v28 - v27 < 0;
        }
        else
        {
          v31 = 0;
          v30 = 0;
        }
      }
      while (v30 != v31);
    }
    do
    {
      v33 = *v17++;
      v32 = v33;
    }
    while ((v33 - 48) < 0xA);
    if ((v32 | 0x20) == 0x65)
    {
      heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v10);
      return 1;
    }
    LODWORD(v26) = (int)(v19 * a3 + (v28 >> 1)) / v28 + v15 * a3;
  }
  else
  {
    v23 = cstdlib_atol(v12);
    v24 = 2 * a3 * v23;
    v25 = v24 + 2;
    if (((a3 * v23) & 0x4000000000000000) == 0)
      v25 = v24 | 1;
    v26 = v25 >> 1;
  }
  heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v10);
  result = 0;
  *a4 = v26;
  return result;
}

int *ScaleTo16BitSignedRange(int *result, int a2, int *a3, int *a4, char a5, int a6)
{
  int v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;

  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (a2)
  {
    if (a6 > 0)
      goto LABEL_37;
    if (a2 < 1)
    {
      a6 = -1;
LABEL_28:
      if (a3)
      {
        v13 = *a3;
        do
        {
          v14 = HIWORD(a6);
          a6 >>= 1;
          ++v13;
        }
        while (v14);
        *a3 = v13;
        if (v13 - 1 >= 0 && a2 >= 1)
        {
          v15 = a2;
          do
          {
            *result++ >>= *a3 + a5;
            --v15;
          }
          while (v15);
        }
      }
      return result;
    }
    v9 = a2;
    a6 = -1;
    v10 = result;
    do
    {
      v12 = *v10++;
      v11 = v12;
      if (v12 < 0)
        v11 = -v11;
      if (v11 > a6)
        a6 = v11;
      --v9;
    }
    while (v9);
    if (a6)
    {
LABEL_37:
      if (!(a6 >> 15))
      {
        if (a4)
        {
          v6 = *a4;
          if (!(a6 >> 14))
          {
            do
            {
              ++v6;
              v7 = a6 >= 0x2000;
              a6 *= 2;
            }
            while (!v7);
            *a4 = v6;
          }
          if (v6 >= 1 && a2 >= 1)
          {
            v8 = a2;
            do
            {
              *result++ <<= *a4;
              --v8;
            }
            while (v8);
          }
        }
        return result;
      }
      goto LABEL_28;
    }
  }
  return result;
}

uint64_t ScaleTo16BitSignedRangeWithSkip(uint64_t result, int a2, int a3, int *a4, int *a5, unsigned int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;

  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  if (a2)
  {
    v6 = a3 * a2;
    if (a6)
      goto LABEL_37;
    if (!a3)
    {
      a6 = -1;
LABEL_28:
      if (a4)
      {
        v12 = *a4;
        do
        {
          v13 = HIWORD(a6);
          a6 = (int)a6 >> 1;
          ++v12;
        }
        while (v13);
        *a4 = v12;
        if (v12 - 1 >= 0)
        {
          if (a3)
          {
            v14 = 0;
            do
            {
              *(_DWORD *)(result + v14) = ((1 << (*a4 - 1)) + *(int *)(result + v14)) >> *a4;
              v14 += a3;
            }
            while (v6 != v14);
          }
        }
      }
      return result;
    }
    v10 = 0;
    a6 = -1;
    do
    {
      v11 = *(_DWORD *)(result + v10);
      if (v11 < 0)
        v11 = -v11;
      if (v11 > (int)a6)
        a6 = v11;
      v10 += a3;
    }
    while (v6 != v10);
    if (a6)
    {
LABEL_37:
      if (!(a6 >> 15))
      {
        if (a5)
        {
          v7 = *a5;
          if (!(a6 >> 14))
          {
            do
            {
              ++v7;
              v8 = a6 >= 0x2000;
              a6 *= 2;
            }
            while (!v8);
            *a5 = v7;
          }
          if (v7 >= 1 && a3)
          {
            v9 = 0;
            do
            {
              *(_DWORD *)(result + v9) <<= *a5;
              v9 += a3;
            }
            while (v6 != v9);
          }
        }
        return result;
      }
      goto LABEL_28;
    }
  }
  return result;
}

uint64_t CalcSquareNormWthSkip(uint64_t a1, int a2, int a3, int a4, _DWORD *a5, int a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  _BOOL4 v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  v6 = a3 * a2;
  if (a3 * a2)
  {
    v7 = 0;
    LODWORD(v8) = 0;
    v9 = -1;
    do
    {
      v10 = *(_DWORD *)(a1 + v7);
      if (v10 > v9)
        v9 = *(_DWORD *)(a1 + v7);
      v8 = (v8 + v10 * v10);
      v7 += a3;
    }
    while (v6 != v7);
    if (v9 <= a4)
    {
      v11 = 0;
    }
    else
    {
      if (v9 < 46341)
      {
        v11 = 0;
      }
      else
      {
        v11 = 0;
        do
        {
          ++v11;
          v12 = v9 > 0x16A09;
          v9 = v9 >> 1;
        }
        while (v12);
      }
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = (*(int *)(a1 + v13) >> v11) * (*(int *)(a1 + v13) >> v11);
        v16 = (int)(v15 + v14) < 0;
        v17 = __CFADD__(v15, v14);
        v14 += v15;
        v18 = v17 || v16;
        v11 += v18;
        if (v18)
          v14 = (v14 >> 2) | 0x40000000;
        v13 += a3;
      }
      while (v6 != v13);
      v19 = 0;
      LODWORD(v8) = 0;
      do
      {
        v20 = *(int *)(a1 + v19);
        if (((1 << (v11 - 1)) & v20) != 0)
          v21 = ((int)v20 >> v11) + 1;
        else
          v21 = (int)v20 >> v11;
        if (!a6)
          *(_DWORD *)(a1 + v19) = v21;
        v8 = (v8 + v21 * v21);
        v19 += a3;
      }
      while (v6 != v19);
    }
  }
  else
  {
    v11 = 0;
    v8 = 0;
  }
  *a5 = v11;
  return v8;
}

uint64_t sqroot5(int *a1, unsigned int a2)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  if (!a1)
  {
    if (a2 >= 0x800000)
    {
      v6 = 1023;
      return *((unsigned int *)&astSqrtTbl + 2 * v6 + 1);
    }
    if (!a2)
    {
      v6 = 0;
      return *((unsigned int *)&astSqrtTbl + 2 * v6 + 1);
    }
    LODWORD(v3) = 0;
    goto LABEL_11;
  }
  v2 = a1[1];
  v3 = *a1;
  if (*((_DWORD *)&astSqrtTbl + 2 * v3) > a2)
    LODWORD(v3) = 0;
  v4 = *((_DWORD *)&astSqrtTbl + 2 * v2);
  if (v4 >= a2)
  {
    if (v4 > a2)
    {
      if (*((_DWORD *)&astSqrtTbl + 2 * (int)v3) >= a2)
      {
LABEL_29:
        v6 = (int)v3;
        *a1 = v3;
        return *((unsigned int *)&astSqrtTbl + 2 * v6 + 1);
      }
      goto LABEL_15;
    }
    v6 = v2;
LABEL_28:
    a1[1] = v2;
    return *((unsigned int *)&astSqrtTbl + 2 * v6 + 1);
  }
  if (a2 >= 0x800000)
  {
    v6 = 1023;
    v2 = 1023;
    goto LABEL_28;
  }
  if (*((_DWORD *)&astSqrtTbl + 2 * (int)v3) >= a2)
    goto LABEL_29;
LABEL_11:
  v2 = 1023;
LABEL_15:
  if (v2 - (int)v3 < 2)
  {
LABEL_21:
    if (a1)
    {
      *a1 = v3;
      a1[1] = v2;
    }
    v6 = (int)v3;
    if (a2 - *((_DWORD *)&astSqrtTbl + 2 * (int)v3) >= *((_DWORD *)&astSqrtTbl + 2 * v2) - a2)
      v6 = v2;
  }
  else
  {
    while (1)
    {
      v6 = (uint64_t)(int)(v2 + v3 + (v2 + (int)v3 < 0)) >> 1;
      v5 = *((_DWORD *)&astSqrtTbl + 2 * ((v2 + (int)v3) / 2));
      if (v5 == a2)
        break;
      if (v5 > a2)
        v2 = (v2 + (int)v3) / 2;
      else
        LODWORD(v3) = (v2 + (int)v3) / 2;
      if (v2 - (int)v3 <= 1)
        goto LABEL_21;
    }
  }
  return *((unsigned int *)&astSqrtTbl + 2 * v6 + 1);
}

double Init_SqrtSearch(_QWORD *a1)
{
  double result;

  *(_QWORD *)&result = 0x3FF00000000;
  *a1 = 0x3FF00000000;
  return result;
}

uint64_t GetInterpolatedValue(uint64_t a1, unsigned int *a2, int a3, int a4, _DWORD *a5, int a6)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t result;

  if (a5)
    LODWORD(v6) = *a5;
  else
    LODWORD(v6) = 0;
  if ((int)v6 >= a3)
    goto LABEL_16;
  v6 = (int)v6;
  while (*(_DWORD *)(a1 + 4 * v6) <= a4)
  {
    if (a3 == (_DWORD)++v6)
    {
      LODWORD(v6) = a3;
      goto LABEL_16;
    }
  }
  if ((int)v6 < 1)
  {
LABEL_16:
    if ((_DWORD)v6)
    {
      result = a2[a3 - 1];
      if (!a5)
        return result;
    }
    else
    {
      result = *a2;
      if (!a5)
        return result;
    }
    goto LABEL_20;
  }
  v7 = *(_DWORD *)(a1 + 4 * (v6 - 1));
  v8 = a2[(v6 - 1)];
  v9 = v6;
  v10 = *(_DWORD *)(a1 + v9 * 4);
  v11 = a2[v9];
  v12 = a4 - v7;
  if (!a6)
  {
    result = ((int)((v12 << 12) / (v10 - v7) * v11 + (4096 - (v12 << 12) / (v10 - v7)) * v8) / 4096);
    if (!a5)
      return result;
    goto LABEL_20;
  }
  if (v12 <= v10 - a4)
    result = v8;
  else
    result = v11;
  if (a5)
LABEL_20:
    *a5 = v6;
  return result;
}

uint64_t FixedRFFT(uint64_t result, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int *v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  char *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  int v104;
  uint64_t v105;

  v2 = result;
  if (a2 <= 127)
  {
    if (a2 == 32)
    {
      v69 = (char *)&RFFT_table_32;
      v3 = 5;
    }
    else
    {
      if (a2 != 64)
        return result;
      v69 = (char *)&RFFT_table_64;
      v3 = 6;
    }
  }
  else
  {
    switch(a2)
    {
      case 128:
        v69 = (char *)&RFFT_table_128;
        v3 = 7;
        break;
      case 256:
        v69 = (char *)&RFFT_table_256;
        v3 = 8;
        break;
      case 512:
        v69 = (char *)&RFFT_table_512;
        v3 = 9;
        break;
      default:
        return result;
    }
  }
  v67 = v3;
  v4 = 0;
  v5 = 0;
  v6 = (a2 - 1);
  do
  {
    if (v4 < v5)
    {
      v7 = *(_DWORD *)(result + 4 * v5);
      *(_DWORD *)(result + 4 * v5) = *(_DWORD *)(result + 4 * v4);
      *(_DWORD *)(result + 4 * v4) = v7;
    }
    v8 = a2;
    do
    {
      v9 = v5;
      v10 = v8 >> 1;
      v11 = __OFSUB__(v5, v8 >> 1);
      v5 -= v8 >> 1;
      v8 >>= 1;
    }
    while (v5 < 0 == v11);
    v5 = v9 + v10;
    ++v4;
  }
  while (v4 != v6);
  v12 = 0;
  v13 = (unsigned __int16)a2;
  v14 = 4;
  do
  {
    if (v12 < a2)
    {
      v15 = v12;
      v16 = (int *)(result + 4 + 4 * v12);
      do
      {
        v17 = *(v16 - 1) + *v16;
        v18 = v17 - 2 * *v16;
        *(v16 - 1) = v17;
        *v16 = v18;
        v15 += v14;
        v16 += v14;
      }
      while (v15 < (unsigned __int16)a2);
    }
    v12 = 2 * v14 - 2;
    v14 *= 4;
  }
  while (v12 < (int)v6);
  v19 = 2;
  v68 = 1;
  v105 = result;
  v94 = (unsigned __int16)a2;
  do
  {
    v75 = v19;
    v20 = 2 * v19;
    v83 = (2 * v19) >> 2;
    v81 = (2 * v19) >> 3;
    v70 = 4 * v19;
    v73 = 2 * v19;
    v21 = 0;
    v22 = 4 * v19;
    v88 = 2 * v83 + v81;
    do
    {
      v23 = v21;
      v24 = v22;
      v103 = 4 * v81 + 4 * v21;
      v25 = 4 * v22;
      v101 = v83 + (uint64_t)v81 + v21;
      v99 = v88 + v21;
      v26 = 8 * v83 + 4 * v21;
      v97 = v88 + v83 + v21;
      v27 = v2;
      v28 = v21;
      v29 = 12 * v83 + 4 * v21;
      v95 = v22;
      v92 = v25;
      do
      {
        v30 = *(_DWORD *)(v27 + v29) - *(_DWORD *)(v27 + v26);
        *(_DWORD *)(v27 + v29) = v30;
        v31 = *(_DWORD *)(v27 + 4 * v23) - (v30 + 2 * *(_DWORD *)(v27 + v26));
        *(_DWORD *)(v27 + v26) = v31;
        *(_DWORD *)(v27 + 4 * v23) = 2 * *(_DWORD *)(v27 + 4 * v23) - v31;
        if (v20 != 4)
        {
          v32 = QMul31(*(_DWORD *)(v27 + 4 * v99) - *(_DWORD *)(v27 + 4 * v97), 1518500250);
          v33 = *(_DWORD *)(v27 + 4 * v101);
          result = QMul31(*(_DWORD *)(v27 + 4 * v97) + *(_DWORD *)(v27 + 4 * v99), 1518500250);
          v25 = v92;
          v13 = v94;
          v24 = v95;
          v20 = v73;
          *(_DWORD *)(v27 + 4 * v97) = v33 - result;
          *(_DWORD *)(v27 + 4 * v99) = v33 - result - 2 * *(_DWORD *)(v27 + 4 * v101);
          *(_DWORD *)(v27 + 4 * v101) = *(_DWORD *)(v27 + v103) - v32;
          *(_DWORD *)(v27 + v103) += v32;
        }
        v28 += v24;
        v27 += v25;
      }
      while (v28 < v13);
      v21 = 2 * (v24 - v75);
      v22 = 4 * v24;
      v2 = v105;
    }
    while (v21 < a2);
    if (v20 >= 16)
    {
      if (v81 <= 2)
        v34 = 2;
      else
        v34 = v81;
      v71 = v34;
      v35 = 2 * v83 - 1;
      v36 = v35 + v83;
      v37 = 4 * v83 - 1;
      v38 = v83 - 1;
      v78 = 4;
      v79 = v83 + 1;
      v72 = 1;
      v77 = (2 * v83) | 1;
      v76 = v79 + 2 * v83;
      do
      {
        v39 = 0;
        v40 = (int *)&v69[16 * ((_DWORD)v72 << (v67 + ~(_BYTE)v68)) - 16];
        v41 = *v40;
        v42 = v70;
        v86 = v35;
        v85 = v36;
        v84 = v37;
        v80 = *v40;
        v82 = v38;
        do
        {
          v43 = v39;
          v96 = v42;
          v93 = v78 + 4 * v39;
          v90 = v79 + v39;
          v91 = 4 * v42;
          v44 = v2;
          v87 = v76 + v39;
          v89 = v77 + v39;
          do
          {
            v104 = v38 + v43;
            v102 = v35 + v43;
            v45 = v36 + v43;
            v46 = v37 + v43;
            v47 = QMul31(*(_DWORD *)(v44 + 4 * v89), v41);
            v48 = *(_DWORD *)(v2 + 4 * v45);
            v49 = v40[1];
            v100 = QMul31(v48, v49) + v47;
            v50 = QMul31(*(_DWORD *)(v105 + 4 * v45), v41);
            v98 = v50 - QMul31(*(_DWORD *)(v44 + 4 * v89), v49);
            v51 = v40[2];
            v52 = QMul31(*(_DWORD *)(v44 + 4 * v87), v51);
            v53 = v40[3];
            v54 = QMul31(*(_DWORD *)(v105 + 4 * v46), v53) + v52;
            v55 = QMul31(*(_DWORD *)(v105 + 4 * v46), v51);
            v56 = QMul31(*(_DWORD *)(v44 + 4 * v87), v53);
            v38 = v82;
            v37 = v84;
            v13 = v94;
            v57 = v55 - v56;
            v58 = v55 - v56 + v98;
            result = v102;
            v59 = *(_DWORD *)(v105 + 4 * (int)v102);
            v60 = v58 + v59;
            *(_DWORD *)(v44 + 4 * v89) = v58 - v59;
            v61 = v54 + v100;
            *(_DWORD *)(v105 + 4 * v46) = v60;
            v62 = v100 - v54;
            v2 = v105;
            v63 = *(_DWORD *)(v44 + 4 * v90);
            *(_DWORD *)(v105 + 4 * v45) = -v63 - v62;
            *(_DWORD *)(v44 + 4 * v87) = v63 - v62;
            v36 = v85;
            v64 = *(_DWORD *)(v44 + v93);
            *(_DWORD *)(v105 + 4 * (int)v102) = v64 - v61;
            *(_DWORD *)(v44 + v93) = v64 + v61;
            v35 = v86;
            v65 = v98 - v57;
            v41 = v80;
            v66 = *(_DWORD *)(v105 + 4 * v104);
            *(_DWORD *)(v105 + 4 * v104) = v66 - v65;
            *(_DWORD *)(v44 + 4 * v90) = v66 + v65;
            v43 += v96;
            v44 += v91;
          }
          while (v43 < v94);
          v39 = 2 * (v96 - v75);
          v42 = 4 * v96;
        }
        while (v39 < a2);
        v78 += 4;
        ++v79;
        ++v76;
        ++v77;
        v35 = v86 - 1;
        v36 = v85 - 1;
        v37 = v84 - 1;
        v38 = v82 - 1;
        ++v72;
      }
      while (v72 != v71);
    }
    v19 = v73;
    ++v68;
  }
  while (v68 != v67);
  return result;
}

int *FixedIRFFT(int *result, int a2)
{
  int *v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  int *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  int *v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  BOOL v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  char *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  int v112;
  int *v113;
  uint64_t v114;
  uint64_t v115;

  v2 = result;
  if (a2 <= 127)
  {
    if (a2 == 32)
    {
      v74 = (char *)&RFFT_table_32;
      v3 = 5;
    }
    else
    {
      if (a2 != 64)
        return result;
      v74 = (char *)&RFFT_table_64;
      v3 = 6;
    }
  }
  else
  {
    switch(a2)
    {
      case 128:
        v74 = (char *)&RFFT_table_128;
        v3 = 7;
        break;
      case 256:
        v74 = (char *)&RFFT_table_256;
        v3 = 8;
        break;
      case 512:
        v74 = (char *)&RFFT_table_512;
        v3 = 9;
        break;
      default:
        return result;
    }
  }
  v4 = 2 * a2;
  result = (int *)a2;
  v73 = 1;
  v113 = v2;
  v78 = a2;
  v102 = (int *)a2;
  v72 = v3;
  do
  {
    v79 = v4 >> 1;
    v5 = v4 >> 3;
    v84 = v4;
    v82 = v4 >> 4;
    v71 = (a2 - 1);
    v6 = 0;
    v95 = v82 + v5;
    v93 = v82 + 2 * v5;
    v91 = 8 * v5;
    v89 = 12 * v5;
    v87 = 3 * v5 + v82;
    v98 = v5;
    do
    {
      v7 = v6;
      v8 = v4;
      v114 = 4 * v82 + 4 * v6;
      v9 = 4 * v4;
      v111 = v95 + v6;
      v10 = v5 + v6;
      v109 = v93 + v6;
      v11 = v91 + 4 * v6;
      v103 = v87 + v6;
      v12 = v6;
      v13 = v89 + 4 * v6;
      v105 = v9;
      v107 = v4;
      v100 = v6;
      do
      {
        v14 = v2[v7];
        v15 = *(int *)((char *)v2 + v11);
        v2[v7] = v15 + v14;
        v2[v10] *= 2;
        v16 = v14 - v15;
        *(int *)((char *)v2 + v11) = v16 - 2 * *(int *)((char *)v2 + v13);
        *(int *)((char *)v2 + v13) = v16 + 2 * *(int *)((char *)v2 + v13);
        if ((_DWORD)v5 != 1)
        {
          v17 = QMul31(v2[v111] - *(int *)((char *)v2 + v114), 1518500250);
          v18 = QMul31(v2[v109] + v2[v103], 1518500250);
          v5 = v98;
          v7 = v100;
          v9 = v105;
          v8 = v107;
          *(int *)((char *)v2 + v114) += v2[v111];
          v2[v111] = v2[v103] - v2[v109];
          v2[v109] = -2 * (v18 + v17);
          v19 = v17 - v18;
          result = v102;
          v2[v103] = 2 * v19;
        }
        v12 += v8;
        v2 = (int *)((char *)v2 + v9);
      }
      while (v12 < (uint64_t)result);
      v6 = 2 * v8 - v79;
      v4 = 4 * v8;
      a2 = v78;
      v2 = v113;
    }
    while (v6 < v78);
    if (v84 >= 0x20)
    {
      v86 = 0;
      v75 = v84 & 0x7FFFFFFE;
      if (v82 <= 2)
        v20 = 2;
      else
        v20 = v82;
      v76 = v20;
      v21 = 2 * v5 - 1;
      v22 = v21 + v5;
      v23 = 4 * v5 - 1;
      v24 = v5 - 1;
      v83 = 4;
      v85 = v5 + 1;
      v77 = 1;
      v80 = v5 + 1 + 2 * v5;
      v81 = (2 * v5) | 1;
      v94 = v21;
      v92 = v21 + v5;
      v90 = v23;
      v88 = v5 - 1;
      do
      {
        v25 = 0;
        v26 = (int *)&v74[16 * ((_DWORD)v77 << (v73 - 1)) - 16];
        v27 = *v26;
        v28 = v75;
        v112 = *v26;
        do
        {
          v29 = v25;
          v104 = v28;
          v99 = 4 * v28;
          v101 = v83 + 4 * v25;
          v96 = v81 + v25;
          v97 = v85 + v25;
          v30 = v86 + v25;
          v31 = v2;
          v115 = v80 + v25;
          do
          {
            v32 = v21 + v30;
            v108 = v22 + v30;
            v110 = v23 + v30;
            v33 = *(int *)((char *)v31 + v101);
            v34 = v2[v21 + v30];
            v35 = v33 - v34;
            *(int *)((char *)v31 + v101) = v34 + v33;
            v36 = v2[v24 + v30];
            v37 = v31[v97];
            v38 = v36 - v37;
            v2[v24 + v30] = v37 + v36;
            v39 = v2[v110];
            v40 = v31[v96];
            v41 = v40 + v39;
            v2[v32] = v39 - v40;
            v42 = v31[v115];
            v43 = v2[v108];
            v31[v97] = v42 - v43;
            v44 = v35 - (v43 + v42);
            v106 = v43 + v42 + v35;
            v45 = v38 - v41;
            v46 = v41 + v38;
            v47 = QMul31(v44, v27);
            v48 = v26;
            v49 = v26[1];
            v31[v96] = QMul31(v45, v49) + v47;
            v50 = QMul31(v45, v112);
            v51 = v49;
            v26 = v48;
            v113[v108] = QMul31(v44, v51) - v50;
            v52 = v48[2];
            v53 = QMul31(v106, v52);
            v54 = v48[3];
            v31[v115] = v53 - QMul31(v46, v54);
            v55 = QMul31(v46, v52);
            v2 = v113;
            v56 = QMul31(v106, v54);
            v27 = v112;
            v24 = v88;
            v23 = v90;
            v22 = v92;
            v21 = v94;
            v113[v110] = v56 + v55;
            result = v102;
            v29 += v104;
            v31 = (int *)((char *)v31 + v99);
            v30 += v104;
          }
          while (v29 < (uint64_t)v102);
          v25 = 2 * v104 - v79;
          v28 = 4 * v104;
          a2 = v78;
        }
        while (v25 < v78);
        v83 += 4;
        ++v85;
        ++v80;
        ++v81;
        --v86;
        ++v77;
      }
      while (v77 != v76);
    }
    v4 = v79;
    ++v73;
  }
  while (v73 != v72);
  v57 = 0;
  v58 = 4;
  do
  {
    if (v57 < a2)
    {
      v59 = v57;
      v60 = &v2[v57 + 1];
      do
      {
        v61 = *(v60 - 1) + *v60;
        v62 = v61 - 2 * *v60;
        *(v60 - 1) = v61;
        *v60 = v62;
        v59 += v58;
        v60 += v58;
      }
      while (v59 < (uint64_t)result);
    }
    v57 = 2 * v58 - 2;
    v58 *= 4;
  }
  while (v57 < (int)v71);
  v63 = 0;
  v64 = 0;
  do
  {
    if (v63 < v64)
    {
      v65 = v2[v64];
      v2[v64] = v2[v63];
      v2[v63] = v65;
    }
    v66 = a2;
    do
    {
      v67 = v64;
      v68 = v66 >> 1;
      v69 = __OFSUB__(v64, v66 >> 1);
      v64 -= v66 >> 1;
      v66 >>= 1;
    }
    while (v64 < 0 == v69);
    v64 = v67 + v68;
    ++v63;
  }
  while (v63 != v71);
  v70 = a2;
  do
  {
    *v2++ >>= v72;
    --v70;
  }
  while (v70);
  return result;
}

uint64_t QMul31(int a1, int a2)
{
  unsigned int v2;
  int v3;
  unsigned int v4;

  if (a1 >= 0)
    v2 = a1;
  else
    v2 = -a1;
  v3 = (a1 >> 31) | 1;
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = -a2;
  if (a2 < 0)
    v3 = -v3;
  return ((((v4 & 0x7FFF) * (v2 >> 15) + (v4 >> 15) * (v2 & 0x7FFF)) >> 16) + (((v4 >> 15) * (v2 >> 15)) >> 1)) * v3;
}

uint64_t c_abs(uint64_t result)
{
  if ((int)result >= 0)
    return result;
  else
    return -(int)result;
}

uint64_t call_cfsv_construct(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4)
{
  uint64_t result;

  result = heap_Calloc(*(_QWORD **)(a1 + 8), 24, 1);
  if (result)
  {
    *(_WORD *)result = a3;
    *(_QWORD *)(result + 8) = a2;
    *(_DWORD *)(result + 16) = 0;
    *(_WORD *)(result + 20) = a4;
  }
  return result;
}

_QWORD *call_cfsv_destruct(_QWORD *result, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)(a2 + 8))
      return heap_Free((_QWORD *)result[1], a2);
  }
  return result;
}

uint64_t call_cfsv_rfft(__int16 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  __int16 v7;
  uint64_t v8;
  int v9;
  __int16 v10;

  if (*a1 < a2)
    return 0;
  result = 0;
  if (a2 <= 127)
  {
    if (a2 != 32 && a2 != 64)
      return result;
  }
  else if (a2 != 128 && a2 != 512 && a2 != 256)
  {
    return result;
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = (unsigned __int16)a2;
  do
  {
    v9 = ((int)c_abs(*(unsigned int *)(*((_QWORD *)a1 + 1) + 4 * v5)) >> v7) + v6;
    if (v9 <= 0x3FFFFFFF)
      v10 = v7;
    else
      v10 = v7 + 1;
    v7 = v10;
    v6 = v9 >> (v9 > 0x3FFFFFFF);
    ++v5;
  }
  while (v8 != v5);
  if (v10 >= 1)
    call_cfsv_setScale((unsigned __int16 *)a1, (__int16)(a1[10] - v10));
  FixedRFFT(*((_QWORD *)a1 + 1), a2);
  return 1;
}

unsigned __int16 *call_cfsv_setScale(unsigned __int16 *result, int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  char v5;
  char v6;
  _DWORD *v7;
  int *v8;

  v2 = result[10];
  if (v2 != (unsigned __int16)a2)
  {
    v3 = (__int16)v2;
    v4 = *result;
    v5 = v3 - a2;
    if (v3 >= a2)
    {
      if ((__int16)v4 >= 1)
      {
        v8 = (int *)*((_QWORD *)result + 1);
        do
        {
          *v8++ >>= v5;
          --v4;
        }
        while (v4);
      }
    }
    else if ((__int16)v4 >= 1)
    {
      v6 = a2 - v3;
      v7 = (_DWORD *)*((_QWORD *)result + 1);
      do
      {
        *v7++ <<= v6;
        --v4;
      }
      while (v4);
    }
    result[10] = a2;
  }
  return result;
}

uint64_t call_cfsv_rifft(__int16 *a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  __int16 v7;
  uint64_t v8;
  int v9;
  __int16 v10;

  if (*a1 < a2)
    return 0;
  result = 0;
  if (a2 <= 127)
  {
    if (a2 != 32 && a2 != 64)
      return result;
  }
  else if (a2 != 128 && a2 != 512 && a2 != 256)
  {
    return result;
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = (unsigned __int16)a2;
  do
  {
    v9 = ((int)c_abs(*(unsigned int *)(*((_QWORD *)a1 + 1) + 4 * v5)) >> v7) + v6;
    if (v9 <= 0x3FFFFFFF)
      v10 = v7;
    else
      v10 = v7 + 1;
    v7 = v10;
    v6 = v9 >> (v9 > 0x3FFFFFFF);
    ++v5;
  }
  while (v8 != v5);
  if (v10 >= 1)
    call_cfsv_setScale((unsigned __int16 *)a1, (__int16)(a1[10] - v10));
  FixedIRFFT(*((int **)a1 + 1), a2);
  return 1;
}

uint64_t call_cfsv_changeInputSampleOrder(unsigned __int16 *a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _DWORD *v10;
  _DWORD *v11;

  v2 = *a1;
  LODWORD(v3) = (int)(((_DWORD)v2 + (v2 >> 15)) << 16) >> 17;
  if ((__int16)v2 <= 1)
  {
    v3 = (int)v3;
  }
  else
  {
    v4 = 0;
    v3 = (int)v3;
    v5 = (_DWORD *)(*((_QWORD *)a1 + 1) + 36);
    v6 = (_DWORD *)(a2 + 16);
    v7 = (_DWORD *)(a2 + 4 * v2 - 16);
    do
    {
      *(v6 - 4) = *(v5 - 9);
      *(v6 - 3) = *(v5 - 7);
      *(v6 - 2) = *(v5 - 5);
      *(v6 - 1) = *(v5 - 3);
      *v6 = *(v5 - 1);
      v6[1] = v5[1];
      v6[2] = v5[3];
      v6[3] = v5[5];
      v7[3] = *(v5 - 6);
      v7[2] = *(v5 - 4);
      v7[1] = *(v5 - 2);
      *v7 = *v5;
      *(v7 - 1) = v5[2];
      *(v7 - 2) = v5[4];
      *(v7 - 3) = v5[6];
      if ((int)v4 + 7 < (int)v3 - 1)
        *(v7 - 4) = v5[8];
      v4 += 8;
      v5 += 16;
      v6 += 8;
      v7 -= 8;
    }
    while (v4 < (int)v3);
  }
  v8 = *((_QWORD *)a1 + 1);
  *(_DWORD *)(a2 + 4 * v3) = *(_DWORD *)(v8 + 4);
  if ((__int16)v2 >= 1)
  {
    v9 = 0;
    v10 = (_DWORD *)(a2 + 16);
    v11 = (_DWORD *)(v8 + 16);
    do
    {
      *(v11 - 4) = *(v10 - 4);
      *(v11 - 3) = *(v10 - 3);
      *(v11 - 2) = *(v10 - 2);
      *(v11 - 1) = *(v10 - 1);
      *v11 = *v10;
      v11[1] = v10[1];
      v11[2] = v10[2];
      v11[3] = v10[3];
      v9 += 8;
      v10 += 8;
      v11 += 8;
    }
    while (v9 < v2);
  }
  return 1;
}

uint64_t call_cfsv_changeOutputSampleOrder(unsigned __int16 *a1, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  _DWORD *v12;

  v2 = *a1;
  LODWORD(v3) = (int)(((_DWORD)v2 + (v2 >> 15)) << 16) >> 17;
  if ((__int16)v2 <= 1)
  {
    v3 = (int)v3;
  }
  else
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 1);
    v3 = (int)v3;
    v6 = a2 + 9;
    v7 = (_DWORD *)(v5 + 16);
    v8 = (_DWORD *)(v5 + 4 * v2 - 16);
    do
    {
      *(v6 - 9) = *(v7 - 4);
      *(v6 - 7) = *(v7 - 3);
      *(v6 - 5) = *(v7 - 2);
      *(v6 - 3) = *(v7 - 1);
      *(v6 - 1) = *v7;
      v6[1] = v7[1];
      v6[3] = v7[2];
      v6[5] = v7[3];
      *(v6 - 6) = v8[3];
      *(v6 - 4) = v8[2];
      *(v6 - 2) = v8[1];
      *v6 = *v8;
      v6[2] = *(v8 - 1);
      v6[4] = *(v8 - 2);
      v6[6] = *(v8 - 3);
      if ((int)v4 + 7 < (int)v3 - 1)
        v6[8] = *(v8 - 4);
      v7 += 8;
      v8 -= 8;
      v4 += 8;
      v6 += 16;
    }
    while (v4 < (int)v3);
  }
  v9 = *((_QWORD *)a1 + 1);
  a2[1] = *(_DWORD *)(v9 + 4 * v3);
  if ((__int16)v2 >= 1)
  {
    v10 = 0;
    v11 = a2 + 4;
    v12 = (_DWORD *)(v9 + 16);
    do
    {
      *(v12 - 4) = *(v11 - 4);
      *(v12 - 3) = *(v11 - 3);
      *(v12 - 2) = *(v11 - 2);
      *(v12 - 1) = *(v11 - 1);
      *v12 = *v11;
      v12[1] = v11[1];
      v12[2] = v11[2];
      v12[3] = v11[3];
      v10 += 8;
      v11 += 8;
      v12 += 8;
    }
    while (v10 < v2);
  }
  return 1;
}

uint64_t featex_bet5_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  int v6;
  const char *v7;
  uint64_t Voice;
  uint64_t USVoice;
  uint64_t VParam;
  uint64_t NNFeatexData;
  int v12;
  uint64_t v14;
  uint64_t v15;

  v3 = 2229280774;
  if ((safeh_HandleCheck(a1, a2, 415, 248) & 0x80000000) != 0)
    return 2229280776;
  v14 = 0;
  v15 = 0;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v6 = *(unsigned __int8 *)(v4 + 152);
    v5 = (const char *)(v4 + 152);
    if (v6)
      v7 = v5;
    else
      v7 = 0;
  }
  else
  {
    v7 = 0;
  }
  Voice = select_bet5_loadVoice(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 16), v7, (uint64_t)&v14, 0);
  if ((Voice & 0x80000000) != 0)
    return Voice;
  if (v14)
  {
    USVoice = select_bet5_GetUSVoice(v14, v15);
    *(_QWORD *)(a1 + 32) = USVoice;
    if (!USVoice)
      return v3;
  }
  else if (!*(_QWORD *)(a1 + 32))
  {
    return v3;
  }
  VParam = select_bet5_GetVParam(v14, v15);
  *(_QWORD *)(a1 + 40) = VParam;
  if (VParam)
  {
    NNFeatexData = select_bet5_GetNNFeatexData(v14, v15);
    *(_QWORD *)(a1 + 104) = NNFeatexData;
    if (NNFeatexData)
    {
      *(_QWORD *)(a1 + 112) = select_bet5_GetTransWeightRulesDiph(v14, v15, (_DWORD *)(a1 + 128));
      *(_QWORD *)(a1 + 120) = select_bet5_GetTransWeightRulesPhon(v14, v15, (_DWORD *)(a1 + 132));
      nnfeatex_DeInit((uint64_t *)(a1 + 88));
      v12 = nnfeatex_Init(a1 + 88, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 16));
      if (v12)
        return v12 | 0x84E02000;
      else
        return 0;
    }
  }
  return v3;
}

uint64_t featex_bet5_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t, char *, uint64_t, uint64_t, uint64_t);
  char *v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v7 = safeh_HandleCheck(a1, a2, 415, 248);
  if ((v7 & 0x80000000) != 0)
    return 2229280776;
  v8 = v7;
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 56) + 64))(a3, a4, 78, "application/x-realspeak-cspp-sptchk;version=4.0",
    0,
    0,
    a1 + 136);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 56) + 64))(a3, a4, 78, "application/x-realspeak-cspp-sgt;version=4.0",
         0,
         0,
         a1 + 152);
  v10 = 0;
  v11 = a1 + 168;
  do
  {
    switch((int)v10)
    {
      case 0:
        v12 = *(_QWORD *)(a1 + 56);
        v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, uint64_t, uint64_t, uint64_t))(v12 + 64);
        v14 = szOUTPUT_STREAMS_0[v10];
        v15 = (*(uint64_t (**)(uint64_t))(v12 + 152))(v9);
        v9 = v13(a3, a4, 207, v14, v15, 1, v11);
        goto LABEL_6;
      case 1:
      case 2:
      case 3:
        v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 56) + 64))(a3, a4, 207, szOUTPUT_STREAMS_0[v10], 0, 1, v11);
LABEL_6:
        v8 = v9;
        break;
      default:
        break;
    }
    if ((v8 & 0x80000000) != 0)
      break;
    v11 += 16;
  }
  while (v10++ < 3);
  if ((v8 & 0x80000000) != 0)
  {
    v17 = 0;
    v18 = *(_QWORD *)(a1 + 56);
    do
    {
      v19 = *(_QWORD *)(a1 + v17 + 168);
      if (v19)
        (*(void (**)(uint64_t, _QWORD))(v18 + 72))(v19, *(_QWORD *)(a1 + v17 + 176));
      v17 += 16;
    }
    while (v17 != 64);
  }
  return v8;
}

uint64_t featex_bet5_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v9;
  unsigned __int16 *v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int ProcessEnd;
  int v22;
  int v23;
  int v24;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int Process;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int16 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unsigned int v50;
  uint64_t v51;

  v51 = 0;
  v49 = 0;
  v9 = safeh_HandleCheck(a1, a2, 415, 248);
  if ((v9 & 0x80000000) != 0)
    return 2229280776;
  *a5 = 1;
  if (!*(_QWORD *)(a1 + 168))
    return v9;
  v50 = 0;
  v10 = *(unsigned __int16 **)(a1 + 240);
  cstdlib_memset(v10, 0, 0xE48uLL);
  v11 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)v10 = v11;
  if (!v11)
  {
    v13 = 0;
    v14 = -2065686522;
    goto LABEL_9;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 48) + 272))(a3, a4, 128, 3, 0, 0);
  v12 = nnfeatex_ProcessStart((uint64_t *)(a1 + 88), a3, a4, v10, &v49);
  if (v12)
  {
    v13 = 0;
    v14 = v12 | 0x84E02000;
    goto LABEL_9;
  }
  v14 = UNICORN__select_bet5_FeatureExtractProcessStart(*(uint64_t **)(a1 + 80), *(_QWORD *)(a1 + 32), a3, a4, v10, &v49);
  if (v14 < 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FEATEX_BET5", 55005, (uint64_t)"%s%x", v27, v28, v29, v30, "lhError");
    v13 = 0;
    goto LABEL_9;
  }
  if ((__int16)v10[5] > 1)
  {
    Process = UNICORN__select_bet5_FeatureExtractProcess(*(uint64_t **)(a1 + 80), *(_QWORD *)(a1 + 40), a3, a4, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), (_DWORD *)(a1 + 232), (uint64_t)v10, (uint64_t *)(a1 + 64), (unsigned int *)(a1 + 72));
    v13 = 1;
    if (Process < 0)
      goto LABEL_60;
    v37 = nnfeatex_Process((uint64_t *)(a1 + 88), a3, a4, (uint64_t)v10, (uint64_t)&v49, 0, &v51, &v50, 1);
    if (v37)
    {
      v14 = v37 | 0x84E02000;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FEATEX_BET5", 70001, (uint64_t)"%x", v38, v39, v40, v41, v37 | 0x84E02000);
      goto LABEL_9;
    }
    featex_bet5_loc_ApplyTransWeightRules(*(_QWORD *)(a1 + 112), *(_DWORD *)(a1 + 128), *(_QWORD *)(a1 + 120), *(_DWORD *)(a1 + 132), *(_QWORD *)(a1 + 32), (uint64_t)v10);
    if (log_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32)) >= 6)
      featex_bet5_loc_logFeatures(*(_QWORD *)(a1 + 16), (uint64_t)v10);
    featex_bet5_removeRAPColumns((void *)*(unsigned int *)(*(_QWORD *)(a1 + 32) + 3580), (uint64_t)v10, v51, v50);
    Process = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 104))(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176), *(_QWORD *)(a1 + 64), (32 * *(_DWORD *)(a1 + 72)));
    if (Process < 0
      || (Process = featex_bet5_serializeFeatures(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 192), (uint64_t *)v10), Process < 0))
    {
LABEL_60:
      v14 = Process;
      goto LABEL_9;
    }
    v42 = *(_QWORD *)(a1 + 32);
    v43 = v10[5];
    if (!*(_DWORD *)(v42 + 3580))
      v43 *= *(_WORD *)(v42 + 3578);
    v14 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 56) + 104))(*(_QWORD *)(a1 + 200), *(_QWORD *)(a1 + 208), v51, 4 * v43 * v50);
    if (v14 < 0
      || (v48 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 3608)) != 0
      && (v14 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 56) + 104))(*(_QWORD *)(a1 + 216), *(_QWORD *)(a1 + 224), v48, 4 * v10[5] * *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) + 3578)), v14 < 0))
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FEATEX_BET5", 70002, (uint64_t)"%s%s%s%x", v44, v45, v46, v47, "contentType");
      goto LABEL_9;
    }
  }
  else
  {
    v31 = v49;
    if (v49)
    {
      if (*(_QWORD *)(a1 + 168))
      {
        if (*((_DWORD *)v10 + 880))
        {
          v14 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 104))();
          if (v14 < 0)
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"FEATEX_BET5", 55008, (uint64_t)"%s%s%s%x", v32, v33, v34, v35, "contentType");
        }
      }
      v31 = 1;
    }
    *a5 = v31;
  }
  v13 = 1;
  if (v14 < 0 || v49)
  {
LABEL_9:
    for (i = 0; i != 64; i += 16)
    {
      v17 = a1 + i;
      v18 = *(_QWORD *)(a1 + i + 168);
      if (v18)
      {
        v19 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 56) + 72))(v18, *(_QWORD *)(v17 + 176));
        *(_QWORD *)(v17 + 168) = 0;
        if (v14 > -1 && v19 < 0)
          v14 = v19;
      }
    }
  }
  if (v13 && (v14 & 0x80000000) == 0)
  {
    ProcessEnd = UNICORN__select_bet5_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 80), v10);
    if (ProcessEnd >= 0)
      v22 = v14;
    else
      v22 = ProcessEnd;
    v23 = nnfeatex_ProcessEnd((uint64_t *)(a1 + 88), &v51, &v50);
    if (v23)
      v14 = v23 | 0x84E02000;
    else
      v14 = v22;
  }
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 48) + 64))(a3, a4);
  if (v14 > -1 && v24 < 0)
    v15 = v24;
  else
    v15 = v14;
  if (*(_DWORD *)(a1 + 72))
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), *(_QWORD *)(a1 + 64));
    *(_QWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return v15;
}

BOOL featex_bet5_loc_ApplyTransWeightRules(_BOOL8 result, int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  float *v12;
  unsigned int v13;
  uint64_t v14;
  float *v15;
  unsigned int v16;
  float *v17;
  float *v18;

  if (*(__int16 *)(a6 + 10) >= 1)
  {
    v9 = result;
    v10 = 0;
    v17 = (float *)(a3 + 8);
    v18 = (float *)(result + 8);
    do
    {
      if (a2)
      {
        v11 = 0;
        v12 = v18;
        do
        {
          result = featex_bet5_loc_TransRulesMatch(a5, v9, a6, (__int16)v10, v11);
          if (result)
          {
            v13 = *((unsigned __int8 *)v12 - 1) + v10 * *(unsigned __int16 *)(*(_QWORD *)a6 + 3360);
            *(_DWORD *)(*(_QWORD *)(a6 + 3584) + 4 * v13) = (float)((float)(*v12
                                                                                          * (float)*(unsigned int *)(*(_QWORD *)(a6 + 3584) + 4 * v13))
                                                                                  + 0.5);
          }
          ++v11;
          v12 += 3;
        }
        while (a2 != v11);
      }
      if (a4)
      {
        v14 = 0;
        v15 = v17;
        do
        {
          result = featex_bet5_loc_TransRulesMatch(a5, a3, a6, (__int16)v10, v14);
          if (result)
          {
            v16 = *((unsigned __int8 *)v15 - 1) + v10 * *(unsigned __int16 *)(*(_QWORD *)a6 + 3360);
            *(_DWORD *)(*(_QWORD *)(a6 + 3592) + 4 * v16) = (float)((float)(*v15
                                                                                          * (float)*(unsigned int *)(*(_QWORD *)(a6 + 3592) + 4 * v16))
                                                                                  + 0.5);
          }
          ++v14;
          v15 += 3;
        }
        while (a4 != v14);
      }
      ++v10;
    }
    while (v10 < *(__int16 *)(a6 + 10));
  }
  return result;
}

uint64_t featex_bet5_loc_logFeatures(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  const char *v9;
  size_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  uint64_t j;
  size_t v15;
  size_t v16;
  size_t v17;
  char v18[32];
  char __dst[256];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (*(__int16 *)(a2 + 10) >= 1)
  {
    v3 = result;
    LH_itoa(0xCFu, v18, 0xAu);
    for (i = 0; i != 5; ++i)
    {
      v5 = dword_214FA6800[i];
      v6 = a2 + 8 * v5;
      v8 = *(_QWORD *)(v6 + 16);
      v7 = (uint64_t *)(v6 + 16);
      v9 = "application/x-realspeak-u8-feat-";
      if (!v8)
      {
        v9 = "application/x-realspeak-u16-feat-";
        if (!*(_QWORD *)(a2 + 8 * v5 + 1760))
          continue;
      }
      cstdlib_strncpy(__dst, v9, 0x100uLL);
      v10 = cstdlib_strlen(__dst);
      LH_itoa(v5, &__dst[v10], 0xAu);
      v11 = *v7;
      if (!*v7)
        v11 = *(_QWORD *)(a2 + 8 * v5 + 1760);
      log_OutBinary(*(_QWORD *)(v3 + 32), (uint64_t)"FEATEX_BET5", 100, 0, (uint64_t)v18, (uint64_t)__dst, v11, *(unsigned __int16 *)(a2 + 10) << (*v7 == 0), 0);
    }
    LH_itoa(0x4Eu, v18, 0xAu);
    if (*(_QWORD *)(a2 + 504))
    {
      cstdlib_strncpy(__dst, "application/x-realspeak-u8-feat-", 0x100uLL);
      v12 = cstdlib_strlen(__dst);
      LH_itoa(0x3Du, &__dst[v12], 0xAu);
      log_OutBinary(*(_QWORD *)(v3 + 32), (uint64_t)"SELECT_BET5", 100, 0, (uint64_t)v18, (uint64_t)__dst, *(_QWORD *)(a2 + 504), *(unsigned __int16 *)(a2 + 10), 0);
    }
    if (*(_QWORD *)(a2 + 512))
    {
      cstdlib_strncpy(__dst, "application/x-realspeak-u8-feat-", 0x100uLL);
      v13 = cstdlib_strlen(__dst);
      LH_itoa(0x3Eu, &__dst[v13], 0xAu);
      log_OutBinary(*(_QWORD *)(v3 + 32), (uint64_t)"SELECT_BET5", 100, 0, (uint64_t)v18, (uint64_t)__dst, *(_QWORD *)(a2 + 512), *(unsigned __int16 *)(a2 + 10), 0);
    }
    for (j = 97; j != 123; ++j)
    {
      if (*(_QWORD *)(a2 + 8 * j))
      {
        cstdlib_strncpy(__dst, "application/x-realspeak-u8-feat-", 0x100uLL);
        v15 = cstdlib_strlen(__dst);
        LH_itoa(j - 2, &__dst[v15], 0xAu);
        log_OutBinary(*(_QWORD *)(v3 + 32), (uint64_t)"SELECT_BET5", 100, 0, (uint64_t)v18, (uint64_t)__dst, *(_QWORD *)(a2 + 8 * j), *(unsigned __int16 *)(a2 + 10), 0);
      }
    }
    cstdlib_strncpy(__dst, "application/x-realspeak-u32-feat-", 0x100uLL);
    v16 = cstdlib_strlen(__dst);
    LH_itoa(0x35u, &__dst[v16], 0xAu);
    log_OutBinary(*(_QWORD *)(v3 + 32), (uint64_t)"FEATEX_BET5", 100, 0, (uint64_t)v18, (uint64_t)__dst, *(_QWORD *)(a2 + 3584), 4 * *(unsigned __int16 *)(a2 + 10) * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360), 0);
    cstdlib_strncpy(__dst, "application/x-realspeak-u32-feat-", 0x100uLL);
    v17 = cstdlib_strlen(__dst);
    LH_itoa(0x36u, &__dst[v17], 0xAu);
    return log_OutBinary(*(_QWORD *)(v3 + 32), (uint64_t)"FEATEX_BET5", 100, 0, (uint64_t)v18, (uint64_t)__dst, *(_QWORD *)(a2 + 3592), 4 * *(unsigned __int16 *)(a2 + 10) * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360), 0);
  }
  return result;
}

void *featex_bet5_removeRAPColumns(void *result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  signed int v11;
  unsigned __int16 v12;
  unsigned int v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned __int16 *v19;
  int v20;
  void *v21;
  const void *v22;
  size_t v23;
  uint64_t v24;
  uint64_t i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v31;
  int v33;

  v31 = (int)result;
  v4 = *(__int16 *)(a2 + 10);
  if (v4 >= 1)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = (__int16)v4;
      v10 = (__int16)v4 - 1;
      if (v10 <= (int)v7)
      {
        v12 = v7;
        v11 = v7;
      }
      else
      {
        v11 = v7;
        v12 = v7;
        do
        {
          if (*(_DWORD *)(*(_QWORD *)(a2 + 3608) + 4 * v11 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3578)) != -2)
            break;
          v11 = (__int16)++v12;
        }
        while (v10 > (__int16)v12);
      }
      if (v7 != v12)
      {
        v13 = (unsigned __int16)(v4 - v11);
        if (v9 <= v11)
          v14 = 0;
        else
          v14 = v13;
        if (v8 >= v11)
        {
          v16 = (__int16)v12;
        }
        else
        {
          v15 = *(_QWORD *)(a2 + 1800);
          v16 = (__int16)v12;
          v17 = *(unsigned __int16 *)(v15 + 2 * (__int16)v12);
          v18 = v11;
          v19 = (unsigned __int16 *)(v15 + v6);
          do
          {
            v20 = *v19++;
            v17 += v20;
            *(_WORD *)(v15 + 2 * (__int16)v12) = v17;
            --v18;
          }
          while (v7 != v18);
        }
        if (v16 <= v7)
        {
          LOWORD(v4) = *(_WORD *)(a2 + 10);
        }
        else
        {
          v33 = v8;
          if (v31)
          {
            v21 = (void *)(a3 + 4 * v7 * a4);
            v22 = (const void *)(a3 + 4 * v12 * a4);
            v23 = a4 * (unint64_t)(4 * v14);
          }
          else
          {
            v24 = *(unsigned __int16 *)(*(_QWORD *)a2 + 3578);
            v21 = (void *)(a3 + 4 * v24 * a4 * v7);
            v22 = (const void *)(a3 + 4 * v24 * a4 * v12);
            v23 = a4 * (unint64_t)(4 * v14) * v24;
          }
          cstdlib_memmove(v21, v22, v23);
          for (i = 0; i != 1728; i += 8)
          {
            v26 = *(_QWORD *)(a2 + i + 32);
            if (v26)
              cstdlib_memmove((void *)(v26 + v7), (const void *)(v26 + v16), v14);
            v27 = *(_QWORD *)(a2 + i + 1776);
            if (v27)
              cstdlib_memmove((void *)(v27 + 2 * v7), (const void *)(v27 + 2 * v16), (2 * v14));
          }
          v28 = *(_QWORD *)(a2 + 3552);
          if (v28)
            cstdlib_memmove((void *)(v28 + 8 * v7), (const void *)(v28 + 8 * v16), (8 * v14));
          v29 = *(_QWORD *)(a2 + 3560);
          if (v29)
            cstdlib_memmove((void *)(v29 + 9 * v7), (const void *)(v29 + 9 * v16), (9 * v14));
          cstdlib_memmove((void *)(*(_QWORD *)(a2 + 3568) + 4 * v33 * *(unsigned __int16 *)(*(_QWORD *)a2 + 2966)), (const void *)(*(_QWORD *)(a2 + 3568) + 4 * v11 * *(unsigned __int16 *)(*(_QWORD *)a2 + 2966)), (4 * v14) * (unint64_t)*(unsigned __int16 *)(*(_QWORD *)a2 + 2966));
          cstdlib_memmove((void *)(*(_QWORD *)(a2 + 3576) + 4 * v33 * *(unsigned __int16 *)(*(_QWORD *)a2 + 2966)), (const void *)(*(_QWORD *)(a2 + 3576) + 4 * v11 * *(unsigned __int16 *)(*(_QWORD *)a2 + 2966)), (4 * v14) * (unint64_t)*(unsigned __int16 *)(*(_QWORD *)a2 + 2966));
          cstdlib_memmove((void *)(*(_QWORD *)(a2 + 3584) + 4 * v33 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360)), (const void *)(*(_QWORD *)(a2 + 3584) + 4 * v11 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360)), (4 * v14) * (unint64_t)*(unsigned __int16 *)(*(_QWORD *)a2 + 3360));
          cstdlib_memmove((void *)(*(_QWORD *)(a2 + 3592) + 4 * v33 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360)), (const void *)(*(_QWORD *)(a2 + 3592) + 4 * v11 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360)), (4 * v14) * (unint64_t)*(unsigned __int16 *)(*(_QWORD *)a2 + 3360));
          cstdlib_memmove((void *)(*(_QWORD *)(a2 + 3600) + *(unsigned __int16 *)(*(_QWORD *)a2 + 2966) * (uint64_t)v33), (const void *)(*(_QWORD *)(a2 + 3600) + *(unsigned __int16 *)(*(_QWORD *)a2 + 2966) * (uint64_t)v11), *(unsigned __int16 *)(*(_QWORD *)a2 + 2966) * (unint64_t)v14);
          result = cstdlib_memmove((void *)(*(_QWORD *)(a2 + 3608) + 4 * v33 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3578)), (const void *)(*(_QWORD *)(a2 + 3608) + 4 * v11 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3578)), (4 * v14) * (unint64_t)*(unsigned __int16 *)(*(_QWORD *)a2 + 3578));
          LOWORD(v4) = v7 - v12 + *(_WORD *)(a2 + 10);
          *(_WORD *)(a2 + 10) = v4;
        }
      }
      ++v7;
      v6 += 2;
      v8 = v7;
    }
    while (v7 < (__int16)v4);
  }
  return result;
}

uint64_t featex_bet5_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = safeh_HandleCheck(a1, a2, 415, 248);
  if ((v3 & 0x80000000) != 0)
    return 2229280776;
  v4 = v3;
  v5 = 0;
  v6 = *(_QWORD *)(a1 + 56);
  do
  {
    v7 = *(_QWORD *)(a1 + v5 + 168);
    if (v7)
      (*(void (**)(uint64_t, _QWORD))(v6 + 72))(v7, *(_QWORD *)(a1 + v5 + 176));
    v5 += 16;
  }
  while (v5 != 64);
  return v4;
}

uint64_t featex_bet5_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2229280769;
  result = 0;
  *a2 = &IFeatextract_0;
  return result;
}

BOOL featex_bet5_loc_TransRulesMatch(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  unsigned __int8 *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  char *v14;

  v8 = (unsigned __int8 *)(a2 + 12 * a5);
  if (!cstdlib_strchr(*(char **)(*(_QWORD *)(a1 + 3424) + 8 * *v8), *(unsigned __int8 *)(*(_QWORD *)(a3 + 32) + a4)))
    return 0;
  v9 = a4 + 1;
  if (!cstdlib_strchr(*(char **)(*(_QWORD *)(a1 + 3424) + 8 * v8[1]), *(unsigned __int8 *)(*(_QWORD *)(a3 + 32) + v9)))return 0;
  v10 = a4 ? *(unsigned __int8 *)(a4 + *(_QWORD *)(a3 + 32) - 1) : 35;
  if (!cstdlib_strchr(*(char **)(*(_QWORD *)(a1 + 3424) + 8 * v8[2]), v10))
    return 0;
  v11 = *(__int16 *)(a3 + 10) - 2;
  if (v11 != a4)
  {
    if (cstdlib_strchr(*(char **)(*(_QWORD *)(a1 + 3424) + 8 * v8[3]), *(unsigned __int8 *)(a4 + *(_QWORD *)(a3 + 32) + 2)))
    {
      goto LABEL_12;
    }
    v11 = *(__int16 *)(a3 + 10) - 2;
  }
  if (v11 != a4 || !cstdlib_strchr(*(char **)(*(_QWORD *)(a1 + 3424) + 8 * v8[3]), 35))
    return 0;
LABEL_12:
  if ((*(_DWORD *)(a1 + 3092) & 0x80000000) != 0)
    return 1;
  v12 = *(_QWORD *)(a1 + 3432);
  v13 = *(char **)(v12 + 8 * v8[4]);
  if (v13)
  {
    if (!cstdlib_strchr(v13, *(unsigned __int8 *)(*(_QWORD *)(a3 + 248) + a4) + 48))
      return 0;
    v12 = *(_QWORD *)(a1 + 3432);
  }
  v14 = *(char **)(v12 + 8 * v8[5]);
  return !v14 || cstdlib_strchr(v14, *(unsigned __int8 *)(*(_QWORD *)(a3 + 248) + v9) + 48);
}

uint64_t featex_bet5_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2229280775;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 416;
  }
  return result;
}

uint64_t featex_bet5_ClassClose()
{
  return 0;
}

uint64_t featex_bet5_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t Voice;
  uint64_t USVoice;
  uint64_t VParam;
  uint64_t NNFeatexData;
  uint64_t Object;
  uint64_t v24;
  int v25;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v31 = 0;
  v32 = 0;
  v29 = 0;
  v30 = 0;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  inited = InitRsrcFunction(a3, a4, &v32);
  if ((inited & 0x80000000) != 0)
    return inited;
  v10 = (_QWORD *)heap_Calloc(*(_QWORD **)(v32 + 8), 1, 248);
  if (!v10)
    goto LABEL_13;
  v15 = v10;
  *v10 = a3;
  v10[1] = a4;
  v16 = v32;
  v10[2] = v32;
  v10[3] = a1;
  v10[6] = 0;
  v17 = v10 + 6;
  v10[4] = 0;
  v10[7] = 0;
  v18 = heap_Calloc(*(_QWORD **)(v16 + 8), 1, 3656);
  v15[30] = v18;
  if (v18)
  {
    v28 = 0;
    LODWORD(v29) = 0;
    Voice = select_bet5_loadVoice(v15[3], v15[2], 0, (uint64_t)&v28, 0);
    if ((Voice & 0x80000000) != 0)
    {
LABEL_16:
      featex_bet5_ObjClose(*(_QWORD **)a5, *(_QWORD *)(a5 + 8));
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      return Voice;
    }
    USVoice = select_bet5_GetUSVoice(v28, v29);
    v15[4] = USVoice;
    if (USVoice)
    {
      VParam = select_bet5_GetVParam(v28, v29);
      v15[5] = VParam;
      if (VParam)
      {
        NNFeatexData = select_bet5_GetNNFeatexData(v28, v29);
        v15[13] = NNFeatexData;
        if (NNFeatexData)
        {
          v15[14] = select_bet5_GetTransWeightRulesDiph(v28, v29, (_DWORD *)v15 + 32);
          v15[15] = select_bet5_GetTransWeightRulesPhon(v28, v29, (_DWORD *)v15 + 33);
          Object = objc_GetObject(*(_QWORD *)(v32 + 48), (uint64_t)"LINGDB", &v30);
          if ((Object & 0x80000000) != 0
            || (*v17 = *(_QWORD *)(v30 + 8),
                Object = objc_GetObject(*(_QWORD *)(v32 + 48), (uint64_t)"SYNTHSTREAM", &v31),
                (Object & 0x80000000) != 0)
            || (v24 = *(_QWORD *)(v31 + 8),
                v15[7] = v24,
                Object = UNICORN__select_bet5_FeatureExtractObjOpen(a3, a4, v24, v15[6], v15 + 10),
                (Object & 0x80000000) != 0))
          {
            Voice = Object;
          }
          else
          {
            v25 = nnfeatex_Init((uint64_t)(v15 + 11), v15[6], v15[4], v15[13], v15[2]);
            if (!v25)
            {
              Voice = 0;
              *(_QWORD *)a5 = v15;
              *(_DWORD *)(a5 + 8) = 415;
              return Voice;
            }
            Voice = v25 | 0x84E02000;
          }
          goto LABEL_16;
        }
      }
    }
  }
  else
  {
LABEL_13:
    Voice = 2229280778;
    log_OutPublic(*(_QWORD *)(v32 + 32), (uint64_t)"FEATEX_BET5", 31000, 0, v11, v12, v13, v14, v27);
  }
  return Voice;
}

uint64_t featex_bet5_ObjClose(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t ObjClose;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 415, 248);
  if ((v3 & 0x80000000) != 0)
    return 2229280776;
  if (!a1)
    return v3;
  nnfeatex_DeInit(a1 + 11);
  ObjClose = UNICORN__select_bet5_FeatureExtractObjClose(a1[10]);
  if (a1[6])
    objc_ReleaseObject(*(_QWORD *)(a1[2] + 48), (uint64_t)"LINGDB");
  if (a1[7])
    objc_ReleaseObject(*(_QWORD *)(a1[2] + 48), (uint64_t)"SYNTHSTREAM");
  v5 = a1[4];
  if (v5)
  {
    v6 = a1[3];
    if (!v6 || (v7 = *(_QWORD *)(v6 + 48)) == 0)
      v7 = *(_QWORD *)(a1[2] + 48);
    objc_ReleaseObject(v7, v5 + 152);
  }
  v8 = a1[30];
  if (v8)
    heap_Free(*(_QWORD **)(a1[2] + 8), v8);
  heap_Free(*(_QWORD **)(a1[2] + 8), (uint64_t)a1);
  return ObjClose;
}

uint64_t featex_bet5_serializeFeatures(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t result;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  size_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  size_t v28;
  uint64_t v29;
  void *__dst;

  v9 = 0;
  v10 = 0;
  v11 = *a5;
  __dst = 0;
  v12 = v11 + 2748;
  do
  {
    v13 = *(unsigned __int8 *)(v12 + v9);
    if (*(_BYTE *)(v12 + v9))
    {
      if (v13 == 2)
      {
        v10 += 2;
      }
      else if (v13 == 1)
      {
        ++v10;
      }
      else if ((unsigned __int16)v9 - 53 <= 1)
      {
        v10 += 4 * *(unsigned __int16 *)(v11 + 3360);
      }
    }
    ++v9;
  }
  while (v9 != 218);
  v14 = *(_QWORD **)(v11 + 3336);
  if (v14 && *v14)
  {
    v15 = 0;
    v16 = v14 + 1;
    while (v16[v15++])
      ;
    v10 += v15;
  }
  else
  {
    LODWORD(v15) = 0;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, void **, _QWORD))(a2 + 112))(a3, a4, &__dst, v10 * *((unsigned __int16 *)a5 + 5));
  if ((result & 0x80000000) == 0)
  {
    v29 = a4;
    v19 = 0;
    v20 = (char *)__dst;
    v21 = v11 + 2748;
    while (1)
    {
      v22 = *(unsigned __int8 *)(v21 + v19);
      if (*(_BYTE *)(v21 + v19))
      {
        if (v22 == 2)
        {
          v25 = *((unsigned __int16 *)a5 + 5);
          cstdlib_memcpy(v20, (const void *)a5[v19 + 220], 2 * v25);
          v20 += 2 * v25;
        }
        else
        {
          if (v22 == 1)
          {
            v23 = *((unsigned __int16 *)a5 + 5);
            v24 = (const void *)a5[v19 + 2];
LABEL_28:
            cstdlib_memcpy(v20, v24, v23);
            v20 += v23;
            goto LABEL_29;
          }
          if ((unsigned __int16)v19 - 53 <= 1)
          {
            v23 = 4 * *((unsigned __int16 *)a5 + 5) * *(unsigned __int16 *)(v11 + 3360);
            if (v19 == 53)
              v26 = 448;
            else
              v26 = 449;
            v24 = (const void *)a5[v26];
            goto LABEL_28;
          }
        }
      }
LABEL_29:
      if (++v19 == 218)
      {
        if ((_DWORD)v15)
        {
          v27 = 0;
          do
          {
            v28 = *((unsigned __int16 *)a5 + 5);
            cstdlib_memcpy(v20, *(const void **)(a5[438] + 8 * (unsigned __int16)v27), v28);
            v20 += v28;
            ++v27;
          }
          while (v15 > (unsigned __int16)v27);
        }
        return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a2 + 120))(a3, v29, v10 * *((unsigned __int16 *)a5 + 5));
      }
    }
  }
  return result;
}

uint64_t UnicornAddon_Init(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  float *v30;
  float v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;

  *(_QWORD *)(a5 + 8) = a2;
  *(_QWORD *)(a5 + 16) = a3;
  *(_DWORD *)(a5 + 24) = a4;
  if (!*(_DWORD *)(*(_QWORD *)(a2 + 568) + 6692) || !*(_DWORD *)(*(_QWORD *)(a3 + 568) + 6692))
    return 0;
  v9 = 2229280778;
  v10 = *(_DWORD *)(a2 + 2452);
  v11 = *(_DWORD *)(a3 + 2452);
  if (v10 >= v11)
    v12 = v11;
  else
    v12 = v10;
  v13 = heap_Calloc(*(_QWORD **)(a1 + 8), *(unsigned int *)(a3 + 2448), 4);
  if (v13)
  {
    v14 = v13;
    v15 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * *(unsigned int *)(a3 + 2448));
    if (v15)
    {
      v16 = (uint64_t)v15;
      v17 = *(unsigned int *)(a3 + 2448);
      if ((_DWORD)v17)
        memset_pattern16(v15, &unk_214FA6820, 4 * v17);
      v18 = heap_Calloc(*(_QWORD **)(a1 + 8), *(unsigned int *)(a2 + 2448), 4);
      if (v18)
      {
        v19 = v18;
        v20 = (void *)heap_Alloc(*(_QWORD *)(a1 + 8), 4 * *(unsigned int *)(a2 + 2448));
        if (v20)
        {
          v21 = (uint64_t)v20;
          v22 = *(unsigned int *)(a2 + 2448);
          if ((_DWORD)v22)
            memset_pattern16(v20, &unk_214FA6820, 4 * v22);
          v23 = *(unsigned int *)(a3 + 2448);
          if ((_DWORD)v23)
          {
            v24 = 0;
            LODWORD(v25) = v22;
            do
            {
              if ((_DWORD)v25)
              {
                v26 = 0;
                v27 = *(_QWORD *)(a3 + 2440);
                v28 = *(_QWORD *)(a2 + 2440);
                do
                {
                  if ((_DWORD)v12)
                  {
                    v29 = (float *)(v28 + 4 * (*(_DWORD *)(a2 + 2452) * v26));
                    v30 = (float *)(v27 + 4 * (v24 * *(_DWORD *)(a3 + 2452)));
                    v31 = 0.0;
                    v32 = v12;
                    do
                    {
                      v33 = *v30++;
                      v34 = v33;
                      v35 = *v29++;
                      v31 = v31 + (float)((float)(v34 - v35) * (float)(v34 - v35));
                      --v32;
                    }
                    while (v32);
                  }
                  else
                  {
                    v31 = 0.0;
                  }
                  if (v31 < *(float *)(v16 + 4 * v24))
                  {
                    *(_DWORD *)(v14 + 4 * v24) = v26;
                    *(float *)(v16 + 4 * v24) = v31;
                  }
                  if (v31 < *(float *)(v21 + 4 * v26))
                  {
                    *(_DWORD *)(v19 + 4 * v26) = v24;
                    *(float *)(v21 + 4 * v26) = v31;
                  }
                  ++v26;
                  v25 = *(unsigned int *)(a2 + 2448);
                }
                while (v26 < v25);
                v23 = *(unsigned int *)(a3 + 2448);
              }
              ++v24;
            }
            while (v24 < v23);
          }
          *(_QWORD *)(a5 + 32) = v19;
          *(_QWORD *)(a5 + 40) = v14;
          heap_Free(*(_QWORD **)(a1 + 8), v16);
          heap_Free(*(_QWORD **)(a1 + 8), v21);
          return 0;
        }
      }
    }
  }
  return v9;
}

_QWORD *UnicornAddon_Deinit(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 40);
  if (v4)
    result = heap_Free((_QWORD *)result[1], v4);
  v5 = *(_QWORD *)(a2 + 32);
  if (v5)
    return heap_Free((_QWORD *)v3[1], v5);
  return result;
}

uint64_t UnicornAddon_UID2AddonId(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t result;
  unint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  result = 0xFFFFFFFFLL;
  if (a1 && a3 != -1 && a2 >= 1)
  {
    v5 = 0;
    v6 = (unsigned int *)(a1 + 24);
    do
    {
      v7 = *v6;
      v6 += 12;
      if (v7 > a3)
        break;
      ++v5;
    }
    while (v5 < a2);
    return (v5 - 1);
  }
  return result;
}

_QWORD *UnicornPipelineFactory_Create(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)();
  BOOL (*v13)(uint64_t);
  const char *v14;
  uint64_t (*v15)(uint64_t, int);
  uint64_t (*v16)(uint64_t, int);
  void *v17;
  uint64_t (*v18)(uint64_t);
  uint64_t (*v19)(uint64_t);
  uint64_t (*v20)(uint64_t, int);
  uint64_t (*v21)(uint64_t, _DWORD *);
  void *v22;
  void *v23;
  uint64_t (*v24)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, int);
  uint64_t v25;

  v8 = heap_Calloc(*(_QWORD **)(a2 + 8), 1, 112);
  v9 = (_QWORD *)v8;
  if (v8)
  {
    *(_QWORD *)(v8 + 8) = a2;
    if (a1 == 1)
    {
      v25 = heap_Calloc(*(_QWORD **)(a2 + 8), 1, 240);
      if (v25)
      {
        v11 = v25;
        if ((UnicornPipelineMT_Create(v25, a2, a3, a4) & 0x80000000) == 0)
        {
          v12 = UnicornPipelineMT_isMultiThreaded;
          v13 = UnicornPipelineMT_isDone;
          v14 = "Unicorn Pipeline is MULTITHREAD";
          v15 = UnicornPipelineMT_SetSIMDCallbacks;
          v16 = UnicornPipelineMT_SetForcedEEEnabled;
          v17 = UnicornPipelineMT_GetForcedEEEnabled;
          v18 = UnicornPipelineMT_GetStream;
          v19 = UnicornPipelineMT_GetPreparedCount;
          v20 = UnicornPipelineMT_SynthesizeDummy;
          v21 = UnicornPipelineMT_ProcessPhoneme;
          v22 = UnicornPipelineMT_Destroy;
          v23 = UnicornPipelineMT_Release;
          v24 = UnicornPipelineMT_Init;
          goto LABEL_11;
        }
      }
    }
    else if (!a1)
    {
      v10 = heap_Calloc(*(_QWORD **)(a2 + 8), 1, 200);
      if (v10)
      {
        v11 = v10;
        if ((UnicornPipeline_Create(v10, a2, a3, a4) & 0x80000000) == 0)
        {
          v12 = UnicornPipeline_isMultiThreaded;
          v13 = UnicornPipeline_isDone;
          v14 = "Unicorn Pipeline is STANDARD SINGLETHREAD";
          v15 = UnicornPipeline_SetSIMDCallbacks;
          v16 = UnicornPipeline_SetForcedEEEnabled;
          v17 = UnicornPipeline_GetForcedEEEnabled;
          v18 = UnicornPipeline_GetStream;
          v19 = UnicornPipeline_GetPreparedCount;
          v20 = UnicornPipeline_SynthesizeDummy;
          v21 = UnicornPipeline_ProcessPhoneme;
          v22 = UnicornPipeline_Destroy;
          v23 = UnicornPipeline_Release;
          v24 = UnicornPipeline_Init;
LABEL_11:
          v9[2] = v24;
          v9[3] = v23;
          v9[4] = v22;
          v9[5] = v21;
          v9[6] = v20;
          v9[7] = v19;
          v9[8] = v18;
          v9[9] = v17;
          v9[10] = v16;
          v9[11] = v15;
          v9[12] = v13;
          v9[13] = v12;
          *v9 = v11;
          UNICORN__log_select_Diag(a2, 3, (uint64_t)v14);
          return v9;
        }
      }
    }
    return 0;
  }
  return v9;
}

uint64_t UnicornPipelineClass_Init(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 2229280776;
  else
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(*(_QWORD *)a1, a3, a4, a5, a6, a7);
}

uint64_t UnicornPipelineClass_Release(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 2229280776;
  else
    return (*(uint64_t (**)(_QWORD))(a1 + 24))(*(_QWORD *)a1);
}

uint64_t UnicornPipelineClass_Destroy(uint64_t a1, int a2)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;

  v2 = (uint64_t *)a1;
  v3 = safeh_HandleCheck(a1, a2, 135969, 112);
  if (v3 < 0)
    v2 = 0;
  if (v3 < 0)
    return 2229280776;
  v4 = ((uint64_t (*)(uint64_t))v2[4])(*v2);
  if (*v2)
    heap_Free(*(_QWORD **)(v2[1] + 8), *v2);
  *v2 = 0;
  heap_Free(*(_QWORD **)(v2[1] + 8), (uint64_t)v2);
  return v4;
}

uint64_t UnicornPipelineClass_ProcessPhoneme(uint64_t a1, int a2, uint64_t a3)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 2229280776;
  else
    return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 40))(*(_QWORD *)a1, a3);
}

uint64_t UnicornPipelineClass_SynthesizeDummy(uint64_t a1, int a2, uint64_t a3)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 2229280776;
  else
    return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(*(_QWORD *)a1, a3);
}

uint64_t UnicornPipelineClass_GetPreparedCount(uint64_t a1, int a2)
{
  safeh_HandleCheck(a1, a2, 135969, 112);
  return (*(uint64_t (**)(_QWORD))(a1 + 56))(*(_QWORD *)a1);
}

uint64_t UnicornPipelineClass_GetStream(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 0;
  else
    return (*(uint64_t (**)(_QWORD))(a1 + 64))(*(_QWORD *)a1);
}

uint64_t UnicornPipelineClass_GetForcedEEEnabled(uint64_t a1, int a2)
{
  safeh_HandleCheck(a1, a2, 135969, 112);
  return (*(uint64_t (**)(_QWORD))(a1 + 72))(*(_QWORD *)a1);
}

uint64_t UnicornPipelineClass_SetForcedEEEnabled(uint64_t a1, int a2, uint64_t a3)
{
  safeh_HandleCheck(a1, a2, 135969, 112);
  return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 80))(*(_QWORD *)a1, a3);
}

uint64_t UnicornPipelineClass_SetSIMDCallbacks(uint64_t a1, int a2, uint64_t a3)
{
  safeh_HandleCheck(a1, a2, 135969, 112);
  return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 88))(*(_QWORD *)a1, a3);
}

uint64_t UnicornPipelineClass_isDone(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 0;
  else
    return (*(uint64_t (**)(_QWORD))(a1 + 96))(*(_QWORD *)a1);
}

uint64_t UnicornPipelineClass_isMultiThreaded(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 135969, 112) & 0x80000000) != 0)
    return 0;
  else
    return (*(uint64_t (**)(_QWORD))(a1 + 104))(*(_QWORD *)a1);
}

float UNICORN__mfsLLCost(float a1, float a2)
{
  return (float)(a1 * a2) * (float)(a1 * a2);
}

float UNICORN__mfsLLCostVar(float a1, float a2)
{
  return (float)(a1 * a1) * a2;
}

float UNICORN__mfsProbToPenalty(float a1, float a2)
{
  float v2;
  float v3;

  v2 = (float)(a2 * 0.39894) * expf((float)((float)(a1 * a2) * (float)(a1 * a2)) * -0.5);
  v3 = 20.0;
  if (v2 > 1.0e-10)
  {
    v3 = 0.0;
    if (v2 < 0.9)
      return fabsf(logf(v2)) / 2.3026;
  }
  return v3;
}

float UNICORN__mfsLogLikelihood(float a1, float a2)
{
  float v3;
  float v4;

  v3 = -(float)(a1 * a1);
  v4 = UNICORN__bet5_finv(a2);
  return -(float)(logf(v4) - (float)(v3 * a2));
}

char *UNICORN__mfs_InitParam(uint64_t a1)
{
  _OWORD *v2;
  __int128 v3;
  char *result;
  unint64_t v5;
  float *v6;
  uint64x2_t v7;
  int32x2_t v8;

  v2 = (_OWORD *)(a1 + 6132);
  cstdlib_memset((void *)a1, 0, 0x2D88uLL);
  *(_QWORD *)(a1 + 11520) = 0;
  *(_DWORD *)(a1 + 11544) = 100000;
  *(_QWORD *)(a1 + 11536) = 0;
  *(_DWORD *)(a1 + 11488) = 0;
  *(_DWORD *)(a1 + 5048) = 0;
  *(_QWORD *)(a1 + 5548) = -4294965296;
  *(_DWORD *)(a1 + 5592) = 0;
  *(_QWORD *)(a1 + 5556) = 0x3F8000003F800000;
  *(_DWORD *)(a1 + 5564) = 2000;
  *(_OWORD *)(a1 + 5504) = xmmword_214FA6840;
  *(_QWORD *)(a1 + 6120) = 0x3C00000001;
  *(_DWORD *)(a1 + 6128) = 1112014848;
  *v2 = xmmword_214FA6850;
  *(_QWORD *)(a1 + 6148) = 0x7530000000C8;
  *(_DWORD *)(a1 + 6156) = 1056964608;
  *(_QWORD *)(a1 + 6160) = 0x4248000040600000;
  *(_QWORD *)(a1 + 6664) = 0x186A0FFFFFFFFLL;
  *(_QWORD *)(a1 + 6192) = 3212836864;
  *(_DWORD *)(a1 + 6200) = 0;
  *(_OWORD *)(a1 + 6616) = 0u;
  *(_QWORD *)&v3 = -1;
  *((_QWORD *)&v3 + 1) = -1;
  *(_OWORD *)(a1 + 6584) = v3;
  *(_OWORD *)(a1 + 6600) = v3;
  *(_OWORD *)(a1 + 6552) = v3;
  *(_OWORD *)(a1 + 6568) = v3;
  *(_OWORD *)(a1 + 6520) = v3;
  *(_OWORD *)(a1 + 6536) = v3;
  *(_OWORD *)(a1 + 6488) = v3;
  *(_OWORD *)(a1 + 6504) = v3;
  *(_OWORD *)(a1 + 6456) = v3;
  *(_OWORD *)(a1 + 6472) = v3;
  *(_OWORD *)(a1 + 6424) = v3;
  *(_OWORD *)(a1 + 6440) = v3;
  *(_OWORD *)(a1 + 6392) = v3;
  *(_OWORD *)(a1 + 6408) = v3;
  *(_OWORD *)(a1 + 6360) = v3;
  *(_OWORD *)(a1 + 6376) = v3;
  *(_OWORD *)(a1 + 6328) = v3;
  *(_OWORD *)(a1 + 6344) = v3;
  *(_OWORD *)(a1 + 6296) = v3;
  *(_OWORD *)(a1 + 6312) = v3;
  *(_OWORD *)(a1 + 6264) = v3;
  *(_OWORD *)(a1 + 6280) = v3;
  *(_OWORD *)(a1 + 6232) = v3;
  *(_OWORD *)(a1 + 6248) = v3;
  *(_DWORD *)(a1 + 6632) = 200;
  *(_OWORD *)(a1 + 6636) = xmmword_214FA6860;
  *(_DWORD *)(a1 + 6652) = 1084647014;
  *(_QWORD *)(a1 + 6656) = 0x40A6666640BCCCCDLL;
  *(_QWORD *)(a1 + 5980) = 0;
  *(_QWORD *)(a1 + 5992) = 1;
  *(_QWORD *)(a1 + 6000) = 0x4000000000000000;
  v2[34] = xmmword_214FA6870;
  *(_DWORD *)(a1 + 6692) = 0;
  *(_QWORD *)(a1 + 6696) = 0x300000000;
  *(_QWORD *)(a1 + 6704) = 0;
  *(_DWORD *)(a1 + 6712) = 0;
  *(_DWORD *)(a1 + 6672) = 1123942400;
  *(_QWORD *)(a1 + 6744) = 0;
  *(_OWORD *)(a1 + 6728) = 0u;
  *(_DWORD *)(a1 + 6764) = 0;
  *(_DWORD *)(a1 + 6772) = 3;
  *(_QWORD *)(a1 + 6776) = 1056964608;
  *(_QWORD *)(a1 + 6784) = 1065353216;
  *(_DWORD *)(a1 + 5568) = 1084227584;
  *(_QWORD *)(a1 + 5576) = 0x447A0000000003B6;
  *(_QWORD *)(a1 + 5584) = 0x4120000000000000;
  v2[335] = xmmword_214FA6880;
  *(_DWORD *)(a1 + 11508) = 4000;
  *(_QWORD *)(a1 + 11512) = 0x7D000000FA0;
  *(_DWORD *)(a1 + 5924) = 9;
  *(_QWORD *)(a1 + 5928) = 0x1400000001;
  UNICORN__InitVParam((_DWORD *)a1);
  result = cstdlib_strcpy((char *)(a1 + 5072), "mfs");
  v5 = 0;
  *(_DWORD *)(a1 + 5524) = 1056964608;
  *(_DWORD *)(a1 + 10464) = 1065353216;
  v6 = (float *)(a1 + 10472);
  v7.i64[0] = 255;
  v7.i64[1] = 255;
  do
  {
    v8 = vmovn_s64((int64x2_t)vcgtq_u64(v7, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v5), (int8x16_t)xmmword_214F962F0)));
    if ((v8.i8[0] & 1) != 0)
      *(v6 - 1) = 1.0 / (float)(v5 + 1);
    if ((v8.i8[4] & 1) != 0)
      *v6 = 1.0 / (float)(v5 + 2);
    v5 += 2;
    v6 += 2;
  }
  while (v5 != 256);
  return result;
}

void *UNICORN__mfs_DeInitParam(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  UNICORN__DeInitVParam(a1, a2);
  v4 = a2[677];
  if (v4)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v4);
    a2[677] = 0;
  }
  v5 = a2[1301];
  if (v5)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v5);
    a2[1301] = 0;
  }
  v6 = a2[1302];
  if (v6)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v6);
    a2[1302] = 0;
  }
  v7 = a2[1303];
  if (v7)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v7);
    a2[1303] = 0;
  }
  v8 = a2[1304];
  if (v8)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v8);
    a2[1304] = 0;
  }
  v9 = a2[1305];
  if (v9)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v9);
    a2[1305] = 0;
  }
  v10 = a2[1306];
  if (v10)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v10);
    a2[1306] = 0;
  }
  v11 = a2[1307];
  if (v11)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v11);
    a2[1307] = 0;
  }
  v12 = a2[776];
  if (v12)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v12);
    a2[776] = 0;
  }
  v13 = a2[777];
  if (v13)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v13);
    a2[777] = 0;
  }
  v14 = a2[778];
  if (v14)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v14);
    a2[778] = 0;
  }
  return cstdlib_memset(a2, 0, 0x2D88uLL);
}

const char *BET5_Param_GetInfo(char *__s2, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  const char *result;
  char **v8;
  const char *v9;
  char **v10;

  v6 = 0;
  result = "F_PRUNE_DUR_OUTLIER_DIST_PARAM1";
  v8 = &off_24D2946F0;
  do
  {
    result = (const char *)cstdlib_strcmp(result, __s2);
    if (!(_DWORD)result)
      break;
    ++v6;
    v9 = *v8;
    v8 += 2;
    result = v9;
  }
  while (v6 != 7);
  v10 = &(&auxTableParamInfo)[2 * v6];
  *a2 = *((_DWORD *)v10 + 2);
  *a3 = *((_DWORD *)v10 + 3);
  return result;
}

uint64_t BET5_Param_GetType(int a1)
{
  uint64_t v1;
  int *v2;
  int v3;

  v1 = 0;
  v2 = &dword_24D2946E8;
  while (1)
  {
    v3 = *v2;
    v2 += 4;
    if (v3 == a1)
      break;
    if ((_DWORD)++v1 == 7)
    {
      v1 = 7;
      return *((unsigned int *)&auxTableParamInfo + 4 * v1 + 3);
    }
  }
  return *((unsigned int *)&auxTableParamInfo + 4 * v1 + 3);
}

float BET5_Param_GetGlobalValue(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  float *v4;
  float result;

  switch(a2)
  {
    case 1:
      v3 = 6168;
      goto LABEL_9;
    case 2:
      v3 = 6172;
      goto LABEL_9;
    case 3:
      v3 = 6776;
      goto LABEL_9;
    case 4:
      v3 = 6176;
      goto LABEL_9;
    case 5:
      v3 = 6180;
      goto LABEL_9;
    case 6:
      v3 = 6184;
      goto LABEL_9;
    case 7:
      v3 = 6188;
LABEL_9:
      v4 = (float *)(a1 + v3);
      result = *v4;
      *a3 = *(_DWORD *)v4;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t select_bet5_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2229280769;
  result = 0;
  *a2 = &ISelect_Bet5;
  return result;
}

uint64_t select_bet5_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2229280775;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 135967;
  }
  return result;
}

uint64_t select_bet5_ClassClose()
{
  return 0;
}

uint64_t select_bet5_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, int a4, uint64_t *a5)
{
  uint64_t inited;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Voice;
  uint64_t v16;
  _BYTE *v17;
  uint64_t UnicornPipeline;
  _QWORD v20[3];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = 0;
  v23 = 0;
  v24 = 0;
  v22 = 0;
  *a5 = 0;
  *((_DWORD *)a5 + 2) = 0;
  inited = InitRsrcFunction(a3, a4, &v25);
  if ((inited & 0x80000000) != 0)
    return inited;
  v8 = heap_Calloc(*(_QWORD **)(v25 + 8), 1, 1304);
  v13 = v25;
  if (!v8)
  {
    log_OutPublic(*(_QWORD *)(v25 + 32), (uint64_t)"SELECT_BET5", 31000, 0, v9, v10, v11, v12, v20[0]);
    return 2229280778;
  }
  v14 = v8;
  *(_QWORD *)v8 = a1;
  *(_QWORD *)(v8 + 8) = v13;
  *(_DWORD *)(v8 + 1296) = 0;
  *(_QWORD *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 16) = 0;
  *(_QWORD *)(v8 + 24) = 0;
  v21 = 0;
  LODWORD(v22) = 0;
  Voice = select_bet5_loadVoice(a1, v25, 0, (uint64_t)&v21, 0);
  if ((Voice & 0x80000000) != 0)
    goto LABEL_14;
  Voice = safeh_HandleCheck(v21, v22, 117, 43432);
  if ((Voice & 0x80000000) != 0)
    goto LABEL_14;
  *(_QWORD *)(v14 + 16) = v21;
  Voice = select_bet5_loc_CreateAddonListParamName(v14);
  if ((Voice & 0x80000000) != 0)
    goto LABEL_14;
  Voice = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(v14 + 8) + 40), *(_QWORD *)(v14 + 40), "");
  if ((Voice & 0x80000000) != 0)
    goto LABEL_14;
  v16 = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 40);
  v17 = *(_BYTE **)(v14 + 40);
  v20[0] = v14;
  v20[1] = select_bet5_loc_CheckParamChange;
  v20[2] = select_bet5_loc_LearnParamChange;
  Voice = paramc_ListenerAdd(v16, v17, v20);
  if ((Voice & 0x80000000) != 0
    || (Voice = objc_GetObject(*(_QWORD *)(v25 + 48), (uint64_t)"LINGDB", &v23), (Voice & 0x80000000) != 0)
    || (*(_QWORD *)(v14 + 24) = *(_QWORD *)(v23 + 8),
        Voice = objc_GetObject(*(_QWORD *)(v25 + 48), (uint64_t)"SYNTHSTREAM", &v24),
        (Voice & 0x80000000) != 0))
  {
LABEL_14:
    UnicornPipeline = Voice;
LABEL_15:
    select_bet5_ObjClose(*a5, a5[1]);
    *a5 = 0;
    *((_DWORD *)a5 + 2) = 0;
    return UnicornPipeline;
  }
  *(_QWORD *)(v14 + 64) = *(_QWORD *)(v24 + 8);
  paramc_ParamSetInt(*(_QWORD *)(v25 + 40), (uint64_t)"bet2voiceframesize", *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 16) + 12480) + 24));
  *a5 = v14;
  *((_DWORD *)a5 + 2) = 135968;
  if ((select_bet5_RegisterObject(v14, a5[1], v25) & 0x80000000) == 0)
    *(_DWORD *)(v14 + 1296) = 1;
  UnicornPipeline = select_bet5_loc_CreateUnicornPipeline((_QWORD *)v14);
  if ((UnicornPipeline & 0x80000000) != 0)
    goto LABEL_15;
  return UnicornPipeline;
}

uint64_t select_bet5_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v12;
  uint64_t (*v13)(uint64_t, char *, const char *);

  v3 = safeh_HandleCheck(a1, a2, 135968, 1304);
  if ((v3 & 0x80000000) != 0)
    return 2229280776;
  if (!a1)
    return v3;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = UnicornPipelineClass_Destroy(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
  if (*(_QWORD *)(a1 + 24))
    objc_ReleaseObject(*(_QWORD *)(v4 + 48), (uint64_t)"LINGDB");
  if (*(_QWORD *)(a1 + 64))
    objc_ReleaseObject(*(_QWORD *)(v4 + 48), (uint64_t)"SYNTHSTREAM");
  if (*(_DWORD *)(a1 + 1296) == 1)
    objc_UnregisterObject(*(_QWORD *)(v4 + 48), (uint64_t)"SELECTBET5");
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
  v7 = *(_BYTE **)(a1 + 40);
  *(_QWORD *)&v12 = a1;
  *((_QWORD *)&v12 + 1) = select_bet5_loc_CheckParamChange;
  v13 = select_bet5_loc_LearnParamChange;
  paramc_ListenerRemove(v6, v7, &v12);
  select_bet5_loc_LearnParamChange(a1, *(char **)(a1 + 40), "");
  select_bet5_loc_FreeUnicornAddons(*(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 1248), *(_DWORD *)(a1 + 56));
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), *(_QWORD *)(a1 + 40));
  *(_QWORD *)(a1 + 40) = 0;
  v8 = *(_QWORD *)(a1 + 16);
  if (v8)
  {
    if (!*(_QWORD *)a1 || (v9 = *(_QWORD *)(*(_QWORD *)a1 + 48)) == 0)
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
    objc_ReleaseObject(v9, v8);
  }
  v10 = *(_QWORD *)(a1 + 32);
  if (v10)
    heap_Free(*(_QWORD **)(v4 + 8), v10);
  *(_QWORD *)(a1 + 32) = 0;
  heap_Free(*(_QWORD **)(v4 + 8), a1);
  return v5;
}

uint64_t select_bet5_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t Voice;
  uint64_t UnicornPipeline;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  __int128 v12;
  uint64_t (*v13)(uint64_t, char *, const char *);
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  char __dst[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_OWORD *)__dst = 0u;
  v18 = 0u;
  if ((safeh_HandleCheck(a1, a2, 135968, 1304) & 0x80000000) != 0)
    return 2229280776;
  v15 = 0;
  v16 = 0;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && *(_BYTE *)(v3 + 14536))
    cstdlib_strncpy(__dst, (const char *)(v3 + 14536), 0x100uLL);
  Voice = select_bet5_loadVoice(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), __dst, (uint64_t)&v15, 0);
  if ((Voice & 0x80000000) != 0)
    return Voice;
  if ((safeh_HandleCheck(v15, v16, 117, 43432) & 0x80000000) == 0)
    *(_QWORD *)(a1 + 16) = v15;
  UnicornPipelineClass_Destroy(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
  UnicornPipeline = select_bet5_loc_CreateUnicornPipeline((_QWORD *)a1);
  if (cstdlib_strcmp(__dst, (const char *)(*(_QWORD *)(a1 + 16) + 14536)))
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
    v7 = *(_BYTE **)(a1 + 40);
    *(_QWORD *)&v12 = a1;
    *((_QWORD *)&v12 + 1) = select_bet5_loc_CheckParamChange;
    v13 = select_bet5_loc_LearnParamChange;
    v14 = 0;
    paramc_ListenerRemove(v6, v7, &v12);
    if (*(_DWORD *)(a1 + 56))
    {
      select_bet5_loc_LearnParamChange(a1, *(char **)(a1 + 40), "");
      select_bet5_loc_FreeUnicornAddons(*(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 1248), *(_DWORD *)(a1 + 56));
    }
    Voice = select_bet5_loc_CreateAddonListParamName(a1);
    if ((Voice & 0x80000000) != 0)
      return Voice;
    paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), *(_QWORD *)(a1 + 40), &v14);
    if (v14)
      v8 = select_bet5_loc_LearnParamChange(a1, *(char **)(a1 + 40), v14);
    else
      v8 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), *(_QWORD *)(a1 + 40), "");
    UnicornPipeline = v8;
    if ((v8 & 0x80000000) == 0)
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
      v10 = *(_BYTE **)(a1 + 40);
      *(_QWORD *)&v12 = a1;
      *((_QWORD *)&v12 + 1) = select_bet5_loc_CheckParamChange;
      v13 = select_bet5_loc_LearnParamChange;
      return paramc_ListenerAdd(v9, v10, &v12);
    }
  }
  return UnicornPipeline;
}

uint64_t select_bet5_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v23;

  v7 = 2229280776;
  if ((safeh_HandleCheck(a1, a2, 135968, 1304) & 0x80000000) == 0)
  {
    synstrmaux_InitStreamOpener(a1 + 376, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5");
    v8 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), 1, 3656);
    *(_QWORD *)(a1 + 32) = v8;
    if (v8)
    {
      v13 = 0;
      *(_QWORD *)(a1 + 1200) = 0;
      *(_DWORD *)(a1 + 1208) = 0;
      *(_QWORD *)(a1 + 1272) = 0;
      *(_QWORD *)(a1 + 1288) = 0;
      *(_QWORD *)(a1 + 1280) = 0;
      do
      {
        v14 = 0;
        while (s_select_Bet5_SynthStreamInfo[v14] != (_DWORD)v13)
        {
          v14 += 6;
          if (v14 == 114)
            goto LABEL_11;
        }
        v15 = *(const char **)&s_select_Bet5_SynthStreamInfo[v14 + 2];
        if (cstdlib_strcmp(v15, "application/x-realspeak-markers-pp;version=4.0"))
        {
          synstrmaux_RegisterInStream((_WORD *)(a1 + 376), (uint64_t)v15, (unint64_t)(v13 - 3) < 4, a1 + 16 * v13 + 72);
        }
        else
        {
          v16 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 64) + 152))();
          synstrmaux_RegisterStream((_WORD *)(a1 + 376), (uint64_t)v15, 0, v16, (unint64_t)(v13 - 3) < 4, a1 + 16 * v13 + 72);
        }
LABEL_11:
        ++v13;
      }
      while (v13 != 7);
      for (i = 0; i != 12; ++i)
      {
        v18 = 0;
        while (s_select_Bet5_SynthStreamInfo[v18 + 1] != (_DWORD)i)
        {
          v18 += 6;
          if (v18 == 114)
            goto LABEL_20;
        }
        v19 = *(const char **)&s_select_Bet5_SynthStreamInfo[v18 + 2];
        if (cstdlib_strcmp(v19, "application/x-realspeak-markers-pp;version=4.0"))
        {
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 376), (uint64_t)v19, a1 + 16 * i + 184);
        }
        else
        {
          v20 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 64) + 152))();
          synstrmaux_RegisterStream((_WORD *)(a1 + 376), (uint64_t)v19, 1, v20, 0, a1 + 16 * i + 184);
        }
LABEL_20:
        ;
      }
      v21 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 376), *(_QWORD *)(a1 + 64), a3, a4);
      if ((v21 & 0x80000000) != 0)
      {
        v7 = v21;
LABEL_26:
        synstrmaux_CloseStreams((_WORD *)(a1 + 376), *(_QWORD *)(a1 + 64));
        return v7;
      }
      v7 = UnicornPipelineClass_SetForcedEEEnabled(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240), 1);
      if ((v7 & 0x80000000) != 0)
        goto LABEL_26;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 31000, 0, v9, v10, v11, v12, v23);
      return 2229280778;
    }
  }
  return v7;
}

uint64_t select_bet5_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _WORD *v34;
  int v35;
  unsigned __int16 v36;
  uint64_t DirectStart;
  void *StartPtr_LH_F32;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int *v66;
  int v67;
  int *v68;
  uint64_t UInt;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  _DWORD *v78;
  uint64_t v79;
  float v80;
  uint64_t v81;
  unsigned int *v82;
  int v83;
  unint64_t v84;
  uint64_t v85;
  _DWORD *v86;
  uint64_t v87;
  _DWORD *v88;
  _DWORD *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  float v94;
  float v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t Stream;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  int PreparedCount;
  int v107;
  uint64_t v108;
  uint64_t v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  unsigned int v118;
  int v119;
  uint64_t v121;
  unsigned int v122;
  _BOOL4 v123;
  int v124;
  int v125;
  char v126;
  int v127;
  uint64_t v128;
  int v129;
  BOOL v130;
  int v131;
  _BOOL4 v134;
  unsigned __int16 v135;
  unsigned int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t *v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _DWORD *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  const void *v151[2];

  v144 = 0;
  v145 = 0;
  v7 = 2229280778;
  v143 = 0;
  v142 = 0;
  v141 = 0;
  if ((safeh_HandleCheck(a1, a2, 135968, 1304) & 0x80000000) != 0)
    return 2229280776;
  *a5 = 1;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 64);
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(v9 + 144))(*(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), (char *)&v145 + 4, &v144);
  if ((v10 & 0x80000000) != 0)
    return v10;
  *(_DWORD *)(a1 + 1200) |= v144;
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(v9 + 144))(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), &v145, (char *)&v143 + 4);
  if ((v10 & 0x80000000) != 0)
    return v10;
  *(_DWORD *)(a1 + 1204) |= HIDWORD(v143);
  v11 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(v9 + 144))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), (char *)&v144 + 4, &v143);
  if ((v11 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 1208) |= v143;
    if (!HIDWORD(v145) || !(_DWORD)v145 || !HIDWORD(v144))
    {
LABEL_122:
      v97 = *(_QWORD *)(a1 + 32);
      if (v97 && *(__int16 *)(v97 + 10) <= 1)
      {
        Stream = UnicornPipelineClass_GetStream(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
        if (Stream)
          select_bet5_FreeTuningData(*(_QWORD **)(a1 + 8), (uint64_t *)(Stream + 1768));
        UnicornPipelineClass_Release(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
        select_bet5_loc_deInitFeatures(a1);
        if (*(_DWORD *)(a1 + 1204) || *(_DWORD *)(a1 + 1200) || *(_DWORD *)(a1 + 1208))
        {
          v99 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 3520);
          if (v99)
          {
            v11 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 64) + 104))(*(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 192), *(_QWORD *)(a1 + 1256) + 32 * *(unsigned int *)(a1 + 1268), (32 * v99));
            if ((v11 & 0x80000000) != 0)
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 58008, (uint64_t)"%s%s%s%x", v100, v101, v102, v103, "contentType");
          }
          goto LABEL_136;
        }
        goto LABEL_162;
      }
      if (UnicornPipelineClass_isDone(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240)))
      {
        if (*(_DWORD *)(a1 + 1204) || *(_DWORD *)(a1 + 1200) || *(_DWORD *)(a1 + 1208))
        {
LABEL_136:
          synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 376), v9);
          v104 = 1;
LABEL_137:
          *a5 = v104;
          return v11;
        }
LABEL_162:
        *a5 = 0;
        return v11;
      }
      v105 = UnicornPipelineClass_GetStream(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
      v11 = UnicornPipelineClass_ProcessPhoneme(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240), (uint64_t)&v142);
      if ((v11 & 0x80000000) != 0)
        return v11;
      PreparedCount = UnicornPipelineClass_GetPreparedCount(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
      v107 = *(_DWORD *)(a1 + 1280);
      v108 = (PreparedCount - v107);
      if (PreparedCount == v107)
      {
        v117 = 0;
        goto LABEL_153;
      }
      v109 = *(_QWORD *)(a1 + 16);
      v110 = *(_DWORD *)(v109 + 11912);
      v111 = *(_DWORD *)(a1 + 1276) + v108;
      v112 = *(_DWORD *)(*(_QWORD *)(v109 + 12480) + 5924);
      LODWORD(v151[0]) = 0;
      LODWORD(v150) = 0;
      v113 = v111 / v110;
      select_bet5_GetEEMode(a1, v151, &v150);
      if (!UnicornPipelineClass_GetForcedEEEnabled(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240))
        || v113 < v112
        || (v11 = UnicornPipelineClass_SetForcedEEEnabled(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240), 0),
            (v11 & 0x80000000) == 0))
      {
        if (v142)
          goto LABEL_144;
        v140 = v105;
        v124 = (int)v151[0];
        v125 = UnicornPipelineClass_GetPreparedCount(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
        if (v124)
        {
          if (v125 >= (int)v110)
          {
            v127 = *(_DWORD *)(a1 + 1280);
            v105 = v140;
            while (1)
            {
              v128 = (v125 - v127);
              if (v125 <= v127)
              {
LABEL_181:
                v126 = 1;
                goto LABEL_182;
              }
              v129 = (v125 - 1) / (int)v110;
              v130 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) + v129) == 1 && v129 * v110 + 1 == v125;
              if (v130)
                break;
              v131 = v125--;
              if (v131 <= (int)v110)
                goto LABEL_181;
            }
            v126 = 0;
            *(_DWORD *)(a1 + 1292) = v110 - 1;
            v108 = v128;
LABEL_182:
            v134 = v113 >= v112 && (_DWORD)v108 != 0 || (_DWORD)v150 == 0;
            v117 = 0;
            if ((v126 & 1) == 0 && v134)
            {
              if (!(_DWORD)v108)
              {
                v117 = 0;
                goto LABEL_145;
              }
LABEL_144:
              log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"Sent to synth: %d", v114, v115, v116, v108);
              v117 = 1;
LABEL_145:
              v118 = *(_DWORD *)(a1 + 1280) + v108;
              v10 = select_bet5_ProcessAndWriteMarkers(a1, v118);
              if ((v10 & 0x80000000) == 0)
              {
                v10 = select_bet5_WriteAll(v8, a1 + 184, v9, v105, *(_DWORD *)(a1 + 1280), v118, *(_DWORD *)(a1 + 1288), *(_DWORD *)(a1 + 1292), *(_DWORD *)(a1 + 1284), v142, *(_DWORD *)(a1 + 1208));
                if ((v10 & 0x80000000) == 0)
                {
                  *(int32x2_t *)(a1 + 1276) = vadd_s32(*(int32x2_t *)(a1 + 1276), vdup_n_s32(v108));
                  v11 = UnicornPipelineClass_SynthesizeDummy(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240), v108);
                  if ((v11 & 0x80000000) != 0)
                    return v11;
                  if (LODWORD(v151[0]))
                  {
                    v119 = *(_DWORD *)(a1 + 1292);
                    *(_DWORD *)(a1 + 1284) += v119 + *(_DWORD *)(a1 + 1288);
                    *(_QWORD *)(a1 + 1288) = v110 - v119;
                  }
                  goto LABEL_153;
                }
              }
              return v10;
            }
LABEL_153:
            if (v142)
            {
              v121 = UnicornPipelineClass_GetStream(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
              if (v121)
                select_bet5_FreeTuningData(*(_QWORD **)(a1 + 8), (uint64_t *)(v121 + 1768));
              if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 12480) + 6800) == 9
                && UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32)) >= 3)
              {
                if (v121)
                {
                  v122 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 11912) * *(__int16 *)(*(_QWORD *)(a1 + 32) + 10);
                  if (v122)
                  {
                    *(_DWORD *)(v121 + 1948) /= v122;
                    *(_DWORD *)(v121 + 1952) /= v122;
                    *(_DWORD *)(v121 + 1956) /= v122;
                    *(_DWORD *)(v121 + 1960) /= v122;
                    *(_DWORD *)(v121 + 1964) /= v122;
                    *(_DWORD *)(v121 + 1968) /= v122;
                    *(_DWORD *)(v121 + 1972) /= v122;
                    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 8), 3, (uint64_t)"average counts: initCluster:%d searchStage1:%d searchStage2Casc1:%d searchStage2Casc2:%d searchStage2Casc3:%d vitInnerLoop:%d(%d)");
                  }
                }
              }
              UnicornPipelineClass_Release(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
              select_bet5_loc_deInitFeatures(a1);
              v123 = v142 == 0;
            }
            else
            {
              v123 = 1;
            }
            if (v117)
              v123 = 1;
            if (v123)
              v104 = 2;
            else
              v104 = 0;
            goto LABEL_137;
          }
          v126 = 1;
        }
        else
        {
          v126 = 0;
          v108 = v108 + v125 / v110 * v110 - v125;
        }
        v105 = v140;
        goto LABEL_182;
      }
      return v11;
    }
    *(_DWORD *)(a1 + 1264) = HIDWORD(v144) >> 5;
    v151[0] = 0;
    LODWORD(v150) = 0;
    v12 = (*(uint64_t (**)(_QWORD, _QWORD, const void **, uint64_t *))(*(_QWORD *)(a1 + 64) + 88))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), v151, &v150);
    v17 = *(_QWORD *)(a1 + 8);
    if ((v12 & 0x80000000) != 0)
    {
      v49 = v12;
      log_OutPublic(*(_QWORD *)(v17 + 32), (uint64_t)"SELECT_BET5", 21008, (uint64_t)"%s%x", v13, v14, v15, v16, "lhError");
      return v49;
    }
    else
    {
      v18 = (void *)heap_Calloc(*(_QWORD **)(v17 + 8), 1, v150);
      if (v18)
      {
        v19 = (uint64_t)v18;
        v20 = cstdlib_memcpy(v18, v151[0], v150);
        if (v150 >= 0x20)
        {
          v21 = 0;
          v22 = 0;
          while (1)
          {
            v23 = (*(uint64_t (**)(void *))(*(_QWORD *)(a1 + 64) + 152))(v20);
            v20 = (void *)(*(uint64_t (**)(char *, _QWORD, uint64_t))(v23 + 8))((char *)v151[0] + v21, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8), v19 + v21);
            if (!(_DWORD)v20)
              break;
            ++v22;
            v21 += 32;
            if (v22 >= (unint64_t)v150 >> 5)
              goto LABEL_14;
          }
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), v19);
          return v7;
        }
LABEL_14:
        v24 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 64) + 96))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80));
        if ((v24 & 0x80000000) != 0)
        {
          v51 = v24;
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), v19);
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 2571, (uint64_t)"%s%x", v52, v53, v54, v55, "lhError");
          return v51;
        }
        else
        {
          *(_QWORD *)(a1 + 1256) = v19;
          v25 = *(_QWORD *)(a1 + 32);
          LODWORD(v150) = 0;
          v151[0] = 0;
          v26 = *(_QWORD *)(a1 + 64);
          v27 = *(_QWORD *)(a1 + 8);
          v28 = *(_QWORD *)(a1 + 16);
          v29 = *(unsigned __int16 *)(v28 + 42808);
          *(_QWORD *)v25 = v28 + 14384;
          if ((select_bet5_deserializeFeatures(v27, v26, *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), (uint64_t *)v25) & 0x80000000) != 0)
            goto LABEL_27;
          v34 = (_WORD *)(v28 + 17962);
          v35 = *(_DWORD *)(v28 + 17964);
          v36 = *(_WORD *)(v25 + 10);
          if (!v35)
            v36 *= *v34;
          v139 = a1 + 72;
          DirectStart = select_bet5_ReadDirectStart(v27, a1 + 72, v26, 2u, "application/x-realspeak-nn-ufeats", (uint64_t)v151, (uint64_t)&v150);
          v31 = v150;
          if (v150 != 4 * v36 * v29)
          {
LABEL_27:
            v7 = 2229280789;
            v50 = 71001;
          }
          else
          {
            v11 = DirectStart;
            if ((DirectStart & 0x80000000) != 0)
            {
              select_bet5_ReadDirectEnd(v27, v139, v26, 2u, "application/x-realspeak-nn-ufeats", v150);
              return v11;
            }
            if (VectBlock_Create(v27, a1 + 1216, v150, v150 / v36))
            {
              StartPtr_LH_F32 = (void *)VectBlock_Get_StartPtr_LH_F32(a1 + 1216);
              cstdlib_memcpy(StartPtr_LH_F32, v151[0], v150);
              select_bet5_ReadDirectEnd(v27, v139, v26, 2u, "application/x-realspeak-nn-ufeats", v150);
              v150 = 0;
              v151[0] = 0;
              v148 = 0;
              v149 = 0;
              v39 = *(_QWORD *)(a1 + 8);
              v40 = *(_QWORD *)(a1 + 16);
              v41 = *(_QWORD *)(a1 + 64);
              v147 = 0;
              v146 = 0;
              v141 = 0;
              v138 = v41;
              v42 = select_bet5_ReadDirectStart(v39, v139, v41, 3u, "application/x-realspeak-tapids;version=4.0",
                      (uint64_t)&v146,
                      (uint64_t)&v148 + 4);
              v47 = HIDWORD(v148);
              if (v42 < 0 || !HIDWORD(v148))
              {
                v146 = 0;
              }
              else if (HIDWORD(v148) != 4
                                       * *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) + 10)
                                       * (unint64_t)*(unsigned __int16 *)(v40 + 17962))
              {
                log_OutPublic(*(_QWORD *)(v39 + 32), (uint64_t)"SELECT_BET5", 71001, 0, v43, v44, v45, v46, v136);
                v48 = 0;
                v11 = 2229280789;
                goto LABEL_116;
              }
              v56 = HIDWORD(v148) >> 2;
              if ((select_bet5_ReadDirectStart(v39, v139, v138, 4u, "application/x-realspeak-usfrozen;version=4.0",
                      (uint64_t)v151,
                      (uint64_t)&v148) & 0x80000000) != 0
                || !(_DWORD)v148)
              {
                v151[0] = 0;
              }
              else
              {
                if (v47 >= 4)
                {
                  v130 = v56 == v148 >> 2;
                  v56 = v148 >> 2;
                  v57 = a1 + 72;
                  if (!v130)
                    goto LABEL_57;
LABEL_44:
                  if ((select_bet5_ReadDirectStart(v39, v57, v138, 6u, "application/x-realspeak-usnoreusebias;version=4.0",
                          (uint64_t)&v150,
                          (uint64_t)&v147 + 4) & 0x80000000) != 0
                    || !HIDWORD(v147))
                  {
                    v150 = 0;
                  }
                  else
                  {
                    if (v56)
                    {
                      v130 = v56 == HIDWORD(v147) / 0x1F8;
                      v56 = HIDWORD(v147) / 0x1F8;
                      v57 = a1 + 72;
                      if (!v130)
                        goto LABEL_57;
LABEL_53:
                      v58 = select_bet5_ReadDirectStart(v39, v57, v138, 5u, "application/x-realspeak-usprosodybias;version=4.0",
                              (uint64_t)&v149,
                              (uint64_t)&v147);
                      if ((v58 & 0x80000000) != 0 || !(_DWORD)v147)
                      {
                        v11 = 0;
                        v149 = 0;
                      }
                      else
                      {
                        v11 = v58;
                        if (v56)
                        {
                          v130 = v56 == v147 >> 3;
                          v56 = v147 >> 3;
                          v57 = a1 + 72;
                          if (!v130)
                          {
LABEL_57:
                            v48 = 0;
                            v11 = 2229280768;
LABEL_117:
                            select_bet5_ReadDirectEnd(v39, v57, v138, 3u, "application/x-realspeak-tapids;version=4.0",
                              HIDWORD(v148));
                            select_bet5_ReadDirectEnd(v39, v57, v138, 4u, "application/x-realspeak-usfrozen;version=4.0",
                              v148);
                            select_bet5_ReadDirectEnd(v39, v57, v138, 6u, "application/x-realspeak-usnoreusebias;version=4.0",
                              HIDWORD(v147));
                            select_bet5_ReadDirectEnd(v39, v57, v138, 5u, "application/x-realspeak-usprosodybias;version=4.0",
                              v147);
                            if ((v11 & 0x80000000) != 0)
                            {
                              select_bet5_FreeTuningData((_QWORD *)v39, (uint64_t *)&v141);
                              return v11;
                            }
                            v11 = UnicornPipelineClass_Init(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240), *(_QWORD *)(a1 + 32), a1 + 1216, v48, *(_QWORD *)(a1 + 1248), *(unsigned int *)(a1 + 56));
                            if ((v11 & 0x80000000) != 0)
                              return v11;
                            UnicornPipelineClass_SetSIMDCallbacks(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240), 1);
                            v96 = UnicornPipelineClass_GetStream(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
                            if (v96)
                              *(_DWORD *)(v96 + 1976) = 1;
                            *(_DWORD *)(a1 + 1268) = 0;
                            *(_OWORD *)(a1 + 1280) = 0u;
                            goto LABEL_122;
                          }
LABEL_61:
                          if (!v56)
                          {
                            if (!v146)
                            {
                              v48 = 0;
                              goto LABEL_117;
                            }
                            v70 = *(unsigned __int16 *)(v40 + 17962) * *(__int16 *)(*(_QWORD *)(a1 + 32) + 10);
                            if (v70 >= 1 && *v146 == -1)
                            {
                              v135 = 0;
                              do
                                v71 = ++v135;
                              while (v70 > v135 && v146[v135] == -1);
                            }
                            else
                            {
                              v71 = 0;
                            }
                            v48 = 0;
                            v56 = (unsigned __int16)v70;
                            if (!(_WORD)v70 || v70 == v71)
                              goto LABEL_117;
                          }
                          v59 = (uint64_t *)heap_Calloc(*(_QWORD **)(v39 + 8), 1, 32);
                          v48 = (uint64_t)v59;
                          v141 = v59;
                          if (!v59
                            || (*((_DWORD *)v59 + 2) = v56,
                                v137 = v56,
                                v64 = heap_Calloc(*(_QWORD **)(v39 + 8), v56, 48),
                                (*(_QWORD *)v48 = v64) == 0))
                          {
LABEL_115:
                            log_OutPublic(*(_QWORD *)(v39 + 32), (uint64_t)"SELECT_BET5", 19000, 0, v60, v61, v62, v63, v136);
                            v11 = 2229280778;
LABEL_116:
                            v57 = a1 + 72;
                            goto LABEL_117;
                          }
                          v65 = 50;
                          *(_DWORD *)(v48 + 20) = 50;
                          v66 = (int *)(v48 + 20);
                          if ((paramc_ParamGetUInt(*(_QWORD *)(v39 + 40), (uint64_t)"uselectweightdurationbias", (unsigned int *)(v48 + 20)) & 0x80000000) == 0)
                          {
                            if (*v66 < 0x65)
                              goto LABEL_68;
                            v65 = 100;
                          }
                          *v66 = v65;
LABEL_68:
                          v67 = 50;
                          *(_DWORD *)(v48 + 24) = 50;
                          v68 = (int *)(v48 + 24);
                          UInt = paramc_ParamGetUInt(*(_QWORD *)(v39 + 40), (uint64_t)"uselectweightpitchbias", (unsigned int *)(v48 + 24));
                          if ((UInt & 0x80000000) != 0)
                          {
                            v11 = 0;
                          }
                          else
                          {
                            v11 = UInt;
                            if (*v68 < 0x65)
                            {
LABEL_81:
                              v72 = 0;
                              v73 = 4;
                              v74 = *(_QWORD *)v48;
                              v75 = v56;
                              while (1)
                              {
                                v76 = v72;
                                *(_BYTE *)(v74 + 48 * v72 + 28) = 0;
                                if (!v150)
                                  break;
                                v77 = *(_DWORD *)(v150 + 504 * v72);
                                if (!v77)
                                  break;
                                v48 = (uint64_t)v141;
                                v78 = (_DWORD *)(*v141 + 48 * v72);
                                *v78 = 1;
                                v78[6] = v77;
                                v79 = heap_Calloc(*(_QWORD **)(v39 + 8), (v77 + 1), 4);
                                v74 = *(_QWORD *)v48;
                                *(_QWORD *)(*(_QWORD *)v48 + 48 * v76 + 8) = v79;
                                if (!v79)
                                  goto LABEL_115;
                                v81 = v74 + 48 * v76;
                                v83 = *(_DWORD *)(v81 + 24);
                                v82 = (unsigned int *)(v81 + 24);
                                if (v83)
                                {
                                  v84 = 0;
                                  v85 = v150 + v73;
                                  v75 = v137;
                                  do
                                  {
                                    *(_DWORD *)(v79 + 4 * v84) = *(_DWORD *)(v85 + 4 * v84);
                                    ++v84;
                                  }
                                  while (v84 < *v82);
                                }
                                else
                                {
                                  LODWORD(v84) = 0;
                                  v75 = v137;
                                }
                                v89 = (_DWORD *)(v79 + 4 * v84);
LABEL_101:
                                *v89 = -1;
                                v90 = v149;
                                if (!v149)
                                  goto LABEL_113;
                                v91 = v149 + 8 * v76;
                                v92 = *(unsigned __int8 *)(v91 + 6);
                                v93 = *(unsigned __int8 *)(v91 + 4);
                                if (!(v92 | v93))
                                  goto LABEL_113;
                                if (v93 == 1)
                                {
                                  v94 = 100.0;
                                }
                                else
                                {
                                  if (v93 != 2)
                                    goto LABEL_108;
                                  v94 = -100.0;
                                }
                                *(_DWORD *)(v48 + 16) = 1;
                                LOBYTE(v80) = *(_BYTE *)(v90 + 8 * v76 + 5);
                                v80 = (float)LODWORD(v80);
                                *(float *)(v74 + 48 * v76 + 20) = v80 / v94;
LABEL_108:
                                if (v92 == 1)
                                {
                                  v95 = 100.0;
                                  goto LABEL_112;
                                }
                                if (v92 == 2)
                                {
                                  v95 = -100.0;
LABEL_112:
                                  *(_DWORD *)(v48 + 12) = 1;
                                  LOBYTE(v80) = *(_BYTE *)(v90 + 8 * v76 + 7);
                                  *(float *)(v74 + 48 * v76 + 16) = (float)LODWORD(v80) / v95;
                                }
LABEL_113:
                                v72 = v76 + 1;
                                v73 += 504;
                                if (v76 + 1 == v75)
                                {
                                  *(_DWORD *)(v74 + 48 * v76) = 4;
                                  goto LABEL_116;
                                }
                              }
                              v86 = (_DWORD *)heap_Calloc(*(_QWORD **)(v39 + 8), 2, 4);
                              v48 = (uint64_t)v141;
                              v74 = *v141;
                              *(_QWORD *)(*v141 + 48 * v76 + 8) = v86;
                              if (!v86)
                                goto LABEL_115;
                              *(_DWORD *)(v74 + 48 * v76 + 24) = 1;
                              if (!v151[0] || *((_DWORD *)v151[0] + v76) == -1)
                              {
                                if (!v146 || v146[v76] == -1)
                                {
                                  *(_DWORD *)(v74 + 48 * v76) = 2;
                                  *v86 = 0;
                                  goto LABEL_98;
                                }
                                log_OutText(*(_QWORD *)(v39 + 32), (uint64_t)"SELECT_BET5", 5, 0, (uint64_t)"%s: %u", v61, v62, v63, (uint64_t)"Locked unit");
                                v74 = *(_QWORD *)v48;
                                v87 = *(_QWORD *)v48 + 48 * v76;
                                *(_DWORD *)v87 = 0;
                                v88 = v146;
                              }
                              else
                              {
                                log_OutText(*(_QWORD *)(v39 + 32), (uint64_t)"SELECT_BET5", 5, 0, (uint64_t)"%s: %u", v61, v62, v63, (uint64_t)"Locked unit");
                                v74 = *(_QWORD *)v48;
                                v87 = *(_QWORD *)v48 + 48 * v76;
                                *(_DWORD *)v87 = 0;
                                v88 = v151[0];
                              }
                              v86 = *(_DWORD **)(v87 + 8);
                              *v86 = v88[v76];
LABEL_98:
                              v89 = v86 + 1;
                              goto LABEL_101;
                            }
                            v67 = 100;
                          }
                          *v68 = v67;
                          goto LABEL_81;
                        }
                        v56 = v147 >> 3;
                      }
                      v57 = a1 + 72;
                      goto LABEL_61;
                    }
                    v56 = HIDWORD(v147) / 0x1F8;
                  }
                  v57 = a1 + 72;
                  goto LABEL_53;
                }
                v56 = v148 >> 2;
              }
              v57 = a1 + 72;
              goto LABEL_44;
            }
            v50 = 71000;
          }
          log_OutPublic(*(_QWORD *)(v27 + 32), (uint64_t)"SELECT_BET5", v50, 0, v30, v31, v32, v33, v136);
        }
      }
    }
    return v7;
  }
  return v11;
}

uint64_t select_bet5_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t Stream;
  uint64_t v5;
  uint64_t v7;

  v7 = 0;
  if ((safeh_HandleCheck(a1, a2, 135968, 1304) & 0x80000000) != 0)
    return 2229280776;
  *(_QWORD *)(a1 + 1272) = 0;
  *(_QWORD *)(a1 + 1200) = 0;
  *(_DWORD *)(a1 + 1208) = 0;
  v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 376), *(_QWORD *)(a1 + 64));
  if (!UnicornPipelineClass_isDone(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240)))
  {
    Stream = UnicornPipelineClass_GetStream(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
    if (Stream)
      v5 = *(_QWORD *)(Stream + 1768);
    else
      v5 = 0;
    v7 = v5;
    UnicornPipelineClass_Release(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
    select_bet5_FreeTuningData(*(_QWORD **)(a1 + 8), &v7);
  }
  if (*(_QWORD *)(a1 + 32))
  {
    select_bet5_loc_deInitFeatures(a1);
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), *(_QWORD *)(a1 + 32));
  }
  *(_QWORD *)(a1 + 32) = 0;
  return v3;
}

uint64_t select_bet5_GetAlphabetInformation(uint64_t a1, int a2, char *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  char *v9;
  uint64_t v10;
  int v11;
  const char *v12;
  int v13;
  const char **v14;
  const char *v15;
  int v16;
  char *v17;

  v5 = safeh_HandleCheck(a1, a2, 135968, 1304);
  if ((v5 & 0x80000000) != 0)
    return 2229280776;
  if (!*(_QWORD *)(a1 + 16))
    return 2229280785;
  v6 = v5;
  cstdlib_memset(a3, 0, 0x985uLL);
  v7 = 0;
  v8 = 0;
  do
  {
    if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v7 + 16528) != 255)
    {
      v9 = &a3[(unsigned __int16)v8];
      *v9 = v7;
      v9[514] = *(_BYTE *)(*(_QWORD *)(a1 + 16) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v7 + 16528) + 15500);
      v9[257] = *(_BYTE *)(*(_QWORD *)(a1 + 16) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v7 + 16528) + 15243);
      v9[771] = *(_BYTE *)(*(_QWORD *)(a1 + 16) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v7 + 16528) + 15757);
      v9[1028] = *(_BYTE *)(*(_QWORD *)(a1 + 16) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v7 + 16528) + 16014);
      ++v8;
    }
    ++v7;
  }
  while (v7 != 256);
  cstdlib_strcpy(a3 + 1285, (const char *)(*(_QWORD *)(a1 + 16) + 16784));
  if (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 17504) == 1 && cstdlib_strlen("12345"))
  {
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = &a12345[v10];
      v13 = *v12;
      if (!cstdlib_strchr(a3 + 1285, v13) && !cstdlib_strchr(a3, v13))
        cstdlib_strncat(a3 + 1349, v12, 1uLL);
      v10 = (unsigned __int16)++v11;
    }
    while (cstdlib_strlen("12345") > (unsigned __int16)v11);
  }
  v14 = *(const char ***)(*(_QWORD *)(a1 + 16) + 16848);
  if (v14)
  {
    v15 = *v14;
    if (*v14)
    {
      v16 = 0;
      v17 = a3 + 1413;
      do
      {
        cstdlib_strcat(v17, v15);
        cstdlib_strcat(v17, " ");
        v15 = *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 16848) + 8 * (unsigned __int16)++v16);
      }
      while (v15);
    }
  }
  return v6;
}

uint64_t select_bet5_QueryCapability(uint64_t a1, int a2, const char *a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v7 = 2229280768;
  v8 = safeh_HandleCheck(a1, a2, 135968, 1304);
  if ((v8 & 0x80000000) != 0)
    return 2229280776;
  if (!*(_QWORD *)(a1 + 16))
    return 2229280785;
  v9 = v8;
  if (!cstdlib_strcmp(a3, "PRM") || !cstdlib_strcmp(a3, "BND"))
  {
    *a4 = 1;
    return v9;
  }
  if (!cstdlib_strcmp(a3, "max-PRM"))
  {
    LOBYTE(v10) = 3;
    goto LABEL_12;
  }
  if (!cstdlib_strcmp(a3, "units-per-phoneme"))
  {
    v10 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 11912);
LABEL_12:
    *(_BYTE *)a4 = v10;
    return v9;
  }
  return v7;
}

uint64_t select_bet5_loc_CreateAddonListParamName(uint64_t a1)
{
  uint64_t Str;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *__s2;
  char *__s;
  char *v13;

  __s = 0;
  v13 = 0;
  __s2 = 0;
  Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), (uint64_t)"voice", &v13);
  if ((Str & 0x80000000) != 0)
    return Str;
  Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), (uint64_t)"voiceoperatingpoint", &__s);
  if ((Str & 0x80000000) != 0)
    return Str;
  v3 = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), (uint64_t)"vopversion", &__s2);
  if ((v3 & 0x80000000) == 0)
  {
    v4 = cstdlib_strlen(__s);
    if (__s2)
      v5 = cstdlib_strlen(__s2);
    else
      v5 = 0;
    v7 = cstdlib_strlen(v13);
    v8 = (char *)heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 8) + 8), *(_QWORD *)(a1 + 40), v5 + v4 + v7 + 16);
    *(_QWORD *)(a1 + 40) = v8;
    if (v8)
    {
      v9 = v7;
      cstdlib_strcpy(v8, "voiceaddons.");
      if (v7)
      {
        v10 = 0;
        do
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 40) + v10 + 12) = cstdlib_tolower(v13[v10]);
          ++v10;
        }
        while (v9 != v10);
      }
      *(_BYTE *)(v9 + *(_QWORD *)(a1 + 40) + 12) = 0;
      cstdlib_strcat(*(char **)(a1 + 40), ".");
      cstdlib_strcat(*(char **)(a1 + 40), __s);
      if (__s2)
      {
        cstdlib_strcat(*(char **)(a1 + 40), ".");
        cstdlib_strcat(*(char **)(a1 + 40), __s2);
      }
    }
    else
    {
      return 2229280778;
    }
  }
  return v3;
}

uint64_t select_bet5_loc_CheckParamChange()
{
  return 0;
}

uint64_t select_bet5_loc_LearnParamChange(uint64_t a1, char *__s1, const char *a3)
{
  uint64_t v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t Voice;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  size_t v41;
  _QWORD v42[2];
  char __dst[16];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  char __s[16];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  if (cstdlib_strcmp(__s1, *(const char **)(a1 + 40)))
    return 0;
  v42[0] = 0;
  v42[1] = 0;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  *(_OWORD *)__s = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v50 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  *(_OWORD *)__dst = 0u;
  v6 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 11804);
  if (*(_DWORD *)(a1 + 56))
  {
    v7 = 0;
    do
    {
      if (!*(_QWORD *)a1 || (v8 = *(_QWORD *)(*(_QWORD *)a1 + 48)) == 0)
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
      objc_ReleaseObject(v8, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v7++));
      v9 = *(unsigned int *)(a1 + 56);
    }
    while (v7 < v9);
  }
  else
  {
    LODWORD(v9) = 0;
  }
  select_bet5_loc_FreeUnicornAddons(*(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 1248), v9);
  *(_DWORD *)(a1 + 56) = 0;
  if (!a3 || !cstdlib_strlen(a3))
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), *(_QWORD *)(a1 + 48));
    v5 = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    return v5;
  }
  v41 = 0;
  if (betX_GetVAOName(a3, &v41, __s, 0x100uLL))
  {
    v5 = 2229280778;
    do
    {
      Voice = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), (uint64_t)"voiceaddon", __s);
      if ((Voice & 0x80000000) != 0)
        return Voice;
      Voice = select_bet5_loadVoice(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), 0, (uint64_t)v42, 1);
      if ((Voice & 0x80000000) != 0)
        return Voice;
      v11 = v42[0];
      v12 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 8) + 8), *(_QWORD *)(a1 + 48), 8 * (*(_DWORD *)(a1 + 56) + 1));
      *(_QWORD *)(a1 + 48) = v12;
      if (!v12)
        return v5;
      v16 = *(unsigned int *)(a1 + 56);
      *(_QWORD *)(v12 + 8 * v16) = v11;
      v17 = *(_QWORD *)(a1 + 16);
      if (!v17)
        return 2229280774;
      v18 = *(_DWORD *)(v17 + 11912);
      v19 = *(_QWORD *)(v17 + 12480);
      v20 = *(_DWORD *)(v19 + 24);
      v21 = *(_QWORD *)(v11 + 12480);
      v22 = *(_DWORD *)(v21 + 24);
      v23 = *(_DWORD *)(v19 + 11520);
      v24 = *(_DWORD *)(v21 + 11520);
      if (v18 != *(_DWORD *)(v11 + 11912) || v20 != v22 || v23 != v24)
      {
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 1, 0, (uint64_t)"Unable to load VAO data %s: expected #states=%d frame_size=%d psola_mode=%d found #states=%d frame_size=%d psola_mode=%d", v13, v14, v15, v11);
        return 2229280793;
      }
      *(_DWORD *)(a1 + 56) = v16 + 1;
      cstdlib_strcpy(__dst, "voiceaddonoffset.");
      if (cstdlib_strlen(__s))
      {
        v25 = 0;
        v26 = 1;
        do
        {
          __dst[v25 + 17] = cstdlib_tolower(__s[v25]);
          v25 = v26;
        }
        while (cstdlib_strlen(__s) > v26++);
      }
      v28 = v6 + *(_DWORD *)(v11 + 11912) - 1;
      Voice = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), (uint64_t)__dst, v28);
      if ((Voice & 0x80000000) != 0)
        return Voice;
      v6 = *(_DWORD *)(v11 + 11804) + v28;
      cstdlib_memset(__s, 0, 0x100uLL);
      cstdlib_memset(__dst, 0, 0x100uLL);
    }
    while (betX_GetVAOName(a3, &v41, __s, 0x100uLL));
  }
  v29 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v29)
  {
    v30 = *(_QWORD *)(a1 + 8);
    v31 = *(_QWORD *)(a1 + 16);
    v32 = *(uint64_t **)(a1 + 48);
    v33 = *(_DWORD *)(v31 + 11804);
    v34 = heap_Calloc(*(_QWORD **)(v30 + 8), *(unsigned int *)(a1 + 56), 48);
    if (!v34)
      return 2229280778;
    v35 = v34;
    v36 = 0;
    v37 = v31 + 11912;
    while (1)
    {
      v38 = v33 + *(_DWORD *)(*v32 + 11912) - 1;
      Voice = UnicornAddon_Init(v30, v37, *v32 + 11912, v38, v35 + v36);
      if ((Voice & 0x80000000) != 0)
        return Voice;
      v39 = *v32++;
      v33 = *(_DWORD *)(v39 + 11804) + v38;
      v36 += 48;
      if (48 * v29 == v36)
        goto LABEL_37;
    }
  }
  v35 = 0;
LABEL_37:
  v5 = 0;
  *(_QWORD *)(a1 + 1248) = v35;
  return v5;
}

uint64_t select_bet5_RegisterObject(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = 0;
  v7 = 0u;
  v8 = 0u;
  cstdlib_memset(&v7, 0, 0x28uLL);
  LOBYTE(v7) = 1;
  *((_QWORD *)&v7 + 1) = &ISelect_Bet5;
  *(_QWORD *)&v8 = a1;
  *((_QWORD *)&v8 + 1) = a2;
  v9 = 0;
  return objc_RegisterObject(*(_QWORD *)(a3 + 48), (uint64_t)"SELECTBET5", &v7);
}

uint64_t select_bet5_loc_CreateUnicornPipeline(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  _BYTE *v10;

  v10 = 0;
  v2 = a1[1];
  paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"bet5multithreadenabled", &v10);
  if (v10 && *v10 && cstdlib_strchr("nNfF0", (char)*v10))
  {
    v3 = UnicornPipelineFactory_Create(0, v2, a1[2] + 11912, *(_QWORD *)(a1[2] + 12480));
    a1[154] = v3;
    a1[155] = v4;
  }
  else
  {
    v3 = UnicornPipelineFactory_Create(*(_QWORD *)(v2 + 400) != 0, v2, a1[2] + 11912, *(_QWORD *)(a1[2] + 12480));
    a1[154] = v3;
    a1[155] = v4;
    if (!*(_QWORD *)(v2 + 400))
    {
      log_OutText(*(_QWORD *)(a1[1] + 32), (uint64_t)"SELECT_BET5", 1, 0, (uint64_t)"Impossible to use MultiThread implementation because no external service was found to support this. Fallback to standard implementation.", v5, v6, v7, v9);
      v3 = (_QWORD *)a1[154];
      v4 = a1[155];
    }
  }
  return safeh_HandleCheck((uint64_t)v3, v4, 135969, 0);
}

_QWORD *select_bet5_loc_FreeUnicornAddons(_QWORD *result, uint64_t a2, unsigned int a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  if (a3)
  {
    v4 = result;
    v5 = 0;
    v6 = 48 * a3;
    do
    {
      UnicornAddon_Deinit(v4, a2 + v5);
      v5 += 48;
    }
    while (v6 != v5);
    return heap_Free((_QWORD *)v4[1], a2);
  }
  return result;
}

_QWORD *select_bet5_FreeTuningData(_QWORD *result, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  if (a2)
  {
    v3 = *a2;
    if (v3)
    {
      v4 = result;
      v5 = *(_QWORD *)v3;
      if (*(_QWORD *)v3)
      {
        if (*(_DWORD *)(v3 + 8))
        {
          v6 = 0;
          v7 = 8;
          do
          {
            if (*(_QWORD *)(*(_QWORD *)v3 + v7))
            {
              heap_Free((_QWORD *)v4[1], *(_QWORD *)(*(_QWORD *)v3 + v7));
              v3 = *a2;
            }
            ++v6;
            v7 += 48;
          }
          while (v6 < *(unsigned int *)(v3 + 8));
          v5 = *(_QWORD *)v3;
        }
        heap_Free((_QWORD *)v4[1], v5);
        v3 = *a2;
      }
      result = heap_Free((_QWORD *)v4[1], v3);
      *a2 = 0;
    }
  }
  return result;
}

_QWORD *select_bet5_loc_deInitFeatures(uint64_t a1)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 8);
  VectBlock_Destroy((_QWORD **)v2, (uint64_t *)(a1 + 1216));
  result = select_bet5_deserializeFeatures_Free((_QWORD *)v2, *(_QWORD **)(a1 + 32));
  v4 = *(_QWORD *)(a1 + 1256);
  if (v4)
  {
    if (*(_DWORD *)(a1 + 1264))
    {
      v5 = 0;
      v6 = 0;
      do
      {
        v7 = (*(uint64_t (**)(_QWORD *))(*(_QWORD *)(a1 + 64) + 152))(result);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD))(v7 + 16))(*(_QWORD *)(a1 + 1256) + v5, *(_QWORD *)(v2 + 8));
        ++v6;
        v5 += 32;
      }
      while (v6 < *(unsigned int *)(a1 + 1264));
      v4 = *(_QWORD *)(a1 + 1256);
    }
    result = heap_Free(*(_QWORD **)(v2 + 8), v4);
    *(_QWORD *)(a1 + 1256) = 0;
  }
  return result;
}

uint64_t select_bet5_GetEEMode(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result;
  _BYTE *v6;

  v6 = 0;
  *a2 = 1;
  *a3 = 0;
  result = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40), (uint64_t)"bet5earlyemissionallowed", &v6);
  if ((result & 0x80000000) == 0 && v6 && *v6)
  {
    result = (uint64_t)cstdlib_strchr("yYtT1", (char)*v6);
    if (result)
    {
      *a3 = 1;
      *a2 = 0;
    }
  }
  return result;
}

uint64_t select_bet5_ProcessAndWriteMarkers(uint64_t a1, unsigned int a2)
{
  uint64_t Stream;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  int v20;
  _DWORD *v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  _DWORD *v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  __int128 __b;
  __int128 v53;

  if (!*(_QWORD *)(a1 + 1256) || *(_DWORD *)(a1 + 1268) >= *(_DWORD *)(a1 + 1264))
    return 0;
  Stream = UnicornPipelineClass_GetStream(*(_QWORD *)(a1 + 1232), *(_QWORD *)(a1 + 1240));
  v8 = Stream;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 11912);
  v10 = a2 / v9;
  v11 = *(_QWORD *)(a1 + 1256);
  v12 = *(unsigned int *)(a1 + 1268);
  v13 = (int *)(v11 + 32 * v12);
  v14 = *(_DWORD *)(Stream + 400);
  if (v14 < a2 / v9)
  {
    v15 = 0;
    v16 = 0;
    v17 = *(_DWORD *)(a1 + 1264);
    v18 = v17 >= v12;
    v19 = v17 - v12;
    if (!v18)
      v19 = 0;
    v20 = *(_DWORD *)(Stream + 400);
    v21 = (_DWORD *)(v11 + 32 * v12);
    do
    {
      if (v16 == v19)
        break;
      v21[4] = 0;
      if (*v21 == 33)
      {
        v22 = 0;
        v23 = v20 * v9;
        v24 = v9;
        do
        {
          v5 = *(unsigned int *)(*(_QWORD *)(v8 + 1800) + 40 * v23 + 8);
          v22 += v5;
          ++v23;
          --v24;
        }
        while (v24);
        v21[4] = v22;
        ++v15;
      }
      v21 += 8;
      ++v16;
      v20 = v14 + v15;
    }
    while (v14 + v15 < v10);
  }
  if (*(_DWORD *)(a1 + 1288))
  {
    v25 = *(_DWORD *)(a1 + 1280);
    if (v25)
    {
      v26 = *(_DWORD *)(a1 + 1264);
      v27 = v12;
      if (v12 < v26)
      {
        while (1)
        {
          v28 = *v13;
          v13 += 8;
          if (v28 == 33)
            break;
          if (v26 == ++v27)
          {
            v27 = *(_DWORD *)(a1 + 1264);
            break;
          }
        }
      }
      if (v27 == v26)
        v29 = v12;
      else
        v29 = v27;
      v30 = v11 + 32 * v29;
      v32 = *(_DWORD *)(v30 + 16);
      v31 = (unsigned int *)(v30 + 16);
      v33 = *(_DWORD *)(*(_QWORD *)(v8 + 1800) + 40 * (v25 - 1) + 8);
      v18 = v32 >= v33;
      v34 = v32 - v33;
      if (v18)
        *v31 = v34;
    }
  }
  if (v14 >= v10)
  {
    v35 = 0;
  }
  else
  {
    LODWORD(v35) = 0;
    v36 = *(_DWORD *)(a1 + 1264);
    v18 = v36 >= v12;
    LODWORD(v37) = v36 - v12;
    if (v18)
      v37 = v37;
    else
      v37 = 0;
    v38 = (_DWORD *)(v11 + 32 * v12 + 16);
    while ((_DWORD)v37 != (_DWORD)v35)
    {
      v39 = *(_DWORD *)(a1 + 1272);
      *(v38 - 1) = v39;
      if (*(v38 - 4) == 33)
      {
        *(_DWORD *)(a1 + 1272) = *v38 + v39;
        *(_DWORD *)(v8 + 400) = ++v14;
      }
      v35 = (v35 + 1);
      v38 += 8;
      if (v14 >= v10)
        goto LABEL_38;
    }
    v35 = v37;
  }
LABEL_38:
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"About to write %d markers, starting with index %d", v5, v6, v7, v35);
  v41 = *(unsigned int *)(a1 + 1268);
  if (v41 < (int)v41 + (int)v35)
  {
    v42 = 32 * v41;
    do
    {
      marker_logOutText(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET5", 3, (uint64_t)"Outputting marker ", *(_QWORD *)(a1 + 1256) + v42);
      ++v41;
      v42 += 32;
    }
    while (v41 < (*(_DWORD *)(a1 + 1268) + v35));
    LODWORD(v41) = *(_DWORD *)(a1 + 1268);
  }
  if ((_DWORD)v35)
  {
    v40 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 64) + 104))(*(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 192), *(_QWORD *)(a1 + 1256) + 32 * v41, (32 * v35));
    if ((v40 & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 58008, (uint64_t)"%s%s%s%x", v43, v44, v45, v46, "contentType");
  }
  else
  {
    v40 = 0;
  }
  *(_DWORD *)(a1 + 1268) += v35;
  if (*(_DWORD *)(a1 + 1292))
  {
    __b = 0u;
    v53 = 0u;
    cstdlib_memset(&__b, 0, 0x20uLL);
    DWORD2(v53) = 35;
    v47 = *(_DWORD *)(a1 + 1272);
    LODWORD(__b) = 33;
    HIDWORD(__b) = v47;
    LODWORD(v53) = *(_DWORD *)(*(_QWORD *)(v8 + 1800) + 40 * (a2 - 1) + 8);
    *(_DWORD *)(a1 + 1272) = v53 + v47;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32), (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"Outputting             trailSilMrk:tag=%d u32Value=%d posCur=%d lenCur=%d", v48, v49, v50, 33);
    return (*(uint64_t (**)(_QWORD, _QWORD, __int128 *, uint64_t))(*(_QWORD *)(a1 + 64) + 104))(*(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 192), &__b, 32);
  }
  return v40;
}

uint64_t select_bet5_WriteAll(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, unsigned int a7, unsigned int a8, int a9, int a10, int a11)
{
  unint64_t v11;
  uint64_t i;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  _DWORD *v48;
  uint64_t v49;
  int v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t j;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v11 = a6 - a5 + a7 + a8;
  if (!(a6 - a5 + a7 + a8))
    return 0;
  for (i = 1; i != 12; ++i)
  {
    v16 = 0;
    while (s_select_Bet5_SynthStreamInfo[v16 + 1] != (_DWORD)i)
    {
      v16 += 6;
      if (v16 == 114)
      {
        LODWORD(v17) = 0;
        goto LABEL_8;
      }
    }
    v17 = *(_QWORD *)&s_select_Bet5_SynthStreamInfo[v16 + 4];
LABEL_8:
    v22 = (*(uint64_t (**)(_QWORD, _QWORD, char *, _QWORD))(a3 + 112))(*(_QWORD *)(a2 + 16 * i), *(_QWORD *)(a2 + 16 * i + 8), (char *)&v80 + 8 * i, (v11 * v17));
    if ((v22 & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET5", 71003, (uint64_t)"%s%s%s%x", v18, v19, v20, v21, "contentType");
      return v22;
    }
  }
  if (a7)
  {
    v23 = 0;
    v24 = *(_QWORD *)(a4 + 1800);
    v25 = *((_QWORD *)&v80 + 1);
    v26 = v81;
    v27 = *((_QWORD *)&v82 + 1);
    v28 = v83;
    v30 = v84;
    v29 = v85;
    v31 = (_DWORD *)(v82 + 4);
    v32 = *((_QWORD *)&v85 + 1);
    do
    {
      *(v31 - 1) = 0;
      *v31 = a9 + a5 + v23;
      if (v24)
      {
        *(_DWORD *)(v25 + 4 * v23) = -1;
        *(_DWORD *)(v26 + 4 * v23) = 0;
        *(_DWORD *)(*((_QWORD *)&v26 + 1) + 4 * v23) = 0;
        *(_DWORD *)(v27 + 4 * v23) = 0;
        *(_DWORD *)(v28 + 4 * v23) = 0;
        *(_DWORD *)(*((_QWORD *)&v28 + 1) + 4 * v23) = 0;
        *(_DWORD *)(v30 + 4 * v23) = 0;
        *(_DWORD *)(*((_QWORD *)&v30 + 1) + 4 * v23) = 0;
        *(_DWORD *)(v29 + 4 * v23) = 0;
        *(_DWORD *)(v32 + 4 * v23) = 0;
      }
      ++v23;
      v31 += 2;
    }
    while (a7 != v23);
  }
  v33 = a8;
  v34 = v11 - a8;
  if (v34 > a7)
  {
    v35 = 0;
    v36 = *((_QWORD *)&v85 + 1) + 4 * a7;
    v37 = v85 + 4 * a7;
    if (a11)
      v38 = 3;
    else
      v38 = 1;
    v39 = *((_QWORD *)&v84 + 1) + 4 * a7;
    v40 = v84 + 4 * a7;
    v41 = *((_QWORD *)&v83 + 1) + 4 * a7;
    v42 = v83 + 4 * a7;
    v43 = *((_QWORD *)&v82 + 1) + 4 * a7;
    v44 = *((_QWORD *)&v81 + 1) + 4 * a7;
    v45 = v81 + 4 * a7;
    v46 = *(_QWORD *)(a4 + 1800);
    v47 = ~(unint64_t)a8 + v11 - a7;
    v48 = (_DWORD *)(v82 + 8 * a7 + 4);
    v49 = *((_QWORD *)&v80 + 1) + 4 * a7;
    do
    {
      if (v47 != v35 || a10 == 0)
        v51 = 0;
      else
        v51 = v38;
      *(v48 - 1) = v51;
      *v48 = a9 + a7 + a5 + v35;
      if (v46)
      {
        v52 = (_DWORD *)(v46 + 40 * (a5 + v35));
        *(_DWORD *)(v49 + 4 * v35) = *v52;
        *(_DWORD *)(v45 + 4 * v35) = v52[1];
        *(_DWORD *)(v44 + 4 * v35) = v52[2];
        *(_DWORD *)(v43 + 4 * v35) = v52[3];
        *(_DWORD *)(v42 + 4 * v35) = v52[4];
        *(_DWORD *)(v41 + 4 * v35) = v52[5];
        *(_DWORD *)(v40 + 4 * v35) = v52[6];
        *(_DWORD *)(v39 + 4 * v35) = v52[7];
        *(_DWORD *)(v37 + 4 * v35) = v52[8];
        *(_DWORD *)(v36 + 4 * v35) = v52[9];
      }
      ++v35;
      v48 += 2;
    }
    while ((unint64_t)a7 + v35 < v34);
  }
  if (v34 < v11)
  {
    v53 = 0;
    v54 = 4 * v11 - 4 * v33;
    v55 = *((_QWORD *)&v85 + 1) + v54;
    v56 = v85 + v54;
    v57 = *((_QWORD *)&v84 + 1) + v54;
    v58 = v84 + v54;
    v59 = *((_QWORD *)&v83 + 1) + v54;
    v60 = v83 + v54;
    v61 = *((_QWORD *)&v82 + 1) + v54;
    v62 = *((_QWORD *)&v81 + 1) + v54;
    v63 = v81 + v54;
    v64 = *((_QWORD *)&v80 + 1) + v54;
    v65 = *(_QWORD *)(a4 + 1800);
    v66 = (_DWORD *)(v82 - 8 * v33 + 8 * v11 + 4);
    do
    {
      *(v66 - 1) = 0;
      *v66 = a9 + a7 + a6 + v53;
      if (v65)
      {
        *(_DWORD *)(v64 + 4 * v53) = -1;
        *(_DWORD *)(v63 + 4 * v53) = 0;
        *(_DWORD *)(v62 + 4 * v53) = 0;
        *(_DWORD *)(v61 + 4 * v53) = 0;
        *(_DWORD *)(v60 + 4 * v53) = 0;
        *(_DWORD *)(v59 + 4 * v53) = 0;
        *(_DWORD *)(v58 + 4 * v53) = 0;
        *(_DWORD *)(v57 + 4 * v53) = 0;
        *(_DWORD *)(v56 + 4 * v53) = 0;
        *(_DWORD *)(v55 + 4 * v53) = 0;
      }
      ++v53;
      v66 += 2;
    }
    while (v33 != v53);
  }
  for (j = 1; j != 12; ++j)
  {
    if (*((_QWORD *)&v80 + j))
    {
      v68 = 0;
      while (s_select_Bet5_SynthStreamInfo[v68 + 1] != (_DWORD)j)
      {
        v68 += 6;
        if (v68 == 114)
        {
          LODWORD(v69) = 0;
          goto LABEL_41;
        }
      }
      v69 = *(_QWORD *)&s_select_Bet5_SynthStreamInfo[v68 + 4];
LABEL_41:
      v22 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a3 + 120))(*(_QWORD *)(a2 + 16 * j), *(_QWORD *)(a2 + 16 * j + 8), (v11 * v69));
      if ((v22 & 0x80000000) != 0)
        log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET5", 71003, (uint64_t)"%s%s%s%x", v70, v71, v72, v73, "contentType");
    }
  }
  return v22;
}

uint64_t select_bet5_ReadDirectStart(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t *v16;
  uint64_t NullHandle;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v13 = 0;
  while (s_select_Bet5_SynthStreamInfo[v13] != a4)
  {
    v13 += 6;
    if (v13 == 114)
      return 2229280788;
  }
  v15 = *(const char **)&s_select_Bet5_SynthStreamInfo[v13 + 2];
  v16 = (uint64_t *)(a2 + 16 * a4);
  NullHandle = safeh_GetNullHandle();
  v19 = safeh_HandlesEqual(*v16, v16[1], NullHandle, v18);
  if (a4 - 3 <= 3 && v19)
    return 0;
  if (cstdlib_strcmp(v15, a5))
  {
    v14 = 2229280788;
  }
  else
  {
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 88))(*v16, v16[1], a6, a7);
    if ((v14 & 0x80000000) == 0)
      return v14;
  }
  log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET5", 71001, (uint64_t)"%s%s", v20, v21, v22, v23, "layer");
  return v14;
}

uint64_t select_bet5_ReadDirectEnd(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, const char *a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t *v13;
  uint64_t NullHandle;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v10 = result;
  v11 = 0;
  while (s_select_Bet5_SynthStreamInfo[v11] != a4)
  {
    v11 += 6;
    if (v11 == 114)
      return result;
  }
  v12 = *(const char **)&s_select_Bet5_SynthStreamInfo[v11 + 2];
  v13 = (uint64_t *)(a2 + 16 * a4);
  NullHandle = safeh_GetNullHandle();
  result = safeh_HandlesEqual(*v13, v13[1], NullHandle, v15);
  if (a4 - 3 > 3 || !(_DWORD)result)
  {
    if (cstdlib_strcmp(v12, a5))
      return log_OutPublic(*(_QWORD *)(v10 + 32), (uint64_t)"SELECT_BET5", 71001, (uint64_t)"%s%s", v16, v17, v18, v19, "layer");
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 96))(*v13, v13[1], a6);
    if ((result & 0x80000000) != 0)
      return log_OutPublic(*(_QWORD *)(v10 + 32), (uint64_t)"SELECT_BET5", 71001, (uint64_t)"%s%s", v16, v17, v18, v19, "layer");
  }
  return result;
}

uint64_t PredictPipeline_ProcessStart(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t (**v5)(_QWORD, _QWORD *);
  const char *v7;
  _QWORD v8[3];

  v3 = *(_QWORD *)(a1 + 1072);
  v4 = (_QWORD *)*(unsigned int *)(a1 + 392);
  v8[1] = a2;
  v8[2] = a3;
  v8[0] = a1;
  v5 = *(uint64_t (***)(_QWORD, _QWORD *))(a1 + 1760);
  if (((*v5)(v5, v8) & 0x80000000) != 0)
  {
    v7 = "PredictPipeline, Error, self->Open\n";
  }
  else
  {
    if ((v5[1](v5, v4) & 0x80000000) == 0)
      return 0;
    v7 = "PredictPipeline, Error, self->Set\n";
  }
  UNICORN__log_select_Diag(v3, 0, (uint64_t)v7);
  return 2229280778;
}

uint64_t PredictPipeline_Create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD v6[3];

  v6[1] = a2;
  v6[2] = a3;
  v6[0] = 0;
  v4 = UnicornPredict_Create(a1, (uint64_t)v6);
  if (!v4)
    UNICORN__log_select_Diag(a1, 0, (uint64_t)"PredictPipeline, Error, UnicornPredict_Create\n");
  return v4;
}

uint64_t PredictPipeline_Process(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 224) + 1072);
  if (((*(uint64_t (**)(void))(a1 + 16))() & 0x80000000) == 0)
    return 0;
  UNICORN__log_select_Diag(v1, 0, (uint64_t)"PredictPipeline, Error, self->Process\n");
  return 2229280778;
}

uint64_t PredictPipeline_Destroy(uint64_t a1)
{
  UnicornPredict_Destroy(a1);
  return 0;
}

uint64_t PredictPipeline_GetNProcessedPhonemes(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(void))(result + 40))();
  return result;
}

uint64_t Search_NoPrune(_QWORD *a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, _QWORD *a8, signed int a9, int a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v24;
  uint64_t result;
  BOOL v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  float v30;
  uint64_t v31;
  int v32;
  float *IndexPtr_LH_F32;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v11 = a1[14];
  v10 = a1[15];
  if (*(_DWORD *)(v11 + 5992) == 1)
  {
    v14 = a2;
    v15 = a3;
    v16 = *(_DWORD *)(*(_QWORD *)(a5 + 8 * a2 + 56) + 4 * a3);
    v17 = a1[13];
    v18 = v17 + 768;
    v36 = (_QWORD *)(v17 + 768 + 8 * a2 + 40);
    v37 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v17 + 768 + 8 * a2) + 8 * a3) + 40 * v16);
    v38 = v17;
    v19 = *(_DWORD *)(*(_QWORD *)(v17 + 848)
                    + 4 * (*(_DWORD *)(*v36 + 4 * v37) / *(_DWORD *)(*(_QWORD *)(v17 + 568) + 5992)));
    IndexPtr_LH_F32 = (float *)VectBlock_Get_IndexPtr_LH_F32(v10 + 1848, a9);
    v20 = a8[2] + 32 * a9;
    v40 = v14;
    v39 = v18;
    v21 = *(_QWORD *)(*(_QWORD *)(v18 + 8 * v14) + 8 * v15);
    v22 = v16;
    v23 = *(_DWORD *)(v21 + 40 * v16 + 4);
    v24 = *(_DWORD *)(v20 + 16);
    if (*(_DWORD *)(v20 + 20) < v23)
    {
      result = UNICORN__mfs_CostList_Resize(a8, a9, v23);
      if ((result & 0x80000000) != 0)
        return result;
      v23 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v15) + 40 * v16 + 4);
    }
    if (v23)
      v26 = v24 - a6 >= a7;
    else
      v26 = 1;
    if (!v26)
    {
      v27 = 0;
      do
      {
        v28 = a7;
        v29 = *(_DWORD *)(*v36 + 4 * (v37 + v27));
        v30 = mfs_bnfData_Distance(v38, IndexPtr_LH_F32, v29);
        if (a10)
        {
          v31 = a8[9];
          *(_DWORD *)(a8[8] + 4 * ((v29 / *(_DWORD *)(v11 + 5992)) >> 5)) |= 1 << (v29 / *(_DWORD *)(v11 + 5992));
          v32 = v19 + v27;
          *(float *)(v31 + 4 * (v19 + v27)) = v30;
        }
        else
        {
          v32 = v19 + v27;
        }
        mfs_CostList_PadWithBnfOffset(a8, a9, v29, v32, v30);
        ++v27;
        a7 = v28;
      }
      while (v27 < *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v15) + 40 * v22 + 4)
           && *(_DWORD *)(a8[2] + 32 * a9 + 16) - a6 < v28);
    }
    return 0;
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(v10 + 1072), 1, (uint64_t)"CONFIG ERROR : Search is not implemented for Phoneme Substate Modeling\n");
    return 2229280768;
  }
}

uint64_t Search_PruneBNF(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, _QWORD *a8, signed int a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t IndexPtr_LH_F32;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  unsigned int v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BOOL4 IsPhonemeDurationOutlier;
  float v33;
  float v34;
  float v35;
  unsigned int v37;
  float *v41;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;

  v10 = a1[14];
  v9 = a1[15];
  if (*(_DWORD *)(v10 + 5992) == 1)
  {
    v13 = a2;
    v14 = (int)a3;
    v15 = *(_DWORD *)(*(_QWORD *)(a5 + 8 * a2 + 56) + 4 * (int)a3);
    v16 = a1[13];
    v45 = *(unsigned __int8 *)(a4 + 1);
    v44 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v16 + 768 + 8 * a2) + 8 * (int)a3) + 40 * v15);
    IndexPtr_LH_F32 = VectBlock_Get_IndexPtr_LH_F32(v9 + 1848, a9);
    v18 = a9;
    v41 = (float *)IndexPtr_LH_F32;
    v19 = a8[2] + 32 * a9;
    v20 = v13;
    v46 = v16 + 768;
    v47 = v15;
    v48 = v14;
    v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v16 + 768 + 8 * v13) + 8 * v14) + 40 * v15 + 4);
    v22 = *(_DWORD *)(v19 + 16);
    if (*(_DWORD *)(v19 + 20) >= v21)
    {
      v23 = a6;
    }
    else
    {
      v23 = a6;
      v24 = UNICORN__mfs_CostList_Resize(a8, a9, v21);
      if ((v24 & 0x80000000) != 0)
        return v24;
      v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v46 + 8 * v20) + 8 * v48) + 40 * v15 + 4);
      v18 = a9;
    }
    v43 = v18;
    if (v21)
      v26 = v22 - v23 >= a7;
    else
      v26 = 1;
    if (v26)
    {
      v27 = *(_DWORD *)(a8[2] + 32 * a9 + 16);
    }
    else
    {
      v29 = 1;
      do
      {
        v30 = a7;
        v28 = (_QWORD *)(v16 + 8 * v20 + 808);
        v31 = *(unsigned int *)(*v28 + 4 * (v44 + v29 - 1));
        if (v45 == 1
          || (IsPhonemeDurationOutlier = UNICORN__IsPhonemeDurationOutlier(v16, *(_DWORD *)(*v28 + 4 * (v44 + v29 - 1)), *(float *)(v10 + 6160), a3, *(_DWORD *)(a5 + 24), *(_DWORD *)(a5 + 28)), v33 = 9999.9, !IsPhonemeDurationOutlier))
        {
          v33 = mfs_bnfData_Distance(v16, v41, v31);
        }
        v34 = *(float *)(*(_QWORD *)(v16 + 592) + 16 * v31);
        v35 = *(float *)(v10 + 6192);
        if (v34 < v35)
          v33 = v33 * (float)(v34 / v35);
        if (v33 <= 0.5 || (v27 = *(_DWORD *)(a8[2] + 32 * a9 + 16), v27 <= 0xC8))
        {
          UNICORN__mfs_CostList_Pad(a8, v43, v31, v33);
          v27 = *(_DWORD *)(a8[2] + 32 * a9 + 16);
        }
        v26 = v29++ >= *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v46 + 8 * v20) + 8 * v48) + 40 * v47 + 4);
        a7 = v30;
      }
      while (!v26 && v27 - v23 < v30);
    }
    v37 = *(_DWORD *)(v10 + 6144);
    if (v27 <= v37)
    {
      return 0;
    }
    else
    {
      v25 = mfs_CostList_Select((uint64_t)a8, v43, 1, v37);
      if ((v25 & 0x80000000) == 0)
        UNICORN__mfs_CostList_Prune(a8, v43, *(_DWORD *)(v10 + 6144));
    }
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(v9 + 1072), 1, (uint64_t)"CONFIG ERROR : Search is not implemented for Phoneme Substate Modeling\n");
    return 2229280768;
  }
  return v25;
}

uint64_t Search_Diphone_PruneBNF(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, _QWORD *a8, signed int a9)
{
  uint64_t v9;
  uint64_t v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  BOOL v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _BOOL4 IsPhonemeDurationOutlier;
  float v38;
  BOOL v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v46;
  uint64_t v47;
  float *IndexPtr_LH_F32;
  uint64_t v50;
  int v51;
  uint64_t v52;
  _QWORD *v53;
  int v54;
  uint64_t v55;

  v9 = a1[15];
  if (*(_DWORD *)(a1[14] + 5992) != 1)
  {
    v42 = 2229280768;
    v43 = *(_QWORD *)(v9 + 1072);
    v44 = "CONFIG ERROR : Search is not implemented for Phoneme Substate Modeling\n";
LABEL_29:
    UNICORN__log_select_Diag(v43, 1, (uint64_t)v44);
    return v42;
  }
  v12 = a3;
  v50 = a1[14];
  v14 = *(_DWORD *)(*(_QWORD *)(a5 + 8 * a2 + 56) + 4 * (int)a3);
  v51 = *(unsigned __int8 *)(a4 + 1);
  v15 = a1[13];
  v55 = v15 + 768;
  v16 = *(_QWORD *)(*(_QWORD *)(v15 + 768 + 8 * a2) + 8 * (int)a3);
  v54 = *(_DWORD *)(v16 + 40 * v14);
  v17 = a8[2] + 32 * a9;
  v18 = *(_DWORD *)(v16 + 40 * v14 + 4);
  v20 = *(_DWORD *)(v17 + 16);
  if (*(_DWORD *)(v17 + 20) < v18)
  {
    v21 = v12;
    v22 = UNICORN__mfs_CostList_Resize(a8, a9, v18);
    v12 = v21;
    if ((v22 & 0x80000000) != 0)
      return v22;
  }
  v53 = a8;
  v46 = v9;
  v47 = v12;
  v23 = (int)v12;
  IndexPtr_LH_F32 = (float *)VectBlock_Get_IndexPtr_LH_F32(v9 + 1848, a9);
  v28 = v54;
  v52 = a2;
  v29 = *(_QWORD *)(v55 + 8 * a2);
  v30 = a7;
  if (*(_DWORD *)(*(_QWORD *)(v29 + 8 * v23) + 40 * v14 + 4))
    v31 = v20 - a6 >= a7;
  else
    v31 = 1;
  if (!v31)
  {
    v32 = (_QWORD *)(v15 + 8 * a2 + 808);
    v33 = 0xFFFFFFFFLL;
    v34 = 1;
    do
    {
      v35 = *(unsigned int *)(*v32 + 4 * (v28 + v34 - 1));
      v36 = *(_QWORD *)(v15 + 592);
      if (*(unsigned __int8 *)(v36 + 16 * v35 + 13) == *(unsigned __int8 *)(a4 + 1)
        && *(unsigned __int8 *)(v36 + 16 * v35 + 14) == *(unsigned __int8 *)(a4 + 2))
      {
        if ((v51 == 1
           || (IsPhonemeDurationOutlier = UNICORN__IsPhonemeDurationOutlier(v15, *(_DWORD *)(*v32 + 4 * (v28 + v34 - 1)), *(float *)(v50 + 6160), v47, *(_DWORD *)(a5 + 24), *(_DWORD *)(a5 + 28)), v38 = 9999.9, !IsPhonemeDurationOutlier))&& (v38 = mfs_bnfData_Distance(v15, IndexPtr_LH_F32, v35), v38 <= 0.5)|| *(_DWORD *)(v53[2] + 32 * a9 + 16) <= 0xC8u)
        {
          if (v35 <= v33)
            UNICORN__mfs_CostList_Add(v38, v15, v53, a9, v35);
          else
            UNICORN__mfs_CostList_Pad(v53, a9, v35, v38);
        }
        v20 = *(_DWORD *)(v53[2] + 32 * a9 + 16);
        v28 = v54;
        v29 = *(_QWORD *)(v55 + 8 * v52);
        v30 = a7;
      }
      else
      {
        v35 = v33;
      }
      v31 = v34++ >= *(unsigned int *)(*(_QWORD *)(v29 + 8 * v23) + 40 * v14 + 4);
      v39 = v31 || v20 - a6 >= v30;
      v33 = v35;
    }
    while (!v39);
  }
  v40 = *(_DWORD *)(v53[2] + 32 * a9 + 16);
  v41 = *(unsigned int *)(v50 + 6144);
  if (v40 <= v41)
  {
    v42 = 0;
  }
  else
  {
    v42 = mfs_CostList_Select((uint64_t)v53, a9, 1, v41);
    if ((v42 & 0x80000000) != 0)
      return v42;
    UNICORN__mfs_CostList_Prune(v53, a9, *(_DWORD *)(v50 + 6144));
    v40 = *(_DWORD *)(v53[2] + 32 * a9 + 16);
  }
  if (!v40)
  {
    UNICORN__log_select_Error(*(_QWORD *)(v46 + 1072), 0, (uint64_t)"** ERROR no candidates found for Offline Unit Bulking: state #%d (diphone: A%02d+A%02d)\n", v41, v24, v25, v26, v27);
    return 2229280783;
  }
  if (v40 <= 0x31)
  {
    v43 = *(_QWORD *)(v46 + 1072);
    v44 = "** Warning too few candidates (%d) for Offline Unit Bulking: state #%d (diphone: A%02d+A%02d)\n";
    goto LABEL_29;
  }
  return v42;
}

uint64_t mfs_QuantizeLF0Frame(uint64_t a1, float a2)
{
  float v2;

  if (a2 <= 0.0)
  {
    if (*(_DWORD *)(a1 + 5596))
      return *(unsigned int *)(a1 + 5600);
    else
      return 0;
  }
  else
  {
    v2 = *(float *)(a1 + 6016);
    if (v2 > a2)
      a2 = *(float *)(a1 + 6016);
    if (a2 > *(float *)(a1 + 6036))
      a2 = *(float *)(a1 + 6036);
    return (float)((float)((float)(a2 - v2) * *(float *)(a1 + 6056)) + 0.5);
  }
}

uint64_t mfs_UpdateTargetQuantizedTrajectory_LF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  unsigned int v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  unsigned int v16;

  v3 = *(unsigned int *)(a3 + 104);
  if ((int)v3 < 1)
    return 0;
  v6 = *(_QWORD *)(a1 + 568);
  v7 = *(_DWORD *)(a2 + 1824);
  v8 = *(float **)(a3 + 32);
  v9 = 2229280778;
  v10 = *(_QWORD *)(a2 + 1072);
  *(_DWORD *)(a2 + 1824) = v3 + v7;
  v11 = heap_Realloc(*(uint64_t **)(v10 + 8), *(_QWORD *)(a2 + 1808), 2 * (v3 + v7));
  *(_QWORD *)(a2 + 1808) = v11;
  if (v11)
  {
    v12 = heap_Realloc(*(uint64_t **)(v10 + 8), *(_QWORD *)(a2 + 1816), 4 * *(unsigned int *)(a2 + 1824));
    *(_QWORD *)(a2 + 1816) = v12;
    if (v12)
    {
      v13 = *(_QWORD *)(a2 + 1808);
      do
      {
        v14 = *v8;
        if (*v8 <= 0.0)
        {
          v16 = *(_DWORD *)(v6 + 5596);
          if (v16)
            v16 = *(_DWORD *)(v6 + 5600);
        }
        else
        {
          v15 = *(float *)(v6 + 6016);
          if (v15 > v14)
            v14 = *(float *)(v6 + 6016);
          if (v14 > *(float *)(v6 + 6036))
            v14 = *(float *)(v6 + 6036);
          v16 = (float)((float)((float)(v14 - v15) * *(float *)(v6 + 6056)) + 0.5);
        }
        *(_WORD *)(v13 + 2 * v7) = v16;
        *(_DWORD *)(v12 + 4 * v7++) = *(_DWORD *)(a3 + 120);
        ++v8;
        --v3;
      }
      while (v3);
      return 0;
    }
  }
  return v9;
}

uint64_t UnicornPredict_Create(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 312);
  v5 = v4;
  if (v4)
  {
    v6 = *(_QWORD *)(a2 + 16);
    if (*(_QWORD *)(v6 + 8016))
    {
      if ((ANNFactory_CreateANNLibInstance((_QWORD *)(v4 + 56), a1) & 0x80000000) != 0)
        goto LABEL_12;
    }
    else
    {
      if (!*(_QWORD *)(v6 + 9816))
      {
        UNICORN__log_select_Diag(a1, 0, (uint64_t)"%s_Create failed because the model does not contain BET5 ANN data\n");
        goto LABEL_12;
      }
      if ((ANNFactory_CreateFastInferInstance((_QWORD *)(v4 + 56), a1) & 0x80000000) != 0)
      {
LABEL_12:
        heap_Free(*(_QWORD **)(a1 + 8), v5);
        return 0;
      }
    }
    *(_DWORD *)(v5 + 144) = 20;
    v7 = heap_Calloc(*(_QWORD **)(a1 + 8), 20, 16);
    *(_QWORD *)(v5 + 136) = v7;
    if (!v7)
    {
LABEL_10:
      (*(void (**)(_QWORD))(v5 + 128))(*(_QWORD *)(v5 + 56));
      goto LABEL_12;
    }
    *(_QWORD *)v5 = UnicornPredict_Open;
    *(_QWORD *)(v5 + 8) = UnicornPredict_Set;
    *(_QWORD *)(v5 + 16) = UnicornPredict_Process;
    *(_QWORD *)(v5 + 24) = UnicornPredict_Reset;
    *(_QWORD *)(v5 + 32) = UnicornPredict_Close;
    *(_QWORD *)(v5 + 40) = UnicornPredict_GetNProcessedPhonemes;
    *(_QWORD *)(v5 + 48) = a1;
    if (((*(uint64_t (**)(_QWORD, _QWORD))(v5 + 64))(*(_QWORD *)(v5 + 56), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 1944)) & 0x80000000) != 0)
    {
      UNICORN__log_select_Diag(a1, 0, (uint64_t)"%s_Create, Error, ANNObject Open failed\n");
      goto LABEL_10;
    }
  }
  return v5;
}

uint64_t UnicornPredict_Open(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;

  if (!a1)
    return 2229280778;
  v3 = a2[1];
  v2 = a2[2];
  v4 = *a2;
  *(_QWORD *)(a1 + 216) = v2;
  *(_QWORD *)(a1 + 224) = v4;
  *(_QWORD *)(a1 + 184) = v2;
  *(_QWORD *)(a1 + 192) = v3;
  *(_QWORD *)(a1 + 168) = v3;
  *(_QWORD *)(a1 + 176) = v4;
  v5 = *(_DWORD *)v3;
  v6 = *(_DWORD *)(v4 + 392);
  *(_DWORD *)(a1 + 200) = v6;
  *(_DWORD *)(a1 + 204) = v5;
  v7 = 1;
  v8 = *(unsigned __int8 *)(v3 + 1932);
  if (*(_DWORD *)(v2 + 6728))
    v8 *= 8;
  *(_DWORD *)(a1 + 160) = v8;
  if (*(_DWORD *)(v2 + 5984))
    v9 = 1;
  else
    v9 = v5;
  *(_DWORD *)(a1 + 208) = v6 * v9;
  *(_DWORD *)(a1 + 212) = 1;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  v10 = *(_DWORD *)(a1 + 144);
  if (v10)
  {
    v11 = *(_QWORD *)(v2 + 10408);
    v12 = *(_QWORD **)(a1 + 136);
    *(_DWORD *)(a1 + 148) = 1;
    *v12 = v11;
    v12[1] = UnicornPredict_CopyOutputToBNFStream;
  }
  else
  {
    v7 = 0;
  }
  if (v7 < v10)
  {
    v14 = *(_QWORD *)(v2 + 10416);
    v15 = (_QWORD *)(*(_QWORD *)(a1 + 136) + 16 * v7++);
    *(_DWORD *)(a1 + 148) = v7;
    *v15 = v14;
    v15[1] = UnicornPredict_CopyOutputToLF0Stream;
  }
  if (v7 < v10)
  {
    v16 = *(_QWORD *)(v2 + 10424);
    v17 = (_QWORD *)(*(_QWORD *)(a1 + 136) + 16 * v7++);
    *(_DWORD *)(a1 + 148) = v7;
    *v17 = v16;
    v17[1] = UnicornPredict_CopyOutputToDURStream;
  }
  if (v7 < v10)
  {
    v18 = *(_QWORD *)(v2 + 10432);
    v19 = (_QWORD *)(*(_QWORD *)(a1 + 136) + 16 * v7++);
    *(_DWORD *)(a1 + 148) = v7;
    *v19 = v18;
    v19[1] = UnicornPredict_CopyOutputToSDURStream;
  }
  if (v7 < v10)
  {
    v20 = *(_QWORD *)(v2 + 10440);
    v21 = (_QWORD *)(*(_QWORD *)(a1 + 136) + 16 * v7++);
    *(_DWORD *)(a1 + 148) = v7;
    *v21 = v20;
    v21[1] = UnicornPredict_CopyOutputToVUVStream;
  }
  if (v7 >= v10)
    return 0;
  v13 = 0;
  v22 = *(_QWORD *)(v2 + 10448);
  v23 = (_QWORD *)(*(_QWORD *)(a1 + 136) + 16 * v7);
  *(_DWORD *)(a1 + 148) = v7 + 1;
  *v23 = v22;
  v23[1] = UnicornPredict_CopyOutputToELF0Stream;
  return v13;
}

uint64_t UnicornPredict_Set(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;

  *(_DWORD *)(a1 + 200) = a2;
  v3 = *(_QWORD *)(a1 + 216);
  v4 = *(_QWORD *)(a1 + 224);
  if (!*(_DWORD *)(v3 + 5984))
    a2 *= *(_DWORD *)(a1 + 204);
  *(_DWORD *)(a1 + 208) = a2;
  *(_DWORD *)(v4 + 1944) = *(_DWORD *)(v3 + 6728) != 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  v5 = (*(uint64_t (**)(_QWORD))(a1 + 120))(*(_QWORD *)(a1 + 56));
  v6 = *(_DWORD *)(a1 + 208);
  if (*(_DWORD *)(v4 + 1840) == 4 * (v6 * v5))
  {
    v7 = *(_DWORD *)(a1 + 160);
    v8 = v7 * v6;
    v10 = (uint64_t *)(a1 + 48);
    v9 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(v4 + 1832);
    if (*(_DWORD *)(*(_QWORD *)(a1 + 216) + 6728))
    {
      v11 = v8 >> 3;
      v7 >>= 3;
      v12 = v4 + 1864;
    }
    else
    {
      v12 = v4 + 1864;
      v11 = v7 * v6;
    }
    if (VectBlock_Create(v9, v12, v11, v7))
    {
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(v4 + 1864);
      if (VectBlock_Create(*(_QWORD *)(a1 + 48), v4 + 1848, 4 * v8, *(_DWORD *)(a1 + 160)))
      {
        *(_QWORD *)(a1 + 280) = *(_QWORD *)(v4 + 1848);
        if (VectBlock_Create(*(_QWORD *)(a1 + 48), v4 + 1880, 2 * v8 + 32, *(_DWORD *)(a1 + 160)))
        {
          *(_QWORD *)(a1 + 272) = *(_QWORD *)(v4 + 1880);
          if (VectBlock_Create(*(_QWORD *)(a1 + 48), v4 + 1928, 4 * *(_DWORD *)(a1 + 208) + 64, 1))
          {
            *(_QWORD *)(a1 + 296) = *(_QWORD *)(v4 + 1928);
            v14 = *(_QWORD *)(a1 + 216);
            if (!*(_QWORD *)(v14 + 10448))
              goto LABEL_16;
            if (VectBlock_Create(*(_QWORD *)(a1 + 48), v4 + 1896, 8 * *(_DWORD *)(v14 + 5992) * *(_DWORD *)(a1 + 208), 1))
            {
              *(_QWORD *)(a1 + 288) = *(_QWORD *)(v4 + 1896);
              if (VectBlock_Create(*(_QWORD *)(a1 + 48), v4 + 1912, 4 * *(_DWORD *)(*(_QWORD *)(a1 + 216) + 5992) * *(_DWORD *)(a1 + 208), 1))
              {
                *(_QWORD *)(a1 + 304) = *(_QWORD *)(v4 + 1912);
LABEL_16:
                v15 = *(_QWORD *)(a1 + 232);
                if (v15)
                {
                  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v15);
                  *(_QWORD *)(a1 + 232) = 0;
                }
                v16 = *(_QWORD *)(a1 + 224);
                if (!v16)
                  return 0;
                v17 = *(_QWORD *)(v16 + 1768);
                if (!v17)
                  return 0;
                if (*(_DWORD *)(v17 + 12) != 1)
                  return 0;
                v18 = *(_DWORD *)(v17 + 8);
                v19 = *(_DWORD *)(a1 + 200);
                if (v18 != *(_DWORD *)(a1 + 204) * v19)
                  return 0;
                v20 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), (v19 + 4), 4);
                *(_QWORD *)(a1 + 232) = v20;
                if (v20)
                  return 0;
              }
            }
          }
        }
      }
    }
    v13 = "%s_Set, Error, Out of memory\n";
    goto LABEL_25;
  }
  v10 = (uint64_t *)(a1 + 48);
  v13 = "%s_Set, Error, Inputs misaligned\n";
LABEL_25:
  UNICORN__log_select_Diag(*v10, 0, (uint64_t)v13);
  return 2229280778;
}

uint64_t UnicornPredict_Process(uint64_t a1, _DWORD *a2)
{
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  const char *v10;
  _DWORD *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  _DWORD *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v49;
  uint64_t v50;

  if (a2)
    *a2 = 0;
  v4 = *(_DWORD *)(a1 + 240);
  v5 = v4 + 1;
  v6 = v4 + 4;
  if (v6 >= *(_DWORD *)(a1 + 200))
    v7 = *(_DWORD *)(a1 + 200);
  else
    v7 = v6;
  v8 = *(_DWORD *)(a1 + 256);
  *(_DWORD *)(a1 + 240) = v5;
  *(_DWORD *)(a1 + 244) = v8;
  *(_DWORD *)(a1 + 248) = v8;
  *(_DWORD *)(a1 + 252) = v8;
  if (v8 >= v7)
    return 0;
  v9 = 0;
  v10 = "%s_Process: Expected Output  '%s' not found in ANNObject\n";
  do
  {
    v11 = *(_DWORD **)(a1 + 216);
    v12 = v11[1685];
    v13 = *(_DWORD *)(a1 + 200);
    if (v12 < 1)
      v12 = *(_DWORD *)(a1 + 200);
    *(_DWORD *)(a1 + 248) = v8;
    v14 = v11[1686];
    v15 = v8 >= v14;
    v16 = v8 - v14;
    if (v15)
      v17 = v16;
    else
      v17 = 0;
    *(_DWORD *)(a1 + 244) = v17;
    v18 = v17 + v12;
    *(_DWORD *)(a1 + 252) = v18;
    if (v18 >= v13)
    {
      *(_DWORD *)(a1 + 252) = v13;
      v21 = v13;
    }
    else
    {
      v19 = v11[1687];
      v15 = v18 >= v19;
      v20 = v18 - v19;
      if (v15)
        v21 = v20;
      else
        v21 = 0;
      v13 = v18;
    }
    if (v21 > v8)
      v8 = v21;
    *(_DWORD *)(a1 + 256) = v8;
    v22 = *(_QWORD *)(a1 + 152);
    v23 = v13 - v17;
    if (v11[1496])
    {
      v24 = (*(uint64_t (**)(_QWORD))(a1 + 120))(*(_QWORD *)(a1 + 56)) * v17;
      if (!(_DWORD)v23)
        return v9;
    }
    else
    {
      v25 = *(_DWORD *)(a1 + 204) * v17;
      v24 = v25 * (*(uint64_t (**)(_QWORD))(a1 + 120))(*(_QWORD *)(a1 + 56));
      v23 = (*(_DWORD *)(a1 + 204) * v23);
      if (!(_DWORD)v23)
        return v9;
    }
    v26 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 72))(*(_QWORD *)(a1 + 56), v22 + 4 * v24, v23);
    if ((v26 & 0x80000000) != 0)
      goto LABEL_60;
    v27 = *(_QWORD *)(a1 + 224);
    if (v27)
    {
      v28 = *(uint64_t **)(v27 + 1768);
      if (v28)
      {
        if (*((_DWORD *)v28 + 3) == 1)
        {
          v29 = *(_DWORD *)(a1 + 204);
          if (*((_DWORD *)v28 + 2) == v29 * *(_DWORD *)(a1 + 200))
          {
            v30 = *(_QWORD *)(a1 + 232);
            if (v30)
            {
              v31 = *(_QWORD *)(a1 + 216);
              v32 = *(_QWORD *)(v31 + 10456) ? *(char **)(v31 + 10456) : "output_pdur";
              v33 = *(_DWORD *)(a1 + 244);
              v34 = *(_DWORD *)(a1 + 252);
              v15 = v34 >= v33;
              v35 = v34 - v33;
              if (v35 != 0 && v15)
              {
                v36 = *v28;
                v37 = v33 * v29;
                v38 = v35;
                v39 = *(_DWORD **)(a1 + 232);
                do
                {
                  *v39++ = *(_DWORD *)(v36 + 48 * v37 + 16);
                  v37 += v29;
                  --v38;
                }
                while (v38);
              }
              else
              {
                v35 = 0;
              }
              *(_DWORD *)(v30 + 4 * v35) = *(_DWORD *)(v31 + 11576);
              *(_DWORD *)(v30 + 4 * (v35 + 1)) = *(_DWORD *)(v31 + 11580);
              *(_DWORD *)(v30 + 4 * (v35 + 2)) = *(_DWORD *)(v31 + 11568);
              *(_DWORD *)(v30 + 4 * (v35 + 3)) = *(_DWORD *)(v31 + 11572);
              v26 = (*(uint64_t (**)(_QWORD, char *))(a1 + 112))(*(_QWORD *)(a1 + 56), v32);
              if ((v26 & 0x80000000) != 0)
              {
LABEL_60:
                v9 = v26;
                v46 = *(_QWORD *)(a1 + 48);
                v47 = "%s_Set, Error, ANNObject Set failed\n";
LABEL_58:
                UNICORN__log_select_Diag(v46, 0, (uint64_t)v47);
                return v9;
              }
            }
          }
        }
      }
    }
    v40 = (*(uint64_t (**)(_QWORD))(a1 + 80))(*(_QWORD *)(a1 + 56));
    if ((v40 & 0x80000000) != 0)
    {
      v9 = v40;
      v46 = *(_QWORD *)(a1 + 48);
      v47 = "%s_Process, Error, ANNObject Process\n";
      goto LABEL_58;
    }
    v49 = 0;
    v50 = 0;
    v41 = *(unsigned int *)(a1 + 148);
    if ((_DWORD)v41)
    {
      v42 = 0;
      v43 = 0;
      v9 = 0;
      while (1)
      {
        v44 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + v42);
        if (v44)
        {
          v45 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *, char *, uint64_t *))(a1 + 88))(*(_QWORD *)(a1 + 56), v44, &v49, (char *)&v50 + 4, &v50);
          if ((v45 & 0x80000000) != 0)
          {
            v9 = v45;
LABEL_57:
            v46 = *(_QWORD *)(a1 + 48);
            v47 = v10;
            goto LABEL_58;
          }
          v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 136) + v42 + 8))(a1, v49, HIDWORD(v50), v50);
          if ((v9 & 0x80000000) != 0)
          {
            v10 = "%s_Process: Collector  '%s', Error\n";
            goto LABEL_57;
          }
          v41 = *(unsigned int *)(a1 + 148);
        }
        ++v43;
        v42 += 16;
        if (v43 >= v41)
        {
          if ((v9 & 0x80000000) == 0)
            goto LABEL_50;
          return v9;
        }
      }
    }
    v9 = 0;
LABEL_50:
    (*(void (**)(_QWORD))(a1 + 96))(*(_QWORD *)(a1 + 56));
    if (a2)
      *a2 += *(_DWORD *)(a1 + 256) - *(_DWORD *)(a1 + 248);
    v8 = *(_DWORD *)(a1 + 256);
  }
  while (v8 < v7);
  return v9;
}

uint64_t UnicornPredict_Reset(uint64_t a1)
{
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  (*(void (**)(_QWORD))(a1 + 96))(*(_QWORD *)(a1 + 56));
  return 0;
}

uint64_t UnicornPredict_Close()
{
  return 0;
}

uint64_t UnicornPredict_GetNProcessedPhonemes(uint64_t a1)
{
  return *(unsigned int *)(a1 + 256);
}

_QWORD *UnicornPredict_Destroy(uint64_t a1)
{
  uint64_t v2;

  (*(void (**)(_QWORD))(a1 + 104))(*(_QWORD *)(a1 + 56));
  (*(void (**)(_QWORD))(a1 + 128))(*(_QWORD *)(a1 + 56));
  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), *(_QWORD *)(a1 + 136));
  v2 = *(_QWORD *)(a1 + 232);
  if (v2)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), v2);
    *(_QWORD *)(a1 + 232) = 0;
  }
  return heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), a1);
}

uint64_t UnicornPredict_CopyOutputToBNFStream(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5;
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  float v29;
  float v30;
  uint64_t v31;
  float v32;
  float v33;
  unint64_t v34;
  unsigned int v35;
  float v36;
  float v37;
  unint64_t v38;
  unsigned int v39;
  float v40;
  int v41;
  BOOL v42;
  BOOL v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  float v50;
  int v51;
  unsigned int v52;
  char v53;
  char v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v5 = *(_DWORD *)(a1 + 200);
  if ((v5 < a3 || *(_DWORD *)(a1 + 160) != a4) && (*(_DWORD *)(a1 + 204) * v5 < a3 || *(_DWORD *)(a1 + 160) != a4))
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 0, (uint64_t)"UnicornPredict_CopyOutputToBNFStream: nPhonemes=%d, nStates=%d, _timesteps=%d, _dim=%d, nBNFOrder=%d\n");
    return 2229280775;
  }
  v8 = *(_DWORD *)(a1 + 248);
  v9 = (v8 - *(_DWORD *)(a1 + 244)) * a4;
  v10 = *(_QWORD *)(a1 + 216);
  v11 = *(_DWORD *)(v10 + 5984);
  if (!v11)
  {
    v18 = *(_DWORD *)(a1 + 204);
    v12 = a2 + 4 * v18 * v9;
    v13 = (*(_DWORD *)(a1 + 256) - v8) * v18;
    v14 = (unsigned int *)(a1 + 160);
    v15 = v8 * a4;
    v21 = v8 * a4 * v18;
    v16 = *(_QWORD *)(a1 + 280) + 4 * v21;
    v17 = *(_QWORD *)(a1 + 272) + 2 * v21;
    if (*(_DWORD *)(v10 + 6728))
      goto LABEL_10;
LABEL_12:
    v20 = v18 * v15;
    v19 = 1;
    goto LABEL_13;
  }
  v12 = a2 + 4 * v9;
  v13 = *(_DWORD *)(a1 + 256) - v8;
  v14 = (unsigned int *)(a1 + 160);
  v15 = v8 * a4;
  v16 = *(_QWORD *)(a1 + 280) + 4 * v8 * a4;
  v17 = *(_QWORD *)(a1 + 272) + 2 * v8 * a4;
  v18 = 1;
  if (!*(_DWORD *)(v10 + 6728))
    goto LABEL_12;
LABEL_10:
  v19 = 0;
  v20 = (a4 >> 3) * v8 * v18;
LABEL_13:
  if (v11)
    v22 = 1;
  else
    v22 = *(_DWORD *)(a1 + 204);
  v23 = *(_QWORD *)(a1 + 296) + 4 * (v22 * v8);
  if ((v19 & 1) != 0)
  {
    if (v13)
    {
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v57 = v13;
      LODWORD(v27) = *(_DWORD *)(a1 + 160);
      v56 = *(_QWORD *)(a1 + 296) + 4 * (v22 * v8);
      do
      {
        if ((_DWORD)v27)
        {
          v28 = 0;
          v58 = v24;
          v29 = 0.0;
          do
          {
            v30 = *(float *)(v12 + 4 * (v26 + v28));
            *(float *)(v16 + 4 * (v25 + v28)) = v30;
            v29 = v29 + (float)(v30 * v30);
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"ANN-predicted BNF: %d,%d %f\n");
            ++v28;
            v27 = *(unsigned int *)(a1 + 160);
          }
          while (v28 < v27);
          if ((_DWORD)v27)
          {
            v31 = 0;
            v32 = sqrtf(v29);
            v23 = v56;
            v24 = v58;
            do
            {
              *(float *)(v16 + 4 * (v25 + v31)) = *(float *)(v16 + 4 * (v25 + v31))
                                                                / v32;
              ++v31;
            }
            while (v27 != v31);
            v33 = 0.0;
            v34 = v27;
            v35 = v25;
            do
            {
              v36 = fabsf(*(float *)(v16 + 4 * v35));
              if (v36 > v33)
                v33 = v36;
              ++v35;
              --v34;
            }
            while (v34);
            if (v33 <= 0.0)
              v37 = 1.0;
            else
              v37 = 1.0 / v33;
            v38 = v27;
            v39 = v25;
            do
            {
              v40 = *(float *)(v16 + 4 * v39);
              v41 = (int)(float)((float)(v37 * 32767.0) * v40);
              *(_WORD *)(v17 + 2 * v39) = v41;
              if ((v41 + 8) <= 0x10)
              {
                v42 = v40 <= 0.0 || v40 > 8.0;
                if (!v42 || (v40 < 0.0 ? (v43 = v40 < -8.0) : (v43 = 1), !v43))
                  *(_WORD *)(v17 + 2 * v39) = (int)(float)((float)(v37 * (float)(v40 * 4.0)) * 32767.0);
              }
              ++v39;
              --v38;
            }
            while (v38);
            v26 += v28;
          }
          else
          {
            v26 += v28;
            v37 = 1.0;
            v23 = v56;
            v24 = v58;
          }
        }
        else
        {
          v37 = 1.0;
        }
        v44 = 1.0 / (v37 * 32767.0);
        *(float *)(v23 + 4 * v24) = v44;
        v25 += v27;
        ++v24;
      }
      while (v24 != v57);
    }
  }
  else if (v13)
  {
    v45 = 0;
    v46 = *(_QWORD *)(a1 + 264) + v20;
    v47 = *v14;
    do
    {
      if (v47)
      {
        v48 = 0;
        do
        {
          v49 = v48 + v45 * v47;
          v50 = *(float *)(v12 + 4 * v49);
          *(float *)(v16 + 4 * v49) = v50;
          *(_WORD *)(v17 + 2 * v49) = v50 < 0.0;
          v51 = 1 << (~(_BYTE)v48 & 7);
          v52 = (v47 >> 3) * v45 + (v48 >> 3);
          v53 = *(_BYTE *)(v46 + v52);
          v54 = v53 | v51;
          v55 = v53 & ~(_BYTE)v51;
          if (v50 < 0.0)
            v55 = v54;
          *(_BYTE *)(v46 + v52) = v55;
          ++v48;
          v47 = *v14;
        }
        while (v48 < *v14);
      }
      *(_DWORD *)(v23 + 4 * v45++) = 1065353216;
    }
    while (v45 != v13);
  }
  return 0;
}

uint64_t UnicornPredict_CopyOutputToLF0Stream(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  int v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  float v27;
  unsigned int v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  uint64_t i;
  unsigned int v34;
  int v35;
  float v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v40 = *(_QWORD *)(a1 + 176);
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"+%s_CopyOutputToLF0Stream\n");
  v9 = *(_DWORD *)(a1 + 200);
  v8 = *(_DWORD *)(a1 + 204);
  v10 = v9 >= a3 && 6 * v8 == a4;
  if (v10 || a4 == 6 && v8 * v9 >= a3)
  {
    v11 = *(unsigned int *)(a1 + 248);
    v12 = *(_DWORD *)(*(_QWORD *)(a1 + 216) + 5984);
    if (v12)
      v13 = 1;
    else
      v13 = *(_DWORD *)(a1 + 204);
    v14 = (v11 - *(_DWORD *)(a1 + 244)) * a4 * v13;
    v15 = *(unsigned int *)(*(_QWORD *)(a1 + 176) + 32);
    if ((int)v15 < 1)
    {
      LODWORD(v16) = 0;
    }
    else
    {
      v16 = 0;
      while (*(_DWORD *)(*(_QWORD *)(a1 + 184) + 184 + 4 * v16) != 2)
      {
        if (v15 == ++v16)
        {
          LODWORD(v16) = *(_DWORD *)(*(_QWORD *)(a1 + 176) + 32);
          break;
        }
      }
    }
    v17 = a2 + 4 * v14;
    if (v12)
    {
      if (v11 >= v9)
        goto LABEL_48;
      v18 = 0;
      v39 = v16;
      while (1)
      {
        v19 = 0;
        v20 = *(_QWORD *)(v40 + 384) + 312 * v11 + 8 * v39;
        v21 = (_QWORD *)(v20 + 96);
        v22 = (_QWORD *)(v20 + 136);
        do
        {
          if ((v8 - 1) > 0xFFFFFFFC)
            goto LABEL_32;
          v41 = v19;
          v23 = v19 + 1;
          v24 = 2;
          do
          {
            v25 = 0;
            if (v11 < *(unsigned int *)(a1 + 256))
              v25 = *(_DWORD *)(v17 + 4 * v18++);
            *(_DWORD *)(*(_QWORD *)(*v21 + 8 * v24) + 4 * v23) = v25;
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d,%d,%d, mean %f -> %f \n");
            ++v24;
            v8 = *(_DWORD *)(a1 + 204);
          }
          while (v24 < (v8 + 2));
          if ((v8 - 1) > 0xFFFFFFFC)
          {
            v19 = v41;
LABEL_32:
            v23 = v19 + 1;
            goto LABEL_33;
          }
          v26 = 2;
          do
          {
            v27 = 1.0;
            if (v11 < *(unsigned int *)(a1 + 256))
              v27 = *(float *)(v17 + 4 * v18++);
            *(float *)(*(_QWORD *)(*v22 + 8 * v26) + 4 * v23) = v27;
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d,%d,%d, var  %f -> %f \n");
            ++v26;
            v8 = *(_DWORD *)(a1 + 204);
          }
          while (v26 < (v8 + 2));
LABEL_33:
          v19 = v23;
        }
        while (v23 != 3);
        if (++v11 >= *(unsigned int *)(a1 + 200))
          goto LABEL_48;
      }
    }
    if (v11 < v9)
    {
      v28 = 0;
      v42 = v16;
      do
      {
        if ((v8 - 1) <= 0xFFFFFFFC)
        {
          v29 = *(_QWORD *)(v40 + 384) + 312 * v11 + 8 * v42;
          v30 = (_QWORD *)(v29 + 96);
          v31 = (_QWORD *)(v29 + 136);
          v32 = 2;
          do
          {
            for (i = 1; i != 4; ++i)
            {
              if (v11 >= *(unsigned int *)(a1 + 256))
              {
                v36 = 1.0;
                v35 = 0;
              }
              else
              {
                v34 = v28 + 1;
                v35 = *(_DWORD *)(v17 + 4 * v28);
                v28 += 2;
                v36 = *(float *)(v17 + 4 * v34);
              }
              UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d,%d,%d, mean %f -> %f \n");
              UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d,%d,%d, var  %f -> %f \n");
              *(_DWORD *)(*(_QWORD *)(*v30 + 8 * v32) + 4 * i) = v35;
              *(float *)(*(_QWORD *)(*v31 + 8 * v32) + 4 * i) = v36;
            }
            ++v32;
            v8 = *(_DWORD *)(a1 + 204);
          }
          while (v32 < (v8 + 2));
          v9 = *(_DWORD *)(a1 + 200);
        }
        ++v11;
      }
      while (v11 < v9);
    }
LABEL_48:
    v37 = 0;
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 0, (uint64_t)"UnicornPredict_CopyOutputToLF0Stream: nPhonemes=%d, nStates=%d, _timesteps=%d, _dim=%d\n");
    v37 = 2229280775;
  }
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"+%s_CopyOutputToLF0Stream\n");
  return v37;
}

uint64_t UnicornPredict_CopyOutputToDURStream(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  float v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  _DWORD *v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  float v31;
  float v32;
  int v33;
  uint64_t v35;
  int v36;

  v8 = *(_QWORD *)(a1 + 176);
  v36 = 0;
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"+%s_CopyOutputToDurStream_Phoneme\n");
  v9 = *(_DWORD *)(a1 + 200);
  if (a4 == 1 && v9 >= a3 || a4 == 1 && *(_DWORD *)(a1 + 204) * v9 >= a3)
  {
    v10 = *(unsigned int *)(a1 + 248);
    v11 = (v10 - *(_DWORD *)(a1 + 244));
    v12 = *(_DWORD *)(*(_QWORD *)(a1 + 216) + 5984);
    if (v12)
    {
      v13 = (unsigned int *)(a1 + 256);
    }
    else
    {
      v15 = *(unsigned int *)(a1 + 204);
      v11 = (v15 * v11);
      v16 = a2 + 4 * v11;
      v13 = (unsigned int *)(a1 + 256);
      v17 = (*(_DWORD *)(a1 + 256) - v10) * v15;
      LODWORD(v18) = v17 / v15;
      if (v17 / v15 <= 1)
        v18 = 1;
      else
        v18 = v18;
      do
      {
        if (v15 <= v17)
        {
          v19 = 0;
          v20 = v12;
          do
          {
            v21 = 0.0;
            v22 = v20;
            v23 = v15;
            do
            {
              v21 = v21 + *(float *)(v16 + 4 * v22++);
              --v23;
            }
            while (v23);
            *(float *)(v16 + 4 * (v12 + v19++)) = v21 / (float)v15;
            v20 += v15;
          }
          while (v19 != v18);
        }
        ++v12;
      }
      while (v12 != 1);
    }
    *(_DWORD *)(v8 + 408) = 0;
    if ((_DWORD)v10)
    {
      v24 = 0;
      v25 = (_DWORD *)(*(_QWORD *)(v8 + 384) + 24);
      v26 = v10;
      do
      {
        v24 += *v25;
        v25 += 78;
        --v26;
      }
      while (v26);
      *(_DWORD *)(v8 + 408) = v24;
    }
    if (v10 >= v9)
    {
      v14 = 0;
    }
    else
    {
      v27 = 0;
      v35 = a2 + 4 * v11;
      v28 = 312 * v10;
      do
      {
        if (v10 >= *v13)
          v29 = (float)*(unsigned int *)(a1 + 204) * 0.08;
        else
          v29 = *(float *)(v35 + 4 * v27++);
        v30 = *(_QWORD *)(v8 + 384);
        if (v29 >= 0.0)
          v31 = v29 * 1000.0;
        else
          v31 = 0.0;
        v32 = v31 / (float)*(int *)(*(_QWORD *)(a1 + 184) + 24);
        *(float *)(v30 + v28 + 32) = v31;
        UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d duration scale (%f)\n");
        v33 = *(_DWORD *)(a1 + 212);
        if (v33 == 2)
        {
          UNICORN__UniformStateDuration(v32, *(_QWORD *)(a1 + 48), v30 + v28, *(int **)(a1 + 168));
        }
        else if (v33 == 1)
        {
          UNICORN__MaxLLStateDuration(*(_QWORD *)(a1 + 48), v30 + v28, *(unsigned int **)(a1 + 168), (float *)&v36, v32);
        }
        else
        {
          UNICORN__StateDuration(v32, *(_QWORD *)(a1 + 48), v30 + v28, *(int **)(a1 + 168));
        }
        *(_DWORD *)(v8 + 408) += *(_DWORD *)(v30 + v28 + 24);
        ++v10;
        v28 += 312;
      }
      while (v10 < *(unsigned int *)(a1 + 200));
      v14 = 0;
    }
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 0, (uint64_t)"UnicornPredict_CopyOutputToDURStream: nPhonemes=%d, nStates=%d, _timesteps=%d, _dim=%d\n");
    v14 = 2229280775;
  }
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"-%s_CopyOutputToDurStream_Phoneme\n");
  return v14;
}

uint64_t UnicornPredict_CopyOutputToSDURStream(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int *v20;
  int *v21;
  unint64_t v22;
  float v23;
  int v24;
  int v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  uint64_t v44;

  v8 = *(_QWORD *)(a1 + 176);
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"+%s_CopyOutputToDurStream\n");
  *(_DWORD *)(v8 + 408) = 0;
  v9 = *(_DWORD *)(a1 + 200);
  v10 = *(_DWORD *)(a1 + 204);
  v11 = v9 >= a3 && v10 == a4;
  v12 = a4;
  if (v11 || a4 == 1 && (v12 = *(_DWORD *)(a1 + 204), v10 * v9 >= a3))
  {
    v13 = *(_DWORD *)(a1 + 244);
    v14 = *(unsigned int *)(a1 + 248);
    if (*(_DWORD *)(*(_QWORD *)(a1 + 216) + 5984))
      v12 = 1;
    if ((_DWORD)v14)
    {
      v15 = 0;
      v16 = (_DWORD *)(*(_QWORD *)(v8 + 384) + 24);
      v17 = *(unsigned int *)(a1 + 248);
      do
      {
        v15 += *v16;
        v16 += 78;
        --v17;
      }
      while (v17);
      *(_DWORD *)(v8 + 408) = v15;
    }
    if (v14 >= v9)
    {
      v39 = 0;
    }
    else
    {
      v18 = 0;
      v44 = a2 + 4 * ((v14 - v13) * a4 * v12);
      v41 = v8;
      do
      {
        v19 = *(_QWORD *)(v8 + 384);
        v20 = (int *)(v19 + 312 * v14);
        v20[6] = 0;
        v21 = v20 + 6;
        if ((*(_DWORD *)(a1 + 204) - 1) > 0xFFFFFFFC)
        {
          v25 = 0;
        }
        else
        {
          v42 = (int *)(v19 + 312 * v14);
          v43 = v19;
          v22 = 2;
          do
          {
            if (v14 >= *(unsigned int *)(a1 + 256))
              v23 = 0.08;
            else
              v23 = *(float *)(v44 + 4 * v18++);
            if (v23 < 0.0)
              v23 = 0.0;
            if ((int)(float)((float)((float)(1000.0 / (float)*(int *)(*(_QWORD *)(a1 + 184) + 24)) * v23) + 0.5) <= 1)
              v24 = 1;
            else
              v24 = (int)(float)((float)((float)(1000.0 / (float)*(int *)(*(_QWORD *)(a1 + 184) + 24)) * v23) + 0.5);
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"ANN sdur %d (HMM %d)\n");
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d %d %d\n");
            *(_DWORD *)(*((_QWORD *)v42 + 2) + 4 * v22) = v24;
            v25 = *v21 + v24;
            *v21 = v25;
            ++v22;
          }
          while (v22 < (*(_DWORD *)(a1 + 204) + 2));
          v8 = v41;
          v20 = v42;
          v19 = v43;
        }
        if (v14 < *(unsigned int *)(a1 + 256))
        {
          v26 = *(int **)(a1 + 192);
          LODWORD(v27) = *v26;
          if ((*v26 - 4) >= 0xFFFFFFFE)
          {
            v28 = *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8);
            v29 = *v20;
            if (*(_BYTE *)(*(_QWORD *)(v28 + 32) + v29) == 1)
            {
              v30 = *(unsigned __int16 *)(*(_QWORD *)(v28 + 1784) + 2 * v29);
              if (v30)
              {
                v31 = *(_QWORD *)(a1 + 184);
                if ((v30 / *(_DWORD *)(v31 + 24)) <= 1)
                  v32 = 1;
                else
                  v32 = v30 / *(_DWORD *)(v31 + 24);
                *v21 = 0;
                v33 = *(_QWORD *)(v19 + 312 * v14 + 16);
                if (v32 <= (int)v27)
                {
                  v38 = 2;
                  do
                  {
                    *(_DWORD *)(v33 + 4 * v38) = 1;
                    v25 = *v21 + 1;
                    *v21 = v25;
                    v36 = v38++ <= *v26;
                  }
                  while (v36);
                }
                else
                {
                  v25 = 0;
                  v34 = 2;
                  do
                  {
                    v35 = *(_DWORD *)(v33 + 4 * v34);
                    if (v35 <= 0)
                    {
                      v35 = 1;
                      *(_DWORD *)(v33 + 4 * v34) = 1;
                      v25 = *v21;
                      LODWORD(v27) = *v26;
                    }
                    v25 += v35;
                    *v21 = v25;
                    v36 = v34++ <= (int)v27;
                  }
                  while (v36);
                  if (v32 < v25)
                  {
                    if ((int)v27 >= 1)
                    {
                      v37 = 2;
                      do
                      {
                        *(_DWORD *)(v33 + 4 * v37) = 1;
                        v27 = *v26;
                        v36 = v37++ <= v27;
                      }
                      while (v36);
                    }
                    *v21 = v27;
                    v25 = v27;
                  }
                  if (v32 >= v25)
                  {
                    *(_DWORD *)(v33 + 12) += v32 - v25;
                    *v21 = v32;
                    v25 = v32;
                  }
                }
                *(float *)(v19 + 312 * v14 + 32) = (float)v25 * (float)*(int *)(v31 + 24);
              }
            }
          }
        }
        *(_DWORD *)(v8 + 408) += v25;
        ++v14;
      }
      while (v14 < *(unsigned int *)(a1 + 200));
      v39 = 0;
    }
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 0, (uint64_t)"UnicornPredict_CopyOutputToSDURStream: nPhonemes=%d, nStates=%d, _timesteps=%d, _dim=%d\n");
    v39 = 2229280775;
  }
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"-%s_CopyOutputToDurStream\n");
  return v39;
}

uint64_t UnicornPredict_CopyOutputToVUVStream(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  int v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  float v22;
  char v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;

  v8 = *(_QWORD *)(a1 + 176);
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"+%s_CopyOutputToVUVStream\n");
  v9 = *(_DWORD *)(a1 + 200);
  v10 = *(_DWORD *)(a1 + 204);
  v11 = v9 >= a3 && v10 == a4;
  v12 = a4;
  if (v11 || a4 == 1 && (v12 = *(_DWORD *)(a1 + 204), v10 * v9 >= a3))
  {
    v13 = *(unsigned int *)(a1 + 248);
    if (*(_DWORD *)(*(_QWORD *)(a1 + 216) + 5984))
      v14 = 1;
    else
      v14 = v12;
    v15 = *(unsigned int *)(*(_QWORD *)(a1 + 176) + 32);
    if ((int)v15 < 1)
    {
      LODWORD(v16) = 0;
    }
    else
    {
      v16 = 0;
      while (*(_DWORD *)(*(_QWORD *)(a1 + 184) + 184 + 4 * v16) != 2)
      {
        if (v15 == ++v16)
        {
          LODWORD(v16) = *(_DWORD *)(*(_QWORD *)(a1 + 176) + 32);
          break;
        }
      }
    }
    if (v13 >= v9)
    {
      v29 = 0;
    }
    else
    {
      v17 = 0;
      v18 = a2 + 4 * ((v13 - *(_DWORD *)(a1 + 244)) * a4 * v14);
      v19 = v16;
      do
      {
        if ((v12 - 1) <= 0xFFFFFFFC)
        {
          v20 = (_QWORD *)(*(_QWORD *)(v8 + 384) + 312 * v13 + 176);
          v21 = 2;
          do
          {
            v22 = 0.0;
            if (v13 < *(unsigned int *)(a1 + 256))
              v22 = *(float *)(v18 + 4 * v17++);
            if (v22 < 0.0)
              v22 = 0.0;
            v23 = *(_BYTE *)(*v20 + v21);
            if (v22 > 1.0)
              v22 = 1.0;
            v24 = *(_QWORD *)(a1 + 184) + 4 * v19;
            v25 = *(float *)(v24 + 1128);
            v26 = 1 << *(_DWORD *)(v24 + 184);
            v27 = v23 & ~(_BYTE)v26;
            v28 = v23 | v26;
            if (v22 <= v25)
              v28 = v27;
            *(_BYTE *)(*v20 + v21) = v28;
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"%d: vuv %f %d (HMM %d)\n");
            ++v21;
            v12 = *(_DWORD *)(a1 + 204);
          }
          while (v21 < (v12 + 2));
          v9 = *(_DWORD *)(a1 + 200);
        }
        ++v13;
      }
      while (v13 < v9);
      v29 = 0;
    }
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 0, (uint64_t)"UnicornPredict_CopyOutputToVUVStream: nPhonemes=%d, nStates=%d, _timesteps=%d, _dim=%d\n");
    v29 = 2229280775;
  }
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"-%s_CopyOutputToVUVStream\n");
  return v29;
}

uint64_t UnicornPredict_CopyOutputToELF0Stream(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  uint32x4_t v15;
  int32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v28;

  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"+%s_CopyOutputToELF0Stream\n");
  v9 = *(_DWORD *)(a1 + 200);
  v8 = *(_DWORD *)(a1 + 204);
  v10 = 2 * v8;
  v11 = v9 >= a3 && v10 == a4;
  if (v11 || a4 == 2 && v8 * v9 >= a3)
  {
    v12 = *(_DWORD *)(a1 + 248);
    if (*(_DWORD *)(*(_QWORD *)(a1 + 216) + 5984))
      v13 = 1;
    else
      v13 = *(_DWORD *)(a1 + 204);
    v14 = 0;
    if (v12)
    {
      v15 = (uint32x4_t)vdupq_n_s32(v12 - 1);
      v16 = vdupq_n_s32(v10);
      v17 = 0uLL;
      do
      {
        v18 = v17;
        v17 = (int8x16_t)vaddq_s32(v16, (int32x4_t)v17);
        v14 += 4;
      }
      while (((v12 + 3) & 0xFFFFFFFC) != v14);
      v14 = vaddvq_s32((int32x4_t)vbslq_s8((int8x16_t)vcgtq_u32((uint32x4_t)vorrq_s8((int8x16_t)vdupq_n_s32(v14 - 4), (int8x16_t)xmmword_214F03640), v15), v18, v17));
    }
    v19 = *(_DWORD *)(a1 + 256);
    if (v12 < v19)
    {
      v20 = 0;
      v21 = *(_QWORD *)(a1 + 288);
      v28 = *(_QWORD *)(a1 + 304);
      v22 = a2 + 4 * (v12 - *(_DWORD *)(a1 + 244)) * a4 * v13;
      v23 = *(_DWORD *)(a1 + 204);
      do
      {
        if (v23)
        {
          v24 = 0;
          do
          {
            *(_DWORD *)(v21 + 4 * v14) = *(_DWORD *)(v22 + 4 * v20);
            v25 = v14;
            *(_DWORD *)(v21 + 4 * (v14 + 1)) = *(_DWORD *)(v22 + 4 * (v20 + 1));
            if (v14)
            {
              v26 = mfs_QuantizeLF0Frame(*(_QWORD *)(a1 + 216), *(float *)(v21 + 4 * (v14 - 1)));
              *(_DWORD *)(v28 + 4 * (v24 + v12 * *(_DWORD *)(a1 + 204))) = mfs_QuantizeLF0Frame(*(_QWORD *)(a1 + 216), *(float *)(v21 + 4 * v25))- v26;
              UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 11, (uint64_t)"@t_(%d) L(%f,%d) - R(%f,%d) = d(%d)\n");
              v8 = *(_DWORD *)(a1 + 204);
            }
            v14 = v25 + 2;
            ++v24;
            v20 += 2;
          }
          while (v24 < v8);
          v19 = *(_DWORD *)(a1 + 256);
          v23 = v8;
        }
        ++v12;
      }
      while (v12 < v19);
    }
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 10, (uint64_t)"-%s_CopyOutputToELF0Stream\n");
    return 0;
  }
  else
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 48), 0, (uint64_t)"UnicornPredict_CopyOutputToELF0Stream: nPhonemes=%d, nStates=%d, _timesteps=%d, _dim=%d\n");
    return 2229280775;
  }
}

void AdjustDurationForTuning(int *a1, unsigned int a2, uint64_t a3, int a4, _DWORD *a5)
{
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  double v19;
  unsigned int v21;
  BOOL v22;
  float v23;
  double v24;
  float v25;
  unsigned int v26;
  unsigned int v27;
  int v29;

  v7 = a4 - 4;
  v8 = a2 / (a4 - 4);
  if (a2 % (a4 - 4))
  {
    v9 = a2;
    do
    {
      v10 = *a1++;
      *a5++ = v10;
      --v9;
    }
    while (v9);
  }
  else if (a4 != 4)
  {
    v11 = 0;
    v12 = *(float *)(a3 + 4 * v7);
    v13 = *(float *)(a3 + 4 * (a4 - 3));
    v14 = *(float *)(a3 + 4 * (a4 - 1));
    v15 = v8 - 1;
    if (v8 <= 1)
      v16 = 1;
    else
      v16 = v8;
    v26 = a2 / (a4 - 4);
    v27 = a2;
    do
    {
      if (v7 <= a2)
      {
        v18 = 0;
        v17 = v11 + 1;
        v29 = v11 * v8;
        do
        {
          v19 = exp((float)(v12 + (float)(*(float *)&a1[(v29 + v18)] * v13)));
          if (v17 < v7 && v15 == v18)
            v21 = v11 + 1;
          else
            v21 = v11;
          if (v18)
            v22 = 1;
          else
            v22 = v11 == 0;
          v23 = v19;
          if (!v22)
            v21 = v11 - 1;
          v24 = v23 + (float)(v14 * *(float *)(a3 + 4 * v21));
          if (v24 < 0.008)
            v24 = 0.008;
          v25 = log(v24);
          *(float *)&a5[(v29 + v18++)] = (float)(v25 - v12) / v13;
        }
        while (v16 != v18);
        v8 = v26;
        a2 = v27;
      }
      else
      {
        v17 = v11 + 1;
      }
      v11 = v17;
    }
    while (v17 != v7);
  }
}

uint64_t UnicornPipeline_Create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;

  v6 = 2229280778;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  v7 = PredictPipeline_Create(a2, a3, a4);
  *(_QWORD *)(a1 + 40) = v7;
  if (v7)
  {
    v8 = heap_Calloc(*(_QWORD **)(a2 + 8), 1, 1984);
    *(_QWORD *)(a1 + 16) = v8;
    if (v8)
    {
      v9 = UnicornSearch_Create(a2);
      *(_QWORD *)(a1 + 48) = v9;
      if (v9)
      {
        v10 = *(_QWORD *)(a1 + 8);
        if (v10 && (v11 = *(_QWORD *)(v10 + 568)) != 0)
        {
          v12 = *(_DWORD *)(v11 + 5928) > 1u || *(_DWORD *)(v11 + 5932) != -1;
          v6 = 0;
          *(_DWORD *)(a1 + 180) = v12;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v6;
}

uint64_t UnicornPipeline_SetForcedEEEnabled(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;

  v2 = 2229281037;
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 568);
      if (v4)
      {
        if (a2)
          v5 = *(_DWORD *)(v4 + 5928) > 1u || *(_DWORD *)(v4 + 5932) != -1;
        else
          v5 = 0;
        v2 = 0;
        *(_DWORD *)(a1 + 180) = v5;
      }
    }
  }
  return v2;
}

uint64_t UnicornPipeline_Destroy(_QWORD *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (uint64_t *)a1[6];
  if (v2)
  {
    UnicornSearch_Destroy(v2);
    a1[6] = 0;
  }
  v3 = a1[2];
  if (v3)
    heap_Free(*(_QWORD **)(*a1 + 8), v3);
  a1[2] = 0;
  v4 = a1[5];
  if (v4)
    return PredictPipeline_Destroy(v4);
  else
    return 2229280774;
}

uint64_t UnicornPipeline_Init(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t inited;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t Stream;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;

  v12 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(a1 + 16);
  v13 = *(_QWORD *)a1;
  v14 = *(_DWORD **)(v12 + 568);
  inited = UNICORN__mfs_InitStream(*(_QWORD *)a1, (void *)v11, v14);
  if ((inited & 0x80000000) != 0)
  {
    v26 = inited;
    v27 = "mfs_InitStream() failed";
LABEL_11:
    UNICORN__log_select_Error(v13, v26, (uint64_t)v27, v16, v17, v18, v19, v20);
    return v26;
  }
  Stream = UNICORN__mfs_LoadStream(v11, v12, (uint64_t)v14, a5, a6);
  if ((Stream & 0x80000000) != 0)
  {
    v26 = Stream;
    v27 = "mfs_LoadStream() failed";
    goto LABEL_11;
  }
  *(_QWORD *)(v11 + 1768) = a4;
  UNICORN__log_select_Diag(v13, 2, (uint64_t)">> loading vstream done\n");
  *(_DWORD *)(v11 + 1980) = *(_DWORD *)(a1 + 192);
  *(_QWORD *)(v11 + 8) = a2;
  *(_OWORD *)(v11 + 1832) = *a3;
  *(_QWORD *)(v11 + 1760) = *(_QWORD *)(a1 + 40);
  v22 = UNICORN__mfs_ParamGenStart(v11, (int *)v12, v14);
  if ((v22 & 0x80000000) != 0)
    return v22;
  v23 = *(_DWORD *)v12;
  *(_DWORD *)(a1 + 144) = *(_DWORD *)v12;
  v24 = *(_DWORD *)(v11 + 392);
  *(_DWORD *)(a1 + 148) = v24 * v23;
  *(_DWORD *)(a1 + 152) = v24;
  *(_DWORD *)(v11 + 1080) = v24 * v23;
  v22 = Install_DynamicBeams_Unicorn((uint64_t)v14, (unsigned int *)v12, v11, v24 * v23);
  if ((v22 & 0x80000000) != 0)
    return v22;
  v22 = TransWeights_InitCopy((uint64_t)v14, (int *)v12, v11, *(_DWORD *)(a1 + 148));
  if ((v22 & 0x80000000) != 0)
    return v22;
  if (!*(_DWORD *)(*(_QWORD *)(v12 + 568) + 11520))
  {
    *(_QWORD *)(v11 + 1800) = 0;
    goto LABEL_13;
  }
  v25 = heap_Calloc(*(_QWORD **)(v13 + 8), *(unsigned int *)(a1 + 148), 40);
  *(_QWORD *)(v11 + 1800) = v25;
  if (v25)
  {
LABEL_13:
    v30 = v11;
    v31 = v12;
    v32 = v14;
    v22 = (**(uint64_t (***)(void))(a1 + 48))();
    if ((v22 & 0x80000000) == 0)
    {
      v22 = ViterbiEE_Init(a1 + 56, v11, v14, v12);
      if ((v22 & 0x80000000) == 0)
      {
        *(_QWORD *)(a1 + 184) = 0;
        *(_QWORD *)(a1 + 156) = 0;
        *(_QWORD *)(a1 + 172) = 0;
        *(_QWORD *)(a1 + 164) = 0;
        return BET5_GenericRules_ParamActions_AllocMemoryAndInit((uint64_t)v14, (int *)v12, v11);
      }
    }
    return v22;
  }
  return 2229280778;
}

uint64_t UnicornPipeline_Release(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  ViterbiEE_Release((uint64_t)(a1 + 7));
  v2 = a1[6];
  if (v2)
  {
    v3 = (*(uint64_t (**)(void))(v2 + 40))();
    if ((v3 & 0x80000000) != 0)
    {
      UNICORN__log_select_Diag(*a1, 0, (uint64_t)"SearchPipeline, Error, self->Close\n");
      return 2229280778;
    }
  }
  else
  {
    v3 = 0;
  }
  v4 = (_QWORD *)a1[23];
  if (v4)
  {
    UNICORN__Psola_Deinitialise(*a1, v4);
    a1[23] = 0;
    v5 = (_QWORD *)a1[2];
  }
  else
  {
    v5 = (_QWORD *)a1[2];
    if (v5)
    {
      v6 = v5[225];
      if (v6)
      {
        heap_Free(*(_QWORD **)(*a1 + 8), v6);
        v5 = (_QWORD *)a1[2];
        v5[225] = 0;
      }
    }
  }
  BET5_GenericRules_ParamActions_FreeMemory(v5);
  UNICORN__mfs_DeInitStream((_QWORD *)a1[2]);
  return v3;
}

uint64_t UnicornPipeline_ProcessPhoneme(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t *v6;
  int v7;
  int v8;
  signed int v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  int v16;
  __int16 v18;
  char v19;

  *a2 = 0;
  v4 = UNICORN__mfs_ParamGenContinue(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 568));
  if ((v4 & 0x80000000) == 0)
  {
    v5 = *(_DWORD *)(a1 + 160);
    if (v5 >= *(_DWORD *)(a1 + 152))
    {
      v15 = 0;
      goto LABEL_26;
    }
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 8))();
    if ((v4 & 0x80000000) == 0)
    {
      v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 24))();
      if ((v4 & 0x80000000) == 0)
      {
        v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 32))();
        if ((v4 & 0x80000000) == 0)
        {
          v6 = *(uint64_t **)(a1 + 16);
          v19 = 0;
          v18 = 0;
          UNICORN__mfs_Ling_GetPhonCtxt(v6[1], *(_DWORD *)(a1 + 160), &v18);
          if (*(int *)(a1 + 144) >= 1)
          {
            v7 = 0;
            v8 = HIBYTE(v18);
            v9 = *(_DWORD *)(a1 + 156);
            do
            {
              v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 568) + 11548);
              UNICORN__log_select_Diag(*(_QWORD *)a1, 12, (uint64_t)"Decoder at state idx %d\n");
              v11 = v6[138];
              if (!*(_DWORD *)(v11 + 32 * v9 + 16))
              {
                v4 = UNICORN__mfs_CostList_Add(0.0, *(_QWORD *)(a1 + 8), v6 + 136, v9, v10);
                if ((v4 & 0x80000000) != 0)
                  return v4;
                v11 = v6[138];
              }
              v12 = *(_DWORD *)(a1 + 144) == 2 && v8 == 1;
              v13 = v12 && v7 == 0;
              v14 = v13;
              v4 = ViterbiEE_Decode(a1 + 56, v11 + 32 * v9, v14);
              if ((v4 & 0x80000000) != 0)
                return v4;
              mfs_CostList_FreeAt(v6 + 136, v9);
              v9 = *(_DWORD *)(a1 + 156) + 1;
              *(_DWORD *)(a1 + 156) = v9;
            }
            while (++v7 < *(_DWORD *)(a1 + 144));
          }
          v15 = UnicornPipeline_PrepareEmissionIfPossible(a1, 0);
          v5 = *(_DWORD *)(a1 + 160) + 1;
          *(_DWORD *)(a1 + 160) = v5;
          if ((v15 & 0x80000000) != 0)
            return v15;
LABEL_26:
          v16 = *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 168);
          if (v16)
          {
            v15 = UnicornPipeline_PrepareSynth(a1, v16);
            if ((v15 & 0x80000000) != 0)
              return v15;
            UNICORN__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Prepared: %d units\n");
            v5 = *(_DWORD *)(a1 + 160);
          }
          *a2 = v5 >= *(_DWORD *)(a1 + 152);
          return v15;
        }
      }
    }
  }
  return v4;
}

uint64_t UnicornPipeline_PrepareSynth(uint64_t a1, int a2)
{
  uint64_t result;
  int v4;
  int v5;

  if (a2 < 1)
    return 0;
  result = 0;
  v4 = *(_DWORD *)(a1 + 168);
  v5 = a2 + 1;
  do
  {
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 568) + 11520))
    {
      result = mfs_Psola_CalculateAdjustments_ByOne(*(int **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 1800), v4, *(_DWORD *)(a1 + 148), (int *)(a1 + 172));
      if ((result & 0x80000000) != 0)
        return result;
      v4 = *(_DWORD *)(a1 + 168);
    }
    *(_DWORD *)(a1 + 168) = ++v4;
    --v5;
  }
  while (v5 > 1);
  return result;
}

uint64_t UnicornPipeline_GetAvailableCount(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 172) - *(_DWORD *)(a1 + 176));
}

uint64_t UnicornPipeline_GetAvailableDuration(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int *v4;
  uint64_t v5;
  int v6;

  v2 = *(int *)(result + 172);
  v1 = *(int *)(result + 176);
  if ((int)v1 >= (int)v2)
    return 0;
  v3 = result;
  LODWORD(result) = 0;
  v4 = (int *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 1800) + 40 * (int)v1 + 8);
  v5 = v2 - v1;
  do
  {
    v6 = *v4;
    v4 += 10;
    result = (v6 + result);
    --v5;
  }
  while (v5);
  return result;
}

uint64_t UnicornPipeline_SynthesizeDummy(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 176) += a2;
  return 0;
}

BOOL UnicornPipeline_GetForcedEEEnabled(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 180) != 0;
  return result;
}

uint64_t UnicornPipeline_GetPreparedCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 172);
}

uint64_t UnicornPipeline_GetStream(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

BOOL UnicornPipeline_isDone(uint64_t a1)
{
  return *(_DWORD *)(a1 + 160) >= *(_DWORD *)(a1 + 152);
}

uint64_t UnicornPipeline_isMultiThreaded()
{
  return 0;
}

uint64_t UnicornPipeline_PrepareEmissionIfPossible(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int UniquePathLength;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 16);
  if (a2)
    *a2 = 0;
  if (*(_DWORD *)(a1 + 160) + 1 == *(_DWORD *)(a1 + 152))
  {
    UniquePathLength = *(_DWORD *)(a1 + 148) - *(_DWORD *)(a1 + 164);
    if (!UniquePathLength)
      return 0;
  }
  else
  {
    UniquePathLength = ViterbiEE_GetUniquePathLength(a1 + 56, *(_DWORD *)(a1 + 164));
    if (!UniquePathLength)
    {
      if (!*(_DWORD *)(a1 + 180))
        return 0;
      UniquePathLength = ViterbiForcedEE_GetPathLength(a1 + 56, *(_DWORD *)(a1 + 164));
      if (!UniquePathLength)
        return 0;
    }
  }
  v6 = *(_DWORD *)(a1 + 164);
  v7 = v6 + UniquePathLength;
  v8 = v4 + 1448;
  result = ViterbiEE_Backtrack(a1 + 56, v6, v6 + UniquePathLength, *(_QWORD *)(v4 + 8), v4 + 1448, v4 + 1472, v4 + 1496);
  if ((result & 0x80000000) == 0)
  {
    v10 = v4 + 1552;
    v11 = v4 + 1400;
    UNICORN__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Emitted: %d (+%d) units (%d decoded, debt %d)\n");
    if (*(_DWORD *)(a1 + 180))
      ViterbiForcedEE_KillPaths(a1 + 56, v7 - 1, *(_DWORD *)(a1 + 156) - 1, v8);
    result = mfs_UnitSequence_SequencePartial(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) + 32), v11, v10, v6, v6 + UniquePathLength);
    if ((result & 0x80000000) == 0)
    {
      *(_DWORD *)(a1 + 164) = v7;
      if (a2)
        *a2 = 1;
    }
  }
  return result;
}

uint64_t UnicornPipeline_SetSIMDCallbacks(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = result;
    ViterbiEE_EnableSIMD(result + 56, a2);
    return (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 48) + 48))();
  }
  return result;
}

uint64_t UNICORN__mfs_SegmentList_Init(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = a1;
  a3[1] = a2;
  a3[2] = 0;
  a3[3] = 0;
  return 0;
}

uint64_t mfs_SegmentList_InitPrealloc(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t result;

  *(_QWORD *)a4 = a1;
  *(_QWORD *)(a4 + 8) = a2;
  v6 = heap_Alloc(*(_QWORD *)(a1 + 8), 28 * a3);
  *(_QWORD *)(a4 + 16) = v6;
  if (!v6)
    return 2229280778;
  result = 0;
  *(_DWORD *)(a4 + 24) = 0;
  *(_DWORD *)(a4 + 28) = a3;
  return result;
}

_QWORD *UNICORN__mfs_SegmentList_DeInit(_QWORD *result)
{
  _QWORD *v1;

  v1 = result;
  if (result[1])
  {
    result = heap_Free(*(_QWORD **)(*result + 8), result[2]);
    v1[2] = 0;
  }
  v1[3] = 0;
  return result;
}

uint64_t UNICORN__mfs_SegmentList_Add(uint64_t a1, int a2, char a3, int a4, int a5)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;

  v10 = *(_DWORD *)(a1 + 24);
  if (v10 >= *(_DWORD *)(a1 + 28))
  {
    v11 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 28 * (v10 + 1));
    if (!v11)
      return 2229280778;
    *(_QWORD *)(a1 + 16) = v11;
    v10 = *(_DWORD *)(a1 + 24);
    v12 = v10 + 1;
    *(_DWORD *)(a1 + 28) = v10 + 1;
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = v10 + 1;
  }
  v13 = 0;
  v14 = v11 + 28 * v10;
  *(_DWORD *)v14 = a2;
  *(_BYTE *)(v14 + 4) = a3;
  *(_DWORD *)(v14 + 8) = a4;
  *(_DWORD *)(v14 + 12) = a5;
  *(_DWORD *)(v14 + 16) = 1;
  *(_DWORD *)(a1 + 24) = v12;
  return v13;
}

uint64_t UNICORN__mfs_SegmentList_Length(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 24);
  return result;
}

uint64_t UNICORN__mfs_SegmentList_Get(uint64_t a1, unsigned int a2, _DWORD *a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  uint64_t result;
  uint64_t v10;
  _DWORD *v11;

  if (a1 && *(_DWORD *)(a1 + 24) > a2)
  {
    result = 0;
    v10 = *(_QWORD *)(a1 + 16) + 28 * a2;
    *a3 = *(_DWORD *)v10;
    *a4 = *(_BYTE *)(v10 + 4);
    v11 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 28 * a2);
    *a5 = v11[2];
    *a6 = v11[3];
    *a7 = v11[5];
    *a8 = v11[6];
  }
  else
  {
    *a3 = 0;
    *a4 = 0;
    *a6 = 0;
    result = 2229280775;
    *a5 = 0;
  }
  return result;
}

uint64_t SearchPipeline(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  _QWORD v10[3];

  v3 = *(_QWORD *)(a1 + 1072);
  v10[1] = a2;
  v10[2] = a3;
  v10[0] = a1;
  v4 = (uint64_t *)UnicornSearch_Create(v3);
  if (!v4)
  {
    v7 = 2229280778;
    v8 = "SearchPipeline, Error, UnicornSearch_Create\n";
LABEL_10:
    UNICORN__log_select_Diag(v3, 0, (uint64_t)v8);
    return v7;
  }
  v5 = v4;
  if ((((uint64_t (*)(uint64_t *, _QWORD *))*v4)(v4, v10) & 0x80000000) != 0)
  {
    v7 = 2229280778;
    v8 = "SearchPipeline, Error, self->Open\n";
    goto LABEL_10;
  }
  ((void (*)(uint64_t *, uint64_t))v5[6])(v5, 1);
  if ((((uint64_t (*)(uint64_t *))v5[2])(v5) & 0x80000000) != 0)
  {
    v7 = 2229280778;
    v8 = "SearchPipeline, Error, self->Process\n";
    goto LABEL_10;
  }
  v6 = ((uint64_t (*)(uint64_t *))v5[5])(v5);
  if ((v6 & 0x80000000) != 0)
  {
    v7 = 2229280778;
    v8 = "SearchPipeline, Error, self->Close\n";
    goto LABEL_10;
  }
  v7 = v6;
  UnicornSearch_Destroy(v5);
  return v7;
}

uint64_t UnicornPipelineMT_Create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t result;

  *(_QWORD *)a1 = a2;
  v7 = (uint64_t *)(a1 + 208);
  result = critsec_ObjOpen(*(_QWORD *)(a2 + 16), *(_QWORD **)(a2 + 8), (uint64_t *)(a1 + 208));
  if ((result & 0x80000000) == 0)
  {
    if ((_DWORD)result)
    {
      critsec_ObjClose(*v7);
      return UnicornPipeline_Destroy((_QWORD *)(a1 + 8));
    }
    else
    {
      *(_QWORD *)(a1 + 216) = 0;
      result = UnicornPipeline_Create(a1 + 8, *(_QWORD *)a1, a3, a4);
      *(_DWORD *)(a1 + 200) = 1;
    }
  }
  return result;
}

uint64_t UnicornPipelineMT_Destroy(uint64_t a1)
{
  critsec_ObjClose(*(_QWORD *)(a1 + 208));
  return UnicornPipeline_Destroy((_QWORD *)(a1 + 8));
}

uint64_t UnicornPipelineMT_Init(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, int a6)
{
  return UnicornPipeline_Init(a1 + 8, a2, a3, a4, a5, a6);
}

uint64_t UnicornPipelineMT_Release(uint64_t a1)
{
  int v2;
  uint64_t v3;

  if (!*(_DWORD *)(a1 + 216))
    return UnicornPipeline_Release((uint64_t *)(a1 + 8));
  critsec_Enter(*(_QWORD **)(a1 + 208));
  if (*(_DWORD *)(a1 + 172) < *(_DWORD *)(a1 + 156))
    *(_DWORD *)(a1 + 220) = 1;
  critsec_Leave(*(_QWORD **)(a1 + 208));
  thread_Join(*(_QWORD **)(a1 + 232));
  thread_ObjClose(*(_QWORD *)(a1 + 232));
  *(_QWORD *)(a1 + 232) = 0;
  v2 = semaphore_ObjectClose(*(_QWORD *)(a1 + 224));
  *(_QWORD *)(a1 + 216) = 0;
  if (!v2)
    return UnicornPipeline_Release((uint64_t *)(a1 + 8));
  v3 = v2 | 0x84E02000;
  UnicornPipeline_Release((uint64_t *)(a1 + 8));
  return v3;
}

uint64_t UnicornPipelineMT_ProcessPhoneme(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v10;
  int v11;
  int v12;
  int v13;
  signed int v14;
  _BOOL4 v17;
  uint64_t v18;
  int v19;
  __int16 v20;
  char v21;

  if (*(_DWORD *)(a1 + 216) != 1)
  {
    v8 = semaphore_ObjectOpen(*(_QWORD *)(*(_QWORD *)a1 + 400), *(_QWORD **)(*(_QWORD *)a1 + 8), 0, 0x7FFFLL, (uint64_t *)(a1 + 224));
    if (v8 < 0)
      return v8 | 0x84E02000;
    v8 = thread_ObjOpen(*(_QWORD *)(*(_QWORD *)a1 + 400), *(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t *)(a1 + 232));
    if (v8 < 0)
      return v8 | 0x84E02000;
    v8 = thread_Start(*(_QWORD **)(a1 + 232));
    if (v8)
      return v8 | 0x84E02000;
    *(_DWORD *)(a1 + 216) = 1;
  }
  v4 = 0;
  v19 = 0;
  v5 = *(_DWORD *)(a1 + 168);
  if (v5 < *(_DWORD *)(a1 + 160))
  {
    if (!*(_DWORD *)(a1 + 220))
    {
      while (1)
      {
        v21 = 0;
        v20 = 0;
        UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), v5, &v20);
        v10 = *(_DWORD *)(a1 + 152);
        if (v10 >= 1)
        {
          v11 = 0;
          v12 = HIBYTE(v20);
          while (!*(_DWORD *)(a1 + 220))
          {
            v13 = *(_DWORD *)(a1 + 168);
            v8 = semaphore_Acquire(*(_QWORD **)(a1 + 224));
            if (v8)
              return v8 | 0x84E02000;
            v14 = v11 + v13 * v10;
            v17 = *(_DWORD *)(a1 + 152) == 2 && v12 == 1 && v11 == 0;
            v18 = ViterbiEE_Decode(a1 + 64, *(_QWORD *)(*(_QWORD *)(a1 + 24) + 1104) + 32 * v14, v17);
            if ((_DWORD)v18)
            {
              v4 = v18;
              if ((v18 & 0x80000000) != 0)
                return v4;
              break;
            }
            mfs_CostList_FreeAt((_QWORD *)(*(_QWORD *)(a1 + 24) + 1088), v14);
            ++*(_DWORD *)(a1 + 164);
            ++v11;
            v10 = *(_DWORD *)(a1 + 152);
            if (v11 >= v10)
              break;
          }
        }
        v4 = UnicornPipeline_PrepareEmissionIfPossible(a1 + 8, &v19);
        if ((v4 & 0x80000000) != 0)
          return v4;
        v5 = *(_DWORD *)(a1 + 168) + 1;
        *(_DWORD *)(a1 + 168) = v5;
        if (v5 >= *(_DWORD *)(a1 + 160) || *(_DWORD *)(a1 + 220) | v19)
          goto LABEL_5;
      }
    }
    v4 = 0;
  }
LABEL_5:
  v6 = *(_DWORD *)(a1 + 172);
  v7 = *(_DWORD *)(a1 + 176);
  if (v6 == v7)
  {
LABEL_8:
    *a2 = v6 >= *(_DWORD *)(a1 + 156);
    return v4;
  }
  v4 = UnicornPipeline_PrepareSynth(a1 + 8, v6 - v7);
  if ((v4 & 0x80000000) == 0)
  {
    UNICORN__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Prepared: %d units\n");
    v6 = *(_DWORD *)(a1 + 172);
    goto LABEL_8;
  }
  return v4;
}

uint64_t UnicornPipelineMT_locSearch(uint64_t a1)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;

  if (*(int *)(a1 + 160) >= 1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(a1 + 24);
    while (!*(_DWORD *)(a1 + 220))
    {
      if ((UNICORN__mfs_ParamGenContinue(v3, *(_QWORD *)(a1 + 16), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 568)) & 0x80000000) != 0
        || ((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 8))() & 0x80000000) != 0
        || ((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 24))() & 0x80000000) != 0
        || ((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 32))() & 0x80000000) != 0)
      {
        goto LABEL_16;
      }
      v4 = *(_DWORD *)(a1 + 152);
      if (v4 >= 1)
      {
        v5 = 0;
        while (1)
        {
          v6 = v2 * v4;
          if (!*(_DWORD *)(*(_QWORD *)(v3 + 1104) + 32 * (v5 + v6) + 16)
            && (UNICORN__mfs_CostList_Add(0.0, *(_QWORD *)(a1 + 16), (_QWORD *)(v3 + 1088), (int)v5 + v6, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 568) + 11548)) & 0x80000000) != 0)
          {
            break;
          }
          if ((semaphore_Release(*(_QWORD **)(a1 + 224)) & 0x80000000) != 0)
            break;
          v4 = *(_DWORD *)(a1 + 152);
          if ((int)++v5 >= v4)
            goto LABEL_14;
        }
LABEL_16:
        *(_DWORD *)(a1 + 220) = 1;
        break;
      }
LABEL_14:
      if (++v2 >= *(_DWORD *)(a1 + 160))
        break;
    }
  }
  semaphore_Release(*(_QWORD **)(a1 + 224));
  return 0;
}

BOOL UnicornPipelineMT_GetForcedEEEnabled(uint64_t a1)
{
  return UnicornPipeline_GetForcedEEEnabled(a1 + 8);
}

uint64_t UnicornPipelineMT_SetForcedEEEnabled(uint64_t a1, int a2)
{
  return UnicornPipeline_SetForcedEEEnabled(a1 + 8, a2);
}

uint64_t UnicornPipelineMT_SetSIMDCallbacks(uint64_t a1, int a2)
{
  return UnicornPipeline_SetSIMDCallbacks(a1 + 8, a2);
}

BOOL UnicornPipelineMT_isDone(uint64_t a1)
{
  return UnicornPipeline_isDone(a1 + 8);
}

uint64_t UnicornPipelineMT_isMultiThreaded()
{
  return 1;
}

uint64_t UnicornPipelineMT_SynthesizeDummy(uint64_t a1, int a2)
{
  return UnicornPipeline_SynthesizeDummy(a1 + 8, a2);
}

uint64_t UnicornPipelineMT_GetPreparedCount(uint64_t a1)
{
  return UnicornPipeline_GetPreparedCount(a1 + 8);
}

uint64_t UnicornPipelineMT_GetStream(uint64_t a1)
{
  return UnicornPipeline_GetStream(a1 + 8);
}

uint64_t UNICORN__mfs_FSM_Load(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int *v4;
  uint64_t v5;
  BOOL v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  _DWORD *v11;
  char *v12;
  unint64_t v13;

  result = 2229280772;
  v4 = *(int **)(a2 + 8);
  v5 = *(unsigned int *)(a2 + 16);
  if (v4)
    v6 = (_DWORD)v5 == 0;
  else
    v6 = 1;
  if (!v6)
  {
    v7 = *v4;
    *(_DWORD *)a1 = *v4;
    if (v5 >= 5)
    {
      v8 = v4[1];
      *(_DWORD *)(a1 + 4) = v8;
      if (v5 >= 9)
      {
        v9 = v4[2];
        *(_DWORD *)(a1 + 8) = v9;
        if (v5 >= 0xD)
        {
          v10 = (char *)v4 + v5;
          v11 = v4 + 3;
          *(_QWORD *)(a1 + 16) = v11;
          v12 = (char *)&v11[2 * (v7 + 1)];
          if (v12 < v10)
          {
            *(_QWORD *)(a1 + 24) = v12;
            v13 = (unint64_t)&v12[8 * v8];
            if (v13 < (unint64_t)v10)
            {
              *(_QWORD *)(a1 + 32) = v13;
              if ((char *)(v13 + 12 * v9) == v10)
                return 0;
              else
                return 2229280772;
            }
          }
        }
      }
    }
  }
  return result;
}

void *UNICORN__mfs_FSM_DeInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x28uLL);
}

uint64_t UNICORN__mfs_Version_Init()
{
  return 3341;
}

uint64_t UNICORN__mfs_Version_Retrieve(uint64_t a1, _BYTE *a2)
{
  char v2;
  char *v3;
  const char *v4;
  int v6;

  *(_QWORD *)(a1 + 64) = a2;
  v2 = 86;
  v3 = &byte_214FA6939;
  v4 = "vljpollet";
  do
  {
    *a2++ = *v4 ^ v2;
    if (!*(unsigned __int8 *)++v4)
      v4 = "vljpollet";
    v6 = *v3++;
    v2 = v6;
  }
  while (v6);
  *(a2 - 1) = 0;
  return __sprintf_chk((char *)a1, 0, 0x40uLL, "%d.%02d %s", 1, 0, "Unicorn");
}

uint64_t UNICORN__mfs_Version_DeInit(uint64_t a1)
{
  *(_QWORD *)(a1 + 64) = 0;
  return 0;
}

uint64_t UNICORN__mfs_Version_DataCheck(uint64_t a1, const char *a2)
{
  return strcmp(UNICORN__VersionMetaData01, a2);
}

void *Allocate_EQ_SYM5DIAG(uint64_t a1, unsigned int a2)
{
  char *v4;
  void *result;
  uint64_t v6;

  *(_DWORD *)a1 = a2;
  v4 = (char *)malloc(20 * a2);
  *(_QWORD *)(a1 + 8) = v4;
  result = malloc(8 * a2);
  *(_QWORD *)(a1 + 16) = result;
  if (a2)
  {
    v6 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 16) + v6) = v4;
      v4 += 12;
      v6 += 8;
    }
    while (8 * a2 != v6);
  }
  *(_QWORD *)(a1 + 24) = v4;
  *(_QWORD *)(a1 + 32) = &v4[4 * a2];
  return result;
}

double Deallocate_EQ_SYM5DIAG(uint64_t a1)
{
  double result;

  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  *(_DWORD *)a1 = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

float EQ_SYM5DIAG_LU_decomposition(unsigned int *a1, double a2)
{
  uint64_t v2;
  float *v3;
  _DWORD *v4;
  float32x2_t v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  float **v10;
  uint64_t v11;
  float *v12;
  float v13;
  float v14;
  float v15;

  v2 = *((_QWORD *)a1 + 2);
  v4 = *(_DWORD **)v2;
  v3 = *(float **)(v2 + 8);
  LODWORD(a2) = **(_DWORD **)v2;
  v5 = vdiv_f32(*(float32x2_t *)(*(_QWORD *)v2 + 4), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0));
  *(float32x2_t *)(v4 + 1) = v5;
  v6 = v3[1];
  *(float *)&a2 = *v3 + (float)((float)((float)-v5.f32[0] * v5.f32[0]) * *(float *)&a2);
  *v3 = *(float *)&a2;
  v7 = (float)(v6 + (float)((float)-(float)(*((float *)v4 + 1) * *((float *)v4 + 2)) * *(float *)v4)) / *(float *)&a2;
  v8 = v3[2] / *(float *)&a2;
  v3[1] = v7;
  v3[2] = v8;
  v9 = *a1;
  if (v9 >= 3)
  {
    v10 = (float **)(v2 + 16);
    v11 = v9 - 2;
    do
    {
      v12 = *v10;
      v13 = (*v10)[1];
      v14 = **v10 + (float)((float)-(float)(v7 * v7) * *(float *)&a2);
      *v12 = v14;
      *(float *)&a2 = v14 + (float)((float)-(float)((*(v10 - 2))[2] * (*(v10 - 2))[2]) * **(v10 - 2));
      *v12 = *(float *)&a2;
      v7 = (float)(v13 + (float)((float)-(float)(v3[1] * v3[2]) * *v3)) / *(float *)&a2;
      v15 = v12[2] / *(float *)&a2;
      v12[1] = v7;
      v12[2] = v15;
      ++v10;
      v3 = v12;
      --v11;
    }
    while (v11);
  }
  return *(float *)&a2;
}

float *solve_LU_EQ_SYM5DIAG(_QWORD *a1, float *a2)
{
  float *v2;
  uint64_t *v3;
  float *v4;
  float v5;
  uint64_t v6;
  float v7;
  uint64_t v8;
  float *v9;
  float *v10;
  uint64_t *v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  float *v18;
  uint64_t v19;
  float **v20;
  float *v21;

  v3 = (uint64_t *)a1[2];
  v2 = (float *)a1[3];
  v4 = (float *)a1[4];
  v5 = *v2;
  *v4 = *v2;
  v6 = *v3;
  v7 = v2[1] - (float)(*(float *)(*v3 + 4) * v5);
  v4[1] = v7;
  v8 = *(unsigned int *)a1;
  if ((int)v8 >= 3)
  {
    v9 = v4 + 2;
    v10 = v2 + 2;
    v11 = v3 + 1;
    v12 = v8 - 2;
    do
    {
      v13 = *v10++;
      v14 = v13;
      v15 = *(float *)(v6 + 8);
      v16 = *v11++;
      v6 = v16;
      v7 = v14 - (float)((float)(v15 * *(v9 - 2)) + (float)(*(float *)(v16 + 4) * v7));
      *v9++ = v7;
      --v12;
    }
    while (v12);
  }
  if (a2 || (a2 = (float *)malloc(4 * v8)) != 0)
  {
    v17 = v4[(int)v8 - 1] / *(float *)v3[(int)v8 - 1];
    a2[(int)v8 - 1] = v17;
    v18 = (float *)v3[(int)v8 - 2];
    a2[(int)v8 - 2] = (float)(v4[(int)v8 - 2] / *v18) - (float)(v18[1] * v17);
    if ((int)v8 >= 3)
    {
      v19 = (v8 - 3);
      v20 = (float **)&v3[(v8 - 3)];
      do
      {
        v21 = *v20--;
        a2[v19] = (float)((float)(v4[v19] / *v21) - (float)(v21[1] * a2[v19 + 1])) - (float)(v21[2] * a2[v19 + 2]);
        --v19;
      }
      while (v19 != -1);
    }
  }
  return a2;
}

float *solve_EQ_SYM5DIAG(unsigned int *a1, float *a2, double a3)
{
  EQ_SYM5DIAG_LU_decomposition(a1, a3);
  return solve_LU_EQ_SYM5DIAG(a1, a2);
}

uint64_t UNICORN__mfs_CostList_CompareNodesScore_faster(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = v2 > v3;
  if (v2 >= v3)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t UNICORN__mfs_CostList_Init(uint64_t a1, uint64_t a2, unsigned int *__b, unsigned int a4, int a5)
{
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[32];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v10 = 2229280778;
  cstdlib_memset(__b, 0, 0xE8uLL);
  result = 2229280774;
  if (a1 && a2)
  {
    *(_QWORD *)__b = a1;
    *((_QWORD *)__b + 1) = a2;
    v12 = heap_Calloc(*(_QWORD **)(a1 + 8), a4, 32);
    *((_QWORD *)__b + 2) = v12;
    if (!v12)
      return 2229280778;
    if (a4)
    {
      v13 = 0;
      do
      {
        v14 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), 1, 12);
        v15 = *((_QWORD *)__b + 2);
        *(_QWORD *)(v15 + v13) = v14;
        if (!v14)
          return 2229280778;
        v16 = v15 + v13;
        *(_QWORD *)(v16 + 16) = 0x100000000;
        *(_DWORD *)(v16 + 24) = a5;
        *(_DWORD *)(v16 + 28) = 1;
        v13 += 32;
      }
      while (32 * a4 != v13);
    }
    __b[6] = a4;
    if (*(_DWORD *)(a2 + 1928) == 1)
    {
      v17 = (unsigned int *)*((_QWORD *)__b + 1);
      if (v17[482] != 1)
        return 0;
      v18 = ((*(_DWORD *)(*((_QWORD *)v17 + 71) + 11548) + 1)
           / *(_DWORD *)(*((_QWORD *)v17 + 71) + 5992)
           + 31) >> 5;
      __b[14] = -1;
      __b[15] = v18;
      *((_QWORD *)__b + 8) = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v18, 4);
      v19 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), 4, (*(_DWORD *)(*((_QWORD *)v17 + 71) + 11548) + 101)/ *(_DWORD *)(*((_QWORD *)v17 + 71) + 5992));
      *((_QWORD *)__b + 9) = v19;
      if (*((_QWORD *)__b + 8))
      {
        if (v19)
        {
          __b[8] = -1;
          __b[20] = -1;
          if (*(_DWORD *)(*((_QWORD *)v17 + 71) + 5992) == 1)
            goto LABEL_13;
          v26 = __b[15];
          __b[9] = v26;
          *((_QWORD *)__b + 5) = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v26, 4);
          v27 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), 4, (*(_DWORD *)(*((_QWORD *)v17 + 71) + 11548) + 101)/ *(_DWORD *)(*((_QWORD *)v17 + 71) + 5992));
          *((_QWORD *)__b + 6) = v27;
          if (*((_QWORD *)__b + 5))
          {
            if (v27)
            {
              v28 = __b[15];
              __b[21] = v28;
              *((_QWORD *)__b + 11) = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v28, 4);
              v29 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), 4, (*(_DWORD *)(*((_QWORD *)v17 + 71) + 11548) + 101)/ *(_DWORD *)(*((_QWORD *)v17 + 71) + 5992));
              *((_QWORD *)__b + 12) = v29;
              if (*((_QWORD *)__b + 11))
              {
                if (v29)
                {
LABEL_13:
                  __b[55] = 1;
                  v20 = ((v17[249] + 31) >> 5) * *v17;
                  __b[54] = v20;
                  v21 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v20, 4);
                  *((_QWORD *)__b + 26) = v21;
                  if (v21)
                  {
                    v22 = *v17;
                    if ((int)v22 >= 1)
                    {
                      v23 = v17[249];
                      v24 = (unsigned int *)v30;
                      do
                      {
                        *v24++ = v23;
                        --v22;
                      }
                      while (v22);
                    }
                    Unicorn_CostListBlock_ResetPointers((char *)__b, (uint64_t)v30);
                    v25 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v17[249], 4);
                    *((_QWORD *)__b + 13) = v25;
                    if (v25)
                      return 0;
                    else
                      return 2229280778;
                  }
                }
              }
            }
          }
        }
      }
      return v10;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t Unicorn_CostListBlock_Set(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _DWORD v9[8];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 8);
  if ((*(_DWORD *)v2 - 1) <= 0xFFFFFFFC)
  {
    v3 = 0;
    v4 = (*(_DWORD *)v2 + 2);
    v5 = *(_QWORD *)(v2 + 776);
    v6 = *(_QWORD *)(a2 + 64) + 8;
    do
    {
      v9[v3] = *(_DWORD *)(*(_QWORD *)(v5 + 16 + 8 * v3) + 40 * *(unsigned int *)(v6 + 4 * v3) + 4);
      v7 = v3 + 3;
      ++v3;
    }
    while (v7 < v4);
  }
  Unicorn_CostListBlock_ResetPointers((char *)a1, (uint64_t)v9);
  return 0;
}

char *Unicorn_CostListBlock_ResetPointers(char *result, uint64_t a2)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;

  if (a2)
  {
    v2 = (int *)*((_QWORD *)result + 1);
    if (*v2 < 1)
    {
      v8 = 0;
    }
    else
    {
      v3 = 0;
      v4 = 0;
      v5 = result + 176;
      do
      {
        v6 = (*(_DWORD *)(a2 + 4 * v3) + 31) >> 5;
        *(_QWORD *)&v5[8 * v3 - 64] = *((_QWORD *)result + 26) + 4 * v4;
        *(_DWORD *)&v5[4 * v3] = v6;
        v4 += v6;
        v7 = v3 + 2;
        ++v3;
      }
      while (v7 <= *v2);
      v8 = 4 * v4;
    }
    return (char *)cstdlib_memset(*((void **)result + 26), 0, v8);
  }
  return result;
}

_QWORD *mfs_CostList_FreeAt(_QWORD *a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v3 = a2;
  v4 = 32 * a2;
  result = heap_Free(*(_QWORD **)(*a1 + 8), *(_QWORD *)(a1[2] + v4));
  v6 = a1[2];
  v7 = v6 + 32 * v3;
  *(_QWORD *)(v6 + v4) = 0;
  v10 = *(_QWORD *)(v7 + 8);
  v9 = (_QWORD *)(v7 + 8);
  v8 = v10;
  if (v10)
  {
    result = heap_Free(*(_QWORD **)(*a1 + 8), v8);
    *v9 = 0;
  }
  return result;
}

_QWORD *UNICORN__mfs_CostList_DeInit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;

  v1 = result;
  v2 = result[5];
  if (v2)
  {
    result = heap_Free(*(_QWORD **)(*result + 8), v2);
    v1[5] = 0;
  }
  v3 = v1[6];
  if (v3)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v3);
    v1[6] = 0;
  }
  v4 = v1[8];
  if (v4)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v4);
    v1[8] = 0;
  }
  v5 = v1[9];
  if (v5)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v5);
    v1[9] = 0;
  }
  v6 = v1[11];
  if (v6)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v6);
    v1[11] = 0;
  }
  v7 = v1[12];
  if (v7)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v7);
    v1[12] = 0;
  }
  v8 = v1[26];
  if (v8)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v8);
    v1[26] = 0;
  }
  v9 = v1[13];
  if (v9)
  {
    result = heap_Free(*(_QWORD **)(*v1 + 8), v9);
    v1[13] = 0;
  }
  v10 = v1[2];
  if (v10)
  {
    if (*((_DWORD *)v1 + 6))
    {
      v11 = 0;
      do
        mfs_CostList_FreeAt(v1, v11++);
      while (v11 < *((_DWORD *)v1 + 6));
      v10 = v1[2];
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), v10);
    v1[2] = 0;
  }
  *((_DWORD *)v1 + 6) = 0;
  return result;
}

uint64_t UNICORN__mfs_CostList_IsNodeInList(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v6;
  unsigned int InsertionPoint;

  v6 = *(_QWORD *)(a1 + 16) + 32 * a2;
  *a4 = -1;
  InsertionPoint = mfs_CostList_FindInsertionPoint((uint64_t *)v6, a3);
  if (InsertionPoint >= *(_DWORD *)(v6 + 16) || *(_DWORD *)(*(_QWORD *)v6 + 12 * InsertionPoint) != a3)
    return 0;
  *a4 = InsertionPoint;
  return 1;
}

uint64_t mfs_CostList_FindInsertionPoint(uint64_t *a1, unsigned int a2)
{
  int v2;
  int v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v2 = *((_DWORD *)a1 + 4);
  v3 = v2 - 1;
  if (v2 < 1)
    return 0;
  result = 0;
  v6 = *a1;
  while (1)
  {
    v7 = ((v3 + (int)result) >> 1);
    v8 = *(_DWORD *)(v6 + 12 * (int)v7);
    if (v8 >= a2)
    {
      if (v8 <= a2)
        return v7;
      v3 = v7 - 1;
    }
    else
    {
      result = (v7 + 1);
    }
    if ((int)result <= v3)
    {
      v7 = ((v3 + (int)result) >> 1);
      v9 = *(_DWORD *)(v6 + 12 * (int)v7);
      if (v9 >= a2)
      {
        if (v9 <= a2)
          return v7;
        v3 = v7 - 1;
      }
      else
      {
        result = (v7 + 1);
      }
      if ((int)result <= v3)
        break;
    }
LABEL_17:
    if ((int)result > v3)
      return result;
  }
  v7 = ((v3 + (int)result) >> 1);
  v10 = *(_DWORD *)(v6 + 12 * (int)v7);
  if (v10 < a2)
  {
    result = (v7 + 1);
    goto LABEL_17;
  }
  if (v10 > a2)
  {
    v3 = v7 - 1;
    goto LABEL_17;
  }
  return v7;
}

uint64_t UNICORN__mfs_CostList_Resize(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v3 = a1[2] + 32 * a2;
  if (*(_DWORD *)(v3 + 20) >= a3)
    return 0;
  v5 = heap_Realloc(*(uint64_t **)(*a1 + 8), *(_QWORD *)v3, 12 * a3);
  if (!v5)
    return 2229280778;
  v6 = v5;
  result = 0;
  *(_DWORD *)(v3 + 20) = a3;
  *(_QWORD *)v3 = v6;
  return result;
}

uint64_t UNICORN__mfs_CostList_Add(float a1, uint64_t a2, _QWORD *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int InsertionPoint;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;

  v5 = 2229280769;
  v6 = a3[2];
  v7 = a4;
  v8 = v6 + 32 * a4;
  if (!*(_DWORD *)(v8 + 24))
  {
    InsertionPoint = mfs_CostList_FindInsertionPoint((uint64_t *)(v6 + 32 * a4), a5);
    v13 = InsertionPoint;
    v15 = (unsigned int *)(v8 + 16);
    v14 = *(_DWORD *)(v8 + 16);
    v16 = *(_QWORD *)v8;
    if (InsertionPoint < v14 && *(_DWORD *)(v16 + 12 * InsertionPoint) == a5)
    {
      return 2229280770;
    }
    else
    {
      v17 = v6 + 32 * v7;
      v19 = *(_DWORD *)(v17 + 20);
      v18 = (unsigned int *)(v17 + 20);
      if (v19 == v14)
      {
        v20 = v14 + 64;
        *v18 = v20;
        v21 = heap_Realloc(*(uint64_t **)(*a3 + 8), v16, 12 * v20);
        *(_QWORD *)v8 = v21;
        if (!v21)
        {
          *v18 -= 64;
          return 2229280778;
        }
        v16 = v21;
        v14 = *v15;
      }
      v22 = v13;
      v23 = v14 - v13;
      if (v23)
      {
        cstdlib_memmove((void *)(v16 + 12 * (v13 + 1)), (const void *)(v16 + 12 * v13), 12 * v23);
        v16 = *(_QWORD *)v8;
        v13 = *v15;
      }
      v5 = 0;
      v24 = v16 + 12 * v22;
      *(_DWORD *)v24 = a5;
      *(float *)(v24 + 4) = a1;
      *v15 = v13 + 1;
    }
  }
  return v5;
}

uint64_t UNICORN__mfs_CostList_Pad(_QWORD *a1, unsigned int a2, int a3, float a4)
{
  uint64_t v4;
  uint64_t v5;
  int *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v4 = 2229280769;
  v5 = a1[2] + 32 * a2;
  if (!*(_DWORD *)(v5 + 24))
  {
    v8 = (int *)(v5 + 16);
    v9 = *(_DWORD *)(v5 + 16);
    v10 = (_DWORD *)(v5 + 20);
    v11 = *(_QWORD *)v5;
    if (*(_DWORD *)(v5 + 20) == v9)
    {
      *v10 = v9 + 64;
      v12 = heap_Realloc(*(uint64_t **)(*a1 + 8), v11, 12 * (v9 + 64));
      *(_QWORD *)v5 = v12;
      if (!v12)
      {
        *v10 -= 64;
        return 2229280778;
      }
      v11 = v12;
      v13 = *v8;
    }
    else
    {
      v13 = *(_DWORD *)(v5 + 16);
    }
    v4 = 0;
    v14 = v11 + 12 * v9;
    *(_DWORD *)v14 = a3;
    *(float *)(v14 + 4) = a4;
    *v8 = v13 + 1;
  }
  return v4;
}

uint64_t mfs_CostList_Pad_Faster(uint64_t result, int a2, float a3)
{
  unsigned int v3;
  uint64_t v4;

  v3 = *(_DWORD *)(result + 16);
  v4 = *(_QWORD *)result + 12 * v3;
  *(_DWORD *)v4 = a2;
  *(float *)(v4 + 4) = a3;
  *(_DWORD *)(result + 16) = v3 + 1;
  return result;
}

uint64_t mfs_CostList_PadWithBnfOffset(_QWORD *a1, unsigned int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v9;

  result = UNICORN__mfs_CostList_Pad(a1, a2, a3, a5);
  if (!(_DWORD)result)
  {
    v9 = a1[2] + 32 * a2;
    *(_DWORD *)(*(_QWORD *)v9 + 12 * (*(_DWORD *)(v9 + 16) - 1) + 8) = a4;
  }
  return result;
}

uint64_t UNICORN__mfs_ConcatTwoLists(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t result;

  v4 = *(_QWORD *)(a3 + 16) + 32 * a4;
  v5 = (unsigned int *)(v4 + 16);
  v6 = *(_DWORD *)(v4 + 16);
  if (!v6)
    goto LABEL_6;
  v7 = a1[2];
  v8 = a2;
  v9 = v7 + 32 * a2;
  v10 = (_DWORD *)(v9 + 16);
  v11 = *(_DWORD *)(v9 + 16) + 2 * v6;
  v12 = (unsigned int *)(v9 + 20);
  if (v11 <= *(_DWORD *)(v9 + 20))
    goto LABEL_5;
  *v12 = v11;
  v13 = heap_Realloc(*(uint64_t **)(*a1 + 8), *(_QWORD *)v9, 12 * v11);
  *(_QWORD *)v9 = v13;
  if (!v13)
  {
    *v12 -= v6;
    result = 2229280778;
    goto LABEL_8;
  }
  v6 = *v5;
  if (*v5)
  {
LABEL_5:
    cstdlib_memcpy((void *)(*(_QWORD *)v9 + 12 * *v10), *(const void **)v4, 12 * v6);
    result = 0;
    *v10 += *v5;
    *(_DWORD *)(v7 + 32 * v8 + 28) = 0;
  }
  else
  {
LABEL_6:
    result = 0;
  }
LABEL_8:
  *v5 = 0;
  return result;
}

uint64_t mfs_ClonePrevList(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v5;
  _DWORD *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  void **v13;
  _QWORD *v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a2)
  {
    if (a3)
    {
      v5 = a3 - 1;
      v6 = (_DWORD *)a1 + v5 + 44;
      if (*((_DWORD *)a1 + a3 + 44) == *v6)
      {
        v8 = a1[2];
        v9 = a2 - 1;
        v10 = v8 + 32 * v9;
        v12 = *(_DWORD *)(v10 + 16);
        v11 = (unsigned int *)(v10 + 16);
        if ((UNICORN__mfs_CostList_Resize(a1, a2, v12) & 0x80000000) == 0)
        {
          v13 = (void **)(v8 + 32 * a2);
          v14 = a1 + 14;
          cstdlib_memcpy(*v13, *(const void **)(v8 + 32 * v9), 12 * *v11);
          v15 = *v11;
          if (*v11)
          {
            v16 = *v13;
            v17 = *v11;
            do
            {
              ++*v16;
              v16 += 3;
              --v17;
            }
            while (v17);
          }
          v18 = v8 + 32 * a2;
          *(_DWORD *)(v18 + 16) = v15;
          v19 = v8 + 32 * v9;
          *(_DWORD *)(v18 + 28) = *(_DWORD *)(v19 + 28);
          *(_QWORD *)(v18 + 20) = *(_QWORD *)(v19 + 20);
          cstdlib_memcpy((void *)v14[a3], (const void *)v14[v5], 4 * *v6);
        }
      }
    }
  }
  return 0;
}

uint64_t UNICORN__mfs_CostList_Sort(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t result;
  unsigned int v9;
  uint64_t (*v10)(unint64_t, unint64_t);

  v4 = *(_QWORD *)(a1 + 16);
  v5 = a2;
  v6 = v4 + 32 * a2;
  v7 = (_DWORD *)(v6 + 24);
  if (*(_DWORD *)(v6 + 24) == a3 && *(_DWORD *)(v6 + 28))
    return 0;
  if (!a3)
  {
    v9 = *(_DWORD *)(v4 + 32 * a2 + 16);
    if (v9)
    {
      v10 = (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesUid;
      goto LABEL_10;
    }
LABEL_11:
    result = 0;
    *v7 = a3;
    *(_DWORD *)(v4 + 32 * v5 + 28) = 1;
    return result;
  }
  if (a3 == 1)
  {
    v9 = *(_DWORD *)(v4 + 32 * a2 + 16);
    if (v9)
    {
      v10 = (uint64_t (*)(unint64_t, unint64_t))UNICORN__mfs_CostList_CompareNodesScore_faster;
LABEL_10:
      ssft_qsort(*(_QWORD *)v6, v9, 12, v10);
      goto LABEL_11;
    }
    goto LABEL_11;
  }
  return 2229280769;
}

uint64_t mfs_CostList_CompareNodesUid(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

uint64_t mfs_CostList_QSelectUnitIDs_Faster(uint64_t result, int a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t *v19;
  int v20;
  uint64_t v21;
  int v22;

  v3 = a2 - 1;
  if (a2 != 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = (uint64_t *)(result + 12 * a3);
    do
    {
      v7 = v3;
      v8 = (uint64_t *)(result + 12 * v3);
      v9 = *((_DWORD *)v8 + 2);
      v10 = *v8;
      v11 = *((_DWORD *)v6 + 2);
      *v8 = *v6;
      *((_DWORD *)v8 + 2) = v11;
      *v6 = v10;
      *((_DWORD *)v6 + 2) = v9;
      v12 = v4;
      if (v4 < v3)
      {
        v13 = (uint64_t *)(result + 12 * v4);
        v14 = v7 - v4;
        v12 = v4;
        do
        {
          if (*(_DWORD *)v13 < *(_DWORD *)v8)
          {
            v15 = (uint64_t *)(result + 12 * v12);
            v16 = *((_DWORD *)v15 + 2);
            v17 = *v15;
            v18 = *((_DWORD *)v13 + 2);
            *v15 = *v13;
            *((_DWORD *)v15 + 2) = v18;
            *v13 = v17;
            *((_DWORD *)v13 + 2) = v16;
            ++v12;
          }
          v13 = (uint64_t *)((char *)v13 + 12);
          --v14;
        }
        while (v14);
      }
      v19 = (uint64_t *)(result + 12 * v12);
      v20 = *((_DWORD *)v19 + 2);
      v21 = *v19;
      v22 = *((_DWORD *)v8 + 2);
      *v19 = *v8;
      *((_DWORD *)v19 + 2) = v22;
      *v8 = v21;
      *((_DWORD *)v8 + 2) = v20;
      if (v12 == a3)
        break;
      if (v12 >= a3)
      {
        v3 = v12 - 1;
      }
      else
      {
        v4 = v12 + 1;
        v3 = v7;
      }
      ++v5;
    }
    while (v5 < v3);
  }
  return result;
}

uint64_t mfs_CostList_QSelectScores_Faster(uint64_t result, int a2, int a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  int v23;

  v3 = a2 - 1;
  if (a2 != 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = a3 - 1;
    do
    {
      v7 = (uint64_t *)(result + 12 * v3);
      v8 = *((_DWORD *)v7 + 2);
      v9 = *v7;
      v10 = (uint64_t *)(result + 12 * (v3 >> 1));
      v11 = *((_DWORD *)v10 + 2);
      v12 = v3;
      *v7 = *v10;
      *((_DWORD *)v7 + 2) = v11;
      *v10 = v9;
      *((_DWORD *)v10 + 2) = v8;
      v13 = v4;
      if (v4 < v3)
      {
        v14 = (uint64_t *)(result + 12 * v4);
        v15 = v3 - (unint64_t)v4;
        v13 = v4;
        do
        {
          if (*((_DWORD *)v14 + 1) < *(_DWORD *)(result + 12 * v3 + 4))
          {
            v16 = (uint64_t *)(result + 12 * v13);
            v17 = *((_DWORD *)v16 + 2);
            v18 = *v16;
            v19 = *((_DWORD *)v14 + 2);
            *v16 = *v14;
            *((_DWORD *)v16 + 2) = v19;
            *v14 = v18;
            *((_DWORD *)v14 + 2) = v17;
            ++v13;
          }
          v14 = (uint64_t *)((char *)v14 + 12);
          --v15;
        }
        while (v15);
      }
      v20 = (uint64_t *)(result + 12 * v13);
      v21 = *((_DWORD *)v20 + 2);
      v22 = *v20;
      v23 = *((_DWORD *)v7 + 2);
      *v20 = *v7;
      *((_DWORD *)v20 + 2) = v23;
      *v7 = v22;
      *((_DWORD *)v7 + 2) = v21;
      if (v13 == v6)
        break;
      if (v13 >= v6)
      {
        v3 = v13 - 1;
      }
      else
      {
        v4 = v13 + 1;
        v3 = v12;
      }
      ++v5;
    }
    while (v5 < v3);
  }
  return result;
}

uint64_t mfs_CostList_Select(uint64_t a1, unsigned int a2, int a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v8;
  int v9;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = a2;
  v6 = v4 + 32 * a2;
  if (*(_DWORD *)(v6 + 24) == a3 && *(_DWORD *)(v6 + 28))
    return 0;
  if (!a3)
  {
    v9 = *(_DWORD *)(v4 + 32 * a2 + 16);
    if (v9)
      mfs_CostList_QSelectUnitIDs_Faster(*(_QWORD *)v6, v9, a4);
    goto LABEL_10;
  }
  if (a3 == 1)
  {
    v8 = *(_DWORD *)(v4 + 32 * a2 + 16);
    if (v8)
      mfs_CostList_QSelectScores_Faster(*(_QWORD *)v6, v8, a4);
LABEL_10:
    result = 0;
    *(_DWORD *)(v4 + 32 * v5 + 28) = 0;
    return result;
  }
  return 2229280769;
}

uint64_t UNICORN__mfs_CostList_UpdateCost_inlined(uint64_t result, unsigned int a2, unsigned int a3, float a4)
{
  *(float *)(*(_QWORD *)(*(_QWORD *)(result + 16) + 32 * a2) + 12 * a3 + 4) = a4;
  return result;
}

uint64_t UNICORN__mfs_CostList_UpdateCostEnd_inlined(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 16) + 32 * a2;
  if (*(_DWORD *)(v2 + 24) == 1)
    *(_DWORD *)(v2 + 28) = 0;
  return result;
}

uint64_t UNICORN__mfs_CostList_UpdateCost(uint64_t result, unsigned int a2, unsigned int a3, float a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(result + 16) + 32 * a2;
  *(float *)(*(_QWORD *)v4 + 12 * a3 + 4) = a4;
  if (*(_DWORD *)(v4 + 24) == 1)
    *(_DWORD *)(v4 + 28) = 0;
  return result;
}

uint64_t UNICORN__mfs_CostList_HasUnit(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int *v14;
  int v15;
  unint64_t v16;
  BOOL v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int *v22;
  int v23;
  uint64_t result;
  int v25;
  int v26;
  int v27;
  unsigned int v28;

  v3 = a1[2];
  if (!v3)
    return 0;
  v4 = v3 + 32 * a2;
  v6 = (_DWORD *)(v4 + 16);
  v5 = *(unsigned int *)(v4 + 16);
  if (!*(_DWORD *)(v4 + 16))
    return 0;
  v8 = v3 + 32 * a2;
  if (!*(_DWORD *)(v8 + 24))
  {
    v17 = __OFSUB__((_DWORD)v5, 1);
    v18 = v5 - 1;
    if (v18 < 0 == v17)
    {
      v19 = 0;
      do
      {
        v20 = (v18 + v19) / 2;
        v21 = *(_DWORD *)(*(_QWORD *)v4 + 12 * v20);
        if (v21 >= a3)
        {
          if (v21 <= a3)
            return 1;
          v18 = v20 - 1;
        }
        else
        {
          v19 = v20 + 1;
        }
      }
      while (v19 <= v18);
    }
    return 0;
  }
  v10 = *(_QWORD *)(v8 + 8);
  v9 = (uint64_t *)(v8 + 8);
  if (v10)
    goto LABEL_25;
  v11 = heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * v5);
  *v9 = v11;
  v12 = *v6;
  if (v11)
  {
    if ((_DWORD)v12)
    {
      v13 = 0;
      v14 = *(int **)v4;
      do
      {
        v15 = *v14;
        v14 += 3;
        *(_DWORD *)(v11 + 4 * v13++) = v15;
        v16 = *v6;
      }
      while (v13 < v16);
    }
    else
    {
      v16 = 0;
    }
    ssft_qsort(v11, v16, 4, (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesUid);
    LODWORD(v5) = *v6;
LABEL_25:
    v17 = __OFSUB__((_DWORD)v5, 1);
    v25 = v5 - 1;
    if (v25 < 0 == v17)
    {
      v26 = 0;
      do
      {
        v27 = (v25 + v26) / 2;
        v28 = *(_DWORD *)(*v9 + 4 * v27);
        if (v28 >= a3)
        {
          if (v28 <= a3)
            return 1;
          v25 = v27 - 1;
        }
        else
        {
          v26 = v27 + 1;
        }
      }
      while (v26 <= v25);
    }
    return 0;
  }
  if (!(_DWORD)v12)
    return 0;
  v22 = *(int **)v4;
  while (1)
  {
    v23 = *v22;
    v22 += 3;
    if (v23 == a3)
      break;
    result = 0;
    if (!--v12)
      return result;
  }
  return 1;
}

_QWORD *UNICORN__mfs_CostList_Prune(_QWORD *result, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v3 = a2;
  v4 = result[2] + 32 * a2;
  if (*(_DWORD *)(v4 + 16) > a3)
  {
    v5 = result;
    *(int32x2_t *)(v4 + 16) = vdup_n_s32(a3);
    result = (_QWORD *)heap_Realloc(*(uint64_t **)(*result + 8), *(_QWORD *)v4, 12 * a3);
    if (result)
      *(_QWORD *)v4 = result;
    v6 = v5[2] + 32 * v3;
    v9 = *(_QWORD *)(v6 + 8);
    v8 = (_QWORD *)(v6 + 8);
    v7 = v9;
    if (v9)
    {
      result = heap_Free(*(_QWORD **)(*v5 + 8), v7);
      *v8 = 0;
    }
  }
  return result;
}

_QWORD *UNICORN__mfs_CostList_FreeUidIndex(_QWORD *result)
{
  _QWORD *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result[2])
  {
    v1 = result;
    v2 = *((unsigned int *)result + 6);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 8;
      do
      {
        v5 = v1[2];
        v6 = *(_QWORD *)(v5 + v4);
        if (v6)
        {
          result = heap_Free(*(_QWORD **)(*v1 + 8), v6);
          *(_QWORD *)(v5 + v4) = 0;
          v2 = *((unsigned int *)v1 + 6);
        }
        ++v3;
        v4 += 32;
      }
      while (v3 < v2);
    }
  }
  return result;
}

uint64_t UNICORN__mfs_SparseMtx_Load(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  float v5;
  float v6;
  float v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  v2 = 2229280772;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    v4 = *(_DWORD *)(a2 + 16);
    if (v4)
    {
      *(_QWORD *)a1 = v3;
      v5 = (float)v4 * 0.25;
      v6 = sqrtf(v5);
      if ((float)(v6 - floorf(v6)) <= 0.0)
      {
        v9 = v6;
        v10 = v4 >> 2;
        do
        {
          v11 = v9 * v9;
          ++v9;
        }
        while (v11 < v10);
        v8 = v9 - 1;
      }
      else
      {
        v7 = sqrt((v5 + -1.0) * 0.5);
        v8 = v7;
      }
      v2 = 0;
      *(_DWORD *)(a1 + 8) = v8;
      *(_DWORD *)(a1 + 12) = v8;
    }
  }
  return v2;
}

uint64_t mfs_FullMtx_Load(_QWORD *a1, char *__src, int a3, void *a4, int *a5)
{
  char *v10;
  int v11;

  if (a5)
    *a5 = 0;
  if (__src)
  {
    cstdlib_memcpy(a1 + 1, __src, 4uLL);
    cstdlib_memcpy((char *)a1 + 12, __src + 4, 4uLL);
    v10 = __src + 8;
    if (a5)
    {
      v11 = *a5 + 8;
      *a5 = v11;
      if (a3)
      {
        cstdlib_memcpy(a4, v10, 4uLL);
        v10 = __src + 12;
        v11 = *a5 + 4;
        *a5 = v11;
      }
      *a1 = v10;
      *a5 = v11 + 4 * *((_DWORD *)a1 + 2) * *((_DWORD *)a1 + 3);
    }
    else if (a3)
    {
      cstdlib_memcpy(a4, v10, 4uLL);
      *a1 = __src + 12;
    }
    else
    {
      *a1 = v10;
    }
  }
  return 0;
}

void *UNICORN__mfs_SparseMtx_DeInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x10uLL);
}

uint64_t UnicornSearch_StageTwo_TreeIndex_Sliced(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t updated;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  int *v12;
  int v13;
  int v14;
  uint64_t BnfTargetVectorPacked;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  float v27;
  uint64_t v28;
  unsigned int *v29;
  int v30;
  uint64_t v31;
  float v32;
  BOOL v33;
  float v34;
  int v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  _DWORD *v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t *v46;
  float v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int *v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  _DWORD *v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t *v69;
  float v70;
  int v71;
  uint64_t v72;
  unsigned int *v73;
  int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  float v88;
  int v89;
  uint64_t v90;
  int v91;
  BOOL v92;
  float v93;
  float v94;
  BOOL v95;
  float v96;
  float v97;
  float v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  int v103;
  uint64_t *v104;
  int v105;
  unsigned int v106;
  __int128 __b;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  unint64_t v111;

  v111 = 0;
  v109 = 0u;
  v110 = 0u;
  __b = 0u;
  v108 = 0u;
  v3 = a2 + *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 92);
  v4 = v3 - 2;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v4))
  {
    updated = 0;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 16) + 32 * v4) + 4) = 0;
  }
  else
  {
    cstdlib_memset(&__b, 0, 0x48uLL);
    *(_DWORD *)(a1 + 280) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 16) + 4 * a2);
    if (*(float *)(*(_QWORD *)(a1 + 112) + 6704) == 0.0)
    {
      LODWORD(updated) = 0;
    }
    else
    {
      updated = mfs_UpdateTargetQuantizedTrajectory_LF0(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 120), a1 + 176);
      if ((updated & 0x80000000) != 0)
        return updated;
    }
    v106 = updated;
    v7 = *(_QWORD *)(a1 + 336);
    if (v7)
      mfs_TCost_Elf0_Manhattan_TreeIndex(*(float **)(a1 + 112), *(_QWORD *)(a1 + 120), (uint64_t *)(*(_QWORD *)(a1 + 120) + 1088), v3 - 2, a1 + 176, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 64) + 4 * a2), a2, *(unsigned __int8 *)(a1 + 345) == 1, *(float *)(v7 + 4 * (2 * v4)), *(float *)(v7 + 4 * ((2 * (_DWORD)v4) | 1u)));
    if (*(_BYTE *)(a1 + 156) || *(_BYTE *)(a1 + 345) != 1)
    {
      v9 = *(_QWORD *)(a1 + 112);
      v8 = *(_QWORD *)(a1 + 120);
      v10 = *(_DWORD *)(a1 + 100);
      v11 = *(_DWORD *)(a1 + 380);
      v12 = *(int **)(v8 + 1096);
      v13 = *v12;
      cstdlib_memset(&__b, 0, 0x48uLL);
      if (v12[482] == 1)
      {
        v111 = __PAIR64__(v11, v10);
        if (v11)
        {
          if ((_DWORD)a2 == 2)
            v14 = 1;
          else
            v14 = v13 + 1 == (_DWORD)a2 ? 2 : 4;
          HIDWORD(v110) = v14;
        }
        else
        {
          HIDWORD(v110) = 0;
        }
        *(_QWORD *)&__b = GetBnfTargetVectorPacked(v8, v4 / *(_DWORD *)(v9 + 5992), (float *)&v109 + 2);
        if (*(int *)(v9 + 6752) >= 1)
        {
          if (v3 != 2)
          {
            if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * (v3 - 3)))
              BnfTargetVectorPacked = 0;
            else
              BnfTargetVectorPacked = GetBnfTargetVectorPacked(v8, (v3 - 3) / *(_DWORD *)(v9 + 5992), (float *)&v109 + 3);
            *((_QWORD *)&__b + 1) = BnfTargetVectorPacked;
          }
          v16 = (v3 - 1) / *(_DWORD *)(v9 + 5992);
          if (v16 < v10)
          {
            if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * (v3 - 1)))
              v17 = 0;
            else
              v17 = GetBnfTargetVectorPacked(v8, v16, (float *)&v110);
            *(_QWORD *)&v108 = v17;
          }
          if (*(int *)(v9 + 6752) >= 2)
          {
            if (v4 >= 2)
            {
              if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * (v3 - 4)))
                v18 = 0;
              else
                v18 = GetBnfTargetVectorPacked(v8, (v3 - 4) / *(_DWORD *)(v9 + 5992), (float *)&v110 + 1);
              *((_QWORD *)&v108 + 1) = v18;
            }
            v19 = v3 / *(_DWORD *)(v9 + 5992);
            if (v19 < v10)
            {
              if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v3))
                v20 = 0;
              else
                v20 = GetBnfTargetVectorPacked(v8, v19, (float *)&v110 + 2);
              *(_QWORD *)&v109 = v20;
            }
          }
        }
      }
      switch(HIDWORD(v110))
      {
        case 4:
          v40 = *(_QWORD **)(a1 + 120);
          v41 = v40[137];
          if (*(_DWORD *)(v41 + 1928) == 1)
          {
            v42 = *(_DWORD **)(a1 + 112);
            if (v42[1688])
            {
              v43 = v40[138];
              if (*(_DWORD *)(v43 + 32 * v4 + 16))
              {
                v44 = 0;
                v45 = 0;
                v46 = (uint64_t *)(v43 + 32 * v4);
                v47 = 1.0 - *(float *)(v40[169] + 4 * v4);
                v105 = *(_DWORD *)(*(_QWORD *)(v41 + 568) + 11548) - 1;
                v48 = *v46;
                do
                {
                  if (v42[1496])
                  {
                    v49 = (unsigned int *)(*v46 + v44 + 8);
                    v50 = v49;
                  }
                  else
                  {
                    v51 = *(_QWORD *)(v41 + 1064);
                    v52 = *(_DWORD *)(*v46 + v44 + 8);
                    v49 = (unsigned int *)(v51 + 4 * (2 * v52));
                    v50 = (unsigned int *)(v51 + 4 * ((2 * v52) | 1u));
                  }
                  v53 = *(_DWORD *)(v48 + v44);
                  v54 = *v50;
                  if (*((_QWORD *)&__b + 1))
                  {
                    v55 = *(float *)(v40[164] + 4);
                    if (((*(_DWORD *)(v40[144] + 4 * (((v53 - 1) / v42[1498]) >> 5)) >> ((v53 - 1) / v42[1498])) & 1) != 0)
                      v56 = *(float *)(v40[145] + 4 * *v49);
                    else
                      v56 = (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v41, *(_QWORD *)(a1 + 56), *((float *)&v109 + 3));
                    v57 = (float)(v55 * v56) + 0.0;
                  }
                  else
                  {
                    v57 = 0.0;
                  }
                  if ((_QWORD)v108)
                  {
                    v58 = *(float *)(v40[164] + 8);
                    if (((*(_DWORD *)(v40[144] + 4 * (((v53 + 1) / v42[1498]) >> 5)) >> ((v53 + 1) / v42[1498])) & 1) != 0)
                      v59 = *(float *)(v40[145] + 4 * v54);
                    else
                      v59 = (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v41, *(_QWORD *)(a1 + 56), *(float *)&v110);
                    v57 = v57 + (float)(v58 * v59);
                  }
                  if ((int)v42[1688] >= 2)
                  {
                    if (*((_QWORD *)&v108 + 1) && v53 >= 2)
                    {
                      v60 = *(float *)(v40[164] + 12);
                      v57 = v57
                          + (float)(v60
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v41, *(_QWORD *)(a1 + 56), *((float *)&v110 + 1)));
                    }
                    if ((_QWORD)v109 && v53 + 2 <= v105)
                    {
                      v61 = *(float *)(v40[164] + 16);
                      v57 = v57
                          + (float)(v61
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v41, *(_QWORD *)(a1 + 56), *((float *)&v110 + 2)));
                    }
                  }
                  v62 = v40[138] + 32 * v4;
                  v48 = *(_QWORD *)v62;
                  *(float *)(*(_QWORD *)v62 + v44 + 4) = (float)(v47 * v57) + *(float *)(*(_QWORD *)v62 + v44 + 4);
                  ++v45;
                  v44 += 12;
                }
                while (v45 < *(unsigned int *)(v62 + 16));
              }
            }
          }
          break;
        case 2:
          v63 = *(_QWORD **)(a1 + 120);
          v64 = v63[137];
          if (*(_DWORD *)(v64 + 1928) == 1)
          {
            v65 = *(_DWORD **)(a1 + 112);
            if (v65[1688])
            {
              v66 = v63[138];
              if (*(_DWORD *)(v66 + 32 * v4 + 16))
              {
                v67 = 0;
                v68 = 0;
                v69 = (uint64_t *)(v66 + 32 * v4);
                v70 = 1.0 - *(float *)(v63[169] + 4 * v4);
                v71 = *(_DWORD *)(*(_QWORD *)(v64 + 568) + 11548) - 1;
                v72 = *v69;
                do
                {
                  if (v65[1496])
                    v73 = (unsigned int *)(*v69 + v67 + 8);
                  else
                    v73 = (unsigned int *)(*(_QWORD *)(v64 + 1064)
                                         + 4 * (2 * *(_DWORD *)(*v69 + v67 + 8)));
                  v74 = *(_DWORD *)(v72 + v67);
                  if (*((_QWORD *)&__b + 1))
                  {
                    v75 = *(float *)(v63[164] + 4);
                    if (((*(_DWORD *)(v63[144] + 4 * (((v74 - 1) / v65[1498]) >> 5)) >> ((v74 - 1) / v65[1498])) & 1) != 0)
                      v76 = *(float *)(v63[145] + 4 * *v73);
                    else
                      v76 = (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v64, *(_QWORD *)(a1 + 56), *((float *)&v109 + 3));
                    v77 = (float)(v75 * v76) + 0.0;
                  }
                  else
                  {
                    v77 = 0.0;
                  }
                  if ((_QWORD)v108 && v74 < v71)
                  {
                    v78 = *(float *)(v63[164] + 8);
                    v77 = v77
                        + (float)(v78
                                * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v64, *(_QWORD *)(a1 + 56), *(float *)&v110));
                  }
                  if ((int)v65[1688] >= 2)
                  {
                    if (*((_QWORD *)&v108 + 1) && v74 >= 2)
                    {
                      v79 = *(float *)(v63[164] + 12);
                      v77 = v77
                          + (float)(v79
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v64, *(_QWORD *)(a1 + 56), *((float *)&v110 + 1)));
                    }
                    if ((_QWORD)v109 && v74 + 2 <= v71)
                    {
                      v80 = *(float *)(v63[164] + 16);
                      v77 = v77
                          + (float)(v80
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v64, *(_QWORD *)(a1 + 56), *((float *)&v110 + 2)));
                    }
                  }
                  v81 = v63[138] + 32 * v4;
                  v72 = *(_QWORD *)v81;
                  *(float *)(*(_QWORD *)v81 + v67 + 4) = (float)(v70 * v77) + *(float *)(*(_QWORD *)v81 + v67 + 4);
                  ++v68;
                  v67 += 12;
                }
                while (v68 < *(unsigned int *)(v81 + 16));
              }
            }
          }
          break;
        case 1:
          v21 = *(_QWORD **)(a1 + 120);
          v22 = v21[137];
          if (*(_DWORD *)(v22 + 1928) == 1)
          {
            v23 = *(_DWORD **)(a1 + 112);
            if (v23[1688])
            {
              v24 = v21[138];
              if (*(_DWORD *)(v24 + 32 * v4 + 16))
              {
                v25 = 0;
                v26 = 0;
                v27 = 1.0 - *(float *)(v21[169] + 4 * v4);
                v103 = *(_DWORD *)(*(_QWORD *)(v22 + 568) + 11548) - 1;
                v104 = (uint64_t *)(v24 + 32 * v4);
                v28 = *v104;
                do
                {
                  if (v23[1496])
                    v29 = (unsigned int *)(*v104 + v25 + 8);
                  else
                    v29 = (unsigned int *)(*(_QWORD *)(v22 + 1064) + 4 * ((2 * *(_DWORD *)(*v104 + v25 + 8)) | 1u));
                  v30 = *(_DWORD *)(v28 + v25);
                  v31 = *v29;
                  v32 = 0.0;
                  if (*((_QWORD *)&__b + 1))
                    v33 = v30 < 1;
                  else
                    v33 = 1;
                  if (!v33)
                  {
                    v34 = *(float *)(v21[164] + 4);
                    v32 = (float)(v34
                                * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v22, *(_QWORD *)(a1 + 56), *((float *)&v109 + 3)))+ 0.0;
                  }
                  if ((_QWORD)v108)
                  {
                    v35 = v30 + 1;
                    if (((*(_DWORD *)(v21[144] + 4 * ((v35 / v23[1498]) >> 5)) >> (v35 / v23[1498])) & 1) != 0)
                    {
                      v32 = v32 + (float)(*(float *)(v21[164] + 8) * *(float *)(v21[145] + 4 * v31));
                    }
                    else
                    {
                      v36 = (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v22, *(_QWORD *)(a1 + 56), *(float *)&v110);
                      v32 = v32 + (float)(*(float *)(v21[164] + 8) * v36);
                      *(_DWORD *)(v21[144] + 4 * ((v35 / v23[1498]) >> 5)) |= 1 << (v35 / v23[1498]);
                      *(float *)(v21[145] + 4 * v31) = v36;
                    }
                  }
                  if ((int)v23[1688] >= 2)
                  {
                    if (*((_QWORD *)&v108 + 1) && v30 >= 2)
                    {
                      v37 = *(float *)(v21[164] + 12);
                      v32 = v32
                          + (float)(v37
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v22, *(_QWORD *)(a1 + 56), *((float *)&v110 + 1)));
                    }
                    if ((_QWORD)v109 && v30 + 2 <= v103)
                    {
                      v38 = *(float *)(v21[164] + 16);
                      v32 = v32
                          + (float)(v38
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v22, *(_QWORD *)(a1 + 56), *((float *)&v110 + 2)));
                    }
                  }
                  v39 = v21[138] + 32 * v4;
                  v28 = *(_QWORD *)v39;
                  *(float *)(*(_QWORD *)v39 + v25 + 4) = (float)(v27 * v32) + *(float *)(*(_QWORD *)v39 + v25 + 4);
                  ++v26;
                  v25 += 12;
                }
                while (v26 < *(unsigned int *)(v39 + 16));
              }
            }
          }
          break;
        default:
          v82 = *(_QWORD **)(a1 + 120);
          v83 = v82[137];
          if (*(_DWORD *)(v83 + 1928) == 1)
          {
            v84 = *(_QWORD *)(a1 + 112);
            if (*(_DWORD *)(v84 + 6752))
            {
              v85 = v82[138];
              if (*(_DWORD *)(v85 + 32 * v4 + 16))
              {
                v86 = 0;
                v87 = 0;
                v88 = 1.0 - *(float *)(v82[169] + 4 * v4);
                v89 = *(_DWORD *)(*(_QWORD *)(v83 + 568) + 11548) - 1;
                v90 = *(_QWORD *)(v85 + 32 * v4);
                do
                {
                  v91 = *(_DWORD *)(v90 + v86);
                  if (*((_QWORD *)&__b + 1))
                    v92 = v91 < 1;
                  else
                    v92 = 1;
                  v93 = 0.0;
                  if (!v92)
                  {
                    v94 = *(float *)(v82[164] + 4);
                    v93 = (float)(v94
                                * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v83, *(_QWORD *)(a1 + 56), *((float *)&v109 + 3)))+ 0.0;
                  }
                  if ((_QWORD)v108)
                    v95 = v91 < v89;
                  else
                    v95 = 0;
                  if (v95)
                  {
                    v96 = *(float *)(v82[164] + 8);
                    v93 = v93
                        + (float)(v96
                                * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v83, *(_QWORD *)(a1 + 56), *(float *)&v110));
                  }
                  if (*(int *)(v84 + 6752) >= 2)
                  {
                    if (*((_QWORD *)&v108 + 1) && v91 >= 2)
                    {
                      v97 = *(float *)(v82[164] + 12);
                      v93 = v93
                          + (float)(v97
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v83, *(_QWORD *)(a1 + 56), *((float *)&v110 + 1)));
                    }
                    if ((_QWORD)v109 && v91 + 2 <= v89)
                    {
                      v98 = *(float *)(v82[164] + 16);
                      v93 = v93
                          + (float)(v98
                                  * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v83, *(_QWORD *)(a1 + 56), *((float *)&v110 + 2)));
                    }
                  }
                  v99 = v82[138] + 32 * v4;
                  v90 = *(_QWORD *)v99;
                  *(float *)(*(_QWORD *)v99 + v86 + 4) = (float)(v88 * v93) + *(float *)(*(_QWORD *)v99 + v86 + 4);
                  ++v87;
                  v86 += 12;
                }
                while (v87 < *(unsigned int *)(v99 + 16));
              }
            }
          }
          break;
      }
    }
    v100 = *(_QWORD *)(a1 + 136);
    v101 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 5564);
    updated = v106;
    if (*(_DWORD *)(*(_QWORD *)(v100 + 16) + 32 * v4 + 16) > v101)
    {
      updated = mfs_CostList_Select(v100, v4, 1, v101);
      UNICORN__mfs_CostList_Prune(*(_QWORD **)(a1 + 136), v4, *(_DWORD *)(*(_QWORD *)(a1 + 112) + 5564));
    }
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 11, (uint64_t)"costlist(%d)\n");
  }
  return updated;
}

uint64_t select_bet5_loadVoice(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5)
{
  uint64_t VAOBrokerString;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t AddRefCountedObject;
  uint64_t v15;
  uint64_t v16;
  uint64_t Object;
  _QWORD v19[2];
  _QWORD v20[2];
  uint64_t v21;
  char __s2[16];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  *(_OWORD *)__s2 = 0u;
  v23 = 0u;
  v19[1] = 0;
  v20[0] = a2;
  v20[1] = 1;
  v19[0] = a2;
  if (a5)
  {
    VAOBrokerString = betX_CreateVAOBrokerString(a2, 1, __s2, 0x100uLL, 0);
    v11 = v19;
    if ((VAOBrokerString & 0x80000000) != 0)
      return VAOBrokerString;
  }
  else
  {
    VAOBrokerString = betX_CreateRegularBrokerString(a2, 0, __s2, 0x100uLL);
    v11 = v20;
    if ((VAOBrokerString & 0x80000000) != 0)
      return VAOBrokerString;
  }
  if (a3)
  {
    v12 = cstdlib_strcmp(a3, __s2);
    v13 = *(_QWORD *)(a1 + 48);
    if (!v12)
    {
      Object = objc_GetObject(v13, (uint64_t)__s2, &v21);
      VAOBrokerString = Object;
      if (!a5 && (Object & 0x80000000) == 0)
      {
        objc_ReleaseObject(*(_QWORD *)(a1 + 48), (uint64_t)a3);
        v16 = *(_QWORD *)(v21 + 32);
        *(_QWORD *)a4 = v16;
        *(_DWORD *)(a4 + 8) = 117;
LABEL_18:
        paramc_ParamSetStr(*(_QWORD *)(a2 + 40), (uint64_t)"voicecomponentid", (char *)(v16 + 43362));
        paramc_ParamSetInt(*(_QWORD *)(a2 + 40), (uint64_t)"bet5nstatesperphoneme", *(_DWORD *)(v16 + 11912));
        return VAOBrokerString;
      }
      goto LABEL_12;
    }
    objc_ReleaseObject(v13, (uint64_t)a3);
  }
  AddRefCountedObject = objc_GetAddRefCountedObject(*(_QWORD *)(a1 + 48), (uint64_t)__s2, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))ObjcVoiceOpen, (void (*)(_QWORD, _QWORD, _OWORD *))ObjcVoiceClose, (uint64_t)v11, &v21);
  VAOBrokerString = AddRefCountedObject;
  if (a5 && (AddRefCountedObject & 0x80000000) != 0)
  {
    v15 = betX_CreateVAOBrokerString(a2, 1, __s2, 0x100uLL, 1);
    if ((v15 & 0x80000000) != 0)
      return v15;
    VAOBrokerString = objc_GetAddRefCountedObject(*(_QWORD *)(a1 + 48), (uint64_t)__s2, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))ObjcVoiceOpen, (void (*)(_QWORD, _QWORD, _OWORD *))ObjcVoiceClose, (uint64_t)v20, &v21);
  }
LABEL_12:
  if ((VAOBrokerString & 0x80000000) == 0)
  {
    v16 = *(_QWORD *)(v21 + 32);
    *(_QWORD *)a4 = v16;
    *(_DWORD *)(a4 + 8) = 117;
    if (!a5)
      goto LABEL_18;
  }
  return VAOBrokerString;
}

uint64_t ObjcVoiceOpen(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t *a5)
{
  int v9;
  uint64_t v10;
  uint64_t result;
  int v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int inited;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int Data;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  _OWORD __dst[2];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;
  void *__src;
  _BYTE *v75;
  _QWORD *v76;
  char __b[80];
  char __s1[4];
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v75 = 0;
  v76 = 0;
  v9 = *((_DWORD *)a5 + 2);
  v10 = *a5;
  v73 = 0;
  __src = 0;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v50 = 0u;
  memset(__dst, 0, sizeof(__dst));
  result = InitRsrcFunction(a1, a2, &__src);
  if ((result & 0x80000000) == 0)
  {
    cstdlib_memcpy(__dst, __src, 0x198uLL);
    v50 = *(_OWORD *)(v10 + 32);
    v12 = ssftriff_reader_ObjOpen(a1, a2, 2 * (v9 == 0), a3, "SEL5", 1031, (uint64_t *)&v76);
    if (v12 < 0)
    {
      return (v12 & 0x1FFFu) - 2065686528;
    }
    else
    {
      v13 = (char *)heap_Calloc(*((_QWORD **)&__dst[0] + 1), 1, 43432);
      v18 = (uint64_t)v13;
      if (v13)
      {
        *(_QWORD *)(a4 + 32) = v13;
        cstdlib_strcpy(v13, a3);
        cstdlib_strcpy((char *)(v18 + 14536), a3);
        cstdlib_memset((void *)(v18 + 16528), 255, 0x100uLL);
        cstdlib_memset((void *)(v18 + 17432), 255, 0x11CuLL);
        cstdlib_memset((void *)(v18 + 17760), 255, 0x20uLL);
        *(_DWORD *)(v18 + 16908) = 1;
        *(_BYTE *)(v18 + 43362) = 0;
        UNICORN__mfs_InitParam(v18 + 256);
        cstdlib_memset(__b, 0, 0x50uLL);
        *(_DWORD *)(v18 + 43428) = 0;
        if ((paramc_ParamGetStr(*((uint64_t *)&v50 + 1), (uint64_t)"bet5odlbnf", &v75) & 0x80000000) == 0
          && v75
          && *v75
          && cstdlib_strchr("yYtT1", (char)*v75))
        {
          *(_DWORD *)(v18 + 43428) = 1;
        }
        v20 = select_bet5_ParseRiff((uint64_t *)__dst, v18, (uint64_t)v76, 0, __b, 0, 0, v19);
        if ((v20 & 0x80000000) != 0)
        {
          Data = v20;
          cstdlib_strcpy(__s1, "");
          if (__b[0])
          {
            v44 = 1;
            v45 = __b;
            do
            {
              cstdlib_strcat(__s1, "/");
              cstdlib_strcat(__s1, v45);
              v45 = &__b[5 * v44++];
            }
            while (*v45);
          }
          log_OutPublic(v50, (uint64_t)"SELECT_BET5", 58003, (uint64_t)"%s%s%s%s%s%x", v40, v41, v42, v43, "file");
        }
        else if (*(_BYTE *)(v18 + 5071) && *(int *)(v18 + 388) > 0)
        {
          v25 = *(uint64_t **)(v18 + 16848);
          if (v25)
          {
            v26 = *v25;
            if (v26)
            {
              v27 = 0;
              v28 = 1;
              do
              {
                *(_QWORD *)(v18 + 8 * v27 + 2984) = v26;
                v27 = v28;
                v26 = *(_QWORD *)(*(_QWORD *)(v18 + 16848) + 8 * v28++);
              }
              while (v26);
            }
          }
          log_OutText(v50, (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"Memory mapped %s: %lu bytes in %lu chunks", v22, v23, v24, (uint64_t)a3);
          inited = UNICORN__mfs_InitData((uint64_t)__dst, (void *)(v18 + 11912), (_DWORD *)(v18 + 256));
          if ((inited & 0x80000000) != 0)
          {
            Data = inited;
          }
          else
          {
            Data = UNICORN__mfs_LoadData((uint64_t)__dst, (uint64_t)a3, *(_DWORD *)(v18 + 43428), (int32x2_t *)(v18 + 11912), (int32x2_t *)(v18 + 256));
            if ((Data & 0x80000000) == 0)
            {
              *(_WORD *)(v18 + 17962) = *(_DWORD *)(v18 + 11912);
              *(_DWORD *)(v18 + 17964) = *(_DWORD *)(v18 + 6240);
              *(_DWORD *)(v18 + 17134) = 33620481;
              *(_BYTE *)(v18 + 17187) = 1;
              *(_QWORD *)(v18 + 17139) = 0x101010101010101;
              *(_QWORD *)(v18 + 17147) = 0x101010101010101;
              *(_DWORD *)(v18 + 17157) = 16843009;
              *(_BYTE *)(v18 + 17161) = 1;
              *(_DWORD *)(v18 + 17163) = 16843009;
              *(_DWORD *)(v18 + 17166) = 16843009;
              *(_WORD *)(v18 + 17185) = -1;
              *(_BYTE *)(v18 + 17156) = 8;
              *(_BYTE *)(v18 + 17178) = 9;
              *(_QWORD *)(v18 + 17195) = 0x101010101010101;
              *(_WORD *)(v18 + 17208) = 257;
              *(_DWORD *)(v18 + 17204) = 16843009;
              *(_QWORD *)&v38 = 0x101010101010101;
              *((_QWORD *)&v38 + 1) = 0x101010101010101;
              *(_OWORD *)(v18 + 17313) = v38;
              *(_OWORD *)(v18 + 17301) = v38;
              *(_OWORD *)(v18 + 17285) = v38;
              *(_OWORD *)(v18 + 17269) = v38;
              *(_OWORD *)(v18 + 17253) = v38;
              v39 = *((_QWORD *)&v50 + 1);
              *(_DWORD *)__s1 = 0;
              if ((paramc_ParamGetUInt(*((uint64_t *)&v50 + 1), (uint64_t)"bet5underrunthreshold", (unsigned int *)__s1) & 0x80000000) == 0)
                *(_DWORD *)(v18 + 6180) = *(_DWORD *)__s1;
              if ((paramc_ParamGetUInt(v39, (uint64_t)"bet5earlyemissionmaxhypotheses", (unsigned int *)__s1) & 0x80000000) == 0)
                *(_DWORD *)(v18 + 6184) = *(_DWORD *)__s1;
              if ((paramc_ParamGetUInt(v39, (uint64_t)"bet5earlyemissionmaxphonambiguitywindow", (unsigned int *)__s1) & 0x80000000) == 0)
                *(_DWORD *)(v18 + 6188) = *(_DWORD *)__s1;
            }
          }
        }
        else
        {
          log_OutPublic(v50, (uint64_t)"SELECT_BET5", 71002, (uint64_t)"%s%s", v21, v22, v23, v24, "file");
          Data = -2065686524;
        }
      }
      else
      {
        log_OutPublic(v50, (uint64_t)"SELECT_BET5", 71000, 0, v14, v15, v16, v17, v48);
        Data = -2065686518;
      }
      if (v76)
      {
        ssftriff_reader_ObjClose(v76, v30, v31, v32, v33, v34, v35, v36);
        v76 = 0;
      }
      v46 = Data & 0x7FF01FFF;
      if ((Data & 0x7FF01FFF) == 0xA200014)
        result = 2229280772;
      else
        result = Data;
      if (v46 == 169869332)
        v47 = 0;
      else
        v47 = v18;
      if (v18)
      {
        if (v46 == 169869332)
        {
          heap_Free(*((_QWORD **)&__dst[0] + 1), v18);
          v47 = 0;
          result = 2229280772;
        }
      }
      *(_QWORD *)(a4 + 32) = v47;
    }
  }
  return result;
}

uint64_t ObjcVoiceClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  _WORD *v17;
  uint64_t *v18;
  int v19;
  uint64_t **v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  _QWORD *v39;

  v39 = 0;
  inited = InitRsrcFunction(a1, a2, &v39);
  v5 = inited;
  if (a3 && (inited & 0x80000000) == 0)
  {
    v6 = *(_QWORD *)(a3 + 32);
    v7 = *(_QWORD **)(v6 + 16848);
    if (v7 && *v7)
    {
      v8 = 2984;
      do
      {
        *(_QWORD *)(v6 + v8) = 0;
        v9 = *(_QWORD *)(*(_QWORD *)(v6 + 16848) + v8 - 2976);
        v8 += 8;
      }
      while (v9);
    }
    v10 = *(_QWORD *)(v6 + 17752);
    if (v10)
    {
      heap_Free((_QWORD *)v39[1], v10);
      *(_QWORD *)(v6 + 17752) = 0;
    }
    uselect_FreeRiffStringTable(v39, *(uint64_t **)(v6 + 5296));
    *(_QWORD *)(v6 + 5296) = 0;
    uselect_FreeRiffStringTable(v39, *(uint64_t **)(v6 + 17816));
    uselect_FreeRiffStringTable(v39, *(uint64_t **)(v6 + 17808));
    v11 = v39;
    v12 = *(uint64_t **)(v6 + 17720);
    v13 = *(uint64_t ***)(v6 + 17728);
    v14 = *(uint64_t **)(v6 + 17736);
    if (v12)
    {
      v15 = *v12;
      if (*v12)
      {
        v16 = 0;
        do
        {
          heap_Free((_QWORD *)v11[1], v15);
          v15 = v12[(unsigned __int16)++v16];
        }
        while (v15);
      }
      heap_Free((_QWORD *)v11[1], (uint64_t)v12);
    }
    v17 = (_WORD *)(v6 + 42784);
    if (v13)
    {
      v18 = *v13;
      if (*v13)
      {
        v19 = 0;
        v20 = v13;
        do
        {
          v21 = *v18;
          if (*v18)
          {
            v22 = 0;
            do
            {
              heap_Free((_QWORD *)v11[1], v21);
              ++v22;
              v18 = *v20;
              v21 = (*v20)[(unsigned __int16)v22];
            }
            while (v21);
          }
          heap_Free((_QWORD *)v11[1], (uint64_t)v18);
          v20 = &v13[(unsigned __int16)++v19];
          v18 = *v20;
        }
        while (*v20);
      }
      heap_Free((_QWORD *)v11[1], (uint64_t)v13);
    }
    if (v14)
    {
      v23 = *v14;
      if (*v14)
      {
        v24 = 0;
        do
        {
          heap_Free((_QWORD *)v11[1], v23);
          v23 = v14[(unsigned __int16)++v24];
        }
        while (v23);
      }
      heap_Free((_QWORD *)v11[1], (uint64_t)v14);
    }
    uselect_FreeRiffStringTable(v39, *(uint64_t **)(v6 + 16848));
    uselect_FreeRiffStringTable(v39, *(uint64_t **)(v6 + 16856));
    mfs_DeInitDataAndParam((uint64_t)v39, v6 + 11912, (_QWORD *)(v6 + 256));
    uselect_FreeRiffStringTable(v39, *(uint64_t **)(v6 + 42800));
    v31 = *(_QWORD *)(v6 + 42792);
    if (v31)
    {
      v32 = v39;
      if (*v17)
      {
        v33 = 0;
        v34 = 0;
        do
        {
          v35 = *(_QWORD *)(v6 + 42792);
          v36 = *(_QWORD *)(v35 + v33);
          if (v36)
          {
            heap_Free((_QWORD *)v32[1], v36);
            v35 = *(_QWORD *)(v6 + 42792);
          }
          uselect_FreeRiffStringTable(v32, *(uint64_t **)(v35 + v33 + 8));
          ++v34;
          v33 += 16;
        }
        while (v34 < (unsigned __int16)*v17);
        v31 = *(_QWORD *)(v6 + 42792);
      }
      heap_Free((_QWORD *)v32[1], v31);
      *(_QWORD *)(v6 + 42792) = 0;
      *v17 = 0;
    }
    if (*(_WORD *)(v6 + 43360))
    {
      v37 = 0;
      do
        ssftriff_reader_ReleaseChunkData(*(_QWORD **)(v6 + 42848 + 8 * v37++), v31, v25, v26, v27, v28, v29, v30);
      while (v37 < *(unsigned __int16 *)(v6 + 43360));
    }
    *(_WORD *)(v6 + 43360) = 0;
    *(_BYTE *)v6 = 0;
    heap_Free((_QWORD *)v39[1], v6);
  }
  return v5;
}

uint64_t select_bet5_GetUSVoice(uint64_t a1, int a2)
{
  uint64_t v3;

  if ((int)safeh_HandleCheck(a1, a2, 117, 43432) >= 0)
    v3 = a1;
  else
    v3 = 0;
  if (v3)
    return v3 + 14384;
  else
    return 0;
}

uint64_t select_bet5_GetVParam(uint64_t a1, int a2)
{
  uint64_t v3;

  if ((int)safeh_HandleCheck(a1, a2, 117, 43432) >= 0)
    v3 = a1;
  else
    v3 = 0;
  if (v3)
    return v3 + 256;
  else
    return 0;
}

uint64_t select_bet5_GetNNFeatexData(uint64_t a1, int a2)
{
  uint64_t v3;

  if ((int)safeh_HandleCheck(a1, a2, 117, 43432) >= 0)
    v3 = a1;
  else
    v3 = 0;
  if (v3)
    return v3 + 42784;
  else
    return 0;
}

uint64_t select_bet5_GetTransWeightRulesDiph(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v5;

  if ((int)safeh_HandleCheck(a1, a2, 117, 43432) >= 0)
    v5 = a1;
  else
    v5 = 0;
  if (a3 && v5)
  {
    *a3 = *(_DWORD *)(v5 + 42824);
    return *(_QWORD *)(v5 + 42816);
  }
  if (v5)
    return *(_QWORD *)(v5 + 42816);
  return 0;
}

uint64_t select_bet5_GetTransWeightRulesPhon(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v5;

  if ((int)safeh_HandleCheck(a1, a2, 117, 43432) >= 0)
    v5 = a1;
  else
    v5 = 0;
  if (a3 && v5)
  {
    *a3 = *(_DWORD *)(v5 + 42840);
    return *(_QWORD *)(v5 + 42832);
  }
  if (v5)
    return *(_QWORD *)(v5 + 42832);
  return 0;
}

uint64_t select_bet5_ParseRiff(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v13;
  uint64_t ChunkData;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unsigned int v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  uint64_t *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  int RiffStringTable;
  unsigned int v212;
  unsigned int v213;
  int v214;
  unsigned int v215;
  unsigned int v216;
  int v217;
  double v218;
  double v219;
  double v220;
  double v221;
  double v222;
  double v223;
  double v224;
  double v225;
  double v226;
  double v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  unint64_t v248;
  uint64_t v249;
  int v250;
  int *v251;
  int v252;
  int v253;
  uint64_t v254;
  uint64_t *v255;
  unint64_t v256;
  unint64_t i;
  int v258;
  BOOL v259;
  unsigned int v260;
  uint64_t v261;
  const void *v262;
  uint64_t v263;
  unsigned int v264;
  unsigned int v265;
  int v266;
  uint64_t v267;
  unint64_t v268;
  const void *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  char *v300;
  int v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t *v304;
  size_t v305;
  int v306;
  unsigned __int8 *v307;
  unsigned int v308;
  size_t v309;
  const void *v310;
  char *v311;
  int v312;
  unsigned int v313;
  char *v314;
  unsigned int v315;
  uint64_t v316;
  int StringW;
  _BYTE *v318;
  int MfsData;
  unsigned int v320;
  unsigned int v321;
  unsigned int v322;
  char *v323;
  double v324;
  double v325;
  double v326;
  double v327;
  double v328;
  double v329;
  char *v330;
  double v331;
  double v332;
  double v333;
  double v334;
  double v335;
  double v336;
  double v337;
  double v338;
  double v339;
  double v340;
  double v341;
  double v342;
  double v343;
  double v344;
  double v345;
  double v346;
  double v347;
  double v348;
  double v349;
  double v350;
  double v351;
  double v352;
  double v353;
  double v354;
  double v355;
  double v356;
  double v357;
  double v358;
  double v359;
  double v360;
  double v361;
  double v362;
  double v363;
  double v364;
  double v365;
  double v366;
  double v367;
  double v368;
  double v369;
  double v370;
  double v371;
  double v372;
  double v373;
  double v374;
  double v375;
  double v376;
  double v377;
  double v378;
  double v379;
  double v380;
  double v381;
  double v382;
  double v383;
  double v384;
  double v385;
  double v386;
  double v387;
  double v388;
  double v389;
  double v390;
  double v391;
  double v392;
  double v393;
  double v394;
  double v395;
  double v396;
  double v397;
  double v398;
  double v399;
  double v400;
  double v401;
  double v402;
  double v403;
  double v404;
  double v405;
  double v406;
  double v407;
  double v408;
  double v409;
  double v410;
  double v411;
  double v412;
  double v413;
  double v414;
  double v415;
  double v416;
  double v417;
  double v418;
  double v419;
  double v420;
  double v421;
  double v422;
  double v423;
  double v424;
  double v425;
  double v426;
  double v427;
  double v428;
  double v429;
  double v430;
  double v431;
  double v432;
  double v433;
  double v434;
  double v435;
  double v436;
  double v437;
  double v438;
  double v439;
  double v440;
  double v441;
  double v442;
  double v443;
  double v444;
  double v445;
  double v446;
  double v447;
  double v448;
  double v449;
  double v450;
  double v451;
  double v452;
  char *v453;
  char *v454;
  char *v455;
  char *v456;
  char *v457;
  char *v458;
  char *v459;
  double v460;
  double v461;
  double v462;
  double v463;
  double v464;
  const void *v465;
  unsigned int v466;
  uint64_t v467;
  _BYTE *v468;
  int v469;
  unint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  const void *v476;
  int v477;
  _DWORD *v478;
  unint64_t v479;
  unsigned int v480;
  uint64_t v481;
  int v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t *v485;
  unint64_t v486;
  int v487;
  char *v488;
  const void *v489;
  unint64_t v490;
  int v491;
  uint64_t v492;
  unint64_t v493;
  int v494;
  unsigned int v495;
  void *v496;
  int *v497;
  int v498;
  char *v499;
  uint64_t v500;
  unsigned int v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t *v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  char *v509;
  _QWORD *v510;
  uint64_t v511;
  _QWORD *v512;
  size_t v513;
  void *v514;
  unint64_t v515;
  int v516;
  void *v517;
  uint64_t v518;
  int v519;
  const void *v520;
  unsigned __int16 v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  int v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  int v529;
  char *v531;
  uint64_t v532;
  _DWORD *v533;
  int v534;
  uint64_t v535;
  unsigned __int16 v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  int v540;
  int v541;
  int v542;
  unsigned int v543;
  int v544;
  unint64_t v545;
  int v546;
  int *v547;
  uint64_t v548;
  uint64_t v549;
  _QWORD *v550;
  unsigned int v551;
  uint64_t v552;
  unint64_t v553;
  int v554;
  const void *v555;
  unint64_t v556;
  int v557;
  int v558;
  int Position;
  uint64_t v560;
  unint64_t v561;
  int v562;
  uint64_t v563;
  unint64_t v564;
  int v565;
  unint64_t v566;
  int v567;
  unint64_t v568;
  int v569;
  unint64_t v570;
  int v571;
  unint64_t v572;
  unint64_t v573;
  int v574;
  int v575;
  unint64_t v576;
  int v577;
  unint64_t v578;
  int v579;
  unint64_t v580;
  int v581;
  unint64_t v582;
  int v583;
  unint64_t v584;
  int v585;
  char *v586;
  char *v587;
  char *v588;
  uint64_t v590;
  _QWORD *v591;
  int *v592;
  int *v593;
  _QWORD *v594;
  _QWORD *v595;
  _QWORD *v596;
  _QWORD *v597;
  _QWORD *v598;
  _QWORD *v599;
  _QWORD *v600;
  _QWORD *v601;
  _QWORD *v602;
  _QWORD *v603;
  _QWORD *v604;
  _QWORD *v605;
  _QWORD *v606;
  _QWORD *v607;
  _QWORD *v608;
  _QWORD *v609;
  uint64_t *v610;
  uint64_t *v611;
  _QWORD *v612;
  uint64_t *v613;
  uint64_t *v614;
  uint64_t *v615;
  void *v616;
  _QWORD *v617;
  _BYTE *v618;
  _QWORD *v619;
  _BYTE *v620;
  _QWORD *v621;
  _QWORD *v622;
  _BYTE *v623;
  _QWORD *v624;
  _BYTE *v625;
  void *v626;
  _BYTE *v627;
  void *v628;
  uint64_t *v629;
  uint64_t *v630;
  _BYTE *v631;
  uint64_t *v632;
  uint64_t *v633;
  unsigned __int16 *v634;
  unsigned int v635;
  char *v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  unsigned __int8 *v640;
  char *__s;
  unsigned int v643;
  _DWORD *v644;
  _DWORD *v645;
  char *__s1;
  char *__dst;
  int v649[2];
  char *v650;
  unsigned int v651;
  char __src[4];
  char v653;
  int v654;
  char v655[8];
  void *v656[128];
  char __s2[8];
  uint64_t v658;

  v643 = a7;
  v8 = a6;
  v13 = a1;
  v635 = 0;
  v658 = *MEMORY[0x24BDAC8D0];
  v634 = (unsigned __int16 *)(a2 + 42784);
  v640 = (unsigned __int8 *)(a2 + 16880);
  v637 = a2 + 42844;
  v654 = 0;
  v653 = 0;
  *(_DWORD *)__src = 0;
  __dst = (char *)&a5[5 * a4];
  v616 = (void *)(a2 + 5036);
  v626 = (void *)(a2 + 16884);
  v644 = (_DWORD *)(a2 + 11864);
  v645 = (_DWORD *)(a2 + 11824);
  v594 = (_QWORD *)(a2 + 8032);
  v595 = (_QWORD *)(a2 + 8632);
  v596 = (_QWORD *)(a2 + 8512);
  v597 = (_QWORD *)(a2 + 8392);
  v598 = (_QWORD *)(a2 + 9832);
  v599 = (_QWORD *)(a2 + 10552);
  v600 = (_QWORD *)(a2 + 10192);
  v601 = (_QWORD *)(a2 + 10432);
  v602 = (_QWORD *)(a2 + 9712);
  v603 = (_QWORD *)(a2 + 9592);
  v604 = (_QWORD *)(a2 + 9472);
  v605 = (_QWORD *)(a2 + 9352);
  v606 = (_QWORD *)(a2 + 9256);
  v607 = (_QWORD *)(a2 + 9232);
  v608 = (_QWORD *)(a2 + 9112);
  v609 = (_QWORD *)(a2 + 8056);
  v612 = (_QWORD *)(a2 + 10072);
  v617 = (_QWORD *)(a2 + 8272);
  v619 = (_QWORD *)(a2 + 7312);
  v622 = (_QWORD *)(a2 + 8872);
  v632 = (uint64_t *)(a2 + 5296);
  v636 = (char *)(a2 + 43362);
  v629 = (uint64_t *)(a2 + 42800);
  v628 = (void *)(a2 + 42808);
  v621 = (_QWORD *)(a2 + 42832);
  v624 = (_QWORD *)(a2 + 42816);
  v630 = (uint64_t *)(a2 + 17816);
  v633 = (uint64_t *)(a2 + 17808);
  v610 = (uint64_t *)(a2 + 16856);
  v611 = (uint64_t *)(a2 + 16848);
  v615 = (uint64_t *)(a2 + 17720);
  v614 = (uint64_t *)(a2 + 17728);
  v613 = (uint64_t *)(a2 + 17736);
  v618 = (_BYTE *)(a2 + 42656);
  v620 = (_BYTE *)(a2 + 16784);
  v623 = (_BYTE *)(a2 + 15757);
  v625 = (_BYTE *)(a2 + 16014);
  v627 = (_BYTE *)(a2 + 15500);
  v631 = (_BYTE *)(a2 + 15243);
  v639 = a2 + 11880;
  v638 = a2 + 11888;
  __s1 = (char *)(a5 + 5);
  __s = (char *)(a2 + 14986);
  do
  {
    LODWORD(ChunkData) = ssftriff_reader_OpenChunk(a3, (__int32 *)__src, (unsigned int *)&v654, 0, (uint64_t)a5, a6, a7, a8);
    if ((ChunkData & 0x80000000) != 0)
      break;
    cstdlib_strcpy(__dst, __src);
    if (a4 == 1)
    {
      if (!cstdlib_strcmp(__src, "VSTG"))
      {
        LODWORD(v650) = 0;
        *(_QWORD *)v655 = 0;
        if (v8)
        {
          *(_QWORD *)v655 = v8 + ssftriff_reader_GetPosition(a3) - v643;
        }
        else
        {
          ChunkData = ssftriff_reader_GetChunkData(a3, v654, v655, v142, v143, v144, v145, v146);
          if ((ChunkData & 0x80000000) != 0)
            return ChunkData;
        }
        LOBYTE(v656[0]) = 0;
        __s2[0] = 0;
        v215 = v654;
        if (v654)
        {
          v216 = 0;
          do
          {
            LODWORD(v650) = 1024;
            LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v655, v215, v216, __s2, (unsigned int *)&v650);
            if ((ChunkData & 0x80000000) == 0 && v216 < v654)
            {
              v216 += v650;
              LODWORD(v650) = 1024;
              LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v655, v654, v216, v656, (unsigned int *)&v650);
            }
            if ((ChunkData & 0x80000000) != 0)
              break;
            v217 = (int)v650;
            if (!cstdlib_strcmp(__s2, "MEANDURINSECS"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v218 = v218;
              *v645 = LODWORD(v218);
            }
            if (!cstdlib_strcmp(__s2, "STDEVDURINSECS"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v219 = v219;
              *(_DWORD *)(a2 + 11828) = LODWORD(v219);
            }
            if (!cstdlib_strcmp(__s2, "MEANDURINSECSLOG"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v220 = v220;
              *(_DWORD *)(a2 + 11832) = LODWORD(v220);
            }
            if (!cstdlib_strcmp(__s2, "STDEVDURINSECSLOG"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v221 = v221;
              *(_DWORD *)(a2 + 11836) = LODWORD(v221);
            }
            if (!cstdlib_strcmp(__s2, "MEANLEFTPITCH"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v222 = v222;
              *(_DWORD *)(a2 + 11840) = LODWORD(v222);
            }
            if (!cstdlib_strcmp(__s2, "STDEVLEFTPITCH"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v223 = v223;
              *(_DWORD *)(a2 + 11844) = LODWORD(v223);
            }
            if (!cstdlib_strcmp(__s2, "MEANRIGHTPITCH"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v224 = v224;
              *(_DWORD *)(a2 + 11848) = LODWORD(v224);
            }
            if (!cstdlib_strcmp(__s2, "STDEVRIGHTPITCH"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v225 = v225;
              *(_DWORD *)(a2 + 11852) = LODWORD(v225);
            }
            if (!cstdlib_strcmp(__s2, "MEANSLOPEPITCH"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v226 = v226;
              *(_DWORD *)(a2 + 11856) = LODWORD(v226);
            }
            if (!cstdlib_strcmp(__s2, "STDEVSLOPEPITCH"))
            {
              cstdlib_atof((unsigned __int8 *)v656);
              *(float *)&v227 = v227;
              *(_DWORD *)(a2 + 11860) = LODWORD(v227);
            }
            v216 += v217;
            v215 = v654;
          }
          while (v216 < v654);
        }
        goto LABEL_818;
      }
      if (!cstdlib_strcmp(__src, "VSTC"))
      {
        *(_QWORD *)__s2 = 0;
        if (v8)
        {
          *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
        }
        else
        {
          ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v147, v148, v149, v150, v151);
          if ((ChunkData & 0x80000000) != 0)
            return ChunkData;
        }
        if (v654 < 4)
          LODWORD(ChunkData) = -2065686524;
        if ((ChunkData & 0x80000000) == 0)
        {
          cstdlib_memcpy(v644, *(const void **)__s2, 4uLL);
          *(_QWORD *)__s2 += 4;
          LODWORD(ChunkData) = -2065686524;
          if (v654 >= 4 * (unint64_t)(*v644 + 1))
          {
            LODWORD(ChunkData) = StatValues_AllocMemoryForClusterCount((uint64_t)v13, (uint64_t)v645);
            if ((ChunkData & 0x80000000) == 0)
            {
              if (*v644)
              {
                v267 = 0;
                v268 = 0;
                v269 = *(const void **)__s2;
                do
                {
                  cstdlib_memcpy((void *)(*(_QWORD *)(a2 + 11872) + v267), v269, 4uLL);
                  v269 = (const void *)(*(_QWORD *)__s2 + 4);
                  *(_QWORD *)__s2 += 4;
                  ++v268;
                  v267 += 4;
                }
                while (v268 < *(unsigned int *)(a2 + 11864));
              }
            }
          }
        }
        goto LABEL_818;
      }
      if (!cstdlib_strcmp(__src, "VSC1") || !cstdlib_strcmp(__src, "VSC2"))
      {
        *(_QWORD *)__s2 = 0;
        if (v8)
        {
          *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
        }
        else
        {
          ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v152, v153, v154, v155, v156);
          if ((ChunkData & 0x80000000) != 0)
            return ChunkData;
        }
        v249 = *v644;
        if ((_DWORD)v249)
        {
          v250 = 0;
          v251 = *(int **)(a2 + 11872);
          do
          {
            v252 = *v251++;
            v250 += 4 * v252 + 4;
            --v249;
          }
          while (v249);
        }
        else
        {
          v250 = 0;
        }
        if (v654 != v250)
          LODWORD(ChunkData) = -2065686524;
        if ((ChunkData & 0x80000000) == 0)
        {
          v253 = cstdlib_strcmp(__src, "VSC1");
          v254 = v253 ? 11888 : 11880;
          v255 = (uint64_t *)(v253 ? v638 : v639);
          LODWORD(ChunkData) = StatValues_AllocMemoryForClusterStatValues((uint64_t)v13, v255, *(_DWORD *)(a2 + 11864), *(_QWORD *)(a2 + 11872));
          if ((ChunkData & 0x80000000) == 0)
          {
            v256 = *v644;
            if ((_DWORD)v256)
            {
              for (i = 0; i < v256; ++i)
              {
                v258 = *(_DWORD *)(*(_QWORD *)(a2 + 11872) + 4 * i);
                v259 = __CFADD__(v258, 1);
                v260 = v258 + 1;
                if (!v259)
                {
                  v261 = 0;
                  v262 = *(const void **)__s2;
                  v263 = 4 * v260;
                  do
                  {
                    cstdlib_memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a2 + v254) + 8 * i) + v261), v262, 4uLL);
                    v262 = (const void *)(*(_QWORD *)__s2 + 4);
                    *(_QWORD *)__s2 += 4;
                    v261 += 4;
                  }
                  while (v263 != v261);
                  v256 = *v644;
                  v8 = a6;
                  v13 = a1;
                }
              }
            }
          }
        }
        goto LABEL_818;
      }
      if (!cstdlib_strcmp(a5, "FEEX"))
      {
        if (!cstdlib_strcmp(__src, "VCAT"))
        {
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
          }
          else
          {
            v481 = ssftriff_reader_GetChunkData(a3, v654, __s2, v270, v271, v272, v273, v274);
            if ((v481 & 0x80000000) != 0)
              return v481;
          }
LABEL_756:
          v207 = v13;
          v208 = a2;
          v209 = a3;
          v210 = 2;
LABEL_83:
          RiffStringTable = select_bet5_ParseRiff(v207, v208, v209, v210, a5, 0, 0);
          goto LABEL_748;
        }
        if (!cstdlib_strcmp(__src, "VBOP"))
        {
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            v489 = (const void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
            *(_QWORD *)__s2 = v489;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v275, v276, v277, v278, v279);
            if ((ChunkData & 0x80000000) != 0)
              return ChunkData;
            v489 = *(const void **)__s2;
          }
          if (v654 >= 0xF8)
            v513 = 248;
          else
            v513 = v654;
          v514 = v626;
LABEL_792:
          cstdlib_memcpy(v514, v489, v513);
          goto LABEL_818;
        }
        if (!cstdlib_strcmp(__src, "PRE3"))
        {
          LOWORD(v656[0]) = 0;
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v280, v281, v282, v283, v284);
            if ((ChunkData & 0x80000000) != 0)
              return ChunkData;
          }
          if (v654 >= 2)
          {
            v521 = 0;
            do
            {
              cstdlib_memcpy(v656, (const void *)(*(_QWORD *)__s2 + 2 * v521), 2uLL);
              if (LOWORD(v656[0]) < 0x47u)
                *(_DWORD *)(a2 + 4 * LOWORD(v656[0]) + 17432) = 1;
              else
                log_OutText(v13[4], (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"Unknown preselection feature: %u for %s", v522, v523, v524, LOWORD(v656[0]));
              ++v521;
            }
            while (v654 >> 1 > v521);
          }
          goto LABEL_818;
        }
        if (!cstdlib_strcmp(__src, "TRA3"))
        {
          LOWORD(v656[0]) = 0;
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v285, v286, v287, v288, v289);
            if ((ChunkData & 0x80000000) != 0)
              return ChunkData;
          }
          if (v654 >= 2)
          {
            v536 = 0;
            do
            {
              cstdlib_memcpy(v656, (const void *)(*(_QWORD *)__s2 + 2 * v536), 2uLL);
              if (LOWORD(v656[0]) < 8u)
                *(_DWORD *)(a2 + 4 * LOWORD(v656[0]) + 17760) = 1;
              else
                log_OutText(v13[4], (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"Unknown transition feature: %u for %s", v537, v538, v539, LOWORD(v656[0]));
              ++v536;
            }
            while (v654 >> 1 > v536);
          }
          goto LABEL_818;
        }
        if (!cstdlib_strcmp(__src, "TRAF"))
        {
          LODWORD(v656[0]) = 0;
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            v520 = (const void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
            *(_QWORD *)__s2 = v520;
          }
          else
          {
            v481 = ssftriff_reader_GetChunkData(a3, v654, __s2, v290, v291, v292, v293, v294);
            if ((v481 & 0x80000000) != 0)
              return v481;
            v520 = *(const void **)__s2;
          }
          cstdlib_memcpy(v656, v520, 4uLL);
          *((_WORD *)v640 + 432) = v656[0];
          ssftriff_reader_Seek(a3, 4u, 1);
          v552 = heap_Calloc((_QWORD *)v13[1], 12, *((unsigned __int16 *)v640 + 432));
          *(_QWORD *)(a2 + 17752) = v552;
          if (!v552)
            return 2229280778;
LABEL_871:
          v469 = select_bet5_ParseRiff(v13, a2, a3, 2, a5, 0, 0);
LABEL_712:
          LODWORD(ChunkData) = v469;
          goto LABEL_818;
        }
        if (!cstdlib_strcmp(__src, "PHM3"))
        {
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            v489 = (const void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
            *(_QWORD *)__s2 = v489;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v295, v296, v297, v298, v299);
            if ((ChunkData & 0x80000000) != 0)
              return ChunkData;
            v489 = *(const void **)__s2;
          }
          if (v654 >= 0x100)
            v513 = 256;
          else
            v513 = v654;
          v514 = v616;
          goto LABEL_792;
        }
        if (!cstdlib_strcmp(__src, "CTXR"))
          goto LABEL_756;
        if (!cstdlib_strcmp(__src, "NNFE"))
          goto LABEL_871;
        goto LABEL_815;
      }
      if (cstdlib_strcmp(a5, "STM3"))
      {
LABEL_815:
        cstdlib_strcpy(__s2, "");
        v525 = 0;
        do
        {
          cstdlib_strcat(__s2, "/");
          cstdlib_strcat(__s2, &a5[5 * (unsigned __int16)v525++]);
        }
        while (a4 >= (unsigned __int16)v525);
        log_OutText(v13[4], (uint64_t)"SELECT_BET5", 3, 0, (uint64_t)"Unknown data: %s for %s", v526, v527, v528, (uint64_t)__s2);
        goto LABEL_818;
      }
      *(_DWORD *)v655 = 0;
      v157 = *(int *)(a2 + 388);
      if (cstdlib_strcmp(__src, "STC3"))
      {
        if (cstdlib_strcmp(__src, "TRE3"))
        {
          if (cstdlib_strcmp(__src, "PDF3"))
          {
            if (cstdlib_strcmp(__src, "WIN3"))
            {
              if (cstdlib_strcmp(__src, "STC3") && cstdlib_strcmp(__src, "STC4"))
              {
                if (cstdlib_strcmp(__src, "STW4"))
                {
                  if (cstdlib_strcmp(__src, "UNP4"))
                  {
                    if (cstdlib_strcmp(__src, "PCI4"))
                    {
                      if (cstdlib_strcmp(__src, "JCI4"))
                      {
                        if (cstdlib_strcmp(__src, "JCS4"))
                        {
                          if (cstdlib_strcmp(__src, "JTYP"))
                          {
                            if (cstdlib_strcmp(__src, "JFSM"))
                            {
                              if (cstdlib_strcmp(__src, "FSMR"))
                              {
                                if (cstdlib_strcmp(__src, "JCBK"))
                                  goto LABEL_226;
                                v183 = v654;
                                v184 = a2;
                                v185 = a3;
                                v186 = 24;
                              }
                              else
                              {
                                v183 = v654;
                                v184 = a2;
                                v185 = a3;
                                v186 = 16;
                              }
                            }
                            else
                            {
                              v183 = v654;
                              v184 = a2;
                              v185 = a3;
                              v186 = 9;
                            }
                          }
                          else
                          {
                            v183 = v654;
                            v184 = a2;
                            v185 = a3;
                            v186 = 14;
                          }
                        }
                        else
                        {
                          v183 = v654;
                          v184 = a2;
                          v185 = a3;
                          v186 = 7;
                        }
                      }
                      else
                      {
                        v183 = v654;
                        v184 = a2;
                        v185 = a3;
                        v186 = 6;
                      }
                      MfsData = select_bet5_LoadMfsData(v184, v185, v186, v157, v183, v8, v643, 0);
                    }
                    else
                    {
                      MfsData = select_bet5_ParseRiff(v13, a2, a3, 2, a5, v8, v643);
                    }
                    goto LABEL_812;
                  }
                  if (v8)
                  {
                    v558 = v654;
                    Position = ssftriff_reader_GetPosition(a3);
                    LODWORD(ChunkData) = 0;
                    v560 = a2 + 24 * (int)v157;
                    *(_QWORD *)(v560 + 7432) = v8 + Position - v643;
                    *(_DWORD *)(v560 + 7440) = v558;
                  }
                  else
                  {
                    LODWORD(ChunkData) = -2065686527;
                  }
                }
                else
                {
                  *(_QWORD *)__s2 = 0;
                  if (v8)
                  {
                    v555 = (const void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
                    *(_QWORD *)__s2 = v555;
                  }
                  else
                  {
                    ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v178, v179, v180, v181, v182);
                    if ((ChunkData & 0x80000000) != 0)
                      return ChunkData;
                    v555 = *(const void **)__s2;
                  }
                  v563 = a2 + 4 * v157;
                  cstdlib_memcpy((void *)(v563 + 5700), v555, 4uLL);
                  *(_QWORD *)__s2 += 4;
                  cstdlib_memcpy((void *)(v563 + 5720), *(const void **)__s2, 4uLL);
                }
              }
              else
              {
                LODWORD(v650) = 0;
                v656[0] = 0;
                if (v8)
                {
                  v517 = (void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
                  v656[0] = v517;
                }
                else
                {
                  ChunkData = ssftriff_reader_GetChunkData(a3, v654, v656, v173, v174, v175, v176, v177);
                  if ((ChunkData & 0x80000000) != 0)
                    return ChunkData;
                  v517 = v656[0];
                }
                v547 = (int *)(a2 + 4 * v157);
                cstdlib_memcpy(v547 + 1420, v517, 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1435, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1446, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1576, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1566, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1571, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1584, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                cstdlib_memcpy(v547 + 1589, v656[0], 4uLL);
                v656[0] = (char *)v656[0] + 4;
                v593 = v547 + 115;
                if (v547[115] >= 1)
                {
                  v548 = v157;
                  v549 = 0;
                  v550 = (_QWORD *)(a2 + 8 * v548 + 1464);
                  v551 = *(_DWORD *)v655;
                  do
                  {
                    __s2[0] = 0;
                    LODWORD(v650) = 256;
                    LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v656[0], v654, v551, __s2, (unsigned int *)&v650);
                    if ((ChunkData & 0x80000000) != 0)
                      break;
                    *(_QWORD *)(*v550 + 8 * v549) = UNICORN__heap_StrDup((_QWORD *)v13[1], __s2);
                    if (!*(_QWORD *)(*v550 + 8 * v549))
                      goto LABEL_867;
                    v551 = *(_DWORD *)v655 + (_DWORD)v650;
                    *(_DWORD *)v655 += (_DWORD)v650;
                    ++v549;
                  }
                  while (v549 < *v593);
                }
              }
              goto LABEL_813;
            }
            v518 = a2 + 256 + 4 * v157;
            v519 = *(_DWORD *)(v518 + 224);
            v492 = a2 + 256 + 120 * (int)v157 + 24 * v519 + 2008;
            *(_DWORD *)(v518 + 224) = v519 + 1;
          }
          else
          {
            v656[0] = 0;
            if (v8)
            {
              v496 = (void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
              v656[0] = v496;
            }
            else
            {
              v481 = ssftriff_reader_GetChunkData(a3, v654, v656, v168, v169, v170, v171, v172);
              if ((v481 & 0x80000000) != 0)
                return v481;
              v496 = v656[0];
            }
            *(_DWORD *)v655 = 256;
            LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v496, v654, 0, __s2, (unsigned int *)v655);
            if ((ChunkData & 0x80000000) != 0)
            {
              v492 = 0;
            }
            else
            {
              v531 = UNICORN__heap_StrDup((_QWORD *)v13[1], __s2);
              v532 = a2 + 256 + 4 * v157;
              v535 = *(int *)(v532 + 244);
              v533 = (_DWORD *)(v532 + 244);
              v534 = v535;
              *(_QWORD *)(a2 + 256 + 40 * (int)v157 + 8 * v535 + 728) = v531;
              if ((v655[0] & 3) != 0)
                *(_DWORD *)v655 -= *(_DWORD *)v655 | 0xFFFFFFFC;
              v492 = a2 + 120 * (int)v157 + 24 * v534 + 1664;
              *v533 = v534 + 1;
            }
          }
        }
        else
        {
          v492 = a2 + 24 * (int)v157 + 1544;
        }
        v312 = 1;
        if ((ChunkData & 0x80000000) != 0 || !v492)
          goto LABEL_814;
        *(_QWORD *)__s2 = 0;
        if (v8)
        {
          v540 = ssftriff_reader_GetPosition(a3);
          v541 = *(_DWORD *)v655;
          *(_QWORD *)(v492 + 8) = v8 + v540 - v643 + *(unsigned int *)v655;
          v542 = v654 - v541;
        }
        else
        {
          v543 = *(unsigned __int16 *)(v637 + 516);
          LODWORD(ChunkData) = -2065686524;
          if (v543 > 0x3F)
            goto LABEL_813;
          if (*(_DWORD *)v655)
          {
            ssftriff_reader_Seek(a3, *(unsigned int *)v655, 1);
            v543 = *(unsigned __int16 *)(v637 + 516);
          }
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v543 + 42848), __s2, v163, v164, v165, v166, v167);
          if ((ChunkData & 0x80000000) != 0)
            goto LABEL_813;
          ++*(_WORD *)(v637 + 516);
          v544 = v654;
          *(_DWORD *)v637 += v654;
          *(_QWORD *)(v492 + 8) = *(_QWORD *)__s2;
          v542 = v544 - *(_DWORD *)v655;
        }
        *(_DWORD *)(v492 + 16) = v542;
        goto LABEL_813;
      }
      LODWORD(v650) = 0;
      v656[0] = 0;
      if (v8)
      {
        v488 = (char *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
        v656[0] = v488;
      }
      else
      {
        ChunkData = ssftriff_reader_GetChunkData(a3, v654, v656, v158, v159, v160, v161, v162);
        if ((ChunkData & 0x80000000) != 0)
          return ChunkData;
        v488 = (char *)v656[0];
      }
      v497 = (int *)(a2 + 4 * v157);
      cstdlib_memcpy(v497 + 110, &v488[*(unsigned int *)v655], 4uLL);
      *(_DWORD *)v655 += 4;
      v592 = v497 + 115;
      cstdlib_memcpy(v497 + 115, (char *)v656[0] + *(unsigned int *)v655, 4uLL);
      v498 = *(_DWORD *)v655;
      *(_DWORD *)v655 += 4;
      v499 = (char *)v656[0];
      v497[351] = *((_BYTE *)v656[0] + *(unsigned int *)v655) != 0;
      v500 = (v498 + 5);
      *(_DWORD *)v655 = v500;
      cstdlib_memcpy(v497 + 346, &v499[v500], 4uLL);
      v501 = *(_DWORD *)v655 + 4;
      *(_DWORD *)v655 += 4;
      v502 = v497[115];
      if ((int)v502 >= 1)
      {
        v503 = heap_Calloc((_QWORD *)v13[1], v502, 8);
        v504 = v157;
        v505 = v13;
        v590 = v504;
        v506 = a2 + 8 * v504;
        *(_QWORD *)(v506 + 1504) = v503;
        if (!v503)
          LODWORD(ChunkData) = -2065686518;
        if ((ChunkData & 0x80000000) == 0)
        {
          v507 = heap_Calloc((_QWORD *)v505[1], *v592, 8);
          *(_QWORD *)(v506 + 1424) = v507;
          if (v507)
          {
            v508 = heap_Calloc((_QWORD *)v505[1], *v592, 8);
            *(_QWORD *)(a2 + 8 * v590 + 1464) = v508;
            v13 = v505;
            if (!v508)
              goto LABEL_867;
            v501 = *(_DWORD *)v655;
            v157 = v590;
            goto LABEL_776;
          }
          LODWORD(ChunkData) = -2065686518;
        }
        v13 = v505;
        goto LABEL_813;
      }
LABEL_776:
      __s2[0] = 0;
      LODWORD(v650) = 256;
      LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v656[0], v654, v501, __s2, (unsigned int *)&v650);
      if ((ChunkData & 0x80000000) == 0)
      {
        v509 = UNICORN__heap_StrDup((_QWORD *)v13[1], __s2);
        v510 = (_QWORD *)(a2 + 8 * v157);
        v510[50] = v509;
        *(_DWORD *)v655 += (_DWORD)v650;
        if (!v509)
          goto LABEL_867;
        if (*v592 >= 1)
        {
          v511 = 0;
          v512 = v510 + 188;
          v591 = v510 + 178;
          while (1)
          {
            __s2[0] = 0;
            LODWORD(v650) = 256;
            MfsData = ssftriff_reader_ReadStringZ(a3, (uint64_t)v656[0], v654, *(unsigned int *)v655, __s2, (unsigned int *)&v650);
            if (MfsData < 0)
              goto LABEL_812;
            *(_QWORD *)(*v512 + 8 * v511) = UNICORN__heap_StrDup((_QWORD *)v13[1], __s2);
            if (!*(_QWORD *)(*v512 + 8 * v511))
              goto LABEL_867;
            *(_DWORD *)v655 += (_DWORD)v650;
            __s2[0] = 0;
            LODWORD(v650) = 256;
            LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v656[0], v654, *(unsigned int *)v655, __s2, (unsigned int *)&v650);
            if ((ChunkData & 0x80000000) == 0)
            {
              *(_QWORD *)(*v591 + 8 * v511) = UNICORN__heap_StrDup((_QWORD *)v13[1], __s2);
              if (!*(_QWORD *)(*v591 + 8 * v511))
                goto LABEL_867;
              *(_DWORD *)v655 += (_DWORD)v650;
              if (++v511 < *v592)
                continue;
            }
            goto LABEL_813;
          }
        }
      }
      goto LABEL_813;
    }
    if (a4)
    {
      if (!cstdlib_strcmp(a5, "FEEX") && !cstdlib_strcmp(__s1, "VCAT"))
      {
        *(_QWORD *)__s2 = 0;
        if (v8)
        {
          *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
        }
        else
        {
          ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v187, v188, v189, v190, v191);
          if ((ChunkData & 0x80000000) != 0)
            return ChunkData;
        }
        if (!cstdlib_strcmp(__src, "ALPH"))
        {
          LODWORD(v656[0]) = 257;
          LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v654, 0, __s, (unsigned int *)v656);
          if ((ChunkData & 0x80000000) == 0)
          {
            *(_WORD *)v640 = 255;
            if (cstdlib_strlen(__s))
            {
              v305 = 0;
              v306 = 0;
              do
              {
                v307 = (unsigned __int8 *)(a2 + v305 + 14986);
                v308 = *v307;
                if (v308 < *v640)
                {
                  *v640 = v308;
                  v308 = *v307;
                }
                if (v308 > v640[1])
                {
                  v640[1] = v308;
                  v308 = *v307;
                }
                *(_BYTE *)(a2 + v308 + 16528) = v306;
                v305 = (v306 + 1);
                v309 = cstdlib_strlen(__s);
                v306 = v305;
              }
              while (v309 > v305);
            }
          }
          goto LABEL_813;
        }
        if (cstdlib_strcmp(__src, "VOIC"))
        {
          if (cstdlib_strcmp(__src, "COVO"))
          {
            if (cstdlib_strcmp(__src, "SAFE"))
            {
              if (cstdlib_strcmp(__src, "PLOS"))
              {
                if (cstdlib_strcmp(__src, "DIFF"))
                {
                  if (cstdlib_strcmp(__src, "NUCL"))
                  {
                    if (cstdlib_strcmp(__src, "GENF"))
                    {
                      if (cstdlib_strcmp(__src, "TAGA"))
                      {
                        if (cstdlib_strcmp(__src, "BTOA"))
                          goto LABEL_226;
                        v300 = *(char **)__s2;
                        v301 = v654;
                        v302 = (uint64_t)v13;
                        v303 = a3;
                        v304 = v610;
                      }
                      else
                      {
                        v300 = *(char **)__s2;
                        v301 = v654;
                        v302 = (uint64_t)v13;
                        v303 = a3;
                        v304 = v611;
                      }
                      goto LABEL_716;
                    }
                    MfsData = select_bet5_LoadRiffGenericFeatureMap((uint64_t)v13, a3, *(char **)__s2, v654, v615, v614, v613);
LABEL_812:
                    LODWORD(ChunkData) = MfsData;
                    goto LABEL_813;
                  }
                  LODWORD(v656[0]) = 128;
                  v465 = *(const void **)__s2;
                  v466 = v654;
                  v467 = a3;
                  v468 = v618;
                }
                else
                {
                  LODWORD(v656[0]) = 64;
                  v465 = *(const void **)__s2;
                  v466 = v654;
                  v467 = a3;
                  v468 = v620;
                }
              }
              else
              {
                LODWORD(v656[0]) = 257;
                v465 = *(const void **)__s2;
                v466 = v654;
                v467 = a3;
                v468 = v623;
              }
            }
            else
            {
              LODWORD(v656[0]) = 257;
              v465 = *(const void **)__s2;
              v466 = v654;
              v467 = a3;
              v468 = v625;
            }
          }
          else
          {
            LODWORD(v656[0]) = 257;
            v465 = *(const void **)__s2;
            v466 = v654;
            v467 = a3;
            v468 = v627;
          }
        }
        else
        {
          LODWORD(v656[0]) = 257;
          v465 = *(const void **)__s2;
          v466 = v654;
          v467 = a3;
          v468 = v631;
        }
        MfsData = ssftriff_reader_ReadStringZ(v467, (uint64_t)v465, v466, 0, v468, (unsigned int *)v656);
        goto LABEL_812;
      }
      if (!cstdlib_strcmp(a5, "FEEX") && !cstdlib_strcmp(__s1, "TRAF") && !cstdlib_strcmp(__src, "FEAT"))
      {
        LOWORD(v656[0]) = 0;
        *(_QWORD *)__s2 = 0;
        if (v8)
        {
          v310 = (const void *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
          *(_QWORD *)__s2 = v310;
        }
        else
        {
          ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v192, v193, v194, v195, v196);
          if ((ChunkData & 0x80000000) != 0)
            return ChunkData;
          v310 = *(const void **)__s2;
        }
        cstdlib_memcpy(v656, v310, 2uLL);
        v476 = (const void *)(*(_QWORD *)__s2 + 2);
        *(_QWORD *)__s2 += 2;
        v477 = LOWORD(v656[0]);
        if (LOWORD(v656[0]) >= 8u)
        {
          log_OutPublic(v13[4], (uint64_t)"SELECT_BET5", 58010, (uint64_t)"%s%hu", v472, v473, v474, v475, "feature");
          return 2229280772;
        }
        *(_DWORD *)(a2 + 4 * LOWORD(v656[0]) + 17760) = v635;
        v478 = (_DWORD *)(*(_QWORD *)(a2 + 17752) + 12 * v635);
        *v478 = v477;
        cstdlib_memcpy(v478 + 2, v476, 2uLL);
        *(_QWORD *)__s2 += 2;
        cstdlib_memcpy((void *)(*(_QWORD *)(a2 + 17752) + 12 * v635++ + 4), *(const void **)__s2, 4uLL);
        goto LABEL_818;
      }
      if (!cstdlib_strcmp(a5, "FEEX") && !cstdlib_strcmp(__s1, "CTXR"))
      {
        if (!cstdlib_strcmp(__src, "RULF"))
        {
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            v311 = (char *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
            *(_QWORD *)__s2 = v311;
          }
          else
          {
            v481 = ssftriff_reader_GetChunkData(a3, v654, __s2, v228, v229, v230, v231, v232);
            if ((v481 & 0x80000000) != 0)
              return v481;
            v311 = *(char **)__s2;
          }
          v482 = v654;
          v483 = (uint64_t)v13;
          v484 = a3;
          v485 = v633;
          goto LABEL_747;
        }
        if (!cstdlib_strcmp(__src, "RULT"))
        {
          *(_QWORD *)__s2 = 0;
          if (v8)
          {
            v311 = (char *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
            *(_QWORD *)__s2 = v311;
          }
          else
          {
            v481 = ssftriff_reader_GetChunkData(a3, v654, __s2, v233, v234, v235, v236, v237);
            if ((v481 & 0x80000000) != 0)
              return v481;
            v311 = *(char **)__s2;
          }
          v482 = v654;
          v483 = (uint64_t)v13;
          v484 = a3;
          v485 = v630;
LABEL_747:
          RiffStringTable = select_bet5_LoadRiffStringTable(v483, v484, v311, v482, v485);
LABEL_748:
          LODWORD(ChunkData) = RiffStringTable;
          goto LABEL_818;
        }
        if (!cstdlib_strcmp(__src, "TRD4"))
        {
          v479 = *(unsigned __int16 *)(v637 + 516);
          if (v479 <= 0x3F)
          {
            LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v479 + 42848), v624, v238, v239, v240, v241, v242);
            if ((ChunkData & 0x80000000) == 0)
            {
              ++*(_WORD *)(v637 + 516);
              v480 = v654;
              *(_DWORD *)v637 += v654;
              *((_DWORD *)v634 + 10) = v480 / 0xC;
            }
            goto LABEL_818;
          }
LABEL_914:
          LODWORD(ChunkData) = -2065686524;
          goto LABEL_818;
        }
        if (!cstdlib_strcmp(__src, "TRP4"))
        {
          v248 = *(unsigned __int16 *)(v637 + 516);
          if (v248 <= 0x3F)
          {
            LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v248 + 42848), v621, v243, v244, v245, v246, v247);
            if ((ChunkData & 0x80000000) == 0)
            {
              ++*(_WORD *)(v637 + 516);
              v495 = v654;
              *(_DWORD *)v637 += v654;
              *((_DWORD *)v634 + 14) = v495 / 0xC;
            }
            goto LABEL_818;
          }
LABEL_133:
          LODWORD(ChunkData) = -2065686524;
          goto LABEL_818;
        }
        goto LABEL_815;
      }
      if (cstdlib_strcmp(a5, "FEEX") || cstdlib_strcmp(__s1, "NNFE"))
      {
        if (!cstdlib_strcmp(a5, "STM3") && !cstdlib_strcmp(__s1, "PCI4"))
        {
          v202 = *(unsigned int *)(a2 + 388);
          if (!cstdlib_strcmp(__src, "PCII"))
          {
            v203 = v654;
            v204 = a2;
            v205 = a3;
            v206 = 4;
            goto LABEL_711;
          }
          if (!cstdlib_strcmp(__src, "PCIL"))
          {
            v203 = v654;
            v204 = a2;
            v205 = a3;
            v206 = 5;
LABEL_711:
            v469 = select_bet5_LoadMfsData(v204, v205, v206, v202, v203, v8, v643, 0);
            goto LABEL_712;
          }
        }
        goto LABEL_815;
      }
      *(_QWORD *)__s2 = 0;
      if (v8)
      {
        *(_QWORD *)__s2 = v8 + ssftriff_reader_GetPosition(a3) - v643;
      }
      else
      {
        ChunkData = ssftriff_reader_GetChunkData(a3, v654, __s2, v197, v198, v199, v200, v201);
        if ((ChunkData & 0x80000000) != 0)
          return ChunkData;
      }
      if (cstdlib_strcmp(__src, "NNLT"))
      {
        if (cstdlib_strcmp(__src, "NNUF"))
        {
LABEL_226:
          v312 = 0;
LABEL_814:
          if (v312)
            goto LABEL_818;
          goto LABEL_815;
        }
        cstdlib_memcpy(v628, *(const void **)__s2, 2uLL);
        v300 = *(char **)__s2;
        v301 = v654;
        v302 = (uint64_t)v13;
        v303 = a3;
        v304 = v629;
LABEL_716:
        MfsData = select_bet5_LoadRiffStringTable(v302, v303, v300, v301, v304);
        goto LABEL_812;
      }
      v313 = *v634;
      LODWORD(ChunkData) = -2065686524;
      if (v313 <= 0x10)
      {
        v314 = *(char **)__s2;
        v315 = v654;
        if (*((_QWORD *)v634 + 1))
        {
LABEL_231:
          *v634 = v313 + 1;
          LODWORD(v656[0]) = 0;
          StringW = ssftriff_reader_ReadStringW(a3, (uint64_t)v314, v315, 0, 0, v656);
          if ((StringW & 0x80000000) == 0 || (LODWORD(ChunkData) = StringW, (StringW & 0x1FFF) == 9))
          {
            v318 = (_BYTE *)heap_Alloc(v13[1], LODWORD(v656[0]));
            *(_QWORD *)(*((_QWORD *)v634 + 1) + 16 * *v634 - 16) = v318;
            if (v318)
            {
              MfsData = ssftriff_reader_ReadStringW(a3, (uint64_t)v314, v315, 0, v318, v656);
              if ((MfsData & 0x80000000) == 0)
              {
                v301 = v315 - (LODWORD(v656[0]) + 1);
                v300 = &v314[LODWORD(v656[0]) - 1 + 2];
                v304 = (uint64_t *)(*((_QWORD *)v634 + 1) + 16 * *v634 - 8);
                v302 = (uint64_t)v13;
                v303 = a3;
                goto LABEL_716;
              }
              goto LABEL_812;
            }
            goto LABEL_867;
          }
        }
        else
        {
          v316 = heap_Calloc((_QWORD *)v13[1], 18, 16);
          *((_QWORD *)v634 + 1) = v316;
          if (v316)
          {
            LOWORD(v313) = *v634;
            goto LABEL_231;
          }
LABEL_867:
          LODWORD(ChunkData) = -2065686518;
        }
      }
LABEL_813:
      v312 = 1;
      goto LABEL_814;
    }
    if (!cstdlib_strcmp(__src, "VINF"))
    {
      LODWORD(v650) = 0;
      *(_QWORD *)v655 = 0;
      if (v8)
      {
        *(_QWORD *)v655 = v8 + ssftriff_reader_GetPosition(a3) - v643;
      }
      else
      {
        ChunkData = ssftriff_reader_GetChunkData(a3, v654, v655, v15, v16, v17, v18, v19);
        if ((ChunkData & 0x80000000) != 0)
          return ChunkData;
      }
      v212 = v654;
      if (!v654)
        goto LABEL_818;
      v213 = 0;
      while (1)
      {
        LOBYTE(v656[0]) = 0;
        __s2[0] = 0;
        LODWORD(v650) = 1024;
        LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v655, v212, v213, __s2, (unsigned int *)&v650);
        if ((ChunkData & 0x80000000) == 0 && v213 < v654)
        {
          v213 += v650;
          LODWORD(v650) = 1024;
          LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v655, v654, v213, v656, (unsigned int *)&v650);
        }
        if ((ChunkData & 0x80000000) != 0)
          goto LABEL_127;
        v214 = (int)v650;
        if (!cstdlib_strcmp("GUID", __s2) || !cstdlib_strcmp("ComponentID", __s2))
        {
          cstdlib_strcpy(v636, (const char *)v656);
          goto LABEL_127;
        }
        v213 += v214;
        v212 = v654;
        v13 = a1;
        if (v213 >= v654)
          goto LABEL_818;
      }
    }
    if (!cstdlib_strcmp(__src, "VPRP"))
    {
      LODWORD(v650) = 0;
      *(_QWORD *)v655 = 0;
      if (v8)
      {
        *(_QWORD *)v655 = v8 + ssftriff_reader_GetPosition(a3) - v643;
      }
      else
      {
        ChunkData = ssftriff_reader_GetChunkData(a3, v654, v655, v20, v21, v22, v23, v24);
        if ((ChunkData & 0x80000000) != 0)
          return ChunkData;
      }
      LOBYTE(v656[0]) = 0;
      __s2[0] = 0;
      v264 = v654;
      if (v654)
      {
        v265 = 0;
        do
        {
          LODWORD(v650) = 1024;
          LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v655, v264, v265, __s2, (unsigned int *)&v650);
          if ((ChunkData & 0x80000000) == 0 && v265 < v654)
          {
            v265 += v650;
            LODWORD(v650) = 1024;
            LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v655, v654, v265, v656, (unsigned int *)&v650);
          }
          if ((ChunkData & 0x80000000) != 0)
            break;
          v266 = (int)v650;
          if (!cstdlib_strcmp(__s2, "COUNT_UNITS_FULL_SPEECHBASE"))
            *(_DWORD *)(a2 + 11804) = LH_atou((const char *)v656);
          if (!cstdlib_strcmp(__s2, "COUNT_UNITS_AVAILABLE"))
            *(_DWORD *)(a2 + 11812) = LH_atou((const char *)v656);
          if (!cstdlib_strcmp(__s2, "COUNT_UNITS_GRAVEYARD"))
            *(_DWORD *)(a2 + 11816) = LH_atou((const char *)v656);
          if (!cstdlib_strcmp(__s2, "COUNT_UNITS_REMOVED"))
            *(_DWORD *)(a2 + 11808) = LH_atou((const char *)v656);
          v265 += v266;
          v264 = v654;
        }
        while (v265 < v654);
      }
      goto LABEL_818;
    }
    if (!cstdlib_strcmp(__src, "VSTS"))
      goto LABEL_82;
    if (!cstdlib_strcmp(__src, "VCFG"))
    {
      v651 = 0;
      *(_QWORD *)v649 = 0;
      v650 = 0;
      if (v8)
      {
        *(_QWORD *)v649 = v8 + ssftriff_reader_GetPosition(a3) - v643;
      }
      else
      {
        ChunkData = ssftriff_reader_GetChunkData(a3, v654, v649, v25, v26, v27, v28, v29);
        if ((ChunkData & 0x80000000) != 0)
          return ChunkData;
      }
      v320 = v654;
      if (v654)
      {
        v321 = 0;
        do
        {
          __s2[0] = 0;
          v655[0] = 0;
          v651 = 64;
          LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v649, v320, v321, v655, &v651);
          if ((ChunkData & 0x80000000) == 0 && v321 < v654)
          {
            v321 += v651;
            v651 = 256;
            LODWORD(ChunkData) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v649, v654, v321, __s2, &v651);
          }
          if ((ChunkData & 0x80000000) != 0)
            break;
          v322 = v651;
          cstdlib_strcpy((char *)v656, "bet5voiceoverride.");
          cstdlib_strcat((char *)v656, v655);
          if ((paramc_ParamGetStr(v13[5], (uint64_t)v656, &v650) & 0x80000000) != 0 || !v650 || !*v650)
            v650 = __s2;
          if (!cstdlib_strcmp(v655, "BREAKER"))
          {
            v323 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 336) = v323;
            if (!v323)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "BRK_LENGTH"))
            *(_DWORD *)(a2 + 344) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "BRK_TC"))
            *(_DWORD *)(a2 + 348) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "BRK_ZPAD"))
            *(_DWORD *)(a2 + 352) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "ALGN_ST"))
            *(_DWORD *)(a2 + 368) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "ALGN_PH"))
            *(_DWORD *)(a2 + 372) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "ALPHA"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v324 = v324;
            *(_DWORD *)(a2 + 256) = LODWORD(v324);
          }
          if (!cstdlib_strcmp(v655, "BETA"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v325 = v325;
            *(_DWORD *)(a2 + 260) = LODWORD(v325);
          }
          if (!cstdlib_strcmp(v655, "FS"))
            *(_DWORD *)(a2 + 264) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_SILENCE_SYNTH"))
            *(_DWORD *)(a2 + 5304) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "VUV_REL_AMP"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v326 = v326;
            *(_DWORD *)(a2 + 268) = LODWORD(v326);
          }
          if (!cstdlib_strcmp(v655, "ORDER"))
            *(_DWORD *)(a2 + 272) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "FRAME_SIZE"))
            *(_DWORD *)(a2 + 280) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "RHO"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v327 = v327;
            *(_DWORD *)(a2 + 288) = LODWORD(v327);
          }
          if (!cstdlib_strcmp(v655, "VOL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v328 = v328;
            *(_DWORD *)(a2 + 292) = LODWORD(v328);
          }
          if (!cstdlib_strcmp(v655, "MVF_BOOST"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v329 = v329;
            *(_DWORD *)(a2 + 296) = LODWORD(v329);
          }
          if (!cstdlib_strcmp(v655, "VSYNTH"))
          {
            v330 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 360) = v330;
            if (!v330)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "F0_RHO"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v331 = v331;
            *(_DWORD *)(a2 + 300) = LODWORD(v331);
          }
          if (!cstdlib_strcmp(v655, "F0_STD"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v332 = v332;
            *(_DWORD *)(a2 + 304) = LODWORD(v332);
          }
          if (!cstdlib_strcmp(v655, "F0_MEAN"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v333 = v333;
            *(_DWORD *)(a2 + 308) = LODWORD(v333);
          }
          if (!cstdlib_strcmp(v655, "SPEECH_F0_MEAN"))
            *(_DWORD *)(a2 + 312) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "PDF_VARIANCE_TYPE"))
            *(_DWORD *)(a2 + 328) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_PSOLA_MODE"))
            *(_DWORD *)(a2 + 11776) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_PSOLA_MODE2_PROTECT_VOWELS"))
            *(_DWORD *)(a2 + 11780) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_ENABLE_CREAK_PROTECTION"))
            *(_DWORD *)(a2 + 11792) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_PSOLA_MIN_DURATION_RATIO"))
            *(_DWORD *)(a2 + 11796) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_PSOLA_MAX_DURATION_RATIO"))
            *(_DWORD *)(a2 + 11800) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_VITERBI_DECODER_VARIANT"))
            *(_DWORD *)(a2 + 11744) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v334 = v334;
            *(_DWORD *)(a2 + 5760) = LODWORD(v334);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_SLL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v335 = v335;
            *(_DWORD *)(a2 + 5848) = LODWORD(v335);
          }
          if (!cstdlib_strcmp(v655, "F_SLL_STEP"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v336 = v336;
            *(_DWORD *)(a2 + 5844) = LODWORD(v336);
          }
          if (!cstdlib_strcmp(v655, "F_Q"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v337 = v337;
            *(_DWORD *)(a2 + 5772) = LODWORD(v337);
          }
          if (!cstdlib_strcmp(v655, "F_Q_UNV"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v338 = v338;
            *(_DWORD *)(a2 + 5776) = LODWORD(v338);
          }
          if (!cstdlib_strcmp(v655, "F_SYM_QA"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v339 = v339;
            *(_DWORD *)(a2 + 5780) = LODWORD(v339);
          }
          if (!cstdlib_strcmp(v655, "N_SEARCH_MODE"))
            *(_DWORD *)(a2 + 7056) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_NODE_LIMIT"))
            *(_DWORD *)(a2 + 5804) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_INV_NODE_LIMIT"))
            *(_DWORD *)(a2 + 5808) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_PRUNE_PCT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v340 = v340;
            *(_DWORD *)(a2 + 5812) = LODWORD(v340);
          }
          if (!cstdlib_strcmp(v655, "F_BEAM_WIDTH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v341 = v341;
            *(_DWORD *)(a2 + 5824) = LODWORD(v341);
          }
          if (!cstdlib_strcmp(v655, "F_BEAM_WIDTH_UNV"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v342 = v342;
            *(_DWORD *)(a2 + 5828) = LODWORD(v342);
          }
          if (!cstdlib_strcmp(v655, "F_NODE_PRUNE_PCT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v343 = v343;
            *(_DWORD *)(a2 + 5816) = LODWORD(v343);
          }
          if (!cstdlib_strcmp(v655, "N_NODE_PRUNE_MAX"))
            *(_DWORD *)(a2 + 5820) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_SILVIT"))
            *(_DWORD *)(a2 + 5832) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_SLL_MAX"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v344 = v344;
            *(_DWORD *)(a2 + 5836) = LODWORD(v344);
          }
          if (!cstdlib_strcmp(v655, "F_SLL_WEIGHT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v345 = v345;
            *(_DWORD *)(a2 + 5840) = LODWORD(v345);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPOS_SNT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v346 = v346;
            *(_DWORD *)(a2 + 5860) = LODWORD(v346);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPOS_SNT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v347 = v347;
            *(_DWORD *)(a2 + 5864) = LODWORD(v347);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPOS_PHR_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v348 = v348;
            *(_DWORD *)(a2 + 5868) = LODWORD(v348);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPOS_PHR_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v349 = v349;
            *(_DWORD *)(a2 + 5872) = LODWORD(v349);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPOS_SNT_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v350 = v350;
            *(_DWORD *)(a2 + 5876) = LODWORD(v350);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPOS_SNT_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v351 = v351;
            *(_DWORD *)(a2 + 5880) = LODWORD(v351);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPOS_PHR_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v352 = v352;
            *(_DWORD *)(a2 + 5884) = LODWORD(v352);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPOS_PHR_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v353 = v353;
            *(_DWORD *)(a2 + 5888) = LODWORD(v353);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPOS_PHR_MID"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v354 = v354;
            *(_DWORD *)(a2 + 5892) = LODWORD(v354);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPOS_PHR_MID"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v355 = v355;
            *(_DWORD *)(a2 + 5896) = LODWORD(v355);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDWRDPOSSHP_SENT_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v356 = v356;
            *(_DWORD *)(a2 + 5900) = LODWORD(v356);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDWRDPOSSHP_SENT_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v357 = v357;
            *(_DWORD *)(a2 + 5904) = LODWORD(v357);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDWRDPOSSHP_SENT_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v358 = v358;
            *(_DWORD *)(a2 + 5908) = LODWORD(v358);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDWRDPOSSHP_SENT_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v359 = v359;
            *(_DWORD *)(a2 + 5912) = LODWORD(v359);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDWRDPOSSHP_SENT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v360 = v360;
            *(_DWORD *)(a2 + 5916) = LODWORD(v360);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDWRDPOSSHP_SENT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v361 = v361;
            *(_DWORD *)(a2 + 5920) = LODWORD(v361);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDWRDPOSSHP_IP4_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v362 = v362;
            *(_DWORD *)(a2 + 5924) = LODWORD(v362);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDWRDPOSSHP_IP4_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v363 = v363;
            *(_DWORD *)(a2 + 5928) = LODWORD(v363);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDWRDPOSSHP_IP4_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v364 = v364;
            *(_DWORD *)(a2 + 5932) = LODWORD(v364);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDWRDPOSSHP_IP4_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v365 = v365;
            *(_DWORD *)(a2 + 5936) = LODWORD(v365);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDWRDPOSSHP_IP4_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v366 = v366;
            *(_DWORD *)(a2 + 5940) = LODWORD(v366);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDWRDPOSSHP_IP4_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v367 = v367;
            *(_DWORD *)(a2 + 5944) = LODWORD(v367);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRM_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v368 = v368;
            *(_DWORD *)(a2 + 5948) = LODWORD(v368);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRM_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v369 = v369;
            *(_DWORD *)(a2 + 5952) = LODWORD(v369);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRM_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v370 = v370;
            *(_DWORD *)(a2 + 5956) = LODWORD(v370);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRM_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v371 = v371;
            *(_DWORD *)(a2 + 5960) = LODWORD(v371);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRM_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v372 = v372;
            *(_DWORD *)(a2 + 5964) = LODWORD(v372);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRM_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v373 = v373;
            *(_DWORD *)(a2 + 5968) = LODWORD(v373);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRM_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v374 = v374;
            *(_DWORD *)(a2 + 5972) = LODWORD(v374);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRM_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v375 = v375;
            *(_DWORD *)(a2 + 5976) = LODWORD(v375);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRMSHP_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v376 = v376;
            *(_DWORD *)(a2 + 5980) = LODWORD(v376);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRMSHP_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v377 = v377;
            *(_DWORD *)(a2 + 5984) = LODWORD(v377);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRMSHP_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v378 = v378;
            *(_DWORD *)(a2 + 5988) = LODWORD(v378);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRMSHP_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v379 = v379;
            *(_DWORD *)(a2 + 5992) = LODWORD(v379);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRMSHP_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v380 = v380;
            *(_DWORD *)(a2 + 5996) = LODWORD(v380);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRMSHP_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v381 = v381;
            *(_DWORD *)(a2 + 6000) = LODWORD(v381);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRMSHP_NUC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v382 = v382;
            *(_DWORD *)(a2 + 6004) = LODWORD(v382);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRMSHP_NUC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v383 = v383;
            *(_DWORD *)(a2 + 6008) = LODWORD(v383);
          }
          if (!cstdlib_strcmp(v655, "F_Q_WRDPRMSHP_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v384 = v384;
            *(_DWORD *)(a2 + 6012) = LODWORD(v384);
          }
          if (!cstdlib_strcmp(v655, "F_B_WRDPRMSHP_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v385 = v385;
            *(_DWORD *)(a2 + 6016) = LODWORD(v385);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPOS_SNT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v386 = v386;
            *(_DWORD *)(a2 + 6020) = LODWORD(v386);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPOS_PHR_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v387 = v387;
            *(_DWORD *)(a2 + 6024) = LODWORD(v387);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPOS_SNT_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v388 = v388;
            *(_DWORD *)(a2 + 6028) = LODWORD(v388);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPOS_PHR_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v389 = v389;
            *(_DWORD *)(a2 + 6032) = LODWORD(v389);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPOS_PHR_MID"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v390 = v390;
            *(_DWORD *)(a2 + 6036) = LODWORD(v390);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDWRDPOSSHP_SENT_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v391 = v391;
            *(_DWORD *)(a2 + 6040) = LODWORD(v391);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDWRDPOSSHP_SENT_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v392 = v392;
            *(_DWORD *)(a2 + 6044) = LODWORD(v392);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDWRDPOSSHP_SENT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v393 = v393;
            *(_DWORD *)(a2 + 6048) = LODWORD(v393);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDWRDPOSSHP_IP4_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v394 = v394;
            *(_DWORD *)(a2 + 6052) = LODWORD(v394);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDWRDPOSSHP_IP4_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v395 = v395;
            *(_DWORD *)(a2 + 6056) = LODWORD(v395);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDWRDPOSSHP_IP4_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v396 = v396;
            *(_DWORD *)(a2 + 6060) = LODWORD(v396);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRM_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v397 = v397;
            *(_DWORD *)(a2 + 6064) = LODWORD(v397);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRM_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v398 = v398;
            *(_DWORD *)(a2 + 6068) = LODWORD(v398);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRM_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v399 = v399;
            *(_DWORD *)(a2 + 6072) = LODWORD(v399);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRM_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v400 = v400;
            *(_DWORD *)(a2 + 6076) = LODWORD(v400);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRMSHP_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v401 = v401;
            *(_DWORD *)(a2 + 6080) = LODWORD(v401);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRMSHP_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v402 = v402;
            *(_DWORD *)(a2 + 6084) = LODWORD(v402);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRMSHP_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v403 = v403;
            *(_DWORD *)(a2 + 6088) = LODWORD(v403);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRMSHP_NUC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v404 = v404;
            *(_DWORD *)(a2 + 6092) = LODWORD(v404);
          }
          if (!cstdlib_strcmp(v655, "F_QA_WRDPRMSHP_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v405 = v405;
            *(_DWORD *)(a2 + 6096) = LODWORD(v405);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPOS_SNT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v406 = v406;
            *(_DWORD *)(a2 + 6100) = LODWORD(v406);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPOS_PHR_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v407 = v407;
            *(_DWORD *)(a2 + 6104) = LODWORD(v407);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPOS_SNT_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v408 = v408;
            *(_DWORD *)(a2 + 6108) = LODWORD(v408);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPOS_PHR_INIT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v409 = v409;
            *(_DWORD *)(a2 + 6112) = LODWORD(v409);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPOS_PHR_MID"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v410 = v410;
            *(_DWORD *)(a2 + 6116) = LODWORD(v410);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDWRDPOSSHP_SENT_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v411 = v411;
            *(_DWORD *)(a2 + 6120) = LODWORD(v411);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDWRDPOSSHP_SENT_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v412 = v412;
            *(_DWORD *)(a2 + 6124) = LODWORD(v412);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDWRDPOSSHP_SENT_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v413 = v413;
            *(_DWORD *)(a2 + 6128) = LODWORD(v413);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDWRDPOSSHP_IP4_SINGLE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v414 = v414;
            *(_DWORD *)(a2 + 6132) = LODWORD(v414);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDWRDPOSSHP_IP4_INITIAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v415 = v415;
            *(_DWORD *)(a2 + 6136) = LODWORD(v415);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDWRDPOSSHP_IP4_FINAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v416 = v416;
            *(_DWORD *)(a2 + 6140) = LODWORD(v416);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRM_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v417 = v417;
            *(_DWORD *)(a2 + 6144) = LODWORD(v417);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRM_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v418 = v418;
            *(_DWORD *)(a2 + 6148) = LODWORD(v418);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRM_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v419 = v419;
            *(_DWORD *)(a2 + 6152) = LODWORD(v419);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRM_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v420 = v420;
            *(_DWORD *)(a2 + 6156) = LODWORD(v420);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRMSHP_UACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v421 = v421;
            *(_DWORD *)(a2 + 6160) = LODWORD(v421);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRMSHP_DACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v422 = v422;
            *(_DWORD *)(a2 + 6164) = LODWORD(v422);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRMSHP_ACC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v423 = v423;
            *(_DWORD *)(a2 + 6168) = LODWORD(v423);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRMSHP_NUC"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v424 = v424;
            *(_DWORD *)(a2 + 6172) = LODWORD(v424);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_WRDPRMSHP_EMPH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v425 = v425;
            *(_DWORD *)(a2 + 6176) = LODWORD(v425);
          }
          if (!cstdlib_strcmp(v655, "F_W_CONTEXT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v426 = v426;
            *(_DWORD *)(a2 + 5764) = LODWORD(v426);
          }
          if (!cstdlib_strcmp(v655, "F_W_GENERIC_CONTEXT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v427 = v427;
            *(_DWORD *)(a2 + 5768) = LODWORD(v427);
          }
          if (!cstdlib_strcmp(v655, "N_DATABNF_TYPE_OF_BNF_STYLE"))
            *(_DWORD *)(a2 + 7012) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_DATAJV_TYPE_OF_JV_STYLE"))
            *(_DWORD *)(a2 + 7016) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_DATAJV_CLUSTERED"))
            *(_DWORD *)(a2 + 7020) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "F_MODE_DEC4_SIMD_STYLE"))
            *(_DWORD *)(a2 + 7024) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_EXPLICIT_PHONE_MODEL"))
            *(_DWORD *)(a2 + 6232) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_DIPHONE_UNITS"))
            *(_DWORD *)(a2 + 6236) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_PHONEME_SUBSTATE_MODEL"))
            *(_DWORD *)(a2 + 6240) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_PHONEME_SUBSTATE_DATA_OPTIMIZATION"))
            *(_DWORD *)(a2 + 6244) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_UNITBULKING"))
            *(_DWORD *)(a2 + 6252) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_UNITBULKING_SEARCH_MINADJ"))
            *(_DWORD *)(a2 + 6256) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "F_UNITBULKING_SEARCH_COST_NO_ADJACENT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v428 = v428;
            *(_DWORD *)(a2 + 6260) = LODWORD(v428);
          }
          if (!cstdlib_strcmp(v655, "B_STATE_LM_BACKUP"))
            *(_DWORD *)(a2 + 6324) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_ALL_STATE_LM"))
            *(_DWORD *)(a2 + 6328) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_BACKOFF"))
            *(_DWORD *)(a2 + 6332) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_UNIGRAMS_IN_PJ_SPMTX_MCP"))
            *(_DWORD *)(a2 + 6932) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_CODEBOOK_VECTORS_MCP"))
            *(_DWORD *)(a2 + 6948) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "B_CONTEXTEXPANDBNF"))
            *(_DWORD *)(a2 + 7008) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_TYPEOFPITCHCOST"))
            *(_DWORD *)(a2 + 7028) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_LLMINNEGTARGETSTEP"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v429 = v429;
            *(_DWORD *)(a2 + 6448) = LODWORD(v429);
          }
          if (!cstdlib_strcmp(v655, "B_USEQUANTIZEDLL"))
            *(_DWORD *)(a2 + 6452) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_USELL"))
            *(_DWORD *)(a2 + 6456) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "F_PITCHSLOPEWEIGHT"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v430 = v430;
            *(_DWORD *)(a2 + 7032) = LODWORD(v430);
          }
          if (!cstdlib_strcmp(v655, "F_BNF_MAXVAL"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v431 = v431;
            *(float *)(a2 + 6928) = 127.0 / *(float *)&v431;
          }
          if (!cstdlib_strcmp(v655, "B_UNIGRAMS_IN_PJ_SPMTX_LF0"))
            *(_DWORD *)(a2 + 6936) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_USE_PJ_FSM_MCP"))
            *(_DWORD *)(a2 + 6940) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_NGRAM_ORDER_PJ_FSM_MCP"))
            *(_DWORD *)(a2 + 6944) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_USE_PJ_FSM_LF0"))
            *(_DWORD *)(a2 + 6952) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_NGRAM_ORDER_PJ_FSM_LF0"))
            *(_DWORD *)(a2 + 6956) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_BIAS_PJ_FSM_LF0"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v432 = v432;
            *(_DWORD *)(a2 + 6960) = LODWORD(v432);
          }
          if (!cstdlib_strcmp(v655, "N_BIAS_SHIFT_PJ_FSM_LF0"))
            *(_DWORD *)(a2 + 6964) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_BIAS_ONLY_VOICED_PJ_FSM_LF0"))
            *(_DWORD *)(a2 + 6968) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_QUANT_PRECOMP_FSMR_LF0"))
            *(_DWORD *)(a2 + 6972) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_TRANSPOSE_PJ_MTX"))
            *(_DWORD *)(a2 + 6980) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_ANN_CHUNK_PH_SIZE"))
            *(_DWORD *)(a2 + 6996) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_ANN_CHUNK_PH_OVL_L_SIZE"))
            *(_DWORD *)(a2 + 7000) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_ANN_CHUNK_PH_OVL_R_SIZE"))
            *(_DWORD *)(a2 + 7004) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_ADDITIVE_TRANS_WEIGHTS"))
            *(_DWORD *)(a2 + 6392) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_ENABLE_CCL"))
            *(_DWORD *)(a2 + 6376) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_LEN_CCL"))
            *(_DWORD *)(a2 + 6380) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_SLL_THRES"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v433 = v433;
            *(_DWORD *)(a2 + 6384) = LODWORD(v433);
          }
          if (!cstdlib_strcmp(v655, "B_ENABLE_SLL_THRES"))
            *(_DWORD *)(a2 + 6388) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "B_ENABLE_BNF_DISTANCE_PRUNING"))
            *(_DWORD *)(a2 + 6396) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_BNF_PRUNING_MIN_NODES"))
            *(_DWORD *)(a2 + 6400) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_BNF_MIN_CAND"))
            *(_DWORD *)(a2 + 6404) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "N_BNF_MAX_CAND"))
            *(_DWORD *)(a2 + 6408) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "N_BNF_THRESH"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v434 = v434;
            *(_DWORD *)(a2 + 6412) = LODWORD(v434);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_DUR_OUTLIER_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v435 = v435;
            *(_DWORD *)(a2 + 6416) = LODWORD(v435);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_DUR_OUTLIER_MAX"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v436 = v436;
            *(_DWORD *)(a2 + 6420) = LODWORD(v436);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_DUR_OUTLIER_DIST_PARAM1"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v437 = v437;
            *(_DWORD *)(a2 + 6424) = LODWORD(v437);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_DUR_OUTLIER_DIST_PARAM2"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v438 = v438;
            *(_DWORD *)(a2 + 6428) = LODWORD(v438);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_PITCH_SLOPE_OUTLIER_DIST_PARAM1"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v439 = v439;
            *(_DWORD *)(a2 + 6432) = LODWORD(v439);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_PITCH_SLOPE_OUTLIER_DIST_PARAM2"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v440 = v440;
            *(_DWORD *)(a2 + 6436) = LODWORD(v440);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_PITCH_EDGE_OUTLIER_DIST_PARAM1"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v441 = v441;
            *(_DWORD *)(a2 + 6440) = LODWORD(v441);
          }
          if (!cstdlib_strcmp(v655, "F_PRUNE_PITCH_EDGE_OUTLIER_DIST_PARAM2"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v442 = v442;
            *(_DWORD *)(a2 + 6444) = LODWORD(v442);
          }
          if (!cstdlib_strcmp(v655, "B_BNF_RND_PROJECTION"))
            *(_DWORD *)(a2 + 6984) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_BNF_VECTOR_SIZE"))
            *(_DWORD *)(a2 + 6988) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "N_BNF_LF0_JOIN_THRESHOLD"))
            *(_DWORD *)(a2 + 6920) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_MAX_RNN_LF0_JOIN_DEVIATION"))
            *(_DWORD *)(a2 + 6924) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "S_LANGUAGE_INDICES"))
            *(_QWORD *)(a2 + 6464) = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
          if (!cstdlib_strcmp(v655, "S_QUESTION_INDICES"))
            *(_QWORD *)(a2 + 6472) = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
          if (!cstdlib_strcmp(v655, "S_STYLE_INDICES"))
            *(_QWORD *)(a2 + 6480) = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
          if (!cstdlib_strcmp(v655, "N_MAIN_LANGUAGE_INDEX"))
            *(_DWORD *)(a2 + 6872) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_LANGUAGE_SCORE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v443 = v443;
            *(_DWORD *)(a2 + 6876) = LODWORD(v443);
          }
          if (!cstdlib_strcmp(v655, "F_QUESTION_SCORE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v444 = v444;
            *(_DWORD *)(a2 + 6880) = LODWORD(v444);
          }
          if (!cstdlib_strcmp(v655, "F_STYLE_SCORE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v445 = v445;
            *(_DWORD *)(a2 + 6884) = LODWORD(v445);
          }
          if (!cstdlib_strcmp(v655, "N_NODE_PRUNE_MIN"))
            *(_DWORD *)(a2 + 6888) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "F_NODE_SCORE_MAX"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v446 = v446;
            *(_DWORD *)(a2 + 6892) = LODWORD(v446);
          }
          if (!cstdlib_strcmp(v655, "F_BEG_1ST_CASCADED_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v447 = v447;
            *(_DWORD *)(a2 + 6896) = LODWORD(v447);
          }
          if (!cstdlib_strcmp(v655, "F_MID_1ST_CASCADED_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v448 = v448;
            *(_DWORD *)(a2 + 6900) = LODWORD(v448);
          }
          if (!cstdlib_strcmp(v655, "F_END_1ST_CASCADED_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v449 = v449;
            *(_DWORD *)(a2 + 6904) = LODWORD(v449);
          }
          if (!cstdlib_strcmp(v655, "F_BEG_2ND_CASCADED_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v450 = v450;
            *(_DWORD *)(a2 + 6908) = LODWORD(v450);
          }
          if (!cstdlib_strcmp(v655, "F_MID_2ND_CASCADED_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v451 = v451;
            *(_DWORD *)(a2 + 6912) = LODWORD(v451);
          }
          if (!cstdlib_strcmp(v655, "F_END_2ND_CASCADED_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v452 = v452;
            *(_DWORD *)(a2 + 6916) = LODWORD(v452);
          }
          if (!cstdlib_strcmp(v655, "N_MAX_UNITBASE_UNITS"))
            *(_DWORD *)(a2 + 7048) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_MAXLOAD_UNITS"))
            *(_DWORD *)(a2 + 7052) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_USE_ANN_PRED"))
            *(_DWORD *)(a2 + 6992) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_BNF"))
          {
            v453 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10664) = v453;
            if (!v453)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_LF0"))
          {
            v454 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10672) = v454;
            if (!v454)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_DUR"))
          {
            v455 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10680) = v455;
            if (!v455)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_SDUR"))
          {
            v456 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10688) = v456;
            if (!v456)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_VUV"))
          {
            v457 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10696) = v457;
            if (!v457)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_ELF0"))
          {
            v458 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10704) = v458;
            if (!v458)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "S_ANN_PRED_OUTLAYER_PDUR"))
          {
            v459 = UNICORN__heap_StrDup((_QWORD *)v13[1], v650);
            *(_QWORD *)(a2 + 10712) = v459;
            if (!v459)
              LODWORD(ChunkData) = -2065686518;
          }
          if (!cstdlib_strcmp(v655, "F_JOIN_UNIT_SYLRATE_FACTOR"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v460 = v460;
            *(_DWORD *)(a2 + 7040) = LODWORD(v460);
          }
          if (!cstdlib_strcmp(v655, "B_JOIN_UNIT_SYLRATE_ADJ"))
            *(_DWORD *)(a2 + 7044) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "F_HMM_STREAM_WEIGHT_DUR_TUNE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v461 = v461;
            *(_DWORD *)(a2 + 11752) = LODWORD(v461);
          }
          if (!cstdlib_strcmp(v655, "F_BEAM_WIDTH_TUNE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v462 = v462;
            *(_DWORD *)(a2 + 11748) = LODWORD(v462);
          }
          if (!cstdlib_strcmp(v655, "F_JCOST_WEIGHT_ADJ_TUNE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v463 = v463;
            *(_DWORD *)(a2 + 11756) = LODWORD(v463);
          }
          if (!cstdlib_strcmp(v655, "F_SYM_QA_TUNE"))
          {
            cstdlib_atof((unsigned __int8 *)v650);
            *(float *)&v464 = v464;
            *(_DWORD *)(a2 + 11760) = LODWORD(v464);
          }
          if (!cstdlib_strcmp(v655, "N_NODE_LIMIT_TUNE"))
            *(_DWORD *)(a2 + 11764) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_INV_NODE_LIMIT_TUNE"))
            *(_DWORD *)(a2 + 11768) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "N_NODE_PRUNE_MAX_TUNE"))
            *(_DWORD *)(a2 + 11772) = LH_atoi(v650);
          if (!cstdlib_strcmp(v655, "B_MIXEDVOICINGBIGRAMS"))
            *(_DWORD *)(a2 + 5852) = LH_atoi(v650) != 0;
          if (!cstdlib_strcmp(v655, "N_UV_CODE"))
            *(_DWORD *)(a2 + 5856) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "N_UNDERRUN_THRESHOLD"))
            *(_DWORD *)(a2 + 6180) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "N_EARLYEMISSION_MAX_HYPOTHESES"))
            *(_DWORD *)(a2 + 6184) = LH_atou(v650);
          if (!cstdlib_strcmp(v655, "N_EARLYEMISSION_MAX_AMBIGUITY_WINDOW"))
            *(_DWORD *)(a2 + 6188) = LH_atou(v650);
          if ((ChunkData & 0x80000000) != 0)
            break;
          v321 += v322;
          v320 = v654;
        }
        while (v321 < v654);
      }
      goto LABEL_818;
    }
    if (!cstdlib_strcmp(__src, "FEEX"))
    {
LABEL_82:
      v207 = v13;
      v208 = a2;
      v209 = a3;
      v210 = 1;
      goto LABEL_83;
    }
    if (!cstdlib_strcmp(__src, "PCT4"))
    {
      *(_QWORD *)__s2 = 0;
      if (v8)
      {
        v311 = (char *)(v8 + ssftriff_reader_GetPosition(a3) - v643);
        *(_QWORD *)__s2 = v311;
      }
      else
      {
        v481 = ssftriff_reader_GetChunkData(a3, v654, __s2, v30, v31, v32, v33, v34);
        if ((v481 & 0x80000000) != 0)
          return v481;
        v311 = *(char **)__s2;
      }
      v482 = v654;
      v483 = (uint64_t)v13;
      v484 = a3;
      v485 = v632;
      goto LABEL_747;
    }
    if (cstdlib_strcmp(__src, "STM3"))
    {
      if (!cstdlib_strcmp(__src, "CJE5"))
      {
        v486 = *(unsigned __int16 *)(v637 + 516);
        if (v486 <= 0x3F)
        {
          v487 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v486 + 42848), v622, v40, v41, v42, v43, v44);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v487;
            *(_DWORD *)(a2 + 8880) = v487;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "UND4"))
      {
        v490 = *(unsigned __int16 *)(v637 + 516);
        if (v490 <= 0x3F)
        {
          v491 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v490 + 42848), v619, v45, v46, v47, v48, v49);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v491;
            *(_DWORD *)(a2 + 7320) = v491;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "ANNP"))
      {
        v493 = *(unsigned __int16 *)(v637 + 516);
        if (v493 <= 0x3F)
        {
          v494 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v493 + 42848), v617, v50, v51, v52, v53, v54);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v494;
            *(_DWORD *)(a2 + 8280) = v494;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "ANNF"))
      {
        v515 = *(unsigned __int16 *)(v637 + 516);
        if (v515 <= 0x3F)
        {
          v516 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v515 + 42848), v612, v55, v56, v57, v58, v59);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v516;
            *(_DWORD *)(a2 + 10080) = v516;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "BNCV"))
      {
        RiffStringTable = select_bet5_LoadMfsData(a2, a3, 8u, 0, v654, 0, 0, *(unsigned int *)(v637 + 584));
        goto LABEL_748;
      }
      if (!cstdlib_strcmp(__src, "BNCN"))
      {
        v545 = *(unsigned __int16 *)(v637 + 516);
        if (v545 <= 0x3F)
        {
          v546 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v545 + 42848), v609, v60, v61, v62, v63, v64);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v546;
            *(_DWORD *)(a2 + 8064) = v546;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "UIDO"))
      {
        v553 = *(unsigned __int16 *)(v637 + 516);
        if (v553 <= 0x3F)
        {
          v554 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v553 + 42848), v608, v65, v66, v67, v68, v69);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v554;
            *(_DWORD *)(a2 + 9120) = v554;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "EF0L"))
      {
        v556 = *(unsigned __int16 *)(v637 + 516);
        if (v556 <= 0x3F)
        {
          v557 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v556 + 42848), v607, v70, v71, v72, v73, v74);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v557;
            *(_DWORD *)(a2 + 9240) = v557;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "EF0R"))
      {
        v561 = *(unsigned __int16 *)(v637 + 516);
        if (v561 <= 0x3F)
        {
          v562 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v561 + 42848), v606, v75, v76, v77, v78, v79);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v562;
            *(_DWORD *)(a2 + 9264) = v562;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "MIF0"))
      {
        v564 = *(unsigned __int16 *)(v637 + 516);
        if (v564 <= 0x3F)
        {
          v565 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v564 + 42848), v605, v80, v81, v82, v83, v84);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v565;
            *(_DWORD *)(a2 + 9360) = v565;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "FRAD"))
      {
        v566 = *(unsigned __int16 *)(v637 + 516);
        if (v566 <= 0x3F)
        {
          v567 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v566 + 42848), v604, v85, v86, v87, v88, v89);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v567;
            *(_DWORD *)(a2 + 9480) = v567;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "CSLL"))
      {
        v568 = *(unsigned __int16 *)(v637 + 516);
        if (v568 <= 0x3F)
        {
          v569 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v568 + 42848), v603, v90, v91, v92, v93, v94);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v569;
            *(_DWORD *)(a2 + 9600) = v569;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "CINT"))
      {
        v570 = *(unsigned __int16 *)(v637 + 516);
        if (v570 <= 0x3F)
        {
          v571 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v570 + 42848), v602, v95, v96, v97, v98, v99);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v571;
            *(_DWORD *)(a2 + 9720) = v571;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "FUZ5"))
      {
        v572 = *(unsigned __int16 *)(v637 + 516);
        if (v572 <= 0x3F)
        {
          v575 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v572 + 42848), v601, v100, v101, v102, v103, v104);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v575;
            *(_DWORD *)(a2 + 10440) = v575;
          }
          goto LABEL_818;
        }
        goto LABEL_914;
      }
      if (!cstdlib_strcmp(__src, "CSYM"))
      {
        v573 = *(unsigned __int16 *)(v637 + 516);
        if (v573 > 0x3F)
          goto LABEL_133;
        v574 = v654;
        LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v573 + 42848), v600, v105, v106, v107, v108, v109);
        if ((ChunkData & 0x80000000) == 0)
        {
          ++*(_WORD *)(v637 + 516);
          *(_DWORD *)v637 += v574;
          *(_DWORD *)(a2 + 10200) = v574;
        }
LABEL_936:
        v8 = a6;
LABEL_127:
        v13 = a1;
        goto LABEL_818;
      }
      if (!cstdlib_strcmp(__src, "GCR5"))
      {
        v576 = *(unsigned __int16 *)(v637 + 516);
        if (v576 <= 0x3F)
        {
          v577 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v576 + 42848), v599, v110, v111, v112, v113, v114);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v577;
            *(_DWORD *)(a2 + 10560) = v577;
          }
          goto LABEL_936;
        }
LABEL_935:
        LODWORD(ChunkData) = -2065686524;
        goto LABEL_936;
      }
      if (!cstdlib_strcmp(__src, "PHOD"))
      {
        v578 = *(unsigned __int16 *)(v637 + 516);
        if (v578 <= 0x3F)
        {
          v579 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v578 + 42848), v598, v115, v116, v117, v118, v119);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v579;
            *(_DWORD *)(a2 + 9840) = v579;
          }
          goto LABEL_936;
        }
        goto LABEL_935;
      }
      if (!cstdlib_strcmp(__src, "BNFT"))
      {
        v580 = *(unsigned __int16 *)(v637 + 516);
        if (v580 <= 0x3F)
        {
          v581 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v580 + 42848), v597, v120, v121, v122, v123, v124);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v581;
            *(_DWORD *)(a2 + 8400) = v581;
          }
          goto LABEL_936;
        }
        goto LABEL_935;
      }
      if (!cstdlib_strcmp(__src, "LOUD"))
      {
        v582 = *(unsigned __int16 *)(v637 + 516);
        if (v582 <= 0x3F)
        {
          v583 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v582 + 42848), v596, v125, v126, v127, v128, v129);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v583;
            *(_DWORD *)(a2 + 8520) = v583;
          }
          goto LABEL_936;
        }
        goto LABEL_935;
      }
      if (!cstdlib_strcmp(__src, "SYLR"))
      {
        v584 = *(unsigned __int16 *)(v637 + 516);
        if (v584 <= 0x3F)
        {
          v585 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v584 + 42848), v595, v130, v131, v132, v133, v134);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v585;
            *(_DWORD *)(a2 + 8640) = v585;
          }
          goto LABEL_936;
        }
        goto LABEL_935;
      }
      v8 = a6;
      v13 = a1;
      if (!cstdlib_strcmp(__src, "BNFD"))
      {
        v140 = *(unsigned __int16 *)(v637 + 516);
        if (v140 <= 0x3F)
        {
          v141 = v654;
          LODWORD(ChunkData) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v140 + 42848), v594, v135, v136, v137, v138, v139);
          if ((ChunkData & 0x80000000) == 0)
          {
            ++*(_WORD *)(v637 + 516);
            *(_DWORD *)v637 += v141;
            *(_DWORD *)(a2 + 8040) = v141;
          }
          goto LABEL_936;
        }
        goto LABEL_935;
      }
      goto LABEL_815;
    }
    *(_QWORD *)__s2 = 0;
    v470 = *(unsigned __int16 *)(v637 + 516);
    LODWORD(ChunkData) = -2065686524;
    if (v470 <= 0x3F)
    {
      RiffStringTable = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v470 + 42848), __s2, v35, v36, v37, v38, v39);
      if (RiffStringTable < 0)
        goto LABEL_748;
      v471 = ssftriff_reader_GetPosition(a3);
      ++*(_WORD *)(v637 + 516);
      *(_DWORD *)v637 += v654;
      LODWORD(ChunkData) = select_bet5_ParseRiff(v13, a2, a3, 1, a5, *(_QWORD *)__s2, v471);
      ++*(_DWORD *)(a2 + 388);
    }
LABEL_818:
    v529 = ssftriff_reader_CloseChunk(a3);
    if ((int)ChunkData > -1 && v529 < 0)
      LODWORD(ChunkData) = v529;
  }
  while ((ChunkData & 0x80000000) == 0);
  if ((ChunkData & 0x1FFF) == 0x14)
    ChunkData = 0;
  else
    ChunkData = ChunkData;
  if ((ChunkData & 0x80000000) == 0)
    *__dst = 0;
  v586 = *(char **)(a2 + 6464);
  if (v586)
    ParseInternalTagString(v586, a2 + 6488);
  v587 = *(char **)(a2 + 6472);
  if (v587)
    ParseInternalTagString(v587, a2 + 6616);
  v588 = *(char **)(a2 + 6480);
  if (v588)
    ParseInternalTagString(v588, a2 + 6744);
  return ChunkData;
}

uint64_t select_bet5_LoadRiffStringTable(uint64_t a1, uint64_t a2, char *__src, int a4, uint64_t *a5)
{
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  char *v13;
  uint64_t result;
  _BYTE *v15;
  unsigned __int16 __dst;
  unsigned int v17;

  __dst = 0;
  cstdlib_memcpy(&__dst, __src, 2uLL);
  if (__dst)
  {
    v10 = heap_Calloc(*(_QWORD **)(a1 + 8), __dst + 1, 8);
    *a5 = v10;
    if (v10)
    {
      if (__dst)
      {
        v11 = 0;
        v12 = a4 - 2;
        v13 = __src + 2;
        do
        {
          v17 = 0;
          result = ssftriff_reader_ReadStringW(a2, (uint64_t)v13, v12, 0, 0, &v17);
          if ((result & 0x80000000) != 0 && (result & 0x1FFF) != 9)
            break;
          *(_QWORD *)(*a5 + 8 * v11) = heap_Alloc(*(_QWORD *)(a1 + 8), v17);
          v15 = *(_BYTE **)(*a5 + 8 * v11);
          if (!v15)
            return 2229280778;
          result = ssftriff_reader_ReadStringW(a2, (uint64_t)v13, v12, 0, v15, &v17);
          if ((result & 0x80000000) != 0)
            break;
          v13 += v17 + 1;
          v12 -= v17 + 1;
          ++v11;
        }
        while (v11 < __dst);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 2229280778;
    }
  }
  else
  {
    result = 0;
    *a5 = 0;
  }
  return result;
}

uint64_t select_bet5_LoadMfsData(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v12;
  int Position;
  uint64_t result;
  uint64_t v16;
  int v17;
  unint64_t v18;

  v8 = a5;
  v9 = a4;
  if (a6)
  {
    v12 = a7;
    Position = ssftriff_reader_GetPosition(a2);
    result = 0;
    v16 = a1 + 120 * a3 + 24 * v9;
    *(_QWORD *)(v16 + 7072) = a6 + (Position - v12);
    *(_DWORD *)(v16 + 7080) = v8;
  }
  else if ((_DWORD)a8)
  {
    result = 2229280769;
    if (a3 == 8 && !(_DWORD)a4)
    {
      *(_DWORD *)(a1 + 8040) = a5;
      v17 = ssftriff_reader_GetPosition(a2);
      result = 0;
      *(_DWORD *)(a1 + 8044) = v17;
    }
  }
  else
  {
    v18 = *(unsigned __int16 *)(a1 + 43360);
    if (v18 <= 0x3F)
    {
      result = ssftriff_reader_DetachChunkData(a2, (void **)(a1 + 8 * v18 + 42848), (_QWORD *)(a1 + 120 * a3 + 24 * (int)a4 + 7072), a4, a5, 0, a7, a8);
      if ((result & 0x80000000) == 0)
      {
        ++*(_WORD *)(a1 + 43360);
        *(_DWORD *)(a1 + 42844) += v8;
        *(_DWORD *)(a1 + 120 * a3 + 24 * v9 + 7080) = v8;
      }
    }
    else
    {
      return 2229280772;
    }
  }
  return result;
}

uint64_t select_bet5_LoadRiffGenericFeatureMap(uint64_t a1, uint64_t a2, char *__src, unsigned int a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t *v26;
  uint64_t *v27;
  unsigned __int16 v29;
  unsigned int v30;
  unsigned __int16 __dst;
  char __s[256];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v13 = 2229280778;
  __dst = 0;
  cstdlib_memcpy(&__dst, __src, 2uLL);
  v14 = heap_Calloc(*(_QWORD **)(a1 + 8), __dst + 1, 8);
  *a5 = v14;
  if (v14)
  {
    v15 = heap_Calloc(*(_QWORD **)(a1 + 8), __dst + 1, 8);
    *a6 = v15;
    if (v15)
    {
      v16 = heap_Calloc(*(_QWORD **)(a1 + 8), __dst + 1, 8);
      *a7 = v16;
      if (v16)
      {
        if (__dst)
        {
          v26 = a5;
          v27 = a7;
          v17 = 0;
          v18 = 2;
          while (1)
          {
            v29 = 0;
            __s[0] = 0;
            v30 = 256;
            v13 = ssftriff_reader_ReadStringZ(a2, (uint64_t)__src, a4, v18, __s, &v30);
            v19 = v30;
            *(_QWORD *)(*a5 + 8 * v17) = UNICORN__heap_StrDup(*(_QWORD **)(a1 + 8), __s);
            if (!*(_QWORD *)(*a5 + 8 * v17))
              return 2229280778;
            v20 = v19 + v18;
            cstdlib_memcpy(&v29, &__src[v20], 2uLL);
            *(_QWORD *)(*a6 + 8 * v17) = heap_Calloc(*(_QWORD **)(a1 + 8), v29 + 1, 8);
            if (!*(_QWORD *)(*a6 + 8 * v17))
              return 2229280778;
            *(_QWORD *)(*v27 + 8 * v17) = heap_Calloc(*(_QWORD **)(a1 + 8), v29 + 1, 1);
            if (!*(_QWORD *)(*v27 + 8 * v17))
              return 2229280778;
            v18 = v20 + 2;
            if (v29)
            {
              v21 = 0;
              while (1)
              {
                v22 = v18;
                __s[0] = 0;
                v30 = 256;
                v13 = ssftriff_reader_ReadStringZ(a2, (uint64_t)__src, a4, v18, __s, &v30);
                v23 = v30;
                *(_QWORD *)(*(_QWORD *)(*a6 + 8 * v17) + 8 * v21) = UNICORN__heap_StrDup(*(_QWORD **)(a1 + 8), __s);
                if (!*(_QWORD *)(*(_QWORD *)(*a6 + 8 * v17) + 8 * v21))
                  return 2229280778;
                v18 += v23;
                if (++v21 >= (unint64_t)v29)
                {
                  if (v29)
                  {
                    v24 = 0;
                    a5 = v26;
                    do
                    {
                      *(_BYTE *)(*(_QWORD *)(*v27 + 8 * v17) + v24) = __src[v22 + v23 + v24];
                      ++v24;
                    }
                    while (v24 < v29);
                    v18 = v22 + v23 + v24;
                  }
                  else
                  {
                    a5 = v26;
                  }
                  goto LABEL_19;
                }
              }
            }
            a5 = v26;
LABEL_19:
            if (++v17 >= (unint64_t)__dst)
              return v13;
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v13;
}

uint64_t ParseInternalTagString(char *a1, uint64_t a2)
{
  unsigned __int8 *v3;
  char *v4;
  unsigned __int8 v5;
  uint64_t result;

  v3 = (unsigned __int8 *)a1;
  v4 = cstdlib_strchr(a1, 95);
  if (v4)
  {
    v5 = 0;
    do
    {
      *v4 = 0;
      *(_BYTE *)(a2 + v5++) = cstdlib_atoi(v3);
      v3 = (unsigned __int8 *)(v4 + 1);
      v4 = cstdlib_strchr(v4 + 1, 95);
    }
    while (v4);
    v4 = (char *)v5;
  }
  result = cstdlib_atoi(v3);
  v4[a2] = result;
  return result;
}

uint64_t UNICORN__mfs_ParamMap_UnMapSection(uint64_t result)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  for (i = 0; i != 80; i += 16)
  {
    v3 = v1 + i;
    v4 = *(_QWORD *)(v1 + i + 1592);
    if (v4)
    {
      result = brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(v1 + 1072) + 24), *(_QWORD *)(v3 + 1584), v4);
      *(_QWORD *)(v3 + 1592) = 0;
    }
  }
  return result;
}

float mfs_Stub_ParamMap_GetDecodeLF0FromJV(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int *a6, float result)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;
  unsigned int v16;
  float *v17;

  if (*(_QWORD *)(a2 + 2416))
  {
    v12 = *(_QWORD *)(a2 + 568);
    *a6 = 2;
    if (*(_DWORD *)(a3 + 1712) <= 1u)
    {
      v13 = heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)(a3 + 1680), 208);
      *(_QWORD *)(a3 + 1680) = v13;
      if (!v13)
        return result;
      *(_DWORD *)(a3 + 1712) = *a6 + 50;
    }
    if (*(_DWORD *)(v12 + 6764))
    {
      v14 = *(_QWORD *)(a2 + 568);
      if (*(_DWORD *)(v12 + 5984))
        a4 = *(_DWORD *)(*(_QWORD *)(a2 + 848) + 4 * (a4 / *(_DWORD *)(v14 + 5992)))
           + *(_DWORD *)(v14 + 11564) / *(_DWORD *)a2 * (a4 % *(_DWORD *)a2);
      else
        a4 = *(_DWORD *)(*(_QWORD *)(a2 + 848) + 4 * (a4 / *(_DWORD *)(v14 + 5992)));
    }
    v15 = (_WORD *)(*(_QWORD *)(a2 + 2416) + 24 * a4);
    LOWORD(result) = *v15;
    *(float *)&v16 = (float)((float)LODWORD(result) / *(float *)(v12 + 6056)) + *(float *)(v12 + 6016);
    v17 = *(float **)(a3 + 1680);
    *v17 = *(float *)&v16;
    LOWORD(v16) = v15[1];
    result = (float)((float)v16 / *(float *)(v12 + 6056)) + *(float *)(v12 + 6016);
    v17[*a6 - 1] = result;
    *(_QWORD *)(a5 + 16) = v17;
  }
  return result;
}

void UNICORN__mfs_Stub_ParamMap_GetAcousticVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int *a6, float a7)
{
  uint64_t v7;
  int v9;
  unsigned int v13;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  _WORD *v19;
  unsigned int v20;
  float *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int *v25;
  _DWORD *v26;
  int v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  unint64_t v32;
  unsigned __int16 v33;

  v7 = *(_QWORD *)(a2 + 568);
  if ((*(_DWORD *)(v7 + 6772) - 5) >= 0xFFFFFFFE
    && *(_QWORD *)(a3 + 1896)
    && *(_DWORD *)(v7 + 11520) != 3)
  {
    v9 = *(_DWORD *)(v7 + 6800);
    if (v9 == 9 || v9 == 7)
    {
      v13 = a4;
      if (*(_DWORD *)(a2 + 1928))
      {
        mfs_Stub_ParamMap_GetDecodeLF0FromJV(a1, a2, a3, a4, a5, a6, a7);
        return;
      }
      v16 = *a6;
      if (!*a6)
      {
        v33 = 0;
        mfs_GetMessageOffsetAndDur_Frames(a2, a4, 0, &v33);
        v16 = v33;
        *a6 = v33;
      }
      if (*(_DWORD *)(a3 + 1712) < v16)
      {
        v17 = heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)(a3 + 1680), 4 * (int)(v16 + 50));
        *(_QWORD *)(a3 + 1680) = v17;
        if (!v17)
          return;
        *(_DWORD *)(a3 + 1712) = *a6 + 50;
      }
      if (*(_DWORD *)(v7 + 6764))
      {
        v18 = *(_QWORD *)(a2 + 568);
        if (*(_DWORD *)(v7 + 5984))
          v13 = *(_DWORD *)(*(_QWORD *)(a2 + 848) + 4 * (v13 / *(_DWORD *)(v18 + 5992)))
              + *(_DWORD *)(v18 + 11564) / *(_DWORD *)a2 * (v13 % *(_DWORD *)a2);
        else
          v13 = *(_DWORD *)(*(_QWORD *)(a2 + 848) + 4 * (v13 / *(_DWORD *)(v18 + 5992)));
      }
      v19 = (_WORD *)(*(_QWORD *)(a2 + 2416) + 24 * v13);
      LOWORD(a7) = *v19;
      *(float *)&v20 = (float)((float)LODWORD(a7) / *(float *)(v7 + 6056)) + *(float *)(v7 + 6016);
      v21 = *(float **)(a3 + 1680);
      *v21 = *(float *)&v20;
      LOWORD(v20) = v19[1];
      v22 = *a6;
      v23 = (int)v22 - 1;
      v21[v23] = (float)((float)v20 / *(float *)(v7 + 6056)) + *(float *)(v7 + 6016);
      *(_QWORD *)(a5 + 16) = v21;
      if ((int)v22 < 4)
      {
        LODWORD(v24) = 1;
      }
      else
      {
        v24 = v22 >> 1;
        v25 = *(int **)(a3 + 1680);
        v27 = *v25;
        v26 = v25 + 1;
        v28 = v27;
        v29 = v24 - 1;
        do
        {
          *v26++ = v28;
          --v29;
        }
        while (v29);
      }
      if ((int)v24 < (int)v23)
      {
        v30 = *(_QWORD *)(a3 + 1680);
        v31 = (_DWORD *)(v30 + 4 * v24);
        v32 = v23 - (unint64_t)v24;
        do
        {
          *v31++ = *(_DWORD *)(v30 + 4 * v23);
          --v32;
        }
        while (v32);
      }
    }
  }
}

uint64_t mfs_bnfData_Init(int32x2_t *a1, int32x2_t *a2, uint64_t a3)
{
  __int32 v6;
  __int8 *v7;
  unsigned int v8;
  _BOOL4 v9;
  _BOOL4 v10;
  uint64_t result;
  __int32 v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int32x2_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int32 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int32 *v25;
  unsigned __int32 v26;
  unsigned __int32 v27;
  __int32 v28;
  unsigned __int32 v29;
  unsigned __int32 v30;
  int32x2_t v31;
  int v32;
  uint64_t v33;
  int32x2_t v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int32x2_t *v41;
  uint64_t v42;
  int32x2_t v43;
  BOOL v44;
  uint64_t v45;
  _DWORD *v46;
  _DWORD *v47;
  int *v48;
  int v49;
  uint64_t v51;
  unsigned __int32 v52;
  int32x2_t v53;
  int32x2_t v54;
  __int32 v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  int v59;
  int v60;
  int32x2_t v61;
  unsigned int v62;
  _BYTE *v63;
  unsigned int v64;
  int32x2_t v65;
  int32x2_t v66;
  int32x2_t v67;
  int32x2_t v68;
  int32x2_t v69;
  int32x2_t v70;
  int32x2_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  _QWORD *v75;
  __int32 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _BOOL4 v84;

  v6 = a1[844].i32[1];
  a2[241].i32[0] = v6 == 1;
  v7 = (__int8 *)a1[972];
  if (v7)
  {
    a2[242] = (int32x2_t)(v7 + 1);
    a2[241].i8[4] = *v7;
  }
  else
  {
    a2[242] = 0;
  }
  if (v6 != 1)
    return 0;
  v8 = a1[846].i32[1] - 5;
  v9 = v8 < 0xFFFFFFFE;
  if (a1[775].i32[0])
    v10 = a1[774].i32[1] != 0;
  else
    v10 = 0;
  v12 = a1[748].i32[0];
  v13 = a2->i32[0];
  if (v12)
    v14 = a2->i32[0];
  else
    v14 = 1;
  a1[749].i32[0] = v14;
  if (v13 <= 0)
  {
    v15 = 0;
    LODWORD(v18) = 0;
    a2[124].i32[1] = 0;
  }
  else
  {
    v15 = 0;
    v16 = a2[5];
    if (v13 + 2 <= 3)
      v17 = 3;
    else
      v17 = (v13 + 2);
    v18 = v17 - 2;
    v19 = (unsigned int *)(*(_QWORD *)&v16 + 8);
    do
    {
      v21 = *v19++;
      v20 = v21;
      if (v15 <= v21)
        v15 = v20;
      --v18;
    }
    while (v18);
    v22 = 0;
    a2[124].i32[1] = 0;
    v23 = 2;
    do
    {
      v24 = *(unsigned int *)(*(_QWORD *)&v16 + 4 * v23);
      if ((_DWORD)v24)
      {
        v25 = (unsigned __int32 *)(*(_QWORD *)(*(_QWORD *)&a2[97] + 8 * v23) + 44);
        do
        {
          v27 = *v25;
          v25 += 10;
          v26 = v27;
          if (v22 <= v27)
            v22 = v26;
          LODWORD(v18) = v26 + v18;
          --v24;
        }
        while (v24);
        a2[124].i32[1] = v22;
      }
      ++v23;
    }
    while (v23 != v17);
  }
  v28 = a1[1444].i32[1];
  if (!v28)
  {
    a1[1444].i32[1] = v18;
    v29 = a1[1443].i32[1] - v18;
    a1[1445].i32[0] = v29;
    goto LABEL_34;
  }
  if ((_DWORD)v18 == v28)
  {
    v29 = a1[1445].u32[0];
LABEL_34:
    v30 = v29 + v18;
    a1[1445].i32[1] = v30;
    v31 = a1[1107];
    a2[106] = v31;
    if (!*(_QWORD *)&v31)
      goto LABEL_117;
    if (v29)
      v32 = 2;
    else
      v32 = 1;
    v44 = v12 == 0;
    a2[106] = (int32x2_t)(*(_QWORD *)&v31 + 4);
    v33 = v32 + v15;
    v34 = a2[71];
    v35 = *(_DWORD *)(*(_QWORD *)&v34 + 5992);
    v36 = v29 / v35;
    if (v44)
      v37 = v36 + 1;
    else
      v37 = v36;
    a2[124].i32[0] = v30 / v35;
    a2[107].i32[0] = v33;
    if (v13 >= 1)
    {
      v84 = v10;
      v38 = 0;
      v39 = 2;
      while (1)
      {
        v40 = *(_DWORD *)(*(_QWORD *)&a2[71] + 5984);
        v41 = &a2[v39];
        v41[106] = (int32x2_t)heap_Calloc(*(_QWORD **)(a3 + 8), v33, 4);
        v42 = heap_Calloc(*(_QWORD **)(a3 + 8), v33, 4);
        v41[114] = (int32x2_t)v42;
        v43 = v41[106];
        v44 = !*(_QWORD *)&v43 || v42 == 0;
        if (v44)
          goto LABEL_117;
        if (v40)
          v38 = 0;
        v45 = *(unsigned int *)(*(_QWORD *)&a2[5] + 4 * v39);
        if ((_DWORD)v45)
        {
          v46 = (_DWORD *)(*(_QWORD *)&v43 + 4);
          v47 = (_DWORD *)(v42 + 4);
          v48 = (int *)(*(_QWORD *)(*(_QWORD *)&a2[97] + 8 * v39) + 44);
          do
          {
            v49 = *v48;
            v48 += 10;
            *v47++ = v37 + v38;
            *v46++ = v49;
            v38 += v49;
            --v45;
          }
          while (v45);
        }
        if (v39++ > a2->i32[0])
        {
          v34 = a2[71];
          v14 = a1[749].u32[0];
          v10 = v84;
          v9 = v8 < 0xFFFFFFFE;
          break;
        }
      }
    }
    v51 = heap_Calloc(*(_QWORD **)(a3 + 8), 2 * ((*(_DWORD *)(*(_QWORD *)&v34 + 11548) + 1) / v14), 4);
    a2[133] = (int32x2_t)v51;
    if (!v51)
    {
LABEL_117:
      result = 2229280778;
      goto LABEL_118;
    }
    if (a1[1443].i32[1])
    {
      v52 = 0;
      v53 = a2[106];
      v54 = a2[71];
      v55 = a1[749].i32[0];
      do
      {
        v56 = *(_DWORD *)(*(_QWORD *)&v54 + 5992);
        if ((int)(v52 - v55) < 0)
          v57 = 0;
        else
          v57 = *(_DWORD *)(*(_QWORD *)&v53 + 4 * ((v52 - v55) / v56));
        v58 = v52 + v55;
        if (v58 >= *(_DWORD *)(*(_QWORD *)&v54 + 11548) + 1)
          v59 = 0;
        else
          v59 = *(_DWORD *)(*(_QWORD *)&v53 + 4 * (v58 / v56));
        v60 = *(_DWORD *)(*(_QWORD *)&v53 + 4 * (v52 / v56));
        *(_DWORD *)(v51 + 4 * (2 * v60)) = v57;
        *(_DWORD *)(v51 + 4 * ((2 * v60) | 1u)) = v59;
        v55 = a1[749].i32[0];
        v52 += v55;
      }
      while (v52 < a1[1443].i32[1]);
    }
    v61 = a1[975];
    if (*(_QWORD *)&v61 && (a2[126] = (int32x2_t)(*(_QWORD *)&v61 + 16), v62 = a1[976].i32[0] - 16, v62 > 3))
    {
      v63 = (_BYTE *)a1[972];
      if (!v63)
      {
        v64 = v62 >> 2;
        LODWORD(v63) = a1[841].i32[1];
LABEL_73:
        a2[190].i32[1] = 1;
        a2[125] = 0;
        v65 = vadd_s32(a1[973], (int32x2_t)0x10FFFFFFF0);
        a2[191] = vrev64_s32(v65);
        if (!(_DWORD)v63)
        {
          if (v64 <= 1)
            LODWORD(v63) = 1;
          else
            LODWORD(v63) = v64;
          LOBYTE(v63) = v65.i32[0] / v63;
        }
        goto LABEL_78;
      }
    }
    else
    {
      v63 = (_BYTE *)a1[972];
      if (!v63)
      {
        LODWORD(v63) = a1[841].i32[1];
        if (!(_DWORD)v63)
        {
          result = 2229280785;
          goto LABEL_118;
        }
        v64 = 0;
        goto LABEL_73;
      }
    }
    a2[190].i32[1] = 0;
    a2[125] = (int32x2_t)(v63 + 16);
    a2[191] = 0;
    LOBYTE(v63) = *v63;
LABEL_78:
    a2[190].i8[0] = (char)v63;
    v66 = a1[1122];
    if (v66)
      a2[127] = (int32x2_t)(*(_QWORD *)&v66 + 16);
    v67 = a1[1125];
    if (v67)
      a2[128] = (int32x2_t)(*(_QWORD *)&v67 + 16);
    v68 = a1[1152];
    if (v68)
      a2[129] = (int32x2_t)(*(_QWORD *)&v68 + 16);
    if (v10)
    {
      v69 = a1[1167];
      if (v69)
        a2[130] = (int32x2_t)(*(_QWORD *)&v69 + 16);
    }
    v70 = a1[1182];
    if (v70)
      a2[131] = (int32x2_t)(*(_QWORD *)&v70 + 16);
    if (v8 <= 0xFFFFFFFD)
    {
      v71 = a1[1137];
      if (v71)
        a2[132] = (int32x2_t)(*(_QWORD *)&v71 + 16);
    }
    if (a2->i32[0] < 1)
    {
      result = 0;
      goto LABEL_118;
    }
    v72 = 0;
    v73 = a2[107].u32[0];
    v74 = (uint64_t *)&a2[134];
    while (1)
    {
      v75 = *(_QWORD **)(a3 + 8);
      if (a2[190].i32[1])
        v74[58] = heap_Calloc(v75, v73, 4);
      else
        *v74 = heap_Calloc(v75, v73, 8);
      v76 = a2[190].i32[1];
      if (v76 == 1)
      {
        if (!v74[58])
          goto LABEL_117;
      }
      else if (!v76 && !*v74)
      {
        goto LABEL_117;
      }
      if (a2[126])
      {
        v77 = heap_Calloc(*(_QWORD **)(a3 + 8), v73, 8);
        v74[8] = v77;
        if (!v77)
          goto LABEL_117;
      }
      if (a2[127])
      {
        v78 = heap_Calloc(*(_QWORD **)(a3 + 8), v73, 8);
        v74[16] = v78;
        if (!v78)
          goto LABEL_117;
      }
      if (a2[128])
      {
        v79 = heap_Calloc(*(_QWORD **)(a3 + 8), v73, 8);
        v74[24] = v79;
        if (!v79)
          goto LABEL_117;
      }
      if (a2[129])
      {
        v80 = heap_Calloc(*(_QWORD **)(a3 + 8), v73, 8);
        v74[32] = v80;
        if (!v80)
          goto LABEL_117;
      }
      if (a2[130])
      {
        v81 = heap_Calloc(*(_QWORD **)(a3 + 8), v73, 8);
        v74[40] = v81;
        if (!v81)
          goto LABEL_117;
      }
      if (v8 <= 0xFFFFFFFD)
      {
        if (a2[132])
        {
          v82 = heap_Calloc(*(_QWORD **)(a3 + 8), v73, 8);
          v74[48] = v82;
          if (!v82)
            goto LABEL_117;
        }
      }
      v83 = v72 + 2;
      initClusterData((uint64_t)a2, (uint64_t)a1, v72 + 2, v9, v10);
      result = 0;
      ++v72;
      ++v74;
      if (v83 > a2->i32[0])
        goto LABEL_118;
    }
  }
  result = 2229280768;
LABEL_118:
  a2[241].i8[4] = a2[190].i8[0];
  return result;
}

uint64_t initClusterData(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v5 = *(unsigned int *)(*(_QWORD *)(result + 40) + 4 * a3);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = a3 - 2;
    v8 = (_QWORD *)(result + 8 * v7);
    v9 = v8 + 116;
    v10 = v8 + 192;
    v11 = v8 + 134;
    v12 = v8 + 142;
    v13 = v8 + 150;
    v14 = v8 + 158;
    v15 = v8 + 166;
    v16 = v8 + 174;
    v17 = v8 + 182;
    do
    {
      v18 = *(_DWORD *)(a2 + 5984);
      if (v18)
        v18 = *(_DWORD *)(*(_QWORD *)(result + 568) + 11564) / *(_DWORD *)result * v7;
      v19 = *(unsigned int *)(*v9 + 4 * v6 + 4);
      if (*(_DWORD *)(result + 1524))
        *(_DWORD *)(*v10 + 4 * v6 + 4) = v19 * *(unsigned __int8 *)(result + 1520);
      else
        *(_QWORD *)(*v11 + 8 * v6 + 8) = *(_QWORD *)(result + 1000)
                                       + v19 * *(unsigned __int8 *)(result + 1520);
      v20 = *(_QWORD *)(result + 1008);
      if (v20)
        *(_QWORD *)(*v12 + 8 * v6 + 8) = v20 + 4 * v19;
      v21 = v18 + v19;
      v22 = *(_QWORD *)(result + 1016);
      if (v22)
        *(_QWORD *)(*v13 + 8 * v6 + 8) = v22 + 2 * v21;
      v23 = *(_QWORD *)(result + 1024);
      if (v23)
        *(_QWORD *)(*v14 + 8 * v6 + 8) = v23 + 2 * v21;
      v24 = *(_QWORD *)(result + 1032);
      if (v24)
        *(_QWORD *)(*v15 + 8 * v6 + 8) = v24 + v21;
      if (a5)
      {
        v25 = *(_QWORD *)(result + 1040);
        if (v25)
          *(_QWORD *)(*v16 + 8 * v6 + 8) = v25 + v21;
      }
      if (a4)
      {
        v26 = *(_QWORD *)(result + 1056);
        if (v26)
          *(_QWORD *)(*v17 + 8 * v6 + 8) = v26 + 2 * v21;
      }
      ++v6;
    }
    while (v5 != v6);
  }
  return result;
}

_QWORD *mfs_bnfData_DeInit(_QWORD *result, uint64_t a2)
{
  int *v2;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = (int *)result;
  if (*((_DWORD *)result + 482) == 1)
  {
    if (*(int *)result >= 1)
    {
      v4 = result + 108;
      v5 = 1;
      do
      {
        v6 = v4[84];
        if (v6)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v6);
          v4[84] = 0;
        }
        v7 = v4[26];
        if (v7)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v7);
          v4[26] = 0;
        }
        v8 = v4[34];
        if (v8)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v8);
          v4[34] = 0;
        }
        v9 = v4[42];
        if (v9)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v9);
          v4[42] = 0;
        }
        v10 = v4[50];
        if (v10)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v10);
          v4[50] = 0;
        }
        v11 = v4[58];
        if (v11)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v11);
          v4[58] = 0;
        }
        v12 = v4[66];
        if (v12)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v12);
          v4[66] = 0;
        }
        if (*v4)
        {
          heap_Free(*(_QWORD **)(a2 + 8), *v4);
          *v4 = 0;
        }
        v13 = v4[8];
        if (v13)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v13);
          v4[8] = 0;
        }
        v14 = v4[74];
        if (v14)
        {
          heap_Free(*(_QWORD **)(a2 + 8), v14);
          v4[74] = 0;
        }
        ++v5;
        ++v4;
      }
      while (v5 <= *v2);
    }
    return heap_Free(*(_QWORD **)(a2 + 8), *((_QWORD *)v2 + 133));
  }
  else
  {
    *((_BYTE *)result + 1932) = 0;
    result[242] = 0;
  }
  return result;
}

float mfs_bnfData_sse(float *a1, float *a2, unsigned int a3)
{
  uint64_t v3;
  float result;
  float v5;
  float v6;
  float v7;

  if (!a3)
    return 0.0;
  v3 = a3;
  result = 0.0;
  do
  {
    v5 = *a1++;
    v6 = v5;
    v7 = *a2++;
    result = result + (float)((float)(v6 - v7) * (float)(v6 - v7));
    --v3;
  }
  while (v3);
  return result;
}

char *mfs_bnfData_Delta(char *result, char *a2, unsigned int a3, _BYTE *a4)
{
  uint64_t v4;
  char v5;
  char v6;
  char v7;

  if (a3)
  {
    v4 = a3;
    do
    {
      v6 = *result++;
      v5 = v6;
      v7 = *a2++;
      *a4++ = v5 - v7;
      --v4;
    }
    while (v4);
  }
  return result;
}

float mfs_bnfData_Delta_flt(float *a1, float *a2, unsigned int a3, float *a4)
{
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  float result;

  if (a3)
  {
    v4 = a3;
    do
    {
      v5 = *a1++;
      v6 = v5;
      v7 = *a2++;
      result = v6 - v7;
      *a4++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

char *mfs_bnfData_Delta_norm(char *result, char *a2, unsigned int a3, float *a4)
{
  uint64_t v4;
  float v5;
  uint64_t v6;
  char *v7;
  char *v8;
  float v9;
  int v10;
  float v11;
  int v12;
  float v13;
  float v14;
  int v15;
  float v16;
  int v17;

  if (a3)
  {
    v4 = a3;
    v5 = 0.0;
    v6 = a3;
    v7 = a2;
    v8 = result;
    v9 = 0.0;
    do
    {
      v10 = *v8++;
      v11 = (float)(v10 * v10);
      v12 = *v7++;
      v9 = v9 + v11;
      v5 = v5 + (float)(v12 * v12);
      --v6;
    }
    while (v6);
    v13 = sqrtf(v9);
    v14 = sqrtf(v5);
    do
    {
      v15 = *result++;
      v16 = (float)v15;
      v17 = *a2++;
      *a4++ = (float)(v16 / v13) - (float)((float)v17 / v14);
      --v4;
    }
    while (v4);
  }
  return result;
}

float mfs_bnfData_CosineCost(char *a1, char *a2, unsigned int a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  float v10;
  float v11;
  float v12;

  if (a3)
  {
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = a3;
    do
    {
      v8 = *a1++;
      v7 = v8;
      v9 = *a2++;
      v5 += v9 * v7;
      v4 += v7 * v7;
      v3 += v9 * v9;
      --v6;
    }
    while (v6);
    v10 = (float)v5;
    v11 = (float)v4;
    v12 = (float)v3;
  }
  else
  {
    v10 = 0.0;
    v11 = 0.0;
    v12 = 0.0;
  }
  return 1.0 - (float)(v10 / (float)(sqrtf(v11) * sqrtf(v12)));
}

float mfs_bnfData_CosineCost_LeftSidedPreNormalised(float *a1, char *a2, unsigned int a3)
{
  uint64_t v3;
  float v4;
  float v5;
  int v6;
  int v7;
  float v8;
  float v9;

  if (a3)
  {
    v3 = a3;
    v4 = 0.0;
    v5 = 0.0;
    do
    {
      v7 = *a2++;
      v6 = v7;
      v8 = (float)v7;
      v9 = *a1++;
      v5 = v5 + (float)(v8 * v9);
      v4 = v4 + (float)(v6 * v6);
      --v3;
    }
    while (v3);
  }
  else
  {
    v5 = 0.0;
    v4 = 0.0;
  }
  return 1.0 - (float)(v5 / sqrtf(v4));
}

float mfs_bnfData_CosineCost_Normalised(float *a1, float *a2, unsigned int a3)
{
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  float v7;

  if (a3)
  {
    v3 = a3;
    v4 = 0.0;
    do
    {
      v5 = *a2++;
      v6 = v5;
      v7 = *a1++;
      v4 = v4 + (float)(v6 * v7);
      --v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0.0;
  }
  return 1.0 - v4;
}

float mfs_bnfData_CosineCost_F32(float *a1, float *a2, unsigned int a3)
{
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;

  if (a3)
  {
    v3 = a3;
    v4 = 0.0;
    v5 = 0.0;
    v6 = 0.0;
    do
    {
      v7 = *a1++;
      v8 = v7;
      v9 = *a2++;
      v6 = v6 + (float)(v8 * v9);
      v5 = v5 + (float)(v8 * v8);
      v4 = v4 + (float)(v9 * v9);
      --v3;
    }
    while (v3);
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v4 = 0.0;
  }
  return 1.0 - (float)(v6 / (float)(sqrtf(v5) * sqrtf(v4)));
}

float mfs_bnfData_Distance(uint64_t a1, float *a2, unsigned int a3)
{
  uint64_t v3;
  char *v4;
  float v5;
  float v6;
  int v7;
  int v8;
  float v9;
  float v10;
  float result;
  uint64_t v12;

  v3 = *(unsigned __int8 *)(a1 + 1932);
  if (*(_BYTE *)(a1 + 1932))
  {
    v4 = (char *)(*(_QWORD *)(a1 + 1936) + v3 * a3);
    v5 = 0.0;
    v6 = 0.0;
    do
    {
      v8 = *v4++;
      v7 = v8;
      v9 = (float)v8;
      v10 = *a2++;
      v6 = v6 + (float)(v9 * v10);
      v5 = v5 + (float)(v7 * v7);
      --v3;
    }
    while (v3);
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
  }
  result = 1.0 - (float)(v6 / sqrtf(v5));
  v12 = *(_QWORD *)(a1 + 1904);
  if (v12)
    return result * *(float *)(v12 + 4 * a3);
  return result;
}

uint64_t mfs_bnfData_Clusterize_Block_Distance_fxd16(uint64_t a1, uint64_t a2, __int16 *a3, unsigned int a4, int a5, uint64_t a6, float a7)
{
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  __int16 *v28;
  char *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v34;
  uint64_t v35;

  v35 = 0;
  v11 = a5 - 2;
  v12 = *(unsigned __int8 *)(a1 + 1520);
  v13 = (_QWORD *)(a1 + 8 * v11);
  v14 = a4;
  v15 = *(unsigned int *)(v13[108] + 4 * a4);
  if (*(_DWORD *)(a1 + 1524) != 1)
  {
    v21 = 0;
    v35 = *(_QWORD *)(v13[134] + 8 * a4);
    if (!(_DWORD)v15)
      goto LABEL_11;
LABEL_6:
    v22 = 0;
    v23 = 0;
    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 8 * v11 + 1136) + 8 * v14);
    v25 = v35;
    do
    {
      v26 = 0;
      if ((_DWORD)v12)
      {
        v27 = v12;
        v28 = a3;
        v29 = (char *)(v25 + v22);
        do
        {
          v31 = *v29++;
          v30 = v31;
          v32 = *v28++;
          v26 += v32 * v30;
          --v27;
        }
        while (v27);
      }
      *(float *)(a6 + 4 * v23) = (float)((float)-(float)(*(float *)(v24 + 4 * v23) * (float)v26) * a7) + 1.0;
      ++v23;
      v22 += v12;
    }
    while (v23 != v15);
    goto LABEL_11;
  }
  v34 = a2;
  v21 = brk_DataMap(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 2464), (*(_DWORD *)(v13[192] + 4 * a4) + *(_DWORD *)(a1 + 1528)), (v15 * v12), (uint64_t)&v35);
  if ((v21 & 0x80000000) != 0)
  {
    UNICORN__log_select_Error(v34, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v16, v17, v18, v19, v20);
    return v21;
  }
  a2 = v34;
  if ((_DWORD)v15)
    goto LABEL_6;
LABEL_11:
  if (*(_DWORD *)(a1 + 1524) == 1)
    return brk_DataUnmap(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 2464), v35);
  return v21;
}

uint64_t mfs_bnfData_Clusterize_Block_Distance_RandomProjection(uint64_t a1, uint64_t a2, char *a3, unsigned int a4, int a5, uint64_t a6)
{
  unint64_t v10;
  float v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  unsigned int v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char v29;
  char v30;
  char v31;
  unint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v43 = 0;
  v10 = *(unsigned __int8 *)(a1 + 1520);
  if (*(_BYTE *)(a1 + 1520))
    v11 = 3.1416 / (float)((float)v10 * 8.0);
  else
    v11 = 0.3927;
  v12 = (_QWORD *)(a1 + 8 * (a5 - 2));
  v13 = *(unsigned int *)(v12[108] + 4 * a4);
  if (*(_DWORD *)(a1 + 1524) != 1)
  {
    v40 = 0;
    v41 = a1;
    v39 = a2;
    v43 = *(_QWORD *)(v12[134] + 8 * a4);
    if (!(_DWORD)v13)
      goto LABEL_21;
    goto LABEL_9;
  }
  v14 = brk_DataMap(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 2464), (*(_DWORD *)(v12[192] + 4 * a4) + *(_DWORD *)(a1 + 1528)), (v13 * v10), (uint64_t)&v43);
  v20 = v14;
  if ((v14 & 0x80000000) != 0)
  {
    UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v15, v16, v17, v18, v19);
    return v20;
  }
  v40 = v14;
  v41 = a1;
  v39 = a2;
  if ((_DWORD)v13)
  {
LABEL_9:
    v21 = 0;
    v22 = 0;
    v23 = v43;
    v42 = v43 + 1;
    v24 = a3 + 1;
    do
    {
      if ((v10 & 3) != 0)
      {
        if ((_DWORD)v10)
        {
          v25 = 0;
          v26 = v10;
          v27 = a3;
          v28 = (char *)(v23 + v21);
          do
          {
            v30 = *v27++;
            v29 = v30;
            v31 = *v28++;
            v25 += BitsSetTable256[(v31 ^ v29)];
            --v26;
          }
          while (v26);
          goto LABEL_20;
        }
      }
      else if ((_DWORD)v10)
      {
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v37 = v42 + v21;
        do
        {
          v36 += BitsSetTable256[(*(_BYTE *)(v37 + v32 - 1) ^ a3[v32])];
          v35 += BitsSetTable256[*(_BYTE *)(v37 + v32) ^ v24[v32]];
          v34 += BitsSetTable256[*(_BYTE *)(v37 + v32 + 1) ^ v24[v32 + 1]];
          v33 += BitsSetTable256[*(_BYTE *)(v37 + v32 + 2) ^ v24[v32 + 2]];
          v32 += 4;
        }
        while (v32 < v10);
        v25 = v35 + v36 + v34 + v33;
        goto LABEL_20;
      }
      v25 = 0;
LABEL_20:
      *(float *)(a6 + 4 * v22++) = 1.0 - cosf(v11 * (float)v25);
      v21 += v10;
    }
    while (v22 != v13);
  }
LABEL_21:
  v20 = v40;
  if (*(_DWORD *)(v41 + 1524) == 1)
    return brk_DataUnmap(*(_QWORD *)(v39 + 24), *(_QWORD *)(v41 + 2464), v43);
  return v20;
}

uint64_t mfs_bnfData_Distance_Unit_ID_fxd16(uint64_t result, uint64_t a2, __int16 *a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char *v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;

  v6 = result;
  v19 = 0;
  v7 = *(unsigned __int8 *)(result + 1520);
  if (*(_DWORD *)(result + 1524) == 1)
  {
    result = brk_DataMap(*(_QWORD *)(a2 + 24), *(_QWORD *)(result + 2464), (*(_DWORD *)(result + 1528)+ *(_DWORD *)(*(_QWORD *)(result + 848)+ 4 * (a4 / *(_DWORD *)(*(_QWORD *)(result + 568) + 5992)))* v7), v7, (uint64_t)&v19);
    if ((result & 0x80000000) != 0)
      return UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v8, v9, v10, v11, v12);
    v13 = v19;
  }
  else
  {
    v13 = *(_QWORD *)(result + 1000)
        + (*(_DWORD *)(*(_QWORD *)(result + 848)
                                   + 4 * (a4 / *(_DWORD *)(*(_QWORD *)(result + 568) + 5992)))
                       * v7);
    v19 = v13;
  }
  if ((_DWORD)v7)
  {
    v14 = 0;
    v15 = (char *)v13;
    do
    {
      v17 = *v15++;
      v16 = v17;
      v18 = *a3++;
      v14 += v18 * v16;
      --v7;
    }
    while (v7);
  }
  if (*(_DWORD *)(v6 + 1524) == 1)
    return brk_DataUnmap(*(_QWORD *)(a2 + 24), *(_QWORD *)(v6 + 2464), v13);
  return result;
}

void mfs_bnfData_Distance_Unit_ID_RandomProjection(uint64_t a1, uint64_t a2, char *a3, unsigned int a4)
{
  unint64_t v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  char *v16;
  char v17;
  char v18;
  char v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;

  v7 = *(unsigned __int8 *)(a1 + 1520);
  v27 = 0;
  if ((_DWORD)v7)
    v8 = 3.1416 / (float)((float)v7 * 8.0);
  else
    v8 = 0.3927;
  if (*(_DWORD *)(a1 + 1524) == 1)
  {
    if ((brk_DataMap(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 2464), (*(_DWORD *)(a1 + 1528)+ *(_DWORD *)(*(_QWORD *)(a1 + 848) + 4 * (a4 / *(_DWORD *)(*(_QWORD *)(a1 + 568) + 5992)))* v7), v7, (uint64_t)&v27) & 0x80000000) != 0)
    {
      UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v9, v10, v11, v12, v13);
      return;
    }
    v14 = v27;
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 1000)
        + (*(_DWORD *)(*(_QWORD *)(a1 + 848) + 4 * (a4 / *(_DWORD *)(*(_QWORD *)(a1 + 568) + 5992)))
                       * v7);
    v27 = v14;
  }
  if ((v7 & 3) != 0)
  {
    if ((_DWORD)v7)
    {
      v15 = 0;
      v16 = (char *)v14;
      do
      {
        v18 = *a3++;
        v17 = v18;
        v19 = *v16++;
        v15 += BitsSetTable256[(v19 ^ v17)];
        --v7;
      }
      while (v7);
      goto LABEL_18;
    }
  }
  else if ((_DWORD)v7)
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = v14 + 1;
    v26 = a3 + 1;
    do
    {
      v24 += BitsSetTable256[(*(_BYTE *)(v14 + v20) ^ a3[v20])];
      v23 += BitsSetTable256[*(_BYTE *)(v25 + v20) ^ v26[v20]];
      v22 += BitsSetTable256[*(_BYTE *)(v25 + v20 + 1) ^ v26[v20 + 1]];
      v21 += BitsSetTable256[*(_BYTE *)(v25 + v20 + 2) ^ v26[v20 + 2]];
      v20 += 4;
    }
    while (v20 < v7);
    v15 = v23 + v24 + v22 + v21;
    goto LABEL_18;
  }
  v15 = 0;
LABEL_18:
  cosf(v8 * (float)v15);
  if (*(_DWORD *)(a1 + 1524) == 1)
    brk_DataUnmap(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 2464), v14);
}

uint64_t clamp_u32(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;

  if (a1 >= a3)
    v3 = a3;
  else
    v3 = a1;
  if (a1 >= a2)
    return v3;
  else
    return a2;
}

uint64_t clamp_s32(signed int a1, unsigned int a2, signed int a3)
{
  unsigned int v3;

  if (a1 >= a3)
    v3 = a3;
  else
    v3 = a1;
  if (a1 >= (int)a2)
    return v3;
  else
    return a2;
}

uint64_t UNICORN__redistributeInjectDur(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int *v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  BOOL v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int v44;

  v10 = UNICORN__mfs_SegmentList_Length(a1 + 1552);
  if (*a2 != 3)
    return 2229280775;
  if (v10 >= 7)
  {
    v11 = 0;
    v12 = *(_DWORD *)(a3 + 24);
    v13 = 4 * v12;
    v14 = 3 * v12;
    v15 = (unsigned int *)(a5 + 16);
    v16 = (_DWORD *)(a4 + 196);
    v17 = 28 * (v10 - 3) - 84;
    v18 = 3;
    do
    {
      v19 = *a2;
      v20 = (*a2 & 1) == 0 || v19 < 2;
      v21 = (*a2 - 1) >> 1;
      if (v20)
        v21 = (*a2 >> 1) - 1;
      if (v18 != v21 + (int)v18 / *a2 * v19)
        goto LABEL_48;
      if (*(v16 - 11) == 1 && !*(v16 - 21))
      {
        v22 = *(v15 - 2);
        v23 = *(_QWORD *)(a1 + 1568);
        v24 = *(_DWORD *)(v23 + v11 + 68);
        v25 = v22 - v24;
        if (v22 > v24)
        {
          if (v25 >= 0)
            v26 = v22 - v24;
          else
            v26 = v25 + 1;
          v27 = v26 >> 1;
          if (v25 >= v13)
            v25 = v27;
          *(v15 - 1) += v25;
          v28 = v22 - v25;
          goto LABEL_19;
        }
        if (v22 < v24)
        {
          v29 = __OFSUB__(v24, v22);
          v30 = v24 - v22;
          if (v30 < 0 != v29)
            v31 = v30 + 1;
          else
            v31 = v30;
          v32 = v31 >> 1;
          if (v30 >= v13)
            v30 = v32;
          if (*(_DWORD *)(v23 + v11 + 96) > v14)
          {
            v33 = *(v15 - 1);
            if (v25 + v33 > v14)
            {
              *(v15 - 1) = v33 - v30;
              v28 = v22 + v30;
LABEL_19:
              *(v15 - 2) = v28;
            }
          }
        }
      }
      if (*(v16 - 10) == 1 && !*v16)
      {
        v34 = *v15;
        v35 = *(_QWORD *)(a1 + 1568);
        v36 = *(_DWORD *)(v35 + v11 + 124);
        v37 = *v15 - v36;
        if (*v15 <= v36)
        {
          if (v34 >= v36)
            goto LABEL_48;
          v29 = __OFSUB__(v36, v34);
          v41 = v36 - v34;
          if (v41 < 0 != v29)
            v42 = v41 + 1;
          else
            v42 = v41;
          v43 = v42 >> 1;
          if (v41 >= v13)
            v41 = v43;
          if (*(_DWORD *)(v35 + v11 + 96) <= v14)
            goto LABEL_48;
          v44 = *(v15 - 1);
          if (v37 + v44 <= v14)
            goto LABEL_48;
          *(v15 - 1) = v44 - v41;
          v40 = v34 + v41;
        }
        else
        {
          if (v37 >= 0)
            v38 = *v15 - v36;
          else
            v38 = v37 + 1;
          v39 = v38 >> 1;
          if (v37 >= v13)
            v37 = v39;
          *(v15 - 1) += v37;
          v40 = v34 - v37;
        }
        *v15 = v40;
      }
LABEL_48:
      ++v15;
      v16 += 10;
      v11 += 28;
      ++v18;
    }
    while (v17 != v11);
  }
  return 0;
}

uint64_t mfs_Psola_CalculateAdjustments_ByOne(int *a1, uint64_t a2, uint64_t a3, int a4, int a5, int *a6)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  int v19;
  int v20;
  _DWORD *v21;
  _BOOL4 v22;
  int v23;
  uint64_t v24;
  _DWORD *v25;
  int *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  unsigned int *v35;
  _DWORD *v36;
  int v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  int v41;
  int *v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  float *v50;
  float v51;
  int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  _DWORD *v64;
  uint64_t v65;
  int v66;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  _DWORD *v75;
  unint64_t v77;
  int *v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  int v83;
  uint64_t v84;
  int v86;
  BOOL v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int *v93;
  int v94;
  uint64_t v95;
  int v96;
  unsigned int *v97;
  unsigned int v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  uint64_t v102;

  v11 = (uint64_t)a1;
  v102 = *MEMORY[0x24BDAC8D0];
  v12 = *a1;
  v13 = *(_QWORD *)(a2 + 1568);
  v14 = a4;
  v15 = *(_QWORD *)(a2 + 1536);
  v16 = (unsigned int *)(a3 + 40 * a4);
  if (a4 <= 0)
    v17 = 0;
  else
    v17 = (unsigned int *)(a3 + 40 * (a4 - 1));
  v18 = *(_DWORD *)(v13 + 28 * a4);
  v97 = v16;
  *v16 = v18;
  if (v18 == -1)
  {
    v19 = 0;
  }
  else
  {
    v19 = *(_DWORD *)(v13 + 28 * a4 + 8);
    v15 = v13;
  }
  v20 = *(_DWORD *)(v15 + 28 * a4 + 12);
  v21 = (_DWORD *)(a3 + 40 * a4);
  v21[1] = v19;
  v21[2] = v20;
  v21[5] = 1000;
  if (!a4)
  {
    v46 = a3 + 40 * a4;
    *(_DWORD *)(v46 + 32) = 0;
    *(_DWORD *)(v46 + 12) = 1000;
    goto LABEL_97;
  }
  v96 = v12;
  v22 = *v17 + 1 == v18;
  if (*v17 + 1 == v18)
    v23 = 1;
  else
    v23 = 100;
  v24 = a3 + 40 * a4;
  *(_DWORD *)(v24 + 32) = v22;
  v25 = (_DWORD *)(v24 + 32);
  v17[9] = v22;
  *(v25 - 2) = v23;
  v17[7] = v23;
  *(v25 - 5) = 1000;
  v26 = v25 - 5;
  v17[4] = 1000;
  v27 = UnicornAddon_UID2AddonId(*(_QWORD *)(a2 + 1776), *(_DWORD *)(a2 + 1784), v18);
  v28 = *(_QWORD *)(a2 + 1776);
  v29 = v11;
  if (v27 != -1)
  {
    v30 = v28 + 48 * v27;
    v29 = *(_QWORD *)(v30 + 16);
    *v97 -= *(_DWORD *)(v30 + 24);
  }
  v95 = v29;
  v94 = v27;
  v31 = UnicornAddon_UID2AddonId(v28, *(_DWORD *)(a2 + 1784), *v17);
  if (v31 != -1)
  {
    v32 = *(_QWORD *)(a2 + 1776) + 48 * v31;
    v11 = *(_QWORD *)(v32 + 16);
    *v17 -= *(_DWORD *)(v32 + 24);
  }
  v33 = v96;
  v34 = a4 / v96;
  v35 = (unsigned int *)v95;
  v36 = *(_DWORD **)(v95 + 568);
  v37 = v36[2880];
  if ((v37 - 1) <= 1 && !*v25 && *v17 != -1)
  {
    v47 = *v97;
    if (*v97 != -1)
    {
      v91 = v31;
      v92 = a5;
      v101 = 0;
      v99 = 0u;
      v100 = 0u;
      v98 = 0;
      UNICORN__mfs_Stub_ParamMap_GetAcousticVector(*(_QWORD *)(a2 + 1072), v95, a2, v47, (uint64_t)&v99, (int *)&v98, 0.0);
      v93 = a6;
      if (v48 < 0 || (v49 = v98, (int)v98 < 1))
      {
LABEL_32:
        v52 = 1000;
      }
      else
      {
        v50 = (float *)v100;
        while (1)
        {
          v51 = exp(*v50);
          v52 = (int)(v51 + 0.5);
          if (v52 >= 10)
            break;
          ++v50;
          if (!--v49)
            goto LABEL_32;
        }
      }
      v53 = *v17;
      v101 = 0;
      v99 = 0u;
      v100 = 0u;
      v98 = 0;
      UNICORN__mfs_Stub_ParamMap_GetAcousticVector(*(_QWORD *)(a2 + 1072), v11, a2, v53, (uint64_t)&v99, (int *)&v98, 0.0);
      if (v54 < 0 || (v55 = v98, (int)v98 < 1))
      {
LABEL_38:
        v59 = 1000;
        v60 = 1000;
        a6 = v93;
        v31 = v91;
        a5 = v92;
        v33 = v96;
        v34 = a4 / v96;
        v35 = (unsigned int *)v95;
      }
      else
      {
        v56 = v100;
        while (1)
        {
          v57 = exp(*(float *)(v56 + 4 * ((int)v55 - 1)));
          v58 = (int)(v57 + 0.5);
          if (v58 > 9)
            break;
          if (!--v55)
            goto LABEL_38;
        }
        v59 = 1000;
        a6 = v93;
        v31 = v91;
        a5 = v92;
        v33 = v96;
        v34 = a4 / v96;
        v35 = (unsigned int *)v95;
        v60 = 1000;
        if (v52 != 1000 && v58 != 1000)
        {
          v89 = v52 + v58;
          if (v52 + v58 < 0 != __OFADD__(v52, v58))
            ++v89;
          v90 = 1000 * (v89 >> 1);
          v59 = v90 / v52;
          v60 = v90 / v58;
        }
      }
      *v26 = v59;
      v17[4] = v60;
      v36 = (_DWORD *)*((_QWORD *)v35 + 71);
      v37 = v36[2880];
    }
  }
  v38 = a4 - v34 * v33;
  if ((v37 & 0xFFFFFFFE) == 2)
  {
    if (v38 + 1 == v33)
    {
      v39 = *v35;
      v40 = (int)*v35 * (uint64_t)v34;
      if ((int)*v35 < 1)
        goto LABEL_40;
      v41 = 0;
      v42 = (int *)(a3 + 40 * v40 + 8);
      v43 = *v35;
      do
      {
        v44 = *v42;
        v42 += 10;
        v41 += v44;
        --v43;
      }
      while (v43);
      if (v41 < 1)
LABEL_40:
        v45 = 1000;
      else
        v45 = (int)(float)((float)(*(float *)(*(_QWORD *)(a2 + 384) + 312 * v34 + 32) * 1000.0) / (float)v41);
      if (*(_DWORD *)(a3 + 40 * v40) + (_DWORD)v39 - 1 != *(_DWORD *)(a3 + 40 * ((int)v39 - 1 + (int)v40)))
      {
        if ((int)v39 < 1)
          goto LABEL_58;
        v61 = v36[6];
        if (*(_DWORD *)(a3 + 40 * v40 + 8) == v61)
        {
LABEL_44:
          if (v45 >= 1300)
            v45 = 1300;
          if (v45 <= 700)
            v45 = 700;
        }
        else
        {
          v77 = 0;
          v78 = (int *)(a3 + 40 * v40 + 48);
          while (v39 - 1 != v77)
          {
            v79 = *v78;
            v78 += 10;
            ++v77;
            if (v79 == v61)
            {
              if (v77 < v39)
                goto LABEL_44;
              break;
            }
          }
        }
      }
      v62 = v36[2886];
      if (v45 < v62)
        v62 = v45;
      if (v45 >= v36[2885])
        v63 = v62;
      else
        v63 = v36[2885];
      if ((int)v39 >= 1)
      {
        v64 = (_DWORD *)(a3 + 40 * v40);
        do
        {
          if (*v64 != -1)
            v64[5] = v63;
          v64 += 10;
          --v39;
        }
        while (v39);
      }
    }
LABEL_58:
    if (v38 && a4 + 1 != a5)
      goto LABEL_61;
  }
  *a6 = a4;
LABEL_61:
  v65 = *(_QWORD *)(a2 + 8);
  if (*(_BYTE *)(*(_QWORD *)(v65 + 32) + v34) == 1 && v38 == v33 - 1 && v33 - 1 <= a4)
  {
    v66 = v34 | *(unsigned __int16 *)(*(_QWORD *)(v65 + 1784) + 2 * v34);
    if ((int)*(float *)(*(_QWORD *)(a2 + 384) + 312 * v34 + 32) > 50 && v66 == 0)
      v68 = 50;
    else
      v68 = (int)*(float *)(*(_QWORD *)(a2 + 384) + 312 * v34 + 32);
    v69 = v14 - v38;
    if (v33 == 2 && *(_DWORD *)(a3 + 40 * (int)v69) == -1 && (v70 = (int)v69 + 1, *(_DWORD *)(a3 + 40 * v70) == -1))
    {
      v86 = v36[6];
      *(_DWORD *)(a3 + 40 * (int)v69 + 8) = v86;
      v87 = __OFSUB__(v68, v86);
      v88 = v68 - v86;
      if ((v88 < 0) ^ v87 | (v88 == 0))
        *(_DWORD *)(a3 + 40 * v70 + 8) = 0;
      else
        *(_DWORD *)(a3 + 40 * v70 + 8) = v88;
    }
    else
    {
      v71 = v69 + 1;
      if (*(_DWORD *)(a3 + 40 * (v69 + 1)) == -1)
      {
        v72 = v31;
        v73 = a5;
        if (v33 < 1)
        {
          v74 = 0;
        }
        else
        {
          v74 = 0;
          v69 = (int)v69;
          v75 = (_DWORD *)(40 * (int)v14 - 40 * v38 + a3 + 8);
          do
          {
            if (v71 != v69)
              v74 += *v75;
            v75 += 10;
          }
          while (v69++ < v14);
        }
        if (v68 <= v74)
          v80 = 0;
        else
          v80 = v68 - v74;
        v81 = a3 + 40 * v71;
        UNICORN__log_select_Diag(*(_QWORD *)(a2 + 1072), 2, (uint64_t)"PSOLA: changing dead unit duration from %d to %d ms");
        *(_DWORD *)(v81 + 8) = v80;
        a5 = v73;
        v31 = v72;
      }
    }
  }
  if (v94 == -1)
    v82 = 0;
  else
    v82 = *(_DWORD *)(*(_QWORD *)(a2 + 1776) + 48 * v94 + 24);
  *v97 += v82;
  if (v31 == -1)
    v83 = 0;
  else
    v83 = *(_DWORD *)(*(_QWORD *)(a2 + 1776) + 48 * v31 + 24);
  *v17 += v83;
LABEL_97:
  if (a4 + 1 >= a5)
  {
    v84 = a3 + 40 * (int)v14;
    *(_DWORD *)(v84 + 36) = 0;
    *(_DWORD *)(v84 + 16) = 1000;
    *a6 = a5;
  }
  return 0;
}

uint64_t UnicornSearch_StageTwo_TreeIndex_Cascaded(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t updated;
  uint64_t v8;
  uint64_t v9;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  uint64_t BnfTargetVectorPacked;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  float v34;
  unsigned int v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int *v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  uint64_t *v48;
  float v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int v54;
  uint64_t v55;
  int v56;
  float v57;
  float v58;
  _QWORD *v59;
  uint64_t v60;
  _DWORD *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int *v64;
  int v65;
  uint64_t v66;
  unint64_t v67;
  float v68;
  uint64_t *v69;
  uint64_t v70;
  int v71;
  unsigned int *v72;
  int v73;
  uint64_t v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  uint64_t v80;
  float v81;
  float v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  float v86;
  int v87;
  uint64_t v88;
  uint64_t *v89;
  unsigned int v90;
  float v91;
  uint64_t *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  unsigned int v96;
  uint64_t v97;
  int v98;
  float v99;
  float v100;
  _DWORD *v101;
  float v102;
  unsigned int v103;
  uint64_t v104;
  unsigned int *v105;
  unsigned int v106;
  _QWORD *v107;
  uint64_t v108;
  _DWORD *v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  float v115;
  uint64_t v116;
  unsigned int *v117;
  int v118;
  uint64_t v119;
  float v120;
  float v121;
  float v122;
  float v123;
  _QWORD *v124;
  uint64_t v125;
  _DWORD *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  unsigned int *v130;
  unsigned int v131;
  uint64_t v132;
  unint64_t v133;
  float v134;
  uint64_t *v135;
  uint64_t v136;
  unsigned int *v137;
  float v138;
  float v139;
  float v140;
  uint64_t v141;
  unint64_t v142;
  _DWORD *v143;
  unsigned int v144;
  uint64_t v145;
  signed int v146;
  float v147;
  char v148;
  int v149;
  float v150;
  float *v151;
  unint64_t v152;
  float v153;
  int v154;
  unsigned int v156;
  uint64_t v158;
  unint64_t v159;
  unsigned int *v160;
  unsigned int v161;
  uint64_t v162;
  unint64_t v163;
  uint64_t v164;
  int v165;
  float v166;
  float v167;
  unsigned int v168;
  BOOL v169;
  uint64_t v170;
  unint64_t v171;
  unsigned int *v172;
  unsigned int v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  int v177;
  float v178;
  float v179;
  uint64_t v180;
  unsigned int *v181;
  unsigned int *v182;
  unsigned int *v183;
  unsigned int v184;
  uint64_t v185;
  uint64_t *v186;
  uint64_t *v187;
  unsigned int v188;
  _DWORD *v189;
  unsigned int *v190;
  BOOL v191;
  uint64_t v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  __int128 __b;
  __int128 v197;
  __int128 v198;
  _OWORD v199[2];
  __int128 v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  uint64_t v204;

  v204 = *MEMORY[0x24BDAC8D0];
  memset(v199, 0, sizeof(v199));
  v197 = 0u;
  v198 = 0u;
  __b = 0u;
  v2 = a2 + *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 92);
  v3 = v2 - 2;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 16);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v3))
  {
    updated = 0;
    *(_DWORD *)(*(_QWORD *)(v4 + 32 * v3) + 4) = 0;
    return updated;
  }
  v8 = *(_QWORD *)(a1 + 112);
  v9 = *(_QWORD *)(a1 + 120);
  v200 = *(_OWORD *)(v8 + 6640);
  __asm { FMOV            V1.2S, #1.0 }
  v201 = *(_QWORD *)(v8 + 6656);
  v202 = _D1;
  v203 = 1065353216;
  cstdlib_memset(&__b, 0, 0x50uLL);
  v14 = *(_QWORD *)(v9 + 1768);
  v15 = !v14 || !*(_DWORD *)(v14 + 16) && !*(_DWORD *)(v14 + 12);
  v16 = *(_QWORD *)(a1 + 112);
  if (*(int *)(v16 + 6752) > 1)
    return 2229280769;
  v191 = v15;
  v17 = *(_DWORD *)(a1 + 92);
  v18 = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 280) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 16) + 4 * a2);
  if (*(float *)(v16 + 6704) == 0.0)
  {
    updated = 0;
  }
  else
  {
    updated = mfs_UpdateTargetQuantizedTrajectory_LF0(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 120), a1 + 176);
    if ((updated & 0x80000000) != 0)
      return updated;
  }
  v19 = *(_QWORD *)(a1 + 336);
  if (v19)
  {
    v20 = (a2 + v18 * v17 - 2);
    mfs_TCost_Elf0_Manhattan_TreeIndex(*(float **)(a1 + 112), *(_QWORD *)(a1 + 120), (uint64_t *)(*(_QWORD *)(a1 + 120) + 1088), v20, a1 + 176, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 64) + 4 * a2), a2, *(unsigned __int8 *)(a1 + 345) == 1, *(float *)(v19 + 4 * (2 * v20)), *(float *)(v19 + 4 * ((2 * (_DWORD)v20) | 1u)));
  }
  if (!*(_BYTE *)(a1 + 156) && *(_BYTE *)(a1 + 345) == 1)
  {
    v21 = 4295000000.0;
    goto LABEL_160;
  }
  v193 = updated;
  v192 = v9;
  v188 = *(_DWORD *)(a1 + 100);
  v22 = *(_DWORD *)(a1 + 380);
  v24 = *(_QWORD *)(a1 + 112);
  v23 = *(_QWORD *)(a1 + 120);
  v25 = *(int **)(v23 + 1096);
  v26 = *v25;
  cstdlib_memset(&__b, 0, 0x50uLL);
  if (v25[482] == 1)
  {
    *(_QWORD *)((char *)&v199[1] + 4) = __PAIR64__(v22, v188);
    LODWORD(v199[1]) = 0;
    if (v22)
    {
      if ((_DWORD)a2 == 2)
      {
        HIDWORD(v199[0]) = 1;
      }
      else
      {
        v27 = v26 + 1 == (_DWORD)a2 ? 0x200000002 : 0x100000004;
        *(_QWORD *)((char *)v199 + 12) = v27;
      }
    }
    else
    {
      HIDWORD(v199[0]) = 0;
    }
    *(_QWORD *)&__b = GetBnfTargetVectorPacked(v23, v3 / *(_DWORD *)(v24 + 5992), (float *)&v198 + 2);
    if (*(int *)(v24 + 6752) >= 1)
    {
      if (v2 != 2)
      {
        if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * (v2 - 3)))
          BnfTargetVectorPacked = 0;
        else
          BnfTargetVectorPacked = GetBnfTargetVectorPacked(v23, (v2 - 3) / *(_DWORD *)(v24 + 5992), (float *)&v198 + 3);
        *((_QWORD *)&__b + 1) = BnfTargetVectorPacked;
      }
      v29 = (v2 - 1) / *(_DWORD *)(v24 + 5992);
      if (v29 < v188)
      {
        if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * (v2 - 1)))
          v30 = 0;
        else
          v30 = GetBnfTargetVectorPacked(v23, v29, (float *)v199);
        *(_QWORD *)&v197 = v30;
      }
      if (*(int *)(v24 + 6752) >= 2)
      {
        if (v3 >= 2)
        {
          if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * (v2 - 4)))
            v31 = 0;
          else
            v31 = GetBnfTargetVectorPacked(v23, (v2 - 4) / *(_DWORD *)(v24 + 5992), (float *)v199 + 1);
          *((_QWORD *)&v197 + 1) = v31;
        }
        v32 = v2 / *(_DWORD *)(v24 + 5992);
        if (v32 < v188)
        {
          if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v2))
            v33 = 0;
          else
            v33 = GetBnfTargetVectorPacked(v23, v32, (float *)v199 + 2);
          *(_QWORD *)&v198 = v33;
        }
      }
    }
  }
  v34 = *((float *)&v200 + LODWORD(v199[1])) * (float)*(int *)(*(_QWORD *)(a1 + 112) + 5564);
  v35 = (int)v34;
  v36 = v4 + 32 * v3;
  v38 = *(_DWORD *)(v36 + 16);
  v37 = (_DWORD *)(v36 + 16);
  v39 = v193;
  if (v38 > (int)v34)
  {
    v39 = mfs_CostList_Select(*(_QWORD *)(a1 + 136), v2 - 2, 1, (int)v34);
    v40 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 16) + 32 * v3;
    v42 = *(_DWORD *)(v40 + 16);
    v41 = (unsigned int *)(v40 + 16);
    if (v42 > v35)
      *v41 = v35;
  }
  if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(v192 + 1072) + 32)) >= 3)
    *(_DWORD *)(v192 + 1956) += *v37;
  v194 = v39;
  v189 = v37;
  if (HIDWORD(v199[0]) == 4)
  {
    v59 = *(_QWORD **)(a1 + 120);
    v60 = v59[137];
    if (*(_DWORD *)(v60 + 1928) != 1)
      goto LABEL_117;
    v61 = *(_DWORD **)(a1 + 112);
    if (!v61[1688])
      goto LABEL_117;
    v62 = v59[138];
    v63 = v62 + 32 * v3;
    v65 = *(_DWORD *)(v63 + 16);
    v64 = (unsigned int *)(v63 + 16);
    if (!v65)
      goto LABEL_117;
    v66 = 0;
    v67 = 0;
    v68 = 1.0 - *(float *)(v59[169] + 4 * v3);
    v69 = (uint64_t *)(v62 + 32 * v3);
    v70 = *v69;
    v21 = 4295000000.0;
    v182 = v64;
    v185 = v59[137];
    while (1)
    {
      v71 = v61[1496];
      v72 = (unsigned int *)(v71
                           ? v70 + v66 + 8
                           : *(_QWORD *)(v60 + 1064) + 4 * (2 * *(_DWORD *)(v70 + v66 + 8)));
      v73 = *(_DWORD *)(v70 + v66);
      v74 = *v72;
      if (!*((_QWORD *)&__b + 1))
        break;
      v75 = *(float *)(v59[164] + 4);
      if (((*(_DWORD *)(v59[144] + 4 * (((v73 - 1) / v61[1498]) >> 5)) >> ((v73 - 1) / v61[1498])) & 1) == 0)
      {
        v79 = (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v185, *(_QWORD *)(a1 + 56), *((float *)&v198 + 3));
        v64 = v182;
        v60 = v185;
        v76 = (float)(v75 * v79) + 0.0;
        if (v61[1496])
          goto LABEL_86;
LABEL_85:
        v74 = *(unsigned int *)(*(_QWORD *)(v60 + 1064) + 4 * ((2 * *(_DWORD *)(*v69 + v66 + 8)) | 1u));
        goto LABEL_86;
      }
      v76 = (float)(v75 * *(float *)(v59[145] + 4 * v74)) + 0.0;
      if (!v71)
        goto LABEL_85;
LABEL_86:
      if ((_QWORD)v197)
      {
        v77 = *(float *)(v59[164] + 8);
        if (((*(_DWORD *)(v59[144] + 4 * (((v73 + 1) / v61[1498]) >> 5)) >> ((v73 + 1) / v61[1498])) & 1) != 0)
        {
          v78 = *(float *)(v59[145] + 4 * v74);
        }
        else
        {
          (*(void (**)(uint64_t, _QWORD, float))(a1 + 392))(v185, *(_QWORD *)(a1 + 56), *(float *)v199);
          v64 = v182;
          v60 = v185;
        }
        v76 = v76 + (float)(v77 * v78);
      }
      v70 = *v69;
      v80 = *v69 + v66;
      v81 = *(float *)(v80 + 4);
      v82 = (float)(v68 * v76) + v81;
      *(float *)(v80 + 4) = v82;
      if (v82 < v21)
        v21 = (float)(v68 * v76) + v81;
      ++v67;
      v66 += 12;
      if (v67 >= *v64)
        goto LABEL_118;
    }
    v76 = 0.0;
    if (v71)
      goto LABEL_86;
    goto LABEL_85;
  }
  if (HIDWORD(v199[0]) != 2)
  {
    if (HIDWORD(v199[0]) == 1)
    {
      v43 = *(_QWORD *)(a1 + 120);
      v44 = *(_QWORD *)(v43 + 1096);
      if (*(_DWORD *)(v44 + 1928) == 1)
      {
        v45 = *(_QWORD *)(a1 + 112);
        if (*(_DWORD *)(v45 + 6752))
        {
          if (*((_QWORD *)&__b + 1))
          {
            v46 = 1.0 - *(float *)(*(_QWORD *)(v43 + 1352) + 4 * v3);
            v47 = *(_QWORD *)(v43 + 1104);
            v48 = (uint64_t *)(v47 + 32 * v3);
            v49 = 0.0;
            if (*(_DWORD *)v44 > v3
              || *(_DWORD *)(v43 + 1120) != v3 / *(_DWORD *)v44 - 1
              || !*(_QWORD *)(v43 + 1128)
              || !*(_QWORD *)(v43 + 1136))
            {
              goto LABEL_186;
            }
            v49 = *(float *)(v45 + 6004);
            v50 = v47 + 32 * v3;
            v51 = *(unsigned int *)(v50 + 16);
            v181 = (unsigned int *)(v50 + 16);
            if (*(_DWORD *)(v50 + 16))
            {
              v52 = 0;
              v53 = 0;
              v54 = 0;
              v55 = *v48;
              do
              {
                v56 = *(_DWORD *)(v55 + v52);
                if (v56 >= 1)
                {
                  if (((*(_DWORD *)(*(_QWORD *)(v43 + 1128) + 4 * (((v56 - 1) / *(_DWORD *)(v45 + 5992)) >> 5)) >> ((v56 - 1) / *(_DWORD *)(v45 + 5992))) & 1) != 0)
                  {
                    ++v54;
                    *(float *)(v55 + v52 + 4) = *(float *)(v55 + v52 + 4)
                                              + (float)(v46
                                                      * (float)(*(float *)(*(_QWORD *)(v43 + 1312) + 4)
                                                              * *(float *)(*(_QWORD *)(v43 + 1136)
                                                                         + 4
                                                                         * *(unsigned int *)(*(_QWORD *)(v44 + 1064)
                                                                                           + 4
                                                                                           * (2 * *(_DWORD *)(v55 + v52 + 8))))));
                  }
                  else if (*(_DWORD *)(v45 + 6000))
                  {
                    *(float *)(v55 + v52 + 4) = v49 + *(float *)(v55 + v52 + 4);
                  }
                  else
                  {
                    v57 = *(float *)(*(_QWORD *)(v43 + 1312) + 4);
                    v184 = v54;
                    v58 = (*(float (**)(uint64_t, _QWORD, _QWORD, float))(a1 + 392))(v44, *(_QWORD *)(a1 + 56), *((_QWORD *)&__b + 1), *((float *)&v198 + 3));
                    v54 = v184;
                    v55 = *v48;
                    *(float *)(*v48 + v52 + 4) = *(float *)(*v48 + v52 + 4) + (float)(v46 * (float)(v57 * v58));
                    v51 = *v181;
                  }
                }
                ++v53;
                v52 += 12;
              }
              while (v53 < v51);
            }
            else
            {
              v54 = 0;
            }
            v156 = *(_DWORD *)(v45 + 6000);
            if (v156 && v54 < v156)
            {
LABEL_186:
              v158 = v47 + 32 * v3;
              v161 = *(_DWORD *)(v158 + 16);
              v160 = (unsigned int *)(v158 + 16);
              v159 = v161;
              if (v161)
              {
                v162 = 0;
                v163 = 0;
                v164 = *v48;
                do
                {
                  v165 = *(_DWORD *)(v164 + v162);
                  if (v165 >= 1)
                  {
                    v166 = *(float *)(*(_QWORD *)(v43 + 1312) + 4);
                    v167 = (*(float (**)(uint64_t, _QWORD, _QWORD, _QWORD, float))(a1 + 392))(v44, *(_QWORD *)(a1 + 56), *((_QWORD *)&__b + 1), (v165 - 1), *((float *)&v198 + 3));
                    v164 = *v48;
                    *(float *)(*v48 + v162 + 4) = (float)(v46 * (float)(v166 * v167))
                                                + (float)(*(float *)(*v48 + v162 + 4) - v49);
                    v159 = *v160;
                  }
                  ++v163;
                  v162 += 12;
                  v21 = 4295000000.0;
                }
                while (v163 < v159);
                goto LABEL_118;
              }
            }
          }
        }
      }
    }
    else
    {
      UnicornSearch_TreeIndex_InnerDefault_Cascaded(a1, (_QWORD *)(*(_QWORD *)(a1 + 120) + 1088), v2 - 2, (uint64_t)&__b);
    }
LABEL_117:
    v21 = 4295000000.0;
    goto LABEL_118;
  }
  v83 = *(_QWORD *)(a1 + 120);
  v84 = *(_QWORD *)(v83 + 1096);
  if (*(_DWORD *)(v84 + 1928) != 1)
    goto LABEL_117;
  v85 = *(_QWORD *)(a1 + 112);
  if (!*(_DWORD *)(v85 + 6752) || !(_QWORD)v197)
    goto LABEL_117;
  v86 = 1.0 - *(float *)(*(_QWORD *)(v83 + 1352) + 4 * v3);
  v87 = *(_DWORD *)(*(_QWORD *)(v84 + 568) + 11548) - 1;
  v88 = *(_QWORD *)(v83 + 1104);
  v89 = (uint64_t *)(v88 + 32 * v3);
  v90 = v3 / *(_DWORD *)v84 + 1;
  v91 = 0.0;
  if (v90 < *(_DWORD *)(a1 + 88)
    && *(_DWORD *)(v83 + 1168) == v90
    && *(_QWORD *)(v83 + 1176)
    && *(_QWORD *)(v83 + 1184))
  {
    v91 = *(float *)(v85 + 6004);
    v180 = *(_QWORD *)(v83 + 1104);
    v92 = (uint64_t *)(v88 + 32 * v3);
    v93 = *((unsigned int *)v92 + 4);
    v183 = (unsigned int *)(v92 + 2);
    v186 = v92;
    if (*((_DWORD *)v92 + 4))
    {
      v94 = 0;
      v95 = 0;
      v96 = 0;
      v97 = *v92;
      do
      {
        v98 = *(_DWORD *)(v97 + v94);
        if (v98 < v87)
        {
          if (((*(_DWORD *)(*(_QWORD *)(v83 + 1176) + 4 * (((v98 + 1) / *(_DWORD *)(v85 + 5992)) >> 5)) >> ((v98 + 1) / *(_DWORD *)(v85 + 5992))) & 1) != 0)
          {
            ++v96;
            *(float *)(v97 + v94 + 4) = *(float *)(v97 + v94 + 4)
                                      + (float)(v86
                                              * (float)(*(float *)(*(_QWORD *)(v83 + 1312) + 8)
                                                      * *(float *)(*(_QWORD *)(v83 + 1184)
                                                                 + 4
                                                                 * *(unsigned int *)(*(_QWORD *)(v84 + 1064)
                                                                                   + 4
                                                                                   * ((2 * *(_DWORD *)(v97 + v94 + 8)) | 1u)))));
          }
          else if (*(_DWORD *)(v85 + 6000))
          {
            *(float *)(v97 + v94 + 4) = v91 + *(float *)(v97 + v94 + 4);
          }
          else
          {
            v99 = *(float *)(*(_QWORD *)(v83 + 1312) + 8);
            v100 = (*(float (**)(uint64_t, _QWORD, _QWORD, float))(a1 + 392))(v84, *(_QWORD *)(a1 + 56), v197, *(float *)v199);
            v97 = *v186;
            *(float *)(*v186 + v94 + 4) = *(float *)(*v186 + v94 + 4) + (float)(v86 * (float)(v99 * v100));
            v93 = *v183;
          }
        }
        ++v95;
        v94 += 12;
      }
      while (v95 < v93);
    }
    else
    {
      v96 = 0;
    }
    v168 = *(_DWORD *)(v85 + 6000);
    v169 = !v168 || v96 >= v168;
    v89 = v186;
    v88 = v180;
    if (v169)
      goto LABEL_117;
  }
  v170 = v88 + 32 * v3;
  v173 = *(_DWORD *)(v170 + 16);
  v172 = (unsigned int *)(v170 + 16);
  v171 = v173;
  if (!v173)
    goto LABEL_117;
  v174 = 0;
  v175 = 0;
  v176 = *v89;
  do
  {
    v177 = *(_DWORD *)(v176 + v174);
    if (v177 < v87)
    {
      v178 = *(float *)(*(_QWORD *)(v83 + 1312) + 8);
      v179 = (*(float (**)(uint64_t, _QWORD, _QWORD, _QWORD, float))(a1 + 392))(v84, *(_QWORD *)(a1 + 56), v197, (v177 + 1), *(float *)v199);
      v176 = *v89;
      *(float *)(*v89 + v174 + 4) = (float)(v86 * (float)(v178 * v179)) + (float)(*(float *)(*v89 + v174 + 4) - v91);
      v171 = *v172;
    }
    ++v175;
    v174 += 12;
    v21 = 4295000000.0;
  }
  while (v175 < v171);
LABEL_118:
  if (HIDWORD(v199[0]) == 4)
  {
    v9 = v192;
    updated = v194;
    v101 = v189;
  }
  else
  {
    v102 = *((float *)&v200 + LODWORD(v199[1]) + 3) * (float)*(int *)(*(_QWORD *)(a1 + 112) + 5564);
    v103 = (int)v102;
    v101 = v189;
    v9 = v192;
    updated = v194;
    if (*v189 > (int)v102)
    {
      updated = mfs_CostList_Select(*(_QWORD *)(a1 + 136), v3, 1, (int)v102);
      v104 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 16) + 32 * v3;
      v106 = *(_DWORD *)(v104 + 16);
      v105 = (unsigned int *)(v104 + 16);
      if (v106 > v103)
        *v105 = v103;
    }
  }
  if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(v9 + 1072) + 32)) >= 3)
    *(_DWORD *)(v9 + 1960) += *v101;
  if (HIDWORD(v199[0]) == 4)
    goto LABEL_160;
  if (HIDWORD(v199[0]) == 2)
  {
    v124 = *(_QWORD **)(a1 + 120);
    v125 = v124[137];
    if (*(_DWORD *)(v125 + 1928) != 1)
      goto LABEL_160;
    v126 = *(_DWORD **)(a1 + 112);
    if (!v126[1688] || !*((_QWORD *)&__b + 1))
      goto LABEL_160;
    v195 = updated;
    v127 = v124[138];
    v128 = v127 + 32 * v3;
    v131 = *(_DWORD *)(v128 + 16);
    v130 = (unsigned int *)(v128 + 16);
    v129 = v131;
    if (!v131)
      goto LABEL_158;
    v132 = 0;
    v133 = 0;
    v134 = 1.0 - *(float *)(v124[169] + 4 * v3);
    v135 = (uint64_t *)(v127 + 32 * v3);
    v136 = *v135;
    do
    {
      if (v126[1496])
        v137 = (unsigned int *)(v136 + v132 + 8);
      else
        v137 = (unsigned int *)(*(_QWORD *)(v125 + 1064) + 4 * (2 * *(_DWORD *)(v136 + v132 + 8)));
      if (((*(_DWORD *)(v124[144] + 4 * (((*(_DWORD *)(v136 + v132) - 1) / v126[1498]) >> 5)) >> ((*(_DWORD *)(v136 + v132) - 1) / v126[1498])) & 1) != 0)
      {
        v138 = *(float *)(v124[164] + 4) * *(float *)(v124[145] + 4 * *v137);
      }
      else
      {
        v139 = *(float *)(v124[164] + 4);
        v138 = v139
             * (*(float (**)(uint64_t, _QWORD, _QWORD, float))(a1 + 392))(v125, *(_QWORD *)(a1 + 56), *((_QWORD *)&__b + 1), *((float *)&v198 + 3));
        v136 = *v135;
        v129 = *v130;
      }
      v140 = (float)(v134 * v138) + *(float *)(v136 + v132 + 4);
      *(float *)(v136 + v132 + 4) = v140;
      if (v140 < v21)
        v21 = v140;
      ++v133;
      v132 += 12;
    }
    while (v133 < v129);
    goto LABEL_157;
  }
  if (HIDWORD(v199[0]) != 1)
  {
    UnicornSearch_TreeIndex_InnerDefault_Cascaded(a1, (_QWORD *)(*(_QWORD *)(a1 + 120) + 1088), v3, (uint64_t)&__b);
    goto LABEL_160;
  }
  v107 = *(_QWORD **)(a1 + 120);
  v108 = v107[137];
  if (*(_DWORD *)(v108 + 1928) == 1)
  {
    v195 = updated;
    v109 = *(_DWORD **)(a1 + 112);
    if (!v109[1688])
      goto LABEL_158;
    if (!(_QWORD)v197)
      goto LABEL_158;
    v110 = v107[138];
    v111 = v110 + 32 * v3;
    v112 = *(unsigned int *)(v111 + 16);
    v190 = (unsigned int *)(v111 + 16);
    if (!*(_DWORD *)(v111 + 16))
      goto LABEL_158;
    v113 = 0;
    v114 = 0;
    v115 = 1.0 - *(float *)(v107[169] + 4 * v3);
    v187 = (uint64_t *)(v110 + 32 * v3);
    v116 = *v187;
    do
    {
      if (v109[1496])
        v117 = (unsigned int *)(v116 + v113 + 8);
      else
        v117 = (unsigned int *)(*(_QWORD *)(v108 + 1064) + 4 * ((2 * *(_DWORD *)(v116 + v113 + 8)) | 1u));
      v118 = *(_DWORD *)(v116 + v113) + 1;
      v119 = *v117;
      if (((*(_DWORD *)(v107[144] + 4 * ((v118 / v109[1498]) >> 5)) >> (v118 / v109[1498])) & 1) != 0)
      {
        v120 = *(float *)(v107[164] + 8) * *(float *)(v107[145] + 4 * v119);
      }
      else
      {
        v121 = (*(float (**)(uint64_t, _QWORD, _QWORD, _QWORD, float))(a1 + 392))(v108, *(_QWORD *)(a1 + 56), v197, (*(_DWORD *)(v116 + v113) + 1), *(float *)v199);
        v122 = *(float *)(v107[164] + 8);
        *(_DWORD *)(v107[144] + 4 * ((v118 / v109[1498]) >> 5)) |= 1 << (v118 / v109[1498]);
        v120 = v121 * v122;
        *(float *)(v107[145] + 4 * v119) = v121;
        v116 = *v187;
        v112 = *v190;
      }
      v123 = (float)(v115 * v120) + *(float *)(v116 + v113 + 4);
      *(float *)(v116 + v113 + 4) = v123;
      if (v123 < v21)
        v21 = v123;
      ++v114;
      v113 += 12;
    }
    while (v114 < v112);
LABEL_157:
    v9 = v192;
LABEL_158:
    updated = v195;
  }
LABEL_160:
  v141 = v4 + 32 * v3;
  v144 = *(_DWORD *)(v141 + 16);
  v143 = (_DWORD *)(v141 + 16);
  v142 = v144;
  v145 = *(_QWORD *)(a1 + 112);
  v146 = (int)(float)*(int *)(v145 + 5564);
  v147 = *(float *)(v145 + 6636);
  v148 = !v191;
  if (v147 <= 0.0)
    v148 = 1;
  if ((v148 & 1) == 0)
  {
    v149 = 0;
    if ((_DWORD)v142 && v146 >= 1)
    {
      v149 = 0;
      v150 = v21 + v147;
      v151 = (float *)(*(_QWORD *)(v4 + 32 * v3) + 4);
      v152 = 1;
      do
      {
        v153 = *v151;
        v151 += 3;
        if (v153 < v150)
          ++v149;
        if (v152 >= v142)
          break;
        ++v152;
      }
      while (v149 < v146);
    }
    if (v149 >= v146)
      v149 = (int)(float)*(int *)(v145 + 5564);
    v154 = (int)(float)*(int *)(v145 + 6632);
    if (v149 <= v154)
      v146 = v154;
    else
      v146 = v149;
  }
  if ((int)v142 > v146)
  {
    updated = mfs_CostList_Select(*(_QWORD *)(a1 + 136), v3, 1, v146);
    UNICORN__mfs_CostList_Prune(*(_QWORD **)(a1 + 136), v3, v146);
  }
  if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(v9 + 1072) + 32)) >= 3)
    *(_DWORD *)(v9 + 1964) += *v143;
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 11, (uint64_t)"costlist(%d)\n");
  return updated;
}

void UnicornSearch_TreeIndex_InnerDefault_Cascaded(uint64_t a1, _QWORD *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  int v10;
  uint64_t v12;
  unint64_t v13;
  float v14;
  int v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  float v20;
  float v21;
  BOOL v22;
  float v23;

  v4 = a2[1];
  if (*(_DWORD *)(v4 + 1928) == 1)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 112) + 6752))
    {
      v7 = a2[2];
      v8 = v7 + 32 * a3;
      v10 = *(_DWORD *)(v8 + 16);
      v9 = (unsigned int *)(v8 + 16);
      if (v10)
      {
        v12 = 0;
        v13 = 0;
        v14 = 1.0 - *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 1352) + 4 * a3);
        v15 = *(_DWORD *)(*(_QWORD *)(v4 + 568) + 11548) - 1;
        v16 = (uint64_t *)(v7 + 32 * a3);
        v17 = *v16;
        do
        {
          v18 = *(_DWORD *)(v17 + v12);
          if (*(_QWORD *)(a4 + 8))
            v19 = v18 < 1;
          else
            v19 = 1;
          v20 = 0.0;
          if (!v19)
          {
            v21 = *(float *)(a2[28] + 4);
            v20 = (float)(v21
                        * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v4, *(_QWORD *)(a1 + 56), *(float *)(a4 + 44)))+ 0.0;
          }
          if (*(_QWORD *)(a4 + 16))
            v22 = v18 < v15;
          else
            v22 = 0;
          if (v22)
          {
            v23 = *(float *)(a2[28] + 8);
            v20 = v20
                + (float)(v23
                        * (*(float (**)(uint64_t, _QWORD, float))(a1 + 392))(v4, *(_QWORD *)(a1 + 56), *(float *)(a4 + 48)));
          }
          v17 = *v16;
          *(float *)(*v16 + v12 + 4) = (float)(v14 * v20) + *(float *)(*v16 + v12 + 4);
          ++v13;
          v12 += 12;
        }
        while (v13 < *v9);
      }
    }
  }
}

uint64_t UNICORN__mfs_TCost_Init(uint64_t a1, uint64_t a2, _DWORD *__b)
{
  float v6;
  float v7;

  cstdlib_memset(__b, 0, 0xA0uLL);
  *__b = *(_DWORD *)(a2 + 212) + *(_DWORD *)(a2 + 208);
  v6 = 1.0 / (float)(*(float *)(a2 + 5428) + *(float *)(a2 + 5432));
  *((float *)__b + 1) = v6;
  __b[3] = *(_DWORD *)(a2 + 5532);
  __b[2] = *(_DWORD *)(a2 + 208);
  __b[27] = *(_DWORD *)(a2 + 5432);
  __b[28] = *(_DWORD *)(a2 + 5428);
  v7 = *(float *)(a2 + 5424);
  *((float *)__b + 29) = v7;
  *((float *)__b + 1) = v6 * v7;
  UNICORN__mfs_F32Vect_Init(a1, (_QWORD *)__b + 7);
  UNICORN__mfs_F32Vect_Init(a1, (_QWORD *)__b + 10);
  *((_QWORD *)__b + 3) = 0;
  *((_QWORD *)__b + 4) = 0;
  *((_QWORD *)__b + 19) = mfs_TCost_Elf0_Manhattan_Clusterize;
  return 0;
}

uint64_t mfs_TCost_EnableSIMD(uint64_t a1, int a2)
{
  uint64_t result;
  void *v4;

  if (!a1)
    return 8;
  result = 0;
  v4 = mfs_TCost_Elf0_Manhattan_Clusterize_SIMD;
  if (!a2)
    v4 = mfs_TCost_Elf0_Manhattan_Clusterize;
  *(_QWORD *)(a1 + 152) = v4;
  return result;
}

uint64_t UNICORN__mfs_FillTgtVect(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  float v23;
  uint64_t v24;

  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_DWORD *)(v8 + 1520);
  v10 = *(_DWORD *)(v8 + 3040);
  *(_DWORD *)(a3 + 104) = a4;
  v11 = a3 + 56;
  UNICORN__mfs_F32Vect_Clear((_QWORD *)(a3 + 56));
  result = UNICORN__mfs_F32Vect_Create(v11, a4);
  if ((result & 0x80000000) != 0)
    return result;
  v13 = a3 + 80;
  UNICORN__mfs_F32Vect_Clear((_QWORD *)(a3 + 80));
  result = UNICORN__mfs_F32Vect_Create(a3 + 80, a4 + *(_DWORD *)a3 - 1);
  if ((result & 0x80000000) != 0)
    return result;
  v14 = v9;
  v15 = *(_QWORD *)(a3 + 64);
  *(_QWORD *)(a3 + 24) = *(_QWORD *)(*(_QWORD *)(v8 + 1576) + 8 * v9);
  *(_QWORD *)(a3 + 32) = v15;
  if (a4 < 1)
  {
LABEL_21:
    v24 = *(_QWORD *)(a2 + 24);
    *(_DWORD *)(v24 + 3040) = v10;
    *(_DWORD *)(v24 + 1520) = v9;
    return result;
  }
  v16 = 0;
  v17 = 0;
  v18 = -1.0;
  v19 = 1.0;
  while ((*(_BYTE *)(*(_QWORD *)(a2 + 48) + v14) & 4) == 0)
  {
    v20 = -1.0e10;
    v21 = 1.0;
    if ((v16 & 1) == 0)
      goto LABEL_9;
LABEL_13:
    result = UNICORN__mfs_F32Vect_Pad(v11, v20);
    if ((result & 0x80000000) != 0)
      return result;
    v23 = sqrtf(v21);
    if (v18 != v21)
      v19 = v23;
    result = UNICORN__mfs_F32Vect_Pad(v13, v19);
    if ((result & 0x80000000) != 0)
      return result;
    if (v18 != v21)
      v18 = v21;
    ++v14;
    ++v17;
    v16 = 1;
    if (v17 == a4)
    {
      v9 = v14;
      goto LABEL_21;
    }
  }
  v20 = **(float **)(*(_QWORD *)(v8 + 3096) + 8 * v10);
  v21 = **(float **)(*(_QWORD *)(v8 + 3136) + 8 * v10++);
  if ((v16 & 1) != 0)
    goto LABEL_13;
LABEL_9:
  if (*(int *)(a1 + 208) < 1)
    goto LABEL_13;
  v22 = 0;
  while (1)
  {
    result = UNICORN__mfs_F32Vect_Pad(v13, sqrtf(*(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 1616) + 8 * v14) + 4 * v22)));
    if ((result & 0x80000000) != 0)
      return result;
    if (++v22 >= *(int *)(a1 + 208))
      goto LABEL_13;
  }
}

_QWORD *UNICORN__mfs_TCost_Clear(uint64_t a1)
{
  UNICORN__mfs_F32Vect_Clear((_QWORD *)(a1 + 56));
  return UNICORN__mfs_F32Vect_Clear((_QWORD *)(a1 + 80));
}

void mfs_TCost_BNFCandidateCostStream(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float *a5, unsigned int a6, int a7)
{
  float *v7;
  float *v8;
  uint64_t v9;
  float v14;
  float *v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  float v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  int v40;
  float v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  float v45;
  float *v46;
  uint64_t v47;
  float v48;
  float v49;
  float *v50;
  float v51;
  float v52;
  float v53;
  int v54;
  float v55;
  float v56;
  int v57;
  float v58[5];
  float v59;
  float v60;
  float v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v7 = *(float **)(a1 + 32);
  v8 = *(float **)(a3 + 16);
  v9 = *(unsigned int *)(a1 + 104);
  a5[2] = 0.0;
  *a5 = 0.0;
  if ((_DWORD)v9)
  {
    switch(a7)
    {
      case 1:
        v59 = *v7;
        v58[0] = *v8;
        v42 = v9 - 1;
        v43 = a4 - 1;
        if ((int)v9 < 3)
        {
          v60 = v7[v42];
          v44 = 2;
        }
        else
        {
          v61 = v7[v42];
          v58[2] = v8[v43];
          v60 = *(float *)((char *)v7 + ((2 * v9) & 0x1FFFFFFFCLL));
          LODWORD(v43) = a4 >> 1;
          v44 = 3;
        }
        v58[1] = v8[(int)v43];
        a5[2] = mfs_bnfData_CosineCost_F32(&v59, v58, v44) * *(float *)(a1 + 108);
        v39 = *(float *)(a1 + 116);
        v57 = v9 - a4;
        if ((int)v9 - a4 < 0)
          v57 = a4 - v9;
        v55 = (float)v57;
        v56 = (float)a4;
        goto LABEL_50;
      case 2:
      case 5:
        if (*(_DWORD *)(a1 + 120) == 1)
        {
          v14 = 0.0;
          if (a4 < 3)
          {
LABEL_13:
            v22 = sqrtf(v14) / (float)((float)((float)a4 + -2.0) * 3.0);
            goto LABEL_35;
          }
          v15 = v8 + 2;
          v16 = (a4 - 1) - 1;
          while (1)
          {
            v17 = *(v15 - 1);
            if (v17 <= 0.0)
            {
              v21 = 1000.0;
              v20 = 5.0;
            }
            else
            {
              v18 = *(v15 - 2);
              v19 = *v15;
              v14 = v14 + UNICORN__mfsLLCost(v17 - *(float *)(a1 + 124), *(float *)(a1 + 136));
              if (v18 <= 0.0 || v19 <= 0.0)
                goto LABEL_12;
              v14 = v14
                  + UNICORN__mfsLLCost((float)((float)(v19 * 0.5) + (float)(v18 * -0.5)) - *(float *)(a1 + 128), *(float *)(a1 + 140));
              v20 = (float)((float)(v18 + v19) + (float)(v17 * -2.0)) - *(float *)(a1 + 132);
              v21 = *(float *)(a1 + 144);
            }
            v14 = v14 + UNICORN__mfsLLCost(v20, v21);
LABEL_12:
            ++v15;
            if (!--v16)
              goto LABEL_13;
          }
        }
        v45 = 0.0;
        if (a4 >= 3)
        {
          v46 = v8 + 1;
          v47 = (a4 - 1) - 1;
          do
          {
            if (*v46 > 0.0)
              v45 = v45 + UNICORN__mfsLLCost(5.0, 1000.0);
            ++v46;
            --v47;
          }
          while (v47);
        }
        v22 = sqrtf(v45);
LABEL_35:
        if (a7 == 5)
        {
          v48 = v8[1];
          v49 = v7[(int)v9 - 1];
          v50 = &v8[a4];
          v51 = *(v50 - 2);
          if (*v7 <= v48)
            v52 = v8[1];
          else
            v52 = *v7;
          if (v49 <= v51)
            v53 = *(v50 - 2);
          else
            v53 = v7[(int)v9 - 1];
          v22 = v22 + (float)((float)(vabds_f32(*v7, v48) / v52) + (float)(vabds_f32(v49, v51) / v53));
        }
        a5[2] = v22 * *(float *)(a1 + 108);
        v39 = *(float *)(a1 + 116);
        v54 = -2 - (v9 - a4);
        if ((int)v9 - a4 + 2 >= 0)
          v54 = v9 - a4 + 2;
        v55 = (float)v54;
        v56 = (float)a4 + -2.0;
LABEL_50:
        v41 = v55 / v56;
LABEL_51:
        *a5 = v41 * v39;
        break;
      case 3:
      case 4:
        v23 = (float *)((char *)&UNICORN__tblSubUnitLRWeights + 12 * a6);
        v24 = v7[(int)v9 - 1];
        v25 = a4 - 1;
        v26 = v8[v25];
        v27 = v7[((int)v9 - 1) >> 1];
        v28 = v8[(int)v25 >> 1];
        v29 = vabds_f32(*v7, *v8);
        if (*v7 <= *v8)
          v30 = *v8;
        else
          v30 = *v7;
        v31 = (float)(v29 / v30) * *v23;
        v32 = vabds_f32(v24, v26);
        if (v24 <= v26)
          v33 = v8[v25];
        else
          v33 = v7[(int)v9 - 1];
        v34 = v31 + (float)((float)(v32 / v33) * v23[1]);
        v35 = vabds_f32(v27, v28);
        if (v27 <= v28)
          v27 = v8[(int)v25 >> 1];
        v36 = v35 / v27;
        v37 = (float)a4;
        v38 = v34
            + (float)((float)(v36 * v23[2])
                    * (float)((float)((float)a4 + (float)(int)v9) / (float)((float)a4 * (float)(int)v9)));
        if (a7 == 4)
          v38 = (float)(vabds_f32((float)(*v7 - v24) / (float)(int)v9, (float)(*v8 - v26) / v37) * *(float *)(a2 + 6776))
              + (float)((float)(1.0 - *(float *)(a2 + 6776)) * v38);
        a5[2] = v38 * *(float *)(a1 + 108);
        v39 = *(float *)(a1 + 116);
        v40 = v9 - a4;
        if ((int)v9 - a4 < 0)
          v40 = a4 - v9;
        v41 = (float)v40 / v37;
        goto LABEL_51;
      default:
        return;
    }
  }
}

float mfs_TCost_BNFCandidateCostStreamElf0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float *a5, unsigned int a6, float *a7, int a8, float result)
{
  float *v9;
  int v10;
  float v14;
  float v15;
  float *v16;
  float v17;
  float v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  int v28;
  float v29[5];
  float v30[2];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v9 = *(float **)(a3 + 16);
  v10 = *(_DWORD *)(a1 + 104);
  a5[2] = 0.0;
  *a5 = 0.0;
  if (v10)
  {
    if ((a8 - 3) < 2)
    {
      v16 = (float *)((char *)&UNICORN__tblSubUnitLRWeights + 12 * a6);
      v17 = *v9;
      v18 = a7[1];
      v19 = &v9[a4];
      v20 = *(v19 - 1);
      v21 = vabds_f32(*a7, v17);
      if (*a7 <= v17)
        v22 = v17;
      else
        v22 = *a7;
      v23 = (float)(v21 / v22) * *v16;
      v24 = vabds_f32(v18, v20);
      if (v18 <= v20)
        v25 = *(v19 - 1);
      else
        v25 = a7[1];
      v26 = v23 + (float)((float)(v24 / v25) * v16[1]);
      v27 = (float)a4;
      if (a8 == 4)
        v26 = (float)(vabds_f32((float)(*a7 - v18) / (float)v10, (float)(v17 - v20) / (float)a4) * *(float *)(a2 + 6776))
            + (float)((float)(1.0 - *(float *)(a2 + 6776)) * v26);
      a5[2] = v26 * *(float *)(a1 + 108);
      v28 = v10 - a4;
      if (v10 - a4 < 0)
        v28 = a4 - v10;
    }
    else
    {
      if (a8)
      {
        if (a8 != 1)
          return result;
        v14 = a7[1];
        v30[0] = *a7;
        v29[0] = *v9;
        v30[1] = v14;
        v29[1] = v9[a4 - 1];
        v15 = mfs_bnfData_CosineCost_F32(v30, v29, 2u) * *(float *)(a1 + 108);
      }
      else
      {
        v15 = *(float *)(a1 + 108) * sqrtf((float)(*a7 - *v9) + (float)(a7[1] - v9[a4 - 1]));
      }
      a5[2] = v15;
      v28 = v10 - a4;
      if (v10 - a4 < 0)
        v28 = a4 - v10;
      v27 = (float)a4;
    }
    result = (float)((float)v28 / v27) * *(float *)(a1 + 116);
    *a5 = result;
  }
  return result;
}

uint64_t mfs_LogElf0Targets_Clustered(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
    return UNICORN__log_select_Diag(result, 10, (uint64_t)"PHN:%3d  STA:%d - F0_LEFT_PGEN:%5.2f F0_LEFT_RNN :%5.2f   F0_RIGHT_PGEN:%5.2f F0_RIGHT_RNN :%5.2f\n");
  return result;
}

uint64_t LogEdgeLF0Targets(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 104))
    return UNICORN__log_select_Diag(result, 10, (uint64_t)"PHN:%3d  STA:%d - F0_LEFT_PGEN:%5.2f F0_LEFT_RNN :%5.2f   F0_RIGHT_PGEN:%5.2f F0_RIGHT_RNN :%5.2f\n");
  return result;
}

uint64_t UNICORN__mfs_TCost_SetTarget(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5)
{
  uint64_t v8;

  v8 = UNICORN__mfs_FillTgtVect(*(_QWORD *)(a2 + 568), a3, a1, *(_DWORD *)(a4[2] + 4 * a5));
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a4[14] + 8 * a5) + 4);
  *(float *)(a1 + 136) = UNICORN__bet5_finv(sqrtf(*(float *)(*(_QWORD *)(a4[19] + 8 * a5) + 4)));
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(*(_QWORD *)(a4[14] + 8 * a5) + 8);
  *(float *)(a1 + 140) = UNICORN__bet5_finv(sqrtf(*(float *)(*(_QWORD *)(a4[19] + 8 * a5) + 8)));
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(_QWORD *)(a4[14] + 8 * a5) + 12);
  *(float *)(a1 + 144) = UNICORN__bet5_finv(sqrtf(*(float *)(*(_QWORD *)(a4[19] + 8 * a5) + 12)));
  *(_DWORD *)(a1 + 120) = (*(unsigned __int8 *)(a4[22] + a5) >> 2) & 1;
  return v8;
}

void UNICORN__mfs_TCost_Copy(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = (uint64_t)(a1 + 7);
  UNICORN__mfs_F32Vect_Clear(a1 + 7);
  UNICORN__mfs_F32Vect_Clear(a1 + 10);
  cstdlib_memcpy(a1, a2, 0xA0uLL);
  UNICORN__mfs_F32Vect_Copy(v4, a2 + 7);
  UNICORN__mfs_F32Vect_Copy((uint64_t)(a1 + 10), a2 + 10);
  v5 = a1[8];
  a1[3] = a2[3];
  a1[4] = v5;
}

uint64_t GetBnfTargetVectorPacked(uint64_t a1, int a2, float *a3)
{
  *a3 = VectBlock_Get_IndexElm_LH_F32(a1 + 1928, a2);
  if (*(_DWORD *)(a1 + 1944))
    return VectBlock_Get_IndexPtr_LH_S8(a1 + 1864, a2);
  else
    return VectBlock_Get_IndexPtr_LH_S16(a1 + 1880, a2);
}

uint64_t Search_TreeIndex(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, signed int a9)
{
  int *v12;
  int *v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  int v22;
  uint64_t result;
  int v24;
  uint64_t BnfTargetVectorPacked;
  unint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  unsigned int v31;
  float v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v41;
  float v42;

  v12 = *(int **)(a1 + 104);
  v41 = *(_QWORD *)(a1 + 112);
  v13 = &v12[2 * a2];
  v14 = *(_QWORD *)(a1 + 120);
  v15 = (unsigned int *)(*(_QWORD *)(*((_QWORD *)v13 + 96) + 8 * (int)a3)
                       + 40 * *(int *)(*(_QWORD *)(a5 + 8 * a2 + 56) + 4 * (int)a3));
  v16 = *v15;
  v17 = v15[1];
  v18 = *((_QWORD *)v13 + 101);
  v19 = *(float *)(*(_QWORD *)(v14 + 1352) + 4 * a9);
  v20 = **(float **)(a8 + 224);
  v21 = *(_QWORD *)(a8 + 16) + 32 * a9;
  v22 = *v12;
  v34 = v18;
  v35 = v16;
  v37 = *(int *)(*(_QWORD *)(a5 + 8 * a2 + 56) + 4 * (int)a3);
  v36 = *(_DWORD *)(v21 + 16);
  if (*(_DWORD *)(v21 + 20) >= v17)
  {
    LODWORD(result) = 0;
  }
  else
  {
    result = UNICORN__mfs_CostList_Resize((_QWORD *)a8, a9, v17);
    if ((result & 0x80000000) != 0)
      return result;
  }
  v38 = result;
  v24 = a9 / v22;
  v42 = 0.0;
  BnfTargetVectorPacked = GetBnfTargetVectorPacked(v14, a9 / *(_DWORD *)(v41 + 5992), &v42);
  if (*(_DWORD *)(v41 + 5992) == 1 || *(_DWORD *)(a8 + 56) != v24)
  {
    (*(void (**)(int *, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, float))(a1 + 384))(v12, *(_QWORD *)(a1 + 56), BnfTargetVectorPacked, v37, a3, *(_QWORD *)(a8 + 104), v42);
    *(_DWORD *)(a8 + 56) = v24;
  }
  if ((_DWORD)v17)
  {
    result = v38;
    if (v36 - a6 >= a7)
      return result;
    v26 = 0;
    v27 = (_DWORD *)(v34 + 4 * v35);
    v28 = (int)a3 - 2;
    v29 = (float)(1.0 - v19) * v20;
    v30 = *(unsigned int *)(*((_QWORD *)v12 + 106)
                          + 4 * (*v27 / *(_DWORD *)(*((_QWORD *)v12 + 71) + 5992)));
    do
    {
      v31 = v27[v26];
      v32 = *(float *)(*(_QWORD *)(a8 + 104) + 4 * v26);
      v33 = *(_QWORD *)(a8 + 72);
      *(_DWORD *)(*(_QWORD *)(a8 + 64) + 4 * ((v31 / *(_DWORD *)(v41 + 5992)) >> 5)) |= 1 << (v31
                                                                                              / *(_DWORD *)(v41 + 5992));
      *(float *)(v33 + 4 * v30) = v32;
      mfs_CostList_PadWithBnfOffset((_QWORD *)a8, a9, v31, v30 + v26, v29 * v32);
      *(_DWORD *)(*(_QWORD *)(a8 + 112 + 8 * v28) + 4 * (v26 >> 5)) |= 1 << v26;
      ++v26;
    }
    while (v26 < v17 && *(_DWORD *)(*(_QWORD *)(a8 + 16) + 32 * a9 + 16) - a6 < a7);
  }
  return v38;
}

uint64_t Search_PruneBNF_TreeIndex(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, signed int a9)
{
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  float v17;
  float v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  float v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  float v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t List;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v59;
  _QWORD *v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 *v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  unint64_t v72;
  __int128 *v73;
  unsigned int v74;
  __int128 v75;
  uint64_t v76;
  _OWORD *v77;
  float v78;
  _QWORD *v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  int v85;
  unint64_t v86;
  uint64_t v87;
  float v88;
  float v89;
  unsigned int v90;
  _DWORD *v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  float v96;
  uint64_t v97;
  int v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  unsigned int v104;
  _DWORD *v105;
  int v106;
  uint64_t i;
  unsigned int v108;
  unint64_t v109;
  unsigned int v110;
  unsigned int *v111;
  unsigned int v112;
  uint64_t v113;
  unsigned int *v114;
  unint64_t v115;
  unsigned int v116;
  unint64_t v117;
  uint64_t v118;
  unsigned int *v119;
  unsigned int v120;
  float v121;
  uint64_t v122;
  uint64_t v123;
  int v125;
  int v126;
  int v127;
  int v128;
  uint64_t v129;
  unsigned int v130;
  unsigned int v131;
  uint64_t v132;
  uint64_t v133;
  float (*v134)(int, int, unsigned int, float, float);
  _QWORD *v137;
  uint64_t v138;
  int v139;
  int v140;
  int v142;
  uint64_t v143;
  uint64_t v144;
  _DWORD *v145;
  uint64_t v146;
  uint64_t v147;
  _QWORD *v148;
  _DWORD *v149;
  uint64_t v150;
  float v152;
  float v153;
  float v154;
  float v155;
  _OWORD v156[99];
  _DWORD __b[255];
  _BYTE v158[20];

  *(_QWORD *)&v158[4] = *MEMORY[0x24BDAC8D0];
  v139 = *(unsigned __int8 *)(a4 + 1);
  v12 = *(_DWORD **)(a1 + 104);
  v13 = *(_QWORD *)(a1 + 112);
  v14 = *(_QWORD *)(a1 + 120);
  v145 = v12 + 192;
  v146 = *(int *)(*(_QWORD *)(a5 + 8 * a2 + 56) + 4 * a3);
  v15 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)&v12[2 * a2 + 192] + 8 * a3) + 40 * (int)v146);
  v16 = v15[1];
  v17 = *(float *)(*(_QWORD *)(v14 + 1352) + 4 * a9);
  v18 = **(float **)(a8 + 224);
  v147 = *v15;
  v148 = &v12[2 * a2 + 202];
  v19 = *(_DWORD *)(*v148 + 4 * v147);
  v138 = *(_QWORD *)(a8 + 16);
  v149 = v12;
  v20 = *v12;
  v152 = 0.0;
  v153 = 0.0;
  BET5_GenericRules_Param_GetLocalValue(v13, v14, 1u, a9, &v153);
  if ((v21 & 0x80000000) != 0)
    return v21;
  v150 = v13;
  BET5_GenericRules_Param_GetLocalValue(v13, v14, 2u, a9, &v152);
  if ((v21 & 0x80000000) != 0)
    return v21;
  v143 = a3;
  v144 = a2;
  v132 = a3 - 2;
  cstdlib_memset(__b, 0, 0x400uLL);
  if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(v14 + 1072) + 32)) >= 3)
    *(_DWORD *)(v14 + 1948) += *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v145[2 * a2] + 8 * a3) + 40 * (int)v146 + 4);
  v133 = v14;
  v22 = v13;
  v23 = *((_QWORD *)v149 + 71);
  v24 = v19 / *(_DWORD *)(v23 + 5992);
  v25 = *(_DWORD *)(*((_QWORD *)v149 + 106) + 4 * v24);
  v26 = *(_DWORD *)(v150 + 5984)
      ? v25 + *(_DWORD *)(v23 + 11564) / *v149 * v132
      : *(_DWORD *)(*((_QWORD *)v149 + 106) + 4 * v24);
  if (*(_DWORD *)(*(_QWORD *)(a8 + 16) + 32 * a9 + 20) < v16)
  {
    v21 = UNICORN__mfs_CostList_Resize((_QWORD *)a8, a9, v16);
    v22 = v150;
    if ((v21 & 0x80000000) != 0)
      return v21;
  }
  v27 = *(_QWORD *)(v14 + 1768);
  if (v27
    && *(_DWORD *)(v27 + 12) == 1
    && *(_DWORD *)(v27 + 8) > a9
    && *(float *)(*(_QWORD *)v27 + 48 * a9 + 16) != 0.0)
  {
    v28 = *(_DWORD *)(v27 + 20);
    if (v28 >= 0x64)
      v29 = 100;
    else
      v29 = v28;
  }
  else
  {
    v29 = -1;
  }
  v30 = 0.0;
  v31 = (a9 / v20);
  v127 = v26;
  v128 = v29;
  if (v139 == 1)
  {
    v134 = 0;
    v32 = 0;
    v33 = 0;
LABEL_28:
    v140 = 1;
    v35 = 0.0;
    goto LABEL_37;
  }
  v34 = *(float *)(v22 + 6160);
  if (v34 < *(float *)(v22 + 6164) || v29 != -1)
  {
    v38 = *((_QWORD *)v149 + 71);
    v39 = *(_DWORD *)(v38 + 24);
    v32 = v39 * *(_DWORD *)(a5 + 24);
    v33 = *(_DWORD *)(a5 + 28) * v39;
    if (v29)
    {
      if (v29 == -1)
      {
        v35 = v34 * (float)v33;
      }
      else
      {
        v40 = *(float *)(v38 + 11572) * 1000.0 * (float)(130 - v29);
        v35 = v40 / 100.0;
      }
    }
    else
    {
      v35 = 1000.0;
    }
    if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) >= 3)
      UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 3, (uint64_t)"phonidx %u: dist duroutlier legacy: phondur target %u msecs, stdevdur %u msecs, threshold %u msecs\n");
    v140 = 0;
    v134 = (float (*)(int, int, unsigned int, float, float))PhonemeDurationOutlierDistance_LegacyOrTuning;
    v22 = v150;
    goto LABEL_37;
  }
  v35 = v153;
  if (v153 == 0.0
    || (v36 = *(_QWORD *)(v22 + 11624)) == 0
    || (v37 = *(_QWORD *)(v22 + 11632)) == 0
    || v132 >= *(_DWORD *)(v22 + 11608)
    || v146 > *(_DWORD *)(*(_QWORD *)(v22 + 11616) + 4 * v132))
  {
    v134 = 0;
    v32 = 0;
    v33 = 0;
    goto LABEL_28;
  }
  v32 = (*(_DWORD *)(*(_QWORD *)(v36 + 8 * v132) + 4 * v146)
                     + *(_DWORD *)(*((_QWORD *)v149 + 71) + 24) * *(_DWORD *)(a5 + 24)) >> 1;
  v131 = *(_DWORD *)(*(_QWORD *)(v37 + 8 * v132) + 4 * v146);
  v30 = v152;
  if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) < 3)
  {
    v140 = 0;
    v134 = PhonemeDurationOutlierDistance;
    v22 = v150;
    v33 = v131;
  }
  else
  {
    v33 = v131;
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 3, (uint64_t)"phonidx %u: dist duroutlier: phondur target %u msecs [(predicted %u + meancluster %u)/2], stdevcluster %u msecs, param1 %.3f, param2 %.3f\n");
    v22 = v150;
    v140 = 0;
    v134 = PhonemeDurationOutlierDistance;
  }
LABEL_37:
  if (*(_DWORD *)(a8 + 56) != (_DWORD)v31)
  {
    v21 = Search_BNFCostCache_Fill(a1, v31, *(_QWORD *)(a1 + 136) + 56);
    v22 = v150;
    if ((v21 & 0x80000000) != 0)
      return v21;
  }
  if (*(_DWORD *)(*((_QWORD *)v149 + 71) + 5992) != 1)
  {
    v41 = v31 + 1;
    if ((v31 + 1) < *(_DWORD *)(a1 + 88) && v41 != *(_DWORD *)(a8 + 80))
    {
      v21 = Search_BNFCostCache_Fill(a1, v41, *(_QWORD *)(a1 + 136) + 80);
      v22 = v150;
      if ((v21 & 0x80000000) != 0)
        return v21;
    }
  }
  v130 = v33;
  if (a3 < 3 || *(_DWORD *)(v22 + 5992) == 1 || *(_DWORD *)(a8 + 56) != (_DWORD)v31)
    goto LABEL_51;
  v42 = 0;
  v43 = (a9 - 1);
  if (a9 < 1 || *(_DWORD *)(v22 + 6200) || v128 != -1)
    goto LABEL_52;
  if (*(float *)(*(_QWORD *)(v14 + 1352) + 4 * v43) != *(float *)(*(_QWORD *)(v14 + 1352) + 4 * a9)
    || *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v43))
  {
    goto LABEL_51;
  }
  v154 = 0.0;
  v155 = 0.0;
  v123 = v22;
  BET5_GenericRules_Param_GetLocalValue(v22, v14, 1u, a9 - 1, &v155);
  if ((v21 & 0x80000000) != 0)
    return v21;
  BET5_GenericRules_Param_GetLocalValue(v123, v14, 2u, v43, &v154);
  if ((v21 & 0x80000000) != 0)
    return v21;
  if (v155 == v153)
  {
    v22 = v150;
    if (v154 != v152)
    {
LABEL_51:
      v42 = 0;
      goto LABEL_52;
    }
    v42 = 1;
  }
  else
  {
    v42 = 0;
    v22 = v150;
  }
LABEL_52:
  v142 = v32;
  v44 = *(_QWORD *)(a1 + 104);
  v45 = *(_QWORD *)(v44 + 2376);
  if (!v45)
  {
    List = 0;
    v46 = 0;
    v60 = (_QWORD *)a8;
LABEL_115:
    if (v42)
    {
      List = mfs_ClonePrevList(v60, a9, v132);
      if ((List & 0x80000000) != 0)
        return List;
      if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) >= 4)
        UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 3, (uint64_t)"[Stage1 costs cloned from previous costlist.]\n");
      goto LABEL_167;
    }
    v78 = 1.0 - v17;
    v79 = (_QWORD *)(v138 + 32 * a9);
    if ((v140 & 1) != 0)
    {
      v80 = *(_QWORD *)&v145[2 * v144];
      v81 = v146;
      if (!*(_DWORD *)(v22 + 6200))
      {
        v82 = *(_QWORD *)(v80 + 8 * v143);
        v83 = v82 + 40 * (int)v146;
        v85 = *(_DWORD *)(v83 + 4);
        v84 = (unsigned int *)(v83 + 4);
        if (v85)
        {
          v137 = (_QWORD *)(v138 + 32 * a9);
          v86 = 0;
          v87 = *(_QWORD *)(a8 + 72);
          do
          {
            v88 = *(float *)(v87 + 4 * (v25 + v86));
            v89 = v88 + ComputeFuzzyDist(v46, (uint64_t)&v155, v25 + v86);
            v90 = (float)(v89 * 10.0);
            if (v90 >= 0xFF)
              v91 = v158;
            else
              v91 = &__b[v90];
            ++*v91;
            *(float *)(*(_QWORD *)(a8 + 104) + 4 * v86++) = v89;
          }
          while (v86 < *v84);
LABEL_147:
          v81 = v146;
          v22 = v150;
          v79 = v137;
        }
LABEL_148:
        v106 = __b[0];
        for (i = 1; i != 256; ++i)
        {
          v106 += __b[i];
          __b[i] = v106;
        }
        v108 = (float)(*(float *)(v22 + 6156) * 10.0);
        if (v108 - 1 <= 0xFE)
        {
          while (__b[v108 - 1] < *(_DWORD *)(v22 + 6148))
          {
            if (++v108 == 256)
            {
              v108 = 256;
              break;
            }
          }
        }
        v109 = v108;
        v110 = v108 != 0;
        v111 = &__b[v108 - 1];
        while (v109 >= 2)
        {
          if (*(v111 - 1) <= *(_DWORD *)(v22 + 6148))
          {
            v110 = v109;
            break;
          }
          --v109;
          v112 = *v111--;
          if (v112 <= *(_DWORD *)(v22 + 6152))
          {
            v110 = v109 + 1;
            break;
          }
        }
        v113 = v82 + 40 * v81;
        v116 = *(_DWORD *)(v113 + 4);
        v114 = (unsigned int *)(v113 + 4);
        v115 = v116;
        if (v116)
        {
          v117 = 0;
          v118 = a9;
          v119 = (unsigned int *)(v138 + 32 * a9 + 16);
          do
          {
            v120 = *v119;
            if (*v119 - a6 >= a7)
              break;
            v121 = *(float *)(*(_QWORD *)(a8 + 104) + 4 * v117);
            if ((float)(v121 * 10.0) <= (float)v110)
            {
              v122 = *v79 + 12 * v120;
              *(_DWORD *)v122 = *(_DWORD *)(*v148 + 4 * (v147 + v117));
              *(float *)(v122 + 4) = (float)(v78 * v18) * v121;
              *(_DWORD *)(v122 + 8) = v25 + v117;
              *v119 = v120 + 1;
              *(_DWORD *)(*(_QWORD *)(a8 + 112 + 8 * (int)v132) + 4 * (v117 >> 5)) |= 1 << v117;
              v115 = *v114;
            }
            ++v117;
          }
          while (v117 < v115);
          goto LABEL_168;
        }
LABEL_167:
        v118 = a9;
LABEL_168:
        if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(v133 + 1072) + 32)) >= 3)
          *(_DWORD *)(v133 + 1952) += *(_DWORD *)(v138 + 32 * v118 + 16);
        return List;
      }
    }
    else
    {
      v80 = *(_QWORD *)&v145[2 * v144];
      v81 = v146;
    }
    v82 = *(_QWORD *)(v80 + 8 * v143);
    if (!*(_DWORD *)(v82 + 40 * v81 + 4))
      goto LABEL_148;
    v137 = (_QWORD *)(v138 + 32 * a9);
    v92 = 0;
    while (1)
    {
      v93 = *(unsigned int *)(*v148 + 4 * (v147 + v92));
      if (v140)
      {
        v94 = v25 + v92;
        v95 = (v25 + v92);
        v96 = 0.0;
      }
      else
      {
        v96 = v134(*(_DWORD *)(*((_QWORD *)v149 + 71) + 24)* *(unsigned __int8 *)(*((_QWORD *)v149 + 307) + (v25 + v92)), v142, v130, v35, v30);
        if (v96 >= 9999.9)
        {
          v94 = v25 + v92;
          v97 = a8;
          goto LABEL_143;
        }
        v94 = v25 + v92;
        v95 = (v25 + v92);
      }
      v97 = a8;
      v96 = v96 + *(float *)(*(_QWORD *)(a8 + 72) + 4 * v95);
      if (*(_DWORD *)(v150 + 6200))
      {
        if (*(_DWORD *)(v150 + 6196))
        {
          v98 = *(char *)(*((_QWORD *)v149 + 130) + (v127 + v92));
          v99 = *(float *)(v150 + 6192);
          if (v98 < (int)v99)
          {
            v100 = (float)v98 / v99;
LABEL_142:
            v96 = v96 * v100;
          }
        }
        else
        {
          v101 = *(float *)(*((_QWORD *)v149 + 74) + 16 * v93);
          v102 = *(float *)(v150 + 6192);
          if (v101 < v102)
          {
            v100 = v101 / v102;
            goto LABEL_142;
          }
        }
      }
LABEL_143:
      v103 = v96 + ComputeFuzzyDist(v46, (uint64_t)&v155, v94);
      v104 = (float)(v103 * 10.0);
      if (v104 >= 0xFF)
        v105 = v158;
      else
        v105 = &__b[v104];
      ++*v105;
      *(float *)(*(_QWORD *)(v97 + 104) + 4 * v92++) = v103;
      v82 = *(_QWORD *)(*(_QWORD *)&v145[2 * v144] + 8 * v143);
      if (v92 >= *(unsigned int *)(v82 + 40 * (int)v146 + 4))
        goto LABEL_147;
    }
  }
  v46 = 0;
  v47 = 0;
  v129 = *(_QWORD *)(a1 + 120);
  v154 = 0.0;
  v48 = *(unsigned int *)(v44 + 2384) + 1;
  do
  {
    if (!--v48)
      break;
    if (*(_DWORD *)(v45 + 20))
    {
      *(_QWORD *)&v156[v47] = v45;
      v46 = ++v47;
    }
    v45 += 64;
  }
  while (v47 < 0x64);
  v126 = v42;
  if (*(_QWORD *)(v44 + 2392))
  {
    if (v47 > 0x63)
    {
      List = 0;
LABEL_86:
      v125 = v25;
      v61 = 0;
      v62 = *(_QWORD *)(a1 + 120);
      v63 = (v31 + 1);
      while (1)
      {
        v64 = *(_QWORD *)&v156[v61];
        v65 = *(unsigned int *)(v64 + 16);
        v66 = *(_QWORD *)(v62 + 8);
        if ((v65 - 253) > 1)
        {
          v69 = *(_QWORD *)(v66 + 8 * v65 + 16);
          if (!v69)
            goto LABEL_100;
          v68 = (unsigned __int8 *)(v69 + v31);
          goto LABEL_96;
        }
        v67 = *(_QWORD *)(v66 + 32);
        if (!v67)
          goto LABEL_100;
        if ((_DWORD)v65 == 253)
        {
          if ((_DWORD)v31)
          {
            v68 = (unsigned __int8 *)(v67 + (v31 - 1));
LABEL_96:
            v70 = *v68;
            goto LABEL_98;
          }
        }
        else if (v63 < *(_DWORD *)(a1 + 88))
        {
          v68 = (unsigned __int8 *)(v67 + v63);
          goto LABEL_96;
        }
        v70 = 1;
LABEL_98:
        LOBYTE(v156[v61]) = v70;
        if (*(_DWORD *)(v64 + 36) <= v70)
        {
LABEL_100:
          if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) >= 3)
            UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 3, (uint64_t)"\nphonidx %u: Warning : fuzzy table %s has been deactivated for target feature value %u\n");
          v71 = v61 + 1;
          if (v61 + 1 < v46)
          {
            v72 = v46 - (unint64_t)v71;
            v73 = &v156[v71];
            v74 = v61;
            do
            {
              v75 = *v73++;
              v156[v74++] = v75;
              --v72;
            }
            while (v72);
          }
          v47 = --v46;
          goto LABEL_106;
        }
        ++v61;
LABEL_106:
        if (v61 >= v47)
        {
          v25 = v125;
          goto LABEL_108;
        }
      }
    }
    if (*(_DWORD *)(v44 + 2400))
    {
      v49 = 0;
      while (1)
      {
        v50 = *(_QWORD *)(v44 + 2392);
        List = BET5_GenericRules_Rule_Matches(v129, (unsigned int *)(v50 + 48 * v49), v31, &v154);
        if ((List & 0x80000000) != 0)
          return List;
        if (v154 != 0.0)
        {
          v52 = *(unsigned int *)(v50 + 48 * v49 + 16);
          if ((_DWORD)v52)
          {
            v53 = 0;
            v54 = *(_QWORD *)(v50 + 48 * v49 + 24);
            do
            {
              if (*(_DWORD *)(v54 + 12 * v53) == 4)
              {
                if (v46)
                {
                  v55 = 0;
                  v56 = *(_QWORD *)(v44 + 2376);
                  v57 = *(unsigned int *)(v54 + 12 * v53 + 8);
                  v58 = v46;
                  v59 = &v155;
                  while (*(_DWORD *)(*(_QWORD *)v59 + 16) != *(_DWORD *)(v56 + (v57 << 6) + 16))
                  {
                    ++v55;
                    v59 += 4;
                    if (v46 == v55)
                      goto LABEL_76;
                  }
                  *(_QWORD *)v59 = v56 + (v57 << 6);
                }
                else
                {
                  LODWORD(v55) = 0;
                }
                if ((_DWORD)v55 == v46)
                {
                  v56 = *(_QWORD *)(v44 + 2376);
                  v57 = *(unsigned int *)(v54 + 12 * v53 + 8);
                  v58 = v46;
LABEL_76:
                  *(_QWORD *)&v156[v58] = v56 + (v57 << 6);
                  ++v46;
                }
              }
              ++v53;
            }
            while (v53 != v52);
          }
        }
        if (v46 >= 0x64)
          break;
        ++v49;
        v47 = v46;
        if (v49 >= *(unsigned int *)(v44 + 2400))
          goto LABEL_83;
      }
      v47 = v46;
      goto LABEL_86;
    }
  }
  List = 0;
LABEL_83:
  if (v47)
    goto LABEL_86;
LABEL_108:
  if (UNICORN__log_select_GetLogLevel(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 32)) <= 2)
  {
    v60 = (_QWORD *)a8;
  }
  else
  {
    v60 = (_QWORD *)a8;
    if (v46)
    {
      v76 = 0;
      v77 = v156;
      do
      {
        ++v77;
        UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 3, (uint64_t)"phonidx %u: dist fuzzy %u:%s: target feature value: %u\n");
        ++v76;
      }
      while (v46 != v76);
    }
  }
  v22 = v150;
  v42 = v126;
  if ((List & 0x80000000) == 0)
    goto LABEL_115;
  return List;
}

uint64_t Search_BNFCostCache_Fill(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t BnfTargetVectorPacked;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v27;
  float v28;

  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_QWORD *)(a1 + 112);
  if (*(_DWORD *)(v6 + 5992) == 1)
  {
    v7 = *(_DWORD *)v5 * a2;
    v8 = *(_DWORD *)v5 + 2;
  }
  else
  {
    v8 = 3;
    v7 = a2;
  }
  v27 = *(_QWORD *)(a1 + 120);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 384);
  cstdlib_memset(*(void **)(a3 + 8), 0, 4 * *(unsigned int *)(a3 + 4));
  result = 0;
  if (v8 < 3)
  {
LABEL_11:
    *(_DWORD *)a3 = a2;
  }
  else
  {
    v28 = 0.0;
    v11 = 2;
    while (1)
    {
      v12 = *(unsigned int *)(*(_QWORD *)(v9 + 312 * a2 + 64) + 4 * v11);
      BnfTargetVectorPacked = GetBnfTargetVectorPacked(v27, v7, &v28);
      result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, float))(a1 + 384))(v5, *(_QWORD *)(a1 + 56), BnfTargetVectorPacked, v12, v11, *(_QWORD *)(*(_QWORD *)(a1 + 136) + 104), v28);
      if ((result & 0x80000000) != 0)
        break;
      v14 = *(_QWORD *)(*(_QWORD *)(v5 + 776) + 8 * v11);
      v15 = v14 + 40 * (int)v12;
      v17 = *(_DWORD *)(v15 + 4);
      v16 = (unsigned int *)(v15 + 4);
      if (v17)
      {
        v18 = 0;
        v19 = *(unsigned int *)(v14 + 40 * (int)v12);
        v20 = *(_QWORD *)(v5 + 816);
        v21 = *(_DWORD *)(*(_QWORD *)(v5 + 848)
                        + 4 * (*(_DWORD *)(v20 + 4 * v19) / *(_DWORD *)(*(_QWORD *)(v5 + 568) + 5992)));
        v22 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 104);
        v23 = *(_QWORD *)(a3 + 8);
        v24 = *(_QWORD *)(a3 + 16);
        do
        {
          v25 = *(_DWORD *)(v20 + 4 * (v19 + v18)) / *(_DWORD *)(v6 + 5992);
          *(_DWORD *)(v23 + 4 * (v25 >> 5)) |= 1 << v25;
          *(_DWORD *)(v24 + 4 * (v21 + v18)) = *(_DWORD *)(v22 + 4 * v18);
          ++v18;
        }
        while (v18 < *v16);
      }
      ++v11;
      ++v7;
      if (v11 == v8)
        goto LABEL_11;
    }
  }
  return result;
}

float ComputeFuzzyDist(unsigned int a1, uint64_t a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  float result;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0.0;
  v3 = a1;
  v4 = (unsigned __int8 *)(a2 + 8);
  result = 0.0;
  do
  {
    v6 = *((_QWORD *)v4 - 1);
    v7 = *(_QWORD *)(v6 + 40);
    if (v7)
      result = result
             + *(float *)(*(_QWORD *)(v6 + 24)
                        + 4
                        * (*(unsigned __int8 *)(v7
                                              + *(unsigned __int8 *)(v6 + 49)
                                              + *(unsigned __int8 *)(v6 + 48) * a3)
                         + *(_DWORD *)(v6 + 36) * *v4));
    v4 += 16;
    --v3;
  }
  while (v3);
  return result;
}

uint64_t UnicornSearch_Create(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 400);
  v3 = v2;
  if (v2)
  {
    *(_DWORD *)(v2 + 360) = 1;
    v4 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 16);
    *(_QWORD *)(v3 + 352) = v4;
    if (v4
      && (*(_DWORD *)(v3 + 376) = 1,
          v5 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 16),
          (*(_QWORD *)(v3 + 368) = v5) != 0))
    {
      *(_QWORD *)v3 = UnicornSearch_Open;
      *(_QWORD *)(v3 + 8) = UnicornSearch_Set;
      *(_QWORD *)(v3 + 16) = UnicornSearch_Process;
      *(_QWORD *)(v3 + 24) = UnicornSearch_ProcessOne;
      *(_QWORD *)(v3 + 32) = UnicornSearch_Reset;
      *(_QWORD *)(v3 + 40) = UnicornSearch_Close;
      *(_QWORD *)(v3 + 48) = UnicornSearch_SetSIMDCallback;
      *(_QWORD *)(v3 + 56) = a1;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t UnicornSearch_Open(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  _DWORD *v4;
  int *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _BOOL4 v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;

  v2 = 2229280778;
  if (a1)
  {
    v5 = (int *)a2[1];
    v4 = (_DWORD *)a2[2];
    v6 = *a2;
    *(_QWORD *)(a1 + 104) = v5;
    *(_QWORD *)(a1 + 112) = v4;
    *(_QWORD *)(a1 + 72) = v6;
    *(_QWORD *)(a1 + 80) = v4;
    *(_QWORD *)(a1 + 64) = v5;
    v7 = *v5;
    v8 = *(_DWORD *)(v6 + 392);
    *(_DWORD *)(a1 + 88) = v8;
    if (v4[1496])
      v9 = 1;
    else
      v9 = v7;
    *(_DWORD *)(a1 + 96) = v7;
    *(_DWORD *)(a1 + 100) = v8 * v9;
    *(_QWORD *)(a1 + 120) = v6;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = v6 + 1088;
    *(_BYTE *)(a1 + 156) = 1;
    *(_DWORD *)(a1 + 160) = v4[1548];
    *(_BYTE *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 168) = v4[1693];
    v10 = *(_QWORD *)(v6 + 1808);
    if (v10)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 56) + 8), v10);
      v6 = *(_QWORD *)(a1 + 120);
      *(_QWORD *)(v6 + 1808) = 0;
    }
    v11 = *(_QWORD *)(v6 + 1816);
    if (v11)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 56) + 8), v11);
      v6 = *(_QWORD *)(a1 + 120);
      *(_QWORD *)(v6 + 1816) = 0;
    }
    *(_DWORD *)(v6 + 1824) = 0;
    *(_QWORD *)(a1 + 336) = *(_QWORD *)(v6 + 1896);
    v12 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 56) + 8), (*(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 88)), 4);
    *(_QWORD *)(a1 + 144) = v12;
    if (v12)
    {
      v13 = *(_DWORD *)(a1 + 88);
      v14 = *(_DWORD *)(a1 + 96);
      v15 = *(_QWORD *)(a1 + 120);
      if (v14 * v13)
      {
        v16 = 0;
        v17 = 0;
        v18 = *(_QWORD **)(v15 + 1768);
        do
        {
          if (v18)
          {
            if (*(_DWORD *)(*v18 + v16))
              v19 = 0;
            else
              v19 = **(_DWORD **)(*v18 + v16 + 8) > *(_DWORD *)(*(_QWORD *)(a1 + 112) + 11548);
            *(_DWORD *)(v12 + 4 * v17) = v19;
            v13 = *(_DWORD *)(a1 + 88);
            v14 = *(_DWORD *)(a1 + 96);
          }
          ++v17;
          v20 = (v14 * v13);
          v16 += 48;
        }
        while (v17 < v20);
      }
      else
      {
        LODWORD(v20) = 0;
      }
      v21 = UNICORN__mfs_CostList_Init(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 104), (unsigned int *)(v15 + 1088), v20, 0);
      v22 = *(_QWORD *)(a1 + 112);
      *(_QWORD *)(*(_QWORD *)(a1 + 136) + 224) = &tblBNFContextWeights[5 * *(int *)(v22 + 6752)];
      if ((v21 & 0x80000000) != 0)
        return v21;
      v2 = UNICORN__mfs_TCost_Init(*(_QWORD *)(a1 + 56), v22, (_DWORD *)(a1 + 176));
      if ((v2 & 0x80000000) == 0)
      {
        v23 = *(unsigned int *)(*(_QWORD *)(a1 + 72) + 32);
        *(_DWORD *)(a1 + 152) = 0;
        if ((int)v23 >= 1)
        {
          v24 = 0;
          v25 = *(_QWORD *)(a1 + 80) + 184;
          do
          {
            if (*(_DWORD *)(v25 + 4 * v24) == 2)
              break;
            *(_DWORD *)(a1 + 152) = ++v24;
          }
          while (v23 != v24);
        }
        v26 = *(_DWORD **)(a1 + 112);
        if (v26[1535])
        {
          if (v26[1495])
          {
            v27 = *(_QWORD **)(a1 + 352);
            *v27 = 0;
            v27[1] = Search_Diphone_PruneBNF;
            if (*(_DWORD *)(*(_QWORD *)(a1 + 104) + 1928) != 1)
              goto LABEL_42;
            goto LABEL_36;
          }
          if (*(_DWORD *)(*(_QWORD *)(a1 + 104) + 1928) == 1)
          {
            *(_DWORD *)(a1 + 380) = 1;
            v28 = *(_QWORD **)(a1 + 352);
            v29 = Search_PruneBNF_TreeIndex;
            goto LABEL_35;
          }
          v31 = *(_QWORD **)(a1 + 352);
          v32 = Search_PruneBNF;
        }
        else
        {
          if (*(_DWORD *)(*(_QWORD *)(a1 + 104) + 1928) == 1)
          {
            *(_DWORD *)(a1 + 380) = 1;
            v28 = *(_QWORD **)(a1 + 352);
            v29 = Search_TreeIndex;
LABEL_35:
            *v28 = 0;
            v28[1] = v29;
LABEL_36:
            v30 = *(_QWORD **)(a1 + 368);
            *v30 = 0;
            v30[1] = UnicornSearch_StageTwo_TreeIndex_Sliced;
            if (v26[1688] == 1 && v26[1700] == 9)
              v30[1] = UnicornSearch_StageTwo_TreeIndex_Cascaded;
            return v2;
          }
          v31 = *(_QWORD **)(a1 + 352);
          v32 = Search_NoPrune;
        }
        *v31 = 0;
        v31[1] = v32;
LABEL_42:
        v33 = *(_QWORD **)(a1 + 368);
        *v33 = 0;
        v33[1] = UnicornSearch_StageTwo_Default;
      }
    }
  }
  return v2;
}

uint64_t UnicornSearch_Set(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  uint64_t v8;

  *(_DWORD *)(a1 + 92) = a2;
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 384) + 312 * a2;
  UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 11, (uint64_t)"[Phoneme %d]\n");
  UNICORN__mfs_Ling_GetPhonCtxt(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8), *(_DWORD *)(a1 + 92), (_BYTE *)(a1 + 344));
  UNICORN__mfs_Ling_LogPhonCtxt(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 80), *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8), *(_DWORD *)(a1 + 92));
  if (*(_DWORD *)(a1 + 380) && *(_DWORD *)(*(_QWORD *)(a1 + 112) + 5992) != 1)
  {
    v3 = *(_QWORD *)(a1 + 136);
    v7 = *(_OWORD *)(v3 + 32);
    v8 = *(_QWORD *)(v3 + 48);
    *(_OWORD *)(v3 + 32) = *(_OWORD *)(v3 + 56);
    *(_QWORD *)(v3 + 48) = *(_QWORD *)(v3 + 72);
    v4 = *(_QWORD *)(a1 + 136);
    *(_QWORD *)(v4 + 72) = *(_QWORD *)(v4 + 96);
    *(_OWORD *)(v4 + 56) = *(_OWORD *)(v4 + 80);
    v5 = *(_QWORD *)(a1 + 136);
    *(_OWORD *)(v5 + 80) = v7;
    *(_QWORD *)(v5 + 96) = v8;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 104) + 1928) == 1)
    Unicorn_CostListBlock_Set(*(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 128));
  return 0;
}

uint64_t UnicornSearch_Process(uint64_t a1)
{
  unsigned int v2;
  __n128 v3;
  uint64_t result;

  if (*(int *)(a1 + 88) < 1)
    return 0;
  v2 = 0;
  while (1)
  {
    UnicornSearch_Set(a1, v2);
    result = UnicornSearch_ProcessOne(a1, v3);
    if ((result & 0x80000000) != 0)
      break;
    if ((signed int)++v2 >= *(_DWORD *)(a1 + 88))
      return 0;
  }
  return result;
}

uint64_t UnicornSearch_ProcessOne(uint64_t a1, __n128 a2)
{
  int v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  _BYTE *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int **v23;
  _DWORD *v24;
  float *v25;
  int v26;
  int v27;
  int *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;

  v3 = *(_DWORD *)(a1 + 96);
  if ((v3 - 1) <= 0xFFFFFFFC)
  {
    v4 = 0;
    v5 = v3 * *(_DWORD *)(a1 + 92);
    v6 = 2;
    while (1)
    {
      if (*(_BYTE *)(a1 + 345) == 1)
      {
        if (!*(_BYTE *)(a1 + 156) || v6 == 3 && v3 == 3)
          goto LABEL_18;
        if (v6 == 2)
        {
          v7 = (_BYTE *)(a1 + 344);
          if (!*(_DWORD *)(a1 + 92))
            goto LABEL_18;
LABEL_12:
          if (*v7 == 1)
            goto LABEL_18;
          goto LABEL_13;
        }
        if (v6 == v3 + 1)
        {
          v7 = (_BYTE *)(a1 + 346);
          if (*(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 88) - 1)
            goto LABEL_18;
          goto LABEL_12;
        }
      }
LABEL_13:
      v8 = v5 + v6 - 2;
      v9 = *(_QWORD *)(a1 + 120);
      v10 = *(uint64_t **)(v9 + 1768);
      if (!v10)
      {
        v12 = (v5 + v6 - 2);
LABEL_17:
        v4 = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 352) + 8))(a1, 1, v6, a1 + 344, *(_QWORD *)(a1 + 128), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 16) + 32 * v12 + 16), *(unsigned int *)(*(_QWORD *)(a1 + 112) + 5548));
        if ((v4 & 0x80000000) != 0)
          return v4;
        goto LABEL_18;
      }
      v11 = *v10;
      v12 = (v5 + v6 - 2);
      if (*(_DWORD *)(v11 + 48 * v8))
        goto LABEL_17;
      UNICORN__mfs_CostList_Add(0.0, *(_QWORD *)(a1 + 104), (_QWORD *)(v9 + 1088), v8, *(_DWORD *)(*(_QWORD *)(v11 + 48 * v12 + 8)+ 4 * (*(_DWORD *)(v11 + 48 * v12 + 24) - 1)));
LABEL_18:
      ++v6;
      v3 = *(_DWORD *)(a1 + 96);
      v13 = (v3 + 2);
      if (v6 >= v13)
      {
        if (v13 >= 3)
        {
          v14 = *(_QWORD *)(a1 + 120);
          v15 = *(_QWORD **)(v14 + 1768);
          v16 = 2;
          a2.n128_u32[0] = 1167867904;
          do
          {
            if (v15)
            {
              v17 = (v5 - 2 + v16);
              if (*(_DWORD *)(*v15 + 48 * v17) == 1)
              {
                v18 = *(_QWORD *)(v14 + 1104) + 32 * v17;
                v19 = *(unsigned int *)(v18 + 16);
                if ((_DWORD)v19)
                {
                  v20 = 0;
                  v21 = *v15 + 48 * v17;
                  v22 = *(unsigned int *)(v21 + 24);
                  v23 = (int **)(v21 + 8);
                  do
                  {
                    if ((_DWORD)v22)
                    {
                      v24 = (_DWORD *)(*(_QWORD *)v18 + 12 * v20);
                      v27 = *v24;
                      v25 = (float *)(v24 + 1);
                      v26 = v27;
                      v28 = *v23;
                      v29 = v22;
                      do
                      {
                        v30 = *v28++;
                        if (v26 == v30)
                          *v25 = *v25 + 5000.0;
                        --v29;
                      }
                      while (v29);
                    }
                    ++v20;
                  }
                  while (v20 != v19);
                }
              }
            }
            ++v16;
          }
          while (v16 != v13);
        }
        goto LABEL_34;
      }
    }
  }
  v4 = 0;
LABEL_34:
  if ((v3 - 1) <= 0xFFFFFFFC)
  {
    v31 = 2;
    do
    {
      v4 = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)(a1 + 368) + 8))(a1, v31, a2);
      if ((v4 & 0x80000000) != 0)
        break;
      v31 = (v31 + 1);
    }
    while (v31 < *(_DWORD *)(a1 + 96) + 2);
  }
  return v4;
}

uint64_t UnicornSearch_Reset()
{
  return 0;
}

uint64_t UnicornSearch_Close(uint64_t a1)
{
  uint64_t v2;

  UNICORN__mfs_TCost_Clear(a1 + 176);
  v2 = *(_QWORD *)(a1 + 144);
  if (v2)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 56) + 8), v2);
    *(_QWORD *)(a1 + 144) = 0;
  }
  return 0;
}

uint64_t UnicornSearch_SetSIMDCallback(uint64_t *a1, int a2)
{
  unint64_t v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  void *v9;
  void *v10;

  if (!*(_DWORD *)(a1[14] + 6728))
  {
    if (a2)
    {
      v9 = mfs_bnfData_Clusterize_Block_Distance_fxd16_SIMD;
      v10 = mfs_bnfData_Distance_Unit_ID_fxd16_SIMD;
    }
    else
    {
      v9 = mfs_bnfData_Clusterize_Block_Distance_fxd16;
      v10 = mfs_bnfData_Distance_Unit_ID_fxd16;
    }
    goto LABEL_11;
  }
  if (!a2)
  {
LABEL_13:
    a1[48] = (uint64_t)mfs_bnfData_Clusterize_Block_Distance_RandomProjection;
    a1[49] = (uint64_t)mfs_bnfData_Distance_Unit_ID_RandomProjection;
    goto LABEL_14;
  }
  HIDWORD(v4) = *(unsigned __int8 *)(a1[13] + 1520);
  LODWORD(v4) = (HIDWORD(v4) << 24) - 0x8000000;
  v5 = (v4 >> 27);
  v6 = v5 > 7;
  v7 = (1 << v5) & 0xAB;
  if (v6 || v7 == 0)
  {
    UNICORN__log_select_Diag(a1[7], 1, (uint64_t)"WARNING : SIMD Random Projection Search only available for BNF size of16/32/48/64 Bytes, current size %d;"
               " fallback to ANSIC implementation. \n");
    goto LABEL_13;
  }
  v9 = mfs_bnfData_Clusterize_Block_Distance_RandomProjection_SIMD;
  v10 = mfs_bnfData_Distance_Unit_ID_RandomProjection_SIMD;
LABEL_11:
  a1[48] = (uint64_t)v9;
  a1[49] = (uint64_t)v10;
LABEL_14:
  mfs_TCost_EnableSIMD((uint64_t)(a1 + 22), a2);
  return 0;
}

_QWORD *UnicornSearch_Destroy(uint64_t *a1)
{
  UNICORN__log_select_Diag(a1[7], 10, (uint64_t)"+Destroy\n");
  heap_Free(*(_QWORD **)(a1[7] + 8), a1[44]);
  a1[44] = 0;
  heap_Free(*(_QWORD **)(a1[7] + 8), a1[46]);
  a1[46] = 0;
  UNICORN__log_select_Diag(a1[7], 10, (uint64_t)"--Destroy\n");
  return heap_Free(*(_QWORD **)(a1[7] + 8), (uint64_t)a1);
}

uint64_t UnicornSearch_StageTwo_Default(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float v7;
  uint64_t updated;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  float *v14;
  float *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  float v21;
  _BOOL4 v23;
  int v24;
  unsigned int v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  float v30;
  float v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  float v39;
  float v40;
  float v41;
  unsigned int v42;
  float *IndexPtr_LH_F32;
  _BOOL4 v45;
  uint64_t v46;
  float *v47;
  float *v48;
  int v49;
  _OWORD v50[2];
  uint64_t v51;
  float v52;
  float v53;
  _QWORD v54[3];

  v54[1] = *MEMORY[0x24BDAC8D0];
  v3 = a2 + *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 92);
  v4 = v3 - 2;
  v6 = *(_QWORD *)(a1 + 112);
  v5 = *(_QWORD *)(a1 + 120);
  v7 = *(float *)(*(_QWORD *)(v5 + 1352) + 4 * v4);
  v54[0] = 0;
  if (*(_DWORD *)(v6 + 5992) != 1)
  {
    UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 1, (uint64_t)"CONFIG ERROR : Search is not implemented for Phoneme Substate Modeling\n");
    return 2229280768;
  }
  v46 = a1 + 176;
  updated = UNICORN__mfs_TCost_SetTarget(a1 + 176, *(_QWORD *)(a1 + 104), v5, *(_QWORD **)(a1 + 128), a2);
  if ((updated & 0x80000000) == 0)
  {
    if (*(float *)(*(_QWORD *)(a1 + 112) + 6704) == 0.0
      || (updated = mfs_UpdateTargetQuantizedTrajectory_LF0(*(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 120), v46),
          (updated & 0x80000000) == 0))
    {
      v10 = *(_QWORD *)(a1 + 336);
      if (v10)
      {
        LODWORD(v54[0]) = *(_DWORD *)(v10 + 4 * (2 * v4));
        HIDWORD(v54[0]) = *(_DWORD *)(v10 + 4 * ((2 * (_DWORD)v4) | 1u));
      }
      if (!*(_BYTE *)(a1 + 156) && *(_BYTE *)(a1 + 345) == 1)
      {
        v11 = *(_QWORD *)(a1 + 136);
        LODWORD(v12) = *(_DWORD *)(*(_QWORD *)(v11 + 16) + 32 * v4 + 16);
LABEL_69:
        v42 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 5564);
        if (v12 > v42)
        {
          updated = mfs_CostList_Select(v11, v4, 1, v42);
          UNICORN__mfs_CostList_Prune(*(_QWORD **)(a1 + 136), v4, *(_DWORD *)(*(_QWORD *)(a1 + 112) + 5564));
        }
        goto LABEL_71;
      }
      IndexPtr_LH_F32 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(_QWORD *)(a1 + 120) + 1848, v3 - 2);
      v13 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 6752);
      if (v13 < 1)
      {
        v48 = 0;
      }
      else
      {
        if (v3 - 1 >= *(_DWORD *)(a1 + 100))
        {
          v48 = 0;
        }
        else
        {
          v48 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(_QWORD *)(a1 + 120) + 1848, v3 - 1);
          v13 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 6752);
        }
        if (v13 >= 2 && v3 < *(_DWORD *)(a1 + 100))
        {
          v47 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(_QWORD *)(a1 + 120) + 1848, v3);
          if (v3 == 2)
          {
LABEL_19:
            v14 = 0;
            goto LABEL_27;
          }
LABEL_21:
          if (*(int *)(*(_QWORD *)(a1 + 112) + 6752) < 1)
            v14 = 0;
          else
            v14 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(_QWORD *)(a1 + 120) + 1848, v3 - 3);
          if (v4 >= 2 && *(int *)(*(_QWORD *)(a1 + 112) + 6752) >= 2)
          {
            v15 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(_QWORD *)(a1 + 120) + 1848, v3 - 4);
LABEL_28:
            v16 = *(_QWORD *)(a1 + 136);
            v18 = *(_QWORD *)(v16 + 16);
            v17 = (_QWORD *)(v16 + 16);
            if (!*(_DWORD *)(v18 + 32 * v4 + 16))
            {
LABEL_71:
              UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 11, (uint64_t)"costlist(%d)\n");
              return updated;
            }
            v19 = 0;
            v20 = 0;
            v21 = 1.0 - v7;
            v23 = (float)(1.0 - v7) > 0.0 && IndexPtr_LH_F32 != 0;
            v45 = v23;
            while (1)
            {
              v51 = 0;
              memset(v50, 0, sizeof(v50));
              v24 = *(_BYTE *)(a1 + 164) == 1 ? *(_DWORD *)(a1 + 280) : 0;
              v25 = *(_DWORD *)(*(_QWORD *)(*v17 + 32 * v4) + v19);
              v49 = v24;
              UNICORN__mfs_Stub_ParamMap_GetAcousticVector(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 120), v25, (uint64_t)v50, &v49, 0.0);
              updated = v27;
              if ((v27 & 0x80000000) != 0)
                return updated;
              v28 = *(_QWORD *)(a1 + 112);
              v29 = *(unsigned __int8 *)(a1 + 164);
              if (*(_QWORD *)(a1 + 336))
                mfs_TCost_BNFCandidateCostStreamElf0(v46, v28, (uint64_t)v50, v49, &v52, v29, (float *)v54, *(_DWORD *)(a1 + 168), v26);
              else
                mfs_TCost_BNFCandidateCostStream(v46, v28, (uint64_t)v50, v49, &v52, v29, *(_DWORD *)(a1 + 168));
              if (*(_BYTE *)(a1 + 164))
              {
                v30 = *(float *)(a1 + 180) * *(float *)(a1 + 292);
                v52 = v30
                    * UNICORN__CandidatePhonemeDurationDistanceBasic(*(_QWORD *)(a1 + 104), v25, a2, *(_DWORD *)(*(_QWORD *)(a1 + 128) + 24));
              }
              UNICORN__mfs_ParamMap_UnMapSection(*(_QWORD *)(a1 + 120));
              v31 = 0.0;
              if (v45)
              {
                v32 = *(_QWORD *)(a1 + 112);
                if (*(_DWORD *)(v32 + 6140))
                {
                  v33 = *(float *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 16) + 32 * v4) + v19 + 4);
                }
                else
                {
                  v33 = mfs_bnfData_Distance(*(_QWORD *)(a1 + 104), IndexPtr_LH_F32, v25);
                  v32 = *(_QWORD *)(a1 + 112);
                }
                v31 = v33 * tblBNFContextWeights[5 * *(int *)(v32 + 6752)];
              }
              if (v14 && v25 && v21 > 0.0)
              {
                v34 = tblBNFContextWeights[5 * *(int *)(*(_QWORD *)(a1 + 112) + 6752) + 1];
                v31 = v31 + (float)(v34 * mfs_bnfData_Distance(*(_QWORD *)(a1 + 104), v14, v25 - 1));
              }
              if (v15 && v25 >= 2 && v21 > 0.0)
              {
                v35 = tblBNFContextWeights[5 * *(int *)(*(_QWORD *)(a1 + 112) + 6752) + 3];
                v31 = v31 + (float)(v35 * mfs_bnfData_Distance(*(_QWORD *)(a1 + 104), v15, v25 - 2));
              }
              if (v48)
              {
                v36 = *(_QWORD *)(a1 + 112);
                if (v25 < *(_DWORD *)(v36 + 11548) - 1 && v21 > 0.0)
                {
                  v37 = tblBNFContextWeights[5 * *(int *)(v36 + 6752) + 2];
                  v31 = v31 + (float)(v37 * mfs_bnfData_Distance(*(_QWORD *)(a1 + 104), v48, v25 + 1));
                }
              }
              if (v47)
              {
                v38 = *(_QWORD *)(a1 + 112);
                if (v25 < *(_DWORD *)(v38 + 11548) - 2 && v21 > 0.0)
                {
                  v39 = tblBNFContextWeights[5 * *(int *)(v38 + 6752) + 4];
                  v31 = v31 + (float)(v39 * mfs_bnfData_Distance(*(_QWORD *)(a1 + 104), v47, v25 + 2));
                }
              }
              v40 = v53;
              if (*(_BYTE *)(a1 + 345) == 1)
              {
                v40 = v53 * 0.01;
                v53 = v53 * 0.01;
              }
              v41 = (float)(v7 * v40) + (float)(v21 * v31);
              UNICORN__log_select_Diag(*(_QWORD *)(a1 + 56), 11, (uint64_t)"%f = BNF(%f) LF0(%f) DUR(%f)\n");
              UNICORN__mfs_CostList_UpdateCost(*(_QWORD *)(a1 + 136), v4, v20++, v41);
              v11 = *(_QWORD *)(a1 + 136);
              v17 = (_QWORD *)(v11 + 16);
              v12 = *(unsigned int *)(*(_QWORD *)(v11 + 16) + 32 * v4 + 16);
              v19 += 12;
              if (v20 >= v12)
                goto LABEL_69;
            }
          }
LABEL_27:
          v15 = 0;
          goto LABEL_28;
        }
      }
      v47 = 0;
      if (v3 == 2)
        goto LABEL_19;
      goto LABEL_21;
    }
  }
  return updated;
}

uint64_t select_bet5_deserializeFeatures(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v20;
  int v21;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  int v28;
  size_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  int v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int16 v38;
  size_t v39;
  uint64_t v40;
  const char **v41;
  size_t v42;
  unsigned int Index;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  void *__src;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = *a5;
  __src = 0;
  v50 = 0;
  v14 = v13 + 2748;
  do
  {
    v15 = *(unsigned __int8 *)(v14 + v10);
    if (*(_BYTE *)(v14 + v10))
    {
      if (v15 == 2)
      {
        v12 += 2;
      }
      else if (v15 == 1)
      {
        ++v12;
        ++v11;
      }
      else if ((unsigned __int16)v10 - 53 <= 1)
      {
        v12 += 4 * *(unsigned __int16 *)(v13 + 3360);
      }
    }
    ++v10;
  }
  while (v10 != 218);
  v16 = *(_QWORD **)(v13 + 3336);
  if (v16 && *v16)
  {
    v17 = 0;
    v18 = v16 + 1;
    while (v18[v17++])
      ;
    v12 += v17;
  }
  else
  {
    LODWORD(v17) = 0;
  }
  v20 = (*(uint64_t (**)(uint64_t, uint64_t, void **, unsigned int *))(a2 + 88))(a3, a4, &__src, &v50);
  if ((v20 & 0x80000000) != 0)
    return v20;
  if (!v12)
    return 21;
  v21 = v50 / v12;
  if (v50 % v12)
    return 21;
  *((_WORD *)a5 + 5) = v21;
  v49 = a1;
  v23 = heap_Calloc(*(_QWORD **)(a1 + 8), (unsigned __int16)v21 * v11, 1);
  if (!v23)
    return 2229280778;
  v24 = (char *)v23;
  v45 = v20;
  v46 = a2;
  v47 = a3;
  v48 = a4;
  v25 = 0;
  v26 = (char *)__src;
  v27 = v13 + 2748;
  do
  {
    v28 = *(unsigned __int8 *)(v27 + v25);
    if (!*(_BYTE *)(v27 + v25))
      goto LABEL_36;
    if (v28 == 2)
    {
      v30 = *((unsigned __int16 *)a5 + 5);
      v31 = (void *)heap_Calloc(*(_QWORD **)(v49 + 8), v30, 2);
      a5[v25 + 220] = (uint64_t)v31;
      if (!v31)
        return 2229280778;
      cstdlib_memcpy(v31, v26, 2 * v30);
      v26 += 2 * v30;
    }
    else
    {
      if (v28 == 1)
      {
        v29 = *((unsigned __int16 *)a5 + 5);
        a5[v25 + 2] = (uint64_t)v24;
        cstdlib_memcpy(v24, v26, v29);
        v24 += v29;
      }
      else
      {
        if ((unsigned __int16)v25 - 53 > 1)
          goto LABEL_36;
        if (v25 == 53)
          v32 = 448;
        else
          v32 = 449;
        v33 = *(unsigned __int16 *)(v13 + 3360) * *((unsigned __int16 *)a5 + 5);
        v34 = (void *)heap_Calloc(*(_QWORD **)(v49 + 8), *(unsigned __int16 *)(v13 + 3360) * (unint64_t)*((unsigned __int16 *)a5 + 5), 4);
        a5[v32] = (uint64_t)v34;
        if (!v34)
          return 2229280778;
        v29 = (4 * v33);
        cstdlib_memcpy(v34, v26, v29);
      }
      v26 += v29;
    }
LABEL_36:
    ++v25;
  }
  while (v25 != 218);
  if (!(_DWORD)v17)
    goto LABEL_51;
  v35 = heap_Calloc(*(_QWORD **)(v49 + 8), v17 * *((unsigned __int16 *)a5 + 5), 1);
  if (!v35)
    return 2229280778;
  v36 = v35;
  v37 = heap_Calloc(*(_QWORD **)(v49 + 8), v17, 8);
  a5[438] = v37;
  v20 = 2229280778;
  if (v37)
  {
    v38 = 0;
    do
    {
      v39 = *((unsigned __int16 *)a5 + 5);
      v40 = v38;
      *(_QWORD *)(a5[438] + 8 * v38) = v36;
      cstdlib_memcpy(*(void **)(a5[438] + 8 * v38), v26, v39);
      if (cstdlib_strncmp(*(const char **)(*(_QWORD *)(v13 + 3336) + 8 * v40), "INNO_", 5uLL))
      {
        v41 = *(const char ***)(*(_QWORD *)(v13 + 3344) + 8 * v40);
        v42 = cstdlib_strlen("FEATIDX");
        Index = usextract_getIndex(v41, "FEATIDX", (unint64_t)&aFeatidx[v42]);
        if (Index == -1)
        {
          if (cstdlib_strcmp(*(const char **)(*(_QWORD *)(*a5 + 3336) + 8 * v40), "POS"))
          {
            if (!cstdlib_strcmp(*(const char **)(*(_QWORD *)(*a5 + 3336) + 8 * v40), "PHR"))
              a5[64] = *(_QWORD *)(a5[438] + 8 * v40);
          }
          else
          {
            a5[63] = *(_QWORD *)(a5[438] + 8 * v40);
          }
        }
        else
        {
          a5[*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*a5 + 3352) + 8 * v40) + Index) + 2] = *(_QWORD *)(a5[438] + 8 * v40);
        }
      }
      else
      {
        v44 = cstdlib_atoi((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*a5 + 3336) + 8 * v40) + 5)) + 79;
        if (v44 <= 0x5E)
          a5[v44 + 2] = *(_QWORD *)(a5[438] + 8 * v40);
      }
      v26 += v39;
      v36 += v39;
      v38 = v40 + 1;
    }
    while (v17 > (unsigned __int16)(v40 + 1));
LABEL_51:
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v46 + 96))(v47, v48, v12 * *((unsigned __int16 *)a5 + 5));
    return v45;
  }
  return v20;
}

